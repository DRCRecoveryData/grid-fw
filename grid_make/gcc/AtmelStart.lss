
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001398c  00004000  00004000  00004000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000005b0  20000000  0001798c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  000205b0  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  000205b0  2**0
                  CONTENTS
  4 .bss          0001ca28  200005b0  00017f40  000205b0  2**4
                  ALLOC
  5 .stack        00010000  2001cfd8  00034968  000205b0  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000205b0  2**0
                  CONTENTS, READONLY
  7 .comment      000000a7  00000000  00000000  000205de  2**0
                  CONTENTS, READONLY
  8 .debug_info   000cc542  00000000  00000000  00020685  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00016452  00000000  00000000  000ecbc7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    00036964  00000000  00000000  00103019  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00003150  00000000  00000000  00139980  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00008928  00000000  00000000  0013cad0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  0004ee4a  00000000  00000000  001453f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00061238  00000000  00000000  00194242  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00129d32  00000000  00000000  001f547a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  000089e0  00000000  00000000  0031f1ac  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00004000 <exception_table>:
    4000:	d8 cf 02 20 8d 30 01 00 89 30 01 00 89 30 01 00     ... .0...0...0..
    4010:	89 30 01 00 89 30 01 00 89 30 01 00 00 00 00 00     .0...0...0......
	...
    402c:	81 b2 00 00 89 30 01 00 00 00 00 00 11 b3 00 00     .....0..........
    403c:	75 b3 00 00 89 30 01 00 89 30 01 00 89 30 01 00     u....0...0...0..
    404c:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    405c:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    406c:	69 fa 00 00 89 30 01 00 89 30 01 00 89 30 01 00     i....0...0...0..
    407c:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    408c:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    409c:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    40ac:	89 30 01 00 89 30 01 00 35 c1 00 00 61 c1 00 00     .0...0..5...a...
    40bc:	e5 e2 00 00 ed e2 00 00 f5 e2 00 00 fd e2 00 00     ................
    40cc:	05 e3 00 00 89 30 01 00 89 30 01 00 89 30 01 00     .....0...0...0..
    40dc:	89 30 01 00 89 30 01 00 89 30 01 00 00 00 00 00     .0...0...0......
	...
    40f4:	5d de 00 00 d9 12 01 00 e9 12 01 00 f1 12 01 00     ]...............
    4104:	f9 12 01 00 01 13 01 00 11 13 01 00 19 13 01 00     ................
    4114:	21 13 01 00 89 30 01 00 89 30 01 00 89 30 01 00     !....0...0...0..
    4124:	89 30 01 00 29 13 01 00 6d 13 01 00 75 13 01 00     .0..)...m...u...
    4134:	7d 13 01 00 85 13 01 00 95 13 01 00 9d 13 01 00     }...............
    4144:	a5 13 01 00 ad 13 01 00 3d 14 01 00 45 14 01 00     ........=...E...
    4154:	4d 14 01 00 55 14 01 00 65 14 01 00 6d 14 01 00     M...U...e...m...
    4164:	75 14 01 00 89 30 01 00 89 30 01 00 89 30 01 00     u....0...0...0..
    4174:	89 30 01 00 00 00 00 00 00 00 00 00 f9 d9 00 00     .0..............
    4184:	01 da 00 00 09 da 00 00 11 da 00 00 00 00 00 00     ................
    4194:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    41a4:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    41b4:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    41c4:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    41d4:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    41e4:	89 30 01 00 89 30 01 00 5d 3a 01 00 6d 3a 01 00     .0...0..]:..m:..
    41f4:	7d 3a 01 00 8d 3a 01 00 89 30 01 00 89 30 01 00     }:...:...0...0..
    4204:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    4214:	89 30 01 00 59 30 01 00 69 30 01 00 71 30 01 00     .0..Y0..i0..q0..
    4224:	81 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    4234:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    4244:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..
    4254:	89 30 01 00 89 30 01 00 89 30 01 00 89 30 01 00     .0...0...0...0..

00004264 <deregister_tm_clones>:
    4264:	4803      	ldr	r0, [pc, #12]	; (4274 <deregister_tm_clones+0x10>)
    4266:	4b04      	ldr	r3, [pc, #16]	; (4278 <deregister_tm_clones+0x14>)
    4268:	4283      	cmp	r3, r0
    426a:	d002      	beq.n	4272 <deregister_tm_clones+0xe>
    426c:	4b03      	ldr	r3, [pc, #12]	; (427c <deregister_tm_clones+0x18>)
    426e:	b103      	cbz	r3, 4272 <deregister_tm_clones+0xe>
    4270:	4718      	bx	r3
    4272:	4770      	bx	lr
    4274:	0001798c 	.word	0x0001798c
    4278:	0001798c 	.word	0x0001798c
    427c:	00000000 	.word	0x00000000

00004280 <register_tm_clones>:
    4280:	4805      	ldr	r0, [pc, #20]	; (4298 <register_tm_clones+0x18>)
    4282:	4906      	ldr	r1, [pc, #24]	; (429c <register_tm_clones+0x1c>)
    4284:	1a0b      	subs	r3, r1, r0
    4286:	0fd9      	lsrs	r1, r3, #31
    4288:	eb01 01a3 	add.w	r1, r1, r3, asr #2
    428c:	1049      	asrs	r1, r1, #1
    428e:	d002      	beq.n	4296 <register_tm_clones+0x16>
    4290:	4b03      	ldr	r3, [pc, #12]	; (42a0 <register_tm_clones+0x20>)
    4292:	b103      	cbz	r3, 4296 <register_tm_clones+0x16>
    4294:	4718      	bx	r3
    4296:	4770      	bx	lr
    4298:	0001798c 	.word	0x0001798c
    429c:	0001798c 	.word	0x0001798c
    42a0:	00000000 	.word	0x00000000

000042a4 <__do_global_dtors_aux>:
    42a4:	b510      	push	{r4, lr}
    42a6:	4c06      	ldr	r4, [pc, #24]	; (42c0 <__do_global_dtors_aux+0x1c>)
    42a8:	7823      	ldrb	r3, [r4, #0]
    42aa:	b943      	cbnz	r3, 42be <__do_global_dtors_aux+0x1a>
    42ac:	f7ff ffda 	bl	4264 <deregister_tm_clones>
    42b0:	4b04      	ldr	r3, [pc, #16]	; (42c4 <__do_global_dtors_aux+0x20>)
    42b2:	b113      	cbz	r3, 42ba <__do_global_dtors_aux+0x16>
    42b4:	4804      	ldr	r0, [pc, #16]	; (42c8 <__do_global_dtors_aux+0x24>)
    42b6:	f3af 8000 	nop.w
    42ba:	2301      	movs	r3, #1
    42bc:	7023      	strb	r3, [r4, #0]
    42be:	bd10      	pop	{r4, pc}
    42c0:	200005b0 	.word	0x200005b0
    42c4:	00000000 	.word	0x00000000
    42c8:	0001798c 	.word	0x0001798c

000042cc <frame_dummy>:
    42cc:	b508      	push	{r3, lr}
    42ce:	4b04      	ldr	r3, [pc, #16]	; (42e0 <frame_dummy+0x14>)
    42d0:	b11b      	cbz	r3, 42da <frame_dummy+0xe>
    42d2:	4904      	ldr	r1, [pc, #16]	; (42e4 <frame_dummy+0x18>)
    42d4:	4804      	ldr	r0, [pc, #16]	; (42e8 <frame_dummy+0x1c>)
    42d6:	f3af 8000 	nop.w
    42da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    42de:	e7cf      	b.n	4280 <register_tm_clones>
    42e0:	00000000 	.word	0x00000000
    42e4:	200005b4 	.word	0x200005b4
    42e8:	0001798c 	.word	0x0001798c

000042ec <audio_midi_req>:
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */

static int32_t audio_midi_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    42ec:	b410      	push	{r4}
		
	//return ERR_NOT_FOUND;	
		
	if ((0x81 == req->bmRequestType) && (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1])) {
    42ee:	780b      	ldrb	r3, [r1, #0]
    42f0:	2b81      	cmp	r3, #129	; 0x81
    42f2:	d110      	bne.n	4316 <audio_midi_req+0x2a>
    42f4:	4b1a      	ldr	r3, [pc, #104]	; (4360 <audio_midi_req+0x74>)
    42f6:	888a      	ldrh	r2, [r1, #4]
    42f8:	7919      	ldrb	r1, [r3, #4]
    42fa:	4291      	cmp	r1, r2
    42fc:	4619      	mov	r1, r3
    42fe:	d002      	beq.n	4306 <audio_midi_req+0x1a>
    4300:	795b      	ldrb	r3, [r3, #5]
    4302:	4293      	cmp	r3, r2
    4304:	d128      	bne.n	4358 <audio_midi_req+0x6c>
	return usbdc_xfer(ep, _audiodf_midi_funcd.audio_desc, _audiodf_midi_funcd.audio_desc[0], false);
    4306:	6809      	ldr	r1, [r1, #0]
    4308:	780a      	ldrb	r2, [r1, #0]
    430a:	2300      	movs	r3, #0
			switch (req->bRequest) {
				case 0x03: /* Get Protocol */
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
				case 0x0B: /* Set Protocol */
				_audiodf_midi_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
    430c:	4c15      	ldr	r4, [pc, #84]	; (4364 <audio_midi_req+0x78>)
    430e:	46a4      	mov	ip, r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    4310:	f85d 4b04 	ldr.w	r4, [sp], #4
				return usbdc_xfer(ep, NULL, 0, 0);
    4314:	4760      	bx	ip
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    4316:	f3c3 1341 	ubfx	r3, r3, #5, #2
    431a:	2b01      	cmp	r3, #1
    431c:	d11c      	bne.n	4358 <audio_midi_req+0x6c>
		if (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1]) {
    431e:	4b10      	ldr	r3, [pc, #64]	; (4360 <audio_midi_req+0x74>)
    4320:	888a      	ldrh	r2, [r1, #4]
    4322:	791c      	ldrb	r4, [r3, #4]
    4324:	4294      	cmp	r4, r2
    4326:	461c      	mov	r4, r3
    4328:	d002      	beq.n	4330 <audio_midi_req+0x44>
    432a:	795b      	ldrb	r3, [r3, #5]
    432c:	4293      	cmp	r3, r2
    432e:	d113      	bne.n	4358 <audio_midi_req+0x6c>
			switch (req->bRequest) {
    4330:	784b      	ldrb	r3, [r1, #1]
    4332:	2b03      	cmp	r3, #3
    4334:	d006      	beq.n	4344 <audio_midi_req+0x58>
    4336:	2b0b      	cmp	r3, #11
    4338:	d008      	beq.n	434c <audio_midi_req+0x60>
    433a:	f06f 000c 	mvn.w	r0, #12
}
    433e:	f85d 4b04 	ldr.w	r4, [sp], #4
    4342:	4770      	bx	lr
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
    4344:	4908      	ldr	r1, [pc, #32]	; (4368 <audio_midi_req+0x7c>)
    4346:	2300      	movs	r3, #0
    4348:	2201      	movs	r2, #1
    434a:	e7df      	b.n	430c <audio_midi_req+0x20>
				_audiodf_midi_funcd.protocol = req->wValue;
    434c:	884b      	ldrh	r3, [r1, #2]
    434e:	7223      	strb	r3, [r4, #8]
				return usbdc_xfer(ep, NULL, 0, 0);
    4350:	2300      	movs	r3, #0
    4352:	461a      	mov	r2, r3
    4354:	4619      	mov	r1, r3
    4356:	e7d9      	b.n	430c <audio_midi_req+0x20>
			return ERR_NOT_FOUND; // Never hit breakpoint here
    4358:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    435c:	e7ef      	b.n	433e <audio_midi_req+0x52>
    435e:	bf00      	nop
    4360:	200005cc 	.word	0x200005cc
    4364:	0001328d 	.word	0x0001328d
    4368:	200005d4 	.word	0x200005d4

0000436c <audio_midi_ctrl>:
	switch (ctrl) {
    436c:	2901      	cmp	r1, #1
{
    436e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4372:	460d      	mov	r5, r1
    4374:	4614      	mov	r4, r2
	switch (ctrl) {
    4376:	d070      	beq.n	445a <audio_midi_ctrl+0xee>
    4378:	2902      	cmp	r1, #2
    437a:	f000 8092 	beq.w	44a2 <audio_midi_ctrl+0x136>
    437e:	2900      	cmp	r1, #0
    4380:	f040 8092 	bne.w	44a8 <audio_midi_ctrl+0x13c>
		return audio_midi_enable(drv, (struct usbd_descriptors *)param);
    4384:	6886      	ldr	r6, [r0, #8]
	ifc = desc->sod;
    4386:	f8df 8148 	ldr.w	r8, [pc, #328]	; 44d0 <audio_midi_ctrl+0x164>
    438a:	6810      	ldr	r0, [r2, #0]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    438c:	f8df 9144 	ldr.w	r9, [pc, #324]	; 44d4 <audio_midi_ctrl+0x168>
    4390:	1d37      	adds	r7, r6, #4
		if (NULL == ifc) {
    4392:	b920      	cbnz	r0, 439e <audio_midi_ctrl+0x32>
			return ERR_NOT_FOUND;
    4394:	f06f 0009 	mvn.w	r0, #9
}
    4398:	b003      	add	sp, #12
    439a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    439e:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    43a0:	7882      	ldrb	r2, [r0, #2]
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    43a2:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    43a6:	2b01      	cmp	r3, #1
    43a8:	d1f4      	bne.n	4394 <audio_midi_ctrl+0x28>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    43aa:	783b      	ldrb	r3, [r7, #0]
    43ac:	429a      	cmp	r2, r3
    43ae:	d07e      	beq.n	44ae <audio_midi_ctrl+0x142>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    43b0:	2bff      	cmp	r3, #255	; 0xff
    43b2:	d17f      	bne.n	44b4 <audio_midi_ctrl+0x148>
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    43b4:	2d01      	cmp	r5, #1
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    43b6:	f807 2b01 	strb.w	r2, [r7], #1
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    43ba:	d009      	beq.n	43d0 <audio_midi_ctrl+0x64>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);		
    43bc:	6823      	ldr	r3, [r4, #0]
    43be:	6861      	ldr	r1, [r4, #4]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    43c0:	7818      	ldrb	r0, [r3, #0]
    43c2:	2204      	movs	r2, #4
    43c4:	4418      	add	r0, r3
    43c6:	47c0      	blx	r8
	for (i=0; i<2; i++){
    43c8:	2d01      	cmp	r5, #1
    43ca:	d042      	beq.n	4452 <audio_midi_ctrl+0xe6>
    43cc:	2501      	movs	r5, #1
    43ce:	e7e0      	b.n	4392 <audio_midi_ctrl+0x26>
			ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    43d0:	6861      	ldr	r1, [r4, #4]
    43d2:	f8df a104 	ldr.w	sl, [pc, #260]	; 44d8 <audio_midi_ctrl+0x16c>
    43d6:	2205      	movs	r2, #5
    43d8:	47c0      	blx	r8
    43da:	4683      	mov	fp, r0
			while (NULL != ep) {
    43dc:	f1bb 0f00 	cmp.w	fp, #0
    43e0:	d0ec      	beq.n	43bc <audio_midi_ctrl+0x50>
				ep_desc.bEndpointAddress = ep[2];
    43e2:	f89b 2002 	ldrb.w	r2, [fp, #2]
    43e6:	f88d 2002 	strb.w	r2, [sp, #2]
				ep_desc.bmAttributes     = ep[3];
    43ea:	f89b 2003 	ldrb.w	r2, [fp, #3]
    43ee:	f88d 2003 	strb.w	r2, [sp, #3]
	return (ptr[0] + (ptr[1] << 8));
    43f2:	f89b 1005 	ldrb.w	r1, [fp, #5]
    43f6:	f89b 2004 	ldrb.w	r2, [fp, #4]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43fa:	4b31      	ldr	r3, [pc, #196]	; (44c0 <audio_midi_ctrl+0x154>)
    43fc:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    4400:	b292      	uxth	r2, r2
				ep_desc.wMaxPacketSize   = usb_get_u16(ep + 4);
    4402:	f8ad 2004 	strh.w	r2, [sp, #4]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    4406:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    440a:	b2d2      	uxtb	r2, r2
    440c:	f889 2004 	strb.w	r2, [r9, #4]
				usb_debug2[0] = i;
    4410:	2201      	movs	r2, #1
    4412:	f889 2000 	strb.w	r2, [r9]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    4416:	f89d 0002 	ldrb.w	r0, [sp, #2]
    441a:	f89d 1003 	ldrb.w	r1, [sp, #3]
    441e:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    4422:	b292      	uxth	r2, r2
    4424:	4798      	blx	r3
    4426:	2800      	cmp	r0, #0
    4428:	d147      	bne.n	44ba <audio_midi_ctrl+0x14e>
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    442a:	f89d 2002 	ldrb.w	r2, [sp, #2]
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    442e:	f89d 0002 	ldrb.w	r0, [sp, #2]
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    4432:	0613      	lsls	r3, r2, #24
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    4434:	b2c0      	uxtb	r0, r0
    4436:	bf4c      	ite	mi
    4438:	71b0      	strbmi	r0, [r6, #6]
					func_data->func_ep_out = ep_desc.bEndpointAddress;
    443a:	71f0      	strbpl	r0, [r6, #7]
					usb_d_ep_enable(func_data->func_ep_out);
    443c:	47d0      	blx	sl
				desc->sod = ep;
    443e:	f8c4 b000 	str.w	fp, [r4]
	return (desc + usb_desc_len(desc));
    4442:	f89b 0000 	ldrb.w	r0, [fp]
				ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    4446:	6861      	ldr	r1, [r4, #4]
    4448:	4b1e      	ldr	r3, [pc, #120]	; (44c4 <audio_midi_ctrl+0x158>)
    444a:	4458      	add	r0, fp
    444c:	4798      	blx	r3
    444e:	4683      	mov	fp, r0
    4450:	e7c4      	b.n	43dc <audio_midi_ctrl+0x70>
	_audiodf_midi_funcd.enabled = true;
    4452:	4b1d      	ldr	r3, [pc, #116]	; (44c8 <audio_midi_ctrl+0x15c>)
	return ERR_NONE;
    4454:	2000      	movs	r0, #0
	_audiodf_midi_funcd.enabled = true;
    4456:	745d      	strb	r5, [r3, #17]
	return ERR_NONE;
    4458:	e79e      	b.n	4398 <audio_midi_ctrl+0x2c>
		return audio_midi_disable(drv, (struct usbd_descriptors *)param);
    445a:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    445c:	b12a      	cbz	r2, 446a <audio_midi_ctrl+0xfe>
		ifc_desc.bInterfaceClass = desc->sod[5];
    445e:	6813      	ldr	r3, [r2, #0]
		if ((AUDIO_AC_SUBCLASS != ifc_desc.bInterfaceClass) && (AUDIO_MS_SUBCLASS != ifc_desc.bInterfaceClass)) {
    4460:	795b      	ldrb	r3, [r3, #5]
    4462:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    4466:	2b01      	cmp	r3, #1
    4468:	d194      	bne.n	4394 <audio_midi_ctrl+0x28>
	if (func_data->func_iface[0] != 0xFF) {
    446a:	792b      	ldrb	r3, [r5, #4]
	if (func_data->func_ep_in != 0xFF) {
    446c:	79a8      	ldrb	r0, [r5, #6]
	if (func_data->func_iface[0] != 0xFF) {
    446e:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[0] = 0xFF;
    4470:	bf1c      	itt	ne
    4472:	23ff      	movne	r3, #255	; 0xff
    4474:	712b      	strbne	r3, [r5, #4]
	if (func_data->func_iface[1] != 0xFF) {
    4476:	796b      	ldrb	r3, [r5, #5]
    4478:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[1] = 0xFF;
    447a:	bf1c      	itt	ne
    447c:	23ff      	movne	r3, #255	; 0xff
    447e:	716b      	strbne	r3, [r5, #5]
	if (func_data->func_ep_in != 0xFF) {
    4480:	28ff      	cmp	r0, #255	; 0xff
    4482:	d003      	beq.n	448c <audio_midi_ctrl+0x120>
		usb_d_ep_deinit(func_data->func_ep_in);
    4484:	4b11      	ldr	r3, [pc, #68]	; (44cc <audio_midi_ctrl+0x160>)
    4486:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    4488:	23ff      	movs	r3, #255	; 0xff
    448a:	71ab      	strb	r3, [r5, #6]
	if (func_data->func_ep_out != 0xFF) {
    448c:	79e8      	ldrb	r0, [r5, #7]
    448e:	28ff      	cmp	r0, #255	; 0xff
    4490:	d003      	beq.n	449a <audio_midi_ctrl+0x12e>
		usb_d_ep_deinit(func_data->func_ep_out);
    4492:	4b0e      	ldr	r3, [pc, #56]	; (44cc <audio_midi_ctrl+0x160>)
    4494:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    4496:	23ff      	movs	r3, #255	; 0xff
    4498:	71eb      	strb	r3, [r5, #7]
	_audiodf_midi_funcd.enabled = false;
    449a:	4b0b      	ldr	r3, [pc, #44]	; (44c8 <audio_midi_ctrl+0x15c>)
    449c:	2000      	movs	r0, #0
    449e:	7458      	strb	r0, [r3, #17]
	return ERR_NONE;
    44a0:	e77a      	b.n	4398 <audio_midi_ctrl+0x2c>
		return ERR_UNSUPPORTED_OP;
    44a2:	f06f 001a 	mvn.w	r0, #26
    44a6:	e777      	b.n	4398 <audio_midi_ctrl+0x2c>
	switch (ctrl) {
    44a8:	f06f 000c 	mvn.w	r0, #12
    44ac:	e774      	b.n	4398 <audio_midi_ctrl+0x2c>
				return ERR_ALREADY_INITIALIZED;
    44ae:	f06f 0011 	mvn.w	r0, #17
    44b2:	e771      	b.n	4398 <audio_midi_ctrl+0x2c>
				return ERR_NO_RESOURCE;
    44b4:	f06f 001b 	mvn.w	r0, #27
    44b8:	e76e      	b.n	4398 <audio_midi_ctrl+0x2c>
					return ERR_NOT_INITIALIZED;
    44ba:	f06f 0013 	mvn.w	r0, #19
    44be:	e76b      	b.n	4398 <audio_midi_ctrl+0x2c>
    44c0:	0000f571 	.word	0x0000f571
    44c4:	0000b857 	.word	0x0000b857
    44c8:	200005cc 	.word	0x200005cc
    44cc:	0000f5d5 	.word	0x0000f5d5
    44d0:	0000b83d 	.word	0x0000b83d
    44d4:	20009140 	.word	0x20009140
    44d8:	0000f601 	.word	0x0000f601

000044dc <audiodf_midi_init>:

/**
 * \brief Initialize the USB Audio Midi Function Driver
 */
int32_t audiodf_midi_init(void)
{
    44dc:	b508      	push	{r3, lr}
	
	
	if (usbdc_get_state() > USBD_S_POWER) {
    44de:	4b0a      	ldr	r3, [pc, #40]	; (4508 <audiodf_midi_init+0x2c>)
    44e0:	4798      	blx	r3
    44e2:	2801      	cmp	r0, #1
    44e4:	d80c      	bhi.n	4500 <audiodf_midi_init+0x24>
		return ERR_DENIED;
	}
	
	_audiodf_midi.ctrl      = audio_midi_ctrl;
    44e6:	4809      	ldr	r0, [pc, #36]	; (450c <audiodf_midi_init+0x30>)
    44e8:	4b09      	ldr	r3, [pc, #36]	; (4510 <audiodf_midi_init+0x34>)
	_audiodf_midi.func_data = &_audiodf_midi_funcd;
    44ea:	e9c0 3006 	strd	r3, r0, [r0, #24]
	
	usbdc_register_function(&_audiodf_midi);
    44ee:	4b09      	ldr	r3, [pc, #36]	; (4514 <audiodf_midi_init+0x38>)
    44f0:	3014      	adds	r0, #20
    44f2:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &audio_midi_req_h);
    44f4:	2001      	movs	r0, #1
    44f6:	4908      	ldr	r1, [pc, #32]	; (4518 <audiodf_midi_init+0x3c>)
    44f8:	4b08      	ldr	r3, [pc, #32]	; (451c <audiodf_midi_init+0x40>)
    44fa:	4798      	blx	r3
	return ERR_NONE;
    44fc:	2000      	movs	r0, #0
}
    44fe:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    4500:	f06f 0010 	mvn.w	r0, #16
    4504:	e7fb      	b.n	44fe <audiodf_midi_init+0x22>
    4506:	bf00      	nop
    4508:	000136c5 	.word	0x000136c5
    450c:	200005cc 	.word	0x200005cc
    4510:	0000436d 	.word	0x0000436d
    4514:	0001366d 	.word	0x0001366d
    4518:	20000000 	.word	0x20000000
    451c:	000135e5 	.word	0x000135e5

00004520 <audiodf_midi_write>:
}



int32_t audiodf_midi_write(uint8_t byte0, uint8_t byte1, uint8_t byte2, uint8_t byte3)
{
    4520:	b410      	push	{r4}
		return ERR_DENIED;
	}
	
	// if previous xfer is completed
	
	_audiodf_midi_funcd.midi_report[0] = byte0;
    4522:	4c07      	ldr	r4, [pc, #28]	; (4540 <audiodf_midi_write+0x20>)
    4524:	7260      	strb	r0, [r4, #9]
	_audiodf_midi_funcd.midi_report[1] = byte1;
    4526:	72a1      	strb	r1, [r4, #10]
	_audiodf_midi_funcd.midi_report[2] = byte2;
    4528:	72e2      	strb	r2, [r4, #11]
	_audiodf_midi_funcd.midi_report[3] = byte3;
    452a:	7323      	strb	r3, [r4, #12]

	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    452c:	79a0      	ldrb	r0, [r4, #6]
    452e:	f104 0109 	add.w	r1, r4, #9
    4532:	4c04      	ldr	r4, [pc, #16]	; (4544 <audiodf_midi_write+0x24>)
    4534:	2300      	movs	r3, #0
    4536:	46a4      	mov	ip, r4
    4538:	2204      	movs	r2, #4
	
}
    453a:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    453e:	4760      	bx	ip
    4540:	200005cc 	.word	0x200005cc
    4544:	0001328d 	.word	0x0001328d

00004548 <audiodf_midi_write_status>:

int32_t audiodf_midi_write_status(){
    4548:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	
	struct usb_d_ep_status epstat;
	return usb_d_ep_get_status(_audiodf_midi_funcd.func_ep_in, &epstat);
    454a:	4b04      	ldr	r3, [pc, #16]	; (455c <audiodf_midi_write_status+0x14>)
    454c:	a901      	add	r1, sp, #4
    454e:	7998      	ldrb	r0, [r3, #6]
    4550:	4b03      	ldr	r3, [pc, #12]	; (4560 <audiodf_midi_write_status+0x18>)
    4552:	4798      	blx	r3
	
}
    4554:	b005      	add	sp, #20
    4556:	f85d fb04 	ldr.w	pc, [sp], #4
    455a:	bf00      	nop
    455c:	200005cc 	.word	0x200005cc
    4560:	0000f729 	.word	0x0000f729

00004564 <audiodf_midi_read>:



int32_t audiodf_midi_read(uint8_t *buf, uint32_t size)
{
    4564:	b410      	push	{r4}
    4566:	460a      	mov	r2, r1
	if (!audiodf_midi_is_enabled()) {
		return ERR_DENIED;
	}
		
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4568:	4c04      	ldr	r4, [pc, #16]	; (457c <audiodf_midi_read+0x18>)
    456a:	4601      	mov	r1, r0
    456c:	4804      	ldr	r0, [pc, #16]	; (4580 <audiodf_midi_read+0x1c>)
    456e:	46a4      	mov	ip, r4
    4570:	79c0      	ldrb	r0, [r0, #7]
}
    4572:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4576:	2300      	movs	r3, #0
    4578:	4760      	bx	ip
    457a:	bf00      	nop
    457c:	0001328d 	.word	0x0001328d
    4580:	200005cc 	.word	0x200005cc

00004584 <audiodf_midi_register_callback>:


int32_t audiodf_midi_register_callback(enum audiodf_midi_cb_type cb_type, FUNC_PTR func)
{
    4584:	b510      	push	{r4, lr}
    4586:	460a      	mov	r2, r1
	switch (cb_type) {
    4588:	b120      	cbz	r0, 4594 <audiodf_midi_register_callback+0x10>
    458a:	2801      	cmp	r0, #1
    458c:	d009      	beq.n	45a2 <audiodf_midi_register_callback+0x1e>
    458e:	f06f 000c 	mvn.w	r0, #12
		break;
		default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
}
    4592:	bd10      	pop	{r4, pc}
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    4594:	4b05      	ldr	r3, [pc, #20]	; (45ac <audiodf_midi_register_callback+0x28>)
    4596:	79d8      	ldrb	r0, [r3, #7]
    4598:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    459a:	4b05      	ldr	r3, [pc, #20]	; (45b0 <audiodf_midi_register_callback+0x2c>)
    459c:	4798      	blx	r3
	return ERR_NONE;
    459e:	2000      	movs	r0, #0
		break;
    45a0:	e7f7      	b.n	4592 <audiodf_midi_register_callback+0xe>
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    45a2:	4b02      	ldr	r3, [pc, #8]	; (45ac <audiodf_midi_register_callback+0x28>)
    45a4:	2102      	movs	r1, #2
    45a6:	7998      	ldrb	r0, [r3, #6]
    45a8:	e7f7      	b.n	459a <audiodf_midi_register_callback+0x16>
    45aa:	bf00      	nop
    45ac:	200005cc 	.word	0x200005cc
    45b0:	0000f7e9 	.word	0x0000f7e9

000045b4 <grid_ain_channel_init>:

struct AIN_Channel* ain_channel_buffer;



uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    45b4:	b570      	push	{r4, r5, r6, lr}
	instance->buffer_depth = buffer_depth;
	
	instance->result_format = result_format;
	instance->result_resolution = result_resolution;
	
	instance->result_average = 0;
    45b6:	2500      	movs	r5, #0
	instance->result_format = result_format;
    45b8:	7142      	strb	r2, [r0, #5]
	instance->result_resolution = result_resolution;
    45ba:	7183      	strb	r3, [r0, #6]
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    45bc:	4604      	mov	r4, r0
	
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45be:	4b0a      	ldr	r3, [pc, #40]	; (45e8 <grid_ain_channel_init+0x34>)
	instance->buffer_depth = buffer_depth;
    45c0:	7101      	strb	r1, [r0, #4]
	instance->result_average = 0;
    45c2:	8145      	strh	r5, [r0, #10]
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45c4:	0048      	lsls	r0, r1, #1
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    45c6:	460e      	mov	r6, r1
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45c8:	4798      	blx	r3
	
	// Init the whole buffer with zeros
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    45ca:	462b      	mov	r3, r5
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45cc:	6020      	str	r0, [r4, #0]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    45ce:	462a      	mov	r2, r5
    45d0:	b2d9      	uxtb	r1, r3
    45d2:	428e      	cmp	r6, r1
    45d4:	d803      	bhi.n	45de <grid_ain_channel_init+0x2a>
		instance->buffer[i] = 0;
	}
	
	instance->result_changed = 0;
    45d6:	81a2      	strh	r2, [r4, #12]
	instance->result_value = 0;
    45d8:	8122      	strh	r2, [r4, #8]
		
	return 0;
}
    45da:	2000      	movs	r0, #0
    45dc:	bd70      	pop	{r4, r5, r6, pc}
		instance->buffer[i] = 0;
    45de:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    45e2:	3301      	adds	r3, #1
    45e4:	e7f4      	b.n	45d0 <grid_ain_channel_init+0x1c>
    45e6:	bf00      	nop
    45e8:	00014315 	.word	0x00014315

000045ec <grid_ain_init>:
	}
}


/** Initialize ain buffer for a given number of analog channels */
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    45f0:	4605      	mov	r5, r0
    45f2:	4699      	mov	r9, r3
	
	// ain_channel_result_resolution = resolution
	
	
	// 2D buffer, example: 16 potentiometers, last 32 samples stored for each
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45f4:	0100      	lsls	r0, r0, #4
    45f6:	4b0b      	ldr	r3, [pc, #44]	; (4624 <grid_ain_init+0x38>)
    45f8:	4e0b      	ldr	r6, [pc, #44]	; (4628 <grid_ain_init+0x3c>)

	for (uint8_t i=0; i<length; i++){
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45fa:	f8df a030 	ldr.w	sl, [pc, #48]	; 462c <grid_ain_init+0x40>
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45fe:	460f      	mov	r7, r1
    4600:	4690      	mov	r8, r2
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    4602:	4798      	blx	r3
	for (uint8_t i=0; i<length; i++){
    4604:	2400      	movs	r4, #0
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    4606:	6030      	str	r0, [r6, #0]
	for (uint8_t i=0; i<length; i++){
    4608:	42a5      	cmp	r5, r4
    460a:	d102      	bne.n	4612 <grid_ain_init+0x26>
	}

	return 0;
}
    460c:	2000      	movs	r0, #0
    460e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    4612:	6830      	ldr	r0, [r6, #0]
    4614:	464b      	mov	r3, r9
    4616:	eb00 1004 	add.w	r0, r0, r4, lsl #4
    461a:	4642      	mov	r2, r8
    461c:	4639      	mov	r1, r7
    461e:	47d0      	blx	sl
	for (uint8_t i=0; i<length; i++){
    4620:	3401      	adds	r4, #1
    4622:	e7f1      	b.n	4608 <grid_ain_init+0x1c>
    4624:	00014315 	.word	0x00014315
    4628:	2000c0a8 	.word	0x2000c0a8
    462c:	000045b5 	.word	0x000045b5

00004630 <grid_ain_add_sample>:

uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    4630:	4b30      	ldr	r3, [pc, #192]	; (46f4 <grid_ain_add_sample+0xc4>)
uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
    4632:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    4636:	681a      	ldr	r2, [r3, #0]
    4638:	0104      	lsls	r4, r0, #4
    463a:	eb02 1300 	add.w	r3, r2, r0, lsl #4
	uint16_t maximum = 0;

	uint8_t minimum_index = 0;
	uint8_t maximum_index = 0;
	
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    463e:	5914      	ldr	r4, [r2, r4]
    4640:	f893 e004 	ldrb.w	lr, [r3, #4]
    4644:	2200      	movs	r2, #0
	uint8_t maximum_index = 0;
    4646:	4615      	mov	r5, r2
	uint8_t minimum_index = 0;
    4648:	4616      	mov	r6, r2
	uint16_t maximum = 0;
    464a:	4691      	mov	r9, r2
	uint16_t minimum = -1; // -1 trick to get the largest possible number
    464c:	f64f 78ff 	movw	r8, #65535	; 0xffff
	uint32_t sum = 0;
    4650:	4610      	mov	r0, r2
    4652:	fa5f fc82 	uxtb.w	ip, r2
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    4656:	45e6      	cmp	lr, ip
    4658:	d83c      	bhi.n	46d4 <grid_ain_add_sample+0xa4>
	
	}
	
	uint16_t average = sum/instance->buffer_depth;
	
	if (value>average){		
    465a:	180a      	adds	r2, r1, r0
	uint16_t average = sum/instance->buffer_depth;
    465c:	fbb0 f0fe 	udiv	r0, r0, lr
	if (value>average){		
    4660:	b280      	uxth	r0, r0
    4662:	4288      	cmp	r0, r1
		// Replace minimum in the buffer and recalculate sum
		sum = sum - instance->buffer[minimum_index] + value;
    4664:	bf34      	ite	cc
    4666:	b230      	sxthcc	r0, r6
		instance->buffer[minimum_index] = value;		
	}else{
		// Replace maximum in the buffer and recalculate sum
		sum = sum - instance->buffer[maximum_index] + value;
    4668:	b228      	sxthcs	r0, r5
    466a:	f834 5010 	ldrh.w	r5, [r4, r0, lsl #1]
		instance->buffer[maximum_index] = value;
    466e:	f824 1010 	strh.w	r1, [r4, r0, lsl #1]
		sum = sum - instance->buffer[maximum_index] + value;
    4672:	1b52      	subs	r2, r2, r5
	}
	
	// Recalculate average
	average = sum/instance->buffer_depth;
    4674:	7919      	ldrb	r1, [r3, #4]
    4676:	fbb2 f2f1 	udiv	r2, r2, r1
	
	
	uint8_t downscale_factor = (16-instance->result_resolution);
    467a:	7999      	ldrb	r1, [r3, #6]
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    467c:	795c      	ldrb	r4, [r3, #5]
	
	uint16_t downsampled = average>>downscale_factor;
	uint16_t upscaled    = downsampled<<upscale_factor;
	
	uint8_t criteria_a = instance->result_value != upscaled;
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    467e:	895e      	ldrh	r6, [r3, #10]
	
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
	uint8_t criteria_d = upscaled==0;
	
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4680:	f8b3 e008 	ldrh.w	lr, [r3, #8]
	uint8_t downscale_factor = (16-instance->result_resolution);
    4684:	f1c1 0710 	rsb	r7, r1, #16
	uint16_t downsampled = average>>downscale_factor;
    4688:	b295      	uxth	r5, r2
    468a:	b2ff      	uxtb	r7, r7
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    468c:	1a61      	subs	r1, r4, r1
	uint16_t upscaled    = downsampled<<upscale_factor;
    468e:	b2c8      	uxtb	r0, r1
	uint16_t downsampled = average>>downscale_factor;
    4690:	fa45 f107 	asr.w	r1, r5, r7
	uint16_t upscaled    = downsampled<<upscale_factor;
    4694:	b289      	uxth	r1, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4696:	1b76      	subs	r6, r6, r5
	uint16_t upscaled    = downsampled<<upscale_factor;
    4698:	4081      	lsls	r1, r0
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    469a:	2e00      	cmp	r6, #0
	uint16_t upscaled    = downsampled<<upscale_factor;
    469c:	fa1f fc81 	uxth.w	ip, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    46a0:	bfb8      	it	lt
    46a2:	4276      	neglt	r6, r6
    46a4:	2501      	movs	r5, #1
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    46a6:	45e6      	cmp	lr, ip
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    46a8:	fa05 f707 	lsl.w	r7, r5, r7
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    46ac:	d01f      	beq.n	46ee <grid_ain_add_sample+0xbe>
    46ae:	42be      	cmp	r6, r7
    46b0:	dc09      	bgt.n	46c6 <grid_ain_add_sample+0x96>
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
    46b2:	fa05 f404 	lsl.w	r4, r5, r4
    46b6:	fa05 f000 	lsl.w	r0, r5, r0
    46ba:	1a20      	subs	r0, r4, r0
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    46bc:	4560      	cmp	r0, ip
    46be:	d002      	beq.n	46c6 <grid_ain_add_sample+0x96>
    46c0:	f1bc 0f00 	cmp.w	ip, #0
    46c4:	d113      	bne.n	46ee <grid_ain_add_sample+0xbe>
		
		instance->result_average = average;
		instance->result_value = upscaled;
		instance->result_changed = 1;
    46c6:	2001      	movs	r0, #1
	average = sum/instance->buffer_depth;
    46c8:	815a      	strh	r2, [r3, #10]
		instance->result_value = upscaled;
    46ca:	f8a3 c008 	strh.w	ip, [r3, #8]
		instance->result_changed = 1;
    46ce:	8198      	strh	r0, [r3, #12]
		return 1;
	}else{		
		return 0;
	}
	
}
    46d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		uint16_t current = instance->buffer[i];
    46d4:	f834 7012 	ldrh.w	r7, [r4, r2, lsl #1]
		if (current > maximum){
    46d8:	45b9      	cmp	r9, r7
    46da:	bf3c      	itt	cc
    46dc:	4665      	movcc	r5, ip
    46de:	46b9      	movcc	r9, r7
		if (current < minimum){
    46e0:	45b8      	cmp	r8, r7
		sum += current;
    46e2:	4438      	add	r0, r7
		if (current < minimum){
    46e4:	bf84      	itt	hi
    46e6:	4666      	movhi	r6, ip
    46e8:	46b8      	movhi	r8, r7
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    46ea:	3201      	adds	r2, #1
    46ec:	e7b1      	b.n	4652 <grid_ain_add_sample+0x22>
		return 0;
    46ee:	2000      	movs	r0, #0
    46f0:	e7ee      	b.n	46d0 <grid_ain_add_sample+0xa0>
    46f2:	bf00      	nop
    46f4:	2000c0a8 	.word	0x2000c0a8

000046f8 <grid_ain_get_changed>:

uint8_t grid_ain_get_changed(uint8_t channel){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
	return instance->result_changed;
    46f8:	4b02      	ldr	r3, [pc, #8]	; (4704 <grid_ain_get_changed+0xc>)
    46fa:	681b      	ldr	r3, [r3, #0]
    46fc:	eb03 1000 	add.w	r0, r3, r0, lsl #4
}
    4700:	7b00      	ldrb	r0, [r0, #12]
    4702:	4770      	bx	lr
    4704:	2000c0a8 	.word	0x2000c0a8

00004708 <grid_ain_get_average>:
	
uint16_t grid_ain_get_average(uint8_t channel, uint8_t resolution){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    4708:	4b08      	ldr	r3, [pc, #32]	; (472c <grid_ain_get_average+0x24>)
    470a:	681a      	ldr	r2, [r3, #0]
	instance->result_changed = 0;
	
	if (resolution>6 && resolution<15){
    470c:	1fcb      	subs	r3, r1, #7
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    470e:	eb02 1200 	add.w	r2, r2, r0, lsl #4
	if (resolution>6 && resolution<15){
    4712:	2b07      	cmp	r3, #7
	instance->result_changed = 0;
    4714:	f04f 0000 	mov.w	r0, #0
    4718:	8190      	strh	r0, [r2, #12]
	if (resolution>6 && resolution<15){
    471a:	d805      	bhi.n	4728 <grid_ain_get_average+0x20>
		

		
		return (instance->result_value)/(1<<(instance->result_format-resolution));
    471c:	7950      	ldrb	r0, [r2, #5]
    471e:	8913      	ldrh	r3, [r2, #8]
    4720:	1a40      	subs	r0, r0, r1
    4722:	fa43 f000 	asr.w	r0, r3, r0
    4726:	b280      	uxth	r0, r0
		
	}
	else{
		return 0;
	}
}
    4728:	4770      	bx	lr
    472a:	bf00      	nop
    472c:	2000c0a8 	.word	0x2000c0a8

00004730 <grid_port_reset_receiver>:
#include "grid_buf.h"

// PORTS


void grid_port_reset_receiver(struct grid_port* por){
    4730:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	usart_async_disable(por->usart);
    4732:	4b24      	ldr	r3, [pc, #144]	; (47c4 <grid_port_reset_receiver+0x94>)
	
	
	por->ping_partner_token = 255;
	por->ping_local_token = 255;
	
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4734:	4e24      	ldr	r6, [pc, #144]	; (47c8 <grid_port_reset_receiver+0x98>)
void grid_port_reset_receiver(struct grid_port* por){
    4736:	4604      	mov	r4, r0
	usart_async_disable(por->usart);
    4738:	6840      	ldr	r0, [r0, #4]
    473a:	4798      	blx	r3
	por->partner_status = 0;
    473c:	f642 734b 	movw	r3, #12107	; 0x2f4b
	por->rx_double_buffer_seek_start_index = 0;
    4740:	2500      	movs	r5, #0
	por->rx_double_buffer_read_start_index = 0;
    4742:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	por->ping_local_token = 255;
    4746:	f642 7731 	movw	r7, #12081	; 0x2f31
	por->partner_status = 0;
    474a:	54e5      	strb	r5, [r4, r3]
	por->ping_partner_token = 255;
    474c:	f642 7332 	movw	r3, #12082	; 0x2f32
    4750:	22ff      	movs	r2, #255	; 0xff
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4752:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
	por->ping_partner_token = 255;
    4756:	54e2      	strb	r2, [r4, r3]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4758:	2102      	movs	r1, #2
	por->ping_local_token = 255;
    475a:	55e2      	strb	r2, [r4, r7]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    475c:	303b      	adds	r0, #59	; 0x3b
    475e:	47b0      	blx	r6
	grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4760:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4764:	5de2      	ldrb	r2, [r4, r7]
    4766:	2102      	movs	r1, #2
    4768:	3039      	adds	r0, #57	; 0x39
    476a:	47b0      	blx	r6
	grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    476c:	f642 7347 	movw	r3, #12103	; 0x2f47
    4770:	f504 563c 	add.w	r6, r4, #12032	; 0x2f00
    4774:	3633      	adds	r6, #51	; 0x33
    4776:	5ce1      	ldrb	r1, [r4, r3]
    4778:	4b14      	ldr	r3, [pc, #80]	; (47cc <grid_port_reset_receiver+0x9c>)
    477a:	9101      	str	r1, [sp, #4]
    477c:	4630      	mov	r0, r6
    477e:	4798      	blx	r3
    4780:	9901      	ldr	r1, [sp, #4]
    4782:	4b13      	ldr	r3, [pc, #76]	; (47d0 <grid_port_reset_receiver+0xa0>)
    4784:	4602      	mov	r2, r0
    4786:	4630      	mov	r0, r6
    4788:	4798      	blx	r3


	
	por->rx_double_buffer_timeout = 0;
	grid_sys_port_reset_dma(por);
    478a:	4b12      	ldr	r3, [pc, #72]	; (47d4 <grid_port_reset_receiver+0xa4>)
	por->rx_double_buffer_timeout = 0;
    478c:	61e5      	str	r5, [r4, #28]
	grid_sys_port_reset_dma(por);
    478e:	4620      	mov	r0, r4
    4790:	4798      	blx	r3
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    4792:	f504 539d 	add.w	r3, r4, #5024	; 0x13a0
    4796:	3314      	adds	r3, #20
    4798:	f504 521c 	add.w	r2, r4, #9984	; 0x2700
    479c:	323c      	adds	r2, #60	; 0x3c
    479e:	4619      	mov	r1, r3
		por->rx_double_buffer[i] = 0;
    47a0:	f803 5b01 	strb.w	r5, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    47a4:	4293      	cmp	r3, r2
    47a6:	d1fb      	bne.n	47a0 <grid_port_reset_receiver+0x70>
    47a8:	f104 032c 	add.w	r3, r4, #44	; 0x2c
	}
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
		por->tx_double_buffer[i] = 0;
    47ac:	2200      	movs	r2, #0
    47ae:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    47b2:	428b      	cmp	r3, r1
    47b4:	d1fb      	bne.n	47ae <grid_port_reset_receiver+0x7e>
	}
	
	usart_async_enable(por->usart);
    47b6:	6860      	ldr	r0, [r4, #4]
    47b8:	4b07      	ldr	r3, [pc, #28]	; (47d8 <grid_port_reset_receiver+0xa8>)
	
}
    47ba:	b003      	add	sp, #12
    47bc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	usart_async_enable(por->usart);
    47c0:	4718      	bx	r3
    47c2:	bf00      	nop
    47c4:	00010831 	.word	0x00010831
    47c8:	00009889 	.word	0x00009889
    47cc:	000099d1 	.word	0x000099d1
    47d0:	00009a05 	.word	0x00009a05
    47d4:	00009415 	.word	0x00009415
    47d8:	00010805 	.word	0x00010805

000047dc <grid_buffer_init>:



uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
	
	grid_buffer_error_count = 0;
    47dc:	4a0f      	ldr	r2, [pc, #60]	; (481c <grid_buffer_init+0x40>)
    47de:	2300      	movs	r3, #0
uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
    47e0:	b510      	push	{r4, lr}
    47e2:	3002      	adds	r0, #2
	grid_buffer_error_count = 0;
    47e4:	7013      	strb	r3, [r2, #0]
	
	buf->buffer_length = length;
	
	buf->read_length   = 0;
    47e6:	f8a0 33ee 	strh.w	r3, [r0, #1006]	; 0x3ee
	buf->buffer_length = length;
    47ea:	f820 1c02 	strh.w	r1, [r0, #-2]
	
	buf->read_start    = 0;
    47ee:	f8a0 33e8 	strh.w	r3, [r0, #1000]	; 0x3e8
	buf->read_stop     = 0;
    47f2:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
	buf->read_active   = 0;
    47f6:	f8a0 33ec 	strh.w	r3, [r0, #1004]	; 0x3ec
	
	buf->write_start    = 0;
    47fa:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
	buf->write_stop     = 0;
    47fe:	f8a0 33f2 	strh.w	r3, [r0, #1010]	; 0x3f2
	buf->write_active   = 0;
    4802:	f8a0 33f4 	strh.w	r3, [r0, #1012]	; 0x3f4
	

	for (uint16_t i=0; i<buf->buffer_length; i++){
		buf->buffer_storage[i] = 0;
    4806:	461c      	mov	r4, r3
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4808:	b29a      	uxth	r2, r3
    480a:	4291      	cmp	r1, r2
    480c:	d801      	bhi.n	4812 <grid_buffer_init+0x36>
	}
	
	return 1;
	
}
    480e:	2001      	movs	r0, #1
    4810:	bd10      	pop	{r4, pc}
		buf->buffer_storage[i] = 0;
    4812:	f800 4b01 	strb.w	r4, [r0], #1
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4816:	3301      	adds	r3, #1
    4818:	e7f6      	b.n	4808 <grid_buffer_init+0x2c>
    481a:	bf00      	nop
    481c:	2000c09c 	.word	0x2000c09c

00004820 <grid_buffer_get_space>:

uint16_t grid_buffer_get_space(struct grid_buffer* buf){
	
	uint16_t space = 0;
		
	if (buf->read_start > buf->write_start){
    4820:	f8b0 33ea 	ldrh.w	r3, [r0, #1002]	; 0x3ea
    4824:	f8b0 23f2 	ldrh.w	r2, [r0, #1010]	; 0x3f2
    4828:	4293      	cmp	r3, r2
		space = buf->read_start - buf->write_start;
	}
	else{
		space = buf->buffer_length - buf->write_start + buf->read_start;
    482a:	bf9b      	ittet	ls
    482c:	8800      	ldrhls	r0, [r0, #0]
    482e:	18c0      	addls	r0, r0, r3
		space = buf->read_start - buf->write_start;
    4830:	1a98      	subhi	r0, r3, r2
		space = buf->buffer_length - buf->write_start + buf->read_start;
    4832:	1a80      	subls	r0, r0, r2
    4834:	b280      	uxth	r0, r0
	}
	
	return space;
}
    4836:	4770      	bx	lr

00004838 <grid_buffer_write_init>:





uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    4838:	b510      	push	{r4, lr}
	
	
	
	uint16_t space = grid_buffer_get_space(buf);
    483a:	4b0c      	ldr	r3, [pc, #48]	; (486c <grid_buffer_write_init+0x34>)
uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    483c:	4604      	mov	r4, r0
	uint16_t space = grid_buffer_get_space(buf);
    483e:	4798      	blx	r3

	
	if (space>length){
    4840:	4288      	cmp	r0, r1
    4842:	d90b      	bls.n	485c <grid_buffer_write_init+0x24>
		
		buf->write_stop = (buf->write_start+length)%buf->buffer_length;
    4844:	f8b4 33f2 	ldrh.w	r3, [r4, #1010]	; 0x3f2
    4848:	8820      	ldrh	r0, [r4, #0]
    484a:	440b      	add	r3, r1
    484c:	fbb3 f2f0 	udiv	r2, r3, r0
    4850:	fb00 3312 	mls	r3, r0, r2, r3
    4854:	f8a4 33f4 	strh.w	r3, [r4, #1012]	; 0x3f4
	}
	
	
	
	
}
    4858:	4608      	mov	r0, r1
    485a:	bd10      	pop	{r4, pc}
		grid_buffer_error_count++;
    485c:	4a04      	ldr	r2, [pc, #16]	; (4870 <grid_buffer_write_init+0x38>)
    485e:	7813      	ldrb	r3, [r2, #0]
    4860:	3301      	adds	r3, #1
    4862:	b2db      	uxtb	r3, r3
    4864:	7013      	strb	r3, [r2, #0]
		return 0; // failed
    4866:	2100      	movs	r1, #0
    4868:	e7f6      	b.n	4858 <grid_buffer_write_init+0x20>
    486a:	bf00      	nop
    486c:	00004821 	.word	0x00004821
    4870:	2000c09c 	.word	0x2000c09c

00004874 <grid_buffer_write_character>:

uint8_t grid_buffer_write_character(struct grid_buffer* buf, uint8_t character){
	

		
	buf->buffer_storage[buf->write_active] = character;
    4874:	f8b0 33f6 	ldrh.w	r3, [r0, #1014]	; 0x3f6
    4878:	18c2      	adds	r2, r0, r3
		
	buf->write_active++;
    487a:	3301      	adds	r3, #1
	buf->buffer_storage[buf->write_active] = character;
    487c:	7091      	strb	r1, [r2, #2]
	buf->write_active %= buf->buffer_length;
    487e:	8801      	ldrh	r1, [r0, #0]
    4880:	b29b      	uxth	r3, r3
    4882:	fbb3 f2f1 	udiv	r2, r3, r1
    4886:	fb01 3312 	mls	r3, r1, r2, r3
    488a:	f8a0 33f6 	strh.w	r3, [r0, #1014]	; 0x3f6
		
	return 1;
		

}
    488e:	2001      	movs	r0, #1
    4890:	4770      	bx	lr
	...

00004894 <grid_buffer_write_acknowledge>:

uint8_t grid_buffer_write_acknowledge(struct grid_buffer* buf){
	
	if (buf->write_active == buf->write_stop){
    4894:	f8b0 33f4 	ldrh.w	r3, [r0, #1012]	; 0x3f4
    4898:	f8b0 23f6 	ldrh.w	r2, [r0, #1014]	; 0x3f6
    489c:	4293      	cmp	r3, r2
		buf->write_start = buf->write_active;
		return 1;
	}
	else{
		
		grid_buffer_error_count++;
    489e:	bf17      	itett	ne
    48a0:	4a05      	ldrne	r2, [pc, #20]	; (48b8 <grid_buffer_write_acknowledge+0x24>)
		buf->write_start = buf->write_active;
    48a2:	f8a0 33f2 	strheq.w	r3, [r0, #1010]	; 0x3f2
		grid_buffer_error_count++;
    48a6:	7813      	ldrbne	r3, [r2, #0]
    48a8:	3301      	addne	r3, #1
    48aa:	bf17      	itett	ne
    48ac:	b2db      	uxtbne	r3, r3
		return 1;
    48ae:	2001      	moveq	r0, #1
		grid_buffer_error_count++;
    48b0:	7013      	strbne	r3, [r2, #0]
    48b2:	2000      	movne	r0, #0
		return 0;
	}
	
	
}
    48b4:	4770      	bx	lr
    48b6:	bf00      	nop
    48b8:	2000c09c 	.word	0x2000c09c

000048bc <grid_port_receive_decode>:
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    48c0:	ed2d 8b02 	vpush	{d8}
	uint8_t buffer[length];
    48c4:	1dd3      	adds	r3, r2, #7
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48c6:	b08b      	sub	sp, #44	; 0x2c
    48c8:	4690      	mov	r8, r2
	uint8_t buffer[length];
    48ca:	08db      	lsrs	r3, r3, #3
    48cc:	466a      	mov	r2, sp
    48ce:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
	for (uint16_t i = 0; i<length; i++){
    48d2:	2200      	movs	r2, #0
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48d4:	af02      	add	r7, sp, #8
	uint8_t buffer[length];
    48d6:	469d      	mov	sp, r3
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48d8:	4604      	mov	r4, r0
    48da:	6a83      	ldr	r3, [r0, #40]	; 0x28
	uint8_t buffer[length];
    48dc:	f10d 0908 	add.w	r9, sp, #8
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    48e0:	f241 3088 	movw	r0, #5000	; 0x1388
    48e4:	f241 35b4 	movw	r5, #5044	; 0x13b4
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    48e8:	4694      	mov	ip, r2
	for (uint16_t i = 0; i<length; i++){
    48ea:	b291      	uxth	r1, r2
    48ec:	4588      	cmp	r8, r1
    48ee:	f200 80e3 	bhi.w	4ab8 <grid_port_receive_decode+0x1fc>
	for (uint16_t i = 0; i<length; i++){
    48f2:	2200      	movs	r2, #0
	message = &buffer[0];
    48f4:	464d      	mov	r5, r9
	for (uint16_t i = 0; i<length; i++){
    48f6:	f241 3088 	movw	r0, #5000	; 0x1388
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    48fa:	f241 3cb4 	movw	ip, #5044	; 0x13b4
    48fe:	4696      	mov	lr, r2
	for (uint16_t i = 0; i<length; i++){
    4900:	b291      	uxth	r1, r2
    4902:	4588      	cmp	r8, r1
    4904:	f200 80e5 	bhi.w	4ad2 <grid_port_receive_decode+0x216>
	por->rx_double_buffer_read_start_index = (por->rx_double_buffer_read_start_index + length)%GRID_DOUBLE_BUFFER_RX_SIZE;
    4908:	4443      	add	r3, r8
    490a:	fbb3 f2f0 	udiv	r2, r3, r0
    490e:	fb00 3312 	mls	r3, r0, r2, r3
	por->rx_double_buffer_seek_start_index =  por->rx_double_buffer_read_start_index;
    4912:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
	por->rx_double_buffer_status = 0;
    4916:	2300      	movs	r3, #0
    4918:	6223      	str	r3, [r4, #32]
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    491a:	f8df a250 	ldr.w	sl, [pc, #592]	; 4b6c <grid_port_receive_decode+0x2b0>
    491e:	f8df b250 	ldr.w	fp, [pc, #592]	; 4b70 <grid_port_receive_decode+0x2b4>
    4922:	4b88      	ldr	r3, [pc, #544]	; (4b44 <grid_port_receive_decode+0x288>)
	for (uint16_t i = 1; i<length; i++){
    4924:	2601      	movs	r6, #1
    4926:	45b0      	cmp	r8, r6
    4928:	f200 80dd 	bhi.w	4ae6 <grid_port_receive_decode+0x22a>
	if (message[0] == GRID_CONST_SOH && message[length-1] == GRID_CONST_LF){
    492c:	782b      	ldrb	r3, [r5, #0]
    492e:	2b01      	cmp	r3, #1
    4930:	f040 80bc 	bne.w	4aac <grid_port_receive_decode+0x1f0>
    4934:	eb05 0308 	add.w	r3, r5, r8
    4938:	f813 9c01 	ldrb.w	r9, [r3, #-1]
    493c:	f1b9 0f0a 	cmp.w	r9, #10
    4940:	f040 80b4 	bne.w	4aac <grid_port_receive_decode+0x1f0>
		checksum_received = grid_msg_checksum_read(message, length);
    4944:	4b80      	ldr	r3, [pc, #512]	; (4b48 <grid_port_receive_decode+0x28c>)
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4946:	4e81      	ldr	r6, [pc, #516]	; (4b4c <grid_port_receive_decode+0x290>)
		checksum_received = grid_msg_checksum_read(message, length);
    4948:	4641      	mov	r1, r8
    494a:	4628      	mov	r0, r5
    494c:	4798      	blx	r3
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    494e:	4641      	mov	r1, r8
		checksum_received = grid_msg_checksum_read(message, length);
    4950:	4682      	mov	sl, r0
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4952:	4628      	mov	r0, r5
    4954:	47b0      	blx	r6
		if (checksum_calculated == checksum_received && error_flag == 0){
    4956:	4582      	cmp	sl, r0
    4958:	f040 81fc 	bne.w	4d54 <grid_port_receive_decode+0x498>
			if (message[1] == GRID_CONST_BRC){ // Broadcast message
    495c:	786b      	ldrb	r3, [r5, #1]
    495e:	2b0f      	cmp	r3, #15
    4960:	f040 810c 	bne.w	4b7c <grid_port_receive_decode+0x2c0>
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4964:	f107 061f 	add.w	r6, r7, #31
				uint8_t error=0;
    4968:	f04f 0300 	mov.w	r3, #0
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    496c:	f8df b204 	ldr.w	fp, [pc, #516]	; 4b74 <grid_port_receive_decode+0x2b8>
				uint8_t error=0;
    4970:	77fb      	strb	r3, [r7, #31]
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4972:	2202      	movs	r2, #2
    4974:	4633      	mov	r3, r6
    4976:	2104      	movs	r1, #4
    4978:	4628      	mov	r0, r5
    497a:	47d8      	blx	fp
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    497c:	4649      	mov	r1, r9
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    497e:	6078      	str	r0, [r7, #4]
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4980:	4633      	mov	r3, r6
    4982:	2202      	movs	r2, #2
    4984:	4628      	mov	r0, r5
    4986:	47d8      	blx	fp
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4988:	4633      	mov	r3, r6
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    498a:	6038      	str	r0, [r7, #0]
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    498c:	2202      	movs	r2, #2
    498e:	2106      	movs	r1, #6
    4990:	4628      	mov	r0, r5
    4992:	47d8      	blx	fp
    4994:	b2c3      	uxtb	r3, r0
    4996:	617b      	str	r3, [r7, #20]
    4998:	f1a3 0a7f 	sub.w	sl, r3, #127	; 0x7f
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    499c:	2202      	movs	r2, #2
    499e:	4633      	mov	r3, r6
    49a0:	2108      	movs	r1, #8
    49a2:	4628      	mov	r0, r5
    49a4:	47d8      	blx	fp
    49a6:	b2c3      	uxtb	r3, r0
    49a8:	613b      	str	r3, [r7, #16]
    49aa:	f1a3 097f 	sub.w	r9, r3, #127	; 0x7f
				uint8_t received_rot = grid_msg_get_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
    49ae:	2202      	movs	r2, #2
    49b0:	4633      	mov	r3, r6
    49b2:	210c      	movs	r1, #12
    49b4:	4628      	mov	r0, r5
    49b6:	47d8      	blx	fp
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    49b8:	f642 7330 	movw	r3, #12080	; 0x2f30
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    49bc:	fa4f fa8a 	sxtb.w	sl, sl
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    49c0:	5ce3      	ldrb	r3, [r4, r3]
    49c2:	4418      	add	r0, r3
    49c4:	f000 0203 	and.w	r2, r0, #3
    49c8:	ee08 2a10 	vmov	s16, r2
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    49cc:	fa4f f989 	sxtb.w	r9, r9
				if (por->partner_fi == 0){ // 0 deg
    49d0:	b143      	cbz	r3, 49e4 <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 1){ // 90 deg
    49d2:	2b01      	cmp	r3, #1
    49d4:	f040 8098 	bne.w	4b08 <grid_port_receive_decode+0x24c>
					rotated_dx  -= received_dy;
    49d8:	693b      	ldr	r3, [r7, #16]
    49da:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dy  += received_dx;
    49de:	46d1      	mov	r9, sl
					rotated_dx  -= received_dy;
    49e0:	fa4f fa83 	sxtb.w	sl, r3
				uint8_t updated_dx = rotated_dx + GRID_SYS_DEFAULT_POSITION + por->dx;
    49e4:	f642 7349 	movw	r3, #12105	; 0x2f49
    49e8:	f897 b000 	ldrb.w	fp, [r7]
    49ec:	5ce3      	ldrb	r3, [r4, r3]
    49ee:	337f      	adds	r3, #127	; 0x7f
    49f0:	449a      	add	sl, r3
    49f2:	fa5f f38a 	uxtb.w	r3, sl
    49f6:	60fb      	str	r3, [r7, #12]
				uint8_t updated_dy = rotated_dy + GRID_SYS_DEFAULT_POSITION + por->dy;
    49f8:	f642 734a 	movw	r3, #12106	; 0x2f4a
    49fc:	f814 a003 	ldrb.w	sl, [r4, r3]
    4a00:	f10a 0a7f 	add.w	sl, sl, #127	; 0x7f
    4a04:	44d1      	add	r9, sl
    4a06:	fa5f f389 	uxtb.w	r3, r9
    4a0a:	60bb      	str	r3, [r7, #8]
				if (received_dx + GRID_SYS_DEFAULT_POSITION == 0 && received_dy + GRID_SYS_DEFAULT_POSITION == 0)
    4a0c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    4a10:	4313      	orrs	r3, r2
    4a12:	f897 a004 	ldrb.w	sl, [r7, #4]
    4a16:	d020      	beq.n	4a5a <grid_port_receive_decode+0x19e>
					grid_msg_set_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, updated_id, &error);
    4a18:	f8df 915c 	ldr.w	r9, [pc, #348]	; 4b78 <grid_port_receive_decode+0x2bc>
    4a1c:	9600      	str	r6, [sp, #0]
    4a1e:	4653      	mov	r3, sl
    4a20:	2202      	movs	r2, #2
    4a22:	2104      	movs	r1, #4
    4a24:	4628      	mov	r0, r5
    4a26:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, updated_dx, &error);
    4a28:	9600      	str	r6, [sp, #0]
    4a2a:	68fb      	ldr	r3, [r7, #12]
    4a2c:	2202      	movs	r2, #2
    4a2e:	2106      	movs	r1, #6
    4a30:	4628      	mov	r0, r5
    4a32:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, updated_dy, &error);
    4a34:	9600      	str	r6, [sp, #0]
    4a36:	68bb      	ldr	r3, [r7, #8]
    4a38:	2202      	movs	r2, #2
    4a3a:	2108      	movs	r1, #8
    4a3c:	4628      	mov	r0, r5
    4a3e:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, updated_age, &error);
    4a40:	465b      	mov	r3, fp
    4a42:	2202      	movs	r2, #2
    4a44:	210a      	movs	r1, #10
    4a46:	9600      	str	r6, [sp, #0]
    4a48:	4628      	mov	r0, r5
    4a4a:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, updated_rot, &error);
    4a4c:	ee18 3a10 	vmov	r3, s16
    4a50:	9600      	str	r6, [sp, #0]
    4a52:	2202      	movs	r2, #2
    4a54:	210c      	movs	r1, #12
    4a56:	4628      	mov	r0, r5
    4a58:	47c8      	blx	r9
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a5a:	68fb      	ldr	r3, [r7, #12]
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a5c:	483c      	ldr	r0, [pc, #240]	; (4b50 <grid_port_receive_decode+0x294>)
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a5e:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a62:	68bb      	ldr	r3, [r7, #8]
    4a64:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a68:	eb0b 2a0a 	add.w	sl, fp, sl, lsl #8
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a6c:	4b39      	ldr	r3, [pc, #228]	; (4b54 <grid_port_receive_decode+0x298>)
    4a6e:	4651      	mov	r1, sl
    4a70:	4798      	blx	r3
    4a72:	b9d8      	cbnz	r0, 4aac <grid_port_receive_decode+0x1f0>
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a74:	4b35      	ldr	r3, [pc, #212]	; (4b4c <grid_port_receive_decode+0x290>)
    4a76:	4641      	mov	r1, r8
    4a78:	4628      	mov	r0, r5
    4a7a:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a7c:	f504 542c 	add.w	r4, r4, #11008	; 0x2b00
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a80:	4b35      	ldr	r3, [pc, #212]	; (4b58 <grid_port_receive_decode+0x29c>)
    4a82:	4602      	mov	r2, r0
    4a84:	4641      	mov	r1, r8
    4a86:	4628      	mov	r0, r5
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a88:	3434      	adds	r4, #52	; 0x34
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a8a:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a8c:	4b33      	ldr	r3, [pc, #204]	; (4b5c <grid_port_receive_decode+0x2a0>)
    4a8e:	4641      	mov	r1, r8
    4a90:	4620      	mov	r0, r4
    4a92:	4798      	blx	r3
    4a94:	b150      	cbz	r0, 4aac <grid_port_receive_decode+0x1f0>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4a96:	4e32      	ldr	r6, [pc, #200]	; (4b60 <grid_port_receive_decode+0x2a4>)
    4a98:	44a8      	add	r8, r5
						for (uint16_t i=0; i<length; i++){
    4a9a:	45a8      	cmp	r8, r5
    4a9c:	d14d      	bne.n	4b3a <grid_port_receive_decode+0x27e>
						grid_buffer_write_acknowledge(&por->rx_buffer);
    4a9e:	4b31      	ldr	r3, [pc, #196]	; (4b64 <grid_port_receive_decode+0x2a8>)
    4aa0:	4620      	mov	r0, r4
    4aa2:	4798      	blx	r3
						grid_msg_push_recent(&grid_sys_state, fingerprint);
    4aa4:	482a      	ldr	r0, [pc, #168]	; (4b50 <grid_port_receive_decode+0x294>)
    4aa6:	4b30      	ldr	r3, [pc, #192]	; (4b68 <grid_port_receive_decode+0x2ac>)
    4aa8:	4651      	mov	r1, sl
    4aaa:	4798      	blx	r3
}
    4aac:	3724      	adds	r7, #36	; 0x24
    4aae:	46bd      	mov	sp, r7
    4ab0:	ecbd 8b02 	vpop	{d8}
    4ab4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4ab8:	18d6      	adds	r6, r2, r3
    4aba:	fbb6 f1f0 	udiv	r1, r6, r0
    4abe:	fb00 6111 	mls	r1, r0, r1, r6
    4ac2:	4421      	add	r1, r4
    4ac4:	5d4e      	ldrb	r6, [r1, r5]
    4ac6:	f809 6002 	strb.w	r6, [r9, r2]
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    4aca:	f801 c005 	strb.w	ip, [r1, r5]
	for (uint16_t i = 0; i<length; i++){
    4ace:	3201      	adds	r2, #1
    4ad0:	e70b      	b.n	48ea <grid_port_receive_decode+0x2e>
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    4ad2:	18d6      	adds	r6, r2, r3
    4ad4:	fbb6 f1f0 	udiv	r1, r6, r0
    4ad8:	fb00 6111 	mls	r1, r0, r1, r6
    4adc:	4421      	add	r1, r4
    4ade:	3201      	adds	r2, #1
    4ae0:	f801 e00c 	strb.w	lr, [r1, ip]
	for (uint16_t i = 0; i<length; i++){
    4ae4:	e70c      	b.n	4900 <grid_port_receive_decode+0x44>
		if (buffer[i] == GRID_CONST_SOH){
    4ae6:	f819 2006 	ldrb.w	r2, [r9, r6]
    4aea:	2a01      	cmp	r2, #1
    4aec:	d109      	bne.n	4b02 <grid_port_receive_decode+0x246>
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4aee:	4651      	mov	r1, sl
    4af0:	4658      	mov	r0, fp
    4af2:	4798      	blx	r3
			length -= i;
    4af4:	eba8 0806 	sub.w	r8, r8, r6
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4af8:	4b12      	ldr	r3, [pc, #72]	; (4b44 <grid_port_receive_decode+0x288>)
			length -= i;
    4afa:	fa1f f888 	uxth.w	r8, r8
			message = &buffer[i];
    4afe:	eb09 0506 	add.w	r5, r9, r6
	for (uint16_t i = 1; i<length; i++){
    4b02:	3601      	adds	r6, #1
    4b04:	b2b6      	uxth	r6, r6
    4b06:	e70e      	b.n	4926 <grid_port_receive_decode+0x6a>
				else if(por->partner_fi == 2){ // 180 deg
    4b08:	2b02      	cmp	r3, #2
    4b0a:	d10a      	bne.n	4b22 <grid_port_receive_decode+0x266>
					rotated_dx  -= received_dx;
    4b0c:	697b      	ldr	r3, [r7, #20]
    4b0e:	f1c3 0a7f 	rsb	sl, r3, #127	; 0x7f
					rotated_dy  -= received_dy;
    4b12:	693b      	ldr	r3, [r7, #16]
					rotated_dx  -= received_dx;
    4b14:	fa4f fa8a 	sxtb.w	sl, sl
					rotated_dy  -= received_dy;
    4b18:	f1c3 097f 	rsb	r9, r3, #127	; 0x7f
					rotated_dy  -= received_dx;
    4b1c:	fa4f f989 	sxtb.w	r9, r9
    4b20:	e760      	b.n	49e4 <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 3){ // 270 deg
    4b22:	2b03      	cmp	r3, #3
    4b24:	d105      	bne.n	4b32 <grid_port_receive_decode+0x276>
					rotated_dy  -= received_dx;
    4b26:	697b      	ldr	r3, [r7, #20]
    4b28:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dx  += received_dy;
    4b2c:	46ca      	mov	sl, r9
					rotated_dy  -= received_dx;
    4b2e:	4699      	mov	r9, r3
    4b30:	e7f4      	b.n	4b1c <grid_port_receive_decode+0x260>
				int8_t rotated_dy = 0;
    4b32:	f04f 0900 	mov.w	r9, #0
				int8_t rotated_dx = 0;
    4b36:	46ca      	mov	sl, r9
    4b38:	e754      	b.n	49e4 <grid_port_receive_decode+0x128>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4b3a:	f815 1b01 	ldrb.w	r1, [r5], #1
    4b3e:	4620      	mov	r0, r4
    4b40:	47b0      	blx	r6
						for (uint16_t i=0; i<length; i++){
    4b42:	e7aa      	b.n	4a9a <grid_port_receive_decode+0x1de>
    4b44:	000146ad 	.word	0x000146ad
    4b48:	000099e9 	.word	0x000099e9
    4b4c:	000099d1 	.word	0x000099d1
    4b50:	2000f008 	.word	0x2000f008
    4b54:	00009a41 	.word	0x00009a41
    4b58:	00009a05 	.word	0x00009a05
    4b5c:	00004839 	.word	0x00004839
    4b60:	00004875 	.word	0x00004875
    4b64:	00004895 	.word	0x00004895
    4b68:	00009a5b 	.word	0x00009a5b
    4b6c:	00016928 	.word	0x00016928
    4b70:	0001693b 	.word	0x0001693b
    4b74:	00009a15 	.word	0x00009a15
    4b78:	00009a2d 	.word	0x00009a2d
			else if (message[1] == GRID_CONST_DCT){ // Direct Message
    4b7c:	2b0e      	cmp	r3, #14
    4b7e:	f040 80e5 	bne.w	4d4c <grid_port_receive_decode+0x490>
				if (message[2] == GRID_CONST_ACK){
    4b82:	78ab      	ldrb	r3, [r5, #2]
    4b84:	2b07      	cmp	r3, #7
    4b86:	d191      	bne.n	4aac <grid_port_receive_decode+0x1f0>
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b88:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4d68 <grid_port_receive_decode+0x4ac>
    4b8c:	2200      	movs	r2, #0
    4b8e:	2102      	movs	r1, #2
    4b90:	f105 0008 	add.w	r0, r5, #8
    4b94:	47c8      	blx	r9
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b96:	2200      	movs	r2, #0
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b98:	fa5f fa80 	uxtb.w	sl, r0
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b9c:	2102      	movs	r1, #2
    4b9e:	1da8      	adds	r0, r5, #6
    4ba0:	47c8      	blx	r9
					if (por->partner_status == 0){
    4ba2:	f642 724b 	movw	r2, #12107	; 0x2f4b
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4ba6:	fa5f fb80 	uxtb.w	fp, r0
					if (por->partner_status == 0){
    4baa:	5ca2      	ldrb	r2, [r4, r2]
    4bac:	2a00      	cmp	r2, #0
    4bae:	d172      	bne.n	4c96 <grid_port_receive_decode+0x3da>
						if (por->ping_local_token == 255){ // I have no clue
    4bb0:	f642 7931 	movw	r9, #12081	; 0x2f31
    4bb4:	f814 2009 	ldrb.w	r2, [r4, r9]
    4bb8:	2aff      	cmp	r2, #255	; 0xff
    4bba:	d11b      	bne.n	4bf4 <grid_port_receive_decode+0x338>
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4bbc:	4a66      	ldr	r2, [pc, #408]	; (4d58 <grid_port_receive_decode+0x49c>)
    4bbe:	4867      	ldr	r0, [pc, #412]	; (4d5c <grid_port_receive_decode+0x4a0>)
    4bc0:	4790      	blx	r2
    4bc2:	f000 027f 	and.w	r2, r0, #127	; 0x7f
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4bc6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4bca:	f804 2009 	strb.w	r2, [r4, r9]
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4bce:	4b64      	ldr	r3, [pc, #400]	; (4d60 <grid_port_receive_decode+0x4a4>)
    4bd0:	2102      	movs	r1, #2
    4bd2:	3039      	adds	r0, #57	; 0x39
    4bd4:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4bd6:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4bda:	f642 7247 	movw	r2, #12103	; 0x2f47
    4bde:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4be2:	5ca1      	ldrb	r1, [r4, r2]
    4be4:	6179      	str	r1, [r7, #20]
    4be6:	4648      	mov	r0, r9
    4be8:	47b0      	blx	r6
    4bea:	6979      	ldr	r1, [r7, #20]
    4bec:	4b5d      	ldr	r3, [pc, #372]	; (4d64 <grid_port_receive_decode+0x4a8>)
    4bee:	4602      	mov	r2, r0
    4bf0:	4648      	mov	r0, r9
    4bf2:	4798      	blx	r3
						if (partner_token_received != por->ping_partner_token){
    4bf4:	f642 7232 	movw	r2, #12082	; 0x2f32
    4bf8:	5ca1      	ldrb	r1, [r4, r2]
    4bfa:	4559      	cmp	r1, fp
    4bfc:	d017      	beq.n	4c2e <grid_port_receive_decode+0x372>
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bfe:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = partner_token_received;							
    4c02:	f804 b002 	strb.w	fp, [r4, r2]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4c06:	4b56      	ldr	r3, [pc, #344]	; (4d60 <grid_port_receive_decode+0x4a4>)
    4c08:	465a      	mov	r2, fp
    4c0a:	2102      	movs	r1, #2
    4c0c:	303b      	adds	r0, #59	; 0x3b
    4c0e:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4c10:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4c14:	f642 7347 	movw	r3, #12103	; 0x2f47
    4c18:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4c1c:	5ce1      	ldrb	r1, [r4, r3]
    4c1e:	6179      	str	r1, [r7, #20]
    4c20:	4648      	mov	r0, r9
    4c22:	47b0      	blx	r6
    4c24:	6979      	ldr	r1, [r7, #20]
    4c26:	4b4f      	ldr	r3, [pc, #316]	; (4d64 <grid_port_receive_decode+0x4a8>)
    4c28:	4602      	mov	r2, r0
    4c2a:	4648      	mov	r0, r9
    4c2c:	4798      	blx	r3
						if (por->ping_local_token != local_token_received){
    4c2e:	f642 7331 	movw	r3, #12081	; 0x2f31
    4c32:	5ce3      	ldrb	r3, [r4, r3]
    4c34:	4553      	cmp	r3, sl
    4c36:	d129      	bne.n	4c8c <grid_port_receive_decode+0x3d0>
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c38:	7a62      	ldrb	r2, [r4, #9]
    4c3a:	78eb      	ldrb	r3, [r5, #3]
    4c3c:	1a9b      	subs	r3, r3, r2
    4c3e:	3306      	adds	r3, #6
    4c40:	425a      	negs	r2, r3
    4c42:	f002 0203 	and.w	r2, r2, #3
    4c46:	f003 0303 	and.w	r3, r3, #3
    4c4a:	bf58      	it	pl
    4c4c:	4253      	negpl	r3, r2
    4c4e:	f642 7230 	movw	r2, #12080	; 0x2f30
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c52:	f1a8 000a 	sub.w	r0, r8, #10
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c56:	54a3      	strb	r3, [r4, r2]
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c58:	2102      	movs	r1, #2
    4c5a:	4b43      	ldr	r3, [pc, #268]	; (4d68 <grid_port_receive_decode+0x4ac>)
    4c5c:	2200      	movs	r2, #0
    4c5e:	4428      	add	r0, r5
    4c60:	4798      	blx	r3
    4c62:	f642 732c 	movw	r3, #12076	; 0x2f2c
							por->partner_status = 1;
    4c66:	2201      	movs	r2, #1
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c68:	50e0      	str	r0, [r4, r3]
							por->partner_status = 1;
    4c6a:	f642 734b 	movw	r3, #12107	; 0x2f4b
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c6e:	493f      	ldr	r1, [pc, #252]	; (4d6c <grid_port_receive_decode+0x4b0>)
							por->partner_status = 1;
    4c70:	54e2      	strb	r2, [r4, r3]
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c72:	483f      	ldr	r0, [pc, #252]	; (4d70 <grid_port_receive_decode+0x4b4>)
    4c74:	4b3f      	ldr	r3, [pc, #252]	; (4d74 <grid_port_receive_decode+0x4b8>)
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c76:	4d40      	ldr	r5, [pc, #256]	; (4d78 <grid_port_receive_decode+0x4bc>)
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c78:	4798      	blx	r3
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c7a:	2300      	movs	r3, #0
    4c7c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    4c80:	e9cd 3200 	strd	r3, r2, [sp]
    4c84:	4835      	ldr	r0, [pc, #212]	; (4d5c <grid_port_receive_decode+0x4a0>)
    4c86:	22ff      	movs	r2, #255	; 0xff
    4c88:	4619      	mov	r1, r3
    4c8a:	47a8      	blx	r5
						por->ping_flag = 1;
    4c8c:	f642 7348 	movw	r3, #12104	; 0x2f48
    4c90:	2201      	movs	r2, #1
    4c92:	54e2      	strb	r2, [r4, r3]
    4c94:	e70a      	b.n	4aac <grid_port_receive_decode+0x1f0>
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c96:	7a61      	ldrb	r1, [r4, #9]
    4c98:	78ea      	ldrb	r2, [r5, #3]
    4c9a:	1a52      	subs	r2, r2, r1
    4c9c:	3206      	adds	r2, #6
    4c9e:	4251      	negs	r1, r2
						validator &= local_token_received == por->ping_local_token;
    4ca0:	f642 7031 	movw	r0, #12081	; 0x2f31
						validator &= partner_token_received == por->ping_partner_token;
    4ca4:	f642 7c32 	movw	ip, #12082	; 0x2f32
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4ca8:	f001 0103 	and.w	r1, r1, #3
						validator &= local_token_received == por->ping_local_token;
    4cac:	5c20      	ldrb	r0, [r4, r0]
						validator &= partner_token_received == por->ping_partner_token;
    4cae:	f814 c00c 	ldrb.w	ip, [r4, ip]
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4cb2:	f002 0203 	and.w	r2, r2, #3
    4cb6:	bf58      	it	pl
    4cb8:	424a      	negpl	r2, r1
    4cba:	f642 7130 	movw	r1, #12080	; 0x2f30
    4cbe:	4550      	cmp	r0, sl
    4cc0:	bf08      	it	eq
    4cc2:	45dc      	cmpeq	ip, fp
    4cc4:	5c61      	ldrb	r1, [r4, r1]
    4cc6:	bf0c      	ite	eq
    4cc8:	f04f 0a01 	moveq.w	sl, #1
    4ccc:	f04f 0a00 	movne.w	sl, #0
						validator &= por->partner_hwcfg == grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4cd0:	f642 732c 	movw	r3, #12076	; 0x2f2c
    4cd4:	f1a8 000a 	sub.w	r0, r8, #10
    4cd8:	428a      	cmp	r2, r1
    4cda:	bf14      	ite	ne
    4cdc:	f04f 0a00 	movne.w	sl, #0
    4ce0:	f00a 0a01 	andeq.w	sl, sl, #1
    4ce4:	4428      	add	r0, r5
    4ce6:	2200      	movs	r2, #0
    4ce8:	2102      	movs	r1, #2
    4cea:	f854 b003 	ldr.w	fp, [r4, r3]
    4cee:	47c8      	blx	r9
						if (validator == 1){
    4cf0:	4558      	cmp	r0, fp
    4cf2:	d103      	bne.n	4cfc <grid_port_receive_decode+0x440>
    4cf4:	f1ba 0f00 	cmp.w	sl, #0
    4cf8:	f47f aed8 	bne.w	4aac <grid_port_receive_decode+0x1f0>
							por->partner_status = 0;
    4cfc:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4d00:	2200      	movs	r2, #0
    4d02:	54e2      	strb	r2, [r4, r3]
							por->ping_local_token = 255;
    4d04:	f642 7831 	movw	r8, #12081	; 0x2f31
							por->ping_partner_token = 255;
    4d08:	f642 7332 	movw	r3, #12082	; 0x2f32
    4d0c:	22ff      	movs	r2, #255	; 0xff
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4d0e:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = 255;
    4d12:	54e2      	strb	r2, [r4, r3]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4d14:	4d12      	ldr	r5, [pc, #72]	; (4d60 <grid_port_receive_decode+0x4a4>)
							por->ping_local_token = 255;
    4d16:	f804 2008 	strb.w	r2, [r4, r8]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4d1a:	2102      	movs	r1, #2
    4d1c:	303b      	adds	r0, #59	; 0x3b
    4d1e:	47a8      	blx	r5
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4d20:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4d24:	f814 2008 	ldrb.w	r2, [r4, r8]
    4d28:	2102      	movs	r1, #2
    4d2a:	3039      	adds	r0, #57	; 0x39
    4d2c:	47a8      	blx	r5
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4d2e:	f642 7347 	movw	r3, #12103	; 0x2f47
    4d32:	f504 553c 	add.w	r5, r4, #12032	; 0x2f00
    4d36:	3533      	adds	r5, #51	; 0x33
    4d38:	5ce1      	ldrb	r1, [r4, r3]
    4d3a:	6179      	str	r1, [r7, #20]
    4d3c:	4628      	mov	r0, r5
    4d3e:	47b0      	blx	r6
    4d40:	6979      	ldr	r1, [r7, #20]
    4d42:	4b08      	ldr	r3, [pc, #32]	; (4d64 <grid_port_receive_decode+0x4a8>)
    4d44:	4602      	mov	r2, r0
    4d46:	4628      	mov	r0, r5
    4d48:	4798      	blx	r3
    4d4a:	e6af      	b.n	4aac <grid_port_receive_decode+0x1f0>
				printf("{\"type\": \"WARNING\", \"data\": [\"Unknow Message Type\"]}\r\n");
    4d4c:	480b      	ldr	r0, [pc, #44]	; (4d7c <grid_port_receive_decode+0x4c0>)
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d4e:	4b0c      	ldr	r3, [pc, #48]	; (4d80 <grid_port_receive_decode+0x4c4>)
    4d50:	4798      	blx	r3
	return;
    4d52:	e6ab      	b.n	4aac <grid_port_receive_decode+0x1f0>
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d54:	480b      	ldr	r0, [pc, #44]	; (4d84 <grid_port_receive_decode+0x4c8>)
    4d56:	e7fa      	b.n	4d4e <grid_port_receive_decode+0x492>
    4d58:	000097a9 	.word	0x000097a9
    4d5c:	2000f008 	.word	0x2000f008
    4d60:	00009889 	.word	0x00009889
    4d64:	00009a05 	.word	0x00009a05
    4d68:	00009861 	.word	0x00009861
    4d6c:	00016960 	.word	0x00016960
    4d70:	0001693b 	.word	0x0001693b
    4d74:	000146ad 	.word	0x000146ad
    4d78:	00009813 	.word	0x00009813
    4d7c:	00016968 	.word	0x00016968
    4d80:	000147bd 	.word	0x000147bd
    4d84:	0001699e 	.word	0x0001699e

00004d88 <grid_port_receive_task>:
void grid_port_receive_task(struct grid_port* por){
    4d88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (por->usart_error_flag == 1){
    4d8a:	7e03      	ldrb	r3, [r0, #24]
    4d8c:	2b01      	cmp	r3, #1
void grid_port_receive_task(struct grid_port* por){
    4d8e:	4604      	mov	r4, r0
	if (por->usart_error_flag == 1){
    4d90:	d10d      	bne.n	4dae <grid_port_receive_task+0x26>
		por->usart_error_flag = 0;
    4d92:	2500      	movs	r5, #0
    4d94:	7605      	strb	r5, [r0, #24]
		grid_port_reset_receiver(por);
    4d96:	4b53      	ldr	r3, [pc, #332]	; (4ee4 <grid_port_receive_task+0x15c>)
    4d98:	4798      	blx	r3
		grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500); // White triangle
    4d9a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d9e:	e9cd 5300 	strd	r5, r3, [sp]
    4da2:	23ff      	movs	r3, #255	; 0xff
    4da4:	4850      	ldr	r0, [pc, #320]	; (4ee8 <grid_port_receive_task+0x160>)
    4da6:	4d51      	ldr	r5, [pc, #324]	; (4eec <grid_port_receive_task+0x164>)
    4da8:	461a      	mov	r2, r3
    4daa:	4619      	mov	r1, r3
    4dac:	47a8      	blx	r5
	if	(por->rx_double_buffer_status == 0){
    4dae:	6a25      	ldr	r5, [r4, #32]
    4db0:	bb7d      	cbnz	r5, 4e12 <grid_port_receive_task+0x8a>
		if (por->usart!=NULL){ // His is GRID usart port
    4db2:	6863      	ldr	r3, [r4, #4]
    4db4:	b1cb      	cbz	r3, 4dea <grid_port_receive_task+0x62>
			if (por->rx_double_buffer_timeout > 1000){
    4db6:	69e3      	ldr	r3, [r4, #28]
    4db8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4dbc:	d93e      	bls.n	4e3c <grid_port_receive_task+0xb4>
				if (por->partner_status == 1){
    4dbe:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4dc2:	5ce3      	ldrb	r3, [r4, r3]
    4dc4:	2b01      	cmp	r3, #1
    4dc6:	d12c      	bne.n	4e22 <grid_port_receive_task+0x9a>
					GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout Disconnect & Reset Receiver");
    4dc8:	4949      	ldr	r1, [pc, #292]	; (4ef0 <grid_port_receive_task+0x168>)
    4dca:	4b4a      	ldr	r3, [pc, #296]	; (4ef4 <grid_port_receive_task+0x16c>)
    4dcc:	484a      	ldr	r0, [pc, #296]	; (4ef8 <grid_port_receive_task+0x170>)
    4dce:	4798      	blx	r3
					grid_port_reset_receiver(por);
    4dd0:	4b44      	ldr	r3, [pc, #272]	; (4ee4 <grid_port_receive_task+0x15c>)
    4dd2:	4620      	mov	r0, r4
    4dd4:	4798      	blx	r3
					grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500);
    4dd6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4dda:	e9cd 5300 	strd	r5, r3, [sp]
    4dde:	23ff      	movs	r3, #255	; 0xff
    4de0:	4841      	ldr	r0, [pc, #260]	; (4ee8 <grid_port_receive_task+0x160>)
    4de2:	4d42      	ldr	r5, [pc, #264]	; (4eec <grid_port_receive_task+0x164>)
    4de4:	461a      	mov	r2, r3
    4de6:	4619      	mov	r1, r3
    4de8:	47a8      	blx	r5
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4dea:	f241 3687 	movw	r6, #4999	; 0x1387
void grid_port_receive_task(struct grid_port* por){
    4dee:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4df2:	f241 30b4 	movw	r0, #5044	; 0x13b4
    4df6:	46b4      	mov	ip, r6
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4df8:	f241 3788 	movw	r7, #5000	; 0x1388
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4dfc:	f241 3e86 	movw	lr, #4998	; 0x1386
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4e00:	6a62      	ldr	r2, [r4, #36]	; 0x24
    4e02:	18a3      	adds	r3, r4, r2
    4e04:	5c1b      	ldrb	r3, [r3, r0]
    4e06:	2b0a      	cmp	r3, #10
    4e08:	d11b      	bne.n	4e42 <grid_port_receive_task+0xba>
				por->rx_double_buffer_timeout = 0;
    4e0a:	2300      	movs	r3, #0
    4e0c:	2501      	movs	r5, #1
    4e0e:	e9c4 3507 	strd	r3, r5, [r4, #28]
	if (por->rx_double_buffer_read_start_index < por->rx_double_buffer_seek_start_index){
    4e12:	e9d4 2109 	ldrd	r2, r1, [r4, #36]	; 0x24
    4e16:	4291      	cmp	r1, r2
    4e18:	d359      	bcc.n	4ece <grid_port_receive_task+0x146>
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e1a:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
    4e1e:	3209      	adds	r2, #9
    4e20:	e056      	b.n	4ed0 <grid_port_receive_task+0x148>
					if (por->rx_double_buffer_read_start_index == 0 && por->rx_double_buffer_seek_start_index == 0){
    4e22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4e24:	b913      	cbnz	r3, 4e2c <grid_port_receive_task+0xa4>
    4e26:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4e28:	2b00      	cmp	r3, #0
    4e2a:	d0de      	beq.n	4dea <grid_port_receive_task+0x62>
						GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout & Reset Receiver");
    4e2c:	4933      	ldr	r1, [pc, #204]	; (4efc <grid_port_receive_task+0x174>)
    4e2e:	4b31      	ldr	r3, [pc, #196]	; (4ef4 <grid_port_receive_task+0x16c>)
    4e30:	4831      	ldr	r0, [pc, #196]	; (4ef8 <grid_port_receive_task+0x170>)
    4e32:	4798      	blx	r3
						grid_port_reset_receiver(por);
    4e34:	4b2b      	ldr	r3, [pc, #172]	; (4ee4 <grid_port_receive_task+0x15c>)
    4e36:	4620      	mov	r0, r4
    4e38:	4798      	blx	r3
    4e3a:	e7d6      	b.n	4dea <grid_port_receive_task+0x62>
				por->rx_double_buffer_timeout++;
    4e3c:	3301      	adds	r3, #1
    4e3e:	61e3      	str	r3, [r4, #28]
    4e40:	e7d3      	b.n	4dea <grid_port_receive_task+0x62>
			else if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 0){
    4e42:	b923      	cbnz	r3, 4e4e <grid_port_receive_task+0xc6>
	if (por->rx_double_buffer_status == 0){
    4e44:	6a23      	ldr	r3, [r4, #32]
    4e46:	2b00      	cmp	r3, #0
    4e48:	d1e3      	bne.n	4e12 <grid_port_receive_task+0x8a>
}
    4e4a:	b003      	add	sp, #12
    4e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (por->rx_double_buffer_seek_start_index == por->rx_double_buffer_read_start_index-1)
    4e4e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    4e50:	1e6b      	subs	r3, r5, #1
    4e52:	429a      	cmp	r2, r3
    4e54:	d10d      	bne.n	4e72 <grid_port_receive_task+0xea>
				grid_port_reset_receiver(por);	
    4e56:	4b23      	ldr	r3, [pc, #140]	; (4ee4 <grid_port_receive_task+0x15c>)
    4e58:	4620      	mov	r0, r4
    4e5a:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 255, 0, 0, 2, 200); // RED
    4e5c:	2302      	movs	r3, #2
    4e5e:	20c8      	movs	r0, #200	; 0xc8
    4e60:	e9cd 3000 	strd	r3, r0, [sp]
    4e64:	2300      	movs	r3, #0
    4e66:	461a      	mov	r2, r3
    4e68:	21ff      	movs	r1, #255	; 0xff
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e6a:	481f      	ldr	r0, [pc, #124]	; (4ee8 <grid_port_receive_task+0x160>)
    4e6c:	4c1f      	ldr	r4, [pc, #124]	; (4eec <grid_port_receive_task+0x164>)
    4e6e:	47a0      	blx	r4
				return;
    4e70:	e7eb      	b.n	4e4a <grid_port_receive_task+0xc2>
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4e72:	42b2      	cmp	r2, r6
    4e74:	d10b      	bne.n	4e8e <grid_port_receive_task+0x106>
    4e76:	b955      	cbnz	r5, 4e8e <grid_port_receive_task+0x106>
				grid_port_reset_receiver(por);
    4e78:	4b1a      	ldr	r3, [pc, #104]	; (4ee4 <grid_port_receive_task+0x15c>)
    4e7a:	4620      	mov	r0, r4
    4e7c:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 2, 200); // RED
    4e7e:	2302      	movs	r3, #2
    4e80:	21c8      	movs	r1, #200	; 0xc8
    4e82:	e9cd 3100 	strd	r3, r1, [sp]
    4e86:	22ff      	movs	r2, #255	; 0xff
    4e88:	462b      	mov	r3, r5
    4e8a:	4629      	mov	r1, r5
    4e8c:	e7ed      	b.n	4e6a <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4e8e:	4465      	add	r5, ip
    4e90:	fbb5 f3f7 	udiv	r3, r5, r7
    4e94:	fb07 5513 	mls	r5, r7, r3, r5
    4e98:	4425      	add	r5, r4
    4e9a:	5c2b      	ldrb	r3, [r5, r0]
    4e9c:	b153      	cbz	r3, 4eb4 <grid_port_receive_task+0x12c>
				grid_port_reset_receiver(por);
    4e9e:	4b11      	ldr	r3, [pc, #68]	; (4ee4 <grid_port_receive_task+0x15c>)
    4ea0:	4620      	mov	r0, r4
    4ea2:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4ea4:	2302      	movs	r3, #2
    4ea6:	22c8      	movs	r2, #200	; 0xc8
    4ea8:	e9cd 3200 	strd	r3, r2, [sp]
    4eac:	2200      	movs	r2, #0
    4eae:	23ff      	movs	r3, #255	; 0xff
    4eb0:	4611      	mov	r1, r2
    4eb2:	e7da      	b.n	4e6a <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4eb4:	4572      	cmp	r2, lr
				por->rx_double_buffer_seek_start_index++;
    4eb6:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
    4eba:	bf98      	it	ls
    4ebc:	3201      	addls	r2, #1
    4ebe:	b289      	uxth	r1, r1
				por->rx_double_buffer_timeout = 0;
    4ec0:	61e3      	str	r3, [r4, #28]
				por->rx_double_buffer_seek_start_index++;
    4ec2:	bf94      	ite	ls
    4ec4:	6262      	strls	r2, [r4, #36]	; 0x24
				por->rx_double_buffer_seek_start_index=0;
    4ec6:	6263      	strhi	r3, [r4, #36]	; 0x24
		for(uint16_t i = 0; i<490; i++){
    4ec8:	2900      	cmp	r1, #0
    4eca:	d199      	bne.n	4e00 <grid_port_receive_task+0x78>
    4ecc:	e7ba      	b.n	4e44 <grid_port_receive_task+0xbc>
		length = por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4ece:	3201      	adds	r2, #1
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4ed0:	1a52      	subs	r2, r2, r1
	grid_port_receive_decode(por, por->rx_double_buffer_read_start_index, length);
    4ed2:	4b0b      	ldr	r3, [pc, #44]	; (4f00 <grid_port_receive_task+0x178>)
    4ed4:	b292      	uxth	r2, r2
    4ed6:	b289      	uxth	r1, r1
    4ed8:	4620      	mov	r0, r4
    4eda:	4798      	blx	r3
	por->rx_double_buffer_status = 0;
    4edc:	2300      	movs	r3, #0
    4ede:	6223      	str	r3, [r4, #32]
    4ee0:	e7b3      	b.n	4e4a <grid_port_receive_task+0xc2>
    4ee2:	bf00      	nop
    4ee4:	00004731 	.word	0x00004731
    4ee8:	2000f008 	.word	0x2000f008
    4eec:	00009813 	.word	0x00009813
    4ef0:	000169d1 	.word	0x000169d1
    4ef4:	000146ad 	.word	0x000146ad
    4ef8:	0001693b 	.word	0x0001693b
    4efc:	000169f5 	.word	0x000169f5
    4f00:	000048bd 	.word	0x000048bd

00004f04 <grid_buffer_read_size>:
	return 1;
}

uint16_t grid_buffer_read_size(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f04:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4f08:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f0c:	428b      	cmp	r3, r1
uint16_t grid_buffer_read_size(struct grid_buffer* buf){
    4f0e:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f10:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop) {
    4f12:	d000      	beq.n	4f16 <grid_buffer_read_size+0x12>
		while(1){
    4f14:	e7fe      	b.n	4f14 <grid_buffer_read_size+0x10>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f16:	f8b0 63ea 	ldrh.w	r6, [r0, #1002]	; 0x3ea
    4f1a:	42b3      	cmp	r3, r6
    4f1c:	d000      	beq.n	4f20 <grid_buffer_read_size+0x1c>
		while(1){
    4f1e:	e7fe      	b.n	4f1e <grid_buffer_read_size+0x1a>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	if (buf->read_start == buf->write_start) {
    4f20:	f8b0 73f2 	ldrh.w	r7, [r0, #1010]	; 0x3f2
    4f24:	42be      	cmp	r6, r7
    4f26:	d016      	beq.n	4f56 <grid_buffer_read_size+0x52>
	}
	
	
	
	// Seek message end character
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f28:	8805      	ldrh	r5, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f2a:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f2c:	b2a3      	uxth	r3, r4
    4f2e:	429d      	cmp	r5, r3
    4f30:	d800      	bhi.n	4f34 <grid_buffer_read_size+0x30>
		}
		
		
	}
	
	while(1){
    4f32:	e7fe      	b.n	4f32 <grid_buffer_read_size+0x2e>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f34:	1930      	adds	r0, r6, r4
    4f36:	fbb0 f1f5 	udiv	r1, r0, r5
    4f3a:	fb05 0111 	mls	r1, r5, r1, r0
		if (index == buf->write_start) return 0;
    4f3e:	b288      	uxth	r0, r1
    4f40:	4287      	cmp	r7, r0
    4f42:	d008      	beq.n	4f56 <grid_buffer_read_size+0x52>
		if (buf->buffer_storage[index] == '\n'){
    4f44:	4411      	add	r1, r2
    4f46:	3301      	adds	r3, #1
    4f48:	b298      	uxth	r0, r3
    4f4a:	788b      	ldrb	r3, [r1, #2]
    4f4c:	2b0a      	cmp	r3, #10
    4f4e:	f104 0401 	add.w	r4, r4, #1
    4f52:	d1eb      	bne.n	4f2c <grid_buffer_read_size+0x28>
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f56:	2000      	movs	r0, #0
    4f58:	e7fc      	b.n	4f54 <grid_buffer_read_size+0x50>

00004f5a <grid_buffer_read_init>:

uint16_t grid_buffer_read_init(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f5a:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4f5e:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f62:	4293      	cmp	r3, r2
uint16_t grid_buffer_read_init(struct grid_buffer* buf){
    4f64:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->read_active != buf->read_stop) {
    4f66:	d000      	beq.n	4f6a <grid_buffer_read_init+0x10>
		while(1){
    4f68:	e7fe      	b.n	4f68 <grid_buffer_read_init+0xe>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f6a:	f8b0 53ea 	ldrh.w	r5, [r0, #1002]	; 0x3ea
    4f6e:	42ab      	cmp	r3, r5
    4f70:	d000      	beq.n	4f74 <grid_buffer_read_init+0x1a>
		while(1){
    4f72:	e7fe      	b.n	4f72 <grid_buffer_read_init+0x18>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	if (buf->read_start == buf->write_start) {
    4f74:	f8b0 63f2 	ldrh.w	r6, [r0, #1010]	; 0x3f2
    4f78:	42b5      	cmp	r5, r6
    4f7a:	d020      	beq.n	4fbe <grid_buffer_read_init+0x64>
	}
	
	
	
	// Seek message end character	
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f7c:	8801      	ldrh	r1, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f7e:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f80:	b2a3      	uxth	r3, r4
    4f82:	4299      	cmp	r1, r3
    4f84:	d800      	bhi.n	4f88 <grid_buffer_read_init+0x2e>
		}
		
		
	}
		
	while(1){
    4f86:	e7fe      	b.n	4f86 <grid_buffer_read_init+0x2c>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f88:	192f      	adds	r7, r5, r4
    4f8a:	fbb7 f2f1 	udiv	r2, r7, r1
    4f8e:	fb01 7212 	mls	r2, r1, r2, r7
		if (index == buf->write_start) return 0;	
    4f92:	b297      	uxth	r7, r2
    4f94:	42be      	cmp	r6, r7
    4f96:	d012      	beq.n	4fbe <grid_buffer_read_init+0x64>
		if (buf->buffer_storage[index] == '\n'){
    4f98:	1887      	adds	r7, r0, r2
    4f9a:	3301      	adds	r3, #1
    4f9c:	78bf      	ldrb	r7, [r7, #2]
    4f9e:	2f0a      	cmp	r7, #10
    4fa0:	b29b      	uxth	r3, r3
    4fa2:	f104 0401 	add.w	r4, r4, #1
    4fa6:	d1eb      	bne.n	4f80 <grid_buffer_read_init+0x26>
			buf->read_stop = (index+1)%buf->buffer_length;
    4fa8:	3201      	adds	r2, #1
    4faa:	fbb2 f4f1 	udiv	r4, r2, r1
    4fae:	fb01 2214 	mls	r2, r1, r4, r2
    4fb2:	f8a0 23ec 	strh.w	r2, [r0, #1004]	; 0x3ec
			buf->read_length = i+1;
    4fb6:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4fba:	4618      	mov	r0, r3
    4fbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4fbe:	2300      	movs	r3, #0
    4fc0:	e7fb      	b.n	4fba <grid_buffer_read_init+0x60>

00004fc2 <grid_buffer_read_character>:

uint8_t grid_buffer_read_character(struct grid_buffer* buf){
	
	// Check if packet is not over
	if (buf->read_active != buf->read_stop){
    4fc2:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4fc6:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4fca:	4299      	cmp	r1, r3
uint8_t grid_buffer_read_character(struct grid_buffer* buf){
    4fcc:	b510      	push	{r4, lr}
    4fce:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop){
    4fd0:	d00b      	beq.n	4fea <grid_buffer_read_character+0x28>
		
		uint8_t character = buf->buffer_storage[buf->read_active];
		
		buf->read_active++;
		buf->read_active %= buf->buffer_length;
    4fd2:	8814      	ldrh	r4, [r2, #0]
		uint8_t character = buf->buffer_storage[buf->read_active];
    4fd4:	18c1      	adds	r1, r0, r3
		buf->read_active++;
    4fd6:	3301      	adds	r3, #1
		buf->read_active %= buf->buffer_length;
    4fd8:	b29b      	uxth	r3, r3
		uint8_t character = buf->buffer_storage[buf->read_active];
    4fda:	7888      	ldrb	r0, [r1, #2]
		buf->read_active %= buf->buffer_length;
    4fdc:	fbb3 f1f4 	udiv	r1, r3, r4
    4fe0:	fb04 3311 	mls	r3, r4, r1, r3
    4fe4:	f8a2 33ee 	strh.w	r3, [r2, #1006]	; 0x3ee
			// TRAP: TRANSMISSION WAS OVER ALREADY
		}
	}
	

}
    4fe8:	bd10      	pop	{r4, pc}
		while(1){
    4fea:	e7fe      	b.n	4fea <grid_buffer_read_character+0x28>

00004fec <grid_buffer_read_acknowledge>:

// TRANSMISSION WAS ACKNOWLEDGED, PACKET CAN BE DELETED
uint8_t grid_buffer_read_acknowledge(struct grid_buffer* buf){
	
	// Check if packet is really over
	if (buf->read_active == buf->read_stop){
    4fec:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4ff0:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4ff4:	4293      	cmp	r3, r2
    4ff6:	d000      	beq.n	4ffa <grid_buffer_read_acknowledge+0xe>
		buf->read_start = buf->read_stop;
		return 1;
	}else{
		
		while(1){
    4ff8:	e7fe      	b.n	4ff8 <grid_buffer_read_acknowledge+0xc>
		buf->read_start = buf->read_stop;
    4ffa:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	

}
    4ffe:	2001      	movs	r0, #1
    5000:	4770      	bx	lr
	...

00005004 <grid_port_init>:
	buf->read_start  = buf->read_stop;
	
	return 1;
}

void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    5004:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5008:	4604      	mov	r4, r0
	
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    500a:	f500 501c 	add.w	r0, r0, #9984	; 0x2700
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    500e:	b087      	sub	sp, #28
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    5010:	f8df 8148 	ldr.w	r8, [pc, #328]	; 515c <grid_port_init+0x158>
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    5014:	460d      	mov	r5, r1
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    5016:	303c      	adds	r0, #60	; 0x3c
    5018:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    501c:	4616      	mov	r6, r2
    501e:	461f      	mov	r7, r3
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    5020:	47c0      	blx	r8
	grid_buffer_init(&por->rx_buffer, GRID_BUFFER_SIZE);
    5022:	f504 502c 	add.w	r0, r4, #11008	; 0x2b00
    5026:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    502a:	3034      	adds	r0, #52	; 0x34
    502c:	47c0      	blx	r8
	
	
	por->cooldown = 0;
    502e:	2000      	movs	r0, #0
	
	por->dma_channel = dma;
    5030:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
	por->cooldown = 0;
    5034:	6020      	str	r0, [r4, #0]
	
	por->tx_double_buffer_status	= 0;
	por->rx_double_buffer_status	= 0;
	
	
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5036:	f241 3288 	movw	r2, #5000	; 0x1388
	por->dma_channel = dma;
    503a:	72a3      	strb	r3, [r4, #10]
	por->direction = dir;
    503c:	7267      	strb	r7, [r4, #9]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    503e:	4603      	mov	r3, r0
	por->usart	= usart;
    5040:	6065      	str	r5, [r4, #4]
	por->type		= type;
    5042:	7226      	strb	r6, [r4, #8]
	por->tx_double_buffer_status	= 0;
    5044:	81a0      	strh	r0, [r4, #12]
	por->rx_double_buffer_status	= 0;
    5046:	6220      	str	r0, [r4, #32]
		por->tx_double_buffer[i] = 0;		
    5048:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    504a:	3301      	adds	r3, #1
    504c:	4293      	cmp	r3, r2
		por->tx_double_buffer[i] = 0;		
    504e:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5052:	d1f9      	bne.n	5048 <grid_port_init+0x44>
	}
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5054:	2300      	movs	r3, #0
		por->rx_double_buffer[i] = 0;
    5056:	f241 31b4 	movw	r1, #5044	; 0x13b4
    505a:	461d      	mov	r5, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    505c:	f241 3288 	movw	r2, #5000	; 0x1388
		por->rx_double_buffer[i] = 0;
    5060:	18e0      	adds	r0, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5062:	3301      	adds	r3, #1
    5064:	4293      	cmp	r3, r2
		por->rx_double_buffer[i] = 0;
    5066:	5445      	strb	r5, [r0, r1]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5068:	d1fa      	bne.n	5060 <grid_port_init+0x5c>
	}
	
	por->partner_fi = 0;
	
	por->partner_hwcfg = 0;
    506a:	f642 732c 	movw	r3, #12076	; 0x2f2c
	por->partner_fi = 0;
    506e:	f642 7130 	movw	r1, #12080	; 0x2f30
	por->partner_status = 1;
	
	por->ping_local_token = 255;
    5072:	f642 7031 	movw	r0, #12081	; 0x2f31
	por->partner_fi = 0;
    5076:	5465      	strb	r5, [r4, r1]
	por->partner_hwcfg = 0;
    5078:	50e5      	str	r5, [r4, r3]
	por->partner_status = 1;
    507a:	f642 734b 	movw	r3, #12107	; 0x2f4b
    507e:	2201      	movs	r2, #1
	por->ping_local_token = 255;
    5080:	27ff      	movs	r7, #255	; 0xff
	por->partner_status = 1;
    5082:	54e2      	strb	r2, [r4, r3]
	por->ping_local_token = 255;
    5084:	5427      	strb	r7, [r4, r0]
	por->ping_partner_token = 255;
    5086:	f642 7032 	movw	r0, #12082	; 0x2f32
	
	por->ping_flag = 0;
	
	if (type == GRID_PORT_TYPE_USART){	
    508a:	4296      	cmp	r6, r2
	por->ping_partner_token = 255;
    508c:	5427      	strb	r7, [r4, r0]
	por->ping_flag = 0;
    508e:	f642 7048 	movw	r0, #12104	; 0x2f48
    5092:	5425      	strb	r5, [r4, r0]
	if (type == GRID_PORT_TYPE_USART){	
    5094:	d156      	bne.n	5144 <grid_port_init+0x140>
		
		por->partner_status = 0;
    5096:	54e5      	strb	r5, [r4, r3]
		por->partner_fi = 0;
    5098:	5465      	strb	r5, [r4, r1]
		
		
		sprintf(por->ping_packet, "%c%c%c%c%02x%02x%02x%c00\n", GRID_CONST_SOH, GRID_CONST_DCT, GRID_CONST_BELL, por->direction, grid_sys_get_hwcfg(), 255, 255, GRID_CONST_EOT);
    509a:	4b2b      	ldr	r3, [pc, #172]	; (5148 <grid_port_init+0x144>)
    509c:	f894 9009 	ldrb.w	r9, [r4, #9]
    50a0:	4798      	blx	r3
    50a2:	f504 583c 	add.w	r8, r4, #12032	; 0x2f00
    50a6:	2304      	movs	r3, #4
    50a8:	f108 0833 	add.w	r8, r8, #51	; 0x33
    50ac:	e9cd 7304 	strd	r7, r3, [sp, #16]
    50b0:	fa5f f989 	uxtb.w	r9, r9
    50b4:	2307      	movs	r3, #7
    50b6:	4632      	mov	r2, r6
    50b8:	4924      	ldr	r1, [pc, #144]	; (514c <grid_port_init+0x148>)
    50ba:	f8cd 9004 	str.w	r9, [sp, #4]
    50be:	e9cd 0702 	strd	r0, r7, [sp, #8]
    50c2:	f8df 909c 	ldr.w	r9, [pc, #156]	; 5160 <grid_port_init+0x15c>
    50c6:	9300      	str	r3, [sp, #0]
    50c8:	4640      	mov	r0, r8
    50ca:	230e      	movs	r3, #14
    50cc:	47c8      	blx	r9
		
		por->ping_packet_length = strlen(por->ping_packet);	
    50ce:	4b20      	ldr	r3, [pc, #128]	; (5150 <grid_port_init+0x14c>)
    50d0:	4640      	mov	r0, r8
    50d2:	4798      	blx	r3
    50d4:	f642 7347 	movw	r3, #12103	; 0x2f47
    50d8:	b2c0      	uxtb	r0, r0
    50da:	54e0      	strb	r0, [r4, r3]
			
		grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    50dc:	4640      	mov	r0, r8
    50de:	f814 9003 	ldrb.w	r9, [r4, r3]
    50e2:	5ce1      	ldrb	r1, [r4, r3]
    50e4:	4b1b      	ldr	r3, [pc, #108]	; (5154 <grid_port_init+0x150>)
    50e6:	4798      	blx	r3
    50e8:	fa5f f989 	uxtb.w	r9, r9
    50ec:	4b1a      	ldr	r3, [pc, #104]	; (5158 <grid_port_init+0x154>)
    50ee:	4602      	mov	r2, r0
    50f0:	4649      	mov	r1, r9
    50f2:	4640      	mov	r0, r8
    50f4:	4798      	blx	r3
		

		
		if (por->direction == GRID_CONST_NORTH){
    50f6:	7a63      	ldrb	r3, [r4, #9]
    50f8:	2b11      	cmp	r3, #17
    50fa:	d108      	bne.n	510e <grid_port_init+0x10a>
			por->dx = 0;
    50fc:	f642 7349 	movw	r3, #12105	; 0x2f49
    5100:	54e5      	strb	r5, [r4, r3]
			por->dy = 1;
    5102:	f642 734a 	movw	r3, #12106	; 0x2f4a
    5106:	54e6      	strb	r6, [r4, r3]
	}
	else{
		por->partner_status = 1; //UI AND USB are considered to be connected by default
	}
	
}
    5108:	b007      	add	sp, #28
    510a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if (por->direction == GRID_CONST_EAST){
    510e:	7a63      	ldrb	r3, [r4, #9]
    5110:	2b12      	cmp	r3, #18
    5112:	d106      	bne.n	5122 <grid_port_init+0x11e>
			por->dx = 1;
    5114:	f642 7349 	movw	r3, #12105	; 0x2f49
    5118:	54e6      	strb	r6, [r4, r3]
			por->dy = 0;
    511a:	f642 734a 	movw	r3, #12106	; 0x2f4a
    511e:	54e5      	strb	r5, [r4, r3]
    5120:	e7f2      	b.n	5108 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_SOUTH){
    5122:	7a63      	ldrb	r3, [r4, #9]
    5124:	2b13      	cmp	r3, #19
    5126:	d106      	bne.n	5136 <grid_port_init+0x132>
			por->dx = 0;
    5128:	f642 7349 	movw	r3, #12105	; 0x2f49
    512c:	54e5      	strb	r5, [r4, r3]
			por->dy = -1;
    512e:	f642 734a 	movw	r3, #12106	; 0x2f4a
    5132:	54e7      	strb	r7, [r4, r3]
    5134:	e7e8      	b.n	5108 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_WEST){
    5136:	7a63      	ldrb	r3, [r4, #9]
    5138:	2b14      	cmp	r3, #20
    513a:	d1e5      	bne.n	5108 <grid_port_init+0x104>
			por->dx = -1;
    513c:	f642 7349 	movw	r3, #12105	; 0x2f49
    5140:	54e7      	strb	r7, [r4, r3]
    5142:	e7ea      	b.n	511a <grid_port_init+0x116>
		por->partner_status = 1; //UI AND USB are considered to be connected by default
    5144:	54e2      	strb	r2, [r4, r3]
}
    5146:	e7df      	b.n	5108 <grid_port_init+0x104>
    5148:	000098ed 	.word	0x000098ed
    514c:	00016a0e 	.word	0x00016a0e
    5150:	00014f81 	.word	0x00014f81
    5154:	000099d1 	.word	0x000099d1
    5158:	00009a05 	.word	0x00009a05
    515c:	000047dd 	.word	0x000047dd
    5160:	00014ac5 	.word	0x00014ac5

00005164 <grid_port_init_all>:

void grid_port_init_all(void){
    5164:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5168:	2600      	movs	r6, #0
    516a:	4d1c      	ldr	r5, [pc, #112]	; (51dc <grid_port_init_all+0x78>)
    516c:	491c      	ldr	r1, [pc, #112]	; (51e0 <grid_port_init_all+0x7c>)
    516e:	481d      	ldr	r0, [pc, #116]	; (51e4 <grid_port_init_all+0x80>)
    5170:	9600      	str	r6, [sp, #0]
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    5172:	2401      	movs	r4, #1
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5174:	2311      	movs	r3, #17
    5176:	2201      	movs	r2, #1
    5178:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    517a:	f04f 0902 	mov.w	r9, #2
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    517e:	4622      	mov	r2, r4
    5180:	4919      	ldr	r1, [pc, #100]	; (51e8 <grid_port_init_all+0x84>)
    5182:	481a      	ldr	r0, [pc, #104]	; (51ec <grid_port_init_all+0x88>)
    5184:	9400      	str	r4, [sp, #0]
    5186:	2312      	movs	r3, #18
    5188:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    518a:	2703      	movs	r7, #3
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    518c:	4622      	mov	r2, r4
    518e:	4918      	ldr	r1, [pc, #96]	; (51f0 <grid_port_init_all+0x8c>)
    5190:	4818      	ldr	r0, [pc, #96]	; (51f4 <grid_port_init_all+0x90>)
    5192:	f8cd 9000 	str.w	r9, [sp]
    5196:	2313      	movs	r3, #19
    5198:	47a8      	blx	r5
	
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    519a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 5204 <grid_port_init_all+0xa0>
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    519e:	9700      	str	r7, [sp, #0]
    51a0:	4622      	mov	r2, r4
    51a2:	4915      	ldr	r1, [pc, #84]	; (51f8 <grid_port_init_all+0x94>)
    51a4:	4815      	ldr	r0, [pc, #84]	; (51fc <grid_port_init_all+0x98>)
    51a6:	2314      	movs	r3, #20
    51a8:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    51aa:	f04f 0aff 	mov.w	sl, #255	; 0xff
    51ae:	463a      	mov	r2, r7
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    51b0:	4f13      	ldr	r7, [pc, #76]	; (5200 <grid_port_init_all+0x9c>)
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    51b2:	f8cd a000 	str.w	sl, [sp]
    51b6:	4633      	mov	r3, r6
    51b8:	4631      	mov	r1, r6
    51ba:	4640      	mov	r0, r8
    51bc:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    51be:	4633      	mov	r3, r6
    51c0:	f8cd a000 	str.w	sl, [sp]
    51c4:	464a      	mov	r2, r9
    51c6:	4631      	mov	r1, r6
    51c8:	4638      	mov	r0, r7
    51ca:	47a8      	blx	r5
	
	GRID_PORT_U.partner_status = 1; // UI IS ALWAYS CONNECTED
    51cc:	f642 734b 	movw	r3, #12107	; 0x2f4b
    51d0:	f808 4003 	strb.w	r4, [r8, r3]
	GRID_PORT_H.partner_status = 1; // HOST IS ALWAYS CONNECTED (Not really!)
    51d4:	54fc      	strb	r4, [r7, r3]
	
	
}
    51d6:	b002      	add	sp, #8
    51d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    51dc:	00005005 	.word	0x00005005
    51e0:	2001ce04 	.word	0x2001ce04
    51e4:	20009150 	.word	0x20009150
    51e8:	2001cdb0 	.word	0x2001cdb0
    51ec:	20019870 	.word	0x20019870
    51f0:	2001cf08 	.word	0x2001cf08
    51f4:	200138d4 	.word	0x200138d4
    51f8:	2001ceb8 	.word	0x2001ceb8
    51fc:	200102d4 	.word	0x200102d4
    5200:	20016824 	.word	0x20016824
    5204:	2000c0b0 	.word	0x2000c0b0

00005208 <grid_port_process_inbound>:


//=============================== PROCESS INBOUND ==============================//


uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    5208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    520c:	f500 582c 	add.w	r8, r0, #11008	; 0x2b00
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    5210:	b091      	sub	sp, #68	; 0x44
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    5212:	f108 0834 	add.w	r8, r8, #52	; 0x34
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    5216:	af02      	add	r7, sp, #8
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    5218:	4b5c      	ldr	r3, [pc, #368]	; (538c <grid_port_process_inbound+0x184>)
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    521a:	6079      	str	r1, [r7, #4]
    521c:	4606      	mov	r6, r0
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    521e:	4640      	mov	r0, r8
    5220:	4798      	blx	r3
	
	if (!packet_size){
    5222:	4605      	mov	r5, r0
    5224:	2800      	cmp	r0, #0
    5226:	f000 80af 	beq.w	5388 <grid_port_process_inbound+0x180>
		uint8_t port_count = 6;
		struct grid_port* port_array_default[port_count];
		struct grid_port* port_array[port_count];
		
		
		port_array_default[0] = &GRID_PORT_N;
    522a:	4b59      	ldr	r3, [pc, #356]	; (5390 <grid_port_process_inbound+0x188>)
    522c:	60bb      	str	r3, [r7, #8]
		port_array_default[1] = &GRID_PORT_E;
    522e:	4b59      	ldr	r3, [pc, #356]	; (5394 <grid_port_process_inbound+0x18c>)
    5230:	60fb      	str	r3, [r7, #12]
		port_array_default[2] = &GRID_PORT_S;
    5232:	4b59      	ldr	r3, [pc, #356]	; (5398 <grid_port_process_inbound+0x190>)
    5234:	613b      	str	r3, [r7, #16]
		port_array_default[3] = &GRID_PORT_W;
    5236:	4b59      	ldr	r3, [pc, #356]	; (539c <grid_port_process_inbound+0x194>)
    5238:	617b      	str	r3, [r7, #20]
		
		port_array_default[4] = &GRID_PORT_U;
    523a:	4b59      	ldr	r3, [pc, #356]	; (53a0 <grid_port_process_inbound+0x198>)
    523c:	61bb      	str	r3, [r7, #24]
		port_array_default[5] = &GRID_PORT_H;
    523e:	4b59      	ldr	r3, [pc, #356]	; (53a4 <grid_port_process_inbound+0x19c>)
    5240:	61fb      	str	r3, [r7, #28]
	}else{
    5242:	46eb      	mov	fp, sp
		
		uint8_t j=0;
		
		for(uint8_t i=0; i<port_count; i++){
    5244:	f107 0308 	add.w	r3, r7, #8
		port_array_default[5] = &GRID_PORT_H;
    5248:	f04f 0906 	mov.w	r9, #6
		uint8_t j=0;
    524c:	2400      	movs	r4, #0
			if (port_array_default[i]->partner_status != 0){
    524e:	f642 714b 	movw	r1, #12107	; 0x2f4b
    5252:	f853 2b04 	ldr.w	r2, [r3], #4
    5256:	5c50      	ldrb	r0, [r2, r1]
    5258:	b138      	cbz	r0, 526a <grid_port_process_inbound+0x62>
				port_array[j] = port_array_default[i];
    525a:	f107 0038 	add.w	r0, r7, #56	; 0x38
    525e:	eb00 0084 	add.w	r0, r0, r4, lsl #2
				j++;
    5262:	3401      	adds	r4, #1
				port_array[j] = port_array_default[i];
    5264:	f840 2c18 	str.w	r2, [r0, #-24]
				j++;
    5268:	b2e4      	uxtb	r4, r4
		for(uint8_t i=0; i<port_count; i++){
    526a:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    526e:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
    5272:	d1ee      	bne.n	5252 <grid_port_process_inbound+0x4a>
		
		for (uint8_t i=0; i<port_count; i++)
		{
			if (port_array[i] != por || loopback){
			
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5274:	4a4c      	ldr	r2, [pc, #304]	; (53a8 <grid_port_process_inbound+0x1a0>)
    5276:	4649      	mov	r1, r9
			if (port_array[i] != por || loopback){
    5278:	f107 0a20 	add.w	sl, r7, #32
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    527c:	f242 7c3c 	movw	ip, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5280:	b2c8      	uxtb	r0, r1
    5282:	4284      	cmp	r4, r0
    5284:	d805      	bhi.n	5292 <grid_port_process_inbound+0x8a>
					return 0;
				}	
			}	
		}
		
		if (packet_size != grid_buffer_read_init(&por->rx_buffer)){
    5286:	4b49      	ldr	r3, [pc, #292]	; (53ac <grid_port_process_inbound+0x1a4>)
    5288:	4640      	mov	r0, r8
    528a:	4798      	blx	r3
    528c:	42a8      	cmp	r0, r5
    528e:	d047      	beq.n	5320 <grid_port_process_inbound+0x118>
			while(1){			
    5290:	e7fe      	b.n	5290 <grid_port_process_inbound+0x88>
			if (port_array[i] != por || loopback){
    5292:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
    5296:	42b0      	cmp	r0, r6
    5298:	d101      	bne.n	529e <grid_port_process_inbound+0x96>
    529a:	687b      	ldr	r3, [r7, #4]
    529c:	b1b3      	cbz	r3, 52cc <grid_port_process_inbound+0xc4>
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    529e:	4460      	add	r0, ip
    52a0:	4790      	blx	r2
    52a2:	42a8      	cmp	r0, r5
    52a4:	4a40      	ldr	r2, [pc, #256]	; (53a8 <grid_port_process_inbound+0x1a0>)
    52a6:	f242 7c3c 	movw	ip, #10044	; 0x273c
    52aa:	d20f      	bcs.n	52cc <grid_port_process_inbound+0xc4>
					grid_sys_alert_set_alert(&grid_sys_state, 100,100,0,2,200);
    52ac:	2302      	movs	r3, #2
    52ae:	22c8      	movs	r2, #200	; 0xc8
    52b0:	e9cd 3200 	strd	r3, r2, [sp]
    52b4:	2264      	movs	r2, #100	; 0x64
    52b6:	483e      	ldr	r0, [pc, #248]	; (53b0 <grid_port_process_inbound+0x1a8>)
    52b8:	4c3e      	ldr	r4, [pc, #248]	; (53b4 <grid_port_process_inbound+0x1ac>)
    52ba:	2300      	movs	r3, #0
    52bc:	4611      	mov	r1, r2
    52be:	47a0      	blx	r4
					return 0;
    52c0:	46dd      	mov	sp, fp
		}	

		return 1;
	}
		
}
    52c2:	4648      	mov	r0, r9
    52c4:	373c      	adds	r7, #60	; 0x3c
    52c6:	46bd      	mov	sp, r7
    52c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (uint8_t i=0; i<port_count; i++)
    52cc:	3101      	adds	r1, #1
    52ce:	e7d7      	b.n	5280 <grid_port_process_inbound+0x78>
			if (port_array[i] != por || loopback){
    52d0:	f85a 0029 	ldr.w	r0, [sl, r9, lsl #2]
    52d4:	42b0      	cmp	r0, r6
    52d6:	d101      	bne.n	52dc <grid_port_process_inbound+0xd4>
    52d8:	6879      	ldr	r1, [r7, #4]
    52da:	b129      	cbz	r1, 52e8 <grid_port_process_inbound+0xe0>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52dc:	4418      	add	r0, r3
    52de:	4629      	mov	r1, r5
    52e0:	4790      	blx	r2
    52e2:	4a35      	ldr	r2, [pc, #212]	; (53b8 <grid_port_process_inbound+0x1b0>)
    52e4:	f242 733c 	movw	r3, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52e8:	f109 0901 	add.w	r9, r9, #1
    52ec:	fa5f f189 	uxtb.w	r1, r9
    52f0:	428c      	cmp	r4, r1
    52f2:	d8ed      	bhi.n	52d0 <grid_port_process_inbound+0xc8>
    52f4:	f04f 0a00 	mov.w	sl, #0
		for (uint16_t j=0; j<packet_size; j++)
    52f8:	fa1f f38a 	uxth.w	r3, sl
    52fc:	429d      	cmp	r5, r3
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52fe:	4640      	mov	r0, r8
		for (uint16_t j=0; j<packet_size; j++)
    5300:	d816      	bhi.n	5330 <grid_port_process_inbound+0x128>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    5302:	4b2e      	ldr	r3, [pc, #184]	; (53bc <grid_port_process_inbound+0x1b4>)
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5304:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 53c8 <grid_port_process_inbound+0x1c0>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    5308:	4798      	blx	r3
			if (port_array[i] != por || loopback){
    530a:	f107 0520 	add.w	r5, r7, #32
		for (uint8_t i=0; i<port_count; i++)
    530e:	2100      	movs	r1, #0
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5310:	f242 783c 	movw	r8, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5314:	b2cb      	uxtb	r3, r1
    5316:	429c      	cmp	r4, r3
    5318:	d82c      	bhi.n	5374 <grid_port_process_inbound+0x16c>
		return 1;
    531a:	f04f 0901 	mov.w	r9, #1
    531e:	e7cf      	b.n	52c0 <grid_port_process_inbound+0xb8>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    5320:	4a25      	ldr	r2, [pc, #148]	; (53b8 <grid_port_process_inbound+0x1b0>)
    5322:	f04f 0900 	mov.w	r9, #0
			if (port_array[i] != por || loopback){
    5326:	f107 0a20 	add.w	sl, r7, #32
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    532a:	f242 733c 	movw	r3, #10044	; 0x273c
    532e:	e7dd      	b.n	52ec <grid_port_process_inbound+0xe4>
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    5330:	4b23      	ldr	r3, [pc, #140]	; (53c0 <grid_port_process_inbound+0x1b8>)
    5332:	4798      	blx	r3
			for (uint8_t i=0; i<port_count; i++){
    5334:	f04f 0900 	mov.w	r9, #0
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    5338:	4601      	mov	r1, r0
				if (port_array[i] != por || loopback){
    533a:	f107 0320 	add.w	r3, r7, #32
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    533e:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    5342:	fa5f f089 	uxtb.w	r0, r9
    5346:	4284      	cmp	r4, r0
    5348:	d802      	bhi.n	5350 <grid_port_process_inbound+0x148>
		for (uint16_t j=0; j<packet_size; j++)
    534a:	f10a 0a01 	add.w	sl, sl, #1
    534e:	e7d3      	b.n	52f8 <grid_port_process_inbound+0xf0>
				if (port_array[i] != por || loopback){
    5350:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
    5354:	42b0      	cmp	r0, r6
    5356:	d101      	bne.n	535c <grid_port_process_inbound+0x154>
    5358:	687a      	ldr	r2, [r7, #4]
    535a:	b142      	cbz	r2, 536e <grid_port_process_inbound+0x166>
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    535c:	4b19      	ldr	r3, [pc, #100]	; (53c4 <grid_port_process_inbound+0x1bc>)
    535e:	6039      	str	r1, [r7, #0]
    5360:	4460      	add	r0, ip
    5362:	4798      	blx	r3
    5364:	6839      	ldr	r1, [r7, #0]
    5366:	f107 0320 	add.w	r3, r7, #32
    536a:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    536e:	f109 0901 	add.w	r9, r9, #1
    5372:	e7e6      	b.n	5342 <grid_port_process_inbound+0x13a>
			if (port_array[i] != por || loopback){
    5374:	f855 0021 	ldr.w	r0, [r5, r1, lsl #2]
    5378:	42b0      	cmp	r0, r6
    537a:	d101      	bne.n	5380 <grid_port_process_inbound+0x178>
    537c:	687b      	ldr	r3, [r7, #4]
    537e:	b10b      	cbz	r3, 5384 <grid_port_process_inbound+0x17c>
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5380:	4440      	add	r0, r8
    5382:	47c8      	blx	r9
		for (uint8_t i=0; i<port_count; i++)
    5384:	3101      	adds	r1, #1
    5386:	e7c5      	b.n	5314 <grid_port_process_inbound+0x10c>
		return 0;
    5388:	4681      	mov	r9, r0
    538a:	e79a      	b.n	52c2 <grid_port_process_inbound+0xba>
    538c:	00004f05 	.word	0x00004f05
    5390:	20009150 	.word	0x20009150
    5394:	20019870 	.word	0x20019870
    5398:	200138d4 	.word	0x200138d4
    539c:	200102d4 	.word	0x200102d4
    53a0:	2000c0b0 	.word	0x2000c0b0
    53a4:	20016824 	.word	0x20016824
    53a8:	00004821 	.word	0x00004821
    53ac:	00004f5b 	.word	0x00004f5b
    53b0:	2000f008 	.word	0x2000f008
    53b4:	00009813 	.word	0x00009813
    53b8:	00004839 	.word	0x00004839
    53bc:	00004fed 	.word	0x00004fed
    53c0:	00004fc3 	.word	0x00004fc3
    53c4:	00004875 	.word	0x00004875
    53c8:	00004895 	.word	0x00004895

000053cc <grid_port_process_outbound_usb>:



//=============================== PROCESS OUTBOUND ==============================//

uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    53cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			

	// OLD DEBUG IMPLEMENTATION
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    53d0:	f500 551c 	add.w	r5, r0, #9984	; 0x2700
    53d4:	353c      	adds	r5, #60	; 0x3c
    53d6:	4ba7      	ldr	r3, [pc, #668]	; (5674 <grid_port_process_outbound_usb+0x2a8>)
uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    53d8:	b0ed      	sub	sp, #436	; 0x1b4
    53da:	4680      	mov	r8, r0
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    53dc:	4628      	mov	r0, r5
    53de:	4798      	blx	r3
	
	if (!length){		
    53e0:	4604      	mov	r4, r0
    53e2:	b910      	cbnz	r0, 53ea <grid_port_process_outbound_usb+0x1e>
			
	// Let's send the packet through USB
	cdcdf_acm_write(por->tx_double_buffer, packet_length);

	
}
    53e4:	b06d      	add	sp, #436	; 0x1b4
    53e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    53ea:	f108 0b2c 	add.w	fp, r8, #44	; 0x2c
    53ee:	f508 539d 	add.w	r3, r8, #5024	; 0x13a0
    53f2:	3314      	adds	r3, #20
	if (!length){		
    53f4:	465a      	mov	r2, fp
		por->tx_double_buffer[i] = 0;
    53f6:	2100      	movs	r1, #0
    53f8:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    53fc:	429a      	cmp	r2, r3
    53fe:	d1fb      	bne.n	53f8 <grid_port_process_outbound_usb+0x2c>
	grid_msg_init(&message);
    5400:	4b9d      	ldr	r3, [pc, #628]	; (5678 <grid_port_process_outbound_usb+0x2ac>)
		grid_msg_packet_receive_char(&message, nextchar);
    5402:	f8df 92b8 	ldr.w	r9, [pc, #696]	; 56bc <grid_port_process_outbound_usb+0x2f0>
	grid_msg_init(&message);
    5406:	a805      	add	r0, sp, #20
    5408:	4798      	blx	r3
	grid_buffer_read_init(&por->tx_buffer);
    540a:	4b9c      	ldr	r3, [pc, #624]	; (567c <grid_port_process_outbound_usb+0x2b0>)
    540c:	4628      	mov	r0, r5
    540e:	4798      	blx	r3
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    5410:	4b9b      	ldr	r3, [pc, #620]	; (5680 <grid_port_process_outbound_usb+0x2b4>)
	for (uint16_t i = 0; i<length; i++){
    5412:	46da      	mov	sl, fp
    5414:	2700      	movs	r7, #0
    5416:	b2ba      	uxth	r2, r7
    5418:	4294      	cmp	r4, r2
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    541a:	4628      	mov	r0, r5
	for (uint16_t i = 0; i<length; i++){
    541c:	d825      	bhi.n	546a <grid_port_process_outbound_usb+0x9e>
	grid_buffer_read_acknowledge(&por->tx_buffer);
    541e:	4b99      	ldr	r3, [pc, #612]	; (5684 <grid_port_process_outbound_usb+0x2b8>)
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5420:	4c99      	ldr	r4, [pc, #612]	; (5688 <grid_port_process_outbound_usb+0x2bc>)
	grid_buffer_read_acknowledge(&por->tx_buffer);
    5422:	4798      	blx	r3
	int8_t dx = grid_msg_header_get_dx(&message) - GRID_SYS_DEFAULT_POSITION;
    5424:	4b99      	ldr	r3, [pc, #612]	; (568c <grid_port_process_outbound_usb+0x2c0>)
    5426:	a805      	add	r0, sp, #20
    5428:	4798      	blx	r3
    542a:	387f      	subs	r0, #127	; 0x7f
    542c:	b243      	sxtb	r3, r0
    542e:	9300      	str	r3, [sp, #0]
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    5430:	a805      	add	r0, sp, #20
    5432:	4b97      	ldr	r3, [pc, #604]	; (5690 <grid_port_process_outbound_usb+0x2c4>)
    5434:	4798      	blx	r3
    5436:	387f      	subs	r0, #127	; 0x7f
    5438:	b243      	sxtb	r3, r0
	for (uint16_t i=0; i<message.body_length; i++){
    543a:	f04f 0a00 	mov.w	sl, #0
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    543e:	9301      	str	r3, [sp, #4]
	uint8_t current_start		= 0;
    5440:	4656      	mov	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    5442:	9a6a      	ldr	r2, [sp, #424]	; 0x1a8
    5444:	fa1f f38a 	uxth.w	r3, sl
    5448:	429a      	cmp	r2, r3
    544a:	d818      	bhi.n	547e <grid_port_process_outbound_usb+0xb2>
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    544c:	4b91      	ldr	r3, [pc, #580]	; (5694 <grid_port_process_outbound_usb+0x2c8>)
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    544e:	4e92      	ldr	r6, [pc, #584]	; (5698 <grid_port_process_outbound_usb+0x2cc>)
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5450:	a805      	add	r0, sp, #20
    5452:	4798      	blx	r3
	for (uint32_t i=0; i<packet_length; i++){
    5454:	2400      	movs	r4, #0
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5456:	4605      	mov	r5, r0
	for (uint32_t i=0; i<packet_length; i++){
    5458:	42ac      	cmp	r4, r5
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    545a:	4621      	mov	r1, r4
	for (uint32_t i=0; i<packet_length; i++){
    545c:	f040 8104 	bne.w	5668 <grid_port_process_outbound_usb+0x29c>
	cdcdf_acm_write(por->tx_double_buffer, packet_length);
    5460:	4b8e      	ldr	r3, [pc, #568]	; (569c <grid_port_process_outbound_usb+0x2d0>)
    5462:	f108 002c 	add.w	r0, r8, #44	; 0x2c
    5466:	4798      	blx	r3
}
    5468:	e7bc      	b.n	53e4 <grid_port_process_outbound_usb+0x18>
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    546a:	4798      	blx	r3
    546c:	4606      	mov	r6, r0
		grid_msg_packet_receive_char(&message, nextchar);
    546e:	4601      	mov	r1, r0
    5470:	a805      	add	r0, sp, #20
    5472:	47c8      	blx	r9
		por->tx_double_buffer[i] = nextchar;	
    5474:	3701      	adds	r7, #1
    5476:	f80a 6b01 	strb.w	r6, [sl], #1
	for (uint16_t i = 0; i<length; i++){
    547a:	4b81      	ldr	r3, [pc, #516]	; (5680 <grid_port_process_outbound_usb+0x2b4>)
    547c:	e7cb      	b.n	5416 <grid_port_process_outbound_usb+0x4a>
		if (message.body[i] == GRID_CONST_STX){
    547e:	aa05      	add	r2, sp, #20
    5480:	4413      	add	r3, r2
    5482:	7d1b      	ldrb	r3, [r3, #20]
    5484:	2b02      	cmp	r3, #2
    5486:	d104      	bne.n	5492 <grid_port_process_outbound_usb+0xc6>
			current_start = i;
    5488:	fa5f f68a 	uxtb.w	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    548c:	f10a 0a01 	add.w	sl, sl, #1
    5490:	e7d7      	b.n	5442 <grid_port_process_outbound_usb+0x76>
		else if (message.body[i] == GRID_CONST_ETX && current_start!=0){
    5492:	2b03      	cmp	r3, #3
    5494:	d1fa      	bne.n	548c <grid_port_process_outbound_usb+0xc0>
    5496:	b90e      	cbnz	r6, 549c <grid_port_process_outbound_usb+0xd0>
			current_start = 0;
    5498:	2600      	movs	r6, #0
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    549a:	e7f7      	b.n	548c <grid_port_process_outbound_usb+0xc0>
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    549c:	4631      	mov	r1, r6
    549e:	2201      	movs	r2, #1
    54a0:	a805      	add	r0, sp, #20
    54a2:	47a0      	blx	r4
    54a4:	4635      	mov	r5, r6
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    54a6:	2301      	movs	r3, #1
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    54a8:	b2c6      	uxtb	r6, r0
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    54aa:	2204      	movs	r2, #4
    54ac:	4629      	mov	r1, r5
    54ae:	a805      	add	r0, sp, #20
    54b0:	47a0      	blx	r4
    54b2:	b2c0      	uxtb	r0, r0
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54b4:	2e00      	cmp	r6, #0
    54b6:	d13f      	bne.n	5538 <grid_port_process_outbound_usb+0x16c>
    54b8:	280e      	cmp	r0, #14
    54ba:	d1ed      	bne.n	5498 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_offset,		GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_length);
    54bc:	4629      	mov	r1, r5
    54be:	2302      	movs	r3, #2
    54c0:	2205      	movs	r2, #5
    54c2:	a805      	add	r0, sp, #20
    54c4:	47a0      	blx	r4
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    54c6:	4629      	mov	r1, r5
    54c8:	2302      	movs	r3, #2
    54ca:	2207      	movs	r2, #7
    54cc:	a805      	add	r0, sp, #20
    54ce:	47a0      	blx	r4
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    54d0:	4629      	mov	r1, r5
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    54d2:	4681      	mov	r9, r0
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    54d4:	2302      	movs	r3, #2
    54d6:	2209      	movs	r2, #9
    54d8:	a805      	add	r0, sp, #20
    54da:	47a0      	blx	r4
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54dc:	4629      	mov	r1, r5
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    54de:	4607      	mov	r7, r0
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54e0:	2302      	movs	r3, #2
    54e2:	220b      	movs	r2, #11
    54e4:	a805      	add	r0, sp, #20
    54e6:	47a0      	blx	r4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54e8:	9901      	ldr	r1, [sp, #4]
    54ea:	4a6d      	ldr	r2, [pc, #436]	; (56a0 <grid_port_process_outbound_usb+0x2d4>)
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54ec:	f88d 000f 	strb.w	r0, [sp, #15]
				uint8_t midi_command = 	(midi_commandchannel&0xF0)>>4;
    54f0:	f3c9 1303 	ubfx	r3, r9, #4, #4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54f4:	7bd2      	ldrb	r2, [r2, #15]
				midievent.byte0 = 0<<4|midi_command;
    54f6:	f88d 300c 	strb.w	r3, [sp, #12]
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54fa:	f1c1 0900 	rsb	r9, r1, #0
    54fe:	f009 0903 	and.w	r9, r9, #3
    5502:	eb09 0982 	add.w	r9, r9, r2, lsl #2
    5506:	f009 090f 	and.w	r9, r9, #15
				midievent.byte1 = midi_command<<4|midi_channel;
    550a:	ea49 1903 	orr.w	r9, r9, r3, lsl #4
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    550e:	b2ff      	uxtb	r7, r7
    5510:	9b00      	ldr	r3, [sp, #0]
				midievent.byte1 = midi_command<<4|midi_channel;
    5512:	f88d 900d 	strb.w	r9, [sp, #13]
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    5516:	37e0      	adds	r7, #224	; 0xe0
    5518:	2260      	movs	r2, #96	; 0x60
    551a:	eb07 1703 	add.w	r7, r7, r3, lsl #4
    551e:	fb97 f3f2 	sdiv	r3, r7, r2
    5522:	fb02 7713 	mls	r7, r2, r3, r7
    5526:	f88d 700e 	strb.w	r7, [sp, #14]
				grid_midi_tx_push(midievent);
    552a:	9803      	ldr	r0, [sp, #12]
    552c:	4b5d      	ldr	r3, [pc, #372]	; (56a4 <grid_port_process_outbound_usb+0x2d8>)
    552e:	4798      	blx	r3
				grid_midi_tx_pop(midievent);				
    5530:	9803      	ldr	r0, [sp, #12]
    5532:	4b5d      	ldr	r3, [pc, #372]	; (56a8 <grid_port_process_outbound_usb+0x2dc>)
    5534:	4798      	blx	r3
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5536:	e7a9      	b.n	548c <grid_port_process_outbound_usb+0xc0>
			else if (msg_class == GRID_CLASS_MIDIABSOLUTE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5538:	2e01      	cmp	r6, #1
    553a:	d127      	bne.n	558c <grid_port_process_outbound_usb+0x1c0>
    553c:	280e      	cmp	r0, #14
    553e:	d1ab      	bne.n	5498 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5540:	4629      	mov	r1, r5
    5542:	2302      	movs	r3, #2
    5544:	2205      	movs	r2, #5
    5546:	a805      	add	r0, sp, #20
    5548:	47a0      	blx	r4
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    554a:	4629      	mov	r1, r5
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    554c:	4681      	mov	r9, r0
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    554e:	2302      	movs	r3, #2
    5550:	2207      	movs	r2, #7
    5552:	a805      	add	r0, sp, #20
    5554:	47a0      	blx	r4
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5556:	4629      	mov	r1, r5
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5558:	4607      	mov	r7, r0
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    555a:	2302      	movs	r3, #2
    555c:	2209      	movs	r2, #9
    555e:	a805      	add	r0, sp, #20
    5560:	47a0      	blx	r4
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5562:	220b      	movs	r2, #11
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5564:	4606      	mov	r6, r0
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5566:	4629      	mov	r1, r5
    5568:	2302      	movs	r3, #2
    556a:	a805      	add	r0, sp, #20
    556c:	47a0      	blx	r4
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    556e:	f88d 900c 	strb.w	r9, [sp, #12]
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5572:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5576:	f88d 600e 	strb.w	r6, [sp, #14]
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    557a:	f88d 000f 	strb.w	r0, [sp, #15]
				grid_midi_tx_push(midievent);
    557e:	9803      	ldr	r0, [sp, #12]
    5580:	4b48      	ldr	r3, [pc, #288]	; (56a4 <grid_port_process_outbound_usb+0x2d8>)
    5582:	4798      	blx	r3
				grid_midi_tx_pop(midievent);	
    5584:	9803      	ldr	r0, [sp, #12]
    5586:	4b48      	ldr	r3, [pc, #288]	; (56a8 <grid_port_process_outbound_usb+0x2dc>)
    5588:	4798      	blx	r3
    558a:	e785      	b.n	5498 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    558c:	2e90      	cmp	r6, #144	; 0x90
    558e:	d11d      	bne.n	55cc <grid_port_process_outbound_usb+0x200>
    5590:	280e      	cmp	r0, #14
    5592:	d181      	bne.n	5498 <grid_port_process_outbound_usb+0xcc>
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5594:	4629      	mov	r1, r5
    5596:	2302      	movs	r3, #2
    5598:	2205      	movs	r2, #5
    559a:	a805      	add	r0, sp, #20
    559c:	47a0      	blx	r4
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    559e:	4629      	mov	r1, r5
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    55a0:	4607      	mov	r7, r0
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    55a2:	2302      	movs	r3, #2
    55a4:	2207      	movs	r2, #7
    55a6:	a805      	add	r0, sp, #20
    55a8:	47a0      	blx	r4
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    55aa:	4629      	mov	r1, r5
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    55ac:	4606      	mov	r6, r0
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    55ae:	2302      	movs	r3, #2
    55b0:	2209      	movs	r2, #9
    55b2:	a805      	add	r0, sp, #20
    55b4:	47a0      	blx	r4
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    55b6:	4b3d      	ldr	r3, [pc, #244]	; (56ac <grid_port_process_outbound_usb+0x2e0>)
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    55b8:	f88d 000e 	strb.w	r0, [sp, #14]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    55bc:	a903      	add	r1, sp, #12
    55be:	483c      	ldr	r0, [pc, #240]	; (56b0 <grid_port_process_outbound_usb+0x2e4>)
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    55c0:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    55c4:	f88d 600c 	strb.w	r6, [sp, #12]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    55c8:	4798      	blx	r3
    55ca:	e765      	b.n	5498 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYMACRO_code && msg_instr == GRID_INSTR_EXECUTE_code){
    55cc:	2e91      	cmp	r6, #145	; 0x91
    55ce:	f47f af63 	bne.w	5498 <grid_port_process_outbound_usb+0xcc>
    55d2:	280e      	cmp	r0, #14
    55d4:	f47f af60 	bne.w	5498 <grid_port_process_outbound_usb+0xcc>
    55d8:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55da:	2302      	movs	r3, #2
    55dc:	4632      	mov	r2, r6
    55de:	4629      	mov	r1, r5
    55e0:	a805      	add	r0, sp, #20
    55e2:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e4:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55e6:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e8:	2302      	movs	r3, #2
    55ea:	b2d2      	uxtb	r2, r2
    55ec:	4629      	mov	r1, r5
    55ee:	a805      	add	r0, sp, #20
    55f0:	47a0      	blx	r4
    55f2:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55f4:	28ff      	cmp	r0, #255	; 0xff
    55f6:	d00d      	beq.n	5614 <grid_port_process_outbound_usb+0x248>
                        key.ispressed = 1;
    55f8:	2201      	movs	r2, #1
    55fa:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    55fe:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    5600:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5602:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5606:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    560a:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    560c:	e893 0003 	ldmia.w	r3, {r0, r1}
    5610:	4b28      	ldr	r3, [pc, #160]	; (56b4 <grid_port_process_outbound_usb+0x2e8>)
    5612:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    5614:	3604      	adds	r6, #4
    5616:	b2f6      	uxtb	r6, r6
    5618:	2e1d      	cmp	r6, #29
    561a:	d1de      	bne.n	55da <grid_port_process_outbound_usb+0x20e>
                delay_ms(5);
    561c:	4b26      	ldr	r3, [pc, #152]	; (56b8 <grid_port_process_outbound_usb+0x2ec>)
    561e:	2005      	movs	r0, #5
    5620:	4798      	blx	r3
    5622:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5624:	2302      	movs	r3, #2
    5626:	4632      	mov	r2, r6
    5628:	4629      	mov	r1, r5
    562a:	a805      	add	r0, sp, #20
    562c:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    562e:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5630:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    5632:	2302      	movs	r3, #2
    5634:	b2d2      	uxtb	r2, r2
    5636:	4629      	mov	r1, r5
    5638:	a805      	add	r0, sp, #20
    563a:	47a0      	blx	r4
    563c:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    563e:	28ff      	cmp	r0, #255	; 0xff
    5640:	d00d      	beq.n	565e <grid_port_process_outbound_usb+0x292>
                        key.ispressed = 0;
    5642:	2200      	movs	r2, #0
    5644:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    5648:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    564a:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    564c:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5650:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    5654:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    5656:	e893 0003 	ldmia.w	r3, {r0, r1}
    565a:	4b16      	ldr	r3, [pc, #88]	; (56b4 <grid_port_process_outbound_usb+0x2e8>)
    565c:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    565e:	3604      	adds	r6, #4
    5660:	b2f6      	uxtb	r6, r6
    5662:	2e1d      	cmp	r6, #29
    5664:	d1de      	bne.n	5624 <grid_port_process_outbound_usb+0x258>
    5666:	e717      	b.n	5498 <grid_port_process_outbound_usb+0xcc>
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5668:	a805      	add	r0, sp, #20
    566a:	47b0      	blx	r6
	for (uint32_t i=0; i<packet_length; i++){
    566c:	3401      	adds	r4, #1
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    566e:	f80b 0b01 	strb.w	r0, [fp], #1
	for (uint32_t i=0; i<packet_length; i++){
    5672:	e6f1      	b.n	5458 <grid_port_process_outbound_usb+0x8c>
    5674:	00004f05 	.word	0x00004f05
    5678:	000085c5 	.word	0x000085c5
    567c:	00004f5b 	.word	0x00004f5b
    5680:	00004fc3 	.word	0x00004fc3
    5684:	00004fed 	.word	0x00004fed
    5688:	0000858d 	.word	0x0000858d
    568c:	00008481 	.word	0x00008481
    5690:	000084c1 	.word	0x000084c1
    5694:	00008521 	.word	0x00008521
    5698:	000086bb 	.word	0x000086bb
    569c:	0000bda1 	.word	0x0000bda1
    56a0:	2000f008 	.word	0x2000f008
    56a4:	0000af21 	.word	0x0000af21
    56a8:	0000af49 	.word	0x0000af49
    56ac:	0000ad59 	.word	0x0000ad59
    56b0:	20010264 	.word	0x20010264
    56b4:	0000b031 	.word	0x0000b031
    56b8:	0000dddd 	.word	0x0000dddd
    56bc:	0000866d 	.word	0x0000866d

000056c0 <grid_port_process_outbound_ui>:

uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    56c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    56c4:	ed2d 8b02 	vpush	{d8}
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    56c8:	f500 541c 	add.w	r4, r0, #9984	; 0x2700
    56cc:	343c      	adds	r4, #60	; 0x3c
uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    56ce:	f5ad 7d7b 	sub.w	sp, sp, #1004	; 0x3ec
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    56d2:	4bb5      	ldr	r3, [pc, #724]	; (59a8 <grid_port_process_outbound_ui+0x2e8>)
    56d4:	4620      	mov	r0, r4
    56d6:	4798      	blx	r3
	
	if (!length){
    56d8:	2500      	movs	r5, #0
    56da:	9006      	str	r0, [sp, #24]
    56dc:	b928      	cbnz	r0, 56ea <grid_port_process_outbound_ui+0x2a>

		
	}
	
	
}
    56de:	f50d 7d7b 	add.w	sp, sp, #1004	; 0x3ec
    56e2:	ecbd 8b02 	vpop	{d8}
    56e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56ea:	4bb0      	ldr	r3, [pc, #704]	; (59ac <grid_port_process_outbound_ui+0x2ec>)
    56ec:	952f      	str	r5, [sp, #188]	; 0xbc
    56ee:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    56f2:	4629      	mov	r1, r5
    56f4:	a830      	add	r0, sp, #192	; 0xc0
    56f6:	4798      	blx	r3
		grid_buffer_read_init(&por->tx_buffer);
    56f8:	4bad      	ldr	r3, [pc, #692]	; (59b0 <grid_port_process_outbound_ui+0x2f0>)
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56fa:	4fae      	ldr	r7, [pc, #696]	; (59b4 <grid_port_process_outbound_ui+0x2f4>)
		grid_buffer_read_init(&por->tx_buffer);
    56fc:	4620      	mov	r0, r4
    56fe:	4798      	blx	r3
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    5700:	ae2f      	add	r6, sp, #188	; 0xbc
		for (uint16_t i = 0; i<length; i++){
    5702:	9a06      	ldr	r2, [sp, #24]
    5704:	b2ab      	uxth	r3, r5
    5706:	429a      	cmp	r2, r3
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5708:	4620      	mov	r0, r4
		for (uint16_t i = 0; i<length; i++){
    570a:	d839      	bhi.n	5780 <grid_port_process_outbound_ui+0xc0>
		grid_buffer_read_acknowledge(&por->tx_buffer);
    570c:	4baa      	ldr	r3, [pc, #680]	; (59b8 <grid_port_process_outbound_ui+0x2f8>)
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    570e:	4fab      	ldr	r7, [pc, #684]	; (59bc <grid_port_process_outbound_ui+0x2fc>)
		grid_buffer_read_acknowledge(&por->tx_buffer);
    5710:	4798      	blx	r3
		uint8_t error=0;
    5712:	2500      	movs	r5, #0
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    5714:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    5718:	2202      	movs	r2, #2
    571a:	2106      	movs	r1, #6
    571c:	4630      	mov	r0, r6
		uint8_t error=0;
    571e:	f88d 5026 	strb.w	r5, [sp, #38]	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    5722:	47b8      	blx	r7
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    5724:	f10d 0326 	add.w	r3, sp, #38	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    5728:	fa5f fb80 	uxtb.w	fp, r0
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    572c:	2202      	movs	r2, #2
    572e:	2108      	movs	r1, #8
    5730:	4630      	mov	r0, r6
    5732:	47b8      	blx	r7
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    5734:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    5738:	b2c0      	uxtb	r0, r0
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    573a:	d125      	bne.n	5788 <grid_port_process_outbound_ui+0xc8>
			position_is_me = 1;
    573c:	f1a0 027f 	sub.w	r2, r0, #127	; 0x7f
    5740:	f1d2 0b00 	rsbs	fp, r2, #0
    5744:	eb4b 0b02 	adc.w	fp, fp, r2
		uint8_t position_is_local = 0;
    5748:	462c      	mov	r4, r5
		uint8_t position_is_global = 0;
    574a:	9502      	str	r5, [sp, #8]
		uint8_t error_flag = 0;	
    574c:	2300      	movs	r3, #0
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    574e:	4d9c      	ldr	r5, [pc, #624]	; (59c0 <grid_port_process_outbound_ui+0x300>)
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5750:	f8df a298 	ldr.w	sl, [pc, #664]	; 59ec <grid_port_process_outbound_ui+0x32c>
		uint8_t error_flag = 0;	
    5754:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5758:	9303      	str	r3, [sp, #12]
		uint8_t current_start		= 0;
    575a:	4698      	mov	r8, r3
			if (message[i] == GRID_CONST_STX){
    575c:	9b03      	ldr	r3, [sp, #12]
    575e:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
    5762:	f813 1009 	ldrb.w	r1, [r3, r9]
    5766:	2902      	cmp	r1, #2
    5768:	d120      	bne.n	57ac <grid_port_process_outbound_ui+0xec>
				current_start = i;
    576a:	f89d 800c 	ldrb.w	r8, [sp, #12]
		for (uint16_t i=0; i<length; i++){
    576e:	9b03      	ldr	r3, [sp, #12]
    5770:	9a06      	ldr	r2, [sp, #24]
    5772:	3301      	adds	r3, #1
    5774:	9303      	str	r3, [sp, #12]
    5776:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    577a:	429a      	cmp	r2, r3
    577c:	d8ee      	bhi.n	575c <grid_port_process_outbound_ui+0x9c>
    577e:	e7ae      	b.n	56de <grid_port_process_outbound_ui+0x1e>
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5780:	47b8      	blx	r7
    5782:	5570      	strb	r0, [r6, r5]
		for (uint16_t i = 0; i<length; i++){
    5784:	3501      	adds	r5, #1
    5786:	e7bc      	b.n	5702 <grid_port_process_outbound_ui+0x42>
		else if (dx == GRID_SYS_GLOBAL_POSITION && dy==GRID_SYS_GLOBAL_POSITION){
    5788:	f1bb 0f00 	cmp.w	fp, #0
    578c:	d105      	bne.n	579a <grid_port_process_outbound_ui+0xda>
		uint8_t position_is_global = 0;
    578e:	fab0 f380 	clz	r3, r0
    5792:	095b      	lsrs	r3, r3, #5
    5794:	9302      	str	r3, [sp, #8]
		uint8_t position_is_local = 0;
    5796:	465c      	mov	r4, fp
    5798:	e7d8      	b.n	574c <grid_port_process_outbound_ui+0x8c>
		else if (dx == GRID_SYS_LOCAL_POSITION && dy==GRID_SYS_LOCAL_POSITION){
    579a:	ea0b 0000 	and.w	r0, fp, r0
    579e:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    57a2:	425c      	negs	r4, r3
    57a4:	415c      	adcs	r4, r3
		uint8_t position_is_global = 0;
    57a6:	46ab      	mov	fp, r5
		uint8_t position_is_me = 0;
    57a8:	9502      	str	r5, [sp, #8]
    57aa:	e7cf      	b.n	574c <grid_port_process_outbound_ui+0x8c>
			else if (message[i] == GRID_CONST_ETX && current_start!=0){
    57ac:	2903      	cmp	r1, #3
    57ae:	d1de      	bne.n	576e <grid_port_process_outbound_ui+0xae>
    57b0:	f1b8 0f00 	cmp.w	r8, #0
    57b4:	d102      	bne.n	57bc <grid_port_process_outbound_ui+0xfc>
				current_start = 0;
    57b6:	f04f 0800 	mov.w	r8, #0
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    57ba:	e7d8      	b.n	576e <grid_port_process_outbound_ui+0xae>
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    57bc:	f108 0001 	add.w	r0, r8, #1
    57c0:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57c4:	4448      	add	r0, r9
    57c6:	47a8      	blx	r5
    57c8:	b2c6      	uxtb	r6, r0
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    57ca:	f108 0004 	add.w	r0, r8, #4
    57ce:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57d2:	2101      	movs	r1, #1
    57d4:	4448      	add	r0, r9
    57d6:	47a8      	blx	r5
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    57d8:	2e30      	cmp	r6, #48	; 0x30
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    57da:	b2c7      	uxtb	r7, r0
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    57dc:	d126      	bne.n	582c <grid_port_process_outbound_ui+0x16c>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57de:	f108 0005 	add.w	r0, r8, #5
    57e2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57e6:	2102      	movs	r1, #2
    57e8:	4448      	add	r0, r9
    57ea:	47a8      	blx	r5
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57ec:	2f0e      	cmp	r7, #14
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57ee:	4606      	mov	r6, r0
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57f0:	d10e      	bne.n	5810 <grid_port_process_outbound_ui+0x150>
						if (grid_sys_get_bank_valid(&grid_sys_state) == 0){
    57f2:	4874      	ldr	r0, [pc, #464]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    57f4:	4b74      	ldr	r3, [pc, #464]	; (59c8 <grid_port_process_outbound_ui+0x308>)
    57f6:	4798      	blx	r3
    57f8:	4602      	mov	r2, r0
    57fa:	b920      	cbnz	r0, 5806 <grid_port_process_outbound_ui+0x146>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
    57fc:	4601      	mov	r1, r0
    57fe:	4f73      	ldr	r7, [pc, #460]	; (59cc <grid_port_process_outbound_ui+0x30c>)
    5800:	4873      	ldr	r0, [pc, #460]	; (59d0 <grid_port_process_outbound_ui+0x310>)
    5802:	230c      	movs	r3, #12
    5804:	47b8      	blx	r7
						grid_sys_set_bank(&grid_sys_state, banknumber);
    5806:	486f      	ldr	r0, [pc, #444]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5808:	b2f1      	uxtb	r1, r6
								grid_sys_set_bank(&grid_sys_state, banknumber);
    580a:	4b72      	ldr	r3, [pc, #456]	; (59d4 <grid_port_process_outbound_ui+0x314>)
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    580c:	4798      	blx	r3
    580e:	e7d2      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
					else if (msg_instr == GRID_INSTR_FETCH_code){ //GET BANK
    5810:	2f0f      	cmp	r7, #15
    5812:	d1d0      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_valid(&grid_sys_state) != 0){
    5814:	486b      	ldr	r0, [pc, #428]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5816:	4b6c      	ldr	r3, [pc, #432]	; (59c8 <grid_port_process_outbound_ui+0x308>)
    5818:	4798      	blx	r3
    581a:	2800      	cmp	r0, #0
    581c:	d0cb      	beq.n	57b6 <grid_port_process_outbound_ui+0xf6>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
    581e:	2200      	movs	r2, #0
    5820:	486b      	ldr	r0, [pc, #428]	; (59d0 <grid_port_process_outbound_ui+0x310>)
    5822:	4e6a      	ldr	r6, [pc, #424]	; (59cc <grid_port_process_outbound_ui+0x30c>)
    5824:	2309      	movs	r3, #9
    5826:	4611      	mov	r1, r2
    5828:	47b0      	blx	r6
    582a:	e7c4      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_BANKENABLED_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    582c:	2e31      	cmp	r6, #49	; 0x31
    582e:	d140      	bne.n	58b2 <grid_port_process_outbound_ui+0x1f2>
    5830:	2f0e      	cmp	r7, #14
    5832:	d1c0      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
    5834:	9b02      	ldr	r3, [sp, #8]
    5836:	ea4b 0303 	orr.w	r3, fp, r3
    583a:	4323      	orrs	r3, r4
    583c:	d0bb      	beq.n	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_BANKNUMBER_offset], GRID_CLASS_BANKENABLED_BANKNUMBER_length, &error_flag);
    583e:	f108 0005 	add.w	r0, r8, #5
    5842:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5846:	2102      	movs	r1, #2
    5848:	4448      	add	r0, r9
    584a:	47a8      	blx	r5
    584c:	b2c6      	uxtb	r6, r0
					uint8_t isenabled  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_ISENABLED_offset], GRID_CLASS_BANKENABLED_ISENABLED_length, &error_flag);
    584e:	f108 0007 	add.w	r0, r8, #7
    5852:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5856:	2102      	movs	r1, #2
    5858:	4448      	add	r0, r9
    585a:	47a8      	blx	r5
    585c:	fa5f f880 	uxtb.w	r8, r0
					if (isenabled == 1){
    5860:	f1b8 0f01 	cmp.w	r8, #1
    5864:	d110      	bne.n	5888 <grid_port_process_outbound_ui+0x1c8>
						grid_sys_bank_enable(&grid_sys_state, banknumber);
    5866:	4f57      	ldr	r7, [pc, #348]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5868:	4b5b      	ldr	r3, [pc, #364]	; (59d8 <grid_port_process_outbound_ui+0x318>)
    586a:	4631      	mov	r1, r6
    586c:	4638      	mov	r0, r7
    586e:	4798      	blx	r3
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5870:	4b5a      	ldr	r3, [pc, #360]	; (59dc <grid_port_process_outbound_ui+0x31c>)
    5872:	4638      	mov	r0, r7
    5874:	4798      	blx	r3
    5876:	42b0      	cmp	r0, r6
    5878:	d19d      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
							if (grid_sys_state.bank_activebank_valid == 1){
    587a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    587e:	2b01      	cmp	r3, #1
    5880:	d199      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
								grid_sys_set_bank(&grid_sys_state, banknumber);
    5882:	4631      	mov	r1, r6
    5884:	4638      	mov	r0, r7
    5886:	e7c0      	b.n	580a <grid_port_process_outbound_ui+0x14a>
					}else if (isenabled == 0){	
    5888:	f1b8 0f00 	cmp.w	r8, #0
    588c:	d193      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    588e:	484d      	ldr	r0, [pc, #308]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5890:	4b52      	ldr	r3, [pc, #328]	; (59dc <grid_port_process_outbound_ui+0x31c>)
    5892:	4798      	blx	r3
    5894:	42b0      	cmp	r0, r6
    5896:	d107      	bne.n	58a8 <grid_port_process_outbound_ui+0x1e8>
							if (grid_sys_state.bank_activebank_valid == 1){
    5898:	484a      	ldr	r0, [pc, #296]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    589a:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    589e:	2b01      	cmp	r3, #1
    58a0:	d102      	bne.n	58a8 <grid_port_process_outbound_ui+0x1e8>
								grid_sys_set_bank(&grid_sys_state, 255);
    58a2:	4b4c      	ldr	r3, [pc, #304]	; (59d4 <grid_port_process_outbound_ui+0x314>)
    58a4:	21ff      	movs	r1, #255	; 0xff
    58a6:	4798      	blx	r3
						grid_sys_bank_disable(&grid_sys_state, banknumber);
    58a8:	4b4d      	ldr	r3, [pc, #308]	; (59e0 <grid_port_process_outbound_ui+0x320>)
    58aa:	4846      	ldr	r0, [pc, #280]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    58ac:	4631      	mov	r1, r6
    58ae:	4798      	blx	r3
    58b0:	e75d      	b.n	576e <grid_port_process_outbound_ui+0xae>
				else if (msg_class == GRID_CLASS_BANKCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    58b2:	2e32      	cmp	r6, #50	; 0x32
    58b4:	d147      	bne.n	5946 <grid_port_process_outbound_ui+0x286>
    58b6:	2f0e      	cmp	r7, #14
    58b8:	f47f af7d 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    58bc:	9b02      	ldr	r3, [sp, #8]
    58be:	ea4b 0303 	orr.w	r3, fp, r3
    58c2:	4323      	orrs	r3, r4
    58c4:	f43f af77 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    58c8:	f108 0005 	add.w	r0, r8, #5
    58cc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58d0:	2102      	movs	r1, #2
    58d2:	4448      	add	r0, r9
    58d4:	47a8      	blx	r5
    58d6:	b2c3      	uxtb	r3, r0
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58d8:	f108 0007 	add.w	r0, r8, #7
    58dc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58e0:	2102      	movs	r1, #2
    58e2:	4448      	add	r0, r9
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    58e4:	ee08 3a10 	vmov	s16, r3
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58e8:	47a8      	blx	r5
    58ea:	4606      	mov	r6, r0
					uint8_t green	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_GRE_offset], GRID_CLASS_BANKCOLOR_GRE_length, &error_flag);
    58ec:	f108 0009 	add.w	r0, r8, #9
    58f0:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58f4:	2102      	movs	r1, #2
    58f6:	4448      	add	r0, r9
    58f8:	47a8      	blx	r5
    58fa:	4607      	mov	r7, r0
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58fc:	f108 000b 	add.w	r0, r8, #11
    5900:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5904:	2102      	movs	r1, #2
    5906:	4448      	add	r0, r9
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    5908:	0436      	lsls	r6, r6, #16
    590a:	023f      	lsls	r7, r7, #8
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    590c:	47a8      	blx	r5
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    590e:	b2bf      	uxth	r7, r7
    5910:	f406 067f 	and.w	r6, r6, #16711680	; 0xff0000
    5914:	433e      	orrs	r6, r7
    5916:	4f2b      	ldr	r7, [pc, #172]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5918:	4b32      	ldr	r3, [pc, #200]	; (59e4 <grid_port_process_outbound_ui+0x324>)
    591a:	fa56 f280 	uxtab	r2, r6, r0
    591e:	ee18 1a10 	vmov	r1, s16
    5922:	4638      	mov	r0, r7
    5924:	4798      	blx	r3
					if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5926:	4b2d      	ldr	r3, [pc, #180]	; (59dc <grid_port_process_outbound_ui+0x31c>)
    5928:	4638      	mov	r0, r7
    592a:	4798      	blx	r3
    592c:	ee18 3a10 	vmov	r3, s16
    5930:	4298      	cmp	r0, r3
    5932:	f47f af40 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_state.bank_activebank_valid == 1){
    5936:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    593a:	2b01      	cmp	r3, #1
    593c:	f47f af3b 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
							grid_sys_set_bank(&grid_sys_state, banknumber);
    5940:	ee18 1a10 	vmov	r1, s16
    5944:	e79e      	b.n	5884 <grid_port_process_outbound_ui+0x1c4>
				else if (msg_class == GRID_CLASS_LEDPHASE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    5946:	2e40      	cmp	r6, #64	; 0x40
    5948:	d154      	bne.n	59f4 <grid_port_process_outbound_ui+0x334>
    594a:	2f0e      	cmp	r7, #14
    594c:	f47f af33 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5950:	ea5b 0304 	orrs.w	r3, fp, r4
    5954:	f43f af2f 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_NUM_offset], GRID_CLASS_LEDPHASE_NUM_length, &error_flag);
    5958:	f108 0005 	add.w	r0, r8, #5
    595c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5960:	2102      	movs	r1, #2
    5962:	4448      	add	r0, r9
    5964:	47a8      	blx	r5
    5966:	b2c6      	uxtb	r6, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_LAY_offset], GRID_CLASS_LEDPHASE_LAY_length, &error_flag);
    5968:	f108 0007 	add.w	r0, r8, #7
    596c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5970:	2102      	movs	r1, #2
    5972:	4448      	add	r0, r9
    5974:	47a8      	blx	r5
    5976:	b2c7      	uxtb	r7, r0
					uint16_t led_pha  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_PHA_offset], GRID_CLASS_LEDPHASE_PHA_length, &error_flag);
    5978:	f108 0009 	add.w	r0, r8, #9
    597c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5980:	2102      	movs	r1, #2
    5982:	4448      	add	r0, r9
    5984:	47a8      	blx	r5
					if (led_pha*2 > 255){
    5986:	b283      	uxth	r3, r0
    5988:	005b      	lsls	r3, r3, #1
    598a:	2bff      	cmp	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    598c:	bfdc      	itt	le
    598e:	0040      	lslle	r0, r0, #1
    5990:	f000 03fe 	andle.w	r3, r0, #254	; 0xfe
    5994:	f8df 8058 	ldr.w	r8, [pc, #88]	; 59f0 <grid_port_process_outbound_ui+0x330>
    5998:	4813      	ldr	r0, [pc, #76]	; (59e8 <grid_port_process_outbound_ui+0x328>)
						grid_led_set_phase(&grid_led_state, led_num, led_lay, 255);
    599a:	bfc8      	it	gt
    599c:	23ff      	movgt	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    599e:	463a      	mov	r2, r7
    59a0:	4631      	mov	r1, r6
    59a2:	47c0      	blx	r8
    59a4:	e707      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
    59a6:	bf00      	nop
    59a8:	00004f05 	.word	0x00004f05
    59ac:	00014469 	.word	0x00014469
    59b0:	00004f5b 	.word	0x00004f5b
    59b4:	00004fc3 	.word	0x00004fc3
    59b8:	00004fed 	.word	0x00004fed
    59bc:	00009a15 	.word	0x00009a15
    59c0:	00009861 	.word	0x00009861
    59c4:	2000f008 	.word	0x2000f008
    59c8:	0000970b 	.word	0x0000970b
    59cc:	0000a191 	.word	0x0000a191
    59d0:	2001c7c0 	.word	0x2001c7c0
    59d4:	00009763 	.word	0x00009763
    59d8:	000096d9 	.word	0x000096d9
    59dc:	00009707 	.word	0x00009707
    59e0:	000096e5 	.word	0x000096e5
    59e4:	000096f1 	.word	0x000096f1
    59e8:	2001c838 	.word	0x2001c838
    59ec:	2000effc 	.word	0x2000effc
    59f0:	00006d91 	.word	0x00006d91
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    59f4:	2e41      	cmp	r6, #65	; 0x41
    59f6:	d13a      	bne.n	5a6e <grid_port_process_outbound_ui+0x3ae>
    59f8:	2f0e      	cmp	r7, #14
    59fa:	f47f aedc 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    59fe:	ea5b 0304 	orrs.w	r3, fp, r4
    5a02:	f43f aed8 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_NUM_offset], GRID_CLASS_LEDCOLOR_NUM_length, &error_flag);
    5a06:	f108 0005 	add.w	r0, r8, #5
    5a0a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a0e:	2102      	movs	r1, #2
    5a10:	4448      	add	r0, r9
    5a12:	47a8      	blx	r5
    5a14:	4607      	mov	r7, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_LAY_offset], GRID_CLASS_LEDCOLOR_LAY_length, &error_flag);
    5a16:	f108 0007 	add.w	r0, r8, #7
    5a1a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a1e:	2102      	movs	r1, #2
    5a20:	4448      	add	r0, r9
    5a22:	47a8      	blx	r5
    5a24:	9004      	str	r0, [sp, #16]
					uint8_t led_red	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_RED_offset], GRID_CLASS_LEDCOLOR_RED_length, &error_flag);
    5a26:	f108 0009 	add.w	r0, r8, #9
    5a2a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a2e:	2102      	movs	r1, #2
    5a30:	4448      	add	r0, r9
    5a32:	47a8      	blx	r5
    5a34:	9005      	str	r0, [sp, #20]
					uint8_t led_gre	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_GRE_offset], GRID_CLASS_LEDCOLOR_GRE_length, &error_flag);
    5a36:	f108 000b 	add.w	r0, r8, #11
    5a3a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a3e:	2102      	movs	r1, #2
    5a40:	4448      	add	r0, r9
    5a42:	47a8      	blx	r5
    5a44:	4606      	mov	r6, r0
					uint8_t led_blu	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_BLU_offset], GRID_CLASS_LEDCOLOR_BLU_length, &error_flag);
    5a46:	f108 000d 	add.w	r0, r8, #13
    5a4a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a4e:	2102      	movs	r1, #2
    5a50:	4448      	add	r0, r9
    5a52:	47a8      	blx	r5
					grid_led_set_color(&grid_led_state, led_num, led_lay, led_red, led_gre, led_blu);
    5a54:	9b05      	ldr	r3, [sp, #20]
    5a56:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5a5a:	b2c0      	uxtb	r0, r0
    5a5c:	b2f6      	uxtb	r6, r6
    5a5e:	9001      	str	r0, [sp, #4]
    5a60:	9600      	str	r6, [sp, #0]
    5a62:	48a9      	ldr	r0, [pc, #676]	; (5d08 <grid_port_process_outbound_ui+0x648>)
    5a64:	4ea9      	ldr	r6, [pc, #676]	; (5d0c <grid_port_process_outbound_ui+0x64c>)
    5a66:	b2db      	uxtb	r3, r3
    5a68:	b2f9      	uxtb	r1, r7
    5a6a:	47b0      	blx	r6
    5a6c:	e6a3      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if(msg_class == GRID_CLASS_SERIALNUMBER_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5a6e:	2e11      	cmp	r6, #17
    5a70:	d15d      	bne.n	5b2e <grid_port_process_outbound_ui+0x46e>
    5a72:	2f0f      	cmp	r7, #15
    5a74:	f47f ae9f 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5a78:	9b02      	ldr	r3, [sp, #8]
    5a7a:	ea5b 0303 	orrs.w	r3, fp, r3
    5a7e:	f43f ae9a 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint32_t uniqueid[4] = {0};
    5a82:	2210      	movs	r2, #16
    5a84:	2100      	movs	r1, #0
    5a86:	4fa2      	ldr	r7, [pc, #648]	; (5d10 <grid_port_process_outbound_ui+0x650>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a88:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 5d38 <grid_port_process_outbound_ui+0x678>
					uint32_t uniqueid[4] = {0};
    5a8c:	a80a      	add	r0, sp, #40	; 0x28
    5a8e:	47b8      	blx	r7
					grid_sys_get_id(uniqueid);					
    5a90:	4ba0      	ldr	r3, [pc, #640]	; (5d14 <grid_port_process_outbound_ui+0x654>)
    5a92:	a80a      	add	r0, sp, #40	; 0x28
    5a94:	4798      	blx	r3
					grid_msg_init(&response);
    5a96:	4ba0      	ldr	r3, [pc, #640]	; (5d18 <grid_port_process_outbound_ui+0x658>)
    5a98:	a893      	add	r0, sp, #588	; 0x24c
    5a9a:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a9c:	227f      	movs	r2, #127	; 0x7f
    5a9e:	2300      	movs	r3, #0
    5aa0:	4611      	mov	r1, r2
    5aa2:	a893      	add	r0, sp, #588	; 0x24c
    5aa4:	47c0      	blx	r8
					uint8_t response_payload[50] = {0};
    5aa6:	f04f 0800 	mov.w	r8, #0
    5aaa:	222e      	movs	r2, #46	; 0x2e
    5aac:	4641      	mov	r1, r8
    5aae:	a80f      	add	r0, sp, #60	; 0x3c
    5ab0:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5ab4:	47b8      	blx	r7
					snprintf(response_payload, 49, GRID_CLASS_SERIALNUMBER_frame);
    5ab6:	2303      	movs	r3, #3
    5ab8:	e9cd 6300 	strd	r6, r3, [sp]
    5abc:	4a97      	ldr	r2, [pc, #604]	; (5d1c <grid_port_process_outbound_ui+0x65c>)
    5abe:	4e98      	ldr	r6, [pc, #608]	; (5d20 <grid_port_process_outbound_ui+0x660>)
    5ac0:	2131      	movs	r1, #49	; 0x31
    5ac2:	2302      	movs	r3, #2
    5ac4:	a80e      	add	r0, sp, #56	; 0x38
    5ac6:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5ac8:	4b96      	ldr	r3, [pc, #600]	; (5d24 <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5aca:	4e97      	ldr	r6, [pc, #604]	; (5d28 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5acc:	a80e      	add	r0, sp, #56	; 0x38
    5ace:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5ad0:	270d      	movs	r7, #13
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5ad2:	4602      	mov	r2, r0
    5ad4:	4b95      	ldr	r3, [pc, #596]	; (5d2c <grid_port_process_outbound_ui+0x66c>)
    5ad6:	a90e      	add	r1, sp, #56	; 0x38
    5ad8:	a893      	add	r0, sp, #588	; 0x24c
    5ada:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5adc:	2301      	movs	r3, #1
    5ade:	2204      	movs	r2, #4
    5ae0:	4641      	mov	r1, r8
    5ae2:	a893      	add	r0, sp, #588	; 0x24c
    5ae4:	9700      	str	r7, [sp, #0]
    5ae6:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD0_offset, GRID_CLASS_SERIALNUMBER_WORD0_length, uniqueid[0]);
    5ae8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5aea:	9300      	str	r3, [sp, #0]
    5aec:	2205      	movs	r2, #5
    5aee:	2308      	movs	r3, #8
    5af0:	4641      	mov	r1, r8
    5af2:	a893      	add	r0, sp, #588	; 0x24c
    5af4:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD1_offset, GRID_CLASS_SERIALNUMBER_WORD1_length, uniqueid[1]);
    5af6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5af8:	9300      	str	r3, [sp, #0]
    5afa:	463a      	mov	r2, r7
    5afc:	2308      	movs	r3, #8
    5afe:	4641      	mov	r1, r8
    5b00:	a893      	add	r0, sp, #588	; 0x24c
    5b02:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD2_offset, GRID_CLASS_SERIALNUMBER_WORD2_length, uniqueid[2]);
    5b04:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5b06:	9300      	str	r3, [sp, #0]
    5b08:	2215      	movs	r2, #21
    5b0a:	2308      	movs	r3, #8
    5b0c:	4641      	mov	r1, r8
    5b0e:	a893      	add	r0, sp, #588	; 0x24c
    5b10:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD3_offset, GRID_CLASS_SERIALNUMBER_WORD3_length, uniqueid[3]);
    5b12:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5b14:	9300      	str	r3, [sp, #0]
    5b16:	221d      	movs	r2, #29
    5b18:	2308      	movs	r3, #8
    5b1a:	4641      	mov	r1, r8
    5b1c:	a893      	add	r0, sp, #588	; 0x24c
    5b1e:	47b0      	blx	r6
					grid_msg_packet_close(&response);
    5b20:	4b83      	ldr	r3, [pc, #524]	; (5d30 <grid_port_process_outbound_ui+0x670>)
    5b22:	a893      	add	r0, sp, #588	; 0x24c
    5b24:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    5b26:	4b83      	ldr	r3, [pc, #524]	; (5d34 <grid_port_process_outbound_ui+0x674>)
    5b28:	a893      	add	r0, sp, #588	; 0x24c
    5b2a:	4798      	blx	r3
				else if(msg_class == GRID_CLASS_UPTIME_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5b2c:	e61f      	b.n	576e <grid_port_process_outbound_ui+0xae>
    5b2e:	2e14      	cmp	r6, #20
    5b30:	d13f      	bne.n	5bb2 <grid_port_process_outbound_ui+0x4f2>
    5b32:	2f0f      	cmp	r7, #15
    5b34:	f47f ae3f 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5b38:	9b02      	ldr	r3, [sp, #8]
    5b3a:	ea5b 0303 	orrs.w	r3, fp, r3
    5b3e:	f43f ae3a 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5b42:	4b75      	ldr	r3, [pc, #468]	; (5d18 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b44:	4f7c      	ldr	r7, [pc, #496]	; (5d38 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5b46:	a893      	add	r0, sp, #588	; 0x24c
    5b48:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b4a:	227f      	movs	r2, #127	; 0x7f
					uint8_t response_payload[50] = {0};
    5b4c:	f04f 0800 	mov.w	r8, #0
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b50:	4611      	mov	r1, r2
    5b52:	2300      	movs	r3, #0
    5b54:	a893      	add	r0, sp, #588	; 0x24c
    5b56:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b58:	4b6d      	ldr	r3, [pc, #436]	; (5d10 <grid_port_process_outbound_ui+0x650>)
    5b5a:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5b5e:	222e      	movs	r2, #46	; 0x2e
    5b60:	4641      	mov	r1, r8
    5b62:	a80f      	add	r0, sp, #60	; 0x3c
    5b64:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b66:	2303      	movs	r3, #3
    5b68:	e9cd 6300 	strd	r6, r3, [sp]
    5b6c:	4a73      	ldr	r2, [pc, #460]	; (5d3c <grid_port_process_outbound_ui+0x67c>)
    5b6e:	4e6c      	ldr	r6, [pc, #432]	; (5d20 <grid_port_process_outbound_ui+0x660>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b70:	4f6d      	ldr	r7, [pc, #436]	; (5d28 <grid_port_process_outbound_ui+0x668>)
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b72:	2131      	movs	r1, #49	; 0x31
    5b74:	2302      	movs	r3, #2
    5b76:	a80e      	add	r0, sp, #56	; 0x38
    5b78:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b7a:	4b6a      	ldr	r3, [pc, #424]	; (5d24 <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b7c:	4e70      	ldr	r6, [pc, #448]	; (5d40 <grid_port_process_outbound_ui+0x680>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b7e:	a80e      	add	r0, sp, #56	; 0x38
    5b80:	4798      	blx	r3
    5b82:	4b6a      	ldr	r3, [pc, #424]	; (5d2c <grid_port_process_outbound_ui+0x66c>)
    5b84:	4602      	mov	r2, r0
    5b86:	a90e      	add	r1, sp, #56	; 0x38
    5b88:	a893      	add	r0, sp, #588	; 0x24c
    5b8a:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b8c:	230d      	movs	r3, #13
    5b8e:	9300      	str	r3, [sp, #0]
    5b90:	2204      	movs	r2, #4
    5b92:	2301      	movs	r3, #1
    5b94:	4641      	mov	r1, r8
    5b96:	a893      	add	r0, sp, #588	; 0x24c
    5b98:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b9a:	6833      	ldr	r3, [r6, #0]
    5b9c:	9300      	str	r3, [sp, #0]
    5b9e:	2205      	movs	r2, #5
    5ba0:	2308      	movs	r3, #8
    5ba2:	4641      	mov	r1, r8
    5ba4:	a893      	add	r0, sp, #588	; 0x24c
    5ba6:	47b8      	blx	r7
					uint32_t milliseconds = grid_sys_state.uptime/RTC1MS%1000;
    5ba8:	6833      	ldr	r3, [r6, #0]
					uint32_t seconds =		grid_sys_state.uptime/RTC1MS/1000%60;
    5baa:	6833      	ldr	r3, [r6, #0]
					uint32_t minutes =		grid_sys_state.uptime/RTC1MS/1000/60%60;
    5bac:	6833      	ldr	r3, [r6, #0]
					uint32_t hours =		grid_sys_state.uptime/RTC1MS/1000/60/60%60;
    5bae:	6833      	ldr	r3, [r6, #0]
    5bb0:	e7b6      	b.n	5b20 <grid_port_process_outbound_ui+0x460>
				else if(msg_class == GRID_CLASS_RESETCAUSE_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5bb2:	2e12      	cmp	r6, #18
    5bb4:	d137      	bne.n	5c26 <grid_port_process_outbound_ui+0x566>
    5bb6:	2f0f      	cmp	r7, #15
    5bb8:	f47f adfd 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5bbc:	9b02      	ldr	r3, [sp, #8]
    5bbe:	ea5b 0303 	orrs.w	r3, fp, r3
    5bc2:	f43f adf8 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5bc6:	4b54      	ldr	r3, [pc, #336]	; (5d18 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5bc8:	4f5b      	ldr	r7, [pc, #364]	; (5d38 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5bca:	a893      	add	r0, sp, #588	; 0x24c
    5bcc:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5bce:	227f      	movs	r2, #127	; 0x7f
    5bd0:	4611      	mov	r1, r2
    5bd2:	2300      	movs	r3, #0
    5bd4:	a893      	add	r0, sp, #588	; 0x24c
    5bd6:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5bd8:	2700      	movs	r7, #0
    5bda:	4b4d      	ldr	r3, [pc, #308]	; (5d10 <grid_port_process_outbound_ui+0x650>)
    5bdc:	970e      	str	r7, [sp, #56]	; 0x38
    5bde:	222e      	movs	r2, #46	; 0x2e
    5be0:	4639      	mov	r1, r7
    5be2:	a80f      	add	r0, sp, #60	; 0x3c
    5be4:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_RESETCAUSE_frame);
    5be6:	2303      	movs	r3, #3
    5be8:	e9cd 6300 	strd	r6, r3, [sp]
    5bec:	4a55      	ldr	r2, [pc, #340]	; (5d44 <grid_port_process_outbound_ui+0x684>)
    5bee:	4e4c      	ldr	r6, [pc, #304]	; (5d20 <grid_port_process_outbound_ui+0x660>)
    5bf0:	2131      	movs	r1, #49	; 0x31
    5bf2:	2302      	movs	r3, #2
    5bf4:	a80e      	add	r0, sp, #56	; 0x38
    5bf6:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bf8:	4b4a      	ldr	r3, [pc, #296]	; (5d24 <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bfa:	4e4b      	ldr	r6, [pc, #300]	; (5d28 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bfc:	a80e      	add	r0, sp, #56	; 0x38
    5bfe:	4798      	blx	r3
    5c00:	4b4a      	ldr	r3, [pc, #296]	; (5d2c <grid_port_process_outbound_ui+0x66c>)
    5c02:	4602      	mov	r2, r0
    5c04:	a90e      	add	r1, sp, #56	; 0x38
    5c06:	a893      	add	r0, sp, #588	; 0x24c
    5c08:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5c0a:	230d      	movs	r3, #13
    5c0c:	9300      	str	r3, [sp, #0]
    5c0e:	2204      	movs	r2, #4
    5c10:	2301      	movs	r3, #1
    5c12:	4639      	mov	r1, r7
    5c14:	a893      	add	r0, sp, #588	; 0x24c
    5c16:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_RESETCAUSE_CAUSE_offset, GRID_CLASS_RESETCAUSE_CAUSE_length,grid_sys_state.reset_cause);
    5c18:	4b49      	ldr	r3, [pc, #292]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c1a:	791b      	ldrb	r3, [r3, #4]
    5c1c:	9300      	str	r3, [sp, #0]
    5c1e:	2205      	movs	r2, #5
    5c20:	2302      	movs	r3, #2
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5c22:	4639      	mov	r1, r7
    5c24:	e26e      	b.n	6104 <grid_port_process_outbound_ui+0xa44>
				else if(msg_class == GRID_CLASS_RESET_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me)){
    5c26:	2e13      	cmp	r6, #19
    5c28:	d113      	bne.n	5c52 <grid_port_process_outbound_ui+0x592>
    5c2a:	2f0e      	cmp	r7, #14
    5c2c:	f47f adc3 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5c30:	f1bb 0f00 	cmp.w	fp, #0
    5c34:	f43f adbf 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5c38:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5c3c:	4942      	ldr	r1, [pc, #264]	; (5d48 <grid_port_process_outbound_ui+0x688>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5c3e:	4b43      	ldr	r3, [pc, #268]	; (5d4c <grid_port_process_outbound_ui+0x68c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5c40:	68ca      	ldr	r2, [r1, #12]
    5c42:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5c46:	4313      	orrs	r3, r2
    5c48:	60cb      	str	r3, [r1, #12]
    5c4a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    5c4e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    5c50:	e7fd      	b.n	5c4e <grid_port_process_outbound_ui+0x58e>
				else if (msg_class == GRID_CLASS_GLOBALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c52:	2e61      	cmp	r6, #97	; 0x61
    5c54:	d10c      	bne.n	5c70 <grid_port_process_outbound_ui+0x5b0>
    5c56:	2f0e      	cmp	r7, #14
    5c58:	f47f adad 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5c5c:	9b02      	ldr	r3, [sp, #8]
    5c5e:	ea5b 0303 	orrs.w	r3, fp, r3
    5c62:	f43f ada8 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
    5c66:	493a      	ldr	r1, [pc, #232]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5c68:	4835      	ldr	r0, [pc, #212]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c6a:	4b3a      	ldr	r3, [pc, #232]	; (5d54 <grid_port_process_outbound_ui+0x694>)
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5c6c:	4798      	blx	r3
    5c6e:	e5a2      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c70:	2e60      	cmp	r6, #96	; 0x60
    5c72:	d117      	bne.n	5ca4 <grid_port_process_outbound_ui+0x5e4>
    5c74:	2f0e      	cmp	r7, #14
    5c76:	f47f ad9e 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5c7a:	9b02      	ldr	r3, [sp, #8]
    5c7c:	ea5b 0303 	orrs.w	r3, fp, r3
    5c80:	f43f ad99 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_store_configuration(&grid_sys_state, &grid_nvm_state);
    5c84:	4932      	ldr	r1, [pc, #200]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5c86:	482e      	ldr	r0, [pc, #184]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c88:	4b33      	ldr	r3, [pc, #204]	; (5d58 <grid_port_process_outbound_ui+0x698>)
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c8a:	4e34      	ldr	r6, [pc, #208]	; (5d5c <grid_port_process_outbound_ui+0x69c>)
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c8c:	4798      	blx	r3
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c8e:	2700      	movs	r7, #0
    5c90:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5c94:	e9cd 7300 	strd	r7, r3, [sp]
    5c98:	4829      	ldr	r0, [pc, #164]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c9a:	463b      	mov	r3, r7
    5c9c:	22ff      	movs	r2, #255	; 0xff
    5c9e:	4639      	mov	r1, r7
    5ca0:	47b0      	blx	r6
    5ca2:	e588      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5ca4:	2e62      	cmp	r6, #98	; 0x62
    5ca6:	d10b      	bne.n	5cc0 <grid_port_process_outbound_ui+0x600>
    5ca8:	2f0e      	cmp	r7, #14
    5caa:	f47f ad84 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5cae:	9b02      	ldr	r3, [sp, #8]
    5cb0:	ea5b 0303 	orrs.w	r3, fp, r3
    5cb4:	f43f ad7f 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5cb8:	4925      	ldr	r1, [pc, #148]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5cba:	4b29      	ldr	r3, [pc, #164]	; (5d60 <grid_port_process_outbound_ui+0x6a0>)
    5cbc:	4650      	mov	r0, sl
    5cbe:	e7e4      	b.n	5c8a <grid_port_process_outbound_ui+0x5ca>
				else if (msg_class == GRID_CLASS_GLOBALRECALL_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5cc0:	2e63      	cmp	r6, #99	; 0x63
    5cc2:	d112      	bne.n	5cea <grid_port_process_outbound_ui+0x62a>
    5cc4:	2f0e      	cmp	r7, #14
    5cc6:	f47f ad76 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5cca:	9b02      	ldr	r3, [sp, #8]
    5ccc:	ea5b 0303 	orrs.w	r3, fp, r3
    5cd0:	f43f ad71 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_GLOBALRECALL_BANKNUMBER_offset], GRID_CLASS_GLOBALRECALL_BANKNUMBER_length	, &error_flag);
    5cd4:	f108 0005 	add.w	r0, r8, #5
    5cd8:	2102      	movs	r1, #2
    5cda:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5cde:	4448      	add	r0, r9
    5ce0:	47a8      	blx	r5
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    5ce2:	4b20      	ldr	r3, [pc, #128]	; (5d64 <grid_port_process_outbound_ui+0x6a4>)
    5ce4:	b2c1      	uxtb	r1, r0
    5ce6:	4816      	ldr	r0, [pc, #88]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5ce8:	e590      	b.n	580c <grid_port_process_outbound_ui+0x14c>
				else if (msg_class == GRID_CLASS_LOCALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5cea:	2e71      	cmp	r6, #113	; 0x71
    5cec:	d13e      	bne.n	5d6c <grid_port_process_outbound_ui+0x6ac>
    5cee:	2f0e      	cmp	r7, #14
    5cf0:	f47f ad61 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5cf4:	9b02      	ldr	r3, [sp, #8]
    5cf6:	ea5b 0303 	orrs.w	r3, fp, r3
    5cfa:	f43f ad5c 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);						
    5cfe:	4914      	ldr	r1, [pc, #80]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5d00:	4b19      	ldr	r3, [pc, #100]	; (5d68 <grid_port_process_outbound_ui+0x6a8>)
    5d02:	4650      	mov	r0, sl
    5d04:	e7b2      	b.n	5c6c <grid_port_process_outbound_ui+0x5ac>
    5d06:	bf00      	nop
    5d08:	2001c838 	.word	0x2001c838
    5d0c:	00006d21 	.word	0x00006d21
    5d10:	00014469 	.word	0x00014469
    5d14:	000098c1 	.word	0x000098c1
    5d18:	000085c5 	.word	0x000085c5
    5d1c:	00016a28 	.word	0x00016a28
    5d20:	000149fd 	.word	0x000149fd
    5d24:	00014f81 	.word	0x00014f81
    5d28:	000085a9 	.word	0x000085a9
    5d2c:	00008535 	.word	0x00008535
    5d30:	000086f1 	.word	0x000086f1
    5d34:	000087c5 	.word	0x000087c5
    5d38:	000085f9 	.word	0x000085f9
    5d3c:	00016a52 	.word	0x00016a52
    5d40:	2000f008 	.word	0x2000f008
    5d44:	00016a64 	.word	0x00016a64
    5d48:	e000ed00 	.word	0xe000ed00
    5d4c:	05fa0004 	.word	0x05fa0004
    5d50:	2000fa1c 	.word	0x2000fa1c
    5d54:	000090e5 	.word	0x000090e5
    5d58:	00008d91 	.word	0x00008d91
    5d5c:	00009813 	.word	0x00009813
    5d60:	000091dd 	.word	0x000091dd
    5d64:	00008f89 	.word	0x00008f89
    5d68:	00009af5 	.word	0x00009af5
				else if (msg_class == GRID_CLASS_LOCALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d6c:	2e70      	cmp	r6, #112	; 0x70
    5d6e:	d10b      	bne.n	5d88 <grid_port_process_outbound_ui+0x6c8>
    5d70:	2f0e      	cmp	r7, #14
    5d72:	f47f ad20 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5d76:	9b02      	ldr	r3, [sp, #8]
    5d78:	ea5b 0303 	orrs.w	r3, fp, r3
    5d7c:	f43f ad1b 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_store_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d80:	49b4      	ldr	r1, [pc, #720]	; (6054 <grid_port_process_outbound_ui+0x994>)
    5d82:	4bb5      	ldr	r3, [pc, #724]	; (6058 <grid_port_process_outbound_ui+0x998>)
    5d84:	4650      	mov	r0, sl
    5d86:	e771      	b.n	5c6c <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_LOCALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d88:	2e72      	cmp	r6, #114	; 0x72
    5d8a:	d10b      	bne.n	5da4 <grid_port_process_outbound_ui+0x6e4>
    5d8c:	2f0e      	cmp	r7, #14
    5d8e:	f47f ad12 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5d92:	9b02      	ldr	r3, [sp, #8]
    5d94:	ea5b 0303 	orrs.w	r3, fp, r3
    5d98:	f43f ad0d 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d9c:	49ad      	ldr	r1, [pc, #692]	; (6054 <grid_port_process_outbound_ui+0x994>)
    5d9e:	4baf      	ldr	r3, [pc, #700]	; (605c <grid_port_process_outbound_ui+0x99c>)
    5da0:	4650      	mov	r0, sl
    5da2:	e763      	b.n	5c6c <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5da4:	2e80      	cmp	r6, #128	; 0x80
    5da6:	f040 81b0 	bne.w	610a <grid_port_process_outbound_ui+0xa4a>
    5daa:	2f0f      	cmp	r7, #15
    5dac:	d122      	bne.n	5df4 <grid_port_process_outbound_ui+0x734>
    5dae:	9b02      	ldr	r3, [sp, #8]
    5db0:	ea5b 0303 	orrs.w	r3, fp, r3
    5db4:	f43f acff 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5db8:	f108 0005 	add.w	r0, r8, #5
    5dbc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dc0:	2102      	movs	r1, #2
    5dc2:	4448      	add	r0, r9
    5dc4:	47a8      	blx	r5
    5dc6:	4606      	mov	r6, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5dc8:	f108 0007 	add.w	r0, r8, #7
    5dcc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dd0:	2102      	movs	r1, #2
    5dd2:	4448      	add	r0, r9
    5dd4:	47a8      	blx	r5
    5dd6:	4607      	mov	r7, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5dd8:	f108 0009 	add.w	r0, r8, #9
    5ddc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5de0:	2102      	movs	r1, #2
    5de2:	4448      	add	r0, r9
    5de4:	47a8      	blx	r5
					grid_ui_recall_event_configuration(&grid_ui_state, banknumber, elementnumber, eventtype);
    5de6:	b2f1      	uxtb	r1, r6
    5de8:	b2c3      	uxtb	r3, r0
    5dea:	4e9d      	ldr	r6, [pc, #628]	; (6060 <grid_port_process_outbound_ui+0x9a0>)
    5dec:	b2fa      	uxtb	r2, r7
    5dee:	4650      	mov	r0, sl
    5df0:	47b0      	blx	r6
    5df2:	e4e0      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    5df4:	2f0e      	cmp	r7, #14
    5df6:	f47f acde 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5dfa:	f1bb 0f00 	cmp.w	fp, #0
    5dfe:	f040 80e0 	bne.w	5fc2 <grid_port_process_outbound_ui+0x902>
    5e02:	2c00      	cmp	r4, #0
    5e04:	f000 8150 	beq.w	60a8 <grid_port_process_outbound_ui+0x9e8>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5e08:	ab2f      	add	r3, sp, #188	; 0xbc
    5e0a:	f108 0005 	add.w	r0, r8, #5
    5e0e:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5e12:	2102      	movs	r1, #2
    5e14:	4418      	add	r0, r3
    5e16:	47a8      	blx	r5
    5e18:	b2c3      	uxtb	r3, r0
    5e1a:	9305      	str	r3, [sp, #20]
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5e1c:	f108 0007 	add.w	r0, r8, #7
    5e20:	ab2f      	add	r3, sp, #188	; 0xbc
    5e22:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5e26:	2102      	movs	r1, #2
    5e28:	4418      	add	r0, r3
    5e2a:	47a8      	blx	r5
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e2c:	ab2f      	add	r3, sp, #188	; 0xbc
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5e2e:	9007      	str	r0, [sp, #28]
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e30:	f108 0009 	add.w	r0, r8, #9
    5e34:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5e38:	2102      	movs	r1, #2
    5e3a:	4418      	add	r0, r3
    5e3c:	47a8      	blx	r5
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e3e:	2700      	movs	r7, #0
    5e40:	4b88      	ldr	r3, [pc, #544]	; (6064 <grid_port_process_outbound_ui+0x9a4>)
    5e42:	970e      	str	r7, [sp, #56]	; 0x38
    5e44:	227e      	movs	r2, #126	; 0x7e
    5e46:	4639      	mov	r1, r7
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e48:	fa5f f980 	uxtb.w	r9, r0
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e4c:	a80f      	add	r0, sp, #60	; 0x3c
    5e4e:	4798      	blx	r3
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e50:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5e54:	f108 000b 	add.w	r0, r8, #11
    5e58:	eba3 0308 	sub.w	r3, r3, r8
    5e5c:	aa2f      	add	r2, sp, #188	; 0xbc
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e5e:	ae0e      	add	r6, sp, #56	; 0x38
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e60:	3b0b      	subs	r3, #11
					for(uint32_t j = 0; j<actionstring_length; j++){
    5e62:	eb02 0800 	add.w	r8, r2, r0
    5e66:	4639      	mov	r1, r7
    5e68:	4299      	cmp	r1, r3
    5e6a:	f0c0 80ed 	bcc.w	6048 <grid_port_process_outbound_ui+0x988>
					grid_ui_event_register_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype, actionstring, actionstring_length);
    5e6e:	9905      	ldr	r1, [sp, #20]
    5e70:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e74:	f89d 801c 	ldrb.w	r8, [sp, #28]
    5e78:	4f7b      	ldr	r7, [pc, #492]	; (6068 <grid_port_process_outbound_ui+0x9a8>)
    5e7a:	0109      	lsls	r1, r1, #4
    5e7c:	9104      	str	r1, [sp, #16]
    5e7e:	9905      	ldr	r1, [sp, #20]
    5e80:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    5e84:	2664      	movs	r6, #100	; 0x64
    5e86:	68d0      	ldr	r0, [r2, #12]
    5e88:	fb06 f608 	mul.w	r6, r6, r8
    5e8c:	aa0e      	add	r2, sp, #56	; 0x38
    5e8e:	4649      	mov	r1, r9
    5e90:	4430      	add	r0, r6
    5e92:	47b8      	blx	r7
					if (banknumber == grid_sys_state.bank_activebank_number){
    5e94:	4b75      	ldr	r3, [pc, #468]	; (606c <grid_port_process_outbound_ui+0x9ac>)
    5e96:	9a05      	ldr	r2, [sp, #20]
    5e98:	7bdb      	ldrb	r3, [r3, #15]
    5e9a:	4293      	cmp	r3, r2
    5e9c:	d105      	bne.n	5eaa <grid_port_process_outbound_ui+0x7ea>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    5e9e:	9905      	ldr	r1, [sp, #20]
    5ea0:	4f73      	ldr	r7, [pc, #460]	; (6070 <grid_port_process_outbound_ui+0x9b0>)
    5ea2:	464b      	mov	r3, r9
    5ea4:	4642      	mov	r2, r8
    5ea6:	4650      	mov	r0, sl
    5ea8:	47b8      	blx	r7
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5eaa:	f8da 3004 	ldr.w	r3, [sl, #4]
    5eae:	9a04      	ldr	r2, [sp, #16]
    5eb0:	4413      	add	r3, r2
    5eb2:	4649      	mov	r1, r9
    5eb4:	68d8      	ldr	r0, [r3, #12]
    5eb6:	4b6f      	ldr	r3, [pc, #444]	; (6074 <grid_port_process_outbound_ui+0x9b4>)
    5eb8:	4430      	add	r0, r6
    5eba:	4798      	blx	r3
					if (event_index != 255){
    5ebc:	28ff      	cmp	r0, #255	; 0xff
    5ebe:	d03d      	beq.n	5f3c <grid_port_process_outbound_ui+0x87c>
						if (position_is_local){
    5ec0:	b304      	cbz	r4, 5f04 <grid_port_process_outbound_ui+0x844>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5ec2:	f8da 2004 	ldr.w	r2, [sl, #4]
    5ec6:	9904      	ldr	r1, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5ec8:	9f04      	ldr	r7, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5eca:	440a      	add	r2, r1
    5ecc:	23bc      	movs	r3, #188	; 0xbc
    5ece:	68d2      	ldr	r2, [r2, #12]
    5ed0:	4432      	add	r2, r6
    5ed2:	fb10 f303 	smulbb	r3, r0, r3
    5ed6:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5ed8:	441a      	add	r2, r3
    5eda:	2100      	movs	r1, #0
    5edc:	f882 10b8 	strb.w	r1, [r2, #184]	; 0xb8
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5ee0:	f8da 2004 	ldr.w	r2, [sl, #4]
    5ee4:	443a      	add	r2, r7
    5ee6:	68d2      	ldr	r2, [r2, #12]
    5ee8:	4432      	add	r2, r6
    5eea:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5eec:	441a      	add	r2, r3
    5eee:	f882 10b6 	strb.w	r1, [r2, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5ef2:	f8da 2004 	ldr.w	r2, [sl, #4]
    5ef6:	443a      	add	r2, r7
    5ef8:	68d2      	ldr	r2, [r2, #12]
    5efa:	4432      	add	r2, r6
    5efc:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5efe:	4413      	add	r3, r2
    5f00:	f883 10b7 	strb.w	r1, [r3, #183]	; 0xb7
						if (position_is_me){
    5f04:	f1bb 0f00 	cmp.w	fp, #0
    5f08:	d018      	beq.n	5f3c <grid_port_process_outbound_ui+0x87c>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    5f0a:	22bc      	movs	r2, #188	; 0xbc
    5f0c:	fb10 f002 	smulbb	r0, r0, r2
    5f10:	f8da 3004 	ldr.w	r3, [sl, #4]
    5f14:	9a04      	ldr	r2, [sp, #16]
    5f16:	4413      	add	r3, r2
    5f18:	2201      	movs	r2, #1
    5f1a:	68db      	ldr	r3, [r3, #12]
    5f1c:	4433      	add	r3, r6
    5f1e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    5f20:	4403      	add	r3, r0
    5f22:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5f26:	f8da 3004 	ldr.w	r3, [sl, #4]
    5f2a:	9a04      	ldr	r2, [sp, #16]
    5f2c:	441a      	add	r2, r3
    5f2e:	68d3      	ldr	r3, [r2, #12]
    5f30:	441e      	add	r6, r3
    5f32:	6e33      	ldr	r3, [r6, #96]	; 0x60
    5f34:	4418      	add	r0, r3
    5f36:	2300      	movs	r3, #0
    5f38:	f880 30b7 	strb.w	r3, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    5f3c:	4b4e      	ldr	r3, [pc, #312]	; (6078 <grid_port_process_outbound_ui+0x9b8>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f3e:	4e4f      	ldr	r6, [pc, #316]	; (607c <grid_port_process_outbound_ui+0x9bc>)
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f40:	4f4f      	ldr	r7, [pc, #316]	; (6080 <grid_port_process_outbound_ui+0x9c0>)
					grid_msg_init(&response);
    5f42:	a893      	add	r0, sp, #588	; 0x24c
    5f44:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f46:	227f      	movs	r2, #127	; 0x7f
    5f48:	4611      	mov	r1, r2
    5f4a:	2300      	movs	r3, #0
    5f4c:	a893      	add	r0, sp, #588	; 0x24c
    5f4e:	47b0      	blx	r6
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f50:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    5f52:	2600      	movs	r6, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f54:	494b      	ldr	r1, [pc, #300]	; (6084 <grid_port_process_outbound_ui+0x9c4>)
    5f56:	9300      	str	r3, [sp, #0]
    5f58:	2202      	movs	r2, #2
    5f5a:	2380      	movs	r3, #128	; 0x80
    5f5c:	a80a      	add	r0, sp, #40	; 0x28
					uint8_t response_payload[10] = {0};
    5f5e:	e9cd 660a 	strd	r6, r6, [sp, #40]	; 0x28
    5f62:	f8ad 6030 	strh.w	r6, [sp, #48]	; 0x30
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f66:	47b8      	blx	r7
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f68:	4b47      	ldr	r3, [pc, #284]	; (6088 <grid_port_process_outbound_ui+0x9c8>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f6a:	4f48      	ldr	r7, [pc, #288]	; (608c <grid_port_process_outbound_ui+0x9cc>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f6c:	a80a      	add	r0, sp, #40	; 0x28
    5f6e:	4798      	blx	r3
    5f70:	4b47      	ldr	r3, [pc, #284]	; (6090 <grid_port_process_outbound_ui+0x9d0>)
    5f72:	4602      	mov	r2, r0
    5f74:	a90a      	add	r1, sp, #40	; 0x28
    5f76:	a893      	add	r0, sp, #588	; 0x24c
    5f78:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f7a:	9b05      	ldr	r3, [sp, #20]
    5f7c:	9300      	str	r3, [sp, #0]
    5f7e:	2205      	movs	r2, #5
    5f80:	2302      	movs	r3, #2
    5f82:	4631      	mov	r1, r6
    5f84:	a893      	add	r0, sp, #588	; 0x24c
    5f86:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    5f88:	2302      	movs	r3, #2
    5f8a:	2207      	movs	r2, #7
    5f8c:	4631      	mov	r1, r6
    5f8e:	a893      	add	r0, sp, #588	; 0x24c
    5f90:	f8cd 8000 	str.w	r8, [sp]
    5f94:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    5f96:	2302      	movs	r3, #2
    5f98:	2209      	movs	r2, #9
    5f9a:	4631      	mov	r1, r6
    5f9c:	a893      	add	r0, sp, #588	; 0x24c
    5f9e:	f8cd 9000 	str.w	r9, [sp]
    5fa2:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5fa4:	230a      	movs	r3, #10
    5fa6:	9300      	str	r3, [sp, #0]
    5fa8:	2204      	movs	r2, #4
    5faa:	2301      	movs	r3, #1
    5fac:	4631      	mov	r1, r6
    5fae:	a893      	add	r0, sp, #588	; 0x24c
    5fb0:	47b8      	blx	r7
                        grid_msg_packet_close(&response);
    5fb2:	4b38      	ldr	r3, [pc, #224]	; (6094 <grid_port_process_outbound_ui+0x9d4>)
    5fb4:	a893      	add	r0, sp, #588	; 0x24c
    5fb6:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5fb8:	4b37      	ldr	r3, [pc, #220]	; (6098 <grid_port_process_outbound_ui+0x9d8>)
    5fba:	a893      	add	r0, sp, #588	; 0x24c
    5fbc:	4798      	blx	r3
    5fbe:	f7ff bbfa 	b.w	57b6 <grid_port_process_outbound_ui+0xf6>
                    if (!position_is_local){
    5fc2:	2c00      	cmp	r4, #0
    5fc4:	f47f af20 	bne.w	5e08 <grid_port_process_outbound_ui+0x748>
                        grid_keyboard_state.isenabled = 0;             
    5fc8:	4e34      	ldr	r6, [pc, #208]	; (609c <grid_port_process_outbound_ui+0x9dc>)
                        grid_msg_init(&response);
    5fca:	4b2b      	ldr	r3, [pc, #172]	; (6078 <grid_port_process_outbound_ui+0x9b8>)
                        grid_keyboard_state.isenabled = 0;             
    5fcc:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    5fd0:	a893      	add	r0, sp, #588	; 0x24c
    5fd2:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5fd4:	227f      	movs	r2, #127	; 0x7f
    5fd6:	4623      	mov	r3, r4
    5fd8:	4611      	mov	r1, r2
    5fda:	a893      	add	r0, sp, #588	; 0x24c
    5fdc:	4f27      	ldr	r7, [pc, #156]	; (607c <grid_port_process_outbound_ui+0x9bc>)
    5fde:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fe0:	2303      	movs	r3, #3
    5fe2:	492f      	ldr	r1, [pc, #188]	; (60a0 <grid_port_process_outbound_ui+0x9e0>)
    5fe4:	9300      	str	r3, [sp, #0]
    5fe6:	2202      	movs	r2, #2
    5fe8:	4f25      	ldr	r7, [pc, #148]	; (6080 <grid_port_process_outbound_ui+0x9c0>)
                        uint8_t response_payload[10] = {0};
    5fea:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fee:	2392      	movs	r3, #146	; 0x92
    5ff0:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    5ff2:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5ff6:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5ff8:	4b23      	ldr	r3, [pc, #140]	; (6088 <grid_port_process_outbound_ui+0x9c8>)
    5ffa:	a80e      	add	r0, sp, #56	; 0x38
    5ffc:	4798      	blx	r3
    5ffe:	a90e      	add	r1, sp, #56	; 0x38
    6000:	4602      	mov	r2, r0
    6002:	4b23      	ldr	r3, [pc, #140]	; (6090 <grid_port_process_outbound_ui+0x9d0>)
    6004:	a893      	add	r0, sp, #588	; 0x24c
    6006:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    6008:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    600c:	9300      	str	r3, [sp, #0]
    600e:	4e1f      	ldr	r6, [pc, #124]	; (608c <grid_port_process_outbound_ui+0x9cc>)
    6010:	4621      	mov	r1, r4
    6012:	a893      	add	r0, sp, #588	; 0x24c
    6014:	2302      	movs	r3, #2
    6016:	2205      	movs	r2, #5
    6018:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    601a:	230d      	movs	r3, #13
    601c:	4621      	mov	r1, r4
    601e:	2204      	movs	r2, #4
    6020:	9300      	str	r3, [sp, #0]
    6022:	a893      	add	r0, sp, #588	; 0x24c
    6024:	2301      	movs	r3, #1
    6026:	47b0      	blx	r6
                        grid_msg_packet_close(&response);
    6028:	4b1a      	ldr	r3, [pc, #104]	; (6094 <grid_port_process_outbound_ui+0x9d4>)
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    602a:	4e1e      	ldr	r6, [pc, #120]	; (60a4 <grid_port_process_outbound_ui+0x9e4>)
                        grid_msg_packet_close(&response);
    602c:	a893      	add	r0, sp, #588	; 0x24c
    602e:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    6030:	4b19      	ldr	r3, [pc, #100]	; (6098 <grid_port_process_outbound_ui+0x9d8>)
    6032:	a893      	add	r0, sp, #588	; 0x24c
    6034:	4798      	blx	r3
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    6036:	23fa      	movs	r3, #250	; 0xfa
    6038:	e9cd 4300 	strd	r4, r3, [sp]
    603c:	2364      	movs	r3, #100	; 0x64
    603e:	480b      	ldr	r0, [pc, #44]	; (606c <grid_port_process_outbound_ui+0x9ac>)
    6040:	461a      	mov	r2, r3
    6042:	4619      	mov	r1, r3
    6044:	47b0      	blx	r6
    6046:	e6df      	b.n	5e08 <grid_port_process_outbound_ui+0x748>
						actionstring[j] = message[current_start+GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset + j];
    6048:	f818 2b01 	ldrb.w	r2, [r8], #1
    604c:	558a      	strb	r2, [r1, r6]
					for(uint32_t j = 0; j<actionstring_length; j++){
    604e:	3101      	adds	r1, #1
    6050:	e70a      	b.n	5e68 <grid_port_process_outbound_ui+0x7a8>
    6052:	bf00      	nop
    6054:	2000fa1c 	.word	0x2000fa1c
    6058:	00009ae5 	.word	0x00009ae5
    605c:	00009b05 	.word	0x00009b05
    6060:	00009b15 	.word	0x00009b15
    6064:	00014469 	.word	0x00014469
    6068:	00009f35 	.word	0x00009f35
    606c:	2000f008 	.word	0x2000f008
    6070:	0000a191 	.word	0x0000a191
    6074:	0000a145 	.word	0x0000a145
    6078:	000085c5 	.word	0x000085c5
    607c:	000085f9 	.word	0x000085f9
    6080:	00014ac5 	.word	0x00014ac5
    6084:	00016a70 	.word	0x00016a70
    6088:	00014f81 	.word	0x00014f81
    608c:	000085a9 	.word	0x000085a9
    6090:	00008535 	.word	0x00008535
    6094:	000086f1 	.word	0x000086f1
    6098:	000087c5 	.word	0x000087c5
    609c:	20010264 	.word	0x20010264
    60a0:	00016a64 	.word	0x00016a64
    60a4:	00009813 	.word	0x00009813
                        grid_keyboard_state.isenabled = 0;             
    60a8:	4e8b      	ldr	r6, [pc, #556]	; (62d8 <grid_port_process_outbound_ui+0xc18>)
                        grid_msg_init(&response);
    60aa:	4b8c      	ldr	r3, [pc, #560]	; (62dc <grid_port_process_outbound_ui+0xc1c>)
                        grid_keyboard_state.isenabled = 0;             
    60ac:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    60b0:	a893      	add	r0, sp, #588	; 0x24c
    60b2:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    60b4:	227f      	movs	r2, #127	; 0x7f
    60b6:	4611      	mov	r1, r2
    60b8:	4f89      	ldr	r7, [pc, #548]	; (62e0 <grid_port_process_outbound_ui+0xc20>)
    60ba:	4623      	mov	r3, r4
    60bc:	a893      	add	r0, sp, #588	; 0x24c
    60be:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60c0:	2303      	movs	r3, #3
    60c2:	4988      	ldr	r1, [pc, #544]	; (62e4 <grid_port_process_outbound_ui+0xc24>)
    60c4:	9300      	str	r3, [sp, #0]
    60c6:	2202      	movs	r2, #2
    60c8:	2392      	movs	r3, #146	; 0x92
    60ca:	4f87      	ldr	r7, [pc, #540]	; (62e8 <grid_port_process_outbound_ui+0xc28>)
                        uint8_t response_payload[10] = {0};
    60cc:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60d0:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    60d2:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60d6:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    60d8:	4b84      	ldr	r3, [pc, #528]	; (62ec <grid_port_process_outbound_ui+0xc2c>)
    60da:	a80e      	add	r0, sp, #56	; 0x38
    60dc:	4798      	blx	r3
    60de:	4b84      	ldr	r3, [pc, #528]	; (62f0 <grid_port_process_outbound_ui+0xc30>)
    60e0:	4602      	mov	r2, r0
    60e2:	a90e      	add	r1, sp, #56	; 0x38
    60e4:	a893      	add	r0, sp, #588	; 0x24c
    60e6:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    60e8:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    60ec:	9300      	str	r3, [sp, #0]
    60ee:	2205      	movs	r2, #5
    60f0:	2302      	movs	r3, #2
    60f2:	4621      	mov	r1, r4
    60f4:	4e7f      	ldr	r6, [pc, #508]	; (62f4 <grid_port_process_outbound_ui+0xc34>)
    60f6:	a893      	add	r0, sp, #588	; 0x24c
    60f8:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    60fa:	230d      	movs	r3, #13
    60fc:	9300      	str	r3, [sp, #0]
    60fe:	2204      	movs	r2, #4
    6100:	2301      	movs	r3, #1
    6102:	4621      	mov	r1, r4
    6104:	a893      	add	r0, sp, #588	; 0x24c
    6106:	47b0      	blx	r6
    6108:	e753      	b.n	5fb2 <grid_port_process_outbound_ui+0x8f2>
                else if (msg_class == GRID_CLASS_HIDKEYSTATUS_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    610a:	2e92      	cmp	r6, #146	; 0x92
    610c:	d13e      	bne.n	618c <grid_port_process_outbound_ui+0xacc>
    610e:	2f0e      	cmp	r7, #14
    6110:	f47f ab51 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    6114:	9b02      	ldr	r3, [sp, #8]
    6116:	ea5b 0303 	orrs.w	r3, fp, r3
    611a:	f43f ab4c 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    611e:	f108 0005 	add.w	r0, r8, #5
    6122:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6126:	2102      	movs	r1, #2
    6128:	4448      	add	r0, r9
    612a:	47a8      	blx	r5
                    grid_keyboard_state.isenabled = isenabled;
    612c:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 62d8 <grid_port_process_outbound_ui+0xc18>
                    grid_msg_init(&response);
    6130:	4b6a      	ldr	r3, [pc, #424]	; (62dc <grid_port_process_outbound_ui+0xc1c>)
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    6132:	f888 0045 	strb.w	r0, [r8, #69]	; 0x45
                    grid_msg_init(&response);
    6136:	a893      	add	r0, sp, #588	; 0x24c
    6138:	4798      	blx	r3
                    grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    613a:	227f      	movs	r2, #127	; 0x7f
    613c:	4611      	mov	r1, r2
    613e:	4f68      	ldr	r7, [pc, #416]	; (62e0 <grid_port_process_outbound_ui+0xc20>)
    6140:	2300      	movs	r3, #0
    6142:	a893      	add	r0, sp, #588	; 0x24c
    6144:	47b8      	blx	r7
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6146:	2303      	movs	r3, #3
    6148:	4966      	ldr	r1, [pc, #408]	; (62e4 <grid_port_process_outbound_ui+0xc24>)
    614a:	9300      	str	r3, [sp, #0]
                    uint8_t response_payload[10] = {0};
    614c:	2700      	movs	r7, #0
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    614e:	4633      	mov	r3, r6
    6150:	2202      	movs	r2, #2
    6152:	4e65      	ldr	r6, [pc, #404]	; (62e8 <grid_port_process_outbound_ui+0xc28>)
                    uint8_t response_payload[10] = {0};
    6154:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6158:	a80e      	add	r0, sp, #56	; 0x38
                    uint8_t response_payload[10] = {0};
    615a:	e9cd 770e 	strd	r7, r7, [sp, #56]	; 0x38
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    615e:	47b0      	blx	r6
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6160:	4b62      	ldr	r3, [pc, #392]	; (62ec <grid_port_process_outbound_ui+0xc2c>)
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    6162:	4e64      	ldr	r6, [pc, #400]	; (62f4 <grid_port_process_outbound_ui+0xc34>)
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6164:	a80e      	add	r0, sp, #56	; 0x38
    6166:	4798      	blx	r3
    6168:	4b61      	ldr	r3, [pc, #388]	; (62f0 <grid_port_process_outbound_ui+0xc30>)
    616a:	4602      	mov	r2, r0
    616c:	a90e      	add	r1, sp, #56	; 0x38
    616e:	a893      	add	r0, sp, #588	; 0x24c
    6170:	4798      	blx	r3
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    6172:	f898 3045 	ldrb.w	r3, [r8, #69]	; 0x45
    6176:	9300      	str	r3, [sp, #0]
    6178:	2205      	movs	r2, #5
    617a:	2302      	movs	r3, #2
    617c:	4639      	mov	r1, r7
    617e:	a893      	add	r0, sp, #588	; 0x24c
    6180:	47b0      	blx	r6
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    6182:	230a      	movs	r3, #10
    6184:	9300      	str	r3, [sp, #0]
    6186:	2204      	movs	r2, #4
    6188:	2301      	movs	r3, #1
    618a:	e54a      	b.n	5c22 <grid_port_process_outbound_ui+0x562>
				else if (msg_class == GRID_CLASS_CONFIGDEFAULT_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    618c:	2e81      	cmp	r6, #129	; 0x81
    618e:	f47f ab12 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    6192:	2f0e      	cmp	r7, #14
    6194:	f47f ab0f 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    6198:	ea5b 0304 	orrs.w	r3, fp, r4
    619c:	f43f ab0b 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    61a0:	f108 0005 	add.w	r0, r8, #5
    61a4:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    61a8:	2102      	movs	r1, #2
    61aa:	4448      	add	r0, r9
    61ac:	47a8      	blx	r5
    61ae:	b2c7      	uxtb	r7, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    61b0:	f108 0007 	add.w	r0, r8, #7
    61b4:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    61b8:	2102      	movs	r1, #2
    61ba:	4448      	add	r0, r9
    61bc:	47a8      	blx	r5
    61be:	4606      	mov	r6, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    61c0:	f108 0009 	add.w	r0, r8, #9
    61c4:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    61c8:	2102      	movs	r1, #2
    61ca:	4448      	add	r0, r9
    61cc:	47a8      	blx	r5
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61ce:	f8da 3004 	ldr.w	r3, [sl, #4]
    61d2:	eb03 1307 	add.w	r3, r3, r7, lsl #4
    61d6:	b2f2      	uxtb	r2, r6
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    61d8:	fa5f f880 	uxtb.w	r8, r0
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61dc:	f04f 0964 	mov.w	r9, #100	; 0x64
    61e0:	68d8      	ldr	r0, [r3, #12]
    61e2:	4b45      	ldr	r3, [pc, #276]	; (62f8 <grid_port_process_outbound_ui+0xc38>)
    61e4:	9204      	str	r2, [sp, #16]
    61e6:	fb09 f902 	mul.w	r9, r9, r2
    61ea:	4641      	mov	r1, r8
    61ec:	4448      	add	r0, r9
    61ee:	4798      	blx	r3
					if (banknumber == grid_sys_state.bank_activebank_number){
    61f0:	4b42      	ldr	r3, [pc, #264]	; (62fc <grid_port_process_outbound_ui+0xc3c>)
    61f2:	7bdb      	ldrb	r3, [r3, #15]
    61f4:	42bb      	cmp	r3, r7
    61f6:	d105      	bne.n	6204 <grid_port_process_outbound_ui+0xb44>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    61f8:	9a04      	ldr	r2, [sp, #16]
    61fa:	4e41      	ldr	r6, [pc, #260]	; (6300 <grid_port_process_outbound_ui+0xc40>)
    61fc:	4643      	mov	r3, r8
    61fe:	4639      	mov	r1, r7
    6200:	4650      	mov	r0, sl
    6202:	47b0      	blx	r6
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6204:	f8da 3004 	ldr.w	r3, [sl, #4]
    6208:	013a      	lsls	r2, r7, #4
    620a:	4413      	add	r3, r2
    620c:	4641      	mov	r1, r8
    620e:	68d8      	ldr	r0, [r3, #12]
    6210:	4b3c      	ldr	r3, [pc, #240]	; (6304 <grid_port_process_outbound_ui+0xc44>)
    6212:	4448      	add	r0, r9
    6214:	4798      	blx	r3
					if (event_index != 255){
    6216:	28ff      	cmp	r0, #255	; 0xff
    6218:	d018      	beq.n	624c <grid_port_process_outbound_ui+0xb8c>
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    621a:	f8da 3004 	ldr.w	r3, [sl, #4]
    621e:	22bc      	movs	r2, #188	; 0xbc
    6220:	fb10 f002 	smulbb	r0, r0, r2
    6224:	013a      	lsls	r2, r7, #4
    6226:	4413      	add	r3, r2
    6228:	2201      	movs	r2, #1
    622a:	68db      	ldr	r3, [r3, #12]
    622c:	444b      	add	r3, r9
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    622e:	0139      	lsls	r1, r7, #4
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    6230:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6232:	4403      	add	r3, r0
    6234:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    6238:	f8da 3004 	ldr.w	r3, [sl, #4]
    623c:	440b      	add	r3, r1
    623e:	68db      	ldr	r3, [r3, #12]
    6240:	4499      	add	r9, r3
    6242:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
    6246:	4418      	add	r0, r3
    6248:	f880 20b7 	strb.w	r2, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    624c:	4b23      	ldr	r3, [pc, #140]	; (62dc <grid_port_process_outbound_ui+0xc1c>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    624e:	f8df 9090 	ldr.w	r9, [pc, #144]	; 62e0 <grid_port_process_outbound_ui+0xc20>
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6252:	4e25      	ldr	r6, [pc, #148]	; (62e8 <grid_port_process_outbound_ui+0xc28>)
					grid_msg_init(&response);
    6254:	a893      	add	r0, sp, #588	; 0x24c
    6256:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6258:	227f      	movs	r2, #127	; 0x7f
    625a:	4611      	mov	r1, r2
    625c:	2300      	movs	r3, #0
    625e:	a893      	add	r0, sp, #588	; 0x24c
    6260:	47c8      	blx	r9
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6262:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    6264:	f04f 0900 	mov.w	r9, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6268:	4927      	ldr	r1, [pc, #156]	; (6308 <grid_port_process_outbound_ui+0xc48>)
    626a:	9300      	str	r3, [sp, #0]
    626c:	2202      	movs	r2, #2
    626e:	2380      	movs	r3, #128	; 0x80
    6270:	a80e      	add	r0, sp, #56	; 0x38
					uint8_t response_payload[10] = {0};
    6272:	e9cd 990e 	strd	r9, r9, [sp, #56]	; 0x38
    6276:	f8ad 9040 	strh.w	r9, [sp, #64]	; 0x40
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    627a:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    627c:	4b1b      	ldr	r3, [pc, #108]	; (62ec <grid_port_process_outbound_ui+0xc2c>)
    627e:	a80e      	add	r0, sp, #56	; 0x38
    6280:	4798      	blx	r3
    6282:	4b1b      	ldr	r3, [pc, #108]	; (62f0 <grid_port_process_outbound_ui+0xc30>)
    6284:	4602      	mov	r2, r0
    6286:	a90e      	add	r1, sp, #56	; 0x38
    6288:	a893      	add	r0, sp, #588	; 0x24c
    628a:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    628c:	9700      	str	r7, [sp, #0]
    628e:	2302      	movs	r3, #2
    6290:	4f18      	ldr	r7, [pc, #96]	; (62f4 <grid_port_process_outbound_ui+0xc34>)
    6292:	2205      	movs	r2, #5
    6294:	4649      	mov	r1, r9
    6296:	a893      	add	r0, sp, #588	; 0x24c
    6298:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    629a:	9b04      	ldr	r3, [sp, #16]
    629c:	9300      	str	r3, [sp, #0]
    629e:	2207      	movs	r2, #7
    62a0:	2302      	movs	r3, #2
    62a2:	4649      	mov	r1, r9
    62a4:	a893      	add	r0, sp, #588	; 0x24c
    62a6:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    62a8:	f8cd 8000 	str.w	r8, [sp]
    62ac:	2302      	movs	r3, #2
    62ae:	2209      	movs	r2, #9
    62b0:	4649      	mov	r1, r9
    62b2:	a893      	add	r0, sp, #588	; 0x24c
    62b4:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    62b6:	230a      	movs	r3, #10
    62b8:	2204      	movs	r2, #4
    62ba:	4649      	mov	r1, r9
    62bc:	9300      	str	r3, [sp, #0]
    62be:	a893      	add	r0, sp, #588	; 0x24c
    62c0:	2301      	movs	r3, #1
    62c2:	47b8      	blx	r7
					grid_msg_packet_close(&response);
    62c4:	4b11      	ldr	r3, [pc, #68]	; (630c <grid_port_process_outbound_ui+0xc4c>)
    62c6:	a893      	add	r0, sp, #588	; 0x24c
    62c8:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    62ca:	4b11      	ldr	r3, [pc, #68]	; (6310 <grid_port_process_outbound_ui+0xc50>)
    62cc:	a893      	add	r0, sp, #588	; 0x24c
    62ce:	4798      	blx	r3
				current_start = 0;
    62d0:	46c8      	mov	r8, r9
    62d2:	f7ff ba4c 	b.w	576e <grid_port_process_outbound_ui+0xae>
    62d6:	bf00      	nop
    62d8:	20010264 	.word	0x20010264
    62dc:	000085c5 	.word	0x000085c5
    62e0:	000085f9 	.word	0x000085f9
    62e4:	00016a64 	.word	0x00016a64
    62e8:	00014ac5 	.word	0x00014ac5
    62ec:	00014f81 	.word	0x00014f81
    62f0:	00008535 	.word	0x00008535
    62f4:	000085a9 	.word	0x000085a9
    62f8:	00009fa1 	.word	0x00009fa1
    62fc:	2000f008 	.word	0x2000f008
    6300:	0000a191 	.word	0x0000a191
    6304:	0000a145 	.word	0x0000a145
    6308:	00016a70 	.word	0x00016a70
    630c:	000086f1 	.word	0x000086f1
    6310:	000087c5 	.word	0x000087c5

00006314 <grid_port_process_outbound_usart>:

uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    6314:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    6318:	8987      	ldrh	r7, [r0, #12]
uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    631a:	4605      	mov	r5, r0
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    631c:	bb1f      	cbnz	r7, 6366 <grid_port_process_outbound_usart+0x52>
		
		uint16_t packet_size = grid_buffer_read_size(&por->tx_buffer);
    631e:	f500 561c 	add.w	r6, r0, #9984	; 0x2700
    6322:	363c      	adds	r6, #60	; 0x3c
    6324:	4b11      	ldr	r3, [pc, #68]	; (636c <grid_port_process_outbound_usart+0x58>)
    6326:	4630      	mov	r0, r6
    6328:	4798      	blx	r3
		
		if (!packet_size){
    632a:	4604      	mov	r4, r0
    632c:	b1a0      	cbz	r0, 6358 <grid_port_process_outbound_usart+0x44>
			// NO PACKET IN RX BUFFER
			return 0;
		}else{
			
			// Let's transfer the packet to local memory
			grid_buffer_read_init(&por->tx_buffer);
    632e:	4b10      	ldr	r3, [pc, #64]	; (6370 <grid_port_process_outbound_usart+0x5c>)
			
			por->tx_double_buffer_status = packet_size;
			
			for (uint16_t i = 0; i<packet_size; i++){
				
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6330:	f8df a048 	ldr.w	sl, [pc, #72]	; 637c <grid_port_process_outbound_usart+0x68>
			grid_buffer_read_init(&por->tx_buffer);
    6334:	4630      	mov	r0, r6
    6336:	f105 082c 	add.w	r8, r5, #44	; 0x2c
    633a:	4798      	blx	r3
			por->tx_double_buffer_status = packet_size;
    633c:	46c1      	mov	r9, r8
    633e:	81ac      	strh	r4, [r5, #12]
			for (uint16_t i = 0; i<packet_size; i++){
    6340:	b2bb      	uxth	r3, r7
    6342:	429c      	cmp	r4, r3
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6344:	4630      	mov	r0, r6
			for (uint16_t i = 0; i<packet_size; i++){
    6346:	d809      	bhi.n	635c <grid_port_process_outbound_usart+0x48>
				por->tx_double_buffer[i] = character;
				
			}
		
			// Let's acknowledge the transaction
			grid_buffer_read_acknowledge(&por->tx_buffer);
    6348:	4b0a      	ldr	r3, [pc, #40]	; (6374 <grid_port_process_outbound_usart+0x60>)
    634a:	4798      	blx	r3
			
			// Let's send the packet through USART
			io_write(&por->usart->io, por->tx_double_buffer, por->tx_double_buffer_status);		
    634c:	89aa      	ldrh	r2, [r5, #12]
    634e:	6868      	ldr	r0, [r5, #4]
    6350:	4b09      	ldr	r3, [pc, #36]	; (6378 <grid_port_process_outbound_usart+0x64>)
    6352:	4649      	mov	r1, r9
    6354:	4798      	blx	r3
			
			return 1;
    6356:	2001      	movs	r0, #1
		}
		
	}
	
	return 0;
}
    6358:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    635c:	47d0      	blx	sl
				por->tx_double_buffer[i] = character;
    635e:	3701      	adds	r7, #1
    6360:	f808 0b01 	strb.w	r0, [r8], #1
			for (uint16_t i = 0; i<packet_size; i++){
    6364:	e7ec      	b.n	6340 <grid_port_process_outbound_usart+0x2c>
	return 0;
    6366:	2000      	movs	r0, #0
    6368:	e7f6      	b.n	6358 <grid_port_process_outbound_usart+0x44>
    636a:	bf00      	nop
    636c:	00004f05 	.word	0x00004f05
    6370:	00004f5b 	.word	0x00004f5b
    6374:	00004fed 	.word	0x00004fed
    6378:	0000b0ed 	.word	0x0000b0ed
    637c:	00004fc3 	.word	0x00004fc3

00006380 <grid_d51_init>:
	
}



void grid_d51_init(){
    6380:	b570      	push	{r4, r5, r6, lr}
	
	uint32_t hwid = grid_sys_get_hwcfg();
    6382:	4b09      	ldr	r3, [pc, #36]	; (63a8 <grid_d51_init+0x28>)
	
	#ifdef NDEBUG		
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "USER ROW CHECK!");
	grid_d51_verify_user_row();
	#else
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6384:	4d09      	ldr	r5, [pc, #36]	; (63ac <grid_d51_init+0x2c>)
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    6386:	4c0a      	ldr	r4, [pc, #40]	; (63b0 <grid_d51_init+0x30>)
	uint32_t hwid = grid_sys_get_hwcfg();
    6388:	4798      	blx	r3
    638a:	4601      	mov	r1, r0
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    638c:	4809      	ldr	r0, [pc, #36]	; (63b4 <grid_d51_init+0x34>)
    638e:	47a0      	blx	r4
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6390:	4909      	ldr	r1, [pc, #36]	; (63b8 <grid_d51_init+0x38>)
    6392:	4628      	mov	r0, r5
    6394:	47a0      	blx	r4
	{
	}
	
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Unit Test");
    6396:	4909      	ldr	r1, [pc, #36]	; (63bc <grid_d51_init+0x3c>)
    6398:	4628      	mov	r0, r5
    639a:	47a0      	blx	r4
	while (1)
	{
	}
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    639c:	4628      	mov	r0, r5
    639e:	4623      	mov	r3, r4
    63a0:	4907      	ldr	r1, [pc, #28]	; (63c0 <grid_d51_init+0x40>)
	#endif
		
}
    63a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    63a6:	4718      	bx	r3
    63a8:	000098ed 	.word	0x000098ed
    63ac:	0001693b 	.word	0x0001693b
    63b0:	000146ad 	.word	0x000146ad
    63b4:	00016a80 	.word	0x00016a80
    63b8:	00016aa1 	.word	0x00016aa1
    63bc:	00016ab4 	.word	0x00016ab4
    63c0:	00016ac1 	.word	0x00016ac1

000063c4 <grid_expr_clear_input>:
}


grid_expr_clear_input(struct grid_expr_model* expr){

    expr->input_string_length = 0;
    63c4:	2300      	movs	r3, #0
    63c6:	f880 30fe 	strb.w	r3, [r0, #254]	; 0xfe

    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    63ca:	1d02      	adds	r2, r0, #4
    63cc:	30fe      	adds	r0, #254	; 0xfe

        expr->input_string[i] = 0;
    63ce:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    63d2:	4282      	cmp	r2, r0
    63d4:	d1fb      	bne.n	63ce <grid_expr_clear_input+0xa>

    }

}
    63d6:	4770      	bx	lr

000063d8 <grid_expr_clear_output>:

grid_expr_clear_output(struct grid_expr_model* expr){


    expr->output_string_length = 0;
    63d8:	2300      	movs	r3, #0
    63da:	f880 31fa 	strb.w	r3, [r0, #506]	; 0x1fa

    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    63de:	f100 02ff 	add.w	r2, r0, #255	; 0xff
    63e2:	f200 10f9 	addw	r0, r0, #505	; 0x1f9

        expr->output_string[i] = 0;
    63e6:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    63ea:	4282      	cmp	r2, r0
    63ec:	d1fb      	bne.n	63e6 <grid_expr_clear_output+0xe>

    }

}
    63ee:	4770      	bx	lr

000063f0 <grid_expr_init>:
void grid_expr_init(struct grid_expr_model* expr){
    63f0:	b510      	push	{r4, lr}
    expr->current_event = NULL;
    63f2:	2300      	movs	r3, #0
    63f4:	6003      	str	r3, [r0, #0]
    grid_expr_clear_input(expr);
    63f6:	4b04      	ldr	r3, [pc, #16]	; (6408 <grid_expr_init+0x18>)
void grid_expr_init(struct grid_expr_model* expr){
    63f8:	4601      	mov	r1, r0
    grid_expr_clear_input(expr);
    63fa:	4798      	blx	r3
}
    63fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_expr_clear_output(expr);
    6400:	4b02      	ldr	r3, [pc, #8]	; (640c <grid_expr_init+0x1c>)
    6402:	4608      	mov	r0, r1
    6404:	4718      	bx	r3
    6406:	bf00      	nop
    6408:	000063c5 	.word	0x000063c5
    640c:	000063d9 	.word	0x000063d9

00006410 <grid_expr_set_current_event>:



grid_expr_set_current_event(struct grid_expr_model* expr, struct grid_ui_event* eve){

    expr->current_event = eve;
    6410:	6001      	str	r1, [r0, #0]
}
    6412:	4770      	bx	lr

00006414 <get>:
}


char get(char** e)
{
    char ret = **e;
    6414:	6802      	ldr	r2, [r0, #0]
{
    6416:	4603      	mov	r3, r0
    char ret = **e;
    6418:	f812 0b01 	ldrb.w	r0, [r2], #1
    ++*e;
    641c:	601a      	str	r2, [r3, #0]
    return ret;
}
    641e:	4770      	bx	lr

00006420 <number>:

int number(char** e)
{
    6420:	b530      	push	{r4, r5, lr}
    char ret = **e;
    6422:	6801      	ldr	r1, [r0, #0]
    6424:	f811 3b01 	ldrb.w	r3, [r1], #1
    ++*e;
    6428:	6001      	str	r1, [r0, #0]
{
    642a:	4602      	mov	r2, r0
    int result = get(e) - '0';
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    {
        result = 10*result + get(e) - '0'; // HEX para
    642c:	250a      	movs	r5, #10
    int result = get(e) - '0';
    642e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    return **e;
    6432:	6811      	ldr	r1, [r2, #0]
    6434:	780b      	ldrb	r3, [r1, #0]
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    6436:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
    643a:	2c09      	cmp	r4, #9
    643c:	d900      	bls.n	6440 <number+0x20>
    }
    return result;
}
    643e:	bd30      	pop	{r4, r5, pc}
    ++*e;
    6440:	3101      	adds	r1, #1
        result = 10*result + get(e) - '0'; // HEX para
    6442:	fb05 3300 	mla	r3, r5, r0, r3
    ++*e;
    6446:	6011      	str	r1, [r2, #0]
        result = 10*result + get(e) - '0'; // HEX para
    6448:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    644c:	e7f1      	b.n	6432 <number+0x12>
	...

00006450 <expr_level_0>:
            result -= expr_level_2(e);
    return result;
}

int expr_level_0(char ** e) // equality
{
    6450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_1(e);
    6452:	4e2a      	ldr	r6, [pc, #168]	; (64fc <expr_level_0+0xac>)
        else if (peeked == '=' && peeked2 == '='){
            get(e); // burn the second character
            result = (result == expr_level_1(e));
        }
        else if (peeked == '!' && peeked2 == '='){
            get(e); // burn the second character
    6454:	4f2a      	ldr	r7, [pc, #168]	; (6500 <expr_level_0+0xb0>)
{
    6456:	4605      	mov	r5, r0
    int result = expr_level_1(e);
    6458:	47b0      	blx	r6
    645a:	4604      	mov	r4, r0
    return **e;
    645c:	682a      	ldr	r2, [r5, #0]
    645e:	7813      	ldrb	r3, [r2, #0]
    while (     (peek(e) == '>' && peek2(e) != '=') || 
    6460:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
    6464:	293c      	cmp	r1, #60	; 0x3c
    6466:	d004      	beq.n	6472 <expr_level_0+0x22>
                (peek(e) == '<' && peek2(e) != '=') || 
    6468:	2b3d      	cmp	r3, #61	; 0x3d
    646a:	d143      	bne.n	64f4 <expr_level_0+0xa4>
                (peek(e) == '!' && peek2(e) == '=') ||
    646c:	7851      	ldrb	r1, [r2, #1]
    646e:	293d      	cmp	r1, #61	; 0x3d
    6470:	d142      	bne.n	64f8 <expr_level_0+0xa8>
    ++*e;
    6472:	1c51      	adds	r1, r2, #1
    6474:	6029      	str	r1, [r5, #0]
        if ((peeked == '>' && peeked2 != '=')){
    6476:	2b3e      	cmp	r3, #62	; 0x3e
    return **e;
    6478:	7852      	ldrb	r2, [r2, #1]
        if ((peeked == '>' && peeked2 != '=')){
    647a:	d108      	bne.n	648e <expr_level_0+0x3e>
    647c:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result>expr_level_1(e));
    647e:	4628      	mov	r0, r5
        if ((peeked == '>' && peeked2 != '=')){
    6480:	d028      	beq.n	64d4 <expr_level_0+0x84>
            result = (result>expr_level_1(e));
    6482:	47b0      	blx	r6
    6484:	42a0      	cmp	r0, r4
    6486:	bfac      	ite	ge
    6488:	2400      	movge	r4, #0
    648a:	2401      	movlt	r4, #1
    648c:	e7e6      	b.n	645c <expr_level_0+0xc>
        else if (peeked == '<' && peeked2 != '='){
    648e:	2b3c      	cmp	r3, #60	; 0x3c
    6490:	d108      	bne.n	64a4 <expr_level_0+0x54>
    6492:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result<expr_level_1(e));
    6494:	4628      	mov	r0, r5
        else if (peeked == '<' && peeked2 != '='){
    6496:	d025      	beq.n	64e4 <expr_level_0+0x94>
            result = (result<expr_level_1(e));
    6498:	47b0      	blx	r6
    649a:	42a0      	cmp	r0, r4
    649c:	bfd4      	ite	le
    649e:	2400      	movle	r4, #0
    64a0:	2401      	movgt	r4, #1
    64a2:	e7db      	b.n	645c <expr_level_0+0xc>
        else if (peeked == '=' && peeked2 == '='){
    64a4:	2b3d      	cmp	r3, #61	; 0x3d
    64a6:	d109      	bne.n	64bc <expr_level_0+0x6c>
    64a8:	2a3d      	cmp	r2, #61	; 0x3d
    64aa:	d1d7      	bne.n	645c <expr_level_0+0xc>
            get(e); // burn the second character
    64ac:	4628      	mov	r0, r5
    64ae:	47b8      	blx	r7
            result = (result == expr_level_1(e));
    64b0:	4628      	mov	r0, r5
    64b2:	47b0      	blx	r6
    64b4:	1b03      	subs	r3, r0, r4
    64b6:	425c      	negs	r4, r3
    64b8:	415c      	adcs	r4, r3
    64ba:	e7cf      	b.n	645c <expr_level_0+0xc>
        else if (peeked == '!' && peeked2 == '='){
    64bc:	2b21      	cmp	r3, #33	; 0x21
    64be:	d1cd      	bne.n	645c <expr_level_0+0xc>
    64c0:	2a3d      	cmp	r2, #61	; 0x3d
    64c2:	d1cb      	bne.n	645c <expr_level_0+0xc>
            get(e); // burn the second character
    64c4:	4628      	mov	r0, r5
    64c6:	47b8      	blx	r7
            result = (result != expr_level_1(e));
    64c8:	4628      	mov	r0, r5
    64ca:	47b0      	blx	r6
    64cc:	1b04      	subs	r4, r0, r4
    64ce:	bf18      	it	ne
    64d0:	2401      	movne	r4, #1
    64d2:	e7c3      	b.n	645c <expr_level_0+0xc>
        }
        else if (peeked == '>' && peeked2 == '='){
            get(e); // burn the second character
    64d4:	47b8      	blx	r7
            result = (result >= expr_level_1(e));
    64d6:	4628      	mov	r0, r5
    64d8:	47b0      	blx	r6
    64da:	42a0      	cmp	r0, r4
    64dc:	bfcc      	ite	gt
    64de:	2400      	movgt	r4, #0
    64e0:	2401      	movle	r4, #1
    64e2:	e7bb      	b.n	645c <expr_level_0+0xc>
        }
        else if (peeked == '<' && peeked2 == '='){
            get(e); // burn the second character
    64e4:	47b8      	blx	r7
            result = (result <= expr_level_1(e));
    64e6:	4628      	mov	r0, r5
    64e8:	47b0      	blx	r6
    64ea:	42a0      	cmp	r0, r4
    64ec:	bfb4      	ite	lt
    64ee:	2400      	movlt	r4, #0
    64f0:	2401      	movge	r4, #1
    64f2:	e7b3      	b.n	645c <expr_level_0+0xc>
                (peek(e) == '=' && peek2(e) == '=') ||
    64f4:	2b21      	cmp	r3, #33	; 0x21
    64f6:	d0b9      	beq.n	646c <expr_level_0+0x1c>
        }
    }
    return result;
}
    64f8:	4620      	mov	r0, r4
    64fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    64fc:	000065bd 	.word	0x000065bd
    6500:	00006415 	.word	0x00006415

00006504 <expr_level_3>:
        get(e);
    6504:	4913      	ldr	r1, [pc, #76]	; (6554 <expr_level_3+0x50>)
{
    6506:	b570      	push	{r4, r5, r6, lr}
    6508:	4604      	mov	r4, r0
    650a:	2501      	movs	r5, #1
    return **e;
    650c:	6823      	ldr	r3, [r4, #0]
    650e:	781b      	ldrb	r3, [r3, #0]
    if (peek(e) >= '0' && peek(e) <= '9') // HEX para
    6510:	2b2f      	cmp	r3, #47	; 0x2f
    6512:	d908      	bls.n	6526 <expr_level_3+0x22>
    6514:	2b39      	cmp	r3, #57	; 0x39
    6516:	d818      	bhi.n	654a <expr_level_3+0x46>
        return number(e);
    6518:	4b0f      	ldr	r3, [pc, #60]	; (6558 <expr_level_3+0x54>)
    651a:	4620      	mov	r0, r4
    651c:	4798      	blx	r3
    651e:	4601      	mov	r1, r0
}
    6520:	fb05 f001 	mul.w	r0, r5, r1
    6524:	bd70      	pop	{r4, r5, r6, pc}
    else if (peek(e) == '(')
    6526:	2b28      	cmp	r3, #40	; 0x28
    6528:	d109      	bne.n	653e <expr_level_3+0x3a>
        get(e); // '('
    652a:	4e0a      	ldr	r6, [pc, #40]	; (6554 <expr_level_3+0x50>)
    652c:	4620      	mov	r0, r4
    652e:	47b0      	blx	r6
        int result = expr_level_0(e);
    6530:	4b0a      	ldr	r3, [pc, #40]	; (655c <expr_level_3+0x58>)
    6532:	4620      	mov	r0, r4
    6534:	4798      	blx	r3
    6536:	4601      	mov	r1, r0
        get(e); // ')'
    6538:	4620      	mov	r0, r4
    653a:	47b0      	blx	r6
        return result;
    653c:	e7f0      	b.n	6520 <expr_level_3+0x1c>
    else if (peek(e) == '-')
    653e:	2b2d      	cmp	r3, #45	; 0x2d
    6540:	d103      	bne.n	654a <expr_level_3+0x46>
        get(e);
    6542:	4620      	mov	r0, r4
    6544:	4788      	blx	r1
        return -expr_level_3(e);
    6546:	426d      	negs	r5, r5
    6548:	e7e0      	b.n	650c <expr_level_3+0x8>
    printf("ERROR in expr_level_3()\n");
    654a:	4805      	ldr	r0, [pc, #20]	; (6560 <expr_level_3+0x5c>)
    654c:	4b05      	ldr	r3, [pc, #20]	; (6564 <expr_level_3+0x60>)
    654e:	4798      	blx	r3
    return 0; // error
    6550:	2100      	movs	r1, #0
    6552:	e7e5      	b.n	6520 <expr_level_3+0x1c>
    6554:	00006415 	.word	0x00006415
    6558:	00006421 	.word	0x00006421
    655c:	00006451 	.word	0x00006451
    6560:	00016b49 	.word	0x00016b49
    6564:	000147bd 	.word	0x000147bd

00006568 <expr_level_2>:
{
    6568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_3(e);
    656a:	4e13      	ldr	r6, [pc, #76]	; (65b8 <expr_level_2+0x50>)
{
    656c:	4605      	mov	r5, r0
    int result = expr_level_3(e);
    656e:	47b0      	blx	r6
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6570:	f240 4721 	movw	r7, #1057	; 0x421
    int result = expr_level_3(e);
    6574:	4604      	mov	r4, r0
    return **e;
    6576:	682a      	ldr	r2, [r5, #0]
    6578:	7811      	ldrb	r1, [r2, #0]
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    657a:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
    657e:	b2db      	uxtb	r3, r3
    6580:	2b0a      	cmp	r3, #10
    6582:	d803      	bhi.n	658c <expr_level_2+0x24>
    6584:	fa27 f303 	lsr.w	r3, r7, r3
    6588:	07db      	lsls	r3, r3, #31
    658a:	d401      	bmi.n	6590 <expr_level_2+0x28>
}
    658c:	4620      	mov	r0, r4
    658e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ++*e;
    6590:	3201      	adds	r2, #1
        if (peeked == '*'){
    6592:	292a      	cmp	r1, #42	; 0x2a
    ++*e;
    6594:	602a      	str	r2, [r5, #0]
            result *= expr_level_3(e);
    6596:	4628      	mov	r0, r5
        if (peeked == '*'){
    6598:	d102      	bne.n	65a0 <expr_level_2+0x38>
            result *= expr_level_3(e);
    659a:	47b0      	blx	r6
    659c:	4344      	muls	r4, r0
    659e:	e7ea      	b.n	6576 <expr_level_2+0xe>
        else if (peeked == '%'){
    65a0:	2925      	cmp	r1, #37	; 0x25
    65a2:	d105      	bne.n	65b0 <expr_level_2+0x48>
            result %= expr_level_3(e);
    65a4:	47b0      	blx	r6
    65a6:	fb94 f3f0 	sdiv	r3, r4, r0
    65aa:	fb03 4410 	mls	r4, r3, r0, r4
    65ae:	e7e2      	b.n	6576 <expr_level_2+0xe>
            result /= expr_level_3(e);
    65b0:	47b0      	blx	r6
    65b2:	fb94 f4f0 	sdiv	r4, r4, r0
    65b6:	e7de      	b.n	6576 <expr_level_2+0xe>
    65b8:	00006505 	.word	0x00006505

000065bc <expr_level_1>:
{
    65bc:	b570      	push	{r4, r5, r6, lr}
    int result = expr_level_2(e);
    65be:	4e0b      	ldr	r6, [pc, #44]	; (65ec <expr_level_1+0x30>)
{
    65c0:	4605      	mov	r5, r0
    int result = expr_level_2(e);
    65c2:	47b0      	blx	r6
    65c4:	4604      	mov	r4, r0
    return **e;
    65c6:	682b      	ldr	r3, [r5, #0]
    65c8:	781a      	ldrb	r2, [r3, #0]
    while (peek(e) == '+' || peek(e) == '-')
    65ca:	2a2b      	cmp	r2, #43	; 0x2b
    65cc:	d003      	beq.n	65d6 <expr_level_1+0x1a>
    65ce:	2a2d      	cmp	r2, #45	; 0x2d
    65d0:	d001      	beq.n	65d6 <expr_level_1+0x1a>
}
    65d2:	4620      	mov	r0, r4
    65d4:	bd70      	pop	{r4, r5, r6, pc}
    ++*e;
    65d6:	3301      	adds	r3, #1
        if (get(e) == '+')
    65d8:	2a2b      	cmp	r2, #43	; 0x2b
    ++*e;
    65da:	602b      	str	r3, [r5, #0]
            result += expr_level_2(e);
    65dc:	4628      	mov	r0, r5
        if (get(e) == '+')
    65de:	d102      	bne.n	65e6 <expr_level_1+0x2a>
            result += expr_level_2(e);
    65e0:	47b0      	blx	r6
    65e2:	4404      	add	r4, r0
    65e4:	e7ef      	b.n	65c6 <expr_level_1+0xa>
            result -= expr_level_2(e);
    65e6:	47b0      	blx	r6
    65e8:	1a24      	subs	r4, r4, r0
    65ea:	e7ec      	b.n	65c6 <expr_level_1+0xa>
    65ec:	00006569 	.word	0x00006569

000065f0 <insertTo>:


    return expression_inner(&str);
}

void insertTo(char* start,int length,char* that){
    65f0:	b570      	push	{r4, r5, r6, lr}
    65f2:	b09a      	sub	sp, #104	; 0x68
    65f4:	4604      	mov	r4, r0
    
    char ending[100] = {0};
    65f6:	4b0b      	ldr	r3, [pc, #44]	; (6624 <insertTo+0x34>)
void insertTo(char* start,int length,char* that){
    65f8:	4615      	mov	r5, r2
    65fa:	460e      	mov	r6, r1
    char ending[100] = {0};
    65fc:	2260      	movs	r2, #96	; 0x60
    65fe:	2100      	movs	r1, #0
    6600:	a802      	add	r0, sp, #8
    6602:	9101      	str	r1, [sp, #4]
    6604:	4798      	blx	r3
    
    //printf("insertTo: Hova: %s Milyen hosszú helyre: %d Mit: %s\n", start, length, that);
    
    sprintf(ending,"%s",start+length);
    6606:	19a1      	adds	r1, r4, r6
    6608:	a801      	add	r0, sp, #4
    660a:	4e07      	ldr	r6, [pc, #28]	; (6628 <insertTo+0x38>)
    660c:	47b0      	blx	r6
    sprintf(start,"%s",that);
    660e:	4629      	mov	r1, r5
    6610:	4620      	mov	r0, r4
    6612:	47b0      	blx	r6
    sprintf(start+strlen(that),"%s",ending);
    6614:	4b05      	ldr	r3, [pc, #20]	; (662c <insertTo+0x3c>)
    6616:	4628      	mov	r0, r5
    6618:	4798      	blx	r3
    661a:	a901      	add	r1, sp, #4
    661c:	4420      	add	r0, r4
    661e:	47b0      	blx	r6
}
    6620:	b01a      	add	sp, #104	; 0x68
    6622:	bd70      	pop	{r4, r5, r6, pc}
    6624:	00014469 	.word	0x00014469
    6628:	00014ebd 	.word	0x00014ebd
    662c:	00014f81 	.word	0x00014f81

00006630 <brack_len>:
        // START: SUKU
    
    int nyitCount = 0;
    int zarCount = 0;
    
    for(int i=0; i<maxLen; i++){
    6630:	2300      	movs	r3, #0
int brack_len(char* funcDesc,int maxLen){ //pl.: almafa(6*(2+2))*45
    6632:	b530      	push	{r4, r5, lr}
    int nyitCount = 0;
    6634:	461a      	mov	r2, r3
    int zarCount = 0;
    6636:	461c      	mov	r4, r3
    for(int i=0; i<maxLen; i++){
    6638:	428b      	cmp	r3, r1
    663a:	da0c      	bge.n	6656 <brack_len+0x26>
        
        if (funcDesc[i] == '('){
    663c:	5cc5      	ldrb	r5, [r0, r3]
    663e:	2d28      	cmp	r5, #40	; 0x28
    6640:	f103 0301 	add.w	r3, r3, #1
    6644:	d101      	bne.n	664a <brack_len+0x1a>
            
            nyitCount++;
    6646:	3201      	adds	r2, #1
    6648:	e7f6      	b.n	6638 <brack_len+0x8>
        }
        else if (funcDesc[i] == ')'){
    664a:	2d29      	cmp	r5, #41	; 0x29
    664c:	d1f4      	bne.n	6638 <brack_len+0x8>
            zarCount++;
    664e:	3401      	adds	r4, #1
            
            if (zarCount == nyitCount){
    6650:	42a2      	cmp	r2, r4
    6652:	d1f1      	bne.n	6638 <brack_len+0x8>
                return i+1;
    6654:	4618      	mov	r0, r3
            }
        }
        
    }
}
    6656:	bd30      	pop	{r4, r5, pc}

00006658 <calcSubFnc>:



void calcSubFnc(char* startposition){
    6658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    uint8_t debug_level = 0; 

    char* fName = startposition;
    char* fNameEnd = strstr(fName,"(");
    665c:	4b82      	ldr	r3, [pc, #520]	; (6868 <calcSubFnc+0x210>)
void calcSubFnc(char* startposition){
    665e:	b0ab      	sub	sp, #172	; 0xac
    char* fNameEnd = strstr(fName,"(");
    6660:	2128      	movs	r1, #40	; 0x28
void calcSubFnc(char* startposition){
    6662:	4680      	mov	r8, r0
    char* fNameEnd = strstr(fName,"(");
    6664:	4798      	blx	r3


    if (debug_level) printf("FNC name: ");
    if (debug_level) delay_ms(1);

    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6666:	eba0 0208 	sub.w	r2, r0, r8
    char* fNameEnd = strstr(fName,"(");
    666a:	4681      	mov	r9, r0
    for(uint8_t i=0; i<fNameEnd-fName; i++){
    666c:	2300      	movs	r3, #0
    666e:	9200      	str	r2, [sp, #0]
    6670:	9900      	ldr	r1, [sp, #0]
    6672:	b2da      	uxtb	r2, r3
    6674:	428a      	cmp	r2, r1
    6676:	f103 0301 	add.w	r3, r3, #1
    667a:	dbf9      	blt.n	6670 <calcSubFnc+0x18>
    }

    if (debug_level) printf("\r\n");
    if (debug_level) delay_ms(1);
    
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    667c:	4b7b      	ldr	r3, [pc, #492]	; (686c <calcSubFnc+0x214>)
    
    if (debug_level) printf("calcSubFnc Maxoffset: %d  ## \r\n", max_offset);
    if (debug_level) delay_ms(5);;
    
    int param_expr_results[10] = {0};
    667e:	4f7c      	ldr	r7, [pc, #496]	; (6870 <calcSubFnc+0x218>)
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6680:	4648      	mov	r0, r9
    6682:	4798      	blx	r3
    6684:	4b7b      	ldr	r3, [pc, #492]	; (6874 <calcSubFnc+0x21c>)
    6686:	4601      	mov	r1, r0
    6688:	4648      	mov	r0, r9
    668a:	4798      	blx	r3
    int param_expr_results[10] = {0};
    668c:	2228      	movs	r2, #40	; 0x28
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    668e:	1e86      	subs	r6, r0, #2
    int param_expr_results[10] = {0};
    6690:	2100      	movs	r1, #0
    6692:	a807      	add	r0, sp, #28
    6694:	47b8      	blx	r7
    char* comma = strstr(start, ",");
    int commaoffset = -1;
    
    
    
    for (int i=0; i<max_offset; i=i){
    6696:	2500      	movs	r5, #0
    int param_expr_results_count = 0;
    6698:	462c      	mov	r4, r5
    for (int i=0; i<max_offset; i=i){
    669a:	42b5      	cmp	r5, r6
    669c:	da2a      	bge.n	66f4 <calcSubFnc+0x9c>
    669e:	eb09 0a05 	add.w	sl, r9, r5
    66a2:	4652      	mov	r2, sl
    66a4:	46ab      	mov	fp, r5
        
        int commaoffset = -1;
        
        for(int j=i; j<max_offset; j++){
            
            if (start[j] == ','){
    66a6:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    66aa:	f8cd b004 	str.w	fp, [sp, #4]
    66ae:	292c      	cmp	r1, #44	; 0x2c
    66b0:	f10b 0b01 	add.w	fp, fp, #1
    66b4:	f000 80cc 	beq.w	6850 <calcSubFnc+0x1f8>
        for(int j=i; j<max_offset; j++){
    66b8:	455e      	cmp	r6, fp
    66ba:	dcf4      	bgt.n	66a6 <calcSubFnc+0x4e>
 
        if (commaoffset==-1){
            
           // printf("No more commas! \r\n");
            
            char param_expr[20] = {0};
    66bc:	f04f 0900 	mov.w	r9, #0
    66c0:	4649      	mov	r1, r9
    66c2:	2210      	movs	r2, #16
    66c4:	a812      	add	r0, sp, #72	; 0x48
    66c6:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
            
            for (int j=0; j<(max_offset-i); j++){
    66ca:	1b75      	subs	r5, r6, r5
            char param_expr[20] = {0};
    66cc:	47b8      	blx	r7
            for (int j=0; j<(max_offset-i); j++){
    66ce:	4649      	mov	r1, r9
    66d0:	ab11      	add	r3, sp, #68	; 0x44
    66d2:	e003      	b.n	66dc <calcSubFnc+0x84>
                param_expr[j] = start[i+j];
    66d4:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
    66d8:	545a      	strb	r2, [r3, r1]
            for (int j=0; j<(max_offset-i); j++){
    66da:	3101      	adds	r1, #1
    66dc:	428d      	cmp	r5, r1
    66de:	dcf9      	bgt.n	66d4 <calcSubFnc+0x7c>
            }
            
            if (debug_level) printf("Parameter: \"%s\", ", param_expr);
            if (debug_level) delay_ms(2);
            
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66e0:	9304      	str	r3, [sp, #16]
    int result = expr_level_0(e);
    66e2:	a804      	add	r0, sp, #16
    66e4:	4b64      	ldr	r3, [pc, #400]	; (6878 <calcSubFnc+0x220>)
    66e6:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66e8:	ab2a      	add	r3, sp, #168	; 0xa8
    66ea:	eb03 0384 	add.w	r3, r3, r4, lsl #2
            
            
            if (debug_level) printf("Result: \"%d\" \r\n", param_expr_results[param_expr_results_count]);
            if (debug_level) delay_ms(2);
            
            param_expr_results_count++;
    66ee:	3401      	adds	r4, #1
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66f0:	f843 0c8c 	str.w	r0, [r3, #-140]
    
    
    // START: CALC BUILTIN


    char justName[10] = {0};
    66f4:	2300      	movs	r3, #0
    66f6:	aa04      	add	r2, sp, #16
    66f8:	e9cd 3304 	strd	r3, r3, [sp, #16]
    66fc:	f8ad 3018 	strh.w	r3, [sp, #24]
    
    for (int i=0; i<9; i++){
    6700:	f108 0008 	add.w	r0, r8, #8
    6704:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    6708:	4693      	mov	fp, r2
        
        if (fName[i] == '('){
    670a:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    670e:	2928      	cmp	r1, #40	; 0x28
    6710:	d127      	bne.n	6762 <calcSubFnc+0x10a>
        }
        
    }

    
    if(strcmp(justName,"abs")==0){
    6712:	495a      	ldr	r1, [pc, #360]	; (687c <calcSubFnc+0x224>)
    6714:	4d5a      	ldr	r5, [pc, #360]	; (6880 <calcSubFnc+0x228>)
    6716:	f8df a19c 	ldr.w	sl, [pc, #412]	; 68b4 <calcSubFnc+0x25c>
    671a:	4658      	mov	r0, fp
    671c:	47a8      	blx	r5
    671e:	f10d 0944 	add.w	r9, sp, #68	; 0x44
    6722:	b318      	cbz	r0, 676c <calcSubFnc+0x114>
        resultOfFnc = abs(param_expr_results[0]);
    }
    else if(strcmp(justName,"six")==0){
    6724:	4957      	ldr	r1, [pc, #348]	; (6884 <calcSubFnc+0x22c>)
    6726:	4658      	mov	r0, fp
    6728:	47a8      	blx	r5
    672a:	2800      	cmp	r0, #0
    672c:	f000 808e 	beq.w	684c <calcSubFnc+0x1f4>
        resultOfFnc = 666666;
    }
    else if(strcmp(justName,"add")==0){
    6730:	4955      	ldr	r1, [pc, #340]	; (6888 <calcSubFnc+0x230>)
    6732:	4658      	mov	r0, fp
    6734:	47a8      	blx	r5
    6736:	2800      	cmp	r0, #0
    6738:	d130      	bne.n	679c <calcSubFnc+0x144>
        resultOfFnc = param_expr_results[0] + param_expr_results[1];
    673a:	e9dd 5307 	ldrd	r5, r3, [sp, #28]
    673e:	441d      	add	r5, r3
    6740:	e018      	b.n	6774 <calcSubFnc+0x11c>
                param_expr[j] = start[i+j];
    6742:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
    6746:	5488      	strb	r0, [r1, r2]
            for (int j=0; j<commaoffset-i; j++){
    6748:	3201      	adds	r2, #1
    674a:	4295      	cmp	r5, r2
    674c:	dcf9      	bgt.n	6742 <calcSubFnc+0xea>
    int result = expr_level_0(e);
    674e:	4b4a      	ldr	r3, [pc, #296]	; (6878 <calcSubFnc+0x220>)
    6750:	9104      	str	r1, [sp, #16]
    6752:	a804      	add	r0, sp, #16
    6754:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6756:	ab07      	add	r3, sp, #28
    6758:	465d      	mov	r5, fp
    675a:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
            param_expr_results_count++;
    675e:	3401      	adds	r4, #1
    for (int i=0; i<max_offset; i=i){
    6760:	e79b      	b.n	669a <calcSubFnc+0x42>
    for (int i=0; i<9; i++){
    6762:	4283      	cmp	r3, r0
            justName[i] = fName[i];
    6764:	f802 1b01 	strb.w	r1, [r2], #1
    for (int i=0; i<9; i++){
    6768:	d1cf      	bne.n	670a <calcSubFnc+0xb2>
    676a:	e7d2      	b.n	6712 <calcSubFnc+0xba>
        resultOfFnc = abs(param_expr_results[0]);
    676c:	9d07      	ldr	r5, [sp, #28]
    676e:	2d00      	cmp	r5, #0
    6770:	bfb8      	it	lt
    6772:	426d      	neglt	r5, r5
    
    //printf("resultOfFnc: %d\n", resultOfFnc);
    

    
    char buff[100] = {0};
    6774:	2100      	movs	r1, #0
    6776:	2260      	movs	r2, #96	; 0x60
    6778:	a812      	add	r0, sp, #72	; 0x48
    677a:	9111      	str	r1, [sp, #68]	; 0x44
    677c:	47b8      	blx	r7
    
    sprintf(buff,"(%d)",resultOfFnc); //HEX para, sign para
    677e:	462a      	mov	r2, r5
    6780:	4942      	ldr	r1, [pc, #264]	; (688c <calcSubFnc+0x234>)
    6782:	4648      	mov	r0, r9
    6784:	47d0      	blx	sl
    
    // hova, milyen hosszan, mit
    insertTo(startposition,(fNameEnd-fName)+max_offset+2,buff);
    6786:	9b00      	ldr	r3, [sp, #0]
    6788:	4433      	add	r3, r6
    678a:	4619      	mov	r1, r3
    678c:	464a      	mov	r2, r9
    678e:	4b40      	ldr	r3, [pc, #256]	; (6890 <calcSubFnc+0x238>)
    6790:	3102      	adds	r1, #2
    6792:	4640      	mov	r0, r8
    6794:	4798      	blx	r3
    
        
    //printf(" @@ debug: %s @@\n", startposition);
}
    6796:	b02b      	add	sp, #172	; 0xac
    6798:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    679c:	493d      	ldr	r1, [pc, #244]	; (6894 <calcSubFnc+0x23c>)
    679e:	4658      	mov	r0, fp
    67a0:	47a8      	blx	r5
    67a2:	b120      	cbz	r0, 67ae <calcSubFnc+0x156>
    67a4:	493c      	ldr	r1, [pc, #240]	; (6898 <calcSubFnc+0x240>)
    67a6:	4658      	mov	r0, fp
    67a8:	47a8      	blx	r5
    67aa:	2800      	cmp	r0, #0
    67ac:	d13e      	bne.n	682c <calcSubFnc+0x1d4>
        char fmt_str[] = "%02x";
    67ae:	4b3b      	ldr	r3, [pc, #236]	; (689c <calcSubFnc+0x244>)
        if (param_expr_results_count>1){
    67b0:	2c01      	cmp	r4, #1
        char fmt_str[] = "%02x";
    67b2:	6818      	ldr	r0, [r3, #0]
    67b4:	791b      	ldrb	r3, [r3, #4]
    67b6:	9002      	str	r0, [sp, #8]
    67b8:	f88d 300c 	strb.w	r3, [sp, #12]
        if (param_expr_results_count>1){
    67bc:	dd0a      	ble.n	67d4 <calcSubFnc+0x17c>
            if (param_expr_results[param_expr_results_count-1]<=8){
    67be:	ab2a      	add	r3, sp, #168	; 0xa8
    67c0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    67c4:	f853 3c90 	ldr.w	r3, [r3, #-144]
    67c8:	2b08      	cmp	r3, #8
                fmt_str[2] = param_expr_results[param_expr_results_count-1]+'0';
    67ca:	bfd4      	ite	le
    67cc:	3330      	addle	r3, #48	; 0x30
                fmt_str[2] = 8+'0';
    67ce:	2338      	movgt	r3, #56	; 0x38
    67d0:	f88d 300a 	strb.w	r3, [sp, #10]
        uint8_t temp_array[20] = {0};
    67d4:	2100      	movs	r1, #0
    67d6:	2210      	movs	r2, #16
    67d8:	a812      	add	r0, sp, #72	; 0x48
    67da:	9111      	str	r1, [sp, #68]	; 0x44
    67dc:	47b8      	blx	r7
        sprintf(temp_array, fmt_str, param_expr_results[0]);
    67de:	9d07      	ldr	r5, [sp, #28]
    67e0:	a902      	add	r1, sp, #8
    67e2:	462a      	mov	r2, r5
    67e4:	4648      	mov	r0, r9
    67e6:	47d0      	blx	sl
        if (param_expr_results_count>1){
    67e8:	2c01      	cmp	r4, #1
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67ea:	4a2d      	ldr	r2, [pc, #180]	; (68a0 <calcSubFnc+0x248>)
            temp_array_length = param_expr_results[param_expr_results_count-1];
    67ec:	bfc4      	itt	gt
    67ee:	ab2a      	addgt	r3, sp, #168	; 0xa8
    67f0:	eb03 0484 	addgt.w	r4, r3, r4, lsl #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67f4:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
            temp_array_length = param_expr_results[param_expr_results_count-1];
    67f8:	bfc8      	it	gt
    67fa:	f814 1c90 	ldrbgt.w	r1, [r4, #-144]
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67fe:	b2d8      	uxtb	r0, r3
    6800:	f5c3 73fc 	rsb	r3, r3, #504	; 0x1f8
            temp_array_length = 2; // default print length
    6804:	bfd8      	it	le
    6806:	2102      	movle	r1, #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6808:	3301      	adds	r3, #1
    680a:	1a5b      	subs	r3, r3, r1
    680c:	4413      	add	r3, r2
        for (uint8_t i=0; i<temp_array_length; i++){
    680e:	2400      	movs	r4, #0
    6810:	fa5f fc84 	uxtb.w	ip, r4
    6814:	458c      	cmp	ip, r1
    6816:	d303      	bcc.n	6820 <calcSubFnc+0x1c8>
        expr->output_string_length += temp_array_length;
    6818:	4401      	add	r1, r0
    681a:	f882 11fa 	strb.w	r1, [r2, #506]	; 0x1fa
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    681e:	e7a9      	b.n	6774 <calcSubFnc+0x11c>
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6820:	f819 c004 	ldrb.w	ip, [r9, r4]
    6824:	f803 cb01 	strb.w	ip, [r3], #1
        for (uint8_t i=0; i<temp_array_length; i++){
    6828:	3401      	adds	r4, #1
    682a:	e7f1      	b.n	6810 <calcSubFnc+0x1b8>
    else if(strcmp(justName,"if")==0){
    682c:	491d      	ldr	r1, [pc, #116]	; (68a4 <calcSubFnc+0x24c>)
    682e:	4658      	mov	r0, fp
    6830:	47a8      	blx	r5
    6832:	b928      	cbnz	r0, 6840 <calcSubFnc+0x1e8>
        if (param_expr_results[0]){
    6834:	9b07      	ldr	r3, [sp, #28]
    6836:	b10b      	cbz	r3, 683c <calcSubFnc+0x1e4>
            resultOfFnc = param_expr_results[1];
    6838:	9d08      	ldr	r5, [sp, #32]
    683a:	e79b      	b.n	6774 <calcSubFnc+0x11c>
            resultOfFnc = param_expr_results[2];
    683c:	9d09      	ldr	r5, [sp, #36]	; 0x24
    683e:	e799      	b.n	6774 <calcSubFnc+0x11c>
        printf("Function \"%s\" not found!\n", justName);
    6840:	4819      	ldr	r0, [pc, #100]	; (68a8 <calcSubFnc+0x250>)
    6842:	4b1a      	ldr	r3, [pc, #104]	; (68ac <calcSubFnc+0x254>)
    6844:	4659      	mov	r1, fp
    6846:	4798      	blx	r3
        resultOfFnc = 0;
    6848:	2500      	movs	r5, #0
    684a:	e793      	b.n	6774 <calcSubFnc+0x11c>
        resultOfFnc = 666666;
    684c:	4d18      	ldr	r5, [pc, #96]	; (68b0 <calcSubFnc+0x258>)
    684e:	e791      	b.n	6774 <calcSubFnc+0x11c>
            char param_expr[20] = {0};
    6850:	2300      	movs	r3, #0
    6852:	4619      	mov	r1, r3
    6854:	9311      	str	r3, [sp, #68]	; 0x44
    6856:	2210      	movs	r2, #16
    6858:	4b05      	ldr	r3, [pc, #20]	; (6870 <calcSubFnc+0x218>)
    685a:	a812      	add	r0, sp, #72	; 0x48
    685c:	4798      	blx	r3
            for (int j=0; j<commaoffset-i; j++){
    685e:	9b01      	ldr	r3, [sp, #4]
    6860:	2200      	movs	r2, #0
    6862:	1b5d      	subs	r5, r3, r5
    6864:	a911      	add	r1, sp, #68	; 0x44
    6866:	e770      	b.n	674a <calcSubFnc+0xf2>
    6868:	00014b09 	.word	0x00014b09
    686c:	00014f81 	.word	0x00014f81
    6870:	00014469 	.word	0x00014469
    6874:	00006631 	.word	0x00006631
    6878:	00006451 	.word	0x00006451
    687c:	00016b61 	.word	0x00016b61
    6880:	00014be9 	.word	0x00014be9
    6884:	00016b65 	.word	0x00016b65
    6888:	00016b69 	.word	0x00016b69
    688c:	00016b90 	.word	0x00016b90
    6890:	000065f1 	.word	0x000065f1
    6894:	00016b6d 	.word	0x00016b6d
    6898:	00017746 	.word	0x00017746
    689c:	00016b95 	.word	0x00016b95
    68a0:	20013220 	.word	0x20013220
    68a4:	00016b73 	.word	0x00016b73
    68a8:	00016b76 	.word	0x00016b76
    68ac:	000146ad 	.word	0x000146ad
    68b0:	000a2c2a 	.word	0x000a2c2a
    68b4:	00014ac5 	.word	0x00014ac5

000068b8 <char_is_valid_name>:


uint8_t char_is_valid_name(uint8_t ch){


    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_')){
    68b8:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    68bc:	2b09      	cmp	r3, #9
    68be:	d909      	bls.n	68d4 <char_is_valid_name+0x1c>
    68c0:	f020 0320 	bic.w	r3, r0, #32
    68c4:	3b41      	subs	r3, #65	; 0x41
    68c6:	2b19      	cmp	r3, #25
    68c8:	d904      	bls.n	68d4 <char_is_valid_name+0x1c>

                    return 1;
    68ca:	f1a0 035f 	sub.w	r3, r0, #95	; 0x5f
    68ce:	4258      	negs	r0, r3
    68d0:	4158      	adcs	r0, r3
    68d2:	4770      	bx	lr
    68d4:	2001      	movs	r0, #1
                }
    
    return 0;


}
    68d6:	4770      	bx	lr

000068d8 <subst_all_variables_starting_from_the_back>:


void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    68dc:	ed2d 8b02 	vpush	{d8}
    uint8_t variable_name_valid = 0;
    

    int izgi = 0;
    int var_end_pos = -1;
    char var_name[10] = {0};
    68e0:	2200      	movs	r2, #0
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68e2:	b0a1      	sub	sp, #132	; 0x84
    char var_name[10] = {0};
    68e4:	e9cd 2201 	strd	r2, r2, [sp, #4]
    68e8:	f8df a23c 	ldr.w	sl, [pc, #572]	; 6b28 <subst_all_variables_starting_from_the_back+0x250>
    68ec:	f8ad 200c 	strh.w	r2, [sp, #12]
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68f0:	460d      	mov	r5, r1
    68f2:	1846      	adds	r6, r0, r1
    int var_end_pos = -1;
    68f4:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    uint8_t variable_name_found = 0;
    68f8:	4611      	mov	r1, r2
    uint8_t function_name_found = 0;
    68fa:	4691      	mov	r9, r2
    
    if (debug_level) printf("Subst Vars\r\n");
    
    // i must be signed int
    for(int i = len; i>=0; i--){
    68fc:	2d00      	cmp	r5, #0
    68fe:	da04      	bge.n	690a <subst_all_variables_starting_from_the_back+0x32>
    if (debug_level ==2) printf("i%d %d %d %d\r\n",i, function_name_found, variable_name_found, variable_name_valid);
    if (debug_level ==2) delay_ms(5);
        
    }
    
}
    6900:	b021      	add	sp, #132	; 0x84
    6902:	ecbd 8b02 	vpop	{d8}
    6906:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (function_name_found){
    690a:	ee08 6a10 	vmov	s16, r6
    690e:	f816 4901 	ldrb.w	r4, [r6], #-1
    6912:	4620      	mov	r0, r4
    6914:	47d0      	blx	sl
    6916:	f1b9 0f00 	cmp.w	r9, #0
    691a:	d011      	beq.n	6940 <subst_all_variables_starting_from_the_back+0x68>
                function_name_found=0;
    691c:	f1b0 0900 	subs.w	r9, r0, #0
    6920:	bf18      	it	ne
    6922:	f04f 0901 	movne.w	r9, #1
        if (variable_name_found){
    6926:	2900      	cmp	r1, #0
    6928:	d144      	bne.n	69b4 <subst_all_variables_starting_from_the_back+0xdc>
                for (int j = 0; j<10; j++){
    692a:	2300      	movs	r3, #0
    692c:	aa01      	add	r2, sp, #4
                var_name[j] = 0;
    692e:	4619      	mov	r1, r3
            for (int j = 0; j<10; j++){
    6930:	3301      	adds	r3, #1
    6932:	2b0a      	cmp	r3, #10
                var_name[j] = 0;
    6934:	f802 1b01 	strb.w	r1, [r2], #1
            for (int j = 0; j<10; j++){
    6938:	d1fa      	bne.n	6930 <subst_all_variables_starting_from_the_back+0x58>
            variable_name_valid = 0;
    693a:	2200      	movs	r2, #0
            variable_name_found = 0;
    693c:	4611      	mov	r1, r2
    693e:	e04c      	b.n	69da <subst_all_variables_starting_from_the_back+0x102>
        else if (variable_name_found == 0){
    6940:	2900      	cmp	r1, #0
    6942:	d137      	bne.n	69b4 <subst_all_variables_starting_from_the_back+0xdc>
            if  (char_is_valid_name(expr_string[i])){
    6944:	2800      	cmp	r0, #0
    6946:	d0f0      	beq.n	692a <subst_all_variables_starting_from_the_back+0x52>
                if (expr_string[i+1] == '('){
    6948:	78b3      	ldrb	r3, [r6, #2]
    694a:	2b28      	cmp	r3, #40	; 0x28
    694c:	f000 80cd 	beq.w	6aea <subst_all_variables_starting_from_the_back+0x212>
                    if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6950:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
                        variable_name_valid = 1; 
    6954:	2b09      	cmp	r3, #9
    6956:	bf88      	it	hi
    6958:	2201      	movhi	r2, #1
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    695a:	46ab      	mov	fp, r5
                var_name[var_end_pos-i] = expr_string[i];
    695c:	ebab 0305 	sub.w	r3, fp, r5
    6960:	a920      	add	r1, sp, #128	; 0x80
    6962:	440b      	add	r3, r1
    6964:	f803 4c7c 	strb.w	r4, [r3, #-124]
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6968:	3c30      	subs	r4, #48	; 0x30
    696a:	2c09      	cmp	r4, #9
    696c:	d924      	bls.n	69b8 <subst_all_variables_starting_from_the_back+0xe0>
                if (i==0){
    696e:	b125      	cbz	r5, 697a <subst_all_variables_starting_from_the_back+0xa2>
                    if (!char_is_valid_name(expr_string[i-1])){
    6970:	7830      	ldrb	r0, [r6, #0]
    6972:	47d0      	blx	sl
    6974:	2800      	cmp	r0, #0
    6976:	f040 80b6 	bne.w	6ae6 <subst_all_variables_starting_from_the_back+0x20e>
                    int var_name_len = strlen(var_name);
    697a:	4b5e      	ldr	r3, [pc, #376]	; (6af4 <subst_all_variables_starting_from_the_back+0x21c>)
    697c:	a801      	add	r0, sp, #4
    697e:	4798      	blx	r3
                    char var_name_good[10] = {0};
    6980:	2300      	movs	r3, #0
    6982:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6986:	aa01      	add	r2, sp, #4
                    int var_name_len = strlen(var_name);
    6988:	4680      	mov	r8, r0
                    char var_name_good[10] = {0};
    698a:	4402      	add	r2, r0
    698c:	f8ad 3018 	strh.w	r3, [sp, #24]
                    for (int j = 0; j<var_name_len; j++){
    6990:	a904      	add	r1, sp, #16
                        var_name_good[j+1] = 0;
    6992:	4618      	mov	r0, r3
                    for (int j = 0; j<var_name_len; j++){
    6994:	4543      	cmp	r3, r8
    6996:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
    699a:	db20      	blt.n	69de <subst_all_variables_starting_from_the_back+0x106>
                    if (var_name_len == 2 || var_name_len == 3){
    699c:	f1a8 0302 	sub.w	r3, r8, #2
    69a0:	2b01      	cmp	r3, #1
    69a2:	d864      	bhi.n	6a6e <subst_all_variables_starting_from_the_back+0x196>
                        if (var_name_good[0] == 'T'){
    69a4:	f89d 3010 	ldrb.w	r3, [sp, #16]
    69a8:	2b54      	cmp	r3, #84	; 0x54
    69aa:	d15e      	bne.n	6a6a <subst_all_variables_starting_from_the_back+0x192>
                            for (uint8_t j = 1; j<var_name_len; j++){
    69ac:	2301      	movs	r3, #1
                            uint8_t index = 0;
    69ae:	2200      	movs	r2, #0
                            uint8_t is_template_var = 1;
    69b0:	4618      	mov	r0, r3
    69b2:	e02d      	b.n	6a10 <subst_all_variables_starting_from_the_back+0x138>
            if (char_is_valid_name(expr_string[i])){
    69b4:	2800      	cmp	r0, #0
    69b6:	d1d1      	bne.n	695c <subst_all_variables_starting_from_the_back+0x84>
            if (variable_name_valid){
    69b8:	2a00      	cmp	r2, #0
    69ba:	d1d8      	bne.n	696e <subst_all_variables_starting_from_the_back+0x96>
    69bc:	2401      	movs	r4, #1
            if (!char_is_valid_name(expr_string[i])){
    69be:	7870      	ldrb	r0, [r6, #1]
    69c0:	47d0      	blx	sl
    69c2:	4601      	mov	r1, r0
    69c4:	2800      	cmp	r0, #0
    69c6:	f040 8093 	bne.w	6af0 <subst_all_variables_starting_from_the_back+0x218>
    69ca:	aa01      	add	r2, sp, #4
                for (int j = 0; j<10; j++){
    69cc:	4603      	mov	r3, r0
    69ce:	3301      	adds	r3, #1
    69d0:	2b0a      	cmp	r3, #10
                    var_name[j] = 0;
    69d2:	f802 0b01 	strb.w	r0, [r2], #1
                for (int j = 0; j<10; j++){
    69d6:	d1fa      	bne.n	69ce <subst_all_variables_starting_from_the_back+0xf6>
                variable_name_valid = 0;
    69d8:	2200      	movs	r2, #0
    for(int i = len; i>=0; i--){
    69da:	3d01      	subs	r5, #1
    69dc:	e78e      	b.n	68fc <subst_all_variables_starting_from_the_back+0x24>
                        var_name_good[j] = var_name[var_name_len-1-j];
    69de:	7814      	ldrb	r4, [r2, #0]
    69e0:	700c      	strb	r4, [r1, #0]
                        var_name_good[j+1] = 0;
    69e2:	3301      	adds	r3, #1
    69e4:	f801 0f01 	strb.w	r0, [r1, #1]!
                    for (int j = 0; j<var_name_len; j++){
    69e8:	e7d4      	b.n	6994 <subst_all_variables_starting_from_the_back+0xbc>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    69ea:	a920      	add	r1, sp, #128	; 0x80
    69ec:	4419      	add	r1, r3
                            for (uint8_t j = 1; j<var_name_len; j++){
    69ee:	3301      	adds	r3, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    69f0:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    69f4:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    69f8:	2c09      	cmp	r4, #9
                                    index = index*10;
    69fa:	bf9f      	itttt	ls
    69fc:	eb02 0282 	addls.w	r2, r2, r2, lsl #2
    6a00:	eb01 0242 	addls.w	r2, r1, r2, lsl #1
                                    index += var_name_good[j] - '0'; 
    6a04:	3a30      	subls	r2, #48	; 0x30
    6a06:	f002 02ff 	andls.w	r2, r2, #255	; 0xff
                                    is_template_var = 0;
    6a0a:	bf88      	it	hi
    6a0c:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a0e:	b2db      	uxtb	r3, r3
    6a10:	4543      	cmp	r3, r8
    6a12:	dbea      	blt.n	69ea <subst_all_variables_starting_from_the_back+0x112>
                            if (is_template_var){
    6a14:	b358      	cbz	r0, 6a6e <subst_all_variables_starting_from_the_back+0x196>
                                variable_value = grid_expr_state.current_event->parent->template_parameter_list[index];
    6a16:	4b38      	ldr	r3, [pc, #224]	; (6af8 <subst_all_variables_starting_from_the_back+0x220>)
    6a18:	681b      	ldr	r3, [r3, #0]
    6a1a:	685b      	ldr	r3, [r3, #4]
    6a1c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    6a20:	68d4      	ldr	r4, [r2, #12]
                    char buff[100] = {0};
    6a22:	4b36      	ldr	r3, [pc, #216]	; (6afc <subst_all_variables_starting_from_the_back+0x224>)
    6a24:	2700      	movs	r7, #0
    6a26:	2260      	movs	r2, #96	; 0x60
    6a28:	4639      	mov	r1, r7
    6a2a:	a808      	add	r0, sp, #32
    6a2c:	9707      	str	r7, [sp, #28]
    6a2e:	4798      	blx	r3
                    sprintf(buff,"%d",variable_value); // HEX para
    6a30:	4933      	ldr	r1, [pc, #204]	; (6b00 <subst_all_variables_starting_from_the_back+0x228>)
    6a32:	4b34      	ldr	r3, [pc, #208]	; (6b04 <subst_all_variables_starting_from_the_back+0x22c>)
    6a34:	4622      	mov	r2, r4
    6a36:	a807      	add	r0, sp, #28
    6a38:	4798      	blx	r3
                    insertTo(found,var_name_len,buff);
    6a3a:	4b33      	ldr	r3, [pc, #204]	; (6b08 <subst_all_variables_starting_from_the_back+0x230>)
    6a3c:	aa07      	add	r2, sp, #28
    6a3e:	4641      	mov	r1, r8
    6a40:	ee18 0a10 	vmov	r0, s16
    6a44:	4798      	blx	r3
                    for (int j = 0; j<10; j++){
    6a46:	ab01      	add	r3, sp, #4
                    insertTo(found,var_name_len,buff);
    6a48:	461a      	mov	r2, r3
                        var_name[j] = 0;
    6a4a:	4639      	mov	r1, r7
                    for (int j = 0; j<10; j++){
    6a4c:	3701      	adds	r7, #1
    6a4e:	2f0a      	cmp	r7, #10
                        var_name[j] = 0;
    6a50:	f802 1b01 	strb.w	r1, [r2], #1
                    for (int j = 0; j<10; j++){
    6a54:	d1fa      	bne.n	6a4c <subst_all_variables_starting_from_the_back+0x174>
                    for (int j = 0; j<10; j++){
    6a56:	2200      	movs	r2, #0
                        var_name[j] = 0;
    6a58:	4611      	mov	r1, r2
                    for (int j = 0; j<10; j++){
    6a5a:	3201      	adds	r2, #1
    6a5c:	2a0a      	cmp	r2, #10
                        var_name[j] = 0;
    6a5e:	f803 1b01 	strb.w	r1, [r3], #1
                    for (int j = 0; j<10; j++){
    6a62:	d1fa      	bne.n	6a5a <subst_all_variables_starting_from_the_back+0x182>
                    variable_name_valid = 0;
    6a64:	2200      	movs	r2, #0
    6a66:	4614      	mov	r4, r2
    6a68:	e7a9      	b.n	69be <subst_all_variables_starting_from_the_back+0xe6>
                        else if (var_name_good[0] == 'Z'){
    6a6a:	2b5a      	cmp	r3, #90	; 0x5a
    6a6c:	d01e      	beq.n	6aac <subst_all_variables_starting_from_the_back+0x1d4>
                    int32_t variable_value = 1;
    6a6e:	2401      	movs	r4, #1
    6a70:	e7d7      	b.n	6a22 <subst_all_variables_starting_from_the_back+0x14a>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6a72:	a920      	add	r1, sp, #128	; 0x80
    6a74:	4411      	add	r1, r2
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a76:	3201      	adds	r2, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6a78:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6a7c:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6a80:	2c09      	cmp	r4, #9
                                    index = index*10;
    6a82:	bf9f      	itttt	ls
    6a84:	eb03 0383 	addls.w	r3, r3, r3, lsl #2
    6a88:	eb01 0343 	addls.w	r3, r1, r3, lsl #1
                                    index += var_name_good[j] - '0'; 
    6a8c:	3b30      	subls	r3, #48	; 0x30
    6a8e:	f003 03ff 	andls.w	r3, r3, #255	; 0xff
                                    is_template_var = 0;
    6a92:	bf88      	it	hi
    6a94:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a96:	b2d2      	uxtb	r2, r2
    6a98:	4542      	cmp	r2, r8
    6a9a:	dbea      	blt.n	6a72 <subst_all_variables_starting_from_the_back+0x19a>
                            if (is_template_var){
    6a9c:	2800      	cmp	r0, #0
    6a9e:	d0e6      	beq.n	6a6e <subst_all_variables_starting_from_the_back+0x196>
                                if (index == 0){
    6aa0:	b943      	cbnz	r3, 6ab4 <subst_all_variables_starting_from_the_back+0x1dc>
                                    variable_value = grid_sys_get_bank_num(&grid_sys_state);
    6aa2:	481a      	ldr	r0, [pc, #104]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6aa4:	4b1a      	ldr	r3, [pc, #104]	; (6b10 <subst_all_variables_starting_from_the_back+0x238>)
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6aa6:	4798      	blx	r3
    6aa8:	4604      	mov	r4, r0
    6aaa:	e7ba      	b.n	6a22 <subst_all_variables_starting_from_the_back+0x14a>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6aac:	2201      	movs	r2, #1
                            uint8_t index = 0;
    6aae:	2300      	movs	r3, #0
                            uint8_t is_template_var = 1;
    6ab0:	4610      	mov	r0, r2
    6ab2:	e7f1      	b.n	6a98 <subst_all_variables_starting_from_the_back+0x1c0>
                                else if (index == 1){
    6ab4:	2b01      	cmp	r3, #1
    6ab6:	d102      	bne.n	6abe <subst_all_variables_starting_from_the_back+0x1e6>
                                    variable_value = grid_sys_get_bank_red(&grid_sys_state);
    6ab8:	4814      	ldr	r0, [pc, #80]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6aba:	4b16      	ldr	r3, [pc, #88]	; (6b14 <subst_all_variables_starting_from_the_back+0x23c>)
    6abc:	e7f3      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 2){
    6abe:	2b02      	cmp	r3, #2
    6ac0:	d102      	bne.n	6ac8 <subst_all_variables_starting_from_the_back+0x1f0>
                                    variable_value = grid_sys_get_bank_gre(&grid_sys_state);
    6ac2:	4812      	ldr	r0, [pc, #72]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ac4:	4b14      	ldr	r3, [pc, #80]	; (6b18 <subst_all_variables_starting_from_the_back+0x240>)
    6ac6:	e7ee      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 3){
    6ac8:	2b03      	cmp	r3, #3
    6aca:	d102      	bne.n	6ad2 <subst_all_variables_starting_from_the_back+0x1fa>
                                    variable_value = grid_sys_get_bank_blu(&grid_sys_state);
    6acc:	480f      	ldr	r0, [pc, #60]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ace:	4b13      	ldr	r3, [pc, #76]	; (6b1c <subst_all_variables_starting_from_the_back+0x244>)
    6ad0:	e7e9      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 4){
    6ad2:	2b04      	cmp	r3, #4
    6ad4:	d102      	bne.n	6adc <subst_all_variables_starting_from_the_back+0x204>
                                    variable_value = grid_sys_get_map_state(&grid_sys_state);
    6ad6:	480d      	ldr	r0, [pc, #52]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ad8:	4b11      	ldr	r3, [pc, #68]	; (6b20 <subst_all_variables_starting_from_the_back+0x248>)
    6ada:	e7e4      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 5){
    6adc:	2b05      	cmp	r3, #5
    6ade:	d1c6      	bne.n	6a6e <subst_all_variables_starting_from_the_back+0x196>
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6ae0:	480a      	ldr	r0, [pc, #40]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ae2:	4b10      	ldr	r3, [pc, #64]	; (6b24 <subst_all_variables_starting_from_the_back+0x24c>)
    6ae4:	e7df      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
    6ae6:	2201      	movs	r2, #1
    6ae8:	e7bd      	b.n	6a66 <subst_all_variables_starting_from_the_back+0x18e>
                    function_name_found = 1;                    
    6aea:	f04f 0901 	mov.w	r9, #1
    6aee:	e71c      	b.n	692a <subst_all_variables_starting_from_the_back+0x52>
    6af0:	4621      	mov	r1, r4
    6af2:	e772      	b.n	69da <subst_all_variables_starting_from_the_back+0x102>
    6af4:	00014f81 	.word	0x00014f81
    6af8:	20013220 	.word	0x20013220
    6afc:	00014469 	.word	0x00014469
    6b00:	00016da1 	.word	0x00016da1
    6b04:	00014ac5 	.word	0x00014ac5
    6b08:	000065f1 	.word	0x000065f1
    6b0c:	2000f008 	.word	0x2000f008
    6b10:	00009707 	.word	0x00009707
    6b14:	00009711 	.word	0x00009711
    6b18:	00009717 	.word	0x00009717
    6b1c:	0000971d 	.word	0x0000971d
    6b20:	00009723 	.word	0x00009723
    6b24:	00009727 	.word	0x00009727
    6b28:	000068b9 	.word	0x000068b9

00006b2c <subst_all_functions_starting_from_the_back>:



void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6b2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    if (debug_level) printf("Subst Fncs in %s\r\n", expr_string);
    if (debug_level) delay_ms(5);
    
    uint8_t function_name_found = 0;
    uint8_t function_name_valid = 0;
    6b30:	2200      	movs	r2, #0

            
        }
        else if (function_name_found){
            
            if (char_is_valid_name(expr_string[i])){
    6b32:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6b9c <subst_all_functions_starting_from_the_back+0x70>
                //printf("izgi=%d, i=%d\n", izgi, i);  
                
            }
            else if (function_name_valid){
                
                calcSubFnc(&expr_string[i+1]);
    6b36:	4f18      	ldr	r7, [pc, #96]	; (6b98 <subst_all_functions_starting_from_the_back+0x6c>)
    6b38:	1844      	adds	r4, r0, r1
void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6b3a:	4605      	mov	r5, r0
    uint8_t function_name_found = 0;
    6b3c:	4611      	mov	r1, r2
    for(int i= len; i>=0; i--){
    6b3e:	ebb4 0a05 	subs.w	sl, r4, r5
    6b42:	d501      	bpl.n	6b48 <subst_all_functions_starting_from_the_back+0x1c>

        if (debug_level) printf("i%d %d %d\r\n",i, function_name_found, function_name_valid);
        if (debug_level) delay_ms(1);
    }
    
}
    6b44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (expr_string[i] == '(' && function_name_valid == 0){
    6b48:	7826      	ldrb	r6, [r4, #0]
    6b4a:	2e28      	cmp	r6, #40	; 0x28
    6b4c:	d100      	bne.n	6b50 <subst_all_functions_starting_from_the_back+0x24>
    6b4e:	b1e2      	cbz	r2, 6b8a <subst_all_functions_starting_from_the_back+0x5e>
        else if (function_name_found){
    6b50:	b1c9      	cbz	r1, 6b86 <subst_all_functions_starting_from_the_back+0x5a>
            if (char_is_valid_name(expr_string[i])){
    6b52:	4630      	mov	r0, r6
    6b54:	47c0      	blx	r8
    6b56:	4681      	mov	r9, r0
    6b58:	b158      	cbz	r0, 6b72 <subst_all_functions_starting_from_the_back+0x46>
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6b5a:	3e30      	subs	r6, #48	; 0x30
    6b5c:	2e09      	cmp	r6, #9
    6b5e:	d816      	bhi.n	6b8e <subst_all_functions_starting_from_the_back+0x62>
                if (i==0 && function_name_valid){ // start of expr string special case
    6b60:	f1ba 0f00 	cmp.w	sl, #0
    6b64:	d10f      	bne.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
    6b66:	b172      	cbz	r2, 6b86 <subst_all_functions_starting_from_the_back+0x5a>
                    calcSubFnc(&expr_string[i]);
    6b68:	4620      	mov	r0, r4
    6b6a:	47b8      	blx	r7
                    function_name_valid = 0;
    6b6c:	2200      	movs	r2, #0
                function_name_found = 0;
    6b6e:	4611      	mov	r1, r2
    6b70:	e009      	b.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
            else if (function_name_valid){
    6b72:	2a00      	cmp	r2, #0
    6b74:	d0fb      	beq.n	6b6e <subst_all_functions_starting_from_the_back+0x42>
                calcSubFnc(&expr_string[i+1]);
    6b76:	1c60      	adds	r0, r4, #1
    6b78:	47b8      	blx	r7
                function_name_found = (expr_string[i] == '(');
    6b7a:	7821      	ldrb	r1, [r4, #0]
    6b7c:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
    6b80:	4259      	negs	r1, r3
    6b82:	4159      	adcs	r1, r3
                function_name_valid = 0;
    6b84:	464a      	mov	r2, r9
    for(int i= len; i>=0; i--){
    6b86:	3c01      	subs	r4, #1
    6b88:	e7d9      	b.n	6b3e <subst_all_functions_starting_from_the_back+0x12>
            function_name_found = 1;
    6b8a:	2101      	movs	r1, #1
    6b8c:	e7fb      	b.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
                if (i==0 && function_name_valid){ // start of expr string special case
    6b8e:	f1ba 0f00 	cmp.w	sl, #0
    6b92:	d0e9      	beq.n	6b68 <subst_all_functions_starting_from_the_back+0x3c>
                    function_name_valid = 1;
    6b94:	460a      	mov	r2, r1
    6b96:	e7f6      	b.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
    6b98:	00006659 	.word	0x00006659
    6b9c:	000068b9 	.word	0x000068b9

00006ba0 <grid_expr_evaluate>:
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6ba0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    grid_expr_clear_input(expr);
    6ba2:	4b12      	ldr	r3, [pc, #72]	; (6bec <grid_expr_evaluate+0x4c>)
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6ba4:	4604      	mov	r4, r0
    6ba6:	460e      	mov	r6, r1
    6ba8:	4611      	mov	r1, r2
    grid_expr_clear_input(expr);
    6baa:	4798      	blx	r3
    grid_expr_clear_output(expr);
    6bac:	4b10      	ldr	r3, [pc, #64]	; (6bf0 <grid_expr_evaluate+0x50>)
    6bae:	4620      	mov	r0, r4
    6bb0:	4798      	blx	r3
    for (uint32_t i=0; i<input_length; i++){
    6bb2:	1d22      	adds	r2, r4, #4
    6bb4:	2300      	movs	r3, #0
    6bb6:	4615      	mov	r5, r2
    6bb8:	4299      	cmp	r1, r3
    6bba:	d811      	bhi.n	6be0 <grid_expr_evaluate+0x40>
    expr->input_string_length = input_length;
    6bbc:	f884 10fe 	strb.w	r1, [r4, #254]	; 0xfe
    subst_all_variables_starting_from_the_back(expr->input_string, expr->input_string_length);    
    6bc0:	4b0c      	ldr	r3, [pc, #48]	; (6bf4 <grid_expr_evaluate+0x54>)
    6bc2:	4628      	mov	r0, r5
    6bc4:	4798      	blx	r3
    subst_all_functions_starting_from_the_back(expr->input_string, expr->input_string_length);
    6bc6:	f894 10fe 	ldrb.w	r1, [r4, #254]	; 0xfe
    6bca:	4b0b      	ldr	r3, [pc, #44]	; (6bf8 <grid_expr_evaluate+0x58>)
    6bcc:	4628      	mov	r0, r5
    6bce:	4798      	blx	r3
    int result = expr_level_0(e);
    6bd0:	4b0a      	ldr	r3, [pc, #40]	; (6bfc <grid_expr_evaluate+0x5c>)
    6bd2:	9501      	str	r5, [sp, #4]
    6bd4:	a801      	add	r0, sp, #4
    6bd6:	4798      	blx	r3
    expr->return_value = result;
    6bd8:	f8c4 01fc 	str.w	r0, [r4, #508]	; 0x1fc
}
    6bdc:	b002      	add	sp, #8
    6bde:	bd70      	pop	{r4, r5, r6, pc}
        expr->input_string[i] = input_str[i];
    6be0:	5cf0      	ldrb	r0, [r6, r3]
    6be2:	f802 0b01 	strb.w	r0, [r2], #1
    for (uint32_t i=0; i<input_length; i++){
    6be6:	3301      	adds	r3, #1
    6be8:	e7e6      	b.n	6bb8 <grid_expr_evaluate+0x18>
    6bea:	bf00      	nop
    6bec:	000063c5 	.word	0x000063c5
    6bf0:	000063d9 	.word	0x000063d9
    6bf4:	000068d9 	.word	0x000068d9
    6bf8:	00006b2d 	.word	0x00006b2d
    6bfc:	00006451 	.word	0x00006451

00006c00 <grid_led_lowlevel_hardware_transfer_complete_cb>:


void grid_led_lowlevel_hardware_transfer_complete_cb(struct _dma_resource *resource){
	

	grid_led_hardware_transfer_done = 1;
    6c00:	4b01      	ldr	r3, [pc, #4]	; (6c08 <grid_led_lowlevel_hardware_transfer_complete_cb+0x8>)
    6c02:	2201      	movs	r2, #1
    6c04:	701a      	strb	r2, [r3, #0]
	
	
}
    6c06:	4770      	bx	lr
    6c08:	2000914c 	.word	0x2000914c

00006c0c <grid_led_lowlevel_set_color>:
uint8_t grid_led_lowlevel_set_color(struct grid_led_model* mod, uint32_t led_index, uint16_t led_r, uint16_t led_g, uint16_t led_b){
    6c0c:	b510      	push	{r4, lr}
	if (led_index<mod->led_number){
    6c0e:	7844      	ldrb	r4, [r0, #1]
    6c10:	428c      	cmp	r4, r1
    6c12:	d91c      	bls.n	6c4e <grid_led_lowlevel_set_color+0x42>
		mod->led_frame_buffer_usable[led_index*3 + 0] = grid_led_color_code[led_g];
    6c14:	2bff      	cmp	r3, #255	; 0xff
    6c16:	f04f 040c 	mov.w	r4, #12
    6c1a:	fb04 f101 	mul.w	r1, r4, r1
    6c1e:	bf28      	it	cs
    6c20:	23ff      	movcs	r3, #255	; 0xff
    6c22:	4c0c      	ldr	r4, [pc, #48]	; (6c54 <grid_led_lowlevel_set_color+0x48>)
    6c24:	68c0      	ldr	r0, [r0, #12]
    6c26:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6c2a:	5043      	str	r3, [r0, r1]
		mod->led_frame_buffer_usable[led_index*3 + 1] = grid_led_color_code[led_r];
    6c2c:	2aff      	cmp	r2, #255	; 0xff
    6c2e:	bf28      	it	cs
    6c30:	22ff      	movcs	r2, #255	; 0xff
    6c32:	4401      	add	r1, r0
    6c34:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
    6c38:	604b      	str	r3, [r1, #4]
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6c3a:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6c3e:	2bff      	cmp	r3, #255	; 0xff
    6c40:	bf28      	it	cs
    6c42:	23ff      	movcs	r3, #255	; 0xff
		return 0;
    6c44:	2000      	movs	r0, #0
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6c46:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6c4a:	608b      	str	r3, [r1, #8]
}
    6c4c:	bd10      	pop	{r4, pc}
		return -1;		
    6c4e:	20ff      	movs	r0, #255	; 0xff
    6c50:	e7fc      	b.n	6c4c <grid_led_lowlevel_set_color+0x40>
    6c52:	bf00      	nop
    6c54:	2000fe60 	.word	0x2000fe60

00006c58 <grid_led_hardware_init>:


}


void grid_led_hardware_init(struct grid_led_model* mod){
    6c58:	b510      	push	{r4, lr}
	
	spi_m_dma_get_io_descriptor(&GRID_LED, &mod->hardware_io_descriptor);
    6c5a:	4c06      	ldr	r4, [pc, #24]	; (6c74 <grid_led_hardware_init+0x1c>)
    6c5c:	4b06      	ldr	r3, [pc, #24]	; (6c78 <grid_led_hardware_init+0x20>)
    6c5e:	f100 0114 	add.w	r1, r0, #20
    6c62:	4620      	mov	r0, r4
    6c64:	4798      	blx	r3
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    6c66:	4620      	mov	r0, r4
    6c68:	4a04      	ldr	r2, [pc, #16]	; (6c7c <grid_led_hardware_init+0x24>)
    6c6a:	4b05      	ldr	r3, [pc, #20]	; (6c80 <grid_led_hardware_init+0x28>)
	

		
}
    6c6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    6c70:	2100      	movs	r1, #0
    6c72:	4718      	bx	r3
    6c74:	2001ce54 	.word	0x2001ce54
    6c78:	0000ba51 	.word	0x0000ba51
    6c7c:	00006c01 	.word	0x00006c01
    6c80:	0000ba1d 	.word	0x0000ba1d

00006c84 <grid_led_get_led_number>:

uint32_t grid_led_get_led_number(struct grid_led_model* mod){

	return mod->led_number;

}
    6c84:	7840      	ldrb	r0, [r0, #1]
    6c86:	4770      	bx	lr

00006c88 <grid_led_tick>:

/** ================== ANIMATION ==================  */


void grid_led_tick(struct grid_led_model* mod){
    6c88:	b5f0      	push	{r4, r5, r6, r7, lr}
	

	/** ATOMI - all phase registers must be updated  */
	for (uint8_t j=0; j<mod->led_number; j++){
    6c8a:	7846      	ldrb	r6, [r0, #1]
    6c8c:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    6c90:	eb06 0282 	add.w	r2, r6, r2, lsl #2
    6c94:	2400      	movs	r4, #0
    6c96:	270d      	movs	r7, #13
    6c98:	b2e3      	uxtb	r3, r4
    6c9a:	429e      	cmp	r6, r3
    6c9c:	d800      	bhi.n	6ca0 <grid_led_tick+0x18>
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
		}	
	}
	/** END */
	
}
    6c9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6ca0:	6903      	ldr	r3, [r0, #16]
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    6ca2:	2103      	movs	r1, #3
    6ca4:	fb07 3304 	mla	r3, r7, r4, r3
    6ca8:	7add      	ldrb	r5, [r3, #11]
    6caa:	f893 c00c 	ldrb.w	ip, [r3, #12]
    6cae:	3901      	subs	r1, #1
    6cb0:	4465      	add	r5, ip
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    6cb2:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    6cb6:	72dd      	strb	r5, [r3, #11]
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    6cb8:	4413      	add	r3, r2
    6cba:	d1f5      	bne.n	6ca8 <grid_led_tick+0x20>
	for (uint8_t j=0; j<mod->led_number; j++){
    6cbc:	3401      	adds	r4, #1
    6cbe:	e7eb      	b.n	6c98 <grid_led_tick+0x10>

00006cc0 <grid_led_set_min>:
	grid_led_set_max(mod, num, layer, r, g, b);

}


void grid_led_set_min(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6cc0:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r = r;
    6cc2:	7844      	ldrb	r4, [r0, #1]
    6cc4:	6900      	ldr	r0, [r0, #16]
    6cc6:	fb04 1202 	mla	r2, r4, r2, r1
    6cca:	240d      	movs	r4, #13
    6ccc:	4362      	muls	r2, r4
    6cce:	1881      	adds	r1, r0, r2
    6cd0:	5483      	strb	r3, [r0, r2]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g = g;
    6cd2:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cd6:	704b      	strb	r3, [r1, #1]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b = b;	
    6cd8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cdc:	708b      	strb	r3, [r1, #2]
}
    6cde:	bd10      	pop	{r4, pc}

00006ce0 <grid_led_set_mid>:

void grid_led_set_mid(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6ce0:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.r = r;
    6ce2:	7844      	ldrb	r4, [r0, #1]
    6ce4:	fb04 1102 	mla	r1, r4, r2, r1
    6ce8:	6902      	ldr	r2, [r0, #16]
    6cea:	200d      	movs	r0, #13
    6cec:	fb00 2201 	mla	r2, r0, r1, r2
    6cf0:	70d3      	strb	r3, [r2, #3]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.g = g;
    6cf2:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cf6:	7113      	strb	r3, [r2, #4]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.b = b;	
    6cf8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cfc:	7153      	strb	r3, [r2, #5]
}
    6cfe:	bd10      	pop	{r4, pc}

00006d00 <grid_led_set_max>:

void grid_led_set_max(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d00:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r = r;
    6d02:	7844      	ldrb	r4, [r0, #1]
    6d04:	fb04 1102 	mla	r1, r4, r2, r1
    6d08:	6902      	ldr	r2, [r0, #16]
    6d0a:	200d      	movs	r0, #13
    6d0c:	fb00 2201 	mla	r2, r0, r1, r2
    6d10:	7193      	strb	r3, [r2, #6]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g = g;
    6d12:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6d16:	71d3      	strb	r3, [r2, #7]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b = b;	
    6d18:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6d1c:	7213      	strb	r3, [r2, #8]
}
    6d1e:	bd10      	pop	{r4, pc}

00006d20 <grid_led_set_color>:
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d20:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    6d24:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
    6d28:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d2c:	f8df a058 	ldr.w	sl, [pc, #88]	; 6d88 <grid_led_set_color+0x68>
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d30:	461c      	mov	r4, r3
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d32:	2314      	movs	r3, #20
    6d34:	fbb9 fcf3 	udiv	ip, r9, r3
    6d38:	f8cd c004 	str.w	ip, [sp, #4]
    6d3c:	fbb8 fcf3 	udiv	ip, r8, r3
    6d40:	fbb4 f3f3 	udiv	r3, r4, r3
    6d44:	f8cd c000 	str.w	ip, [sp]
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d48:	4605      	mov	r5, r0
    6d4a:	460e      	mov	r6, r1
    6d4c:	4617      	mov	r7, r2
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d4e:	47d0      	blx	sl
	grid_led_set_mid(mod, num, layer, r/2, g/2, b/2);
    6d50:	ea4f 0359 	mov.w	r3, r9, lsr #1
    6d54:	9301      	str	r3, [sp, #4]
    6d56:	ea4f 0358 	mov.w	r3, r8, lsr #1
    6d5a:	9300      	str	r3, [sp, #0]
    6d5c:	463a      	mov	r2, r7
    6d5e:	0863      	lsrs	r3, r4, #1
    6d60:	4631      	mov	r1, r6
    6d62:	4628      	mov	r0, r5
    6d64:	f8df a024 	ldr.w	sl, [pc, #36]	; 6d8c <grid_led_set_color+0x6c>
    6d68:	47d0      	blx	sl
	grid_led_set_max(mod, num, layer, r, g, b);
    6d6a:	4623      	mov	r3, r4
    6d6c:	4c05      	ldr	r4, [pc, #20]	; (6d84 <grid_led_set_color+0x64>)
    6d6e:	463a      	mov	r2, r7
    6d70:	4631      	mov	r1, r6
    6d72:	4628      	mov	r0, r5
    6d74:	46a4      	mov	ip, r4
    6d76:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
}
    6d7a:	b002      	add	sp, #8
    6d7c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_led_set_max(mod, num, layer, r, g, b);
    6d80:	4760      	bx	ip
    6d82:	bf00      	nop
    6d84:	00006d01 	.word	0x00006d01
    6d88:	00006cc1 	.word	0x00006cc1
    6d8c:	00006ce1 	.word	0x00006ce1

00006d90 <grid_led_set_phase>:

void grid_led_set_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    6d90:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].pha = val;
    6d92:	7844      	ldrb	r4, [r0, #1]
    6d94:	fb04 1102 	mla	r1, r4, r2, r1
    6d98:	6902      	ldr	r2, [r0, #16]
    6d9a:	200d      	movs	r0, #13
    6d9c:	fb00 2101 	mla	r1, r0, r1, r2
    6da0:	72cb      	strb	r3, [r1, #11]
}
    6da2:	bd10      	pop	{r4, pc}

00006da4 <grid_led_set_frequency>:
uint8_t grid_led_get_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer){
	
	return mod->led_smart_buffer[num+(mod->led_number*layer)].pha;
}

void grid_led_set_frequency(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    6da4:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].fre = val;
    6da6:	7844      	ldrb	r4, [r0, #1]
    6da8:	fb04 1102 	mla	r1, r4, r2, r1
    6dac:	6902      	ldr	r2, [r0, #16]
    6dae:	200d      	movs	r0, #13
    6db0:	fb00 2101 	mla	r1, r0, r1, r2
    6db4:	730b      	strb	r3, [r1, #12]
}
    6db6:	bd10      	pop	{r4, pc}

00006db8 <grid_led_buffer_init>:
void grid_led_buffer_init(struct grid_led_model* mod, uint32_t length){
    6db8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6dbc:	4604      	mov	r4, r0
	mod->led_number = length;
    6dbe:	7041      	strb	r1, [r0, #1]
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    6dc0:	b2cd      	uxtb	r5, r1
    6dc2:	200c      	movs	r0, #12
    6dc4:	4368      	muls	r0, r5
    6dc6:	3090      	adds	r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6dc8:	4f4c      	ldr	r7, [pc, #304]	; (6efc <grid_led_buffer_init+0x144>)
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    6dca:	6060      	str	r0, [r4, #4]
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6dcc:	47b8      	blx	r7
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    6dce:	f100 0390 	add.w	r3, r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6dd2:	60a0      	str	r0, [r4, #8]
    6dd4:	4606      	mov	r6, r0
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    6dd6:	2027      	movs	r0, #39	; 0x27
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    6dd8:	60e3      	str	r3, [r4, #12]
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    6dda:	4368      	muls	r0, r5
    6ddc:	47b8      	blx	r7
    6dde:	6120      	str	r0, [r4, #16]
	if(mod->led_frame_buffer==NULL || mod->led_smart_buffer==NULL){
    6de0:	b106      	cbz	r6, 6de4 <grid_led_buffer_init+0x2c>
    6de2:	b900      	cbnz	r0, 6de6 <grid_led_buffer_init+0x2e>
		while(1){
    6de4:	e7fe      	b.n	6de4 <grid_led_buffer_init+0x2c>
    6de6:	2300      	movs	r3, #0
		mod->led_frame_buffer[i] = LED_CODE_R;
    6de8:	4619      	mov	r1, r3
    6dea:	68a2      	ldr	r2, [r4, #8]
    6dec:	54d1      	strb	r1, [r2, r3]
	for (uint8_t i = 0; i<GRID_LED_RESET_LENGTH; i++){
    6dee:	3301      	adds	r3, #1
    6df0:	2b90      	cmp	r3, #144	; 0x90
    6df2:	d1fa      	bne.n	6dea <grid_led_buffer_init+0x32>
	for (uint32_t i = 0; i<mod->led_number; i++){
    6df4:	2500      	movs	r5, #0
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    6df6:	4f42      	ldr	r7, [pc, #264]	; (6f00 <grid_led_buffer_init+0x148>)
    6df8:	462e      	mov	r6, r5
	for (uint32_t i = 0; i<mod->led_number; i++){
    6dfa:	7863      	ldrb	r3, [r4, #1]
    6dfc:	429d      	cmp	r5, r3
    6dfe:	d30c      	bcc.n	6e1a <grid_led_buffer_init+0x62>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    6e00:	4d40      	ldr	r5, [pc, #256]	; (6f04 <grid_led_buffer_init+0x14c>)
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    6e02:	4e41      	ldr	r6, [pc, #260]	; (6f08 <grid_led_buffer_init+0x150>)
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    6e04:	4f41      	ldr	r7, [pc, #260]	; (6f0c <grid_led_buffer_init+0x154>)
    6e06:	f04f 0b00 	mov.w	fp, #0
	for(uint8_t i = 0; i<mod->led_number; i++){
    6e0a:	7863      	ldrb	r3, [r4, #1]
    6e0c:	fa5f fa8b 	uxtb.w	sl, fp
    6e10:	4553      	cmp	r3, sl
    6e12:	d80a      	bhi.n	6e2a <grid_led_buffer_init+0x72>
}
    6e14:	b003      	add	sp, #12
    6e16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    6e1a:	2300      	movs	r3, #0
    6e1c:	4629      	mov	r1, r5
    6e1e:	9600      	str	r6, [sp, #0]
    6e20:	461a      	mov	r2, r3
    6e22:	4620      	mov	r0, r4
    6e24:	47b8      	blx	r7
	for (uint32_t i = 0; i<mod->led_number; i++){
    6e26:	3501      	adds	r5, #1
    6e28:	e7e7      	b.n	6dfa <grid_led_buffer_init+0x42>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    6e2a:	2300      	movs	r3, #0
    6e2c:	e9cd 3300 	strd	r3, r3, [sp]
    6e30:	2201      	movs	r2, #1
    6e32:	4651      	mov	r1, sl
    6e34:	4620      	mov	r0, r4
    6e36:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    6e38:	2300      	movs	r3, #0
    6e3a:	227f      	movs	r2, #127	; 0x7f
    6e3c:	e9cd 2300 	strd	r2, r3, [sp]
    6e40:	4651      	mov	r1, sl
    6e42:	2201      	movs	r2, #1
    6e44:	4620      	mov	r0, r4
    6e46:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    6e48:	2300      	movs	r3, #0
    6e4a:	22ff      	movs	r2, #255	; 0xff
    6e4c:	e9cd 2300 	strd	r2, r3, [sp]
    6e50:	4651      	mov	r1, sl
    6e52:	2201      	movs	r2, #1
    6e54:	4620      	mov	r0, r4
    6e56:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e58:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 6f10 <grid_led_buffer_init+0x158>
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e5c:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 6f14 <grid_led_buffer_init+0x15c>
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e60:	2300      	movs	r3, #0
    6e62:	2201      	movs	r2, #1
    6e64:	4651      	mov	r1, sl
    6e66:	4620      	mov	r0, r4
    6e68:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e6a:	2300      	movs	r3, #0
    6e6c:	2201      	movs	r2, #1
    6e6e:	4651      	mov	r1, sl
    6e70:	4620      	mov	r0, r4
    6e72:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x00, 0x00);
    6e74:	2300      	movs	r3, #0
    6e76:	e9cd 3300 	strd	r3, r3, [sp]
    6e7a:	2202      	movs	r2, #2
    6e7c:	4651      	mov	r1, sl
    6e7e:	4620      	mov	r0, r4
    6e80:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x7F, 0x00);
    6e82:	2300      	movs	r3, #0
    6e84:	227f      	movs	r2, #127	; 0x7f
    6e86:	e9cd 2300 	strd	r2, r3, [sp]
    6e8a:	4651      	mov	r1, sl
    6e8c:	2202      	movs	r2, #2
    6e8e:	4620      	mov	r0, r4
    6e90:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0xFF, 0x00);
    6e92:	2300      	movs	r3, #0
    6e94:	22ff      	movs	r2, #255	; 0xff
    6e96:	e9cd 2300 	strd	r2, r3, [sp]
    6e9a:	4651      	mov	r1, sl
    6e9c:	2202      	movs	r2, #2
    6e9e:	4620      	mov	r0, r4
    6ea0:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_B, 0);
    6ea2:	2300      	movs	r3, #0
    6ea4:	2202      	movs	r2, #2
    6ea6:	4651      	mov	r1, sl
    6ea8:	4620      	mov	r0, r4
    6eaa:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_B, 0);
    6eac:	2300      	movs	r3, #0
    6eae:	2202      	movs	r2, #2
    6eb0:	4651      	mov	r1, sl
    6eb2:	4620      	mov	r0, r4
    6eb4:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6eb6:	2300      	movs	r3, #0
    6eb8:	461a      	mov	r2, r3
    6eba:	e9cd 3300 	strd	r3, r3, [sp]
    6ebe:	4651      	mov	r1, sl
    6ec0:	4620      	mov	r0, r4
    6ec2:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6ec4:	2300      	movs	r3, #0
    6ec6:	461a      	mov	r2, r3
    6ec8:	e9cd 3300 	strd	r3, r3, [sp]
    6ecc:	4651      	mov	r1, sl
    6ece:	4620      	mov	r0, r4
    6ed0:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6ed2:	2300      	movs	r3, #0
    6ed4:	461a      	mov	r2, r3
    6ed6:	e9cd 3300 	strd	r3, r3, [sp]
    6eda:	4651      	mov	r1, sl
    6edc:	4620      	mov	r0, r4
    6ede:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_ALERT, 0);
    6ee0:	2300      	movs	r3, #0
    6ee2:	461a      	mov	r2, r3
    6ee4:	4651      	mov	r1, sl
    6ee6:	4620      	mov	r0, r4
    6ee8:	47c8      	blx	r9
		grid_led_set_phase(mod, i, GRID_LED_LAYER_ALERT, 0);
    6eea:	2300      	movs	r3, #0
    6eec:	461a      	mov	r2, r3
    6eee:	4651      	mov	r1, sl
    6ef0:	4620      	mov	r0, r4
    6ef2:	47c0      	blx	r8
	for(uint8_t i = 0; i<mod->led_number; i++){
    6ef4:	f10b 0b01 	add.w	fp, fp, #1
    6ef8:	e787      	b.n	6e0a <grid_led_buffer_init+0x52>
    6efa:	bf00      	nop
    6efc:	00014315 	.word	0x00014315
    6f00:	00006c0d 	.word	0x00006c0d
    6f04:	00006cc1 	.word	0x00006cc1
    6f08:	00006ce1 	.word	0x00006ce1
    6f0c:	00006d01 	.word	0x00006d01
    6f10:	00006da5 	.word	0x00006da5
    6f14:	00006d91 	.word	0x00006d91

00006f18 <grid_led_lowlevel_init>:
uint8_t grid_led_lowlevel_init(struct grid_led_model* mod, uint8_t num){
    6f18:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6f1a:	4e29      	ldr	r6, [pc, #164]	; (6fc0 <grid_led_lowlevel_init+0xa8>)
	for(uint16_t i=0; i<256; i++){
    6f1c:	2300      	movs	r3, #0
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    6f1e:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
		temp |= (i/2%2)   ? (LED_CODE_O<<28) : (LED_CODE_Z<<28);
    6f22:	f013 0f02 	tst.w	r3, #2
    6f26:	bf0c      	ite	eq
    6f28:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    6f2c:	f04f 4560 	movne.w	r5, #3758096384	; 0xe0000000
		temp |= (i/4%2)   ? (LED_CODE_O<<16) : (LED_CODE_Z<<16);
    6f30:	f013 0f04 	tst.w	r3, #4
    6f34:	bf0c      	ite	eq
    6f36:	f44f 2400 	moveq.w	r4, #524288	; 0x80000
    6f3a:	f44f 2460 	movne.w	r4, #917504	; 0xe0000
		temp |= (i/8%2)   ? (LED_CODE_O<<20) : (LED_CODE_Z<<20);
    6f3e:	f013 0f08 	tst.w	r3, #8
    6f42:	ea45 0504 	orr.w	r5, r5, r4
    6f46:	bf0c      	ite	eq
    6f48:	f44f 0400 	moveq.w	r4, #8388608	; 0x800000
    6f4c:	f44f 0460 	movne.w	r4, #14680064	; 0xe00000
		temp |= (i/16%2)  ? (LED_CODE_O<<8)  : (LED_CODE_Z<<8);
    6f50:	f013 0f10 	tst.w	r3, #16
    6f54:	ea45 0504 	orr.w	r5, r5, r4
    6f58:	bf0c      	ite	eq
    6f5a:	f44f 6400 	moveq.w	r4, #2048	; 0x800
    6f5e:	f44f 6460 	movne.w	r4, #3584	; 0xe00
		temp |= (i/32%2)  ? (LED_CODE_O<<12) : (LED_CODE_Z<<12);
    6f62:	f013 0f20 	tst.w	r3, #32
    6f66:	bf0c      	ite	eq
    6f68:	f44f 4200 	moveq.w	r2, #32768	; 0x8000
    6f6c:	f44f 4260 	movne.w	r2, #57344	; 0xe000
    6f70:	432c      	orrs	r4, r5
		temp |= (i/64%2)  ? (LED_CODE_O<<0)  : (LED_CODE_Z<<0);
    6f72:	f013 0f40 	tst.w	r3, #64	; 0x40
    6f76:	ea44 0402 	orr.w	r4, r4, r2
    6f7a:	bf0c      	ite	eq
    6f7c:	2208      	moveq	r2, #8
    6f7e:	220e      	movne	r2, #14
    6f80:	4314      	orrs	r4, r2
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f82:	09da      	lsrs	r2, r3, #7
    6f84:	bf14      	ite	ne
    6f86:	22e0      	movne	r2, #224	; 0xe0
    6f88:	2280      	moveq	r2, #128	; 0x80
	for(uint16_t i=0; i<256; i++){
    6f8a:	3301      	adds	r3, #1
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f8c:	4322      	orrs	r2, r4
	for(uint16_t i=0; i<256; i++){
    6f8e:	b29b      	uxth	r3, r3
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f90:	433a      	orrs	r2, r7
	for(uint16_t i=0; i<256; i++){
    6f92:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		grid_led_color_code[i] = temp;
    6f96:	f846 2b04 	str.w	r2, [r6], #4
	for(uint16_t i=0; i<256; i++){
    6f9a:	d108      	bne.n	6fae <grid_led_lowlevel_init+0x96>
	grid_led_buffer_init(mod, num);		
    6f9c:	4b09      	ldr	r3, [pc, #36]	; (6fc4 <grid_led_lowlevel_init+0xac>)
    6f9e:	9001      	str	r0, [sp, #4]
    6fa0:	4798      	blx	r3
	grid_led_hardware_init(mod);
    6fa2:	9801      	ldr	r0, [sp, #4]
    6fa4:	4b08      	ldr	r3, [pc, #32]	; (6fc8 <grid_led_lowlevel_init+0xb0>)
    6fa6:	4798      	blx	r3
}
    6fa8:	2000      	movs	r0, #0
    6faa:	b003      	add	sp, #12
    6fac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    6fae:	f013 0f01 	tst.w	r3, #1
    6fb2:	bf14      	ite	ne
    6fb4:	f04f 6760 	movne.w	r7, #234881024	; 0xe000000
    6fb8:	f04f 6700 	moveq.w	r7, #134217728	; 0x8000000
    6fbc:	e7b1      	b.n	6f22 <grid_led_lowlevel_init+0xa>
    6fbe:	bf00      	nop
    6fc0:	2000fe60 	.word	0x2000fe60
    6fc4:	00006db9 	.word	0x00006db9
    6fc8:	00006c59 	.word	0x00006c59

00006fcc <grid_led_lowlevel_render>:


void grid_led_lowlevel_render(struct grid_led_model* mod, uint32_t num){
    6fcc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6fd0:	7847      	ldrb	r7, [r0, #1]
		uint8_t layer = i;
				
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
		uint8_t min_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g;
		uint8_t min_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b;
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fd2:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 7074 <grid_led_lowlevel_render+0xa8>
    6fd6:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    6fda:	eb07 0783 	add.w	r7, r7, r3, lsl #2
    6fde:	6903      	ldr	r3, [r0, #16]
	uint32_t mix_b = 0;
    6fe0:	2500      	movs	r5, #0
    6fe2:	240d      	movs	r4, #13
    6fe4:	fb04 3401 	mla	r4, r4, r1, r3
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
    6fe8:	2603      	movs	r6, #3
	uint32_t mix_g = 0;
    6fea:	462b      	mov	r3, r5
	uint32_t mix_r = 0;
    6fec:	462a      	mov	r2, r5
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fee:	f894 900b 	ldrb.w	r9, [r4, #11]
		uint8_t max_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r;
		uint8_t max_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g;
		uint8_t max_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b;
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
				
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    6ff2:	f894 b003 	ldrb.w	fp, [r4, #3]
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6ff6:	f818 e009 	ldrb.w	lr, [r8, r9]
		uint8_t mid_a = mid_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6ffa:	44c1      	add	r9, r8
    6ffc:	3e01      	subs	r6, #1
    6ffe:	f899 a100 	ldrb.w	sl, [r9, #256]	; 0x100
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    7002:	f899 c200 	ldrb.w	ip, [r9, #512]	; 0x200
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    7006:	f894 9000 	ldrb.w	r9, [r4]
    700a:	fb1b fb0a 	smulbb	fp, fp, sl
    700e:	fb09 bb0e 	mla	fp, r9, lr, fp
    7012:	f894 9006 	ldrb.w	r9, [r4, #6]
    7016:	fb09 b90c 	mla	r9, r9, ip, fp
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    701a:	f894 b004 	ldrb.w	fp, [r4, #4]
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    701e:	444a      	add	r2, r9
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    7020:	f894 9001 	ldrb.w	r9, [r4, #1]
    7024:	fb1b fb0a 	smulbb	fp, fp, sl
    7028:	fb09 bb0e 	mla	fp, r9, lr, fp
    702c:	f894 9007 	ldrb.w	r9, [r4, #7]
    7030:	fb09 b90c 	mla	r9, r9, ip, fp
    7034:	444b      	add	r3, r9
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    7036:	f894 9005 	ldrb.w	r9, [r4, #5]
    703a:	f894 b002 	ldrb.w	fp, [r4, #2]
    703e:	fb19 f90a 	smulbb	r9, r9, sl
    7042:	fb0b 9e0e 	mla	lr, fp, lr, r9
    7046:	f894 9008 	ldrb.w	r9, [r4, #8]
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    704a:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    704e:	fb09 ec0c 	mla	ip, r9, ip, lr
    7052:	4465      	add	r5, ip
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    7054:	443c      	add	r4, r7
    7056:	d1ca      	bne.n	6fee <grid_led_lowlevel_render+0x22>

	mix_r = (mix_r)/2/256;
	mix_g = (mix_g)/2/256;
	mix_b = (mix_b)/2/256;
				
	grid_led_lowlevel_set_color(mod, num, mix_r, mix_g, mix_b);
    7058:	f3c5 254f 	ubfx	r5, r5, #9, #16
    705c:	4c04      	ldr	r4, [pc, #16]	; (7070 <grid_led_lowlevel_render+0xa4>)
    705e:	9500      	str	r5, [sp, #0]
    7060:	f3c3 234f 	ubfx	r3, r3, #9, #16
    7064:	f3c2 224f 	ubfx	r2, r2, #9, #16
    7068:	47a0      	blx	r4
	
}
    706a:	b003      	add	sp, #12
    706c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7070:	00006c0d 	.word	0x00006c0d
    7074:	20000008 	.word	0x20000008

00007078 <grid_led_lowlevel_render_all>:


void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7078:	b570      	push	{r4, r5, r6, lr}
	
	for (uint32_t i=0; i<mod->led_number; i++){
		
		grid_led_lowlevel_render(mod, i);
    707a:	4e06      	ldr	r6, [pc, #24]	; (7094 <grid_led_lowlevel_render_all+0x1c>)
void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    707c:	4605      	mov	r5, r0
	for (uint32_t i=0; i<mod->led_number; i++){
    707e:	2400      	movs	r4, #0
    7080:	786b      	ldrb	r3, [r5, #1]
    7082:	42a3      	cmp	r3, r4
    7084:	d800      	bhi.n	7088 <grid_led_lowlevel_render_all+0x10>
	}
	
}
    7086:	bd70      	pop	{r4, r5, r6, pc}
		grid_led_lowlevel_render(mod, i);
    7088:	4621      	mov	r1, r4
    708a:	4628      	mov	r0, r5
    708c:	47b0      	blx	r6
	for (uint32_t i=0; i<mod->led_number; i++){
    708e:	3401      	adds	r4, #1
    7090:	e7f6      	b.n	7080 <grid_led_lowlevel_render_all+0x8>
    7092:	bf00      	nop
    7094:	00006fcd 	.word	0x00006fcd

00007098 <grid_led_lowlevel_hardware_start_transfer>:
			
	}
	
}

void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    7098:	b510      	push	{r4, lr}
	
	// SEND DATA TO LEDs
	grid_led_hardware_transfer_done = 0;
    709a:	4b07      	ldr	r3, [pc, #28]	; (70b8 <grid_led_lowlevel_hardware_start_transfer+0x20>)
void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    709c:	4604      	mov	r4, r0
	grid_led_hardware_transfer_done = 0;
    709e:	2200      	movs	r2, #0
    70a0:	701a      	strb	r2, [r3, #0]
	spi_m_dma_enable(&GRID_LED);
    70a2:	4806      	ldr	r0, [pc, #24]	; (70bc <grid_led_lowlevel_hardware_start_transfer+0x24>)
    70a4:	4b06      	ldr	r3, [pc, #24]	; (70c0 <grid_led_lowlevel_hardware_start_transfer+0x28>)
    70a6:	4798      	blx	r3
			
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    70a8:	88a2      	ldrh	r2, [r4, #4]
    70aa:	68a1      	ldr	r1, [r4, #8]
    70ac:	6960      	ldr	r0, [r4, #20]
    70ae:	4b05      	ldr	r3, [pc, #20]	; (70c4 <grid_led_lowlevel_hardware_start_transfer+0x2c>)

}
    70b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    70b4:	4718      	bx	r3
    70b6:	bf00      	nop
    70b8:	2000914c 	.word	0x2000914c
    70bc:	2001ce54 	.word	0x2001ce54
    70c0:	0000b9f5 	.word	0x0000b9f5
    70c4:	0000b0ed 	.word	0x0000b0ed

000070c8 <grid_module_common_init>:

	
/* ============================== GRID_MODULE_INIT() ================================ */


void grid_module_common_init(void){
    70c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	grid_ui_model_init(&grid_core_state, 1);
    70cc:	4d70      	ldr	r5, [pc, #448]	; (7290 <grid_module_common_init+0x1c8>)
    70ce:	4b71      	ldr	r3, [pc, #452]	; (7294 <grid_module_common_init+0x1cc>)
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
	
		
	if (1){	// INIT CORE_STATE->hearbeat	
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70d0:	f8df 9240 	ldr.w	r9, [pc, #576]	; 7314 <grid_module_common_init+0x24c>
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
		payload_length = strlen(payload_template);
    70d4:	f8df 8240 	ldr.w	r8, [pc, #576]	; 7318 <grid_module_common_init+0x250>
	
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    70d8:	4f6f      	ldr	r7, [pc, #444]	; (7298 <grid_module_common_init+0x1d0>)
		uint8_t error = 0;
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    70da:	f8df a240 	ldr.w	sl, [pc, #576]	; 731c <grid_module_common_init+0x254>
void grid_module_common_init(void){
    70de:	b0a5      	sub	sp, #148	; 0x94
	grid_ui_model_init(&grid_core_state, 1);
    70e0:	4628      	mov	r0, r5
    70e2:	2101      	movs	r1, #1
    70e4:	4798      	blx	r3
	grid_ui_bank_init(&grid_core_state, 0, 1);
    70e6:	4628      	mov	r0, r5
    70e8:	4b6c      	ldr	r3, [pc, #432]	; (729c <grid_module_common_init+0x1d4>)
    70ea:	2201      	movs	r2, #1
    70ec:	2100      	movs	r1, #0
    70ee:	4798      	blx	r3
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    70f0:	2200      	movs	r2, #0
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70f2:	2400      	movs	r4, #0
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    70f4:	6868      	ldr	r0, [r5, #4]
    70f6:	4b6a      	ldr	r3, [pc, #424]	; (72a0 <grid_module_common_init+0x1d8>)
    70f8:	4611      	mov	r1, r2
    70fa:	4798      	blx	r3
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70fc:	227e      	movs	r2, #126	; 0x7e
    70fe:	4621      	mov	r1, r4
    7100:	a804      	add	r0, sp, #16
    7102:	9403      	str	r4, [sp, #12]
    7104:	47c8      	blx	r9
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
    7106:	4967      	ldr	r1, [pc, #412]	; (72a4 <grid_module_common_init+0x1dc>)
    7108:	4b67      	ldr	r3, [pc, #412]	; (72a8 <grid_module_common_init+0x1e0>)
    710a:	a803      	add	r0, sp, #12
    710c:	4798      	blx	r3
		payload_length = strlen(payload_template);
    710e:	a803      	add	r0, sp, #12
    7110:	47c0      	blx	r8
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    7112:	aa03      	add	r2, sp, #12
    7114:	1816      	adds	r6, r2, r0
    7116:	2303      	movs	r3, #3
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7118:	f10d 0b0b 	add.w	fp, sp, #11
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    711c:	4963      	ldr	r1, [pc, #396]	; (72ac <grid_module_common_init+0x1e4>)
    711e:	9300      	str	r3, [sp, #0]
    7120:	2202      	movs	r2, #2
    7122:	2310      	movs	r3, #16
    7124:	4630      	mov	r0, r6
    7126:	47b8      	blx	r7
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7128:	230e      	movs	r3, #14
    712a:	2201      	movs	r2, #1
    712c:	2104      	movs	r1, #4
	
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    712e:	4f60      	ldr	r7, [pc, #384]	; (72b0 <grid_module_common_init+0x1e8>)
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7130:	f8cd b000 	str.w	fp, [sp]
    7134:	4630      	mov	r0, r6
		uint8_t error = 0;
    7136:	f88d 400b 	strb.w	r4, [sp, #11]
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    713a:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    713c:	47b8      	blx	r7
    713e:	2202      	movs	r2, #2
    7140:	4603      	mov	r3, r0
    7142:	2105      	movs	r1, #5
    7144:	4630      	mov	r0, r6
    7146:	f8cd b000 	str.w	fp, [sp]
    714a:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMAJOR_offset, GRID_CLASS_HEARTBEAT_VMAJOR_length , GRID_PROTOCOL_VERSION_MAJOR, &error);
    714c:	2301      	movs	r3, #1
    714e:	2202      	movs	r2, #2
    7150:	2107      	movs	r1, #7
    7152:	4630      	mov	r0, r6
    7154:	f8cd b000 	str.w	fp, [sp]
    7158:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMINOR_offset, GRID_CLASS_HEARTBEAT_VMINOR_length  , GRID_PROTOCOL_VERSION_MINOR, &error);
    715a:	2301      	movs	r3, #1
    715c:	2202      	movs	r2, #2
    715e:	2109      	movs	r1, #9
    7160:	4630      	mov	r0, r6
    7162:	f8cd b000 	str.w	fp, [sp]
    7166:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VPATCH_offset, GRID_CLASS_HEARTBEAT_VPATCH_length  , GRID_PROTOCOL_VERSION_PATCH, &error);
    7168:	2309      	movs	r3, #9
    716a:	2202      	movs	r2, #2
    716c:	210b      	movs	r1, #11
    716e:	4630      	mov	r0, r6
    7170:	f8cd b000 	str.w	fp, [sp]
    7174:	47d0      	blx	sl
	
		payload_length = strlen(payload_template);
    7176:	a803      	add	r0, sp, #12
    7178:	47c0      	blx	r8
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    717a:	686e      	ldr	r6, [r5, #4]
		payload_length = strlen(payload_template);
    717c:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    717e:	aa03      	add	r2, sp, #12
    7180:	68f0      	ldr	r0, [r6, #12]
    7182:	4e4c      	ldr	r6, [pc, #304]	; (72b4 <grid_module_common_init+0x1ec>)
    7184:	210c      	movs	r1, #12
    7186:	47b0      	blx	r6
		
	}

	if (1){	// INIT CORE_STATE->mapmode press
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7188:	227e      	movs	r2, #126	; 0x7e
    718a:	4621      	mov	r1, r4
    718c:	a804      	add	r0, sp, #16
    718e:	9403      	str	r4, [sp, #12]
    7190:	47c8      	blx	r9
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_PRESS GRID_ACTIONSTRING_MAPMODE_PRESS);
    7192:	4949      	ldr	r1, [pc, #292]	; (72b8 <grid_module_common_init+0x1f0>)
    7194:	4b44      	ldr	r3, [pc, #272]	; (72a8 <grid_module_common_init+0x1e0>)
    7196:	a803      	add	r0, sp, #12
    7198:	4798      	blx	r3
		payload_length = strlen(payload_template);
    719a:	a803      	add	r0, sp, #12
    719c:	47c0      	blx	r8
    719e:	4603      	mov	r3, r0
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_PRESS, payload_template, payload_length);			
    71a0:	6868      	ldr	r0, [r5, #4]
    71a2:	aa03      	add	r2, sp, #12
    71a4:	68c0      	ldr	r0, [r0, #12]
    71a6:	2107      	movs	r1, #7
    71a8:	47b0      	blx	r6
		
	}	

	if (1){ // INIT CORE_STATE->mapmode release
			
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71aa:	227e      	movs	r2, #126	; 0x7e
    71ac:	4621      	mov	r1, r4
    71ae:	a804      	add	r0, sp, #16
    71b0:	9403      	str	r4, [sp, #12]
    71b2:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_RELEASE GRID_ACTIONSTRING_MAPMODE_RELEASE);
    71b4:	4941      	ldr	r1, [pc, #260]	; (72bc <grid_module_common_init+0x1f4>)
    71b6:	4b3c      	ldr	r3, [pc, #240]	; (72a8 <grid_module_common_init+0x1e0>)
    71b8:	a803      	add	r0, sp, #12
    71ba:	4798      	blx	r3
		payload_length = strlen(payload_template);
    71bc:	a803      	add	r0, sp, #12
    71be:	47c0      	blx	r8
    71c0:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_RELEASE, payload_template, payload_length);
    71c2:	6868      	ldr	r0, [r5, #4]
    71c4:	aa03      	add	r2, sp, #12
    71c6:	68c0      	ldr	r0, [r0, #12]
    71c8:	2108      	movs	r1, #8
    71ca:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgresponse
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71cc:	227e      	movs	r2, #126	; 0x7e
    71ce:	4621      	mov	r1, r4
    71d0:	a804      	add	r0, sp, #16
    71d2:	9403      	str	r4, [sp, #12]
    71d4:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_RESPONES GRID_ACTIONSTRING_CFG_RESPONSE);
    71d6:	493a      	ldr	r1, [pc, #232]	; (72c0 <grid_module_common_init+0x1f8>)
    71d8:	4b33      	ldr	r3, [pc, #204]	; (72a8 <grid_module_common_init+0x1e0>)
    71da:	a803      	add	r0, sp, #12
    71dc:	4798      	blx	r3
		payload_length = strlen(payload_template);
    71de:	a803      	add	r0, sp, #12
    71e0:	47c0      	blx	r8
    71e2:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_RESPONSE, payload_template, payload_length);
    71e4:	6868      	ldr	r0, [r5, #4]
    71e6:	aa03      	add	r2, sp, #12
    71e8:	68c0      	ldr	r0, [r0, #12]
    71ea:	2109      	movs	r1, #9
    71ec:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgrequest
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71ee:	227e      	movs	r2, #126	; 0x7e
    71f0:	4621      	mov	r1, r4
    71f2:	a804      	add	r0, sp, #16
    71f4:	9403      	str	r4, [sp, #12]
    71f6:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_REQUEST GRID_ACTIONSTRING_CFG_REQUEST);
    71f8:	4932      	ldr	r1, [pc, #200]	; (72c4 <grid_module_common_init+0x1fc>)
    71fa:	4b2b      	ldr	r3, [pc, #172]	; (72a8 <grid_module_common_init+0x1e0>)
    71fc:	a803      	add	r0, sp, #12
    71fe:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7200:	a803      	add	r0, sp, #12
    7202:	47c0      	blx	r8
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7204:	686c      	ldr	r4, [r5, #4]
		payload_length = strlen(payload_template);
    7206:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7208:	aa03      	add	r2, sp, #12
    720a:	68e0      	ldr	r0, [r4, #12]
	}	
	
	
	//enable pwr!
	
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    720c:	4c2e      	ldr	r4, [pc, #184]	; (72c8 <grid_module_common_init+0x200>)
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    720e:	210a      	movs	r1, #10
    7210:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    7212:	492e      	ldr	r1, [pc, #184]	; (72cc <grid_module_common_init+0x204>)
    7214:	482e      	ldr	r0, [pc, #184]	; (72d0 <grid_module_common_init+0x208>)
    7216:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7218:	4b2e      	ldr	r3, [pc, #184]	; (72d4 <grid_module_common_init+0x20c>)
    721a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    721e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(UI_PWR_EN, true);

	// ADC SETUP	
	
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    7222:	47b8      	blx	r7
    7224:	4625      	mov	r5, r4
    7226:	b970      	cbnz	r0, 7246 <grid_module_common_init+0x17e>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PO16");
    7228:	492b      	ldr	r1, [pc, #172]	; (72d8 <grid_module_common_init+0x210>)
    722a:	4829      	ldr	r0, [pc, #164]	; (72d0 <grid_module_common_init+0x208>)
    722c:	47a8      	blx	r5
		grid_module_po16_revb_init();
    722e:	4b2b      	ldr	r3, [pc, #172]	; (72dc <grid_module_common_init+0x214>)
	}
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
		grid_module_bu16_revb_init();
    7230:	4798      	blx	r3
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
	}


	grid_sys_init(&grid_sys_state);
    7232:	4b2b      	ldr	r3, [pc, #172]	; (72e0 <grid_module_common_init+0x218>)
    7234:	482b      	ldr	r0, [pc, #172]	; (72e4 <grid_module_common_init+0x21c>)
    7236:	4798      	blx	r3


	grid_nvm_init(&grid_nvm_state, &FLASH_0);
    7238:	492b      	ldr	r1, [pc, #172]	; (72e8 <grid_module_common_init+0x220>)
    723a:	482c      	ldr	r0, [pc, #176]	; (72ec <grid_module_common_init+0x224>)
    723c:	4b2c      	ldr	r3, [pc, #176]	; (72f0 <grid_module_common_init+0x228>)
    723e:	4798      	blx	r3
	
		
}
    7240:	b025      	add	sp, #148	; 0x94
    7242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    7246:	47b8      	blx	r7
    7248:	2808      	cmp	r0, #8
    724a:	d0ed      	beq.n	7228 <grid_module_common_init+0x160>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    724c:	47b8      	blx	r7
    724e:	2880      	cmp	r0, #128	; 0x80
    7250:	d104      	bne.n	725c <grid_module_common_init+0x194>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
    7252:	4928      	ldr	r1, [pc, #160]	; (72f4 <grid_module_common_init+0x22c>)
    7254:	481e      	ldr	r0, [pc, #120]	; (72d0 <grid_module_common_init+0x208>)
    7256:	47a8      	blx	r5
		grid_module_bu16_revb_init();
    7258:	4b27      	ldr	r3, [pc, #156]	; (72f8 <grid_module_common_init+0x230>)
    725a:	e7e9      	b.n	7230 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    725c:	47b8      	blx	r7
    725e:	2888      	cmp	r0, #136	; 0x88
    7260:	d0f7      	beq.n	7252 <grid_module_common_init+0x18a>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_PBF4_RevA){
    7262:	47b8      	blx	r7
    7264:	2840      	cmp	r0, #64	; 0x40
    7266:	d104      	bne.n	7272 <grid_module_common_init+0x1aa>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PBF4");					
    7268:	4924      	ldr	r1, [pc, #144]	; (72fc <grid_module_common_init+0x234>)
    726a:	4819      	ldr	r0, [pc, #100]	; (72d0 <grid_module_common_init+0x208>)
    726c:	47a0      	blx	r4
		grid_module_pbf4_reva_init();			
    726e:	4b24      	ldr	r3, [pc, #144]	; (7300 <grid_module_common_init+0x238>)
    7270:	e7de      	b.n	7230 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_EN16_RevA){
    7272:	47b8      	blx	r7
    7274:	28c0      	cmp	r0, #192	; 0xc0
    7276:	d104      	bne.n	7282 <grid_module_common_init+0x1ba>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: EN16");
    7278:	4922      	ldr	r1, [pc, #136]	; (7304 <grid_module_common_init+0x23c>)
    727a:	4815      	ldr	r0, [pc, #84]	; (72d0 <grid_module_common_init+0x208>)
    727c:	47a0      	blx	r4
		grid_module_en16_reva_init();	
    727e:	4b22      	ldr	r3, [pc, #136]	; (7308 <grid_module_common_init+0x240>)
    7280:	e7d6      	b.n	7230 <grid_module_common_init+0x168>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
    7282:	4922      	ldr	r1, [pc, #136]	; (730c <grid_module_common_init+0x244>)
    7284:	4812      	ldr	r0, [pc, #72]	; (72d0 <grid_module_common_init+0x208>)
    7286:	47a0      	blx	r4
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
    7288:	4921      	ldr	r1, [pc, #132]	; (7310 <grid_module_common_init+0x248>)
    728a:	4811      	ldr	r0, [pc, #68]	; (72d0 <grid_module_common_init+0x208>)
    728c:	47a0      	blx	r4
    728e:	e7d0      	b.n	7232 <grid_module_common_init+0x16a>
    7290:	2001c7c0 	.word	0x2001c7c0
    7294:	00009a71 	.word	0x00009a71
    7298:	00014ac5 	.word	0x00014ac5
    729c:	00009aa5 	.word	0x00009aa5
    72a0:	0000a3d1 	.word	0x0000a3d1
    72a4:	00016b9a 	.word	0x00016b9a
    72a8:	00014ebd 	.word	0x00014ebd
    72ac:	00016a52 	.word	0x00016a52
    72b0:	000098ed 	.word	0x000098ed
    72b4:	00009f35 	.word	0x00009f35
    72b8:	00016bae 	.word	0x00016bae
    72bc:	00016bd4 	.word	0x00016bd4
    72c0:	00016bed 	.word	0x00016bed
    72c4:	00016c13 	.word	0x00016c13
    72c8:	000146ad 	.word	0x000146ad
    72cc:	00016c39 	.word	0x00016c39
    72d0:	00016ae3 	.word	0x00016ae3
    72d4:	41008000 	.word	0x41008000
    72d8:	00016c49 	.word	0x00016c49
    72dc:	000083a1 	.word	0x000083a1
    72e0:	00009651 	.word	0x00009651
    72e4:	2000f008 	.word	0x2000f008
    72e8:	2001ccf8 	.word	0x2001ccf8
    72ec:	2000fa1c 	.word	0x2000fa1c
    72f0:	00008cf9 	.word	0x00008cf9
    72f4:	00016c5b 	.word	0x00016c5b
    72f8:	00007651 	.word	0x00007651
    72fc:	00016c6d 	.word	0x00016c6d
    7300:	00008045 	.word	0x00008045
    7304:	00016c7f 	.word	0x00016c7f
    7308:	00007b69 	.word	0x00007b69
    730c:	00016c91 	.word	0x00016c91
    7310:	00016cad 	.word	0x00016cad
    7314:	00014469 	.word	0x00014469
    7318:	00014f81 	.word	0x00014f81
    731c:	00009a2d 	.word	0x00009a2d

00007320 <grid_module_bu16_revb_hardware_start_transfer>:

static uint8_t grid_bu16_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_bu16_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};
	
	
void grid_module_bu16_revb_hardware_start_transfer(void){
    7320:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7322:	4c04      	ldr	r4, [pc, #16]	; (7334 <grid_module_bu16_revb_hardware_start_transfer+0x14>)
    7324:	4804      	ldr	r0, [pc, #16]	; (7338 <grid_module_bu16_revb_hardware_start_transfer+0x18>)
    7326:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7328:	4623      	mov	r3, r4
    732a:	4804      	ldr	r0, [pc, #16]	; (733c <grid_module_bu16_revb_hardware_start_transfer+0x1c>)

}
    732c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7330:	4718      	bx	r3
    7332:	bf00      	nop
    7334:	0000e645 	.word	0x0000e645
    7338:	2001cd84 	.word	0x2001cd84
    733c:	2001cf58 	.word	0x2001cf58

00007340 <grid_module_bu16_revb_hardware_transfer_complete_cb>:

static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    7344:	4aa4      	ldr	r2, [pc, #656]	; (75d8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x298>)
    7346:	7813      	ldrb	r3, [r2, #0]
static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7348:	b08b      	sub	sp, #44	; 0x2c
    734a:	4614      	mov	r4, r2
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    734c:	b933      	cbnz	r3, 735c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_bu16_revb_hardware_transfer_complete++;
    734e:	7813      	ldrb	r3, [r2, #0]
    7350:	3301      	adds	r3, #1
    7352:	b2db      	uxtb	r3, r3
    7354:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_bu16_revb_hardware_transfer_complete = 0;
	grid_module_bu16_revb_hardware_start_transfer();
}
    7356:	b00b      	add	sp, #44	; 0x2c
    7358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    735c:	4b9f      	ldr	r3, [pc, #636]	; (75dc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x29c>)
    735e:	48a0      	ldr	r0, [pc, #640]	; (75e0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7360:	4d9f      	ldr	r5, [pc, #636]	; (75e0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7362:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7364:	7c6a      	ldrb	r2, [r5, #17]
		bank=0;
    7366:	28ff      	cmp	r0, #255	; 0xff
    7368:	bf14      	ite	ne
    736a:	4603      	movne	r3, r0
    736c:	2300      	moveq	r3, #0
	if (bank_changed){
    736e:	b9fa      	cbnz	r2, 73b0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x70>
	uint16_t adcresult_0 = 0;
    7370:	2300      	movs	r3, #0
    7372:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7376:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    737a:	7863      	ldrb	r3, [r4, #1]
    737c:	4a99      	ldr	r2, [pc, #612]	; (75e4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a4>)
    737e:	3308      	adds	r3, #8
    7380:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7382:	7863      	ldrb	r3, [r4, #1]
    7384:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    7386:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7388:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_bu16_revb_mux++;
    738a:	7863      	ldrb	r3, [r4, #1]
    738c:	3301      	adds	r3, #1
    738e:	b2db      	uxtb	r3, r3
    7390:	7063      	strb	r3, [r4, #1]
	grid_module_bu16_revb_mux%=8;
    7392:	7863      	ldrb	r3, [r4, #1]
    7394:	f003 0307 	and.w	r3, r3, #7
    7398:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_bu16_revb_mux/1%2);
    739a:	7863      	ldrb	r3, [r4, #1]
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    739c:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    73a0:	b2f6      	uxtb	r6, r6
    73a2:	4b91      	ldr	r3, [pc, #580]	; (75e8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    73a4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    73a8:	d141      	bne.n	742e <grid_module_bu16_revb_hardware_transfer_complete_cb+0xee>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    73aa:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    73ae:	e040      	b.n	7432 <grid_module_bu16_revb_hardware_transfer_complete_cb+0xf2>
		grid_sys_state.bank_active_changed = 0;
    73b0:	f04f 0900 	mov.w	r9, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73b4:	fa0f fa83 	sxth.w	sl, r3
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    73b8:	f8df 823c 	ldr.w	r8, [pc, #572]	; 75f8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>
		grid_sys_state.bank_active_changed = 0;
    73bc:	f885 9011 	strb.w	r9, [r5, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73c0:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73c4:	eb04 1703 	add.w	r7, r4, r3, lsl #4
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    73c8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    73cc:	7bea      	ldrb	r2, [r5, #15]
    73ce:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    73d2:	fa5f f689 	uxtb.w	r6, r9
    73d6:	7a5b      	ldrb	r3, [r3, #9]
    73d8:	42b3      	cmp	r3, r6
    73da:	d9c9      	bls.n	7370 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x30>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73dc:	f8d8 2004 	ldr.w	r2, [r8, #4]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    73e0:	f8df b220 	ldr.w	fp, [pc, #544]	; 7604 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c4>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73e4:	4452      	add	r2, sl
    73e6:	2364      	movs	r3, #100	; 0x64
    73e8:	68d2      	ldr	r2, [r2, #12]
    73ea:	4373      	muls	r3, r6
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73ec:	19b9      	adds	r1, r7, r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73ee:	441a      	add	r2, r3
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73f0:	7888      	ldrb	r0, [r1, #2]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    73f2:	f891 1042 	ldrb.w	r1, [r1, #66]	; 0x42
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73f6:	6190      	str	r0, [r2, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    73f8:	61d1      	str	r1, [r2, #28]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    73fa:	f8d8 2004 	ldr.w	r2, [r8, #4]
    73fe:	7be9      	ldrb	r1, [r5, #15]
    7400:	eb02 1201 	add.w	r2, r2, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7404:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7406:	68d2      	ldr	r2, [r2, #12]
    7408:	4413      	add	r3, r2
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    740a:	4632      	mov	r2, r6
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    740c:	60de      	str	r6, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    740e:	7be9      	ldrb	r1, [r5, #15]
    7410:	2300      	movs	r3, #0
    7412:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7414:	7be9      	ldrb	r1, [r5, #15]
    7416:	2304      	movs	r3, #4
    7418:	4632      	mov	r2, r6
    741a:	4640      	mov	r0, r8
    741c:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    741e:	7be9      	ldrb	r1, [r5, #15]
    7420:	2305      	movs	r3, #5
    7422:	4632      	mov	r2, r6
    7424:	4640      	mov	r0, r8
    7426:	47d8      	blx	fp
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7428:	f109 0901 	add.w	r9, r9, #1
    742c:	e7cc      	b.n	73c8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x88>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    742e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_bu16_revb_mux/2%2);
    7432:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7434:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 7608 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c8>
    7438:	486c      	ldr	r0, [pc, #432]	; (75ec <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2ac>)
    743a:	f013 0f02 	tst.w	r3, #2
    743e:	4b6a      	ldr	r3, [pc, #424]	; (75e8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7440:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7444:	bf14      	ite	ne
    7446:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    744a:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_bu16_revb_mux/4%2);
    744e:	7863      	ldrb	r3, [r4, #1]
    7450:	f013 0f04 	tst.w	r3, #4
    7454:	4b64      	ldr	r3, [pc, #400]	; (75e8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7456:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    745a:	bf14      	ite	ne
    745c:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7460:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7464:	2100      	movs	r1, #0
    7466:	2302      	movs	r3, #2
    7468:	aa05      	add	r2, sp, #20
    746a:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    746c:	2302      	movs	r3, #2
    746e:	f10d 0216 	add.w	r2, sp, #22
    7472:	485f      	ldr	r0, [pc, #380]	; (75f0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b0>)
    7474:	2100      	movs	r1, #0
    7476:	47c0      	blx	r8
	uint8_t result_value[2] = {0};
    7478:	2300      	movs	r3, #0
    747a:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint8_t result_valid[2] = {0};
    747e:	f8ad 3010 	strh.w	r3, [sp, #16]
	if (adcresult_0>60000){
    7482:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	result_index[0] = adc_index_0;
    7486:	f88d 7008 	strb.w	r7, [sp, #8]
	if (adcresult_0>60000){
    748a:	f64e 2260 	movw	r2, #60000	; 0xea60
    748e:	4293      	cmp	r3, r2
	result_index[1] = adc_index_1;
    7490:	f88d 6009 	strb.w	r6, [sp, #9]
	if (adcresult_0>60000){
    7494:	d978      	bls.n	7588 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x248>
		result_valid[0] = 1;
    7496:	2301      	movs	r3, #1
    7498:	f88d 3010 	strb.w	r3, [sp, #16]
	if (adcresult_1>60000){
    749c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    74a0:	f64e 2260 	movw	r2, #60000	; 0xea60
    74a4:	4293      	cmp	r3, r2
    74a6:	d975      	bls.n	7594 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x254>
		result_value[1] = 0;
    74a8:	2300      	movs	r3, #0
		result_value[1] = 127;
    74aa:	f88d 300d 	strb.w	r3, [sp, #13]
		result_valid[1] = 1;
    74ae:	2301      	movs	r3, #1
    74b0:	f88d 3011 	strb.w	r3, [sp, #17]
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    74b4:	4b4f      	ldr	r3, [pc, #316]	; (75f4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b4>)
    74b6:	ae06      	add	r6, sp, #24
    74b8:	f103 0710 	add.w	r7, r3, #16
    74bc:	6818      	ldr	r0, [r3, #0]
    74be:	6859      	ldr	r1, [r3, #4]
    74c0:	4632      	mov	r2, r6
    74c2:	c203      	stmia	r2!, {r0, r1}
    74c4:	3308      	adds	r3, #8
    74c6:	42bb      	cmp	r3, r7
    74c8:	4616      	mov	r6, r2
    74ca:	d1f7      	bne.n	74bc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74cc:	484a      	ldr	r0, [pc, #296]	; (75f8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    74ce:	2300      	movs	r3, #0
    74d0:	f10d 0908 	add.w	r9, sp, #8
    74d4:	f10d 0b0c 	add.w	fp, sp, #12
    74d8:	9301      	str	r3, [sp, #4]
    74da:	4682      	mov	sl, r0
		uint8_t res_index = result_index[i];
    74dc:	f819 6b01 	ldrb.w	r6, [r9], #1
		uint8_t res_value = result_value[i];
    74e0:	f81b 8b01 	ldrb.w	r8, [fp], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74e4:	6843      	ldr	r3, [r0, #4]
    74e6:	7bea      	ldrb	r2, [r5, #15]
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74e8:	19a1      	adds	r1, r4, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74ea:	b2d2      	uxtb	r2, r2
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74ec:	f891 c082 	ldrb.w	ip, [r1, #130]	; 0x82
    74f0:	45e0      	cmp	r8, ip
    74f2:	d042      	beq.n	757a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
    74f4:	9f01      	ldr	r7, [sp, #4]
		uint8_t res_valid = result_valid[i];
    74f6:	a904      	add	r1, sp, #16
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74f8:	5c79      	ldrb	r1, [r7, r1]
    74fa:	2901      	cmp	r1, #1
    74fc:	d13d      	bne.n	757a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74fe:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    7502:	2164      	movs	r1, #100	; 0x64
    7504:	68db      	ldr	r3, [r3, #12]
    7506:	fb16 f101 	smulbb	r1, r6, r1
    750a:	440b      	add	r3, r1
			if (grid_bu16_helper_template_b_abs[res_index] == 0){ // Button Press Event
    750c:	f1bc 0f00 	cmp.w	ip, #0
    7510:	d14d      	bne.n	75ae <grid_module_bu16_revb_hardware_transfer_complete_cb+0x26e>
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7512:	699a      	ldr	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7514:	f8d3 e01c 	ldr.w	lr, [r3, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7518:	2a00      	cmp	r2, #0
    751a:	bf0c      	ite	eq
    751c:	227f      	moveq	r2, #127	; 0x7f
    751e:	2200      	movne	r2, #0
    7520:	619a      	str	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7522:	f1be 0f00 	cmp.w	lr, #0
    7526:	d13c      	bne.n	75a2 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x262>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7528:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    752c:	f8c3 c01c 	str.w	ip, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7530:	f895 c00f 	ldrb.w	ip, [r5, #15]
    7534:	9f01      	ldr	r7, [sp, #4]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7536:	69db      	ldr	r3, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7538:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
    753c:	44bc      	add	ip, r7
    753e:	f88c 2002 	strb.w	r2, [ip, #2]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7542:	7bea      	ldrb	r2, [r5, #15]
    7544:	eb04 1202 	add.w	r2, r4, r2, lsl #4
    7548:	443a      	add	r2, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    754a:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    754e:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
    7552:	2300      	movs	r3, #0
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7554:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7558:	441a      	add	r2, r3
    755a:	3310      	adds	r3, #16
    755c:	68d2      	ldr	r2, [r2, #12]
    755e:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7560:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7562:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7566:	d1f5      	bne.n	7554 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x214>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7568:	7be9      	ldrb	r1, [r5, #15]
    756a:	2304      	movs	r3, #4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    756c:	4632      	mov	r2, r6
    756e:	4f23      	ldr	r7, [pc, #140]	; (75fc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2bc>)
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7570:	4426      	add	r6, r4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7572:	47b8      	blx	r7
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7574:	4820      	ldr	r0, [pc, #128]	; (75f8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
    7576:	f886 8082 	strb.w	r8, [r6, #130]	; 0x82
	for (uint8_t i=0; i<2; i++)
    757a:	9b01      	ldr	r3, [sp, #4]
    757c:	b173      	cbz	r3, 759c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x25c>
	grid_module_bu16_revb_hardware_transfer_complete = 0;
    757e:	2300      	movs	r3, #0
    7580:	7023      	strb	r3, [r4, #0]
	grid_module_bu16_revb_hardware_start_transfer();
    7582:	4b1f      	ldr	r3, [pc, #124]	; (7600 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c0>)
    7584:	4798      	blx	r3
    7586:	e6e6      	b.n	7356 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16>
	else if (adcresult_0<200){
    7588:	2bc7      	cmp	r3, #199	; 0xc7
    758a:	d887      	bhi.n	749c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x15c>
		result_value[0] = 127;
    758c:	237f      	movs	r3, #127	; 0x7f
    758e:	f88d 300c 	strb.w	r3, [sp, #12]
    7592:	e780      	b.n	7496 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x156>
	else if (adcresult_1<200){
    7594:	2bc7      	cmp	r3, #199	; 0xc7
    7596:	d88d      	bhi.n	74b4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x174>
		result_value[1] = 127;
    7598:	237f      	movs	r3, #127	; 0x7f
    759a:	e786      	b.n	74aa <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16a>
    759c:	2301      	movs	r3, #1
    759e:	9301      	str	r3, [sp, #4]
    75a0:	e79c      	b.n	74dc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x19c>
				else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    75a2:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    75a6:	bf08      	it	eq
    75a8:	f04f 0c7f 	moveq.w	ip, #127	; 0x7f
    75ac:	e7be      	b.n	752c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1ec>
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    75ae:	aa0a      	add	r2, sp, #40	; 0x28
    75b0:	4432      	add	r2, r6
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    75b2:	60de      	str	r6, [r3, #12]
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    75b4:	f812 2c10 	ldrb.w	r2, [r2, #-16]
    75b8:	611a      	str	r2, [r3, #16]
    75ba:	2300      	movs	r3, #0
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    75bc:	469c      	mov	ip, r3
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    75be:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    75c2:	441a      	add	r2, r3
    75c4:	3310      	adds	r3, #16
    75c6:	68d2      	ldr	r2, [r2, #12]
    75c8:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    75ca:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    75cc:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    75d0:	d1f5      	bne.n	75be <grid_module_bu16_revb_hardware_transfer_complete_cb+0x27e>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    75d2:	7be9      	ldrb	r1, [r5, #15]
    75d4:	2305      	movs	r3, #5
    75d6:	e7c9      	b.n	756c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x22c>
    75d8:	200005ec 	.word	0x200005ec
    75dc:	00009707 	.word	0x00009707
    75e0:	2000f008 	.word	0x2000f008
    75e4:	20000308 	.word	0x20000308
    75e8:	41008000 	.word	0x41008000
    75ec:	2001cd84 	.word	0x2001cd84
    75f0:	2001cf58 	.word	0x2001cf58
    75f4:	00016cbc 	.word	0x00016cbc
    75f8:	2000effc 	.word	0x2000effc
    75fc:	0000a191 	.word	0x0000a191
    7600:	00007321 	.word	0x00007321
    7604:	0000a4e5 	.word	0x0000a4e5
    7608:	0000e589 	.word	0x0000e589

0000760c <grid_module_bu16_revb_hardware_init>:

void grid_module_bu16_revb_hardware_init(void){
    760c:	b570      	push	{r4, r5, r6, lr}
	

	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    760e:	4c0b      	ldr	r4, [pc, #44]	; (763c <grid_module_bu16_revb_hardware_init+0x30>)
    7610:	4e0b      	ldr	r6, [pc, #44]	; (7640 <grid_module_bu16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7612:	4d0c      	ldr	r5, [pc, #48]	; (7644 <grid_module_bu16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7614:	4b0c      	ldr	r3, [pc, #48]	; (7648 <grid_module_bu16_revb_hardware_init+0x3c>)
    7616:	2200      	movs	r2, #0
    7618:	4611      	mov	r1, r2
    761a:	4620      	mov	r0, r4
    761c:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    761e:	2200      	movs	r2, #0
    7620:	4b09      	ldr	r3, [pc, #36]	; (7648 <grid_module_bu16_revb_hardware_init+0x3c>)
    7622:	4611      	mov	r1, r2
    7624:	4628      	mov	r0, r5
    7626:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    7628:	4620      	mov	r0, r4
    762a:	4c08      	ldr	r4, [pc, #32]	; (764c <grid_module_bu16_revb_hardware_init+0x40>)
    762c:	2100      	movs	r1, #0
    762e:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    7630:	4628      	mov	r0, r5
    7632:	4623      	mov	r3, r4
    7634:	2100      	movs	r1, #0

}
    7636:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    763a:	4718      	bx	r3
    763c:	2001cd84 	.word	0x2001cd84
    7640:	0000e511 	.word	0x0000e511
    7644:	2001cf58 	.word	0x2001cf58
    7648:	00007341 	.word	0x00007341
    764c:	0000e4d1 	.word	0x0000e4d1

00007650 <grid_module_bu16_revb_init>:



void grid_module_bu16_revb_init(){
    7650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	grid_led_lowlevel_init(&grid_led_state, 16);
    7654:	4b12      	ldr	r3, [pc, #72]	; (76a0 <grid_module_bu16_revb_init+0x50>)
    7656:	4813      	ldr	r0, [pc, #76]	; (76a4 <grid_module_bu16_revb_init+0x54>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7658:	4e13      	ldr	r6, [pc, #76]	; (76a8 <grid_module_bu16_revb_init+0x58>)
    765a:	4f14      	ldr	r7, [pc, #80]	; (76ac <grid_module_bu16_revb_init+0x5c>)
		
		for (uint8_t j=0; j<16; j++){

			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    765c:	f8df 805c 	ldr.w	r8, [pc, #92]	; 76bc <grid_module_bu16_revb_init+0x6c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7660:	2110      	movs	r1, #16
    7662:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    7664:	4810      	ldr	r0, [pc, #64]	; (76a8 <grid_module_bu16_revb_init+0x58>)
    7666:	4b12      	ldr	r3, [pc, #72]	; (76b0 <grid_module_bu16_revb_init+0x60>)
    7668:	2104      	movs	r1, #4
    766a:	4798      	blx	r3
    766c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    766e:	2210      	movs	r2, #16
    7670:	b2e1      	uxtb	r1, r4
    7672:	4630      	mov	r0, r6
    7674:	47b8      	blx	r7
		for (uint8_t j=0; j<16; j++){
    7676:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    767a:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    767c:	6870      	ldr	r0, [r6, #4]
    767e:	b2e9      	uxtb	r1, r5
    7680:	2202      	movs	r2, #2
    7682:	4448      	add	r0, r9
    7684:	3501      	adds	r5, #1
    7686:	47c0      	blx	r8
		for (uint8_t j=0; j<16; j++){
    7688:	2d10      	cmp	r5, #16
    768a:	d1f7      	bne.n	767c <grid_module_bu16_revb_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    768c:	3401      	adds	r4, #1
    768e:	2c04      	cmp	r4, #4
    7690:	d1ed      	bne.n	766e <grid_module_bu16_revb_init+0x1e>

		}		
		
	}
				
	grid_module_bu16_revb_hardware_init();
    7692:	4b08      	ldr	r3, [pc, #32]	; (76b4 <grid_module_bu16_revb_init+0x64>)
    7694:	4798      	blx	r3
	grid_module_bu16_revb_hardware_start_transfer();

};
    7696:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_bu16_revb_hardware_start_transfer();
    769a:	4b07      	ldr	r3, [pc, #28]	; (76b8 <grid_module_bu16_revb_init+0x68>)
    769c:	4718      	bx	r3
    769e:	bf00      	nop
    76a0:	00006f19 	.word	0x00006f19
    76a4:	2001c838 	.word	0x2001c838
    76a8:	2000effc 	.word	0x2000effc
    76ac:	00009aa5 	.word	0x00009aa5
    76b0:	00009a71 	.word	0x00009a71
    76b4:	0000760d 	.word	0x0000760d
    76b8:	00007321 	.word	0x00007321
    76bc:	0000a3d1 	.word	0x0000a3d1

000076c0 <grid_module_en16_reva_hardware_start_transfer>:





void grid_module_en16_reva_hardware_start_transfer(void){
    76c0:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    76c2:	4b08      	ldr	r3, [pc, #32]	; (76e4 <grid_module_en16_reva_hardware_start_transfer+0x24>)
	

	gpio_set_pin_level(PIN_UI_SPI_CS0, true);

	spi_m_async_enable(&UI_SPI);
    76c4:	4808      	ldr	r0, [pc, #32]	; (76e8 <grid_module_en16_reva_hardware_start_transfer+0x28>)

	//io_write(io, UI_SPI_TX_BUFFER, 8);
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    76c6:	4c09      	ldr	r4, [pc, #36]	; (76ec <grid_module_en16_reva_hardware_start_transfer+0x2c>)
    76c8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    76cc:	619a      	str	r2, [r3, #24]
	spi_m_async_enable(&UI_SPI);
    76ce:	4b08      	ldr	r3, [pc, #32]	; (76f0 <grid_module_en16_reva_hardware_start_transfer+0x30>)
    76d0:	4798      	blx	r3
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    76d2:	4a08      	ldr	r2, [pc, #32]	; (76f4 <grid_module_en16_reva_hardware_start_transfer+0x34>)
    76d4:	4804      	ldr	r0, [pc, #16]	; (76e8 <grid_module_en16_reva_hardware_start_transfer+0x28>)
    76d6:	46a4      	mov	ip, r4
    76d8:	2308      	movs	r3, #8

}
    76da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    76de:	f102 010e 	add.w	r1, r2, #14
    76e2:	4760      	bx	ip
    76e4:	41008000 	.word	0x41008000
    76e8:	2001cc70 	.word	0x2001cc70
    76ec:	0000f20d 	.word	0x0000f20d
    76f0:	0000f16d 	.word	0x0000f16d
    76f4:	2000067e 	.word	0x2000067e

000076f8 <grid_module_en16_reva_hardware_transfer_complete_cb>:

void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    76f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    76fc:	4ba8      	ldr	r3, [pc, #672]	; (79a0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2a8>)
	
	// Set the shift registers to continuously load data until new transaction is issued
	gpio_set_pin_level(PIN_UI_SPI_CS0, false);


	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    76fe:	48a9      	ldr	r0, [pc, #676]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
	if (bank == 255){
		bank=0;
	}


	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7700:	4fa8      	ldr	r7, [pc, #672]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7702:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7706:	615a      	str	r2, [r3, #20]
void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    7708:	b089      	sub	sp, #36	; 0x24
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    770a:	4ba7      	ldr	r3, [pc, #668]	; (79a8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b0>)
    770c:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    770e:	7c7b      	ldrb	r3, [r7, #17]
		bank=0;
    7710:	28ff      	cmp	r0, #255	; 0xff
    7712:	bf14      	ite	ne
    7714:	4606      	movne	r6, r0
    7716:	2600      	moveq	r6, #0
		
	if (bank_changed){
    7718:	2b00      	cmp	r3, #0
    771a:	f040 815f 	bne.w	79dc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e4>
		

		uint8_t i = UI_ENCODER_LOOKUP[j];
		

		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    771e:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 79d8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e0>
				uint8_t controlnumber = i;
 
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 

				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    7722:	0133      	lsls	r3, r6, #4
    7724:	9302      	str	r3, [sp, #8]
    7726:	eb08 1306 	add.w	r3, r8, r6, lsl #4
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    772a:	f04f 0b00 	mov.w	fp, #0
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    772e:	9303      	str	r3, [sp, #12]
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7730:	f3cb 0346 	ubfx	r3, fp, #1, #7
    7734:	f00b 0201 	and.w	r2, fp, #1
    7738:	f818 3003 	ldrb.w	r3, [r8, r3]
    773c:	0092      	lsls	r2, r2, #2
    773e:	4113      	asrs	r3, r2
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    7740:	eb08 020b 	add.w	r2, r8, fp
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7744:	b2de      	uxtb	r6, r3
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    7746:	f892 015c 	ldrb.w	r0, [r2, #348]	; 0x15c
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    774a:	f003 030f 	and.w	r3, r3, #15
		if (old_value != new_value){
    774e:	4283      	cmp	r3, r0
    7750:	fa5f f18b 	uxtb.w	r1, fp
    7754:	f000 8115 	beq.w	7982 <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7758:	4894      	ldr	r0, [pc, #592]	; (79ac <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b4>)
            UI_SPI_RX_BUFFER_LAST[j] = new_value;
    775a:	f882 315c 	strb.w	r3, [r2, #348]	; 0x15c
			UI_SPI_DEBUG = j;
    775e:	4a94      	ldr	r2, [pc, #592]	; (79b0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b8>)
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7760:	f81b 4000 	ldrb.w	r4, [fp, r0]
			UI_SPI_DEBUG = j;
    7764:	7011      	strb	r1, [r2, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    7766:	4d93      	ldr	r5, [pc, #588]	; (79b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2bc>)
			uint8_t button_value = (new_value&0b00000100)?1:0;
    7768:	f3c3 0280 	ubfx	r2, r3, #2, #1
    776c:	9201      	str	r2, [sp, #4]
            uint8_t phase_a      = (new_value&0b00000010)?1:0;
    776e:	f3c3 0240 	ubfx	r2, r3, #1, #1
    7772:	9200      	str	r2, [sp, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    7774:	eb05 1204 	add.w	r2, r5, r4, lsl #4
    7778:	9801      	ldr	r0, [sp, #4]
    777a:	7851      	ldrb	r1, [r2, #1]
    777c:	4281      	cmp	r1, r0
			uint8_t phase_b      = (new_value&0b00000001)?1:0;
    777e:	f006 0601 	and.w	r6, r6, #1
			if (button_value != grid_ui_encoder_array[i].button_value){
    7782:	ea4f 1704 	mov.w	r7, r4, lsl #4
    7786:	d04d      	beq.n	7824 <grid_module_en16_reva_hardware_transfer_complete_cb+0x12c>
				grid_ui_encoder_array[i].button_changed = 1;
    7788:	2101      	movs	r1, #1
				grid_ui_encoder_array[i].button_value = new_value>>2;
    778a:	089b      	lsrs	r3, r3, #2
				grid_ui_encoder_array[i].button_changed = 1;
    778c:	7091      	strb	r1, [r2, #2]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    778e:	f8df a214 	ldr.w	sl, [pc, #532]	; 79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>
				grid_ui_encoder_array[i].button_value = new_value>>2;
    7792:	7053      	strb	r3, [r2, #1]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7794:	4a88      	ldr	r2, [pc, #544]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7796:	f8df c230 	ldr.w	ip, [pc, #560]	; 79c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    779a:	6852      	ldr	r2, [r2, #4]
    779c:	f89a 100f 	ldrb.w	r1, [sl, #15]
    77a0:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    77a4:	2164      	movs	r1, #100	; 0x64
    77a6:	68d2      	ldr	r2, [r2, #12]
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    77a8:	f10d 0910 	add.w	r9, sp, #16
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    77ac:	fb04 2201 	mla	r2, r4, r1, r2
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    77b0:	f8dc 1004 	ldr.w	r1, [ip, #4]
    77b4:	f8dc 0000 	ldr.w	r0, [ip]
    77b8:	46ce      	mov	lr, r9
    77ba:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    77be:	497f      	ldr	r1, [pc, #508]	; (79bc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    77c0:	f10c 0c08 	add.w	ip, ip, #8
    77c4:	458c      	cmp	ip, r1
    77c6:	46f1      	mov	r9, lr
    77c8:	d1f2      	bne.n	77b0 <grid_module_en16_reva_hardware_transfer_complete_cb+0xb8>
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    77ca:	a908      	add	r1, sp, #32
    77cc:	4421      	add	r1, r4
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    77ce:	60d4      	str	r4, [r2, #12]
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    77d0:	2b00      	cmp	r3, #0
    77d2:	f040 8152 	bne.w	7a7a <grid_module_en16_reva_hardware_transfer_complete_cb+0x382>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    77d6:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    77da:	6111      	str	r1, [r2, #16]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    77dc:	6991      	ldr	r1, [r2, #24]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    77de:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    77e2:	2900      	cmp	r1, #0
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    77e4:	69d1      	ldr	r1, [r2, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    77e6:	f8c2 c014 	str.w	ip, [r2, #20]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    77ea:	bf0c      	ite	eq
    77ec:	4660      	moveq	r0, ip
    77ee:	2000      	movne	r0, #0
    77f0:	6190      	str	r0, [r2, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    77f2:	2900      	cmp	r1, #0
    77f4:	f040 813d 	bne.w	7a72 <grid_module_en16_reva_hardware_transfer_complete_cb+0x37a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    77f8:	233f      	movs	r3, #63	; 0x3f
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    77fa:	496a      	ldr	r1, [pc, #424]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    77fc:	61d3      	str	r3, [r2, #28]
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    77fe:	7bcb      	ldrb	r3, [r1, #15]
    7800:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    7804:	4423      	add	r3, r4
    7806:	7718      	strb	r0, [r3, #28]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7808:	7bcb      	ldrb	r3, [r1, #15]
    780a:	69d2      	ldr	r2, [r2, #28]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    780c:	7bc9      	ldrb	r1, [r1, #15]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    780e:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    7812:	4423      	add	r3, r4
    7814:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7818:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    781a:	4867      	ldr	r0, [pc, #412]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    781c:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 79cc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>
    7820:	4622      	mov	r2, r4
    7822:	47c8      	blx	r9
            if (a_now == 1 && b_now == 1){ //detent found
    7824:	9b00      	ldr	r3, [sp, #0]
    7826:	2b00      	cmp	r3, #0
    7828:	f000 8155 	beq.w	7ad6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3de>
    782c:	2e00      	cmp	r6, #0
    782e:	f000 8155 	beq.w	7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
			uint8_t b_prev = grid_ui_encoder_array[i].phase_b_previous;
    7832:	19eb      	adds	r3, r5, r7
                if (b_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7834:	7b9a      	ldrb	r2, [r3, #14]
    7836:	2a00      	cmp	r2, #0
    7838:	f040 8128 	bne.w	7a8c <grid_module_en16_reva_hardware_transfer_complete_cb+0x394>
    783c:	7bd9      	ldrb	r1, [r3, #15]
    783e:	2900      	cmp	r1, #0
    7840:	f040 814c 	bne.w	7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7844:	2201      	movs	r2, #1
    7846:	73da      	strb	r2, [r3, #15]
                    delta = -1;
    7848:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			grid_ui_encoder_array[i].phase_a_previous = a_now;
    784c:	442f      	add	r7, r5
    784e:	9b00      	ldr	r3, [sp, #0]
    7850:	737b      	strb	r3, [r7, #13]
			grid_ui_encoder_array[i].phase_b_previous = b_now;
    7852:	73be      	strb	r6, [r7, #14]
			if (delta != 0){
    7854:	f1b9 0f00 	cmp.w	r9, #0
    7858:	f000 8093 	beq.w	7982 <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
				uint32_t elapsed_time = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_ui_encoder_array[i].last_real_time);
    785c:	68b9      	ldr	r1, [r7, #8]
    785e:	4851      	ldr	r0, [pc, #324]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7860:	4b57      	ldr	r3, [pc, #348]	; (79c0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c8>)
    7862:	4798      	blx	r3
				if (elapsed_ms>25){
    7864:	f5b0 7fd0 	cmp.w	r0, #416	; 0x1a0
    7868:	f080 811b 	bcs.w	7aa2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3aa>
                uint32_t elapsed_ms = elapsed_time/RTC1MS;
    786c:	0900      	lsrs	r0, r0, #4
    786e:	2801      	cmp	r0, #1
    7870:	bf38      	it	cc
    7872:	2001      	movcc	r0, #1
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7874:	4e4b      	ldr	r6, [pc, #300]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7876:	4b53      	ldr	r3, [pc, #332]	; (79c4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2cc>)
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7878:	f240 2771 	movw	r7, #625	; 0x271
    787c:	fb00 7010 	mls	r0, r0, r0, r7
    7880:	2796      	movs	r7, #150	; 0x96
    7882:	fbb0 f7f7 	udiv	r7, r0, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7886:	4630      	mov	r0, r6
    7888:	4798      	blx	r3
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    788a:	4a4b      	ldr	r2, [pc, #300]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    788c:	6852      	ldr	r2, [r2, #4]
    788e:	7bf1      	ldrb	r1, [r6, #15]
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7890:	4e4d      	ldr	r6, [pc, #308]	; (79c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>)
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7892:	eb02 1201 	add.w	r2, r2, r1, lsl #4
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7896:	3701      	adds	r7, #1
    7898:	b2ff      	uxtb	r7, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    789a:	eb05 1504 	add.w	r5, r5, r4, lsl #4
				delta_high = delta * (velocityfactor * 2 - 1);
    789e:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    78a2:	eb0a 0a47 	add.w	sl, sl, r7, lsl #1
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    78a6:	68d2      	ldr	r2, [r2, #12]
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    78a8:	60a8      	str	r0, [r5, #8]
				delta_high = delta * (velocityfactor * 2 - 1);
    78aa:	fb0a fa09 	mul.w	sl, sl, r9
				delta_low =  delta * velocityfactor;			
    78ae:	fb07 f509 	mul.w	r5, r7, r9
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    78b2:	2164      	movs	r1, #100	; 0x64
				delta_low =  delta * velocityfactor;			
    78b4:	b2ab      	uxth	r3, r5
				delta_high = delta * (velocityfactor * 2 - 1);
    78b6:	fa1f f78a 	uxth.w	r7, sl
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    78ba:	fb04 2201 	mla	r2, r4, r1, r2
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    78be:	f10d 0e10 	add.w	lr, sp, #16
    78c2:	6871      	ldr	r1, [r6, #4]
    78c4:	6830      	ldr	r0, [r6, #0]
    78c6:	46f4      	mov	ip, lr
    78c8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    78cc:	493b      	ldr	r1, [pc, #236]	; (79bc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    78ce:	3608      	adds	r6, #8
    78d0:	428e      	cmp	r6, r1
    78d2:	46e6      	mov	lr, ip
    78d4:	d1f5      	bne.n	78c2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x1ca>
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    78d6:	a908      	add	r1, sp, #32
    78d8:	4421      	add	r1, r4
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    78da:	6214      	str	r4, [r2, #32]
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    78dc:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    78e0:	6251      	str	r1, [r2, #36]	; 0x24
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    78e2:	9903      	ldr	r1, [sp, #12]
    78e4:	4421      	add	r1, r4
    78e6:	f891 c09c 	ldrb.w	ip, [r1, #156]	; 0x9c
				uint8_t new_abs_low_velocity_value = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    78ea:	f891 60dc 	ldrb.w	r6, [r1, #220]	; 0xdc
				uint8_t new_abs_high_velocity_value = grid_en16_helper_template_e_abs_high_velocity[bank][i];
    78ee:	f891 011c 	ldrb.w	r0, [r1, #284]	; 0x11c
                
				uint8_t new_rel_no_velocity_value =  template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL];
    78f2:	f892 1034 	ldrb.w	r1, [r2, #52]	; 0x34
				
				if (delta != 0){
                    
                    
                    // ABSOLUTE NO VELOCITY						
					if (new_abs_no_velocity_value + delta < 0){
    78f6:	44cc      	add	ip, r9
    78f8:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
    78fc:	f000 80d3 	beq.w	7aa6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ae>
						new_abs_no_velocity_value = 0;
					}
					else if (new_abs_no_velocity_value + delta > 127){
    7900:	f1bc 0f7f 	cmp.w	ip, #127	; 0x7f
    7904:	f300 80d2 	bgt.w	7aac <grid_module_en16_reva_hardware_transfer_complete_cb+0x3b4>
						new_abs_no_velocity_value = 127;
					}
					else{
						new_abs_no_velocity_value += delta;
    7908:	fa5f fc8c 	uxtb.w	ip, ip
					}	
                    
                    // ABSOLUTE LOW VELOCITY						
					if (new_abs_low_velocity_value + delta_low < 0){
    790c:	1975      	adds	r5, r6, r5
    790e:	b2db      	uxtb	r3, r3
    7910:	f100 80cf 	bmi.w	7ab2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ba>
						new_abs_low_velocity_value = 0;
					}
					else if (new_abs_low_velocity_value + delta_low > 127){
    7914:	2d7f      	cmp	r5, #127	; 0x7f
    7916:	f300 80ce 	bgt.w	7ab6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3be>
						new_abs_low_velocity_value = 127;
					}
					else{
						new_abs_low_velocity_value += delta_low;
    791a:	441e      	add	r6, r3
    791c:	b2f6      	uxtb	r6, r6
					}	
  					
                    // ABSOLUTE HIGH VELOCITY						
					if (new_abs_high_velocity_value + delta_high < 0){
    791e:	eb10 0a0a 	adds.w	sl, r0, sl
    7922:	b2ff      	uxtb	r7, r7
    7924:	f100 80c9 	bmi.w	7aba <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c2>
						new_abs_high_velocity_value = 0;
					}
					else if (new_abs_high_velocity_value + delta_high > 127){
    7928:	f1ba 0f7f 	cmp.w	sl, #127	; 0x7f
    792c:	f300 80c7 	bgt.w	7abe <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c6>
						new_abs_high_velocity_value = 127;
					}
					else{
						new_abs_high_velocity_value += delta_high;
    7930:	4438      	add	r0, r7
    7932:	b2c0      	uxtb	r0, r0
					}	



                    // RELATIVE NO VELOCITY
					if (new_rel_no_velocity_value == 255){
    7934:	29ff      	cmp	r1, #255	; 0xff
    7936:	f040 80c4 	bne.w	7ac2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ca>
						if (delta>0){
							new_rel_no_velocity_value = 65;
						}
						else{
							new_rel_no_velocity_value = 63;
    793a:	f1b9 0f01 	cmp.w	r9, #1
					}
                    
                    // RELATIVE LOW VELOCITY
					if (new_rel_low_velocity_value == 255){
                        
                        new_rel_low_velocity_value = 64 + delta_low;
    793e:	f103 0340 	add.w	r3, r3, #64	; 0x40
							new_rel_no_velocity_value = 63;
    7942:	bf0c      	ite	eq
    7944:	2541      	moveq	r5, #65	; 0x41
    7946:	253f      	movne	r5, #63	; 0x3f
                        new_rel_low_velocity_value = 64 + delta_low;
    7948:	b2db      	uxtb	r3, r3
					}
                    
                    // RELATIVE HIGH VELOCITY
					if (new_rel_high_velocity_value == 255){
				
                        new_rel_high_velocity_value = 64 + delta_high;
    794a:	3740      	adds	r7, #64	; 0x40
	
                    
                    
					
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = new_rel_no_velocity_value;
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = new_rel_low_velocity_value;
    794c:	e9c2 530d 	strd	r5, r3, [r2, #52]	; 0x34
                    
                    
                    
                    
                    
                    if (button_value == 1){
    7950:	9b01      	ldr	r3, [sp, #4]
    7952:	4914      	ldr	r1, [pc, #80]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7954:	4d1d      	ldr	r5, [pc, #116]	; (79cc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>)
						new_rel_high_velocity_value += delta_high;
    7956:	b2ff      	uxtb	r7, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = new_rel_high_velocity_value;
    7958:	63d7      	str	r7, [r2, #60]	; 0x3c
                    if (button_value == 1){
    795a:	2b00      	cmp	r3, #0
    795c:	f000 80b8 	beq.w	7ad0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3d8>
                        
                        // ABS is only updated if nonpush rotation event happened
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7960:	9b02      	ldr	r3, [sp, #8]
                        
                        // ABS high velocity
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
                        
                        
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    7962:	7bc9      	ldrb	r1, [r1, #15]
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7964:	4443      	add	r3, r8
    7966:	4423      	add	r3, r4
    7968:	f883 c09c 	strb.w	ip, [r3, #156]	; 0x9c
                        grid_en16_helper_template_e_abs_low_velocity[bank][i] = new_abs_low_velocity_value;
    796c:	f883 60dc 	strb.w	r6, [r3, #220]	; 0xdc
                        grid_en16_helper_template_e_abs_high_velocity[bank][i] = new_abs_high_velocity_value;
    7970:	f883 011c 	strb.w	r0, [r3, #284]	; 0x11c
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = new_abs_low_velocity_value;
    7974:	e9c2 c60a 	strd	ip, r6, [r2, #40]	; 0x28
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
    7978:	6310      	str	r0, [r2, #48]	; 0x30
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    797a:	2301      	movs	r3, #1
                    }
                    else{
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    797c:	480e      	ldr	r0, [pc, #56]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    797e:	4622      	mov	r2, r4
    7980:	47a8      	blx	r5
	for (uint8_t j=0; j<16; j++){
    7982:	f10b 0b01 	add.w	fp, fp, #1
    7986:	f1bb 0f10 	cmp.w	fp, #16
    798a:	f47f aed1 	bne.w	7730 <grid_module_en16_reva_hardware_transfer_complete_cb+0x38>

			
	}
		

	grid_module_en16_reva_hardware_transfer_complete = 0;
    798e:	4b10      	ldr	r3, [pc, #64]	; (79d0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d8>)
    7990:	2200      	movs	r2, #0
    7992:	701a      	strb	r2, [r3, #0]
	grid_module_en16_reva_hardware_start_transfer();
    7994:	4b0f      	ldr	r3, [pc, #60]	; (79d4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2dc>)
}
    7996:	b009      	add	sp, #36	; 0x24
    7998:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_module_en16_reva_hardware_start_transfer();
    799c:	4718      	bx	r3
    799e:	bf00      	nop
    79a0:	41008000 	.word	0x41008000
    79a4:	2000f008 	.word	0x2000f008
    79a8:	00009707 	.word	0x00009707
    79ac:	20000318 	.word	0x20000318
    79b0:	2000c09d 	.word	0x2000c09d
    79b4:	20019770 	.word	0x20019770
    79b8:	2000effc 	.word	0x2000effc
    79bc:	00016cdc 	.word	0x00016cdc
    79c0:	000097ad 	.word	0x000097ad
    79c4:	000097a9 	.word	0x000097a9
    79c8:	00016ccc 	.word	0x00016ccc
    79cc:	0000a191 	.word	0x0000a191
    79d0:	2001c854 	.word	0x2001c854
    79d4:	000076c1 	.word	0x000076c1
    79d8:	2000067e 	.word	0x2000067e
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79dc:	b233      	sxth	r3, r6
		grid_sys_state.bank_active_changed = 0;
    79de:	2400      	movs	r4, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79e0:	ea4f 1b03 	mov.w	fp, r3, lsl #4
    79e4:	f8df 8108 	ldr.w	r8, [pc, #264]	; 7af0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f8>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    79e8:	f8df a108 	ldr.w	sl, [pc, #264]	; 7af4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3fc>
		grid_sys_state.bank_active_changed = 0;
    79ec:	747c      	strb	r4, [r7, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79ee:	465d      	mov	r5, fp
    79f0:	f8d8 3004 	ldr.w	r3, [r8, #4]
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    79f4:	f8df c100 	ldr.w	ip, [pc, #256]	; 7af8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x400>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79f8:	445b      	add	r3, fp
    79fa:	2164      	movs	r1, #100	; 0x64
    79fc:	68db      	ldr	r3, [r3, #12]
    79fe:	b2e2      	uxtb	r2, r4
    7a00:	fb01 3304 	mla	r3, r1, r4, r3
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7a04:	f10d 0e10 	add.w	lr, sp, #16
    7a08:	f8dc 1004 	ldr.w	r1, [ip, #4]
    7a0c:	f8dc 0000 	ldr.w	r0, [ip]
    7a10:	46f1      	mov	r9, lr
    7a12:	e8a9 0003 	stmia.w	r9!, {r0, r1}
    7a16:	4933      	ldr	r1, [pc, #204]	; (7ae4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ec>)
    7a18:	f10c 0c08 	add.w	ip, ip, #8
    7a1c:	458c      	cmp	ip, r1
    7a1e:	46ce      	mov	lr, r9
    7a20:	d1f2      	bne.n	7a08 <grid_module_en16_reva_hardware_transfer_complete_cb+0x310>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a22:	a904      	add	r1, sp, #16
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7a24:	60dc      	str	r4, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a26:	5d09      	ldrb	r1, [r1, r4]
    7a28:	6119      	str	r1, [r3, #16]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    7a2a:	f815 000a 	ldrb.w	r0, [r5, sl]
    7a2e:	6198      	str	r0, [r3, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    7a30:	482d      	ldr	r0, [pc, #180]	; (7ae8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f0>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a32:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 7afc <grid_module_en16_reva_hardware_transfer_complete_cb+0x404>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    7a36:	5c28      	ldrb	r0, [r5, r0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a38:	6259      	str	r1, [r3, #36]	; 0x24
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7a3a:	e9c3 0407 	strd	r0, r4, [r3, #28]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    7a3e:	492b      	ldr	r1, [pc, #172]	; (7aec <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f4>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a40:	9200      	str	r2, [sp, #0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    7a42:	5c68      	ldrb	r0, [r5, r1]
    7a44:	6298      	str	r0, [r3, #40]	; 0x28
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7a46:	f101 0040 	add.w	r0, r1, #64	; 0x40
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7a4a:	3180      	adds	r1, #128	; 0x80
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7a4c:	5c28      	ldrb	r0, [r5, r0]
    7a4e:	62d8      	str	r0, [r3, #44]	; 0x2c
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7a50:	5c69      	ldrb	r1, [r5, r1]
    7a52:	6319      	str	r1, [r3, #48]	; 0x30
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a54:	4640      	mov	r0, r8
    7a56:	7bf9      	ldrb	r1, [r7, #15]
    7a58:	2300      	movs	r3, #0
    7a5a:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7a5c:	3401      	adds	r4, #1
    7a5e:	7bf9      	ldrb	r1, [r7, #15]
    7a60:	9a00      	ldr	r2, [sp, #0]
    7a62:	2301      	movs	r3, #1
    7a64:	4640      	mov	r0, r8
    7a66:	47c8      	blx	r9
		for (uint8_t i = 0; i<16; i++)
    7a68:	2c10      	cmp	r4, #16
    7a6a:	f105 0501 	add.w	r5, r5, #1
    7a6e:	d1bf      	bne.n	79f0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2f8>
    7a70:	e655      	b.n	771e <grid_module_en16_reva_hardware_transfer_complete_cb+0x26>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7a72:	293f      	cmp	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7a74:	bf08      	it	eq
    7a76:	4663      	moveq	r3, ip
    7a78:	e6bf      	b.n	77fa <grid_module_en16_reva_hardware_transfer_complete_cb+0x102>
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a7a:	f811 3c10 	ldrb.w	r3, [r1, #-16]
    7a7e:	6113      	str	r3, [r2, #16]
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;
    7a80:	2300      	movs	r3, #0
    7a82:	6153      	str	r3, [r2, #20]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7a84:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7a88:	2305      	movs	r3, #5
    7a8a:	e6c6      	b.n	781a <grid_module_en16_reva_hardware_transfer_complete_cb+0x122>
                if (a_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7a8c:	7b5a      	ldrb	r2, [r3, #13]
    7a8e:	bb2a      	cbnz	r2, 7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
    7a90:	7bd9      	ldrb	r1, [r3, #15]
    7a92:	b921      	cbnz	r1, 7a9e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3a6>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7a94:	f04f 0901 	mov.w	r9, #1
    7a98:	f883 900f 	strb.w	r9, [r3, #15]
    7a9c:	e6d6      	b.n	784c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
			int16_t delta = 0;
    7a9e:	4691      	mov	r9, r2
    7aa0:	e6d4      	b.n	784c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
					elapsed_ms = 25;
    7aa2:	2019      	movs	r0, #25
    7aa4:	e6e6      	b.n	7874 <grid_module_en16_reva_hardware_transfer_complete_cb+0x17c>
						new_abs_no_velocity_value = 0;
    7aa6:	f04f 0c00 	mov.w	ip, #0
    7aaa:	e72f      	b.n	790c <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_no_velocity_value = 127;
    7aac:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
    7ab0:	e72c      	b.n	790c <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_low_velocity_value = 0;
    7ab2:	2600      	movs	r6, #0
    7ab4:	e733      	b.n	791e <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_low_velocity_value = 127;
    7ab6:	267f      	movs	r6, #127	; 0x7f
    7ab8:	e731      	b.n	791e <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_high_velocity_value = 0;
    7aba:	2000      	movs	r0, #0
    7abc:	e73a      	b.n	7934 <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_abs_high_velocity_value = 127;
    7abe:	207f      	movs	r0, #127	; 0x7f
    7ac0:	e738      	b.n	7934 <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_rel_no_velocity_value += delta;
    7ac2:	4489      	add	r9, r1
						new_rel_low_velocity_value += delta_low;
    7ac4:	440b      	add	r3, r1
						new_rel_no_velocity_value += delta;
    7ac6:	fa5f f589 	uxtb.w	r5, r9
						new_rel_low_velocity_value += delta_low;
    7aca:	b2db      	uxtb	r3, r3
						new_rel_high_velocity_value += delta_high;
    7acc:	440f      	add	r7, r1
    7ace:	e73d      	b.n	794c <grid_module_en16_reva_hardware_transfer_complete_cb+0x254>
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    7ad0:	7bc9      	ldrb	r1, [r1, #15]
    7ad2:	230d      	movs	r3, #13
    7ad4:	e752      	b.n	797c <grid_module_en16_reva_hardware_transfer_complete_cb+0x284>
            if (a_now == 0 && b_now == 0){
    7ad6:	b90e      	cbnz	r6, 7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                grid_ui_encoder_array[i].phase_change_lock = 0;
    7ad8:	19eb      	adds	r3, r5, r7
    7ada:	73de      	strb	r6, [r3, #15]
			int16_t delta = 0;
    7adc:	f04f 0900 	mov.w	r9, #0
    7ae0:	e6b4      	b.n	784c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
    7ae2:	bf00      	nop
    7ae4:	00016cdc 	.word	0x00016cdc
    7ae8:	200006da 	.word	0x200006da
    7aec:	2000071a 	.word	0x2000071a
    7af0:	2000effc 	.word	0x2000effc
    7af4:	2000069a 	.word	0x2000069a
    7af8:	00016ccc 	.word	0x00016ccc
    7afc:	0000a4e5 	.word	0x0000a4e5

00007b00 <grid_module_en16_reva_hardware_init>:
    7b00:	4b0f      	ldr	r3, [pc, #60]	; (7b40 <grid_module_en16_reva_hardware_init+0x40>)
    7b02:	f44f 1200 	mov.w	r2, #2097152	; 0x200000

void grid_module_en16_reva_hardware_init(void){
    7b06:	b510      	push	{r4, lr}
    7b08:	615a      	str	r2, [r3, #20]
	
	
	
	
	
	spi_m_async_set_mode(&UI_SPI, SPI_MODE_3);
    7b0a:	4c0e      	ldr	r4, [pc, #56]	; (7b44 <grid_module_en16_reva_hardware_init+0x44>)
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    7b0c:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    7b0e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    7b12:	629a      	str	r2, [r3, #40]	; 0x28
    7b14:	4a0c      	ldr	r2, [pc, #48]	; (7b48 <grid_module_en16_reva_hardware_init+0x48>)
    7b16:	629a      	str	r2, [r3, #40]	; 0x28
    7b18:	2103      	movs	r1, #3
    7b1a:	4b0c      	ldr	r3, [pc, #48]	; (7b4c <grid_module_en16_reva_hardware_init+0x4c>)
    7b1c:	4620      	mov	r0, r4
    7b1e:	4798      	blx	r3
	spi_m_async_set_baudrate(&UI_SPI, 1000000); // was 400000 check clock div setting
    7b20:	490b      	ldr	r1, [pc, #44]	; (7b50 <grid_module_en16_reva_hardware_init+0x50>)
    7b22:	4b0c      	ldr	r3, [pc, #48]	; (7b54 <grid_module_en16_reva_hardware_init+0x54>)
    7b24:	4620      	mov	r0, r4
    7b26:	4798      	blx	r3
	
	spi_m_async_get_io_descriptor(&UI_SPI, &grid_module_en16_reva_hardware_io);
    7b28:	490b      	ldr	r1, [pc, #44]	; (7b58 <grid_module_en16_reva_hardware_init+0x58>)
    7b2a:	4b0c      	ldr	r3, [pc, #48]	; (7b5c <grid_module_en16_reva_hardware_init+0x5c>)
    7b2c:	4620      	mov	r0, r4
    7b2e:	4798      	blx	r3


	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7b30:	4620      	mov	r0, r4
    7b32:	4a0b      	ldr	r2, [pc, #44]	; (7b60 <grid_module_en16_reva_hardware_init+0x60>)
    7b34:	4b0b      	ldr	r3, [pc, #44]	; (7b64 <grid_module_en16_reva_hardware_init+0x64>)


}
    7b36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7b3a:	2100      	movs	r1, #0
    7b3c:	4718      	bx	r3
    7b3e:	bf00      	nop
    7b40:	41008000 	.word	0x41008000
    7b44:	2001cc70 	.word	0x2001cc70
    7b48:	c0000020 	.word	0xc0000020
    7b4c:	0000f1d1 	.word	0x0000f1d1
    7b50:	000f4240 	.word	0x000f4240
    7b54:	0000f195 	.word	0x0000f195
    7b58:	2000c0a0 	.word	0x2000c0a0
    7b5c:	0000f2b5 	.word	0x0000f2b5
    7b60:	000076f9 	.word	0x000076f9
    7b64:	0000f271 	.word	0x0000f271

00007b68 <grid_module_en16_reva_init>:

void grid_module_en16_reva_init(){
    7b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	grid_led_lowlevel_init(&grid_led_state, 16);
    7b6c:	4b1d      	ldr	r3, [pc, #116]	; (7be4 <grid_module_en16_reva_init+0x7c>)
    7b6e:	481e      	ldr	r0, [pc, #120]	; (7be8 <grid_module_en16_reva_init+0x80>)

	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
	{
		
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b70:	4e1e      	ldr	r6, [pc, #120]	; (7bec <grid_module_en16_reva_init+0x84>)
    7b72:	4f1f      	ldr	r7, [pc, #124]	; (7bf0 <grid_module_en16_reva_init+0x88>)
		
		for(uint8_t j=0; j<16; j++){
		
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7b74:	f8df 808c 	ldr.w	r8, [pc, #140]	; 7c04 <grid_module_en16_reva_init+0x9c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7b78:	2110      	movs	r1, #16
    7b7a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);	
    7b7c:	481b      	ldr	r0, [pc, #108]	; (7bec <grid_module_en16_reva_init+0x84>)
    7b7e:	4b1d      	ldr	r3, [pc, #116]	; (7bf4 <grid_module_en16_reva_init+0x8c>)
    7b80:	2104      	movs	r1, #4
    7b82:	4798      	blx	r3
    7b84:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b86:	2210      	movs	r2, #16
    7b88:	b2e1      	uxtb	r1, r4
    7b8a:	4630      	mov	r0, r6
    7b8c:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    7b8e:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b92:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7b94:	6870      	ldr	r0, [r6, #4]
    7b96:	b2e9      	uxtb	r1, r5
    7b98:	2203      	movs	r2, #3
    7b9a:	4448      	add	r0, r9
    7b9c:	3501      	adds	r5, #1
    7b9e:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    7ba0:	2d10      	cmp	r5, #16
    7ba2:	d1f7      	bne.n	7b94 <grid_module_en16_reva_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
    7ba4:	3401      	adds	r4, #1
    7ba6:	2c04      	cmp	r4, #4
    7ba8:	d1ed      	bne.n	7b86 <grid_module_en16_reva_init+0x1e>
    7baa:	2200      	movs	r2, #0
    7bac:	4b12      	ldr	r3, [pc, #72]	; (7bf8 <grid_module_en16_reva_init+0x90>)
	// initialize local encoder helper struct
	for (uint8_t j = 0; j<16; j++)
	{
		grid_ui_encoder_array[j].controller_number = j;
		
		grid_ui_encoder_array[j].button_value = 1;
    7bae:	2001      	movs	r0, #1
		grid_ui_encoder_array[j].button_changed = 0; 
    7bb0:	4611      	mov	r1, r2
		grid_ui_encoder_array[j].rotation_value = 0;
		grid_ui_encoder_array[j].rotation_changed = 1;
		grid_ui_encoder_array[j].rotation_direction = 0;
		grid_ui_encoder_array[j].last_real_time = -1;
    7bb2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		grid_ui_encoder_array[j].controller_number = j;
    7bb6:	701a      	strb	r2, [r3, #0]
		grid_ui_encoder_array[j].button_value = 1;
    7bb8:	3201      	adds	r2, #1
	for (uint8_t j = 0; j<16; j++)
    7bba:	2a10      	cmp	r2, #16
		grid_ui_encoder_array[j].button_value = 1;
    7bbc:	7058      	strb	r0, [r3, #1]
		grid_ui_encoder_array[j].button_changed = 0; 
    7bbe:	7099      	strb	r1, [r3, #2]
		grid_ui_encoder_array[j].rotation_value = 0;
    7bc0:	70d9      	strb	r1, [r3, #3]
		grid_ui_encoder_array[j].rotation_changed = 1;
    7bc2:	7118      	strb	r0, [r3, #4]
		grid_ui_encoder_array[j].rotation_direction = 0;
    7bc4:	7159      	strb	r1, [r3, #5]
		grid_ui_encoder_array[j].last_real_time = -1;
    7bc6:	609c      	str	r4, [r3, #8]
		grid_ui_encoder_array[j].velocity = 0;
    7bc8:	7319      	strb	r1, [r3, #12]
		grid_ui_encoder_array[j].phase_a_previous = 1;
    7bca:	7358      	strb	r0, [r3, #13]
		grid_ui_encoder_array[j].phase_b_previous = 1;	
    7bcc:	7398      	strb	r0, [r3, #14]
        
        grid_ui_encoder_array[j].phase_change_lock = 0;
    7bce:	73d9      	strb	r1, [r3, #15]
	for (uint8_t j = 0; j<16; j++)
    7bd0:	f103 0310 	add.w	r3, r3, #16
    7bd4:	d1ef      	bne.n	7bb6 <grid_module_en16_reva_init+0x4e>
		
	}
	
	
	grid_module_en16_reva_hardware_init();
    7bd6:	4b09      	ldr	r3, [pc, #36]	; (7bfc <grid_module_en16_reva_init+0x94>)
    7bd8:	4798      	blx	r3
	
	
	grid_module_en16_reva_hardware_start_transfer();
	
}
    7bda:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_en16_reva_hardware_start_transfer();
    7bde:	4b08      	ldr	r3, [pc, #32]	; (7c00 <grid_module_en16_reva_init+0x98>)
    7be0:	4718      	bx	r3
    7be2:	bf00      	nop
    7be4:	00006f19 	.word	0x00006f19
    7be8:	2001c838 	.word	0x2001c838
    7bec:	2000effc 	.word	0x2000effc
    7bf0:	00009aa5 	.word	0x00009aa5
    7bf4:	00009a71 	.word	0x00009a71
    7bf8:	20019770 	.word	0x20019770
    7bfc:	00007b01 	.word	0x00007b01
    7c00:	000076c1 	.word	0x000076c1
    7c04:	0000a3d1 	.word	0x0000a3d1

00007c08 <grid_module_pbf4_reva_hardware_start_transfer>:
static uint8_t grid_pbf4_helper_template_b_abs[16] = {0};
	
static uint8_t grid_pbf4_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_pbf4_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};

void grid_module_pbf4_reva_hardware_start_transfer(void){
    7c08:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7c0a:	4c04      	ldr	r4, [pc, #16]	; (7c1c <grid_module_pbf4_reva_hardware_start_transfer+0x14>)
    7c0c:	4804      	ldr	r0, [pc, #16]	; (7c20 <grid_module_pbf4_reva_hardware_start_transfer+0x18>)
    7c0e:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7c10:	4623      	mov	r3, r4
    7c12:	4804      	ldr	r0, [pc, #16]	; (7c24 <grid_module_pbf4_reva_hardware_start_transfer+0x1c>)
	
}
    7c14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7c18:	4718      	bx	r3
    7c1a:	bf00      	nop
    7c1c:	0000e645 	.word	0x0000e645
    7c20:	2001cd84 	.word	0x2001cd84
    7c24:	2001cf58 	.word	0x2001cf58

00007c28 <grid_module_pbf4_reva_hardware_transfer_complete_cb>:

void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7c28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7c2c:	4aa8      	ldr	r2, [pc, #672]	; (7ed0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7c2e:	7813      	ldrb	r3, [r2, #0]
void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7c30:	b08b      	sub	sp, #44	; 0x2c
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7c32:	b933      	cbnz	r3, 7c42 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a>
		grid_module_pbf4_reva_hardware_transfer_complete++;
    7c34:	7813      	ldrb	r3, [r2, #0]
    7c36:	3301      	adds	r3, #1
    7c38:	b2db      	uxtb	r3, r3
    7c3a:	7013      	strb	r3, [r2, #0]
	
	
	
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
	grid_module_pbf4_reva_hardware_start_transfer();
}
    7c3c:	b00b      	add	sp, #44	; 0x2c
    7c3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    7c42:	4ba4      	ldr	r3, [pc, #656]	; (7ed4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ac>)
    7c44:	7c5a      	ldrb	r2, [r3, #17]
    7c46:	469a      	mov	sl, r3
    7c48:	bb02      	cbnz	r2, 7c8c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x64>
	uint16_t adcresult_0 = 0;
    7c4a:	2300      	movs	r3, #0
    7c4c:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7c50:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7c54:	4ba0      	ldr	r3, [pc, #640]	; (7ed8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b0>)
    7c56:	49a1      	ldr	r1, [pc, #644]	; (7edc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b4>)
    7c58:	781a      	ldrb	r2, [r3, #0]
    7c5a:	3208      	adds	r2, #8
    7c5c:	5c8d      	ldrb	r5, [r1, r2]
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c5e:	781a      	ldrb	r2, [r3, #0]
    7c60:	b2d2      	uxtb	r2, r2
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7c62:	b2ed      	uxtb	r5, r5
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c64:	5c8c      	ldrb	r4, [r1, r2]
	grid_module_pbf4_reva_mux++;
    7c66:	781a      	ldrb	r2, [r3, #0]
    7c68:	3201      	adds	r2, #1
    7c6a:	b2d2      	uxtb	r2, r2
    7c6c:	701a      	strb	r2, [r3, #0]
	grid_module_pbf4_reva_mux%=8;
    7c6e:	781a      	ldrb	r2, [r3, #0]
    7c70:	f002 0207 	and.w	r2, r2, #7
    7c74:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(MUX_A, grid_module_pbf4_reva_mux/1%2);
    7c76:	781a      	ldrb	r2, [r3, #0]
    7c78:	f012 0f01 	tst.w	r2, #1
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c7c:	b2e4      	uxtb	r4, r4
    7c7e:	4a98      	ldr	r2, [pc, #608]	; (7ee0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7c80:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    7c84:	d133      	bne.n	7cee <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xc6>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7c86:	f8c2 1114 	str.w	r1, [r2, #276]	; 0x114
}
    7c8a:	e032      	b.n	7cf2 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xca>
		grid_sys_state.bank_active_changed = 0;
    7c8c:	2500      	movs	r5, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7c8e:	4c95      	ldr	r4, [pc, #596]	; (7ee4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7c90:	4e95      	ldr	r6, [pc, #596]	; (7ee8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c0>)
		grid_sys_state.bank_active_changed = 0;
    7c92:	745d      	strb	r5, [r3, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7c94:	2764      	movs	r7, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7c96:	6863      	ldr	r3, [r4, #4]
    7c98:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c9c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    7ca0:	b2ea      	uxtb	r2, r5
    7ca2:	7a5b      	ldrb	r3, [r3, #9]
    7ca4:	4293      	cmp	r3, r2
    7ca6:	d9d0      	bls.n	7c4a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7ca8:	6863      	ldr	r3, [r4, #4]
    7caa:	f89a 100f 	ldrb.w	r1, [sl, #15]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cae:	9201      	str	r2, [sp, #4]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7cb0:	eb03 1301 	add.w	r3, r3, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cb4:	4620      	mov	r0, r4
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7cb6:	68db      	ldr	r3, [r3, #12]
    7cb8:	fb07 3302 	mla	r3, r7, r2, r3
    7cbc:	3501      	adds	r5, #1
    7cbe:	60da      	str	r2, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cc0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7cc4:	2300      	movs	r3, #0
    7cc6:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7cc8:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7ccc:	9a01      	ldr	r2, [sp, #4]
    7cce:	2301      	movs	r3, #1
    7cd0:	4620      	mov	r0, r4
    7cd2:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7cd4:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7cd8:	9a01      	ldr	r2, [sp, #4]
    7cda:	2304      	movs	r3, #4
    7cdc:	4620      	mov	r0, r4
    7cde:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7ce0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7ce4:	9a01      	ldr	r2, [sp, #4]
    7ce6:	2305      	movs	r3, #5
    7ce8:	4620      	mov	r0, r4
    7cea:	47b0      	blx	r6
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7cec:	e7d3      	b.n	7c96 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x6e>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7cee:	f8c2 1118 	str.w	r1, [r2, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_pbf4_reva_mux/2%2);
    7cf2:	781a      	ldrb	r2, [r3, #0]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7cf4:	4e7d      	ldr	r6, [pc, #500]	; (7eec <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c4>)
    7cf6:	487e      	ldr	r0, [pc, #504]	; (7ef0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c8>)
	uint32_t input_0 = adcresult_0*1.03;
    7cf8:	f8df b210 	ldr.w	fp, [pc, #528]	; 7f0c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e4>
    7cfc:	f8df 9210 	ldr.w	r9, [pc, #528]	; 7f10 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e8>
    7d00:	f012 0f02 	tst.w	r2, #2
    7d04:	4a76      	ldr	r2, [pc, #472]	; (7ee0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7d06:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    7d0a:	bf14      	ite	ne
    7d0c:	f8c2 1118 	strne.w	r1, [r2, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7d10:	f8c2 1114 	streq.w	r1, [r2, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_pbf4_reva_mux/4%2);
    7d14:	781b      	ldrb	r3, [r3, #0]
    7d16:	f013 0f04 	tst.w	r3, #4
    7d1a:	4b71      	ldr	r3, [pc, #452]	; (7ee0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7d1c:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7d20:	bf14      	ite	ne
    7d22:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7d26:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7d2a:	2100      	movs	r1, #0
    7d2c:	2302      	movs	r3, #2
    7d2e:	aa05      	add	r2, sp, #20
    7d30:	47b0      	blx	r6
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    7d32:	2302      	movs	r3, #2
    7d34:	f10d 0216 	add.w	r2, sp, #22
    7d38:	2100      	movs	r1, #0
    7d3a:	486e      	ldr	r0, [pc, #440]	; (7ef4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2cc>)
    7d3c:	47b0      	blx	r6
	uint32_t input_0 = adcresult_0*1.03;
    7d3e:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    7d42:	4e6d      	ldr	r6, [pc, #436]	; (7ef8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d0>)
    7d44:	47d8      	blx	fp
    7d46:	a360      	add	r3, pc, #384	; (adr r3, 7ec8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    7d48:	e9d3 2300 	ldrd	r2, r3, [r3]
    7d4c:	47b0      	blx	r6
    7d4e:	47c8      	blx	r9
    7d50:	f64f 77ff 	movw	r7, #65535	; 0xffff
    7d54:	42b8      	cmp	r0, r7
    7d56:	4680      	mov	r8, r0
    7d58:	bf28      	it	cs
    7d5a:	46b8      	movcs	r8, r7
    7d5c:	9001      	str	r0, [sp, #4]
	adcresult_0 = input_0;
    7d5e:	f8ad 8014 	strh.w	r8, [sp, #20]
	uint32_t input_1 = adcresult_1*1.03;
    7d62:	f8bd 0016 	ldrh.w	r0, [sp, #22]
    7d66:	47d8      	blx	fp
    7d68:	a357      	add	r3, pc, #348	; (adr r3, 7ec8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    7d6a:	e9d3 2300 	ldrd	r2, r3, [r3]
    7d6e:	47b0      	blx	r6
    7d70:	47c8      	blx	r9
	adcresult_1 = input_1;
    7d72:	42b8      	cmp	r0, r7
    7d74:	4603      	mov	r3, r0
    7d76:	bf28      	it	cs
    7d78:	463b      	movcs	r3, r7
    7d7a:	f8ad 3016 	strh.w	r3, [sp, #22]
	if (adc_index_1 == 8 || adc_index_1 == 9){
    7d7e:	f1a4 0308 	sub.w	r3, r4, #8
    7d82:	2b01      	cmp	r3, #1
    7d84:	d972      	bls.n	7e6c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
	else if (adc_index_0 > 13){ // BUTTON
    7d86:	2d0d      	cmp	r5, #13
    7d88:	f8df 9188 	ldr.w	r9, [pc, #392]	; 7f14 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ec>
    7d8c:	f240 80c4 	bls.w	7f18 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2f0>
		uint8_t result_value[2] = {0};
    7d90:	2300      	movs	r3, #0
		if (adcresult_0>60000){
    7d92:	9a01      	ldr	r2, [sp, #4]
		uint8_t result_value[2] = {0};
    7d94:	f8ad 300c 	strh.w	r3, [sp, #12]
		uint8_t result_valid[2] = {0};
    7d98:	f8ad 3010 	strh.w	r3, [sp, #16]
		if (adcresult_0>60000){
    7d9c:	f64e 2360 	movw	r3, #60000	; 0xea60
		result_index[0] = adc_index_0-4;
    7da0:	3d04      	subs	r5, #4
		result_index[1] = adc_index_1-4;
    7da2:	3c04      	subs	r4, #4
		if (adcresult_0>60000){
    7da4:	429a      	cmp	r2, r3
		result_index[0] = adc_index_0-4;
    7da6:	f88d 5008 	strb.w	r5, [sp, #8]
		result_index[1] = adc_index_1-4;
    7daa:	f88d 4009 	strb.w	r4, [sp, #9]
		if (adcresult_0>60000){
    7dae:	d963      	bls.n	7e78 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x250>
			result_valid[0] = 1;
    7db0:	2301      	movs	r3, #1
    7db2:	f88d 3010 	strb.w	r3, [sp, #16]
		if (adcresult_1>60000){
    7db6:	f64e 2360 	movw	r3, #60000	; 0xea60
    7dba:	4298      	cmp	r0, r3
    7dbc:	d963      	bls.n	7e86 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x25e>
			result_value[1] = 0;
    7dbe:	2300      	movs	r3, #0
			result_value[1] = 127;
    7dc0:	f88d 300d 	strb.w	r3, [sp, #13]
			result_valid[1] = 1;
    7dc4:	2301      	movs	r3, #1
    7dc6:	f88d 3011 	strb.w	r3, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7dca:	4b4c      	ldr	r3, [pc, #304]	; (7efc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d4>)
    7dcc:	ac06      	add	r4, sp, #24
    7dce:	6818      	ldr	r0, [r3, #0]
    7dd0:	6859      	ldr	r1, [r3, #4]
    7dd2:	4622      	mov	r2, r4
    7dd4:	c203      	stmia	r2!, {r0, r1}
    7dd6:	3308      	adds	r3, #8
    7dd8:	454b      	cmp	r3, r9
    7dda:	4614      	mov	r4, r2
    7ddc:	d1f7      	bne.n	7dce <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a6>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7dde:	f8df b104 	ldr.w	fp, [pc, #260]	; 7ee4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>
    7de2:	ab03      	add	r3, sp, #12
    7de4:	f10d 0808 	add.w	r8, sp, #8
    7de8:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7dea:	2400      	movs	r4, #0
    7dec:	46d9      	mov	r9, fp
			uint8_t res_value = result_value[i];
    7dee:	9b01      	ldr	r3, [sp, #4]
			uint8_t res_index = result_index[i];
    7df0:	f818 7b01 	ldrb.w	r7, [r8], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7df4:	4a42      	ldr	r2, [pc, #264]	; (7f00 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
			uint8_t res_value = result_value[i];
    7df6:	f813 6b01 	ldrb.w	r6, [r3], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7dfa:	5dd2      	ldrb	r2, [r2, r7]
			uint8_t res_value = result_value[i];
    7dfc:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7dfe:	f8db 3004 	ldr.w	r3, [fp, #4]
    7e02:	f89a 100f 	ldrb.w	r1, [sl, #15]
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7e06:	4296      	cmp	r6, r2
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7e08:	b2c9      	uxtb	r1, r1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7e0a:	d02e      	beq.n	7e6a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			uint8_t res_valid = result_valid[i];
    7e0c:	a804      	add	r0, sp, #16
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7e0e:	5c20      	ldrb	r0, [r4, r0]
    7e10:	2801      	cmp	r0, #1
    7e12:	d12a      	bne.n	7e6a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7e14:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    7e18:	2064      	movs	r0, #100	; 0x64
    7e1a:	68db      	ldr	r3, [r3, #12]
    7e1c:	fb17 f000 	smulbb	r0, r7, r0
    7e20:	4403      	add	r3, r0
				if (grid_pbf4_helper_template_b_abs[res_index] == 0){ // Button Press Event
    7e22:	2a00      	cmp	r2, #0
    7e24:	d13b      	bne.n	7e9e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x276>
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7e26:	6999      	ldr	r1, [r3, #24]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7e28:	2900      	cmp	r1, #0
    7e2a:	bf0c      	ite	eq
    7e2c:	217f      	moveq	r1, #127	; 0x7f
    7e2e:	2100      	movne	r1, #0
    7e30:	6199      	str	r1, [r3, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7e32:	69d9      	ldr	r1, [r3, #28]
    7e34:	bb69      	cbnz	r1, 7e92 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x26a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7e36:	213f      	movs	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7e38:	61d9      	str	r1, [r3, #28]
					grid_pbf4_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7e3a:	f89a 300f 	ldrb.w	r3, [sl, #15]
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e3e:	f89a 300f 	ldrb.w	r3, [sl, #15]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e42:	227f      	movs	r2, #127	; 0x7f
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e44:	2300      	movs	r3, #0
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7e46:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e4a:	4419      	add	r1, r3
    7e4c:	3310      	adds	r3, #16
    7e4e:	68c9      	ldr	r1, [r1, #12]
    7e50:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e52:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e54:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e56:	d1f6      	bne.n	7e46 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x21e>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7e58:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7e5c:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7e5e:	4d29      	ldr	r5, [pc, #164]	; (7f04 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2dc>)
    7e60:	463a      	mov	r2, r7
    7e62:	4658      	mov	r0, fp
    7e64:	47a8      	blx	r5
					grid_pbf4_helper_template_b_abs[result_index[i]] = res_value;
    7e66:	4b26      	ldr	r3, [pc, #152]	; (7f00 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
    7e68:	55de      	strb	r6, [r3, r7]
		for (uint8_t i=0; i<2; i++)
    7e6a:	b184      	cbz	r4, 7e8e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x266>
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
    7e6c:	4a18      	ldr	r2, [pc, #96]	; (7ed0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7e6e:	2300      	movs	r3, #0
    7e70:	7013      	strb	r3, [r2, #0]
	grid_module_pbf4_reva_hardware_start_transfer();
    7e72:	4b25      	ldr	r3, [pc, #148]	; (7f08 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e0>)
    7e74:	4798      	blx	r3
    7e76:	e6e1      	b.n	7c3c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x14>
		else if (adcresult_0<200){
    7e78:	9b01      	ldr	r3, [sp, #4]
    7e7a:	2bc7      	cmp	r3, #199	; 0xc7
    7e7c:	d89b      	bhi.n	7db6 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x18e>
			result_value[0] = 127;
    7e7e:	237f      	movs	r3, #127	; 0x7f
    7e80:	f88d 300c 	strb.w	r3, [sp, #12]
    7e84:	e794      	b.n	7db0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x188>
		else if (adcresult_1<200){
    7e86:	28c7      	cmp	r0, #199	; 0xc7
    7e88:	d89f      	bhi.n	7dca <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a2>
			result_value[1] = 127;
    7e8a:	237f      	movs	r3, #127	; 0x7f
    7e8c:	e798      	b.n	7dc0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x198>
    7e8e:	2401      	movs	r4, #1
    7e90:	e7ad      	b.n	7dee <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1c6>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7e92:	293f      	cmp	r1, #63	; 0x3f
    7e94:	d101      	bne.n	7e9a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x272>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7e96:	217f      	movs	r1, #127	; 0x7f
    7e98:	e7ce      	b.n	7e38 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x210>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    7e9a:	61da      	str	r2, [r3, #28]
    7e9c:	e7cd      	b.n	7e3a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x212>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7e9e:	aa0a      	add	r2, sp, #40	; 0x28
    7ea0:	19d1      	adds	r1, r2, r7
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7ea2:	60df      	str	r7, [r3, #12]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7ea4:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7ea8:	6119      	str	r1, [r3, #16]
    7eaa:	2300      	movs	r3, #0
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7eac:	461a      	mov	r2, r3
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7eae:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7eb2:	4419      	add	r1, r3
    7eb4:	3310      	adds	r3, #16
    7eb6:	68c9      	ldr	r1, [r1, #12]
    7eb8:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7eba:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7ebc:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7ebe:	d1f6      	bne.n	7eae <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x286>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7ec0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7ec4:	2305      	movs	r3, #5
    7ec6:	e7ca      	b.n	7e5e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x236>
    7ec8:	47ae147b 	.word	0x47ae147b
    7ecc:	3ff07ae1 	.word	0x3ff07ae1
    7ed0:	2000c0ac 	.word	0x2000c0ac
    7ed4:	2000f008 	.word	0x2000f008
    7ed8:	2001c7c8 	.word	0x2001c7c8
    7edc:	20000329 	.word	0x20000329
    7ee0:	41008000 	.word	0x41008000
    7ee4:	2000effc 	.word	0x2000effc
    7ee8:	0000a4e5 	.word	0x0000a4e5
    7eec:	0000e589 	.word	0x0000e589
    7ef0:	2001cd84 	.word	0x2001cd84
    7ef4:	2001cf58 	.word	0x2001cf58
    7ef8:	00013e69 	.word	0x00013e69
    7efc:	00016cdc 	.word	0x00016cdc
    7f00:	200007eb 	.word	0x200007eb
    7f04:	0000a191 	.word	0x0000a191
    7f08:	00007c09 	.word	0x00007c09
    7f0c:	00013d95 	.word	0x00013d95
    7f10:	0001428d 	.word	0x0001428d
    7f14:	00016cec 	.word	0x00016cec
		if (adc_index_1 == 0 || adc_index_1 == 1){
    7f18:	2c01      	cmp	r4, #1
    7f1a:	4e33      	ldr	r6, [pc, #204]	; (7fe8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c0>)
    7f1c:	d85e      	bhi.n	7fdc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3b4>
			grid_ain_add_sample(adc_index_0, (1<<16)-1-adcresult_0);
    7f1e:	ea88 0107 	eor.w	r1, r8, r7
    7f22:	4628      	mov	r0, r5
    7f24:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, (1<<16)-1-adcresult_1);
    7f26:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    7f2a:	1a79      	subs	r1, r7, r1
			grid_ain_add_sample(adc_index_1, adcresult_1);
    7f2c:	4620      	mov	r0, r4
    7f2e:	47b0      	blx	r6
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f30:	4a2e      	ldr	r2, [pc, #184]	; (7fec <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c4>)
		result_index[0] = adc_index_0;
    7f32:	f88d 5010 	strb.w	r5, [sp, #16]
		result_index[1] = adc_index_1;
    7f36:	f88d 4011 	strb.w	r4, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f3a:	ab06      	add	r3, sp, #24
    7f3c:	6810      	ldr	r0, [r2, #0]
    7f3e:	6851      	ldr	r1, [r2, #4]
    7f40:	461c      	mov	r4, r3
    7f42:	c403      	stmia	r4!, {r0, r1}
    7f44:	3208      	adds	r2, #8
    7f46:	454a      	cmp	r2, r9
    7f48:	4623      	mov	r3, r4
    7f4a:	d1f7      	bne.n	7f3c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x314>
		for (uint8_t i=0; i<2; i++)
    7f4c:	ab04      	add	r3, sp, #16
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f4e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 7ff8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>
    7f52:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f54:	f04f 0902 	mov.w	r9, #2
			uint8_t res_index = result_index[i];
    7f58:	9b01      	ldr	r3, [sp, #4]
    7f5a:	f813 4b01 	ldrb.w	r4, [r3], #1
    7f5e:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f60:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7f64:	f89a 200f 	ldrb.w	r2, [sl, #15]
    7f68:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			if (grid_ain_get_changed(res_index)){
    7f6c:	4620      	mov	r0, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f6e:	68dd      	ldr	r5, [r3, #12]
			if (grid_ain_get_changed(res_index)){
    7f70:	4b1f      	ldr	r3, [pc, #124]	; (7ff0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c8>)
    7f72:	4798      	blx	r3
    7f74:	b358      	cbz	r0, 7fce <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3a6>
				uint8_t res_value = grid_ain_get_average(res_index, 7);
    7f76:	4e1f      	ldr	r6, [pc, #124]	; (7ff4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3cc>)
    7f78:	2107      	movs	r1, #7
    7f7a:	4620      	mov	r0, r4
    7f7c:	47b0      	blx	r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f7e:	2764      	movs	r7, #100	; 0x64
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f80:	ab0a      	add	r3, sp, #40	; 0x28
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f82:	fb14 f707 	smulbb	r7, r4, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f86:	4423      	add	r3, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f88:	443d      	add	r5, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f8a:	f813 3c10 	ldrb.w	r3, [r3, #-16]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7f8e:	60ec      	str	r4, [r5, #12]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f90:	612b      	str	r3, [r5, #16]
    7f92:	2500      	movs	r5, #0
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f94:	4b18      	ldr	r3, [pc, #96]	; (7ff8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>)
    7f96:	685a      	ldr	r2, [r3, #4]
    7f98:	442a      	add	r2, r5
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f9a:	2107      	movs	r1, #7
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f9c:	68d2      	ldr	r2, [r2, #12]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f9e:	4620      	mov	r0, r4
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7fa0:	eb02 0b07 	add.w	fp, r2, r7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7fa4:	47b0      	blx	r6
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7fa6:	2107      	movs	r1, #7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7fa8:	f8cb 0014 	str.w	r0, [fp, #20]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7fac:	4620      	mov	r0, r4
    7fae:	47b0      	blx	r6
    7fb0:	3510      	adds	r5, #16
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    7fb2:	2300      	movs	r3, #0
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7fb4:	2d40      	cmp	r5, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7fb6:	f8cb 0018 	str.w	r0, [fp, #24]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    7fba:	f8cb 301c 	str.w	r3, [fp, #28]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7fbe:	d1e9      	bne.n	7f94 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x36c>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);
    7fc0:	4622      	mov	r2, r4
    7fc2:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7fc6:	4c0d      	ldr	r4, [pc, #52]	; (7ffc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d4>)
    7fc8:	2301      	movs	r3, #1
    7fca:	4640      	mov	r0, r8
    7fcc:	47a0      	blx	r4
		for (uint8_t i=0; i<2; i++)
    7fce:	f1b9 0f01 	cmp.w	r9, #1
    7fd2:	f43f af4b 	beq.w	7e6c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
    7fd6:	f04f 0901 	mov.w	r9, #1
    7fda:	e7bd      	b.n	7f58 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x330>
			grid_ain_add_sample(adc_index_0, adcresult_0);
    7fdc:	4641      	mov	r1, r8
    7fde:	4628      	mov	r0, r5
    7fe0:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, adcresult_1);
    7fe2:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    7fe6:	e7a1      	b.n	7f2c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x304>
    7fe8:	00004631 	.word	0x00004631
    7fec:	00016cdc 	.word	0x00016cdc
    7ff0:	000046f9 	.word	0x000046f9
    7ff4:	00004709 	.word	0x00004709
    7ff8:	2000effc 	.word	0x2000effc
    7ffc:	0000a191 	.word	0x0000a191

00008000 <grid_module_pbf4_reva_hardware_init>:

void grid_module_pbf4_reva_hardware_init(void){
    8000:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8002:	4c0b      	ldr	r4, [pc, #44]	; (8030 <grid_module_pbf4_reva_hardware_init+0x30>)
    8004:	4e0b      	ldr	r6, [pc, #44]	; (8034 <grid_module_pbf4_reva_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8006:	4d0c      	ldr	r5, [pc, #48]	; (8038 <grid_module_pbf4_reva_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8008:	4b0c      	ldr	r3, [pc, #48]	; (803c <grid_module_pbf4_reva_hardware_init+0x3c>)
    800a:	2200      	movs	r2, #0
    800c:	4611      	mov	r1, r2
    800e:	4620      	mov	r0, r4
    8010:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8012:	2200      	movs	r2, #0
    8014:	4b09      	ldr	r3, [pc, #36]	; (803c <grid_module_pbf4_reva_hardware_init+0x3c>)
    8016:	4611      	mov	r1, r2
    8018:	4628      	mov	r0, r5
    801a:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    801c:	4620      	mov	r0, r4
    801e:	4c08      	ldr	r4, [pc, #32]	; (8040 <grid_module_pbf4_reva_hardware_init+0x40>)
    8020:	2100      	movs	r1, #0
    8022:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8024:	4628      	mov	r0, r5
    8026:	4623      	mov	r3, r4
    8028:	2100      	movs	r1, #0

}
    802a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    802e:	4718      	bx	r3
    8030:	2001cd84 	.word	0x2001cd84
    8034:	0000e511 	.word	0x0000e511
    8038:	2001cf58 	.word	0x2001cf58
    803c:	00007c29 	.word	0x00007c29
    8040:	0000e4d1 	.word	0x0000e4d1

00008044 <grid_module_pbf4_reva_init>:




void grid_module_pbf4_reva_init(){
    8044:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    8048:	220e      	movs	r2, #14
    804a:	4c16      	ldr	r4, [pc, #88]	; (80a4 <grid_module_pbf4_reva_init+0x60>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);

	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 12);
    804c:	4e16      	ldr	r6, [pc, #88]	; (80a8 <grid_module_pbf4_reva_init+0x64>)
    804e:	f8df 9074 	ldr.w	r9, [pc, #116]	; 80c4 <grid_module_pbf4_reva_init+0x80>
    8052:	4f16      	ldr	r7, [pc, #88]	; (80ac <grid_module_pbf4_reva_init+0x68>)
	grid_ain_init(16, 5, 14, 7);
    8054:	2307      	movs	r3, #7
    8056:	2105      	movs	r1, #5
    8058:	2010      	movs	r0, #16
    805a:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 12);	
    805c:	4b14      	ldr	r3, [pc, #80]	; (80b0 <grid_module_pbf4_reva_init+0x6c>)
    805e:	4815      	ldr	r0, [pc, #84]	; (80b4 <grid_module_pbf4_reva_init+0x70>)
    8060:	210c      	movs	r1, #12
    8062:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    8064:	4810      	ldr	r0, [pc, #64]	; (80a8 <grid_module_pbf4_reva_init+0x64>)
    8066:	4b14      	ldr	r3, [pc, #80]	; (80b8 <grid_module_pbf4_reva_init+0x74>)
    8068:	2104      	movs	r1, #4
    806a:	4798      	blx	r3
    806c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 12);
    806e:	220c      	movs	r2, #12
    8070:	b2e1      	uxtb	r1, r4
    8072:	4630      	mov	r0, r6
    8074:	47c8      	blx	r9
		
		for(uint8_t j=0; j<12; j++){
    8076:	ea4f 1804 	mov.w	r8, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 12);
    807a:	2500      	movs	r5, #0
			
				
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    807c:	6870      	ldr	r0, [r6, #4]
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
    807e:	2d07      	cmp	r5, #7
    8080:	b2e9      	uxtb	r1, r5
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8082:	bf94      	ite	ls
    8084:	2201      	movls	r2, #1
			
			}
			else{ // BUTTONS -> MIDI Note On/Off
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    8086:	2202      	movhi	r2, #2
    8088:	4440      	add	r0, r8
    808a:	3501      	adds	r5, #1
    808c:	47b8      	blx	r7
		for(uint8_t j=0; j<12; j++){
    808e:	2d0c      	cmp	r5, #12
    8090:	d1f4      	bne.n	807c <grid_module_pbf4_reva_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    8092:	3401      	adds	r4, #1
    8094:	2c04      	cmp	r4, #4
    8096:	d1ea      	bne.n	806e <grid_module_pbf4_reva_init+0x2a>
			}
			
		}	
	}
			
	grid_module_pbf4_reva_hardware_init();
    8098:	4b08      	ldr	r3, [pc, #32]	; (80bc <grid_module_pbf4_reva_init+0x78>)
    809a:	4798      	blx	r3
	grid_module_pbf4_reva_hardware_start_transfer();
	
    809c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_pbf4_reva_hardware_start_transfer();
    80a0:	4b07      	ldr	r3, [pc, #28]	; (80c0 <grid_module_pbf4_reva_init+0x7c>)
    80a2:	4718      	bx	r3
    80a4:	000045ed 	.word	0x000045ed
    80a8:	2000effc 	.word	0x2000effc
    80ac:	0000a3d1 	.word	0x0000a3d1
    80b0:	00006f19 	.word	0x00006f19
    80b4:	2001c838 	.word	0x2001c838
    80b8:	00009a71 	.word	0x00009a71
    80bc:	00008001 	.word	0x00008001
    80c0:	00007c09 	.word	0x00007c09
    80c4:	00009aa5 	.word	0x00009aa5

000080c8 <grid_module_po16_revb_hardware_start_transfer>:

volatile uint8_t grid_module_po16_revb_hardware_transfer_complete = 0;
volatile uint8_t grid_module_po16_revb_mux =0;
volatile uint8_t grid_module_po16_revb_mux_lookup[16] = {0, 1, 4, 5, 8, 9, 12, 13, 2, 3, 6, 7, 10, 11, 14, 15};

void grid_module_po16_revb_hardware_start_transfer(void){
    80c8:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    80ca:	4c04      	ldr	r4, [pc, #16]	; (80dc <grid_module_po16_revb_hardware_start_transfer+0x14>)
    80cc:	4804      	ldr	r0, [pc, #16]	; (80e0 <grid_module_po16_revb_hardware_start_transfer+0x18>)
    80ce:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    80d0:	4623      	mov	r3, r4
    80d2:	4804      	ldr	r0, [pc, #16]	; (80e4 <grid_module_po16_revb_hardware_start_transfer+0x1c>)
	
}
    80d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    80d8:	4718      	bx	r3
    80da:	bf00      	nop
    80dc:	0000e645 	.word	0x0000e645
    80e0:	2001cd84 	.word	0x2001cd84
    80e4:	2001cf58 	.word	0x2001cf58

000080e8 <grid_module_po16_revb_hardware_transfer_complete_cb>:

static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    80e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    80ec:	4a88      	ldr	r2, [pc, #544]	; (8310 <grid_module_po16_revb_hardware_transfer_complete_cb+0x228>)
    80ee:	7813      	ldrb	r3, [r2, #0]
static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    80f0:	b089      	sub	sp, #36	; 0x24
    80f2:	4614      	mov	r4, r2
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    80f4:	b933      	cbnz	r3, 8104 <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_po16_revb_hardware_transfer_complete++;
    80f6:	7813      	ldrb	r3, [r2, #0]
    80f8:	3301      	adds	r3, #1
    80fa:	b2db      	uxtb	r3, r3
    80fc:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_po16_revb_hardware_transfer_complete = 0;
	grid_module_po16_revb_hardware_start_transfer();
}
    80fe:	b009      	add	sp, #36	; 0x24
    8100:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    8104:	4d83      	ldr	r5, [pc, #524]	; (8314 <grid_module_po16_revb_hardware_transfer_complete_cb+0x22c>)
    8106:	7c6b      	ldrb	r3, [r5, #17]
    8108:	b9fb      	cbnz	r3, 814a <grid_module_po16_revb_hardware_transfer_complete_cb+0x62>
	uint16_t adcresult_0 = 0;
    810a:	2300      	movs	r3, #0
    810c:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint16_t adcresult_1 = 0;
    8110:	f8ad 300e 	strh.w	r3, [sp, #14]
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    8114:	7863      	ldrb	r3, [r4, #1]
    8116:	4a80      	ldr	r2, [pc, #512]	; (8318 <grid_module_po16_revb_hardware_transfer_complete_cb+0x230>)
    8118:	3308      	adds	r3, #8
    811a:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    811c:	7863      	ldrb	r3, [r4, #1]
    811e:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    8120:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    8122:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_po16_revb_mux++;
    8124:	7863      	ldrb	r3, [r4, #1]
    8126:	3301      	adds	r3, #1
    8128:	b2db      	uxtb	r3, r3
    812a:	7063      	strb	r3, [r4, #1]
	grid_module_po16_revb_mux%=8;
    812c:	7863      	ldrb	r3, [r4, #1]
    812e:	f003 0307 	and.w	r3, r3, #7
    8132:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_po16_revb_mux/1%2);
    8134:	7863      	ldrb	r3, [r4, #1]
    8136:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    813a:	b2f6      	uxtb	r6, r6
    813c:	4b77      	ldr	r3, [pc, #476]	; (831c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    813e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    8142:	d128      	bne.n	8196 <grid_module_po16_revb_hardware_transfer_complete_cb+0xae>
    8144:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    8148:	e027      	b.n	819a <grid_module_po16_revb_hardware_transfer_complete_cb+0xb2>
		grid_sys_state.bank_active_changed = 0;
    814a:	2600      	movs	r6, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    814c:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 8334 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8150:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8344 <grid_module_po16_revb_hardware_transfer_complete_cb+0x25c>
		grid_sys_state.bank_active_changed = 0;
    8154:	746e      	strb	r6, [r5, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8156:	f04f 0a64 	mov.w	sl, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    815a:	f8d8 3004 	ldr.w	r3, [r8, #4]
    815e:	7bea      	ldrb	r2, [r5, #15]
    8160:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    8164:	b2f7      	uxtb	r7, r6
    8166:	7a5b      	ldrb	r3, [r3, #9]
    8168:	42bb      	cmp	r3, r7
    816a:	d9ce      	bls.n	810a <grid_module_po16_revb_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    816c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8170:	7bea      	ldrb	r2, [r5, #15]
    8172:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8176:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8178:	68db      	ldr	r3, [r3, #12]
    817a:	fb0a 3307 	mla	r3, sl, r7, r3
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    817e:	463a      	mov	r2, r7
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8180:	60df      	str	r7, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8182:	7be9      	ldrb	r1, [r5, #15]
    8184:	2300      	movs	r3, #0
    8186:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    8188:	7be9      	ldrb	r1, [r5, #15]
    818a:	2301      	movs	r3, #1
    818c:	463a      	mov	r2, r7
    818e:	4640      	mov	r0, r8
    8190:	47c8      	blx	r9
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8192:	3601      	adds	r6, #1
    8194:	e7e1      	b.n	815a <grid_module_po16_revb_hardware_transfer_complete_cb+0x72>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8196:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_po16_revb_mux/2%2);
    819a:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    819c:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8348 <grid_module_po16_revb_hardware_transfer_complete_cb+0x260>
    81a0:	485f      	ldr	r0, [pc, #380]	; (8320 <grid_module_po16_revb_hardware_transfer_complete_cb+0x238>)
	uint32_t input_0 = adcresult_0*1.03;	
    81a2:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 834c <grid_module_po16_revb_hardware_transfer_complete_cb+0x264>
    81a6:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 8350 <grid_module_po16_revb_hardware_transfer_complete_cb+0x268>
    81aa:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 8354 <grid_module_po16_revb_hardware_transfer_complete_cb+0x26c>
    81ae:	f013 0f02 	tst.w	r3, #2
    81b2:	4b5a      	ldr	r3, [pc, #360]	; (831c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    81b4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    81b8:	bf14      	ite	ne
    81ba:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    81be:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_po16_revb_mux/4%2);
    81c2:	7863      	ldrb	r3, [r4, #1]
    81c4:	f013 0f04 	tst.w	r3, #4
    81c8:	4b54      	ldr	r3, [pc, #336]	; (831c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    81ca:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    81ce:	bf14      	ite	ne
    81d0:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    81d4:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    81d8:	2100      	movs	r1, #0
    81da:	2302      	movs	r3, #2
    81dc:	aa03      	add	r2, sp, #12
    81de:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    81e0:	2302      	movs	r3, #2
    81e2:	f10d 020e 	add.w	r2, sp, #14
    81e6:	2100      	movs	r1, #0
    81e8:	484e      	ldr	r0, [pc, #312]	; (8324 <grid_module_po16_revb_hardware_transfer_complete_cb+0x23c>)
    81ea:	47c0      	blx	r8
	uint32_t input_0 = adcresult_0*1.03;	
    81ec:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    81f0:	47d8      	blx	fp
    81f2:	a345      	add	r3, pc, #276	; (adr r3, 8308 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    81f4:	e9d3 2300 	ldrd	r2, r3, [r3]
    81f8:	47d0      	blx	sl
    81fa:	47c8      	blx	r9
	adcresult_0 = input_0;
    81fc:	f64f 78ff 	movw	r8, #65535	; 0xffff
    8200:	4540      	cmp	r0, r8
    8202:	bf28      	it	cs
    8204:	4640      	movcs	r0, r8
    8206:	f8ad 000c 	strh.w	r0, [sp, #12]
	uint32_t input_1 = adcresult_1*1.03;	
    820a:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    820e:	47d8      	blx	fp
    8210:	a33d      	add	r3, pc, #244	; (adr r3, 8308 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    8212:	e9d3 2300 	ldrd	r2, r3, [r3]
    8216:	47d0      	blx	sl
    8218:	47c8      	blx	r9
	adcresult_1 = input_1;
    821a:	4540      	cmp	r0, r8
    821c:	bf28      	it	cs
    821e:	4640      	movcs	r0, r8
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    8220:	4b41      	ldr	r3, [pc, #260]	; (8328 <grid_module_po16_revb_hardware_transfer_complete_cb+0x240>)
	adcresult_1 = input_1;
    8222:	f8ad 000e 	strh.w	r0, [sp, #14]
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    8226:	4798      	blx	r3
    8228:	2808      	cmp	r0, #8
    822a:	d109      	bne.n	8240 <grid_module_po16_revb_hardware_transfer_complete_cb+0x158>
		adcresult_0	= 65535 - adcresult_0;
    822c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    8230:	43db      	mvns	r3, r3
    8232:	f8ad 300c 	strh.w	r3, [sp, #12]
		adcresult_1 = 65535 - adcresult_1;
    8236:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    823a:	43db      	mvns	r3, r3
    823c:	f8ad 300e 	strh.w	r3, [sp, #14]
	grid_ain_add_sample(adc_index_0, adcresult_0);
    8240:	f8bd 100c 	ldrh.w	r1, [sp, #12]
    8244:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8358 <grid_module_po16_revb_hardware_transfer_complete_cb+0x270>
    8248:	4638      	mov	r0, r7
    824a:	47c0      	blx	r8
	grid_ain_add_sample(adc_index_1, adcresult_1);
    824c:	4630      	mov	r0, r6
    824e:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    8252:	47c0      	blx	r8
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8254:	4b35      	ldr	r3, [pc, #212]	; (832c <grid_module_po16_revb_hardware_transfer_complete_cb+0x244>)
	result_index[0] = adc_index_0;
    8256:	f88d 7008 	strb.w	r7, [sp, #8]
	result_index[1] = adc_index_1;
    825a:	f88d 6009 	strb.w	r6, [sp, #9]
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    825e:	f103 0710 	add.w	r7, r3, #16
    8262:	ae04      	add	r6, sp, #16
    8264:	6818      	ldr	r0, [r3, #0]
    8266:	6859      	ldr	r1, [r3, #4]
    8268:	4632      	mov	r2, r6
    826a:	c203      	stmia	r2!, {r0, r1}
    826c:	3308      	adds	r3, #8
    826e:	42bb      	cmp	r3, r7
    8270:	4616      	mov	r6, r2
    8272:	d1f7      	bne.n	8264 <grid_module_po16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8274:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 8334 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
    8278:	f10d 0a08 	add.w	sl, sp, #8
	for (uint8_t i=0; i<2; i++)
    827c:	f04f 0900 	mov.w	r9, #0
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8280:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8284:	7bea      	ldrb	r2, [r5, #15]
		uint8_t res_index = result_index[i];
    8286:	f81a 6b01 	ldrb.w	r6, [sl], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    828a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		if (grid_ain_get_changed(res_index)){
    828e:	4630      	mov	r0, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8290:	68df      	ldr	r7, [r3, #12]
		if (grid_ain_get_changed(res_index)){
    8292:	4b27      	ldr	r3, [pc, #156]	; (8330 <grid_module_po16_revb_hardware_transfer_complete_cb+0x248>)
    8294:	4798      	blx	r3
    8296:	b350      	cbz	r0, 82ee <grid_module_po16_revb_hardware_transfer_complete_cb+0x206>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8298:	2264      	movs	r2, #100	; 0x64
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    829a:	a908      	add	r1, sp, #32
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    829c:	fb16 f202 	smulbb	r2, r6, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    82a0:	4431      	add	r1, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    82a2:	18bb      	adds	r3, r7, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    82a4:	f811 1c10 	ldrb.w	r1, [r1, #-16]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    82a8:	60de      	str	r6, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    82aa:	6119      	str	r1, [r3, #16]
    82ac:	2700      	movs	r7, #0
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    82ae:	4b21      	ldr	r3, [pc, #132]	; (8334 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>)
    82b0:	9201      	str	r2, [sp, #4]
    82b2:	685b      	ldr	r3, [r3, #4]
    82b4:	443b      	add	r3, r7
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82b6:	2107      	movs	r1, #7
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    82b8:	68db      	ldr	r3, [r3, #12]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82ba:	4630      	mov	r0, r6
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    82bc:	eb03 0b02 	add.w	fp, r3, r2
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82c0:	4b1d      	ldr	r3, [pc, #116]	; (8338 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
    82c2:	4798      	blx	r3
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    82c4:	4b1c      	ldr	r3, [pc, #112]	; (8338 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82c6:	f8cb 0014 	str.w	r0, [fp, #20]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    82ca:	2107      	movs	r1, #7
    82cc:	4630      	mov	r0, r6
    82ce:	4798      	blx	r3
    82d0:	3710      	adds	r7, #16
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    82d2:	2300      	movs	r3, #0
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    82d4:	2f40      	cmp	r7, #64	; 0x40
    82d6:	9a01      	ldr	r2, [sp, #4]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    82d8:	f8cb 0018 	str.w	r0, [fp, #24]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    82dc:	f8cb 301c 	str.w	r3, [fp, #28]
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    82e0:	d1e5      	bne.n	82ae <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c6>
			grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);		
    82e2:	4632      	mov	r2, r6
    82e4:	7be9      	ldrb	r1, [r5, #15]
    82e6:	4e15      	ldr	r6, [pc, #84]	; (833c <grid_module_po16_revb_hardware_transfer_complete_cb+0x254>)
    82e8:	2301      	movs	r3, #1
    82ea:	4640      	mov	r0, r8
    82ec:	47b0      	blx	r6
	for (uint8_t i=0; i<2; i++)
    82ee:	f1b9 0f00 	cmp.w	r9, #0
    82f2:	d004      	beq.n	82fe <grid_module_po16_revb_hardware_transfer_complete_cb+0x216>
	grid_module_po16_revb_hardware_transfer_complete = 0;
    82f4:	2300      	movs	r3, #0
    82f6:	7023      	strb	r3, [r4, #0]
	grid_module_po16_revb_hardware_start_transfer();
    82f8:	4b11      	ldr	r3, [pc, #68]	; (8340 <grid_module_po16_revb_hardware_transfer_complete_cb+0x258>)
    82fa:	4798      	blx	r3
    82fc:	e6ff      	b.n	80fe <grid_module_po16_revb_hardware_transfer_complete_cb+0x16>
    82fe:	f04f 0901 	mov.w	r9, #1
    8302:	e7bd      	b.n	8280 <grid_module_po16_revb_hardware_transfer_complete_cb+0x198>
    8304:	f3af 8000 	nop.w
    8308:	47ae147b 	.word	0x47ae147b
    830c:	3ff07ae1 	.word	0x3ff07ae1
    8310:	200007fd 	.word	0x200007fd
    8314:	2000f008 	.word	0x2000f008
    8318:	20000339 	.word	0x20000339
    831c:	41008000 	.word	0x41008000
    8320:	2001cd84 	.word	0x2001cd84
    8324:	2001cf58 	.word	0x2001cf58
    8328:	000098ed 	.word	0x000098ed
    832c:	00016cec 	.word	0x00016cec
    8330:	000046f9 	.word	0x000046f9
    8334:	2000effc 	.word	0x2000effc
    8338:	00004709 	.word	0x00004709
    833c:	0000a191 	.word	0x0000a191
    8340:	000080c9 	.word	0x000080c9
    8344:	0000a4e5 	.word	0x0000a4e5
    8348:	0000e589 	.word	0x0000e589
    834c:	00013d95 	.word	0x00013d95
    8350:	00013e69 	.word	0x00013e69
    8354:	0001428d 	.word	0x0001428d
    8358:	00004631 	.word	0x00004631

0000835c <grid_module_po16_revb_hardware_init>:

void grid_module_po16_revb_hardware_init(void){
    835c:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    835e:	4c0b      	ldr	r4, [pc, #44]	; (838c <grid_module_po16_revb_hardware_init+0x30>)
    8360:	4e0b      	ldr	r6, [pc, #44]	; (8390 <grid_module_po16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8362:	4d0c      	ldr	r5, [pc, #48]	; (8394 <grid_module_po16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8364:	4b0c      	ldr	r3, [pc, #48]	; (8398 <grid_module_po16_revb_hardware_init+0x3c>)
    8366:	2200      	movs	r2, #0
    8368:	4611      	mov	r1, r2
    836a:	4620      	mov	r0, r4
    836c:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    836e:	2200      	movs	r2, #0
    8370:	4b09      	ldr	r3, [pc, #36]	; (8398 <grid_module_po16_revb_hardware_init+0x3c>)
    8372:	4611      	mov	r1, r2
    8374:	4628      	mov	r0, r5
    8376:	47b0      	blx	r6
		
	adc_async_enable_channel(&ADC_0, 0);
    8378:	4620      	mov	r0, r4
    837a:	4c08      	ldr	r4, [pc, #32]	; (839c <grid_module_po16_revb_hardware_init+0x40>)
    837c:	2100      	movs	r1, #0
    837e:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8380:	4628      	mov	r0, r5
    8382:	4623      	mov	r3, r4
    8384:	2100      	movs	r1, #0

}
    8386:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    838a:	4718      	bx	r3
    838c:	2001cd84 	.word	0x2001cd84
    8390:	0000e511 	.word	0x0000e511
    8394:	2001cf58 	.word	0x2001cf58
    8398:	000080e9 	.word	0x000080e9
    839c:	0000e4d1 	.word	0x0000e4d1

000083a0 <grid_module_po16_revb_init>:




void grid_module_po16_revb_init(){
    83a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    83a4:	220e      	movs	r2, #14
    83a6:	4c15      	ldr	r4, [pc, #84]	; (83fc <grid_module_po16_revb_init+0x5c>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    83a8:	4e15      	ldr	r6, [pc, #84]	; (8400 <grid_module_po16_revb_init+0x60>)
    83aa:	4f16      	ldr	r7, [pc, #88]	; (8404 <grid_module_po16_revb_init+0x64>)
		
		for(uint8_t j=0; j<16; j++){
			
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    83ac:	f8df 806c 	ldr.w	r8, [pc, #108]	; 841c <grid_module_po16_revb_init+0x7c>
	grid_ain_init(16, 5, 14, 7);
    83b0:	2307      	movs	r3, #7
    83b2:	2105      	movs	r1, #5
    83b4:	2010      	movs	r0, #16
    83b6:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 16);
    83b8:	4b13      	ldr	r3, [pc, #76]	; (8408 <grid_module_po16_revb_init+0x68>)
    83ba:	4814      	ldr	r0, [pc, #80]	; (840c <grid_module_po16_revb_init+0x6c>)
    83bc:	2110      	movs	r1, #16
    83be:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    83c0:	480f      	ldr	r0, [pc, #60]	; (8400 <grid_module_po16_revb_init+0x60>)
    83c2:	4b13      	ldr	r3, [pc, #76]	; (8410 <grid_module_po16_revb_init+0x70>)
    83c4:	2104      	movs	r1, #4
    83c6:	4798      	blx	r3
    83c8:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    83ca:	2210      	movs	r2, #16
    83cc:	b2e1      	uxtb	r1, r4
    83ce:	4630      	mov	r0, r6
    83d0:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    83d2:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    83d6:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    83d8:	6870      	ldr	r0, [r6, #4]
    83da:	b2e9      	uxtb	r1, r5
    83dc:	2201      	movs	r2, #1
    83de:	4448      	add	r0, r9
    83e0:	3501      	adds	r5, #1
    83e2:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    83e4:	2d10      	cmp	r5, #16
    83e6:	d1f7      	bne.n	83d8 <grid_module_po16_revb_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
    83e8:	3401      	adds	r4, #1
    83ea:	2c04      	cmp	r4, #4
    83ec:	d1ed      	bne.n	83ca <grid_module_po16_revb_init+0x2a>

		}
	}
	
	grid_module_po16_revb_hardware_init();
    83ee:	4b09      	ldr	r3, [pc, #36]	; (8414 <grid_module_po16_revb_init+0x74>)
    83f0:	4798      	blx	r3
	grid_module_po16_revb_hardware_start_transfer();
	
    83f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_po16_revb_hardware_start_transfer();
    83f6:	4b08      	ldr	r3, [pc, #32]	; (8418 <grid_module_po16_revb_init+0x78>)
    83f8:	4718      	bx	r3
    83fa:	bf00      	nop
    83fc:	000045ed 	.word	0x000045ed
    8400:	2000effc 	.word	0x2000effc
    8404:	00009aa5 	.word	0x00009aa5
    8408:	00006f19 	.word	0x00006f19
    840c:	2001c838 	.word	0x2001c838
    8410:	00009a71 	.word	0x00009a71
    8414:	0000835d 	.word	0x0000835d
    8418:	000080c9 	.word	0x000080c9
    841c:	0000a3d1 	.word	0x0000a3d1

00008420 <grid_msg_header_set_len>:

#include "grid_msg.h"


// ======================= GRID MSG LEN ======================//
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    8420:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8422:	2200      	movs	r2, #0
    8424:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    8428:	f10d 020f 	add.w	r2, sp, #15
    842c:	9200      	str	r2, [sp, #0]
    842e:	2202      	movs	r2, #2
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    8430:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    8432:	4c02      	ldr	r4, [pc, #8]	; (843c <grid_msg_header_set_len+0x1c>)
    8434:	4611      	mov	r1, r2
    8436:	47a0      	blx	r4
	
}
    8438:	b004      	add	sp, #16
    843a:	bd10      	pop	{r4, pc}
    843c:	00009a2d 	.word	0x00009a2d

00008440 <grid_msg_header_set_id>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, &error);
}

// ======================= GRID MSG ID ======================//
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    8440:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8442:	2200      	movs	r2, #0
    8444:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    8448:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    844c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    844e:	9200      	str	r2, [sp, #0]
    8450:	4c02      	ldr	r4, [pc, #8]	; (845c <grid_msg_header_set_id+0x1c>)
    8452:	2202      	movs	r2, #2
    8454:	2104      	movs	r1, #4
    8456:	47a0      	blx	r4
	
}
    8458:	b004      	add	sp, #16
    845a:	bd10      	pop	{r4, pc}
    845c:	00009a2d 	.word	0x00009a2d

00008460 <grid_msg_header_set_dx>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
}

// ======================= GRID MSG DX ======================//
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8460:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8462:	2200      	movs	r2, #0
    8464:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8468:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    846c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    846e:	9200      	str	r2, [sp, #0]
    8470:	4c02      	ldr	r4, [pc, #8]	; (847c <grid_msg_header_set_dx+0x1c>)
    8472:	2202      	movs	r2, #2
    8474:	2106      	movs	r1, #6
    8476:	47a0      	blx	r4
	
}
    8478:	b004      	add	sp, #16
    847a:	bd10      	pop	{r4, pc}
    847c:	00009a2d 	.word	0x00009a2d

00008480 <grid_msg_header_get_dx>:


uint8_t grid_msg_header_get_dx(struct grid_msg* msg){
    8480:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    8482:	2300      	movs	r3, #0
    8484:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    8488:	4c04      	ldr	r4, [pc, #16]	; (849c <grid_msg_header_get_dx+0x1c>)
    848a:	f10d 0307 	add.w	r3, sp, #7
    848e:	2202      	movs	r2, #2
    8490:	2106      	movs	r1, #6
    8492:	47a0      	blx	r4
}
    8494:	b2c0      	uxtb	r0, r0
    8496:	b002      	add	sp, #8
    8498:	bd10      	pop	{r4, pc}
    849a:	bf00      	nop
    849c:	00009a15 	.word	0x00009a15

000084a0 <grid_msg_header_set_dy>:

// ======================= GRID MSG DY ======================//
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    84a0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    84a2:	2200      	movs	r2, #0
    84a4:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    84a8:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    84ac:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    84ae:	9200      	str	r2, [sp, #0]
    84b0:	4c02      	ldr	r4, [pc, #8]	; (84bc <grid_msg_header_set_dy+0x1c>)
    84b2:	2202      	movs	r2, #2
    84b4:	2108      	movs	r1, #8
    84b6:	47a0      	blx	r4
	
}
    84b8:	b004      	add	sp, #16
    84ba:	bd10      	pop	{r4, pc}
    84bc:	00009a2d 	.word	0x00009a2d

000084c0 <grid_msg_header_get_dy>:


uint8_t grid_msg_header_get_dy(struct grid_msg* msg){
    84c0:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    84c2:	2300      	movs	r3, #0
    84c4:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    84c8:	4c04      	ldr	r4, [pc, #16]	; (84dc <grid_msg_header_get_dy+0x1c>)
    84ca:	f10d 0307 	add.w	r3, sp, #7
    84ce:	2202      	movs	r2, #2
    84d0:	2108      	movs	r1, #8
    84d2:	47a0      	blx	r4
}
    84d4:	b2c0      	uxtb	r0, r0
    84d6:	b002      	add	sp, #8
    84d8:	bd10      	pop	{r4, pc}
    84da:	bf00      	nop
    84dc:	00009a15 	.word	0x00009a15

000084e0 <grid_msg_header_set_rot>:

// ======================= GRID MSG ROT ======================//
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    84e0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    84e2:	2200      	movs	r2, #0
    84e4:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    84e8:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    84ec:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    84ee:	9200      	str	r2, [sp, #0]
    84f0:	4c02      	ldr	r4, [pc, #8]	; (84fc <grid_msg_header_set_rot+0x1c>)
    84f2:	2202      	movs	r2, #2
    84f4:	210c      	movs	r1, #12
    84f6:	47a0      	blx	r4
	
}
    84f8:	b004      	add	sp, #16
    84fa:	bd10      	pop	{r4, pc}
    84fc:	00009a2d 	.word	0x00009a2d

00008500 <grid_msg_header_set_age>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
}

// ======================= GRID MSG AGE ======================//
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    8500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8502:	2200      	movs	r2, #0
    8504:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    8508:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    850c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    850e:	9200      	str	r2, [sp, #0]
    8510:	4c02      	ldr	r4, [pc, #8]	; (851c <grid_msg_header_set_age+0x1c>)
    8512:	2202      	movs	r2, #2
    8514:	210a      	movs	r1, #10
    8516:	47a0      	blx	r4
	
}
    8518:	b004      	add	sp, #16
    851a:	bd10      	pop	{r4, pc}
    851c:	00009a2d 	.word	0x00009a2d

00008520 <grid_msg_packet_get_length>:
}

// ======================= MSG GET PACKET LENGTH ======================//
uint32_t grid_msg_packet_get_length(struct grid_msg* msg){
	
	return (msg->header_length + msg->body_length + msg->footer_length);
    8520:	e9d0 3264 	ldrd	r3, r2, [r0, #400]	; 0x190
    8524:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    8528:	4413      	add	r3, r2
}
    852a:	4418      	add	r0, r3
    852c:	4770      	bx	lr

0000852e <grid_msg_body_get_length>:

// ======================= MSG GET BODY LENGTH ======================//
uint32_t grid_msg_body_get_length(struct grid_msg* msg){
	
	return (msg->body_length);
}
    852e:	f8d0 0194 	ldr.w	r0, [r0, #404]	; 0x194
    8532:	4770      	bx	lr

00008534 <grid_msg_body_append_text>:
	
	return (msg->footer_length);
}


void	grid_msg_body_append_text(struct grid_msg* msg, uint8_t* str, uint32_t len){
    8534:	b570      	push	{r4, r5, r6, lr}
    8536:	f8d0 5194 	ldr.w	r5, [r0, #404]	; 0x194

	
	for(uint32_t i=0; i<len; i++){
    853a:	2300      	movs	r3, #0
    853c:	4293      	cmp	r3, r2
    853e:	d103      	bne.n	8548 <grid_msg_body_append_text+0x14>
		
		msg->body[msg->body_length + i] = str[i];
	}
	
	msg->body_length += len;
    8540:	442b      	add	r3, r5
    8542:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    8546:	bd70      	pop	{r4, r5, r6, pc}
		msg->body[msg->body_length + i] = str[i];
    8548:	18c4      	adds	r4, r0, r3
    854a:	442c      	add	r4, r5
    854c:	5cce      	ldrb	r6, [r1, r3]
    854e:	7526      	strb	r6, [r4, #20]
	for(uint32_t i=0; i<len; i++){
    8550:	3301      	adds	r3, #1
    8552:	e7f3      	b.n	853c <grid_msg_body_append_text+0x8>

00008554 <grid_msg_body_append_text_escaped>:

void	grid_msg_body_append_text_escaped(struct grid_msg* msg, uint8_t* str, uint32_t len){
    8554:	b5f0      	push	{r4, r5, r6, r7, lr}
    8556:	f8d0 6194 	ldr.w	r6, [r0, #404]	; 0x194
	
	for(uint32_t i=0; i<len; i++){
    855a:	2400      	movs	r4, #0
		
		if (str[i] == GRID_CONST_STX){
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
		}
		else if (str[i] == GRID_CONST_ETX){
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    855c:	2783      	movs	r7, #131	; 0x83
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    855e:	f04f 0c82 	mov.w	ip, #130	; 0x82
	for(uint32_t i=0; i<len; i++){
    8562:	4294      	cmp	r4, r2
    8564:	eb04 0306 	add.w	r3, r4, r6
    8568:	d102      	bne.n	8570 <grid_msg_body_append_text_escaped+0x1c>
			msg->body[msg->body_length + i] = str[i];
		}
		
	}
	
	msg->body_length += len;
    856a:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    856e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (str[i] == GRID_CONST_STX){
    8570:	5d0d      	ldrb	r5, [r1, r4]
    8572:	2d02      	cmp	r5, #2
    8574:	4403      	add	r3, r0
    8576:	d103      	bne.n	8580 <grid_msg_body_append_text_escaped+0x2c>
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8578:	f883 c014 	strb.w	ip, [r3, #20]
	for(uint32_t i=0; i<len; i++){
    857c:	3401      	adds	r4, #1
    857e:	e7f0      	b.n	8562 <grid_msg_body_append_text_escaped+0xe>
		else if (str[i] == GRID_CONST_ETX){
    8580:	2d03      	cmp	r5, #3
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    8582:	bf0c      	ite	eq
    8584:	751f      	strbeq	r7, [r3, #20]
			msg->body[msg->body_length + i] = str[i];
    8586:	751d      	strbne	r5, [r3, #20]
    8588:	e7f8      	b.n	857c <grid_msg_body_append_text_escaped+0x28>
	...

0000858c <grid_msg_text_get_parameter>:


uint32_t grid_msg_text_get_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length){
    858c:	b420      	push	{r5}
	
	uint8_t error;
	
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    858e:	f101 0514 	add.w	r5, r1, #20
    8592:	4415      	add	r5, r2
    8594:	4619      	mov	r1, r3
    8596:	4428      	add	r0, r5
    8598:	4b02      	ldr	r3, [pc, #8]	; (85a4 <grid_msg_text_get_parameter+0x18>)
	
}
    859a:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    859e:	2200      	movs	r2, #0
    85a0:	4718      	bx	r3
    85a2:	bf00      	nop
    85a4:	00009861 	.word	0x00009861

000085a8 <grid_msg_text_set_parameter>:

void grid_msg_text_set_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length, uint32_t value){
    85a8:	b420      	push	{r5}
	
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    85aa:	f101 0514 	add.w	r5, r1, #20
    85ae:	4415      	add	r5, r2
    85b0:	4619      	mov	r1, r3
    85b2:	9a01      	ldr	r2, [sp, #4]
    85b4:	4b02      	ldr	r3, [pc, #8]	; (85c0 <grid_msg_text_set_parameter+0x18>)
    85b6:	4428      	add	r0, r5
	
}
    85b8:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    85bc:	4718      	bx	r3
    85be:	bf00      	nop
    85c0:	00009889 	.word	0x00009889

000085c4 <grid_msg_init>:


// ======================= GRID MSG INIT ======================//
void	grid_msg_init(struct grid_msg* msg){
	
	msg->header_length = 0;
    85c4:	2300      	movs	r3, #0
	msg->body_length = 0;
    85c6:	e9c0 3364 	strd	r3, r3, [r0, #400]	; 0x190
	msg->footer_length = 0;
    85ca:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
	
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    85ce:	1e42      	subs	r2, r0, #1
    85d0:	f100 0113 	add.w	r1, r0, #19
	{
		msg->header[i] = 0;
    85d4:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    85d8:	4291      	cmp	r1, r2
    85da:	d1fb      	bne.n	85d4 <grid_msg_init+0x10>
    85dc:	f100 0214 	add.w	r2, r0, #20
    85e0:	f200 118b 	addw	r1, r0, #395	; 0x18b
	}
	
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
	{
		msg->body[i] = 0;
    85e4:	2300      	movs	r3, #0
    85e6:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
    85ea:	428a      	cmp	r2, r1
    85ec:	d1fb      	bne.n	85e6 <grid_msg_init+0x22>
	}
	
	for (uint32_t i=0; i<GRID_MSG_FOOTER_maxlength; i++)
	{
		msg->footer[i] = 0;
    85ee:	f880 318b 	strb.w	r3, [r0, #395]	; 0x18b
    85f2:	f8c0 318c 	str.w	r3, [r0, #396]	; 0x18c
	}
	
		
}
    85f6:	4770      	bx	lr

000085f8 <grid_msg_init_header>:

// ======================= MSG INIT HEADER======================//

void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    85f8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    85fc:	461e      	mov	r6, r3
	
    
    uint8_t age = grid_sys_state.sessionid;
    85fe:	4b13      	ldr	r3, [pc, #76]	; (864c <grid_msg_init_header+0x54>)
    
	sprintf(msg->header, GRID_BRC_frame);
    8600:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8668 <grid_msg_init_header+0x70>
    uint8_t age = grid_sys_state.sessionid;
    8604:	795d      	ldrb	r5, [r3, #5]
	sprintf(msg->header, GRID_BRC_frame);
    8606:	2317      	movs	r3, #23
void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    8608:	4604      	mov	r4, r0
    860a:	4688      	mov	r8, r1
    860c:	4617      	mov	r7, r2
	sprintf(msg->header, GRID_BRC_frame);
    860e:	4910      	ldr	r1, [pc, #64]	; (8650 <grid_msg_init_header+0x58>)
    8610:	9300      	str	r3, [sp, #0]
    8612:	2201      	movs	r2, #1
    8614:	230f      	movs	r3, #15
    8616:	47c8      	blx	r9
	msg->header_length = strlen(msg->header);
    8618:	4b0e      	ldr	r3, [pc, #56]	; (8654 <grid_msg_init_header+0x5c>)
    861a:	4620      	mov	r0, r4
    861c:	4798      	blx	r3
	
	grid_msg_header_set_dx(msg, dx);
    861e:	4641      	mov	r1, r8
	msg->header_length = strlen(msg->header);
    8620:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	grid_msg_header_set_dx(msg, dx);
    8624:	4b0c      	ldr	r3, [pc, #48]	; (8658 <grid_msg_init_header+0x60>)
    8626:	4620      	mov	r0, r4
    8628:	4798      	blx	r3
	grid_msg_header_set_dy(msg, dy);
    862a:	4639      	mov	r1, r7
    862c:	4620      	mov	r0, r4
    862e:	4b0b      	ldr	r3, [pc, #44]	; (865c <grid_msg_init_header+0x64>)
    8630:	4798      	blx	r3
	grid_msg_header_set_rot(msg, rot);
    8632:	4631      	mov	r1, r6
    8634:	4620      	mov	r0, r4
    8636:	4b0a      	ldr	r3, [pc, #40]	; (8660 <grid_msg_init_header+0x68>)
    8638:	4798      	blx	r3
    uint8_t age = grid_sys_state.sessionid;
    863a:	b2ed      	uxtb	r5, r5
	grid_msg_header_set_age(msg, age);
    863c:	4b09      	ldr	r3, [pc, #36]	; (8664 <grid_msg_init_header+0x6c>)
    863e:	4629      	mov	r1, r5
    8640:	4620      	mov	r0, r4
	
	
}
    8642:	b003      	add	sp, #12
    8644:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	grid_msg_header_set_age(msg, age);
    8648:	4718      	bx	r3
    864a:	bf00      	nop
    864c:	2000f008 	.word	0x2000f008
    8650:	00016cfc 	.word	0x00016cfc
    8654:	00014f81 	.word	0x00014f81
    8658:	00008461 	.word	0x00008461
    865c:	000084a1 	.word	0x000084a1
    8660:	000084e1 	.word	0x000084e1
    8664:	00008501 	.word	0x00008501
    8668:	00014ac5 	.word	0x00014ac5

0000866c <grid_msg_packet_receive_char>:

// ======================= MSG RECEIVE CHAR ======================//
void	grid_msg_packet_receive_char(struct grid_msg* msg, uint8_t nextchar){
	
	if (msg->body_length == 0){
    866c:	f8d0 2194 	ldr.w	r2, [r0, #404]	; 0x194
    8670:	b96a      	cbnz	r2, 868e <grid_msg_packet_receive_char+0x22>
		
		if (nextchar != GRID_CONST_EOB){
    8672:	2917      	cmp	r1, #23
			msg->header[msg->header_length] = nextchar;
    8674:	bf15      	itete	ne
    8676:	f8d0 3190 	ldrne.w	r3, [r0, #400]	; 0x190
			msg->header_length++;
		}
		else{
			msg->body[msg->body_length] = nextchar;
    867a:	7501      	strbeq	r1, [r0, #20]
			msg->header[msg->header_length] = nextchar;
    867c:	54c1      	strbne	r1, [r0, r3]
			msg->body_length++;
    867e:	2301      	moveq	r3, #1
			msg->header_length++;
    8680:	bf1a      	itte	ne
    8682:	3301      	addne	r3, #1
    8684:	f8c0 3190 	strne.w	r3, [r0, #400]	; 0x190
			msg->body_length++;
    8688:	f8c0 3194 	streq.w	r3, [r0, #404]	; 0x194
    868c:	4770      	bx	lr
			
		}
		
	}
	else if(msg->footer_length == 0){
    868e:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
    8692:	b96b      	cbnz	r3, 86b0 <grid_msg_packet_receive_char+0x44>
		
		if (nextchar != GRID_CONST_EOT){
    8694:	2904      	cmp	r1, #4
    8696:	d005      	beq.n	86a4 <grid_msg_packet_receive_char+0x38>
			msg->body[msg->body_length] = nextchar;
    8698:	1883      	adds	r3, r0, r2
			msg->body_length++;
    869a:	3201      	adds	r2, #1
			msg->body[msg->body_length] = nextchar;
    869c:	7519      	strb	r1, [r3, #20]
			msg->body_length++;
    869e:	f8c0 2194 	str.w	r2, [r0, #404]	; 0x194
    86a2:	4770      	bx	lr
		}
		else{
			msg->footer[msg->footer_length] = nextchar;
    86a4:	f880 118b 	strb.w	r1, [r0, #395]	; 0x18b
			msg->footer_length++;
    86a8:	2301      	movs	r3, #1
		
	}
	else{
		
		msg->footer[msg->footer_length] = nextchar;
		msg->footer_length++;
    86aa:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
		
	}
	
}
    86ae:	4770      	bx	lr
		msg->footer[msg->footer_length] = nextchar;
    86b0:	18c2      	adds	r2, r0, r3
		msg->footer_length++;
    86b2:	3301      	adds	r3, #1
		msg->footer[msg->footer_length] = nextchar;
    86b4:	f882 118b 	strb.w	r1, [r2, #395]	; 0x18b
		msg->footer_length++;
    86b8:	e7f7      	b.n	86aa <grid_msg_packet_receive_char+0x3e>

000086ba <grid_msg_packet_send_char>:

// ======================= GRID MSG SEND CHAR ======================//

uint8_t	grid_msg_packet_send_char(struct grid_msg* msg, uint32_t charindex){
	
	if (charindex < msg->header_length){
    86ba:	f8d0 2190 	ldr.w	r2, [r0, #400]	; 0x190
    86be:	428a      	cmp	r2, r1
    86c0:	d901      	bls.n	86c6 <grid_msg_packet_send_char+0xc>
		
		return msg->header[charindex];
    86c2:	5c40      	ldrb	r0, [r0, r1]
    86c4:	4770      	bx	lr
	}
	else if (charindex < msg->body_length + msg->header_length){
    86c6:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
    86ca:	4413      	add	r3, r2
    86cc:	428b      	cmp	r3, r1
    86ce:	d903      	bls.n	86d8 <grid_msg_packet_send_char+0x1e>
	
		return msg->body[charindex - msg->header_length];
    86d0:	1a89      	subs	r1, r1, r2
    86d2:	4408      	add	r0, r1
    86d4:	7d00      	ldrb	r0, [r0, #20]
    86d6:	4770      	bx	lr
	}
	else if (charindex < msg->footer_length + msg->body_length + msg->header_length){
    86d8:	f8d0 2198 	ldr.w	r2, [r0, #408]	; 0x198
    86dc:	441a      	add	r2, r3
    86de:	428a      	cmp	r2, r1
	
		return msg->footer[charindex - msg->header_length - msg->body_length];
    86e0:	bf83      	ittte	hi
    86e2:	1ac9      	subhi	r1, r1, r3
    86e4:	1840      	addhi	r0, r0, r1
    86e6:	f890 018b 	ldrbhi.w	r0, [r0, #395]	; 0x18b
	}
	else{
		// OVERRUN
		return -1;
    86ea:	20ff      	movls	r0, #255	; 0xff
	}
	
	
}
    86ec:	4770      	bx	lr
	...

000086f0 <grid_msg_packet_close>:



uint8_t	grid_msg_packet_close(struct grid_msg* msg){
    86f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    86f2:	4604      	mov	r4, r0
	
	
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    86f4:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    86f8:	492b      	ldr	r1, [pc, #172]	; (87a8 <grid_msg_packet_close+0xb8>)
    86fa:	4d2c      	ldr	r5, [pc, #176]	; (87ac <grid_msg_packet_close+0xbc>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    86fc:	4e2c      	ldr	r6, [pc, #176]	; (87b0 <grid_msg_packet_close+0xc0>)
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    86fe:	f200 108b 	addw	r0, r0, #395	; 0x18b
    8702:	2204      	movs	r2, #4
    8704:	4420      	add	r0, r4
    8706:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8708:	f8d4 7198 	ldr.w	r7, [r4, #408]	; 0x198
    870c:	f207 108b 	addw	r0, r7, #395	; 0x18b
    8710:	4420      	add	r0, r4
    8712:	47b0      	blx	r6
	
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8714:	e9d4 3164 	ldrd	r3, r1, [r4, #400]	; 0x190
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8718:	4438      	add	r0, r7
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    871a:	440b      	add	r3, r1
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    871c:	4f25      	ldr	r7, [pc, #148]	; (87b4 <grid_msg_packet_close+0xc4>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    871e:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8722:	1819      	adds	r1, r3, r0
    8724:	b2c9      	uxtb	r1, r1
    8726:	4b24      	ldr	r3, [pc, #144]	; (87b8 <grid_msg_packet_close+0xc8>)
    8728:	4620      	mov	r0, r4
    872a:	4798      	blx	r3
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    872c:	f897 10ad 	ldrb.w	r1, [r7, #173]	; 0xad
    8730:	4b22      	ldr	r3, [pc, #136]	; (87bc <grid_msg_packet_close+0xcc>)
    8732:	4620      	mov	r0, r4
    8734:	4798      	blx	r3
	
	grid_sys_state.next_broadcast_message_id++;
    8736:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
    873a:	3301      	adds	r3, #1
    873c:	b2db      	uxtb	r3, r3
    873e:	f887 30ad 	strb.w	r3, [r7, #173]	; 0xad
	
	
	uint8_t checksum = 0;
	
	for (uint32_t i=0; i<msg->header_length; i++){
    8742:	f8d4 3190 	ldr.w	r3, [r4, #400]	; 0x190
    8746:	4621      	mov	r1, r4
    8748:	4423      	add	r3, r4
	uint8_t checksum = 0;
    874a:	2200      	movs	r2, #0
	for (uint32_t i=0; i<msg->header_length; i++){
    874c:	4299      	cmp	r1, r3
    874e:	d11f      	bne.n	8790 <grid_msg_packet_close+0xa0>
    8750:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
    8754:	4423      	add	r3, r4
    8756:	f104 0114 	add.w	r1, r4, #20
    875a:	3314      	adds	r3, #20
		checksum ^= msg->header[i];
	}
		
	for (uint32_t i=0; i<msg->body_length; i++){
    875c:	4299      	cmp	r1, r3
    875e:	d11b      	bne.n	8798 <grid_msg_packet_close+0xa8>
		checksum ^= msg->body[i];
	}
		
	for (uint32_t i=0; i<msg->footer_length; i++){
    8760:	f8d4 0198 	ldr.w	r0, [r4, #408]	; 0x198
    8764:	1823      	adds	r3, r4, r0
    8766:	f204 118b 	addw	r1, r4, #395	; 0x18b
    876a:	f203 138b 	addw	r3, r3, #395	; 0x18b
    876e:	4299      	cmp	r1, r3
    8770:	d116      	bne.n	87a0 <grid_msg_packet_close+0xb0>
		checksum ^= msg->footer[i];
	}
	
	sprintf(&msg->footer[msg->footer_length], "%02x\n", checksum);
    8772:	f200 108b 	addw	r0, r0, #395	; 0x18b
    8776:	4912      	ldr	r1, [pc, #72]	; (87c0 <grid_msg_packet_close+0xd0>)
    8778:	4420      	add	r0, r4
    877a:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    877c:	f8d4 5198 	ldr.w	r5, [r4, #408]	; 0x198
    8780:	f205 108b 	addw	r0, r5, #395	; 0x18b
    8784:	4420      	add	r0, r4
    8786:	47b0      	blx	r6
    8788:	4428      	add	r0, r5
    878a:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	
	
}
    878e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		checksum ^= msg->header[i];
    8790:	f811 0b01 	ldrb.w	r0, [r1], #1
    8794:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->header_length; i++){
    8796:	e7d9      	b.n	874c <grid_msg_packet_close+0x5c>
		checksum ^= msg->body[i];
    8798:	f811 0b01 	ldrb.w	r0, [r1], #1
    879c:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->body_length; i++){
    879e:	e7dd      	b.n	875c <grid_msg_packet_close+0x6c>
		checksum ^= msg->footer[i];
    87a0:	f811 7b01 	ldrb.w	r7, [r1], #1
    87a4:	407a      	eors	r2, r7
	for (uint32_t i=0; i<msg->footer_length; i++){
    87a6:	e7e2      	b.n	876e <grid_msg_packet_close+0x7e>
    87a8:	00016a4f 	.word	0x00016a4f
    87ac:	00014ac5 	.word	0x00014ac5
    87b0:	00014f81 	.word	0x00014f81
    87b4:	2000f008 	.word	0x2000f008
    87b8:	00008421 	.word	0x00008421
    87bc:	00008441 	.word	0x00008441
    87c0:	000176c3 	.word	0x000176c3

000087c4 <grid_msg_packet_send_everywhere>:

uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    87c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	
	uint32_t message_length = grid_msg_packet_get_length(msg);
    87c8:	4b0f      	ldr	r3, [pc, #60]	; (8808 <grid_msg_packet_send_everywhere+0x44>)
uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    87ca:	4606      	mov	r6, r0
	uint32_t message_length = grid_msg_packet_get_length(msg);
    87cc:	4798      	blx	r3
	
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    87ce:	4b0f      	ldr	r3, [pc, #60]	; (880c <grid_msg_packet_send_everywhere+0x48>)
	uint32_t message_length = grid_msg_packet_get_length(msg);
    87d0:	4604      	mov	r4, r0
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    87d2:	b281      	uxth	r1, r0
    87d4:	480e      	ldr	r0, [pc, #56]	; (8810 <grid_msg_packet_send_everywhere+0x4c>)
    87d6:	4798      	blx	r3
    87d8:	b978      	cbnz	r0, 87fa <grid_msg_packet_send_everywhere+0x36>
		
		return 0;
	}
	
	
}
    87da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    87de:	4629      	mov	r1, r5
    87e0:	4630      	mov	r0, r6
    87e2:	47b8      	blx	r7
    87e4:	4601      	mov	r1, r0
    87e6:	4640      	mov	r0, r8
    87e8:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    87ea:	3501      	adds	r5, #1
    87ec:	42a5      	cmp	r5, r4
    87ee:	d1f6      	bne.n	87de <grid_msg_packet_send_everywhere+0x1a>
		grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    87f0:	4807      	ldr	r0, [pc, #28]	; (8810 <grid_msg_packet_send_everywhere+0x4c>)
    87f2:	4b08      	ldr	r3, [pc, #32]	; (8814 <grid_msg_packet_send_everywhere+0x50>)
    87f4:	4798      	blx	r3
		return 1;
    87f6:	2001      	movs	r0, #1
    87f8:	e7ef      	b.n	87da <grid_msg_packet_send_everywhere+0x16>
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    87fa:	4f07      	ldr	r7, [pc, #28]	; (8818 <grid_msg_packet_send_everywhere+0x54>)
    87fc:	f8df 8010 	ldr.w	r8, [pc, #16]	; 8810 <grid_msg_packet_send_everywhere+0x4c>
    8800:	f8df 9018 	ldr.w	r9, [pc, #24]	; 881c <grid_msg_packet_send_everywhere+0x58>
		for(uint32_t i = 0; i<message_length; i++){
    8804:	2500      	movs	r5, #0
    8806:	e7f1      	b.n	87ec <grid_msg_packet_send_everywhere+0x28>
    8808:	00008521 	.word	0x00008521
    880c:	00004839 	.word	0x00004839
    8810:	2000ebe4 	.word	0x2000ebe4
    8814:	00004895 	.word	0x00004895
    8818:	000086bb 	.word	0x000086bb
    881c:	00004875 	.word	0x00004875

00008820 <grid_nvm_ui_bulk_read_init>:
}


void grid_nvm_ui_bulk_read_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->read_bulk_page_index = 0;
    8820:	2300      	movs	r3, #0
    8822:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 1;
    8826:	2301      	movs	r3, #1
    8828:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
			
}
    882c:	4770      	bx	lr

0000882e <grid_nvm_ui_bulk_read_is_in_progress>:

uint8_t grid_nvm_ui_bulk_read_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->read_bulk_status;
	
}
    882e:	f890 0428 	ldrb.w	r0, [r0, #1064]	; 0x428
    8832:	4770      	bx	lr

00008834 <grid_nvm_ui_bulk_read_next>:

void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8834:	b5f0      	push	{r4, r5, r6, r7, lr}
    8836:	4604      	mov	r4, r0
    8838:	b0ed      	sub	sp, #436	; 0x1b4
	
	if (nvm->read_bulk_status == 1){
    883a:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
    883e:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8840:	4608      	mov	r0, r1
	if (nvm->read_bulk_status == 1){
    8842:	d12f      	bne.n	88a4 <grid_nvm_ui_bulk_read_next+0x70>
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8844:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8846:	f8d4 2424 	ldr.w	r2, [r4, #1060]	; 0x424
    884a:	23a0      	movs	r3, #160	; 0xa0
    884c:	fbb2 f3f3 	udiv	r3, r2, r3
    8850:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8854:	4299      	cmp	r1, r3
    8856:	d91c      	bls.n	8892 <grid_nvm_ui_bulk_read_next+0x5e>
			
			if (element < ui->bank_list[bank].element_list_length){
    8858:	6845      	ldr	r5, [r0, #4]
    885a:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    885e:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8860:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8862:	fbb2 f1f7 	udiv	r1, r2, r7
    8866:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    886a:	42b5      	cmp	r5, r6
    886c:	d911      	bls.n	8892 <grid_nvm_ui_bulk_read_next+0x5e>
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    886e:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8872:	68da      	ldr	r2, [r3, #12]
    8874:	2364      	movs	r3, #100	; 0x64
    8876:	fb06 2303 	mla	r3, r6, r3, r2
    887a:	b2ca      	uxtb	r2, r1
    887c:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8880:	4295      	cmp	r5, r2
    8882:	d906      	bls.n	8892 <grid_nvm_ui_bulk_read_next+0x5e>
					// Valid memory location
					
					int status = grid_ui_nvm_load_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);
    8884:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8886:	22bc      	movs	r2, #188	; 0xbc
    8888:	fb02 3201 	mla	r2, r2, r1, r3
    888c:	4b1f      	ldr	r3, [pc, #124]	; (890c <grid_nvm_ui_bulk_read_next+0xd8>)
    888e:	4621      	mov	r1, r4
    8890:	4798      	blx	r3
			}
	
		}
		
		
		if (nvm->read_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8892:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
    8896:	f240 227e 	movw	r2, #638	; 0x27e
    889a:	4293      	cmp	r3, r2
    889c:	d804      	bhi.n	88a8 <grid_nvm_ui_bulk_read_next+0x74>
			
			nvm->read_bulk_page_index++;
    889e:	3301      	adds	r3, #1
    88a0:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
	}
	
	
	
	
}
    88a4:	b06d      	add	sp, #436	; 0x1b4
    88a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			nvm->read_bulk_page_index = 0;
    88a8:	2500      	movs	r5, #0
    88aa:	f8c4 5424 	str.w	r5, [r4, #1060]	; 0x424
			nvm->read_bulk_status = 0;
    88ae:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
			grid_msg_init(&response);
    88b2:	a805      	add	r0, sp, #20
    88b4:	4b16      	ldr	r3, [pc, #88]	; (8910 <grid_nvm_ui_bulk_read_next+0xdc>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    88b6:	4c17      	ldr	r4, [pc, #92]	; (8914 <grid_nvm_ui_bulk_read_next+0xe0>)
			grid_msg_init(&response);
    88b8:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    88ba:	227f      	movs	r2, #127	; 0x7f
    88bc:	462b      	mov	r3, r5
    88be:	4611      	mov	r1, r2
    88c0:	a805      	add	r0, sp, #20
    88c2:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    88c4:	2303      	movs	r3, #3
    88c6:	4914      	ldr	r1, [pc, #80]	; (8918 <grid_nvm_ui_bulk_read_next+0xe4>)
    88c8:	9300      	str	r3, [sp, #0]
    88ca:	2202      	movs	r2, #2
    88cc:	4c13      	ldr	r4, [pc, #76]	; (891c <grid_nvm_ui_bulk_read_next+0xe8>)
			uint8_t response_payload[10] = {0};
    88ce:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    88d2:	2371      	movs	r3, #113	; 0x71
    88d4:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    88d6:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    88da:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    88dc:	4b10      	ldr	r3, [pc, #64]	; (8920 <grid_nvm_ui_bulk_read_next+0xec>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    88de:	4c11      	ldr	r4, [pc, #68]	; (8924 <grid_nvm_ui_bulk_read_next+0xf0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    88e0:	a802      	add	r0, sp, #8
    88e2:	4798      	blx	r3
    88e4:	a902      	add	r1, sp, #8
    88e6:	4602      	mov	r2, r0
    88e8:	4b0f      	ldr	r3, [pc, #60]	; (8928 <grid_nvm_ui_bulk_read_next+0xf4>)
    88ea:	a805      	add	r0, sp, #20
    88ec:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    88ee:	230a      	movs	r3, #10
    88f0:	9300      	str	r3, [sp, #0]
    88f2:	2204      	movs	r2, #4
    88f4:	4629      	mov	r1, r5
    88f6:	a805      	add	r0, sp, #20
    88f8:	2301      	movs	r3, #1
    88fa:	47a0      	blx	r4
			grid_msg_packet_close(&response);
    88fc:	4b0b      	ldr	r3, [pc, #44]	; (892c <grid_nvm_ui_bulk_read_next+0xf8>)
    88fe:	a805      	add	r0, sp, #20
    8900:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8902:	4b0b      	ldr	r3, [pc, #44]	; (8930 <grid_nvm_ui_bulk_read_next+0xfc>)
    8904:	a805      	add	r0, sp, #20
    8906:	4798      	blx	r3
}
    8908:	e7cc      	b.n	88a4 <grid_nvm_ui_bulk_read_next+0x70>
    890a:	bf00      	nop
    890c:	00009e95 	.word	0x00009e95
    8910:	000085c5 	.word	0x000085c5
    8914:	000085f9 	.word	0x000085f9
    8918:	00016d0f 	.word	0x00016d0f
    891c:	00014ac5 	.word	0x00014ac5
    8920:	00014f81 	.word	0x00014f81
    8924:	000085a9 	.word	0x000085a9
    8928:	00008535 	.word	0x00008535
    892c:	000086f1 	.word	0x000086f1
    8930:	000087c5 	.word	0x000087c5

00008934 <grid_nvm_ui_bulk_store_init>:


void grid_nvm_ui_bulk_store_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->store_bulk_page_index = 0;
    8934:	2300      	movs	r3, #0
    8936:	f8c0 3434 	str.w	r3, [r0, #1076]	; 0x434
	nvm->store_bulk_status = 1;
    893a:	2301      	movs	r3, #1
    893c:	f880 3438 	strb.w	r3, [r0, #1080]	; 0x438
	
}
    8940:	4770      	bx	lr

00008942 <grid_nvm_ui_bulk_store_is_in_progress>:

uint8_t grid_nvm_ui_bulk_store_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->store_bulk_status;
	
}
    8942:	f890 0438 	ldrb.w	r0, [r0, #1080]	; 0x438
    8946:	4770      	bx	lr

00008948 <grid_nvm_ui_bulk_store_next>:

// DO THIS!!
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8948:	b5f0      	push	{r4, r5, r6, r7, lr}
     
    // START: NEW
    
    
	if (nvm->store_bulk_status == 1){
    894a:	f890 3438 	ldrb.w	r3, [r0, #1080]	; 0x438
    894e:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8950:	b0ed      	sub	sp, #436	; 0x1b4
    8952:	4604      	mov	r4, r0
    8954:	460d      	mov	r5, r1
	if (nvm->store_bulk_status == 1){
    8956:	d168      	bne.n	8a2a <grid_nvm_ui_bulk_store_next+0xe2>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];

                        if (eve->cfg_changed_flag == 1){


                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    8958:	4f53      	ldr	r7, [pc, #332]	; (8aa8 <grid_nvm_ui_bulk_store_next+0x160>)
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    895a:	26a0      	movs	r6, #160	; 0xa0
            if (bank < ui->bank_list_length){
    895c:	786a      	ldrb	r2, [r5, #1]
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    895e:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    8962:	fbb3 f1f6 	udiv	r1, r3, r6
    8966:	f001 0003 	and.w	r0, r1, #3
            if (bank < ui->bank_list_length){
    896a:	4282      	cmp	r2, r0
    896c:	d95f      	bls.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                if (element < ui->bank_list[bank].element_list_length){
    896e:	6869      	ldr	r1, [r5, #4]
    8970:	eb01 1100 	add.w	r1, r1, r0, lsl #4
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8974:	f04f 0e0a 	mov.w	lr, #10
                if (element < ui->bank_list[bank].element_list_length){
    8978:	7a48      	ldrb	r0, [r1, #9]
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    897a:	fbb3 f2fe 	udiv	r2, r3, lr
    897e:	f002 0c0f 	and.w	ip, r2, #15
                if (element < ui->bank_list[bank].element_list_length){
    8982:	4560      	cmp	r0, ip
    8984:	d953      	bls.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8986:	68c9      	ldr	r1, [r1, #12]
            uint8_t event   = nvm->store_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8988:	fb0e 3212 	mls	r2, lr, r2, r3
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    898c:	2364      	movs	r3, #100	; 0x64
    898e:	fb0c 1303 	mla	r3, ip, r3, r1
    8992:	b2d1      	uxtb	r1, r2
    8994:	f893 005c 	ldrb.w	r0, [r3, #92]	; 0x5c
    8998:	4288      	cmp	r0, r1
    899a:	d948      	bls.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];
    899c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    899e:	21bc      	movs	r1, #188	; 0xbc
    89a0:	fb01 3202 	mla	r2, r1, r2, r3
                        if (eve->cfg_changed_flag == 1){
    89a4:	f892 30b6 	ldrb.w	r3, [r2, #182]	; 0xb6
    89a8:	2b01      	cmp	r3, #1
    89aa:	d140      	bne.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    89ac:	4621      	mov	r1, r4
    89ae:	4628      	mov	r0, r5
    89b0:	47b8      	blx	r7
    89b2:	3800      	subs	r0, #0
    89b4:	bf18      	it	ne
    89b6:	2001      	movne	r0, #1

            }
            
            

            if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    89b8:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    89bc:	f240 227e 	movw	r2, #638	; 0x27e
    89c0:	4293      	cmp	r3, r2
    89c2:	d804      	bhi.n	89ce <grid_nvm_ui_bulk_store_next+0x86>



                nvm->store_bulk_page_index++;       
    89c4:	3301      	adds	r3, #1
    89c6:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        while (something_was_stored == 0){
    89ca:	2800      	cmp	r0, #0
    89cc:	d0c6      	beq.n	895c <grid_nvm_ui_bulk_store_next+0x14>
		

		
		
		
		if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    89ce:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    89d2:	4e36      	ldr	r6, [pc, #216]	; (8aac <grid_nvm_ui_bulk_store_next+0x164>)
    89d4:	f240 227e 	movw	r2, #638	; 0x27e
    89d8:	4293      	cmp	r3, r2
    89da:	d82a      	bhi.n	8a32 <grid_nvm_ui_bulk_store_next+0xea>
			
            
            uint8_t intensity = abs(nvm->store_bulk_page_index%100 - 50)/1.5 + 40;
    89dc:	2264      	movs	r2, #100	; 0x64
    89de:	fbb3 f0f2 	udiv	r0, r3, r2
    89e2:	fb02 3010 	mls	r0, r2, r0, r3
    89e6:	3832      	subs	r0, #50	; 0x32
    89e8:	2800      	cmp	r0, #0
    89ea:	bfb8      	it	lt
    89ec:	4240      	neglt	r0, r0
    89ee:	4f30      	ldr	r7, [pc, #192]	; (8ab0 <grid_nvm_ui_bulk_store_next+0x168>)
    89f0:	4c30      	ldr	r4, [pc, #192]	; (8ab4 <grid_nvm_ui_bulk_store_next+0x16c>)
    89f2:	4d31      	ldr	r5, [pc, #196]	; (8ab8 <grid_nvm_ui_bulk_store_next+0x170>)
    89f4:	47b8      	blx	r7
    89f6:	4b31      	ldr	r3, [pc, #196]	; (8abc <grid_nvm_ui_bulk_store_next+0x174>)
    89f8:	2200      	movs	r2, #0
    89fa:	47a0      	blx	r4
    89fc:	4b30      	ldr	r3, [pc, #192]	; (8ac0 <grid_nvm_ui_bulk_store_next+0x178>)
    89fe:	4c31      	ldr	r4, [pc, #196]	; (8ac4 <grid_nvm_ui_bulk_store_next+0x17c>)
    8a00:	2200      	movs	r2, #0
    8a02:	47a0      	blx	r4
    8a04:	47a8      	blx	r5
    8a06:	b2c4      	uxtb	r4, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, 0, intensity*0.75, intensity, 1, 1000);
    8a08:	4620      	mov	r0, r4
    8a0a:	47b8      	blx	r7
    8a0c:	4b2e      	ldr	r3, [pc, #184]	; (8ac8 <grid_nvm_ui_bulk_store_next+0x180>)
    8a0e:	4f2f      	ldr	r7, [pc, #188]	; (8acc <grid_nvm_ui_bulk_store_next+0x184>)
    8a10:	2200      	movs	r2, #0
    8a12:	47b8      	blx	r7
    8a14:	47a8      	blx	r5
    8a16:	2301      	movs	r3, #1
    8a18:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8a1c:	e9cd 3200 	strd	r3, r2, [sp]
    8a20:	2100      	movs	r1, #0
    8a22:	b2c2      	uxtb	r2, r0
    8a24:	4623      	mov	r3, r4
    8a26:	482a      	ldr	r0, [pc, #168]	; (8ad0 <grid_nvm_ui_bulk_store_next+0x188>)
    8a28:	47b0      	blx	r6
	}
	
	
	
	
}
    8a2a:	b06d      	add	sp, #436	; 0x1b4
    8a2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8a2e:	2000      	movs	r0, #0
    8a30:	e7c2      	b.n	89b8 <grid_nvm_ui_bulk_store_next+0x70>
			nvm->store_bulk_page_index = 0;
    8a32:	2500      	movs	r5, #0
    8a34:	f8c4 5434 	str.w	r5, [r4, #1076]	; 0x434
			nvm->store_bulk_status = 0;
    8a38:	f884 5438 	strb.w	r5, [r4, #1080]	; 0x438
			grid_msg_init(&response);
    8a3c:	a805      	add	r0, sp, #20
    8a3e:	4b25      	ldr	r3, [pc, #148]	; (8ad4 <grid_nvm_ui_bulk_store_next+0x18c>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8a40:	4c25      	ldr	r4, [pc, #148]	; (8ad8 <grid_nvm_ui_bulk_store_next+0x190>)
			grid_msg_init(&response);
    8a42:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8a44:	227f      	movs	r2, #127	; 0x7f
    8a46:	462b      	mov	r3, r5
    8a48:	4611      	mov	r1, r2
    8a4a:	a805      	add	r0, sp, #20
    8a4c:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a4e:	2303      	movs	r3, #3
    8a50:	4922      	ldr	r1, [pc, #136]	; (8adc <grid_nvm_ui_bulk_store_next+0x194>)
    8a52:	9300      	str	r3, [sp, #0]
    8a54:	2202      	movs	r2, #2
    8a56:	4c22      	ldr	r4, [pc, #136]	; (8ae0 <grid_nvm_ui_bulk_store_next+0x198>)
			uint8_t response_payload[10] = {0};
    8a58:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a5c:	2370      	movs	r3, #112	; 0x70
    8a5e:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8a60:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a64:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8a66:	4b1f      	ldr	r3, [pc, #124]	; (8ae4 <grid_nvm_ui_bulk_store_next+0x19c>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8a68:	4c1f      	ldr	r4, [pc, #124]	; (8ae8 <grid_nvm_ui_bulk_store_next+0x1a0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8a6a:	a802      	add	r0, sp, #8
    8a6c:	4798      	blx	r3
    8a6e:	a902      	add	r1, sp, #8
    8a70:	4602      	mov	r2, r0
    8a72:	4b1e      	ldr	r3, [pc, #120]	; (8aec <grid_nvm_ui_bulk_store_next+0x1a4>)
    8a74:	a805      	add	r0, sp, #20
    8a76:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8a78:	230a      	movs	r3, #10
    8a7a:	9300      	str	r3, [sp, #0]
    8a7c:	4629      	mov	r1, r5
    8a7e:	a805      	add	r0, sp, #20
    8a80:	2301      	movs	r3, #1
    8a82:	2204      	movs	r2, #4
    8a84:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8a86:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8a8a:	e9cd 5300 	strd	r5, r3, [sp]
    8a8e:	22ff      	movs	r2, #255	; 0xff
    8a90:	462b      	mov	r3, r5
    8a92:	4629      	mov	r1, r5
    8a94:	480e      	ldr	r0, [pc, #56]	; (8ad0 <grid_nvm_ui_bulk_store_next+0x188>)
    8a96:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8a98:	4b15      	ldr	r3, [pc, #84]	; (8af0 <grid_nvm_ui_bulk_store_next+0x1a8>)
    8a9a:	a805      	add	r0, sp, #20
    8a9c:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8a9e:	4b15      	ldr	r3, [pc, #84]	; (8af4 <grid_nvm_ui_bulk_store_next+0x1ac>)
    8aa0:	a805      	add	r0, sp, #20
    8aa2:	4798      	blx	r3
}
    8aa4:	e7c1      	b.n	8a2a <grid_nvm_ui_bulk_store_next+0xe2>
    8aa6:	bf00      	nop
    8aa8:	00009cf9 	.word	0x00009cf9
    8aac:	00009813 	.word	0x00009813
    8ab0:	00013d95 	.word	0x00013d95
    8ab4:	000140bd 	.word	0x000140bd
    8ab8:	0001428d 	.word	0x0001428d
    8abc:	3ff80000 	.word	0x3ff80000
    8ac0:	40440000 	.word	0x40440000
    8ac4:	00013afd 	.word	0x00013afd
    8ac8:	3fe80000 	.word	0x3fe80000
    8acc:	00013e69 	.word	0x00013e69
    8ad0:	2000f008 	.word	0x2000f008
    8ad4:	000085c5 	.word	0x000085c5
    8ad8:	000085f9 	.word	0x000085f9
    8adc:	00016d0f 	.word	0x00016d0f
    8ae0:	00014ac5 	.word	0x00014ac5
    8ae4:	00014f81 	.word	0x00014f81
    8ae8:	000085a9 	.word	0x000085a9
    8aec:	00008535 	.word	0x00008535
    8af0:	000086f1 	.word	0x000086f1
    8af4:	000087c5 	.word	0x000087c5

00008af8 <grid_nvm_ui_bulk_clear_init>:



void grid_nvm_ui_bulk_clear_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->clear_bulk_page_index = 0;
    8af8:	2300      	movs	r3, #0
    8afa:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 1;
    8afe:	2301      	movs	r3, #1
    8b00:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	
}
    8b04:	4770      	bx	lr

00008b06 <grid_nvm_ui_bulk_clear_is_in_progress>:

uint8_t grid_nvm_ui_bulk_clear_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->clear_bulk_status;
	
}
    8b06:	f890 0430 	ldrb.w	r0, [r0, #1072]	; 0x430
    8b0a:	4770      	bx	lr

00008b0c <grid_nvm_ui_bulk_clear_next>:


void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8b10:	4604      	mov	r4, r0
    8b12:	b0ec      	sub	sp, #432	; 0x1b0
	
	if (nvm->clear_bulk_status == 1){
    8b14:	f894 3430 	ldrb.w	r3, [r4, #1072]	; 0x430
    8b18:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8b1a:	4608      	mov	r0, r1
	if (nvm->clear_bulk_status == 1){
    8b1c:	d15b      	bne.n	8bd6 <grid_nvm_ui_bulk_clear_next+0xca>
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8b1e:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8b20:	f8d4 242c 	ldr.w	r2, [r4, #1068]	; 0x42c
    8b24:	23a0      	movs	r3, #160	; 0xa0
    8b26:	fbb2 f3f3 	udiv	r3, r2, r3
    8b2a:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8b2e:	4299      	cmp	r1, r3
    8b30:	d91c      	bls.n	8b6c <grid_nvm_ui_bulk_clear_next+0x60>
			
			if (element < ui->bank_list[bank].element_list_length){
    8b32:	6845      	ldr	r5, [r0, #4]
    8b34:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8b38:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8b3a:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8b3c:	fbb2 f1f7 	udiv	r1, r2, r7
    8b40:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    8b44:	42b5      	cmp	r5, r6
    8b46:	d911      	bls.n	8b6c <grid_nvm_ui_bulk_clear_next+0x60>
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8b48:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8b4c:	68da      	ldr	r2, [r3, #12]
    8b4e:	2364      	movs	r3, #100	; 0x64
    8b50:	fb06 2303 	mla	r3, r6, r3, r2
    8b54:	b2ca      	uxtb	r2, r1
    8b56:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8b5a:	4295      	cmp	r5, r2
    8b5c:	d906      	bls.n	8b6c <grid_nvm_ui_bulk_clear_next+0x60>
					// Valid memory location
					
					grid_ui_nvm_clear_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);		
    8b5e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8b60:	22bc      	movs	r2, #188	; 0xbc
    8b62:	fb02 3201 	mla	r2, r2, r1, r3
    8b66:	4b3c      	ldr	r3, [pc, #240]	; (8c58 <grid_nvm_ui_bulk_clear_next+0x14c>)
    8b68:	4621      	mov	r1, r4
    8b6a:	4798      	blx	r3
	
		}
		
		
		
		if (nvm->clear_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8b6c:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8b70:	4e3a      	ldr	r6, [pc, #232]	; (8c5c <grid_nvm_ui_bulk_clear_next+0x150>)
    8b72:	f240 227e 	movw	r2, #638	; 0x27e
    8b76:	4293      	cmp	r3, r2
    8b78:	d830      	bhi.n	8bdc <grid_nvm_ui_bulk_clear_next+0xd0>
			
            
            uint8_t intensity = abs(nvm->clear_bulk_page_index%100 - 50)/1.5 + 40;
    8b7a:	2264      	movs	r2, #100	; 0x64
    8b7c:	fbb3 f0f2 	udiv	r0, r3, r2
    8b80:	fb02 3010 	mls	r0, r2, r0, r3
    8b84:	3832      	subs	r0, #50	; 0x32
    8b86:	2800      	cmp	r0, #0
    8b88:	bfb8      	it	lt
    8b8a:	4240      	neglt	r0, r0
    8b8c:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8ca8 <grid_nvm_ui_bulk_clear_next+0x19c>
    8b90:	4d33      	ldr	r5, [pc, #204]	; (8c60 <grid_nvm_ui_bulk_clear_next+0x154>)
    8b92:	4f34      	ldr	r7, [pc, #208]	; (8c64 <grid_nvm_ui_bulk_clear_next+0x158>)
    8b94:	47c0      	blx	r8
    8b96:	4b34      	ldr	r3, [pc, #208]	; (8c68 <grid_nvm_ui_bulk_clear_next+0x15c>)
    8b98:	2200      	movs	r2, #0
    8b9a:	47a8      	blx	r5
    8b9c:	4b33      	ldr	r3, [pc, #204]	; (8c6c <grid_nvm_ui_bulk_clear_next+0x160>)
    8b9e:	4d34      	ldr	r5, [pc, #208]	; (8c70 <grid_nvm_ui_bulk_clear_next+0x164>)
    8ba0:	2200      	movs	r2, #0
    8ba2:	47a8      	blx	r5
    8ba4:	47b8      	blx	r7
    8ba6:	b2c5      	uxtb	r5, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, intensity, intensity*0.75, 0, 1, 1000);
    8ba8:	4628      	mov	r0, r5
    8baa:	47c0      	blx	r8
    8bac:	4b31      	ldr	r3, [pc, #196]	; (8c74 <grid_nvm_ui_bulk_clear_next+0x168>)
    8bae:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8cac <grid_nvm_ui_bulk_clear_next+0x1a0>
    8bb2:	2200      	movs	r2, #0
    8bb4:	47c0      	blx	r8
    8bb6:	47b8      	blx	r7
    8bb8:	2301      	movs	r3, #1
    8bba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8bbe:	e9cd 3200 	strd	r3, r2, [sp]
    8bc2:	4629      	mov	r1, r5
    8bc4:	2300      	movs	r3, #0
    8bc6:	b2c2      	uxtb	r2, r0
    8bc8:	482b      	ldr	r0, [pc, #172]	; (8c78 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8bca:	47b0      	blx	r6


            
            nvm->clear_bulk_page_index++;
    8bcc:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8bd0:	3301      	adds	r3, #1
    8bd2:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	}
	
	
	
	
}
    8bd6:	b06c      	add	sp, #432	; 0x1b0
    8bd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			nvm->clear_bulk_page_index = 0;
    8bdc:	2500      	movs	r5, #0
    8bde:	f8c4 542c 	str.w	r5, [r4, #1068]	; 0x42c
			nvm->clear_bulk_status = 0;
    8be2:	f884 5430 	strb.w	r5, [r4, #1072]	; 0x430
			grid_msg_init(&response);
    8be6:	a805      	add	r0, sp, #20
    8be8:	4b24      	ldr	r3, [pc, #144]	; (8c7c <grid_nvm_ui_bulk_clear_next+0x170>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8bea:	4c25      	ldr	r4, [pc, #148]	; (8c80 <grid_nvm_ui_bulk_clear_next+0x174>)
			grid_msg_init(&response);
    8bec:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8bee:	227f      	movs	r2, #127	; 0x7f
    8bf0:	462b      	mov	r3, r5
    8bf2:	4611      	mov	r1, r2
    8bf4:	a805      	add	r0, sp, #20
    8bf6:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8bf8:	2303      	movs	r3, #3
    8bfa:	4922      	ldr	r1, [pc, #136]	; (8c84 <grid_nvm_ui_bulk_clear_next+0x178>)
    8bfc:	9300      	str	r3, [sp, #0]
    8bfe:	2202      	movs	r2, #2
    8c00:	4c21      	ldr	r4, [pc, #132]	; (8c88 <grid_nvm_ui_bulk_clear_next+0x17c>)
			uint8_t response_payload[10] = {0};
    8c02:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8c06:	2372      	movs	r3, #114	; 0x72
    8c08:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8c0a:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8c0e:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8c10:	4b1e      	ldr	r3, [pc, #120]	; (8c8c <grid_nvm_ui_bulk_clear_next+0x180>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8c12:	4c1f      	ldr	r4, [pc, #124]	; (8c90 <grid_nvm_ui_bulk_clear_next+0x184>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8c14:	a802      	add	r0, sp, #8
    8c16:	4798      	blx	r3
    8c18:	a902      	add	r1, sp, #8
    8c1a:	4602      	mov	r2, r0
    8c1c:	4b1d      	ldr	r3, [pc, #116]	; (8c94 <grid_nvm_ui_bulk_clear_next+0x188>)
    8c1e:	a805      	add	r0, sp, #20
    8c20:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8c22:	230a      	movs	r3, #10
    8c24:	9300      	str	r3, [sp, #0]
    8c26:	4629      	mov	r1, r5
    8c28:	a805      	add	r0, sp, #20
    8c2a:	2301      	movs	r3, #1
    8c2c:	2204      	movs	r2, #4
    8c2e:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8c30:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8c34:	22ff      	movs	r2, #255	; 0xff
    8c36:	4629      	mov	r1, r5
    8c38:	e9cd 5300 	strd	r5, r3, [sp]
    8c3c:	480e      	ldr	r0, [pc, #56]	; (8c78 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8c3e:	462b      	mov	r3, r5
    8c40:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8c42:	4b15      	ldr	r3, [pc, #84]	; (8c98 <grid_nvm_ui_bulk_clear_next+0x18c>)
    8c44:	a805      	add	r0, sp, #20
    8c46:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8c48:	4b14      	ldr	r3, [pc, #80]	; (8c9c <grid_nvm_ui_bulk_clear_next+0x190>)
    8c4a:	a805      	add	r0, sp, #20
    8c4c:	4798      	blx	r3
            grid_ui_reinit_local(&grid_ui_state);
    8c4e:	4814      	ldr	r0, [pc, #80]	; (8ca0 <grid_nvm_ui_bulk_clear_next+0x194>)
    8c50:	4b14      	ldr	r3, [pc, #80]	; (8ca4 <grid_nvm_ui_bulk_clear_next+0x198>)
    8c52:	4798      	blx	r3
}
    8c54:	e7bf      	b.n	8bd6 <grid_nvm_ui_bulk_clear_next+0xca>
    8c56:	bf00      	nop
    8c58:	00009f0d 	.word	0x00009f0d
    8c5c:	00009813 	.word	0x00009813
    8c60:	000140bd 	.word	0x000140bd
    8c64:	0001428d 	.word	0x0001428d
    8c68:	3ff80000 	.word	0x3ff80000
    8c6c:	40440000 	.word	0x40440000
    8c70:	00013afd 	.word	0x00013afd
    8c74:	3fe80000 	.word	0x3fe80000
    8c78:	2000f008 	.word	0x2000f008
    8c7c:	000085c5 	.word	0x000085c5
    8c80:	000085f9 	.word	0x000085f9
    8c84:	00016d0f 	.word	0x00016d0f
    8c88:	00014ac5 	.word	0x00014ac5
    8c8c:	00014f81 	.word	0x00014f81
    8c90:	000085a9 	.word	0x000085a9
    8c94:	00008535 	.word	0x00008535
    8c98:	000086f1 	.word	0x000086f1
    8c9c:	000087c5 	.word	0x000087c5
    8ca0:	2000effc 	.word	0x2000effc
    8ca4:	0000a519 	.word	0x0000a519
    8ca8:	00013d95 	.word	0x00013d95
    8cac:	00013e69 	.word	0x00013e69

00008cb0 <grid_nvm_clear_read_buffer>:



void grid_nvm_clear_read_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cb0:	f100 0309 	add.w	r3, r0, #9
    8cb4:	f200 2209 	addw	r2, r0, #521	; 0x209
		
		mod->read_buffer[i] = 255;
    8cb8:	21ff      	movs	r1, #255	; 0xff
    8cba:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cbe:	4293      	cmp	r3, r2
    8cc0:	d1fb      	bne.n	8cba <grid_nvm_clear_read_buffer+0xa>
		
	}

	mod->read_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    8cc2:	2302      	movs	r3, #2
    8cc4:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	mod->read_buffer_length = 0;
    8cc8:	2300      	movs	r3, #0
    8cca:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
	
}
    8cce:	4770      	bx	lr

00008cd0 <grid_nvm_clear_write_buffer>:

void grid_nvm_clear_write_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cd0:	f500 7306 	add.w	r3, r0, #536	; 0x218
    8cd4:	f500 6283 	add.w	r2, r0, #1048	; 0x418
		
		mod->write_buffer[i] = 255;
    8cd8:	21ff      	movs	r1, #255	; 0xff
    8cda:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cde:	4293      	cmp	r3, r2
    8ce0:	d1fb      	bne.n	8cda <grid_nvm_clear_write_buffer+0xa>
		
	}
	
	mod->write_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    8ce2:	2302      	movs	r3, #2
    8ce4:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	mod->write_buffer_length = 0;
    8ce8:	2300      	movs	r3, #0
    8cea:	f8c0 3418 	str.w	r3, [r0, #1048]	; 0x418
	mod->write_target_address = -1;
    8cee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8cf2:	f8c0 3420 	str.w	r3, [r0, #1056]	; 0x420
}
    8cf6:	4770      	bx	lr

00008cf8 <grid_nvm_init>:
void grid_nvm_init(struct grid_nvm_model* nvm, struct flash_descriptor* flash_instance){
    8cf8:	b510      	push	{r4, lr}
	nvm->bank_settings_page_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8cfa:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
	nvm->flash = flash_instance;
    8cfe:	e9c0 1300 	strd	r1, r3, [r0]
	nvm->status = 1;
    8d02:	2301      	movs	r3, #1
    8d04:	7203      	strb	r3, [r0, #8]
	nvm->read_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    8d06:	2300      	movs	r3, #0
    8d08:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	nvm->write_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    8d0c:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	nvm->read_bulk_page_index = 0;
    8d10:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 0;
    8d14:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
	nvm->clear_bulk_page_index = 0;
    8d18:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 0;	
    8d1c:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	nvm->write_bulk_page_index = 0;
    8d20:	f8c0 343c 	str.w	r3, [r0, #1084]	; 0x43c
	nvm->write_bulk_status = 0;
    8d24:	f880 3440 	strb.w	r3, [r0, #1088]	; 0x440
	grid_nvm_clear_read_buffer(nvm);
    8d28:	4b02      	ldr	r3, [pc, #8]	; (8d34 <grid_nvm_init+0x3c>)
    8d2a:	4798      	blx	r3
}
    8d2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_nvm_clear_write_buffer(nvm);
    8d30:	4b01      	ldr	r3, [pc, #4]	; (8d38 <grid_nvm_init+0x40>)
    8d32:	4718      	bx	r3
    8d34:	00008cb1 	.word	0x00008cb1
    8d38:	00008cd1 	.word	0x00008cd1

00008d3c <grid_nvm_calculate_event_page_offset>:


uint32_t grid_nvm_calculate_event_page_offset(struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    8d3c:	b510      	push	{r4, lr}
	
	
	
	uint8_t bank_number		= eve->parent->parent->index;
    8d3e:	684a      	ldr	r2, [r1, #4]
    8d40:	6853      	ldr	r3, [r2, #4]
	uint8_t element_number	= eve->parent->index;
	uint8_t event_number	= eve->index;

	return GRID_NVM_STRATEGY_BANK_size * bank_number + GRID_NVM_STRATEGY_ELEMENT_size * element_number + GRID_NVM_STRATEGY_EVENT_size * event_number;
    8d42:	7a1c      	ldrb	r4, [r3, #8]
    8d44:	7a13      	ldrb	r3, [r2, #8]
    8d46:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    8d4a:	20a0      	movs	r0, #160	; 0xa0
    8d4c:	005b      	lsls	r3, r3, #1
    8d4e:	fb10 3304 	smlabb	r3, r0, r4, r3
    8d52:	7a08      	ldrb	r0, [r1, #8]
	
    8d54:	4418      	add	r0, r3
    8d56:	bd10      	pop	{r4, pc}

00008d58 <_gpio_set_pin_pull_mode.constprop.0>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    8d58:	01c0      	lsls	r0, r0, #7
    8d5a:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    8d5e:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
		break;

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    8d62:	2301      	movs	r3, #1
    8d64:	408b      	lsls	r3, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    8d66:	4401      	add	r1, r0
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    8d68:	6043      	str	r3, [r0, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    8d6a:	f891 2040 	ldrb.w	r2, [r1, #64]	; 0x40
    8d6e:	f042 0204 	orr.w	r2, r2, #4
    8d72:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8d76:	6183      	str	r3, [r0, #24]

	default:
		ASSERT(false);
		break;
	}
}
    8d78:	4770      	bx	lr

00008d7a <grid_task_enter_task>:
 * Author : SUKU WC
*/

#include "grid_sys.h"

enum grid_task grid_task_enter_task(struct grid_task_model* mod, enum grid_task next_task){
    8d7a:	4603      	mov	r3, r0
	
	
	enum grid_task previous_task = mod->current_task;
    8d7c:	7840      	ldrb	r0, [r0, #1]
	mod->current_task = next_task;
    8d7e:	7059      	strb	r1, [r3, #1]
	return previous_task;
	
}
    8d80:	4770      	bx	lr

00008d82 <grid_task_timer_tick>:
	
}

void grid_task_timer_tick(struct grid_task_model* mod){
	
	mod->timer[mod->current_task]++;
    8d82:	7843      	ldrb	r3, [r0, #1]
    8d84:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    8d88:	6843      	ldr	r3, [r0, #4]
    8d8a:	3301      	adds	r3, #1
    8d8c:	6043      	str	r3, [r0, #4]
	
}
    8d8e:	4770      	bx	lr

00008d90 <grid_sys_nvm_store_configuration>:
}




void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8d94:	f2ad 4dec 	subw	sp, sp, #1260	; 0x4ec

	struct grid_msg message;
	
	grid_msg_init(&message);
    8d98:	4b6a      	ldr	r3, [pc, #424]	; (8f44 <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8d9a:	4c6b      	ldr	r4, [pc, #428]	; (8f48 <grid_sys_nvm_store_configuration+0x1b8>)
	for(uint8_t i=0; i<4; i++){
		
		// BANK ENABLED	
		offset = grid_msg_body_get_length(&message);
			
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8d9c:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 8f70 <grid_sys_nvm_store_configuration+0x1e0>
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8da0:	4606      	mov	r6, r0
	grid_msg_init(&message);
    8da2:	a86c      	add	r0, sp, #432	; 0x1b0
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8da4:	460f      	mov	r7, r1
	grid_msg_init(&message);
    8da6:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8da8:	22ff      	movs	r2, #255	; 0xff
    8daa:	4611      	mov	r1, r2
    8dac:	2300      	movs	r3, #0
    8dae:	a86c      	add	r0, sp, #432	; 0x1b0
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8db0:	2500      	movs	r5, #0
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8db2:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8db4:	4b65      	ldr	r3, [pc, #404]	; (8f4c <grid_sys_nvm_store_configuration+0x1bc>)
    8db6:	9508      	str	r5, [sp, #32]
    8db8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    8dbc:	4629      	mov	r1, r5
    8dbe:	a809      	add	r0, sp, #36	; 0x24
    8dc0:	4798      	blx	r3
	for(uint8_t i=0; i<4; i++){
    8dc2:	3613      	adds	r6, #19
		offset = grid_msg_body_get_length(&message);
    8dc4:	4b62      	ldr	r3, [pc, #392]	; (8f50 <grid_sys_nvm_store_configuration+0x1c0>)
		payload_length = strlen(payload);
    8dc6:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 8f7c <grid_sys_nvm_store_configuration+0x1ec>
			
		grid_msg_body_append_text(&message, payload, payload_length);
    8dca:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8f80 <grid_sys_nvm_store_configuration+0x1f0>
			
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8dce:	4c61      	ldr	r4, [pc, #388]	; (8f54 <grid_sys_nvm_store_configuration+0x1c4>)
		offset = grid_msg_body_get_length(&message);
    8dd0:	a86c      	add	r0, sp, #432	; 0x1b0
    8dd2:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8dd4:	2203      	movs	r2, #3
		offset = grid_msg_body_get_length(&message);
    8dd6:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8dd8:	2331      	movs	r3, #49	; 0x31
    8dda:	495f      	ldr	r1, [pc, #380]	; (8f58 <grid_sys_nvm_store_configuration+0x1c8>)
    8ddc:	9200      	str	r2, [sp, #0]
    8dde:	a808      	add	r0, sp, #32
    8de0:	2202      	movs	r2, #2
    8de2:	47d0      	blx	sl
		payload_length = strlen(payload);
    8de4:	a808      	add	r0, sp, #32
    8de6:	47d8      	blx	fp
		grid_msg_body_append_text(&message, payload, payload_length);
    8de8:	a908      	add	r1, sp, #32
    8dea:	b2c2      	uxtb	r2, r0
    8dec:	a86c      	add	r0, sp, #432	; 0x1b0
    8dee:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8df0:	220e      	movs	r2, #14
    8df2:	4641      	mov	r1, r8
    8df4:	9200      	str	r2, [sp, #0]
    8df6:	2301      	movs	r3, #1
    8df8:	2204      	movs	r2, #4
    8dfa:	a86c      	add	r0, sp, #432	; 0x1b0
    8dfc:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    8dfe:	4641      	mov	r1, r8
    8e00:	9500      	str	r5, [sp, #0]
    8e02:	2302      	movs	r3, #2
    8e04:	2205      	movs	r2, #5
    8e06:	a86c      	add	r0, sp, #432	; 0x1b0
    8e08:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);		
    8e0a:	f816 3b01 	ldrb.w	r3, [r6], #1
    8e0e:	9300      	str	r3, [sp, #0]
    8e10:	4641      	mov	r1, r8
    8e12:	2207      	movs	r2, #7
    8e14:	2302      	movs	r3, #2
    8e16:	a86c      	add	r0, sp, #432	; 0x1b0
    8e18:	47a0      	blx	r4
			
		// BANK COLOR	
		offset = grid_msg_body_get_length(&message);
    8e1a:	4b4d      	ldr	r3, [pc, #308]	; (8f50 <grid_sys_nvm_store_configuration+0x1c0>)
    8e1c:	a86c      	add	r0, sp, #432	; 0x1b0
    8e1e:	4798      	blx	r3
		
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8e20:	2303      	movs	r3, #3
		offset = grid_msg_body_get_length(&message);
    8e22:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8e24:	494d      	ldr	r1, [pc, #308]	; (8f5c <grid_sys_nvm_store_configuration+0x1cc>)
    8e26:	9300      	str	r3, [sp, #0]
    8e28:	2202      	movs	r2, #2
    8e2a:	2332      	movs	r3, #50	; 0x32
    8e2c:	a808      	add	r0, sp, #32
    8e2e:	47d0      	blx	sl
		payload_length = strlen(payload);
    8e30:	a808      	add	r0, sp, #32
    8e32:	47d8      	blx	fp
		
		grid_msg_body_append_text(&message, payload, payload_length);
    8e34:	a908      	add	r1, sp, #32
    8e36:	b2c2      	uxtb	r2, r0
    8e38:	a86c      	add	r0, sp, #432	; 0x1b0
    8e3a:	47c8      	blx	r9

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8e3c:	230e      	movs	r3, #14
    8e3e:	4641      	mov	r1, r8
    8e40:	9300      	str	r3, [sp, #0]
    8e42:	2204      	movs	r2, #4
    8e44:	2301      	movs	r3, #1
    8e46:	a86c      	add	r0, sp, #432	; 0x1b0
    8e48:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    8e4a:	4641      	mov	r1, r8
    8e4c:	9500      	str	r5, [sp, #0]
    8e4e:	2302      	movs	r3, #2
    8e50:	2205      	movs	r2, #5
    8e52:	a86c      	add	r0, sp, #432	; 0x1b0
    8e54:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    8e56:	78f3      	ldrb	r3, [r6, #3]
    8e58:	9300      	str	r3, [sp, #0]
    8e5a:	4641      	mov	r1, r8
    8e5c:	2302      	movs	r3, #2
    8e5e:	2207      	movs	r2, #7
    8e60:	a86c      	add	r0, sp, #432	; 0x1b0
    8e62:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    8e64:	79f3      	ldrb	r3, [r6, #7]
    8e66:	9300      	str	r3, [sp, #0]
    8e68:	4641      	mov	r1, r8
    8e6a:	2302      	movs	r3, #2
    8e6c:	2209      	movs	r2, #9
    8e6e:	a86c      	add	r0, sp, #432	; 0x1b0
    8e70:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    8e72:	7af3      	ldrb	r3, [r6, #11]
    8e74:	9300      	str	r3, [sp, #0]
    8e76:	4641      	mov	r1, r8
    8e78:	2302      	movs	r3, #2
    8e7a:	220b      	movs	r2, #11
    8e7c:	a86c      	add	r0, sp, #432	; 0x1b0
    8e7e:	3501      	adds	r5, #1
    8e80:	47a0      	blx	r4
	for(uint8_t i=0; i<4; i++){
    8e82:	2d04      	cmp	r5, #4
    8e84:	46d8      	mov	r8, fp
    8e86:	d19d      	bne.n	8dc4 <grid_sys_nvm_store_configuration+0x34>
		
		
	}
	
	grid_msg_packet_close(&message);
    8e88:	4e35      	ldr	r6, [pc, #212]	; (8f60 <grid_sys_nvm_store_configuration+0x1d0>)

	grid_nvm_clear_write_buffer(nvm);
	
	uint8_t acknowledge = 0;
	
	if (grid_msg_packet_get_length(&message)){
    8e8a:	4d36      	ldr	r5, [pc, #216]	; (8f64 <grid_sys_nvm_store_configuration+0x1d4>)
	grid_msg_packet_close(&message);
    8e8c:	a86c      	add	r0, sp, #432	; 0x1b0
    8e8e:	47b0      	blx	r6
	grid_nvm_clear_write_buffer(nvm);
    8e90:	4b35      	ldr	r3, [pc, #212]	; (8f68 <grid_sys_nvm_store_configuration+0x1d8>)
    8e92:	4638      	mov	r0, r7
    8e94:	4798      	blx	r3
	if (grid_msg_packet_get_length(&message)){
    8e96:	a86c      	add	r0, sp, #432	; 0x1b0
    8e98:	47a8      	blx	r5
    8e9a:	9602      	str	r6, [sp, #8]
    8e9c:	2800      	cmp	r0, #0
    8e9e:	d04c      	beq.n	8f3a <grid_sys_nvm_store_configuration+0x1aa>

		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    8ea0:	a86c      	add	r0, sp, #432	; 0x1b0
    8ea2:	47a8      	blx	r5
    8ea4:	f507 7a06 	add.w	sl, r7, #536	; 0x218
		
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
			
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8ea8:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 8f84 <grid_sys_nvm_store_configuration+0x1f4>
		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    8eac:	f8c7 0418 	str.w	r0, [r7, #1048]	; 0x418
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8eb0:	2500      	movs	r5, #0
    8eb2:	4652      	mov	r2, sl
    8eb4:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
    8eb8:	42ab      	cmp	r3, r5
    8eba:	d835      	bhi.n	8f28 <grid_sys_nvm_store_configuration+0x198>
		}
		
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8ebc:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    8ec0:	4d2a      	ldr	r5, [pc, #168]	; (8f6c <grid_sys_nvm_store_configuration+0x1dc>)
    8ec2:	6838      	ldr	r0, [r7, #0]
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8ec4:	f8c7 1420 	str.w	r1, [r7, #1056]	; 0x420
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    8ec8:	47a8      	blx	r5
		
		acknowledge = 1;
    8eca:	2501      	movs	r5, #1

	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    8ecc:	4b1d      	ldr	r3, [pc, #116]	; (8f44 <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8ece:	4f1e      	ldr	r7, [pc, #120]	; (8f48 <grid_sys_nvm_store_configuration+0x1b8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ed0:	4e27      	ldr	r6, [pc, #156]	; (8f70 <grid_sys_nvm_store_configuration+0x1e0>)
	grid_msg_init(&response);
    8ed2:	a8d3      	add	r0, sp, #844	; 0x34c
    8ed4:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8ed6:	227f      	movs	r2, #127	; 0x7f
    8ed8:	4611      	mov	r1, r2
    8eda:	2300      	movs	r3, #0
    8edc:	a8d3      	add	r0, sp, #844	; 0x34c
    8ede:	47b8      	blx	r7
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ee0:	2303      	movs	r3, #3
    8ee2:	4924      	ldr	r1, [pc, #144]	; (8f74 <grid_sys_nvm_store_configuration+0x1e4>)
    8ee4:	9300      	str	r3, [sp, #0]
    8ee6:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    8ee8:	2700      	movs	r7, #0
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8eea:	2360      	movs	r3, #96	; 0x60
    8eec:	a805      	add	r0, sp, #20
	uint8_t response_payload[10] = {0};
    8eee:	e9cd 7705 	strd	r7, r7, [sp, #20]
    8ef2:	f8ad 701c 	strh.w	r7, [sp, #28]
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ef6:	47b0      	blx	r6

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8ef8:	a805      	add	r0, sp, #20
    8efa:	47c0      	blx	r8
    8efc:	a905      	add	r1, sp, #20
    8efe:	4602      	mov	r2, r0
    8f00:	a8d3      	add	r0, sp, #844	; 0x34c
    8f02:	47c8      	blx	r9
	
	if (acknowledge == 1){
    8f04:	b1dd      	cbz	r5, 8f3e <grid_sys_nvm_store_configuration+0x1ae>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);	
    8f06:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    8f08:	2204      	movs	r2, #4
    8f0a:	4639      	mov	r1, r7
    8f0c:	9300      	str	r3, [sp, #0]
    8f0e:	a8d3      	add	r0, sp, #844	; 0x34c
    8f10:	2301      	movs	r3, #1
    8f12:	47a0      	blx	r4
	}

	
	grid_msg_packet_close(&response);
    8f14:	9b02      	ldr	r3, [sp, #8]
    8f16:	a8d3      	add	r0, sp, #844	; 0x34c
    8f18:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    8f1a:	4b17      	ldr	r3, [pc, #92]	; (8f78 <grid_sys_nvm_store_configuration+0x1e8>)
    8f1c:	a8d3      	add	r0, sp, #844	; 0x34c
    8f1e:	4798      	blx	r3
		
	
}
    8f20:	f20d 4dec 	addw	sp, sp, #1260	; 0x4ec
    8f24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8f28:	4629      	mov	r1, r5
    8f2a:	a86c      	add	r0, sp, #432	; 0x1b0
    8f2c:	9203      	str	r2, [sp, #12]
    8f2e:	47d8      	blx	fp
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8f30:	3501      	adds	r5, #1
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8f32:	f80a 0b01 	strb.w	r0, [sl], #1
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8f36:	9a03      	ldr	r2, [sp, #12]
    8f38:	e7bc      	b.n	8eb4 <grid_sys_nvm_store_configuration+0x124>
	uint8_t acknowledge = 0;
    8f3a:	4605      	mov	r5, r0
    8f3c:	e7c6      	b.n	8ecc <grid_sys_nvm_store_configuration+0x13c>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    8f3e:	230b      	movs	r3, #11
    8f40:	e7e2      	b.n	8f08 <grid_sys_nvm_store_configuration+0x178>
    8f42:	bf00      	nop
    8f44:	000085c5 	.word	0x000085c5
    8f48:	000085f9 	.word	0x000085f9
    8f4c:	00014469 	.word	0x00014469
    8f50:	0000852f 	.word	0x0000852f
    8f54:	000085a9 	.word	0x000085a9
    8f58:	00016d19 	.word	0x00016d19
    8f5c:	00016a52 	.word	0x00016a52
    8f60:	000086f1 	.word	0x000086f1
    8f64:	00008521 	.word	0x00008521
    8f68:	00008cd1 	.word	0x00008cd1
    8f6c:	0000ee31 	.word	0x0000ee31
    8f70:	00014ac5 	.word	0x00014ac5
    8f74:	00016d0f 	.word	0x00016d0f
    8f78:	000087c5 	.word	0x000087c5
    8f7c:	00014f81 	.word	0x00014f81
    8f80:	00008535 	.word	0x00008535
    8f84:	000086bb 	.word	0x000086bb

00008f88 <grid_sys_recall_configuration>:


void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f8c:	f5ad 7d51 	sub.w	sp, sp, #836	; 0x344

	struct grid_msg message;
	
	grid_msg_init(&message);
    8f90:	4b48      	ldr	r3, [pc, #288]	; (90b4 <grid_sys_recall_configuration+0x12c>)
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f92:	4c49      	ldr	r4, [pc, #292]	; (90b8 <grid_sys_recall_configuration+0x130>)
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f94:	4605      	mov	r5, r0
	grid_msg_init(&message);
    8f96:	a869      	add	r0, sp, #420	; 0x1a4
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f98:	468a      	mov	sl, r1
	grid_msg_init(&message);
    8f9a:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f9c:	227f      	movs	r2, #127	; 0x7f
    8f9e:	4611      	mov	r1, r2
    8fa0:	2300      	movs	r3, #0
    8fa2:	a869      	add	r0, sp, #420	; 0x1a4
    8fa4:	47a0      	blx	r4


	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8fa6:	2400      	movs	r4, #0
    8fa8:	4b44      	ldr	r3, [pc, #272]	; (90bc <grid_sys_recall_configuration+0x134>)
    8faa:	9405      	str	r4, [sp, #20]
    8fac:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    8fb0:	4621      	mov	r1, r4
    8fb2:	a806      	add	r0, sp, #24
    8fb4:	4798      	blx	r3
	uint8_t payload_length = 0;
	uint32_t offset = 0;
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    8fb6:	3513      	adds	r5, #19
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8fb8:	9403      	str	r4, [sp, #12]
		
		if (bank > GRID_SYS_BANK_MAXNUMBER || bank == i){
    8fba:	f1ba 0f04 	cmp.w	sl, #4
    8fbe:	d803      	bhi.n	8fc8 <grid_sys_recall_configuration+0x40>
    8fc0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    8fc4:	459a      	cmp	sl, r3
    8fc6:	d164      	bne.n	9092 <grid_sys_recall_configuration+0x10a>
			
			// BANK ENABLED
			offset = grid_msg_body_get_length(&message);
    8fc8:	4b3d      	ldr	r3, [pc, #244]	; (90c0 <grid_sys_recall_configuration+0x138>)
		
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fca:	4e3e      	ldr	r6, [pc, #248]	; (90c4 <grid_sys_recall_configuration+0x13c>)
			payload_length = strlen(payload);
		
			grid_msg_body_append_text(&message, payload, payload_length);
    8fcc:	f8df 9110 	ldr.w	r9, [pc, #272]	; 90e0 <grid_sys_recall_configuration+0x158>
			offset = grid_msg_body_get_length(&message);
    8fd0:	a869      	add	r0, sp, #420	; 0x1a4
    8fd2:	4798      	blx	r3
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fd4:	f04f 0b03 	mov.w	fp, #3
			offset = grid_msg_body_get_length(&message);
    8fd8:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fda:	2331      	movs	r3, #49	; 0x31
    8fdc:	493a      	ldr	r1, [pc, #232]	; (90c8 <grid_sys_recall_configuration+0x140>)
    8fde:	f8cd b000 	str.w	fp, [sp]
    8fe2:	2202      	movs	r2, #2
    8fe4:	a805      	add	r0, sp, #20
    8fe6:	47b0      	blx	r6
			payload_length = strlen(payload);
    8fe8:	4a38      	ldr	r2, [pc, #224]	; (90cc <grid_sys_recall_configuration+0x144>)
    8fea:	a805      	add	r0, sp, #20
    8fec:	4790      	blx	r2
		
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    8fee:	f04f 080d 	mov.w	r8, #13
			grid_msg_body_append_text(&message, payload, payload_length);
    8ff2:	b2c2      	uxtb	r2, r0
    8ff4:	a905      	add	r1, sp, #20
    8ff6:	a869      	add	r0, sp, #420	; 0x1a4
    8ff8:	47c8      	blx	r9
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8ffa:	4634      	mov	r4, r6
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    8ffc:	4639      	mov	r1, r7
    8ffe:	4e34      	ldr	r6, [pc, #208]	; (90d0 <grid_sys_recall_configuration+0x148>)
    9000:	f8cd 8000 	str.w	r8, [sp]
    9004:	2301      	movs	r3, #1
    9006:	2204      	movs	r2, #4
    9008:	a869      	add	r0, sp, #420	; 0x1a4
    900a:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    900c:	9b03      	ldr	r3, [sp, #12]
    900e:	9300      	str	r3, [sp, #0]
    9010:	4639      	mov	r1, r7
    9012:	2302      	movs	r3, #2
    9014:	2205      	movs	r2, #5
    9016:	a869      	add	r0, sp, #420	; 0x1a4
    9018:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);
    901a:	782b      	ldrb	r3, [r5, #0]
    901c:	9300      	str	r3, [sp, #0]
    901e:	4639      	mov	r1, r7
    9020:	2207      	movs	r2, #7
    9022:	2302      	movs	r3, #2
    9024:	a869      	add	r0, sp, #420	; 0x1a4
    9026:	47b0      	blx	r6
		
			// BANK COLOR
			offset = grid_msg_body_get_length(&message);
    9028:	4b25      	ldr	r3, [pc, #148]	; (90c0 <grid_sys_recall_configuration+0x138>)
    902a:	a869      	add	r0, sp, #420	; 0x1a4
    902c:	4798      	blx	r3
		
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    902e:	2332      	movs	r3, #50	; 0x32
			offset = grid_msg_body_get_length(&message);
    9030:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    9032:	4928      	ldr	r1, [pc, #160]	; (90d4 <grid_sys_recall_configuration+0x14c>)
    9034:	f8cd b000 	str.w	fp, [sp]
    9038:	2202      	movs	r2, #2
    903a:	a805      	add	r0, sp, #20
    903c:	47a0      	blx	r4
			payload_length = strlen(payload);
    903e:	4a23      	ldr	r2, [pc, #140]	; (90cc <grid_sys_recall_configuration+0x144>)
    9040:	a805      	add	r0, sp, #20
    9042:	4790      	blx	r2
		
			grid_msg_body_append_text(&message, payload, payload_length);
    9044:	a905      	add	r1, sp, #20
    9046:	b2c2      	uxtb	r2, r0
    9048:	a869      	add	r0, sp, #420	; 0x1a4
    904a:	47c8      	blx	r9

			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    904c:	2301      	movs	r3, #1
    904e:	2204      	movs	r2, #4
    9050:	4639      	mov	r1, r7
    9052:	a869      	add	r0, sp, #420	; 0x1a4
    9054:	f8cd 8000 	str.w	r8, [sp]
    9058:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    905a:	9b03      	ldr	r3, [sp, #12]
    905c:	9300      	str	r3, [sp, #0]
    905e:	2205      	movs	r2, #5
    9060:	2302      	movs	r3, #2
    9062:	4639      	mov	r1, r7
    9064:	a869      	add	r0, sp, #420	; 0x1a4
    9066:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    9068:	792b      	ldrb	r3, [r5, #4]
    906a:	9300      	str	r3, [sp, #0]
    906c:	2207      	movs	r2, #7
    906e:	2302      	movs	r3, #2
    9070:	4639      	mov	r1, r7
    9072:	a869      	add	r0, sp, #420	; 0x1a4
    9074:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    9076:	7a2b      	ldrb	r3, [r5, #8]
    9078:	9300      	str	r3, [sp, #0]
    907a:	2209      	movs	r2, #9
    907c:	2302      	movs	r3, #2
    907e:	4639      	mov	r1, r7
    9080:	a869      	add	r0, sp, #420	; 0x1a4
    9082:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    9084:	7b2b      	ldrb	r3, [r5, #12]
    9086:	9300      	str	r3, [sp, #0]
    9088:	220b      	movs	r2, #11
    908a:	2302      	movs	r3, #2
    908c:	4639      	mov	r1, r7
    908e:	a869      	add	r0, sp, #420	; 0x1a4
    9090:	47b0      	blx	r6
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9092:	9b03      	ldr	r3, [sp, #12]
    9094:	3301      	adds	r3, #1
    9096:	2b04      	cmp	r3, #4
    9098:	9303      	str	r3, [sp, #12]
    909a:	f105 0501 	add.w	r5, r5, #1
    909e:	d18c      	bne.n	8fba <grid_sys_recall_configuration+0x32>
		}

		
	}
	
	grid_msg_packet_close(&message);
    90a0:	4b0d      	ldr	r3, [pc, #52]	; (90d8 <grid_sys_recall_configuration+0x150>)
    90a2:	a869      	add	r0, sp, #420	; 0x1a4
    90a4:	4798      	blx	r3

	grid_msg_packet_send_everywhere(&message);
    90a6:	4b0d      	ldr	r3, [pc, #52]	; (90dc <grid_sys_recall_configuration+0x154>)
    90a8:	a869      	add	r0, sp, #420	; 0x1a4
    90aa:	4798      	blx	r3
// 	
// 	grid_msg_packet_close(&response);
// 	grid_msg_packet_send_everywhere(&response);
	
	
}
    90ac:	f50d 7d51 	add.w	sp, sp, #836	; 0x344
    90b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    90b4:	000085c5 	.word	0x000085c5
    90b8:	000085f9 	.word	0x000085f9
    90bc:	00014469 	.word	0x00014469
    90c0:	0000852f 	.word	0x0000852f
    90c4:	00014ac5 	.word	0x00014ac5
    90c8:	00016d19 	.word	0x00016d19
    90cc:	00014f81 	.word	0x00014f81
    90d0:	000085a9 	.word	0x000085a9
    90d4:	00016a52 	.word	0x00016a52
    90d8:	000086f1 	.word	0x000086f1
    90dc:	000087c5 	.word	0x000087c5
    90e0:	00008535 	.word	0x00008535

000090e4 <grid_sys_nvm_load_configuration>:


void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    90e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    90e6:	f5ad 7d6d 	sub.w	sp, sp, #948	; 0x3b4
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    90ea:	2400      	movs	r4, #0
void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    90ec:	460e      	mov	r6, r1
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    90ee:	4b2f      	ldr	r3, [pc, #188]	; (91ac <grid_sys_nvm_load_configuration+0xc8>)
    90f0:	946c      	str	r4, [sp, #432]	; 0x1b0
    90f2:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
    90f6:	4621      	mov	r1, r4
    90f8:	a86d      	add	r0, sp, #436	; 0x1b4
    90fa:	4798      	blx	r3
    90fc:	ad6c      	add	r5, sp, #432	; 0x1b0
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    90fe:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
    9102:	f8c6 1214 	str.w	r1, [r6, #532]	; 0x214
	
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    9106:	6830      	ldr	r0, [r6, #0]
    9108:	4e29      	ldr	r6, [pc, #164]	; (91b0 <grid_sys_nvm_load_configuration+0xcc>)
    910a:	f44f 7300 	mov.w	r3, #512	; 0x200
    910e:	462a      	mov	r2, r5
    9110:	47b0      	blx	r6
			}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9112:	4a28      	ldr	r2, [pc, #160]	; (91b4 <grid_sys_nvm_load_configuration+0xd0>)
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    9114:	4621      	mov	r1, r4
	uint8_t acknowledge = 0;	
    9116:	4626      	mov	r6, r4
	uint8_t copydone = 0;
    9118:	4623      	mov	r3, r4
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    911a:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    911e:	1c4c      	adds	r4, r1, #1
    9120:	b943      	cbnz	r3, 9134 <grid_sys_nvm_load_configuration+0x50>
			if (temp[i] == '\n'){ // END OF PACKET, copy newline character
    9122:	5c68      	ldrb	r0, [r5, r1]
    9124:	280a      	cmp	r0, #10
    9126:	d139      	bne.n	919c <grid_sys_nvm_load_configuration+0xb8>
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9128:	4411      	add	r1, r2
    912a:	55c8      	strb	r0, [r1, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    912c:	6214      	str	r4, [r2, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    912e:	6293      	str	r3, [r2, #40]	; 0x28
				acknowledge = 1;
    9130:	2301      	movs	r3, #1
				copydone = 1;
    9132:	461e      	mov	r6, r3
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){		
    9134:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    9138:	4621      	mov	r1, r4
    913a:	d1f0      	bne.n	911e <grid_sys_nvm_load_configuration+0x3a>
	
	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    913c:	4b1e      	ldr	r3, [pc, #120]	; (91b8 <grid_sys_nvm_load_configuration+0xd4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    913e:	4c1f      	ldr	r4, [pc, #124]	; (91bc <grid_sys_nvm_load_configuration+0xd8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9140:	4d1f      	ldr	r5, [pc, #124]	; (91c0 <grid_sys_nvm_load_configuration+0xdc>)
	grid_msg_init(&response);
    9142:	a805      	add	r0, sp, #20
    9144:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9146:	227f      	movs	r2, #127	; 0x7f
    9148:	4611      	mov	r1, r2
    914a:	2300      	movs	r3, #0
    914c:	a805      	add	r0, sp, #20
    914e:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9150:	2303      	movs	r3, #3
    9152:	491c      	ldr	r1, [pc, #112]	; (91c4 <grid_sys_nvm_load_configuration+0xe0>)
    9154:	9300      	str	r3, [sp, #0]
    9156:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    9158:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    915a:	2361      	movs	r3, #97	; 0x61
    915c:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    915e:	e9cd 4402 	strd	r4, r4, [sp, #8]
    9162:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9166:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9168:	4b17      	ldr	r3, [pc, #92]	; (91c8 <grid_sys_nvm_load_configuration+0xe4>)
    916a:	4d18      	ldr	r5, [pc, #96]	; (91cc <grid_sys_nvm_load_configuration+0xe8>)
    916c:	a802      	add	r0, sp, #8
    916e:	4798      	blx	r3
    9170:	4b17      	ldr	r3, [pc, #92]	; (91d0 <grid_sys_nvm_load_configuration+0xec>)
    9172:	4602      	mov	r2, r0
    9174:	a902      	add	r1, sp, #8
    9176:	a805      	add	r0, sp, #20
    9178:	4798      	blx	r3
	
	if (acknowledge == 1){
    917a:	b1ae      	cbz	r6, 91a8 <grid_sys_nvm_load_configuration+0xc4>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    917c:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    917e:	2204      	movs	r2, #4
    9180:	4621      	mov	r1, r4
    9182:	9300      	str	r3, [sp, #0]
    9184:	a805      	add	r0, sp, #20
    9186:	2301      	movs	r3, #1
    9188:	47a8      	blx	r5
	}

	
	grid_msg_packet_close(&response);
    918a:	4b12      	ldr	r3, [pc, #72]	; (91d4 <grid_sys_nvm_load_configuration+0xf0>)
    918c:	a805      	add	r0, sp, #20
    918e:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9190:	4b11      	ldr	r3, [pc, #68]	; (91d8 <grid_sys_nvm_load_configuration+0xf4>)
    9192:	a805      	add	r0, sp, #20
    9194:	4798      	blx	r3
	
}
    9196:	f50d 7d6d 	add.w	sp, sp, #948	; 0x3b4
    919a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    919c:	28ff      	cmp	r0, #255	; 0xff
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    919e:	bf16      	itet	ne
    91a0:	1889      	addne	r1, r1, r2
				copydone = 1;
    91a2:	2301      	moveq	r3, #1
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    91a4:	55c8      	strbne	r0, [r1, r7]
    91a6:	e7c5      	b.n	9134 <grid_sys_nvm_load_configuration+0x50>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    91a8:	230b      	movs	r3, #11
    91aa:	e7e8      	b.n	917e <grid_sys_nvm_load_configuration+0x9a>
    91ac:	00014469 	.word	0x00014469
    91b0:	0000edc5 	.word	0x0000edc5
    91b4:	2000c0b0 	.word	0x2000c0b0
    91b8:	000085c5 	.word	0x000085c5
    91bc:	000085f9 	.word	0x000085f9
    91c0:	00014ac5 	.word	0x00014ac5
    91c4:	00016d0f 	.word	0x00016d0f
    91c8:	00014f81 	.word	0x00014f81
    91cc:	000085a9 	.word	0x000085a9
    91d0:	00008535 	.word	0x00008535
    91d4:	000086f1 	.word	0x000086f1
    91d8:	000087c5 	.word	0x000087c5

000091dc <grid_sys_nvm_clear_configuration>:

void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    91dc:	b530      	push	{r4, r5, lr}
    91de:	460b      	mov	r3, r1
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    91e0:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    91e4:	b0ed      	sub	sp, #436	; 0x1b4
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    91e6:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    91ea:	2201      	movs	r2, #1
    91ec:	6818      	ldr	r0, [r3, #0]
    91ee:	4b18      	ldr	r3, [pc, #96]	; (9250 <grid_sys_nvm_clear_configuration+0x74>)

	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
		
	grid_msg_init(&response);
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91f0:	4c18      	ldr	r4, [pc, #96]	; (9254 <grid_sys_nvm_clear_configuration+0x78>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    91f2:	4d19      	ldr	r5, [pc, #100]	; (9258 <grid_sys_nvm_clear_configuration+0x7c>)
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    91f4:	4798      	blx	r3
	grid_msg_init(&response);
    91f6:	a805      	add	r0, sp, #20
    91f8:	4b18      	ldr	r3, [pc, #96]	; (925c <grid_sys_nvm_clear_configuration+0x80>)
    91fa:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91fc:	227f      	movs	r2, #127	; 0x7f
    91fe:	4611      	mov	r1, r2
    9200:	a805      	add	r0, sp, #20
    9202:	2300      	movs	r3, #0
    9204:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    9206:	2303      	movs	r3, #3
	uint8_t response_payload[10] = {0};
    9208:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    920a:	4915      	ldr	r1, [pc, #84]	; (9260 <grid_sys_nvm_clear_configuration+0x84>)
    920c:	9300      	str	r3, [sp, #0]
    920e:	2202      	movs	r2, #2
    9210:	2362      	movs	r3, #98	; 0x62
    9212:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    9214:	e9cd 4402 	strd	r4, r4, [sp, #8]
    9218:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    921c:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    921e:	4b11      	ldr	r3, [pc, #68]	; (9264 <grid_sys_nvm_clear_configuration+0x88>)
    9220:	a802      	add	r0, sp, #8
    9222:	4798      	blx	r3
    9224:	a902      	add	r1, sp, #8
    9226:	4602      	mov	r2, r0
    9228:	4b0f      	ldr	r3, [pc, #60]	; (9268 <grid_sys_nvm_clear_configuration+0x8c>)
    922a:	a805      	add	r0, sp, #20
    922c:	4798      	blx	r3
		
	if (acknowledge == 1){
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    922e:	230a      	movs	r3, #10
    9230:	4621      	mov	r1, r4
    9232:	2204      	movs	r2, #4
    9234:	9300      	str	r3, [sp, #0]
    9236:	a805      	add	r0, sp, #20
    9238:	4c0c      	ldr	r4, [pc, #48]	; (926c <grid_sys_nvm_clear_configuration+0x90>)
    923a:	2301      	movs	r3, #1
    923c:	47a0      	blx	r4
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
	}

		
	grid_msg_packet_close(&response);
    923e:	4b0c      	ldr	r3, [pc, #48]	; (9270 <grid_sys_nvm_clear_configuration+0x94>)
    9240:	a805      	add	r0, sp, #20
    9242:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9244:	4b0b      	ldr	r3, [pc, #44]	; (9274 <grid_sys_nvm_clear_configuration+0x98>)
    9246:	a805      	add	r0, sp, #20
    9248:	4798      	blx	r3
	
	
}
    924a:	b06d      	add	sp, #436	; 0x1b4
    924c:	bd30      	pop	{r4, r5, pc}
    924e:	bf00      	nop
    9250:	0000eeb1 	.word	0x0000eeb1
    9254:	000085f9 	.word	0x000085f9
    9258:	00014ac5 	.word	0x00014ac5
    925c:	000085c5 	.word	0x000085c5
    9260:	00016d0f 	.word	0x00016d0f
    9264:	00014f81 	.word	0x00014f81
    9268:	00008535 	.word	0x00008535
    926c:	000085a9 	.word	0x000085a9
    9270:	000086f1 	.word	0x000086f1
    9274:	000087c5 	.word	0x000087c5

00009278 <grid_debug_print_text>:



void grid_debug_print_text(uint8_t* debug_string){
    9278:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	uint32_t debug_string_length = strlen(debug_string);
    927c:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 9360 <grid_debug_print_text+0xe8>
	
	struct grid_msg message;
	
	grid_msg_init(&message);
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9280:	4c2b      	ldr	r4, [pc, #172]	; (9330 <grid_debug_print_text+0xb8>)
	
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
	uint32_t offset = 0;
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    9282:	4e2c      	ldr	r6, [pc, #176]	; (9334 <grid_debug_print_text+0xbc>)
	offset += strlen(&payload[offset]);
		
	sprintf(&payload[offset], "# ");
    9284:	4f2c      	ldr	r7, [pc, #176]	; (9338 <grid_debug_print_text+0xc0>)
void grid_debug_print_text(uint8_t* debug_string){
    9286:	f5ad 7d4c 	sub.w	sp, sp, #816	; 0x330
    928a:	4681      	mov	r9, r0
	uint32_t debug_string_length = strlen(debug_string);
    928c:	47d0      	blx	sl
	grid_msg_init(&message);
    928e:	4b2b      	ldr	r3, [pc, #172]	; (933c <grid_debug_print_text+0xc4>)
	uint32_t debug_string_length = strlen(debug_string);
    9290:	4680      	mov	r8, r0
	grid_msg_init(&message);
    9292:	a865      	add	r0, sp, #404	; 0x194
    9294:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9296:	227f      	movs	r2, #127	; 0x7f
    9298:	4611      	mov	r1, r2
    929a:	2300      	movs	r3, #0
    929c:	a865      	add	r0, sp, #404	; 0x194
    929e:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    92a0:	2400      	movs	r4, #0
    92a2:	4621      	mov	r1, r4
    92a4:	4b26      	ldr	r3, [pc, #152]	; (9340 <grid_debug_print_text+0xc8>)
    92a6:	9401      	str	r4, [sp, #4]
    92a8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    92ac:	a802      	add	r0, sp, #8
    92ae:	4798      	blx	r3
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    92b0:	2202      	movs	r2, #2
    92b2:	4924      	ldr	r1, [pc, #144]	; (9344 <grid_debug_print_text+0xcc>)
    92b4:	2320      	movs	r3, #32
    92b6:	a801      	add	r0, sp, #4
    92b8:	47b0      	blx	r6
	offset += strlen(&payload[offset]);
    92ba:	a801      	add	r0, sp, #4
    92bc:	47d0      	blx	sl
	sprintf(&payload[offset], "# ");
    92be:	ab01      	add	r3, sp, #4
    92c0:	4403      	add	r3, r0
    92c2:	4921      	ldr	r1, [pc, #132]	; (9348 <grid_debug_print_text+0xd0>)
	offset += strlen(&payload[offset]);
    92c4:	4605      	mov	r5, r0
	sprintf(&payload[offset], "# ");
    92c6:	4618      	mov	r0, r3
    92c8:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    92ca:	47d0      	blx	sl
    92cc:	ab01      	add	r3, sp, #4
    92ce:	4405      	add	r5, r0

	for(uint32_t i=0; i<debug_string_length; i++){
    92d0:	1958      	adds	r0, r3, r5
    92d2:	4621      	mov	r1, r4
    92d4:	4603      	mov	r3, r0
    92d6:	4654      	mov	r4, sl
    92d8:	4541      	cmp	r1, r8
    92da:	d006      	beq.n	92ea <grid_debug_print_text+0x72>
		
		payload[offset+i] = debug_string[i];
    92dc:	f819 2001 	ldrb.w	r2, [r9, r1]
    92e0:	f803 2b01 	strb.w	r2, [r3], #1
		
		if (offset + i > GRID_PARAMETER_PACKET_marign)
    92e4:	194a      	adds	r2, r1, r5
    92e6:	2ac8      	cmp	r2, #200	; 0xc8
    92e8:	d91f      	bls.n	932a <grid_debug_print_text+0xb2>
		{
			break;
		}
	}
	offset += strlen(&payload[offset]);
    92ea:	47a0      	blx	r4
	
	
	sprintf(&payload[offset], " #");
    92ec:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    92ee:	4405      	add	r5, r0
	sprintf(&payload[offset], " #");
    92f0:	442b      	add	r3, r5
    92f2:	4916      	ldr	r1, [pc, #88]	; (934c <grid_debug_print_text+0xd4>)
    92f4:	4618      	mov	r0, r3
    92f6:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    92f8:	47a0      	blx	r4
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    92fa:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    92fc:	4405      	add	r5, r0
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    92fe:	195f      	adds	r7, r3, r5
    9300:	4913      	ldr	r1, [pc, #76]	; (9350 <grid_debug_print_text+0xd8>)
    9302:	2203      	movs	r2, #3
    9304:	4638      	mov	r0, r7
    9306:	47b0      	blx	r6
	offset += strlen(&payload[offset]);	
    9308:	4638      	mov	r0, r7
    930a:	47a0      	blx	r4
	
	grid_msg_body_append_text(&message, payload, offset);
    930c:	a901      	add	r1, sp, #4
    930e:	1942      	adds	r2, r0, r5
    9310:	4b10      	ldr	r3, [pc, #64]	; (9354 <grid_debug_print_text+0xdc>)
    9312:	a865      	add	r0, sp, #404	; 0x194
    9314:	4798      	blx	r3
	grid_msg_packet_close(&message);
    9316:	4b10      	ldr	r3, [pc, #64]	; (9358 <grid_debug_print_text+0xe0>)
    9318:	a865      	add	r0, sp, #404	; 0x194
    931a:	4798      	blx	r3
	
	grid_msg_packet_send_everywhere(&message);
    931c:	4b0f      	ldr	r3, [pc, #60]	; (935c <grid_debug_print_text+0xe4>)
    931e:	a865      	add	r0, sp, #404	; 0x194
    9320:	4798      	blx	r3
	

	
	
}
    9322:	f50d 7d4c 	add.w	sp, sp, #816	; 0x330
    9326:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for(uint32_t i=0; i<debug_string_length; i++){
    932a:	3101      	adds	r1, #1
    932c:	e7d4      	b.n	92d8 <grid_debug_print_text+0x60>
    932e:	bf00      	nop
    9330:	000085f9 	.word	0x000085f9
    9334:	00014ac5 	.word	0x00014ac5
    9338:	00014ebd 	.word	0x00014ebd
    933c:	000085c5 	.word	0x000085c5
    9340:	00014469 	.word	0x00014469
    9344:	00016d27 	.word	0x00016d27
    9348:	00016d2f 	.word	0x00016d2f
    934c:	00016d32 	.word	0x00016d32
    9350:	00016a4f 	.word	0x00016a4f
    9354:	00008535 	.word	0x00008535
    9358:	000086f1 	.word	0x000086f1
    935c:	000087c5 	.word	0x000087c5
    9360:	00014f81 	.word	0x00014f81

00009364 <tx_cb_USART_GRID>:
static void tx_cb_USART_GRID_W(const struct usart_async_descriptor *const descr)
{
	tx_cb_USART_GRID(&GRID_PORT_W);
}

void tx_cb_USART_GRID(struct grid_port* const por){
    9364:	b530      	push	{r4, r5, lr}
	
	
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    9366:	f06f 052b 	mvn.w	r5, #43	; 0x2b
    936a:	8984      	ldrh	r4, [r0, #12]
    936c:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9370:	1a2d      	subs	r5, r5, r0
    9372:	2200      	movs	r2, #0
    9374:	18e9      	adds	r1, r5, r3
    9376:	428c      	cmp	r4, r1
    9378:	d801      	bhi.n	937e <tx_cb_USART_GRID+0x1a>
		por->tx_double_buffer[i] = 0;
	}
	por->tx_double_buffer_status = 0;	
    937a:	8182      	strh	r2, [r0, #12]
}
    937c:	bd30      	pop	{r4, r5, pc}
		por->tx_double_buffer[i] = 0;
    937e:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    9382:	e7f7      	b.n	9374 <tx_cb_USART_GRID+0x10>

00009384 <tx_cb_USART_GRID_W>:
	tx_cb_USART_GRID(&GRID_PORT_W);
    9384:	4801      	ldr	r0, [pc, #4]	; (938c <tx_cb_USART_GRID_W+0x8>)
    9386:	4b02      	ldr	r3, [pc, #8]	; (9390 <tx_cb_USART_GRID_W+0xc>)
    9388:	4718      	bx	r3
    938a:	bf00      	nop
    938c:	200102d4 	.word	0x200102d4
    9390:	00009365 	.word	0x00009365

00009394 <tx_cb_USART_GRID_S>:
	tx_cb_USART_GRID(&GRID_PORT_S);
    9394:	4801      	ldr	r0, [pc, #4]	; (939c <tx_cb_USART_GRID_S+0x8>)
    9396:	4b02      	ldr	r3, [pc, #8]	; (93a0 <tx_cb_USART_GRID_S+0xc>)
    9398:	4718      	bx	r3
    939a:	bf00      	nop
    939c:	200138d4 	.word	0x200138d4
    93a0:	00009365 	.word	0x00009365

000093a4 <tx_cb_USART_GRID_E>:
	tx_cb_USART_GRID(&GRID_PORT_E);
    93a4:	4801      	ldr	r0, [pc, #4]	; (93ac <tx_cb_USART_GRID_E+0x8>)
    93a6:	4b02      	ldr	r3, [pc, #8]	; (93b0 <tx_cb_USART_GRID_E+0xc>)
    93a8:	4718      	bx	r3
    93aa:	bf00      	nop
    93ac:	20019870 	.word	0x20019870
    93b0:	00009365 	.word	0x00009365

000093b4 <tx_cb_USART_GRID_N>:
	tx_cb_USART_GRID(&GRID_PORT_N);
    93b4:	4801      	ldr	r0, [pc, #4]	; (93bc <tx_cb_USART_GRID_N+0x8>)
    93b6:	4b02      	ldr	r3, [pc, #8]	; (93c0 <tx_cb_USART_GRID_N+0xc>)
    93b8:	4718      	bx	r3
    93ba:	bf00      	nop
    93bc:	20009150 	.word	0x20009150
    93c0:	00009365 	.word	0x00009365

000093c4 <err_cb_USART_GRID>:
	err_cb_USART_GRID(&GRID_PORT_W);
}


void err_cb_USART_GRID(struct grid_port* const por){
	por->usart_error_flag = 1;	
    93c4:	2301      	movs	r3, #1
    93c6:	7603      	strb	r3, [r0, #24]
	
	usart_async_disable(por->usart);
    93c8:	6840      	ldr	r0, [r0, #4]
    93ca:	4b01      	ldr	r3, [pc, #4]	; (93d0 <err_cb_USART_GRID+0xc>)
    93cc:	4718      	bx	r3
    93ce:	bf00      	nop
    93d0:	00010831 	.word	0x00010831

000093d4 <err_cb_USART_GRID_W>:
	err_cb_USART_GRID(&GRID_PORT_W);
    93d4:	4801      	ldr	r0, [pc, #4]	; (93dc <err_cb_USART_GRID_W+0x8>)
    93d6:	4b02      	ldr	r3, [pc, #8]	; (93e0 <err_cb_USART_GRID_W+0xc>)
    93d8:	4718      	bx	r3
    93da:	bf00      	nop
    93dc:	200102d4 	.word	0x200102d4
    93e0:	000093c5 	.word	0x000093c5

000093e4 <err_cb_USART_GRID_S>:
	err_cb_USART_GRID(&GRID_PORT_S);
    93e4:	4801      	ldr	r0, [pc, #4]	; (93ec <err_cb_USART_GRID_S+0x8>)
    93e6:	4b02      	ldr	r3, [pc, #8]	; (93f0 <err_cb_USART_GRID_S+0xc>)
    93e8:	4718      	bx	r3
    93ea:	bf00      	nop
    93ec:	200138d4 	.word	0x200138d4
    93f0:	000093c5 	.word	0x000093c5

000093f4 <err_cb_USART_GRID_E>:
	err_cb_USART_GRID(&GRID_PORT_E);
    93f4:	4801      	ldr	r0, [pc, #4]	; (93fc <err_cb_USART_GRID_E+0x8>)
    93f6:	4b02      	ldr	r3, [pc, #8]	; (9400 <err_cb_USART_GRID_E+0xc>)
    93f8:	4718      	bx	r3
    93fa:	bf00      	nop
    93fc:	20019870 	.word	0x20019870
    9400:	000093c5 	.word	0x000093c5

00009404 <err_cb_USART_GRID_N>:
	err_cb_USART_GRID(&GRID_PORT_N);
    9404:	4801      	ldr	r0, [pc, #4]	; (940c <err_cb_USART_GRID_N+0x8>)
    9406:	4b02      	ldr	r3, [pc, #8]	; (9410 <err_cb_USART_GRID_N+0xc>)
    9408:	4718      	bx	r3
    940a:	bf00      	nop
    940c:	20009150 	.word	0x20009150
    9410:	000093c5 	.word	0x000093c5

00009414 <grid_sys_port_reset_dma>:
#define DMA_SOUTH_RX_CHANNEL	2
#define DMA_WEST_RX_CHANNEL		3

void grid_sys_port_reset_dma(struct grid_port* por){
	
	hri_dmac_clear_CHCTRLA_ENABLE_bit(DMAC, por->dma_channel);
    9414:	7a80      	ldrb	r0, [r0, #10]
}

static inline void hri_dmac_clear_CHCTRLA_ENABLE_bit(const void *const hw, uint8_t submodule_index)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    9416:	0103      	lsls	r3, r0, #4
    9418:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    941c:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
	_dma_enable_transaction(por->dma_channel, false);
    9420:	2100      	movs	r1, #0
    9422:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    9424:	f022 0202 	bic.w	r2, r2, #2
    9428:	641a      	str	r2, [r3, #64]	; 0x40
    942a:	4b01      	ldr	r3, [pc, #4]	; (9430 <grid_sys_port_reset_dma+0x1c>)
    942c:	4718      	bx	r3
    942e:	bf00      	nop
    9430:	0000e295 	.word	0x0000e295

00009434 <dma_transfer_complete_n_cb>:
	grid_sys_port_reset_dma(por);
    9434:	4801      	ldr	r0, [pc, #4]	; (943c <dma_transfer_complete_n_cb+0x8>)
    9436:	4b02      	ldr	r3, [pc, #8]	; (9440 <dma_transfer_complete_n_cb+0xc>)
    9438:	4718      	bx	r3
    943a:	bf00      	nop
    943c:	20009150 	.word	0x20009150
    9440:	00009415 	.word	0x00009415

00009444 <dma_transfer_complete_e_cb>:
    9444:	4801      	ldr	r0, [pc, #4]	; (944c <dma_transfer_complete_e_cb+0x8>)
    9446:	4b02      	ldr	r3, [pc, #8]	; (9450 <dma_transfer_complete_e_cb+0xc>)
    9448:	4718      	bx	r3
    944a:	bf00      	nop
    944c:	20019870 	.word	0x20019870
    9450:	00009415 	.word	0x00009415

00009454 <dma_transfer_complete_s_cb>:
    9454:	4801      	ldr	r0, [pc, #4]	; (945c <dma_transfer_complete_s_cb+0x8>)
    9456:	4b02      	ldr	r3, [pc, #8]	; (9460 <dma_transfer_complete_s_cb+0xc>)
    9458:	4718      	bx	r3
    945a:	bf00      	nop
    945c:	200138d4 	.word	0x200138d4
    9460:	00009415 	.word	0x00009415

00009464 <dma_transfer_complete_w_cb>:
    9464:	4801      	ldr	r0, [pc, #4]	; (946c <dma_transfer_complete_w_cb+0x8>)
    9466:	4b02      	ldr	r3, [pc, #8]	; (9470 <dma_transfer_complete_w_cb+0xc>)
    9468:	4718      	bx	r3
    946a:	bf00      	nop
    946c:	200102d4 	.word	0x200102d4
    9470:	00009415 	.word	0x00009415

00009474 <grid_sys_uart_init>:

}


void grid_sys_uart_init(){
    9474:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    9478:	211c      	movs	r1, #28
    947a:	4c2c      	ldr	r4, [pc, #176]	; (952c <grid_sys_uart_init+0xb8>)
	gpio_set_pin_pull_mode(PC28, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC16, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC12, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PB09, GPIO_PULL_UP);
	
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    947c:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 9578 <grid_sys_uart_init+0x104>
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9480:	4f2b      	ldr	r7, [pc, #172]	; (9530 <grid_sys_uart_init+0xbc>)
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    9482:	4e2c      	ldr	r6, [pc, #176]	; (9534 <grid_sys_uart_init+0xc0>)
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    9484:	4d2c      	ldr	r5, [pc, #176]	; (9538 <grid_sys_uart_init+0xc4>)
			
	// Set parity for grid uart communication
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    9486:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 957c <grid_sys_uart_init+0x108>
    948a:	2002      	movs	r0, #2
    948c:	47a0      	blx	r4
    948e:	2110      	movs	r1, #16
    9490:	2002      	movs	r0, #2
    9492:	47a0      	blx	r4
    9494:	210c      	movs	r1, #12
    9496:	2002      	movs	r0, #2
    9498:	47a0      	blx	r4
    949a:	2109      	movs	r1, #9
    949c:	2001      	movs	r0, #1
    949e:	47a0      	blx	r4
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    94a0:	4c26      	ldr	r4, [pc, #152]	; (953c <grid_sys_uart_init+0xc8>)
    94a2:	4a27      	ldr	r2, [pc, #156]	; (9540 <grid_sys_uart_init+0xcc>)
    94a4:	2101      	movs	r1, #1
    94a6:	4640      	mov	r0, r8
    94a8:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    94aa:	4a26      	ldr	r2, [pc, #152]	; (9544 <grid_sys_uart_init+0xd0>)
    94ac:	2101      	movs	r1, #1
    94ae:	4638      	mov	r0, r7
    94b0:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    94b2:	4a25      	ldr	r2, [pc, #148]	; (9548 <grid_sys_uart_init+0xd4>)
    94b4:	2101      	movs	r1, #1
    94b6:	4630      	mov	r0, r6
    94b8:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    94ba:	4a24      	ldr	r2, [pc, #144]	; (954c <grid_sys_uart_init+0xd8>)
    94bc:	2101      	movs	r1, #1
    94be:	4628      	mov	r0, r5
    94c0:	47a0      	blx	r4
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    94c2:	2101      	movs	r1, #1
    94c4:	4640      	mov	r0, r8
    94c6:	47c8      	blx	r9
	usart_async_set_parity(&USART_EAST, USART_PARITY_ODD);	
    94c8:	2101      	movs	r1, #1
    94ca:	4638      	mov	r0, r7
    94cc:	47c8      	blx	r9
	usart_async_set_parity(&USART_SOUTH, USART_PARITY_ODD);
    94ce:	2101      	movs	r1, #1
    94d0:	4630      	mov	r0, r6
    94d2:	47c8      	blx	r9
	usart_async_set_parity(&USART_WEST, USART_PARITY_ODD);
    94d4:	2101      	movs	r1, #1
    94d6:	4628      	mov	r0, r5
    94d8:	47c8      	blx	r9
	
	// Set callback function for parity error
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_N);
    94da:	4a1d      	ldr	r2, [pc, #116]	; (9550 <grid_sys_uart_init+0xdc>)
    94dc:	2102      	movs	r1, #2
    94de:	4640      	mov	r0, r8
    94e0:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_E);
    94e2:	4a1c      	ldr	r2, [pc, #112]	; (9554 <grid_sys_uart_init+0xe0>)
    94e4:	2102      	movs	r1, #2
    94e6:	4638      	mov	r0, r7
    94e8:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_S);
    94ea:	4a1b      	ldr	r2, [pc, #108]	; (9558 <grid_sys_uart_init+0xe4>)
    94ec:	2102      	movs	r1, #2
    94ee:	4630      	mov	r0, r6
    94f0:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_W);
    94f2:	4a1a      	ldr	r2, [pc, #104]	; (955c <grid_sys_uart_init+0xe8>)
    94f4:	2102      	movs	r1, #2
    94f6:	4628      	mov	r0, r5
    94f8:	47a0      	blx	r4
// 	usart_async_register_callback(&USART_EAST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_E);
// 	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_RXC_CB, rx_cb_USART_GRID_S);
// 	usart_async_register_callback(&USART_WEST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_W);

	
	usart_async_get_io_descriptor(&USART_NORTH, &grid_sys_north_io);
    94fa:	4c19      	ldr	r4, [pc, #100]	; (9560 <grid_sys_uart_init+0xec>)
    94fc:	4919      	ldr	r1, [pc, #100]	; (9564 <grid_sys_uart_init+0xf0>)
    94fe:	4640      	mov	r0, r8
    9500:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_EAST,  &grid_sys_east_io);
    9502:	4919      	ldr	r1, [pc, #100]	; (9568 <grid_sys_uart_init+0xf4>)
    9504:	4638      	mov	r0, r7
    9506:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_SOUTH, &grid_sys_south_io);
    9508:	4918      	ldr	r1, [pc, #96]	; (956c <grid_sys_uart_init+0xf8>)
    950a:	4630      	mov	r0, r6
    950c:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_WEST,  &grid_sys_west_io);
    950e:	4918      	ldr	r1, [pc, #96]	; (9570 <grid_sys_uart_init+0xfc>)
    9510:	4628      	mov	r0, r5
    9512:	47a0      	blx	r4
	
	
	usart_async_enable(&USART_NORTH);
    9514:	4c17      	ldr	r4, [pc, #92]	; (9574 <grid_sys_uart_init+0x100>)
    9516:	4640      	mov	r0, r8
    9518:	47a0      	blx	r4
	usart_async_enable(&USART_EAST);
    951a:	4638      	mov	r0, r7
    951c:	47a0      	blx	r4
	usart_async_enable(&USART_SOUTH);
    951e:	4630      	mov	r0, r6
    9520:	47a0      	blx	r4
	usart_async_enable(&USART_WEST);
    9522:	4628      	mov	r0, r5
    9524:	4623      	mov	r3, r4




}
    9526:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	usart_async_enable(&USART_WEST);
    952a:	4718      	bx	r3
    952c:	00008d59 	.word	0x00008d59
    9530:	2001cdb0 	.word	0x2001cdb0
    9534:	2001cf08 	.word	0x2001cf08
    9538:	2001ceb8 	.word	0x2001ceb8
    953c:	00010881 	.word	0x00010881
    9540:	000093b5 	.word	0x000093b5
    9544:	000093a5 	.word	0x000093a5
    9548:	00009395 	.word	0x00009395
    954c:	00009385 	.word	0x00009385
    9550:	00009405 	.word	0x00009405
    9554:	000093f5 	.word	0x000093f5
    9558:	000093e5 	.word	0x000093e5
    955c:	000093d5 	.word	0x000093d5
    9560:	0001085d 	.word	0x0001085d
    9564:	2000f004 	.word	0x2000f004
    9568:	200138d0 	.word	0x200138d0
    956c:	20016820 	.word	0x20016820
    9570:	2001c850 	.word	0x2001c850
    9574:	00010805 	.word	0x00010805
    9578:	2001ce04 	.word	0x2001ce04
    957c:	000108e1 	.word	0x000108e1

00009580 <grid_sys_dma_rx_init_one>:



void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9580:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	
	uint8_t dma_rx_channel = por->dma_channel;
	
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9582:	6843      	ldr	r3, [r0, #4]
	uint8_t dma_rx_channel = por->dma_channel;
    9584:	7a84      	ldrb	r4, [r0, #10]
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9586:	460f      	mov	r7, r1
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9588:	6a19      	ldr	r1, [r3, #32]
    958a:	4b10      	ldr	r3, [pc, #64]	; (95cc <grid_sys_dma_rx_init_one+0x4c>)
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    958c:	4605      	mov	r5, r0
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    958e:	3128      	adds	r1, #40	; 0x28
    9590:	4620      	mov	r0, r4
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9592:	4616      	mov	r6, r2
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9594:	4798      	blx	r3
	_dma_set_destination_address(dma_rx_channel, (uint32_t *)por->rx_double_buffer);
    9596:	f505 519d 	add.w	r1, r5, #5024	; 0x13a0
    959a:	4b0d      	ldr	r3, [pc, #52]	; (95d0 <grid_sys_dma_rx_init_one+0x50>)
    959c:	3114      	adds	r1, #20
    959e:	4620      	mov	r0, r4
    95a0:	4798      	blx	r3
	_dma_set_data_amount(dma_rx_channel, (uint32_t)buffer_length);
    95a2:	4639      	mov	r1, r7
    95a4:	4b0b      	ldr	r3, [pc, #44]	; (95d4 <grid_sys_dma_rx_init_one+0x54>)
    95a6:	4620      	mov	r0, r4
    95a8:	4798      	blx	r3
	
	struct _dma_resource *resource_rx;
	_dma_get_channel_resource(&resource_rx, dma_rx_channel);
    95aa:	4621      	mov	r1, r4
    95ac:	4b0a      	ldr	r3, [pc, #40]	; (95d8 <grid_sys_dma_rx_init_one+0x58>)
    95ae:	a801      	add	r0, sp, #4
    95b0:	4798      	blx	r3
	
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    95b2:	9b01      	ldr	r3, [sp, #4]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    95b4:	2201      	movs	r2, #1
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    95b6:	601e      	str	r6, [r3, #0]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    95b8:	4620      	mov	r0, r4
    95ba:	4b08      	ldr	r3, [pc, #32]	; (95dc <grid_sys_dma_rx_init_one+0x5c>)
    95bc:	2100      	movs	r1, #0
    95be:	4798      	blx	r3
	
	//resource_rx->dma_cb.error         = function_cb;
	_dma_enable_transaction(dma_rx_channel, false);
    95c0:	4b07      	ldr	r3, [pc, #28]	; (95e0 <grid_sys_dma_rx_init_one+0x60>)
    95c2:	2100      	movs	r1, #0
    95c4:	4620      	mov	r0, r4
    95c6:	4798      	blx	r3
	

}
    95c8:	b003      	add	sp, #12
    95ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    95cc:	0000e225 	.word	0x0000e225
    95d0:	0000e215 	.word	0x0000e215
    95d4:	0000e251 	.word	0x0000e251
    95d8:	0000e2d1 	.word	0x0000e2d1
    95dc:	0000e1ed 	.word	0x0000e1ed
    95e0:	0000e295 	.word	0x0000e295

000095e4 <grid_sys_dma_rx_init>:

void grid_sys_dma_rx_init(){
    95e4:	b510      	push	{r4, lr}
	
	grid_sys_dma_rx_init_one(&GRID_PORT_N, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_n_cb);
    95e6:	4a10      	ldr	r2, [pc, #64]	; (9628 <grid_sys_dma_rx_init+0x44>)
    95e8:	4c10      	ldr	r4, [pc, #64]	; (962c <grid_sys_dma_rx_init+0x48>)
    95ea:	4811      	ldr	r0, [pc, #68]	; (9630 <grid_sys_dma_rx_init+0x4c>)
    95ec:	f241 3188 	movw	r1, #5000	; 0x1388
    95f0:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_E, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_e_cb);
    95f2:	4a10      	ldr	r2, [pc, #64]	; (9634 <grid_sys_dma_rx_init+0x50>)
    95f4:	4810      	ldr	r0, [pc, #64]	; (9638 <grid_sys_dma_rx_init+0x54>)
    95f6:	f241 3188 	movw	r1, #5000	; 0x1388
    95fa:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_S, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_s_cb);
    95fc:	4a0f      	ldr	r2, [pc, #60]	; (963c <grid_sys_dma_rx_init+0x58>)
    95fe:	4810      	ldr	r0, [pc, #64]	; (9640 <grid_sys_dma_rx_init+0x5c>)
    9600:	f241 3188 	movw	r1, #5000	; 0x1388
    9604:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_W, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_w_cb);
    9606:	4a0f      	ldr	r2, [pc, #60]	; (9644 <grid_sys_dma_rx_init+0x60>)
    9608:	480f      	ldr	r0, [pc, #60]	; (9648 <grid_sys_dma_rx_init+0x64>)
    960a:	f241 3188 	movw	r1, #5000	; 0x1388
    960e:	47a0      	blx	r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9610:	4b0e      	ldr	r3, [pc, #56]	; (964c <grid_sys_dma_rx_init+0x68>)
    9612:	2200      	movs	r2, #0
    9614:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
    9618:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
    961c:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
    9620:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
	NVIC_SetPriority(DMAC_0_IRQn, 0);
	NVIC_SetPriority(DMAC_1_IRQn, 0);
	NVIC_SetPriority(DMAC_2_IRQn, 0);
	NVIC_SetPriority(DMAC_3_IRQn, 0);
	
}
    9624:	bd10      	pop	{r4, pc}
    9626:	bf00      	nop
    9628:	00009435 	.word	0x00009435
    962c:	00009581 	.word	0x00009581
    9630:	20009150 	.word	0x20009150
    9634:	00009445 	.word	0x00009445
    9638:	20019870 	.word	0x20019870
    963c:	00009455 	.word	0x00009455
    9640:	200138d4 	.word	0x200138d4
    9644:	00009465 	.word	0x00009465
    9648:	200102d4 	.word	0x200102d4
    964c:	e000e100 	.word	0xe000e100

00009650 <grid_sys_init>:
	return tmp;
}

static inline hri_rstc_rcause_reg_t hri_rstc_read_RCAUSE_reg(const void *const hw)
{
	return ((Rstc *)hw)->RCAUSE.reg;
    9650:	4b16      	ldr	r3, [pc, #88]	; (96ac <grid_sys_init+0x5c>)

void grid_sys_init(struct grid_sys_model* mod){
    9652:	b570      	push	{r4, r5, r6, lr}
    9654:	781b      	ldrb	r3, [r3, #0]
	
	mod->uptime = 0;
	mod->reset_cause = hri_rstc_read_RCAUSE_reg(RSTC);
    9656:	7103      	strb	r3, [r0, #4]
	mod->uptime = 0;
    9658:	2500      	movs	r5, #0
void grid_sys_init(struct grid_sys_model* mod){
    965a:	4604      	mov	r4, r0
	mod->uptime = 0;
    965c:	6005      	str	r5, [r0, #0]
	
    
	mod->sessionid = rand_sync_read8(&RAND_0);
    965e:	4b14      	ldr	r3, [pc, #80]	; (96b0 <grid_sys_init+0x60>)
    9660:	4814      	ldr	r0, [pc, #80]	; (96b4 <grid_sys_init+0x64>)
    9662:	4798      	blx	r3
	mod->bank_color_r[3] = 100;
	mod->bank_color_g[3] = 0;
	mod->bank_color_b[3] = 200;
	
	mod->bank_enabled[0] = 1;
	mod->bank_enabled[1] = 1;
    9664:	4a14      	ldr	r2, [pc, #80]	; (96b8 <grid_sys_init+0x68>)
    9666:	4b15      	ldr	r3, [pc, #84]	; (96bc <grid_sys_init+0x6c>)
	mod->bank_color_g[1] = 100;
    9668:	4915      	ldr	r1, [pc, #84]	; (96c0 <grid_sys_init+0x70>)
	mod->sessionid = rand_sync_read8(&RAND_0);
    966a:	7160      	strb	r0, [r4, #5]
	mod->bank_enabled[1] = 1;
    966c:	e9c4 2304 	strd	r2, r3, [r4, #16]
	mod->bank_color_g[1] = 100;
    9670:	4b14      	ldr	r3, [pc, #80]	; (96c4 <grid_sys_init+0x74>)
	mod->bank_setting_changed_flag = 0;
	
	mod->bank_init_flag = 0;


	mod->bank_activebank_number = 0;
    9672:	73e5      	strb	r5, [r4, #15]
	mod->bank_color_g[1] = 100;
    9674:	e9c4 1306 	strd	r1, r3, [r4, #24]
	mod->bank_color_b[1] = 0;
    9678:	f44f 5348 	mov.w	r3, #12800	; 0x3200
    967c:	8423      	strh	r3, [r4, #32]
	mod->bank_color_b[3] = 200;
    967e:	23c8      	movs	r3, #200	; 0xc8
    9680:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	if (banknumber == 255){
			
		//mod->bank_activebank_number = 0;
		mod->bank_activebank_valid = 0;
		
		mod->bank_active_changed = 1;
    9684:	4b10      	ldr	r3, [pc, #64]	; (96c8 <grid_sys_init+0x78>)
	mod->bank_activebank_color_r = 0;
    9686:	6265      	str	r5, [r4, #36]	; 0x24
		mod->bank_active_changed = 1;
    9688:	2201      	movs	r2, #1
    968a:	745a      	strb	r2, [r3, #17]
				
		mod->bank_activebank_color_r = 127;
    968c:	f647 727f 	movw	r2, #32639	; 0x7f7f
		mod->bank_activebank_valid = 0;
    9690:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9694:	849a      	strh	r2, [r3, #36]	; 0x24
		mod->bank_activebank_color_g = 127;
		mod->bank_activebank_color_b = 127;
    9696:	227f      	movs	r2, #127	; 0x7f
    9698:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	grid_port_init_all();
    969c:	4b0b      	ldr	r3, [pc, #44]	; (96cc <grid_sys_init+0x7c>)
    969e:	4798      	blx	r3
	grid_sys_uart_init();
    96a0:	4b0b      	ldr	r3, [pc, #44]	; (96d0 <grid_sys_init+0x80>)
    96a2:	4798      	blx	r3
}
    96a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	grid_sys_dma_rx_init();
    96a8:	4b0a      	ldr	r3, [pc, #40]	; (96d4 <grid_sys_init+0x84>)
    96aa:	4718      	bx	r3
    96ac:	40000c00 	.word	0x40000c00
    96b0:	0000e805 	.word	0x0000e805
    96b4:	2001cd7c 	.word	0x2001cd7c
    96b8:	01000001 	.word	0x01000001
    96bc:	00010101 	.word	0x00010101
    96c0:	646432c8 	.word	0x646432c8
    96c4:	c800c864 	.word	0xc800c864
    96c8:	2000f008 	.word	0x2000f008
    96cc:	00005165 	.word	0x00005165
    96d0:	00009475 	.word	0x00009475
    96d4:	000095e5 	.word	0x000095e5

000096d8 <grid_sys_bank_enable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    96d8:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 1;
    96da:	bf9e      	ittt	ls
    96dc:	1809      	addls	r1, r1, r0
    96de:	2301      	movls	r3, #1
    96e0:	74cb      	strbls	r3, [r1, #19]
}
    96e2:	4770      	bx	lr

000096e4 <grid_sys_bank_disable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    96e4:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 0;
    96e6:	bf9e      	ittt	ls
    96e8:	1809      	addls	r1, r1, r0
    96ea:	2300      	movls	r3, #0
    96ec:	74cb      	strbls	r3, [r1, #19]
}
    96ee:	4770      	bx	lr

000096f0 <grid_sys_bank_set_color>:
	if (banknumber>GRID_SYS_BANK_MAXNUMBER){
    96f0:	2904      	cmp	r1, #4
    96f2:	d901      	bls.n	96f8 <grid_sys_bank_set_color+0x8>
		return false;
    96f4:	2000      	movs	r0, #0
    96f6:	4770      	bx	lr
	mod->bank_color_r[banknumber] = ((rgb&0x00FF0000)>>16);
    96f8:	4401      	add	r1, r0
    96fa:	0c13      	lsrs	r3, r2, #16
    96fc:	75cb      	strb	r3, [r1, #23]
	mod->bank_color_g[banknumber] = ((rgb&0x0000FF00)>>8);
    96fe:	0a13      	lsrs	r3, r2, #8
    9700:	76cb      	strb	r3, [r1, #27]
	mod->bank_color_b[banknumber] = ((rgb&0x000000FF)>>0);
    9702:	77ca      	strb	r2, [r1, #31]
}
    9704:	4770      	bx	lr

00009706 <grid_sys_get_bank_num>:
}
    9706:	7bc0      	ldrb	r0, [r0, #15]
    9708:	4770      	bx	lr

0000970a <grid_sys_get_bank_valid>:
}
    970a:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
    970e:	4770      	bx	lr

00009710 <grid_sys_get_bank_red>:
}
    9710:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    9714:	4770      	bx	lr

00009716 <grid_sys_get_bank_gre>:
}
    9716:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
    971a:	4770      	bx	lr

0000971c <grid_sys_get_bank_blu>:
}
    971c:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
    9720:	4770      	bx	lr

00009722 <grid_sys_get_map_state>:
}
    9722:	7c00      	ldrb	r0, [r0, #16]
    9724:	4770      	bx	lr

00009726 <grid_sys_get_bank_next>:
uint8_t grid_sys_get_bank_next(struct grid_sys_model* mod){
    9726:	b530      	push	{r4, r5, lr}
    9728:	4602      	mov	r2, r0
	return mod->bank_activebank_number;
    972a:	7bc0      	ldrb	r0, [r0, #15]
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    972c:	1c43      	adds	r3, r0, #1
    972e:	1d44      	adds	r4, r0, #5
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    9730:	f003 0103 	and.w	r1, r3, #3
		if (mod->bank_enabled[bank_check] == 1){
    9734:	1855      	adds	r5, r2, r1
    9736:	7ced      	ldrb	r5, [r5, #19]
    9738:	2d01      	cmp	r5, #1
    973a:	d003      	beq.n	9744 <grid_sys_get_bank_next+0x1e>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    973c:	3301      	adds	r3, #1
    973e:	42a3      	cmp	r3, r4
    9740:	d1f6      	bne.n	9730 <grid_sys_get_bank_next+0xa>
}
    9742:	bd30      	pop	{r4, r5, pc}
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    9744:	b2c8      	uxtb	r0, r1
    9746:	e7fc      	b.n	9742 <grid_sys_get_bank_next+0x1c>

00009748 <grid_sys_get_bank_number_of_first_valid>:
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9748:	f100 0213 	add.w	r2, r0, #19
uint8_t grid_sys_get_bank_number_of_first_valid(struct grid_sys_model* mod){
    974c:	2300      	movs	r3, #0
		if (mod->bank_enabled[i] == 1){
    974e:	f812 1b01 	ldrb.w	r1, [r2], #1
    9752:	2901      	cmp	r1, #1
    9754:	b2d8      	uxtb	r0, r3
    9756:	d003      	beq.n	9760 <grid_sys_get_bank_number_of_first_valid+0x18>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9758:	3301      	adds	r3, #1
    975a:	2b04      	cmp	r3, #4
    975c:	d1f7      	bne.n	974e <grid_sys_get_bank_number_of_first_valid+0x6>
	return 255;
    975e:	20ff      	movs	r0, #255	; 0xff
}
    9760:	4770      	bx	lr

00009762 <grid_sys_set_bank>:
	if (banknumber == 255){
    9762:	29ff      	cmp	r1, #255	; 0xff
    9764:	d10b      	bne.n	977e <grid_sys_set_bank+0x1c>
		mod->bank_active_changed = 1;
    9766:	2301      	movs	r3, #1
    9768:	7443      	strb	r3, [r0, #17]
		mod->bank_activebank_valid = 0;
    976a:	2300      	movs	r3, #0
    976c:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9770:	f647 737f 	movw	r3, #32639	; 0x7f7f
    9774:	8483      	strh	r3, [r0, #36]	; 0x24
		mod->bank_activebank_color_b = 127;
    9776:	237f      	movs	r3, #127	; 0x7f
			
			mod->bank_active_changed = 1;
			
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    9778:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
		//grid_debug_print_text("Invalid Bank Number");	
				
	}

	
}
    977c:	4770      	bx	lr
	else if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    977e:	2903      	cmp	r1, #3
    9780:	d8fc      	bhi.n	977c <grid_sys_set_bank+0x1a>
		mod->bank_init_flag = 1;
    9782:	2301      	movs	r3, #1
    9784:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
		if (mod->bank_enabled[banknumber] == 1){
    9788:	1843      	adds	r3, r0, r1
    978a:	7cda      	ldrb	r2, [r3, #19]
    978c:	2a01      	cmp	r2, #1
    978e:	d1f5      	bne.n	977c <grid_sys_set_bank+0x1a>
			mod->bank_activebank_number = banknumber;
    9790:	73c1      	strb	r1, [r0, #15]
			mod->bank_activebank_valid = 1;
    9792:	f880 2023 	strb.w	r2, [r0, #35]	; 0x23
			mod->bank_active_changed = 1;
    9796:	7442      	strb	r2, [r0, #17]
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
    9798:	7dda      	ldrb	r2, [r3, #23]
    979a:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
    979e:	7eda      	ldrb	r2, [r3, #27]
    97a0:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    97a4:	7fdb      	ldrb	r3, [r3, #31]
    97a6:	e7e7      	b.n	9778 <grid_sys_set_bank+0x16>

000097a8 <grid_sys_rtc_get_time>:

// REALTIME

uint32_t grid_sys_rtc_get_time(struct grid_sys_model* mod){
	return mod->realtime;
}
    97a8:	6a80      	ldr	r0, [r0, #40]	; 0x28
    97aa:	4770      	bx	lr

000097ac <grid_sys_rtc_get_elapsed_time>:
	mod->realtime = tvalue;
}

uint32_t grid_sys_rtc_get_elapsed_time(struct grid_sys_model* mod, uint32_t t_old){
	
	return mod->realtime-t_old;
    97ac:	6a80      	ldr	r0, [r0, #40]	; 0x28
	
	

}
    97ae:	1a40      	subs	r0, r0, r1
    97b0:	4770      	bx	lr

000097b2 <grid_sys_rtc_tick_time>:

void grid_sys_rtc_tick_time(struct grid_sys_model* mod){
	
	mod->realtime++;
    97b2:	6a83      	ldr	r3, [r0, #40]	; 0x28
    97b4:	3301      	adds	r3, #1
    97b6:	6283      	str	r3, [r0, #40]	; 0x28
	if (mod->uptime != -1){
    97b8:	6803      	ldr	r3, [r0, #0]
    97ba:	1c5a      	adds	r2, r3, #1
		mod->uptime++;
    97bc:	bf1c      	itt	ne
    97be:	3301      	addne	r3, #1
    97c0:	6003      	strne	r3, [r0, #0]
	}
	
}
    97c2:	4770      	bx	lr

000097c4 <grid_sys_alert_read_color_changed_flag>:

uint8_t grid_sys_alert_read_color_changed_flag(struct grid_sys_model* mod){
		
	return mod->alert_color_changed;
	
}
    97c4:	7b80      	ldrb	r0, [r0, #14]
    97c6:	4770      	bx	lr

000097c8 <grid_sys_alert_clear_color_changed_flag>:
	
}

void grid_sys_alert_clear_color_changed_flag(struct grid_sys_model* mod){
	
	mod->alert_color_changed = 0;
    97c8:	2300      	movs	r3, #0
    97ca:	7383      	strb	r3, [r0, #14]
	
}
    97cc:	4770      	bx	lr

000097ce <grid_sys_alert_get_color_intensity>:

uint8_t grid_sys_alert_get_color_intensity(struct grid_sys_model* mod){
	
	if (mod->alert_style == 0){ // TRIANGLE
    97ce:	7b03      	ldrb	r3, [r0, #12]
    97d0:	b963      	cbnz	r3, 97ec <grid_sys_alert_get_color_intensity+0x1e>
		
		return (250-abs(mod->alert_state/2-250))/2;
    97d2:	8940      	ldrh	r0, [r0, #10]
    97d4:	0840      	lsrs	r0, r0, #1
    97d6:	38fa      	subs	r0, #250	; 0xfa
    97d8:	2800      	cmp	r0, #0
    97da:	bfb8      	it	lt
    97dc:	4240      	neglt	r0, r0
    97de:	f1c0 00fa 	rsb	r0, r0, #250	; 0xfa
    97e2:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    97e6:	f3c0 0047 	ubfx	r0, r0, #1, #8
    97ea:	4770      	bx	lr
	}
	else if (mod->alert_style == 1){ // SQUARE
    97ec:	2b01      	cmp	r3, #1
    97ee:	d107      	bne.n	9800 <grid_sys_alert_get_color_intensity+0x32>
		
		return 255*(mod->alert_state/250%2);
    97f0:	8940      	ldrh	r0, [r0, #10]
    97f2:	23fa      	movs	r3, #250	; 0xfa
    97f4:	fbb0 f0f3 	udiv	r0, r0, r3
    97f8:	f340 0000 	sbfx	r0, r0, #0, #1
    97fc:	b2c0      	uxtb	r0, r0
    97fe:	4770      	bx	lr
	}
	else if (mod->alert_style == 2){ // CONST
    9800:	2b02      	cmp	r3, #2
    9802:	d105      	bne.n	9810 <grid_sys_alert_get_color_intensity+0x42>
		
		return 255*(mod->alert_state>100);
    9804:	8940      	ldrh	r0, [r0, #10]
    9806:	2864      	cmp	r0, #100	; 0x64
    9808:	bf8c      	ite	hi
    980a:	20ff      	movhi	r0, #255	; 0xff
    980c:	2000      	movls	r0, #0
    980e:	4770      	bx	lr
	}
	
	
}
    9810:	4770      	bx	lr

00009812 <grid_sys_alert_set_alert>:
	mod->alert_color_green = green;
	mod->alert_color_blue = blue;
		
}

void grid_sys_alert_set_alert(struct grid_sys_model* mod, uint8_t red, uint8_t green, uint8_t blue, uint8_t style, uint16_t duration){
    9812:	b510      	push	{r4, lr}
	mod->alert_color_blue = blue;
    9814:	7203      	strb	r3, [r0, #8]
	
	grid_sys_alert_set_color(mod, red, green, blue);

	
	mod->alert_state = duration;
    9816:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    981a:	8143      	strh	r3, [r0, #10]
	mod->alert_color_changed = 1;
    981c:	2401      	movs	r4, #1
	mod->alert_style = style;
    981e:	f89d 3008 	ldrb.w	r3, [sp, #8]
	mod->alert_color_changed = 1;
    9822:	7384      	strb	r4, [r0, #14]
	mod->alert_color_red = red;
    9824:	7181      	strb	r1, [r0, #6]
	mod->alert_color_green = green;
    9826:	71c2      	strb	r2, [r0, #7]
	mod->alert_style = style;
    9828:	7303      	strb	r3, [r0, #12]
	
}
    982a:	bd10      	pop	{r4, pc}

0000982c <grid_sys_alert_get_color_r>:

uint8_t grid_sys_alert_get_color_r(struct grid_sys_model* mod){
	
	return mod->alert_color_red;
}
    982c:	7980      	ldrb	r0, [r0, #6]
    982e:	4770      	bx	lr

00009830 <grid_sys_alert_get_color_g>:

uint8_t grid_sys_alert_get_color_g(struct grid_sys_model* mod){
	
	return mod->alert_color_green;
}
    9830:	79c0      	ldrb	r0, [r0, #7]
    9832:	4770      	bx	lr

00009834 <grid_sys_alert_get_color_b>:

uint8_t grid_sys_alert_get_color_b(struct grid_sys_model* mod){
	
	return mod->alert_color_blue;
}
    9834:	7a00      	ldrb	r0, [r0, #8]
    9836:	4770      	bx	lr

00009838 <grid_sys_read_hex_char_value>:

uint8_t grid_sys_read_hex_char_value(uint8_t ascii, uint8_t* error_flag){
		
	uint8_t result = 0;
	
	if (ascii>47 && ascii<58){
    9838:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    983c:	b2db      	uxtb	r3, r3
    983e:	2b09      	cmp	r3, #9
    9840:	d905      	bls.n	984e <grid_sys_read_hex_char_value+0x16>
		result = ascii-48;
	}
	else if(ascii>96 && ascii<103){
    9842:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
    9846:	2b05      	cmp	r3, #5
    9848:	d803      	bhi.n	9852 <grid_sys_read_hex_char_value+0x1a>
		result = ascii - 97 + 10;
    984a:	3857      	subs	r0, #87	; 0x57
    984c:	b2c3      	uxtb	r3, r0
			*error_flag = ascii;
		}
	}
	
	return result;	
}
    984e:	4618      	mov	r0, r3
    9850:	4770      	bx	lr
		if (error_flag != NULL){
    9852:	b111      	cbz	r1, 985a <grid_sys_read_hex_char_value+0x22>
			*error_flag = ascii;
    9854:	7008      	strb	r0, [r1, #0]
	uint8_t result = 0;
    9856:	2300      	movs	r3, #0
    9858:	e7f9      	b.n	984e <grid_sys_read_hex_char_value+0x16>
    985a:	460b      	mov	r3, r1
    985c:	e7f7      	b.n	984e <grid_sys_read_hex_char_value+0x16>
	...

00009860 <grid_sys_read_hex_string_value>:

uint32_t grid_sys_read_hex_string_value(uint8_t* start_location, uint8_t length, uint8_t* error_flag){
    9860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	uint32_t result  = 0;
	
	for(uint8_t i=0; i<length; i++){
		
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    9862:	4f08      	ldr	r7, [pc, #32]	; (9884 <grid_sys_read_hex_string_value+0x24>)
    9864:	1e45      	subs	r5, r0, #1
    9866:	008c      	lsls	r4, r1, #2
	uint32_t result  = 0;
    9868:	2600      	movs	r6, #0
	for(uint8_t i=0; i<length; i++){
    986a:	3c04      	subs	r4, #4
    986c:	1d23      	adds	r3, r4, #4
    986e:	d101      	bne.n	9874 <grid_sys_read_hex_string_value+0x14>

		
	}

	return result;
}
    9870:	4630      	mov	r0, r6
    9872:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    9874:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    9878:	4611      	mov	r1, r2
    987a:	47b8      	blx	r7
    987c:	40a0      	lsls	r0, r4
    987e:	4406      	add	r6, r0
	for(uint8_t i=0; i<length; i++){
    9880:	e7f3      	b.n	986a <grid_sys_read_hex_string_value+0xa>
    9882:	bf00      	nop
    9884:	00009839 	.word	0x00009839

00009888 <grid_sys_write_hex_string_value>:

void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    9888:	b530      	push	{r4, r5, lr}
    988a:	b085      	sub	sp, #20
	
	uint8_t str[10];
	
	sprintf(str, "%08x", value);
    988c:	4b0a      	ldr	r3, [pc, #40]	; (98b8 <grid_sys_write_hex_string_value+0x30>)
void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    988e:	460c      	mov	r4, r1
    9890:	4605      	mov	r5, r0
	sprintf(str, "%08x", value);
    9892:	490a      	ldr	r1, [pc, #40]	; (98bc <grid_sys_write_hex_string_value+0x34>)
    9894:	a801      	add	r0, sp, #4
    9896:	4798      	blx	r3
		
	for(uint8_t i=0; i<size; i++){	
    9898:	aa01      	add	r2, sp, #4
    989a:	f1c4 0308 	rsb	r3, r4, #8
    989e:	4413      	add	r3, r2
    98a0:	2200      	movs	r2, #0
    98a2:	b2d1      	uxtb	r1, r2
    98a4:	428c      	cmp	r4, r1
    98a6:	d801      	bhi.n	98ac <grid_sys_write_hex_string_value+0x24>
		start_location[i] = str[8-size+i];	
	}

}
    98a8:	b005      	add	sp, #20
    98aa:	bd30      	pop	{r4, r5, pc}
		start_location[i] = str[8-size+i];	
    98ac:	f813 1b01 	ldrb.w	r1, [r3], #1
    98b0:	54a9      	strb	r1, [r5, r2]
	for(uint8_t i=0; i<size; i++){	
    98b2:	3201      	adds	r2, #1
    98b4:	e7f5      	b.n	98a2 <grid_sys_write_hex_string_value+0x1a>
    98b6:	bf00      	nop
    98b8:	00014ac5 	.word	0x00014ac5
    98bc:	00016d35 	.word	0x00016d35

000098c0 <grid_sys_get_id>:



uint32_t grid_sys_get_id(uint32_t* return_array){
			
	return_array[0] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_0);
    98c0:	4b06      	ldr	r3, [pc, #24]	; (98dc <grid_sys_get_id+0x1c>)
    98c2:	681b      	ldr	r3, [r3, #0]
    98c4:	6003      	str	r3, [r0, #0]
	return_array[1] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_1);
    98c6:	4b06      	ldr	r3, [pc, #24]	; (98e0 <grid_sys_get_id+0x20>)
    98c8:	681b      	ldr	r3, [r3, #0]
    98ca:	6043      	str	r3, [r0, #4]
	return_array[2] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_2);
    98cc:	4b05      	ldr	r3, [pc, #20]	; (98e4 <grid_sys_get_id+0x24>)
    98ce:	681b      	ldr	r3, [r3, #0]
    98d0:	6083      	str	r3, [r0, #8]
	return_array[3] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_3);
    98d2:	4b05      	ldr	r3, [pc, #20]	; (98e8 <grid_sys_get_id+0x28>)
    98d4:	681b      	ldr	r3, [r3, #0]
    98d6:	60c3      	str	r3, [r0, #12]
	
	return 1;
	
}
    98d8:	2001      	movs	r0, #1
    98da:	4770      	bx	lr
    98dc:	008061fc 	.word	0x008061fc
    98e0:	00806010 	.word	0x00806010
    98e4:	00806014 	.word	0x00806014
    98e8:	00806018 	.word	0x00806018

000098ec <grid_sys_get_hwcfg>:

uint32_t grid_sys_get_hwcfg(){
    98ec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	// Read the register for the first time, then later just return the saved value

	if (grid_sys_hwfcg == -1){
    98f0:	4e30      	ldr	r6, [pc, #192]	; (99b4 <grid_sys_get_hwcfg+0xc8>)
    98f2:	6833      	ldr	r3, [r6, #0]
    98f4:	3301      	adds	r3, #1
    98f6:	d158      	bne.n	99aa <grid_sys_get_hwcfg+0xbe>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    98f8:	4c2f      	ldr	r4, [pc, #188]	; (99b8 <grid_sys_get_hwcfg+0xcc>)
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    98fa:	4b30      	ldr	r3, [pc, #192]	; (99bc <grid_sys_get_hwcfg+0xd0>)
		gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
		gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
			
		// LOAD DATA
		gpio_set_pin_level(HWCFG_SHIFT, 0);
		delay_ms(1);
    98fc:	4f30      	ldr	r7, [pc, #192]	; (99c0 <grid_sys_get_hwcfg+0xd4>)
	CRITICAL_SECTION_ENTER();
    98fe:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 99cc <grid_sys_get_hwcfg+0xe0>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9902:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    9906:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    990a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    990e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9912:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    9916:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    991a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    991e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    9922:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
    9926:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    992a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    992e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9932:	4b24      	ldr	r3, [pc, #144]	; (99c4 <grid_sys_get_hwcfg+0xd8>)
    9934:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9938:	f1a3 2380 	sub.w	r3, r3, #2147516416	; 0x80008000
    993c:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9940:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9942:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    9946:	47b8      	blx	r7
    9948:	f04f 0a00 	mov.w	sl, #0
			
			
			
		uint8_t hwcfg_value = 0;
    994c:	46d3      	mov	fp, sl
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    994e:	46a8      	mov	r8, r5
			
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
				
			// SHIFT DATA
			gpio_set_pin_level(HWCFG_SHIFT, 1); //This outputs the first value to HWCFG_DATA
			delay_ms(1);
    9950:	2001      	movs	r0, #1
    9952:	f8c4 8098 	str.w	r8, [r4, #152]	; 0x98
    9956:	47b8      	blx	r7
    9958:	a801      	add	r0, sp, #4
    995a:	47c8      	blx	r9
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    995c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    9960:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    9964:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    9968:	405d      	eors	r5, r3
    996a:	4015      	ands	r5, r2
    996c:	405d      	eors	r5, r3
	CRITICAL_SECTION_LEAVE();
    996e:	a801      	add	r0, sp, #4
    9970:	4b15      	ldr	r3, [pc, #84]	; (99c8 <grid_sys_get_hwcfg+0xdc>)
    9972:	4798      	blx	r3
				
				
			if(gpio_get_pin_level(HWCFG_DATA)){
    9974:	042b      	lsls	r3, r5, #16
					
				hwcfg_value |= (1<<i);
    9976:	bf41      	itttt	mi
    9978:	2301      	movmi	r3, #1
    997a:	fa03 f30a 	lslmi.w	r3, r3, sl
    997e:	ea43 0b0b 	orrmi.w	fp, r3, fp
    9982:	fa5f fb8b 	uxtbmi.w	fp, fp
				}else{
					
					
			}
				
			if(i!=7){
    9986:	f1ba 0f07 	cmp.w	sl, #7
    998a:	d007      	beq.n	999c <grid_sys_get_hwcfg+0xb0>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    998c:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    9990:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
					
				// Clock rise
				gpio_set_pin_level(HWCFG_CLOCK, 1);
					
				delay_ms(1);
    9994:	2001      	movs	r0, #1
    9996:	47b8      	blx	r7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9998:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
    999c:	f10a 0a01 	add.w	sl, sl, #1
    99a0:	f1ba 0f08 	cmp.w	sl, #8
    99a4:	d1d4      	bne.n	9950 <grid_sys_get_hwcfg+0x64>
				gpio_set_pin_level(HWCFG_CLOCK, 0);
			}
							
		}
		
		grid_sys_hwfcg = hwcfg_value;
    99a6:	f8c6 b000 	str.w	fp, [r6]
	}

	
	return grid_sys_hwfcg;

}
    99aa:	6830      	ldr	r0, [r6, #0]
    99ac:	b003      	add	sp, #12
    99ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    99b2:	bf00      	nop
    99b4:	2000034c 	.word	0x2000034c
    99b8:	41008000 	.word	0x41008000
    99bc:	40002000 	.word	0x40002000
    99c0:	0000dddd 	.word	0x0000dddd
    99c4:	40028000 	.word	0x40028000
    99c8:	00011b67 	.word	0x00011b67
    99cc:	00011b59 	.word	0x00011b59

000099d0 <grid_msg_calculate_checksum_of_packet_string>:
	grid_sys_ping(&GRID_PORT_S);
	grid_sys_ping(&GRID_PORT_W);
	
}

uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    99d0:	b510      	push	{r4, lr}
	
	uint8_t checksum = 0;
	for (uint32_t i=0; i<length-3; i++){
    99d2:	2300      	movs	r3, #0
uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    99d4:	4602      	mov	r2, r0
	for (uint32_t i=0; i<length-3; i++){
    99d6:	3903      	subs	r1, #3
	uint8_t checksum = 0;
    99d8:	4618      	mov	r0, r3
	for (uint32_t i=0; i<length-3; i++){
    99da:	4299      	cmp	r1, r3
    99dc:	d800      	bhi.n	99e0 <grid_msg_calculate_checksum_of_packet_string+0x10>
		checksum ^= str[i];
	}
	
	return checksum;
	
}
    99de:	bd10      	pop	{r4, pc}
		checksum ^= str[i];
    99e0:	5cd4      	ldrb	r4, [r2, r3]
	for (uint32_t i=0; i<length-3; i++){
    99e2:	3301      	adds	r3, #1
		checksum ^= str[i];
    99e4:	4060      	eors	r0, r4
	for (uint32_t i=0; i<length-3; i++){
    99e6:	e7f8      	b.n	99da <grid_msg_calculate_checksum_of_packet_string+0xa>

000099e8 <grid_msg_checksum_read>:
	return checksum;
	
}


uint8_t grid_msg_checksum_read(uint8_t* str, uint32_t length){
    99e8:	b507      	push	{r0, r1, r2, lr}
	uint8_t error_flag;
	return grid_sys_read_hex_string_value(&str[length-3], 2, &error_flag);
    99ea:	1ecb      	subs	r3, r1, #3
    99ec:	f10d 0207 	add.w	r2, sp, #7
    99f0:	2102      	movs	r1, #2
    99f2:	4418      	add	r0, r3
    99f4:	4b02      	ldr	r3, [pc, #8]	; (9a00 <grid_msg_checksum_read+0x18>)
    99f6:	4798      	blx	r3
}
    99f8:	b2c0      	uxtb	r0, r0
    99fa:	b003      	add	sp, #12
    99fc:	f85d fb04 	ldr.w	pc, [sp], #4
    9a00:	00009861 	.word	0x00009861

00009a04 <grid_msg_checksum_write>:
// 	sprintf(checksum_string, "%02x", checksum);
// 
// 	message[length-3] = checksum_string[0];
// 	message[length-2] = checksum_string[1];
	
	grid_sys_write_hex_string_value(&message[length-3], 2, checksum);
    9a04:	1ecb      	subs	r3, r1, #3
    9a06:	4418      	add	r0, r3
    9a08:	2102      	movs	r1, #2
    9a0a:	4b01      	ldr	r3, [pc, #4]	; (9a10 <grid_msg_checksum_write+0xc>)
    9a0c:	4718      	bx	r3
    9a0e:	bf00      	nop
    9a10:	00009889 	.word	0x00009889

00009a14 <grid_msg_get_parameter>:
}


// MESSAGE PARAMETER FUNCTIONS

uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    9a14:	b410      	push	{r4}
    9a16:	460c      	mov	r4, r1
		
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    9a18:	4420      	add	r0, r4
uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    9a1a:	4611      	mov	r1, r2
}
    9a1c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    9a20:	461a      	mov	r2, r3
    9a22:	4b01      	ldr	r3, [pc, #4]	; (9a28 <grid_msg_get_parameter+0x14>)
    9a24:	4718      	bx	r3
    9a26:	bf00      	nop
    9a28:	00009861 	.word	0x00009861

00009a2c <grid_msg_set_parameter>:

uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    9a2c:	b510      	push	{r4, lr}
    9a2e:	460c      	mov	r4, r1
	
	grid_sys_write_hex_string_value(&message[offset], length, value);
    9a30:	4420      	add	r0, r4
uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    9a32:	4611      	mov	r1, r2
	grid_sys_write_hex_string_value(&message[offset], length, value);
    9a34:	461a      	mov	r2, r3
    9a36:	4b01      	ldr	r3, [pc, #4]	; (9a3c <grid_msg_set_parameter+0x10>)
    9a38:	4798      	blx	r3
	
}
    9a3a:	bd10      	pop	{r4, pc}
    9a3c:	00009889 	.word	0x00009889

00009a40 <grid_msg_find_recent>:

uint8_t grid_msg_find_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
    //uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9a40:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9a44:	30ac      	adds	r0, #172	; 0xac
		
		if (model->recent_messages[i%GRID_SYS_RECENT_MESSAGES_LENGTH] == fingerprint){
    9a46:	f853 2b04 	ldr.w	r2, [r3], #4
    9a4a:	428a      	cmp	r2, r1
    9a4c:	d003      	beq.n	9a56 <grid_msg_find_recent+0x16>
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9a4e:	4283      	cmp	r3, r0
    9a50:	d1f9      	bne.n	9a46 <grid_msg_find_recent+0x6>
			
		}
		
	}
	
	return 0;
    9a52:	2000      	movs	r0, #0
    9a54:	4770      	bx	lr
			return 1;
    9a56:	2001      	movs	r0, #1
}
    9a58:	4770      	bx	lr

00009a5a <grid_msg_push_recent>:

void grid_msg_push_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
	model->recent_messages_index+=1;
    9a5a:	f890 30ac 	ldrb.w	r3, [r0, #172]	; 0xac
    9a5e:	3301      	adds	r3, #1
	model->recent_messages_index%=GRID_SYS_RECENT_MESSAGES_LENGTH;
    9a60:	f003 031f 	and.w	r3, r3, #31
    9a64:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
	
	model->recent_messages[model->recent_messages_index] = fingerprint;
    9a68:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    9a6c:	62c1      	str	r1, [r0, #44]	; 0x2c
	
}
    9a6e:	4770      	bx	lr

00009a70 <grid_ui_model_init>:
	}
	
}


void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a70:	b538      	push	{r3, r4, r5, lr}
	
	mod->status = GRID_UI_STATUS_INITIALIZED;
    9a72:	2301      	movs	r3, #1
    9a74:	7003      	strb	r3, [r0, #0]
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a76:	4605      	mov	r5, r0
	
	mod->bank_list_length = bank_list_length;	
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a78:	4b09      	ldr	r3, [pc, #36]	; (9aa0 <grid_ui_model_init+0x30>)
	mod->bank_list_length = bank_list_length;	
    9a7a:	7041      	strb	r1, [r0, #1]
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a7c:	0108      	lsls	r0, r1, #4
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a7e:	460c      	mov	r4, r1
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a80:	4798      	blx	r3
	
	for(uint8_t i=0; i<bank_list_length; i++){
    9a82:	2300      	movs	r3, #0
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a84:	6068      	str	r0, [r5, #4]
		
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9a86:	461a      	mov	r2, r3
	for(uint8_t i=0; i<bank_list_length; i++){
    9a88:	b2d9      	uxtb	r1, r3
    9a8a:	428c      	cmp	r4, r1
    9a8c:	f100 0010 	add.w	r0, r0, #16
    9a90:	d800      	bhi.n	9a94 <grid_ui_model_init+0x24>
		mod->bank_list[i].element_list_length = 0;
		
	}
	
}
    9a92:	bd38      	pop	{r3, r4, r5, pc}
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9a94:	f800 2c10 	strb.w	r2, [r0, #-16]
		mod->bank_list[i].element_list_length = 0;
    9a98:	f800 2c07 	strb.w	r2, [r0, #-7]
	for(uint8_t i=0; i<bank_list_length; i++){
    9a9c:	3301      	adds	r3, #1
    9a9e:	e7f3      	b.n	9a88 <grid_ui_model_init+0x18>
    9aa0:	00014315 	.word	0x00014315

00009aa4 <grid_ui_bank_init>:

void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9aa4:	b538      	push	{r3, r4, r5, lr}
	
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9aa6:	6843      	ldr	r3, [r0, #4]
    9aa8:	eb03 1501 	add.w	r5, r3, r1, lsl #4
void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9aac:	4614      	mov	r4, r2
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9aae:	010a      	lsls	r2, r1, #4
	bank->parent = parent;
    9ab0:	6068      	str	r0, [r5, #4]
	bank->index = index;
    9ab2:	7229      	strb	r1, [r5, #8]
	
	
	bank->status = GRID_UI_STATUS_INITIALIZED;
	
	bank->element_list_length = element_list_length;
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9ab4:	2064      	movs	r0, #100	; 0x64
	bank->status = GRID_UI_STATUS_INITIALIZED;
    9ab6:	2101      	movs	r1, #1
    9ab8:	5499      	strb	r1, [r3, r2]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9aba:	4360      	muls	r0, r4
    9abc:	4b08      	ldr	r3, [pc, #32]	; (9ae0 <grid_ui_bank_init+0x3c>)
	bank->element_list_length = element_list_length;
    9abe:	726c      	strb	r4, [r5, #9]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9ac0:	4798      	blx	r3
	
	for(uint8_t i=0; i<element_list_length; i++){
    9ac2:	2300      	movs	r3, #0
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9ac4:	60e8      	str	r0, [r5, #12]
		
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9ac6:	461a      	mov	r2, r3
	for(uint8_t i=0; i<element_list_length; i++){
    9ac8:	b2d9      	uxtb	r1, r3
    9aca:	428c      	cmp	r4, r1
    9acc:	f100 0064 	add.w	r0, r0, #100	; 0x64
    9ad0:	d800      	bhi.n	9ad4 <grid_ui_bank_init+0x30>
		bank->element_list[i].event_list_length = 0;
		
	}
	
}
    9ad2:	bd38      	pop	{r3, r4, r5, pc}
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9ad4:	f800 2c64 	strb.w	r2, [r0, #-100]
		bank->element_list[i].event_list_length = 0;
    9ad8:	f800 2c08 	strb.w	r2, [r0, #-8]
	for(uint8_t i=0; i<element_list_length; i++){
    9adc:	3301      	adds	r3, #1
    9ade:	e7f3      	b.n	9ac8 <grid_ui_bank_init+0x24>
    9ae0:	00014315 	.word	0x00014315

00009ae4 <grid_ui_nvm_store_all_configuration>:
	
}



void grid_ui_nvm_store_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9ae4:	460b      	mov	r3, r1
	
    grid_nvm_ui_bulk_store_init(nvm, ui);
    9ae6:	4601      	mov	r1, r0
    9ae8:	4618      	mov	r0, r3
    9aea:	4b01      	ldr	r3, [pc, #4]	; (9af0 <grid_ui_nvm_store_all_configuration+0xc>)
    9aec:	4718      	bx	r3
    9aee:	bf00      	nop
    9af0:	00008935 	.word	0x00008935

00009af4 <grid_ui_nvm_load_all_configuration>:

}

void grid_ui_nvm_load_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9af4:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_read_init(nvm, ui);
    9af6:	4601      	mov	r1, r0
    9af8:	4618      	mov	r0, r3
    9afa:	4b01      	ldr	r3, [pc, #4]	; (9b00 <grid_ui_nvm_load_all_configuration+0xc>)
    9afc:	4718      	bx	r3
    9afe:	bf00      	nop
    9b00:	00008821 	.word	0x00008821

00009b04 <grid_ui_nvm_clear_all_configuration>:

		
	
}

void grid_ui_nvm_clear_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9b04:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_clear_init(nvm, ui);
    9b06:	4601      	mov	r1, r0
    9b08:	4618      	mov	r0, r3
    9b0a:	4b01      	ldr	r3, [pc, #4]	; (9b10 <grid_ui_nvm_clear_all_configuration+0xc>)
    9b0c:	4718      	bx	r3
    9b0e:	bf00      	nop
    9b10:	00008af9 	.word	0x00008af9

00009b14 <grid_ui_recall_event_configuration>:

}


uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9b18:	4698      	mov	r8, r3
	
	struct grid_ui_element* ele = NULL;
	struct grid_ui_event* eve = NULL;
	uint8_t event_index = 255;
	
	if (bank < ui->bank_list_length){
    9b1a:	7843      	ldrb	r3, [r0, #1]
    9b1c:	428b      	cmp	r3, r1
uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9b1e:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
    9b22:	460e      	mov	r6, r1
    9b24:	4615      	mov	r5, r2
	if (bank < ui->bank_list_length){
    9b26:	f240 8082 	bls.w	9c2e <grid_ui_recall_event_configuration+0x11a>
		
		if (element < ui->bank_list[bank].element_list_length){
    9b2a:	6843      	ldr	r3, [r0, #4]
    9b2c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    9b30:	7a5a      	ldrb	r2, [r3, #9]
    9b32:	42aa      	cmp	r2, r5
    9b34:	d97b      	bls.n	9c2e <grid_ui_recall_event_configuration+0x11a>
			
			ele = &ui->bank_list[bank].element_list[element];
    9b36:	68da      	ldr	r2, [r3, #12]
    9b38:	2364      	movs	r3, #100	; 0x64
    9b3a:	fb05 2303 	mla	r3, r5, r3, r2
			
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9b3e:	2200      	movs	r2, #0
    9b40:	f893 c05c 	ldrb.w	ip, [r3, #92]	; 0x5c
	uint8_t event_index = 255;
    9b44:	20ff      	movs	r0, #255	; 0xff
	struct grid_ui_event* eve = NULL;
    9b46:	4614      	mov	r4, r2
				if (ele->event_list[i].type == event_type){
    9b48:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9b4c:	b2d7      	uxtb	r7, r2
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9b4e:	45bc      	cmp	ip, r7
    9b50:	d862      	bhi.n	9c18 <grid_ui_recall_event_configuration+0x104>
		
		
	}
	
	
	if (event_index != 255){ // OK
    9b52:	28ff      	cmp	r0, #255	; 0xff
    9b54:	d06b      	beq.n	9c2e <grid_ui_recall_event_configuration+0x11a>
		
		struct grid_msg message;

		grid_msg_init(&message);
    9b56:	4b5b      	ldr	r3, [pc, #364]	; (9cc4 <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b58:	4d5b      	ldr	r5, [pc, #364]	; (9cc8 <grid_ui_recall_event_configuration+0x1b4>)
		uint32_t offset = 0;



		// BANK ENABLED
		offset = grid_msg_body_get_length(&message);
    9b5a:	f8df a190 	ldr.w	sl, [pc, #400]	; 9cec <grid_ui_recall_event_configuration+0x1d8>

		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b5e:	f8df 9190 	ldr.w	r9, [pc, #400]	; 9cf0 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9b62:	f8df 8190 	ldr.w	r8, [pc, #400]	; 9cf4 <grid_ui_recall_event_configuration+0x1e0>

		grid_msg_body_append_text(&message, payload, payload_length);
    9b66:	4f59      	ldr	r7, [pc, #356]	; (9ccc <grid_ui_recall_event_configuration+0x1b8>)

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9b68:	4e59      	ldr	r6, [pc, #356]	; (9cd0 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9b6a:	a867      	add	r0, sp, #412	; 0x19c
    9b6c:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b6e:	227f      	movs	r2, #127	; 0x7f
    9b70:	4611      	mov	r1, r2
    9b72:	2300      	movs	r3, #0
    9b74:	a867      	add	r0, sp, #412	; 0x19c
    9b76:	47a8      	blx	r5
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9b78:	2100      	movs	r1, #0
    9b7a:	4b56      	ldr	r3, [pc, #344]	; (9cd4 <grid_ui_recall_event_configuration+0x1c0>)
    9b7c:	9103      	str	r1, [sp, #12]
    9b7e:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9b82:	a804      	add	r0, sp, #16
    9b84:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9b86:	a867      	add	r0, sp, #412	; 0x19c
    9b88:	47d0      	blx	sl
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b8a:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9b8c:	4605      	mov	r5, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b8e:	4952      	ldr	r1, [pc, #328]	; (9cd8 <grid_ui_recall_event_configuration+0x1c4>)
    9b90:	2202      	movs	r2, #2
    9b92:	a803      	add	r0, sp, #12
    9b94:	47c8      	blx	r9
		payload_length = strlen(payload);
    9b96:	a803      	add	r0, sp, #12
    9b98:	47c0      	blx	r8
		grid_msg_body_append_text(&message, payload, payload_length);
    9b9a:	a903      	add	r1, sp, #12
    9b9c:	b2c2      	uxtb	r2, r0
    9b9e:	a867      	add	r0, sp, #412	; 0x19c
    9ba0:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9ba2:	230d      	movs	r3, #13
    9ba4:	9300      	str	r3, [sp, #0]
    9ba6:	2204      	movs	r2, #4
    9ba8:	2301      	movs	r3, #1
    9baa:	4629      	mov	r1, r5
    9bac:	a867      	add	r0, sp, #412	; 0x19c
    9bae:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9bb0:	6863      	ldr	r3, [r4, #4]
    9bb2:	685b      	ldr	r3, [r3, #4]
    9bb4:	7a1b      	ldrb	r3, [r3, #8]
    9bb6:	9300      	str	r3, [sp, #0]
    9bb8:	2205      	movs	r2, #5
    9bba:	2302      	movs	r3, #2
    9bbc:	4629      	mov	r1, r5
    9bbe:	a867      	add	r0, sp, #412	; 0x19c
    9bc0:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9bc2:	6863      	ldr	r3, [r4, #4]
    9bc4:	7a1b      	ldrb	r3, [r3, #8]
    9bc6:	9300      	str	r3, [sp, #0]
    9bc8:	2207      	movs	r2, #7
    9bca:	2302      	movs	r3, #2
    9bcc:	4629      	mov	r1, r5
    9bce:	a867      	add	r0, sp, #412	; 0x19c
    9bd0:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9bd2:	7aa3      	ldrb	r3, [r4, #10]
    9bd4:	9300      	str	r3, [sp, #0]
    9bd6:	2209      	movs	r2, #9
    9bd8:	2302      	movs	r3, #2
    9bda:	4629      	mov	r1, r5
    9bdc:	a867      	add	r0, sp, #412	; 0x19c
    9bde:	47b0      	blx	r6

		offset = grid_msg_body_get_length(&message);
    9be0:	a867      	add	r0, sp, #412	; 0x19c
    9be2:	47d0      	blx	sl
		grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9be4:	4b3d      	ldr	r3, [pc, #244]	; (9cdc <grid_ui_recall_event_configuration+0x1c8>)
    9be6:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9be8:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9bec:	a867      	add	r0, sp, #412	; 0x19c
    9bee:	4798      	blx	r3





		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9bf0:	493b      	ldr	r1, [pc, #236]	; (9ce0 <grid_ui_recall_event_configuration+0x1cc>)
    9bf2:	2203      	movs	r2, #3
    9bf4:	a803      	add	r0, sp, #12
    9bf6:	47c8      	blx	r9
		payload_length = strlen(payload);
    9bf8:	a803      	add	r0, sp, #12
    9bfa:	47c0      	blx	r8

		grid_msg_body_append_text(&message, payload, payload_length);
    9bfc:	a903      	add	r1, sp, #12
    9bfe:	b2c2      	uxtb	r2, r0
    9c00:	a867      	add	r0, sp, #412	; 0x19c
    9c02:	47b8      	blx	r7
		payload_length = strlen(payload);

		grid_msg_body_append_text(&message, payload, payload_length);


		grid_msg_packet_close(&message);
    9c04:	4b37      	ldr	r3, [pc, #220]	; (9ce4 <grid_ui_recall_event_configuration+0x1d0>)
    9c06:	a867      	add	r0, sp, #412	; 0x19c
    9c08:	4798      	blx	r3
		grid_msg_packet_send_everywhere(&message);		
    9c0a:	4b37      	ldr	r3, [pc, #220]	; (9ce8 <grid_ui_recall_event_configuration+0x1d4>)
    9c0c:	a867      	add	r0, sp, #412	; 0x19c
    9c0e:	4798      	blx	r3
		
		
	}

	
}
    9c10:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9c14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (ele->event_list[i].type == event_type){
    9c18:	6e19      	ldr	r1, [r3, #96]	; 0x60
    9c1a:	fb0e 1102 	mla	r1, lr, r2, r1
    9c1e:	3201      	adds	r2, #1
    9c20:	f891 900a 	ldrb.w	r9, [r1, #10]
    9c24:	45c1      	cmp	r9, r8
    9c26:	bf04      	itt	eq
    9c28:	4638      	moveq	r0, r7
    9c2a:	460c      	moveq	r4, r1
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9c2c:	e78e      	b.n	9b4c <grid_ui_recall_event_configuration+0x38>
		grid_msg_init(&message);
    9c2e:	a867      	add	r0, sp, #412	; 0x19c
    9c30:	4b24      	ldr	r3, [pc, #144]	; (9cc4 <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9c32:	4c25      	ldr	r4, [pc, #148]	; (9cc8 <grid_ui_recall_event_configuration+0x1b4>)
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c34:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 9cf0 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9c38:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 9cf4 <grid_ui_recall_event_configuration+0x1e0>
		grid_msg_body_append_text(&message, payload, payload_length);
    9c3c:	f8df 908c 	ldr.w	r9, [pc, #140]	; 9ccc <grid_ui_recall_event_configuration+0x1b8>
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9c40:	4f23      	ldr	r7, [pc, #140]	; (9cd0 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9c42:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9c44:	227f      	movs	r2, #127	; 0x7f
    9c46:	4611      	mov	r1, r2
    9c48:	a867      	add	r0, sp, #412	; 0x19c
    9c4a:	2300      	movs	r3, #0
    9c4c:	47a0      	blx	r4
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9c4e:	2100      	movs	r1, #0
    9c50:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9c54:	4b1f      	ldr	r3, [pc, #124]	; (9cd4 <grid_ui_recall_event_configuration+0x1c0>)
    9c56:	9103      	str	r1, [sp, #12]
    9c58:	a804      	add	r0, sp, #16
    9c5a:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9c5c:	4b23      	ldr	r3, [pc, #140]	; (9cec <grid_ui_recall_event_configuration+0x1d8>)
    9c5e:	a867      	add	r0, sp, #412	; 0x19c
    9c60:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c62:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9c64:	4604      	mov	r4, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c66:	491c      	ldr	r1, [pc, #112]	; (9cd8 <grid_ui_recall_event_configuration+0x1c4>)
    9c68:	2202      	movs	r2, #2
    9c6a:	a803      	add	r0, sp, #12
    9c6c:	47d8      	blx	fp
		payload_length = strlen(payload);
    9c6e:	a803      	add	r0, sp, #12
    9c70:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    9c72:	a903      	add	r1, sp, #12
    9c74:	b2c2      	uxtb	r2, r0
    9c76:	a867      	add	r0, sp, #412	; 0x19c
    9c78:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9c7a:	230b      	movs	r3, #11
    9c7c:	9300      	str	r3, [sp, #0]
    9c7e:	4621      	mov	r1, r4
    9c80:	a867      	add	r0, sp, #412	; 0x19c
    9c82:	2301      	movs	r3, #1
    9c84:	2204      	movs	r2, #4
    9c86:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, bank);
    9c88:	4621      	mov	r1, r4
    9c8a:	a867      	add	r0, sp, #412	; 0x19c
    9c8c:	9600      	str	r6, [sp, #0]
    9c8e:	2302      	movs	r3, #2
    9c90:	2205      	movs	r2, #5
    9c92:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, element);
    9c94:	4621      	mov	r1, r4
    9c96:	a867      	add	r0, sp, #412	; 0x19c
    9c98:	9500      	str	r5, [sp, #0]
    9c9a:	2302      	movs	r3, #2
    9c9c:	2207      	movs	r2, #7
    9c9e:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, event_type);
    9ca0:	2302      	movs	r3, #2
    9ca2:	4621      	mov	r1, r4
    9ca4:	a867      	add	r0, sp, #412	; 0x19c
    9ca6:	f8cd 8000 	str.w	r8, [sp]
    9caa:	2209      	movs	r2, #9
    9cac:	47b8      	blx	r7
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9cae:	490c      	ldr	r1, [pc, #48]	; (9ce0 <grid_ui_recall_event_configuration+0x1cc>)
    9cb0:	2203      	movs	r2, #3
    9cb2:	a803      	add	r0, sp, #12
    9cb4:	47d8      	blx	fp
		payload_length = strlen(payload);
    9cb6:	a803      	add	r0, sp, #12
    9cb8:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    9cba:	a903      	add	r1, sp, #12
    9cbc:	b2c2      	uxtb	r2, r0
    9cbe:	a867      	add	r0, sp, #412	; 0x19c
    9cc0:	47c8      	blx	r9
    9cc2:	e79f      	b.n	9c04 <grid_ui_recall_event_configuration+0xf0>
    9cc4:	000085c5 	.word	0x000085c5
    9cc8:	000085f9 	.word	0x000085f9
    9ccc:	00008535 	.word	0x00008535
    9cd0:	000085a9 	.word	0x000085a9
    9cd4:	00014469 	.word	0x00014469
    9cd8:	00016ddd 	.word	0x00016ddd
    9cdc:	00008555 	.word	0x00008555
    9ce0:	00016a4f 	.word	0x00016a4f
    9ce4:	000086f1 	.word	0x000086f1
    9ce8:	000087c5 	.word	0x000087c5
    9cec:	0000852f 	.word	0x0000852f
    9cf0:	00014ac5 	.word	0x00014ac5
    9cf4:	00014f81 	.word	0x00014f81

00009cf8 <grid_ui_nvm_store_event_configuration>:



uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9cfc:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
	

	struct grid_msg message;

	grid_msg_init(&message);
    9d00:	4b52      	ldr	r3, [pc, #328]	; (9e4c <grid_ui_nvm_store_event_configuration+0x154>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9d02:	4e53      	ldr	r6, [pc, #332]	; (9e50 <grid_ui_nvm_store_event_configuration+0x158>)
	uint32_t offset = 0;



	// BANK ENABLED
	offset = grid_msg_body_get_length(&message);
    9d04:	f8df b178 	ldr.w	fp, [pc, #376]	; 9e80 <grid_ui_nvm_store_event_configuration+0x188>

	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9d08:	f8df a178 	ldr.w	sl, [pc, #376]	; 9e84 <grid_ui_nvm_store_event_configuration+0x18c>
	payload_length = strlen(payload);

	grid_msg_body_append_text(&message, payload, payload_length);
    9d0c:	f8df 9178 	ldr.w	r9, [pc, #376]	; 9e88 <grid_ui_nvm_store_event_configuration+0x190>

	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9d10:	f8df 8178 	ldr.w	r8, [pc, #376]	; 9e8c <grid_ui_nvm_store_event_configuration+0x194>
	grid_msg_init(&message);
    9d14:	a867      	add	r0, sp, #412	; 0x19c
uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9d16:	4614      	mov	r4, r2
    9d18:	460d      	mov	r5, r1
	grid_msg_init(&message);
    9d1a:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9d1c:	22ff      	movs	r2, #255	; 0xff
    9d1e:	4611      	mov	r1, r2
    9d20:	2300      	movs	r3, #0
    9d22:	a867      	add	r0, sp, #412	; 0x19c
    9d24:	47b0      	blx	r6
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9d26:	2600      	movs	r6, #0
    9d28:	4b4a      	ldr	r3, [pc, #296]	; (9e54 <grid_ui_nvm_store_event_configuration+0x15c>)
    9d2a:	9603      	str	r6, [sp, #12]
    9d2c:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9d30:	4631      	mov	r1, r6
    9d32:	a804      	add	r0, sp, #16
    9d34:	4798      	blx	r3
	offset = grid_msg_body_get_length(&message);
    9d36:	a867      	add	r0, sp, #412	; 0x19c
    9d38:	47d8      	blx	fp
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9d3a:	4947      	ldr	r1, [pc, #284]	; (9e58 <grid_ui_nvm_store_event_configuration+0x160>)
	offset = grid_msg_body_get_length(&message);
    9d3c:	4607      	mov	r7, r0
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9d3e:	2202      	movs	r2, #2
    9d40:	2380      	movs	r3, #128	; 0x80
    9d42:	a803      	add	r0, sp, #12
    9d44:	47d0      	blx	sl
	payload_length = strlen(payload);
    9d46:	4b45      	ldr	r3, [pc, #276]	; (9e5c <grid_ui_nvm_store_event_configuration+0x164>)
    9d48:	a803      	add	r0, sp, #12
    9d4a:	4798      	blx	r3
	grid_msg_body_append_text(&message, payload, payload_length);
    9d4c:	a903      	add	r1, sp, #12
    9d4e:	b2c2      	uxtb	r2, r0
    9d50:	a867      	add	r0, sp, #412	; 0x19c
    9d52:	47c8      	blx	r9
	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9d54:	230e      	movs	r3, #14
    9d56:	4639      	mov	r1, r7
    9d58:	9300      	str	r3, [sp, #0]
    9d5a:	2204      	movs	r2, #4
    9d5c:	2301      	movs	r3, #1
    9d5e:	a867      	add	r0, sp, #412	; 0x19c
    9d60:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9d62:	6863      	ldr	r3, [r4, #4]
    9d64:	685b      	ldr	r3, [r3, #4]
    9d66:	7a1b      	ldrb	r3, [r3, #8]
    9d68:	9300      	str	r3, [sp, #0]
    9d6a:	4639      	mov	r1, r7
    9d6c:	2302      	movs	r3, #2
    9d6e:	2205      	movs	r2, #5
    9d70:	a867      	add	r0, sp, #412	; 0x19c
    9d72:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9d74:	6863      	ldr	r3, [r4, #4]
    9d76:	7a1b      	ldrb	r3, [r3, #8]
    9d78:	9300      	str	r3, [sp, #0]
    9d7a:	4639      	mov	r1, r7
    9d7c:	2302      	movs	r3, #2
    9d7e:	2207      	movs	r2, #7
    9d80:	a867      	add	r0, sp, #412	; 0x19c
    9d82:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9d84:	7aa3      	ldrb	r3, [r4, #10]
    9d86:	9300      	str	r3, [sp, #0]
    9d88:	4639      	mov	r1, r7
    9d8a:	2302      	movs	r3, #2
    9d8c:	2209      	movs	r2, #9
    9d8e:	a867      	add	r0, sp, #412	; 0x19c
    9d90:	47c0      	blx	r8

	offset = grid_msg_body_get_length(&message);
    9d92:	a867      	add	r0, sp, #412	; 0x19c
    9d94:	47d8      	blx	fp
	grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9d96:	4b32      	ldr	r3, [pc, #200]	; (9e60 <grid_ui_nvm_store_event_configuration+0x168>)
    9d98:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9d9a:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9d9e:	a867      	add	r0, sp, #412	; 0x19c
    9da0:	4798      	blx	r3





	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9da2:	4930      	ldr	r1, [pc, #192]	; (9e64 <grid_ui_nvm_store_event_configuration+0x16c>)
    9da4:	2203      	movs	r2, #3
    9da6:	a803      	add	r0, sp, #12
    9da8:	47d0      	blx	sl
	payload_length = strlen(payload);
    9daa:	4b2c      	ldr	r3, [pc, #176]	; (9e5c <grid_ui_nvm_store_event_configuration+0x164>)
    9dac:	a803      	add	r0, sp, #12
    9dae:	4798      	blx	r3

	grid_msg_body_append_text(&message, payload, payload_length);
    9db0:	a903      	add	r1, sp, #12
    9db2:	b2c2      	uxtb	r2, r0
    9db4:	a867      	add	r0, sp, #412	; 0x19c
    9db6:	47c8      	blx	r9


	grid_msg_packet_close(&message);
    9db8:	4b2b      	ldr	r3, [pc, #172]	; (9e68 <grid_ui_nvm_store_event_configuration+0x170>)
    9dba:	a867      	add	r0, sp, #412	; 0x19c
    9dbc:	4798      	blx	r3

	grid_nvm_clear_write_buffer(nvm);
    9dbe:	4b2b      	ldr	r3, [pc, #172]	; (9e6c <grid_ui_nvm_store_event_configuration+0x174>)
    9dc0:	4628      	mov	r0, r5
    9dc2:	4798      	blx	r3

	uint32_t message_length = grid_msg_packet_get_length(&message);
    9dc4:	4b2a      	ldr	r3, [pc, #168]	; (9e70 <grid_ui_nvm_store_event_configuration+0x178>)
    9dc6:	a867      	add	r0, sp, #412	; 0x19c
    9dc8:	4798      	blx	r3

	if (message_length){
    9dca:	4607      	mov	r7, r0
    9dcc:	b970      	cbnz	r0, 9dec <grid_ui_nvm_store_event_configuration+0xf4>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
		}

	}

	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    9dce:	4621      	mov	r1, r4
    9dd0:	4b28      	ldr	r3, [pc, #160]	; (9e74 <grid_ui_nvm_store_event_configuration+0x17c>)
    9dd2:	4628      	mov	r0, r5
    9dd4:	4798      	blx	r3
	nvm->write_target_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;
    9dd6:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9dda:	0241      	lsls	r1, r0, #9
    9ddc:	f8c5 1420 	str.w	r1, [r5, #1056]	; 0x420
	int status = 0;
	
	
	uint8_t debugtext[200] = {0};

	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    9de0:	f894 60b7 	ldrb.w	r6, [r4, #183]	; 0xb7
    9de4:	2e01      	cmp	r6, #1
    9de6:	d010      	beq.n	9e0a <grid_ui_nvm_store_event_configuration+0x112>
	int status = 0;
    9de8:	2000      	movs	r0, #0
    9dea:	e019      	b.n	9e20 <grid_ui_nvm_store_event_configuration+0x128>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9dec:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 9e90 <grid_ui_nvm_store_event_configuration+0x198>
		nvm->write_buffer_length = message_length;
    9df0:	f8c5 0418 	str.w	r0, [r5, #1048]	; 0x418
		for(uint32_t i = 0; i<message_length; i++){
    9df4:	f505 7806 	add.w	r8, r5, #536	; 0x218
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9df8:	4631      	mov	r1, r6
    9dfa:	a867      	add	r0, sp, #412	; 0x19c
    9dfc:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    9dfe:	3601      	adds	r6, #1
    9e00:	42b7      	cmp	r7, r6
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9e02:	f808 0b01 	strb.w	r0, [r8], #1
		for(uint32_t i = 0; i<message_length; i++){
    9e06:	d1f7      	bne.n	9df8 <grid_ui_nvm_store_event_configuration+0x100>
    9e08:	e7e1      	b.n	9dce <grid_ui_nvm_store_event_configuration+0xd6>
	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    9e0a:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    9e0e:	2b00      	cmp	r3, #0
    9e10:	d1ea      	bne.n	9de8 <grid_ui_nvm_store_event_configuration+0xf0>
		
		//sprintf(debugtext, "Cfg: Default B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);
		flash_erase(nvm->flash, nvm->write_target_address, 1);
    9e12:	6828      	ldr	r0, [r5, #0]
    9e14:	4b18      	ldr	r3, [pc, #96]	; (9e78 <grid_ui_nvm_store_event_configuration+0x180>)
    9e16:	4632      	mov	r2, r6
    9e18:	4798      	blx	r3
		eve->cfg_flashempty_flag = 1;
    9e1a:	f884 60b8 	strb.w	r6, [r4, #184]	; 0xb8
		status = 1;
    9e1e:	4630      	mov	r0, r6
	}
	
	
	if (eve->cfg_default_flag == 0 && eve->cfg_changed_flag == 1){
    9e20:	f8b4 60b6 	ldrh.w	r6, [r4, #182]	; 0xb6
    9e24:	2e01      	cmp	r6, #1
    9e26:	d109      	bne.n	9e3c <grid_ui_nvm_store_event_configuration+0x144>
		
		//sprintf(debugtext, "Cfg: Store B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);		
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, GRID_NVM_PAGE_SIZE);
    9e28:	f8d5 1420 	ldr.w	r1, [r5, #1056]	; 0x420
    9e2c:	6828      	ldr	r0, [r5, #0]
    9e2e:	f505 7206 	add.w	r2, r5, #536	; 0x218
    9e32:	f44f 7300 	mov.w	r3, #512	; 0x200
    9e36:	4d11      	ldr	r5, [pc, #68]	; (9e7c <grid_ui_nvm_store_event_configuration+0x184>)
    9e38:	47a8      	blx	r5
		status = 1;
    9e3a:	4630      	mov	r0, r6
	}


	//grid_debug_print_text(debugtext);

	eve->cfg_changed_flag = 0;
    9e3c:	2300      	movs	r3, #0
    9e3e:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	
	return status;
	
}
    9e42:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9e46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9e4a:	bf00      	nop
    9e4c:	000085c5 	.word	0x000085c5
    9e50:	000085f9 	.word	0x000085f9
    9e54:	00014469 	.word	0x00014469
    9e58:	00016ddd 	.word	0x00016ddd
    9e5c:	00014f81 	.word	0x00014f81
    9e60:	00008555 	.word	0x00008555
    9e64:	00016a4f 	.word	0x00016a4f
    9e68:	000086f1 	.word	0x000086f1
    9e6c:	00008cd1 	.word	0x00008cd1
    9e70:	00008521 	.word	0x00008521
    9e74:	00008d3d 	.word	0x00008d3d
    9e78:	0000eeb1 	.word	0x0000eeb1
    9e7c:	0000ee31 	.word	0x0000ee31
    9e80:	0000852f 	.word	0x0000852f
    9e84:	00014ac5 	.word	0x00014ac5
    9e88:	00008535 	.word	0x00008535
    9e8c:	000085a9 	.word	0x000085a9
    9e90:	000086bb 	.word	0x000086bb

00009e94 <grid_ui_nvm_load_event_configuration>:



uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9e94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
		
	grid_nvm_clear_read_buffer(nvm);
    9e96:	4b19      	ldr	r3, [pc, #100]	; (9efc <grid_ui_nvm_load_event_configuration+0x68>)
uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9e98:	9201      	str	r2, [sp, #4]
    9e9a:	460c      	mov	r4, r1
	grid_nvm_clear_read_buffer(nvm);
    9e9c:	4608      	mov	r0, r1
    9e9e:	4798      	blx	r3
	
	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);	
    9ea0:	9901      	ldr	r1, [sp, #4]
    9ea2:	4b17      	ldr	r3, [pc, #92]	; (9f00 <grid_ui_nvm_load_event_configuration+0x6c>)
    9ea4:	4620      	mov	r0, r4
    9ea6:	4798      	blx	r3
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    9ea8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9eac:	0241      	lsls	r1, r0, #9
	

	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    9eae:	f104 0609 	add.w	r6, r4, #9
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    9eb2:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    9eb6:	6820      	ldr	r0, [r4, #0]
    9eb8:	4c12      	ldr	r4, [pc, #72]	; (9f04 <grid_ui_nvm_load_event_configuration+0x70>)
    9eba:	f44f 7300 	mov.w	r3, #512	; 0x200
    9ebe:	4632      	mov	r2, r6
    9ec0:	47a0      	blx	r4
    9ec2:	2300      	movs	r3, #0
			}
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9ec4:	4c10      	ldr	r4, [pc, #64]	; (9f08 <grid_ui_nvm_load_event_configuration+0x74>)
	uint8_t cfgfound = 0;
    9ec6:	4618      	mov	r0, r3
	uint8_t copydone = 0;
    9ec8:	4619      	mov	r1, r3
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9eca:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    9ece:	1c5a      	adds	r2, r3, #1
    9ed0:	b971      	cbnz	r1, 9ef0 <grid_ui_nvm_load_event_configuration+0x5c>
			if (nvm->read_buffer[i] == '\n'){ // END OF PACKET, copy newline character
    9ed2:	5cf5      	ldrb	r5, [r6, r3]
    9ed4:	2d0a      	cmp	r5, #10
    9ed6:	d106      	bne.n	9ee6 <grid_ui_nvm_load_event_configuration+0x52>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9ed8:	4423      	add	r3, r4
				cfgfound=2;
    9eda:	2002      	movs	r0, #2
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9edc:	55dd      	strb	r5, [r3, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    9ede:	6222      	str	r2, [r4, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    9ee0:	62a1      	str	r1, [r4, #40]	; 0x28
				copydone = 1;
    9ee2:	2101      	movs	r1, #1
    9ee4:	e004      	b.n	9ef0 <grid_ui_nvm_load_event_configuration+0x5c>
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    9ee6:	2dff      	cmp	r5, #255	; 0xff
    9ee8:	d0fb      	beq.n	9ee2 <grid_ui_nvm_load_event_configuration+0x4e>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9eea:	4423      	add	r3, r4
				
				cfgfound=1;
    9eec:	2001      	movs	r0, #1
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9eee:	55dd      	strb	r5, [r3, r7]
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9ef0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    9ef4:	4613      	mov	r3, r2
    9ef6:	d1ea      	bne.n	9ece <grid_ui_nvm_load_event_configuration+0x3a>
	}
	
	return cfgfound;
	
	
}
    9ef8:	b003      	add	sp, #12
    9efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9efc:	00008cb1 	.word	0x00008cb1
    9f00:	00008d3d 	.word	0x00008d3d
    9f04:	0000edc5 	.word	0x0000edc5
    9f08:	2000c0b0 	.word	0x2000c0b0

00009f0c <grid_ui_nvm_clear_event_configuration>:
uint8_t grid_ui_nvm_clear_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9f0c:	b510      	push	{r4, lr}
    9f0e:	460c      	mov	r4, r1
		
		uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    9f10:	4b06      	ldr	r3, [pc, #24]	; (9f2c <grid_ui_nvm_clear_event_configuration+0x20>)
    9f12:	4611      	mov	r1, r2
    9f14:	4620      	mov	r0, r4
    9f16:	4798      	blx	r3
		
		

		flash_erase(nvm->flash, GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset, 1);
    9f18:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9f1c:	0241      	lsls	r1, r0, #9
    9f1e:	4b04      	ldr	r3, [pc, #16]	; (9f30 <grid_ui_nvm_clear_event_configuration+0x24>)
    9f20:	6820      	ldr	r0, [r4, #0]
    9f22:	2201      	movs	r2, #1
    9f24:	4798      	blx	r3

		
		
		return 1;
		
}
    9f26:	2001      	movs	r0, #1
    9f28:	bd10      	pop	{r4, pc}
    9f2a:	bf00      	nop
    9f2c:	00008d3d 	.word	0x00008d3d
    9f30:	0000eeb1 	.word	0x0000eeb1

00009f34 <grid_ui_event_register_actionstring>:
	ele->event_list[event_index].cfg_default_flag = 1;	
	
}


void grid_ui_event_register_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* action_string, uint32_t action_string_length){
    9f34:	b5f0      	push	{r4, r5, r6, r7, lr}
		
	uint8_t event_index = 255;
	
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f36:	f890 c05c 	ldrb.w	ip, [r0, #92]	; 0x5c
    9f3a:	2500      	movs	r5, #0
	uint8_t event_index = 255;
    9f3c:	24ff      	movs	r4, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    9f3e:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9f42:	b2ef      	uxtb	r7, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f44:	45bc      	cmp	ip, r7
    9f46:	d819      	bhi.n	9f7c <grid_ui_event_register_actionstring+0x48>
			event_index = i;
		}
	}
	
	if (event_index == 255){
    9f48:	2cff      	cmp	r4, #255	; 0xff
    9f4a:	d016      	beq.n	9f7a <grid_ui_event_register_actionstring+0x46>
	
	
	
	// Clear Action String
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
		ele->event_list[event_index].action_string[i] = 0;
    9f4c:	21bc      	movs	r1, #188	; 0xbc
    9f4e:	fb14 f401 	smulbb	r4, r4, r1
    9f52:	6e01      	ldr	r1, [r0, #96]	; 0x60
    9f54:	4421      	add	r1, r4
    9f56:	f101 0434 	add.w	r4, r1, #52	; 0x34
    9f5a:	f101 06b6 	add.w	r6, r1, #182	; 0xb6
    9f5e:	4620      	mov	r0, r4
    9f60:	2500      	movs	r5, #0
    9f62:	f800 5b01 	strb.w	r5, [r0], #1
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    9f66:	4286      	cmp	r6, r0
    9f68:	d1fb      	bne.n	9f62 <grid_ui_event_register_actionstring+0x2e>
	}
	ele->event_list[event_index].action_string_length = 0;
    9f6a:	630d      	str	r5, [r1, #48]	; 0x30
	

	uint8_t escaped_characters = 0;
	
	for (uint32_t i=0; i<action_string_length; i++){
    9f6c:	2000      	movs	r0, #0
    9f6e:	4298      	cmp	r0, r3
    9f70:	d10d      	bne.n	9f8e <grid_ui_event_register_actionstring+0x5a>
	}
	

	ele->event_list[event_index].action_string_length = action_string_length;
	
	ele->event_list[event_index].cfg_changed_flag = 1;
    9f72:	2301      	movs	r3, #1
	ele->event_list[event_index].action_string_length = action_string_length;
    9f74:	6308      	str	r0, [r1, #48]	; 0x30
	ele->event_list[event_index].cfg_changed_flag = 1;
    9f76:	f881 30b6 	strb.w	r3, [r1, #182]	; 0xb6
	
	
}
    9f7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    9f7c:	6e06      	ldr	r6, [r0, #96]	; 0x60
    9f7e:	fb0e 6605 	mla	r6, lr, r5, r6
    9f82:	3501      	adds	r5, #1
    9f84:	7ab6      	ldrb	r6, [r6, #10]
    9f86:	428e      	cmp	r6, r1
    9f88:	bf08      	it	eq
    9f8a:	463c      	moveq	r4, r7
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f8c:	e7d9      	b.n	9f42 <grid_ui_event_register_actionstring+0xe>
		if (ele->event_list[event_index].action_string[i] > 127){
    9f8e:	5616      	ldrsb	r6, [r2, r0]
		ele->event_list[event_index].action_string[i] = action_string[i];
    9f90:	5c15      	ldrb	r5, [r2, r0]
		if (ele->event_list[event_index].action_string[i] > 127){
    9f92:	2e00      	cmp	r6, #0
			ele->event_list[event_index].action_string[i] -= 128;
    9f94:	bfb8      	it	lt
    9f96:	3d80      	sublt	r5, #128	; 0x80
    9f98:	7025      	strb	r5, [r4, #0]
	for (uint32_t i=0; i<action_string_length; i++){
    9f9a:	3001      	adds	r0, #1
    9f9c:	3401      	adds	r4, #1
    9f9e:	e7e6      	b.n	9f6e <grid_ui_event_register_actionstring+0x3a>

00009fa0 <grid_ui_event_generate_actionstring>:
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    9fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
    9fa2:	4605      	mov	r5, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fa4:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    9fa8:	b0a3      	sub	sp, #140	; 0x8c
    9faa:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fac:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    9fae:	26ff      	movs	r6, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    9fb0:	27bc      	movs	r7, #188	; 0xbc
    9fb2:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fb4:	4288      	cmp	r0, r1
    9fb6:	d82a      	bhi.n	a00e <grid_ui_event_generate_actionstring+0x6e>
	if (event_index == 255){
    9fb8:	2eff      	cmp	r6, #255	; 0xff
    9fba:	d026      	beq.n	a00a <grid_ui_event_generate_actionstring+0x6a>
	uint8_t action_string[GRID_UI_ACTION_STRING_maxlength] = {0};
    9fbc:	4b35      	ldr	r3, [pc, #212]	; (a094 <grid_ui_event_generate_actionstring+0xf4>)
    9fbe:	2100      	movs	r1, #0
    9fc0:	227e      	movs	r2, #126	; 0x7e
    9fc2:	a802      	add	r0, sp, #8
    9fc4:	9101      	str	r1, [sp, #4]
    9fc6:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    9fc8:	7a6b      	ldrb	r3, [r5, #9]
    9fca:	2b02      	cmp	r3, #2
    9fcc:	d12c      	bne.n	a028 <grid_ui_event_generate_actionstring+0x88>
		switch(event_type){
    9fce:	2c04      	cmp	r4, #4
    9fd0:	d026      	beq.n	a020 <grid_ui_event_generate_actionstring+0x80>
    9fd2:	2c05      	cmp	r4, #5
    9fd4:	d026      	beq.n	a024 <grid_ui_event_generate_actionstring+0x84>
    9fd6:	b91c      	cbnz	r4, 9fe0 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_INIT:	sprintf(action_string, GRID_ACTIONSTRING_INIT_BUT);		break;
    9fd8:	492f      	ldr	r1, [pc, #188]	; (a098 <grid_ui_event_generate_actionstring+0xf8>)
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    9fda:	4b30      	ldr	r3, [pc, #192]	; (a09c <grid_ui_event_generate_actionstring+0xfc>)
    9fdc:	a801      	add	r0, sp, #4
    9fde:	4798      	blx	r3
	if (strlen(action_string)){
    9fe0:	f89d 3004 	ldrb.w	r3, [sp, #4]
    9fe4:	b143      	cbz	r3, 9ff8 <grid_ui_event_generate_actionstring+0x58>
		grid_ui_event_register_actionstring(ele, event_type, action_string, strlen(action_string));
    9fe6:	4b2e      	ldr	r3, [pc, #184]	; (a0a0 <grid_ui_event_generate_actionstring+0x100>)
    9fe8:	a801      	add	r0, sp, #4
    9fea:	4798      	blx	r3
    9fec:	4621      	mov	r1, r4
    9fee:	4603      	mov	r3, r0
    9ff0:	4c2c      	ldr	r4, [pc, #176]	; (a0a4 <grid_ui_event_generate_actionstring+0x104>)
    9ff2:	aa01      	add	r2, sp, #4
    9ff4:	4628      	mov	r0, r5
    9ff6:	47a0      	blx	r4
	ele->event_list[event_index].cfg_changed_flag = 0;
    9ff8:	23bc      	movs	r3, #188	; 0xbc
    9ffa:	fb16 f603 	smulbb	r6, r6, r3
    9ffe:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    a000:	441e      	add	r6, r3
    a002:	f44f 7380 	mov.w	r3, #256	; 0x100
    a006:	f8a6 30b6 	strh.w	r3, [r6, #182]	; 0xb6
}
    a00a:	b023      	add	sp, #140	; 0x8c
    a00c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a00e:	6e2a      	ldr	r2, [r5, #96]	; 0x60
    a010:	fb07 2203 	mla	r2, r7, r3, r2
    a014:	3301      	adds	r3, #1
    a016:	7a92      	ldrb	r2, [r2, #10]
    a018:	42a2      	cmp	r2, r4
    a01a:	bf08      	it	eq
    a01c:	460e      	moveq	r6, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a01e:	e7c8      	b.n	9fb2 <grid_ui_event_generate_actionstring+0x12>
			case GRID_UI_EVENT_DP:		sprintf(action_string, GRID_ACTIONSTRING_DP_BUT);		break;
    a020:	4921      	ldr	r1, [pc, #132]	; (a0a8 <grid_ui_event_generate_actionstring+0x108>)
    a022:	e7da      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:		sprintf(action_string, GRID_ACTIONSTRING_DR_BUT);		break;
    a024:	4921      	ldr	r1, [pc, #132]	; (a0ac <grid_ui_event_generate_actionstring+0x10c>)
    a026:	e7d8      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a028:	2b01      	cmp	r3, #1
    a02a:	d105      	bne.n	a038 <grid_ui_event_generate_actionstring+0x98>
		switch(event_type){
    a02c:	2c00      	cmp	r4, #0
    a02e:	d0d3      	beq.n	9fd8 <grid_ui_event_generate_actionstring+0x38>
    a030:	2c01      	cmp	r4, #1
    a032:	d1d5      	bne.n	9fe0 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_AVC7:	sprintf(action_string, GRID_ACTIONSTRING_AVC7_POT);		break;
    a034:	491e      	ldr	r1, [pc, #120]	; (a0b0 <grid_ui_event_generate_actionstring+0x110>)
    a036:	e7d0      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a038:	2b03      	cmp	r3, #3
    a03a:	d1d1      	bne.n	9fe0 <grid_ui_event_generate_actionstring+0x40>
		switch(event_type){
    a03c:	2c0d      	cmp	r4, #13
    a03e:	d8cf      	bhi.n	9fe0 <grid_ui_event_generate_actionstring+0x40>
    a040:	a301      	add	r3, pc, #4	; (adr r3, a048 <grid_ui_event_generate_actionstring+0xa8>)
    a042:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
    a046:	bf00      	nop
    a048:	0000a081 	.word	0x0000a081
    a04c:	0000a085 	.word	0x0000a085
    a050:	00009fe1 	.word	0x00009fe1
    a054:	00009fe1 	.word	0x00009fe1
    a058:	0000a08d 	.word	0x0000a08d
    a05c:	0000a091 	.word	0x0000a091
    a060:	00009fe1 	.word	0x00009fe1
    a064:	00009fe1 	.word	0x00009fe1
    a068:	00009fe1 	.word	0x00009fe1
    a06c:	00009fe1 	.word	0x00009fe1
    a070:	00009fe1 	.word	0x00009fe1
    a074:	00009fe1 	.word	0x00009fe1
    a078:	00009fe1 	.word	0x00009fe1
    a07c:	0000a089 	.word	0x0000a089
			case GRID_UI_EVENT_INIT:        sprintf(action_string, GRID_ACTIONSTRING_INIT_ENC);	break;
    a080:	490c      	ldr	r1, [pc, #48]	; (a0b4 <grid_ui_event_generate_actionstring+0x114>)
    a082:	e7aa      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_AVC7:        sprintf(action_string, GRID_ACTIONSTRING_AVC7_ENC);	break;
    a084:	490c      	ldr	r1, [pc, #48]	; (a0b8 <grid_ui_event_generate_actionstring+0x118>)
    a086:	e7a8      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_ENCPUSHROT:	sprintf(action_string, GRID_ACTIONSTRING_PUSHROT_ENC);	break;
    a088:	490c      	ldr	r1, [pc, #48]	; (a0bc <grid_ui_event_generate_actionstring+0x11c>)
    a08a:	e7a6      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DP:          sprintf(action_string, GRID_ACTIONSTRING_DP_ENC);	break;
    a08c:	490c      	ldr	r1, [pc, #48]	; (a0c0 <grid_ui_event_generate_actionstring+0x120>)
    a08e:	e7a4      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a090:	490c      	ldr	r1, [pc, #48]	; (a0c4 <grid_ui_event_generate_actionstring+0x124>)
    a092:	e7a2      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
    a094:	00014469 	.word	0x00014469
    a098:	00016deb 	.word	0x00016deb
    a09c:	00014ebd 	.word	0x00014ebd
    a0a0:	00014f81 	.word	0x00014f81
    a0a4:	00009f35 	.word	0x00009f35
    a0a8:	00016e10 	.word	0x00016e10
    a0ac:	00016e3f 	.word	0x00016e3f
    a0b0:	00016e6e 	.word	0x00016e6e
    a0b4:	00016e9d 	.word	0x00016e9d
    a0b8:	00016ee6 	.word	0x00016ee6
    a0bc:	00016f50 	.word	0x00016f50
    a0c0:	00016f7f 	.word	0x00016f7f
    a0c4:	00016fae 	.word	0x00016fae

0000a0c8 <grid_ui_reinit>:
void grid_ui_reinit(struct grid_ui_model* ui){
    a0c8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a0cc:	4606      	mov	r6, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a0ce:	2700      	movs	r7, #0
    a0d0:	7873      	ldrb	r3, [r6, #1]
    a0d2:	b2fc      	uxtb	r4, r7
    a0d4:	42a3      	cmp	r3, r4
    a0d6:	d805      	bhi.n	a0e4 <grid_ui_reinit+0x1c>
	grid_sys_state.bank_active_changed = 1;
    a0d8:	4b18      	ldr	r3, [pc, #96]	; (a13c <grid_ui_reinit+0x74>)
    a0da:	2201      	movs	r2, #1
    a0dc:	745a      	strb	r2, [r3, #17]
}
    a0de:	b003      	add	sp, #12
    a0e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a0e4:	6873      	ldr	r3, [r6, #4]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a0e6:	f04f 0800 	mov.w	r8, #0
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a0ea:	eb03 1404 	add.w	r4, r3, r4, lsl #4
			struct grid_ui_element* ele = &bank->element_list[j];
    a0ee:	f04f 0b64 	mov.w	fp, #100	; 0x64
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a0f2:	7a63      	ldrb	r3, [r4, #9]
    a0f4:	fa5f f088 	uxtb.w	r0, r8
    a0f8:	4283      	cmp	r3, r0
    a0fa:	d801      	bhi.n	a100 <grid_ui_reinit+0x38>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a0fc:	3701      	adds	r7, #1
    a0fe:	e7e7      	b.n	a0d0 <grid_ui_reinit+0x8>
			struct grid_ui_element* ele = &bank->element_list[j];
    a100:	68e3      	ldr	r3, [r4, #12]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a102:	f04f 0900 	mov.w	r9, #0
			struct grid_ui_element* ele = &bank->element_list[j];
    a106:	fb0b 3000 	mla	r0, fp, r0, r3
				struct grid_ui_event* eve = &ele->event_list[k];
    a10a:	f04f 0abc 	mov.w	sl, #188	; 0xbc
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a10e:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
    a112:	fa5f f589 	uxtb.w	r5, r9
    a116:	42a9      	cmp	r1, r5
    a118:	d802      	bhi.n	a120 <grid_ui_reinit+0x58>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a11a:	f108 0801 	add.w	r8, r8, #1
    a11e:	e7e8      	b.n	a0f2 <grid_ui_reinit+0x2a>
				struct grid_ui_event* eve = &ele->event_list[k];
    a120:	6e01      	ldr	r1, [r0, #96]	; 0x60
				grid_ui_event_generate_actionstring(ele, eve->type);
    a122:	4b07      	ldr	r3, [pc, #28]	; (a140 <grid_ui_reinit+0x78>)
    a124:	9001      	str	r0, [sp, #4]
				struct grid_ui_event* eve = &ele->event_list[k];
    a126:	fb0a 1505 	mla	r5, sl, r5, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a12a:	f109 0901 	add.w	r9, r9, #1
    a12e:	7aa9      	ldrb	r1, [r5, #10]
    a130:	4798      	blx	r3
}


void grid_ui_event_reset(struct grid_ui_event* eve){
	
	eve->trigger = GRID_UI_STATUS_READY;
    a132:	2204      	movs	r2, #4
    a134:	9801      	ldr	r0, [sp, #4]
    a136:	726a      	strb	r2, [r5, #9]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a138:	e7e9      	b.n	a10e <grid_ui_reinit+0x46>
    a13a:	bf00      	nop
    a13c:	2000f008 	.word	0x2000f008
    a140:	00009fa1 	.word	0x00009fa1

0000a144 <grid_ui_event_find>:
uint8_t grid_ui_event_find(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a144:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a146:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
    a14a:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a14c:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a14e:	27bc      	movs	r7, #188	; 0xbc
    a150:	b2dd      	uxtb	r5, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a152:	42ae      	cmp	r6, r5
    a154:	d801      	bhi.n	a15a <grid_ui_event_find+0x16>
}
    a156:	4610      	mov	r0, r2
    a158:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a15a:	6e04      	ldr	r4, [r0, #96]	; 0x60
    a15c:	fb07 4403 	mla	r4, r7, r3, r4
    a160:	3301      	adds	r3, #1
    a162:	7aa4      	ldrb	r4, [r4, #10]
    a164:	428c      	cmp	r4, r1
    a166:	bf08      	it	eq
    a168:	462a      	moveq	r2, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a16a:	e7f1      	b.n	a150 <grid_ui_event_find+0xc>

0000a16c <grid_ui_event_trigger>:
	if (event_index == 255){
    a16c:	29ff      	cmp	r1, #255	; 0xff
    a16e:	d005      	beq.n	a17c <grid_ui_event_trigger+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED;
    a170:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a172:	23bc      	movs	r3, #188	; 0xbc
    a174:	fb01 2103 	mla	r1, r1, r3, r2
    a178:	2305      	movs	r3, #5
    a17a:	724b      	strb	r3, [r1, #9]
}
    a17c:	4770      	bx	lr

0000a17e <grid_ui_event_trigger_local>:
	if (event_index == 255){
    a17e:	29ff      	cmp	r1, #255	; 0xff
    a180:	d005      	beq.n	a18e <grid_ui_event_trigger_local+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED_LOCAL;
    a182:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a184:	23bc      	movs	r3, #188	; 0xbc
    a186:	fb01 2103 	mla	r1, r1, r3, r2
    a18a:	2306      	movs	r3, #6
    a18c:	724b      	strb	r3, [r1, #9]
}
    a18e:	4770      	bx	lr

0000a190 <grid_ui_smart_trigger>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a190:	6840      	ldr	r0, [r0, #4]
    a192:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a196:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a198:	68c4      	ldr	r4, [r0, #12]
    a19a:	2064      	movs	r0, #100	; 0x64
    a19c:	fb02 4400 	mla	r4, r2, r0, r4
    a1a0:	4619      	mov	r1, r3
    a1a2:	4620      	mov	r0, r4
    a1a4:	4b05      	ldr	r3, [pc, #20]	; (a1bc <grid_ui_smart_trigger+0x2c>)
    a1a6:	4798      	blx	r3
	if (event_index == 255){
    a1a8:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a1aa:	4601      	mov	r1, r0
	if (event_index == 255){
    a1ac:	d004      	beq.n	a1b8 <grid_ui_smart_trigger+0x28>
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a1ae:	4620      	mov	r0, r4
    a1b0:	4b03      	ldr	r3, [pc, #12]	; (a1c0 <grid_ui_smart_trigger+0x30>)
}
    a1b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a1b6:	4718      	bx	r3
}
    a1b8:	bd10      	pop	{r4, pc}
    a1ba:	bf00      	nop
    a1bc:	0000a145 	.word	0x0000a145
    a1c0:	0000a16d 	.word	0x0000a16d

0000a1c4 <grid_ui_event_register_eventstring>:
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a1c4:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a1c8:	4604      	mov	r4, r0
	grid_debug_print_text("Register Action");
    a1ca:	4e28      	ldr	r6, [pc, #160]	; (a26c <grid_ui_event_register_eventstring+0xa8>)
    a1cc:	4828      	ldr	r0, [pc, #160]	; (a270 <grid_ui_event_register_eventstring+0xac>)
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a1ce:	4699      	mov	r9, r3
    a1d0:	4688      	mov	r8, r1
    a1d2:	4692      	mov	sl, r2
	grid_debug_print_text("Register Action");
    a1d4:	47b0      	blx	r6
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a1d6:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    a1da:	46b3      	mov	fp, r6
    a1dc:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a1de:	25ff      	movs	r5, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a1e0:	26bc      	movs	r6, #188	; 0xbc
    a1e2:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a1e4:	4288      	cmp	r0, r1
    a1e6:	d807      	bhi.n	a1f8 <grid_ui_event_register_eventstring+0x34>
	if (event_index == 255){
    a1e8:	2dff      	cmp	r5, #255	; 0xff
    a1ea:	d10e      	bne.n	a20a <grid_ui_event_register_eventstring+0x46>
		grid_debug_print_text("Event Not Found");
    a1ec:	4821      	ldr	r0, [pc, #132]	; (a274 <grid_ui_event_register_eventstring+0xb0>)
    a1ee:	465b      	mov	r3, fp
}
    a1f0:	b001      	add	sp, #4
    a1f2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		grid_debug_print_text("Event Not Found");
    a1f6:	4718      	bx	r3
		if (ele->event_list[i].type == event_type){
    a1f8:	6e22      	ldr	r2, [r4, #96]	; 0x60
    a1fa:	fb06 2203 	mla	r2, r6, r3, r2
    a1fe:	3301      	adds	r3, #1
    a200:	7a92      	ldrb	r2, [r2, #10]
    a202:	4542      	cmp	r2, r8
    a204:	bf08      	it	eq
    a206:	460d      	moveq	r5, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a208:	e7eb      	b.n	a1e2 <grid_ui_event_register_eventstring+0x1e>
		ele->event_list[event_index].event_string[i] = 0;
    a20a:	23bc      	movs	r3, #188	; 0xbc
    a20c:	fb15 f503 	smulbb	r5, r5, r3
    a210:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a212:	442b      	add	r3, r5
    a214:	f103 0210 	add.w	r2, r3, #16
    a218:	f103 002e 	add.w	r0, r3, #46	; 0x2e
    a21c:	2100      	movs	r1, #0
    a21e:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a222:	4282      	cmp	r2, r0
    a224:	d1fb      	bne.n	a21e <grid_ui_event_register_eventstring+0x5a>
			grid_debug_print_text(" Escaped Char Found ");
    a226:	4814      	ldr	r0, [pc, #80]	; (a278 <grid_ui_event_register_eventstring+0xb4>)
	ele->event_list[event_index].event_string_length = 0;
    a228:	60d9      	str	r1, [r3, #12]
	for (uint32_t i=0; i<event_string_length; i++){
    a22a:	2600      	movs	r6, #0
    a22c:	6e27      	ldr	r7, [r4, #96]	; 0x60
    a22e:	454e      	cmp	r6, r9
    a230:	442f      	add	r7, r5
    a232:	d10b      	bne.n	a24c <grid_ui_event_register_eventstring+0x88>
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a234:	6860      	ldr	r0, [r4, #4]
	ele->event_list[event_index].event_string_length = event_string_length;
    a236:	60fe      	str	r6, [r7, #12]
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a238:	7a22      	ldrb	r2, [r4, #8]
    a23a:	4c10      	ldr	r4, [pc, #64]	; (a27c <grid_ui_event_register_eventstring+0xb8>)
    a23c:	7a01      	ldrb	r1, [r0, #8]
    a23e:	6840      	ldr	r0, [r0, #4]
    a240:	4643      	mov	r3, r8
    a242:	46a4      	mov	ip, r4
}
    a244:	b001      	add	sp, #4
    a246:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a24a:	4760      	bx	ip
		ele->event_list[event_index].event_string[i] = event_string[i];
    a24c:	f81a 3006 	ldrb.w	r3, [sl, r6]
    a250:	4437      	add	r7, r6
    a252:	743b      	strb	r3, [r7, #16]
		if (ele->event_list[event_index].event_string[i] > 127){
    a254:	061b      	lsls	r3, r3, #24
    a256:	d507      	bpl.n	a268 <grid_ui_event_register_eventstring+0xa4>
			grid_debug_print_text(" Escaped Char Found ");
    a258:	47d8      	blx	fp
			ele->event_list[event_index].event_string[i] -= 128;
    a25a:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a25c:	4806      	ldr	r0, [pc, #24]	; (a278 <grid_ui_event_register_eventstring+0xb4>)
    a25e:	442b      	add	r3, r5
    a260:	4433      	add	r3, r6
    a262:	7c1a      	ldrb	r2, [r3, #16]
    a264:	3a80      	subs	r2, #128	; 0x80
    a266:	741a      	strb	r2, [r3, #16]
	for (uint32_t i=0; i<event_string_length; i++){
    a268:	3601      	adds	r6, #1
    a26a:	e7df      	b.n	a22c <grid_ui_event_register_eventstring+0x68>
    a26c:	00009279 	.word	0x00009279
    a270:	00016fdd 	.word	0x00016fdd
    a274:	00016fed 	.word	0x00016fed
    a278:	00016ffd 	.word	0x00016ffd
    a27c:	0000a191 	.word	0x0000a191

0000a280 <grid_ui_event_generate_eventstring>:
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a280:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a282:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a286:	b089      	sub	sp, #36	; 0x24
    a288:	4605      	mov	r5, r0
    a28a:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a28c:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a28e:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a290:	27bc      	movs	r7, #188	; 0xbc
    a292:	b2d8      	uxtb	r0, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a294:	4286      	cmp	r6, r0
    a296:	d81a      	bhi.n	a2ce <grid_ui_event_generate_eventstring+0x4e>
	if (event_index == 255){
    a298:	2aff      	cmp	r2, #255	; 0xff
    a29a:	d016      	beq.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
	uint8_t event_string[GRID_UI_EVENT_STRING_maxlength] = {0};	
    a29c:	4b27      	ldr	r3, [pc, #156]	; (a33c <grid_ui_event_generate_eventstring+0xbc>)
    a29e:	2100      	movs	r1, #0
    a2a0:	221a      	movs	r2, #26
    a2a2:	a801      	add	r0, sp, #4
    a2a4:	9100      	str	r1, [sp, #0]
    a2a6:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    a2a8:	7a6b      	ldrb	r3, [r5, #9]
    a2aa:	2b02      	cmp	r3, #2
    a2ac:	d132      	bne.n	a314 <grid_ui_event_generate_eventstring+0x94>
		if (event_type == GRID_UI_EVENT_INIT){
    a2ae:	b9bc      	cbnz	r4, a2e0 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_INIT_BUT); // !!
    a2b0:	4923      	ldr	r1, [pc, #140]	; (a340 <grid_ui_event_generate_eventstring+0xc0>)
    a2b2:	4b24      	ldr	r3, [pc, #144]	; (a344 <grid_ui_event_generate_eventstring+0xc4>)
    a2b4:	4668      	mov	r0, sp
    a2b6:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2b8:	4b23      	ldr	r3, [pc, #140]	; (a348 <grid_ui_event_generate_eventstring+0xc8>)
    a2ba:	4668      	mov	r0, sp
    a2bc:	4798      	blx	r3
    a2be:	466a      	mov	r2, sp
    a2c0:	4603      	mov	r3, r0
    a2c2:	2100      	movs	r1, #0
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2c4:	4c21      	ldr	r4, [pc, #132]	; (a34c <grid_ui_event_generate_eventstring+0xcc>)
    a2c6:	4628      	mov	r0, r5
    a2c8:	47a0      	blx	r4
}
    a2ca:	b009      	add	sp, #36	; 0x24
    a2cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a2ce:	6e29      	ldr	r1, [r5, #96]	; 0x60
    a2d0:	fb07 1103 	mla	r1, r7, r3, r1
    a2d4:	3301      	adds	r3, #1
    a2d6:	7a89      	ldrb	r1, [r1, #10]
    a2d8:	42a1      	cmp	r1, r4
    a2da:	bf08      	it	eq
    a2dc:	4602      	moveq	r2, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a2de:	e7d8      	b.n	a292 <grid_ui_event_generate_eventstring+0x12>
		else if (event_type == GRID_UI_EVENT_DP){
    a2e0:	2c04      	cmp	r4, #4
    a2e2:	d10a      	bne.n	a2fa <grid_ui_event_generate_eventstring+0x7a>
			sprintf(event_string, GRID_EVENTSTRING_DP_BUT); // !!
    a2e4:	491a      	ldr	r1, [pc, #104]	; (a350 <grid_ui_event_generate_eventstring+0xd0>)
    a2e6:	4b17      	ldr	r3, [pc, #92]	; (a344 <grid_ui_event_generate_eventstring+0xc4>)
    a2e8:	4668      	mov	r0, sp
    a2ea:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2ec:	4b16      	ldr	r3, [pc, #88]	; (a348 <grid_ui_event_generate_eventstring+0xc8>)
    a2ee:	4668      	mov	r0, sp
    a2f0:	4798      	blx	r3
    a2f2:	466a      	mov	r2, sp
    a2f4:	4603      	mov	r3, r0
    a2f6:	2104      	movs	r1, #4
    a2f8:	e7e4      	b.n	a2c4 <grid_ui_event_generate_eventstring+0x44>
		else if (event_type == GRID_UI_EVENT_DR){
    a2fa:	2c05      	cmp	r4, #5
    a2fc:	d1e5      	bne.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_DR_BUT); // !!
    a2fe:	4915      	ldr	r1, [pc, #84]	; (a354 <grid_ui_event_generate_eventstring+0xd4>)
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a300:	4b10      	ldr	r3, [pc, #64]	; (a344 <grid_ui_event_generate_eventstring+0xc4>)
    a302:	4668      	mov	r0, sp
    a304:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a306:	4b10      	ldr	r3, [pc, #64]	; (a348 <grid_ui_event_generate_eventstring+0xc8>)
    a308:	4668      	mov	r0, sp
    a30a:	4798      	blx	r3
    a30c:	466a      	mov	r2, sp
    a30e:	4603      	mov	r3, r0
    a310:	4621      	mov	r1, r4
    a312:	e7d7      	b.n	a2c4 <grid_ui_event_generate_eventstring+0x44>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a314:	2b01      	cmp	r3, #1
    a316:	d105      	bne.n	a324 <grid_ui_event_generate_eventstring+0xa4>
		if (event_type == GRID_UI_EVENT_INIT){
    a318:	2c00      	cmp	r4, #0
    a31a:	d0c9      	beq.n	a2b0 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a31c:	2c01      	cmp	r4, #1
    a31e:	d1d4      	bne.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_POT); // !!
    a320:	490d      	ldr	r1, [pc, #52]	; (a358 <grid_ui_event_generate_eventstring+0xd8>)
    a322:	e7ed      	b.n	a300 <grid_ui_event_generate_eventstring+0x80>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a324:	2b03      	cmp	r3, #3
    a326:	d1d0      	bne.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
		if (event_type == GRID_UI_EVENT_INIT){
    a328:	2c00      	cmp	r4, #0
    a32a:	d0c1      	beq.n	a2b0 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a32c:	2c01      	cmp	r4, #1
    a32e:	d101      	bne.n	a334 <grid_ui_event_generate_eventstring+0xb4>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_ENC); // !!
    a330:	490a      	ldr	r1, [pc, #40]	; (a35c <grid_ui_event_generate_eventstring+0xdc>)
    a332:	e7e5      	b.n	a300 <grid_ui_event_generate_eventstring+0x80>
		else if (event_type == GRID_UI_EVENT_ENCPUSHROT){
    a334:	2c0d      	cmp	r4, #13
    a336:	d1d3      	bne.n	a2e0 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a338:	4909      	ldr	r1, [pc, #36]	; (a360 <grid_ui_event_generate_eventstring+0xe0>)
    a33a:	e7e1      	b.n	a300 <grid_ui_event_generate_eventstring+0x80>
    a33c:	00014469 	.word	0x00014469
    a340:	00017012 	.word	0x00017012
    a344:	00014ebd 	.word	0x00014ebd
    a348:	00014f81 	.word	0x00014f81
    a34c:	0000a1c5 	.word	0x0000a1c5
    a350:	0001702b 	.word	0x0001702b
    a354:	00017049 	.word	0x00017049
    a358:	00017067 	.word	0x00017067
    a35c:	00017085 	.word	0x00017085
    a360:	000170a3 	.word	0x000170a3

0000a364 <grid_ui_event_init>:
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a364:	b570      	push	{r4, r5, r6, lr}
	struct grid_ui_event* eve = &parent->event_list[index];
    a366:	6e06      	ldr	r6, [r0, #96]	; 0x60
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a368:	4615      	mov	r5, r2
	struct grid_ui_event* eve = &parent->event_list[index];
    a36a:	22bc      	movs	r2, #188	; 0xbc
    a36c:	fb11 f202 	smulbb	r2, r1, r2
    a370:	18b4      	adds	r4, r6, r2
	eve->cfg_changed_flag = 0;
    a372:	2300      	movs	r3, #0
	eve->index = index;
    a374:	7221      	strb	r1, [r4, #8]
	eve->status = GRID_UI_STATUS_READY;
    a376:	2104      	movs	r1, #4
	eve->parent = parent;
    a378:	6060      	str	r0, [r4, #4]
	eve->cfg_changed_flag = 0;
    a37a:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	eve->type   = event_type;	
    a37e:	72a5      	strb	r5, [r4, #10]
	eve->status = GRID_UI_STATUS_READY;
    a380:	54b1      	strb	r1, [r6, r2]
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a382:	f104 0210 	add.w	r2, r4, #16
    a386:	f104 012e 	add.w	r1, r4, #46	; 0x2e
		eve->event_string[i] = 0;
    a38a:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a38e:	428a      	cmp	r2, r1
    a390:	d1fb      	bne.n	a38a <grid_ui_event_init+0x26>
	eve->event_string_length = 0;
    a392:	60e3      	str	r3, [r4, #12]
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a394:	f104 01b6 	add.w	r1, r4, #182	; 0xb6
    a398:	f104 0334 	add.w	r3, r4, #52	; 0x34
		eve->action_string[i] = 0;
    a39c:	2200      	movs	r2, #0
    a39e:	f803 2b01 	strb.w	r2, [r3], #1
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a3a2:	4299      	cmp	r1, r3
    a3a4:	d1fb      	bne.n	a39e <grid_ui_event_init+0x3a>
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a3a6:	4b08      	ldr	r3, [pc, #32]	; (a3c8 <grid_ui_event_init+0x64>)
	eve->action_string_length = 0;
    a3a8:	6322      	str	r2, [r4, #48]	; 0x30
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a3aa:	4629      	mov	r1, r5
    a3ac:	4798      	blx	r3
	grid_ui_event_generate_actionstring(eve->parent, event_type);	
    a3ae:	4b07      	ldr	r3, [pc, #28]	; (a3cc <grid_ui_event_init+0x68>)
    a3b0:	6860      	ldr	r0, [r4, #4]
    a3b2:	4629      	mov	r1, r5
    a3b4:	4798      	blx	r3
	eve->cfg_changed_flag = 0;
    a3b6:	f44f 7380 	mov.w	r3, #256	; 0x100
    a3ba:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
	eve->cfg_flashempty_flag = 1;
    a3be:	2301      	movs	r3, #1
    a3c0:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
}
    a3c4:	bd70      	pop	{r4, r5, r6, pc}
    a3c6:	bf00      	nop
    a3c8:	0000a281 	.word	0x0000a281
    a3cc:	00009fa1 	.word	0x00009fa1

0000a3d0 <grid_ui_element_init>:
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a3d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct grid_ui_element* ele = &parent->element_list[index];
    a3d4:	2364      	movs	r3, #100	; 0x64
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a3d6:	4615      	mov	r5, r2
	struct grid_ui_element* ele = &parent->element_list[index];
    a3d8:	68c2      	ldr	r2, [r0, #12]
    a3da:	fb11 f303 	smulbb	r3, r1, r3
    a3de:	18d4      	adds	r4, r2, r3
	ele->index = index;
    a3e0:	7221      	strb	r1, [r4, #8]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a3e2:	2101      	movs	r1, #1
	ele->parent = parent;
    a3e4:	6060      	str	r0, [r4, #4]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a3e6:	54d1      	strb	r1, [r2, r3]
	ele->type = element_type;
    a3e8:	7265      	strb	r5, [r4, #9]
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a3ea:	f104 030c 	add.w	r3, r4, #12
    a3ee:	f104 025c 	add.w	r2, r4, #92	; 0x5c
		ele->template_parameter_list[i] = 0;
    a3f2:	2100      	movs	r1, #0
    a3f4:	f843 1b04 	str.w	r1, [r3], #4
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a3f8:	429a      	cmp	r2, r3
    a3fa:	d1fb      	bne.n	a3f4 <grid_ui_element_init+0x24>
	if (element_type == GRID_UI_ELEMENT_SYSTEM){
    a3fc:	bb1d      	cbnz	r5, a446 <grid_ui_element_init+0x76>
		ele->event_list_length = 6;
    a3fe:	2306      	movs	r3, #6
    a400:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a404:	f44f 608d 	mov.w	r0, #1128	; 0x468
    a408:	4b34      	ldr	r3, [pc, #208]	; (a4dc <grid_ui_element_init+0x10c>)
    a40a:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a40c:	462a      	mov	r2, r5
    a40e:	4629      	mov	r1, r5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a410:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a412:	4d33      	ldr	r5, [pc, #204]	; (a4e0 <grid_ui_element_init+0x110>)
    a414:	4620      	mov	r0, r4
    a416:	47a8      	blx	r5
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_HEARTBEAT); // Heartbeat
    a418:	220c      	movs	r2, #12
    a41a:	2101      	movs	r1, #1
    a41c:	4620      	mov	r0, r4
    a41e:	47a8      	blx	r5
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_MAPMODE_PRESS); // Mapmode press
    a420:	2207      	movs	r2, #7
    a422:	2102      	movs	r1, #2
    a424:	4620      	mov	r0, r4
    a426:	47a8      	blx	r5
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_MAPMODE_RELEASE); // Mapmode release
    a428:	2208      	movs	r2, #8
    a42a:	2103      	movs	r1, #3
    a42c:	4620      	mov	r0, r4
    a42e:	47a8      	blx	r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_CFG_RESPONSE); //
    a430:	2209      	movs	r2, #9
    a432:	2104      	movs	r1, #4
    a434:	4620      	mov	r0, r4
    a436:	47a8      	blx	r5
		grid_ui_event_init(ele, 5, GRID_UI_EVENT_CFG_REQUEST); //
    a438:	220a      	movs	r2, #10
    a43a:	2105      	movs	r1, #5
    a43c:	4620      	mov	r0, r4
    a43e:	462b      	mov	r3, r5
}
    a440:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a444:	4718      	bx	r3
	else if (element_type == GRID_UI_ELEMENT_POTENTIOMETER){
    a446:	2d01      	cmp	r5, #1
    a448:	d111      	bne.n	a46e <grid_ui_element_init+0x9e>
		ele->event_list_length = 2;
    a44a:	2302      	movs	r3, #2
    a44c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a450:	f44f 70bc 	mov.w	r0, #376	; 0x178
    a454:	4b21      	ldr	r3, [pc, #132]	; (a4dc <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a456:	4e22      	ldr	r6, [pc, #136]	; (a4e0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a458:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a45a:	2200      	movs	r2, #0
    a45c:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a45e:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a460:	4620      	mov	r0, r4
    a462:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a464:	462a      	mov	r2, r5
    a466:	4629      	mov	r1, r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a468:	4620      	mov	r0, r4
    a46a:	4633      	mov	r3, r6
    a46c:	e7e8      	b.n	a440 <grid_ui_element_init+0x70>
	else if (element_type == GRID_UI_ELEMENT_BUTTON){
    a46e:	2d02      	cmp	r5, #2
    a470:	d113      	bne.n	a49a <grid_ui_element_init+0xca>
		ele->event_list_length = 3;
    a472:	2303      	movs	r3, #3
    a474:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a478:	f44f 700d 	mov.w	r0, #564	; 0x234
    a47c:	4b17      	ldr	r3, [pc, #92]	; (a4dc <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a47e:	4e18      	ldr	r6, [pc, #96]	; (a4e0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a480:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a482:	2200      	movs	r2, #0
    a484:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a486:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a488:	4620      	mov	r0, r4
    a48a:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a48c:	2204      	movs	r2, #4
    a48e:	2101      	movs	r1, #1
    a490:	4620      	mov	r0, r4
    a492:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a494:	2205      	movs	r2, #5
    a496:	4629      	mov	r1, r5
    a498:	e7e6      	b.n	a468 <grid_ui_element_init+0x98>
	else if (element_type == GRID_UI_ELEMENT_ENCODER){
    a49a:	2d03      	cmp	r5, #3
    a49c:	d11b      	bne.n	a4d6 <grid_ui_element_init+0x106>
		ele->event_list_length = 5;
    a49e:	2705      	movs	r7, #5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a4a0:	4b0e      	ldr	r3, [pc, #56]	; (a4dc <grid_ui_element_init+0x10c>)
		ele->event_list_length = 5;
    a4a2:	f884 705c 	strb.w	r7, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a4a6:	f44f 706b 	mov.w	r0, #940	; 0x3ac
    a4aa:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a4ac:	2200      	movs	r2, #0
    a4ae:	4e0c      	ldr	r6, [pc, #48]	; (a4e0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a4b0:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a4b2:	4611      	mov	r1, r2
    a4b4:	4620      	mov	r0, r4
    a4b6:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a4b8:	2204      	movs	r2, #4
    a4ba:	2101      	movs	r1, #1
    a4bc:	4620      	mov	r0, r4
    a4be:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a4c0:	463a      	mov	r2, r7
    a4c2:	2102      	movs	r1, #2
    a4c4:	4620      	mov	r0, r4
    a4c6:	47b0      	blx	r6
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a4c8:	2201      	movs	r2, #1
    a4ca:	4629      	mov	r1, r5
    a4cc:	4620      	mov	r0, r4
    a4ce:	47b0      	blx	r6
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a4d0:	220d      	movs	r2, #13
    a4d2:	2104      	movs	r1, #4
    a4d4:	e7c8      	b.n	a468 <grid_ui_element_init+0x98>
}
    a4d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4da:	bf00      	nop
    a4dc:	00014315 	.word	0x00014315
    a4e0:	0000a365 	.word	0x0000a365

0000a4e4 <grid_ui_smart_trigger_local>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4e4:	6840      	ldr	r0, [r0, #4]
    a4e6:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger_local(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a4ea:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4ec:	68c4      	ldr	r4, [r0, #12]
    a4ee:	2064      	movs	r0, #100	; 0x64
    a4f0:	fb02 4400 	mla	r4, r2, r0, r4
    a4f4:	4619      	mov	r1, r3
    a4f6:	4620      	mov	r0, r4
    a4f8:	4b05      	ldr	r3, [pc, #20]	; (a510 <grid_ui_smart_trigger_local+0x2c>)
    a4fa:	4798      	blx	r3
	if (event_index == 255){
    a4fc:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4fe:	4601      	mov	r1, r0
	if (event_index == 255){
    a500:	d004      	beq.n	a50c <grid_ui_smart_trigger_local+0x28>
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a502:	4620      	mov	r0, r4
    a504:	4b03      	ldr	r3, [pc, #12]	; (a514 <grid_ui_smart_trigger_local+0x30>)
}
    a506:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a50a:	4718      	bx	r3
}
    a50c:	bd10      	pop	{r4, pc}
    a50e:	bf00      	nop
    a510:	0000a145 	.word	0x0000a145
    a514:	0000a17f 	.word	0x0000a17f

0000a518 <grid_ui_reinit_local>:
void grid_ui_reinit_local(struct grid_ui_model* ui){
    a518:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a51c:	4604      	mov	r4, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a51e:	f04f 0800 	mov.w	r8, #0
    a522:	7863      	ldrb	r3, [r4, #1]
    a524:	fa5f f788 	uxtb.w	r7, r8
    a528:	42bb      	cmp	r3, r7
    a52a:	d805      	bhi.n	a538 <grid_ui_reinit_local+0x20>
	grid_sys_state.bank_active_changed = 1;
    a52c:	4b1c      	ldr	r3, [pc, #112]	; (a5a0 <grid_ui_reinit_local+0x88>)
    a52e:	2201      	movs	r2, #1
    a530:	745a      	strb	r2, [r3, #17]
}
    a532:	b003      	add	sp, #12
    a534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a538:	6866      	ldr	r6, [r4, #4]
    a53a:	eb06 1307 	add.w	r3, r6, r7, lsl #4
    a53e:	9300      	str	r3, [sp, #0]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a540:	f04f 0900 	mov.w	r9, #0
    a544:	9b00      	ldr	r3, [sp, #0]
    a546:	7a5b      	ldrb	r3, [r3, #9]
    a548:	fa5f fb89 	uxtb.w	fp, r9
    a54c:	455b      	cmp	r3, fp
    a54e:	d802      	bhi.n	a556 <grid_ui_reinit_local+0x3e>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a550:	f108 0801 	add.w	r8, r8, #1
    a554:	e7e5      	b.n	a522 <grid_ui_reinit_local+0xa>
			struct grid_ui_element* ele = &bank->element_list[j];
    a556:	9b00      	ldr	r3, [sp, #0]
    a558:	68db      	ldr	r3, [r3, #12]
    a55a:	2564      	movs	r5, #100	; 0x64
    a55c:	fb05 350b 	mla	r5, r5, fp, r3
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a560:	f04f 0a00 	mov.w	sl, #0
    a564:	f895 105c 	ldrb.w	r1, [r5, #92]	; 0x5c
    a568:	fa5f f38a 	uxtb.w	r3, sl
    a56c:	4299      	cmp	r1, r3
    a56e:	d802      	bhi.n	a576 <grid_ui_reinit_local+0x5e>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a570:	f109 0901 	add.w	r9, r9, #1
    a574:	e7e6      	b.n	a544 <grid_ui_reinit_local+0x2c>
				struct grid_ui_event* eve = &ele->event_list[k];
    a576:	6e29      	ldr	r1, [r5, #96]	; 0x60
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a578:	4e0a      	ldr	r6, [pc, #40]	; (a5a4 <grid_ui_reinit_local+0x8c>)
				struct grid_ui_event* eve = &ele->event_list[k];
    a57a:	22bc      	movs	r2, #188	; 0xbc
    a57c:	fb02 1303 	mla	r3, r2, r3, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a580:	9301      	str	r3, [sp, #4]
    a582:	7a99      	ldrb	r1, [r3, #10]
    a584:	4b08      	ldr	r3, [pc, #32]	; (a5a8 <grid_ui_reinit_local+0x90>)
    a586:	4628      	mov	r0, r5
    a588:	4798      	blx	r3
	eve->trigger = GRID_UI_STATUS_READY;
    a58a:	9b01      	ldr	r3, [sp, #4]
    a58c:	2104      	movs	r1, #4
    a58e:	7259      	strb	r1, [r3, #9]
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a590:	465a      	mov	r2, fp
    a592:	7a9b      	ldrb	r3, [r3, #10]
    a594:	4639      	mov	r1, r7
    a596:	4620      	mov	r0, r4
    a598:	47b0      	blx	r6
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a59a:	f10a 0a01 	add.w	sl, sl, #1
    a59e:	e7e1      	b.n	a564 <grid_ui_reinit_local+0x4c>
    a5a0:	2000f008 	.word	0x2000f008
    a5a4:	0000a4e5 	.word	0x0000a4e5
    a5a8:	00009fa1 	.word	0x00009fa1

0000a5ac <grid_ui_event_render_action>:
		return 0;
	}
			
}

uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a5ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a5b0:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
    a5b4:	4606      	mov	r6, r0

	
	uint8_t temp[500] = {0};
    a5b6:	ac05      	add	r4, sp, #20
    a5b8:	4b74      	ldr	r3, [pc, #464]	; (a78c <grid_ui_event_render_action+0x1e0>)
uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a5ba:	9102      	str	r1, [sp, #8]
	uint8_t temp[500] = {0};
    a5bc:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
    a5c0:	2100      	movs	r1, #0
    a5c2:	a806      	add	r0, sp, #24
    a5c4:	6021      	str	r1, [r4, #0]
    a5c6:	4798      	blx	r3

	uint32_t i=0;
	
	// copy event string
	for(true; i<eve->event_string_length; i++){
    a5c8:	68f3      	ldr	r3, [r6, #12]
    a5ca:	18f1      	adds	r1, r6, r3
    a5cc:	f106 0210 	add.w	r2, r6, #16
    a5d0:	4620      	mov	r0, r4
    a5d2:	3110      	adds	r1, #16
    a5d4:	4291      	cmp	r1, r2
    a5d6:	d11e      	bne.n	a616 <grid_ui_event_render_action+0x6a>
		temp[i] = eve->event_string[i];
	
	}

	// copy action string
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a5d8:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a5da:	f106 0134 	add.w	r1, r6, #52	; 0x34
    a5de:	441a      	add	r2, r3
    a5e0:	429a      	cmp	r2, r3
    a5e2:	d81d      	bhi.n	a620 <grid_ui_event_render_action+0x74>


	uint32_t total_substituted_length = 0;

	uint8_t condition_state = 0;
	uint8_t condition_istrue = 0;
    a5e4:	2700      	movs	r7, #0
	uint8_t condition_state = 0;
    a5e6:	9701      	str	r7, [sp, #4]
	uint32_t total_substituted_length = 0;
    a5e8:	463d      	mov	r5, r7
	uint32_t block_start = 0;
    a5ea:	9700      	str	r7, [sp, #0]


	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a5ec:	463c      	mov	r4, r7
    a5ee:	68f0      	ldr	r0, [r6, #12]
    a5f0:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a5f2:	4418      	add	r0, r3
    a5f4:	42a0      	cmp	r0, r4
    a5f6:	d818      	bhi.n	a62a <grid_ui_event_render_action+0x7e>

	}
	
	
	// RESET ENCODER RELATIVE TEMPLATE PARAMETER VALUES
	if(eve->parent->type == GRID_UI_ELEMENT_ENCODER){	
    a5f8:	6873      	ldr	r3, [r6, #4]
    a5fa:	7a5a      	ldrb	r2, [r3, #9]
    a5fc:	2a03      	cmp	r2, #3
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = 255;	
    a5fe:	bf08      	it	eq
    a600:	22ff      	moveq	r2, #255	; 0xff
    }
	
	
	return eve->event_string_length + eve->action_string_length - total_substituted_length;
		
}
    a602:	eba0 0005 	sub.w	r0, r0, r5
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = 255;	
    a606:	bf04      	itt	eq
    a608:	e9c3 220d 	strdeq	r2, r2, [r3, #52]	; 0x34
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = 255;	
    a60c:	63da      	streq	r2, [r3, #60]	; 0x3c
}
    a60e:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
    a612:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		temp[i] = eve->event_string[i];
    a616:	f812 5b01 	ldrb.w	r5, [r2], #1
    a61a:	f800 5b01 	strb.w	r5, [r0], #1
	for(true; i<eve->event_string_length; i++){
    a61e:	e7d9      	b.n	a5d4 <grid_ui_event_render_action+0x28>
		temp[i] = eve->action_string[i - eve->event_string_length];
    a620:	f811 0b01 	ldrb.w	r0, [r1], #1
    a624:	54e0      	strb	r0, [r4, r3]
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a626:	3301      	adds	r3, #1
    a628:	e7da      	b.n	a5e0 <grid_ui_event_render_action+0x34>
		target_string[i-total_substituted_length] = temp[i];
    a62a:	f10d 0914 	add.w	r9, sp, #20
    a62e:	9a02      	ldr	r2, [sp, #8]
    a630:	f819 3004 	ldrb.w	r3, [r9, r4]
    a634:	eba4 0805 	sub.w	r8, r4, r5
		if (temp[i] == '{'){
    a638:	2b7b      	cmp	r3, #123	; 0x7b
		target_string[i-total_substituted_length] = temp[i];
    a63a:	f802 3008 	strb.w	r3, [r2, r8]
		if (temp[i] == '{'){
    a63e:	f000 80a2 	beq.w	a786 <grid_ui_event_render_action+0x1da>
		else if (temp[i] == '}'){
    a642:	2b7d      	cmp	r3, #125	; 0x7d
    a644:	f104 0a01 	add.w	sl, r4, #1
    a648:	d145      	bne.n	a6d6 <grid_ui_event_render_action+0x12a>
			if (block_length){
    a64a:	9b00      	ldr	r3, [sp, #0]
    a64c:	ebba 0b03 	subs.w	fp, sl, r3
    a650:	d030      	beq.n	a6b4 <grid_ui_event_render_action+0x108>
				grid_expr_set_current_event(&grid_expr_state, eve);
    a652:	4b4f      	ldr	r3, [pc, #316]	; (a790 <grid_ui_event_render_action+0x1e4>)
    a654:	484f      	ldr	r0, [pc, #316]	; (a794 <grid_ui_event_render_action+0x1e8>)
    a656:	4631      	mov	r1, r6
    a658:	4798      	blx	r3
				grid_expr_evaluate(&grid_expr_state, &temp[block_start+1], block_length-2); // -2 to not include {
    a65a:	9b00      	ldr	r3, [sp, #0]
    a65c:	484d      	ldr	r0, [pc, #308]	; (a794 <grid_ui_event_render_action+0x1e8>)
    a65e:	3301      	adds	r3, #1
    a660:	f1ab 0202 	sub.w	r2, fp, #2
    a664:	eb09 0103 	add.w	r1, r9, r3
    a668:	b2d2      	uxtb	r2, r2
    a66a:	f8df 9134 	ldr.w	r9, [pc, #308]	; a7a0 <grid_ui_event_render_action+0x1f4>
    a66e:	9303      	str	r3, [sp, #12]
    a670:	47c8      	blx	r9
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a672:	9b03      	ldr	r3, [sp, #12]
				for (uint8_t j = 0; j<block_length; j++){
    a674:	2100      	movs	r1, #0
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a676:	eb08 0003 	add.w	r0, r8, r3
    a67a:	eba0 0e0a 	sub.w	lr, r0, sl
    a67e:	468c      	mov	ip, r1
				for (uint8_t j = 0; j<block_length; j++){
    a680:	b2ca      	uxtb	r2, r1
    a682:	4593      	cmp	fp, r2
    a684:	f101 0101 	add.w	r1, r1, #1
    a688:	d816      	bhi.n	a6b8 <grid_ui_event_render_action+0x10c>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a68a:	4498      	add	r8, r3
    a68c:	9b02      	ldr	r3, [sp, #8]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a68e:	4a41      	ldr	r2, [pc, #260]	; (a794 <grid_ui_event_render_action+0x1e8>)
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a690:	eba8 0a0a 	sub.w	sl, r8, sl
    a694:	2000      	movs	r0, #0
    a696:	449a      	add	sl, r3
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a698:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
    a69c:	b2c1      	uxtb	r1, r0
    a69e:	428b      	cmp	r3, r1
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a6a0:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a6a4:	d80d      	bhi.n	a6c2 <grid_ui_event_render_action+0x116>
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    a6a6:	1aed      	subs	r5, r5, r3
				if (condition_state == 1){
    a6a8:	9b01      	ldr	r3, [sp, #4]
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    a6aa:	445d      	add	r5, fp
				if (condition_state == 1){
    a6ac:	b113      	cbz	r3, a6b4 <grid_ui_event_render_action+0x108>
					condition_istrue = grid_expr_state.return_value;
    a6ae:	f8d2 71fc 	ldr.w	r7, [r2, #508]	; 0x1fc
    a6b2:	b2ff      	uxtb	r7, r7
	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a6b4:	3401      	adds	r4, #1
    a6b6:	e79a      	b.n	a5ee <grid_ui_event_render_action+0x42>
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a6b8:	9802      	ldr	r0, [sp, #8]
    a6ba:	4402      	add	r2, r0
    a6bc:	f802 c00e 	strb.w	ip, [r2, lr]
				for (uint8_t j = 0; j<block_length; j++){
    a6c0:	e7de      	b.n	a680 <grid_ui_event_render_action+0xd4>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a6c2:	f1c3 03fa 	rsb	r3, r3, #250	; 0xfa
    a6c6:	440b      	add	r3, r1
    a6c8:	4413      	add	r3, r2
    a6ca:	3001      	adds	r0, #1
    a6cc:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
    a6d0:	f80a 3001 	strb.w	r3, [sl, r1]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a6d4:	e7e0      	b.n	a698 <grid_ui_event_render_action+0xec>
		else if(temp[i] == '#'){
    a6d6:	2b23      	cmp	r3, #35	; 0x23
    a6d8:	d1ec      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
			if (temp[i+1] == 'I' && temp[i+2] == 'F' ){
    a6da:	f819 300a 	ldrb.w	r3, [r9, sl]
    a6de:	2b49      	cmp	r3, #73	; 0x49
    a6e0:	d109      	bne.n	a6f6 <grid_ui_event_render_action+0x14a>
    a6e2:	1ca3      	adds	r3, r4, #2
    a6e4:	f819 2003 	ldrb.w	r2, [r9, r3]
    a6e8:	2a46      	cmp	r2, #70	; 0x46
    a6ea:	d1e3      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
				i+=2;
    a6ec:	461c      	mov	r4, r3
				condition_state = 1;
    a6ee:	2301      	movs	r3, #1
				total_substituted_length += 3;
    a6f0:	3503      	adds	r5, #3
				condition_state = 1;
    a6f2:	9301      	str	r3, [sp, #4]
    a6f4:	e7de      	b.n	a6b4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'T' && temp[i+2] == 'H' ){
    a6f6:	2b54      	cmp	r3, #84	; 0x54
    a6f8:	d121      	bne.n	a73e <grid_ui_event_render_action+0x192>
    a6fa:	1ca3      	adds	r3, r4, #2
    a6fc:	f819 2003 	ldrb.w	r2, [r9, r3]
    a700:	2a48      	cmp	r2, #72	; 0x48
    a702:	d1d7      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
				if (!condition_istrue){
    a704:	bbaf      	cbnz	r7, a772 <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a706:	f04f 0801 	mov.w	r8, #1
    a70a:	e009      	b.n	a720 <grid_ui_event_render_action+0x174>
						else if(j==(eve->event_string_length + eve->action_string_length)-i-1){
    a70c:	3b01      	subs	r3, #1
    a70e:	4543      	cmp	r3, r8
    a710:	d102      	bne.n	a718 <grid_ui_event_render_action+0x16c>
							printf("Syntax Error!\r\n");
    a712:	4821      	ldr	r0, [pc, #132]	; (a798 <grid_ui_event_render_action+0x1ec>)
    a714:	4b21      	ldr	r3, [pc, #132]	; (a79c <grid_ui_event_render_action+0x1f0>)
    a716:	4798      	blx	r3
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a718:	f108 0801 	add.w	r8, r8, #1
    a71c:	fa5f f888 	uxtb.w	r8, r8
    a720:	68f3      	ldr	r3, [r6, #12]
    a722:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a724:	4413      	add	r3, r2
    a726:	1b1b      	subs	r3, r3, r4
    a728:	4598      	cmp	r8, r3
    a72a:	d2c3      	bcs.n	a6b4 <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    a72c:	eb08 0204 	add.w	r2, r8, r4
    a730:	f819 1002 	ldrb.w	r1, [r9, r2]
    a734:	2923      	cmp	r1, #35	; 0x23
    a736:	d1e9      	bne.n	a70c <grid_ui_event_render_action+0x160>
							total_substituted_length += j;
    a738:	4445      	add	r5, r8
							i+=j-1;
    a73a:	1e54      	subs	r4, r2, #1
							break;
    a73c:	e7ba      	b.n	a6b4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'L' ){
    a73e:	2b45      	cmp	r3, #69	; 0x45
    a740:	d1b8      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
    a742:	1ca3      	adds	r3, r4, #2
    a744:	f819 2003 	ldrb.w	r2, [r9, r3]
    a748:	2a4c      	cmp	r2, #76	; 0x4c
    a74a:	d115      	bne.n	a778 <grid_ui_event_render_action+0x1cc>
				if (condition_istrue){
    a74c:	b18f      	cbz	r7, a772 <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a74e:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a750:	68f3      	ldr	r3, [r6, #12]
    a752:	4413      	add	r3, r2
    a754:	1b1a      	subs	r2, r3, r4
    a756:	2301      	movs	r3, #1
    a758:	4293      	cmp	r3, r2
    a75a:	d2ab      	bcs.n	a6b4 <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    a75c:	1919      	adds	r1, r3, r4
    a75e:	f819 0001 	ldrb.w	r0, [r9, r1]
    a762:	2823      	cmp	r0, #35	; 0x23
    a764:	d102      	bne.n	a76c <grid_ui_event_render_action+0x1c0>
							total_substituted_length += j;
    a766:	441d      	add	r5, r3
							i+=j-1;
    a768:	1e4c      	subs	r4, r1, #1
							break;
    a76a:	e7a3      	b.n	a6b4 <grid_ui_event_render_action+0x108>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a76c:	3301      	adds	r3, #1
    a76e:	b2db      	uxtb	r3, r3
    a770:	e7f2      	b.n	a758 <grid_ui_event_render_action+0x1ac>
					total_substituted_length += 3;
    a772:	3503      	adds	r5, #3
					i+=2;
    a774:	461c      	mov	r4, r3
    a776:	e79d      	b.n	a6b4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'N' ){
    a778:	2a4e      	cmp	r2, #78	; 0x4e
    a77a:	d19b      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
				condition_istrue = 0;
    a77c:	2700      	movs	r7, #0
				total_substituted_length += 3;
    a77e:	3503      	adds	r5, #3
				i+=2;
    a780:	461c      	mov	r4, r3
				condition_state = 0;
    a782:	9701      	str	r7, [sp, #4]
    a784:	e796      	b.n	a6b4 <grid_ui_event_render_action+0x108>
    a786:	9400      	str	r4, [sp, #0]
    a788:	e794      	b.n	a6b4 <grid_ui_event_render_action+0x108>
    a78a:	bf00      	nop
    a78c:	00014469 	.word	0x00014469
    a790:	00006411 	.word	0x00006411
    a794:	20013220 	.word	0x20013220
    a798:	000170c1 	.word	0x000170c1
    a79c:	000147bd 	.word	0x000147bd
    a7a0:	00006ba1 	.word	0x00006ba1

0000a7a4 <grid_port_process_ui>:
void grid_port_process_ui(struct grid_port* por){
    a7a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7a8:	4fb1      	ldr	r7, [pc, #708]	; (aa70 <grid_port_process_ui+0x2cc>)
void grid_port_process_ui(struct grid_port* por){
    a7aa:	f5ad 7d57 	sub.w	sp, sp, #860	; 0x35c
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7ae:	2100      	movs	r1, #0
void grid_port_process_ui(struct grid_port* por){
    a7b0:	9001      	str	r0, [sp, #4]
	uint8_t message_local_action_available = 0;
    a7b2:	4688      	mov	r8, r1
	uint8_t message_broadcast_action_available = 0;
    a7b4:	460d      	mov	r5, r1
    a7b6:	46ba      	mov	sl, r7
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a7b8:	f04f 0c64 	mov.w	ip, #100	; 0x64
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7bc:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7c0:	787a      	ldrb	r2, [r7, #1]
    a7c2:	b2cb      	uxtb	r3, r1
    a7c4:	429a      	cmp	r2, r3
    a7c6:	d95e      	bls.n	a886 <grid_port_process_ui+0xe2>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a7c8:	011b      	lsls	r3, r3, #4
    a7ca:	2400      	movs	r4, #0
    a7cc:	e02e      	b.n	a82c <grid_port_process_ui+0x88>
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7ce:	f8da 9004 	ldr.w	r9, [sl, #4]
    a7d2:	4499      	add	r9, r3
    a7d4:	fb0e f000 	mul.w	r0, lr, r0
    a7d8:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a7dc:	4491      	add	r9, r2
    a7de:	3601      	adds	r6, #1
    a7e0:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    a7e4:	4481      	add	r9, r0
    a7e6:	f899 9009 	ldrb.w	r9, [r9, #9]
    a7ea:	f1b9 0f05 	cmp.w	r9, #5
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7ee:	f8da 9004 	ldr.w	r9, [sl, #4]
    a7f2:	4499      	add	r9, r3
					message_broadcast_action_available++;
    a7f4:	bf08      	it	eq
    a7f6:	3501      	addeq	r5, #1
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7f8:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a7fc:	4491      	add	r9, r2
					message_broadcast_action_available++;
    a7fe:	bf08      	it	eq
    a800:	b2ed      	uxtbeq	r5, r5
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a802:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    a806:	4448      	add	r0, r9
    a808:	7a40      	ldrb	r0, [r0, #9]
    a80a:	2806      	cmp	r0, #6
                    message_local_action_available++;
    a80c:	bf04      	itt	eq
    a80e:	f108 0801 	addeq.w	r8, r8, #1
    a812:	fa5f f888 	uxtbeq.w	r8, r8
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a816:	f8da 0004 	ldr.w	r0, [sl, #4]
    a81a:	4418      	add	r0, r3
    a81c:	68c0      	ldr	r0, [r0, #12]
    a81e:	4410      	add	r0, r2
    a820:	f890 905c 	ldrb.w	r9, [r0, #92]	; 0x5c
    a824:	b2f0      	uxtb	r0, r6
    a826:	4581      	cmp	r9, r0
    a828:	d8d1      	bhi.n	a7ce <grid_port_process_ui+0x2a>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a82a:	3401      	adds	r4, #1
    a82c:	f8da 2004 	ldr.w	r2, [sl, #4]
    a830:	441a      	add	r2, r3
    a832:	7a50      	ldrb	r0, [r2, #9]
    a834:	b2e2      	uxtb	r2, r4
    a836:	4290      	cmp	r0, r2
    a838:	d903      	bls.n	a842 <grid_port_process_ui+0x9e>
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a83a:	fb0c f202 	mul.w	r2, ip, r2
    a83e:	2600      	movs	r6, #0
    a840:	e7e9      	b.n	a816 <grid_port_process_ui+0x72>
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a842:	3101      	adds	r1, #1
    a844:	e7bc      	b.n	a7c0 <grid_port_process_ui+0x1c>
			if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    a846:	6870      	ldr	r0, [r6, #4]
    a848:	68c0      	ldr	r0, [r0, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a84a:	eb00 0e03 	add.w	lr, r0, r3
    a84e:	3201      	adds	r2, #1
    a850:	f8de 0060 	ldr.w	r0, [lr, #96]	; 0x60
    a854:	fb0c 0009 	mla	r0, ip, r9, r0
    a858:	7a40      	ldrb	r0, [r0, #9]
    a85a:	2805      	cmp	r0, #5
				message_broadcast_action_available++;
    a85c:	bf04      	itt	eq
    a85e:	3501      	addeq	r5, #1
    a860:	b2ed      	uxtbeq	r5, r5
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a862:	6870      	ldr	r0, [r6, #4]
    a864:	68c0      	ldr	r0, [r0, #12]
    a866:	4418      	add	r0, r3
    a868:	fa5f f982 	uxtb.w	r9, r2
    a86c:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
    a870:	4548      	cmp	r0, r9
    a872:	d8e8      	bhi.n	a846 <grid_port_process_ui+0xa2>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a874:	3101      	adds	r1, #1
    a876:	6863      	ldr	r3, [r4, #4]
    a878:	7a5a      	ldrb	r2, [r3, #9]
    a87a:	b2cb      	uxtb	r3, r1
    a87c:	429a      	cmp	r2, r3
    a87e:	d909      	bls.n	a894 <grid_port_process_ui+0xf0>
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a880:	437b      	muls	r3, r7
    a882:	2200      	movs	r2, #0
    a884:	e7ed      	b.n	a862 <grid_port_process_ui+0xbe>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a886:	4c7b      	ldr	r4, [pc, #492]	; (aa74 <grid_port_process_ui+0x2d0>)
    a888:	2100      	movs	r1, #0
    a88a:	4626      	mov	r6, r4
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a88c:	2764      	movs	r7, #100	; 0x64
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a88e:	f04f 0cbc 	mov.w	ip, #188	; 0xbc
    a892:	e7f0      	b.n	a876 <grid_port_process_ui+0xd2>
	struct grid_port* port[4] = {&GRID_PORT_N, &GRID_PORT_E, &GRID_PORT_S, &GRID_PORT_W};
    a894:	4b78      	ldr	r3, [pc, #480]	; (aa78 <grid_port_process_ui+0x2d4>)
    a896:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    a898:	ae07      	add	r6, sp, #28
    a89a:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    a89e:	2404      	movs	r4, #4
		if (port[k]->ping_flag == 1){
    a8a0:	f856 7b04 	ldr.w	r7, [r6], #4
    a8a4:	f642 7348 	movw	r3, #12104	; 0x2f48
    a8a8:	5cfb      	ldrb	r3, [r7, r3]
    a8aa:	2b01      	cmp	r3, #1
    a8ac:	d11f      	bne.n	a8ee <grid_port_process_ui+0x14a>
			if (grid_buffer_write_init(&port[k]->tx_buffer, port[k]->ping_packet_length)){
    a8ae:	f642 7347 	movw	r3, #12103	; 0x2f47
    a8b2:	f507 591c 	add.w	r9, r7, #9984	; 0x2700
    a8b6:	f109 093c 	add.w	r9, r9, #60	; 0x3c
    a8ba:	18fa      	adds	r2, r7, r3
    a8bc:	5cf9      	ldrb	r1, [r7, r3]
    a8be:	4b6f      	ldr	r3, [pc, #444]	; (aa7c <grid_port_process_ui+0x2d8>)
    a8c0:	9202      	str	r2, [sp, #8]
    a8c2:	4648      	mov	r0, r9
    a8c4:	4798      	blx	r3
    a8c6:	b170      	cbz	r0, a8e6 <grid_port_process_ui+0x142>
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    a8c8:	4b6d      	ldr	r3, [pc, #436]	; (aa80 <grid_port_process_ui+0x2dc>)
    a8ca:	f507 5b3c 	add.w	fp, r7, #12032	; 0x2f00
    a8ce:	f10b 0b33 	add.w	fp, fp, #51	; 0x33
    a8d2:	1bdb      	subs	r3, r3, r7
    a8d4:	9a02      	ldr	r2, [sp, #8]
    a8d6:	7811      	ldrb	r1, [r2, #0]
    a8d8:	eb03 020b 	add.w	r2, r3, fp
    a8dc:	4291      	cmp	r1, r2
    a8de:	d826      	bhi.n	a92e <grid_port_process_ui+0x18a>
				grid_buffer_write_acknowledge(&port[k]->tx_buffer);
    a8e0:	4b68      	ldr	r3, [pc, #416]	; (aa84 <grid_port_process_ui+0x2e0>)
    a8e2:	4648      	mov	r0, r9
    a8e4:	4798      	blx	r3
			port[k]->ping_flag = 0;
    a8e6:	f642 7248 	movw	r2, #12104	; 0x2f48
    a8ea:	2300      	movs	r3, #0
    a8ec:	54bb      	strb	r3, [r7, r2]
	for (uint8_t k = 0; k<4; k++){
    a8ee:	3c01      	subs	r4, #1
    a8f0:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    a8f4:	d1d4      	bne.n	a8a0 <grid_port_process_ui+0xfc>
	if (message_local_action_available){
    a8f6:	f1b8 0f00 	cmp.w	r8, #0
    a8fa:	d07e      	beq.n	a9fa <grid_port_process_ui+0x256>
		grid_msg_init(&message);
    a8fc:	4b62      	ldr	r3, [pc, #392]	; (aa88 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a8fe:	4e63      	ldr	r6, [pc, #396]	; (aa8c <grid_port_process_ui+0x2e8>)
		grid_msg_init(&message);
    a900:	a86f      	add	r0, sp, #444	; 0x1bc
    a902:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a904:	227f      	movs	r2, #127	; 0x7f
    a906:	4611      	mov	r1, r2
    a908:	4623      	mov	r3, r4
    a90a:	a86f      	add	r0, sp, #444	; 0x1bc
    a90c:	47b0      	blx	r6
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};				
    a90e:	4b60      	ldr	r3, [pc, #384]	; (aa90 <grid_port_process_ui+0x2ec>)
    a910:	940b      	str	r4, [sp, #44]	; 0x2c
    a912:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a916:	4621      	mov	r1, r4
    a918:	a80c      	add	r0, sp, #48	; 0x30
    a91a:	4798      	blx	r3
		uint32_t offset=0;
    a91c:	46a0      	mov	r8, r4
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    a91e:	f89a 3001 	ldrb.w	r3, [sl, #1]
    a922:	b2e6      	uxtb	r6, r4
    a924:	42b3      	cmp	r3, r6
    a926:	d956      	bls.n	a9d6 <grid_port_process_ui+0x232>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a928:	0136      	lsls	r6, r6, #4
    a92a:	2300      	movs	r3, #0
    a92c:	e043      	b.n	a9b6 <grid_port_process_ui+0x212>
    a92e:	9303      	str	r3, [sp, #12]
					grid_buffer_write_character(&port[k]->tx_buffer, port[k]->ping_packet[i]);
    a930:	f81b 1b01 	ldrb.w	r1, [fp], #1
    a934:	4b57      	ldr	r3, [pc, #348]	; (aa94 <grid_port_process_ui+0x2f0>)
    a936:	4648      	mov	r0, r9
    a938:	4798      	blx	r3
    a93a:	9b03      	ldr	r3, [sp, #12]
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    a93c:	e7ca      	b.n	a8d4 <grid_port_process_ui+0x130>
					if (offset>GRID_PARAMETER_PACKET_marign){
    a93e:	f1b8 0fc8 	cmp.w	r8, #200	; 0xc8
    a942:	d829      	bhi.n	a998 <grid_port_process_ui+0x1f4>
						CRITICAL_SECTION_ENTER()
    a944:	4b54      	ldr	r3, [pc, #336]	; (aa98 <grid_port_process_ui+0x2f4>)
    a946:	a805      	add	r0, sp, #20
    a948:	4798      	blx	r3
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a94a:	f8da 3004 	ldr.w	r3, [sl, #4]
    a94e:	4433      	add	r3, r6
    a950:	22bc      	movs	r2, #188	; 0xbc
    a952:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a954:	443b      	add	r3, r7
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a956:	fb02 fb0b 	mul.w	fp, r2, fp
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a95a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    a95c:	445b      	add	r3, fp
    a95e:	7a5b      	ldrb	r3, [r3, #9]
    a960:	2b06      	cmp	r3, #6
    a962:	d116      	bne.n	a992 <grid_port_process_ui+0x1ee>
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    a964:	f8da 3004 	ldr.w	r3, [sl, #4]
    a968:	4433      	add	r3, r6
    a96a:	68db      	ldr	r3, [r3, #12]
    a96c:	443b      	add	r3, r7
    a96e:	6e18      	ldr	r0, [r3, #96]	; 0x60
    a970:	ab0b      	add	r3, sp, #44	; 0x2c
    a972:	eb03 0108 	add.w	r1, r3, r8
    a976:	4458      	add	r0, fp
    a978:	4b48      	ldr	r3, [pc, #288]	; (aa9c <grid_port_process_ui+0x2f8>)
    a97a:	4798      	blx	r3
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    a97c:	f8da 3004 	ldr.w	r3, [sl, #4]
    a980:	4433      	add	r3, r6
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    a982:	4480      	add	r8, r0
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    a984:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    a986:	443b      	add	r3, r7
    a988:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    a98a:	449b      	add	fp, r3
    a98c:	2304      	movs	r3, #4
    a98e:	f88b 3009 	strb.w	r3, [fp, #9]
						CRITICAL_SECTION_LEAVE()
    a992:	4b43      	ldr	r3, [pc, #268]	; (aaa0 <grid_port_process_ui+0x2fc>)
    a994:	a805      	add	r0, sp, #20
    a996:	4798      	blx	r3
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a998:	f109 0901 	add.w	r9, r9, #1
    a99c:	f8da 3004 	ldr.w	r3, [sl, #4]
    a9a0:	4433      	add	r3, r6
    a9a2:	fa5f fb89 	uxtb.w	fp, r9
    a9a6:	68db      	ldr	r3, [r3, #12]
    a9a8:	443b      	add	r3, r7
    a9aa:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    a9ae:	455b      	cmp	r3, fp
    a9b0:	d8c5      	bhi.n	a93e <grid_port_process_ui+0x19a>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a9b2:	9b02      	ldr	r3, [sp, #8]
    a9b4:	3301      	adds	r3, #1
    a9b6:	9302      	str	r3, [sp, #8]
    a9b8:	f8da 3004 	ldr.w	r3, [sl, #4]
    a9bc:	4433      	add	r3, r6
    a9be:	7a5a      	ldrb	r2, [r3, #9]
    a9c0:	f89d 3008 	ldrb.w	r3, [sp, #8]
    a9c4:	429a      	cmp	r2, r3
    a9c6:	d904      	bls.n	a9d2 <grid_port_process_ui+0x22e>
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a9c8:	2764      	movs	r7, #100	; 0x64
    a9ca:	435f      	muls	r7, r3
    a9cc:	f04f 0900 	mov.w	r9, #0
    a9d0:	e7e4      	b.n	a99c <grid_port_process_ui+0x1f8>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    a9d2:	3401      	adds	r4, #1
    a9d4:	e7a3      	b.n	a91e <grid_port_process_ui+0x17a>
		grid_msg_body_append_text(&message, payload, offset);
    a9d6:	a90b      	add	r1, sp, #44	; 0x2c
    a9d8:	4642      	mov	r2, r8
    a9da:	4b32      	ldr	r3, [pc, #200]	; (aaa4 <grid_port_process_ui+0x300>)
    a9dc:	a86f      	add	r0, sp, #444	; 0x1bc
    a9de:	4798      	blx	r3
		grid_msg_packet_close(&message);
    a9e0:	4b31      	ldr	r3, [pc, #196]	; (aaa8 <grid_port_process_ui+0x304>)
    a9e2:	a86f      	add	r0, sp, #444	; 0x1bc
    a9e4:	4798      	blx	r3
		uint32_t message_length = grid_msg_packet_get_length(&message);
    a9e6:	4b31      	ldr	r3, [pc, #196]	; (aaac <grid_port_process_ui+0x308>)
    a9e8:	a86f      	add	r0, sp, #444	; 0x1bc
    a9ea:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    a9ec:	4b23      	ldr	r3, [pc, #140]	; (aa7c <grid_port_process_ui+0x2d8>)
		uint32_t message_length = grid_msg_packet_get_length(&message);
    a9ee:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    a9f0:	b281      	uxth	r1, r0
    a9f2:	482f      	ldr	r0, [pc, #188]	; (aab0 <grid_port_process_ui+0x30c>)
    a9f4:	4798      	blx	r3
    a9f6:	2800      	cmp	r0, #0
    a9f8:	d132      	bne.n	aa60 <grid_port_process_ui+0x2bc>
	if (por->cooldown > 0){
    a9fa:	9b01      	ldr	r3, [sp, #4]
    a9fc:	681b      	ldr	r3, [r3, #0]
    a9fe:	b12b      	cbz	r3, aa0c <grid_port_process_ui+0x268>
		por->cooldown--;
    aa00:	3b01      	subs	r3, #1
    aa02:	9a01      	ldr	r2, [sp, #4]
	if (por->cooldown > 10){
    aa04:	2b0a      	cmp	r3, #10
		por->cooldown--;
    aa06:	6013      	str	r3, [r2, #0]
	if (por->cooldown > 10){
    aa08:	f200 80fc 	bhi.w	ac04 <grid_port_process_ui+0x460>
	if (message_broadcast_action_available){
    aa0c:	2d00      	cmp	r5, #0
    aa0e:	f000 80f9 	beq.w	ac04 <grid_port_process_ui+0x460>
		grid_msg_init(&message);
    aa12:	4b1d      	ldr	r3, [pc, #116]	; (aa88 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    aa14:	4c1d      	ldr	r4, [pc, #116]	; (aa8c <grid_port_process_ui+0x2e8>)
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    aa16:	f8df 805c 	ldr.w	r8, [pc, #92]	; aa74 <grid_port_process_ui+0x2d0>
		grid_msg_init(&message);
    aa1a:	a86f      	add	r0, sp, #444	; 0x1bc
    aa1c:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    aa1e:	227f      	movs	r2, #127	; 0x7f
    aa20:	2300      	movs	r3, #0
    aa22:	4611      	mov	r1, r2
    aa24:	a86f      	add	r0, sp, #444	; 0x1bc
    aa26:	47a0      	blx	r4
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    aa28:	2700      	movs	r7, #0
    aa2a:	4645      	mov	r5, r8
    aa2c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    aa30:	7a5a      	ldrb	r2, [r3, #9]
    aa32:	b2fb      	uxtb	r3, r7
    aa34:	429a      	cmp	r2, r3
    aa36:	f240 80d2 	bls.w	abde <grid_port_process_ui+0x43a>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    aa3a:	2464      	movs	r4, #100	; 0x64
					CRITICAL_SECTION_LEAVE()
    aa3c:	f8df b060 	ldr.w	fp, [pc, #96]	; aaa0 <grid_port_process_ui+0x2fc>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    aa40:	435c      	muls	r4, r3
    aa42:	2600      	movs	r6, #0
    aa44:	e067      	b.n	ab16 <grid_port_process_ui+0x372>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    aa46:	4631      	mov	r1, r6
    aa48:	a86f      	add	r0, sp, #444	; 0x1bc
    aa4a:	47b8      	blx	r7
    aa4c:	4601      	mov	r1, r0
    aa4e:	4640      	mov	r0, r8
    aa50:	47c8      	blx	r9
			for(uint32_t i = 0; i<message_length; i++){
    aa52:	3601      	adds	r6, #1
    aa54:	42a6      	cmp	r6, r4
    aa56:	d1f6      	bne.n	aa46 <grid_port_process_ui+0x2a2>
			grid_buffer_write_acknowledge(&GRID_PORT_U.tx_buffer);
    aa58:	4b0a      	ldr	r3, [pc, #40]	; (aa84 <grid_port_process_ui+0x2e0>)
    aa5a:	4815      	ldr	r0, [pc, #84]	; (aab0 <grid_port_process_ui+0x30c>)
    aa5c:	4798      	blx	r3
		}
    aa5e:	e7cc      	b.n	a9fa <grid_port_process_ui+0x256>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    aa60:	4f14      	ldr	r7, [pc, #80]	; (aab4 <grid_port_process_ui+0x310>)
    aa62:	f8df 804c 	ldr.w	r8, [pc, #76]	; aab0 <grid_port_process_ui+0x30c>
    aa66:	f8df 902c 	ldr.w	r9, [pc, #44]	; aa94 <grid_port_process_ui+0x2f0>
			for(uint32_t i = 0; i<message_length; i++){
    aa6a:	2600      	movs	r6, #0
    aa6c:	e7f2      	b.n	aa54 <grid_port_process_ui+0x2b0>
    aa6e:	bf00      	nop
    aa70:	2000effc 	.word	0x2000effc
    aa74:	2001c7c0 	.word	0x2001c7c0
    aa78:	000170d0 	.word	0x000170d0
    aa7c:	00004839 	.word	0x00004839
    aa80:	ffffd0cd 	.word	0xffffd0cd
    aa84:	00004895 	.word	0x00004895
    aa88:	000085c5 	.word	0x000085c5
    aa8c:	000085f9 	.word	0x000085f9
    aa90:	00014469 	.word	0x00014469
    aa94:	00004875 	.word	0x00004875
    aa98:	00011b59 	.word	0x00011b59
    aa9c:	0000a5ad 	.word	0x0000a5ad
    aaa0:	00011b67 	.word	0x00011b67
    aaa4:	00008535 	.word	0x00008535
    aaa8:	000086f1 	.word	0x000086f1
    aaac:	00008521 	.word	0x00008521
    aab0:	2000e7ec 	.word	0x2000e7ec
    aab4:	000086bb 	.word	0x000086bb
				if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    aab8:	4b5e      	ldr	r3, [pc, #376]	; (ac34 <grid_port_process_ui+0x490>)
    aaba:	a86f      	add	r0, sp, #444	; 0x1bc
    aabc:	4798      	blx	r3
    aabe:	28c8      	cmp	r0, #200	; 0xc8
    aac0:	d828      	bhi.n	ab14 <grid_port_process_ui+0x370>
					CRITICAL_SECTION_ENTER()
    aac2:	4b5d      	ldr	r3, [pc, #372]	; (ac38 <grid_port_process_ui+0x494>)
    aac4:	a806      	add	r0, sp, #24
    aac6:	4798      	blx	r3
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aac8:	686b      	ldr	r3, [r5, #4]
    aaca:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aacc:	4423      	add	r3, r4
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aace:	22bc      	movs	r2, #188	; 0xbc
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aad0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aad2:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aad6:	444b      	add	r3, r9
    aad8:	7a5b      	ldrb	r3, [r3, #9]
    aada:	2b05      	cmp	r3, #5
    aadc:	d118      	bne.n	ab10 <grid_port_process_ui+0x36c>
						uint32_t offset = grid_msg_body_get_length(&message); 
    aade:	4b57      	ldr	r3, [pc, #348]	; (ac3c <grid_port_process_ui+0x498>)
    aae0:	a86f      	add	r0, sp, #444	; 0x1bc
    aae2:	4798      	blx	r3
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    aae4:	686b      	ldr	r3, [r5, #4]
    aae6:	68db      	ldr	r3, [r3, #12]
    aae8:	4423      	add	r3, r4
    aaea:	3014      	adds	r0, #20
    aaec:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    aaee:	aa6f      	add	r2, sp, #444	; 0x1bc
    aaf0:	1811      	adds	r1, r2, r0
    aaf2:	eb03 0009 	add.w	r0, r3, r9
    aaf6:	4b52      	ldr	r3, [pc, #328]	; (ac40 <grid_port_process_ui+0x49c>)
    aaf8:	4798      	blx	r3
    aafa:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    aafc:	4418      	add	r0, r3
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    aafe:	686b      	ldr	r3, [r5, #4]
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    ab00:	90d4      	str	r0, [sp, #848]	; 0x350
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    ab02:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    ab04:	4423      	add	r3, r4
    ab06:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab08:	4499      	add	r9, r3
    ab0a:	2304      	movs	r3, #4
    ab0c:	f889 3009 	strb.w	r3, [r9, #9]
					CRITICAL_SECTION_LEAVE()
    ab10:	a806      	add	r0, sp, #24
    ab12:	47d8      	blx	fp
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ab14:	3601      	adds	r6, #1
    ab16:	686b      	ldr	r3, [r5, #4]
    ab18:	68db      	ldr	r3, [r3, #12]
    ab1a:	4423      	add	r3, r4
    ab1c:	fa5f f986 	uxtb.w	r9, r6
    ab20:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    ab24:	454b      	cmp	r3, r9
    ab26:	d8c7      	bhi.n	aab8 <grid_port_process_ui+0x314>
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    ab28:	3701      	adds	r7, #1
    ab2a:	e77f      	b.n	aa2c <grid_port_process_ui+0x288>
					if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    ab2c:	4b41      	ldr	r3, [pc, #260]	; (ac34 <grid_port_process_ui+0x490>)
    ab2e:	a86f      	add	r0, sp, #444	; 0x1bc
    ab30:	4798      	blx	r3
    ab32:	28c8      	cmp	r0, #200	; 0xc8
    ab34:	d82e      	bhi.n	ab94 <grid_port_process_ui+0x3f0>
						CRITICAL_SECTION_ENTER()
    ab36:	4b40      	ldr	r3, [pc, #256]	; (ac38 <grid_port_process_ui+0x494>)
    ab38:	a80b      	add	r0, sp, #44	; 0x2c
    ab3a:	4798      	blx	r3
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab3c:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab40:	4423      	add	r3, r4
    ab42:	22bc      	movs	r2, #188	; 0xbc
    ab44:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ab46:	442b      	add	r3, r5
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab48:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ab4c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab4e:	444b      	add	r3, r9
    ab50:	7a5b      	ldrb	r3, [r3, #9]
    ab52:	2b05      	cmp	r3, #5
    ab54:	d11c      	bne.n	ab90 <grid_port_process_ui+0x3ec>
							uint32_t offset = grid_msg_body_get_length(&message); 
    ab56:	4b39      	ldr	r3, [pc, #228]	; (ac3c <grid_port_process_ui+0x498>)
    ab58:	a86f      	add	r0, sp, #444	; 0x1bc
    ab5a:	4798      	blx	r3
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    ab5c:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab60:	4423      	add	r3, r4
    ab62:	3014      	adds	r0, #20
    ab64:	68db      	ldr	r3, [r3, #12]
    ab66:	442b      	add	r3, r5
    ab68:	aa6f      	add	r2, sp, #444	; 0x1bc
    ab6a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab6c:	1811      	adds	r1, r2, r0
    ab6e:	eb03 0009 	add.w	r0, r3, r9
    ab72:	4b33      	ldr	r3, [pc, #204]	; (ac40 <grid_port_process_ui+0x49c>)
    ab74:	4798      	blx	r3
    ab76:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    ab78:	4418      	add	r0, r3
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ab7a:	f8da 3004 	ldr.w	r3, [sl, #4]
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    ab7e:	90d4      	str	r0, [sp, #848]	; 0x350
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ab80:	4423      	add	r3, r4
    ab82:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    ab84:	442b      	add	r3, r5
    ab86:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab88:	4499      	add	r9, r3
    ab8a:	2304      	movs	r3, #4
    ab8c:	f889 3009 	strb.w	r3, [r9, #9]
						CRITICAL_SECTION_LEAVE()
    ab90:	a80b      	add	r0, sp, #44	; 0x2c
    ab92:	47d8      	blx	fp
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    ab94:	f108 0801 	add.w	r8, r8, #1
    ab98:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab9c:	4423      	add	r3, r4
    ab9e:	fa5f f988 	uxtb.w	r9, r8
    aba2:	68db      	ldr	r3, [r3, #12]
    aba4:	442b      	add	r3, r5
    aba6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    abaa:	454b      	cmp	r3, r9
    abac:	d8be      	bhi.n	ab2c <grid_port_process_ui+0x388>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    abae:	3601      	adds	r6, #1
    abb0:	f8da 3004 	ldr.w	r3, [sl, #4]
    abb4:	4423      	add	r3, r4
    abb6:	7a5a      	ldrb	r2, [r3, #9]
    abb8:	b2f3      	uxtb	r3, r6
    abba:	429a      	cmp	r2, r3
    abbc:	d906      	bls.n	abcc <grid_port_process_ui+0x428>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    abbe:	2564      	movs	r5, #100	; 0x64
						CRITICAL_SECTION_LEAVE()
    abc0:	f8df b094 	ldr.w	fp, [pc, #148]	; ac58 <grid_port_process_ui+0x4b4>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    abc4:	435d      	muls	r5, r3
    abc6:	f04f 0800 	mov.w	r8, #0
    abca:	e7e5      	b.n	ab98 <grid_port_process_ui+0x3f4>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    abcc:	3701      	adds	r7, #1
    abce:	f89a 3001 	ldrb.w	r3, [sl, #1]
    abd2:	b2fc      	uxtb	r4, r7
    abd4:	42a3      	cmp	r3, r4
    abd6:	d904      	bls.n	abe2 <grid_port_process_ui+0x43e>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    abd8:	0124      	lsls	r4, r4, #4
    abda:	2600      	movs	r6, #0
    abdc:	e7e8      	b.n	abb0 <grid_port_process_ui+0x40c>
    abde:	2700      	movs	r7, #0
    abe0:	e7f5      	b.n	abce <grid_port_process_ui+0x42a>
		por->cooldown += 10;
    abe2:	9b01      	ldr	r3, [sp, #4]
    abe4:	9a01      	ldr	r2, [sp, #4]
    abe6:	681b      	ldr	r3, [r3, #0]
    abe8:	330a      	adds	r3, #10
    abea:	6013      	str	r3, [r2, #0]
		grid_msg_packet_close(&message);
    abec:	a86f      	add	r0, sp, #444	; 0x1bc
    abee:	4b15      	ldr	r3, [pc, #84]	; (ac44 <grid_port_process_ui+0x4a0>)
    abf0:	4798      	blx	r3
		uint32_t length = grid_msg_packet_get_length(&message);
    abf2:	4b10      	ldr	r3, [pc, #64]	; (ac34 <grid_port_process_ui+0x490>)
    abf4:	a86f      	add	r0, sp, #444	; 0x1bc
    abf6:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    abf8:	4b13      	ldr	r3, [pc, #76]	; (ac48 <grid_port_process_ui+0x4a4>)
		uint32_t length = grid_msg_packet_get_length(&message);
    abfa:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    abfc:	b281      	uxth	r1, r0
    abfe:	4813      	ldr	r0, [pc, #76]	; (ac4c <grid_port_process_ui+0x4a8>)
    ac00:	4798      	blx	r3
    ac02:	b988      	cbnz	r0, ac28 <grid_port_process_ui+0x484>
}
    ac04:	f50d 7d57 	add.w	sp, sp, #860	; 0x35c
    ac08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    ac0c:	a86f      	add	r0, sp, #444	; 0x1bc
    ac0e:	47b0      	blx	r6
    ac10:	4601      	mov	r1, r0
    ac12:	4638      	mov	r0, r7
    ac14:	47c0      	blx	r8
			for(uint16_t i = 0; i<length; i++){
    ac16:	b2a9      	uxth	r1, r5
    ac18:	428c      	cmp	r4, r1
    ac1a:	f105 0501 	add.w	r5, r5, #1
    ac1e:	d8f5      	bhi.n	ac0c <grid_port_process_ui+0x468>
			grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    ac20:	4b0b      	ldr	r3, [pc, #44]	; (ac50 <grid_port_process_ui+0x4ac>)
    ac22:	480a      	ldr	r0, [pc, #40]	; (ac4c <grid_port_process_ui+0x4a8>)
    ac24:	4798      	blx	r3
		}
    ac26:	e7ed      	b.n	ac04 <grid_port_process_ui+0x460>
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    ac28:	4e0a      	ldr	r6, [pc, #40]	; (ac54 <grid_port_process_ui+0x4b0>)
    ac2a:	4f08      	ldr	r7, [pc, #32]	; (ac4c <grid_port_process_ui+0x4a8>)
    ac2c:	f8df 802c 	ldr.w	r8, [pc, #44]	; ac5c <grid_port_process_ui+0x4b8>
    ac30:	2500      	movs	r5, #0
    ac32:	e7f0      	b.n	ac16 <grid_port_process_ui+0x472>
    ac34:	00008521 	.word	0x00008521
    ac38:	00011b59 	.word	0x00011b59
    ac3c:	0000852f 	.word	0x0000852f
    ac40:	0000a5ad 	.word	0x0000a5ad
    ac44:	000086f1 	.word	0x000086f1
    ac48:	00004839 	.word	0x00004839
    ac4c:	2000ebe4 	.word	0x2000ebe4
    ac50:	00004895 	.word	0x00004895
    ac54:	000086bb 	.word	0x000086bb
    ac58:	00011b67 	.word	0x00011b67
    ac5c:	00004875 	.word	0x00004875

0000ac60 <grid_usb_serial_bulkout_cb>:
	//grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	
	//cdcdf_acm_write(cdcdf_demo_buf, count); /* Echo data */
	return false;                           /* No error. */
}
    ac60:	2000      	movs	r0, #0
    ac62:	4770      	bx	lr

0000ac64 <grid_usb_serial_statechange_cb>:

//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS); /* Another read */
	return false;                                                                                 /* No error. */
}
static bool grid_usb_serial_statechange_cb(usb_cdc_control_signal_t state)
{
    ac64:	b513      	push	{r0, r1, r4, lr}
	
	//grid_sys_alert_set_alert(&grid_sys_state, 0,255,255,2,300);
	
	if (state.rs232.DTR || 1) {
		/* After connection the R/W callbacks can be registered */
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    ac66:	4c06      	ldr	r4, [pc, #24]	; (ac80 <grid_usb_serial_statechange_cb+0x1c>)
{
    ac68:	f8ad 0004 	strh.w	r0, [sp, #4]
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    ac6c:	4905      	ldr	r1, [pc, #20]	; (ac84 <grid_usb_serial_statechange_cb+0x20>)
    ac6e:	2000      	movs	r0, #0
    ac70:	47a0      	blx	r4
		cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE, (FUNC_PTR)grid_usb_serial_bulkin_cb);
    ac72:	4905      	ldr	r1, [pc, #20]	; (ac88 <grid_usb_serial_statechange_cb+0x24>)
    ac74:	2001      	movs	r0, #1
    ac76:	47a0      	blx	r4
		/* Start Rx */
		//cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	}
	return false; /* No error. */
}
    ac78:	2000      	movs	r0, #0
    ac7a:	b002      	add	sp, #8
    ac7c:	bd10      	pop	{r4, pc}
    ac7e:	bf00      	nop
    ac80:	0000bdcd 	.word	0x0000bdcd
    ac84:	0000ac61 	.word	0x0000ac61
    ac88:	0000acdd 	.word	0x0000acdd

0000ac8c <grid_usb_midi_bulkin_cb>:

	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
	return false;
}
static bool grid_usb_midi_bulkin_cb(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
    ac8c:	b513      	push	{r0, r1, r4, lr}

	grid_sys_alert_set_alert(&grid_sys_state, 255,0,255,2,300);
    ac8e:	2302      	movs	r3, #2
    ac90:	f44f 7296 	mov.w	r2, #300	; 0x12c
    ac94:	e9cd 3200 	strd	r3, r2, [sp]
    ac98:	23ff      	movs	r3, #255	; 0xff
    ac9a:	4804      	ldr	r0, [pc, #16]	; (acac <grid_usb_midi_bulkin_cb+0x20>)
    ac9c:	4c04      	ldr	r4, [pc, #16]	; (acb0 <grid_usb_midi_bulkin_cb+0x24>)
    ac9e:	2200      	movs	r2, #0
    aca0:	4619      	mov	r1, r3
    aca2:	47a0      	blx	r4
	return false;
}
    aca4:	2000      	movs	r0, #0
    aca6:	b002      	add	sp, #8
    aca8:	bd10      	pop	{r4, pc}
    acaa:	bf00      	nop
    acac:	2000f008 	.word	0x2000f008
    acb0:	00009813 	.word	0x00009813

0000acb4 <grid_usb_midi_bulkout_cb>:
{
    acb4:	b513      	push	{r0, r1, r4, lr}
	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
    acb6:	2302      	movs	r3, #2
    acb8:	f44f 7296 	mov.w	r2, #300	; 0x12c
    acbc:	e9cd 3200 	strd	r3, r2, [sp]
    acc0:	22ff      	movs	r2, #255	; 0xff
    acc2:	4804      	ldr	r0, [pc, #16]	; (acd4 <grid_usb_midi_bulkout_cb+0x20>)
    acc4:	4c04      	ldr	r4, [pc, #16]	; (acd8 <grid_usb_midi_bulkout_cb+0x24>)
    acc6:	2300      	movs	r3, #0
    acc8:	4611      	mov	r1, r2
    acca:	47a0      	blx	r4
}
    accc:	2000      	movs	r0, #0
    acce:	b002      	add	sp, #8
    acd0:	bd10      	pop	{r4, pc}
    acd2:	bf00      	nop
    acd4:	2000f008 	.word	0x2000f008
    acd8:	00009813 	.word	0x00009813

0000acdc <grid_usb_serial_bulkin_cb>:
    acdc:	2000      	movs	r0, #0
    acde:	4770      	bx	lr

0000ace0 <grid_usb_serial_init>:
	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)grid_usb_serial_statechange_cb);
    ace0:	4901      	ldr	r1, [pc, #4]	; (ace8 <grid_usb_serial_init+0x8>)
    ace2:	4b02      	ldr	r3, [pc, #8]	; (acec <grid_usb_serial_init+0xc>)
    ace4:	2003      	movs	r0, #3
    ace6:	4718      	bx	r3
    ace8:	0000ac65 	.word	0x0000ac65
    acec:	0000bdcd 	.word	0x0000bdcd

0000acf0 <grid_keyboard_cleanup>:
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
	
	uint8_t changed_flag = 0;
	
	// Remove all inactive (released) keys
	for(uint8_t i=0; i<kb->key_active_count; i++){
    acf0:	2300      	movs	r3, #0
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    acf2:	b5f0      	push	{r4, r5, r6, r7, lr}
			
			changed_flag = 1;
			
			kb->key_list[i].ismodifier = 0;
			kb->key_list[i].ispressed = 0;
			kb->key_list[i].keycode = 255;	
    acf4:	f04f 0cff 	mov.w	ip, #255	; 0xff
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    acf8:	4604      	mov	r4, r0
			// Pop item, move each remaining after this forvard one index
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
				
				kb->key_list[j-1] = kb->key_list[j];
				
				kb->key_list[j].ismodifier = 0;
    acfa:	469e      	mov	lr, r3
	uint8_t changed_flag = 0;
    acfc:	4618      	mov	r0, r3
	for(uint8_t i=0; i<kb->key_active_count; i++){
    acfe:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    ad02:	429d      	cmp	r5, r3
    ad04:	d800      	bhi.n	ad08 <grid_keyboard_cleanup+0x18>
		// USB SEND
	}
	
	return changed_flag;
	
}
    ad06:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (kb->key_list[i].ispressed == false){
    ad08:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    ad0c:	7d8f      	ldrb	r7, [r1, #22]
    ad0e:	b98f      	cbnz	r7, ad34 <grid_keyboard_cleanup+0x44>
    ad10:	1c5a      	adds	r2, r3, #1
    ad12:	b2d6      	uxtb	r6, r2
			kb->key_list[i].ismodifier = 0;
    ad14:	754f      	strb	r7, [r1, #21]
			kb->key_list[i].ispressed = 0;
    ad16:	758f      	strb	r7, [r1, #22]
			kb->key_list[i].keycode = 255;	
    ad18:	f881 c014 	strb.w	ip, [r1, #20]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad1c:	eb04 02c6 	add.w	r2, r4, r6, lsl #3
    ad20:	42b5      	cmp	r5, r6
    ad22:	f102 0208 	add.w	r2, r2, #8
    ad26:	d108      	bne.n	ad3a <grid_keyboard_cleanup+0x4a>
			kb->key_active_count--;
    ad28:	3d01      	subs	r5, #1
			i--; // Retest this index, because it now points to a new item
    ad2a:	3b01      	subs	r3, #1
			kb->key_active_count--;
    ad2c:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
			i--; // Retest this index, because it now points to a new item
    ad30:	b2db      	uxtb	r3, r3
			changed_flag = 1;
    ad32:	2001      	movs	r0, #1
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad34:	3301      	adds	r3, #1
    ad36:	b2db      	uxtb	r3, r3
    ad38:	e7e1      	b.n	acfe <grid_keyboard_cleanup+0xe>
				kb->key_list[j-1] = kb->key_list[j];
    ad3a:	e9d2 0103 	ldrd	r0, r1, [r2, #12]
    ad3e:	1d17      	adds	r7, r2, #4
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad40:	3601      	adds	r6, #1
				kb->key_list[j-1] = kb->key_list[j];
    ad42:	e887 0003 	stmia.w	r7, {r0, r1}
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad46:	b2f6      	uxtb	r6, r6
				kb->key_list[j].ismodifier = 0;
    ad48:	f882 e00d 	strb.w	lr, [r2, #13]
				kb->key_list[j].ispressed = 0;
    ad4c:	f882 e00e 	strb.w	lr, [r2, #14]
				kb->key_list[j].keycode = 255;
    ad50:	f882 c00c 	strb.w	ip, [r2, #12]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad54:	e7e4      	b.n	ad20 <grid_keyboard_cleanup+0x30>
	...

0000ad58 <grid_keyboard_keychange>:


uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    ad58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ad5c:	4604      	mov	r4, r0
	uint8_t item_index = 255;
	uint8_t remove_flag = 0;
	uint8_t changed_flag = 0;
	

	grid_keyboard_cleanup(kb);
    ad5e:	f8df 814c 	ldr.w	r8, [pc, #332]	; aeac <grid_keyboard_keychange+0x154>
uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    ad62:	b0ec      	sub	sp, #432	; 0x1b0
    ad64:	460d      	mov	r5, r1
	grid_keyboard_cleanup(kb);
    ad66:	47c0      	blx	r8
	

	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad68:	2200      	movs	r2, #0
    ad6a:	f894 c044 	ldrb.w	ip, [r4, #68]	; 0x44
    ad6e:	4626      	mov	r6, r4
    ad70:	4623      	mov	r3, r4
	uint8_t changed_flag = 0;
    ad72:	4691      	mov	r9, r2
	uint8_t item_index = 255;
    ad74:	27ff      	movs	r7, #255	; 0xff
				if (key->ispressed == true){
					// OK nothing to do here
				}
				else{
					// Release the damn key
					kb->key_list[i].ispressed = false;
    ad76:	4696      	mov	lr, r2
    ad78:	b2d1      	uxtb	r1, r2
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad7a:	458c      	cmp	ip, r1
    ad7c:	d82e      	bhi.n	addc <grid_keyboard_keychange+0x84>
		}
		
	}
	
	
	uint8_t print_happened = grid_keyboard_cleanup(kb);
    ad7e:	4620      	mov	r0, r4
    ad80:	47c0      	blx	r8
	
	
	if (item_index == 255){
    ad82:	2fff      	cmp	r7, #255	; 0xff
    ad84:	d143      	bne.n	ae0e <grid_keyboard_keychange+0xb6>
		
		// item not in list
		
		if (kb->key_active_count< GRID_KEYBOARD_KEY_maxcount){
    ad86:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    ad8a:	2b05      	cmp	r3, #5
    ad8c:	d83f      	bhi.n	ae0e <grid_keyboard_keychange+0xb6>
			
			if (key->ispressed == true){
    ad8e:	78aa      	ldrb	r2, [r5, #2]
    ad90:	2a01      	cmp	r2, #1
    ad92:	d13c      	bne.n	ae0e <grid_keyboard_keychange+0xb6>
				
				kb->key_list[kb->key_active_count] = *key;
    ad94:	e895 0003 	ldmia.w	r5, {r0, r1}
    ad98:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    ad9c:	3214      	adds	r2, #20
				kb->key_active_count++;
    ad9e:	3301      	adds	r3, #1
				kb->key_list[kb->key_active_count] = *key;
    ada0:	e882 0003 	stmia.w	r2, {r0, r1}
				kb->key_active_count++;
    ada4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		}
		
	}
	
	
	if (changed_flag == 1){
    ada8:	f104 0112 	add.w	r1, r4, #18
	uint8_t item_index = 255;
    adac:	4623      	mov	r3, r4
//		}
			
		
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
		
			kb->hid_key_array[i].b_modifier = kb->key_list[i].ismodifier;
    adae:	7d72      	ldrb	r2, [r6, #21]
    adb0:	3a00      	subs	r2, #0
    adb2:	bf18      	it	ne
    adb4:	2201      	movne	r2, #1
    adb6:	705a      	strb	r2, [r3, #1]
			kb->hid_key_array[i].key_id = kb->key_list[i].keycode;
    adb8:	7d32      	ldrb	r2, [r6, #20]
    adba:	701a      	strb	r2, [r3, #0]
			kb->hid_key_array[i].state = kb->key_list[i].ispressed;
    adbc:	7db2      	ldrb	r2, [r6, #22]
    adbe:	709a      	strb	r2, [r3, #2]
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
    adc0:	3303      	adds	r3, #3
    adc2:	428b      	cmp	r3, r1
    adc4:	f106 0608 	add.w	r6, r6, #8
    adc8:	d1f1      	bne.n	adae <grid_keyboard_keychange+0x56>
		
		}
        
        
        if (kb->isenabled){
    adca:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    adce:	b325      	cbz	r5, ae1a <grid_keyboard_keychange+0xc2>
            
            
    		hiddf_keyboard_keys_state_change(kb->hid_key_array, kb->key_active_count);    
    add0:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    add4:	4b2b      	ldr	r3, [pc, #172]	; (ae84 <grid_keyboard_keychange+0x12c>)
    add6:	4620      	mov	r0, r4
    add8:	4798      	blx	r3
    adda:	e01b      	b.n	ae14 <grid_keyboard_keychange+0xbc>
		if (kb->key_list[i].keycode == key->keycode && kb->key_list[i].ismodifier == key->ismodifier){
    addc:	f893 a014 	ldrb.w	sl, [r3, #20]
    ade0:	7828      	ldrb	r0, [r5, #0]
    ade2:	4582      	cmp	sl, r0
    ade4:	d111      	bne.n	ae0a <grid_keyboard_keychange+0xb2>
    ade6:	f893 a015 	ldrb.w	sl, [r3, #21]
    adea:	7868      	ldrb	r0, [r5, #1]
    adec:	4582      	cmp	sl, r0
    adee:	d10c      	bne.n	ae0a <grid_keyboard_keychange+0xb2>
			if (kb->key_list[i].ispressed == true){
    adf0:	7d98      	ldrb	r0, [r3, #22]
    adf2:	2801      	cmp	r0, #1
    adf4:	d105      	bne.n	ae02 <grid_keyboard_keychange+0xaa>
				if (key->ispressed == true){
    adf6:	78af      	ldrb	r7, [r5, #2]
    adf8:	2f01      	cmp	r7, #1
    adfa:	d002      	beq.n	ae02 <grid_keyboard_keychange+0xaa>
					kb->key_list[i].ispressed = false;
    adfc:	f883 e016 	strb.w	lr, [r3, #22]
					changed_flag = 1;
    ae00:	4681      	mov	r9, r0
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ae02:	3201      	adds	r2, #1
    ae04:	3308      	adds	r3, #8
	uint8_t item_index = 255;
    ae06:	460f      	mov	r7, r1
    ae08:	e7b6      	b.n	ad78 <grid_keyboard_keychange+0x20>
    ae0a:	4639      	mov	r1, r7
    ae0c:	e7f9      	b.n	ae02 <grid_keyboard_keychange+0xaa>
	if (changed_flag == 1){
    ae0e:	f1b9 0f00 	cmp.w	r9, #0
    ae12:	d1c9      	bne.n	ada8 <grid_keyboard_keychange+0x50>
		
		
		// USB SEND
	}
	
}
    ae14:	b06c      	add	sp, #432	; 0x1b0
    ae16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            grid_msg_init(&response);
    ae1a:	a805      	add	r0, sp, #20
    ae1c:	4b1a      	ldr	r3, [pc, #104]	; (ae88 <grid_keyboard_keychange+0x130>)
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    ae1e:	4e1b      	ldr	r6, [pc, #108]	; (ae8c <grid_keyboard_keychange+0x134>)
            grid_msg_init(&response);
    ae20:	4798      	blx	r3
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    ae22:	227f      	movs	r2, #127	; 0x7f
    ae24:	462b      	mov	r3, r5
    ae26:	4611      	mov	r1, r2
    ae28:	a805      	add	r0, sp, #20
    ae2a:	47b0      	blx	r6
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ae2c:	2303      	movs	r3, #3
    ae2e:	4918      	ldr	r1, [pc, #96]	; (ae90 <grid_keyboard_keychange+0x138>)
    ae30:	9300      	str	r3, [sp, #0]
    ae32:	2202      	movs	r2, #2
    ae34:	4e17      	ldr	r6, [pc, #92]	; (ae94 <grid_keyboard_keychange+0x13c>)
            uint8_t response_payload[10] = {0};
    ae36:	f8ad 5010 	strh.w	r5, [sp, #16]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ae3a:	2392      	movs	r3, #146	; 0x92
    ae3c:	a802      	add	r0, sp, #8
            uint8_t response_payload[10] = {0};
    ae3e:	e9cd 5502 	strd	r5, r5, [sp, #8]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ae42:	47b0      	blx	r6
            grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    ae44:	4b14      	ldr	r3, [pc, #80]	; (ae98 <grid_keyboard_keychange+0x140>)
    ae46:	a802      	add	r0, sp, #8
    ae48:	4798      	blx	r3
    ae4a:	a902      	add	r1, sp, #8
    ae4c:	4602      	mov	r2, r0
    ae4e:	4b13      	ldr	r3, [pc, #76]	; (ae9c <grid_keyboard_keychange+0x144>)
    ae50:	a805      	add	r0, sp, #20
    ae52:	4798      	blx	r3
            grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, kb->isenabled);
    ae54:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    ae58:	9300      	str	r3, [sp, #0]
    ae5a:	4c11      	ldr	r4, [pc, #68]	; (aea0 <grid_keyboard_keychange+0x148>)
    ae5c:	4629      	mov	r1, r5
    ae5e:	a805      	add	r0, sp, #20
    ae60:	2302      	movs	r3, #2
    ae62:	2205      	movs	r2, #5
    ae64:	47a0      	blx	r4
            grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    ae66:	230d      	movs	r3, #13
    ae68:	9300      	str	r3, [sp, #0]
    ae6a:	2204      	movs	r2, #4
    ae6c:	4629      	mov	r1, r5
    ae6e:	a805      	add	r0, sp, #20
    ae70:	2301      	movs	r3, #1
    ae72:	47a0      	blx	r4
            grid_msg_packet_close(&response);
    ae74:	4b0b      	ldr	r3, [pc, #44]	; (aea4 <grid_keyboard_keychange+0x14c>)
    ae76:	a805      	add	r0, sp, #20
    ae78:	4798      	blx	r3
            grid_msg_packet_send_everywhere(&response);
    ae7a:	4b0b      	ldr	r3, [pc, #44]	; (aea8 <grid_keyboard_keychange+0x150>)
    ae7c:	a805      	add	r0, sp, #20
    ae7e:	4798      	blx	r3
    ae80:	e7c8      	b.n	ae14 <grid_keyboard_keychange+0xbc>
    ae82:	bf00      	nop
    ae84:	0000ead1 	.word	0x0000ead1
    ae88:	000085c5 	.word	0x000085c5
    ae8c:	000085f9 	.word	0x000085f9
    ae90:	00016a64 	.word	0x00016a64
    ae94:	00014ac5 	.word	0x00014ac5
    ae98:	00014f81 	.word	0x00014f81
    ae9c:	00008535 	.word	0x00008535
    aea0:	000085a9 	.word	0x000085a9
    aea4:	000086f1 	.word	0x000086f1
    aea8:	000087c5 	.word	0x000087c5
    aeac:	0000acf1 	.word	0x0000acf1

0000aeb0 <grid_midi_buffer_init>:



void grid_midi_buffer_init(struct grid_midi_event_desc* buf, uint16_t length){
    aeb0:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    aeb2:	2300      	movs	r3, #0
	{
		buf[i].byte0 = 0;
    aeb4:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    aeb6:	b29c      	uxth	r4, r3
    aeb8:	42a1      	cmp	r1, r4
    aeba:	f100 0004 	add.w	r0, r0, #4
    aebe:	d800      	bhi.n	aec2 <grid_midi_buffer_init+0x12>
		buf[i].byte1 = 0;
		buf[i].byte2 = 0;
		buf[i].byte3 = 0;
	}
	
}
    aec0:	bd10      	pop	{r4, pc}
		buf[i].byte0 = 0;
    aec2:	f800 2c04 	strb.w	r2, [r0, #-4]
		buf[i].byte1 = 0;
    aec6:	f800 2c03 	strb.w	r2, [r0, #-3]
		buf[i].byte2 = 0;
    aeca:	f800 2c02 	strb.w	r2, [r0, #-2]
		buf[i].byte3 = 0;
    aece:	f800 2c01 	strb.w	r2, [r0, #-1]
	for (uint16_t i=0; i<length; i++)
    aed2:	3301      	adds	r3, #1
    aed4:	e7ef      	b.n	aeb6 <grid_midi_buffer_init+0x6>
	...

0000aed8 <grid_usb_midi_init>:
	grid_midi_tx_write_index = 0;
    aed8:	4b0a      	ldr	r3, [pc, #40]	; (af04 <grid_usb_midi_init+0x2c>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aeda:	480b      	ldr	r0, [pc, #44]	; (af08 <grid_usb_midi_init+0x30>)
{
    aedc:	b510      	push	{r4, lr}
	grid_midi_tx_write_index = 0;
    aede:	2400      	movs	r4, #0
    aee0:	801c      	strh	r4, [r3, #0]
	grid_midi_tx_read_index = 0;
    aee2:	4b0a      	ldr	r3, [pc, #40]	; (af0c <grid_usb_midi_init+0x34>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aee4:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_midi_tx_read_index = 0;
    aee8:	801c      	strh	r4, [r3, #0]
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aeea:	4b09      	ldr	r3, [pc, #36]	; (af10 <grid_usb_midi_init+0x38>)
    aeec:	4798      	blx	r3
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_READ, (FUNC_PTR)grid_usb_midi_bulkout_cb);
    aeee:	4620      	mov	r0, r4
    aef0:	4c08      	ldr	r4, [pc, #32]	; (af14 <grid_usb_midi_init+0x3c>)
    aef2:	4909      	ldr	r1, [pc, #36]	; (af18 <grid_usb_midi_init+0x40>)
    aef4:	47a0      	blx	r4
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    aef6:	4623      	mov	r3, r4
    aef8:	4908      	ldr	r1, [pc, #32]	; (af1c <grid_usb_midi_init+0x44>)
}
    aefa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    aefe:	2001      	movs	r0, #1
    af00:	4718      	bx	r3
    af02:	bf00      	nop
    af04:	2000c0a4 	.word	0x2000c0a4
    af08:	20013420 	.word	0x20013420
    af0c:	20010260 	.word	0x20010260
    af10:	0000aeb1 	.word	0x0000aeb1
    af14:	00004585 	.word	0x00004585
    af18:	0000acb5 	.word	0x0000acb5
    af1c:	0000ac8d 	.word	0x0000ac8d

0000af20 <grid_midi_tx_push>:

uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){


	grid_midi_tx_buffer[grid_midi_tx_write_index] = midi_event;
    af20:	4907      	ldr	r1, [pc, #28]	; (af40 <grid_midi_tx_push+0x20>)
    af22:	4a08      	ldr	r2, [pc, #32]	; (af44 <grid_midi_tx_push+0x24>)
    af24:	880b      	ldrh	r3, [r1, #0]
    af26:	f842 0023 	str.w	r0, [r2, r3, lsl #2]

	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    af2a:	f44f 7096 	mov.w	r0, #300	; 0x12c
    af2e:	3301      	adds	r3, #1
uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){
    af30:	b082      	sub	sp, #8
	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    af32:	fbb3 f2f0 	udiv	r2, r3, r0
    af36:	fb00 3312 	mls	r3, r0, r2, r3
    af3a:	800b      	strh	r3, [r1, #0]




}
    af3c:	b002      	add	sp, #8
    af3e:	4770      	bx	lr
    af40:	2000c0a4 	.word	0x2000c0a4
    af44:	20013420 	.word	0x20013420

0000af48 <grid_midi_tx_pop>:

uint8_t grid_midi_tx_pop(){
    af48:	b538      	push	{r3, r4, r5, lr}

	if (grid_midi_tx_read_index != grid_midi_tx_write_index){
    af4a:	4c0f      	ldr	r4, [pc, #60]	; (af88 <grid_midi_tx_pop+0x40>)
    af4c:	4b0f      	ldr	r3, [pc, #60]	; (af8c <grid_midi_tx_pop+0x44>)
    af4e:	8822      	ldrh	r2, [r4, #0]
    af50:	881b      	ldrh	r3, [r3, #0]
    af52:	429a      	cmp	r2, r3
    af54:	d017      	beq.n	af86 <grid_midi_tx_pop+0x3e>
		
		if (audiodf_midi_write_status() != USB_BUSY){
    af56:	4b0e      	ldr	r3, [pc, #56]	; (af90 <grid_midi_tx_pop+0x48>)
    af58:	4798      	blx	r3
    af5a:	2801      	cmp	r0, #1
    af5c:	d013      	beq.n	af86 <grid_midi_tx_pop+0x3e>

			uint8_t byte0 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte0;
    af5e:	8825      	ldrh	r5, [r4, #0]
			uint8_t byte1 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte1;
			uint8_t byte2 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte2;
			uint8_t byte3 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte3;
    af60:	480c      	ldr	r0, [pc, #48]	; (af94 <grid_midi_tx_pop+0x4c>)
    af62:	eb00 0185 	add.w	r1, r0, r5, lsl #2
			
			audiodf_midi_write(byte0, byte1, byte2, byte3);
    af66:	f810 0025 	ldrb.w	r0, [r0, r5, lsl #2]
    af6a:	78cb      	ldrb	r3, [r1, #3]
    af6c:	788a      	ldrb	r2, [r1, #2]
    af6e:	4d0a      	ldr	r5, [pc, #40]	; (af98 <grid_midi_tx_pop+0x50>)
    af70:	7849      	ldrb	r1, [r1, #1]
    af72:	47a8      	blx	r5

			grid_midi_tx_read_index = (grid_midi_tx_read_index+1)%GRID_MIDI_TX_BUFFER_length;
    af74:	8823      	ldrh	r3, [r4, #0]
    af76:	f44f 7196 	mov.w	r1, #300	; 0x12c
    af7a:	3301      	adds	r3, #1
    af7c:	fbb3 f2f1 	udiv	r2, r3, r1
    af80:	fb01 3312 	mls	r3, r1, r2, r3
    af84:	8023      	strh	r3, [r4, #0]

		}
		
	}

}
    af86:	bd38      	pop	{r3, r4, r5, pc}
    af88:	20010260 	.word	0x20010260
    af8c:	2000c0a4 	.word	0x2000c0a4
    af90:	00004549 	.word	0x00004549
    af94:	20013420 	.word	0x20013420
    af98:	00004521 	.word	0x00004521

0000af9c <grid_keyboard_buffer_init>:


void grid_keyboard_buffer_init(struct grid_keyboard_event_desc* buf, uint16_t length){
    af9c:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    af9e:	2300      	movs	r3, #0
	{
		buf[i].ismodifier = 0;
    afa0:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    afa2:	b29c      	uxth	r4, r3
    afa4:	42a1      	cmp	r1, r4
    afa6:	f100 0008 	add.w	r0, r0, #8
    afaa:	d800      	bhi.n	afae <grid_keyboard_buffer_init+0x12>
		buf[i].keycode = 0;
		buf[i].ispressed = 0;
		buf[i].delay = 0;
	}
	
}
    afac:	bd10      	pop	{r4, pc}
		buf[i].ismodifier = 0;
    afae:	f800 2c07 	strb.w	r2, [r0, #-7]
		buf[i].keycode = 0;
    afb2:	f800 2c08 	strb.w	r2, [r0, #-8]
		buf[i].ispressed = 0;
    afb6:	f800 2c06 	strb.w	r2, [r0, #-6]
		buf[i].delay = 0;
    afba:	f840 2c04 	str.w	r2, [r0, #-4]
	for (uint16_t i=0; i<length; i++)
    afbe:	3301      	adds	r3, #1
    afc0:	e7ef      	b.n	afa2 <grid_keyboard_buffer_init+0x6>
	...

0000afc4 <grid_keyboard_init>:
void grid_keyboard_init(struct grid_keyboard_model* kb){
    afc4:	b570      	push	{r4, r5, r6, lr}
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    afc6:	4b13      	ldr	r3, [pc, #76]	; (b014 <grid_keyboard_init+0x50>)
void grid_keyboard_init(struct grid_keyboard_model* kb){
    afc8:	4605      	mov	r5, r0
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    afca:	4813      	ldr	r0, [pc, #76]	; (b018 <grid_keyboard_init+0x54>)
    afcc:	4798      	blx	r3
    afce:	4b13      	ldr	r3, [pc, #76]	; (b01c <grid_keyboard_init+0x58>)
    afd0:	6018      	str	r0, [r3, #0]
    grid_keyboard_tx_write_index = 0;
    afd2:	4b13      	ldr	r3, [pc, #76]	; (b020 <grid_keyboard_init+0x5c>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afd4:	4813      	ldr	r0, [pc, #76]	; (b024 <grid_keyboard_init+0x60>)
    grid_keyboard_tx_write_index = 0;
    afd6:	2400      	movs	r4, #0
    afd8:	801c      	strh	r4, [r3, #0]
	grid_keyboard_tx_read_index = 0;
    afda:	4b13      	ldr	r3, [pc, #76]	; (b028 <grid_keyboard_init+0x64>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afdc:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_keyboard_tx_read_index = 0;
    afe0:	801c      	strh	r4, [r3, #0]
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afe2:	4b12      	ldr	r3, [pc, #72]	; (b02c <grid_keyboard_init+0x68>)
    afe4:	4798      	blx	r3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    afe6:	f105 0612 	add.w	r6, r5, #18
    afea:	462a      	mov	r2, r5
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afec:	4629      	mov	r1, r5
		kb->hid_key_array[i].b_modifier = false;
    afee:	4623      	mov	r3, r4
		kb->hid_key_array[i].key_id = 255;
    aff0:	20ff      	movs	r0, #255	; 0xff
		kb->hid_key_array[i].b_modifier = false;
    aff2:	7053      	strb	r3, [r2, #1]
		kb->hid_key_array[i].key_id = 255;
    aff4:	7010      	strb	r0, [r2, #0]
		kb->hid_key_array[i].state = HID_KB_KEY_UP;
    aff6:	7093      	strb	r3, [r2, #2]
		kb->key_list[i].ismodifier = 0;
    aff8:	3203      	adds	r2, #3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    affa:	42b2      	cmp	r2, r6
		kb->key_list[i].ismodifier = 0;
    affc:	754b      	strb	r3, [r1, #21]
		kb->key_list[i].ispressed = 0;
    affe:	758b      	strb	r3, [r1, #22]
		kb->key_list[i].keycode = 255;
    b000:	7508      	strb	r0, [r1, #20]
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b002:	f101 0108 	add.w	r1, r1, #8
    b006:	d1f4      	bne.n	aff2 <grid_keyboard_init+0x2e>
	kb->key_active_count = 0;
    b008:	f44f 7380 	mov.w	r3, #256	; 0x100
    b00c:	f8a5 3044 	strh.w	r3, [r5, #68]	; 0x44
}
    b010:	bd70      	pop	{r4, r5, r6, pc}
    b012:	bf00      	nop
    b014:	000097a9 	.word	0x000097a9
    b018:	2000f008 	.word	0x2000f008
    b01c:	2001c7cc 	.word	0x2001c7cc
    b020:	2000f0b8 	.word	0x2000f0b8
    b024:	2000f0bc 	.word	0x2000f0bc
    b028:	200102ac 	.word	0x200102ac
    b02c:	0000af9d 	.word	0x0000af9d

0000b030 <grid_keyboard_tx_push>:

uint8_t grid_keyboard_tx_push(struct grid_keyboard_event_desc keyboard_event){
    b030:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b032:	466c      	mov	r4, sp
    b034:	e884 0003 	stmia.w	r4, {r0, r1}


	grid_keyboard_tx_buffer[grid_keyboard_tx_write_index] = keyboard_event;
    b038:	4d09      	ldr	r5, [pc, #36]	; (b060 <grid_keyboard_tx_push+0x30>)
    b03a:	4a0a      	ldr	r2, [pc, #40]	; (b064 <grid_keyboard_tx_push+0x34>)
    b03c:	882b      	ldrh	r3, [r5, #0]
    b03e:	e894 0003 	ldmia.w	r4, {r0, r1}
    b042:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    b046:	e882 0003 	stmia.w	r2, {r0, r1}

	grid_keyboard_tx_write_index = (grid_keyboard_tx_write_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b04a:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b04e:	3301      	adds	r3, #1
    b050:	fbb3 f2f1 	udiv	r2, r3, r1
    b054:	fb01 3312 	mls	r3, r1, r2, r3
    b058:	802b      	strh	r3, [r5, #0]



}
    b05a:	b003      	add	sp, #12
    b05c:	bd30      	pop	{r4, r5, pc}
    b05e:	bf00      	nop
    b060:	2000f0b8 	.word	0x2000f0b8
    b064:	2000f0bc 	.word	0x2000f0bc

0000b068 <grid_keyboard_tx_pop>:

uint8_t grid_keyboard_tx_pop(){
    b068:	b573      	push	{r0, r1, r4, r5, r6, lr}

	if (grid_keyboard_tx_read_index != grid_keyboard_tx_write_index){
    b06a:	4b17      	ldr	r3, [pc, #92]	; (b0c8 <grid_keyboard_tx_pop+0x60>)
    b06c:	4c17      	ldr	r4, [pc, #92]	; (b0cc <grid_keyboard_tx_pop+0x64>)
    b06e:	881b      	ldrh	r3, [r3, #0]
    b070:	8822      	ldrh	r2, [r4, #0]
    b072:	429a      	cmp	r2, r3
    b074:	d026      	beq.n	b0c4 <grid_keyboard_tx_pop+0x5c>
		
        
        
        uint32_t elapsed = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_keyboard_tx_rtc_lasttimestamp);
    b076:	4d16      	ldr	r5, [pc, #88]	; (b0d0 <grid_keyboard_tx_pop+0x68>)
    b078:	4b16      	ldr	r3, [pc, #88]	; (b0d4 <grid_keyboard_tx_pop+0x6c>)
    b07a:	6829      	ldr	r1, [r5, #0]
    b07c:	4816      	ldr	r0, [pc, #88]	; (b0d8 <grid_keyboard_tx_pop+0x70>)
    b07e:	4798      	blx	r3
        
        
		if (elapsed > grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].delay*RTC1MS){
    b080:	8822      	ldrh	r2, [r4, #0]
    b082:	4b16      	ldr	r3, [pc, #88]	; (b0dc <grid_keyboard_tx_pop+0x74>)
    b084:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    b088:	684e      	ldr	r6, [r1, #4]
    b08a:	ebb0 1f06 	cmp.w	r0, r6, lsl #4
    b08e:	d919      	bls.n	b0c4 <grid_keyboard_tx_pop+0x5c>
            
            struct grid_keyboard_event_desc key;
            
            key.ismodifier = grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ismodifier;
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b090:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b094:	7889      	ldrb	r1, [r1, #2]
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b096:	f8ad 3000 	strh.w	r3, [sp]
            key.delay = 0;
    b09a:	2300      	movs	r3, #0
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b09c:	f88d 1002 	strb.w	r1, [sp, #2]
            key.delay = 0;
    b0a0:	9301      	str	r3, [sp, #4]
            
                  
            //grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 50);
            
            grid_keyboard_keychange(&grid_keyboard_state, &key);
    b0a2:	4669      	mov	r1, sp
    b0a4:	4b0e      	ldr	r3, [pc, #56]	; (b0e0 <grid_keyboard_tx_pop+0x78>)
    b0a6:	480f      	ldr	r0, [pc, #60]	; (b0e4 <grid_keyboard_tx_pop+0x7c>)
    b0a8:	4798      	blx	r3

			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b0aa:	8823      	ldrh	r3, [r4, #0]
            
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b0ac:	480a      	ldr	r0, [pc, #40]	; (b0d8 <grid_keyboard_tx_pop+0x70>)
			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b0ae:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b0b2:	3301      	adds	r3, #1
    b0b4:	fbb3 f2f1 	udiv	r2, r3, r1
    b0b8:	fb01 3312 	mls	r3, r1, r2, r3
    b0bc:	8023      	strh	r3, [r4, #0]
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b0be:	4b0a      	ldr	r3, [pc, #40]	; (b0e8 <grid_keyboard_tx_pop+0x80>)
    b0c0:	4798      	blx	r3
    b0c2:	6028      	str	r0, [r5, #0]

		}
		
	}

}
    b0c4:	b002      	add	sp, #8
    b0c6:	bd70      	pop	{r4, r5, r6, pc}
    b0c8:	2000f0b8 	.word	0x2000f0b8
    b0cc:	200102ac 	.word	0x200102ac
    b0d0:	2001c7cc 	.word	0x2001c7cc
    b0d4:	000097ad 	.word	0x000097ad
    b0d8:	2000f008 	.word	0x2000f008
    b0dc:	2000f0bc 	.word	0x2000f0bc
    b0e0:	0000ad59 	.word	0x0000ad59
    b0e4:	20010264 	.word	0x20010264
    b0e8:	000097a9 	.word	0x000097a9

0000b0ec <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    b0ec:	b570      	push	{r4, r5, r6, lr}
    b0ee:	460d      	mov	r5, r1
    b0f0:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b0f2:	4604      	mov	r4, r0
    b0f4:	b110      	cbz	r0, b0fc <io_write+0x10>
    b0f6:	1e08      	subs	r0, r1, #0
    b0f8:	bf18      	it	ne
    b0fa:	2001      	movne	r0, #1
    b0fc:	4905      	ldr	r1, [pc, #20]	; (b114 <io_write+0x28>)
    b0fe:	4b06      	ldr	r3, [pc, #24]	; (b118 <io_write+0x2c>)
    b100:	2234      	movs	r2, #52	; 0x34
    b102:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    b104:	6823      	ldr	r3, [r4, #0]
    b106:	4632      	mov	r2, r6
    b108:	4629      	mov	r1, r5
    b10a:	4620      	mov	r0, r4
}
    b10c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    b110:	4718      	bx	r3
    b112:	bf00      	nop
    b114:	000170e0 	.word	0x000170e0
    b118:	0000e08d 	.word	0x0000e08d

0000b11c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    b11c:	b570      	push	{r4, r5, r6, lr}
    b11e:	460d      	mov	r5, r1
    b120:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b122:	4604      	mov	r4, r0
    b124:	b110      	cbz	r0, b12c <io_read+0x10>
    b126:	1e08      	subs	r0, r1, #0
    b128:	bf18      	it	ne
    b12a:	2001      	movne	r0, #1
    b12c:	4905      	ldr	r1, [pc, #20]	; (b144 <io_read+0x28>)
    b12e:	4b06      	ldr	r3, [pc, #24]	; (b148 <io_read+0x2c>)
    b130:	223d      	movs	r2, #61	; 0x3d
    b132:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    b134:	6863      	ldr	r3, [r4, #4]
    b136:	4632      	mov	r2, r6
    b138:	4629      	mov	r1, r5
    b13a:	4620      	mov	r0, r4
}
    b13c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    b140:	4718      	bx	r3
    b142:	bf00      	nop
    b144:	000170e0 	.word	0x000170e0
    b148:	0000e08d 	.word	0x0000e08d

0000b14c <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    b14c:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    b150:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    b154:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    b158:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    b15a:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    b15c:	2300      	movs	r3, #0
    b15e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    b160:	4770      	bx	lr

0000b162 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    b162:	2300      	movs	r3, #0
    b164:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    b166:	4770      	bx	lr

0000b168 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    b168:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    b16a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    b16c:	689a      	ldr	r2, [r3, #8]
    b16e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    b170:	689a      	ldr	r2, [r3, #8]
    b172:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    b174:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b176:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b178:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b17a:	3301      	adds	r3, #1
    b17c:	6003      	str	r3, [r0, #0]
}
    b17e:	4770      	bx	lr

0000b180 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    b180:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    b182:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    b184:	1c63      	adds	r3, r4, #1
    b186:	d10a      	bne.n	b19e <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    b188:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    b18a:	685a      	ldr	r2, [r3, #4]
    b18c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    b18e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    b190:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    b192:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b194:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b196:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b198:	3301      	adds	r3, #1
    b19a:	6003      	str	r3, [r0, #0]
}
    b19c:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    b19e:	f100 0208 	add.w	r2, r0, #8
    b1a2:	4613      	mov	r3, r2
    b1a4:	6852      	ldr	r2, [r2, #4]
    b1a6:	6815      	ldr	r5, [r2, #0]
    b1a8:	42a5      	cmp	r5, r4
    b1aa:	d9fa      	bls.n	b1a2 <vListInsert+0x22>
    b1ac:	e7ed      	b.n	b18a <vListInsert+0xa>

0000b1ae <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b1ae:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    b1b2:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b1b4:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    b1b6:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    b1b8:	6859      	ldr	r1, [r3, #4]
    b1ba:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    b1bc:	bf08      	it	eq
    b1be:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    b1c0:	2200      	movs	r2, #0
    b1c2:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    b1c4:	681a      	ldr	r2, [r3, #0]
    b1c6:	3a01      	subs	r2, #1
    b1c8:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    b1ca:	6818      	ldr	r0, [r3, #0]
}
    b1cc:	4770      	bx	lr
	...

0000b1d0 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    b1d0:	4808      	ldr	r0, [pc, #32]	; (b1f4 <prvPortStartFirstTask+0x24>)
    b1d2:	6800      	ldr	r0, [r0, #0]
    b1d4:	6800      	ldr	r0, [r0, #0]
    b1d6:	f380 8808 	msr	MSP, r0
    b1da:	f04f 0000 	mov.w	r0, #0
    b1de:	f380 8814 	msr	CONTROL, r0
    b1e2:	b662      	cpsie	i
    b1e4:	b661      	cpsie	f
    b1e6:	f3bf 8f4f 	dsb	sy
    b1ea:	f3bf 8f6f 	isb	sy
    b1ee:	df00      	svc	0
    b1f0:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    b1f2:	0000      	.short	0x0000
    b1f4:	e000ed08 	.word	0xe000ed08

0000b1f8 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    b1f8:	f8df 000c 	ldr.w	r0, [pc, #12]	; b208 <vPortEnableVFP+0x10>
    b1fc:	6801      	ldr	r1, [r0, #0]
    b1fe:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b202:	6001      	str	r1, [r0, #0]
    b204:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    b206:	0000      	.short	0x0000
    b208:	e000ed88 	.word	0xe000ed88

0000b20c <prvTaskExitError>:
{
    b20c:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
    b20e:	2300      	movs	r3, #0
    b210:	9301      	str	r3, [sp, #4]
	configASSERT(uxCriticalNesting == ~0UL);
    b212:	4b0d      	ldr	r3, [pc, #52]	; (b248 <prvTaskExitError+0x3c>)
    b214:	681b      	ldr	r3, [r3, #0]
    b216:	3301      	adds	r3, #1
    b218:	d008      	beq.n	b22c <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    b21a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b21e:	f383 8811 	msr	BASEPRI, r3
    b222:	f3bf 8f6f 	isb	sy
    b226:	f3bf 8f4f 	dsb	sy
    b22a:	e7fe      	b.n	b22a <prvTaskExitError+0x1e>
    b22c:	f04f 0380 	mov.w	r3, #128	; 0x80
    b230:	f383 8811 	msr	BASEPRI, r3
    b234:	f3bf 8f6f 	isb	sy
    b238:	f3bf 8f4f 	dsb	sy
	while (ulDummy == 0) {
    b23c:	9b01      	ldr	r3, [sp, #4]
    b23e:	2b00      	cmp	r3, #0
    b240:	d0fc      	beq.n	b23c <prvTaskExitError+0x30>
}
    b242:	b002      	add	sp, #8
    b244:	4770      	bx	lr
    b246:	bf00      	nop
    b248:	20000350 	.word	0x20000350

0000b24c <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    b24c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    b250:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    b254:	4b07      	ldr	r3, [pc, #28]	; (b274 <pxPortInitialiseStack+0x28>)
    b256:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b25a:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b25e:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b262:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    b266:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b26a:	f840 3c24 	str.w	r3, [r0, #-36]
}
    b26e:	3844      	subs	r0, #68	; 0x44
    b270:	4770      	bx	lr
    b272:	bf00      	nop
    b274:	0000b20d 	.word	0x0000b20d
	...

0000b280 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    b280:	4b07      	ldr	r3, [pc, #28]	; (b2a0 <pxCurrentTCBConst2>)
    b282:	6819      	ldr	r1, [r3, #0]
    b284:	6808      	ldr	r0, [r1, #0]
    b286:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b28a:	f380 8809 	msr	PSP, r0
    b28e:	f3bf 8f6f 	isb	sy
    b292:	f04f 0000 	mov.w	r0, #0
    b296:	f380 8811 	msr	BASEPRI, r0
    b29a:	4770      	bx	lr
    b29c:	f3af 8000 	nop.w

0000b2a0 <pxCurrentTCBConst2>:
    b2a0:	200090ac 	.word	0x200090ac

0000b2a4 <vPortEnterCritical>:
    b2a4:	f04f 0380 	mov.w	r3, #128	; 0x80
    b2a8:	f383 8811 	msr	BASEPRI, r3
    b2ac:	f3bf 8f6f 	isb	sy
    b2b0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    b2b4:	4a0a      	ldr	r2, [pc, #40]	; (b2e0 <vPortEnterCritical+0x3c>)
    b2b6:	6813      	ldr	r3, [r2, #0]
    b2b8:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    b2ba:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    b2bc:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    b2be:	d10d      	bne.n	b2dc <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    b2c0:	4b08      	ldr	r3, [pc, #32]	; (b2e4 <vPortEnterCritical+0x40>)
    b2c2:	681b      	ldr	r3, [r3, #0]
    b2c4:	f013 0fff 	tst.w	r3, #255	; 0xff
    b2c8:	d008      	beq.n	b2dc <vPortEnterCritical+0x38>
    b2ca:	f04f 0380 	mov.w	r3, #128	; 0x80
    b2ce:	f383 8811 	msr	BASEPRI, r3
    b2d2:	f3bf 8f6f 	isb	sy
    b2d6:	f3bf 8f4f 	dsb	sy
    b2da:	e7fe      	b.n	b2da <vPortEnterCritical+0x36>
}
    b2dc:	4770      	bx	lr
    b2de:	bf00      	nop
    b2e0:	20000350 	.word	0x20000350
    b2e4:	e000ed04 	.word	0xe000ed04

0000b2e8 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    b2e8:	4a08      	ldr	r2, [pc, #32]	; (b30c <vPortExitCritical+0x24>)
    b2ea:	6813      	ldr	r3, [r2, #0]
    b2ec:	b943      	cbnz	r3, b300 <vPortExitCritical+0x18>
    b2ee:	f04f 0380 	mov.w	r3, #128	; 0x80
    b2f2:	f383 8811 	msr	BASEPRI, r3
    b2f6:	f3bf 8f6f 	isb	sy
    b2fa:	f3bf 8f4f 	dsb	sy
    b2fe:	e7fe      	b.n	b2fe <vPortExitCritical+0x16>
	uxCriticalNesting--;
    b300:	3b01      	subs	r3, #1
    b302:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    b304:	b90b      	cbnz	r3, b30a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b306:	f383 8811 	msr	BASEPRI, r3
}
    b30a:	4770      	bx	lr
    b30c:	20000350 	.word	0x20000350

0000b310 <PendSV_Handler>:
	__asm volatile(
    b310:	f3ef 8009 	mrs	r0, PSP
    b314:	f3bf 8f6f 	isb	sy
    b318:	4b15      	ldr	r3, [pc, #84]	; (b370 <pxCurrentTCBConst>)
    b31a:	681a      	ldr	r2, [r3, #0]
    b31c:	f01e 0f10 	tst.w	lr, #16
    b320:	bf08      	it	eq
    b322:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    b326:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b32a:	6010      	str	r0, [r2, #0]
    b32c:	e92d 0009 	stmdb	sp!, {r0, r3}
    b330:	f04f 0080 	mov.w	r0, #128	; 0x80
    b334:	f380 8811 	msr	BASEPRI, r0
    b338:	f3bf 8f4f 	dsb	sy
    b33c:	f3bf 8f6f 	isb	sy
    b340:	f007 fb80 	bl	12a44 <vTaskSwitchContext>
    b344:	f04f 0000 	mov.w	r0, #0
    b348:	f380 8811 	msr	BASEPRI, r0
    b34c:	bc09      	pop	{r0, r3}
    b34e:	6819      	ldr	r1, [r3, #0]
    b350:	6808      	ldr	r0, [r1, #0]
    b352:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b356:	f01e 0f10 	tst.w	lr, #16
    b35a:	bf08      	it	eq
    b35c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    b360:	f380 8809 	msr	PSP, r0
    b364:	f3bf 8f6f 	isb	sy
    b368:	4770      	bx	lr
    b36a:	bf00      	nop
    b36c:	f3af 8000 	nop.w

0000b370 <pxCurrentTCBConst>:
    b370:	200090ac 	.word	0x200090ac

0000b374 <SysTick_Handler>:
{
    b374:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
    b376:	f04f 0380 	mov.w	r3, #128	; 0x80
    b37a:	f383 8811 	msr	BASEPRI, r3
    b37e:	f3bf 8f6f 	isb	sy
    b382:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    b386:	4b05      	ldr	r3, [pc, #20]	; (b39c <SysTick_Handler+0x28>)
    b388:	4798      	blx	r3
    b38a:	b118      	cbz	r0, b394 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    b38c:	4b04      	ldr	r3, [pc, #16]	; (b3a0 <SysTick_Handler+0x2c>)
    b38e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    b392:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b394:	2300      	movs	r3, #0
    b396:	f383 8811 	msr	BASEPRI, r3
}
    b39a:	bd08      	pop	{r3, pc}
    b39c:	000127f5 	.word	0x000127f5
    b3a0:	e000ed04 	.word	0xe000ed04

0000b3a4 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b3a4:	4b05      	ldr	r3, [pc, #20]	; (b3bc <vPortSetupTimerInterrupt+0x18>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b3a6:	4906      	ldr	r1, [pc, #24]	; (b3c0 <vPortSetupTimerInterrupt+0x1c>)
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b3a8:	2200      	movs	r2, #0
    b3aa:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b3ac:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    b3ae:	4a05      	ldr	r2, [pc, #20]	; (b3c4 <vPortSetupTimerInterrupt+0x20>)
    b3b0:	f645 51bf 	movw	r1, #23999	; 0x5dbf
    b3b4:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    b3b6:	2207      	movs	r2, #7
    b3b8:	601a      	str	r2, [r3, #0]
}
    b3ba:	4770      	bx	lr
    b3bc:	e000e010 	.word	0xe000e010
    b3c0:	e000e018 	.word	0xe000e018
    b3c4:	e000e014 	.word	0xe000e014

0000b3c8 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b3c8:	4b37      	ldr	r3, [pc, #220]	; (b4a8 <xPortStartScheduler+0xe0>)
    b3ca:	4a38      	ldr	r2, [pc, #224]	; (b4ac <xPortStartScheduler+0xe4>)
{
    b3cc:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b3ce:	6819      	ldr	r1, [r3, #0]
    b3d0:	4291      	cmp	r1, r2
    b3d2:	d108      	bne.n	b3e6 <xPortStartScheduler+0x1e>
	__asm volatile("	mov %0, %1												\n"
    b3d4:	f04f 0380 	mov.w	r3, #128	; 0x80
    b3d8:	f383 8811 	msr	BASEPRI, r3
    b3dc:	f3bf 8f6f 	isb	sy
    b3e0:	f3bf 8f4f 	dsb	sy
    b3e4:	e7fe      	b.n	b3e4 <xPortStartScheduler+0x1c>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    b3e6:	681a      	ldr	r2, [r3, #0]
    b3e8:	4b31      	ldr	r3, [pc, #196]	; (b4b0 <xPortStartScheduler+0xe8>)
    b3ea:	429a      	cmp	r2, r3
    b3ec:	d108      	bne.n	b400 <xPortStartScheduler+0x38>
    b3ee:	f04f 0380 	mov.w	r3, #128	; 0x80
    b3f2:	f383 8811 	msr	BASEPRI, r3
    b3f6:	f3bf 8f6f 	isb	sy
    b3fa:	f3bf 8f4f 	dsb	sy
    b3fe:	e7fe      	b.n	b3fe <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    b400:	4b2c      	ldr	r3, [pc, #176]	; (b4b4 <xPortStartScheduler+0xec>)
    b402:	781a      	ldrb	r2, [r3, #0]
    b404:	b2d2      	uxtb	r2, r2
    b406:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    b408:	22ff      	movs	r2, #255	; 0xff
    b40a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b40c:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b40e:	4a2a      	ldr	r2, [pc, #168]	; (b4b8 <xPortStartScheduler+0xf0>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b410:	b2db      	uxtb	r3, r3
    b412:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b416:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b41a:	f003 0380 	and.w	r3, r3, #128	; 0x80
    b41e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    b420:	2307      	movs	r3, #7
    b422:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    b424:	2100      	movs	r1, #0
    b426:	f89d 0003 	ldrb.w	r0, [sp, #3]
    b42a:	0600      	lsls	r0, r0, #24
    b42c:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    b430:	d40c      	bmi.n	b44c <xPortStartScheduler+0x84>
    b432:	b111      	cbz	r1, b43a <xPortStartScheduler+0x72>
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
    b434:	2b04      	cmp	r3, #4
    b436:	6053      	str	r3, [r2, #4]
    b438:	d011      	beq.n	b45e <xPortStartScheduler+0x96>
    b43a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b43e:	f383 8811 	msr	BASEPRI, r3
    b442:	f3bf 8f6f 	isb	sy
    b446:	f3bf 8f4f 	dsb	sy
    b44a:	e7fe      	b.n	b44a <xPortStartScheduler+0x82>
			ucMaxPriorityValue <<= (uint8_t)0x01;
    b44c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b450:	005b      	lsls	r3, r3, #1
    b452:	b2db      	uxtb	r3, r3
    b454:	f88d 3003 	strb.w	r3, [sp, #3]
    b458:	2101      	movs	r1, #1
    b45a:	4623      	mov	r3, r4
    b45c:	e7e3      	b.n	b426 <xPortStartScheduler+0x5e>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    b45e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    b462:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    b464:	9b01      	ldr	r3, [sp, #4]
    b466:	4a13      	ldr	r2, [pc, #76]	; (b4b4 <xPortStartScheduler+0xec>)
    b468:	b2db      	uxtb	r3, r3
    b46a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    b46c:	4b13      	ldr	r3, [pc, #76]	; (b4bc <xPortStartScheduler+0xf4>)
    b46e:	681a      	ldr	r2, [r3, #0]
    b470:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    b474:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    b476:	681a      	ldr	r2, [r3, #0]
    b478:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    b47c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    b47e:	4b10      	ldr	r3, [pc, #64]	; (b4c0 <xPortStartScheduler+0xf8>)
    b480:	4798      	blx	r3
	uxCriticalNesting = 0;
    b482:	4b10      	ldr	r3, [pc, #64]	; (b4c4 <xPortStartScheduler+0xfc>)
    b484:	2400      	movs	r4, #0
    b486:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
    b488:	4b0f      	ldr	r3, [pc, #60]	; (b4c8 <xPortStartScheduler+0x100>)
    b48a:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    b48c:	4a0f      	ldr	r2, [pc, #60]	; (b4cc <xPortStartScheduler+0x104>)
    b48e:	6813      	ldr	r3, [r2, #0]
    b490:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    b494:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    b496:	4b0e      	ldr	r3, [pc, #56]	; (b4d0 <xPortStartScheduler+0x108>)
    b498:	4798      	blx	r3
	vTaskSwitchContext();
    b49a:	4b0e      	ldr	r3, [pc, #56]	; (b4d4 <xPortStartScheduler+0x10c>)
    b49c:	4798      	blx	r3
	prvTaskExitError();
    b49e:	4b0e      	ldr	r3, [pc, #56]	; (b4d8 <xPortStartScheduler+0x110>)
    b4a0:	4798      	blx	r3
}
    b4a2:	4620      	mov	r0, r4
    b4a4:	b002      	add	sp, #8
    b4a6:	bd10      	pop	{r4, pc}
    b4a8:	e000ed00 	.word	0xe000ed00
    b4ac:	410fc271 	.word	0x410fc271
    b4b0:	410fc270 	.word	0x410fc270
    b4b4:	e000e400 	.word	0xe000e400
    b4b8:	20000800 	.word	0x20000800
    b4bc:	e000ed20 	.word	0xe000ed20
    b4c0:	0000b3a5 	.word	0x0000b3a5
    b4c4:	20000350 	.word	0x20000350
    b4c8:	0000b1f9 	.word	0x0000b1f9
    b4cc:	e000ef34 	.word	0xe000ef34
    b4d0:	0000b1d1 	.word	0x0000b1d1
    b4d4:	00012a45 	.word	0x00012a45
    b4d8:	0000b20d 	.word	0x0000b20d

0000b4dc <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
    b4dc:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    b4e0:	2b0f      	cmp	r3, #15
    b4e2:	4a10      	ldr	r2, [pc, #64]	; (b524 <vPortValidateInterruptPriority+0x48>)
    b4e4:	d90d      	bls.n	b502 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    b4e6:	4910      	ldr	r1, [pc, #64]	; (b528 <vPortValidateInterruptPriority+0x4c>)
    b4e8:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    b4ea:	7811      	ldrb	r1, [r2, #0]
    b4ec:	4299      	cmp	r1, r3
    b4ee:	d908      	bls.n	b502 <vPortValidateInterruptPriority+0x26>
    b4f0:	f04f 0380 	mov.w	r3, #128	; 0x80
    b4f4:	f383 8811 	msr	BASEPRI, r3
    b4f8:	f3bf 8f6f 	isb	sy
    b4fc:	f3bf 8f4f 	dsb	sy
    b500:	e7fe      	b.n	b500 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    b502:	4b0a      	ldr	r3, [pc, #40]	; (b52c <vPortValidateInterruptPriority+0x50>)
    b504:	6852      	ldr	r2, [r2, #4]
    b506:	681b      	ldr	r3, [r3, #0]
    b508:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    b50c:	4293      	cmp	r3, r2
    b50e:	d908      	bls.n	b522 <vPortValidateInterruptPriority+0x46>
    b510:	f04f 0380 	mov.w	r3, #128	; 0x80
    b514:	f383 8811 	msr	BASEPRI, r3
    b518:	f3bf 8f6f 	isb	sy
    b51c:	f3bf 8f4f 	dsb	sy
    b520:	e7fe      	b.n	b520 <vPortValidateInterruptPriority+0x44>
}
    b522:	4770      	bx	lr
    b524:	20000800 	.word	0x20000800
    b528:	e000e3f0 	.word	0xe000e3f0
    b52c:	e000ed0c 	.word	0xe000ed0c

0000b530 <i2c_m_async_write>:

/**
 * \brief Async version of I2C I/O write
 */
static int32_t i2c_m_async_write(struct io_descriptor *const io, const uint8_t *buf, const uint16_t n)
{
    b530:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct i2c_m_async_desc *i2c = CONTAINER_OF(io, struct i2c_m_async_desc, io);
	struct _i2c_m_msg        msg;
	int32_t                  ret;

	msg.addr   = i2c->slave_addr;
    b532:	8a83      	ldrh	r3, [r0, #20]
    b534:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
    b538:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    b53c:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
    b540:	9103      	str	r1, [sp, #12]

	/* start transfer then return */
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b542:	4b05      	ldr	r3, [pc, #20]	; (b558 <i2c_m_async_write+0x28>)
	msg.len    = n;
    b544:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b546:	a901      	add	r1, sp, #4
    b548:	3828      	subs	r0, #40	; 0x28
{
    b54a:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b54c:	4798      	blx	r3
		/* error occurred */
		return ret;
	}

	return (int32_t)n;
}
    b54e:	2800      	cmp	r0, #0
    b550:	bf08      	it	eq
    b552:	4620      	moveq	r0, r4
    b554:	b004      	add	sp, #16
    b556:	bd10      	pop	{r4, pc}
    b558:	000111b9 	.word	0x000111b9

0000b55c <i2c_m_async_read>:
{
    b55c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.addr   = i2c->slave_addr;
    b55e:	8a83      	ldrh	r3, [r0, #20]
    b560:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    b564:	f248 0301 	movw	r3, #32769	; 0x8001
    b568:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
    b56c:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b56e:	4b05      	ldr	r3, [pc, #20]	; (b584 <i2c_m_async_read+0x28>)
	msg.len    = n;
    b570:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b572:	a901      	add	r1, sp, #4
    b574:	3828      	subs	r0, #40	; 0x28
{
    b576:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b578:	4798      	blx	r3
}
    b57a:	2800      	cmp	r0, #0
    b57c:	bf08      	it	eq
    b57e:	4620      	moveq	r0, r4
    b580:	b004      	add	sp, #16
    b582:	bd10      	pop	{r4, pc}
    b584:	000111b9 	.word	0x000111b9

0000b588 <i2c_tx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b588:	8842      	ldrh	r2, [r0, #2]
    b58a:	05d2      	lsls	r2, r2, #23
    b58c:	d402      	bmi.n	b594 <i2c_tx_complete+0xc>
		if (i2c->i2c_cb.tx_complete) {
    b58e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b590:	b103      	cbz	r3, b594 <i2c_tx_complete+0xc>
			i2c->i2c_cb.tx_complete(i2c);
    b592:	4718      	bx	r3
}
    b594:	4770      	bx	lr

0000b596 <i2c_rx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b596:	8842      	ldrh	r2, [r0, #2]
    b598:	05d2      	lsls	r2, r2, #23
    b59a:	d402      	bmi.n	b5a2 <i2c_rx_complete+0xc>
		if (i2c->i2c_cb.rx_complete) {
    b59c:	6b83      	ldr	r3, [r0, #56]	; 0x38
    b59e:	b103      	cbz	r3, b5a2 <i2c_rx_complete+0xc>
			i2c->i2c_cb.rx_complete(i2c);
    b5a0:	4718      	bx	r3
}
    b5a2:	4770      	bx	lr

0000b5a4 <i2c_error>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b5a4:	8842      	ldrh	r2, [r0, #2]
    b5a6:	05d2      	lsls	r2, r2, #23
    b5a8:	d402      	bmi.n	b5b0 <i2c_error+0xc>
		if (i2c->i2c_cb.error) {
    b5aa:	6b03      	ldr	r3, [r0, #48]	; 0x30
    b5ac:	b103      	cbz	r3, b5b0 <i2c_error+0xc>
			i2c->i2c_cb.error(i2c, error);
    b5ae:	4718      	bx	r3
}
    b5b0:	4770      	bx	lr
	...

0000b5b4 <i2c_m_async_init>:

/**
 * \brief Async version of i2c initialize
 */
int32_t i2c_m_async_init(struct i2c_m_async_desc *const i2c, void *const hw)
{
    b5b4:	b570      	push	{r4, r5, r6, lr}
	int32_t init_status;
	ASSERT(i2c);
    b5b6:	4604      	mov	r4, r0
    b5b8:	3800      	subs	r0, #0
{
    b5ba:	460d      	mov	r5, r1
	ASSERT(i2c);
    b5bc:	bf18      	it	ne
    b5be:	2001      	movne	r0, #1
    b5c0:	490e      	ldr	r1, [pc, #56]	; (b5fc <i2c_m_async_init+0x48>)
    b5c2:	4b0f      	ldr	r3, [pc, #60]	; (b600 <i2c_m_async_init+0x4c>)
    b5c4:	2289      	movs	r2, #137	; 0x89
    b5c6:	4798      	blx	r3

	init_status = _i2c_m_async_init(&i2c->device, hw);
    b5c8:	4629      	mov	r1, r5
    b5ca:	4b0e      	ldr	r3, [pc, #56]	; (b604 <i2c_m_async_init+0x50>)
    b5cc:	4620      	mov	r0, r4
    b5ce:	4798      	blx	r3
	if (init_status) {
    b5d0:	4605      	mov	r5, r0
    b5d2:	b980      	cbnz	r0, b5f6 <i2c_m_async_init+0x42>
		return init_status;
	}
	/* Init I/O */
	i2c->io.read  = i2c_m_async_read;
    b5d4:	4b0c      	ldr	r3, [pc, #48]	; (b608 <i2c_m_async_init+0x54>)
    b5d6:	62e3      	str	r3, [r4, #44]	; 0x2c
	i2c->io.write = i2c_m_async_write;
    b5d8:	4b0c      	ldr	r3, [pc, #48]	; (b60c <i2c_m_async_init+0x58>)

	/* Init callbacks */
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b5da:	4a0d      	ldr	r2, [pc, #52]	; (b610 <i2c_m_async_init+0x5c>)
    b5dc:	4e0d      	ldr	r6, [pc, #52]	; (b614 <i2c_m_async_init+0x60>)
	i2c->io.write = i2c_m_async_write;
    b5de:	62a3      	str	r3, [r4, #40]	; 0x28
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b5e0:	2101      	movs	r1, #1
    b5e2:	4620      	mov	r0, r4
    b5e4:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_RX_COMPLETE, (FUNC_PTR)i2c_rx_complete);
    b5e6:	4a0c      	ldr	r2, [pc, #48]	; (b618 <i2c_m_async_init+0x64>)
    b5e8:	2102      	movs	r1, #2
    b5ea:	4620      	mov	r0, r4
    b5ec:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_ERROR, (FUNC_PTR)i2c_error);
    b5ee:	4a0b      	ldr	r2, [pc, #44]	; (b61c <i2c_m_async_init+0x68>)
    b5f0:	4629      	mov	r1, r5
    b5f2:	4620      	mov	r0, r4
    b5f4:	47b0      	blx	r6

	return ERR_NONE;
}
    b5f6:	4628      	mov	r0, r5
    b5f8:	bd70      	pop	{r4, r5, r6, pc}
    b5fa:	bf00      	nop
    b5fc:	000170f4 	.word	0x000170f4
    b600:	0000e08d 	.word	0x0000e08d
    b604:	0001113d 	.word	0x0001113d
    b608:	0000b55d 	.word	0x0000b55d
    b60c:	0000b531 	.word	0x0000b531
    b610:	0000b589 	.word	0x0000b589
    b614:	000112c1 	.word	0x000112c1
    b618:	0000b597 	.word	0x0000b597
    b61c:	0000b5a5 	.word	0x0000b5a5

0000b620 <prvInsertBlockIntoFreeList>:
	BlockLink_t *pxIterator;
	uint8_t *    puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    b620:	4b0f      	ldr	r3, [pc, #60]	; (b660 <prvInsertBlockIntoFreeList+0x40>)
{
    b622:	b530      	push	{r4, r5, lr}
    b624:	461d      	mov	r5, r3
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    b626:	461a      	mov	r2, r3
    b628:	681b      	ldr	r3, [r3, #0]
    b62a:	4283      	cmp	r3, r0
    b62c:	d3fb      	bcc.n	b626 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = (uint8_t *)pxIterator;
	if ((puc + pxIterator->xBlockSize) == (uint8_t *)pxBlockToInsert) {
    b62e:	6854      	ldr	r4, [r2, #4]
    b630:	1911      	adds	r1, r2, r4
    b632:	4288      	cmp	r0, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    b634:	bf01      	itttt	eq
    b636:	6841      	ldreq	r1, [r0, #4]
    b638:	4610      	moveq	r0, r2
    b63a:	1909      	addeq	r1, r1, r4
    b63c:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = (uint8_t *)pxBlockToInsert;
	if ((puc + pxBlockToInsert->xBlockSize) == (uint8_t *)pxIterator->pxNextFreeBlock) {
    b63e:	6844      	ldr	r4, [r0, #4]
    b640:	1901      	adds	r1, r0, r4
    b642:	428b      	cmp	r3, r1
    b644:	d106      	bne.n	b654 <prvInsertBlockIntoFreeList+0x34>
		if (pxIterator->pxNextFreeBlock != pxEnd) {
    b646:	68a9      	ldr	r1, [r5, #8]
    b648:	428b      	cmp	r3, r1
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    b64a:	bf1f      	itttt	ne
    b64c:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    b64e:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    b650:	1909      	addne	r1, r1, r4
    b652:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if (pxIterator != pxBlockToInsert) {
    b654:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    b656:	6003      	str	r3, [r0, #0]
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    b658:	bf18      	it	ne
    b65a:	6010      	strne	r0, [r2, #0]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    b65c:	bd30      	pop	{r4, r5, pc}
    b65e:	bf00      	nop
    b660:	20000808 	.word	0x20000808

0000b664 <pvPortMalloc>:
{
    b664:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (pxEnd == NULL) {
    b668:	4d39      	ldr	r5, [pc, #228]	; (b750 <pvPortMalloc+0xec>)
	vTaskSuspendAll();
    b66a:	4b3a      	ldr	r3, [pc, #232]	; (b754 <pvPortMalloc+0xf0>)
{
    b66c:	4604      	mov	r4, r0
	vTaskSuspendAll();
    b66e:	4798      	blx	r3
		if (pxEnd == NULL) {
    b670:	68ab      	ldr	r3, [r5, #8]
    b672:	b9bb      	cbnz	r3, b6a4 <pvPortMalloc+0x40>
	uxAddress = (size_t)ucHeap;
    b674:	4a38      	ldr	r2, [pc, #224]	; (b758 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
    b676:	4b39      	ldr	r3, [pc, #228]	; (b75c <pvPortMalloc+0xf8>)
	if ((uxAddress & portBYTE_ALIGNMENT_MASK) != 0) {
    b678:	0756      	lsls	r6, r2, #29
		uxAddress += (portBYTE_ALIGNMENT - 1);
    b67a:	bf18      	it	ne
    b67c:	3207      	addne	r2, #7
	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    b67e:	f023 0307 	bic.w	r3, r3, #7
		uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    b682:	bf18      	it	ne
    b684:	f022 0207 	bicne.w	r2, r2, #7
	xStart.xBlockSize      = (size_t)0;
    b688:	2100      	movs	r1, #0
    b68a:	6069      	str	r1, [r5, #4]
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
    b68c:	602a      	str	r2, [r5, #0]
	pxEnd->pxNextFreeBlock = NULL;
    b68e:	e9c3 1100 	strd	r1, r1, [r3]
	pxFirstFreeBlock->xBlockSize      = uxAddress - (size_t)pxFirstFreeBlock;
    b692:	1a99      	subs	r1, r3, r2
	xFreeBytesRemaining            = pxFirstFreeBlock->xBlockSize;
    b694:	e9c5 1103 	strd	r1, r1, [r5, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    b698:	e9c2 3100 	strd	r3, r1, [r2]
	pxEnd                  = (void *)uxAddress;
    b69c:	60ab      	str	r3, [r5, #8]
	xBlockAllocatedBit = ((size_t)1) << ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);
    b69e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    b6a2:	616b      	str	r3, [r5, #20]
		if ((xWantedSize & xBlockAllocatedBit) == 0) {
    b6a4:	f8d5 8014 	ldr.w	r8, [r5, #20]
    b6a8:	ea18 0f04 	tst.w	r8, r4
    b6ac:	d14b      	bne.n	b746 <pvPortMalloc+0xe2>
			if (xWantedSize > 0) {
    b6ae:	2c00      	cmp	r4, #0
    b6b0:	d03c      	beq.n	b72c <pvPortMalloc+0xc8>
				xWantedSize += xHeapStructSize;
    b6b2:	f104 0308 	add.w	r3, r4, #8
				if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0x00) {
    b6b6:	0760      	lsls	r0, r4, #29
					xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    b6b8:	bf1c      	itt	ne
    b6ba:	f023 0307 	bicne.w	r3, r3, #7
    b6be:	3308      	addne	r3, #8
			if ((xWantedSize > 0) && (xWantedSize <= xFreeBytesRemaining)) {
    b6c0:	2b00      	cmp	r3, #0
    b6c2:	d040      	beq.n	b746 <pvPortMalloc+0xe2>
    b6c4:	692f      	ldr	r7, [r5, #16]
    b6c6:	429f      	cmp	r7, r3
    b6c8:	d33d      	bcc.n	b746 <pvPortMalloc+0xe2>
				pxBlock         = xStart.pxNextFreeBlock;
    b6ca:	682e      	ldr	r6, [r5, #0]
				pxPreviousBlock = &xStart;
    b6cc:	4820      	ldr	r0, [pc, #128]	; (b750 <pvPortMalloc+0xec>)
				while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    b6ce:	6872      	ldr	r2, [r6, #4]
    b6d0:	429a      	cmp	r2, r3
    b6d2:	d201      	bcs.n	b6d8 <pvPortMalloc+0x74>
    b6d4:	6831      	ldr	r1, [r6, #0]
    b6d6:	b9a1      	cbnz	r1, b702 <pvPortMalloc+0x9e>
				if (pxBlock != pxEnd) {
    b6d8:	68a9      	ldr	r1, [r5, #8]
    b6da:	42b1      	cmp	r1, r6
    b6dc:	d033      	beq.n	b746 <pvPortMalloc+0xe2>
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    b6de:	1ad2      	subs	r2, r2, r3
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    b6e0:	6831      	ldr	r1, [r6, #0]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    b6e2:	6804      	ldr	r4, [r0, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    b6e4:	6001      	str	r1, [r0, #0]
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    b6e6:	2a10      	cmp	r2, #16
    b6e8:	d912      	bls.n	b710 <pvPortMalloc+0xac>
						pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    b6ea:	18f0      	adds	r0, r6, r3
						configASSERT((((size_t)pxNewBlockLink) & portBYTE_ALIGNMENT_MASK) == 0);
    b6ec:	0741      	lsls	r1, r0, #29
    b6ee:	d00b      	beq.n	b708 <pvPortMalloc+0xa4>
    b6f0:	f04f 0380 	mov.w	r3, #128	; 0x80
    b6f4:	f383 8811 	msr	BASEPRI, r3
    b6f8:	f3bf 8f6f 	isb	sy
    b6fc:	f3bf 8f4f 	dsb	sy
    b700:	e7fe      	b.n	b700 <pvPortMalloc+0x9c>
    b702:	4630      	mov	r0, r6
    b704:	460e      	mov	r6, r1
    b706:	e7e2      	b.n	b6ce <pvPortMalloc+0x6a>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    b708:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize        = xWantedSize;
    b70a:	6073      	str	r3, [r6, #4]
						prvInsertBlockIntoFreeList(pxNewBlockLink);
    b70c:	4b14      	ldr	r3, [pc, #80]	; (b760 <pvPortMalloc+0xfc>)
    b70e:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    b710:	6873      	ldr	r3, [r6, #4]
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    b712:	68e9      	ldr	r1, [r5, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    b714:	1aff      	subs	r7, r7, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    b716:	ea48 0303 	orr.w	r3, r8, r3
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    b71a:	428f      	cmp	r7, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    b71c:	6073      	str	r3, [r6, #4]
					pxBlock->pxNextFreeBlock = NULL;
    b71e:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    b722:	612f      	str	r7, [r5, #16]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    b724:	bf38      	it	cc
    b726:	60ef      	strcc	r7, [r5, #12]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    b728:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
    b72a:	6033      	str	r3, [r6, #0]
	(void)xTaskResumeAll();
    b72c:	4b0d      	ldr	r3, [pc, #52]	; (b764 <pvPortMalloc+0x100>)
    b72e:	4798      	blx	r3
	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);
    b730:	0763      	lsls	r3, r4, #29
    b732:	d00a      	beq.n	b74a <pvPortMalloc+0xe6>
    b734:	f04f 0380 	mov.w	r3, #128	; 0x80
    b738:	f383 8811 	msr	BASEPRI, r3
    b73c:	f3bf 8f6f 	isb	sy
    b740:	f3bf 8f4f 	dsb	sy
    b744:	e7fe      	b.n	b744 <pvPortMalloc+0xe0>
	void *       pvReturn = NULL;
    b746:	2400      	movs	r4, #0
    b748:	e7f0      	b.n	b72c <pvPortMalloc+0xc8>
}
    b74a:	4620      	mov	r0, r4
    b74c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    b750:	20000808 	.word	0x20000808
    b754:	000127b1 	.word	0x000127b1
    b758:	20000820 	.word	0x20000820
    b75c:	20008518 	.word	0x20008518
    b760:	0000b621 	.word	0x0000b621
    b764:	000128f9 	.word	0x000128f9

0000b768 <vPortFree>:
{
    b768:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    b76a:	4604      	mov	r4, r0
    b76c:	b368      	cbz	r0, b7ca <vPortFree+0x62>
		configASSERT((pxLink->xBlockSize & xBlockAllocatedBit) != 0);
    b76e:	4d17      	ldr	r5, [pc, #92]	; (b7cc <vPortFree+0x64>)
    b770:	f850 3c04 	ldr.w	r3, [r0, #-4]
    b774:	696a      	ldr	r2, [r5, #20]
    b776:	4213      	tst	r3, r2
    b778:	d108      	bne.n	b78c <vPortFree+0x24>
    b77a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b77e:	f383 8811 	msr	BASEPRI, r3
    b782:	f3bf 8f6f 	isb	sy
    b786:	f3bf 8f4f 	dsb	sy
    b78a:	e7fe      	b.n	b78a <vPortFree+0x22>
		configASSERT(pxLink->pxNextFreeBlock == NULL);
    b78c:	f850 1c08 	ldr.w	r1, [r0, #-8]
    b790:	b141      	cbz	r1, b7a4 <vPortFree+0x3c>
    b792:	f04f 0380 	mov.w	r3, #128	; 0x80
    b796:	f383 8811 	msr	BASEPRI, r3
    b79a:	f3bf 8f6f 	isb	sy
    b79e:	f3bf 8f4f 	dsb	sy
    b7a2:	e7fe      	b.n	b7a2 <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    b7a4:	ea23 0302 	bic.w	r3, r3, r2
    b7a8:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
    b7ac:	4b08      	ldr	r3, [pc, #32]	; (b7d0 <vPortFree+0x68>)
    b7ae:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
    b7b0:	692a      	ldr	r2, [r5, #16]
    b7b2:	f854 3c04 	ldr.w	r3, [r4, #-4]
    b7b6:	4413      	add	r3, r2
    b7b8:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    b7ba:	f1a4 0008 	sub.w	r0, r4, #8
    b7be:	4b05      	ldr	r3, [pc, #20]	; (b7d4 <vPortFree+0x6c>)
    b7c0:	4798      	blx	r3
}
    b7c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				(void)xTaskResumeAll();
    b7c6:	4b04      	ldr	r3, [pc, #16]	; (b7d8 <vPortFree+0x70>)
    b7c8:	4718      	bx	r3
}
    b7ca:	bd70      	pop	{r4, r5, r6, pc}
    b7cc:	20000808 	.word	0x20000808
    b7d0:	000127b1 	.word	0x000127b1
    b7d4:	0000b621 	.word	0x0000b621
    b7d8:	000128f9 	.word	0x000128f9

0000b7dc <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    b7dc:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    b7de:	4604      	mov	r4, r0
    b7e0:	b118      	cbz	r0, b7ea <_wdt_init+0xe>
    b7e2:	6800      	ldr	r0, [r0, #0]
    b7e4:	3800      	subs	r0, #0
    b7e6:	bf18      	it	ne
    b7e8:	2001      	movne	r0, #1
    b7ea:	4b12      	ldr	r3, [pc, #72]	; (b834 <_wdt_init+0x58>)
    b7ec:	4912      	ldr	r1, [pc, #72]	; (b838 <_wdt_init+0x5c>)
    b7ee:	2250      	movs	r2, #80	; 0x50
    b7f0:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    b7f2:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b7f4:	689a      	ldr	r2, [r3, #8]
    b7f6:	f012 0f0e 	tst.w	r2, #14
    b7fa:	d1fb      	bne.n	b7f4 <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    b7fc:	781a      	ldrb	r2, [r3, #0]
    b7fe:	09d2      	lsrs	r2, r2, #7
    b800:	d115      	bne.n	b82e <_wdt_init+0x52>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b802:	689a      	ldr	r2, [r3, #8]
    b804:	f012 0f0e 	tst.w	r2, #14
    b808:	d1fb      	bne.n	b802 <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    b80a:	781a      	ldrb	r2, [r3, #0]
    b80c:	0792      	lsls	r2, r2, #30
    b80e:	d40e      	bmi.n	b82e <_wdt_init+0x52>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    b810:	781a      	ldrb	r2, [r3, #0]
    b812:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    b816:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b818:	6898      	ldr	r0, [r3, #8]
    b81a:	f010 000e 	ands.w	r0, r0, #14
    b81e:	d1fb      	bne.n	b818 <_wdt_init+0x3c>

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    b820:	785a      	ldrb	r2, [r3, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    b822:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= WDT_CONFIG_PER(data);
    b826:	f042 020b 	orr.w	r2, r2, #11
	((Wdt *)hw)->CONFIG.reg = tmp;
    b82a:	705a      	strb	r2, [r3, #1]

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
	}

	return ERR_NONE;
}
    b82c:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    b82e:	f06f 0010 	mvn.w	r0, #16
    b832:	e7fb      	b.n	b82c <_wdt_init+0x50>
    b834:	0000e08d 	.word	0x0000e08d
    b838:	00017111 	.word	0x00017111

0000b83c <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    b83c:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    b83e:	4288      	cmp	r0, r1
    b840:	d301      	bcc.n	b846 <usb_find_desc+0xa>
		_desc_len_check();
    b842:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    b844:	bd10      	pop	{r4, pc}
		_desc_len_check();
    b846:	7803      	ldrb	r3, [r0, #0]
    b848:	2b01      	cmp	r3, #1
    b84a:	d9fa      	bls.n	b842 <usb_find_desc+0x6>
		if (type == usb_desc_type(desc)) {
    b84c:	7844      	ldrb	r4, [r0, #1]
    b84e:	4294      	cmp	r4, r2
    b850:	d0f8      	beq.n	b844 <usb_find_desc+0x8>
    b852:	4418      	add	r0, r3
    b854:	e7f3      	b.n	b83e <usb_find_desc+0x2>

0000b856 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    b856:	4288      	cmp	r0, r1
    b858:	d301      	bcc.n	b85e <usb_find_ep_desc+0x8>
		_desc_len_check();
    b85a:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    b85c:	4770      	bx	lr
		_desc_len_check();
    b85e:	7803      	ldrb	r3, [r0, #0]
    b860:	2b01      	cmp	r3, #1
    b862:	d9fa      	bls.n	b85a <usb_find_ep_desc+0x4>
	return desc[1];
    b864:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    b866:	2a04      	cmp	r2, #4
    b868:	d0f7      	beq.n	b85a <usb_find_ep_desc+0x4>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    b86a:	2a05      	cmp	r2, #5
    b86c:	d0f6      	beq.n	b85c <usb_find_ep_desc+0x6>
	return (desc + usb_desc_len(desc));
    b86e:	4418      	add	r0, r3
    b870:	e7f1      	b.n	b856 <usb_find_ep_desc>
	...

0000b874 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    b874:	b538      	push	{r3, r4, r5, lr}
    b876:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    b878:	4b0c      	ldr	r3, [pc, #48]	; (b8ac <usb_find_cfg_desc+0x38>)
    b87a:	2202      	movs	r2, #2
{
    b87c:	460c      	mov	r4, r1
	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    b87e:	4798      	blx	r3
	if (!desc) {
    b880:	b978      	cbnz	r0, b8a2 <usb_find_cfg_desc+0x2e>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
}
    b882:	bd38      	pop	{r3, r4, r5, pc}
		_desc_len_check();
    b884:	7803      	ldrb	r3, [r0, #0]
    b886:	2b01      	cmp	r3, #1
    b888:	d90d      	bls.n	b8a6 <usb_find_cfg_desc+0x32>
		if (desc[1] != USB_DT_CONFIG) {
    b88a:	7843      	ldrb	r3, [r0, #1]
    b88c:	2b02      	cmp	r3, #2
    b88e:	d10a      	bne.n	b8a6 <usb_find_cfg_desc+0x32>
		if (desc[5] == cfg_value) {
    b890:	7943      	ldrb	r3, [r0, #5]
    b892:	42ab      	cmp	r3, r5
    b894:	d0f5      	beq.n	b882 <usb_find_cfg_desc+0xe>
	return (ptr[0] + (ptr[1] << 8));
    b896:	78c2      	ldrb	r2, [r0, #3]
    b898:	7883      	ldrb	r3, [r0, #2]
    b89a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    b89e:	fa10 f083 	uxtah	r0, r0, r3
	while (desc < eof) {
    b8a2:	42a0      	cmp	r0, r4
    b8a4:	d3ee      	bcc.n	b884 <usb_find_cfg_desc+0x10>
		return NULL;
    b8a6:	2000      	movs	r0, #0
    b8a8:	e7eb      	b.n	b882 <usb_find_cfg_desc+0xe>
    b8aa:	bf00      	nop
    b8ac:	0000b83d 	.word	0x0000b83d

0000b8b0 <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    b8b0:	b570      	push	{r4, r5, r6, lr}
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    b8b2:	4e09      	ldr	r6, [pc, #36]	; (b8d8 <usb_find_str_desc+0x28>)
{
    b8b4:	4615      	mov	r5, r2
	for (i = 0; desc < eof;) {
    b8b6:	2400      	movs	r4, #0
    b8b8:	4288      	cmp	r0, r1
    b8ba:	d301      	bcc.n	b8c0 <usb_find_str_desc+0x10>
				return desc;
			}
			i++;
			desc = usb_desc_next(desc);
		} else {
			return NULL;
    b8bc:	2000      	movs	r0, #0
		}
	}
	return NULL;
}
    b8be:	bd70      	pop	{r4, r5, r6, pc}
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    b8c0:	2203      	movs	r2, #3
    b8c2:	47b0      	blx	r6
		if (desc) {
    b8c4:	2800      	cmp	r0, #0
    b8c6:	d0fa      	beq.n	b8be <usb_find_str_desc+0xe>
			_desc_len_check();
    b8c8:	7803      	ldrb	r3, [r0, #0]
    b8ca:	2b01      	cmp	r3, #1
    b8cc:	d9f6      	bls.n	b8bc <usb_find_str_desc+0xc>
			if (i == str_index) {
    b8ce:	42ac      	cmp	r4, r5
    b8d0:	d0f5      	beq.n	b8be <usb_find_str_desc+0xe>
	return (desc + usb_desc_len(desc));
    b8d2:	4418      	add	r0, r3
    b8d4:	3401      	adds	r4, #1
    b8d6:	e7ef      	b.n	b8b8 <usb_find_str_desc+0x8>
    b8d8:	0000b83d 	.word	0x0000b83d

0000b8dc <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    b8dc:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    b8de:	4e07      	ldr	r6, [pc, #28]	; (b8fc <stdio_io_init+0x20>)
    b8e0:	4d07      	ldr	r5, [pc, #28]	; (b900 <stdio_io_init+0x24>)
    b8e2:	6833      	ldr	r3, [r6, #0]
{
    b8e4:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
    b8e6:	2100      	movs	r1, #0
    b8e8:	6898      	ldr	r0, [r3, #8]
    b8ea:	47a8      	blx	r5
	setbuf(stdin, NULL);
    b8ec:	6833      	ldr	r3, [r6, #0]
    b8ee:	2100      	movs	r1, #0
    b8f0:	6858      	ldr	r0, [r3, #4]
    b8f2:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    b8f4:	4b03      	ldr	r3, [pc, #12]	; (b904 <stdio_io_init+0x28>)
    b8f6:	601c      	str	r4, [r3, #0]
}
    b8f8:	bd70      	pop	{r4, r5, r6, pc}
    b8fa:	bf00      	nop
    b8fc:	2000054c 	.word	0x2000054c
    b900:	000147f1 	.word	0x000147f1
    b904:	20008520 	.word	0x20008520

0000b908 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    b908:	4a04      	ldr	r2, [pc, #16]	; (b91c <stdio_io_read+0x14>)
{
    b90a:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    b90c:	6810      	ldr	r0, [r2, #0]
    b90e:	b118      	cbz	r0, b918 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
    b910:	b28a      	uxth	r2, r1
    b912:	4619      	mov	r1, r3
    b914:	4b02      	ldr	r3, [pc, #8]	; (b920 <stdio_io_read+0x18>)
    b916:	4718      	bx	r3
}
    b918:	4770      	bx	lr
    b91a:	bf00      	nop
    b91c:	20008520 	.word	0x20008520
    b920:	0000b11d 	.word	0x0000b11d

0000b924 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    b924:	4a04      	ldr	r2, [pc, #16]	; (b938 <stdio_io_write+0x14>)
{
    b926:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    b928:	6810      	ldr	r0, [r2, #0]
    b92a:	b118      	cbz	r0, b934 <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
    b92c:	b28a      	uxth	r2, r1
    b92e:	4619      	mov	r1, r3
    b930:	4b02      	ldr	r3, [pc, #8]	; (b93c <stdio_io_write+0x18>)
    b932:	4718      	bx	r3
}
    b934:	4770      	bx	lr
    b936:	bf00      	nop
    b938:	20008520 	.word	0x20008520
    b93c:	0000b0ed 	.word	0x0000b0ed

0000b940 <_spi_m_dma_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_dma_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    b940:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    b942:	4604      	mov	r4, r0
    b944:	3800      	subs	r0, #0
{
    b946:	460d      	mov	r5, r1
    b948:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    b94a:	bf18      	it	ne
    b94c:	2001      	movne	r0, #1
    b94e:	4907      	ldr	r1, [pc, #28]	; (b96c <_spi_m_dma_io_write+0x2c>)
    b950:	4e07      	ldr	r6, [pc, #28]	; (b970 <_spi_m_dma_io_write+0x30>)
    b952:	2298      	movs	r2, #152	; 0x98
    b954:	47b0      	blx	r6

	struct spi_m_dma_descriptor *spi = CONTAINER_OF(io, struct spi_m_dma_descriptor, io);
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    b956:	f1a4 001c 	sub.w	r0, r4, #28
    b95a:	4c06      	ldr	r4, [pc, #24]	; (b974 <_spi_m_dma_io_write+0x34>)
    b95c:	9b01      	ldr	r3, [sp, #4]
    b95e:	2200      	movs	r2, #0
    b960:	4629      	mov	r1, r5
    b962:	46a4      	mov	ip, r4
}
    b964:	b002      	add	sp, #8
    b966:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    b96a:	4760      	bx	ip
    b96c:	00017126 	.word	0x00017126
    b970:	0000e08d 	.word	0x0000e08d
    b974:	00011945 	.word	0x00011945

0000b978 <_spi_m_dma_io_read>:
{
    b978:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    b97a:	4604      	mov	r4, r0
    b97c:	3800      	subs	r0, #0
{
    b97e:	460d      	mov	r5, r1
    b980:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    b982:	bf18      	it	ne
    b984:	2001      	movne	r0, #1
    b986:	4907      	ldr	r1, [pc, #28]	; (b9a4 <_spi_m_dma_io_read+0x2c>)
    b988:	4e07      	ldr	r6, [pc, #28]	; (b9a8 <_spi_m_dma_io_read+0x30>)
    b98a:	2281      	movs	r2, #129	; 0x81
    b98c:	47b0      	blx	r6
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    b98e:	f1a4 001c 	sub.w	r0, r4, #28
    b992:	4c06      	ldr	r4, [pc, #24]	; (b9ac <_spi_m_dma_io_read+0x34>)
    b994:	9b01      	ldr	r3, [sp, #4]
    b996:	462a      	mov	r2, r5
    b998:	2100      	movs	r1, #0
    b99a:	46a4      	mov	ip, r4
}
    b99c:	b002      	add	sp, #8
    b99e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    b9a2:	4760      	bx	ip
    b9a4:	00017126 	.word	0x00017126
    b9a8:	0000e08d 	.word	0x0000e08d
    b9ac:	00011945 	.word	0x00011945

0000b9b0 <spi_m_dma_init>:
{
    b9b0:	b538      	push	{r3, r4, r5, lr}
    b9b2:	460d      	mov	r5, r1
	ASSERT(spi && hw);
    b9b4:	4604      	mov	r4, r0
    b9b6:	b110      	cbz	r0, b9be <spi_m_dma_init+0xe>
    b9b8:	1e08      	subs	r0, r1, #0
    b9ba:	bf18      	it	ne
    b9bc:	2001      	movne	r0, #1
    b9be:	4908      	ldr	r1, [pc, #32]	; (b9e0 <spi_m_dma_init+0x30>)
    b9c0:	4b08      	ldr	r3, [pc, #32]	; (b9e4 <spi_m_dma_init+0x34>)
    b9c2:	223b      	movs	r2, #59	; 0x3b
    b9c4:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    b9c6:	4620      	mov	r0, r4
	rc            = _spi_m_dma_init(&spi->dev, hw);
    b9c8:	4b07      	ldr	r3, [pc, #28]	; (b9e8 <spi_m_dma_init+0x38>)
	spi->dev.prvt = (void *)hw;
    b9ca:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_dma_init(&spi->dev, hw);
    b9ce:	4629      	mov	r1, r5
    b9d0:	4798      	blx	r3
	if (rc) {
    b9d2:	b918      	cbnz	r0, b9dc <spi_m_dma_init+0x2c>
	spi->io.read  = _spi_m_dma_io_read;
    b9d4:	4b05      	ldr	r3, [pc, #20]	; (b9ec <spi_m_dma_init+0x3c>)
    b9d6:	6263      	str	r3, [r4, #36]	; 0x24
	spi->io.write = _spi_m_dma_io_write;
    b9d8:	4b05      	ldr	r3, [pc, #20]	; (b9f0 <spi_m_dma_init+0x40>)
    b9da:	6223      	str	r3, [r4, #32]
}
    b9dc:	bd38      	pop	{r3, r4, r5, pc}
    b9de:	bf00      	nop
    b9e0:	00017126 	.word	0x00017126
    b9e4:	0000e08d 	.word	0x0000e08d
    b9e8:	000117bd 	.word	0x000117bd
    b9ec:	0000b979 	.word	0x0000b979
    b9f0:	0000b941 	.word	0x0000b941

0000b9f4 <spi_m_dma_enable>:
{
    b9f4:	b510      	push	{r4, lr}
	ASSERT(spi);
    b9f6:	4604      	mov	r4, r0
    b9f8:	3800      	subs	r0, #0
    b9fa:	4b05      	ldr	r3, [pc, #20]	; (ba10 <spi_m_dma_enable+0x1c>)
    b9fc:	4905      	ldr	r1, [pc, #20]	; (ba14 <spi_m_dma_enable+0x20>)
    b9fe:	bf18      	it	ne
    ba00:	2001      	movne	r0, #1
    ba02:	2251      	movs	r2, #81	; 0x51
    ba04:	4798      	blx	r3
	_spi_m_dma_enable(&spi->dev);
    ba06:	1d20      	adds	r0, r4, #4
    ba08:	4b03      	ldr	r3, [pc, #12]	; (ba18 <spi_m_dma_enable+0x24>)
}
    ba0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_dma_enable(&spi->dev);
    ba0e:	4718      	bx	r3
    ba10:	0000e08d 	.word	0x0000e08d
    ba14:	00017126 	.word	0x00017126
    ba18:	00011881 	.word	0x00011881

0000ba1c <spi_m_dma_register_callback>:
	return _spi_m_dma_transfer(&spi->dev, txbuf, rxbuf, length);
}

void spi_m_dma_register_callback(struct spi_m_dma_descriptor *spi, const enum spi_m_dma_cb_type type,
                                 spi_m_dma_cb_t func)
{
    ba1c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    ba1e:	4604      	mov	r4, r0
    ba20:	3800      	subs	r0, #0
{
    ba22:	460d      	mov	r5, r1
    ba24:	4616      	mov	r6, r2
	ASSERT(spi);
    ba26:	4907      	ldr	r1, [pc, #28]	; (ba44 <spi_m_dma_register_callback+0x28>)
    ba28:	4b07      	ldr	r3, [pc, #28]	; (ba48 <spi_m_dma_register_callback+0x2c>)
    ba2a:	f04f 02a8 	mov.w	r2, #168	; 0xa8
    ba2e:	bf18      	it	ne
    ba30:	2001      	movne	r0, #1
    ba32:	4798      	blx	r3
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    ba34:	4632      	mov	r2, r6
    ba36:	4629      	mov	r1, r5
    ba38:	1d20      	adds	r0, r4, #4
    ba3a:	4b04      	ldr	r3, [pc, #16]	; (ba4c <spi_m_dma_register_callback+0x30>)
}
    ba3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    ba40:	4718      	bx	r3
    ba42:	bf00      	nop
    ba44:	00017126 	.word	0x00017126
    ba48:	0000e08d 	.word	0x0000e08d
    ba4c:	000118b1 	.word	0x000118b1

0000ba50 <spi_m_dma_get_io_descriptor>:

int32_t spi_m_dma_get_io_descriptor(struct spi_m_dma_descriptor *const spi, struct io_descriptor **io)
{
    ba50:	b538      	push	{r3, r4, r5, lr}
    ba52:	460d      	mov	r5, r1
	ASSERT(spi && io);
    ba54:	4604      	mov	r4, r0
    ba56:	b110      	cbz	r0, ba5e <spi_m_dma_get_io_descriptor+0xe>
    ba58:	1e08      	subs	r0, r1, #0
    ba5a:	bf18      	it	ne
    ba5c:	2001      	movne	r0, #1
    ba5e:	4904      	ldr	r1, [pc, #16]	; (ba70 <spi_m_dma_get_io_descriptor+0x20>)
    ba60:	4b04      	ldr	r3, [pc, #16]	; (ba74 <spi_m_dma_get_io_descriptor+0x24>)
    ba62:	22ae      	movs	r2, #174	; 0xae
	*io = &spi->io;
    ba64:	3420      	adds	r4, #32
	ASSERT(spi && io);
    ba66:	4798      	blx	r3
	*io = &spi->io;
    ba68:	602c      	str	r4, [r5, #0]

	return 0;
}
    ba6a:	2000      	movs	r0, #0
    ba6c:	bd38      	pop	{r3, r4, r5, pc}
    ba6e:	bf00      	nop
    ba70:	00017126 	.word	0x00017126
    ba74:	0000e08d 	.word	0x0000e08d

0000ba78 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    ba78:	3801      	subs	r0, #1
    ba7a:	2802      	cmp	r0, #2
{
    ba7c:	b508      	push	{r3, lr}
    ba7e:	460b      	mov	r3, r1
    ba80:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    ba82:	d805      	bhi.n	ba90 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    ba84:	4618      	mov	r0, r3
    ba86:	4b04      	ldr	r3, [pc, #16]	; (ba98 <_write+0x20>)
    ba88:	4798      	blx	r3
	if (n < 0) {
    ba8a:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    ba8e:	bd08      	pop	{r3, pc}
		return -1;
    ba90:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ba94:	e7fb      	b.n	ba8e <_write+0x16>
    ba96:	bf00      	nop
    ba98:	0000b925 	.word	0x0000b925

0000ba9c <_event_system_init>:

/**
 * \brief Initialize event system
 */
int32_t _event_system_init(void)
{
    ba9c:	b510      	push	{r4, lr}
    ba9e:	4a13      	ldr	r2, [pc, #76]	; (baec <_event_system_init+0x50>)
}

static inline void hri_evsys_write_USER_reg(const void *const hw, uint8_t index, hri_evsys_user_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->USER[index].reg = data;
    baa0:	4913      	ldr	r1, [pc, #76]	; (baf0 <_event_system_init+0x54>)
    baa2:	2300      	movs	r3, #0
    baa4:	f103 0048 	add.w	r0, r3, #72	; 0x48
    baa8:	3301      	adds	r3, #1
	uint8_t i;
	/* configure user multiplexers */
	for (i = 0; i < EVSYS_USERS; i++) {
		hri_evsys_write_USER_reg(EVSYS, i, user_mux_confs[i]);
    baaa:	f812 4b01 	ldrb.w	r4, [r2], #1
    baae:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	for (i = 0; i < EVSYS_USERS; i++) {
    bab2:	2b43      	cmp	r3, #67	; 0x43
    bab4:	d1f6      	bne.n	baa4 <_event_system_init+0x8>
    bab6:	480f      	ldr	r0, [pc, #60]	; (baf4 <_event_system_init+0x58>)
    bab8:	2100      	movs	r1, #0
    baba:	f100 0440 	add.w	r4, r0, #64	; 0x40
	}

	/* configure channels */
	for (i = 0; i < EVSYS_CHANNELS; i++) {
		hri_evsys_write_CHANNEL_reg(EVSYS, i, channel_confs[i]);
    babe:	00ca      	lsls	r2, r1, #3
    bac0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    bac4:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    bac8:	f830 3b02 	ldrh.w	r3, [r0], #2

static inline void hri_evsys_write_CHANNEL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_channel_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->Channel[submodule_index].CHANNEL.reg = data;
    bacc:	6213      	str	r3, [r2, #32]
		hri_evsys_write_CHINTEN_reg(EVSYS, i, interrupt_cfg[i]);
    bace:	f854 3b04 	ldr.w	r3, [r4], #4
    bad2:	b2db      	uxtb	r3, r3
	((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg = data;
    bad4:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
	((Evsys *)hw)->Channel[submodule_index].CHINTENCLR.reg = ~data;
    bad8:	3101      	adds	r1, #1
    bada:	43db      	mvns	r3, r3
    badc:	b2db      	uxtb	r3, r3
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    bade:	2920      	cmp	r1, #32
    bae0:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    bae4:	d1eb      	bne.n	babe <_event_system_init+0x22>
	}

	return ERR_NONE;
}
    bae6:	2000      	movs	r0, #0
    bae8:	bd10      	pop	{r4, pc}
    baea:	bf00      	nop
    baec:	00017144 	.word	0x00017144
    baf0:	4100e000 	.word	0x4100e000
    baf4:	00017188 	.word	0x00017188

0000baf8 <_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    baf8:	0943      	lsrs	r3, r0, #5
    bafa:	2201      	movs	r2, #1
    bafc:	f000 001f 	and.w	r0, r0, #31
    bb00:	fa02 f000 	lsl.w	r0, r2, r0
    bb04:	3340      	adds	r3, #64	; 0x40
    bb06:	4a02      	ldr	r2, [pc, #8]	; (bb10 <_irq_set+0x18>)
    bb08:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
}
    bb0c:	4770      	bx	lr
    bb0e:	bf00      	nop
    bb10:	e000e100 	.word	0xe000e100

0000bb14 <_get_cycles_for_ms>:
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    bb14:	4b01      	ldr	r3, [pc, #4]	; (bb1c <_get_cycles_for_ms+0x8>)
    bb16:	4358      	muls	r0, r3
    bb18:	4770      	bx	lr
    bb1a:	bf00      	nop
    bb1c:	0001d4c0 	.word	0x0001d4c0

0000bb20 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    bb20:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    bb24:	4615      	mov	r5, r2
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    bb26:	780a      	ldrb	r2, [r1, #0]
    bb28:	f3c2 1341 	ubfx	r3, r2, #5, #2
    bb2c:	2b01      	cmp	r3, #1
{
    bb2e:	4606      	mov	r6, r0
    bb30:	460c      	mov	r4, r1
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    bb32:	d155      	bne.n	bbe0 <cdcdf_acm_req+0xc0>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    bb34:	4b2d      	ldr	r3, [pc, #180]	; (bbec <cdcdf_acm_req+0xcc>)
    bb36:	8889      	ldrh	r1, [r1, #4]
    bb38:	7818      	ldrb	r0, [r3, #0]
    bb3a:	4288      	cmp	r0, r1
    bb3c:	4698      	mov	r8, r3
    bb3e:	d002      	beq.n	bb46 <cdcdf_acm_req+0x26>
    bb40:	785b      	ldrb	r3, [r3, #1]
    bb42:	428b      	cmp	r3, r1
    bb44:	d14c      	bne.n	bbe0 <cdcdf_acm_req+0xc0>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    bb46:	0613      	lsls	r3, r2, #24
    bb48:	88e7      	ldrh	r7, [r4, #6]
    bb4a:	d50f      	bpl.n	bb6c <cdcdf_acm_req+0x4c>
	if (USB_DATA_STAGE == stage) {
    bb4c:	2d01      	cmp	r5, #1
    bb4e:	d033      	beq.n	bbb8 <cdcdf_acm_req+0x98>
	switch (req->bRequest) {
    bb50:	7863      	ldrb	r3, [r4, #1]
    bb52:	2b21      	cmp	r3, #33	; 0x21
    bb54:	d112      	bne.n	bb7c <cdcdf_acm_req+0x5c>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    bb56:	2f07      	cmp	r7, #7
    bb58:	d145      	bne.n	bbe6 <cdcdf_acm_req+0xc6>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    bb5a:	4925      	ldr	r1, [pc, #148]	; (bbf0 <cdcdf_acm_req+0xd0>)
    bb5c:	2300      	movs	r3, #0
    bb5e:	463a      	mov	r2, r7
			return usbdc_xfer(ep, ctrl_buf, len, false);
    bb60:	4c24      	ldr	r4, [pc, #144]	; (bbf4 <cdcdf_acm_req+0xd4>)
    bb62:	4630      	mov	r0, r6
    bb64:	47a0      	blx	r4
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    bb66:	b002      	add	sp, #8
    bb68:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    bb6c:	4b22      	ldr	r3, [pc, #136]	; (bbf8 <cdcdf_acm_req+0xd8>)
    bb6e:	4798      	blx	r3
	switch (req->bRequest) {
    bb70:	7863      	ldrb	r3, [r4, #1]
    bb72:	2b20      	cmp	r3, #32
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    bb74:	4601      	mov	r1, r0
	switch (req->bRequest) {
    bb76:	d004      	beq.n	bb82 <cdcdf_acm_req+0x62>
    bb78:	2b22      	cmp	r3, #34	; 0x22
    bb7a:	d024      	beq.n	bbc6 <cdcdf_acm_req+0xa6>
		return ERR_INVALID_ARG;
    bb7c:	f06f 000c 	mvn.w	r0, #12
    bb80:	e7f1      	b.n	bb66 <cdcdf_acm_req+0x46>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    bb82:	2f07      	cmp	r7, #7
    bb84:	d12f      	bne.n	bbe6 <cdcdf_acm_req+0xc6>
		if (USB_SETUP_STAGE == stage) {
    bb86:	b915      	cbnz	r5, bb8e <cdcdf_acm_req+0x6e>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    bb88:	462b      	mov	r3, r5
    bb8a:	463a      	mov	r2, r7
    bb8c:	e7e8      	b.n	bb60 <cdcdf_acm_req+0x40>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    bb8e:	6800      	ldr	r0, [r0, #0]
    bb90:	9000      	str	r0, [sp, #0]
    bb92:	798b      	ldrb	r3, [r1, #6]
    bb94:	888a      	ldrh	r2, [r1, #4]
    bb96:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bb9a:	f8d8 3010 	ldr.w	r3, [r8, #16]
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    bb9e:	f8ad 2004 	strh.w	r2, [sp, #4]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bba2:	b95b      	cbnz	r3, bbbc <cdcdf_acm_req+0x9c>
				usbd_cdc_line_coding = line_coding_tmp;
    bba4:	4b12      	ldr	r3, [pc, #72]	; (bbf0 <cdcdf_acm_req+0xd0>)
    bba6:	9800      	ldr	r0, [sp, #0]
    bba8:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    bbac:	f89d 2006 	ldrb.w	r2, [sp, #6]
    bbb0:	f8c8 0006 	str.w	r0, [r8, #6]
    bbb4:	8099      	strh	r1, [r3, #4]
    bbb6:	719a      	strb	r2, [r3, #6]
		return ERR_NONE;
    bbb8:	2000      	movs	r0, #0
    bbba:	e7d4      	b.n	bb66 <cdcdf_acm_req+0x46>
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bbbc:	4668      	mov	r0, sp
    bbbe:	4798      	blx	r3
    bbc0:	2800      	cmp	r0, #0
    bbc2:	d1ef      	bne.n	bba4 <cdcdf_acm_req+0x84>
    bbc4:	e7f8      	b.n	bbb8 <cdcdf_acm_req+0x98>
		usbdc_xfer(0, NULL, 0, 0);
    bbc6:	2300      	movs	r3, #0
    bbc8:	461a      	mov	r2, r3
    bbca:	4619      	mov	r1, r3
    bbcc:	4618      	mov	r0, r3
    bbce:	4d09      	ldr	r5, [pc, #36]	; (bbf4 <cdcdf_acm_req+0xd4>)
    bbd0:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    bbd2:	f8d8 3014 	ldr.w	r3, [r8, #20]
    bbd6:	2b00      	cmp	r3, #0
    bbd8:	d0ee      	beq.n	bbb8 <cdcdf_acm_req+0x98>
			cdcdf_acm_notify_state(req->wValue);
    bbda:	8860      	ldrh	r0, [r4, #2]
    bbdc:	4798      	blx	r3
    bbde:	e7eb      	b.n	bbb8 <cdcdf_acm_req+0x98>
		return ERR_NOT_FOUND;
    bbe0:	f06f 0009 	mvn.w	r0, #9
    bbe4:	e7bf      	b.n	bb66 <cdcdf_acm_req+0x46>
			return ERR_INVALID_DATA;
    bbe6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bbea:	e7bc      	b.n	bb66 <cdcdf_acm_req+0x46>
    bbec:	20008524 	.word	0x20008524
    bbf0:	2000852a 	.word	0x2000852a
    bbf4:	0001328d 	.word	0x0001328d
    bbf8:	000136b9 	.word	0x000136b9

0000bbfc <cdcdf_acm_ctrl>:
	switch (ctrl) {
    bbfc:	2901      	cmp	r1, #1
{
    bbfe:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bc02:	4615      	mov	r5, r2
	switch (ctrl) {
    bc04:	d04f      	beq.n	bca6 <cdcdf_acm_ctrl+0xaa>
    bc06:	2902      	cmp	r1, #2
    bc08:	d076      	beq.n	bcf8 <cdcdf_acm_ctrl+0xfc>
    bc0a:	2900      	cmp	r1, #0
    bc0c:	d177      	bne.n	bcfe <cdcdf_acm_ctrl+0x102>
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    bc0e:	6887      	ldr	r7, [r0, #8]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bc10:	f8df 8114 	ldr.w	r8, [pc, #276]	; bd28 <cdcdf_acm_ctrl+0x12c>
	ifc = desc->sod;
    bc14:	6810      	ldr	r0, [r2, #0]
	for (i = 0; i < 2; i++) {
    bc16:	1e7e      	subs	r6, r7, #1
		if (NULL == ifc) {
    bc18:	b928      	cbnz	r0, bc26 <cdcdf_acm_ctrl+0x2a>
			return ERR_NOT_FOUND;
    bc1a:	f06f 0009 	mvn.w	r0, #9
}
    bc1e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bc22:	464e      	mov	r6, r9
    bc24:	e7f8      	b.n	bc18 <cdcdf_acm_ctrl+0x1c>
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bc26:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    bc28:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bc2a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bc2e:	2b02      	cmp	r3, #2
    bc30:	d1f3      	bne.n	bc1a <cdcdf_acm_ctrl+0x1e>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    bc32:	7873      	ldrb	r3, [r6, #1]
    bc34:	429a      	cmp	r2, r3
    bc36:	d065      	beq.n	bd04 <cdcdf_acm_ctrl+0x108>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    bc38:	2bff      	cmp	r3, #255	; 0xff
    bc3a:	d166      	bne.n	bd0a <cdcdf_acm_ctrl+0x10e>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    bc3c:	7072      	strb	r2, [r6, #1]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bc3e:	6869      	ldr	r1, [r5, #4]
    bc40:	f8df a0e8 	ldr.w	sl, [pc, #232]	; bd2c <cdcdf_acm_ctrl+0x130>
    bc44:	2205      	movs	r2, #5
    bc46:	47c0      	blx	r8
    bc48:	f106 0901 	add.w	r9, r6, #1
    bc4c:	4604      	mov	r4, r0
		while (NULL != ep) {
    bc4e:	b964      	cbnz	r4, bc6a <cdcdf_acm_ctrl+0x6e>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    bc50:	682b      	ldr	r3, [r5, #0]
    bc52:	6869      	ldr	r1, [r5, #4]
    bc54:	7818      	ldrb	r0, [r3, #0]
    bc56:	2204      	movs	r2, #4
    bc58:	4418      	add	r0, r3
    bc5a:	47c0      	blx	r8
	for (i = 0; i < 2; i++) {
    bc5c:	42be      	cmp	r6, r7
    bc5e:	d1e0      	bne.n	bc22 <cdcdf_acm_ctrl+0x26>
	_cdcdf_acm_funcd.enabled = true;
    bc60:	4b2d      	ldr	r3, [pc, #180]	; (bd18 <cdcdf_acm_ctrl+0x11c>)
    bc62:	2201      	movs	r2, #1
    bc64:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    bc66:	4620      	mov	r0, r4
    bc68:	e7d9      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
	return (ptr[0] + (ptr[1] << 8));
    bc6a:	7961      	ldrb	r1, [r4, #5]
    bc6c:	7922      	ldrb	r2, [r4, #4]
			ep_desc.bEndpointAddress = ep[2];
    bc6e:	f894 b002 	ldrb.w	fp, [r4, #2]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    bc72:	4b2a      	ldr	r3, [pc, #168]	; (bd1c <cdcdf_acm_ctrl+0x120>)
    bc74:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    bc78:	b292      	uxth	r2, r2
    bc7a:	78e1      	ldrb	r1, [r4, #3]
    bc7c:	4658      	mov	r0, fp
    bc7e:	4798      	blx	r3
    bc80:	2800      	cmp	r0, #0
    bc82:	d145      	bne.n	bd10 <cdcdf_acm_ctrl+0x114>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    bc84:	f01b 0f80 	tst.w	fp, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    bc88:	bf14      	ite	ne
    bc8a:	f889 b002 	strbne.w	fp, [r9, #2]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    bc8e:	f887 b004 	strbeq.w	fp, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    bc92:	4658      	mov	r0, fp
    bc94:	47d0      	blx	sl
			desc->sod = ep;
    bc96:	602c      	str	r4, [r5, #0]
	return (desc + usb_desc_len(desc));
    bc98:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    bc9a:	6869      	ldr	r1, [r5, #4]
    bc9c:	4b20      	ldr	r3, [pc, #128]	; (bd20 <cdcdf_acm_ctrl+0x124>)
    bc9e:	4420      	add	r0, r4
    bca0:	4798      	blx	r3
    bca2:	4604      	mov	r4, r0
    bca4:	e7d3      	b.n	bc4e <cdcdf_acm_ctrl+0x52>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    bca6:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    bca8:	b12a      	cbz	r2, bcb6 <cdcdf_acm_ctrl+0xba>
		ifc_desc.bInterfaceClass = desc->sod[5];
    bcaa:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    bcac:	795b      	ldrb	r3, [r3, #5]
    bcae:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bcb2:	2b02      	cmp	r3, #2
    bcb4:	d1b1      	bne.n	bc1a <cdcdf_acm_ctrl+0x1e>
		if (func_data->func_iface[i] == 0xFF) {
    bcb6:	7823      	ldrb	r3, [r4, #0]
    bcb8:	2bff      	cmp	r3, #255	; 0xff
    bcba:	d007      	beq.n	bccc <cdcdf_acm_ctrl+0xd0>
			if (func_data->func_ep_in[i] != 0xFF) {
    bcbc:	78a0      	ldrb	r0, [r4, #2]
			func_data->func_iface[i] = 0xFF;
    bcbe:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    bcc0:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    bcc2:	7025      	strb	r5, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    bcc4:	d002      	beq.n	bccc <cdcdf_acm_ctrl+0xd0>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    bcc6:	4b17      	ldr	r3, [pc, #92]	; (bd24 <cdcdf_acm_ctrl+0x128>)
    bcc8:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    bcca:	70a5      	strb	r5, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    bccc:	7863      	ldrb	r3, [r4, #1]
    bcce:	2bff      	cmp	r3, #255	; 0xff
    bcd0:	d007      	beq.n	bce2 <cdcdf_acm_ctrl+0xe6>
			if (func_data->func_ep_in[i] != 0xFF) {
    bcd2:	78e0      	ldrb	r0, [r4, #3]
			func_data->func_iface[i] = 0xFF;
    bcd4:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    bcd6:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    bcd8:	7065      	strb	r5, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    bcda:	d002      	beq.n	bce2 <cdcdf_acm_ctrl+0xe6>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    bcdc:	4b11      	ldr	r3, [pc, #68]	; (bd24 <cdcdf_acm_ctrl+0x128>)
    bcde:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    bce0:	70e5      	strb	r5, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    bce2:	7920      	ldrb	r0, [r4, #4]
    bce4:	28ff      	cmp	r0, #255	; 0xff
    bce6:	d003      	beq.n	bcf0 <cdcdf_acm_ctrl+0xf4>
		usb_d_ep_deinit(func_data->func_ep_out);
    bce8:	4b0e      	ldr	r3, [pc, #56]	; (bd24 <cdcdf_acm_ctrl+0x128>)
    bcea:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    bcec:	23ff      	movs	r3, #255	; 0xff
    bcee:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    bcf0:	4b09      	ldr	r3, [pc, #36]	; (bd18 <cdcdf_acm_ctrl+0x11c>)
    bcf2:	2000      	movs	r0, #0
    bcf4:	7158      	strb	r0, [r3, #5]
	return ERR_NONE;
    bcf6:	e792      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
		return ERR_UNSUPPORTED_OP;
    bcf8:	f06f 001a 	mvn.w	r0, #26
    bcfc:	e78f      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
	switch (ctrl) {
    bcfe:	f06f 000c 	mvn.w	r0, #12
    bd02:	e78c      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
				return ERR_ALREADY_INITIALIZED;
    bd04:	f06f 0011 	mvn.w	r0, #17
    bd08:	e789      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
				return ERR_NO_RESOURCE;
    bd0a:	f06f 001b 	mvn.w	r0, #27
    bd0e:	e786      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
				return ERR_NOT_INITIALIZED;
    bd10:	f06f 0013 	mvn.w	r0, #19
    bd14:	e783      	b.n	bc1e <cdcdf_acm_ctrl+0x22>
    bd16:	bf00      	nop
    bd18:	20008524 	.word	0x20008524
    bd1c:	0000f571 	.word	0x0000f571
    bd20:	0000b857 	.word	0x0000b857
    bd24:	0000f5d5 	.word	0x0000f5d5
    bd28:	0000b83d 	.word	0x0000b83d
    bd2c:	0000f601 	.word	0x0000f601

0000bd30 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    bd30:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    bd32:	4b0a      	ldr	r3, [pc, #40]	; (bd5c <cdcdf_acm_init+0x2c>)
    bd34:	4798      	blx	r3
    bd36:	2801      	cmp	r0, #1
    bd38:	d80c      	bhi.n	bd54 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    bd3a:	4809      	ldr	r0, [pc, #36]	; (bd60 <cdcdf_acm_init+0x30>)
    bd3c:	4b09      	ldr	r3, [pc, #36]	; (bd64 <cdcdf_acm_init+0x34>)
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    bd3e:	e9c0 3007 	strd	r3, r0, [r0, #28]

	usbdc_register_function(&_cdcdf_acm);
    bd42:	4b09      	ldr	r3, [pc, #36]	; (bd68 <cdcdf_acm_init+0x38>)
    bd44:	3018      	adds	r0, #24
    bd46:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    bd48:	2001      	movs	r0, #1
    bd4a:	4908      	ldr	r1, [pc, #32]	; (bd6c <cdcdf_acm_init+0x3c>)
    bd4c:	4b08      	ldr	r3, [pc, #32]	; (bd70 <cdcdf_acm_init+0x40>)
    bd4e:	4798      	blx	r3
	return ERR_NONE;
    bd50:	2000      	movs	r0, #0
}
    bd52:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    bd54:	f06f 0010 	mvn.w	r0, #16
    bd58:	e7fb      	b.n	bd52 <cdcdf_acm_init+0x22>
    bd5a:	bf00      	nop
    bd5c:	000136c5 	.word	0x000136c5
    bd60:	20008524 	.word	0x20008524
    bd64:	0000bbfd 	.word	0x0000bbfd
    bd68:	0001366d 	.word	0x0001366d
    bd6c:	20000354 	.word	0x20000354
    bd70:	000135e5 	.word	0x000135e5

0000bd74 <cdcdf_acm_read>:

/**
 * \brief USB CDC ACM Function Read Data
 */
int32_t cdcdf_acm_read(uint8_t *buf, uint32_t size)
{
    bd74:	b410      	push	{r4}
/**
 * \brief Check whether CDC ACM Function is enabled
 */
bool cdcdf_acm_is_enabled(void)
{
	return _cdcdf_acm_funcd.enabled;
    bd76:	4c08      	ldr	r4, [pc, #32]	; (bd98 <cdcdf_acm_read+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    bd78:	7963      	ldrb	r3, [r4, #5]
{
    bd7a:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    bd7c:	b13b      	cbz	r3, bd8e <cdcdf_acm_read+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    bd7e:	4601      	mov	r1, r0
    bd80:	7920      	ldrb	r0, [r4, #4]
    bd82:	4c06      	ldr	r4, [pc, #24]	; (bd9c <cdcdf_acm_read+0x28>)
    bd84:	2300      	movs	r3, #0
    bd86:	46a4      	mov	ip, r4
}
    bd88:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    bd8c:	4760      	bx	ip
}
    bd8e:	f06f 0010 	mvn.w	r0, #16
    bd92:	f85d 4b04 	ldr.w	r4, [sp], #4
    bd96:	4770      	bx	lr
    bd98:	20008524 	.word	0x20008524
    bd9c:	0001328d 	.word	0x0001328d

0000bda0 <cdcdf_acm_write>:
{
    bda0:	b410      	push	{r4}
	return _cdcdf_acm_funcd.enabled;
    bda2:	4c08      	ldr	r4, [pc, #32]	; (bdc4 <cdcdf_acm_write+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    bda4:	7963      	ldrb	r3, [r4, #5]
{
    bda6:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    bda8:	b13b      	cbz	r3, bdba <cdcdf_acm_write+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    bdaa:	4601      	mov	r1, r0
    bdac:	78e0      	ldrb	r0, [r4, #3]
    bdae:	4c06      	ldr	r4, [pc, #24]	; (bdc8 <cdcdf_acm_write+0x28>)
    bdb0:	2301      	movs	r3, #1
    bdb2:	46a4      	mov	ip, r4
}
    bdb4:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    bdb8:	4760      	bx	ip
}
    bdba:	f06f 0010 	mvn.w	r0, #16
    bdbe:	f85d 4b04 	ldr.w	r4, [sp], #4
    bdc2:	4770      	bx	lr
    bdc4:	20008524 	.word	0x20008524
    bdc8:	0001328d 	.word	0x0001328d

0000bdcc <cdcdf_acm_register_callback>:
{
    bdcc:	b508      	push	{r3, lr}
    bdce:	460a      	mov	r2, r1
    bdd0:	2803      	cmp	r0, #3
    bdd2:	d814      	bhi.n	bdfe <cdcdf_acm_register_callback+0x32>
    bdd4:	e8df f000 	tbb	[pc, r0]
    bdd8:	100d0902 	.word	0x100d0902
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    bddc:	4b09      	ldr	r3, [pc, #36]	; (be04 <cdcdf_acm_register_callback+0x38>)
    bdde:	7918      	ldrb	r0, [r3, #4]
    bde0:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    bde2:	4b09      	ldr	r3, [pc, #36]	; (be08 <cdcdf_acm_register_callback+0x3c>)
    bde4:	4798      	blx	r3
	return ERR_NONE;
    bde6:	2000      	movs	r0, #0
}
    bde8:	bd08      	pop	{r3, pc}
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    bdea:	4b06      	ldr	r3, [pc, #24]	; (be04 <cdcdf_acm_register_callback+0x38>)
    bdec:	2102      	movs	r1, #2
    bdee:	78d8      	ldrb	r0, [r3, #3]
    bdf0:	e7f7      	b.n	bde2 <cdcdf_acm_register_callback+0x16>
		cdcdf_acm_set_line_coding = (cdcdf_acm_set_line_coding_t)func;
    bdf2:	4b04      	ldr	r3, [pc, #16]	; (be04 <cdcdf_acm_register_callback+0x38>)
    bdf4:	6119      	str	r1, [r3, #16]
		break;
    bdf6:	e7f6      	b.n	bde6 <cdcdf_acm_register_callback+0x1a>
		cdcdf_acm_notify_state = (cdcdf_acm_notify_state_t)func;
    bdf8:	4b02      	ldr	r3, [pc, #8]	; (be04 <cdcdf_acm_register_callback+0x38>)
    bdfa:	6159      	str	r1, [r3, #20]
    bdfc:	e7f3      	b.n	bde6 <cdcdf_acm_register_callback+0x1a>
	return ERR_NONE;
    bdfe:	f06f 000c 	mvn.w	r0, #12
    be02:	e7f1      	b.n	bde8 <cdcdf_acm_register_callback+0x1c>
    be04:	20008524 	.word	0x20008524
    be08:	0000f7e9 	.word	0x0000f7e9

0000be0c <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    be0c:	4b04      	ldr	r3, [pc, #16]	; (be20 <_sbrk+0x14>)
    be0e:	6819      	ldr	r1, [r3, #0]
{
    be10:	4602      	mov	r2, r0
	if (heap == NULL) {
    be12:	b909      	cbnz	r1, be18 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
    be14:	4903      	ldr	r1, [pc, #12]	; (be24 <_sbrk+0x18>)
    be16:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
    be18:	6818      	ldr	r0, [r3, #0]

	heap += incr;
    be1a:	4402      	add	r2, r0
    be1c:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
}
    be1e:	4770      	bx	lr
    be20:	20008548 	.word	0x20008548
    be24:	2002cfd8 	.word	0x2002cfd8

0000be28 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    be28:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    be2c:	4770      	bx	lr

0000be2e <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    be2e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    be32:	604b      	str	r3, [r1, #4]

	return 0;
}
    be34:	2000      	movs	r0, #0
    be36:	4770      	bx	lr

0000be38 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    be38:	2001      	movs	r0, #1
    be3a:	4770      	bx	lr

0000be3c <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    be3c:	2000      	movs	r0, #0
    be3e:	4770      	bx	lr

0000be40 <_qspi_dma_rx_complete>:
 *  \brief Callback for RX
 *  \param[in, out] dev Pointer to the DMA resource.
 */
static void _qspi_dma_rx_complete(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;
    be40:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_qspi_write_CTRLA_reg(const void *const hw, hri_qspi_ctrla_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLA.reg = data;
    be42:	4903      	ldr	r1, [pc, #12]	; (be50 <_qspi_dma_rx_complete+0x10>)

	_qspi_end_transfer(dev->prvt);
    be44:	681a      	ldr	r2, [r3, #0]

	if (dev->cb.xfer_done) {
    be46:	685b      	ldr	r3, [r3, #4]
    be48:	6011      	str	r1, [r2, #0]
    be4a:	b103      	cbz	r3, be4e <_qspi_dma_rx_complete+0xe>
		dev->cb.xfer_done(resource);
    be4c:	4718      	bx	r3
	}
}
    be4e:	4770      	bx	lr
    be50:	01000002 	.word	0x01000002

0000be54 <_qspi_dma_tx_complete>:
    be54:	4b00      	ldr	r3, [pc, #0]	; (be58 <_qspi_dma_tx_complete+0x4>)
    be56:	4718      	bx	r3
    be58:	0000be41 	.word	0x0000be41

0000be5c <_qspi_dma_error_occured>:
 */
static void _qspi_dma_error_occured(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;

	if (dev->cb.error) {
    be5c:	6883      	ldr	r3, [r0, #8]
    be5e:	689b      	ldr	r3, [r3, #8]
    be60:	b103      	cbz	r3, be64 <_qspi_dma_error_occured+0x8>
		dev->cb.error(resource);
    be62:	4718      	bx	r3
	}
}
    be64:	4770      	bx	lr
	...

0000be68 <_qspi_dma_init>:

int32_t _qspi_dma_init(struct _qspi_dma_dev *dev, void *const hw)
{
    be68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    be6a:	460d      	mov	r5, r1
	ASSERT(dev && hw);
    be6c:	4604      	mov	r4, r0
    be6e:	b110      	cbz	r0, be76 <_qspi_dma_init+0xe>
    be70:	1e08      	subs	r0, r1, #0
    be72:	bf18      	it	ne
    be74:	2001      	movne	r0, #1
	dev->prvt = hw;
    be76:	4626      	mov	r6, r4
	ASSERT(dev && hw);
    be78:	22cb      	movs	r2, #203	; 0xcb
    be7a:	490f      	ldr	r1, [pc, #60]	; (beb8 <_qspi_dma_init+0x50>)
    be7c:	4b0f      	ldr	r3, [pc, #60]	; (bebc <_qspi_dma_init+0x54>)
	hri_qspi_write_BAUD_reg(hw,
	                        CONF_QSPI_CPOL << QSPI_BAUD_CPOL_Pos | CONF_QSPI_CPHA << QSPI_BAUD_CPHA_Pos
	                            | QSPI_BAUD_BAUD(CONF_QSPI_BAUD_RATE) | QSPI_BAUD_DLYBS(CONF_QSPI_DLYBS));

	/* Initialize DMA rx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    be7e:	4f10      	ldr	r7, [pc, #64]	; (bec0 <_qspi_dma_init+0x58>)
	ASSERT(dev && hw);
    be80:	4798      	blx	r3
    be82:	2301      	movs	r3, #1
	dev->prvt = hw;
    be84:	f846 5b0c 	str.w	r5, [r6], #12
    be88:	602b      	str	r3, [r5, #0]
}

static inline void hri_qspi_write_CTRLB_reg(const void *const hw, hri_qspi_ctrlb_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLB.reg = data;
    be8a:	4b0e      	ldr	r3, [pc, #56]	; (bec4 <_qspi_dma_init+0x5c>)
    be8c:	606b      	str	r3, [r5, #4]
}

static inline void hri_qspi_write_BAUD_reg(const void *const hw, hri_qspi_baud_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->BAUD.reg = data;
    be8e:	4b0e      	ldr	r3, [pc, #56]	; (bec8 <_qspi_dma_init+0x60>)
    be90:	60ab      	str	r3, [r5, #8]
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    be92:	211f      	movs	r1, #31
    be94:	4630      	mov	r0, r6
    be96:	47b8      	blx	r7
	dev->resource->back                 = dev;
    be98:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    be9a:	4a0c      	ldr	r2, [pc, #48]	; (becc <_qspi_dma_init+0x64>)
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    be9c:	4d0c      	ldr	r5, [pc, #48]	; (bed0 <_qspi_dma_init+0x68>)
	dev->resource->back                 = dev;
    be9e:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    bea0:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    bea2:	605d      	str	r5, [r3, #4]
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_TX_CHANNEL);
    bea4:	211e      	movs	r1, #30
    bea6:	4630      	mov	r0, r6
    bea8:	47b8      	blx	r7
	dev->resource->back                 = dev;
    beaa:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_tx_complete;
    beac:	4a09      	ldr	r2, [pc, #36]	; (bed4 <_qspi_dma_init+0x6c>)
	dev->resource->back                 = dev;
    beae:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    beb0:	e9c3 2500 	strd	r2, r5, [r3]

	return ERR_NONE;
}
    beb4:	2000      	movs	r0, #0
    beb6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    beb8:	00017248 	.word	0x00017248
    bebc:	0000e08d 	.word	0x0000e08d
    bec0:	0000e2d1 	.word	0x0000e2d1
    bec4:	06000011 	.word	0x06000011
    bec8:	00243b00 	.word	0x00243b00
    becc:	0000be41 	.word	0x0000be41
    bed0:	0000be5d 	.word	0x0000be5d
    bed4:	0000be55 	.word	0x0000be55

0000bed8 <_flash_program>:
 * \param[in]  buffer        Pointer to buffer where the data to
 *                           write is stored
 * \param[in] size           The size of data to write to a page
 */
static void _flash_program(void *const hw, const uint32_t dst_addr, const uint8_t *buffer, const uint16_t size)
{
    bed8:	b570      	push	{r4, r5, r6, lr}
	uint32_t *ptr_read    = (uint32_t *)buffer;
	uint32_t  nvm_address = dst_addr / 4;
    beda:	088d      	lsrs	r5, r1, #2
	return ((Nvmctrl *)hw)->PARAM.reg;
}

static inline bool hri_nvmctrl_get_STATUS_READY_bit(const void *const hw)
{
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bedc:	8a44      	ldrh	r4, [r0, #18]
	uint16_t  i;

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bede:	07e6      	lsls	r6, r4, #31
    bee0:	d5fc      	bpl.n	bedc <_flash_program+0x4>
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bee2:	f24a 5415 	movw	r4, #42261	; 0xa515
    bee6:	8084      	strh	r4, [r0, #4]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bee8:	8a44      	ldrh	r4, [r0, #18]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_PBC | NVMCTRL_CTRLB_CMDEX_KEY);

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    beea:	07e4      	lsls	r4, r4, #31
    beec:	d5fc      	bpl.n	bee8 <_flash_program+0x10>
    beee:	00ad      	lsls	r5, r5, #2
    bef0:	2400      	movs	r4, #0
		/* Wait until this module isn't busy */
	}

	/* Writes to the page buffer must be 32 bits, perform manual copy
	 * to ensure alignment */
	for (i = 0; i < size; i += 4) {
    bef2:	b2a6      	uxth	r6, r4
    bef4:	429e      	cmp	r6, r3
    bef6:	d307      	bcc.n	bf08 <_flash_program+0x30>
    bef8:	8a43      	ldrh	r3, [r0, #18]
		NVM_MEMORY[nvm_address++] = *ptr_read;
		ptr_read++;
	}

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    befa:	07db      	lsls	r3, r3, #31
    befc:	d5fc      	bpl.n	bef8 <_flash_program+0x20>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    befe:	f24a 5303 	movw	r3, #42243	; 0xa503
	((Nvmctrl *)hw)->ADDR.reg = data;
    bf02:	6141      	str	r1, [r0, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bf04:	8083      	strh	r3, [r0, #4]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_ADDR_reg(hw, dst_addr);
	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_WP | NVMCTRL_CTRLB_CMDEX_KEY);
}
    bf06:	bd70      	pop	{r4, r5, r6, pc}
		NVM_MEMORY[nvm_address++] = *ptr_read;
    bf08:	5916      	ldr	r6, [r2, r4]
    bf0a:	5166      	str	r6, [r4, r5]
	for (i = 0; i < size; i += 4) {
    bf0c:	3404      	adds	r4, #4
    bf0e:	e7f0      	b.n	bef2 <_flash_program+0x1a>

0000bf10 <_flash_init>:
{
    bf10:	b538      	push	{r3, r4, r5, lr}
    bf12:	460d      	mov	r5, r1
	ASSERT(device && (hw == NVMCTRL));
    bf14:	4604      	mov	r4, r0
    bf16:	b118      	cbz	r0, bf20 <_flash_init+0x10>
    bf18:	4814      	ldr	r0, [pc, #80]	; (bf6c <_flash_init+0x5c>)
    bf1a:	1a0b      	subs	r3, r1, r0
    bf1c:	4258      	negs	r0, r3
    bf1e:	4158      	adcs	r0, r3
    bf20:	4913      	ldr	r1, [pc, #76]	; (bf70 <_flash_init+0x60>)
    bf22:	4b14      	ldr	r3, [pc, #80]	; (bf74 <_flash_init+0x64>)
    bf24:	224b      	movs	r2, #75	; 0x4b
    bf26:	4798      	blx	r3
	return ((Nvmctrl *)hw)->CTRLA.reg;
    bf28:	882b      	ldrh	r3, [r5, #0]
	device->hw = hw;
    bf2a:	6125      	str	r5, [r4, #16]
	hri_nvmctrl_write_CTRLA_reg(hw, ctrla);
    bf2c:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    bf30:	049b      	lsls	r3, r3, #18
    bf32:	0c9b      	lsrs	r3, r3, #18
	((Nvmctrl *)hw)->CTRLA.reg = data;
    bf34:	802b      	strh	r3, [r5, #0]
	_nvm_dev = device;
    bf36:	4b10      	ldr	r3, [pc, #64]	; (bf78 <_flash_init+0x68>)
    bf38:	601c      	str	r4, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bf3a:	4b10      	ldr	r3, [pc, #64]	; (bf7c <_flash_init+0x6c>)
    bf3c:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    bf40:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
    bf44:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    bf48:	f3bf 8f6f 	isb	sy
    bf4c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    bf50:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    bf54:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    bf58:	f3bf 8f6f 	isb	sy
}
    bf5c:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bf5e:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    bf62:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bf66:	6019      	str	r1, [r3, #0]
    bf68:	601a      	str	r2, [r3, #0]
    bf6a:	bd38      	pop	{r3, r4, r5, pc}
    bf6c:	41004000 	.word	0x41004000
    bf70:	0001725f 	.word	0x0001725f
    bf74:	0000e08d 	.word	0x0000e08d
    bf78:	2000854c 	.word	0x2000854c
    bf7c:	e000e100 	.word	0xe000e100

0000bf80 <_flash_get_page_size>:
}
    bf80:	f44f 7000 	mov.w	r0, #512	; 0x200
    bf84:	4770      	bx	lr

0000bf86 <_flash_get_total_pages>:
	return (uint32_t)hri_nvmctrl_read_PARAM_NVMP_bf(device->hw);
    bf86:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->PARAM.reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;
    bf88:	6898      	ldr	r0, [r3, #8]
}
    bf8a:	b280      	uxth	r0, r0
    bf8c:	4770      	bx	lr

0000bf8e <_flash_read>:
{
    bf8e:	b510      	push	{r4, lr}
	while (!hri_nvmctrl_get_STATUS_READY_bit(device->hw)) {
    bf90:	6904      	ldr	r4, [r0, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bf92:	8a60      	ldrh	r0, [r4, #18]
    bf94:	07c0      	lsls	r0, r0, #31
    bf96:	d5fc      	bpl.n	bf92 <_flash_read+0x4>
	for (i = 0; i < length; i++) {
    bf98:	2000      	movs	r0, #0
    bf9a:	e002      	b.n	bfa2 <_flash_read+0x14>
		buffer[i] = nvm_addr[src_addr + i];
    bf9c:	5c44      	ldrb	r4, [r0, r1]
    bf9e:	5414      	strb	r4, [r2, r0]
	for (i = 0; i < length; i++) {
    bfa0:	3001      	adds	r0, #1
    bfa2:	4298      	cmp	r0, r3
    bfa4:	d1fa      	bne.n	bf9c <_flash_read+0xe>
}
    bfa6:	bd10      	pop	{r4, pc}

0000bfa8 <_flash_write>:
{
    bfa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bfac:	f5ad 5d00 	sub.w	sp, sp, #8192	; 0x2000
    bfb0:	b083      	sub	sp, #12
    bfb2:	4606      	mov	r6, r0
    bfb4:	460c      	mov	r4, r1
    bfb6:	4617      	mov	r7, r2
    bfb8:	9301      	str	r3, [sp, #4]
		block_start_addr = wr_start_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    bfba:	f424 59ff 	bic.w	r9, r4, #8160	; 0x1fe0
    bfbe:	f029 091f 	bic.w	r9, r9, #31
		block_end_addr   = block_start_addr + NVMCTRL_BLOCK_SIZE - 1;
    bfc2:	f509 5aff 	add.w	sl, r9, #8160	; 0x1fe0
    bfc6:	f10a 0a1f 	add.w	sl, sl, #31
    bfca:	f04f 0800 	mov.w	r8, #0
			_flash_read(device, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    bfce:	aa02      	add	r2, sp, #8
    bfd0:	4442      	add	r2, r8
    bfd2:	eb09 0108 	add.w	r1, r9, r8
    bfd6:	4d24      	ldr	r5, [pc, #144]	; (c068 <_flash_write+0xc0>)
    bfd8:	f44f 7300 	mov.w	r3, #512	; 0x200
    bfdc:	4630      	mov	r0, r6
    bfde:	f508 7800 	add.w	r8, r8, #512	; 0x200
    bfe2:	47a8      	blx	r5
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    bfe4:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    bfe8:	d1f1      	bne.n	bfce <_flash_write+0x26>
		j = (wr_start_addr - block_start_addr) / NVMCTRL_PAGE_SIZE;
    bfea:	eba4 0309 	sub.w	r3, r4, r9
    bfee:	0a5a      	lsrs	r2, r3, #9
		k = wr_start_addr - block_start_addr - j * NVMCTRL_PAGE_SIZE;
    bff0:	4639      	mov	r1, r7
    bff2:	f3c3 0308 	ubfx	r3, r3, #0, #9
		while ((wr_start_addr <= block_end_addr) && (length > 0)) {
    bff6:	4554      	cmp	r4, sl
    bff8:	460f      	mov	r7, r1
    bffa:	d801      	bhi.n	c000 <_flash_write+0x58>
    bffc:	9801      	ldr	r0, [sp, #4]
    bffe:	bb18      	cbnz	r0, c048 <_flash_write+0xa0>
		_flash_erase_block(device->hw, block_start_addr);
    c000:	6933      	ldr	r3, [r6, #16]
    c002:	8a5a      	ldrh	r2, [r3, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c004:	07d2      	lsls	r2, r2, #31
    c006:	d5fc      	bpl.n	c002 <_flash_write+0x5a>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c008:	f24a 5201 	movw	r2, #42241	; 0xa501
			_flash_program(device->hw, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    c00c:	f8df b05c 	ldr.w	fp, [pc, #92]	; c06c <_flash_write+0xc4>
	((Nvmctrl *)hw)->ADDR.reg = data;
    c010:	f8c3 9014 	str.w	r9, [r3, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c014:	f04f 0800 	mov.w	r8, #0
    c018:	809a      	strh	r2, [r3, #4]
    c01a:	aa02      	add	r2, sp, #8
    c01c:	4442      	add	r2, r8
    c01e:	eb09 0108 	add.w	r1, r9, r8
    c022:	6930      	ldr	r0, [r6, #16]
    c024:	f44f 7300 	mov.w	r3, #512	; 0x200
    c028:	f508 7800 	add.w	r8, r8, #512	; 0x200
    c02c:	47d8      	blx	fp
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    c02e:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    c032:	d1f2      	bne.n	c01a <_flash_write+0x72>
	} while (block_end_addr < (wr_start_addr + length - 1));
    c034:	9b01      	ldr	r3, [sp, #4]
    c036:	4423      	add	r3, r4
    c038:	3b01      	subs	r3, #1
    c03a:	4553      	cmp	r3, sl
    c03c:	d8bd      	bhi.n	bfba <_flash_write+0x12>
}
    c03e:	f50d 5d00 	add.w	sp, sp, #8192	; 0x2000
    c042:	b003      	add	sp, #12
    c044:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tmp_buffer[j][k] = *buffer;
    c048:	a802      	add	r0, sp, #8
    c04a:	eb00 2042 	add.w	r0, r0, r2, lsl #9
    c04e:	783f      	ldrb	r7, [r7, #0]
    c050:	54c7      	strb	r7, [r0, r3]
			k                = (k + 1) % NVMCTRL_PAGE_SIZE;
    c052:	3301      	adds	r3, #1
    c054:	f3c3 0308 	ubfx	r3, r3, #0, #9
			if (0 == k) {
    c058:	3101      	adds	r1, #1
    c05a:	b903      	cbnz	r3, c05e <_flash_write+0xb6>
				j++;
    c05c:	3201      	adds	r2, #1
			length--;
    c05e:	9801      	ldr	r0, [sp, #4]
    c060:	3801      	subs	r0, #1
			wr_start_addr++;
    c062:	3401      	adds	r4, #1
			length--;
    c064:	9001      	str	r0, [sp, #4]
    c066:	e7c6      	b.n	bff6 <_flash_write+0x4e>
    c068:	0000bf8f 	.word	0x0000bf8f
    c06c:	0000bed9 	.word	0x0000bed9

0000c070 <_flash_erase>:
{
    c070:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c074:	f421 54ff 	bic.w	r4, r1, #8160	; 0x1fe0
{
    c078:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
    c07c:	460e      	mov	r6, r1
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c07e:	4b25      	ldr	r3, [pc, #148]	; (c114 <_flash_erase+0xa4>)
{
    c080:	4607      	mov	r7, r0
    c082:	4615      	mov	r5, r2
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c084:	f024 041f 	bic.w	r4, r4, #31
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c088:	f44f 7200 	mov.w	r2, #512	; 0x200
    c08c:	21ff      	movs	r1, #255	; 0xff
    c08e:	4668      	mov	r0, sp
    c090:	4798      	blx	r3
	if (dst_addr != block_start_addr) {
    c092:	42a6      	cmp	r6, r4
    c094:	d11e      	bne.n	c0d4 <_flash_erase+0x64>
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c096:	4622      	mov	r2, r4
    c098:	462b      	mov	r3, r5
    c09a:	f24a 5001 	movw	r0, #42241	; 0xa501
	while (page_nums >= NVMCTRL_BLOCK_PAGES) {
    c09e:	2b0f      	cmp	r3, #15
    c0a0:	d82e      	bhi.n	c100 <_flash_erase+0x90>
    c0a2:	0929      	lsrs	r1, r5, #4
    c0a4:	f06f 020f 	mvn.w	r2, #15
    c0a8:	fb02 5501 	mla	r5, r2, r1, r5
    c0ac:	eb04 3441 	add.w	r4, r4, r1, lsl #13
	if (page_nums != 0) {
    c0b0:	b165      	cbz	r5, c0cc <_flash_erase+0x5c>
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c0b2:	4e19      	ldr	r6, [pc, #100]	; (c118 <_flash_erase+0xa8>)
    c0b4:	eb04 2545 	add.w	r5, r4, r5, lsl #9
    c0b8:	4621      	mov	r1, r4
    c0ba:	f44f 7300 	mov.w	r3, #512	; 0x200
    c0be:	466a      	mov	r2, sp
    c0c0:	4638      	mov	r0, r7
			block_start_addr += NVMCTRL_PAGE_SIZE;
    c0c2:	f504 7400 	add.w	r4, r4, #512	; 0x200
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c0c6:	47b0      	blx	r6
		for (i = 0; i < page_nums; i++) {
    c0c8:	42a5      	cmp	r5, r4
    c0ca:	d1f5      	bne.n	c0b8 <_flash_erase+0x48>
}
    c0cc:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
    c0d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c0d4:	f504 5800 	add.w	r8, r4, #8192	; 0x2000
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    c0d8:	f506 59f0 	add.w	r9, r6, #7680	; 0x1e00
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c0dc:	4634      	mov	r4, r6
			_flash_write(device, dst_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c0de:	4e0e      	ldr	r6, [pc, #56]	; (c118 <_flash_erase+0xa8>)
    c0e0:	f44f 7300 	mov.w	r3, #512	; 0x200
    c0e4:	466a      	mov	r2, sp
    c0e6:	4621      	mov	r1, r4
    c0e8:	4638      	mov	r0, r7
    c0ea:	47b0      	blx	r6
			if (--page_nums == 0) {
    c0ec:	3d01      	subs	r5, #1
    c0ee:	d0ed      	beq.n	c0cc <_flash_erase+0x5c>
			dst_addr += NVMCTRL_PAGE_SIZE;
    c0f0:	f504 7400 	add.w	r4, r4, #512	; 0x200
			if (dst_addr == block_start_addr) {
    c0f4:	45a0      	cmp	r8, r4
    c0f6:	d0ce      	beq.n	c096 <_flash_erase+0x26>
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    c0f8:	45a1      	cmp	r9, r4
    c0fa:	d1f1      	bne.n	c0e0 <_flash_erase+0x70>
    c0fc:	4644      	mov	r4, r8
    c0fe:	e7ca      	b.n	c096 <_flash_erase+0x26>
		_flash_erase_block(device->hw, block_start_addr);
    c100:	6939      	ldr	r1, [r7, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c102:	8a4e      	ldrh	r6, [r1, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c104:	07f6      	lsls	r6, r6, #31
    c106:	d5fc      	bpl.n	c102 <_flash_erase+0x92>
	((Nvmctrl *)hw)->ADDR.reg = data;
    c108:	614a      	str	r2, [r1, #20]
		page_nums -= NVMCTRL_BLOCK_PAGES;
    c10a:	3b10      	subs	r3, #16
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c10c:	8088      	strh	r0, [r1, #4]
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c10e:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		page_nums -= NVMCTRL_BLOCK_PAGES;
    c112:	e7c4      	b.n	c09e <_flash_erase+0x2e>
    c114:	00014469 	.word	0x00014469
    c118:	0000bfa9 	.word	0x0000bfa9

0000c11c <_flash_is_locked>:
	return !(hri_nvmctrl_get_RUNLOCK_reg(device->hw, 1 << region_id));
    c11c:	6903      	ldr	r3, [r0, #16]
    c11e:	f3c1 31cf 	ubfx	r1, r1, #15, #16
	tmp = ((Nvmctrl *)hw)->RUNLOCK.reg;
    c122:	699a      	ldr	r2, [r3, #24]
    c124:	2301      	movs	r3, #1
    c126:	fa03 f101 	lsl.w	r1, r3, r1
    c12a:	4211      	tst	r1, r2
}
    c12c:	bf0c      	ite	eq
    c12e:	4618      	moveq	r0, r3
    c130:	2000      	movne	r0, #0
    c132:	4770      	bx	lr

0000c134 <NVMCTRL_0_Handler>:
/**
 * \internal NVM 0 interrupt handler
 */
void NVMCTRL_0_Handler(void)
{
	_nvm_interrupt_handler(_nvm_dev);
    c134:	4b09      	ldr	r3, [pc, #36]	; (c15c <NVMCTRL_0_Handler+0x28>)
    c136:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    c138:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_DONE) >> NVMCTRL_INTFLAG_DONE_Pos;
    c13a:	8a1a      	ldrh	r2, [r3, #16]
	if (hri_nvmctrl_get_INTFLAG_DONE_bit(hw)) {
    c13c:	07d2      	lsls	r2, r2, #31
    c13e:	d504      	bpl.n	c14a <NVMCTRL_0_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_DONE;
    c140:	2201      	movs	r2, #1
    c142:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.ready_cb) {
    c144:	6803      	ldr	r3, [r0, #0]
		if (NULL != device->flash_cb.error_cb) {
    c146:	b143      	cbz	r3, c15a <NVMCTRL_0_Handler+0x26>
			device->flash_cb.error_cb(device);
    c148:	4718      	bx	r3
	return ((Nvmctrl *)hw)->INTFLAG.reg;
    c14a:	8a1a      	ldrh	r2, [r3, #16]
    c14c:	b292      	uxth	r2, r2
	} else if (hri_nvmctrl_read_INTFLAG_reg(hw) && ~NVMCTRL_INTFLAG_ERR) {
    c14e:	b122      	cbz	r2, c15a <NVMCTRL_0_Handler+0x26>
	((Nvmctrl *)hw)->INTFLAG.reg = mask;
    c150:	f240 225e 	movw	r2, #606	; 0x25e
    c154:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.error_cb) {
    c156:	6843      	ldr	r3, [r0, #4]
    c158:	e7f5      	b.n	c146 <NVMCTRL_0_Handler+0x12>
}
    c15a:	4770      	bx	lr
    c15c:	2000854c 	.word	0x2000854c

0000c160 <NVMCTRL_1_Handler>:
    c160:	4b00      	ldr	r3, [pc, #0]	; (c164 <NVMCTRL_1_Handler+0x4>)
    c162:	4718      	bx	r3
    c164:	0000c135 	.word	0x0000c135

0000c168 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    c168:	b510      	push	{r4, lr}
    c16a:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    c16c:	4b04      	ldr	r3, [pc, #16]	; (c180 <prvIsQueueEmpty+0x18>)
    c16e:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    c170:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    c172:	4b04      	ldr	r3, [pc, #16]	; (c184 <prvIsQueueEmpty+0x1c>)
    c174:	4798      	blx	r3

	return xReturn;
}
    c176:	fab4 f084 	clz	r0, r4
    c17a:	0940      	lsrs	r0, r0, #5
    c17c:	bd10      	pop	{r4, pc}
    c17e:	bf00      	nop
    c180:	0000b2a5 	.word	0x0000b2a5
    c184:	0000b2e9 	.word	0x0000b2e9

0000c188 <prvCopyDataToQueue>:
{
    c188:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c18a:	4615      	mov	r5, r2
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c18c:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c18e:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
    c190:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c192:	b952      	cbnz	r2, c1aa <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    c194:	6807      	ldr	r7, [r0, #0]
    c196:	bb3f      	cbnz	r7, c1e8 <prvCopyDataToQueue+0x60>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c198:	6840      	ldr	r0, [r0, #4]
    c19a:	4b15      	ldr	r3, [pc, #84]	; (c1f0 <prvCopyDataToQueue+0x68>)
    c19c:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    c19e:	6067      	str	r7, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c1a0:	4605      	mov	r5, r0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    c1a2:	3601      	adds	r6, #1
    c1a4:	63a6      	str	r6, [r4, #56]	; 0x38
}
    c1a6:	4628      	mov	r0, r5
    c1a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    c1aa:	4b12      	ldr	r3, [pc, #72]	; (c1f4 <prvCopyDataToQueue+0x6c>)
    c1ac:	b95d      	cbnz	r5, c1c6 <prvCopyDataToQueue+0x3e>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    c1ae:	6880      	ldr	r0, [r0, #8]
    c1b0:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c1b2:	68a3      	ldr	r3, [r4, #8]
    c1b4:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c1b6:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c1b8:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c1ba:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c1bc:	4293      	cmp	r3, r2
    c1be:	d3f0      	bcc.n	c1a2 <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c1c0:	6823      	ldr	r3, [r4, #0]
    c1c2:	60a3      	str	r3, [r4, #8]
    c1c4:	e7ed      	b.n	c1a2 <prvCopyDataToQueue+0x1a>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    c1c6:	68c0      	ldr	r0, [r0, #12]
    c1c8:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c1ca:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c1cc:	68e3      	ldr	r3, [r4, #12]
    c1ce:	4251      	negs	r1, r2
    c1d0:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
    c1d2:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c1d4:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
    c1d6:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    c1d8:	bf3e      	ittt	cc
    c1da:	6863      	ldrcc	r3, [r4, #4]
    c1dc:	185b      	addcc	r3, r3, r1
    c1de:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    c1e0:	2d02      	cmp	r5, #2
    c1e2:	d101      	bne.n	c1e8 <prvCopyDataToQueue+0x60>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c1e4:	b116      	cbz	r6, c1ec <prvCopyDataToQueue+0x64>
				--uxMessagesWaiting;
    c1e6:	3e01      	subs	r6, #1
	BaseType_t  xReturn = pdFALSE;
    c1e8:	2500      	movs	r5, #0
    c1ea:	e7da      	b.n	c1a2 <prvCopyDataToQueue+0x1a>
    c1ec:	4635      	mov	r5, r6
    c1ee:	e7d8      	b.n	c1a2 <prvCopyDataToQueue+0x1a>
    c1f0:	00012c9d 	.word	0x00012c9d
    c1f4:	00014335 	.word	0x00014335

0000c1f8 <prvCopyDataFromQueue>:
{
    c1f8:	4603      	mov	r3, r0
    c1fa:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c1fc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    c1fe:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c200:	b16a      	cbz	r2, c21e <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c202:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c204:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c206:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c208:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c20a:	bf28      	it	cs
    c20c:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c20e:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c210:	bf28      	it	cs
    c212:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
    c214:	68d9      	ldr	r1, [r3, #12]
}
    c216:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
    c21a:	4b02      	ldr	r3, [pc, #8]	; (c224 <prvCopyDataFromQueue+0x2c>)
    c21c:	4718      	bx	r3
}
    c21e:	f85d 4b04 	ldr.w	r4, [sp], #4
    c222:	4770      	bx	lr
    c224:	00014335 	.word	0x00014335

0000c228 <prvNotifyQueueSetContainer.part.0>:
    c228:	f04f 0380 	mov.w	r3, #128	; 0x80
    c22c:	f383 8811 	msr	BASEPRI, r3
    c230:	f3bf 8f6f 	isb	sy
    c234:	f3bf 8f4f 	dsb	sy
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    c238:	e7fe      	b.n	c238 <prvNotifyQueueSetContainer.part.0+0x10>
	...

0000c23c <prvNotifyQueueSetContainer>:
{
    c23c:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    c23e:	6c84      	ldr	r4, [r0, #72]	; 0x48
{
    c240:	9001      	str	r0, [sp, #4]
    c242:	460a      	mov	r2, r1
	configASSERT(pxQueueSetContainer);
    c244:	b90c      	cbnz	r4, c24a <prvNotifyQueueSetContainer+0xe>
    c246:	4b17      	ldr	r3, [pc, #92]	; (c2a4 <prvNotifyQueueSetContainer+0x68>)
    c248:	4798      	blx	r3
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    c24a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c24c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c24e:	4299      	cmp	r1, r3
    c250:	d308      	bcc.n	c264 <prvNotifyQueueSetContainer+0x28>
    c252:	f04f 0380 	mov.w	r3, #128	; 0x80
    c256:	f383 8811 	msr	BASEPRI, r3
    c25a:	f3bf 8f6f 	isb	sy
    c25e:	f3bf 8f4f 	dsb	sy
    c262:	e7fe      	b.n	c262 <prvNotifyQueueSetContainer+0x26>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    c264:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c266:	428b      	cmp	r3, r1
    c268:	d91a      	bls.n	c2a0 <prvNotifyQueueSetContainer+0x64>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c26a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c26e:	4b0e      	ldr	r3, [pc, #56]	; (c2a8 <prvNotifyQueueSetContainer+0x6c>)
    c270:	a901      	add	r1, sp, #4
    c272:	4620      	mov	r0, r4
    c274:	4798      	blx	r3
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c276:	b26d      	sxtb	r5, r5

		if (cTxLock == queueUNLOCKED) {
    c278:	1c6b      	adds	r3, r5, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c27a:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
    c27c:	d10b      	bne.n	c296 <prvNotifyQueueSetContainer+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    c27e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c280:	b133      	cbz	r3, c290 <prvNotifyQueueSetContainer+0x54>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    c282:	4b0a      	ldr	r3, [pc, #40]	; (c2ac <prvNotifyQueueSetContainer+0x70>)
    c284:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c288:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
    c28a:	2800      	cmp	r0, #0
    c28c:	bf18      	it	ne
    c28e:	2601      	movne	r6, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    c290:	4630      	mov	r0, r6
    c292:	b002      	add	sp, #8
    c294:	bd70      	pop	{r4, r5, r6, pc}
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    c296:	3501      	adds	r5, #1
    c298:	b26d      	sxtb	r5, r5
    c29a:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c29e:	e7f7      	b.n	c290 <prvNotifyQueueSetContainer+0x54>
	BaseType_t xReturn             = pdFALSE;
    c2a0:	2600      	movs	r6, #0
	return xReturn;
    c2a2:	e7f5      	b.n	c290 <prvNotifyQueueSetContainer+0x54>
    c2a4:	0000c229 	.word	0x0000c229
    c2a8:	0000c189 	.word	0x0000c189
    c2ac:	00012b55 	.word	0x00012b55

0000c2b0 <prvUnlockQueue>:
{
    c2b0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c2b4:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    c2b6:	4f1f      	ldr	r7, [pc, #124]	; (c334 <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c2b8:	4e1f      	ldr	r6, [pc, #124]	; (c338 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
    c2ba:	f8df 8084 	ldr.w	r8, [pc, #132]	; c340 <prvUnlockQueue+0x90>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c2be:	f8df 9084 	ldr.w	r9, [pc, #132]	; c344 <prvUnlockQueue+0x94>
	taskENTER_CRITICAL();
    c2c2:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
    c2c4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c2c8:	b26d      	sxtb	r5, r5
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    c2ca:	2d00      	cmp	r5, #0
    c2cc:	dc17      	bgt.n	c2fe <prvUnlockQueue+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
    c2ce:	23ff      	movs	r3, #255	; 0xff
    c2d0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c2d4:	4e19      	ldr	r6, [pc, #100]	; (c33c <prvUnlockQueue+0x8c>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c2d6:	f8df 8060 	ldr.w	r8, [pc, #96]	; c338 <prvUnlockQueue+0x88>
					vTaskMissedYield();
    c2da:	f8df 9064 	ldr.w	r9, [pc, #100]	; c340 <prvUnlockQueue+0x90>
	taskEXIT_CRITICAL();
    c2de:	47b0      	blx	r6
	taskENTER_CRITICAL();
    c2e0:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
    c2e2:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c2e6:	f104 0710 	add.w	r7, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
    c2ea:	b26d      	sxtb	r5, r5
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    c2ec:	2d00      	cmp	r5, #0
    c2ee:	dc17      	bgt.n	c320 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
    c2f0:	23ff      	movs	r3, #255	; 0xff
    c2f2:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c2f6:	4633      	mov	r3, r6
}
    c2f8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	taskEXIT_CRITICAL();
    c2fc:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
    c2fe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c300:	b13b      	cbz	r3, c312 <prvUnlockQueue+0x62>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c302:	2100      	movs	r1, #0
    c304:	4620      	mov	r0, r4
    c306:	47c8      	blx	r9
    c308:	b100      	cbz	r0, c30c <prvUnlockQueue+0x5c>
						vTaskMissedYield();
    c30a:	47c0      	blx	r8
			--cTxLock;
    c30c:	3d01      	subs	r5, #1
    c30e:	b26d      	sxtb	r5, r5
    c310:	e7db      	b.n	c2ca <prvUnlockQueue+0x1a>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c312:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c314:	2b00      	cmp	r3, #0
    c316:	d0da      	beq.n	c2ce <prvUnlockQueue+0x1e>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c318:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c31c:	47b0      	blx	r6
    c31e:	e7f3      	b.n	c308 <prvUnlockQueue+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c320:	6923      	ldr	r3, [r4, #16]
    c322:	2b00      	cmp	r3, #0
    c324:	d0e4      	beq.n	c2f0 <prvUnlockQueue+0x40>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c326:	4638      	mov	r0, r7
    c328:	47c0      	blx	r8
    c32a:	b100      	cbz	r0, c32e <prvUnlockQueue+0x7e>
					vTaskMissedYield();
    c32c:	47c8      	blx	r9
				--cRxLock;
    c32e:	3d01      	subs	r5, #1
    c330:	b26d      	sxtb	r5, r5
    c332:	e7db      	b.n	c2ec <prvUnlockQueue+0x3c>
    c334:	0000b2a5 	.word	0x0000b2a5
    c338:	00012b55 	.word	0x00012b55
    c33c:	0000b2e9 	.word	0x0000b2e9
    c340:	00012c6d 	.word	0x00012c6d
    c344:	0000c23d 	.word	0x0000c23d

0000c348 <xQueueGenericReset>:
{
    c348:	b538      	push	{r3, r4, r5, lr}
    c34a:	460d      	mov	r5, r1
	configASSERT(pxQueue);
    c34c:	4604      	mov	r4, r0
    c34e:	b908      	cbnz	r0, c354 <xQueueGenericReset+0xc>
    c350:	4b18      	ldr	r3, [pc, #96]	; (c3b4 <xQueueGenericReset+0x6c>)
    c352:	4798      	blx	r3
	taskENTER_CRITICAL();
    c354:	4b18      	ldr	r3, [pc, #96]	; (c3b8 <xQueueGenericReset+0x70>)
    c356:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c358:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    c35c:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    c35e:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c360:	434b      	muls	r3, r1
    c362:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c364:	1a5b      	subs	r3, r3, r1
    c366:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c368:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c36a:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c36c:	2000      	movs	r0, #0
		pxQueue->cRxLock           = queueUNLOCKED;
    c36e:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c370:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock           = queueUNLOCKED;
    c372:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
    c376:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
    c37a:	b995      	cbnz	r5, c3a2 <xQueueGenericReset+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c37c:	6923      	ldr	r3, [r4, #16]
    c37e:	b163      	cbz	r3, c39a <xQueueGenericReset+0x52>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c380:	4b0e      	ldr	r3, [pc, #56]	; (c3bc <xQueueGenericReset+0x74>)
    c382:	f104 0010 	add.w	r0, r4, #16
    c386:	4798      	blx	r3
    c388:	b138      	cbz	r0, c39a <xQueueGenericReset+0x52>
					queueYIELD_IF_USING_PREEMPTION();
    c38a:	4b0d      	ldr	r3, [pc, #52]	; (c3c0 <xQueueGenericReset+0x78>)
    c38c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c390:	601a      	str	r2, [r3, #0]
    c392:	f3bf 8f4f 	dsb	sy
    c396:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
    c39a:	4b0a      	ldr	r3, [pc, #40]	; (c3c4 <xQueueGenericReset+0x7c>)
    c39c:	4798      	blx	r3
}
    c39e:	2001      	movs	r0, #1
    c3a0:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    c3a2:	f104 0010 	add.w	r0, r4, #16
    c3a6:	4d08      	ldr	r5, [pc, #32]	; (c3c8 <xQueueGenericReset+0x80>)
    c3a8:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    c3aa:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c3ae:	47a8      	blx	r5
    c3b0:	e7f3      	b.n	c39a <xQueueGenericReset+0x52>
    c3b2:	bf00      	nop
    c3b4:	0000c229 	.word	0x0000c229
    c3b8:	0000b2a5 	.word	0x0000b2a5
    c3bc:	00012b55 	.word	0x00012b55
    c3c0:	e000ed04 	.word	0xe000ed04
    c3c4:	0000b2e9 	.word	0x0000b2e9
    c3c8:	0000b14d 	.word	0x0000b14d

0000c3cc <xQueueGenericCreate>:
{
    c3cc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c3ce:	460d      	mov	r5, r1
    c3d0:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    c3d2:	4606      	mov	r6, r0
    c3d4:	b940      	cbnz	r0, c3e8 <xQueueGenericCreate+0x1c>
    c3d6:	f04f 0380 	mov.w	r3, #128	; 0x80
    c3da:	f383 8811 	msr	BASEPRI, r3
    c3de:	f3bf 8f6f 	isb	sy
    c3e2:	f3bf 8f4f 	dsb	sy
    c3e6:	e7fe      	b.n	c3e6 <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = (size_t)(
    c3e8:	4348      	muls	r0, r1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    c3ea:	4b0b      	ldr	r3, [pc, #44]	; (c418 <xQueueGenericCreate+0x4c>)
    c3ec:	3054      	adds	r0, #84	; 0x54
    c3ee:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    c3f0:	4604      	mov	r4, r0
    c3f2:	b168      	cbz	r0, c410 <xQueueGenericCreate+0x44>
	if (uxItemSize == (UBaseType_t)0) {
    c3f4:	b175      	cbz	r5, c414 <xQueueGenericCreate+0x48>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    c3f6:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    c3fa:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
    c3fc:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    c400:	4b06      	ldr	r3, [pc, #24]	; (c41c <xQueueGenericCreate+0x50>)
    c402:	2101      	movs	r1, #1
    c404:	4620      	mov	r0, r4
    c406:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
    c408:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
    c40a:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    c40e:	64a3      	str	r3, [r4, #72]	; 0x48
}
    c410:	4620      	mov	r0, r4
    c412:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c414:	4603      	mov	r3, r0
    c416:	e7f0      	b.n	c3fa <xQueueGenericCreate+0x2e>
    c418:	0000b665 	.word	0x0000b665
    c41c:	0000c349 	.word	0x0000c349

0000c420 <xQueueGenericSend>:
{
    c420:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c424:	b085      	sub	sp, #20
    c426:	460e      	mov	r6, r1
    c428:	9201      	str	r2, [sp, #4]
    c42a:	461c      	mov	r4, r3
	configASSERT(pxQueue);
    c42c:	4683      	mov	fp, r0
    c42e:	b940      	cbnz	r0, c442 <xQueueGenericSend+0x22>
    c430:	f04f 0380 	mov.w	r3, #128	; 0x80
    c434:	f383 8811 	msr	BASEPRI, r3
    c438:	f3bf 8f6f 	isb	sy
    c43c:	f3bf 8f4f 	dsb	sy
    c440:	e7fe      	b.n	c440 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c442:	b951      	cbnz	r1, c45a <xQueueGenericSend+0x3a>
    c444:	6c02      	ldr	r2, [r0, #64]	; 0x40
    c446:	b142      	cbz	r2, c45a <xQueueGenericSend+0x3a>
    c448:	f04f 0380 	mov.w	r3, #128	; 0x80
    c44c:	f383 8811 	msr	BASEPRI, r3
    c450:	f3bf 8f6f 	isb	sy
    c454:	f3bf 8f4f 	dsb	sy
    c458:	e7fe      	b.n	c458 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c45a:	2c02      	cmp	r4, #2
    c45c:	d10c      	bne.n	c478 <xQueueGenericSend+0x58>
    c45e:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c462:	2a01      	cmp	r2, #1
    c464:	d008      	beq.n	c478 <xQueueGenericSend+0x58>
    c466:	f04f 0380 	mov.w	r3, #128	; 0x80
    c46a:	f383 8811 	msr	BASEPRI, r3
    c46e:	f3bf 8f6f 	isb	sy
    c472:	f3bf 8f4f 	dsb	sy
    c476:	e7fe      	b.n	c476 <xQueueGenericSend+0x56>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c478:	4a47      	ldr	r2, [pc, #284]	; (c598 <xQueueGenericSend+0x178>)
    c47a:	4790      	blx	r2
    c47c:	4680      	mov	r8, r0
    c47e:	b950      	cbnz	r0, c496 <xQueueGenericSend+0x76>
    c480:	9a01      	ldr	r2, [sp, #4]
    c482:	b152      	cbz	r2, c49a <xQueueGenericSend+0x7a>
    c484:	f04f 0380 	mov.w	r3, #128	; 0x80
    c488:	f383 8811 	msr	BASEPRI, r3
    c48c:	f3bf 8f6f 	isb	sy
    c490:	f3bf 8f4f 	dsb	sy
    c494:	e7fe      	b.n	c494 <xQueueGenericSend+0x74>
    c496:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
    c49a:	f8df 9128 	ldr.w	r9, [pc, #296]	; c5c4 <xQueueGenericSend+0x1a4>
    c49e:	46ca      	mov	sl, r9
    c4a0:	e042      	b.n	c528 <xQueueGenericSend+0x108>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c4a2:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    c4a6:	2a00      	cmp	r2, #0
    c4a8:	d055      	beq.n	c556 <xQueueGenericSend+0x136>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c4aa:	4b3c      	ldr	r3, [pc, #240]	; (c59c <xQueueGenericSend+0x17c>)
    c4ac:	f10b 0024 	add.w	r0, fp, #36	; 0x24
    c4b0:	4798      	blx	r3
    c4b2:	e050      	b.n	c556 <xQueueGenericSend+0x136>
				if (xTicksToWait == (TickType_t)0) {
    c4b4:	9f01      	ldr	r7, [sp, #4]
    c4b6:	b917      	cbnz	r7, c4be <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
    c4b8:	47a8      	blx	r5
			return errQUEUE_FULL;
    c4ba:	2000      	movs	r0, #0
    c4bc:	e056      	b.n	c56c <xQueueGenericSend+0x14c>
				} else if (xEntryTimeSet == pdFALSE) {
    c4be:	f1b8 0f00 	cmp.w	r8, #0
    c4c2:	d102      	bne.n	c4ca <xQueueGenericSend+0xaa>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c4c4:	4a36      	ldr	r2, [pc, #216]	; (c5a0 <xQueueGenericSend+0x180>)
    c4c6:	a802      	add	r0, sp, #8
    c4c8:	4790      	blx	r2
		taskEXIT_CRITICAL();
    c4ca:	47a8      	blx	r5
		vTaskSuspendAll();
    c4cc:	4a35      	ldr	r2, [pc, #212]	; (c5a4 <xQueueGenericSend+0x184>)
    c4ce:	f8df 80f8 	ldr.w	r8, [pc, #248]	; c5c8 <xQueueGenericSend+0x1a8>
    c4d2:	4f35      	ldr	r7, [pc, #212]	; (c5a8 <xQueueGenericSend+0x188>)
    c4d4:	4790      	blx	r2
		prvLockQueue(pxQueue);
    c4d6:	47d0      	blx	sl
    c4d8:	f89b 2044 	ldrb.w	r2, [fp, #68]	; 0x44
    c4dc:	2aff      	cmp	r2, #255	; 0xff
    c4de:	bf04      	itt	eq
    c4e0:	2200      	moveq	r2, #0
    c4e2:	f88b 2044 	strbeq.w	r2, [fp, #68]	; 0x44
    c4e6:	f89b 2045 	ldrb.w	r2, [fp, #69]	; 0x45
    c4ea:	2aff      	cmp	r2, #255	; 0xff
    c4ec:	bf04      	itt	eq
    c4ee:	2200      	moveq	r2, #0
    c4f0:	f88b 2045 	strbeq.w	r2, [fp, #69]	; 0x45
    c4f4:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c4f6:	4a2d      	ldr	r2, [pc, #180]	; (c5ac <xQueueGenericSend+0x18c>)
    c4f8:	a901      	add	r1, sp, #4
    c4fa:	a802      	add	r0, sp, #8
    c4fc:	4790      	blx	r2
    c4fe:	2800      	cmp	r0, #0
    c500:	d145      	bne.n	c58e <xQueueGenericSend+0x16e>
	taskENTER_CRITICAL();
    c502:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    c504:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c508:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c50c:	4291      	cmp	r1, r2
    c50e:	d130      	bne.n	c572 <xQueueGenericSend+0x152>
	taskEXIT_CRITICAL();
    c510:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    c512:	9901      	ldr	r1, [sp, #4]
    c514:	4a26      	ldr	r2, [pc, #152]	; (c5b0 <xQueueGenericSend+0x190>)
    c516:	f10b 0010 	add.w	r0, fp, #16
    c51a:	4790      	blx	r2
				prvUnlockQueue(pxQueue);
    c51c:	4658      	mov	r0, fp
    c51e:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
    c520:	47b8      	blx	r7
    c522:	b358      	cbz	r0, c57c <xQueueGenericSend+0x15c>
    c524:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
    c528:	47c8      	blx	r9
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c52a:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c52e:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c532:	4d20      	ldr	r5, [pc, #128]	; (c5b4 <xQueueGenericSend+0x194>)
    c534:	4291      	cmp	r1, r2
    c536:	d301      	bcc.n	c53c <xQueueGenericSend+0x11c>
    c538:	2c02      	cmp	r4, #2
    c53a:	d1bb      	bne.n	c4b4 <xQueueGenericSend+0x94>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c53c:	4622      	mov	r2, r4
    c53e:	4631      	mov	r1, r6
    c540:	4658      	mov	r0, fp
    c542:	4e1d      	ldr	r6, [pc, #116]	; (c5b8 <xQueueGenericSend+0x198>)
    c544:	47b0      	blx	r6
					if (pxQueue->pxQueueSetContainer != NULL) {
    c546:	f8db 2048 	ldr.w	r2, [fp, #72]	; 0x48
    c54a:	2a00      	cmp	r2, #0
    c54c:	d0a9      	beq.n	c4a2 <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c54e:	4b1b      	ldr	r3, [pc, #108]	; (c5bc <xQueueGenericSend+0x19c>)
    c550:	4621      	mov	r1, r4
    c552:	4658      	mov	r0, fp
    c554:	4798      	blx	r3
						} else if (xYieldRequired != pdFALSE) {
    c556:	b138      	cbz	r0, c568 <xQueueGenericSend+0x148>
							queueYIELD_IF_USING_PREEMPTION();
    c558:	4b19      	ldr	r3, [pc, #100]	; (c5c0 <xQueueGenericSend+0x1a0>)
    c55a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c55e:	601a      	str	r2, [r3, #0]
    c560:	f3bf 8f4f 	dsb	sy
    c564:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c568:	47a8      	blx	r5
				return pdPASS;
    c56a:	2001      	movs	r0, #1
}
    c56c:	b005      	add	sp, #20
    c56e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    c572:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
    c574:	4658      	mov	r0, fp
    c576:	47c0      	blx	r8
				(void)xTaskResumeAll();
    c578:	47b8      	blx	r7
    c57a:	e7d3      	b.n	c524 <xQueueGenericSend+0x104>
					portYIELD_WITHIN_API();
    c57c:	4b10      	ldr	r3, [pc, #64]	; (c5c0 <xQueueGenericSend+0x1a0>)
    c57e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c582:	601a      	str	r2, [r3, #0]
    c584:	f3bf 8f4f 	dsb	sy
    c588:	f3bf 8f6f 	isb	sy
    c58c:	e7ca      	b.n	c524 <xQueueGenericSend+0x104>
			prvUnlockQueue(pxQueue);
    c58e:	4658      	mov	r0, fp
    c590:	47c0      	blx	r8
			(void)xTaskResumeAll();
    c592:	47b8      	blx	r7
    c594:	e791      	b.n	c4ba <xQueueGenericSend+0x9a>
    c596:	bf00      	nop
    c598:	00012c7d 	.word	0x00012c7d
    c59c:	00012b55 	.word	0x00012b55
    c5a0:	00012bd5 	.word	0x00012bd5
    c5a4:	000127b1 	.word	0x000127b1
    c5a8:	000128f9 	.word	0x000128f9
    c5ac:	00012be9 	.word	0x00012be9
    c5b0:	00012ad1 	.word	0x00012ad1
    c5b4:	0000b2e9 	.word	0x0000b2e9
    c5b8:	0000c189 	.word	0x0000c189
    c5bc:	0000c23d 	.word	0x0000c23d
    c5c0:	e000ed04 	.word	0xe000ed04
    c5c4:	0000b2a5 	.word	0x0000b2a5
    c5c8:	0000c2b1 	.word	0x0000c2b1

0000c5cc <xQueueGenericSendFromISR>:
{
    c5cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c5d0:	4689      	mov	r9, r1
    c5d2:	4690      	mov	r8, r2
    c5d4:	461f      	mov	r7, r3
	configASSERT(pxQueue);
    c5d6:	4604      	mov	r4, r0
    c5d8:	b940      	cbnz	r0, c5ec <xQueueGenericSendFromISR+0x20>
    c5da:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5de:	f383 8811 	msr	BASEPRI, r3
    c5e2:	f3bf 8f6f 	isb	sy
    c5e6:	f3bf 8f4f 	dsb	sy
    c5ea:	e7fe      	b.n	c5ea <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c5ec:	b951      	cbnz	r1, c604 <xQueueGenericSendFromISR+0x38>
    c5ee:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c5f0:	b143      	cbz	r3, c604 <xQueueGenericSendFromISR+0x38>
    c5f2:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5f6:	f383 8811 	msr	BASEPRI, r3
    c5fa:	f3bf 8f6f 	isb	sy
    c5fe:	f3bf 8f4f 	dsb	sy
    c602:	e7fe      	b.n	c602 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c604:	2f02      	cmp	r7, #2
    c606:	d10b      	bne.n	c620 <xQueueGenericSendFromISR+0x54>
    c608:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c60a:	2b01      	cmp	r3, #1
    c60c:	d008      	beq.n	c620 <xQueueGenericSendFromISR+0x54>
    c60e:	f04f 0380 	mov.w	r3, #128	; 0x80
    c612:	f383 8811 	msr	BASEPRI, r3
    c616:	f3bf 8f6f 	isb	sy
    c61a:	f3bf 8f4f 	dsb	sy
    c61e:	e7fe      	b.n	c61e <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    c620:	4b1e      	ldr	r3, [pc, #120]	; (c69c <xQueueGenericSendFromISR+0xd0>)
    c622:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    c624:	f3ef 8611 	mrs	r6, BASEPRI
    c628:	f04f 0380 	mov.w	r3, #128	; 0x80
    c62c:	f383 8811 	msr	BASEPRI, r3
    c630:	f3bf 8f6f 	isb	sy
    c634:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c638:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c63a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c63c:	429a      	cmp	r2, r3
    c63e:	d301      	bcc.n	c644 <xQueueGenericSendFromISR+0x78>
    c640:	2f02      	cmp	r7, #2
    c642:	d129      	bne.n	c698 <xQueueGenericSendFromISR+0xcc>
			const int8_t cTxLock = pxQueue->cTxLock;
    c644:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c648:	4b15      	ldr	r3, [pc, #84]	; (c6a0 <xQueueGenericSendFromISR+0xd4>)
			const int8_t cTxLock = pxQueue->cTxLock;
    c64a:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c64c:	463a      	mov	r2, r7
    c64e:	4649      	mov	r1, r9
    c650:	4620      	mov	r0, r4
    c652:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    c654:	1c6b      	adds	r3, r5, #1
    c656:	d11a      	bne.n	c68e <xQueueGenericSendFromISR+0xc2>
					if (pxQueue->pxQueueSetContainer != NULL) {
    c658:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c65a:	b183      	cbz	r3, c67e <xQueueGenericSendFromISR+0xb2>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c65c:	4b11      	ldr	r3, [pc, #68]	; (c6a4 <xQueueGenericSendFromISR+0xd8>)
    c65e:	4639      	mov	r1, r7
    c660:	4620      	mov	r0, r4
    c662:	4798      	blx	r3
    c664:	b908      	cbnz	r0, c66a <xQueueGenericSendFromISR+0x9e>
			xReturn = pdPASS;
    c666:	2001      	movs	r0, #1
    c668:	e005      	b.n	c676 <xQueueGenericSendFromISR+0xaa>
							if (pxHigherPriorityTaskWoken != NULL) {
    c66a:	f1b8 0f00 	cmp.w	r8, #0
    c66e:	d0fa      	beq.n	c666 <xQueueGenericSendFromISR+0x9a>
								*pxHigherPriorityTaskWoken = pdTRUE;
    c670:	2001      	movs	r0, #1
    c672:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    c676:	f386 8811 	msr	BASEPRI, r6
}
    c67a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c67e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c680:	2b00      	cmp	r3, #0
    c682:	d0f0      	beq.n	c666 <xQueueGenericSendFromISR+0x9a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c684:	4b08      	ldr	r3, [pc, #32]	; (c6a8 <xQueueGenericSendFromISR+0xdc>)
    c686:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c68a:	4798      	blx	r3
    c68c:	e7ea      	b.n	c664 <xQueueGenericSendFromISR+0x98>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    c68e:	3501      	adds	r5, #1
    c690:	b26d      	sxtb	r5, r5
    c692:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c696:	e7e6      	b.n	c666 <xQueueGenericSendFromISR+0x9a>
			xReturn = errQUEUE_FULL;
    c698:	2000      	movs	r0, #0
    c69a:	e7ec      	b.n	c676 <xQueueGenericSendFromISR+0xaa>
    c69c:	0000b4dd 	.word	0x0000b4dd
    c6a0:	0000c189 	.word	0x0000c189
    c6a4:	0000c23d 	.word	0x0000c23d
    c6a8:	00012b55 	.word	0x00012b55

0000c6ac <xQueueReceive>:
{
    c6ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c6b0:	b085      	sub	sp, #20
    c6b2:	460f      	mov	r7, r1
    c6b4:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    c6b6:	4604      	mov	r4, r0
    c6b8:	b940      	cbnz	r0, c6cc <xQueueReceive+0x20>
	__asm volatile("	mov %0, %1												\n"
    c6ba:	f04f 0380 	mov.w	r3, #128	; 0x80
    c6be:	f383 8811 	msr	BASEPRI, r3
    c6c2:	f3bf 8f6f 	isb	sy
    c6c6:	f3bf 8f4f 	dsb	sy
    c6ca:	e7fe      	b.n	c6ca <xQueueReceive+0x1e>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    c6cc:	b951      	cbnz	r1, c6e4 <xQueueReceive+0x38>
    c6ce:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c6d0:	b143      	cbz	r3, c6e4 <xQueueReceive+0x38>
    c6d2:	f04f 0380 	mov.w	r3, #128	; 0x80
    c6d6:	f383 8811 	msr	BASEPRI, r3
    c6da:	f3bf 8f6f 	isb	sy
    c6de:	f3bf 8f4f 	dsb	sy
    c6e2:	e7fe      	b.n	c6e2 <xQueueReceive+0x36>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c6e4:	4b3e      	ldr	r3, [pc, #248]	; (c7e0 <xQueueReceive+0x134>)
    c6e6:	4798      	blx	r3
    c6e8:	4606      	mov	r6, r0
    c6ea:	b950      	cbnz	r0, c702 <xQueueReceive+0x56>
    c6ec:	9b01      	ldr	r3, [sp, #4]
    c6ee:	b14b      	cbz	r3, c704 <xQueueReceive+0x58>
    c6f0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c6f4:	f383 8811 	msr	BASEPRI, r3
    c6f8:	f3bf 8f6f 	isb	sy
    c6fc:	f3bf 8f4f 	dsb	sy
    c700:	e7fe      	b.n	c700 <xQueueReceive+0x54>
    c702:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    c704:	f8df 9100 	ldr.w	r9, [pc, #256]	; c808 <xQueueReceive+0x15c>
					portYIELD_WITHIN_API();
    c708:	f8df b0f8 	ldr.w	fp, [pc, #248]	; c804 <xQueueReceive+0x158>
    c70c:	46ca      	mov	sl, r9
    c70e:	e03b      	b.n	c788 <xQueueReceive+0xdc>
				if (xTicksToWait == (TickType_t)0) {
    c710:	9d01      	ldr	r5, [sp, #4]
    c712:	b915      	cbnz	r5, c71a <xQueueReceive+0x6e>
					taskEXIT_CRITICAL();
    c714:	47c0      	blx	r8
				return errQUEUE_EMPTY;
    c716:	2000      	movs	r0, #0
    c718:	e053      	b.n	c7c2 <xQueueReceive+0x116>
				} else if (xEntryTimeSet == pdFALSE) {
    c71a:	b916      	cbnz	r6, c722 <xQueueReceive+0x76>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c71c:	4b31      	ldr	r3, [pc, #196]	; (c7e4 <xQueueReceive+0x138>)
    c71e:	a802      	add	r0, sp, #8
    c720:	4798      	blx	r3
		taskEXIT_CRITICAL();
    c722:	47c0      	blx	r8
		vTaskSuspendAll();
    c724:	4b30      	ldr	r3, [pc, #192]	; (c7e8 <xQueueReceive+0x13c>)
    c726:	4e31      	ldr	r6, [pc, #196]	; (c7ec <xQueueReceive+0x140>)
    c728:	4d31      	ldr	r5, [pc, #196]	; (c7f0 <xQueueReceive+0x144>)
    c72a:	4798      	blx	r3
		prvLockQueue(pxQueue);
    c72c:	47d0      	blx	sl
    c72e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c732:	2bff      	cmp	r3, #255	; 0xff
    c734:	bf04      	itt	eq
    c736:	2300      	moveq	r3, #0
    c738:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    c73c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c740:	2bff      	cmp	r3, #255	; 0xff
    c742:	bf04      	itt	eq
    c744:	2300      	moveq	r3, #0
    c746:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    c74a:	47c0      	blx	r8
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c74c:	4b29      	ldr	r3, [pc, #164]	; (c7f4 <xQueueReceive+0x148>)
    c74e:	f8df 80bc 	ldr.w	r8, [pc, #188]	; c80c <xQueueReceive+0x160>
    c752:	a901      	add	r1, sp, #4
    c754:	a802      	add	r0, sp, #8
    c756:	4798      	blx	r3
    c758:	2800      	cmp	r0, #0
    c75a:	d139      	bne.n	c7d0 <xQueueReceive+0x124>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    c75c:	4620      	mov	r0, r4
    c75e:	47c0      	blx	r8
    c760:	2800      	cmp	r0, #0
    c762:	d031      	beq.n	c7c8 <xQueueReceive+0x11c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    c764:	9901      	ldr	r1, [sp, #4]
    c766:	4b24      	ldr	r3, [pc, #144]	; (c7f8 <xQueueReceive+0x14c>)
    c768:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c76c:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    c76e:	4620      	mov	r0, r4
    c770:	47b0      	blx	r6
				if (xTaskResumeAll() == pdFALSE) {
    c772:	47a8      	blx	r5
    c774:	b938      	cbnz	r0, c786 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
    c776:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    c77a:	f8cb 3000 	str.w	r3, [fp]
    c77e:	f3bf 8f4f 	dsb	sy
    c782:	f3bf 8f6f 	isb	sy
    c786:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    c788:	47c8      	blx	r9
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c78a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c78c:	f8df 8080 	ldr.w	r8, [pc, #128]	; c810 <xQueueReceive+0x164>
    c790:	2d00      	cmp	r5, #0
    c792:	d0bd      	beq.n	c710 <xQueueReceive+0x64>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    c794:	4b19      	ldr	r3, [pc, #100]	; (c7fc <xQueueReceive+0x150>)
    c796:	4639      	mov	r1, r7
    c798:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    c79a:	3d01      	subs	r5, #1
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    c79c:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    c79e:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c7a0:	6923      	ldr	r3, [r4, #16]
    c7a2:	b163      	cbz	r3, c7be <xQueueReceive+0x112>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c7a4:	4b16      	ldr	r3, [pc, #88]	; (c800 <xQueueReceive+0x154>)
    c7a6:	f104 0010 	add.w	r0, r4, #16
    c7aa:	4798      	blx	r3
    c7ac:	b138      	cbz	r0, c7be <xQueueReceive+0x112>
						queueYIELD_IF_USING_PREEMPTION();
    c7ae:	4b15      	ldr	r3, [pc, #84]	; (c804 <xQueueReceive+0x158>)
    c7b0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c7b4:	601a      	str	r2, [r3, #0]
    c7b6:	f3bf 8f4f 	dsb	sy
    c7ba:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c7be:	47c0      	blx	r8
				return pdPASS;
    c7c0:	2001      	movs	r0, #1
}
    c7c2:	b005      	add	sp, #20
    c7c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				prvUnlockQueue(pxQueue);
    c7c8:	4620      	mov	r0, r4
    c7ca:	47b0      	blx	r6
				(void)xTaskResumeAll();
    c7cc:	47a8      	blx	r5
    c7ce:	e7da      	b.n	c786 <xQueueReceive+0xda>
			prvUnlockQueue(pxQueue);
    c7d0:	4620      	mov	r0, r4
    c7d2:	47b0      	blx	r6
			(void)xTaskResumeAll();
    c7d4:	47a8      	blx	r5
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    c7d6:	4620      	mov	r0, r4
    c7d8:	47c0      	blx	r8
    c7da:	2800      	cmp	r0, #0
    c7dc:	d0d3      	beq.n	c786 <xQueueReceive+0xda>
    c7de:	e79a      	b.n	c716 <xQueueReceive+0x6a>
    c7e0:	00012c7d 	.word	0x00012c7d
    c7e4:	00012bd5 	.word	0x00012bd5
    c7e8:	000127b1 	.word	0x000127b1
    c7ec:	0000c2b1 	.word	0x0000c2b1
    c7f0:	000128f9 	.word	0x000128f9
    c7f4:	00012be9 	.word	0x00012be9
    c7f8:	00012ad1 	.word	0x00012ad1
    c7fc:	0000c1f9 	.word	0x0000c1f9
    c800:	00012b55 	.word	0x00012b55
    c804:	e000ed04 	.word	0xe000ed04
    c808:	0000b2a5 	.word	0x0000b2a5
    c80c:	0000c169 	.word	0x0000c169
    c810:	0000b2e9 	.word	0x0000b2e9

0000c814 <vQueueWaitForMessageRestricted>:
{
    c814:	b570      	push	{r4, r5, r6, lr}
    c816:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
    c818:	4b10      	ldr	r3, [pc, #64]	; (c85c <vQueueWaitForMessageRestricted+0x48>)
{
    c81a:	460d      	mov	r5, r1
    c81c:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    c81e:	4798      	blx	r3
    c820:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c824:	2bff      	cmp	r3, #255	; 0xff
    c826:	bf04      	itt	eq
    c828:	2300      	moveq	r3, #0
    c82a:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    c82e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c832:	2bff      	cmp	r3, #255	; 0xff
    c834:	bf04      	itt	eq
    c836:	2300      	moveq	r3, #0
    c838:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    c83c:	4b08      	ldr	r3, [pc, #32]	; (c860 <vQueueWaitForMessageRestricted+0x4c>)
    c83e:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    c840:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c842:	b92b      	cbnz	r3, c850 <vQueueWaitForMessageRestricted+0x3c>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    c844:	4b07      	ldr	r3, [pc, #28]	; (c864 <vQueueWaitForMessageRestricted+0x50>)
    c846:	4632      	mov	r2, r6
    c848:	4629      	mov	r1, r5
    c84a:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c84e:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
    c850:	4620      	mov	r0, r4
    c852:	4b05      	ldr	r3, [pc, #20]	; (c868 <vQueueWaitForMessageRestricted+0x54>)
}
    c854:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
    c858:	4718      	bx	r3
    c85a:	bf00      	nop
    c85c:	0000b2a5 	.word	0x0000b2a5
    c860:	0000b2e9 	.word	0x0000b2e9
    c864:	00012b0d 	.word	0x00012b0d
    c868:	0000c2b1 	.word	0x0000c2b1

0000c86c <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    c86c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CRITICAL_SECTION_ENTER();
    c86e:	4b0e      	ldr	r3, [pc, #56]	; (c8a8 <gpio_get_pin_level+0x3c>)
    c870:	4605      	mov	r5, r0
    c872:	a801      	add	r0, sp, #4
    c874:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    c876:	4a0d      	ldr	r2, [pc, #52]	; (c8ac <gpio_get_pin_level+0x40>)
    c878:	096b      	lsrs	r3, r5, #5
    c87a:	01d9      	lsls	r1, r3, #7
    c87c:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    c880:	5851      	ldr	r1, [r2, r1]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    c882:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    c884:	691c      	ldr	r4, [r3, #16]
	CRITICAL_SECTION_LEAVE();
    c886:	4b0a      	ldr	r3, [pc, #40]	; (c8b0 <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    c888:	4054      	eors	r4, r2
    c88a:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    c88c:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    c88e:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    c890:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    c894:	4798      	blx	r3
    c896:	2001      	movs	r0, #1
    c898:	fa00 f505 	lsl.w	r5, r0, r5
    c89c:	4225      	tst	r5, r4
}
    c89e:	bf08      	it	eq
    c8a0:	2000      	moveq	r0, #0
    c8a2:	b003      	add	sp, #12
    c8a4:	bd30      	pop	{r4, r5, pc}
    c8a6:	bf00      	nop
    c8a8:	00011b59 	.word	0x00011b59
    c8ac:	41008000 	.word	0x41008000
    c8b0:	00011b67 	.word	0x00011b67

0000c8b4 <hiddf_demo_sof_event>:
#endif /* CONF_USB_COMPOSITE_CDC_ECHO_DEMO */

#if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO
static uint32_t pin_btn1, pin_btn2, pin_btn3;
static void     hiddf_demo_sof_event(void)
{
    c8b4:	b570      	push	{r4, r5, r6, lr}
        {HID_CAPS_LOCK, false, HID_KB_KEY_UP},
    };
	uint8_t b_btn_state;
#endif

	if (interval++ > 10) {
    c8b6:	4a15      	ldr	r2, [pc, #84]	; (c90c <hiddf_demo_sof_event+0x58>)
    c8b8:	7913      	ldrb	r3, [r2, #4]
    c8ba:	2b0a      	cmp	r3, #10
    c8bc:	4614      	mov	r4, r2
    c8be:	d802      	bhi.n	c8c6 <hiddf_demo_sof_event+0x12>
    c8c0:	3301      	adds	r3, #1
    c8c2:	7113      	strb	r3, [r2, #4]
#endif
	}
	(void)pin_btn1;
	(void)pin_btn2;
	(void)pin_btn3;
}
    c8c4:	bd70      	pop	{r4, r5, r6, pc}
		interval = 0;
    c8c6:	2300      	movs	r3, #0
		if (!gpio_get_pin_level(pin_btn1)) {
    c8c8:	7a10      	ldrb	r0, [r2, #8]
    c8ca:	4d11      	ldr	r5, [pc, #68]	; (c910 <hiddf_demo_sof_event+0x5c>)
		interval = 0;
    c8cc:	7113      	strb	r3, [r2, #4]
		if (!gpio_get_pin_level(pin_btn1)) {
    c8ce:	47a8      	blx	r5
    c8d0:	b920      	cbnz	r0, c8dc <hiddf_demo_sof_event+0x28>
			hiddf_mouse_move(-5, HID_MOUSE_X_AXIS_MV);
    c8d2:	4b10      	ldr	r3, [pc, #64]	; (c914 <hiddf_demo_sof_event+0x60>)
    c8d4:	2101      	movs	r1, #1
    c8d6:	f06f 0004 	mvn.w	r0, #4
    c8da:	4798      	blx	r3
		if (!gpio_get_pin_level(pin_btn3)) {
    c8dc:	7b20      	ldrb	r0, [r4, #12]
    c8de:	47a8      	blx	r5
    c8e0:	b918      	cbnz	r0, c8ea <hiddf_demo_sof_event+0x36>
			hiddf_mouse_move(5, HID_MOUSE_X_AXIS_MV);
    c8e2:	4b0c      	ldr	r3, [pc, #48]	; (c914 <hiddf_demo_sof_event+0x60>)
    c8e4:	2101      	movs	r1, #1
    c8e6:	2005      	movs	r0, #5
    c8e8:	4798      	blx	r3
		if (b_btn_last_state != (b_btn_state = !gpio_get_pin_level(pin_btn2))) {
    c8ea:	7c20      	ldrb	r0, [r4, #16]
    c8ec:	47a8      	blx	r5
    c8ee:	7d22      	ldrb	r2, [r4, #20]
    c8f0:	f080 0001 	eor.w	r0, r0, #1
    c8f4:	b2c3      	uxtb	r3, r0
    c8f6:	429a      	cmp	r2, r3
    c8f8:	d0e4      	beq.n	c8c4 <hiddf_demo_sof_event+0x10>
			b_btn_last_state = b_btn_state;
    c8fa:	4807      	ldr	r0, [pc, #28]	; (c918 <hiddf_demo_sof_event+0x64>)
    c8fc:	7523      	strb	r3, [r4, #20]
			if (1 == b_btn_last_state) {
    c8fe:	7083      	strb	r3, [r0, #2]
}
    c900:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			hiddf_keyboard_keys_state_change(key_array, 1);
    c904:	4b05      	ldr	r3, [pc, #20]	; (c91c <hiddf_demo_sof_event+0x68>)
    c906:	2101      	movs	r1, #1
    c908:	4718      	bx	r3
    c90a:	bf00      	nop
    c90c:	20008550 	.word	0x20008550
    c910:	0000c86d 	.word	0x0000c86d
    c914:	0000e045 	.word	0x0000e045
    c918:	2000035c 	.word	0x2000035c
    c91c:	0000ead1 	.word	0x0000ead1

0000c920 <composite_device_init>:
	usbdc_register_handler(USBDC_HDL_SOF, &hiddf_demo_sof_event_h);
}
#endif /* #if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO */

void composite_device_init(void)
{
    c920:	b510      	push	{r4, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    c922:	4b05      	ldr	r3, [pc, #20]	; (c938 <composite_device_init+0x18>)
    c924:	4805      	ldr	r0, [pc, #20]	; (c93c <composite_device_init+0x1c>)
    c926:	4798      	blx	r3

	/* usbdc_register_funcion inside */
#if CONF_USB_COMPOSITE_CDC_ACM_EN
	cdcdf_acm_init();
    c928:	4b05      	ldr	r3, [pc, #20]	; (c940 <composite_device_init+0x20>)
    c92a:	4798      	blx	r3
#endif
#if CONF_USB_COMPOSITE_HID_MOUSE_EN
	hiddf_mouse_init();
    c92c:	4b05      	ldr	r3, [pc, #20]	; (c944 <composite_device_init+0x24>)
    c92e:	4798      	blx	r3
	hiddf_keyboard_init();
#endif
#if CONF_USB_COMPOSITE_MSC_EN
	mscdf_init(CONF_USB_MSC_MAX_LUN);
#endif
}
    c930:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hiddf_keyboard_init();
    c934:	4b04      	ldr	r3, [pc, #16]	; (c948 <composite_device_init+0x28>)
    c936:	4718      	bx	r3
    c938:	00013611 	.word	0x00013611
    c93c:	20008565 	.word	0x20008565
    c940:	0000bd31 	.word	0x0000bd31
    c944:	0000e001 	.word	0x0000e001
    c948:	0000ea8d 	.word	0x0000ea8d

0000c94c <composite_device_start>:

void composite_device_start(void)
{
    c94c:	b510      	push	{r4, lr}
	usbdc_start(multi_desc);
    c94e:	4b03      	ldr	r3, [pc, #12]	; (c95c <composite_device_start+0x10>)
    c950:	4803      	ldr	r0, [pc, #12]	; (c960 <composite_device_start+0x14>)
    c952:	4798      	blx	r3
	usbdc_attach();
}
    c954:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	usbdc_attach();
    c958:	4b02      	ldr	r3, [pc, #8]	; (c964 <composite_device_start+0x18>)
    c95a:	4718      	bx	r3
    c95c:	0001367d 	.word	0x0001367d
    c960:	20000368 	.word	0x20000368
    c964:	000136b1 	.word	0x000136b1

0000c968 <usb_init>:
}

void usb_init(void)
{

	composite_device_init();
    c968:	4b00      	ldr	r3, [pc, #0]	; (c96c <usb_init+0x4>)
    c96a:	4718      	bx	r3
    c96c:	0000c921 	.word	0x0000c921

0000c970 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    c970:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    c972:	6805      	ldr	r5, [r0, #0]

	if (!head) {
    c974:	b91d      	cbnz	r5, c97e <timer_add_timer_task+0xe>
		list_insert_as_head(list, new_task);
    c976:	4b0f      	ldr	r3, [pc, #60]	; (c9b4 <timer_add_timer_task+0x44>)
	if (it == head) {
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
	}
}
    c978:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		list_insert_after(prev, new_task);
    c97c:	4718      	bx	r3
		if (time_left >= new_task->interval)
    c97e:	f8d1 c008 	ldr.w	ip, [r1, #8]
    c982:	462c      	mov	r4, r5
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    c984:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c986:	f1c2 0e01 	rsb	lr, r2, #1
		if (it->time_label <= time) {
    c98a:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
    c98e:	4293      	cmp	r3, r2
			time_left = it->interval - (time - it->time_label);
    c990:	bf95      	itete	ls
    c992:	19db      	addls	r3, r3, r7
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c994:	4473      	addhi	r3, lr
			time_left = it->interval - (time - it->time_label);
    c996:	1a9b      	subls	r3, r3, r2
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c998:	19db      	addhi	r3, r3, r7
		if (time_left >= new_task->interval)
    c99a:	459c      	cmp	ip, r3
    c99c:	d907      	bls.n	c9ae <timer_add_timer_task+0x3e>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    c99e:	6823      	ldr	r3, [r4, #0]
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    c9a0:	4626      	mov	r6, r4
    c9a2:	b913      	cbnz	r3, c9aa <timer_add_timer_task+0x3a>
		list_insert_after(prev, new_task);
    c9a4:	4b04      	ldr	r3, [pc, #16]	; (c9b8 <timer_add_timer_task+0x48>)
    c9a6:	4630      	mov	r0, r6
    c9a8:	e7e6      	b.n	c978 <timer_add_timer_task+0x8>
    c9aa:	461c      	mov	r4, r3
    c9ac:	e7ed      	b.n	c98a <timer_add_timer_task+0x1a>
	if (it == head) {
    c9ae:	42a5      	cmp	r5, r4
    c9b0:	d0e1      	beq.n	c976 <timer_add_timer_task+0x6>
    c9b2:	e7f7      	b.n	c9a4 <timer_add_timer_task+0x34>
    c9b4:	0000f845 	.word	0x0000f845
    c9b8:	0000f871 	.word	0x0000f871

0000c9bc <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    c9bc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    c9c0:	e9d0 6504 	ldrd	r6, r5, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c9c4:	7e03      	ldrb	r3, [r0, #24]
	uint32_t                 time  = ++timer->time;
    c9c6:	3601      	adds	r6, #1
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c9c8:	07da      	lsls	r2, r3, #31
{
    c9ca:	4604      	mov	r4, r0
	uint32_t                 time  = ++timer->time;
    c9cc:	6106      	str	r6, [r0, #16]
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c9ce:	d41f      	bmi.n	ca10 <timer_process_counted+0x54>
    c9d0:	7e03      	ldrb	r3, [r0, #24]
    c9d2:	079b      	lsls	r3, r3, #30
    c9d4:	d41c      	bmi.n	ca10 <timer_process_counted+0x54>
	}

	while (it && ((time - it->time_label) >= it->interval)) {
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    c9d6:	f8df 8044 	ldr.w	r8, [pc, #68]	; ca1c <timer_process_counted+0x60>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    c9da:	f8df 9044 	ldr.w	r9, [pc, #68]	; ca20 <timer_process_counted+0x64>
		list_remove_head(&timer->tasks);
    c9de:	f100 0714 	add.w	r7, r0, #20
	while (it && ((time - it->time_label) >= it->interval)) {
    c9e2:	b1cd      	cbz	r5, ca18 <timer_process_counted+0x5c>
    c9e4:	686b      	ldr	r3, [r5, #4]
    c9e6:	68aa      	ldr	r2, [r5, #8]
    c9e8:	1af3      	subs	r3, r6, r3
    c9ea:	4293      	cmp	r3, r2
    c9ec:	d314      	bcc.n	ca18 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
    c9ee:	4638      	mov	r0, r7
    c9f0:	47c0      	blx	r8
		if (TIMER_TASK_REPEAT == tmp->mode) {
    c9f2:	7c2b      	ldrb	r3, [r5, #16]
    c9f4:	2b01      	cmp	r3, #1
    c9f6:	d104      	bne.n	ca02 <timer_process_counted+0x46>
			tmp->time_label = time;
    c9f8:	606e      	str	r6, [r5, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    c9fa:	4632      	mov	r2, r6
    c9fc:	4629      	mov	r1, r5
    c9fe:	4638      	mov	r0, r7
    ca00:	47c8      	blx	r9
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);
    ca02:	f8d4 a014 	ldr.w	sl, [r4, #20]

		tmp->cb(tmp);
    ca06:	68eb      	ldr	r3, [r5, #12]
    ca08:	4628      	mov	r0, r5
    ca0a:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    ca0c:	4655      	mov	r5, sl
    ca0e:	e7e8      	b.n	c9e2 <timer_process_counted+0x26>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    ca10:	7e23      	ldrb	r3, [r4, #24]
    ca12:	f043 0302 	orr.w	r3, r3, #2
    ca16:	7623      	strb	r3, [r4, #24]
	}
}
    ca18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    ca1c:	0000f8b9 	.word	0x0000f8b9
    ca20:	0000c971 	.word	0x0000c971

0000ca24 <timer_init>:
{
    ca24:	b570      	push	{r4, r5, r6, lr}
    ca26:	460d      	mov	r5, r1
    ca28:	4616      	mov	r6, r2
	ASSERT(descr && hw && func);
    ca2a:	4604      	mov	r4, r0
    ca2c:	b118      	cbz	r0, ca36 <timer_init+0x12>
    ca2e:	b189      	cbz	r1, ca54 <timer_init+0x30>
    ca30:	1e10      	subs	r0, r2, #0
    ca32:	bf18      	it	ne
    ca34:	2001      	movne	r0, #1
    ca36:	223b      	movs	r2, #59	; 0x3b
    ca38:	4907      	ldr	r1, [pc, #28]	; (ca58 <timer_init+0x34>)
    ca3a:	4b08      	ldr	r3, [pc, #32]	; (ca5c <timer_init+0x38>)
    ca3c:	4798      	blx	r3
	descr->func = func;
    ca3e:	4620      	mov	r0, r4
	descr->func->init(&descr->device, hw);
    ca40:	6833      	ldr	r3, [r6, #0]
	descr->func = func;
    ca42:	f840 6b04 	str.w	r6, [r0], #4
	descr->func->init(&descr->device, hw);
    ca46:	4629      	mov	r1, r5
    ca48:	4798      	blx	r3
	descr->device.timer_cb.period_expired = timer_process_counted;
    ca4a:	4b05      	ldr	r3, [pc, #20]	; (ca60 <timer_init+0x3c>)
    ca4c:	6063      	str	r3, [r4, #4]
	descr->time                           = 0;
    ca4e:	2000      	movs	r0, #0
    ca50:	6160      	str	r0, [r4, #20]
}
    ca52:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw && func);
    ca54:	4608      	mov	r0, r1
    ca56:	e7ee      	b.n	ca36 <timer_init+0x12>
    ca58:	0001727c 	.word	0x0001727c
    ca5c:	0000e08d 	.word	0x0000e08d
    ca60:	0000c9bd 	.word	0x0000c9bd

0000ca64 <timer_start>:
{
    ca64:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr && descr->func);
    ca66:	4605      	mov	r5, r0
    ca68:	b118      	cbz	r0, ca72 <timer_start+0xe>
    ca6a:	6800      	ldr	r0, [r0, #0]
    ca6c:	3800      	subs	r0, #0
    ca6e:	bf18      	it	ne
    ca70:	2001      	movne	r0, #1
	if (descr->func->is_timer_started(&descr->device)) {
    ca72:	462e      	mov	r6, r5
	ASSERT(descr && descr->func);
    ca74:	4909      	ldr	r1, [pc, #36]	; (ca9c <timer_start+0x38>)
    ca76:	4b0a      	ldr	r3, [pc, #40]	; (caa0 <timer_start+0x3c>)
    ca78:	2254      	movs	r2, #84	; 0x54
    ca7a:	4798      	blx	r3
	if (descr->func->is_timer_started(&descr->device)) {
    ca7c:	f856 3b04 	ldr.w	r3, [r6], #4
    ca80:	699b      	ldr	r3, [r3, #24]
    ca82:	4630      	mov	r0, r6
    ca84:	4798      	blx	r3
    ca86:	4604      	mov	r4, r0
    ca88:	b928      	cbnz	r0, ca96 <timer_start+0x32>
	descr->func->start_timer(&descr->device);
    ca8a:	682b      	ldr	r3, [r5, #0]
    ca8c:	4630      	mov	r0, r6
    ca8e:	689b      	ldr	r3, [r3, #8]
    ca90:	4798      	blx	r3
	return ERR_NONE;
    ca92:	4620      	mov	r0, r4
}
    ca94:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
    ca96:	f06f 0010 	mvn.w	r0, #16
    ca9a:	e7fb      	b.n	ca94 <timer_start+0x30>
    ca9c:	0001727c 	.word	0x0001727c
    caa0:	0000e08d 	.word	0x0000e08d

0000caa4 <timer_add_task>:
{
    caa4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    caa8:	460d      	mov	r5, r1
	ASSERT(descr && task && descr->func);
    caaa:	4604      	mov	r4, r0
    caac:	b120      	cbz	r0, cab8 <timer_add_task+0x14>
    caae:	b309      	cbz	r1, caf4 <timer_add_task+0x50>
    cab0:	6800      	ldr	r0, [r0, #0]
    cab2:	3800      	subs	r0, #0
    cab4:	bf18      	it	ne
    cab6:	2001      	movne	r0, #1
    cab8:	4920      	ldr	r1, [pc, #128]	; (cb3c <timer_add_task+0x98>)
    caba:	f8df 8094 	ldr.w	r8, [pc, #148]	; cb50 <timer_add_task+0xac>
    cabe:	227b      	movs	r2, #123	; 0x7b
    cac0:	47c0      	blx	r8
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    cac2:	7f23      	ldrb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    cac4:	f104 0718 	add.w	r7, r4, #24
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    cac8:	f043 0301 	orr.w	r3, r3, #1
    cacc:	7723      	strb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    cace:	4629      	mov	r1, r5
    cad0:	4b1b      	ldr	r3, [pc, #108]	; (cb40 <timer_add_task+0x9c>)
    cad2:	4638      	mov	r0, r7
    cad4:	4798      	blx	r3
    cad6:	4606      	mov	r6, r0
    cad8:	b170      	cbz	r0, caf8 <timer_add_task+0x54>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    cada:	7f23      	ldrb	r3, [r4, #28]
		ASSERT(false);
    cadc:	4917      	ldr	r1, [pc, #92]	; (cb3c <timer_add_task+0x98>)
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    cade:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
		ASSERT(false);
    cae2:	2000      	movs	r0, #0
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    cae4:	7723      	strb	r3, [r4, #28]
		ASSERT(false);
    cae6:	2280      	movs	r2, #128	; 0x80
    cae8:	47c0      	blx	r8
		return ERR_ALREADY_INITIALIZED;
    caea:	f06f 0011 	mvn.w	r0, #17
}
    caee:	b002      	add	sp, #8
    caf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(descr && task && descr->func);
    caf4:	4608      	mov	r0, r1
    caf6:	e7df      	b.n	cab8 <timer_add_task+0x14>
	task->time_label = descr->time;
    caf8:	6962      	ldr	r2, [r4, #20]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    cafa:	4b12      	ldr	r3, [pc, #72]	; (cb44 <timer_add_task+0xa0>)
	task->time_label = descr->time;
    cafc:	606a      	str	r2, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    cafe:	4629      	mov	r1, r5
    cb00:	4638      	mov	r0, r7
    cb02:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    cb04:	7f23      	ldrb	r3, [r4, #28]
    cb06:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    cb0a:	7723      	strb	r3, [r4, #28]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    cb0c:	7f23      	ldrb	r3, [r4, #28]
    cb0e:	f013 0302 	ands.w	r3, r3, #2
    cb12:	d010      	beq.n	cb36 <timer_add_task+0x92>
		CRITICAL_SECTION_ENTER()
    cb14:	4b0c      	ldr	r3, [pc, #48]	; (cb48 <timer_add_task+0xa4>)
    cb16:	a801      	add	r0, sp, #4
    cb18:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    cb1a:	7f23      	ldrb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    cb1c:	4620      	mov	r0, r4
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    cb1e:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    cb22:	7723      	strb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    cb24:	f850 3b04 	ldr.w	r3, [r0], #4
    cb28:	69db      	ldr	r3, [r3, #28]
    cb2a:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    cb2c:	a801      	add	r0, sp, #4
    cb2e:	4b07      	ldr	r3, [pc, #28]	; (cb4c <timer_add_task+0xa8>)
    cb30:	4798      	blx	r3
	return ERR_NONE;
    cb32:	4630      	mov	r0, r6
    cb34:	e7db      	b.n	caee <timer_add_task+0x4a>
    cb36:	4618      	mov	r0, r3
    cb38:	e7d9      	b.n	caee <timer_add_task+0x4a>
    cb3a:	bf00      	nop
    cb3c:	0001727c 	.word	0x0001727c
    cb40:	0000f835 	.word	0x0000f835
    cb44:	0000c971 	.word	0x0000c971
    cb48:	00011b59 	.word	0x00011b59
    cb4c:	00011b67 	.word	0x00011b67
    cb50:	0000e08d 	.word	0x0000e08d

0000cb54 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    cb54:	2000      	movs	r0, #0
    cb56:	4770      	bx	lr

0000cb58 <_usb_d_dev_wait_dfll_rdy>:
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    cb58:	4b07      	ldr	r3, [pc, #28]	; (cb78 <_usb_d_dev_wait_dfll_rdy+0x20>)
    cb5a:	f893 2020 	ldrb.w	r2, [r3, #32]
/**
 * \brief Wait DFLL clock to be ready
 */
static inline void _usb_d_dev_wait_dfll_rdy(void)
{
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    cb5e:	07d1      	lsls	r1, r2, #31
    cb60:	d506      	bpl.n	cb70 <_usb_d_dev_wait_dfll_rdy+0x18>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    cb62:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    cb64:	f402 6210 	and.w	r2, r2, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    cb68:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    cb6c:	d1f9      	bne.n	cb62 <_usb_d_dev_wait_dfll_rdy+0xa>
    cb6e:	4770      	bx	lr
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    cb70:	691a      	ldr	r2, [r3, #16]
		       != (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
			;
	} else {
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    cb72:	05d2      	lsls	r2, r2, #23
    cb74:	d5fc      	bpl.n	cb70 <_usb_d_dev_wait_dfll_rdy+0x18>
			;
	}
}
    cb76:	4770      	bx	lr
    cb78:	40001000 	.word	0x40001000

0000cb7c <_usb_d_dev_ept>:
 * \param[in] epn Endpoint number.
 * \param[in] dir Endpoint direction.
 */
static inline struct _usb_d_dev_ep *_usb_d_dev_ept(uint8_t epn, bool dir)
{
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    cb7c:	b110      	cbz	r0, cb84 <_usb_d_dev_ept+0x8>
    cb7e:	b109      	cbz	r1, cb84 <_usb_d_dev_ept+0x8>
    cb80:	3005      	adds	r0, #5
    cb82:	b2c0      	uxtb	r0, r0
	return &dev_inst.ep[ep_index];
    cb84:	2314      	movs	r3, #20
    cb86:	fb00 3003 	mla	r0, r0, r3, r3
}
    cb8a:	4b01      	ldr	r3, [pc, #4]	; (cb90 <_usb_d_dev_ept+0x14>)
    cb8c:	4418      	add	r0, r3
    cb8e:	4770      	bx	lr
    cb90:	200085a8 	.word	0x200085a8

0000cb94 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    cb94:	b430      	push	{r4, r5}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cb96:	7cc1      	ldrb	r1, [r0, #19]
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    cb98:	7c85      	ldrb	r5, [r0, #18]

	if (!is_ctrl) {
    cb9a:	f001 0307 	and.w	r3, r1, #7
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    cb9e:	f005 020f 	and.w	r2, r5, #15
	if (!is_ctrl) {
    cba2:	2b01      	cmp	r3, #1
    cba4:	ea4f 1442 	mov.w	r4, r2, lsl #5
    cba8:	f102 0308 	add.w	r3, r2, #8
    cbac:	d00a      	beq.n	cbc4 <_usb_d_dev_handle_setup+0x30>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cbae:	015a      	lsls	r2, r3, #5
    cbb0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    cbb4:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cbb8:	2110      	movs	r1, #16
    cbba:	71d1      	strb	r1, [r2, #7]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    cbbc:	bc30      	pop	{r4, r5}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    cbbe:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    cbc2:	4770      	bx	lr
	if (_usb_d_dev_ep_is_busy(ept)) {
    cbc4:	f011 0f40 	tst.w	r1, #64	; 0x40
    cbc8:	d00b      	beq.n	cbe2 <_usb_d_dev_handle_setup+0x4e>
		ept->flags.bits.is_busy = 0;
    cbca:	0152      	lsls	r2, r2, #5
    cbcc:	f36f 1186 	bfc	r1, #6, #1
    cbd0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cbd4:	74c1      	strb	r1, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cbd6:	2180      	movs	r1, #128	; 0x80
    cbd8:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    cbdc:	2140      	movs	r1, #64	; 0x40
    cbde:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105
	ept->flags.bits.is_stalled = 0;
    cbe2:	7cc2      	ldrb	r2, [r0, #19]
    cbe4:	f36f 02c3 	bfc	r2, #3, #1
    cbe8:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    cbea:	4a0a      	ldr	r2, [pc, #40]	; (cc14 <_usb_d_dev_handle_setup+0x80>)
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cbec:	015b      	lsls	r3, r3, #5
    cbee:	1911      	adds	r1, r2, r4
    cbf0:	2000      	movs	r0, #0
    cbf2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cbf6:	f881 023a 	strb.w	r0, [r1, #570]	; 0x23a
    cbfa:	f881 024a 	strb.w	r0, [r1, #586]	; 0x24a
    cbfe:	216f      	movs	r1, #111	; 0x6f
    cc00:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc02:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	dev_inst.ep_callbacks.setup(ept->ep);
    cc06:	4628      	mov	r0, r5
    cc08:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    cc0c:	bc30      	pop	{r4, r5}
	dev_inst.ep_callbacks.setup(ept->ep);
    cc0e:	6893      	ldr	r3, [r2, #8]
    cc10:	4718      	bx	r3
    cc12:	bf00      	nop
    cc14:	200085a8 	.word	0x200085a8

0000cc18 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    cc18:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cc1a:	7c84      	ldrb	r4, [r0, #18]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cc1c:	6882      	ldr	r2, [r0, #8]
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    cc1e:	2320      	movs	r3, #32
    cc20:	fa03 f101 	lsl.w	r1, r3, r1
    cc24:	f004 030f 	and.w	r3, r4, #15
    cc28:	015b      	lsls	r3, r3, #5
    cc2a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    cc2e:	b2c9      	uxtb	r1, r1
    cc30:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cc34:	4b03      	ldr	r3, [pc, #12]	; (cc44 <_usb_d_dev_handle_stall+0x2c>)
    cc36:	4620      	mov	r0, r4
    cc38:	691b      	ldr	r3, [r3, #16]
}
    cc3a:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cc3e:	2101      	movs	r1, #1
    cc40:	4718      	bx	r3
    cc42:	bf00      	nop
    cc44:	200085a8 	.word	0x200085a8

0000cc48 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    cc48:	b410      	push	{r4}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cc4a:	7c84      	ldrb	r4, [r0, #18]
    cc4c:	2cff      	cmp	r4, #255	; 0xff
    cc4e:	d00c      	beq.n	cc6a <_usb_d_dev_trans_done+0x22>
    cc50:	7cc3      	ldrb	r3, [r0, #19]
    cc52:	065a      	lsls	r2, r3, #25
    cc54:	d509      	bpl.n	cc6a <_usb_d_dev_trans_done+0x22>
		return;
	}
	ept->flags.bits.is_busy = 0;
    cc56:	f36f 1386 	bfc	r3, #6, #1
    cc5a:	74c3      	strb	r3, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cc5c:	4b04      	ldr	r3, [pc, #16]	; (cc70 <_usb_d_dev_trans_done+0x28>)
    cc5e:	6882      	ldr	r2, [r0, #8]
    cc60:	691b      	ldr	r3, [r3, #16]
    cc62:	4620      	mov	r0, r4
}
    cc64:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cc68:	4718      	bx	r3
}
    cc6a:	f85d 4b04 	ldr.w	r4, [sp], #4
    cc6e:	4770      	bx	lr
    cc70:	200085a8 	.word	0x200085a8

0000cc74 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    cc74:	b477      	push	{r0, r1, r2, r4, r5, r6}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cc76:	7c83      	ldrb	r3, [r0, #18]
{
    cc78:	460d      	mov	r5, r1
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cc7a:	2bff      	cmp	r3, #255	; 0xff
{
    cc7c:	4611      	mov	r1, r2
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    cc7e:	f644 2225 	movw	r2, #18981	; 0x4a25
    cc82:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cc86:	d020      	beq.n	ccca <_usb_d_dev_trans_stop+0x56>
    cc88:	7cc2      	ldrb	r2, [r0, #19]
    cc8a:	0652      	lsls	r2, r2, #25
    cc8c:	d51d      	bpl.n	ccca <_usb_d_dev_trans_stop+0x56>
		return;
	}
	/* Stop transfer */
	if (dir) {
    cc8e:	f003 030f 	and.w	r3, r3, #15
    cc92:	f103 0408 	add.w	r4, r3, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cc96:	0162      	lsls	r2, r4, #5
    cc98:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cc9c:	b195      	cbz	r5, ccc4 <_usb_d_dev_trans_stop+0x50>
    cc9e:	2680      	movs	r6, #128	; 0x80
    cca0:	7116      	strb	r6, [r2, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    cca2:	aa02      	add	r2, sp, #8
    cca4:	4415      	add	r5, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cca6:	0164      	lsls	r4, r4, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cca8:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ccaa:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    ccae:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    ccb2:	f815 2c04 	ldrb.w	r2, [r5, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ccb6:	71e2      	strb	r2, [r4, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    ccb8:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    ccbc:	4b04      	ldr	r3, [pc, #16]	; (ccd0 <_usb_d_dev_trans_stop+0x5c>)
}
    ccbe:	b003      	add	sp, #12
    ccc0:	bc70      	pop	{r4, r5, r6}
	_usb_d_dev_trans_done(ept, code);
    ccc2:	4718      	bx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    ccc4:	2640      	movs	r6, #64	; 0x40
    ccc6:	7156      	strb	r6, [r2, #5]
}
    ccc8:	e7eb      	b.n	cca2 <_usb_d_dev_trans_stop+0x2e>
}
    ccca:	b003      	add	sp, #12
    cccc:	bc70      	pop	{r4, r5, r6}
    ccce:	4770      	bx	lr
    ccd0:	0000cc49 	.word	0x0000cc49

0000ccd4 <_usb_d_dev_handle_trfail>:
{
    ccd4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    ccd6:	7c83      	ldrb	r3, [r0, #18]
    ccd8:	f003 0c0f 	and.w	ip, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    ccdc:	f640 0204 	movw	r2, #2052	; 0x804
    cce0:	4663      	mov	r3, ip
    cce2:	f8ad 2004 	strh.w	r2, [sp, #4]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    cce6:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    cce8:	f10c 0308 	add.w	r3, ip, #8
    ccec:	460c      	mov	r4, r1

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    ccee:	0159      	lsls	r1, r3, #5
    ccf0:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    ccf4:	780f      	ldrb	r7, [r1, #0]
    ccf6:	b334      	cbz	r4, cd46 <_usb_d_dev_handle_trfail+0x72>
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    ccf8:	f3c7 1702 	ubfx	r7, r7, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    ccfc:	4e2c      	ldr	r6, [pc, #176]	; (cdb0 <_usb_d_dev_handle_trfail+0xdc>)
    ccfe:	eb02 1204 	add.w	r2, r2, r4, lsl #4
    cd02:	4416      	add	r6, r2
    cd04:	aa02      	add	r2, sp, #8
    cd06:	4422      	add	r2, r4
    cd08:	7ab5      	ldrb	r5, [r6, #10]
    cd0a:	f812 ec04 	ldrb.w	lr, [r2, #-4]
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    cd0e:	2f02      	cmp	r7, #2
	st.reg = bank[bank_n].STATUS_BK.reg;
    cd10:	b2ed      	uxtb	r5, r5
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    cd12:	ea4f 124c 	mov.w	r2, ip, lsl #5
    cd16:	d119      	bne.n	cd4c <_usb_d_dev_handle_trfail+0x78>
    cd18:	07e9      	lsls	r1, r5, #31
    cd1a:	d517      	bpl.n	cd4c <_usb_d_dev_handle_trfail+0x78>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    cd1c:	7ab1      	ldrb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd1e:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd20:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd24:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cd28:	f36f 0100 	bfc	r1, #0, #1
    cd2c:	72b1      	strb	r1, [r6, #10]
    cd2e:	f883 e007 	strb.w	lr, [r3, #7]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    cd32:	f004 0101 	and.w	r1, r4, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd36:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    cd3a:	2204      	movs	r2, #4
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cd3c:	4b1d      	ldr	r3, [pc, #116]	; (cdb4 <_usb_d_dev_handle_trfail+0xe0>)
}
    cd3e:	b003      	add	sp, #12
    cd40:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cd44:	4718      	bx	r3
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    cd46:	f007 0707 	and.w	r7, r7, #7
	return tmp;
    cd4a:	e7d7      	b.n	ccfc <_usb_d_dev_handle_trfail+0x28>
	} else if (st.bit.ERRORFLOW) {
    cd4c:	f015 0502 	ands.w	r5, r5, #2
    cd50:	d01b      	beq.n	cd8a <_usb_d_dev_handle_trfail+0xb6>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    cd52:	7ab1      	ldrb	r1, [r6, #10]
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cd54:	7cc5      	ldrb	r5, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd56:	015b      	lsls	r3, r3, #5
    cd58:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    cd5c:	f36f 0141 	bfc	r1, #1, #1
    cd60:	72b1      	strb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd62:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd66:	f883 e007 	strb.w	lr, [r3, #7]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    cd6a:	f005 0307 	and.w	r3, r5, #7
    cd6e:	2b01      	cmp	r3, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd70:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    cd74:	d119      	bne.n	cdaa <_usb_d_dev_handle_trfail+0xd6>
    cd76:	066b      	lsls	r3, r5, #25
    cd78:	d517      	bpl.n	cdaa <_usb_d_dev_handle_trfail+0xd6>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    cd7a:	7cc3      	ldrb	r3, [r0, #19]
    cd7c:	ebb4 1fd3 	cmp.w	r4, r3, lsr #7
    cd80:	ea4f 11d3 	mov.w	r1, r3, lsr #7
    cd84:	d011      	beq.n	cdaa <_usb_d_dev_handle_trfail+0xd6>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cd86:	2200      	movs	r2, #0
    cd88:	e7d8      	b.n	cd3c <_usb_d_dev_handle_trfail+0x68>
	bank->STATUS_BK.reg     = 0;
    cd8a:	490b      	ldr	r1, [pc, #44]	; (cdb8 <_usb_d_dev_handle_trfail+0xe4>)
    cd8c:	eb04 044c 	add.w	r4, r4, ip, lsl #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cd90:	015b      	lsls	r3, r3, #5
    cd92:	eb01 1404 	add.w	r4, r1, r4, lsl #4
    cd96:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cd9a:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cd9e:	f884 523a 	strb.w	r5, [r4, #570]	; 0x23a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cda2:	f883 e007 	strb.w	lr, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cda6:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
}
    cdaa:	b003      	add	sp, #12
    cdac:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cdae:	bf00      	nop
    cdb0:	200087d8 	.word	0x200087d8
    cdb4:	0000cc75 	.word	0x0000cc75
    cdb8:	200085a8 	.word	0x200085a8

0000cdbc <_usb_d_dev_reset_epts>:
{
    cdbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cdc0:	4c0a      	ldr	r4, [pc, #40]	; (cdec <_usb_d_dev_reset_epts+0x30>)
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    cdc2:	4f0b      	ldr	r7, [pc, #44]	; (cdf0 <_usb_d_dev_reset_epts+0x34>)
{
    cdc4:	2501      	movs	r5, #1
		dev_inst.ep[i].ep       = 0xFF;
    cdc6:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    cdc8:	2103      	movs	r1, #3
    cdca:	4620      	mov	r0, r4
    cdcc:	3501      	adds	r5, #1
    cdce:	47b8      	blx	r7
		dev_inst.ep[i].flags.u8 = 0;
    cdd0:	2100      	movs	r1, #0
	for (i = 0; i < USB_D_N_EP; i++) {
    cdd2:	2d1c      	cmp	r5, #28
		dev_inst.ep[i].ep       = 0xFF;
    cdd4:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    cdd6:	74e1      	strb	r1, [r4, #19]
	for (i = 0; i < USB_D_N_EP; i++) {
    cdd8:	f104 0414 	add.w	r4, r4, #20
    cddc:	d1f4      	bne.n	cdc8 <_usb_d_dev_reset_epts+0xc>
}
    cdde:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    cde2:	4804      	ldr	r0, [pc, #16]	; (cdf4 <_usb_d_dev_reset_epts+0x38>)
    cde4:	4b04      	ldr	r3, [pc, #16]	; (cdf8 <_usb_d_dev_reset_epts+0x3c>)
    cde6:	22c0      	movs	r2, #192	; 0xc0
    cde8:	4718      	bx	r3
    cdea:	bf00      	nop
    cdec:	200085bc 	.word	0x200085bc
    cdf0:	0000cc49 	.word	0x0000cc49
    cdf4:	200087d8 	.word	0x200087d8
    cdf8:	00014469 	.word	0x00014469

0000cdfc <_usb_d_dev_in_next>:
{
    cdfc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ce00:	4604      	mov	r4, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    ce02:	7c80      	ldrb	r0, [r0, #18]
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    ce04:	4688      	mov	r8, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    ce06:	f000 070f 	and.w	r7, r0, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    ce0a:	2900      	cmp	r1, #0
    ce0c:	d05b      	beq.n	cec6 <_usb_d_dev_in_next+0xca>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    ce0e:	4b4d      	ldr	r3, [pc, #308]	; (cf44 <_usb_d_dev_in_next+0x148>)
    ce10:	eb03 1347 	add.w	r3, r3, r7, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    ce14:	695e      	ldr	r6, [r3, #20]
    ce16:	f3c6 060d 	ubfx	r6, r6, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    ce1a:	8a22      	ldrh	r2, [r4, #16]
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    ce1c:	f894 e013 	ldrb.w	lr, [r4, #19]
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    ce20:	f240 33ff 	movw	r3, #1023	; 0x3ff
    ce24:	429a      	cmp	r2, r3
    ce26:	bf1a      	itte	ne
    ce28:	f102 3cff 	addne.w	ip, r2, #4294967295	; 0xffffffff
    ce2c:	fa0f fc8c 	sxthne.w	ip, ip
    ce30:	4694      	moveq	ip, r2
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    ce32:	f00e 0907 	and.w	r9, lr, #7
	if (isr) {
    ce36:	f1b8 0f00 	cmp.w	r8, #0
    ce3a:	d005      	beq.n	ce48 <_usb_d_dev_in_next+0x4c>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ce3c:	017b      	lsls	r3, r7, #5
    ce3e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    ce42:	2102      	movs	r1, #2
    ce44:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	ept->trans_count += trans_count;
    ce48:	68a1      	ldr	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    ce4a:	6863      	ldr	r3, [r4, #4]
	ept->trans_count += trans_count;
    ce4c:	4431      	add	r1, r6
	if (ept->trans_count < ept->trans_size) {
    ce4e:	4299      	cmp	r1, r3
	ept->trans_count += trans_count;
    ce50:	60a1      	str	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    ce52:	ea4f 1547 	mov.w	r5, r7, lsl #5
    ce56:	d242      	bcs.n	cede <_usb_d_dev_in_next+0xe2>
		trans_next = ept->trans_size - ept->trans_count;
    ce58:	1a5b      	subs	r3, r3, r1
    ce5a:	b29e      	uxth	r6, r3
		if (ept->flags.bits.use_cache) {
    ce5c:	6823      	ldr	r3, [r4, #0]
    ce5e:	f8df a0f0 	ldr.w	sl, [pc, #240]	; cf50 <_usb_d_dev_in_next+0x154>
    ce62:	f01e 0f20 	tst.w	lr, #32
    ce66:	4419      	add	r1, r3
    ce68:	d02f      	beq.n	ceca <_usb_d_dev_in_next+0xce>
			if (trans_next > ept->size) {
    ce6a:	4296      	cmp	r6, r2
    ce6c:	bf28      	it	cs
    ce6e:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    ce70:	4b35      	ldr	r3, [pc, #212]	; (cf48 <_usb_d_dev_in_next+0x14c>)
    ce72:	68e0      	ldr	r0, [r4, #12]
    ce74:	4632      	mov	r2, r6
    ce76:	4798      	blx	r3
	bank->ADDR.reg          = addr;
    ce78:	eb0a 0305 	add.w	r3, sl, r5
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    ce7c:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    ce7e:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    ce82:	eb0a 0205 	add.w	r2, sl, r5
    ce86:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    ce8a:	f366 030d 	bfi	r3, r6, #0, #14
    ce8e:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    ce92:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    ce96:	f36f 339b 	bfc	r3, #14, #14
    ce9a:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	if (!isr) {
    ce9e:	f1b8 0f00 	cmp.w	r8, #0
    cea2:	d108      	bne.n	ceb6 <_usb_d_dev_in_next+0xba>
			inten = USB_D_BANK1_INT_FLAGS;
    cea4:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    cea8:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    ceac:	bf0c      	ite	eq
    ceae:	234e      	moveq	r3, #78	; 0x4e
    ceb0:	234a      	movne	r3, #74	; 0x4a
    ceb2:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    ceb6:	017b      	lsls	r3, r7, #5
    ceb8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cebc:	2280      	movs	r2, #128	; 0x80
    cebe:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
}
    cec2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    cec6:	460e      	mov	r6, r1
    cec8:	e7a7      	b.n	ce1a <_usb_d_dev_in_next+0x1e>
	bank->ADDR.reg          = addr;
    ceca:	eb0a 0305 	add.w	r3, sl, r5
    cece:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    ced2:	bf28      	it	cs
    ced4:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
    ced8:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
}
    cedc:	e7d1      	b.n	ce82 <_usb_d_dev_in_next+0x86>
	} else if (ept->flags.bits.need_zlp) {
    cede:	f01e 0f10 	tst.w	lr, #16
    cee2:	d00e      	beq.n	cf02 <_usb_d_dev_in_next+0x106>
		ept->flags.bits.need_zlp = 0;
    cee4:	7ce3      	ldrb	r3, [r4, #19]
    cee6:	f36f 1304 	bfc	r3, #4, #1
    ceea:	74e3      	strb	r3, [r4, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    ceec:	4b17      	ldr	r3, [pc, #92]	; (cf4c <_usb_d_dev_in_next+0x150>)
    ceee:	442b      	add	r3, r5
    cef0:	685a      	ldr	r2, [r3, #4]
    cef2:	f36f 020d 	bfc	r2, #0, #14
    cef6:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    cef8:	685a      	ldr	r2, [r3, #4]
    cefa:	f36f 329b 	bfc	r2, #14, #14
    cefe:	605a      	str	r2, [r3, #4]
		goto _in_tx_exec;
    cf00:	e7cd      	b.n	ce9e <_usb_d_dev_in_next+0xa2>
	if (is_ctrl) {
    cf02:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cf06:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
	if (last_pkt == ept->size) {
    cf0a:	ea0c 0c06 	and.w	ip, ip, r6
    cf0e:	bf0c      	ite	eq
    cf10:	234b      	moveq	r3, #75	; 0x4b
    cf12:	234a      	movne	r3, #74	; 0x4a
    cf14:	4562      	cmp	r2, ip
    cf16:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
    cf1a:	d10c      	bne.n	cf36 <_usb_d_dev_in_next+0x13a>
		ept->flags.bits.is_busy = 0;
    cf1c:	7ce3      	ldrb	r3, [r4, #19]
    cf1e:	f36f 1386 	bfc	r3, #6, #1
    cf22:	74e3      	strb	r3, [r4, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    cf24:	4b0a      	ldr	r3, [pc, #40]	; (cf50 <_usb_d_dev_in_next+0x154>)
    cf26:	68db      	ldr	r3, [r3, #12]
    cf28:	4798      	blx	r3
    cf2a:	2800      	cmp	r0, #0
    cf2c:	d1c9      	bne.n	cec2 <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    cf2e:	7ce3      	ldrb	r3, [r4, #19]
    cf30:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    cf34:	74e3      	strb	r3, [r4, #19]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cf36:	4620      	mov	r0, r4
    cf38:	4b06      	ldr	r3, [pc, #24]	; (cf54 <_usb_d_dev_in_next+0x158>)
}
    cf3a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cf3e:	2100      	movs	r1, #0
    cf40:	4718      	bx	r3
    cf42:	bf00      	nop
    cf44:	200087d8 	.word	0x200087d8
    cf48:	00014335 	.word	0x00014335
    cf4c:	200087e8 	.word	0x200087e8
    cf50:	200085a8 	.word	0x200085a8
    cf54:	0000cc49 	.word	0x0000cc49

0000cf58 <_usb_d_dev_out_next>:
{
    cf58:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    cf5c:	7c86      	ldrb	r6, [r0, #18]
    cf5e:	f006 060f 	and.w	r6, r6, #15
{
    cf62:	4604      	mov	r4, r0
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    cf64:	460f      	mov	r7, r1
    cf66:	0175      	lsls	r5, r6, #5
    cf68:	2900      	cmp	r1, #0
    cf6a:	d060      	beq.n	d02e <_usb_d_dev_out_next+0xd6>
    cf6c:	4b5d      	ldr	r3, [pc, #372]	; (d0e4 <_usb_d_dev_out_next+0x18c>)
    cf6e:	442b      	add	r3, r5
    cf70:	685a      	ldr	r2, [r3, #4]
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    cf72:	685b      	ldr	r3, [r3, #4]
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    cf74:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    cf78:	f3c3 090d 	ubfx	r9, r3, #0, #14
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    cf7c:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf80:	7ce2      	ldrb	r2, [r4, #19]
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    cf82:	f240 33ff 	movw	r3, #1023	; 0x3ff
    cf86:	4598      	cmp	r8, r3
    cf88:	bf1c      	itt	ne
    cf8a:	f108 38ff 	addne.w	r8, r8, #4294967295	; 0xffffffff
    cf8e:	fa1f f888 	uxthne.w	r8, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf92:	f002 0307 	and.w	r3, r2, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    cf96:	ea09 0b08 	and.w	fp, r9, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf9a:	9301      	str	r3, [sp, #4]
	if (isr) {
    cf9c:	b12f      	cbz	r7, cfaa <_usb_d_dev_out_next+0x52>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cf9e:	0173      	lsls	r3, r6, #5
    cfa0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cfa4:	2101      	movs	r1, #1
    cfa6:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    cfaa:	0690      	lsls	r0, r2, #26
    cfac:	d50c      	bpl.n	cfc8 <_usb_d_dev_out_next+0x70>
    cfae:	6862      	ldr	r2, [r4, #4]
    cfb0:	b152      	cbz	r2, cfc8 <_usb_d_dev_out_next+0x70>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    cfb2:	68a0      	ldr	r0, [r4, #8]
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    cfb4:	6823      	ldr	r3, [r4, #0]
    cfb6:	68e1      	ldr	r1, [r4, #12]
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    cfb8:	1a12      	subs	r2, r2, r0
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    cfba:	b292      	uxth	r2, r2
    cfbc:	455a      	cmp	r2, fp
    cfbe:	4418      	add	r0, r3
    cfc0:	bf28      	it	cs
    cfc2:	465a      	movcs	r2, fp
    cfc4:	4b48      	ldr	r3, [pc, #288]	; (d0e8 <_usb_d_dev_out_next+0x190>)
    cfc6:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    cfc8:	6863      	ldr	r3, [r4, #4]
    cfca:	2b00      	cmp	r3, #0
    cfcc:	d132      	bne.n	d034 <_usb_d_dev_out_next+0xdc>
    cfce:	7ce2      	ldrb	r2, [r4, #19]
    cfd0:	06d1      	lsls	r1, r2, #27
    cfd2:	d52f      	bpl.n	d034 <_usb_d_dev_out_next+0xdc>
	bank->ADDR.reg          = addr;
    cfd4:	4845      	ldr	r0, [pc, #276]	; (d0ec <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    cfd6:	68e1      	ldr	r1, [r4, #12]
		ept->flags.bits.need_zlp  = 0;
    cfd8:	f022 0230 	bic.w	r2, r2, #48	; 0x30
	bank->ADDR.reg          = addr;
    cfdc:	4428      	add	r0, r5
		ept->flags.bits.need_zlp  = 0;
    cfde:	f042 0220 	orr.w	r2, r2, #32
    cfe2:	74e2      	strb	r2, [r4, #19]
	bank->ADDR.reg          = addr;
    cfe4:	f500 720c 	add.w	r2, r0, #560	; 0x230
    cfe8:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    cfec:	6851      	ldr	r1, [r2, #4]
    cfee:	8a20      	ldrh	r0, [r4, #16]
    cff0:	f360 319b 	bfi	r1, r0, #14, #14
    cff4:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    cff6:	6851      	ldr	r1, [r2, #4]
    cff8:	f363 010d 	bfi	r1, r3, #0, #14
    cffc:	6051      	str	r1, [r2, #4]
	if (!isr) {
    cffe:	b96f      	cbnz	r7, d01c <_usb_d_dev_out_next+0xc4>
		if (is_ctrl) {
    d000:	9b01      	ldr	r3, [sp, #4]
    d002:	2b01      	cmp	r3, #1
	bank->STATUS_BK.reg     = 0;
    d004:	bf04      	itt	eq
    d006:	4b39      	ldreq	r3, [pc, #228]	; (d0ec <_usb_d_dev_out_next+0x194>)
    d008:	195b      	addeq	r3, r3, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d00a:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d00e:	bf0a      	itet	eq
    d010:	f883 724a 	strbeq.w	r7, [r3, #586]	; 0x24a
			inten = USB_D_BANK0_INT_FLAGS;
    d014:	2325      	movne	r3, #37	; 0x25
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    d016:	232d      	moveq	r3, #45	; 0x2d
    d018:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d01c:	0176      	lsls	r6, r6, #5
    d01e:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
    d022:	2340      	movs	r3, #64	; 0x40
    d024:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
}
    d028:	b003      	add	sp, #12
    d02a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d02e:	468a      	mov	sl, r1
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d030:	4689      	mov	r9, r1
    d032:	e7a3      	b.n	cf7c <_usb_d_dev_out_next+0x24>
	} else if (isr && last_pkt < ept->size) {
    d034:	68a1      	ldr	r1, [r4, #8]
    d036:	b1ef      	cbz	r7, d074 <_usb_d_dev_out_next+0x11c>
    d038:	8a22      	ldrh	r2, [r4, #16]
    d03a:	455a      	cmp	r2, fp
    d03c:	d91a      	bls.n	d074 <_usb_d_dev_out_next+0x11c>
		ept->flags.bits.need_zlp = 0;
    d03e:	7ce3      	ldrb	r3, [r4, #19]
		ept->trans_count += last_trans;
    d040:	4449      	add	r1, r9
		ept->flags.bits.need_zlp = 0;
    d042:	f36f 1304 	bfc	r3, #4, #1
    d046:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    d048:	60a1      	str	r1, [r4, #8]
	if (is_ctrl) {
    d04a:	9b01      	ldr	r3, [sp, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d04c:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d050:	2b01      	cmp	r3, #1
    d052:	bf0c      	ite	eq
    d054:	232d      	moveq	r3, #45	; 0x2d
    d056:	2325      	movne	r3, #37	; 0x25
    d058:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
	if (0 == epn) {
    d05c:	b91e      	cbnz	r6, d066 <_usb_d_dev_out_next+0x10e>
	bank->ADDR.reg          = addr;
    d05e:	4b23      	ldr	r3, [pc, #140]	; (d0ec <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d060:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    d062:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d066:	4b22      	ldr	r3, [pc, #136]	; (d0f0 <_usb_d_dev_out_next+0x198>)
    d068:	2100      	movs	r1, #0
    d06a:	4620      	mov	r0, r4
}
    d06c:	b003      	add	sp, #12
    d06e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d072:	4718      	bx	r3
		ept->trans_count += trans_size;
    d074:	4451      	add	r1, sl
		if (ept->trans_count < ept->trans_size) {
    d076:	428b      	cmp	r3, r1
		ept->trans_count += trans_size;
    d078:	60a1      	str	r1, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    d07a:	d9e6      	bls.n	d04a <_usb_d_dev_out_next+0xf2>
			if (ept->flags.bits.use_cache) {
    d07c:	7ce0      	ldrb	r0, [r4, #19]
    d07e:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    d082:	4a1a      	ldr	r2, [pc, #104]	; (d0ec <_usb_d_dev_out_next+0x194>)
			trans_next = ept->trans_size - ept->trans_count;
    d084:	1a5b      	subs	r3, r3, r1
			if (ept->flags.bits.use_cache) {
    d086:	f010 0f20 	tst.w	r0, #32
			trans_next = ept->trans_size - ept->trans_count;
    d08a:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    d08c:	d014      	beq.n	d0b8 <_usb_d_dev_out_next+0x160>
	bank->ADDR.reg          = addr;
    d08e:	1951      	adds	r1, r2, r5
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d090:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    d092:	f8c1 0230 	str.w	r0, [r1, #560]	; 0x230
    d096:	4563      	cmp	r3, ip
    d098:	bf28      	it	cs
    d09a:	4663      	movcs	r3, ip
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d09c:	442a      	add	r2, r5
    d09e:	f8d2 1234 	ldr.w	r1, [r2, #564]	; 0x234
    d0a2:	f363 319b 	bfi	r1, r3, #14, #14
    d0a6:	f8c2 1234 	str.w	r1, [r2, #564]	; 0x234
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d0aa:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
    d0ae:	f36f 030d 	bfc	r3, #0, #14
    d0b2:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
			goto _out_rx_exec;
    d0b6:	e7a2      	b.n	cffe <_usb_d_dev_out_next+0xa6>
				if (trans_next > ept->size) {
    d0b8:	4563      	cmp	r3, ip
    d0ba:	d90a      	bls.n	d0d2 <_usb_d_dev_out_next+0x17a>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    d0bc:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    d0c0:	d80c      	bhi.n	d0dc <_usb_d_dev_out_next+0x184>
						trans_next -= trans_next & size_mask;
    d0c2:	ea23 0308 	bic.w	r3, r3, r8
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    d0c6:	6820      	ldr	r0, [r4, #0]
    d0c8:	4401      	add	r1, r0
	bank->ADDR.reg          = addr;
    d0ca:	1950      	adds	r0, r2, r5
    d0cc:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
}
    d0d0:	e7e4      	b.n	d09c <_usb_d_dev_out_next+0x144>
				} else if (trans_next < ept->size) {
    d0d2:	d2f8      	bcs.n	d0c6 <_usb_d_dev_out_next+0x16e>
					ept->flags.bits.use_cache = 1;
    d0d4:	f040 0020 	orr.w	r0, r0, #32
    d0d8:	74e0      	strb	r0, [r4, #19]
    d0da:	e7f4      	b.n	d0c6 <_usb_d_dev_out_next+0x16e>
						trans_next = USB_D_DEV_TRANS_MAX;
    d0dc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    d0e0:	e7f1      	b.n	d0c6 <_usb_d_dev_out_next+0x16e>
    d0e2:	bf00      	nop
    d0e4:	200087d8 	.word	0x200087d8
    d0e8:	00014335 	.word	0x00014335
    d0ec:	200085a8 	.word	0x200085a8
    d0f0:	0000cc49 	.word	0x0000cc49

0000d0f4 <_usb_d_dev_handler>:
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    d0f4:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
{
    d0f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    d0fc:	8c1f      	ldrh	r7, [r3, #32]
    d0fe:	4d69      	ldr	r5, [pc, #420]	; (d2a4 <_usb_d_dev_handler+0x1b0>)
    d100:	b2bf      	uxth	r7, r7
	if (0 == epint) {
    d102:	2f00      	cmp	r7, #0
    d104:	d163      	bne.n	d1ce <_usb_d_dev_handler+0xda>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    d106:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    d108:	8b1a      	ldrh	r2, [r3, #24]
    d10a:	b292      	uxth	r2, r2
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    d10c:	400a      	ands	r2, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    d10e:	f012 0004 	ands.w	r0, r2, #4
    d112:	d005      	beq.n	d120 <_usb_d_dev_handler+0x2c>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d114:	2204      	movs	r2, #4
    d116:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    d118:	682b      	ldr	r3, [r5, #0]
}
    d11a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.sof();
    d11e:	4718      	bx	r3
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    d120:	f412 7100 	ands.w	r1, r2, #512	; 0x200
    d124:	d01f      	beq.n	d166 <_usb_d_dev_handler+0x72>
    d126:	f240 2201 	movw	r2, #513	; 0x201
    d12a:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d12c:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d12e:	2270      	movs	r2, #112	; 0x70
    d130:	831a      	strh	r2, [r3, #24]
    d132:	4603      	mov	r3, r0
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    d134:	eb05 1243 	add.w	r2, r5, r3, lsl #5
    d138:	f502 700e 	add.w	r0, r2, #568	; 0x238
    d13c:	f8b2 2238 	ldrh.w	r2, [r2, #568]	; 0x238
    d140:	f002 020f 	and.w	r2, r2, #15
    d144:	2a03      	cmp	r2, #3
    d146:	d109      	bne.n	d15c <_usb_d_dev_handler+0x68>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d148:	8801      	ldrh	r1, [r0, #0]
			bank->EXTREG.reg = 0;
    d14a:	2300      	movs	r3, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d14c:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    d150:	8003      	strh	r3, [r0, #0]
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    d152:	686b      	ldr	r3, [r5, #4]
    d154:	2003      	movs	r0, #3
}
    d156:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d15a:	4718      	bx	r3
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    d15c:	3301      	adds	r3, #1
    d15e:	2b05      	cmp	r3, #5
    d160:	d1e8      	bne.n	d134 <_usb_d_dev_handler+0x40>
	uint32_t lpm_variable = 0;
    d162:	2100      	movs	r1, #0
    d164:	e7f5      	b.n	d152 <_usb_d_dev_handler+0x5e>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    d166:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    d16a:	d004      	beq.n	d176 <_usb_d_dev_handler+0x82>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d16c:	2280      	movs	r2, #128	; 0x80
    d16e:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    d170:	2005      	movs	r0, #5
    d172:	686b      	ldr	r3, [r5, #4]
    d174:	e7ef      	b.n	d156 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    d176:	f012 0470 	ands.w	r4, r2, #112	; 0x70
    d17a:	d00b      	beq.n	d194 <_usb_d_dev_handler+0xa0>
    d17c:	2270      	movs	r2, #112	; 0x70
    d17e:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d180:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d182:	f240 2201 	movw	r2, #513	; 0x201
    d186:	831a      	strh	r2, [r3, #24]
		_usb_d_dev_wait_dfll_rdy();
    d188:	4b47      	ldr	r3, [pc, #284]	; (d2a8 <_usb_d_dev_handler+0x1b4>)
    d18a:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    d18c:	686b      	ldr	r3, [r5, #4]
    d18e:	4601      	mov	r1, r0
    d190:	2002      	movs	r0, #2
    d192:	e7e0      	b.n	d156 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    d194:	f012 0108 	ands.w	r1, r2, #8
    d198:	d00e      	beq.n	d1b8 <_usb_d_dev_handler+0xc4>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d19a:	2208      	movs	r2, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d19c:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d1a0:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d1a2:	2270      	movs	r2, #112	; 0x70
    d1a4:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d1a6:	f240 2201 	movw	r2, #513	; 0x201
    d1aa:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    d1ac:	4b3f      	ldr	r3, [pc, #252]	; (d2ac <_usb_d_dev_handler+0x1b8>)
    d1ae:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    d1b0:	686b      	ldr	r3, [r5, #4]
    d1b2:	4621      	mov	r1, r4
    d1b4:	2001      	movs	r0, #1
    d1b6:	e7ce      	b.n	d156 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    d1b8:	07d0      	lsls	r0, r2, #31
    d1ba:	d508      	bpl.n	d1ce <_usb_d_dev_handler+0xda>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d1bc:	f240 2201 	movw	r2, #513	; 0x201
    d1c0:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d1c2:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d1c4:	2270      	movs	r2, #112	; 0x70
    d1c6:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d1c8:	2004      	movs	r0, #4
    d1ca:	686b      	ldr	r3, [r5, #4]
    d1cc:	e7c3      	b.n	d156 <_usb_d_dev_handler+0x62>
    d1ce:	4c35      	ldr	r4, [pc, #212]	; (d2a4 <_usb_d_dev_handler+0x1b0>)
			_usb_d_dev_handle_setup(ept);
    d1d0:	f8df 90e4 	ldr.w	r9, [pc, #228]	; d2b8 <_usb_d_dev_handler+0x1c4>
			_usb_d_dev_handle_trfail(ept, 1);
    d1d4:	f8df 80e4 	ldr.w	r8, [pc, #228]	; d2bc <_usb_d_dev_handler+0x1c8>
		_usb_d_dev_out_next(ept, true);
    d1d8:	f8df a0e4 	ldr.w	sl, [pc, #228]	; d2c0 <_usb_d_dev_handler+0x1cc>
	uint32_t lpm_variable = 0;
    d1dc:	2600      	movs	r6, #0
		if (ept->ep == 0xFF) {
    d1de:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
    d1e2:	2aff      	cmp	r2, #255	; 0xff
    d1e4:	f104 0414 	add.w	r4, r4, #20
    d1e8:	d029      	beq.n	d23e <_usb_d_dev_handler+0x14a>
	if (!(epint & (1u << epn))) {
    d1ea:	f002 020f 	and.w	r2, r2, #15
    d1ee:	2101      	movs	r1, #1
    d1f0:	fa01 f302 	lsl.w	r3, r1, r2
    d1f4:	423b      	tst	r3, r7
    d1f6:	d022      	beq.n	d23e <_usb_d_dev_handler+0x14a>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d1f8:	0153      	lsls	r3, r2, #5
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d1fa:	0152      	lsls	r2, r2, #5
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d1fc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d200:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d204:	f893 0107 	ldrb.w	r0, [r3, #263]	; 0x107
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d208:	f892 3109 	ldrb.w	r3, [r2, #265]	; 0x109
	if (flags) {
    d20c:	4003      	ands	r3, r0
    d20e:	d016      	beq.n	d23e <_usb_d_dev_handler+0x14a>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    d210:	2214      	movs	r2, #20
    d212:	fb02 5206 	mla	r2, r2, r6, r5
    d216:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
    d21a:	f002 0047 	and.w	r0, r2, #71	; 0x47
    d21e:	4288      	cmp	r0, r1
    d220:	d112      	bne.n	d248 <_usb_d_dev_handler+0x154>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d222:	06da      	lsls	r2, r3, #27
    d224:	d502      	bpl.n	d22c <_usb_d_dev_handler+0x138>
			_usb_d_dev_handle_setup(ept);
    d226:	4620      	mov	r0, r4
    d228:	47c8      	blx	r9
    d22a:	e008      	b.n	d23e <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d22c:	f013 0140 	ands.w	r1, r3, #64	; 0x40
    d230:	d003      	beq.n	d23a <_usb_d_dev_handler+0x146>
		_usb_d_dev_handle_stall(ept, 1);
    d232:	4601      	mov	r1, r0
		_usb_d_dev_handle_stall(ept, 0);
    d234:	4b1e      	ldr	r3, [pc, #120]	; (d2b0 <_usb_d_dev_handler+0x1bc>)
    d236:	4620      	mov	r0, r4
    d238:	e013      	b.n	d262 <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d23a:	069b      	lsls	r3, r3, #26
    d23c:	d4fa      	bmi.n	d234 <_usb_d_dev_handler+0x140>
	for (i = 0; i < USB_D_N_EP; i++) {
    d23e:	3601      	adds	r6, #1
    d240:	2e1b      	cmp	r6, #27
    d242:	d1cc      	bne.n	d1de <_usb_d_dev_handler+0xea>
}
    d244:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (_usb_d_dev_ep_is_in(ept)) {
    d248:	0610      	lsls	r0, r2, #24
    d24a:	d514      	bpl.n	d276 <_usb_d_dev_handler+0x182>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d24c:	0658      	lsls	r0, r3, #25
    d24e:	d4f1      	bmi.n	d234 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d250:	0718      	lsls	r0, r3, #28
    d252:	d502      	bpl.n	d25a <_usb_d_dev_handler+0x166>
			_usb_d_dev_handle_trfail(ept, 1);
    d254:	4620      	mov	r0, r4
    d256:	47c0      	blx	r8
    d258:	e7f1      	b.n	d23e <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    d25a:	0798      	lsls	r0, r3, #30
    d25c:	d503      	bpl.n	d266 <_usb_d_dev_handler+0x172>
		_usb_d_dev_in_next(ept, true);
    d25e:	4b15      	ldr	r3, [pc, #84]	; (d2b4 <_usb_d_dev_handler+0x1c0>)
    d260:	4620      	mov	r0, r4
		_usb_d_dev_handle_stall(ept, 0);
    d262:	4798      	blx	r3
    d264:	e7eb      	b.n	d23e <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d266:	f002 0207 	and.w	r2, r2, #7
    d26a:	2a01      	cmp	r2, #1
    d26c:	d1e7      	bne.n	d23e <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d26e:	075a      	lsls	r2, r3, #29
    d270:	d515      	bpl.n	d29e <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 0);
    d272:	2100      	movs	r1, #0
    d274:	e7ee      	b.n	d254 <_usb_d_dev_handler+0x160>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d276:	f013 0020 	ands.w	r0, r3, #32
    d27a:	d001      	beq.n	d280 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    d27c:	2100      	movs	r1, #0
    d27e:	e7d9      	b.n	d234 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d280:	0758      	lsls	r0, r3, #29
    d282:	d4f6      	bmi.n	d272 <_usb_d_dev_handler+0x17e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    d284:	07d8      	lsls	r0, r3, #31
    d286:	d502      	bpl.n	d28e <_usb_d_dev_handler+0x19a>
		_usb_d_dev_out_next(ept, true);
    d288:	4620      	mov	r0, r4
    d28a:	47d0      	blx	sl
    d28c:	e7d7      	b.n	d23e <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d28e:	f002 0207 	and.w	r2, r2, #7
    d292:	2a01      	cmp	r2, #1
    d294:	d1d3      	bne.n	d23e <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d296:	071a      	lsls	r2, r3, #28
    d298:	d501      	bpl.n	d29e <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 1);
    d29a:	2101      	movs	r1, #1
    d29c:	e7da      	b.n	d254 <_usb_d_dev_handler+0x160>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d29e:	06db      	lsls	r3, r3, #27
    d2a0:	d5cd      	bpl.n	d23e <_usb_d_dev_handler+0x14a>
    d2a2:	e7c0      	b.n	d226 <_usb_d_dev_handler+0x132>
    d2a4:	200085a8 	.word	0x200085a8
    d2a8:	0000cb59 	.word	0x0000cb59
    d2ac:	0000cdbd 	.word	0x0000cdbd
    d2b0:	0000cc19 	.word	0x0000cc19
    d2b4:	0000cdfd 	.word	0x0000cdfd
    d2b8:	0000cb95 	.word	0x0000cb95
    d2bc:	0000ccd5 	.word	0x0000ccd5
    d2c0:	0000cf59 	.word	0x0000cf59

0000d2c4 <_usbd_ep_pcksize_size>:
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    d2c4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    d2c8:	d80f      	bhi.n	d2ea <_usbd_ep_pcksize_size+0x26>
    d2ca:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    d2ce:	d80e      	bhi.n	d2ee <_usbd_ep_pcksize_size+0x2a>
    d2d0:	2880      	cmp	r0, #128	; 0x80
    d2d2:	d80e      	bhi.n	d2f2 <_usbd_ep_pcksize_size+0x2e>
    d2d4:	2840      	cmp	r0, #64	; 0x40
    d2d6:	d80e      	bhi.n	d2f6 <_usbd_ep_pcksize_size+0x32>
    d2d8:	2820      	cmp	r0, #32
    d2da:	d80e      	bhi.n	d2fa <_usbd_ep_pcksize_size+0x36>
    d2dc:	2810      	cmp	r0, #16
    d2de:	d80e      	bhi.n	d2fe <_usbd_ep_pcksize_size+0x3a>
    d2e0:	2808      	cmp	r0, #8
    d2e2:	bf94      	ite	ls
    d2e4:	2000      	movls	r0, #0
    d2e6:	2001      	movhi	r0, #1
    d2e8:	4770      	bx	lr
    d2ea:	2007      	movs	r0, #7
    d2ec:	4770      	bx	lr
    d2ee:	2006      	movs	r0, #6
    d2f0:	4770      	bx	lr
    d2f2:	2005      	movs	r0, #5
    d2f4:	4770      	bx	lr
    d2f6:	2004      	movs	r0, #4
    d2f8:	4770      	bx	lr
    d2fa:	2003      	movs	r0, #3
    d2fc:	4770      	bx	lr
    d2fe:	2002      	movs	r0, #2
}
    d300:	4770      	bx	lr
	...

0000d304 <_usb_d_dev_init>:
{
    d304:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    d306:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d30a:	789a      	ldrb	r2, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    d30c:	07d0      	lsls	r0, r2, #31
    d30e:	d41a      	bmi.n	d346 <_usb_d_dev_init+0x42>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d310:	789a      	ldrb	r2, [r3, #2]
    d312:	0791      	lsls	r1, r2, #30
    d314:	d1fc      	bne.n	d310 <_usb_d_dev_init+0xc>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    d316:	781a      	ldrb	r2, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    d318:	0792      	lsls	r2, r2, #30
    d31a:	d50d      	bpl.n	d338 <_usb_d_dev_init+0x34>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    d31c:	781a      	ldrb	r2, [r3, #0]
    d31e:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    d322:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d324:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d328:	7893      	ldrb	r3, [r2, #2]
    d32a:	0798      	lsls	r0, r3, #30
    d32c:	d1fc      	bne.n	d328 <_usb_d_dev_init+0x24>
    d32e:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d332:	7893      	ldrb	r3, [r2, #2]
    d334:	0799      	lsls	r1, r3, #30
    d336:	d4fc      	bmi.n	d332 <_usb_d_dev_init+0x2e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d338:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d33c:	2201      	movs	r2, #1
    d33e:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d340:	789a      	ldrb	r2, [r3, #2]
    d342:	0792      	lsls	r2, r2, #30
    d344:	d1fc      	bne.n	d340 <_usb_d_dev_init+0x3c>
    d346:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d34a:	7893      	ldrb	r3, [r2, #2]
    d34c:	07db      	lsls	r3, r3, #31
    d34e:	d4fc      	bmi.n	d34a <_usb_d_dev_init+0x46>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    d350:	4a1e      	ldr	r2, [pc, #120]	; (d3cc <_usb_d_dev_init+0xc8>)
    d352:	4b1f      	ldr	r3, [pc, #124]	; (d3d0 <_usb_d_dev_init+0xcc>)
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    d354:	e9c3 2200 	strd	r2, r2, [r3]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    d358:	e9c3 2202 	strd	r2, r2, [r3, #8]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    d35c:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    d35e:	4b1d      	ldr	r3, [pc, #116]	; (d3d4 <_usb_d_dev_init+0xd0>)
    d360:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    d362:	4b1d      	ldr	r3, [pc, #116]	; (d3d8 <_usb_d_dev_init+0xd4>)
    d364:	681a      	ldr	r2, [r3, #0]
	uint32_t pad_transp
    d366:	f3c2 1344 	ubfx	r3, r2, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    d36a:	f3c2 2182 	ubfx	r1, r2, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    d36e:	f012 021f 	ands.w	r2, r2, #31
    d372:	d025      	beq.n	d3c0 <_usb_d_dev_init+0xbc>
		pad_transn = 9;
    d374:	2a1f      	cmp	r2, #31
    d376:	bf08      	it	eq
    d378:	2209      	moveq	r2, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    d37a:	b31b      	cbz	r3, d3c4 <_usb_d_dev_init+0xc0>
		pad_transp = 25;
    d37c:	2b1f      	cmp	r3, #31
    d37e:	bf08      	it	eq
    d380:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    d382:	b309      	cbz	r1, d3c8 <_usb_d_dev_init+0xc4>
		pad_trim = 6;
    d384:	2907      	cmp	r1, #7
    d386:	bf08      	it	eq
    d388:	2106      	moveq	r1, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    d38a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    d38e:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    d392:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d396:	b29b      	uxth	r3, r3
    d398:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    d39a:	78d3      	ldrb	r3, [r2, #3]
    d39c:	f043 0303 	orr.w	r3, r3, #3
    d3a0:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    d3a2:	78d3      	ldrb	r3, [r2, #3]
    d3a4:	f043 030c 	orr.w	r3, r3, #12
    d3a8:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d3aa:	2304      	movs	r3, #4
    d3ac:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d3ae:	7890      	ldrb	r0, [r2, #2]
    d3b0:	f010 0003 	ands.w	r0, r0, #3
    d3b4:	d1fb      	bne.n	d3ae <_usb_d_dev_init+0xaa>
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    d3b6:	4b09      	ldr	r3, [pc, #36]	; (d3dc <_usb_d_dev_init+0xd8>)
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    d3b8:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    d3ba:	2301      	movs	r3, #1
    d3bc:	8113      	strh	r3, [r2, #8]
}
    d3be:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    d3c0:	2209      	movs	r2, #9
    d3c2:	e7da      	b.n	d37a <_usb_d_dev_init+0x76>
		pad_transp = 25;
    d3c4:	2319      	movs	r3, #25
    d3c6:	e7dc      	b.n	d382 <_usb_d_dev_init+0x7e>
		pad_trim = 6;
    d3c8:	2106      	movs	r1, #6
    d3ca:	e7de      	b.n	d38a <_usb_d_dev_init+0x86>
    d3cc:	0000cb55 	.word	0x0000cb55
    d3d0:	200085a8 	.word	0x200085a8
    d3d4:	0000cdbd 	.word	0x0000cdbd
    d3d8:	00800084 	.word	0x00800084
    d3dc:	200087d8 	.word	0x200087d8

0000d3e0 <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    d3e0:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d3e4:	789a      	ldrb	r2, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    d3e6:	0792      	lsls	r2, r2, #30
    d3e8:	d122      	bne.n	d430 <_usb_d_dev_enable+0x50>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d3ea:	789a      	ldrb	r2, [r3, #2]
    d3ec:	0790      	lsls	r0, r2, #30
    d3ee:	d1fc      	bne.n	d3ea <_usb_d_dev_enable+0xa>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    d3f0:	7819      	ldrb	r1, [r3, #0]
    d3f2:	b2ca      	uxtb	r2, r1
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    d3f4:	0789      	lsls	r1, r1, #30
    d3f6:	d407      	bmi.n	d408 <_usb_d_dev_enable+0x28>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    d3f8:	f042 0202 	orr.w	r2, r2, #2
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d3fc:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d3fe:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d402:	7893      	ldrb	r3, [r2, #2]
    d404:	079b      	lsls	r3, r3, #30
    d406:	d1fc      	bne.n	d402 <_usb_d_dev_enable+0x22>
    d408:	4b0b      	ldr	r3, [pc, #44]	; (d438 <_usb_d_dev_enable+0x58>)
    d40a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    d40e:	609a      	str	r2, [r3, #8]
    d410:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    d414:	609a      	str	r2, [r3, #8]
    d416:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    d41a:	609a      	str	r2, [r3, #8]
    d41c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    d420:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d422:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d426:	f240 228d 	movw	r2, #653	; 0x28d
    d42a:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    d42c:	2000      	movs	r0, #0
    d42e:	4770      	bx	lr
		return -USB_ERR_DENIED;
    d430:	f06f 0010 	mvn.w	r0, #16
}
    d434:	4770      	bx	lr
    d436:	bf00      	nop
    d438:	e000e100 	.word	0xe000e100

0000d43c <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    d43c:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d440:	8913      	ldrh	r3, [r2, #8]
    d442:	f023 0301 	bic.w	r3, r3, #1
    d446:	041b      	lsls	r3, r3, #16
    d448:	0c1b      	lsrs	r3, r3, #16
    d44a:	8113      	strh	r3, [r2, #8]
}
    d44c:	4770      	bx	lr

0000d44e <_usb_d_dev_set_address>:
	((Usb *)hw)->DEVICE.DADD.reg = data;
    d44e:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    d452:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    d456:	7298      	strb	r0, [r3, #10]
}
    d458:	4770      	bx	lr

0000d45a <_usb_d_dev_get_frame_n>:
	return (((Usb *)hw)->DEVICE.FNUM.reg & USB_DEVICE_FNUM_FNUM_Msk) >> USB_DEVICE_FNUM_FNUM_Pos;
    d45a:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d45e:	8a18      	ldrh	r0, [r3, #16]
}
    d460:	f3c0 00ca 	ubfx	r0, r0, #3, #11
    d464:	4770      	bx	lr
	...

0000d468 <_usb_d_dev_ep_init>:
{
    d468:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d46c:	f000 040f 	and.w	r4, r0, #15
{
    d470:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d472:	f8df 90b0 	ldr.w	r9, [pc, #176]	; d524 <_usb_d_dev_ep_init+0xbc>
    d476:	09c1      	lsrs	r1, r0, #7
{
    d478:	4607      	mov	r7, r0
    d47a:	fa4f f880 	sxtb.w	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d47e:	4620      	mov	r0, r4
    d480:	47c8      	blx	r9
	if (epn > CONF_USB_D_MAX_EP_N) {
    d482:	2c05      	cmp	r4, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d484:	4606      	mov	r6, r0
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    d486:	f005 0503 	and.w	r5, r5, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d48a:	d83f      	bhi.n	d50c <_usb_d_dev_ep_init+0xa4>
	if (ept->ep != 0xFF) {
    d48c:	7c83      	ldrb	r3, [r0, #18]
    d48e:	2bff      	cmp	r3, #255	; 0xff
    d490:	d13f      	bne.n	d512 <_usb_d_dev_ep_init+0xaa>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    d492:	b985      	cbnz	r5, d4b6 <_usb_d_dev_ep_init+0x4e>
		struct _usb_d_dev_ep *ept_in = _usb_d_dev_ept(epn, !dir);
    d494:	ea6f 0108 	mvn.w	r1, r8
    d498:	0fc9      	lsrs	r1, r1, #31
    d49a:	4620      	mov	r0, r4
    d49c:	47c8      	blx	r9
		if (ept_in->ep != 0xFF) {
    d49e:	7c83      	ldrb	r3, [r0, #18]
    d4a0:	2bff      	cmp	r3, #255	; 0xff
    d4a2:	d136      	bne.n	d512 <_usb_d_dev_ep_init+0xaa>
		if (pcfg->cache == NULL) {
    d4a4:	230c      	movs	r3, #12
    d4a6:	491e      	ldr	r1, [pc, #120]	; (d520 <_usb_d_dev_ep_init+0xb8>)
    d4a8:	4363      	muls	r3, r4
    d4aa:	58cb      	ldr	r3, [r1, r3]
    d4ac:	2b00      	cmp	r3, #0
    d4ae:	d133      	bne.n	d518 <_usb_d_dev_ep_init+0xb0>
			return -USB_ERR_FUNC;
    d4b0:	f06f 0012 	mvn.w	r0, #18
    d4b4:	e018      	b.n	d4e8 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d4b6:	f1b8 0f00 	cmp.w	r8, #0
    d4ba:	da17      	bge.n	d4ec <_usb_d_dev_ep_init+0x84>
    d4bc:	4918      	ldr	r1, [pc, #96]	; (d520 <_usb_d_dev_ep_init+0xb8>)
    d4be:	230c      	movs	r3, #12
    d4c0:	fb03 1304 	mla	r3, r3, r4, r1
    d4c4:	6859      	ldr	r1, [r3, #4]
    d4c6:	b9e9      	cbnz	r1, d504 <_usb_d_dev_ep_init+0x9c>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d4c8:	4915      	ldr	r1, [pc, #84]	; (d520 <_usb_d_dev_ep_init+0xb8>)
	ept->size     = max_pkt_siz;
    d4ca:	8232      	strh	r2, [r6, #16]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d4cc:	230c      	movs	r3, #12
    d4ce:	435c      	muls	r4, r3
    d4d0:	190b      	adds	r3, r1, r4
    d4d2:	5909      	ldr	r1, [r1, r4]
    d4d4:	685b      	ldr	r3, [r3, #4]
	ept->ep       = ep;
    d4d6:	74b7      	strb	r7, [r6, #18]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d4d8:	ea13 0328 	ands.w	r3, r3, r8, asr #32
    d4dc:	bf38      	it	cc
    d4de:	460b      	movcc	r3, r1
	ept->flags.u8 = (ep_type + 1);
    d4e0:	3501      	adds	r5, #1
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d4e2:	60f3      	str	r3, [r6, #12]
	ept->flags.u8 = (ep_type + 1);
    d4e4:	74f5      	strb	r5, [r6, #19]
	return USB_OK;
    d4e6:	2000      	movs	r0, #0
}
    d4e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d4ec:	230c      	movs	r3, #12
    d4ee:	490c      	ldr	r1, [pc, #48]	; (d520 <_usb_d_dev_ep_init+0xb8>)
    d4f0:	4363      	muls	r3, r4
    d4f2:	58cb      	ldr	r3, [r1, r3]
    d4f4:	2b00      	cmp	r3, #0
    d4f6:	d0e7      	beq.n	d4c8 <_usb_d_dev_ep_init+0x60>
    d4f8:	4909      	ldr	r1, [pc, #36]	; (d520 <_usb_d_dev_ep_init+0xb8>)
    d4fa:	230c      	movs	r3, #12
    d4fc:	fb03 1304 	mla	r3, r3, r4, r1
    d500:	891b      	ldrh	r3, [r3, #8]
    d502:	e000      	b.n	d506 <_usb_d_dev_ep_init+0x9e>
    d504:	895b      	ldrh	r3, [r3, #10]
    d506:	429a      	cmp	r2, r3
    d508:	ddde      	ble.n	d4c8 <_usb_d_dev_ep_init+0x60>
    d50a:	e7d1      	b.n	d4b0 <_usb_d_dev_ep_init+0x48>
		return -USB_ERR_PARAM;
    d50c:	f06f 0011 	mvn.w	r0, #17
    d510:	e7ea      	b.n	d4e8 <_usb_d_dev_ep_init+0x80>
		return -USB_ERR_REDO;
    d512:	f06f 0013 	mvn.w	r0, #19
    d516:	e7e7      	b.n	d4e8 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d518:	f1b8 0f00 	cmp.w	r8, #0
    d51c:	daec      	bge.n	d4f8 <_usb_d_dev_ep_init+0x90>
    d51e:	e7cd      	b.n	d4bc <_usb_d_dev_ep_init+0x54>
    d520:	00017294 	.word	0x00017294
    d524:	0000cb7d 	.word	0x0000cb7d

0000d528 <_usb_d_dev_ep_deinit>:
{
    d528:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d52a:	f000 050f 	and.w	r5, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d52e:	2d05      	cmp	r5, #5
{
    d530:	4604      	mov	r4, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d532:	d818      	bhi.n	d566 <_usb_d_dev_ep_deinit+0x3e>
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d534:	4b17      	ldr	r3, [pc, #92]	; (d594 <_usb_d_dev_ep_deinit+0x6c>)
	bool                  dir = USB_EP_GET_DIR(ep);
    d536:	09c1      	lsrs	r1, r0, #7
    d538:	b247      	sxtb	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d53a:	4628      	mov	r0, r5
    d53c:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d53e:	7c83      	ldrb	r3, [r0, #18]
    d540:	2bff      	cmp	r3, #255	; 0xff
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d542:	4606      	mov	r6, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d544:	d00f      	beq.n	d566 <_usb_d_dev_ep_deinit+0x3e>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    d546:	4b14      	ldr	r3, [pc, #80]	; (d598 <_usb_d_dev_ep_deinit+0x70>)
    d548:	2203      	movs	r2, #3
    d54a:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d54c:	7cf3      	ldrb	r3, [r6, #19]
    d54e:	f003 0307 	and.w	r3, r3, #7
    d552:	2b01      	cmp	r3, #1
    d554:	d108      	bne.n	d568 <_usb_d_dev_ep_deinit+0x40>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    d556:	0164      	lsls	r4, r4, #5
    d558:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d55c:	2300      	movs	r3, #0
    d55e:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	ept->ep       = 0xFF;
    d562:	23ff      	movs	r3, #255	; 0xff
    d564:	8273      	strh	r3, [r6, #18]
}
    d566:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (USB_EP_GET_DIR(ep)) {
    d568:	2f00      	cmp	r7, #0
    d56a:	da09      	bge.n	d580 <_usb_d_dev_ep_deinit+0x58>
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    d56c:	016b      	lsls	r3, r5, #5
    d56e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d572:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    d576:	f002 028f 	and.w	r2, r2, #143	; 0x8f
    d57a:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    d57e:	e7f0      	b.n	d562 <_usb_d_dev_ep_deinit+0x3a>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    d580:	0164      	lsls	r4, r4, #5
    d582:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d586:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
    d58a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    d58e:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
    d592:	e7e6      	b.n	d562 <_usb_d_dev_ep_deinit+0x3a>
    d594:	0000cb7d 	.word	0x0000cb7d
    d598:	0000cc75 	.word	0x0000cc75

0000d59c <_usb_d_dev_ep_enable>:
{
    d59c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    d5a0:	f000 050f 	and.w	r5, r0, #15
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d5a4:	09c1      	lsrs	r1, r0, #7
    d5a6:	4b55      	ldr	r3, [pc, #340]	; (d6fc <_usb_d_dev_ep_enable+0x160>)
    d5a8:	fa4f f980 	sxtb.w	r9, r0
    d5ac:	4628      	mov	r0, r5
    d5ae:	4798      	blx	r3
    d5b0:	ea4f 1c45 	mov.w	ip, r5, lsl #5
    d5b4:	f10c 4682 	add.w	r6, ip, #1090519040	; 0x41000000
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d5b8:	2d05      	cmp	r5, #5
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d5ba:	f896 1100 	ldrb.w	r1, [r6, #256]	; 0x100
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d5be:	4607      	mov	r7, r0
    d5c0:	b2c8      	uxtb	r0, r1
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d5c2:	f200 8094 	bhi.w	d6ee <_usb_d_dev_ep_enable+0x152>
    d5c6:	7cba      	ldrb	r2, [r7, #18]
    d5c8:	2aff      	cmp	r2, #255	; 0xff
    d5ca:	f000 8090 	beq.w	d6ee <_usb_d_dev_ep_enable+0x152>
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d5ce:	7cf9      	ldrb	r1, [r7, #19]
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d5d0:	4c4b      	ldr	r4, [pc, #300]	; (d700 <_usb_d_dev_ep_enable+0x164>)
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d5d2:	f001 0307 	and.w	r3, r1, #7
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d5d6:	f504 780c 	add.w	r8, r4, #560	; 0x230
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d5da:	2b01      	cmp	r3, #1
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d5dc:	44e0      	add	r8, ip
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d5de:	d147      	bne.n	d670 <_usb_d_dev_ep_enable+0xd4>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    d5e0:	f010 0377 	ands.w	r3, r0, #119	; 0x77
    d5e4:	f040 8086 	bne.w	d6f4 <_usb_d_dev_ep_enable+0x158>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d5e8:	f8b7 9010 	ldrh.w	r9, [r7, #16]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d5ec:	2111      	movs	r1, #17
    d5ee:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d5f2:	4648      	mov	r0, r9
    d5f4:	4943      	ldr	r1, [pc, #268]	; (d704 <_usb_d_dev_ep_enable+0x168>)
    d5f6:	4788      	blx	r1
    d5f8:	0700      	lsls	r0, r0, #28
    d5fa:	f000 41e0 	and.w	r1, r0, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d5fe:	4842      	ldr	r0, [pc, #264]	; (d708 <_usb_d_dev_ep_enable+0x16c>)
    d600:	ea00 3089 	and.w	r0, r0, r9, lsl #14
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d604:	f3c9 090d 	ubfx	r9, r9, #0, #14
	bank->STATUS_BK.reg     = 0;
    d608:	eb04 1545 	add.w	r5, r4, r5, lsl #5
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d60c:	4308      	orrs	r0, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d60e:	f002 020f 	and.w	r2, r2, #15
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d612:	ea49 0101 	orr.w	r1, r9, r1
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d616:	f8c8 0004 	str.w	r0, [r8, #4]
	bank->ADDR.reg          = addr;
    d61a:	eb04 1442 	add.w	r4, r4, r2, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d61e:	f8c8 1014 	str.w	r1, [r8, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d622:	f04f 0c40 	mov.w	ip, #64	; 0x40
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d626:	2180      	movs	r1, #128	; 0x80
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d628:	f886 c105 	strb.w	ip, [r6, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d62c:	f886 1104 	strb.w	r1, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d630:	f885 323a 	strb.w	r3, [r5, #570]	; 0x23a
    d634:	f885 324a 	strb.w	r3, [r5, #586]	; 0x24a
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d638:	68fd      	ldr	r5, [r7, #12]
	bank->ADDR.reg          = addr;
    d63a:	f8c4 5230 	str.w	r5, [r4, #560]	; 0x230
    d63e:	f504 710c 	add.w	r1, r4, #560	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d642:	f8d4 4234 	ldr.w	r4, [r4, #564]	; 0x234
    d646:	f369 349b 	bfi	r4, r9, #14, #14
    d64a:	604c      	str	r4, [r1, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d64c:	684c      	ldr	r4, [r1, #4]
	bank->ADDR.reg          = addr;
    d64e:	0150      	lsls	r0, r2, #5
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d650:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    d654:	f363 040d 	bfi	r4, r3, #0, #14
    d658:	604c      	str	r4, [r1, #4]
    d65a:	21b0      	movs	r1, #176	; 0xb0
    d65c:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d660:	2110      	movs	r1, #16
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d662:	f882 c105 	strb.w	ip, [r2, #261]	; 0x105
	return USB_OK;
    d666:	4618      	mov	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d668:	f882 1109 	strb.w	r1, [r2, #265]	; 0x109
}
    d66c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (dir) {
    d670:	f1b9 0f00 	cmp.w	r9, #0
    d674:	da1e      	bge.n	d6b4 <_usb_d_dev_ep_enable+0x118>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    d676:	f010 0270 	ands.w	r2, r0, #112	; 0x70
    d67a:	d13b      	bne.n	d6f4 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    d67c:	f3c1 0102 	ubfx	r1, r1, #0, #3
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d680:	8a3b      	ldrh	r3, [r7, #16]
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    d682:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
    d686:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d688:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d68c:	4618      	mov	r0, r3
    d68e:	491d      	ldr	r1, [pc, #116]	; (d704 <_usb_d_dev_ep_enable+0x168>)
    d690:	4788      	blx	r1
    d692:	0700      	lsls	r0, r0, #28
    d694:	f3c3 030d 	ubfx	r3, r3, #0, #14
    d698:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
	bank->STATUS_BK.reg     = 0;
    d69c:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d6a0:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d6a2:	2380      	movs	r3, #128	; 0x80
    d6a4:	f8c8 0014 	str.w	r0, [r8, #20]
    d6a8:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d6ac:	f884 224a 	strb.w	r2, [r4, #586]	; 0x24a
	return USB_OK;
    d6b0:	4610      	mov	r0, r2
}
    d6b2:	e7db      	b.n	d66c <_usb_d_dev_ep_enable+0xd0>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    d6b4:	f010 0207 	ands.w	r2, r0, #7
    d6b8:	d11c      	bne.n	d6f4 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    d6ba:	f001 0107 	and.w	r1, r1, #7
    d6be:	4301      	orrs	r1, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d6c0:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d6c4:	8a39      	ldrh	r1, [r7, #16]
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d6c6:	4b0f      	ldr	r3, [pc, #60]	; (d704 <_usb_d_dev_ep_enable+0x168>)
    d6c8:	4608      	mov	r0, r1
    d6ca:	4798      	blx	r3
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d6cc:	4b0e      	ldr	r3, [pc, #56]	; (d708 <_usb_d_dev_ep_enable+0x16c>)
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d6ce:	0700      	lsls	r0, r0, #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d6d0:	ea03 3381 	and.w	r3, r3, r1, lsl #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d6d4:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    d6d8:	4303      	orrs	r3, r0
	bank->STATUS_BK.reg     = 0;
    d6da:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d6de:	f8c8 3004 	str.w	r3, [r8, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d6e2:	2340      	movs	r3, #64	; 0x40
    d6e4:	f886 3105 	strb.w	r3, [r6, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    d6e8:	f884 223a 	strb.w	r2, [r4, #570]	; 0x23a
    d6ec:	e7e0      	b.n	d6b0 <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    d6ee:	f06f 0011 	mvn.w	r0, #17
    d6f2:	e7bb      	b.n	d66c <_usb_d_dev_ep_enable+0xd0>
			return -USB_ERR_REDO;
    d6f4:	f06f 0013 	mvn.w	r0, #19
    d6f8:	e7b8      	b.n	d66c <_usb_d_dev_ep_enable+0xd0>
    d6fa:	bf00      	nop
    d6fc:	0000cb7d 	.word	0x0000cb7d
    d700:	200085a8 	.word	0x200085a8
    d704:	0000d2c5 	.word	0x0000d2c5
    d708:	0fffc000 	.word	0x0fffc000

0000d70c <_usb_d_dev_ep_stall>:
{
    d70c:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d70e:	f000 020f 	and.w	r2, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    d712:	09c4      	lsrs	r4, r0, #7
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d714:	4b2f      	ldr	r3, [pc, #188]	; (d7d4 <_usb_d_dev_ep_stall+0xc8>)
{
    d716:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d718:	4610      	mov	r0, r2
    d71a:	4621      	mov	r1, r4
    d71c:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d71e:	2a05      	cmp	r2, #5
    d720:	d855      	bhi.n	d7ce <_usb_d_dev_ep_stall+0xc2>
	if (USB_EP_STALL_SET == ctrl) {
    d722:	7c83      	ldrb	r3, [r0, #18]
    d724:	2210      	movs	r2, #16
    d726:	2d01      	cmp	r5, #1
    d728:	f003 030f 	and.w	r3, r3, #15
    d72c:	fa02 f204 	lsl.w	r2, r2, r4
    d730:	d113      	bne.n	d75a <_usb_d_dev_ep_stall+0x4e>
    d732:	0159      	lsls	r1, r3, #5
    d734:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d738:	b2d2      	uxtb	r2, r2
    d73a:	f881 2105 	strb.w	r2, [r1, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d73e:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    d740:	2120      	movs	r1, #32
    d742:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d746:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    d748:	b2c9      	uxtb	r1, r1
    d74a:	f883 1109 	strb.w	r1, [r3, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    d74e:	7cc3      	ldrb	r3, [r0, #19]
    d750:	f043 0308 	orr.w	r3, r3, #8
    d754:	74c3      	strb	r3, [r0, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    d756:	2000      	movs	r0, #0
}
    d758:	bd38      	pop	{r3, r4, r5, pc}
	} else if (USB_EP_STALL_CLR == ctrl) {
    d75a:	bb6d      	cbnz	r5, d7b8 <_usb_d_dev_ep_stall+0xac>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    d75c:	015d      	lsls	r5, r3, #5
    d75e:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d762:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
	if (!is_stalled) {
    d766:	4211      	tst	r1, r2
    d768:	d0f5      	beq.n	d756 <_usb_d_dev_ep_stall+0x4a>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d76a:	b2d2      	uxtb	r2, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d76c:	f885 2104 	strb.w	r2, [r5, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d770:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    d772:	2220      	movs	r2, #32
    d774:	40a2      	lsls	r2, r4
    d776:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    d77a:	b2d1      	uxtb	r1, r2
    d77c:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    d780:	f895 3107 	ldrb.w	r3, [r5, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    d784:	4213      	tst	r3, r2
    d786:	d006      	beq.n	d796 <_usb_d_dev_ep_stall+0x8a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d788:	f885 1107 	strb.w	r1, [r5, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    d78c:	2101      	movs	r1, #1
    d78e:	40a1      	lsls	r1, r4
    d790:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d792:	f885 1104 	strb.w	r1, [r5, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d796:	7cc2      	ldrb	r2, [r0, #19]
    d798:	f002 0307 	and.w	r3, r2, #7
    d79c:	2b01      	cmp	r3, #1
    d79e:	d108      	bne.n	d7b2 <_usb_d_dev_ep_stall+0xa6>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    d7a0:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    d7a4:	f013 0330 	ands.w	r3, r3, #48	; 0x30
    d7a8:	d1d5      	bne.n	d756 <_usb_d_dev_ep_stall+0x4a>
			ept->flags.bits.is_stalled = 0;
    d7aa:	f363 02c3 	bfi	r2, r3, #3, #1
		ept->flags.bits.is_stalled = 0;
    d7ae:	74c2      	strb	r2, [r0, #19]
    d7b0:	e7d1      	b.n	d756 <_usb_d_dev_ep_stall+0x4a>
    d7b2:	f36f 02c3 	bfc	r2, #3, #1
    d7b6:	e7fa      	b.n	d7ae <_usb_d_dev_ep_stall+0xa2>
    d7b8:	015b      	lsls	r3, r3, #5
    d7ba:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d7be:	f503 7380 	add.w	r3, r3, #256	; 0x100
    d7c2:	799b      	ldrb	r3, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d7c4:	4213      	tst	r3, r2
    d7c6:	bf14      	ite	ne
    d7c8:	2001      	movne	r0, #1
    d7ca:	2000      	moveq	r0, #0
    d7cc:	e7c4      	b.n	d758 <_usb_d_dev_ep_stall+0x4c>
		return -USB_ERR_PARAM;
    d7ce:	f06f 0011 	mvn.w	r0, #17
    d7d2:	e7c1      	b.n	d758 <_usb_d_dev_ep_stall+0x4c>
    d7d4:	0000cb7d 	.word	0x0000cb7d

0000d7d8 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    d7d8:	b570      	push	{r4, r5, r6, lr}
	uint8_t            epn   = USB_EP_GET_N(ep);
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    d7da:	4b13      	ldr	r3, [pc, #76]	; (d828 <_usb_d_dev_ep_read_req+0x50>)
	uint8_t            epn   = USB_EP_GET_N(ep);
    d7dc:	f000 060f 	and.w	r6, r0, #15
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    d7e0:	0172      	lsls	r2, r6, #5
    d7e2:	eb03 1046 	add.w	r0, r3, r6, lsl #5
	uint32_t           addr  = bank[0].ADDR.reg;
    d7e6:	589d      	ldr	r5, [r3, r2]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    d7e8:	6844      	ldr	r4, [r0, #4]

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    d7ea:	2e05      	cmp	r6, #5
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    d7ec:	f3c4 040d 	ubfx	r4, r4, #0, #14
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    d7f0:	d814      	bhi.n	d81c <_usb_d_dev_ep_read_req+0x44>
    d7f2:	b199      	cbz	r1, d81c <_usb_d_dev_ep_read_req+0x44>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d7f4:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d7f8:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    d7fc:	2b11      	cmp	r3, #17
    d7fe:	d110      	bne.n	d822 <_usb_d_dev_ep_read_req+0x4a>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    d800:	f892 3107 	ldrb.w	r3, [r2, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    d804:	f013 0010 	ands.w	r0, r3, #16
    d808:	d007      	beq.n	d81a <_usb_d_dev_ep_read_req+0x42>
		return ERR_NONE;
	}
	memcpy(req_buf, (void *)addr, 8);
    d80a:	682b      	ldr	r3, [r5, #0]
    d80c:	600b      	str	r3, [r1, #0]
    d80e:	686b      	ldr	r3, [r5, #4]
    d810:	604b      	str	r3, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d812:	2310      	movs	r3, #16
    d814:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	_usbd_ep_ack_setup(epn);

	return bytes;
    d818:	4620      	mov	r0, r4
}
    d81a:	bd70      	pop	{r4, r5, r6, pc}
		return -USB_ERR_PARAM;
    d81c:	f06f 0011 	mvn.w	r0, #17
    d820:	e7fb      	b.n	d81a <_usb_d_dev_ep_read_req+0x42>
		return -USB_ERR_FUNC;
    d822:	f06f 0012 	mvn.w	r0, #18
    d826:	e7f8      	b.n	d81a <_usb_d_dev_ep_read_req+0x42>
    d828:	200087d8 	.word	0x200087d8

0000d82c <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    d82c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    d830:	f890 9008 	ldrb.w	r9, [r0, #8]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d834:	4b39      	ldr	r3, [pc, #228]	; (d91c <_usb_d_dev_ep_trans+0xf0>)
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    d836:	f009 050f 	and.w	r5, r9, #15
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    d83a:	fa4f f789 	sxtb.w	r7, r9
    d83e:	ea4f 19d9 	mov.w	r9, r9, lsr #7
{
    d842:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d844:	4649      	mov	r1, r9
    d846:	4628      	mov	r0, r5
    d848:	4798      	blx	r3

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d84a:	8a02      	ldrh	r2, [r0, #16]
	bool     size_n_aligned = (trans->size & size_mask);
    d84c:	f8d8 1004 	ldr.w	r1, [r8, #4]
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d850:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d854:	429a      	cmp	r2, r3
    d856:	bf1a      	itte	ne
    d858:	f102 33ff 	addne.w	r3, r2, #4294967295	; 0xffffffff
    d85c:	b29b      	uxthne	r3, r3
    d85e:	4613      	moveq	r3, r2

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    d860:	2d05      	cmp	r5, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d862:	4604      	mov	r4, r0
	bool     size_n_aligned = (trans->size & size_mask);
    d864:	ea03 0601 	and.w	r6, r3, r1
	if (epn > CONF_USB_D_MAX_EP_N) {
    d868:	d828      	bhi.n	d8bc <_usb_d_dev_ep_trans+0x90>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    d86a:	f8d8 5000 	ldr.w	r5, [r8]
    d86e:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
    d872:	d30a      	bcc.n	d88a <_usb_d_dev_ep_trans+0x5e>
    d874:	4b2a      	ldr	r3, [pc, #168]	; (d920 <_usb_d_dev_ep_trans+0xf4>)
    d876:	1948      	adds	r0, r1, r5
    d878:	4298      	cmp	r0, r3
    d87a:	d206      	bcs.n	d88a <_usb_d_dev_ep_trans+0x5e>
    d87c:	f015 0503 	ands.w	r5, r5, #3
    d880:	d103      	bne.n	d88a <_usb_d_dev_ep_trans+0x5e>
	    || (!dir && (trans->size < ept->size))) {
    d882:	2f00      	cmp	r7, #0
    d884:	db05      	blt.n	d892 <_usb_d_dev_ep_trans+0x66>
    d886:	4291      	cmp	r1, r2
    d888:	d214      	bcs.n	d8b4 <_usb_d_dev_ep_trans+0x88>
		if (!ept->cache) {
    d88a:	68e3      	ldr	r3, [r4, #12]
    d88c:	2b00      	cmp	r3, #0
    d88e:	d03f      	beq.n	d910 <_usb_d_dev_ep_trans+0xe4>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    d890:	2501      	movs	r5, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    d892:	7ce3      	ldrb	r3, [r4, #19]
    d894:	071b      	lsls	r3, r3, #28
    d896:	d43e      	bmi.n	d916 <_usb_d_dev_ep_trans+0xea>
		return USB_HALTED;
	}

	/* Try to start transactions. */

	atomic_enter_critical(&flags);
    d898:	4b22      	ldr	r3, [pc, #136]	; (d924 <_usb_d_dev_ep_trans+0xf8>)
    d89a:	a801      	add	r0, sp, #4
    d89c:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    d89e:	7ce3      	ldrb	r3, [r4, #19]
    d8a0:	4a21      	ldr	r2, [pc, #132]	; (d928 <_usb_d_dev_ep_trans+0xfc>)
    d8a2:	f013 0a40 	ands.w	sl, r3, #64	; 0x40
    d8a6:	d00e      	beq.n	d8c6 <_usb_d_dev_ep_trans+0x9a>
		atomic_leave_critical(&flags);
    d8a8:	a801      	add	r0, sp, #4
    d8aa:	4790      	blx	r2
		return USB_BUSY;
    d8ac:	2001      	movs	r0, #1
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    d8ae:	b002      	add	sp, #8
    d8b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!dir && size_n_aligned) {
    d8b4:	b12e      	cbz	r6, d8c2 <_usb_d_dev_ep_trans+0x96>
		if (!ept->cache) {
    d8b6:	68e3      	ldr	r3, [r4, #12]
    d8b8:	2b00      	cmp	r3, #0
    d8ba:	d1ea      	bne.n	d892 <_usb_d_dev_ep_trans+0x66>
		return -USB_ERR_PARAM;
    d8bc:	f06f 0011 	mvn.w	r0, #17
    d8c0:	e7f5      	b.n	d8ae <_usb_d_dev_ep_trans+0x82>
	bool use_cache = false;
    d8c2:	4635      	mov	r5, r6
    d8c4:	e7e5      	b.n	d892 <_usb_d_dev_ep_trans+0x66>
	ept->flags.bits.is_busy = 1;
    d8c6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d8ca:	74e3      	strb	r3, [r4, #19]
	atomic_leave_critical(&flags);
    d8cc:	a801      	add	r0, sp, #4
    d8ce:	4790      	blx	r2
	ept->trans_buf   = trans->buf;
    d8d0:	f8d8 3000 	ldr.w	r3, [r8]
    d8d4:	6023      	str	r3, [r4, #0]
	ept->trans_size  = trans->size;
    d8d6:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ept->trans_count = 0;
    d8da:	e9c4 3a01 	strd	r3, sl, [r4, #4]
	ept->flags.bits.dir       = dir;
    d8de:	7ce3      	ldrb	r3, [r4, #19]
    d8e0:	f369 13c7 	bfi	r3, r9, #7, #1
	ept->flags.bits.use_cache = use_cache;
    d8e4:	f365 1345 	bfi	r3, r5, #5, #1
    d8e8:	74e3      	strb	r3, [r4, #19]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d8ea:	f898 3009 	ldrb.w	r3, [r8, #9]
    d8ee:	b113      	cbz	r3, d8f6 <_usb_d_dev_ep_trans+0xca>
    d8f0:	fab6 f386 	clz	r3, r6
    d8f4:	095b      	lsrs	r3, r3, #5
    d8f6:	7ce2      	ldrb	r2, [r4, #19]
	if (dir) {
    d8f8:	2f00      	cmp	r7, #0
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d8fa:	f363 1204 	bfi	r2, r3, #4, #1
		_usb_d_dev_in_next(ept, false);
    d8fe:	4620      	mov	r0, r4
    d900:	bfb4      	ite	lt
    d902:	4b0a      	ldrlt	r3, [pc, #40]	; (d92c <_usb_d_dev_ep_trans+0x100>)
		_usb_d_dev_out_next(ept, false);
    d904:	4b0a      	ldrge	r3, [pc, #40]	; (d930 <_usb_d_dev_ep_trans+0x104>)
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d906:	74e2      	strb	r2, [r4, #19]
		_usb_d_dev_in_next(ept, false);
    d908:	2100      	movs	r1, #0
		_usb_d_dev_out_next(ept, false);
    d90a:	4798      	blx	r3
	return ERR_NONE;
    d90c:	2000      	movs	r0, #0
    d90e:	e7ce      	b.n	d8ae <_usb_d_dev_ep_trans+0x82>
			return -USB_ERR_FUNC;
    d910:	f06f 0012 	mvn.w	r0, #18
    d914:	e7cb      	b.n	d8ae <_usb_d_dev_ep_trans+0x82>
		return USB_HALTED;
    d916:	2002      	movs	r0, #2
    d918:	e7c9      	b.n	d8ae <_usb_d_dev_ep_trans+0x82>
    d91a:	bf00      	nop
    d91c:	0000cb7d 	.word	0x0000cb7d
    d920:	20042000 	.word	0x20042000
    d924:	00011b59 	.word	0x00011b59
    d928:	00011b67 	.word	0x00011b67
    d92c:	0000cdfd 	.word	0x0000cdfd
    d930:	0000cf59 	.word	0x0000cf59

0000d934 <_usb_d_dev_ep_get_status>:
	}
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_ABORT);
}

int32_t _usb_d_dev_ep_get_status(const uint8_t ep, struct usb_d_trans_status *stat)
{
    d934:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d936:	f000 040f 	and.w	r4, r0, #15
{
    d93a:	460a      	mov	r2, r1
	bool                  dir = USB_EP_GET_DIR(ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d93c:	4b19      	ldr	r3, [pc, #100]	; (d9a4 <_usb_d_dev_ep_get_status+0x70>)
    d93e:	09c1      	lsrs	r1, r0, #7
{
    d940:	4607      	mov	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d942:	4620      	mov	r0, r4
    d944:	4798      	blx	r3
	bool                  busy, stall;

	if (epn > CONF_USB_D_MAX_EP_N) {
    d946:	2c05      	cmp	r4, #5
    d948:	d82a      	bhi.n	d9a0 <_usb_d_dev_ep_get_status+0x6c>
		return USB_ERR_PARAM;
	}
	busy  = ept->flags.bits.is_busy;
    d94a:	7cc5      	ldrb	r5, [r0, #19]
    d94c:	f3c5 1180 	ubfx	r1, r5, #6, #1
	stall = ept->flags.bits.is_stalled;
    d950:	f3c5 06c0 	ubfx	r6, r5, #3, #1
	if (stat) {
    d954:	b1fa      	cbz	r2, d996 <_usb_d_dev_ep_get_status+0x62>
		stat->stall = stall;
    d956:	7a53      	ldrb	r3, [r2, #9]
		stat->busy  = busy;
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d958:	0164      	lsls	r4, r4, #5
		stat->stall = stall;
    d95a:	f366 1304 	bfi	r3, r6, #4, #1
		stat->busy  = busy;
    d95e:	f361 0382 	bfi	r3, r1, #2, #1
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d962:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
		stat->busy  = busy;
    d966:	7253      	strb	r3, [r2, #9]
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d968:	f894 3107 	ldrb.w	r3, [r4, #263]	; 0x107
    d96c:	f3c3 1400 	ubfx	r4, r3, #4, #1
		stat->dir   = ept->flags.bits.dir;
		stat->size  = ept->trans_size;
    d970:	6843      	ldr	r3, [r0, #4]
    d972:	6013      	str	r3, [r2, #0]
		stat->count = ept->trans_count;
    d974:	6883      	ldr	r3, [r0, #8]
		stat->ep    = ep;
    d976:	7217      	strb	r7, [r2, #8]
		stat->count = ept->trans_count;
    d978:	6053      	str	r3, [r2, #4]
		stat->xtype = ept->flags.bits.eptype - 1;
    d97a:	7cc3      	ldrb	r3, [r0, #19]
    d97c:	7a50      	ldrb	r0, [r2, #9]
    d97e:	3303      	adds	r3, #3
    d980:	f003 0303 	and.w	r3, r3, #3
		stat->dir   = ept->flags.bits.dir;
    d984:	09ed      	lsrs	r5, r5, #7
		stat->xtype = ept->flags.bits.eptype - 1;
    d986:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
    d98a:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
    d98e:	f020 002b 	bic.w	r0, r0, #43	; 0x2b
    d992:	4303      	orrs	r3, r0
    d994:	7253      	strb	r3, [r2, #9]
		return USB_ERR_PARAM;
    d996:	2e00      	cmp	r6, #0
    d998:	bf0c      	ite	eq
    d99a:	4608      	moveq	r0, r1
    d99c:	2002      	movne	r0, #2
	}
	if (busy) {
		return USB_BUSY;
	}
	return USB_OK;
}
    d99e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return USB_ERR_PARAM;
    d9a0:	2012      	movs	r0, #18
    d9a2:	e7fc      	b.n	d99e <_usb_d_dev_ep_get_status+0x6a>
    d9a4:	0000cb7d 	.word	0x0000cb7d

0000d9a8 <_usb_d_dev_register_callback>:

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    d9a8:	4b06      	ldr	r3, [pc, #24]	; (d9c4 <_usb_d_dev_register_callback+0x1c>)
    d9aa:	2900      	cmp	r1, #0
    d9ac:	bf08      	it	eq
    d9ae:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    d9b0:	2801      	cmp	r0, #1
    d9b2:	d102      	bne.n	d9ba <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    d9b4:	4b04      	ldr	r3, [pc, #16]	; (d9c8 <_usb_d_dev_register_callback+0x20>)
    d9b6:	6059      	str	r1, [r3, #4]
    d9b8:	4770      	bx	lr
	} else if (type == USB_D_CB_SOF) {
    d9ba:	b908      	cbnz	r0, d9c0 <_usb_d_dev_register_callback+0x18>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    d9bc:	4b02      	ldr	r3, [pc, #8]	; (d9c8 <_usb_d_dev_register_callback+0x20>)
    d9be:	6019      	str	r1, [r3, #0]
	}
}
    d9c0:	4770      	bx	lr
    d9c2:	bf00      	nop
    d9c4:	0000cb55 	.word	0x0000cb55
    d9c8:	200085a8 	.word	0x200085a8

0000d9cc <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    d9cc:	4b08      	ldr	r3, [pc, #32]	; (d9f0 <_usb_d_dev_register_ep_callback+0x24>)
    d9ce:	2900      	cmp	r1, #0
    d9d0:	bf08      	it	eq
    d9d2:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    d9d4:	b910      	cbnz	r0, d9dc <_usb_d_dev_register_ep_callback+0x10>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    d9d6:	4b07      	ldr	r3, [pc, #28]	; (d9f4 <_usb_d_dev_register_ep_callback+0x28>)
    d9d8:	6099      	str	r1, [r3, #8]
    d9da:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    d9dc:	2801      	cmp	r0, #1
    d9de:	d102      	bne.n	d9e6 <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    d9e0:	4b04      	ldr	r3, [pc, #16]	; (d9f4 <_usb_d_dev_register_ep_callback+0x28>)
    d9e2:	60d9      	str	r1, [r3, #12]
    d9e4:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    d9e6:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    d9e8:	bf04      	itt	eq
    d9ea:	4b02      	ldreq	r3, [pc, #8]	; (d9f4 <_usb_d_dev_register_ep_callback+0x28>)
    d9ec:	6119      	streq	r1, [r3, #16]
	}
}
    d9ee:	4770      	bx	lr
    d9f0:	0000cb55 	.word	0x0000cb55
    d9f4:	200085a8 	.word	0x200085a8

0000d9f8 <USB_0_Handler>:
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{

	_usb_d_dev_handler();
    d9f8:	4b00      	ldr	r3, [pc, #0]	; (d9fc <USB_0_Handler+0x4>)
    d9fa:	4718      	bx	r3
    d9fc:	0000d0f5 	.word	0x0000d0f5

0000da00 <USB_1_Handler>:
    da00:	4b00      	ldr	r3, [pc, #0]	; (da04 <USB_1_Handler+0x4>)
    da02:	4718      	bx	r3
    da04:	0000d0f5 	.word	0x0000d0f5

0000da08 <USB_2_Handler>:
    da08:	4b00      	ldr	r3, [pc, #0]	; (da0c <USB_2_Handler+0x4>)
    da0a:	4718      	bx	r3
    da0c:	0000d0f5 	.word	0x0000d0f5

0000da10 <USB_3_Handler>:
    da10:	4b00      	ldr	r3, [pc, #0]	; (da14 <USB_3_Handler+0x4>)
    da12:	4718      	bx	r3
    da14:	0000d0f5 	.word	0x0000d0f5

0000da18 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    da18:	b508      	push	{r3, lr}
    da1a:	4603      	mov	r3, r0
    da1c:	4608      	mov	r0, r1
    da1e:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
    da20:	b923      	cbnz	r3, da2c <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    da22:	4b04      	ldr	r3, [pc, #16]	; (da34 <_read+0x1c>)
    da24:	4798      	blx	r3
	if (n < 0) {
    da26:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    da2a:	bd08      	pop	{r3, pc}
		return -1;
    da2c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    da30:	e7fb      	b.n	da2a <_read+0x12>
    da32:	bf00      	nop
    da34:	0000b909 	.word	0x0000b909

0000da38 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    da38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    da3c:	4c0c      	ldr	r4, [pc, #48]	; (da70 <prvCheckForValidListAndQueue+0x38>)
	taskENTER_CRITICAL();
    da3e:	4b0d      	ldr	r3, [pc, #52]	; (da74 <prvCheckForValidListAndQueue+0x3c>)
    da40:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    da42:	6825      	ldr	r5, [r4, #0]
    da44:	b985      	cbnz	r5, da68 <prvCheckForValidListAndQueue+0x30>
			vListInitialise(&xActiveTimerList1);
    da46:	1d27      	adds	r7, r4, #4
    da48:	f8df 8034 	ldr.w	r8, [pc, #52]	; da80 <prvCheckForValidListAndQueue+0x48>
    da4c:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    da4e:	f104 0618 	add.w	r6, r4, #24
			vListInitialise(&xActiveTimerList1);
    da52:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    da54:	4630      	mov	r0, r6
    da56:	47c0      	blx	r8
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    da58:	4b07      	ldr	r3, [pc, #28]	; (da78 <prvCheckForValidListAndQueue+0x40>)
    da5a:	462a      	mov	r2, r5
    da5c:	210c      	movs	r1, #12
    da5e:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    da60:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    da64:	4798      	blx	r3
    da66:	6020      	str	r0, [r4, #0]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    da68:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    da6c:	4b03      	ldr	r3, [pc, #12]	; (da7c <prvCheckForValidListAndQueue+0x44>)
    da6e:	4718      	bx	r3
    da70:	20008968 	.word	0x20008968
    da74:	0000b2a5 	.word	0x0000b2a5
    da78:	0000c3cd 	.word	0x0000c3cd
    da7c:	0000b2e9 	.word	0x0000b2e9
    da80:	0000b14d 	.word	0x0000b14d

0000da84 <prvInsertTimerInActiveList>:
	if (xNextExpiryTime <= xTimeNow) {
    da84:	4291      	cmp	r1, r2
{
    da86:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    da88:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    da8a:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    da8c:	d80a      	bhi.n	daa4 <prvInsertTimerInActiveList+0x20>
		if (((TickType_t)(xTimeNow - xCommandTime))
    da8e:	1ad2      	subs	r2, r2, r3
    da90:	6983      	ldr	r3, [r0, #24]
    da92:	429a      	cmp	r2, r3
    da94:	d20e      	bcs.n	dab4 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    da96:	4b08      	ldr	r3, [pc, #32]	; (dab8 <prvInsertTimerInActiveList+0x34>)
    da98:	1d01      	adds	r1, r0, #4
    da9a:	6b18      	ldr	r0, [r3, #48]	; 0x30
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    da9c:	4b07      	ldr	r3, [pc, #28]	; (dabc <prvInsertTimerInActiveList+0x38>)
    da9e:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    daa0:	2000      	movs	r0, #0
}
    daa2:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    daa4:	429a      	cmp	r2, r3
    daa6:	d201      	bcs.n	daac <prvInsertTimerInActiveList+0x28>
    daa8:	4299      	cmp	r1, r3
    daaa:	d203      	bcs.n	dab4 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    daac:	4b02      	ldr	r3, [pc, #8]	; (dab8 <prvInsertTimerInActiveList+0x34>)
    daae:	1d01      	adds	r1, r0, #4
    dab0:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    dab2:	e7f3      	b.n	da9c <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    dab4:	2001      	movs	r0, #1
	return xProcessTimerNow;
    dab6:	e7f4      	b.n	daa2 <prvInsertTimerInActiveList+0x1e>
    dab8:	20008968 	.word	0x20008968
    dabc:	0000b181 	.word	0x0000b181

0000dac0 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    dac0:	4b0e      	ldr	r3, [pc, #56]	; (dafc <xTimerCreateTimerTask+0x3c>)
{
    dac2:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    dac4:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    dac6:	4b0e      	ldr	r3, [pc, #56]	; (db00 <xTimerCreateTimerTask+0x40>)
    dac8:	681a      	ldr	r2, [r3, #0]
    daca:	b942      	cbnz	r2, dade <xTimerCreateTimerTask+0x1e>
    dacc:	f04f 0380 	mov.w	r3, #128	; 0x80
    dad0:	f383 8811 	msr	BASEPRI, r3
    dad4:	f3bf 8f6f 	isb	sy
    dad8:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
    dadc:	e7fe      	b.n	dadc <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(prvTimerTask,
    dade:	3334      	adds	r3, #52	; 0x34
    dae0:	9301      	str	r3, [sp, #4]
    dae2:	2302      	movs	r3, #2
    dae4:	9300      	str	r3, [sp, #0]
    dae6:	4907      	ldr	r1, [pc, #28]	; (db04 <xTimerCreateTimerTask+0x44>)
    dae8:	4807      	ldr	r0, [pc, #28]	; (db08 <xTimerCreateTimerTask+0x48>)
    daea:	4c08      	ldr	r4, [pc, #32]	; (db0c <xTimerCreateTimerTask+0x4c>)
    daec:	2300      	movs	r3, #0
    daee:	2240      	movs	r2, #64	; 0x40
    daf0:	47a0      	blx	r4
	configASSERT(xReturn);
    daf2:	2800      	cmp	r0, #0
    daf4:	d0ea      	beq.n	dacc <xTimerCreateTimerTask+0xc>
}
    daf6:	b002      	add	sp, #8
    daf8:	bd10      	pop	{r4, pc}
    dafa:	bf00      	nop
    dafc:	0000da39 	.word	0x0000da39
    db00:	20008968 	.word	0x20008968
    db04:	000172dc 	.word	0x000172dc
    db08:	0000dbf1 	.word	0x0000dbf1
    db0c:	00012589 	.word	0x00012589

0000db10 <xTimerGenericCommand>:
{
    db10:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    db12:	4616      	mov	r6, r2
	configASSERT(xTimer);
    db14:	4604      	mov	r4, r0
{
    db16:	461a      	mov	r2, r3
	configASSERT(xTimer);
    db18:	b940      	cbnz	r0, db2c <xTimerGenericCommand+0x1c>
    db1a:	f04f 0380 	mov.w	r3, #128	; 0x80
    db1e:	f383 8811 	msr	BASEPRI, r3
    db22:	f3bf 8f6f 	isb	sy
    db26:	f3bf 8f4f 	dsb	sy
    db2a:	e7fe      	b.n	db2a <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    db2c:	4d0d      	ldr	r5, [pc, #52]	; (db64 <xTimerGenericCommand+0x54>)
    db2e:	6828      	ldr	r0, [r5, #0]
    db30:	b188      	cbz	r0, db56 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    db32:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    db34:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    db38:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    db3a:	dc0e      	bgt.n	db5a <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    db3c:	4b0a      	ldr	r3, [pc, #40]	; (db68 <xTimerGenericCommand+0x58>)
    db3e:	4c0b      	ldr	r4, [pc, #44]	; (db6c <xTimerGenericCommand+0x5c>)
    db40:	4798      	blx	r3
    db42:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    db44:	f04f 0300 	mov.w	r3, #0
    db48:	bf08      	it	eq
    db4a:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    db4c:	6828      	ldr	r0, [r5, #0]
    db4e:	bf18      	it	ne
    db50:	461a      	movne	r2, r3
    db52:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    db54:	47a0      	blx	r4
}
    db56:	b004      	add	sp, #16
    db58:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    db5a:	4c05      	ldr	r4, [pc, #20]	; (db70 <xTimerGenericCommand+0x60>)
    db5c:	2300      	movs	r3, #0
    db5e:	a901      	add	r1, sp, #4
    db60:	e7f8      	b.n	db54 <xTimerGenericCommand+0x44>
    db62:	bf00      	nop
    db64:	20008968 	.word	0x20008968
    db68:	00012c7d 	.word	0x00012c7d
    db6c:	0000c421 	.word	0x0000c421
    db70:	0000c5cd 	.word	0x0000c5cd

0000db74 <prvSwitchTimerLists>:
{
    db74:	b5f0      	push	{r4, r5, r6, r7, lr}
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    db76:	4d1a      	ldr	r5, [pc, #104]	; (dbe0 <prvSwitchTimerLists+0x6c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    db78:	4f1a      	ldr	r7, [pc, #104]	; (dbe4 <prvSwitchTimerLists+0x70>)
{
    db7a:	b085      	sub	sp, #20
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    db7c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    db7e:	681a      	ldr	r2, [r3, #0]
    db80:	b922      	cbnz	r2, db8c <prvSwitchTimerLists+0x18>
	pxCurrentTimerList  = pxOverflowTimerList;
    db82:	6b2a      	ldr	r2, [r5, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
    db84:	e9c5 230b 	strd	r2, r3, [r5, #44]	; 0x2c
}
    db88:	b005      	add	sp, #20
    db8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    db8c:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    db8e:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    db90:	681e      	ldr	r6, [r3, #0]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    db92:	1d21      	adds	r1, r4, #4
    db94:	4608      	mov	r0, r1
    db96:	9103      	str	r1, [sp, #12]
    db98:	47b8      	blx	r7
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    db9a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    db9c:	4620      	mov	r0, r4
    db9e:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    dba0:	69e3      	ldr	r3, [r4, #28]
    dba2:	9903      	ldr	r1, [sp, #12]
    dba4:	2b01      	cmp	r3, #1
    dba6:	d1e9      	bne.n	db7c <prvSwitchTimerLists+0x8>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    dba8:	69a3      	ldr	r3, [r4, #24]
    dbaa:	4433      	add	r3, r6
			if (xReloadTime > xNextExpireTime) {
    dbac:	429e      	cmp	r6, r3
    dbae:	d205      	bcs.n	dbbc <prvSwitchTimerLists+0x48>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    dbb0:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    dbb2:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    dbb4:	4b0c      	ldr	r3, [pc, #48]	; (dbe8 <prvSwitchTimerLists+0x74>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    dbb6:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    dbb8:	4798      	blx	r3
    dbba:	e7df      	b.n	db7c <prvSwitchTimerLists+0x8>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    dbbc:	2300      	movs	r3, #0
    dbbe:	4620      	mov	r0, r4
    dbc0:	9300      	str	r3, [sp, #0]
    dbc2:	4c0a      	ldr	r4, [pc, #40]	; (dbec <prvSwitchTimerLists+0x78>)
    dbc4:	4632      	mov	r2, r6
    dbc6:	4619      	mov	r1, r3
    dbc8:	47a0      	blx	r4
				configASSERT(xResult);
    dbca:	2800      	cmp	r0, #0
    dbcc:	d1d6      	bne.n	db7c <prvSwitchTimerLists+0x8>
    dbce:	f04f 0380 	mov.w	r3, #128	; 0x80
    dbd2:	f383 8811 	msr	BASEPRI, r3
    dbd6:	f3bf 8f6f 	isb	sy
    dbda:	f3bf 8f4f 	dsb	sy
    dbde:	e7fe      	b.n	dbde <prvSwitchTimerLists+0x6a>
    dbe0:	20008968 	.word	0x20008968
    dbe4:	0000b1af 	.word	0x0000b1af
    dbe8:	0000b181 	.word	0x0000b181
    dbec:	0000db11 	.word	0x0000db11

0000dbf0 <prvTimerTask>:
{
    dbf0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    dbf4:	f8df 81c8 	ldr.w	r8, [pc, #456]	; ddc0 <prvTimerTask+0x1d0>
{
    dbf8:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    dbfa:	4c68      	ldr	r4, [pc, #416]	; (dd9c <prvTimerTask+0x1ac>)
    dbfc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dbfe:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    dc02:	4627      	mov	r7, r4
    dc04:	f1bb 0f00 	cmp.w	fp, #0
    dc08:	d044      	beq.n	dc94 <prvTimerTask+0xa4>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    dc0a:	68db      	ldr	r3, [r3, #12]
    dc0c:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
    dc10:	4b63      	ldr	r3, [pc, #396]	; (dda0 <prvTimerTask+0x1b0>)
	xTimeNow = xTaskGetTickCount();
    dc12:	4e64      	ldr	r6, [pc, #400]	; (dda4 <prvTimerTask+0x1b4>)
    dc14:	f8df a1ac 	ldr.w	sl, [pc, #428]	; ddc4 <prvTimerTask+0x1d4>
	vTaskSuspendAll();
    dc18:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    dc1a:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dc1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    dc1e:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dc20:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dc22:	d239      	bcs.n	dc98 <prvTimerTask+0xa8>
		prvSwitchTimerLists();
    dc24:	4b60      	ldr	r3, [pc, #384]	; (dda8 <prvTimerTask+0x1b8>)
    dc26:	4798      	blx	r3
	xLastTime = xTimeNow;
    dc28:	63a5      	str	r5, [r4, #56]	; 0x38
			(void)xTaskResumeAll();
    dc2a:	47d0      	blx	sl
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dc2c:	f8df 9198 	ldr.w	r9, [pc, #408]	; ddc8 <prvTimerTask+0x1d8>
		prvSwitchTimerLists();
    dc30:	f8df a174 	ldr.w	sl, [pc, #372]	; dda8 <prvTimerTask+0x1b8>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dc34:	6838      	ldr	r0, [r7, #0]
    dc36:	2200      	movs	r2, #0
    dc38:	a903      	add	r1, sp, #12
    dc3a:	47c8      	blx	r9
    dc3c:	2800      	cmp	r0, #0
    dc3e:	d0dc      	beq.n	dbfa <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    dc40:	9b03      	ldr	r3, [sp, #12]
    dc42:	2b00      	cmp	r3, #0
    dc44:	dbf6      	blt.n	dc34 <prvTimerTask+0x44>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    dc46:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    dc48:	6963      	ldr	r3, [r4, #20]
    dc4a:	b10b      	cbz	r3, dc50 <prvTimerTask+0x60>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    dc4c:	1d20      	adds	r0, r4, #4
    dc4e:	47c0      	blx	r8
	xTimeNow = xTaskGetTickCount();
    dc50:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dc52:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dc54:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dc56:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dc58:	d200      	bcs.n	dc5c <prvTimerTask+0x6c>
		prvSwitchTimerLists();
    dc5a:	47d0      	blx	sl
	xLastTime = xTimeNow;
    dc5c:	9b03      	ldr	r3, [sp, #12]
    dc5e:	63bd      	str	r5, [r7, #56]	; 0x38
			switch (xMessage.xMessageID) {
    dc60:	2b09      	cmp	r3, #9
    dc62:	d8e7      	bhi.n	dc34 <prvTimerTask+0x44>
    dc64:	a201      	add	r2, pc, #4	; (adr r2, dc6c <prvTimerTask+0x7c>)
    dc66:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    dc6a:	bf00      	nop
    dc6c:	0000dd21 	.word	0x0000dd21
    dc70:	0000dd21 	.word	0x0000dd21
    dc74:	0000dd21 	.word	0x0000dd21
    dc78:	0000dc35 	.word	0x0000dc35
    dc7c:	0000dd6d 	.word	0x0000dd6d
    dc80:	0000dd93 	.word	0x0000dd93
    dc84:	0000dd21 	.word	0x0000dd21
    dc88:	0000dd21 	.word	0x0000dd21
    dc8c:	0000dc35 	.word	0x0000dc35
    dc90:	0000dd6d 	.word	0x0000dd6d
		xNextExpireTime = (TickType_t)0U;
    dc94:	46d9      	mov	r9, fp
    dc96:	e7bb      	b.n	dc10 <prvTimerTask+0x20>
	xLastTime = xTimeNow;
    dc98:	63a0      	str	r0, [r4, #56]	; 0x38
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    dc9a:	f1bb 0f00 	cmp.w	fp, #0
    dc9e:	d027      	beq.n	dcf0 <prvTimerTask+0x100>
    dca0:	4581      	cmp	r9, r0
    dca2:	d83b      	bhi.n	dd1c <prvTimerTask+0x12c>
				(void)xTaskResumeAll();
    dca4:	47d0      	blx	sl
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    dca6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dca8:	68db      	ldr	r3, [r3, #12]
    dcaa:	68dc      	ldr	r4, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    dcac:	1d20      	adds	r0, r4, #4
    dcae:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    dcb0:	69e3      	ldr	r3, [r4, #28]
    dcb2:	2b01      	cmp	r3, #1
    dcb4:	d118      	bne.n	dce8 <prvTimerTask+0xf8>
		if (prvInsertTimerInActiveList(
    dcb6:	69a1      	ldr	r1, [r4, #24]
    dcb8:	462a      	mov	r2, r5
    dcba:	464b      	mov	r3, r9
    dcbc:	4d3b      	ldr	r5, [pc, #236]	; (ddac <prvTimerTask+0x1bc>)
    dcbe:	4449      	add	r1, r9
    dcc0:	4620      	mov	r0, r4
    dcc2:	47a8      	blx	r5
    dcc4:	b180      	cbz	r0, dce8 <prvTimerTask+0xf8>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    dcc6:	2300      	movs	r3, #0
    dcc8:	4d39      	ldr	r5, [pc, #228]	; (ddb0 <prvTimerTask+0x1c0>)
    dcca:	9300      	str	r3, [sp, #0]
    dccc:	464a      	mov	r2, r9
    dcce:	4619      	mov	r1, r3
    dcd0:	4620      	mov	r0, r4
    dcd2:	47a8      	blx	r5
			configASSERT(xResult);
    dcd4:	b940      	cbnz	r0, dce8 <prvTimerTask+0xf8>
    dcd6:	f04f 0380 	mov.w	r3, #128	; 0x80
    dcda:	f383 8811 	msr	BASEPRI, r3
    dcde:	f3bf 8f6f 	isb	sy
    dce2:	f3bf 8f4f 	dsb	sy
    dce6:	e7fe      	b.n	dce6 <prvTimerTask+0xf6>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    dce8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dcea:	4620      	mov	r0, r4
    dcec:	4798      	blx	r3
}
    dcee:	e79d      	b.n	dc2c <prvTimerTask+0x3c>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    dcf0:	6b23      	ldr	r3, [r4, #48]	; 0x30
    dcf2:	681a      	ldr	r2, [r3, #0]
    dcf4:	fab2 f282 	clz	r2, r2
    dcf8:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    dcfa:	6820      	ldr	r0, [r4, #0]
    dcfc:	4b2d      	ldr	r3, [pc, #180]	; (ddb4 <prvTimerTask+0x1c4>)
    dcfe:	eba9 0105 	sub.w	r1, r9, r5
    dd02:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    dd04:	47d0      	blx	sl
    dd06:	2800      	cmp	r0, #0
    dd08:	d190      	bne.n	dc2c <prvTimerTask+0x3c>
					portYIELD_WITHIN_API();
    dd0a:	4b2b      	ldr	r3, [pc, #172]	; (ddb8 <prvTimerTask+0x1c8>)
    dd0c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    dd10:	601a      	str	r2, [r3, #0]
    dd12:	f3bf 8f4f 	dsb	sy
    dd16:	f3bf 8f6f 	isb	sy
    dd1a:	e787      	b.n	dc2c <prvTimerTask+0x3c>
    dd1c:	2200      	movs	r2, #0
    dd1e:	e7ec      	b.n	dcfa <prvTimerTask+0x10a>
				if (prvInsertTimerInActiveList(pxTimer,
    dd20:	69a1      	ldr	r1, [r4, #24]
    dd22:	9b04      	ldr	r3, [sp, #16]
    dd24:	462a      	mov	r2, r5
    dd26:	4419      	add	r1, r3
    dd28:	4d20      	ldr	r5, [pc, #128]	; (ddac <prvTimerTask+0x1bc>)
    dd2a:	4620      	mov	r0, r4
    dd2c:	47a8      	blx	r5
    dd2e:	2800      	cmp	r0, #0
    dd30:	f43f af7e 	beq.w	dc30 <prvTimerTask+0x40>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    dd34:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dd36:	4620      	mov	r0, r4
    dd38:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    dd3a:	69e3      	ldr	r3, [r4, #28]
    dd3c:	2b01      	cmp	r3, #1
    dd3e:	f47f af77 	bne.w	dc30 <prvTimerTask+0x40>
						xResult = xTimerGenericCommand(pxTimer,
    dd42:	69a2      	ldr	r2, [r4, #24]
    dd44:	9904      	ldr	r1, [sp, #16]
    dd46:	2300      	movs	r3, #0
    dd48:	440a      	add	r2, r1
    dd4a:	4620      	mov	r0, r4
    dd4c:	9300      	str	r3, [sp, #0]
    dd4e:	4c18      	ldr	r4, [pc, #96]	; (ddb0 <prvTimerTask+0x1c0>)
    dd50:	4619      	mov	r1, r3
    dd52:	47a0      	blx	r4
						configASSERT(xResult);
    dd54:	2800      	cmp	r0, #0
    dd56:	f47f af6b 	bne.w	dc30 <prvTimerTask+0x40>
    dd5a:	f04f 0380 	mov.w	r3, #128	; 0x80
    dd5e:	f383 8811 	msr	BASEPRI, r3
    dd62:	f3bf 8f6f 	isb	sy
    dd66:	f3bf 8f4f 	dsb	sy
    dd6a:	e7fe      	b.n	dd6a <prvTimerTask+0x17a>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    dd6c:	9904      	ldr	r1, [sp, #16]
    dd6e:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    dd70:	b941      	cbnz	r1, dd84 <prvTimerTask+0x194>
    dd72:	f04f 0380 	mov.w	r3, #128	; 0x80
    dd76:	f383 8811 	msr	BASEPRI, r3
    dd7a:	f3bf 8f6f 	isb	sy
    dd7e:	f3bf 8f4f 	dsb	sy
    dd82:	e7fe      	b.n	dd82 <prvTimerTask+0x192>
				(void)prvInsertTimerInActiveList(
    dd84:	462b      	mov	r3, r5
    dd86:	462a      	mov	r2, r5
    dd88:	4429      	add	r1, r5
    dd8a:	4620      	mov	r0, r4
    dd8c:	4c07      	ldr	r4, [pc, #28]	; (ddac <prvTimerTask+0x1bc>)
    dd8e:	47a0      	blx	r4
				break;
    dd90:	e74e      	b.n	dc30 <prvTimerTask+0x40>
				vPortFree(pxTimer);
    dd92:	4b0a      	ldr	r3, [pc, #40]	; (ddbc <prvTimerTask+0x1cc>)
    dd94:	4620      	mov	r0, r4
    dd96:	4798      	blx	r3
			break;
    dd98:	e74a      	b.n	dc30 <prvTimerTask+0x40>
    dd9a:	bf00      	nop
    dd9c:	20008968 	.word	0x20008968
    dda0:	000127b1 	.word	0x000127b1
    dda4:	000127c5 	.word	0x000127c5
    dda8:	0000db75 	.word	0x0000db75
    ddac:	0000da85 	.word	0x0000da85
    ddb0:	0000db11 	.word	0x0000db11
    ddb4:	0000c815 	.word	0x0000c815
    ddb8:	e000ed04 	.word	0xe000ed04
    ddbc:	0000b769 	.word	0x0000b769
    ddc0:	0000b1af 	.word	0x0000b1af
    ddc4:	000128f9 	.word	0x000128f9
    ddc8:	0000c6ad 	.word	0x0000c6ad

0000ddcc <delay_init>:
/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
	_delay_init(hardware = hw);
    ddcc:	4b01      	ldr	r3, [pc, #4]	; (ddd4 <delay_init+0x8>)
    ddce:	6018      	str	r0, [r3, #0]
    ddd0:	4b01      	ldr	r3, [pc, #4]	; (ddd8 <delay_init+0xc>)
    ddd2:	4718      	bx	r3
    ddd4:	200089a4 	.word	0x200089a4
    ddd8:	00013a9d 	.word	0x00013a9d

0000dddc <delay_ms>:
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dddc:	4b05      	ldr	r3, [pc, #20]	; (ddf4 <delay_ms+0x18>)
{
    ddde:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dde0:	681c      	ldr	r4, [r3, #0]
    dde2:	4b05      	ldr	r3, [pc, #20]	; (ddf8 <delay_ms+0x1c>)
    dde4:	4798      	blx	r3
    dde6:	4b05      	ldr	r3, [pc, #20]	; (ddfc <delay_ms+0x20>)
    dde8:	4601      	mov	r1, r0
    ddea:	4620      	mov	r0, r4
}
    ddec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    ddf0:	4718      	bx	r3
    ddf2:	bf00      	nop
    ddf4:	200089a4 	.word	0x200089a4
    ddf8:	0000bb15 	.word	0x0000bb15
    ddfc:	00013ab1 	.word	0x00013ab1

0000de00 <_init_chip>:
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    de00:	4a0e      	ldr	r2, [pc, #56]	; (de3c <_init_chip+0x3c>)
    de02:	8813      	ldrh	r3, [r2, #0]
    de04:	b29b      	uxth	r3, r3
    de06:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    de0a:	b510      	push	{r4, lr}
    de0c:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    de0e:	4b0c      	ldr	r3, [pc, #48]	; (de40 <_init_chip+0x40>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    de10:	4c0c      	ldr	r4, [pc, #48]	; (de44 <_init_chip+0x44>)
	_osc32kctrl_init_sources();
    de12:	4798      	blx	r3
	_oscctrl_init_sources();
    de14:	4b0c      	ldr	r3, [pc, #48]	; (de48 <_init_chip+0x48>)
    de16:	4798      	blx	r3
	_mclk_init();
    de18:	4b0c      	ldr	r3, [pc, #48]	; (de4c <_init_chip+0x4c>)
    de1a:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    de1c:	2004      	movs	r0, #4
    de1e:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    de20:	4b0b      	ldr	r3, [pc, #44]	; (de50 <_init_chip+0x50>)
    de22:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    de24:	f640 70fb 	movw	r0, #4091	; 0xffb
    de28:	47a0      	blx	r4
}

static inline void hri_mclk_set_AHBMASK_DMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    de2a:	4a0a      	ldr	r2, [pc, #40]	; (de54 <_init_chip+0x54>)
    de2c:	6913      	ldr	r3, [r2, #16]
    de2e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    de32:	6113      	str	r3, [r2, #16]
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    de34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_dma_init();
    de38:	4b07      	ldr	r3, [pc, #28]	; (de58 <_init_chip+0x58>)
    de3a:	4718      	bx	r3
    de3c:	41004000 	.word	0x41004000
    de40:	0000f8c5 	.word	0x0000f8c5
    de44:	0000ecc5 	.word	0x0000ecc5
    de48:	0000e66d 	.word	0x0000e66d
    de4c:	0000eca5 	.word	0x0000eca5
    de50:	0000e671 	.word	0x0000e671
    de54:	40000800 	.word	0x40000800
    de58:	0000e0e1 	.word	0x0000e0e1

0000de5c <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    de5c:	4a0b      	ldr	r2, [pc, #44]	; (de8c <RAMECC_Handler+0x30>)
    de5e:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    de60:	b082      	sub	sp, #8
    de62:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    de64:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    de66:	9b01      	ldr	r3, [sp, #4]
    de68:	0799      	lsls	r1, r3, #30
    de6a:	d505      	bpl.n	de78 <RAMECC_Handler+0x1c>
    de6c:	4b08      	ldr	r3, [pc, #32]	; (de90 <RAMECC_Handler+0x34>)
    de6e:	681b      	ldr	r3, [r3, #0]
    de70:	b113      	cbz	r3, de78 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    de72:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    de74:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    de76:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    de78:	9b01      	ldr	r3, [sp, #4]
    de7a:	07db      	lsls	r3, r3, #31
    de7c:	d504      	bpl.n	de88 <RAMECC_Handler+0x2c>
    de7e:	4b04      	ldr	r3, [pc, #16]	; (de90 <RAMECC_Handler+0x34>)
    de80:	685b      	ldr	r3, [r3, #4]
    de82:	b10b      	cbz	r3, de88 <RAMECC_Handler+0x2c>
    de84:	4a01      	ldr	r2, [pc, #4]	; (de8c <RAMECC_Handler+0x30>)
    de86:	e7f4      	b.n	de72 <RAMECC_Handler+0x16>
}
    de88:	b002      	add	sp, #8
    de8a:	4770      	bx	lr
    de8c:	41020000 	.word	0x41020000
    de90:	2001c858 	.word	0x2001c858

0000de94 <hid_mouse_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    de94:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    de96:	780a      	ldrb	r2, [r1, #0]
    de98:	2a81      	cmp	r2, #129	; 0x81
    de9a:	d11c      	bne.n	ded6 <hid_mouse_req+0x42>
    de9c:	784b      	ldrb	r3, [r1, #1]
    de9e:	2b06      	cmp	r3, #6
    dea0:	d131      	bne.n	df06 <hid_mouse_req+0x72>
    dea2:	4a1a      	ldr	r2, [pc, #104]	; (df0c <hid_mouse_req+0x78>)
    dea4:	888c      	ldrh	r4, [r1, #4]
    dea6:	7a13      	ldrb	r3, [r2, #8]
    dea8:	429c      	cmp	r4, r3
    deaa:	d12c      	bne.n	df06 <hid_mouse_req+0x72>
	switch (req->wValue >> 8) {
    deac:	884b      	ldrh	r3, [r1, #2]
    deae:	0a1b      	lsrs	r3, r3, #8
    deb0:	2b21      	cmp	r3, #33	; 0x21
    deb2:	d005      	beq.n	dec0 <hid_mouse_req+0x2c>
    deb4:	2b22      	cmp	r3, #34	; 0x22
    deb6:	d00a      	beq.n	dece <hid_mouse_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
			switch (req->bRequest) {
    deb8:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    debc:	bc30      	pop	{r4, r5}
    debe:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
    dec0:	6811      	ldr	r1, [r2, #0]
    dec2:	780a      	ldrb	r2, [r1, #0]
    dec4:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    dec6:	4c12      	ldr	r4, [pc, #72]	; (df10 <hid_mouse_req+0x7c>)
    dec8:	46a4      	mov	ip, r4
}
    deca:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    decc:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
    dece:	4911      	ldr	r1, [pc, #68]	; (df14 <hid_mouse_req+0x80>)
    ded0:	2300      	movs	r3, #0
    ded2:	2234      	movs	r2, #52	; 0x34
    ded4:	e7f7      	b.n	dec6 <hid_mouse_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    ded6:	f3c2 1241 	ubfx	r2, r2, #5, #2
    deda:	2a01      	cmp	r2, #1
    dedc:	d113      	bne.n	df06 <hid_mouse_req+0x72>
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
    dede:	4c0b      	ldr	r4, [pc, #44]	; (df0c <hid_mouse_req+0x78>)
    dee0:	888d      	ldrh	r5, [r1, #4]
    dee2:	7a23      	ldrb	r3, [r4, #8]
    dee4:	429d      	cmp	r5, r3
    dee6:	d10e      	bne.n	df06 <hid_mouse_req+0x72>
			switch (req->bRequest) {
    dee8:	784b      	ldrb	r3, [r1, #1]
    deea:	2b03      	cmp	r3, #3
    deec:	d007      	beq.n	defe <hid_mouse_req+0x6a>
    deee:	2b0b      	cmp	r3, #11
    def0:	d1e2      	bne.n	deb8 <hid_mouse_req+0x24>
				_hiddf_mouse_funcd.protocol = req->wValue;
    def2:	884b      	ldrh	r3, [r1, #2]
    def4:	72a3      	strb	r3, [r4, #10]
				return usbdc_xfer(ep, NULL, 0, 0);
    def6:	2300      	movs	r3, #0
    def8:	461a      	mov	r2, r3
    defa:	4619      	mov	r1, r3
    defc:	e7e3      	b.n	dec6 <hid_mouse_req+0x32>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
    defe:	2300      	movs	r3, #0
    df00:	f104 010a 	add.w	r1, r4, #10
    df04:	e7df      	b.n	dec6 <hid_mouse_req+0x32>
			return ERR_NOT_FOUND;
    df06:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    df0a:	e7d7      	b.n	debc <hid_mouse_req+0x28>
    df0c:	200089a8 	.word	0x200089a8
    df10:	0001328d 	.word	0x0001328d
    df14:	000172e4 	.word	0x000172e4

0000df18 <hid_mouse_ctrl>:
	switch (ctrl) {
    df18:	2901      	cmp	r1, #1
{
    df1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    df1c:	4614      	mov	r4, r2
	switch (ctrl) {
    df1e:	d03b      	beq.n	df98 <hid_mouse_ctrl+0x80>
    df20:	2902      	cmp	r1, #2
    df22:	d04f      	beq.n	dfc4 <hid_mouse_ctrl+0xac>
    df24:	2900      	cmp	r1, #0
    df26:	d150      	bne.n	dfca <hid_mouse_ctrl+0xb2>
	ifc = desc->sod;
    df28:	6813      	ldr	r3, [r2, #0]
		return hid_mouse_enable(drv, (struct usbd_descriptors *)param);
    df2a:	6886      	ldr	r6, [r0, #8]
	if (NULL == ifc) {
    df2c:	b91b      	cbnz	r3, df36 <hid_mouse_ctrl+0x1e>
		return ERR_NOT_FOUND;
    df2e:	f06f 0409 	mvn.w	r4, #9
}
    df32:	4620      	mov	r0, r4
    df34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    df36:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    df38:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    df3a:	2903      	cmp	r1, #3
    df3c:	d1f7      	bne.n	df2e <hid_mouse_ctrl+0x16>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    df3e:	7a31      	ldrb	r1, [r6, #8]
    df40:	428a      	cmp	r2, r1
    df42:	d045      	beq.n	dfd0 <hid_mouse_ctrl+0xb8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    df44:	29ff      	cmp	r1, #255	; 0xff
    df46:	d146      	bne.n	dfd6 <hid_mouse_ctrl+0xbe>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    df48:	7232      	strb	r2, [r6, #8]
    df4a:	7818      	ldrb	r0, [r3, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    df4c:	6861      	ldr	r1, [r4, #4]
    df4e:	4f26      	ldr	r7, [pc, #152]	; (dfe8 <hid_mouse_ctrl+0xd0>)
    df50:	2221      	movs	r2, #33	; 0x21
    df52:	4418      	add	r0, r3
    df54:	4b25      	ldr	r3, [pc, #148]	; (dfec <hid_mouse_ctrl+0xd4>)
    df56:	4798      	blx	r3
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    df58:	6823      	ldr	r3, [r4, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    df5a:	6038      	str	r0, [r7, #0]
    df5c:	7818      	ldrb	r0, [r3, #0]
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    df5e:	6861      	ldr	r1, [r4, #4]
    df60:	4418      	add	r0, r3
    df62:	4b23      	ldr	r3, [pc, #140]	; (dff0 <hid_mouse_ctrl+0xd8>)
    df64:	4798      	blx	r3
	desc->sod = ep;
    df66:	6020      	str	r0, [r4, #0]
	if (NULL != ep) {
    df68:	2800      	cmp	r0, #0
    df6a:	d0e0      	beq.n	df2e <hid_mouse_ctrl+0x16>
	return (ptr[0] + (ptr[1] << 8));
    df6c:	7943      	ldrb	r3, [r0, #5]
    df6e:	7902      	ldrb	r2, [r0, #4]
		ep_desc.bEndpointAddress = ep[2];
    df70:	7885      	ldrb	r5, [r0, #2]
		if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    df72:	78c1      	ldrb	r1, [r0, #3]
    df74:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    df78:	b292      	uxth	r2, r2
    df7a:	4b1e      	ldr	r3, [pc, #120]	; (dff4 <hid_mouse_ctrl+0xdc>)
    df7c:	4628      	mov	r0, r5
    df7e:	4798      	blx	r3
    df80:	4604      	mov	r4, r0
    df82:	bb58      	cbnz	r0, dfdc <hid_mouse_ctrl+0xc4>
		if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    df84:	062b      	lsls	r3, r5, #24
    df86:	d52c      	bpl.n	dfe2 <hid_mouse_ctrl+0xca>
			usb_d_ep_enable(func_data->func_ep_in);
    df88:	4b1b      	ldr	r3, [pc, #108]	; (dff8 <hid_mouse_ctrl+0xe0>)
			func_data->func_ep_in = ep_desc.bEndpointAddress;
    df8a:	7275      	strb	r5, [r6, #9]
			usb_d_ep_enable(func_data->func_ep_in);
    df8c:	4628      	mov	r0, r5
    df8e:	4798      	blx	r3
	_hiddf_mouse_funcd.protocol = 1;
    df90:	f240 1301 	movw	r3, #257	; 0x101
    df94:	817b      	strh	r3, [r7, #10]
	return ERR_NONE;
    df96:	e7cc      	b.n	df32 <hid_mouse_ctrl+0x1a>
		return hid_mouse_disable(drv, (struct usbd_descriptors *)param);
    df98:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    df9a:	b11a      	cbz	r2, dfa4 <hid_mouse_ctrl+0x8c>
		ifc_desc.bInterfaceClass = desc->sod[5];
    df9c:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    df9e:	795b      	ldrb	r3, [r3, #5]
    dfa0:	2b03      	cmp	r3, #3
    dfa2:	d1c4      	bne.n	df2e <hid_mouse_ctrl+0x16>
	if (func_data->func_iface != 0xFF) {
    dfa4:	7a2b      	ldrb	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    dfa6:	7a68      	ldrb	r0, [r5, #9]
	if (func_data->func_iface != 0xFF) {
    dfa8:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    dfaa:	bf1c      	itt	ne
    dfac:	23ff      	movne	r3, #255	; 0xff
    dfae:	722b      	strbne	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    dfb0:	28ff      	cmp	r0, #255	; 0xff
    dfb2:	d003      	beq.n	dfbc <hid_mouse_ctrl+0xa4>
		usb_d_ep_deinit(func_data->func_ep_in);
    dfb4:	4b11      	ldr	r3, [pc, #68]	; (dffc <hid_mouse_ctrl+0xe4>)
    dfb6:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    dfb8:	23ff      	movs	r3, #255	; 0xff
    dfba:	726b      	strb	r3, [r5, #9]
	_hiddf_mouse_funcd.enabled = false;
    dfbc:	4b0a      	ldr	r3, [pc, #40]	; (dfe8 <hid_mouse_ctrl+0xd0>)
    dfbe:	2400      	movs	r4, #0
    dfc0:	72dc      	strb	r4, [r3, #11]
	return ERR_NONE;
    dfc2:	e7b6      	b.n	df32 <hid_mouse_ctrl+0x1a>
		return ERR_UNSUPPORTED_OP;
    dfc4:	f06f 041a 	mvn.w	r4, #26
    dfc8:	e7b3      	b.n	df32 <hid_mouse_ctrl+0x1a>
	switch (ctrl) {
    dfca:	f06f 040c 	mvn.w	r4, #12
    dfce:	e7b0      	b.n	df32 <hid_mouse_ctrl+0x1a>
			return ERR_ALREADY_INITIALIZED;
    dfd0:	f06f 0411 	mvn.w	r4, #17
    dfd4:	e7ad      	b.n	df32 <hid_mouse_ctrl+0x1a>
			return ERR_NO_RESOURCE;
    dfd6:	f06f 041b 	mvn.w	r4, #27
    dfda:	e7aa      	b.n	df32 <hid_mouse_ctrl+0x1a>
			return ERR_NOT_INITIALIZED;
    dfdc:	f06f 0413 	mvn.w	r4, #19
    dfe0:	e7a7      	b.n	df32 <hid_mouse_ctrl+0x1a>
			return ERR_INVALID_DATA;
    dfe2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    dfe6:	e7a4      	b.n	df32 <hid_mouse_ctrl+0x1a>
    dfe8:	200089a8 	.word	0x200089a8
    dfec:	0000b83d 	.word	0x0000b83d
    dff0:	0000b857 	.word	0x0000b857
    dff4:	0000f571 	.word	0x0000f571
    dff8:	0000f601 	.word	0x0000f601
    dffc:	0000f5d5 	.word	0x0000f5d5

0000e000 <hiddf_mouse_init>:

/**
 * \brief Initialize the USB HID Mouse Function Driver
 */
int32_t hiddf_mouse_init(void)
{
    e000:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    e002:	4b0a      	ldr	r3, [pc, #40]	; (e02c <hiddf_mouse_init+0x2c>)
    e004:	4798      	blx	r3
    e006:	2801      	cmp	r0, #1
    e008:	d80c      	bhi.n	e024 <hiddf_mouse_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_mouse.ctrl      = hid_mouse_ctrl;
    e00a:	4809      	ldr	r0, [pc, #36]	; (e030 <hiddf_mouse_init+0x30>)
    e00c:	4b09      	ldr	r3, [pc, #36]	; (e034 <hiddf_mouse_init+0x34>)
	_hiddf_mouse.func_data = &_hiddf_mouse_funcd;
    e00e:	e9c0 3004 	strd	r3, r0, [r0, #16]

	usbdc_register_function(&_hiddf_mouse);
    e012:	4b09      	ldr	r3, [pc, #36]	; (e038 <hiddf_mouse_init+0x38>)
    e014:	300c      	adds	r0, #12
    e016:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_mouse_req_h);
    e018:	2001      	movs	r0, #1
    e01a:	4908      	ldr	r1, [pc, #32]	; (e03c <hiddf_mouse_init+0x3c>)
    e01c:	4b08      	ldr	r3, [pc, #32]	; (e040 <hiddf_mouse_init+0x40>)
    e01e:	4798      	blx	r3
	return ERR_NONE;
    e020:	2000      	movs	r0, #0
}
    e022:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    e024:	f06f 0010 	mvn.w	r0, #16
    e028:	e7fb      	b.n	e022 <hiddf_mouse_init+0x22>
    e02a:	bf00      	nop
    e02c:	000136c5 	.word	0x000136c5
    e030:	200089a8 	.word	0x200089a8
    e034:	0000df19 	.word	0x0000df19
    e038:	0001366d 	.word	0x0001366d
    e03c:	200004fc 	.word	0x200004fc
    e040:	000135e5 	.word	0x000135e5

0000e044 <hiddf_mouse_move>:
 * \param pos     Signed value to move
 * \param type    HID mouse class pointer move type
 * \return Operation status.
 */
int32_t hiddf_mouse_move(int8_t pos, enum hiddf_mouse_move_type type)
{
    e044:	b410      	push	{r4}

	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    e046:	4c0e      	ldr	r4, [pc, #56]	; (e080 <hiddf_mouse_move+0x3c>)
    e048:	2300      	movs	r3, #0

	if (type == HID_MOUSE_X_AXIS_MV) {
    e04a:	2901      	cmp	r1, #1
	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    e04c:	6063      	str	r3, [r4, #4]
	if (type == HID_MOUSE_X_AXIS_MV) {
    e04e:	d109      	bne.n	e064 <hiddf_mouse_move+0x20>
		_hiddf_mouse_funcd.mouse_report.bytes.x_axis_var = pos;
    e050:	7160      	strb	r0, [r4, #5]
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
	} else {
		return ERR_INVALID_ARG;
	}

	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e052:	7a60      	ldrb	r0, [r4, #9]
    e054:	4c0b      	ldr	r4, [pc, #44]	; (e084 <hiddf_mouse_move+0x40>)
    e056:	490c      	ldr	r1, [pc, #48]	; (e088 <hiddf_mouse_move+0x44>)
    e058:	46a4      	mov	ip, r4
    e05a:	2300      	movs	r3, #0
}
    e05c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e060:	2204      	movs	r2, #4
    e062:	4760      	bx	ip
	} else if (type == HID_MOUSE_Y_AXIS_MV) {
    e064:	2902      	cmp	r1, #2
    e066:	d101      	bne.n	e06c <hiddf_mouse_move+0x28>
		_hiddf_mouse_funcd.mouse_report.bytes.y_axis_var = pos;
    e068:	71a0      	strb	r0, [r4, #6]
    e06a:	e7f2      	b.n	e052 <hiddf_mouse_move+0xe>
	} else if (type == HID_MOUSE_SCROLL_MV) {
    e06c:	2903      	cmp	r1, #3
    e06e:	d101      	bne.n	e074 <hiddf_mouse_move+0x30>
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
    e070:	71e0      	strb	r0, [r4, #7]
    e072:	e7ee      	b.n	e052 <hiddf_mouse_move+0xe>
}
    e074:	f06f 000c 	mvn.w	r0, #12
    e078:	f85d 4b04 	ldr.w	r4, [sp], #4
    e07c:	4770      	bx	lr
    e07e:	bf00      	nop
    e080:	200089a8 	.word	0x200089a8
    e084:	0001328d 	.word	0x0001328d
    e088:	200089ac 	.word	0x200089ac

0000e08c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    e08c:	b900      	cbnz	r0, e090 <assert+0x4>
		__asm("BKPT #0");
    e08e:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    e090:	4770      	bx	lr
	...

0000e094 <_dmac_handler>:
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e094:	4b10      	ldr	r3, [pc, #64]	; (e0d8 <_dmac_handler+0x44>)
    e096:	8c1a      	ldrh	r2, [r3, #32]
}
/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    e098:	b430      	push	{r4, r5}
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e09a:	8c1d      	ldrh	r5, [r3, #32]
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
	struct _dma_resource *tmp_resource = &_resources[channel];
    e09c:	4c0f      	ldr	r4, [pc, #60]	; (e0dc <_dmac_handler+0x48>)
	tmp &= mask;
    e09e:	f002 021f 	and.w	r2, r2, #31
    e0a2:	210c      	movs	r1, #12
    e0a4:	4351      	muls	r1, r2

	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e0a6:	05ed      	lsls	r5, r5, #23
	struct _dma_resource *tmp_resource = &_resources[channel];
    e0a8:	eb04 0001 	add.w	r0, r4, r1
	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e0ac:	d507      	bpl.n	e0be <_dmac_handler+0x2a>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    e0ae:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e0b2:	2201      	movs	r2, #1
    e0b4:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
		tmp_resource->dma_cb.error(tmp_resource);
    e0b8:	6843      	ldr	r3, [r0, #4]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		tmp_resource->dma_cb.transfer_done(tmp_resource);
	}
}
    e0ba:	bc30      	pop	{r4, r5}
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e0bc:	4718      	bx	r3
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e0be:	8c1d      	ldrh	r5, [r3, #32]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
    e0c0:	05ad      	lsls	r5, r5, #22
    e0c2:	d506      	bpl.n	e0d2 <_dmac_handler+0x3e>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    e0c4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e0c8:	2202      	movs	r2, #2
    e0ca:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e0ce:	5863      	ldr	r3, [r4, r1]
    e0d0:	e7f3      	b.n	e0ba <_dmac_handler+0x26>
}
    e0d2:	bc30      	pop	{r4, r5}
    e0d4:	4770      	bx	lr
    e0d6:	bf00      	nop
    e0d8:	4100a000 	.word	0x4100a000
    e0dc:	200089c0 	.word	0x200089c0

0000e0e0 <_dma_init>:
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    e0e0:	4b3d      	ldr	r3, [pc, #244]	; (e1d8 <_dma_init+0xf8>)
    e0e2:	881a      	ldrh	r2, [r3, #0]
    e0e4:	f022 0202 	bic.w	r2, r2, #2
    e0e8:	0412      	lsls	r2, r2, #16
    e0ea:	0c12      	lsrs	r2, r2, #16
{
    e0ec:	b570      	push	{r4, r5, r6, lr}
    e0ee:	801a      	strh	r2, [r3, #0]
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    e0f0:	885a      	ldrh	r2, [r3, #2]
    e0f2:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    e0f6:	0412      	lsls	r2, r2, #16
    e0f8:	0c12      	lsrs	r2, r2, #16
    e0fa:	805a      	strh	r2, [r3, #2]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    e0fc:	881a      	ldrh	r2, [r3, #0]
    e0fe:	b292      	uxth	r2, r2
    e100:	f042 0201 	orr.w	r2, r2, #1
    e104:	801a      	strh	r2, [r3, #0]
	tmp = ((Dmac *)hw)->CTRL.reg;
    e106:	881a      	ldrh	r2, [r3, #0]
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    e108:	f012 0201 	ands.w	r2, r2, #1
    e10c:	d1fb      	bne.n	e106 <_dma_init+0x26>
	((Dmac *)hw)->CTRL.reg = data;
    e10e:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    e112:	8019      	strh	r1, [r3, #0]
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    e114:	7b59      	ldrb	r1, [r3, #13]
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    e116:	4831      	ldr	r0, [pc, #196]	; (e1dc <_dma_init+0xfc>)
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    e118:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << DMAC_DBGCTRL_DBGRUN_Pos;
    e11c:	f041 0101 	orr.w	r1, r1, #1
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    e120:	7359      	strb	r1, [r3, #13]
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    e122:	492f      	ldr	r1, [pc, #188]	; (e1e0 <_dma_init+0x100>)
	((Dmac *)hw)->PRICTRL0.reg = data;
    e124:	615a      	str	r2, [r3, #20]
	((Dmac *)hw)->BASEADDR.reg = data;
    e126:	6358      	str	r0, [r3, #52]	; 0x34
	((Dmac *)hw)->WRBADDR.reg = data;
    e128:	6399      	str	r1, [r3, #56]	; 0x38
    e12a:	4613      	mov	r3, r2
    e12c:	492d      	ldr	r1, [pc, #180]	; (e1e4 <_dma_init+0x104>)
    e12e:	4602      	mov	r2, r0
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e130:	461d      	mov	r5, r3
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    e132:	011c      	lsls	r4, r3, #4
    e134:	f104 4082 	add.w	r0, r4, #1090519040	; 0x41000000
    e138:	f500 4020 	add.w	r0, r0, #40960	; 0xa000
    e13c:	680e      	ldr	r6, [r1, #0]

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    e13e:	6406      	str	r6, [r0, #64]	; 0x40
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    e140:	790e      	ldrb	r6, [r1, #4]

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    e142:	f880 6045 	strb.w	r6, [r0, #69]	; 0x45
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    e146:	794e      	ldrb	r6, [r1, #5]

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    e148:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    e14c:	3301      	adds	r3, #1
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    e14e:	1910      	adds	r0, r2, r4
    e150:	88ce      	ldrh	r6, [r1, #6]
    e152:	5316      	strh	r6, [r2, r4]
	for (i = 0; i < DMAC_CH_NUM; i++) {
    e154:	2b20      	cmp	r3, #32
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e156:	60c5      	str	r5, [r0, #12]
    e158:	f101 0108 	add.w	r1, r1, #8
    e15c:	d1e9      	bne.n	e132 <_dma_init+0x52>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e15e:	4b22      	ldr	r3, [pc, #136]	; (e1e8 <_dma_init+0x108>)
    e160:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    e164:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    e168:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e16c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e170:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e174:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e176:	2201      	movs	r2, #1
    e178:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e17c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e180:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e184:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e188:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e18a:	2202      	movs	r2, #2
    e18c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e190:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e194:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e198:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e19c:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e19e:	2204      	movs	r2, #4
    e1a0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e1a4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e1a8:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e1ac:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e1b0:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e1b2:	2208      	movs	r2, #8
    e1b4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e1b8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e1bc:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e1c0:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e1c4:	605a      	str	r2, [r3, #4]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    e1c6:	4a04      	ldr	r2, [pc, #16]	; (e1d8 <_dma_init+0xf8>)
    e1c8:	8813      	ldrh	r3, [r2, #0]
    e1ca:	b29b      	uxth	r3, r3
    e1cc:	f043 0302 	orr.w	r3, r3, #2
    e1d0:	8013      	strh	r3, [r2, #0]
}
    e1d2:	2000      	movs	r0, #0
    e1d4:	bd70      	pop	{r4, r5, r6, pc}
    e1d6:	bf00      	nop
    e1d8:	4100a000 	.word	0x4100a000
    e1dc:	2001c870 	.word	0x2001c870
    e1e0:	2001ca70 	.word	0x2001ca70
    e1e4:	00017318 	.word	0x00017318
    e1e8:	e000e100 	.word	0xe000e100

0000e1ec <_dma_set_irq_state>:
	if (DMA_TRANSFER_COMPLETE_CB == type) {
    e1ec:	b939      	cbnz	r1, e1fe <_dma_set_irq_state+0x12>
	if (value == 0x0) {
    e1ee:	4b08      	ldr	r3, [pc, #32]	; (e210 <_dma_set_irq_state+0x24>)
    e1f0:	0100      	lsls	r0, r0, #4
    e1f2:	2102      	movs	r1, #2
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e1f4:	4418      	add	r0, r3
	if (value == 0x0) {
    e1f6:	b93a      	cbnz	r2, e208 <_dma_set_irq_state+0x1c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e1f8:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
    e1fc:	4770      	bx	lr
	} else if (DMA_TRANSFER_ERROR_CB == type) {
    e1fe:	2901      	cmp	r1, #1
    e200:	d104      	bne.n	e20c <_dma_set_irq_state+0x20>
	if (value == 0x0) {
    e202:	4b03      	ldr	r3, [pc, #12]	; (e210 <_dma_set_irq_state+0x24>)
    e204:	0100      	lsls	r0, r0, #4
    e206:	e7f5      	b.n	e1f4 <_dma_set_irq_state+0x8>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
    e208:	f880 104d 	strb.w	r1, [r0, #77]	; 0x4d
}
    e20c:	4770      	bx	lr
    e20e:	bf00      	nop
    e210:	4100a000 	.word	0x4100a000

0000e214 <_dma_set_destination_address>:
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e214:	4b02      	ldr	r3, [pc, #8]	; (e220 <_dma_set_destination_address+0xc>)
    e216:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e21a:	6081      	str	r1, [r0, #8]
}
    e21c:	2000      	movs	r0, #0
    e21e:	4770      	bx	lr
    e220:	2001c870 	.word	0x2001c870

0000e224 <_dma_set_source_address>:
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e224:	4b02      	ldr	r3, [pc, #8]	; (e230 <_dma_set_source_address+0xc>)
    e226:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e22a:	6041      	str	r1, [r0, #4]
}
    e22c:	2000      	movs	r0, #0
    e22e:	4770      	bx	lr
    e230:	2001c870 	.word	0x2001c870

0000e234 <_dma_srcinc_enable>:
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e234:	4a05      	ldr	r2, [pc, #20]	; (e24c <_dma_srcinc_enable+0x18>)
    e236:	0100      	lsls	r0, r0, #4
    e238:	5a13      	ldrh	r3, [r2, r0]
    e23a:	b29b      	uxth	r3, r3
	tmp &= ~DMAC_BTCTRL_SRCINC;
    e23c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
	tmp |= value << DMAC_BTCTRL_SRCINC_Pos;
    e240:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
    e244:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->BTCTRL.reg = tmp;
    e246:	5211      	strh	r1, [r2, r0]
}
    e248:	2000      	movs	r0, #0
    e24a:	4770      	bx	lr
    e24c:	2001c870 	.word	0x2001c870

0000e250 <_dma_set_data_amount>:
	return ((DmacDescriptor *)hw)->DSTADDR.reg;
    e250:	4b0f      	ldr	r3, [pc, #60]	; (e290 <_dma_set_data_amount+0x40>)
{
    e252:	b570      	push	{r4, r5, r6, lr}
    e254:	0104      	lsls	r4, r0, #4
    e256:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e25a:	6886      	ldr	r6, [r0, #8]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e25c:	5b1a      	ldrh	r2, [r3, r4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e25e:	5b1d      	ldrh	r5, [r3, r4]
	tmp = (tmp & DMAC_BTCTRL_BEATSIZE_Msk) >> DMAC_BTCTRL_BEATSIZE_Pos;
    e260:	f3c2 2201 	ubfx	r2, r2, #8, #2
	if (hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(&_descriptor_section[channel])) {
    e264:	052d      	lsls	r5, r5, #20
		hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e266:	bf42      	ittt	mi
    e268:	fa01 f502 	lslmi.w	r5, r1, r2
    e26c:	19ad      	addmi	r5, r5, r6
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e26e:	6085      	strmi	r5, [r0, #8]
	return ((DmacDescriptor *)hw)->SRCADDR.reg;
    e270:	1918      	adds	r0, r3, r4
    e272:	6845      	ldr	r5, [r0, #4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e274:	5b1e      	ldrh	r6, [r3, r4]
	if (hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(&_descriptor_section[channel])) {
    e276:	0576      	lsls	r6, r6, #21
		hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e278:	bf48      	it	mi
    e27a:	fa01 f202 	lslmi.w	r2, r1, r2
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e27e:	4423      	add	r3, r4
    e280:	bf48      	it	mi
    e282:	1952      	addmi	r2, r2, r5
	hri_dmacdescriptor_write_BTCNT_reg(&_descriptor_section[channel], amount);
    e284:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e286:	bf48      	it	mi
    e288:	6042      	strmi	r2, [r0, #4]
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e28a:	8059      	strh	r1, [r3, #2]
}
    e28c:	2000      	movs	r0, #0
    e28e:	bd70      	pop	{r4, r5, r6, pc}
    e290:	2001c870 	.word	0x2001c870

0000e294 <_dma_enable_transaction>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_VALID;
    e294:	0102      	lsls	r2, r0, #4
{
    e296:	b510      	push	{r4, lr}
    e298:	4c0b      	ldr	r4, [pc, #44]	; (e2c8 <_dma_enable_transaction+0x34>)
    e29a:	5aa3      	ldrh	r3, [r4, r2]
    e29c:	b29b      	uxth	r3, r3
    e29e:	f043 0301 	orr.w	r3, r3, #1
    e2a2:	52a3      	strh	r3, [r4, r2]
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    e2a4:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    e2a8:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    e2ac:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    e2ae:	f042 0202 	orr.w	r2, r2, #2
    e2b2:	641a      	str	r2, [r3, #64]	; 0x40
	if (software_trigger) {
    e2b4:	b131      	cbz	r1, e2c4 <_dma_enable_transaction+0x30>
	((Dmac *)hw)->SWTRIGCTRL.reg |= mask;
    e2b6:	4a05      	ldr	r2, [pc, #20]	; (e2cc <_dma_enable_transaction+0x38>)
		hri_dmac_set_SWTRIGCTRL_reg(DMAC, 1 << channel);
    e2b8:	2301      	movs	r3, #1
    e2ba:	6911      	ldr	r1, [r2, #16]
    e2bc:	fa03 f000 	lsl.w	r0, r3, r0
    e2c0:	4308      	orrs	r0, r1
    e2c2:	6110      	str	r0, [r2, #16]
}
    e2c4:	2000      	movs	r0, #0
    e2c6:	bd10      	pop	{r4, pc}
    e2c8:	2001c870 	.word	0x2001c870
    e2cc:	4100a000 	.word	0x4100a000

0000e2d0 <_dma_get_channel_resource>:
	*resource = &_resources[channel];
    e2d0:	4b03      	ldr	r3, [pc, #12]	; (e2e0 <_dma_get_channel_resource+0x10>)
    e2d2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    e2d6:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    e2da:	6001      	str	r1, [r0, #0]
}
    e2dc:	2000      	movs	r0, #0
    e2de:	4770      	bx	lr
    e2e0:	200089c0 	.word	0x200089c0

0000e2e4 <DMAC_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void DMAC_0_Handler(void)
{
	_dmac_handler();
    e2e4:	4b00      	ldr	r3, [pc, #0]	; (e2e8 <DMAC_0_Handler+0x4>)
    e2e6:	4718      	bx	r3
    e2e8:	0000e095 	.word	0x0000e095

0000e2ec <DMAC_1_Handler>:
    e2ec:	4b00      	ldr	r3, [pc, #0]	; (e2f0 <DMAC_1_Handler+0x4>)
    e2ee:	4718      	bx	r3
    e2f0:	0000e095 	.word	0x0000e095

0000e2f4 <DMAC_2_Handler>:
    e2f4:	4b00      	ldr	r3, [pc, #0]	; (e2f8 <DMAC_2_Handler+0x4>)
    e2f6:	4718      	bx	r3
    e2f8:	0000e095 	.word	0x0000e095

0000e2fc <DMAC_3_Handler>:
    e2fc:	4b00      	ldr	r3, [pc, #0]	; (e300 <DMAC_3_Handler+0x4>)
    e2fe:	4718      	bx	r3
    e300:	0000e095 	.word	0x0000e095

0000e304 <DMAC_4_Handler>:
    e304:	4b00      	ldr	r3, [pc, #0]	; (e308 <DMAC_4_Handler+0x4>)
    e306:	4718      	bx	r3
    e308:	0000e095 	.word	0x0000e095

0000e30c <adc_async_window_threshold_reached>:

static void adc_async_window_threshold_reached(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.monitor) {
    e30c:	6983      	ldr	r3, [r0, #24]
    e30e:	b103      	cbz	r3, e312 <adc_async_window_threshold_reached+0x6>
		descr->adc_async_cb.monitor(descr, channel);
    e310:	4718      	bx	r3
	}
}
    e312:	4770      	bx	lr

0000e314 <adc_async_error_occured>:

static void adc_async_error_occured(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.error) {
    e314:	69c3      	ldr	r3, [r0, #28]
    e316:	b103      	cbz	r3, e31a <adc_async_error_occured+0x6>
		descr->adc_async_cb.error(descr, channel);
    e318:	4718      	bx	r3
	}
}
    e31a:	4770      	bx	lr

0000e31c <adc_async_channel_conversion_done>:
{
    e31c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t                              index    = descr->channel_map[channel];
    e320:	6a03      	ldr	r3, [r0, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e322:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
    e326:	5c5c      	ldrb	r4, [r3, r1]
	ringbuffer_put(&descr_ch->convert, data);
    e328:	f8df a054 	ldr.w	sl, [pc, #84]	; e380 <adc_async_channel_conversion_done+0x64>
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e32c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e330:	ea4f 09c4 	mov.w	r9, r4, lsl #3
    e334:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
	ringbuffer_put(&descr_ch->convert, data);
    e338:	f104 0b04 	add.w	fp, r4, #4
{
    e33c:	4605      	mov	r5, r0
    e33e:	460e      	mov	r6, r1
	ringbuffer_put(&descr_ch->convert, data);
    e340:	4658      	mov	r0, fp
    e342:	b2d1      	uxtb	r1, r2
{
    e344:	4617      	mov	r7, r2
	ringbuffer_put(&descr_ch->convert, data);
    e346:	47d0      	blx	sl
	if (1 < _adc_async_get_data_size(&descr->device)) {
    e348:	4b0c      	ldr	r3, [pc, #48]	; (e37c <adc_async_channel_conversion_done+0x60>)
    e34a:	4628      	mov	r0, r5
    e34c:	4798      	blx	r3
    e34e:	2801      	cmp	r0, #1
    e350:	d905      	bls.n	e35e <adc_async_channel_conversion_done+0x42>
		ringbuffer_put(&descr_ch->convert, data >> 8);
    e352:	0a39      	lsrs	r1, r7, #8
    e354:	4658      	mov	r0, fp
    e356:	47d0      	blx	sl
		++descr_ch->bytes_in_buffer;
    e358:	8aa3      	ldrh	r3, [r4, #20]
    e35a:	3301      	adds	r3, #1
    e35c:	82a3      	strh	r3, [r4, #20]
	++descr_ch->bytes_in_buffer;
    e35e:	8aa3      	ldrh	r3, [r4, #20]
    e360:	3301      	adds	r3, #1
    e362:	82a3      	strh	r3, [r4, #20]
	if (descr_ch->adc_async_ch_cb.convert_done) {
    e364:	f858 3009 	ldr.w	r3, [r8, r9]
    e368:	b12b      	cbz	r3, e376 <adc_async_channel_conversion_done+0x5a>
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e36a:	4631      	mov	r1, r6
    e36c:	4628      	mov	r0, r5
}
    e36e:	b001      	add	sp, #4
    e370:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e374:	4718      	bx	r3
}
    e376:	b001      	add	sp, #4
    e378:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e37c:	0001300d 	.word	0x0001300d
    e380:	00011af1 	.word	0x00011af1

0000e384 <adc_async_init>:
{
    e384:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e388:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    e38c:	f89d 8020 	ldrb.w	r8, [sp, #32]
    e390:	460e      	mov	r6, r1
    e392:	4615      	mov	r5, r2
    e394:	461f      	mov	r7, r3
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e396:	4604      	mov	r4, r0
    e398:	b150      	cbz	r0, e3b0 <adc_async_init+0x2c>
    e39a:	2900      	cmp	r1, #0
    e39c:	d032      	beq.n	e404 <adc_async_init+0x80>
    e39e:	2a00      	cmp	r2, #0
    e3a0:	d032      	beq.n	e408 <adc_async_init+0x84>
    e3a2:	f1b8 0f00 	cmp.w	r8, #0
    e3a6:	d031      	beq.n	e40c <adc_async_init+0x88>
    e3a8:	f1b9 0000 	subs.w	r0, r9, #0
    e3ac:	bf18      	it	ne
    e3ae:	2001      	movne	r0, #1
    e3b0:	4917      	ldr	r1, [pc, #92]	; (e410 <adc_async_init+0x8c>)
    e3b2:	f8df a070 	ldr.w	sl, [pc, #112]	; e424 <adc_async_init+0xa0>
    e3b6:	223f      	movs	r2, #63	; 0x3f
    e3b8:	47d0      	blx	sl
	ASSERT(channel_amount <= (channel_max + 1));
    e3ba:	1c78      	adds	r0, r7, #1
    e3bc:	4580      	cmp	r8, r0
    e3be:	4914      	ldr	r1, [pc, #80]	; (e410 <adc_async_init+0x8c>)
    e3c0:	f04f 0240 	mov.w	r2, #64	; 0x40
    e3c4:	bfcc      	ite	gt
    e3c6:	2000      	movgt	r0, #0
    e3c8:	2001      	movle	r0, #1
    e3ca:	47d0      	blx	sl
	device = &descr->device;
    e3cc:	2300      	movs	r3, #0
		channel_map[i] = 0xFF;
    e3ce:	21ff      	movs	r1, #255	; 0xff
    e3d0:	b2da      	uxtb	r2, r3
    e3d2:	3301      	adds	r3, #1
    e3d4:	54a9      	strb	r1, [r5, r2]
	for (uint8_t i = 0; i <= channel_max; i++) {
    e3d6:	b2da      	uxtb	r2, r3
    e3d8:	4297      	cmp	r7, r2
    e3da:	d2f9      	bcs.n	e3d0 <adc_async_init+0x4c>
	init_status           = _adc_async_init(device, hw);
    e3dc:	4b0d      	ldr	r3, [pc, #52]	; (e414 <adc_async_init+0x90>)
	descr->channel_map    = channel_map;
    e3de:	6225      	str	r5, [r4, #32]
	descr->channel_max    = channel_max;
    e3e0:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	descr->channel_amount = channel_amount;
    e3e4:	f884 8025 	strb.w	r8, [r4, #37]	; 0x25
	descr->descr_ch       = descr_ch;
    e3e8:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	init_status           = _adc_async_init(device, hw);
    e3ec:	4631      	mov	r1, r6
    e3ee:	4620      	mov	r0, r4
    e3f0:	4798      	blx	r3
	if (init_status) {
    e3f2:	b928      	cbnz	r0, e400 <adc_async_init+0x7c>
	device->adc_async_ch_cb.convert_done = adc_async_channel_conversion_done;
    e3f4:	4b08      	ldr	r3, [pc, #32]	; (e418 <adc_async_init+0x94>)
    e3f6:	60a3      	str	r3, [r4, #8]
	device->adc_async_cb.window_cb       = adc_async_window_threshold_reached;
    e3f8:	4b08      	ldr	r3, [pc, #32]	; (e41c <adc_async_init+0x98>)
    e3fa:	6023      	str	r3, [r4, #0]
	device->adc_async_cb.error_cb        = adc_async_error_occured;
    e3fc:	4b08      	ldr	r3, [pc, #32]	; (e420 <adc_async_init+0x9c>)
    e3fe:	6063      	str	r3, [r4, #4]
}
    e400:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e404:	4608      	mov	r0, r1
    e406:	e7d3      	b.n	e3b0 <adc_async_init+0x2c>
    e408:	4610      	mov	r0, r2
    e40a:	e7d1      	b.n	e3b0 <adc_async_init+0x2c>
    e40c:	4640      	mov	r0, r8
    e40e:	e7cf      	b.n	e3b0 <adc_async_init+0x2c>
    e410:	00017418 	.word	0x00017418
    e414:	00012f35 	.word	0x00012f35
    e418:	0000e31d 	.word	0x0000e31d
    e41c:	0000e30d 	.word	0x0000e30d
    e420:	0000e315 	.word	0x0000e315
    e424:	0000e08d 	.word	0x0000e08d

0000e428 <adc_async_register_channel_buffer>:
{
    e428:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e42c:	460e      	mov	r6, r1
    e42e:	4617      	mov	r7, r2
    e430:	4698      	mov	r8, r3
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e432:	4604      	mov	r4, r0
    e434:	b118      	cbz	r0, e43e <adc_async_register_channel_buffer+0x16>
    e436:	b1c2      	cbz	r2, e46a <adc_async_register_channel_buffer+0x42>
    e438:	1e18      	subs	r0, r3, #0
    e43a:	bf18      	it	ne
    e43c:	2001      	movne	r0, #1
    e43e:	4921      	ldr	r1, [pc, #132]	; (e4c4 <adc_async_register_channel_buffer+0x9c>)
    e440:	4d21      	ldr	r5, [pc, #132]	; (e4c8 <adc_async_register_channel_buffer+0xa0>)
    e442:	2266      	movs	r2, #102	; 0x66
    e444:	47a8      	blx	r5
	ASSERT(descr->channel_max >= channel);
    e446:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e44a:	491e      	ldr	r1, [pc, #120]	; (e4c4 <adc_async_register_channel_buffer+0x9c>)
    e44c:	42b0      	cmp	r0, r6
    e44e:	f04f 0267 	mov.w	r2, #103	; 0x67
    e452:	bf34      	ite	cc
    e454:	2000      	movcc	r0, #0
    e456:	2001      	movcs	r0, #1
    e458:	47a8      	blx	r5
	if (descr->channel_map[channel] != 0xFF) {
    e45a:	6a23      	ldr	r3, [r4, #32]
    e45c:	5d9a      	ldrb	r2, [r3, r6]
    e45e:	2aff      	cmp	r2, #255	; 0xff
    e460:	d005      	beq.n	e46e <adc_async_register_channel_buffer+0x46>
		return ERR_INVALID_ARG;
    e462:	f06f 000c 	mvn.w	r0, #12
}
    e466:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e46a:	4610      	mov	r0, r2
    e46c:	e7e7      	b.n	e43e <adc_async_register_channel_buffer+0x16>
	for (i = 0; i <= descr->channel_max; i++) {
    e46e:	2200      	movs	r2, #0
    e470:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	uint8_t i, index = 0;
    e474:	4615      	mov	r5, r2
		if (descr->channel_map[i] != 0xFF) {
    e476:	b2d1      	uxtb	r1, r2
    e478:	3201      	adds	r2, #1
    e47a:	5c59      	ldrb	r1, [r3, r1]
    e47c:	29ff      	cmp	r1, #255	; 0xff
			index++;
    e47e:	bf18      	it	ne
    e480:	3501      	addne	r5, #1
	for (i = 0; i <= descr->channel_max; i++) {
    e482:	b2d1      	uxtb	r1, r2
			index++;
    e484:	bf18      	it	ne
    e486:	b2ed      	uxtbne	r5, r5
	for (i = 0; i <= descr->channel_max; i++) {
    e488:	4288      	cmp	r0, r1
    e48a:	d2f4      	bcs.n	e476 <adc_async_register_channel_buffer+0x4e>
	if (index > descr->channel_amount) {
    e48c:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e490:	42ab      	cmp	r3, r5
    e492:	d313      	bcc.n	e4bc <adc_async_register_channel_buffer+0x94>
	if (ERR_NONE != ringbuffer_init(&descr->descr_ch[index].convert, convert_buffer, convert_buffer_length)) {
    e494:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e496:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    e49a:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    e49e:	ea4f 09c3 	mov.w	r9, r3, lsl #3
    e4a2:	4642      	mov	r2, r8
    e4a4:	4b09      	ldr	r3, [pc, #36]	; (e4cc <adc_async_register_channel_buffer+0xa4>)
    e4a6:	4639      	mov	r1, r7
    e4a8:	3004      	adds	r0, #4
    e4aa:	4798      	blx	r3
    e4ac:	2800      	cmp	r0, #0
    e4ae:	d1d8      	bne.n	e462 <adc_async_register_channel_buffer+0x3a>
	descr->channel_map[channel]            = index;
    e4b0:	6a23      	ldr	r3, [r4, #32]
    e4b2:	559d      	strb	r5, [r3, r6]
	descr->descr_ch[index].bytes_in_buffer = 0;
    e4b4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e4b6:	444b      	add	r3, r9
    e4b8:	8298      	strh	r0, [r3, #20]
	return ERR_NONE;
    e4ba:	e7d4      	b.n	e466 <adc_async_register_channel_buffer+0x3e>
		return ERR_NO_RESOURCE;
    e4bc:	f06f 001b 	mvn.w	r0, #27
    e4c0:	e7d1      	b.n	e466 <adc_async_register_channel_buffer+0x3e>
    e4c2:	bf00      	nop
    e4c4:	00017418 	.word	0x00017418
    e4c8:	0000e08d 	.word	0x0000e08d
    e4cc:	00011a75 	.word	0x00011a75

0000e4d0 <adc_async_enable_channel>:
{
    e4d0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    e4d2:	4604      	mov	r4, r0
    e4d4:	3800      	subs	r0, #0
{
    e4d6:	460d      	mov	r5, r1
	ASSERT(descr);
    e4d8:	bf18      	it	ne
    e4da:	2001      	movne	r0, #1
    e4dc:	4e09      	ldr	r6, [pc, #36]	; (e504 <adc_async_enable_channel+0x34>)
    e4de:	490a      	ldr	r1, [pc, #40]	; (e508 <adc_async_enable_channel+0x38>)
    e4e0:	2283      	movs	r2, #131	; 0x83
    e4e2:	47b0      	blx	r6
	ASSERT(descr->channel_max >= channel);
    e4e4:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e4e8:	4907      	ldr	r1, [pc, #28]	; (e508 <adc_async_enable_channel+0x38>)
    e4ea:	42a8      	cmp	r0, r5
    e4ec:	bf34      	ite	cc
    e4ee:	2000      	movcc	r0, #0
    e4f0:	2001      	movcs	r0, #1
    e4f2:	2284      	movs	r2, #132	; 0x84
    e4f4:	47b0      	blx	r6
	_adc_async_enable_channel(&descr->device, channel);
    e4f6:	4620      	mov	r0, r4
    e4f8:	4b04      	ldr	r3, [pc, #16]	; (e50c <adc_async_enable_channel+0x3c>)
    e4fa:	4629      	mov	r1, r5
    e4fc:	4798      	blx	r3
}
    e4fe:	2000      	movs	r0, #0
    e500:	bd70      	pop	{r4, r5, r6, pc}
    e502:	bf00      	nop
    e504:	0000e08d 	.word	0x0000e08d
    e508:	00017418 	.word	0x00017418
    e50c:	00013001 	.word	0x00013001

0000e510 <adc_async_register_callback>:
{
    e510:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(descr);
    e514:	4604      	mov	r4, r0
    e516:	3800      	subs	r0, #0
    e518:	bf18      	it	ne
    e51a:	2001      	movne	r0, #1
    e51c:	f8df 8064 	ldr.w	r8, [pc, #100]	; e584 <adc_async_register_callback+0x74>
{
    e520:	460f      	mov	r7, r1
    e522:	4615      	mov	r5, r2
	ASSERT(descr);
    e524:	4915      	ldr	r1, [pc, #84]	; (e57c <adc_async_register_callback+0x6c>)
    e526:	229c      	movs	r2, #156	; 0x9c
{
    e528:	461e      	mov	r6, r3
	ASSERT(descr);
    e52a:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e52c:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e530:	4912      	ldr	r1, [pc, #72]	; (e57c <adc_async_register_callback+0x6c>)
    e532:	42b8      	cmp	r0, r7
    e534:	bf34      	ite	cc
    e536:	2000      	movcc	r0, #0
    e538:	2001      	movcs	r0, #1
    e53a:	229d      	movs	r2, #157	; 0x9d
    e53c:	47c0      	blx	r8
	switch (type) {
    e53e:	2d01      	cmp	r5, #1
    e540:	d014      	beq.n	e56c <adc_async_register_callback+0x5c>
    e542:	2d02      	cmp	r5, #2
    e544:	d014      	beq.n	e570 <adc_async_register_callback+0x60>
    e546:	b9ad      	cbnz	r5, e574 <adc_async_register_callback+0x64>
	uint8_t index = descr->channel_map[channel];
    e548:	6a23      	ldr	r3, [r4, #32]
		descr->descr_ch[index].adc_async_ch_cb.convert_done = cb;
    e54a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e54c:	5ddb      	ldrb	r3, [r3, r7]
    e54e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e552:	f842 6033 	str.w	r6, [r2, r3, lsl #3]
	_adc_async_set_irq_state(&descr->device, channel, (enum _adc_async_callback_type)type, cb != NULL);
    e556:	1e33      	subs	r3, r6, #0
    e558:	4620      	mov	r0, r4
    e55a:	bf18      	it	ne
    e55c:	2301      	movne	r3, #1
    e55e:	4c08      	ldr	r4, [pc, #32]	; (e580 <adc_async_register_callback+0x70>)
    e560:	462a      	mov	r2, r5
    e562:	4639      	mov	r1, r7
    e564:	47a0      	blx	r4
	return ERR_NONE;
    e566:	2000      	movs	r0, #0
}
    e568:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		descr->adc_async_cb.monitor = cb;
    e56c:	61a6      	str	r6, [r4, #24]
		break;
    e56e:	e7f2      	b.n	e556 <adc_async_register_callback+0x46>
		descr->adc_async_cb.error = cb;
    e570:	61e6      	str	r6, [r4, #28]
		break;
    e572:	e7f0      	b.n	e556 <adc_async_register_callback+0x46>
	switch (type) {
    e574:	f06f 000c 	mvn.w	r0, #12
    e578:	e7f6      	b.n	e568 <adc_async_register_callback+0x58>
    e57a:	bf00      	nop
    e57c:	00017418 	.word	0x00017418
    e580:	00013039 	.word	0x00013039
    e584:	0000e08d 	.word	0x0000e08d

0000e588 <adc_async_read_channel>:
{
    e588:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    e58c:	460e      	mov	r6, r1
    e58e:	4617      	mov	r7, r2
    e590:	461d      	mov	r5, r3
	ASSERT(descr && buffer && length);
    e592:	4604      	mov	r4, r0
    e594:	b120      	cbz	r0, e5a0 <adc_async_read_channel+0x18>
    e596:	2a00      	cmp	r2, #0
    e598:	d03f      	beq.n	e61a <adc_async_read_channel+0x92>
    e59a:	1e18      	subs	r0, r3, #0
    e59c:	bf18      	it	ne
    e59e:	2001      	movne	r0, #1
    e5a0:	f8df 8098 	ldr.w	r8, [pc, #152]	; e63c <adc_async_read_channel+0xb4>
    e5a4:	4920      	ldr	r1, [pc, #128]	; (e628 <adc_async_read_channel+0xa0>)
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e5a6:	f8df a098 	ldr.w	sl, [pc, #152]	; e640 <adc_async_read_channel+0xb8>
	ASSERT(descr && buffer && length);
    e5aa:	22bc      	movs	r2, #188	; 0xbc
    e5ac:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e5ae:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e5b2:	491d      	ldr	r1, [pc, #116]	; (e628 <adc_async_read_channel+0xa0>)
    e5b4:	42b0      	cmp	r0, r6
    e5b6:	bf34      	ite	cc
    e5b8:	2000      	movcc	r0, #0
    e5ba:	2001      	movcs	r0, #1
    e5bc:	22bd      	movs	r2, #189	; 0xbd
    e5be:	47c0      	blx	r8
	data_size = _adc_async_get_data_size(&descr->device);
    e5c0:	4b1a      	ldr	r3, [pc, #104]	; (e62c <adc_async_read_channel+0xa4>)
    e5c2:	4620      	mov	r0, r4
    e5c4:	4798      	blx	r3
	ASSERT(!(length % data_size));
    e5c6:	fbb5 f3f0 	udiv	r3, r5, r0
    e5ca:	fb03 5010 	mls	r0, r3, r0, r5
    e5ce:	fab0 f080 	clz	r0, r0
    e5d2:	4915      	ldr	r1, [pc, #84]	; (e628 <adc_async_read_channel+0xa0>)
    e5d4:	22bf      	movs	r2, #191	; 0xbf
    e5d6:	0940      	lsrs	r0, r0, #5
    e5d8:	47c0      	blx	r8
	index                                         = descr->channel_map[channel];
    e5da:	6a23      	ldr	r3, [r4, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e5dc:	5d9e      	ldrb	r6, [r3, r6]
    e5de:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e5e0:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    e5e4:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
	CRITICAL_SECTION_ENTER()
    e5e8:	a801      	add	r0, sp, #4
    e5ea:	4b11      	ldr	r3, [pc, #68]	; (e630 <adc_async_read_channel+0xa8>)
	num = ringbuffer_num(&descr_ch->convert);
    e5ec:	f106 0904 	add.w	r9, r6, #4
	CRITICAL_SECTION_ENTER()
    e5f0:	4798      	blx	r3
	num = ringbuffer_num(&descr_ch->convert);
    e5f2:	4b10      	ldr	r3, [pc, #64]	; (e634 <adc_async_read_channel+0xac>)
    e5f4:	4648      	mov	r0, r9
    e5f6:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    e5f8:	4b0f      	ldr	r3, [pc, #60]	; (e638 <adc_async_read_channel+0xb0>)
	num = ringbuffer_num(&descr_ch->convert);
    e5fa:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
    e5fc:	a801      	add	r0, sp, #4
    e5fe:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    e600:	2400      	movs	r4, #0
    e602:	45a0      	cmp	r8, r4
    e604:	b2a2      	uxth	r2, r4
    e606:	d001      	beq.n	e60c <adc_async_read_channel+0x84>
    e608:	42a5      	cmp	r5, r4
    e60a:	d108      	bne.n	e61e <adc_async_read_channel+0x96>
	descr_ch->bytes_in_buffer -= was_read;
    e60c:	8ab3      	ldrh	r3, [r6, #20]
}
    e60e:	4620      	mov	r0, r4
	descr_ch->bytes_in_buffer -= was_read;
    e610:	1a9b      	subs	r3, r3, r2
    e612:	82b3      	strh	r3, [r6, #20]
}
    e614:	b002      	add	sp, #8
    e616:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && buffer && length);
    e61a:	4610      	mov	r0, r2
    e61c:	e7c0      	b.n	e5a0 <adc_async_read_channel+0x18>
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e61e:	1939      	adds	r1, r7, r4
    e620:	4648      	mov	r0, r9
    e622:	47d0      	blx	sl
    e624:	3401      	adds	r4, #1
    e626:	e7ec      	b.n	e602 <adc_async_read_channel+0x7a>
    e628:	00017418 	.word	0x00017418
    e62c:	0001300d 	.word	0x0001300d
    e630:	00011b59 	.word	0x00011b59
    e634:	00011b35 	.word	0x00011b35
    e638:	00011b67 	.word	0x00011b67
    e63c:	0000e08d 	.word	0x0000e08d
    e640:	00011ab1 	.word	0x00011ab1

0000e644 <adc_async_start_conversion>:
{
    e644:	b510      	push	{r4, lr}
	ASSERT(descr);
    e646:	4604      	mov	r4, r0
    e648:	3800      	subs	r0, #0
    e64a:	bf18      	it	ne
    e64c:	2001      	movne	r0, #1
    e64e:	4904      	ldr	r1, [pc, #16]	; (e660 <adc_async_start_conversion+0x1c>)
    e650:	4b04      	ldr	r3, [pc, #16]	; (e664 <adc_async_start_conversion+0x20>)
    e652:	22d6      	movs	r2, #214	; 0xd6
    e654:	4798      	blx	r3
	_adc_async_convert(&descr->device);
    e656:	4620      	mov	r0, r4
    e658:	4b03      	ldr	r3, [pc, #12]	; (e668 <adc_async_start_conversion+0x24>)
    e65a:	4798      	blx	r3
}
    e65c:	2000      	movs	r0, #0
    e65e:	bd10      	pop	{r4, pc}
    e660:	00017418 	.word	0x00017418
    e664:	0000e08d 	.word	0x0000e08d
    e668:	00013021 	.word	0x00013021

0000e66c <_oscctrl_init_sources>:
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    e66c:	4770      	bx	lr
	...

0000e670 <_oscctrl_init_referenced_generators>:

static inline void hri_gclk_write_GENCTRL_SRC_bf(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	uint32_t tmp;
	GCLK_CRITICAL_SECTION_ENTER();
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    e670:	4b3b      	ldr	r3, [pc, #236]	; (e760 <_oscctrl_init_referenced_generators+0xf0>)
    e672:	6a1a      	ldr	r2, [r3, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    e674:	f022 020f 	bic.w	r2, r2, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    e678:	f042 0204 	orr.w	r2, r2, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    e67c:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    e67e:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    e682:	6859      	ldr	r1, [r3, #4]
    e684:	4211      	tst	r1, r2
    e686:	d1fc      	bne.n	e682 <_oscctrl_init_referenced_generators+0x12>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    e688:	685a      	ldr	r2, [r3, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    e68a:	0750      	lsls	r0, r2, #29
    e68c:	f3c2 0180 	ubfx	r1, r2, #2, #1
    e690:	d4fa      	bmi.n	e688 <_oscctrl_init_referenced_generators+0x18>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e692:	4b34      	ldr	r3, [pc, #208]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    e694:	4a34      	ldr	r2, [pc, #208]	; (e768 <_oscctrl_init_referenced_generators+0xf8>)
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e696:	7719      	strb	r1, [r3, #28]
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    e698:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e69a:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    e69e:	f3c2 1100 	ubfx	r1, r2, #4, #1
    e6a2:	06d2      	lsls	r2, r2, #27
    e6a4:	d4f9      	bmi.n	e69a <_oscctrl_init_referenced_generators+0x2a>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    e6a6:	f883 1020 	strb.w	r1, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e6aa:	4b2e      	ldr	r3, [pc, #184]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
    e6ac:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    e6b0:	0750      	lsls	r0, r2, #29
    e6b2:	d4fb      	bmi.n	e6ac <_oscctrl_init_referenced_generators+0x3c>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e6b4:	2202      	movs	r2, #2
    e6b6:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e6b8:	4b2a      	ldr	r3, [pc, #168]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
    e6ba:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    e6be:	0791      	lsls	r1, r2, #30
    e6c0:	d4fb      	bmi.n	e6ba <_oscctrl_init_referenced_generators+0x4a>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    e6c2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    e6c4:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e6c6:	4b27      	ldr	r3, [pc, #156]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
    e6c8:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    e6cc:	0712      	lsls	r2, r2, #28
    e6ce:	d4fb      	bmi.n	e6c8 <_oscctrl_init_referenced_generators+0x58>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    e6d0:	2288      	movs	r2, #136	; 0x88
    e6d2:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e6d6:	4a23      	ldr	r2, [pc, #140]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
    e6d8:	4613      	mov	r3, r2
    e6da:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    e6de:	0748      	lsls	r0, r1, #29
    e6e0:	d4fb      	bmi.n	e6da <_oscctrl_init_referenced_generators+0x6a>
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    e6e2:	491f      	ldr	r1, [pc, #124]	; (e760 <_oscctrl_init_referenced_generators+0xf0>)
    e6e4:	2042      	movs	r0, #66	; 0x42
    e6e6:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    e6ea:	2127      	movs	r1, #39	; 0x27
    e6ec:	6491      	str	r1, [r2, #72]	; 0x48
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    e6ee:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    e6f0:	f012 0f06 	tst.w	r2, #6
    e6f4:	d1fb      	bne.n	e6ee <_oscctrl_init_referenced_generators+0x7e>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    e6f6:	f44f 6200 	mov.w	r2, #2048	; 0x800
    e6fa:	64da      	str	r2, [r3, #76]	; 0x4c
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    e6fc:	2202      	movs	r2, #2
    e6fe:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    e702:	4b18      	ldr	r3, [pc, #96]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
    e704:	461a      	mov	r2, r3
    e706:	6d19      	ldr	r1, [r3, #80]	; 0x50
    e708:	0789      	lsls	r1, r1, #30
    e70a:	d4fc      	bmi.n	e706 <_oscctrl_init_referenced_generators+0x96>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    e70c:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    e710:	07db      	lsls	r3, r3, #31
    e712:	d521      	bpl.n	e758 <_oscctrl_init_referenced_generators+0xe8>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    e714:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    e716:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    e71a:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    e71e:	d1f9      	bne.n	e714 <_oscctrl_init_referenced_generators+0xa4>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    e720:	4b10      	ldr	r3, [pc, #64]	; (e764 <_oscctrl_init_referenced_generators+0xf4>)
    e722:	6d5a      	ldr	r2, [r3, #84]	; 0x54
#endif
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 1) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 1)))
    e724:	07d1      	lsls	r1, r2, #31
    e726:	d402      	bmi.n	e72e <_oscctrl_init_referenced_generators+0xbe>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    e728:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    e72a:	0792      	lsls	r2, r2, #30
    e72c:	d5f9      	bpl.n	e722 <_oscctrl_init_referenced_generators+0xb2>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    e72e:	4a0c      	ldr	r2, [pc, #48]	; (e760 <_oscctrl_init_referenced_generators+0xf0>)
    e730:	4611      	mov	r1, r2
    e732:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    e734:	2b00      	cmp	r3, #0
    e736:	d1fc      	bne.n	e732 <_oscctrl_init_referenced_generators+0xc2>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    e738:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    e73a:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    e73e:	f043 0308 	orr.w	r3, r3, #8
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    e742:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    e744:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    e748:	684a      	ldr	r2, [r1, #4]
    e74a:	421a      	tst	r2, r3
    e74c:	d1fc      	bne.n	e748 <_oscctrl_init_referenced_generators+0xd8>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    e74e:	4a04      	ldr	r2, [pc, #16]	; (e760 <_oscctrl_init_referenced_generators+0xf0>)
    e750:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    e752:	075b      	lsls	r3, r3, #29
    e754:	d4fc      	bmi.n	e750 <_oscctrl_init_referenced_generators+0xe0>
		;
#endif
	(void)hw;
}
    e756:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    e758:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    e75a:	05d8      	lsls	r0, r3, #23
    e75c:	d5fc      	bpl.n	e758 <_oscctrl_init_referenced_generators+0xe8>
    e75e:	e7df      	b.n	e720 <_oscctrl_init_referenced_generators+0xb0>
    e760:	40001c00 	.word	0x40001c00
    e764:	40001000 	.word	0x40001000
    e768:	04010000 	.word	0x04010000

0000e76c <_rand_sync_read_data>:

/**
 * \brief Read data bits
 */
static uint32_t _rand_sync_read_data(const struct _rand_sync_dev *dev, const uint8_t n_bits)
{
    e76c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    e770:	f890 8004 	ldrb.w	r8, [r0, #4]
    e774:	f8df 9034 	ldr.w	r9, [pc, #52]	; e7ac <_rand_sync_read_data+0x40>
{
    e778:	4605      	mov	r5, r0
    e77a:	460f      	mov	r7, r1
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    e77c:	f1b8 0f00 	cmp.w	r8, #0
    e780:	d00f      	beq.n	e7a2 <_rand_sync_read_data+0x36>
	if (r_bits < n_bits) {
    e782:	4588      	cmp	r8, r1
    e784:	d20d      	bcs.n	e7a2 <_rand_sync_read_data+0x36>
		uint8_t  i;
		uint32_t d = 0;
    e786:	2600      	movs	r6, #0
		/* Join read bits */
		for (i = 0; i < n_bits; i += r_bits) {
    e788:	4634      	mov	r4, r6
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    e78a:	4628      	mov	r0, r5
    e78c:	47c8      	blx	r9
    e78e:	40a0      	lsls	r0, r4
		for (i = 0; i < n_bits; i += r_bits) {
    e790:	4444      	add	r4, r8
    e792:	b2e4      	uxtb	r4, r4
    e794:	42a7      	cmp	r7, r4
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    e796:	ea46 0600 	orr.w	r6, r6, r0
		for (i = 0; i < n_bits; i += r_bits) {
    e79a:	d8f6      	bhi.n	e78a <_rand_sync_read_data+0x1e>
		}
		return d;
	} else {
		return _rand_sync_read_one(dev);
	}
}
    e79c:	4630      	mov	r0, r6
    e79e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return _rand_sync_read_one(dev);
    e7a2:	4628      	mov	r0, r5
    e7a4:	464b      	mov	r3, r9
}
    e7a6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return _rand_sync_read_one(dev);
    e7aa:	4718      	bx	r3
    e7ac:	0000e8b1 	.word	0x0000e8b1

0000e7b0 <rand_sync_init>:
{
    e7b0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(desc);
    e7b2:	4604      	mov	r4, r0
    e7b4:	3800      	subs	r0, #0
{
    e7b6:	460d      	mov	r5, r1
	ASSERT(desc);
    e7b8:	4b05      	ldr	r3, [pc, #20]	; (e7d0 <rand_sync_init+0x20>)
    e7ba:	4906      	ldr	r1, [pc, #24]	; (e7d4 <rand_sync_init+0x24>)
    e7bc:	bf18      	it	ne
    e7be:	2001      	movne	r0, #1
    e7c0:	2229      	movs	r2, #41	; 0x29
    e7c2:	4798      	blx	r3
	return _rand_sync_init(&desc->dev, hw);
    e7c4:	4629      	mov	r1, r5
    e7c6:	4620      	mov	r0, r4
    e7c8:	4b03      	ldr	r3, [pc, #12]	; (e7d8 <rand_sync_init+0x28>)
}
    e7ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _rand_sync_init(&desc->dev, hw);
    e7ce:	4718      	bx	r3
    e7d0:	0000e08d 	.word	0x0000e08d
    e7d4:	00017433 	.word	0x00017433
    e7d8:	0000e831 	.word	0x0000e831

0000e7dc <rand_sync_enable>:
{
    e7dc:	b510      	push	{r4, lr}
	ASSERT(desc);
    e7de:	4604      	mov	r4, r0
    e7e0:	3800      	subs	r0, #0
    e7e2:	4b05      	ldr	r3, [pc, #20]	; (e7f8 <rand_sync_enable+0x1c>)
    e7e4:	4905      	ldr	r1, [pc, #20]	; (e7fc <rand_sync_enable+0x20>)
    e7e6:	bf18      	it	ne
    e7e8:	2001      	movne	r0, #1
    e7ea:	2236      	movs	r2, #54	; 0x36
    e7ec:	4798      	blx	r3
	return _rand_sync_enable(&desc->dev);
    e7ee:	4620      	mov	r0, r4
    e7f0:	4b03      	ldr	r3, [pc, #12]	; (e800 <rand_sync_enable+0x24>)
}
    e7f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _rand_sync_enable(&desc->dev);
    e7f6:	4718      	bx	r3
    e7f8:	0000e08d 	.word	0x0000e08d
    e7fc:	00017433 	.word	0x00017433
    e800:	0000e879 	.word	0x0000e879

0000e804 <rand_sync_read8>:

uint8_t rand_sync_read8(const struct rand_sync_desc *const desc)
{
    e804:	b510      	push	{r4, lr}
	ASSERT(desc);
    e806:	4604      	mov	r4, r0
    e808:	3800      	subs	r0, #0
    e80a:	bf18      	it	ne
    e80c:	2001      	movne	r0, #1
    e80e:	225b      	movs	r2, #91	; 0x5b
    e810:	4904      	ldr	r1, [pc, #16]	; (e824 <rand_sync_read8+0x20>)
    e812:	4b05      	ldr	r3, [pc, #20]	; (e828 <rand_sync_read8+0x24>)
    e814:	4798      	blx	r3
	return (uint8_t)_rand_sync_read_data(&desc->dev, 8);
    e816:	4b05      	ldr	r3, [pc, #20]	; (e82c <rand_sync_read8+0x28>)
    e818:	2108      	movs	r1, #8
    e81a:	4620      	mov	r0, r4
    e81c:	4798      	blx	r3
}
    e81e:	b2c0      	uxtb	r0, r0
    e820:	bd10      	pop	{r4, pc}
    e822:	bf00      	nop
    e824:	00017433 	.word	0x00017433
    e828:	0000e08d 	.word	0x0000e08d
    e82c:	0000e76d 	.word	0x0000e76d

0000e830 <_rand_sync_init>:
	}
	return ERR_NONE;
}

int32_t _rand_sync_init(struct _rand_sync_dev *const dev, void *const hw)
{
    e830:	b538      	push	{r3, r4, r5, lr}
    e832:	460c      	mov	r4, r1
	int32_t rc;

	ASSERT(dev && hw);
    e834:	4605      	mov	r5, r0
    e836:	b110      	cbz	r0, e83e <_rand_sync_init+0xe>
    e838:	1e08      	subs	r0, r1, #0
    e83a:	bf18      	it	ne
    e83c:	2001      	movne	r0, #1
    e83e:	4b0c      	ldr	r3, [pc, #48]	; (e870 <_rand_sync_init+0x40>)
    e840:	490c      	ldr	r1, [pc, #48]	; (e874 <_rand_sync_init+0x44>)
    e842:	223d      	movs	r2, #61	; 0x3d
    e844:	4798      	blx	r3
}

static inline hri_trng_ctrla_reg_t hri_trng_get_CTRLA_reg(const void *const hw, hri_trng_ctrla_reg_t mask)
{
	uint8_t tmp;
	tmp = ((Trng *)hw)->CTRLA.reg;
    e846:	7823      	ldrb	r3, [r4, #0]
	if (hri_trng_get_CTRLA_reg(hw, TRNG_CTRLA_ENABLE)) {
    e848:	f013 0302 	ands.w	r3, r3, #2
    e84c:	d10c      	bne.n	e868 <_rand_sync_init+0x38>
	((Trng *)hw)->CTRLA.reg &= ~TRNG_CTRLA_RUNSTDBY;
    e84e:	7822      	ldrb	r2, [r4, #0]
    e850:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
    e854:	7022      	strb	r2, [r4, #0]
}

static inline void hri_trng_clear_EVCTRL_DATARDYEO_bit(const void *const hw)
{
	TRNG_CRITICAL_SECTION_ENTER();
	((Trng *)hw)->EVCTRL.reg &= ~TRNG_EVCTRL_DATARDYEO;
    e856:	7922      	ldrb	r2, [r4, #4]
    e858:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    e85c:	7122      	strb	r2, [r4, #4]

	rc = _trng_init(hw);
	if (rc == ERR_NONE) {
		dev->prvt   = hw;
		dev->n_bits = 32;
    e85e:	2220      	movs	r2, #32
		dev->prvt   = hw;
    e860:	602c      	str	r4, [r5, #0]
		dev->n_bits = 32;
    e862:	712a      	strb	r2, [r5, #4]
	return ERR_NONE;
    e864:	4618      	mov	r0, r3
	}
	return rc;
}
    e866:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
    e868:	f06f 0010 	mvn.w	r0, #16
	return rc;
    e86c:	e7fb      	b.n	e866 <_rand_sync_init+0x36>
    e86e:	bf00      	nop
    e870:	0000e08d 	.word	0x0000e08d
    e874:	0001744e 	.word	0x0001744e

0000e878 <_rand_sync_enable>:
{
	_rand_sync_disable(dev);
}

int32_t _rand_sync_enable(struct _rand_sync_dev *const dev)
{
    e878:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    e87a:	4604      	mov	r4, r0
    e87c:	3800      	subs	r0, #0
    e87e:	bf18      	it	ne
    e880:	2001      	movne	r0, #1
    e882:	4d09      	ldr	r5, [pc, #36]	; (e8a8 <_rand_sync_enable+0x30>)
    e884:	4909      	ldr	r1, [pc, #36]	; (e8ac <_rand_sync_enable+0x34>)
    e886:	224e      	movs	r2, #78	; 0x4e
    e888:	47a8      	blx	r5
	ASSERT(dev->prvt);
    e88a:	6820      	ldr	r0, [r4, #0]
    e88c:	4907      	ldr	r1, [pc, #28]	; (e8ac <_rand_sync_enable+0x34>)
    e88e:	3800      	subs	r0, #0
    e890:	bf18      	it	ne
    e892:	2001      	movne	r0, #1
    e894:	224f      	movs	r2, #79	; 0x4f
    e896:	47a8      	blx	r5

	hri_trng_set_CTRLA_ENABLE_bit(dev->prvt);
    e898:	6822      	ldr	r2, [r4, #0]
	((Trng *)hw)->CTRLA.reg |= TRNG_CTRLA_ENABLE;
    e89a:	7813      	ldrb	r3, [r2, #0]
    e89c:	f043 0302 	orr.w	r3, r3, #2
    e8a0:	7013      	strb	r3, [r2, #0]
	return ERR_NONE;
}
    e8a2:	2000      	movs	r0, #0
    e8a4:	bd38      	pop	{r3, r4, r5, pc}
    e8a6:	bf00      	nop
    e8a8:	0000e08d 	.word	0x0000e08d
    e8ac:	0001744e 	.word	0x0001744e

0000e8b0 <_rand_sync_read_one>:
	(void)seed;
	return ERR_UNSUPPORTED_OP;
}

uint32_t _rand_sync_read_one(const struct _rand_sync_dev *const dev)
{
    e8b0:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    e8b2:	4604      	mov	r4, r0
    e8b4:	3800      	subs	r0, #0
    e8b6:	4d0d      	ldr	r5, [pc, #52]	; (e8ec <_rand_sync_read_one+0x3c>)
    e8b8:	490d      	ldr	r1, [pc, #52]	; (e8f0 <_rand_sync_read_one+0x40>)
    e8ba:	bf18      	it	ne
    e8bc:	2001      	movne	r0, #1
    e8be:	2266      	movs	r2, #102	; 0x66
    e8c0:	47a8      	blx	r5
	ASSERT(dev->prvt);
    e8c2:	6820      	ldr	r0, [r4, #0]
    e8c4:	490a      	ldr	r1, [pc, #40]	; (e8f0 <_rand_sync_read_one+0x40>)
    e8c6:	3800      	subs	r0, #0
    e8c8:	bf18      	it	ne
    e8ca:	2001      	movne	r0, #1
    e8cc:	2267      	movs	r2, #103	; 0x67
    e8ce:	47a8      	blx	r5
	ASSERT(hri_trng_get_CTRLA_reg(dev->prvt, TRNG_CTRLA_ENABLE));
    e8d0:	6823      	ldr	r3, [r4, #0]
    e8d2:	4907      	ldr	r1, [pc, #28]	; (e8f0 <_rand_sync_read_one+0x40>)
	tmp = ((Trng *)hw)->CTRLA.reg;
    e8d4:	7818      	ldrb	r0, [r3, #0]
    e8d6:	2268      	movs	r2, #104	; 0x68
    e8d8:	f3c0 0040 	ubfx	r0, r0, #1, #1
    e8dc:	47a8      	blx	r5

	while (!hri_trng_get_INTFLAG_reg(dev->prvt, TRNG_INTFLAG_DATARDY)) {
    e8de:	6823      	ldr	r3, [r4, #0]
	tmp = ((Trng *)hw)->INTFLAG.reg;
    e8e0:	7a9a      	ldrb	r2, [r3, #10]
    e8e2:	07d2      	lsls	r2, r2, #31
    e8e4:	d5fc      	bpl.n	e8e0 <_rand_sync_read_one+0x30>
	return ((Trng *)hw)->DATA.reg;
    e8e6:	6a18      	ldr	r0, [r3, #32]
		/* Wait until data ready. */
	}
	return hri_trng_read_DATA_reg(dev->prvt);
}
    e8e8:	bd38      	pop	{r3, r4, r5, pc}
    e8ea:	bf00      	nop
    e8ec:	0000e08d 	.word	0x0000e08d
    e8f0:	0001744e 	.word	0x0001744e

0000e8f4 <hid_keyboard_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    e8f4:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    e8f6:	780a      	ldrb	r2, [r1, #0]
    e8f8:	2a81      	cmp	r2, #129	; 0x81
    e8fa:	d11c      	bne.n	e936 <hid_keyboard_req+0x42>
    e8fc:	784b      	ldrb	r3, [r1, #1]
    e8fe:	2b06      	cmp	r3, #6
    e900:	d131      	bne.n	e966 <hid_keyboard_req+0x72>
    e902:	4a1a      	ldr	r2, [pc, #104]	; (e96c <hid_keyboard_req+0x78>)
    e904:	888c      	ldrh	r4, [r1, #4]
    e906:	7b13      	ldrb	r3, [r2, #12]
    e908:	429c      	cmp	r4, r3
    e90a:	d12c      	bne.n	e966 <hid_keyboard_req+0x72>
	switch (req->wValue >> 8) {
    e90c:	884b      	ldrh	r3, [r1, #2]
    e90e:	0a1b      	lsrs	r3, r3, #8
    e910:	2b21      	cmp	r3, #33	; 0x21
    e912:	d005      	beq.n	e920 <hid_keyboard_req+0x2c>
    e914:	2b22      	cmp	r3, #34	; 0x22
    e916:	d00a      	beq.n	e92e <hid_keyboard_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
			switch (req->bRequest) {
    e918:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    e91c:	bc30      	pop	{r4, r5}
    e91e:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
    e920:	6811      	ldr	r1, [r2, #0]
    e922:	780a      	ldrb	r2, [r1, #0]
    e924:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    e926:	4c12      	ldr	r4, [pc, #72]	; (e970 <hid_keyboard_req+0x7c>)
    e928:	46a4      	mov	ip, r4
}
    e92a:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    e92c:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
    e92e:	4911      	ldr	r1, [pc, #68]	; (e974 <hid_keyboard_req+0x80>)
    e930:	2300      	movs	r3, #0
    e932:	223b      	movs	r2, #59	; 0x3b
    e934:	e7f7      	b.n	e926 <hid_keyboard_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    e936:	f3c2 1241 	ubfx	r2, r2, #5, #2
    e93a:	2a01      	cmp	r2, #1
    e93c:	d113      	bne.n	e966 <hid_keyboard_req+0x72>
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
    e93e:	4c0b      	ldr	r4, [pc, #44]	; (e96c <hid_keyboard_req+0x78>)
    e940:	888d      	ldrh	r5, [r1, #4]
    e942:	7b23      	ldrb	r3, [r4, #12]
    e944:	429d      	cmp	r5, r3
    e946:	d10e      	bne.n	e966 <hid_keyboard_req+0x72>
			switch (req->bRequest) {
    e948:	784b      	ldrb	r3, [r1, #1]
    e94a:	2b03      	cmp	r3, #3
    e94c:	d007      	beq.n	e95e <hid_keyboard_req+0x6a>
    e94e:	2b0b      	cmp	r3, #11
    e950:	d1e2      	bne.n	e918 <hid_keyboard_req+0x24>
				_hiddf_keyboard_funcd.protocol = req->wValue;
    e952:	884b      	ldrh	r3, [r1, #2]
    e954:	73e3      	strb	r3, [r4, #15]
				return usbdc_xfer(ep, NULL, 0, 0);
    e956:	2300      	movs	r3, #0
    e958:	461a      	mov	r2, r3
    e95a:	4619      	mov	r1, r3
    e95c:	e7e3      	b.n	e926 <hid_keyboard_req+0x32>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
    e95e:	2300      	movs	r3, #0
    e960:	f104 010f 	add.w	r1, r4, #15
    e964:	e7df      	b.n	e926 <hid_keyboard_req+0x32>
			return ERR_NOT_FOUND;
    e966:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    e96a:	e7d7      	b.n	e91c <hid_keyboard_req+0x28>
    e96c:	20008b40 	.word	0x20008b40
    e970:	0001328d 	.word	0x0001328d
    e974:	00017465 	.word	0x00017465

0000e978 <hid_keyboard_ctrl>:
	switch (ctrl) {
    e978:	2901      	cmp	r1, #1
{
    e97a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e97e:	4615      	mov	r5, r2
	switch (ctrl) {
    e980:	d04b      	beq.n	ea1a <hid_keyboard_ctrl+0xa2>
    e982:	2902      	cmp	r1, #2
    e984:	d066      	beq.n	ea54 <hid_keyboard_ctrl+0xdc>
    e986:	2900      	cmp	r1, #0
    e988:	d167      	bne.n	ea5a <hid_keyboard_ctrl+0xe2>
	ifc = desc->sod;
    e98a:	6813      	ldr	r3, [r2, #0]
		return hid_keyboard_enable(drv, (struct usbd_descriptors *)param);
    e98c:	f8d0 8008 	ldr.w	r8, [r0, #8]
	if (NULL == ifc) {
    e990:	b923      	cbnz	r3, e99c <hid_keyboard_ctrl+0x24>
		return ERR_NOT_FOUND;
    e992:	f06f 0409 	mvn.w	r4, #9
}
    e996:	4620      	mov	r0, r4
    e998:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e99c:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    e99e:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e9a0:	2903      	cmp	r1, #3
    e9a2:	d1f6      	bne.n	e992 <hid_keyboard_ctrl+0x1a>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    e9a4:	f898 100c 	ldrb.w	r1, [r8, #12]
    e9a8:	428a      	cmp	r2, r1
    e9aa:	d059      	beq.n	ea60 <hid_keyboard_ctrl+0xe8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    e9ac:	29ff      	cmp	r1, #255	; 0xff
    e9ae:	d15a      	bne.n	ea66 <hid_keyboard_ctrl+0xee>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    e9b0:	f888 200c 	strb.w	r2, [r8, #12]
	return (desc + usb_desc_len(desc));
    e9b4:	7818      	ldrb	r0, [r3, #0]
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e9b6:	6869      	ldr	r1, [r5, #4]
    e9b8:	4e2e      	ldr	r6, [pc, #184]	; (ea74 <hid_keyboard_ctrl+0xfc>)
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e9ba:	f8df b0c8 	ldr.w	fp, [pc, #200]	; ea84 <hid_keyboard_ctrl+0x10c>
    e9be:	f8df 90c8 	ldr.w	r9, [pc, #200]	; ea88 <hid_keyboard_ctrl+0x110>
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e9c2:	4418      	add	r0, r3
    e9c4:	2221      	movs	r2, #33	; 0x21
    e9c6:	4b2c      	ldr	r3, [pc, #176]	; (ea78 <hid_keyboard_ctrl+0x100>)
    e9c8:	4798      	blx	r3
    e9ca:	2702      	movs	r7, #2
    e9cc:	6030      	str	r0, [r6, #0]
		ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e9ce:	682b      	ldr	r3, [r5, #0]
    e9d0:	6869      	ldr	r1, [r5, #4]
    e9d2:	7818      	ldrb	r0, [r3, #0]
    e9d4:	4418      	add	r0, r3
    e9d6:	4b29      	ldr	r3, [pc, #164]	; (ea7c <hid_keyboard_ctrl+0x104>)
    e9d8:	4798      	blx	r3
		desc->sod = ep;
    e9da:	6028      	str	r0, [r5, #0]
		if (NULL != ep) {
    e9dc:	2800      	cmp	r0, #0
    e9de:	d0d8      	beq.n	e992 <hid_keyboard_ctrl+0x1a>
	return (ptr[0] + (ptr[1] << 8));
    e9e0:	7941      	ldrb	r1, [r0, #5]
    e9e2:	7902      	ldrb	r2, [r0, #4]
			ep_desc.bEndpointAddress = ep[2];
    e9e4:	f890 a002 	ldrb.w	sl, [r0, #2]
    e9e8:	eb02 2201 	add.w	r2, r2, r1, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e9ec:	b292      	uxth	r2, r2
    e9ee:	78c1      	ldrb	r1, [r0, #3]
    e9f0:	4650      	mov	r0, sl
    e9f2:	47d8      	blx	fp
    e9f4:	4604      	mov	r4, r0
    e9f6:	2800      	cmp	r0, #0
    e9f8:	d138      	bne.n	ea6c <hid_keyboard_ctrl+0xf4>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    e9fa:	f01a 0f80 	tst.w	sl, #128	; 0x80
				func_data->func_ep_in = ep_desc.bEndpointAddress;
    e9fe:	bf14      	ite	ne
    ea00:	f888 a00d 	strbne.w	sl, [r8, #13]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    ea04:	f888 a00e 	strbeq.w	sl, [r8, #14]
				usb_d_ep_enable(func_data->func_ep_out);
    ea08:	4650      	mov	r0, sl
    ea0a:	47c8      	blx	r9
	for (i = 0; i < 2; i++) {
    ea0c:	2f01      	cmp	r7, #1
    ea0e:	d102      	bne.n	ea16 <hid_keyboard_ctrl+0x9e>
	_hiddf_keyboard_funcd.protocol = 1;
    ea10:	73f7      	strb	r7, [r6, #15]
	_hiddf_keyboard_funcd.enabled  = true;
    ea12:	7437      	strb	r7, [r6, #16]
	return ERR_NONE;
    ea14:	e7bf      	b.n	e996 <hid_keyboard_ctrl+0x1e>
    ea16:	2701      	movs	r7, #1
    ea18:	e7d9      	b.n	e9ce <hid_keyboard_ctrl+0x56>
		return hid_keyboard_disable(drv, (struct usbd_descriptors *)param);
    ea1a:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    ea1c:	b11a      	cbz	r2, ea26 <hid_keyboard_ctrl+0xae>
		ifc_desc.bInterfaceClass = desc->sod[5];
    ea1e:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    ea20:	795b      	ldrb	r3, [r3, #5]
    ea22:	2b03      	cmp	r3, #3
    ea24:	d1b5      	bne.n	e992 <hid_keyboard_ctrl+0x1a>
	if (func_data->func_iface != 0xFF) {
    ea26:	7b23      	ldrb	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    ea28:	7b60      	ldrb	r0, [r4, #13]
	if (func_data->func_iface != 0xFF) {
    ea2a:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    ea2c:	bf1c      	itt	ne
    ea2e:	23ff      	movne	r3, #255	; 0xff
    ea30:	7323      	strbne	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    ea32:	28ff      	cmp	r0, #255	; 0xff
    ea34:	d003      	beq.n	ea3e <hid_keyboard_ctrl+0xc6>
		usb_d_ep_deinit(func_data->func_ep_in);
    ea36:	4b12      	ldr	r3, [pc, #72]	; (ea80 <hid_keyboard_ctrl+0x108>)
    ea38:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    ea3a:	23ff      	movs	r3, #255	; 0xff
    ea3c:	7363      	strb	r3, [r4, #13]
	if (func_data->func_ep_out != 0xFF) {
    ea3e:	7ba0      	ldrb	r0, [r4, #14]
    ea40:	28ff      	cmp	r0, #255	; 0xff
    ea42:	d003      	beq.n	ea4c <hid_keyboard_ctrl+0xd4>
		usb_d_ep_deinit(func_data->func_ep_out);
    ea44:	4b0e      	ldr	r3, [pc, #56]	; (ea80 <hid_keyboard_ctrl+0x108>)
    ea46:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    ea48:	23ff      	movs	r3, #255	; 0xff
    ea4a:	73a3      	strb	r3, [r4, #14]
	_hiddf_keyboard_funcd.enabled = false;
    ea4c:	4b09      	ldr	r3, [pc, #36]	; (ea74 <hid_keyboard_ctrl+0xfc>)
    ea4e:	2400      	movs	r4, #0
    ea50:	741c      	strb	r4, [r3, #16]
	return ERR_NONE;
    ea52:	e7a0      	b.n	e996 <hid_keyboard_ctrl+0x1e>
		return ERR_UNSUPPORTED_OP;
    ea54:	f06f 041a 	mvn.w	r4, #26
    ea58:	e79d      	b.n	e996 <hid_keyboard_ctrl+0x1e>
	switch (ctrl) {
    ea5a:	f06f 040c 	mvn.w	r4, #12
    ea5e:	e79a      	b.n	e996 <hid_keyboard_ctrl+0x1e>
			return ERR_ALREADY_INITIALIZED;
    ea60:	f06f 0411 	mvn.w	r4, #17
    ea64:	e797      	b.n	e996 <hid_keyboard_ctrl+0x1e>
			return ERR_NO_RESOURCE;
    ea66:	f06f 041b 	mvn.w	r4, #27
    ea6a:	e794      	b.n	e996 <hid_keyboard_ctrl+0x1e>
				return ERR_NOT_INITIALIZED;
    ea6c:	f06f 0413 	mvn.w	r4, #19
    ea70:	e791      	b.n	e996 <hid_keyboard_ctrl+0x1e>
    ea72:	bf00      	nop
    ea74:	20008b40 	.word	0x20008b40
    ea78:	0000b83d 	.word	0x0000b83d
    ea7c:	0000b857 	.word	0x0000b857
    ea80:	0000f5d5 	.word	0x0000f5d5
    ea84:	0000f571 	.word	0x0000f571
    ea88:	0000f601 	.word	0x0000f601

0000ea8c <hiddf_keyboard_init>:

/**
 * \brief Initialize the USB HID Keyboard Function Driver
 */
int32_t hiddf_keyboard_init(void)
{
    ea8c:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    ea8e:	4b0a      	ldr	r3, [pc, #40]	; (eab8 <hiddf_keyboard_init+0x2c>)
    ea90:	4798      	blx	r3
    ea92:	2801      	cmp	r0, #1
    ea94:	d80c      	bhi.n	eab0 <hiddf_keyboard_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_keyboard.ctrl      = hid_keyboard_ctrl;
    ea96:	4809      	ldr	r0, [pc, #36]	; (eabc <hiddf_keyboard_init+0x30>)
    ea98:	4b09      	ldr	r3, [pc, #36]	; (eac0 <hiddf_keyboard_init+0x34>)
	_hiddf_keyboard.func_data = &_hiddf_keyboard_funcd;
    ea9a:	e9c0 3006 	strd	r3, r0, [r0, #24]

	usbdc_register_function(&_hiddf_keyboard);
    ea9e:	4b09      	ldr	r3, [pc, #36]	; (eac4 <hiddf_keyboard_init+0x38>)
    eaa0:	3014      	adds	r0, #20
    eaa2:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_keyboard_req_h);
    eaa4:	2001      	movs	r0, #1
    eaa6:	4908      	ldr	r1, [pc, #32]	; (eac8 <hiddf_keyboard_init+0x3c>)
    eaa8:	4b08      	ldr	r3, [pc, #32]	; (eacc <hiddf_keyboard_init+0x40>)
    eaaa:	4798      	blx	r3
	return ERR_NONE;
    eaac:	2000      	movs	r0, #0
}
    eaae:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    eab0:	f06f 0010 	mvn.w	r0, #16
    eab4:	e7fb      	b.n	eaae <hiddf_keyboard_init+0x22>
    eab6:	bf00      	nop
    eab8:	000136c5 	.word	0x000136c5
    eabc:	20008b40 	.word	0x20008b40
    eac0:	0000e979 	.word	0x0000e979
    eac4:	0001366d 	.word	0x0001366d
    eac8:	20000504 	.word	0x20000504
    eacc:	000135e5 	.word	0x000135e5

0000ead0 <hiddf_keyboard_keys_state_change>:
 * \param keys_desc[]  keys_descriptor array for state changing
 * \param keys_count   total keys amount for state changing
 * \return Operation status.
 */
int32_t hiddf_keyboard_keys_state_change(struct hiddf_kb_key_descriptors keys_desc[], uint8_t keys_count)
{
    ead0:	b470      	push	{r4, r5, r6}
	return _hiddf_keyboard_funcd.enabled;
    ead2:	4c20      	ldr	r4, [pc, #128]	; (eb54 <hiddf_keyboard_keys_state_change+0x84>)
	uint8_t i, j;
	uint8_t modifier_keys, regular_keys;

	if (!hiddf_keyboard_is_enabled()) {
    ead4:	7c23      	ldrb	r3, [r4, #16]
    ead6:	2b00      	cmp	r3, #0
    ead8:	d037      	beq.n	eb4a <hiddf_keyboard_keys_state_change+0x7a>
		return ERR_DENIED;
	}

	memset(_hiddf_keyboard_funcd.kb_report, 0x00, 8);
    eada:	2300      	movs	r3, #0
    eadc:	e9c4 3301 	strd	r3, r3, [r4, #4]
	modifier_keys = 0;
    eae0:	461a      	mov	r2, r3

	for (i = 0; i < keys_count; i++) {
		if (true == keys_desc[i].b_modifier) {
    eae2:	1c46      	adds	r6, r0, #1
	for (i = 0; i < keys_count; i++) {
    eae4:	b2dd      	uxtb	r5, r3
    eae6:	42a9      	cmp	r1, r5
    eae8:	d814      	bhi.n	eb14 <hiddf_keyboard_keys_state_change+0x44>
			modifier_keys++;
		}
	}

	regular_keys = keys_count - modifier_keys;
    eaea:	1a8a      	subs	r2, r1, r2

	if (regular_keys > 6) {
    eaec:	b2d2      	uxtb	r2, r2
    eaee:	2a06      	cmp	r2, #6
    eaf0:	d818      	bhi.n	eb24 <hiddf_keyboard_keys_state_change+0x54>
    eaf2:	2500      	movs	r5, #0
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
	} else {
		i = 2;
    eaf4:	2302      	movs	r3, #2
		for (j = 0; j < keys_count; j++) {
    eaf6:	b2ea      	uxtb	r2, r5
    eaf8:	4291      	cmp	r1, r2
    eafa:	d919      	bls.n	eb30 <hiddf_keyboard_keys_state_change+0x60>
			if (HID_KB_KEY_DOWN == keys_desc[j].state) {
    eafc:	7882      	ldrb	r2, [r0, #2]
    eafe:	2a01      	cmp	r2, #1
    eb00:	d105      	bne.n	eb0e <hiddf_keyboard_keys_state_change+0x3e>
				if (true == keys_desc[j].b_modifier) {
    eb02:	7846      	ldrb	r6, [r0, #1]
    eb04:	7802      	ldrb	r2, [r0, #0]
    eb06:	b1de      	cbz	r6, eb40 <hiddf_keyboard_keys_state_change+0x70>
					_hiddf_keyboard_funcd.kb_report[0] |= keys_desc[j].key_id;
    eb08:	7926      	ldrb	r6, [r4, #4]
    eb0a:	4332      	orrs	r2, r6
    eb0c:	7122      	strb	r2, [r4, #4]
		for (j = 0; j < keys_count; j++) {
    eb0e:	3501      	adds	r5, #1
    eb10:	3003      	adds	r0, #3
    eb12:	e7f0      	b.n	eaf6 <hiddf_keyboard_keys_state_change+0x26>
		if (true == keys_desc[i].b_modifier) {
    eb14:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    eb18:	5d75      	ldrb	r5, [r6, r5]
    eb1a:	b10d      	cbz	r5, eb20 <hiddf_keyboard_keys_state_change+0x50>
			modifier_keys++;
    eb1c:	3201      	adds	r2, #1
    eb1e:	b2d2      	uxtb	r2, r2
	for (i = 0; i < keys_count; i++) {
    eb20:	3301      	adds	r3, #1
    eb22:	e7df      	b.n	eae4 <hiddf_keyboard_keys_state_change+0x14>
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
    eb24:	4a0c      	ldr	r2, [pc, #48]	; (eb58 <hiddf_keyboard_keys_state_change+0x88>)
    eb26:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    eb2a:	f8c4 3006 	str.w	r3, [r4, #6]
    eb2e:	8093      	strh	r3, [r2, #4]
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
				}
			}
		}
	}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    eb30:	7b60      	ldrb	r0, [r4, #13]
    eb32:	4c0a      	ldr	r4, [pc, #40]	; (eb5c <hiddf_keyboard_keys_state_change+0x8c>)
    eb34:	490a      	ldr	r1, [pc, #40]	; (eb60 <hiddf_keyboard_keys_state_change+0x90>)
    eb36:	46a4      	mov	ip, r4
    eb38:	2300      	movs	r3, #0
}
    eb3a:	bc70      	pop	{r4, r5, r6}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    eb3c:	2208      	movs	r2, #8
    eb3e:	4760      	bx	ip
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
    eb40:	1c5e      	adds	r6, r3, #1
    eb42:	4423      	add	r3, r4
    eb44:	711a      	strb	r2, [r3, #4]
    eb46:	b2f3      	uxtb	r3, r6
    eb48:	e7e1      	b.n	eb0e <hiddf_keyboard_keys_state_change+0x3e>
}
    eb4a:	f06f 0010 	mvn.w	r0, #16
    eb4e:	bc70      	pop	{r4, r5, r6}
    eb50:	4770      	bx	lr
    eb52:	bf00      	nop
    eb54:	20008b40 	.word	0x20008b40
    eb58:	20008b46 	.word	0x20008b46
    eb5c:	0001328d 	.word	0x0001328d
    eb60:	20008b44 	.word	0x20008b44

0000eb64 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    eb64:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    eb68:	460e      	mov	r6, r1
    eb6a:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    eb6c:	4604      	mov	r4, r0
    eb6e:	b118      	cbz	r0, eb78 <usart_sync_write+0x14>
    eb70:	b329      	cbz	r1, ebbe <usart_sync_write+0x5a>
    eb72:	1e10      	subs	r0, r2, #0
    eb74:	bf18      	it	ne
    eb76:	2001      	movne	r0, #1
    eb78:	4912      	ldr	r1, [pc, #72]	; (ebc4 <usart_sync_write+0x60>)
    eb7a:	4b13      	ldr	r3, [pc, #76]	; (ebc8 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
    eb7c:	4f13      	ldr	r7, [pc, #76]	; (ebcc <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
    eb7e:	22f1      	movs	r2, #241	; 0xf1
    eb80:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    eb82:	3408      	adds	r4, #8
    eb84:	46b9      	mov	r9, r7
    eb86:	4620      	mov	r0, r4
    eb88:	47b8      	blx	r7
    eb8a:	2800      	cmp	r0, #0
    eb8c:	d0fb      	beq.n	eb86 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    eb8e:	f8df 8044 	ldr.w	r8, [pc, #68]	; ebd4 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
    eb92:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
    eb94:	5df1      	ldrb	r1, [r6, r7]
    eb96:	4620      	mov	r0, r4
    eb98:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
    eb9a:	4620      	mov	r0, r4
    eb9c:	47c8      	blx	r9
    eb9e:	2800      	cmp	r0, #0
    eba0:	d0fb      	beq.n	eb9a <usart_sync_write+0x36>
			;
	} while (++offset < length);
    eba2:	3701      	adds	r7, #1
    eba4:	42bd      	cmp	r5, r7
    eba6:	d8f5      	bhi.n	eb94 <usart_sync_write+0x30>
    eba8:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
    ebaa:	4e09      	ldr	r6, [pc, #36]	; (ebd0 <usart_sync_write+0x6c>)
    ebac:	bf08      	it	eq
    ebae:	2501      	moveq	r5, #1
    ebb0:	4620      	mov	r0, r4
    ebb2:	47b0      	blx	r6
    ebb4:	2800      	cmp	r0, #0
    ebb6:	d0fb      	beq.n	ebb0 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
    ebb8:	4628      	mov	r0, r5
    ebba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    ebbe:	4608      	mov	r0, r1
    ebc0:	e7da      	b.n	eb78 <usart_sync_write+0x14>
    ebc2:	bf00      	nop
    ebc4:	000174a0 	.word	0x000174a0
    ebc8:	0000e08d 	.word	0x0000e08d
    ebcc:	000110b9 	.word	0x000110b9
    ebd0:	000110c3 	.word	0x000110c3
    ebd4:	000110a5 	.word	0x000110a5

0000ebd8 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    ebd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ebdc:	460e      	mov	r6, r1
    ebde:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    ebe0:	4604      	mov	r4, r0
    ebe2:	b118      	cbz	r0, ebec <usart_sync_read+0x14>
    ebe4:	b1e9      	cbz	r1, ec22 <usart_sync_read+0x4a>
    ebe6:	1e10      	subs	r0, r2, #0
    ebe8:	bf18      	it	ne
    ebea:	2001      	movne	r0, #1
    ebec:	490e      	ldr	r1, [pc, #56]	; (ec28 <usart_sync_read+0x50>)
    ebee:	4b0f      	ldr	r3, [pc, #60]	; (ec2c <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    ebf0:	f8df 903c 	ldr.w	r9, [pc, #60]	; ec30 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    ebf4:	f8df 803c 	ldr.w	r8, [pc, #60]	; ec34 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
    ebf8:	f44f 7286 	mov.w	r2, #268	; 0x10c
    ebfc:	4798      	blx	r3
	uint32_t                      offset = 0;
    ebfe:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
    ec00:	3408      	adds	r4, #8
    ec02:	4620      	mov	r0, r4
    ec04:	47c8      	blx	r9
    ec06:	2800      	cmp	r0, #0
    ec08:	d0fb      	beq.n	ec02 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    ec0a:	4620      	mov	r0, r4
    ec0c:	47c0      	blx	r8
    ec0e:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
    ec10:	3701      	adds	r7, #1
    ec12:	42bd      	cmp	r5, r7
    ec14:	d8f5      	bhi.n	ec02 <usart_sync_read+0x2a>

	return (int32_t)offset;
    ec16:	2d00      	cmp	r5, #0
}
    ec18:	bf14      	ite	ne
    ec1a:	4628      	movne	r0, r5
    ec1c:	2001      	moveq	r0, #1
    ec1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    ec22:	4608      	mov	r0, r1
    ec24:	e7e2      	b.n	ebec <usart_sync_read+0x14>
    ec26:	bf00      	nop
    ec28:	000174a0 	.word	0x000174a0
    ec2c:	0000e08d 	.word	0x0000e08d
    ec30:	000110cd 	.word	0x000110cd
    ec34:	000110b1 	.word	0x000110b1

0000ec38 <usart_sync_init>:
{
    ec38:	b538      	push	{r3, r4, r5, lr}
    ec3a:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    ec3c:	4604      	mov	r4, r0
    ec3e:	b110      	cbz	r0, ec46 <usart_sync_init+0xe>
    ec40:	1e08      	subs	r0, r1, #0
    ec42:	bf18      	it	ne
    ec44:	2001      	movne	r0, #1
    ec46:	4907      	ldr	r1, [pc, #28]	; (ec64 <usart_sync_init+0x2c>)
    ec48:	4b07      	ldr	r3, [pc, #28]	; (ec68 <usart_sync_init+0x30>)
    ec4a:	2234      	movs	r2, #52	; 0x34
    ec4c:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    ec4e:	4b07      	ldr	r3, [pc, #28]	; (ec6c <usart_sync_init+0x34>)
    ec50:	4629      	mov	r1, r5
    ec52:	f104 0008 	add.w	r0, r4, #8
    ec56:	4798      	blx	r3
	if (init_status) {
    ec58:	b918      	cbnz	r0, ec62 <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
    ec5a:	4b05      	ldr	r3, [pc, #20]	; (ec70 <usart_sync_init+0x38>)
    ec5c:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    ec5e:	4b05      	ldr	r3, [pc, #20]	; (ec74 <usart_sync_init+0x3c>)
    ec60:	6023      	str	r3, [r4, #0]
}
    ec62:	bd38      	pop	{r3, r4, r5, pc}
    ec64:	000174a0 	.word	0x000174a0
    ec68:	0000e08d 	.word	0x0000e08d
    ec6c:	00010fc1 	.word	0x00010fc1
    ec70:	0000ebd9 	.word	0x0000ebd9
    ec74:	0000eb65 	.word	0x0000eb65

0000ec78 <usart_sync_enable>:
{
    ec78:	b510      	push	{r4, lr}
	ASSERT(descr);
    ec7a:	4604      	mov	r4, r0
    ec7c:	3800      	subs	r0, #0
    ec7e:	bf18      	it	ne
    ec80:	2001      	movne	r0, #1
    ec82:	4905      	ldr	r1, [pc, #20]	; (ec98 <usart_sync_enable+0x20>)
    ec84:	4b05      	ldr	r3, [pc, #20]	; (ec9c <usart_sync_enable+0x24>)
    ec86:	2253      	movs	r2, #83	; 0x53
    ec88:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    ec8a:	f104 0008 	add.w	r0, r4, #8
    ec8e:	4b04      	ldr	r3, [pc, #16]	; (eca0 <usart_sync_enable+0x28>)
    ec90:	4798      	blx	r3
}
    ec92:	2000      	movs	r0, #0
    ec94:	bd10      	pop	{r4, pc}
    ec96:	bf00      	nop
    ec98:	000174a0 	.word	0x000174a0
    ec9c:	0000e08d 	.word	0x0000e08d
    eca0:	00011065 	.word	0x00011065

0000eca4 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    eca4:	4b01      	ldr	r3, [pc, #4]	; (ecac <_mclk_init+0x8>)
    eca6:	2201      	movs	r2, #1
    eca8:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    ecaa:	4770      	bx	lr
    ecac:	40000800 	.word	0x40000800

0000ecb0 <hri_gclk_wait_for_sync.constprop.0>:
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    ecb0:	4903      	ldr	r1, [pc, #12]	; (ecc0 <hri_gclk_wait_for_sync.constprop.0+0x10>)
    ecb2:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    ecb6:	684a      	ldr	r2, [r1, #4]
    ecb8:	421a      	tst	r2, r3
    ecba:	d1fc      	bne.n	ecb6 <hri_gclk_wait_for_sync.constprop.0+0x6>
}
    ecbc:	4770      	bx	lr
    ecbe:	bf00      	nop
    ecc0:	40001c00 	.word	0x40001c00

0000ecc4 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    ecc4:	b510      	push	{r4, lr}

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    ecc6:	07c4      	lsls	r4, r0, #31
    ecc8:	d504      	bpl.n	ecd4 <_gclk_init_generators_by_fref+0x10>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ecca:	4b0e      	ldr	r3, [pc, #56]	; (ed04 <_gclk_init_generators_by_fref+0x40>)
    eccc:	4a0e      	ldr	r2, [pc, #56]	; (ed08 <_gclk_init_generators_by_fref+0x44>)
    ecce:	621a      	str	r2, [r3, #32]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ecd0:	4b0e      	ldr	r3, [pc, #56]	; (ed0c <_gclk_init_generators_by_fref+0x48>)
    ecd2:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    ecd4:	0781      	lsls	r1, r0, #30
    ecd6:	d504      	bpl.n	ece2 <_gclk_init_generators_by_fref+0x1e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ecd8:	4b0a      	ldr	r3, [pc, #40]	; (ed04 <_gclk_init_generators_by_fref+0x40>)
    ecda:	4a0d      	ldr	r2, [pc, #52]	; (ed10 <_gclk_init_generators_by_fref+0x4c>)
    ecdc:	625a      	str	r2, [r3, #36]	; 0x24
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ecde:	4b0b      	ldr	r3, [pc, #44]	; (ed0c <_gclk_init_generators_by_fref+0x48>)
    ece0:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    ece2:	0742      	lsls	r2, r0, #29
    ece4:	d504      	bpl.n	ecf0 <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ece6:	4b07      	ldr	r3, [pc, #28]	; (ed04 <_gclk_init_generators_by_fref+0x40>)
    ece8:	4a0a      	ldr	r2, [pc, #40]	; (ed14 <_gclk_init_generators_by_fref+0x50>)
    ecea:	629a      	str	r2, [r3, #40]	; 0x28
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ecec:	4b07      	ldr	r3, [pc, #28]	; (ed0c <_gclk_init_generators_by_fref+0x48>)
    ecee:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    ecf0:	0703      	lsls	r3, r0, #28
    ecf2:	d506      	bpl.n	ed02 <_gclk_init_generators_by_fref+0x3e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ecf4:	4b03      	ldr	r3, [pc, #12]	; (ed04 <_gclk_init_generators_by_fref+0x40>)
    ecf6:	4a08      	ldr	r2, [pc, #32]	; (ed18 <_gclk_init_generators_by_fref+0x54>)
    ecf8:	62da      	str	r2, [r3, #44]	; 0x2c
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    ecfa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ecfe:	4b03      	ldr	r3, [pc, #12]	; (ed0c <_gclk_init_generators_by_fref+0x48>)
    ed00:	4718      	bx	r3
    ed02:	bd10      	pop	{r4, pc}
    ed04:	40001c00 	.word	0x40001c00
    ed08:	00010108 	.word	0x00010108
    ed0c:	0000ecb1 	.word	0x0000ecb1
    ed10:	00010106 	.word	0x00010106
    ed14:	00100106 	.word	0x00100106
    ed18:	00010104 	.word	0x00010104

0000ed1c <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    ed1c:	b510      	push	{r4, lr}

	usart_sync_enable(&GRID_AUX);
    ed1e:	4c04      	ldr	r4, [pc, #16]	; (ed30 <stdio_redirect_init+0x14>)
    ed20:	4b04      	ldr	r3, [pc, #16]	; (ed34 <stdio_redirect_init+0x18>)
    ed22:	4620      	mov	r0, r4
    ed24:	4798      	blx	r3
	stdio_io_init(&GRID_AUX.io);
    ed26:	4620      	mov	r0, r4
    ed28:	4b03      	ldr	r3, [pc, #12]	; (ed38 <stdio_redirect_init+0x1c>)
}
    ed2a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&GRID_AUX.io);
    ed2e:	4718      	bx	r3
    ed30:	2001cd70 	.word	0x2001cd70
    ed34:	0000ec79 	.word	0x0000ec79
    ed38:	0000b8dd 	.word	0x0000b8dd

0000ed3c <flash_ready>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    ed3c:	6943      	ldr	r3, [r0, #20]
    ed3e:	b103      	cbz	r3, ed42 <flash_ready+0x6>
		descr->callbacks.cb_ready(descr);
    ed40:	4718      	bx	r3
	}
}
    ed42:	4770      	bx	lr

0000ed44 <flash_error>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    ed44:	6983      	ldr	r3, [r0, #24]
    ed46:	b103      	cbz	r3, ed4a <flash_error+0x6>
		descr->callbacks.cb_error(descr);
    ed48:	4718      	bx	r3
	}
}
    ed4a:	4770      	bx	lr

0000ed4c <flash_is_address_aligned>:
{
    ed4c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(flash);
    ed4e:	4604      	mov	r4, r0
    ed50:	3800      	subs	r0, #0
    ed52:	bf18      	it	ne
    ed54:	2001      	movne	r0, #1
{
    ed56:	460d      	mov	r5, r1
	ASSERT(flash);
    ed58:	f240 1217 	movw	r2, #279	; 0x117
    ed5c:	4906      	ldr	r1, [pc, #24]	; (ed78 <flash_is_address_aligned+0x2c>)
    ed5e:	4b07      	ldr	r3, [pc, #28]	; (ed7c <flash_is_address_aligned+0x30>)
    ed60:	4798      	blx	r3
	uint32_t page_size = _flash_get_page_size(&flash->dev);
    ed62:	4b07      	ldr	r3, [pc, #28]	; (ed80 <flash_is_address_aligned+0x34>)
    ed64:	4620      	mov	r0, r4
    ed66:	4798      	blx	r3
	if (flash_addr & (page_size - 1)) {
    ed68:	3801      	subs	r0, #1
    ed6a:	4228      	tst	r0, r5
}
    ed6c:	bf14      	ite	ne
    ed6e:	f06f 000d 	mvnne.w	r0, #13
    ed72:	2000      	moveq	r0, #0
    ed74:	bd38      	pop	{r3, r4, r5, pc}
    ed76:	bf00      	nop
    ed78:	000174bc 	.word	0x000174bc
    ed7c:	0000e08d 	.word	0x0000e08d
    ed80:	0000bf81 	.word	0x0000bf81

0000ed84 <flash_init>:
{
    ed84:	b538      	push	{r3, r4, r5, lr}
    ed86:	460d      	mov	r5, r1
	ASSERT(flash && hw);
    ed88:	4604      	mov	r4, r0
    ed8a:	b110      	cbz	r0, ed92 <flash_init+0xe>
    ed8c:	1e08      	subs	r0, r1, #0
    ed8e:	bf18      	it	ne
    ed90:	2001      	movne	r0, #1
    ed92:	4907      	ldr	r1, [pc, #28]	; (edb0 <flash_init+0x2c>)
    ed94:	4b07      	ldr	r3, [pc, #28]	; (edb4 <flash_init+0x30>)
    ed96:	2238      	movs	r2, #56	; 0x38
    ed98:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    ed9a:	4b07      	ldr	r3, [pc, #28]	; (edb8 <flash_init+0x34>)
    ed9c:	4629      	mov	r1, r5
    ed9e:	4620      	mov	r0, r4
    eda0:	4798      	blx	r3
	if (rc) {
    eda2:	b918      	cbnz	r0, edac <flash_init+0x28>
	flash->dev.flash_cb.ready_cb = flash_ready;
    eda4:	4b05      	ldr	r3, [pc, #20]	; (edbc <flash_init+0x38>)
    eda6:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    eda8:	4b05      	ldr	r3, [pc, #20]	; (edc0 <flash_init+0x3c>)
    edaa:	6063      	str	r3, [r4, #4]
}
    edac:	bd38      	pop	{r3, r4, r5, pc}
    edae:	bf00      	nop
    edb0:	000174bc 	.word	0x000174bc
    edb4:	0000e08d 	.word	0x0000e08d
    edb8:	0000bf11 	.word	0x0000bf11
    edbc:	0000ed3d 	.word	0x0000ed3d
    edc0:	0000ed45 	.word	0x0000ed45

0000edc4 <flash_read>:
{
    edc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    edc8:	460d      	mov	r5, r1
    edca:	4616      	mov	r6, r2
    edcc:	461f      	mov	r7, r3
	ASSERT(flash && buffer && length);
    edce:	4604      	mov	r4, r0
    edd0:	b118      	cbz	r0, edda <flash_read+0x16>
    edd2:	b1ea      	cbz	r2, ee10 <flash_read+0x4c>
    edd4:	1e18      	subs	r0, r3, #0
    edd6:	bf18      	it	ne
    edd8:	2001      	movne	r0, #1
    edda:	4910      	ldr	r1, [pc, #64]	; (ee1c <flash_read+0x58>)
    eddc:	4b10      	ldr	r3, [pc, #64]	; (ee20 <flash_read+0x5c>)
    edde:	2256      	movs	r2, #86	; 0x56
    ede0:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ede2:	4b10      	ldr	r3, [pc, #64]	; (ee24 <flash_read+0x60>)
    ede4:	4620      	mov	r0, r4
    ede6:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ede8:	4b0f      	ldr	r3, [pc, #60]	; (ee28 <flash_read+0x64>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    edea:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    edec:	4620      	mov	r0, r4
    edee:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    edf0:	fb00 f008 	mul.w	r0, r0, r8
    edf4:	42a8      	cmp	r0, r5
    edf6:	d30d      	bcc.n	ee14 <flash_read+0x50>
    edf8:	197b      	adds	r3, r7, r5
    edfa:	4298      	cmp	r0, r3
    edfc:	d30a      	bcc.n	ee14 <flash_read+0x50>
	_flash_read(&flash->dev, src_addr, buffer, length);
    edfe:	4620      	mov	r0, r4
    ee00:	463b      	mov	r3, r7
    ee02:	4c0a      	ldr	r4, [pc, #40]	; (ee2c <flash_read+0x68>)
    ee04:	4632      	mov	r2, r6
    ee06:	4629      	mov	r1, r5
    ee08:	47a0      	blx	r4
	return ERR_NONE;
    ee0a:	2000      	movs	r0, #0
}
    ee0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    ee10:	4610      	mov	r0, r2
    ee12:	e7e2      	b.n	edda <flash_read+0x16>
		return ERR_BAD_ADDRESS;
    ee14:	f06f 000d 	mvn.w	r0, #13
    ee18:	e7f8      	b.n	ee0c <flash_read+0x48>
    ee1a:	bf00      	nop
    ee1c:	000174bc 	.word	0x000174bc
    ee20:	0000e08d 	.word	0x0000e08d
    ee24:	0000bf81 	.word	0x0000bf81
    ee28:	0000bf87 	.word	0x0000bf87
    ee2c:	0000bf8f 	.word	0x0000bf8f

0000ee30 <flash_write>:
{
    ee30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ee34:	460e      	mov	r6, r1
    ee36:	4617      	mov	r7, r2
    ee38:	4698      	mov	r8, r3
	ASSERT(flash && buffer && length);
    ee3a:	4605      	mov	r5, r0
    ee3c:	b118      	cbz	r0, ee46 <flash_write+0x16>
    ee3e:	b31a      	cbz	r2, ee88 <flash_write+0x58>
    ee40:	1e18      	subs	r0, r3, #0
    ee42:	bf18      	it	ne
    ee44:	2001      	movne	r0, #1
    ee46:	4914      	ldr	r1, [pc, #80]	; (ee98 <flash_write+0x68>)
    ee48:	4b14      	ldr	r3, [pc, #80]	; (ee9c <flash_write+0x6c>)
    ee4a:	226a      	movs	r2, #106	; 0x6a
    ee4c:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ee4e:	4b14      	ldr	r3, [pc, #80]	; (eea0 <flash_write+0x70>)
    ee50:	4628      	mov	r0, r5
    ee52:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee54:	4b13      	ldr	r3, [pc, #76]	; (eea4 <flash_write+0x74>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ee56:	4604      	mov	r4, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ee58:	4628      	mov	r0, r5
    ee5a:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    ee5c:	4360      	muls	r0, r4
    ee5e:	42b0      	cmp	r0, r6
    ee60:	d314      	bcc.n	ee8c <flash_write+0x5c>
    ee62:	eb08 0306 	add.w	r3, r8, r6
    ee66:	4298      	cmp	r0, r3
    ee68:	d310      	bcc.n	ee8c <flash_write+0x5c>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    ee6a:	4b0f      	ldr	r3, [pc, #60]	; (eea8 <flash_write+0x78>)
    ee6c:	4631      	mov	r1, r6
    ee6e:	4628      	mov	r0, r5
    ee70:	4798      	blx	r3
    ee72:	4604      	mov	r4, r0
    ee74:	b968      	cbnz	r0, ee92 <flash_write+0x62>
	_flash_write(&flash->dev, dst_addr, buffer, length);
    ee76:	4628      	mov	r0, r5
    ee78:	4643      	mov	r3, r8
    ee7a:	4d0c      	ldr	r5, [pc, #48]	; (eeac <flash_write+0x7c>)
    ee7c:	463a      	mov	r2, r7
    ee7e:	4631      	mov	r1, r6
    ee80:	47a8      	blx	r5
	return ERR_NONE;
    ee82:	4620      	mov	r0, r4
}
    ee84:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    ee88:	4610      	mov	r0, r2
    ee8a:	e7dc      	b.n	ee46 <flash_write+0x16>
		return ERR_BAD_ADDRESS;
    ee8c:	f06f 000d 	mvn.w	r0, #13
    ee90:	e7f8      	b.n	ee84 <flash_write+0x54>
		return ERR_DENIED;
    ee92:	f06f 0010 	mvn.w	r0, #16
    ee96:	e7f5      	b.n	ee84 <flash_write+0x54>
    ee98:	000174bc 	.word	0x000174bc
    ee9c:	0000e08d 	.word	0x0000e08d
    eea0:	0000bf81 	.word	0x0000bf81
    eea4:	0000bf87 	.word	0x0000bf87
    eea8:	0000c11d 	.word	0x0000c11d
    eeac:	0000bfa9 	.word	0x0000bfa9

0000eeb0 <flash_erase>:
{
    eeb0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    eeb4:	4688      	mov	r8, r1
    eeb6:	4617      	mov	r7, r2
	ASSERT(flash && page_nums);
    eeb8:	4604      	mov	r4, r0
    eeba:	b110      	cbz	r0, eec2 <flash_erase+0x12>
    eebc:	1e10      	subs	r0, r2, #0
    eebe:	bf18      	it	ne
    eec0:	2001      	movne	r0, #1
    eec2:	4912      	ldr	r1, [pc, #72]	; (ef0c <flash_erase+0x5c>)
    eec4:	4b12      	ldr	r3, [pc, #72]	; (ef10 <flash_erase+0x60>)
    eec6:	229a      	movs	r2, #154	; 0x9a
    eec8:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    eeca:	4b12      	ldr	r3, [pc, #72]	; (ef14 <flash_erase+0x64>)
    eecc:	4620      	mov	r0, r4
    eece:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    eed0:	4b11      	ldr	r3, [pc, #68]	; (ef18 <flash_erase+0x68>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    eed2:	4605      	mov	r5, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    eed4:	4620      	mov	r0, r4
    eed6:	4798      	blx	r3
	rc = flash_is_address_aligned(flash, dst_addr);
    eed8:	4b10      	ldr	r3, [pc, #64]	; (ef1c <flash_erase+0x6c>)
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    eeda:	4681      	mov	r9, r0
	rc = flash_is_address_aligned(flash, dst_addr);
    eedc:	4641      	mov	r1, r8
    eede:	4620      	mov	r0, r4
    eee0:	4798      	blx	r3
	if (rc) {
    eee2:	4606      	mov	r6, r0
    eee4:	b958      	cbnz	r0, eefe <flash_erase+0x4e>
	if ((page_nums > total_pages) || (dst_addr / page_size + page_nums > total_pages)) {
    eee6:	454f      	cmp	r7, r9
    eee8:	d80c      	bhi.n	ef04 <flash_erase+0x54>
    eeea:	fbb8 f5f5 	udiv	r5, r8, r5
    eeee:	443d      	add	r5, r7
    eef0:	454d      	cmp	r5, r9
    eef2:	d807      	bhi.n	ef04 <flash_erase+0x54>
	_flash_erase(&flash->dev, dst_addr, page_nums);
    eef4:	4b0a      	ldr	r3, [pc, #40]	; (ef20 <flash_erase+0x70>)
    eef6:	463a      	mov	r2, r7
    eef8:	4641      	mov	r1, r8
    eefa:	4620      	mov	r0, r4
    eefc:	4798      	blx	r3
}
    eefe:	4630      	mov	r0, r6
    ef00:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ERR_INVALID_ARG;
    ef04:	f06f 060c 	mvn.w	r6, #12
    ef08:	e7f9      	b.n	eefe <flash_erase+0x4e>
    ef0a:	bf00      	nop
    ef0c:	000174bc 	.word	0x000174bc
    ef10:	0000e08d 	.word	0x0000e08d
    ef14:	0000bf81 	.word	0x0000bf81
    ef18:	0000bf87 	.word	0x0000bf87
    ef1c:	0000ed4d 	.word	0x0000ed4d
    ef20:	0000c071 	.word	0x0000c071

0000ef24 <_spi_m_async_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_async_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    ef24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(io);
    ef26:	4604      	mov	r4, r0
    ef28:	3800      	subs	r0, #0
    ef2a:	bf18      	it	ne
    ef2c:	2001      	movne	r0, #1
{
    ef2e:	460f      	mov	r7, r1
    ef30:	4616      	mov	r6, r2
	ASSERT(io);
    ef32:	4909      	ldr	r1, [pc, #36]	; (ef58 <_spi_m_async_io_write+0x34>)
    ef34:	4b09      	ldr	r3, [pc, #36]	; (ef5c <_spi_m_async_io_write+0x38>)
    ef36:	f240 1227 	movw	r2, #295	; 0x127
    ef3a:	4798      	blx	r3
	struct spi_m_async_descriptor *spi = CONTAINER_OF(io, struct spi_m_async_descriptor, io);

	spi->xfer.rxbuf = NULL;
    ef3c:	2500      	movs	r5, #0
	spi->xfer.txbuf = (uint8_t *)buf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ef3e:	2310      	movs	r3, #16
    ef40:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = (uint8_t *)buf;
    ef42:	e9c4 7505 	strd	r7, r5, [r4, #20]
	spi->xfercnt    = 0;
    ef46:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_tx(&spi->dev, true);
    ef4a:	4b05      	ldr	r3, [pc, #20]	; (ef60 <_spi_m_async_io_write+0x3c>)
    ef4c:	2101      	movs	r1, #1
    ef4e:	f1a4 0020 	sub.w	r0, r4, #32
    ef52:	4798      	blx	r3

	return ERR_NONE;
}
    ef54:	4628      	mov	r0, r5
    ef56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ef58:	000174d3 	.word	0x000174d3
    ef5c:	0000e08d 	.word	0x0000e08d
    ef60:	0001166d 	.word	0x0001166d

0000ef64 <_spi_m_async_io_read>:
{
    ef64:	b570      	push	{r4, r5, r6, lr}
	ASSERT(io);
    ef66:	4604      	mov	r4, r0
    ef68:	3800      	subs	r0, #0
    ef6a:	bf18      	it	ne
    ef6c:	2001      	movne	r0, #1
{
    ef6e:	460d      	mov	r5, r1
    ef70:	4616      	mov	r6, r2
	ASSERT(io);
    ef72:	490c      	ldr	r1, [pc, #48]	; (efa4 <_spi_m_async_io_read+0x40>)
    ef74:	4b0c      	ldr	r3, [pc, #48]	; (efa8 <_spi_m_async_io_read+0x44>)
    ef76:	f240 1205 	movw	r2, #261	; 0x105
    ef7a:	4798      	blx	r3
	spi->xfer.rxbuf = buf;
    ef7c:	61a5      	str	r5, [r4, #24]
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ef7e:	2310      	movs	r3, #16
	spi->xfer.txbuf = NULL;
    ef80:	2500      	movs	r5, #0
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ef82:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = NULL;
    ef84:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
    ef86:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_rx(&spi->dev, true);
    ef8a:	3c20      	subs	r4, #32
    ef8c:	4b07      	ldr	r3, [pc, #28]	; (efac <_spi_m_async_io_read+0x48>)
    ef8e:	2101      	movs	r1, #1
    ef90:	4620      	mov	r0, r4
    ef92:	4798      	blx	r3
	_spi_m_async_write_one(&spi->dev, SPI_DUMMY_CHAR);
    ef94:	4b06      	ldr	r3, [pc, #24]	; (efb0 <_spi_m_async_io_read+0x4c>)
    ef96:	f240 11ff 	movw	r1, #511	; 0x1ff
    ef9a:	4620      	mov	r0, r4
    ef9c:	4798      	blx	r3
}
    ef9e:	4628      	mov	r0, r5
    efa0:	bd70      	pop	{r4, r5, r6, pc}
    efa2:	bf00      	nop
    efa4:	000174d3 	.word	0x000174d3
    efa8:	0000e08d 	.word	0x0000e08d
    efac:	00011699 	.word	0x00011699
    efb0:	00011705 	.word	0x00011705

0000efb4 <_spi_dev_error>:
{
    efb4:	b570      	push	{r4, r5, r6, lr}
	_spi_m_async_enable_tx(dev, false);
    efb6:	4b0c      	ldr	r3, [pc, #48]	; (efe8 <_spi_dev_error+0x34>)
{
    efb8:	4604      	mov	r4, r0
    efba:	460d      	mov	r5, r1
	_spi_m_async_enable_tx(dev, false);
    efbc:	2100      	movs	r1, #0
    efbe:	4798      	blx	r3
	_spi_m_async_enable_rx(dev, false);
    efc0:	4b0a      	ldr	r3, [pc, #40]	; (efec <_spi_dev_error+0x38>)
    efc2:	2100      	movs	r1, #0
    efc4:	4620      	mov	r0, r4
    efc6:	4798      	blx	r3
	_spi_m_async_enable_tx_complete(dev, false);
    efc8:	4b09      	ldr	r3, [pc, #36]	; (eff0 <_spi_dev_error+0x3c>)
    efca:	2100      	movs	r1, #0
    efcc:	4620      	mov	r0, r4
    efce:	4798      	blx	r3
	spi->stat = 0;
    efd0:	2300      	movs	r3, #0
    efd2:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	if (spi->callbacks.cb_error) {
    efd6:	6b23      	ldr	r3, [r4, #48]	; 0x30
    efd8:	b123      	cbz	r3, efe4 <_spi_dev_error+0x30>
		spi->callbacks.cb_error(spi, status);
    efda:	4629      	mov	r1, r5
    efdc:	1f20      	subs	r0, r4, #4
}
    efde:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		spi->callbacks.cb_error(spi, status);
    efe2:	4718      	bx	r3
}
    efe4:	bd70      	pop	{r4, r5, r6, pc}
    efe6:	bf00      	nop
    efe8:	0001166d 	.word	0x0001166d
    efec:	00011699 	.word	0x00011699
    eff0:	000116d1 	.word	0x000116d1

0000eff4 <_spi_dev_complete>:
	if (spi->xfercnt >= spi->xfer.size) {
    eff4:	e9d0 320f 	ldrd	r3, r2, [r0, #60]	; 0x3c
    eff8:	429a      	cmp	r2, r3
{
    effa:	b510      	push	{r4, lr}
    effc:	4604      	mov	r4, r0
	if (spi->xfercnt >= spi->xfer.size) {
    effe:	d30b      	bcc.n	f018 <_spi_dev_complete+0x24>
		_spi_m_async_enable_tx_complete(dev, false);
    f000:	4b06      	ldr	r3, [pc, #24]	; (f01c <_spi_dev_complete+0x28>)
    f002:	2100      	movs	r1, #0
    f004:	4798      	blx	r3
		spi->stat = 0;
    f006:	2300      	movs	r3, #0
    f008:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f00c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f00e:	b11b      	cbz	r3, f018 <_spi_dev_complete+0x24>
			spi->callbacks.cb_xfer(spi);
    f010:	1f20      	subs	r0, r4, #4
}
    f012:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			spi->callbacks.cb_xfer(spi);
    f016:	4718      	bx	r3
}
    f018:	bd10      	pop	{r4, pc}
    f01a:	bf00      	nop
    f01c:	000116d1 	.word	0x000116d1

0000f020 <_spi_dev_rx>:
{
    f020:	b570      	push	{r4, r5, r6, lr}
	if (spi->xfer.rxbuf) {
    f022:	6b85      	ldr	r5, [r0, #56]	; 0x38
    f024:	4b1c      	ldr	r3, [pc, #112]	; (f098 <_spi_dev_rx+0x78>)
{
    f026:	4604      	mov	r4, r0
	if (spi->xfer.rxbuf) {
    f028:	b305      	cbz	r5, f06c <_spi_dev_rx+0x4c>
		if (!(dev->char_size > 1)) {
    f02a:	7902      	ldrb	r2, [r0, #4]
    f02c:	2a01      	cmp	r2, #1
    f02e:	d816      	bhi.n	f05e <_spi_dev_rx+0x3e>
			spi->xfer.rxbuf[spi->xfercnt++] = (uint8_t)_spi_m_async_read_one(dev);
    f030:	4798      	blx	r3
    f032:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f034:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    f036:	1c59      	adds	r1, r3, #1
    f038:	6421      	str	r1, [r4, #64]	; 0x40
    f03a:	54d0      	strb	r0, [r2, r3]
	if (spi->xfercnt < spi->xfer.size) {
    f03c:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    f040:	4299      	cmp	r1, r3
    f042:	d21a      	bcs.n	f07a <_spi_dev_rx+0x5a>
		if (spi->xfer.txbuf) {
    f044:	6b62      	ldr	r2, [r4, #52]	; 0x34
    f046:	4b15      	ldr	r3, [pc, #84]	; (f09c <_spi_dev_rx+0x7c>)
    f048:	b1aa      	cbz	r2, f076 <_spi_dev_rx+0x56>
			if (!(dev->char_size > 1)) {
    f04a:	7920      	ldrb	r0, [r4, #4]
    f04c:	2801      	cmp	r0, #1
				_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt]);
    f04e:	bf94      	ite	ls
    f050:	5c51      	ldrbls	r1, [r2, r1]
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f052:	f832 1011 	ldrhhi.w	r1, [r2, r1, lsl #1]
    f056:	4620      	mov	r0, r4
}
    f058:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f05c:	4718      	bx	r3
			((uint16_t *)spi->xfer.rxbuf)[spi->xfercnt++] = (uint16_t)_spi_m_async_read_one(dev);
    f05e:	6c06      	ldr	r6, [r0, #64]	; 0x40
    f060:	1c72      	adds	r2, r6, #1
    f062:	6402      	str	r2, [r0, #64]	; 0x40
    f064:	4798      	blx	r3
    f066:	f825 0016 	strh.w	r0, [r5, r6, lsl #1]
    f06a:	e7e7      	b.n	f03c <_spi_dev_rx+0x1c>
		_spi_m_async_read_one(dev);
    f06c:	4798      	blx	r3
		spi->xfercnt++;
    f06e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f070:	3301      	adds	r3, #1
    f072:	6423      	str	r3, [r4, #64]	; 0x40
    f074:	e7e2      	b.n	f03c <_spi_dev_rx+0x1c>
			_spi_m_async_write_one(dev, dev->dummy_byte);
    f076:	88e1      	ldrh	r1, [r4, #6]
    f078:	e7ed      	b.n	f056 <_spi_dev_rx+0x36>
		_spi_m_async_enable_rx(dev, false);
    f07a:	4b09      	ldr	r3, [pc, #36]	; (f0a0 <_spi_dev_rx+0x80>)
    f07c:	2100      	movs	r1, #0
    f07e:	4620      	mov	r0, r4
    f080:	4798      	blx	r3
		spi->stat = 0;
    f082:	2300      	movs	r3, #0
    f084:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f088:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f08a:	b11b      	cbz	r3, f094 <_spi_dev_rx+0x74>
			spi->callbacks.cb_xfer(spi);
    f08c:	1f20      	subs	r0, r4, #4
}
    f08e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			spi->callbacks.cb_xfer(spi);
    f092:	4718      	bx	r3
}
    f094:	bd70      	pop	{r4, r5, r6, pc}
    f096:	bf00      	nop
    f098:	00011731 	.word	0x00011731
    f09c:	00011705 	.word	0x00011705
    f0a0:	00011699 	.word	0x00011699

0000f0a4 <_spi_dev_tx>:
{
    f0a4:	b570      	push	{r4, r5, r6, lr}
    f0a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
	if (!(dev->char_size > 1)) {
    f0a8:	7902      	ldrb	r2, [r0, #4]
    f0aa:	6b41      	ldr	r1, [r0, #52]	; 0x34
    f0ac:	1c5d      	adds	r5, r3, #1
    f0ae:	2a01      	cmp	r2, #1
		_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt++]);
    f0b0:	6405      	str	r5, [r0, #64]	; 0x40
    f0b2:	bf94      	ite	ls
    f0b4:	5cc9      	ldrbls	r1, [r1, r3]
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f0b6:	f831 1013 	ldrhhi.w	r1, [r1, r3, lsl #1]
    f0ba:	4a09      	ldr	r2, [pc, #36]	; (f0e0 <_spi_dev_tx+0x3c>)
{
    f0bc:	4604      	mov	r4, r0
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f0be:	4790      	blx	r2
	if (spi->xfercnt == spi->xfer.size) {
    f0c0:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
    f0c4:	429a      	cmp	r2, r3
    f0c6:	d109      	bne.n	f0dc <_spi_dev_tx+0x38>
		_spi_m_async_enable_tx(dev, false);
    f0c8:	4b06      	ldr	r3, [pc, #24]	; (f0e4 <_spi_dev_tx+0x40>)
    f0ca:	2100      	movs	r1, #0
    f0cc:	4620      	mov	r0, r4
    f0ce:	4798      	blx	r3
		_spi_m_async_enable_tx_complete(dev, true);
    f0d0:	4620      	mov	r0, r4
    f0d2:	4b05      	ldr	r3, [pc, #20]	; (f0e8 <_spi_dev_tx+0x44>)
}
    f0d4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_enable_tx_complete(dev, true);
    f0d8:	2101      	movs	r1, #1
    f0da:	4718      	bx	r3
}
    f0dc:	bd70      	pop	{r4, r5, r6, pc}
    f0de:	bf00      	nop
    f0e0:	00011705 	.word	0x00011705
    f0e4:	0001166d 	.word	0x0001166d
    f0e8:	000116d1 	.word	0x000116d1

0000f0ec <spi_m_async_init>:
{
    f0ec:	b570      	push	{r4, r5, r6, lr}
    f0ee:	460e      	mov	r6, r1
	ASSERT(spi && hw);
    f0f0:	4604      	mov	r4, r0
    f0f2:	b110      	cbz	r0, f0fa <spi_m_async_init+0xe>
    f0f4:	1e08      	subs	r0, r1, #0
    f0f6:	bf18      	it	ne
    f0f8:	2001      	movne	r0, #1
	spi->dev.prvt = (void *)hw;
    f0fa:	4625      	mov	r5, r4
	ASSERT(spi && hw);
    f0fc:	4911      	ldr	r1, [pc, #68]	; (f144 <spi_m_async_init+0x58>)
    f0fe:	4b12      	ldr	r3, [pc, #72]	; (f148 <spi_m_async_init+0x5c>)
    f100:	22a5      	movs	r2, #165	; 0xa5
    f102:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    f104:	f845 6f04 	str.w	r6, [r5, #4]!
	rc            = _spi_m_async_init(&spi->dev, hw);
    f108:	4b10      	ldr	r3, [pc, #64]	; (f14c <spi_m_async_init+0x60>)
    f10a:	4631      	mov	r1, r6
    f10c:	4628      	mov	r0, r5
    f10e:	4798      	blx	r3
	if (rc >= 0) {
    f110:	2800      	cmp	r0, #0
    f112:	db15      	blt.n	f140 <spi_m_async_init+0x54>
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (FUNC_PTR)_spi_dev_tx);
    f114:	4e0e      	ldr	r6, [pc, #56]	; (f150 <spi_m_async_init+0x64>)
    f116:	4a0f      	ldr	r2, [pc, #60]	; (f154 <spi_m_async_init+0x68>)
    f118:	2100      	movs	r1, #0
    f11a:	4628      	mov	r0, r5
    f11c:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (FUNC_PTR)_spi_dev_rx);
    f11e:	4a0e      	ldr	r2, [pc, #56]	; (f158 <spi_m_async_init+0x6c>)
    f120:	2101      	movs	r1, #1
    f122:	4628      	mov	r0, r5
    f124:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (FUNC_PTR)_spi_dev_complete);
    f126:	4a0d      	ldr	r2, [pc, #52]	; (f15c <spi_m_async_init+0x70>)
    f128:	2102      	movs	r1, #2
    f12a:	4628      	mov	r0, r5
    f12c:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_ERROR, (FUNC_PTR)_spi_dev_error);
    f12e:	4a0c      	ldr	r2, [pc, #48]	; (f160 <spi_m_async_init+0x74>)
    f130:	2103      	movs	r1, #3
    f132:	4628      	mov	r0, r5
    f134:	47b0      	blx	r6
	spi->io.read  = _spi_m_async_io_read;
    f136:	4b0b      	ldr	r3, [pc, #44]	; (f164 <spi_m_async_init+0x78>)
    f138:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->io.write = _spi_m_async_io_write;
    f13a:	4b0b      	ldr	r3, [pc, #44]	; (f168 <spi_m_async_init+0x7c>)
    f13c:	6263      	str	r3, [r4, #36]	; 0x24
	return ERR_NONE;
    f13e:	2000      	movs	r0, #0
}
    f140:	bd70      	pop	{r4, r5, r6, pc}
    f142:	bf00      	nop
    f144:	000174d3 	.word	0x000174d3
    f148:	0000e08d 	.word	0x0000e08d
    f14c:	00011579 	.word	0x00011579
    f150:	00011759 	.word	0x00011759
    f154:	0000f0a5 	.word	0x0000f0a5
    f158:	0000f021 	.word	0x0000f021
    f15c:	0000eff5 	.word	0x0000eff5
    f160:	0000efb5 	.word	0x0000efb5
    f164:	0000ef65 	.word	0x0000ef65
    f168:	0000ef25 	.word	0x0000ef25

0000f16c <spi_m_async_enable>:
{
    f16c:	b510      	push	{r4, lr}
	ASSERT(spi);
    f16e:	4604      	mov	r4, r0
    f170:	3800      	subs	r0, #0
    f172:	4b05      	ldr	r3, [pc, #20]	; (f188 <spi_m_async_enable+0x1c>)
    f174:	4905      	ldr	r1, [pc, #20]	; (f18c <spi_m_async_enable+0x20>)
    f176:	bf18      	it	ne
    f178:	2001      	movne	r0, #1
    f17a:	22c1      	movs	r2, #193	; 0xc1
    f17c:	4798      	blx	r3
	_spi_m_async_enable(&spi->dev);
    f17e:	1d20      	adds	r0, r4, #4
    f180:	4b03      	ldr	r3, [pc, #12]	; (f190 <spi_m_async_enable+0x24>)
}
    f182:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_async_enable(&spi->dev);
    f186:	4718      	bx	r3
    f188:	0000e08d 	.word	0x0000e08d
    f18c:	000174d3 	.word	0x000174d3
    f190:	000115d1 	.word	0x000115d1

0000f194 <spi_m_async_set_baudrate>:
{
    f194:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f196:	4604      	mov	r4, r0
    f198:	3800      	subs	r0, #0
    f19a:	4b0a      	ldr	r3, [pc, #40]	; (f1c4 <spi_m_async_set_baudrate+0x30>)
    f19c:	bf18      	it	ne
    f19e:	2001      	movne	r0, #1
{
    f1a0:	460d      	mov	r5, r1
	ASSERT(spi);
    f1a2:	22cf      	movs	r2, #207	; 0xcf
    f1a4:	4908      	ldr	r1, [pc, #32]	; (f1c8 <spi_m_async_set_baudrate+0x34>)
    f1a6:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f1a8:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f1ac:	06db      	lsls	r3, r3, #27
    f1ae:	d405      	bmi.n	f1bc <spi_m_async_set_baudrate+0x28>
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f1b0:	4629      	mov	r1, r5
    f1b2:	1d20      	adds	r0, r4, #4
    f1b4:	4b05      	ldr	r3, [pc, #20]	; (f1cc <spi_m_async_set_baudrate+0x38>)
}
    f1b6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f1ba:	4718      	bx	r3
}
    f1bc:	f06f 0003 	mvn.w	r0, #3
    f1c0:	bd70      	pop	{r4, r5, r6, pc}
    f1c2:	bf00      	nop
    f1c4:	0000e08d 	.word	0x0000e08d
    f1c8:	000174d3 	.word	0x000174d3
    f1cc:	00011635 	.word	0x00011635

0000f1d0 <spi_m_async_set_mode>:
{
    f1d0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f1d2:	4604      	mov	r4, r0
    f1d4:	3800      	subs	r0, #0
    f1d6:	4b0a      	ldr	r3, [pc, #40]	; (f200 <spi_m_async_set_mode+0x30>)
    f1d8:	bf18      	it	ne
    f1da:	2001      	movne	r0, #1
{
    f1dc:	460d      	mov	r5, r1
	ASSERT(spi);
    f1de:	22d9      	movs	r2, #217	; 0xd9
    f1e0:	4908      	ldr	r1, [pc, #32]	; (f204 <spi_m_async_set_mode+0x34>)
    f1e2:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f1e4:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f1e8:	06db      	lsls	r3, r3, #27
    f1ea:	d405      	bmi.n	f1f8 <spi_m_async_set_mode+0x28>
	return _spi_m_async_set_mode(&spi->dev, mode);
    f1ec:	4629      	mov	r1, r5
    f1ee:	1d20      	adds	r0, r4, #4
    f1f0:	4b05      	ldr	r3, [pc, #20]	; (f208 <spi_m_async_set_mode+0x38>)
}
    f1f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_mode(&spi->dev, mode);
    f1f6:	4718      	bx	r3
}
    f1f8:	f06f 0003 	mvn.w	r0, #3
    f1fc:	bd70      	pop	{r4, r5, r6, pc}
    f1fe:	bf00      	nop
    f200:	0000e08d 	.word	0x0000e08d
    f204:	000174d3 	.word	0x000174d3
    f208:	00011601 	.word	0x00011601

0000f20c <spi_m_async_transfer>:

int32_t spi_m_async_transfer(struct spi_m_async_descriptor *spi, uint8_t const *txbuf, uint8_t *const rxbuf,
                             const uint16_t length)
{
    f20c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(spi);
    f20e:	4604      	mov	r4, r0
    f210:	3800      	subs	r0, #0
{
    f212:	461e      	mov	r6, r3
	ASSERT(spi);
    f214:	bf18      	it	ne
    f216:	2001      	movne	r0, #1
    f218:	4b11      	ldr	r3, [pc, #68]	; (f260 <spi_m_async_transfer+0x54>)
{
    f21a:	460d      	mov	r5, r1
    f21c:	4617      	mov	r7, r2
	ASSERT(spi);
    f21e:	4911      	ldr	r1, [pc, #68]	; (f264 <spi_m_async_transfer+0x58>)
    f220:	f44f 729c 	mov.w	r2, #312	; 0x138
    f224:	4798      	blx	r3

	/* Fill transfer descriptor */
	spi->xfer.rxbuf = (uint8_t *)rxbuf;
	spi->xfer.txbuf = (uint8_t *)txbuf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;
    f226:	2300      	movs	r3, #0
	spi->xfer.size  = length;
    f228:	6426      	str	r6, [r4, #64]	; 0x40
	spi->xfercnt    = 0;
    f22a:	6463      	str	r3, [r4, #68]	; 0x44

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
	_spi_m_async_enable_rx(&spi->dev, true);
    f22c:	1d26      	adds	r6, r4, #4
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f22e:	2310      	movs	r3, #16
    f230:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	spi->xfer.txbuf = (uint8_t *)txbuf;
    f234:	e9c4 570e 	strd	r5, r7, [r4, #56]	; 0x38
	_spi_m_async_enable_rx(&spi->dev, true);
    f238:	4b0b      	ldr	r3, [pc, #44]	; (f268 <spi_m_async_transfer+0x5c>)
    f23a:	2101      	movs	r1, #1
    f23c:	4630      	mov	r0, r6
    f23e:	4798      	blx	r3
	if (txbuf) {
    f240:	4b0a      	ldr	r3, [pc, #40]	; (f26c <spi_m_async_transfer+0x60>)
    f242:	b155      	cbz	r5, f25a <spi_m_async_transfer+0x4e>
		if (!(spi->dev.char_size > 1)) {
    f244:	7a21      	ldrb	r1, [r4, #8]
    f246:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f248:	2901      	cmp	r1, #1
			_spi_m_async_write_one(&spi->dev, txbuf[spi->xfercnt]);
    f24a:	bf94      	ite	ls
    f24c:	5ca9      	ldrbls	r1, [r5, r2]
		} else {
			_spi_m_async_write_one(&spi->dev, ((uint16_t *)txbuf)[spi->xfercnt]);
    f24e:	f835 1012 	ldrhhi.w	r1, [r5, r2, lsl #1]
		}
	} else {
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f252:	4630      	mov	r0, r6
    f254:	4798      	blx	r3
	}

	return ERR_NONE;
}
    f256:	2000      	movs	r0, #0
    f258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f25a:	8961      	ldrh	r1, [r4, #10]
    f25c:	e7f9      	b.n	f252 <spi_m_async_transfer+0x46>
    f25e:	bf00      	nop
    f260:	0000e08d 	.word	0x0000e08d
    f264:	000174d3 	.word	0x000174d3
    f268:	00011699 	.word	0x00011699
    f26c:	00011705 	.word	0x00011705

0000f270 <spi_m_async_register_callback>:
	return ERR_NONE;
}

void spi_m_async_register_callback(struct spi_m_async_descriptor *spi, const enum spi_m_async_cb_type type,
                                   FUNC_PTR func)
{
    f270:	b570      	push	{r4, r5, r6, lr}
    f272:	460e      	mov	r6, r1
    f274:	4615      	mov	r5, r2
	ASSERT(spi && (type < SPI_M_ASYNC_CB_N));
    f276:	4604      	mov	r4, r0
    f278:	b118      	cbz	r0, f282 <spi_m_async_register_callback+0x12>
    f27a:	2901      	cmp	r1, #1
    f27c:	bf8c      	ite	hi
    f27e:	2000      	movhi	r0, #0
    f280:	2001      	movls	r0, #1
    f282:	4909      	ldr	r1, [pc, #36]	; (f2a8 <spi_m_async_register_callback+0x38>)
    f284:	4b09      	ldr	r3, [pc, #36]	; (f2ac <spi_m_async_register_callback+0x3c>)
    f286:	f240 1263 	movw	r2, #355	; 0x163
    f28a:	4798      	blx	r3

	if (SPI_M_ASYNC_CB_XFER == type) {
    f28c:	b90e      	cbnz	r6, f292 <spi_m_async_register_callback+0x22>
		spi->callbacks.cb_xfer = (spi_m_async_cb_xfer_t)func;
    f28e:	6325      	str	r5, [r4, #48]	; 0x30
	} else {
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
	}
}
    f290:	bd70      	pop	{r4, r5, r6, pc}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f292:	1e2a      	subs	r2, r5, #0
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
    f294:	6365      	str	r5, [r4, #52]	; 0x34
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f296:	f104 0004 	add.w	r0, r4, #4
    f29a:	4b05      	ldr	r3, [pc, #20]	; (f2b0 <spi_m_async_register_callback+0x40>)
}
    f29c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f2a0:	bf18      	it	ne
    f2a2:	2201      	movne	r2, #1
    f2a4:	2103      	movs	r1, #3
    f2a6:	4718      	bx	r3
    f2a8:	000174d3 	.word	0x000174d3
    f2ac:	0000e08d 	.word	0x0000e08d
    f2b0:	00011789 	.word	0x00011789

0000f2b4 <spi_m_async_get_io_descriptor>:

int32_t spi_m_async_get_io_descriptor(struct spi_m_async_descriptor *const spi, struct io_descriptor **io)
{
    f2b4:	b538      	push	{r3, r4, r5, lr}
    f2b6:	460d      	mov	r5, r1
	ASSERT(spi && io);
    f2b8:	4604      	mov	r4, r0
    f2ba:	b110      	cbz	r0, f2c2 <spi_m_async_get_io_descriptor+0xe>
    f2bc:	1e08      	subs	r0, r1, #0
    f2be:	bf18      	it	ne
    f2c0:	2001      	movne	r0, #1
    f2c2:	4904      	ldr	r1, [pc, #16]	; (f2d4 <spi_m_async_get_io_descriptor+0x20>)
    f2c4:	4b04      	ldr	r3, [pc, #16]	; (f2d8 <spi_m_async_get_io_descriptor+0x24>)
    f2c6:	f240 126f 	movw	r2, #367	; 0x16f
	*io = &spi->io;
    f2ca:	3424      	adds	r4, #36	; 0x24
	ASSERT(spi && io);
    f2cc:	4798      	blx	r3
	*io = &spi->io;
    f2ce:	602c      	str	r4, [r5, #0]
	return 0;
}
    f2d0:	2000      	movs	r0, #0
    f2d2:	bd38      	pop	{r3, r4, r5, pc}
    f2d4:	000174d3 	.word	0x000174d3
    f2d8:	0000e08d 	.word	0x0000e08d

0000f2dc <crc_sync_init>:

/**
 * \brief Initialize CRC.
 */
int32_t crc_sync_init(struct crc_sync_descriptor *const descr, void *const hw)
{
    f2dc:	b570      	push	{r4, r5, r6, lr}
    f2de:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    f2e0:	4604      	mov	r4, r0
    f2e2:	b110      	cbz	r0, f2ea <crc_sync_init+0xe>
    f2e4:	1e08      	subs	r0, r1, #0
    f2e6:	bf18      	it	ne
    f2e8:	2001      	movne	r0, #1
    f2ea:	4905      	ldr	r1, [pc, #20]	; (f300 <crc_sync_init+0x24>)
    f2ec:	4b05      	ldr	r3, [pc, #20]	; (f304 <crc_sync_init+0x28>)
    f2ee:	222b      	movs	r2, #43	; 0x2b
    f2f0:	4798      	blx	r3

	return _crc_sync_init(&descr->dev, hw);
    f2f2:	4629      	mov	r1, r5
    f2f4:	4620      	mov	r0, r4
    f2f6:	4b04      	ldr	r3, [pc, #16]	; (f308 <crc_sync_init+0x2c>)
}
    f2f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _crc_sync_init(&descr->dev, hw);
    f2fc:	4718      	bx	r3
    f2fe:	bf00      	nop
    f300:	000174f0 	.word	0x000174f0
    f304:	0000e08d 	.word	0x0000e08d
    f308:	00013ae9 	.word	0x00013ae9

0000f30c <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f30c:	4a0a      	ldr	r2, [pc, #40]	; (f338 <_usb_d_find_ep+0x2c>)
{
    f30e:	b570      	push	{r4, r5, r6, lr}
    f310:	2300      	movs	r3, #0
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f312:	f000 050f 	and.w	r5, r0, #15
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    f316:	7854      	ldrb	r4, [r2, #1]
    f318:	4284      	cmp	r4, r0
    f31a:	b259      	sxtb	r1, r3
    f31c:	d00a      	beq.n	f334 <_usb_d_find_ep+0x28>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    f31e:	7816      	ldrb	r6, [r2, #0]
    f320:	b90e      	cbnz	r6, f326 <_usb_d_find_ep+0x1a>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f322:	42ac      	cmp	r4, r5
    f324:	d006      	beq.n	f334 <_usb_d_find_ep+0x28>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f326:	3301      	adds	r3, #1
    f328:	2b0d      	cmp	r3, #13
    f32a:	f102 0220 	add.w	r2, r2, #32
    f32e:	d1f2      	bne.n	f316 <_usb_d_find_ep+0xa>
			return i;
		}
	}
	return -1;
    f330:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
}
    f334:	4608      	mov	r0, r1
    f336:	bd70      	pop	{r4, r5, r6, pc}
    f338:	20008b60 	.word	0x20008b60

0000f33c <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    f33c:	2000      	movs	r0, #0
    f33e:	4770      	bx	lr

0000f340 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    f340:	b513      	push	{r0, r1, r4, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f342:	4b0a      	ldr	r3, [pc, #40]	; (f36c <usb_d_cb_trans_more+0x2c>)
{
    f344:	9101      	str	r1, [sp, #4]
    f346:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f348:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    f34a:	4b09      	ldr	r3, [pc, #36]	; (f370 <usb_d_cb_trans_more+0x30>)
    f34c:	9901      	ldr	r1, [sp, #4]
    f34e:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    f352:	789a      	ldrb	r2, [r3, #2]
    f354:	2a03      	cmp	r2, #3
    f356:	d105      	bne.n	f364 <usb_d_cb_trans_more+0x24>
		return ept->callbacks.more(ep, transfered);
    f358:	699b      	ldr	r3, [r3, #24]
    f35a:	4620      	mov	r0, r4
	}
	return false;
}
    f35c:	b002      	add	sp, #8
    f35e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return ept->callbacks.more(ep, transfered);
    f362:	4718      	bx	r3
}
    f364:	2000      	movs	r0, #0
    f366:	b002      	add	sp, #8
    f368:	bd10      	pop	{r4, pc}
    f36a:	bf00      	nop
    f36c:	0000f30d 	.word	0x0000f30d
    f370:	20008b60 	.word	0x20008b60

0000f374 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    f374:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f378:	4b37      	ldr	r3, [pc, #220]	; (f458 <_usb_d_cb_trans_done+0xe4>)
    f37a:	4c38      	ldr	r4, [pc, #224]	; (f45c <_usb_d_cb_trans_done+0xe8>)
{
    f37c:	b085      	sub	sp, #20
    f37e:	4680      	mov	r8, r0
    f380:	460f      	mov	r7, r1
    f382:	4691      	mov	r9, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f384:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    f386:	0146      	lsls	r6, r0, #5
    f388:	2f00      	cmp	r7, #0
    f38a:	d143      	bne.n	f414 <_usb_d_cb_trans_done+0xa0>
		ept->xfer.hdr.status = USB_XFER_DONE;
    f38c:	19a5      	adds	r5, r4, r6
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f38e:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_DONE;
    f390:	70ef      	strb	r7, [r5, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f392:	2900      	cmp	r1, #0
    f394:	d135      	bne.n	f402 <_usb_d_cb_trans_done+0x8e>
	if (state == USB_EP_S_X_DATA) {
    f396:	2320      	movs	r3, #32
    f398:	220c      	movs	r2, #12
    f39a:	fb13 2000 	smlabb	r0, r3, r0, r2
    f39e:	78ab      	ldrb	r3, [r5, #2]
    f3a0:	2b03      	cmp	r3, #3
    f3a2:	eb04 0200 	add.w	r2, r4, r0
    f3a6:	69eb      	ldr	r3, [r5, #28]
    f3a8:	7868      	ldrb	r0, [r5, #1]
    f3aa:	d126      	bne.n	f3fa <_usb_d_cb_trans_done+0x86>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    f3ac:	2101      	movs	r1, #1
    f3ae:	f995 400c 	ldrsb.w	r4, [r5, #12]
    f3b2:	4798      	blx	r3
		if (err) {
    f3b4:	786b      	ldrb	r3, [r5, #1]
    f3b6:	b168      	cbz	r0, f3d4 <_usb_d_cb_trans_done+0x60>
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f3b8:	2c00      	cmp	r4, #0
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f3ba:	f240 2205 	movw	r2, #517	; 0x205
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f3be:	bfb4      	ite	lt
    f3c0:	4618      	movlt	r0, r3
    f3c2:	f043 0080 	orrge.w	r0, r3, #128	; 0x80
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f3c6:	806a      	strh	r2, [r5, #2]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f3c8:	4b25      	ldr	r3, [pc, #148]	; (f460 <_usb_d_cb_trans_done+0xec>)
    f3ca:	2101      	movs	r1, #1
    f3cc:	4798      	blx	r3
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
}
    f3ce:	b005      	add	sp, #20
    f3d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct usb_d_transfer trans
    f3d4:	2c00      	cmp	r4, #0
    f3d6:	bfac      	ite	ge
    f3d8:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    f3dc:	f003 030f 	andlt.w	r3, r3, #15
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f3e0:	2204      	movs	r2, #4
	struct usb_d_transfer trans
    f3e2:	f88d 300c 	strb.w	r3, [sp, #12]
    f3e6:	2301      	movs	r3, #1
    f3e8:	e9cd 0001 	strd	r0, r0, [sp, #4]
    f3ec:	f88d 300d 	strb.w	r3, [sp, #13]
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f3f0:	70aa      	strb	r2, [r5, #2]
	return _usb_d_dev_ep_trans(&trans);
    f3f2:	4b1c      	ldr	r3, [pc, #112]	; (f464 <_usb_d_cb_trans_done+0xf0>)
    f3f4:	a801      	add	r0, sp, #4
    f3f6:	4798      	blx	r3
    f3f8:	e7e9      	b.n	f3ce <_usb_d_cb_trans_done+0x5a>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    f3fa:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f3fc:	2302      	movs	r3, #2
    f3fe:	70ab      	strb	r3, [r5, #2]
    f400:	e7e5      	b.n	f3ce <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f402:	2301      	movs	r3, #1
    f404:	70ab      	strb	r3, [r5, #2]
	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    f406:	4434      	add	r4, r6
    f408:	464a      	mov	r2, r9
    f40a:	69e3      	ldr	r3, [r4, #28]
    f40c:	78e1      	ldrb	r1, [r4, #3]
    f40e:	4640      	mov	r0, r8
    f410:	4798      	blx	r3
    f412:	e7dc      	b.n	f3ce <_usb_d_cb_trans_done+0x5a>
	} else if (code == USB_TRANS_STALL) {
    f414:	2f01      	cmp	r7, #1
		ept->xfer.hdr.status = USB_XFER_HALT;
    f416:	eb04 0306 	add.w	r3, r4, r6
	} else if (code == USB_TRANS_STALL) {
    f41a:	d10b      	bne.n	f434 <_usb_d_cb_trans_done+0xc0>
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f41c:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_HALT;
    f41e:	2202      	movs	r2, #2
    f420:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f422:	b921      	cbnz	r1, f42e <_usb_d_cb_trans_done+0xba>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f424:	709a      	strb	r2, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f426:	4640      	mov	r0, r8
    f428:	4b0d      	ldr	r3, [pc, #52]	; (f460 <_usb_d_cb_trans_done+0xec>)
    f42a:	4798      	blx	r3
    f42c:	e7eb      	b.n	f406 <_usb_d_cb_trans_done+0x92>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    f42e:	2205      	movs	r2, #5
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f430:	709a      	strb	r2, [r3, #2]
    f432:	e7e8      	b.n	f406 <_usb_d_cb_trans_done+0x92>
	} else if (code == USB_TRANS_ABORT) {
    f434:	2f02      	cmp	r7, #2
    f436:	d107      	bne.n	f448 <_usb_d_cb_trans_done+0xd4>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    f438:	2204      	movs	r2, #4
    f43a:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f43c:	5da2      	ldrb	r2, [r4, r6]
    f43e:	b90a      	cbnz	r2, f444 <_usb_d_cb_trans_done+0xd0>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f440:	709f      	strb	r7, [r3, #2]
			return;
    f442:	e7c4      	b.n	f3ce <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f444:	2201      	movs	r2, #1
    f446:	e7f3      	b.n	f430 <_usb_d_cb_trans_done+0xbc>
	} else if (code == USB_TRANS_RESET) {
    f448:	2f03      	cmp	r7, #3
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    f44a:	bf0c      	ite	eq
    f44c:	f44f 62a0 	moveq.w	r2, #1280	; 0x500
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    f450:	f240 6206 	movwne	r2, #1542	; 0x606
    f454:	805a      	strh	r2, [r3, #2]
    f456:	e7d6      	b.n	f406 <_usb_d_cb_trans_done+0x92>
    f458:	0000f30d 	.word	0x0000f30d
    f45c:	20008b60 	.word	0x20008b60
    f460:	0000d70d 	.word	0x0000d70d
    f464:	0000d82d 	.word	0x0000d82d

0000f468 <usb_d_cb_trans_setup>:
{
    f468:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f46c:	4b18      	ldr	r3, [pc, #96]	; (f4d0 <usb_d_cb_trans_setup+0x68>)
	uint8_t *        req      = ept->xfer.req;
    f46e:	4f19      	ldr	r7, [pc, #100]	; (f4d4 <usb_d_cb_trans_setup+0x6c>)
    f470:	4d19      	ldr	r5, [pc, #100]	; (f4d8 <usb_d_cb_trans_setup+0x70>)
{
    f472:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f474:	4798      	blx	r3
	uint8_t *        req      = ept->xfer.req;
    f476:	f04f 0820 	mov.w	r8, #32
    f47a:	230c      	movs	r3, #12
    f47c:	fb18 3800 	smlabb	r8, r8, r0, r3
    f480:	44b8      	add	r8, r7
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f482:	4b16      	ldr	r3, [pc, #88]	; (f4dc <usb_d_cb_trans_setup+0x74>)
	int8_t           ep_index = _usb_d_find_ep(ep);
    f484:	4606      	mov	r6, r0
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f486:	4641      	mov	r1, r8
    f488:	4620      	mov	r0, r4
    f48a:	4798      	blx	r3
	if (n != 8) {
    f48c:	b2c0      	uxtb	r0, r0
    f48e:	2808      	cmp	r0, #8
    f490:	f044 0980 	orr.w	r9, r4, #128	; 0x80
    f494:	d008      	beq.n	f4a8 <usb_d_cb_trans_setup+0x40>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f496:	2101      	movs	r1, #1
    f498:	4620      	mov	r0, r4
    f49a:	47a8      	blx	r5
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f49c:	4648      	mov	r0, r9
    f49e:	462b      	mov	r3, r5
    f4a0:	2101      	movs	r1, #1
}
    f4a2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f4a6:	4718      	bx	r3
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f4a8:	eb07 1646 	add.w	r6, r7, r6, lsl #5
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f4ac:	2100      	movs	r1, #0
    f4ae:	4620      	mov	r0, r4
    f4b0:	47a8      	blx	r5
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f4b2:	2701      	movs	r7, #1
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    f4b4:	2100      	movs	r1, #0
    f4b6:	4648      	mov	r0, r9
    f4b8:	47a8      	blx	r5
	if (!ept->callbacks.req(ep, req)) {
    f4ba:	6973      	ldr	r3, [r6, #20]
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f4bc:	70b7      	strb	r7, [r6, #2]
	if (!ept->callbacks.req(ep, req)) {
    f4be:	4641      	mov	r1, r8
    f4c0:	4620      	mov	r0, r4
    f4c2:	4798      	blx	r3
    f4c4:	b910      	cbnz	r0, f4cc <usb_d_cb_trans_setup+0x64>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    f4c6:	2305      	movs	r3, #5
    f4c8:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f4ca:	e7e4      	b.n	f496 <usb_d_cb_trans_setup+0x2e>
}
    f4cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f4d0:	0000f30d 	.word	0x0000f30d
    f4d4:	20008b60 	.word	0x20008b60
    f4d8:	0000d70d 	.word	0x0000d70d
    f4dc:	0000d7d9 	.word	0x0000d7d9

0000f4e0 <usb_d_init>:

int32_t usb_d_init(void)
{
    f4e0:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    f4e2:	4b11      	ldr	r3, [pc, #68]	; (f528 <usb_d_init+0x48>)
    f4e4:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    f4e6:	2800      	cmp	r0, #0
    f4e8:	db1d      	blt.n	f526 <usb_d_init+0x46>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f4ea:	4b10      	ldr	r3, [pc, #64]	; (f52c <usb_d_init+0x4c>)
    f4ec:	4810      	ldr	r0, [pc, #64]	; (f530 <usb_d_init+0x50>)
    f4ee:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    f4f2:	2100      	movs	r1, #0
    f4f4:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f4f6:	4b0e      	ldr	r3, [pc, #56]	; (f530 <usb_d_init+0x50>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    f4f8:	490e      	ldr	r1, [pc, #56]	; (f534 <usb_d_init+0x54>)
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f4fa:	2200      	movs	r2, #0
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f4fc:	20ff      	movs	r0, #255	; 0xff
    f4fe:	3201      	adds	r2, #1
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f500:	2a0d      	cmp	r2, #13
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    f502:	e9c3 1105 	strd	r1, r1, [r3, #20]
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f506:	7058      	strb	r0, [r3, #1]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    f508:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f50a:	f103 0320 	add.w	r3, r3, #32
    f50e:	d1f6      	bne.n	f4fe <usb_d_init+0x1e>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    f510:	4c09      	ldr	r4, [pc, #36]	; (f538 <usb_d_init+0x58>)
    f512:	490a      	ldr	r1, [pc, #40]	; (f53c <usb_d_init+0x5c>)
    f514:	2000      	movs	r0, #0
    f516:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    f518:	4909      	ldr	r1, [pc, #36]	; (f540 <usb_d_init+0x60>)
    f51a:	2001      	movs	r0, #1
    f51c:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    f51e:	2002      	movs	r0, #2
    f520:	4908      	ldr	r1, [pc, #32]	; (f544 <usb_d_init+0x64>)
    f522:	47a0      	blx	r4
	return ERR_NONE;
    f524:	2000      	movs	r0, #0
}
    f526:	bd10      	pop	{r4, pc}
    f528:	0000d305 	.word	0x0000d305
    f52c:	00014469 	.word	0x00014469
    f530:	20008b60 	.word	0x20008b60
    f534:	0000f33d 	.word	0x0000f33d
    f538:	0000d9cd 	.word	0x0000d9cd
    f53c:	0000f469 	.word	0x0000f469
    f540:	0000f341 	.word	0x0000f341
    f544:	0000f375 	.word	0x0000f375

0000f548 <usb_d_register_callback>:
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    f548:	4b00      	ldr	r3, [pc, #0]	; (f54c <usb_d_register_callback+0x4>)
    f54a:	4718      	bx	r3
    f54c:	0000d9a9 	.word	0x0000d9a9

0000f550 <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
	return _usb_d_dev_enable();
    f550:	4b00      	ldr	r3, [pc, #0]	; (f554 <usb_d_enable+0x4>)
    f552:	4718      	bx	r3
    f554:	0000d3e1 	.word	0x0000d3e1

0000f558 <usb_d_attach>:
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
	_usb_d_dev_attach();
    f558:	4b00      	ldr	r3, [pc, #0]	; (f55c <usb_d_attach+0x4>)
    f55a:	4718      	bx	r3
    f55c:	0000d43d 	.word	0x0000d43d

0000f560 <usb_d_get_frame_num>:
	return _usb_d_dev_get_speed();
}

uint16_t usb_d_get_frame_num(void)
{
	return _usb_d_dev_get_frame_n();
    f560:	4b00      	ldr	r3, [pc, #0]	; (f564 <usb_d_get_frame_num+0x4>)
    f562:	4718      	bx	r3
    f564:	0000d45b 	.word	0x0000d45b

0000f568 <usb_d_set_address>:
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
	_usb_d_dev_set_address(addr);
    f568:	4b00      	ldr	r3, [pc, #0]	; (f56c <usb_d_set_address+0x4>)
    f56a:	4718      	bx	r3
    f56c:	0000d44f 	.word	0x0000d44f

0000f570 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    f570:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    f572:	4c11      	ldr	r4, [pc, #68]	; (f5b8 <usb_d_ep_init+0x48>)
{
    f574:	4606      	mov	r6, r0
    f576:	460d      	mov	r5, r1
    f578:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f57a:	47a0      	blx	r4
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    f57c:	2800      	cmp	r0, #0
    f57e:	da14      	bge.n	f5aa <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    f580:	20ff      	movs	r0, #255	; 0xff
    f582:	47a0      	blx	r4
		if (ep_index < 0) {
    f584:	1e04      	subs	r4, r0, #0
    f586:	db13      	blt.n	f5b0 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    f588:	4b0c      	ldr	r3, [pc, #48]	; (f5bc <usb_d_ep_init+0x4c>)
    f58a:	463a      	mov	r2, r7
    f58c:	4629      	mov	r1, r5
    f58e:	4630      	mov	r0, r6
    f590:	4798      	blx	r3
	if (rc < 0) {
    f592:	2800      	cmp	r0, #0
    f594:	db08      	blt.n	f5a8 <usb_d_ep_init+0x38>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    f596:	4b0a      	ldr	r3, [pc, #40]	; (f5c0 <usb_d_ep_init+0x50>)
    f598:	0162      	lsls	r2, r4, #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f59a:	f005 0503 	and.w	r5, r5, #3
	ept->xfer.hdr.ep   = ep;
    f59e:	eb03 1444 	add.w	r4, r3, r4, lsl #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f5a2:	549d      	strb	r5, [r3, r2]
	ept->xfer.hdr.ep   = ep;
    f5a4:	7066      	strb	r6, [r4, #1]
	return ERR_NONE;
    f5a6:	2000      	movs	r0, #0
}
    f5a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    f5aa:	f06f 0013 	mvn.w	r0, #19
    f5ae:	e7fb      	b.n	f5a8 <usb_d_ep_init+0x38>
			return -USB_ERR_ALLOC_FAIL;
    f5b0:	f06f 0014 	mvn.w	r0, #20
    f5b4:	e7f8      	b.n	f5a8 <usb_d_ep_init+0x38>
    f5b6:	bf00      	nop
    f5b8:	0000f30d 	.word	0x0000f30d
    f5bc:	0000d469 	.word	0x0000d469
    f5c0:	20008b60 	.word	0x20008b60

0000f5c4 <usb_d_ep0_init>:
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f5c4:	2100      	movs	r1, #0
{
    f5c6:	4602      	mov	r2, r0
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f5c8:	4b01      	ldr	r3, [pc, #4]	; (f5d0 <usb_d_ep0_init+0xc>)
    f5ca:	4608      	mov	r0, r1
    f5cc:	4718      	bx	r3
    f5ce:	bf00      	nop
    f5d0:	0000f571 	.word	0x0000f571

0000f5d4 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    f5d4:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f5d6:	4b07      	ldr	r3, [pc, #28]	; (f5f4 <usb_d_ep_deinit+0x20>)
{
    f5d8:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f5da:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    f5dc:	1e04      	subs	r4, r0, #0
    f5de:	db07      	blt.n	f5f0 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    f5e0:	4b05      	ldr	r3, [pc, #20]	; (f5f8 <usb_d_ep_deinit+0x24>)
    f5e2:	4628      	mov	r0, r5
    f5e4:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    f5e6:	4805      	ldr	r0, [pc, #20]	; (f5fc <usb_d_ep_deinit+0x28>)
    f5e8:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    f5ec:	23ff      	movs	r3, #255	; 0xff
    f5ee:	7043      	strb	r3, [r0, #1]
}
    f5f0:	bd38      	pop	{r3, r4, r5, pc}
    f5f2:	bf00      	nop
    f5f4:	0000f30d 	.word	0x0000f30d
    f5f8:	0000d529 	.word	0x0000d529
    f5fc:	20008b60 	.word	0x20008b60

0000f600 <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    f600:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f602:	4b0c      	ldr	r3, [pc, #48]	; (f634 <usb_d_ep_enable+0x34>)
{
    f604:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f606:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    f608:	1e03      	subs	r3, r0, #0
    f60a:	db10      	blt.n	f62e <usb_d_ep_enable+0x2e>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f60c:	015b      	lsls	r3, r3, #5
    f60e:	4c0a      	ldr	r4, [pc, #40]	; (f638 <usb_d_ep_enable+0x38>)
    f610:	5ce2      	ldrb	r2, [r4, r3]
    f612:	441c      	add	r4, r3
    f614:	2a00      	cmp	r2, #0
    f616:	bf0c      	ite	eq
    f618:	2202      	moveq	r2, #2
    f61a:	2201      	movne	r2, #1
	rc                  = _usb_d_dev_ep_enable(ep);
    f61c:	4b07      	ldr	r3, [pc, #28]	; (f63c <usb_d_ep_enable+0x3c>)
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f61e:	70a2      	strb	r2, [r4, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    f620:	4628      	mov	r0, r5
    f622:	4798      	blx	r3
	if (rc < 0) {
    f624:	2800      	cmp	r0, #0
    f626:	da01      	bge.n	f62c <usb_d_ep_enable+0x2c>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    f628:	2300      	movs	r3, #0
    f62a:	70a3      	strb	r3, [r4, #2]
	}
	return rc;
}
    f62c:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    f62e:	f06f 0011 	mvn.w	r0, #17
    f632:	e7fb      	b.n	f62c <usb_d_ep_enable+0x2c>
    f634:	0000f30d 	.word	0x0000f30d
    f638:	20008b60 	.word	0x20008b60
    f63c:	0000d59d 	.word	0x0000d59d

0000f640 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    f640:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f644:	f890 8008 	ldrb.w	r8, [r0, #8]
    f648:	4b31      	ldr	r3, [pc, #196]	; (f710 <usb_d_ep_transfer+0xd0>)
{
    f64a:	4605      	mov	r5, r0
    f64c:	b087      	sub	sp, #28
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f64e:	4640      	mov	r0, r8
    f650:	4798      	blx	r3
	uint32_t              len = xfer->size;
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    f652:	1e04      	subs	r4, r0, #0
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f654:	7a6f      	ldrb	r7, [r5, #9]
	uint32_t              len = xfer->size;
    f656:	686e      	ldr	r6, [r5, #4]
	if (ep_index < 0) {
    f658:	db55      	blt.n	f706 <usb_d_ep_transfer+0xc6>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
	state = ept->xfer.hdr.state;
    f65a:	f8df a0c8 	ldr.w	sl, [pc, #200]	; f724 <usb_d_ep_transfer+0xe4>
	atomic_enter_critical(&flags);
    f65e:	4b2d      	ldr	r3, [pc, #180]	; (f714 <usb_d_ep_transfer+0xd4>)
	state = ept->xfer.hdr.state;
    f660:	ea4f 1b44 	mov.w	fp, r4, lsl #5
    f664:	eb0a 1444 	add.w	r4, sl, r4, lsl #5
	atomic_enter_critical(&flags);
    f668:	a802      	add	r0, sp, #8
    f66a:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    f66c:	78a3      	ldrb	r3, [r4, #2]
    f66e:	f88d 3007 	strb.w	r3, [sp, #7]
	if (state == USB_EP_S_IDLE) {
    f672:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f676:	2b01      	cmp	r3, #1
    f678:	fa5f f983 	uxtb.w	r9, r3
    f67c:	4b26      	ldr	r3, [pc, #152]	; (f718 <usb_d_ep_transfer+0xd8>)
    f67e:	d11a      	bne.n	f6b6 <usb_d_ep_transfer+0x76>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    f680:	2203      	movs	r2, #3
    f682:	70a2      	strb	r2, [r4, #2]
		atomic_leave_critical(&flags);
    f684:	a802      	add	r0, sp, #8
    f686:	4798      	blx	r3
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f688:	f81a 300b 	ldrb.w	r3, [sl, fp]
    f68c:	b1fb      	cbz	r3, f6ce <usb_d_ep_transfer+0x8e>
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f68e:	1e3b      	subs	r3, r7, #0
    f690:	ea4f 12d8 	mov.w	r2, r8, lsr #7
    f694:	bf18      	it	ne
    f696:	2301      	movne	r3, #1
	struct usb_d_transfer trans
    f698:	6828      	ldr	r0, [r5, #0]
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    f69a:	7a29      	ldrb	r1, [r5, #8]
	struct usb_d_transfer trans
    f69c:	e9cd 0603 	strd	r0, r6, [sp, #12]
    f6a0:	b372      	cbz	r2, f700 <usb_d_ep_transfer+0xc0>
    f6a2:	f041 0280 	orr.w	r2, r1, #128	; 0x80
    f6a6:	f88d 3015 	strb.w	r3, [sp, #21]
	return _usb_d_dev_ep_trans(&trans);
    f6aa:	a803      	add	r0, sp, #12
    f6ac:	4b1b      	ldr	r3, [pc, #108]	; (f71c <usb_d_ep_transfer+0xdc>)
	struct usb_d_transfer trans
    f6ae:	f88d 2014 	strb.w	r2, [sp, #20]
	return _usb_d_dev_ep_trans(&trans);
    f6b2:	4798      	blx	r3
	return rc;
    f6b4:	e008      	b.n	f6c8 <usb_d_ep_transfer+0x88>
		atomic_leave_critical(&flags);
    f6b6:	a802      	add	r0, sp, #8
    f6b8:	4798      	blx	r3
		switch (state) {
    f6ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f6be:	2b06      	cmp	r3, #6
    f6c0:	b2da      	uxtb	r2, r3
    f6c2:	d823      	bhi.n	f70c <usb_d_ep_transfer+0xcc>
    f6c4:	4b16      	ldr	r3, [pc, #88]	; (f720 <usb_d_ep_transfer+0xe0>)
    f6c6:	5698      	ldrsb	r0, [r3, r2]
}
    f6c8:	b007      	add	sp, #28
    f6ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    f6ce:	7ce1      	ldrb	r1, [r4, #19]
    f6d0:	7ca2      	ldrb	r2, [r4, #18]
    f6d2:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    f6d6:	b292      	uxth	r2, r2
		if (req_len == 0) {
    f6d8:	b92a      	cbnz	r2, f6e6 <usb_d_ep_transfer+0xa6>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f6da:	2304      	movs	r3, #4
    f6dc:	70a3      	strb	r3, [r4, #2]
			len                 = 0;
    f6de:	4616      	mov	r6, r2
			zlp                 = true;
    f6e0:	464b      	mov	r3, r9
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    f6e2:	461a      	mov	r2, r3
    f6e4:	e7d8      	b.n	f698 <usb_d_ep_transfer+0x58>
			if (dir) {
    f6e6:	f994 100c 	ldrsb.w	r1, [r4, #12]
    f6ea:	4296      	cmp	r6, r2
    f6ec:	bf28      	it	cs
    f6ee:	4616      	movcs	r6, r2
    f6f0:	2900      	cmp	r1, #0
    f6f2:	daf6      	bge.n	f6e2 <usb_d_ep_transfer+0xa2>
				zlp = (req_len > len);
    f6f4:	42b2      	cmp	r2, r6
    f6f6:	bf94      	ite	ls
    f6f8:	2300      	movls	r3, #0
    f6fa:	2301      	movhi	r3, #1
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    f6fc:	464a      	mov	r2, r9
    f6fe:	e7cb      	b.n	f698 <usb_d_ep_transfer+0x58>
	struct usb_d_transfer trans
    f700:	f001 020f 	and.w	r2, r1, #15
    f704:	e7cf      	b.n	f6a6 <usb_d_ep_transfer+0x66>
		return -USB_ERR_PARAM;
    f706:	f06f 0011 	mvn.w	r0, #17
    f70a:	e7dd      	b.n	f6c8 <usb_d_ep_transfer+0x88>
		switch (state) {
    f70c:	2001      	movs	r0, #1
    f70e:	e7db      	b.n	f6c8 <usb_d_ep_transfer+0x88>
    f710:	0000f30d 	.word	0x0000f30d
    f714:	00011b59 	.word	0x00011b59
    f718:	00011b67 	.word	0x00011b67
    f71c:	0000d82d 	.word	0x0000d82d
    f720:	0001750a 	.word	0x0001750a
    f724:	20008b60 	.word	0x20008b60

0000f728 <usb_d_ep_get_status>:
	ept->xfer.hdr.state  = USB_EP_S_IDLE;
	ept->xfer.hdr.status = USB_XFER_ABORT;
}

int32_t usb_d_ep_get_status(const uint8_t ep, struct usb_d_ep_status *stat)
{
    f728:	b5f0      	push	{r4, r5, r6, r7, lr}
	int8_t                    ep_index = _usb_d_find_ep(ep);
    f72a:	4b12      	ldr	r3, [pc, #72]	; (f774 <usb_d_ep_get_status+0x4c>)
	struct usb_d_ep *         ept      = &usb_d_inst.ep[ep_index];
	struct usb_d_trans_status tmp;
	uint8_t                   state = ept->xfer.hdr.state;
    f72c:	4d12      	ldr	r5, [pc, #72]	; (f778 <usb_d_ep_get_status+0x50>)
{
    f72e:	b085      	sub	sp, #20
    f730:	4606      	mov	r6, r0
    f732:	460c      	mov	r4, r1
	int8_t                    ep_index = _usb_d_find_ep(ep);
    f734:	4798      	blx	r3
	uint8_t                   state = ept->xfer.hdr.state;
    f736:	eb05 1540 	add.w	r5, r5, r0, lsl #5
	if (ep_index < 0) {
    f73a:	2800      	cmp	r0, #0
	uint8_t                   state = ept->xfer.hdr.state;
    f73c:	78af      	ldrb	r7, [r5, #2]
	if (ep_index < 0) {
    f73e:	db14      	blt.n	f76a <usb_d_ep_get_status+0x42>
		return -USB_ERR_PARAM;
	}
	if (stat) {
    f740:	b15c      	cbz	r4, f75a <usb_d_ep_get_status+0x32>
		/* Check transaction status if transferring data. */
		_usb_d_dev_ep_get_status(ep, &tmp);
    f742:	4b0e      	ldr	r3, [pc, #56]	; (f77c <usb_d_ep_get_status+0x54>)
    f744:	a901      	add	r1, sp, #4
    f746:	4630      	mov	r0, r6
    f748:	4798      	blx	r3
		stat->ep    = ep;
    f74a:	7026      	strb	r6, [r4, #0]
		stat->state = state;
    f74c:	70e7      	strb	r7, [r4, #3]
		stat->code  = ept->xfer.hdr.status;
    f74e:	78eb      	ldrb	r3, [r5, #3]
    f750:	7063      	strb	r3, [r4, #1]
		stat->count = tmp.count;
    f752:	9b02      	ldr	r3, [sp, #8]
    f754:	6063      	str	r3, [r4, #4]
		stat->size  = tmp.size;
    f756:	9b01      	ldr	r3, [sp, #4]
    f758:	60a3      	str	r3, [r4, #8]
	}
	switch (state) {
    f75a:	2f06      	cmp	r7, #6
    f75c:	d808      	bhi.n	f770 <usb_d_ep_get_status+0x48>
    f75e:	4b08      	ldr	r3, [pc, #32]	; (f780 <usb_d_ep_get_status+0x58>)
    f760:	443b      	add	r3, r7
    f762:	f993 0007 	ldrsb.w	r0, [r3, #7]
		return -USB_ERR_FUNC;
	default:
		/* Busy */
		return USB_BUSY;
	}
}
    f766:	b005      	add	sp, #20
    f768:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -USB_ERR_PARAM;
    f76a:	f06f 0011 	mvn.w	r0, #17
    f76e:	e7fa      	b.n	f766 <usb_d_ep_get_status+0x3e>
    f770:	2001      	movs	r0, #1
    f772:	e7f8      	b.n	f766 <usb_d_ep_get_status+0x3e>
    f774:	0000f30d 	.word	0x0000f30d
    f778:	20008b60 	.word	0x20008b60
    f77c:	0000d935 	.word	0x0000d935
    f780:	0001750a 	.word	0x0001750a

0000f784 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    f784:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f788:	4605      	mov	r5, r0
	if (ctrl == USB_EP_HALT_CLR) {
    f78a:	460c      	mov	r4, r1
    f78c:	b9d9      	cbnz	r1, f7c6 <usb_d_ep_halt+0x42>
	int8_t           ep_index = _usb_d_find_ep(ep);
    f78e:	4b13      	ldr	r3, [pc, #76]	; (f7dc <usb_d_ep_halt+0x58>)
    f790:	4798      	blx	r3
	if (ep_index < 0) {
    f792:	1e06      	subs	r6, r0, #0
    f794:	db1e      	blt.n	f7d4 <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    f796:	4f12      	ldr	r7, [pc, #72]	; (f7e0 <usb_d_ep_halt+0x5c>)
    f798:	2102      	movs	r1, #2
    f79a:	4628      	mov	r0, r5
    f79c:	47b8      	blx	r7
    f79e:	b180      	cbz	r0, f7c2 <usb_d_ep_halt+0x3e>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f7a0:	4621      	mov	r1, r4
    f7a2:	4628      	mov	r0, r5
    f7a4:	47b8      	blx	r7
		if (rc < 0) {
    f7a6:	2800      	cmp	r0, #0
    f7a8:	db0b      	blt.n	f7c2 <usb_d_ep_halt+0x3e>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    f7aa:	480e      	ldr	r0, [pc, #56]	; (f7e4 <usb_d_ep_halt+0x60>)
    f7ac:	eb00 1046 	add.w	r0, r0, r6, lsl #5
    f7b0:	f240 3301 	movw	r3, #769	; 0x301
    f7b4:	8043      	strh	r3, [r0, #2]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    f7b6:	4622      	mov	r2, r4
    f7b8:	69c3      	ldr	r3, [r0, #28]
    f7ba:	2103      	movs	r1, #3
    f7bc:	4628      	mov	r0, r5
    f7be:	4798      	blx	r3
	return ERR_NONE;
    f7c0:	4620      	mov	r0, r4
	} else if (ctrl == USB_EP_HALT_SET) {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
	}
}
    f7c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ctrl == USB_EP_HALT_SET) {
    f7c6:	2901      	cmp	r1, #1
}
    f7c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f7cc:	4b04      	ldr	r3, [pc, #16]	; (f7e0 <usb_d_ep_halt+0x5c>)
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    f7ce:	bf18      	it	ne
    f7d0:	2102      	movne	r1, #2
    f7d2:	4718      	bx	r3
		return -USB_ERR_PARAM;
    f7d4:	f06f 0011 	mvn.w	r0, #17
    f7d8:	e7f3      	b.n	f7c2 <usb_d_ep_halt+0x3e>
    f7da:	bf00      	nop
    f7dc:	0000f30d 	.word	0x0000f30d
    f7e0:	0000d70d 	.word	0x0000d70d
    f7e4:	20008b60 	.word	0x20008b60

0000f7e8 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    f7e8:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f7ea:	4b0f      	ldr	r3, [pc, #60]	; (f828 <usb_d_ep_register_callback+0x40>)
{
    f7ec:	4614      	mov	r4, r2
    f7ee:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    f7f0:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    f7f2:	4b0e      	ldr	r3, [pc, #56]	; (f82c <usb_d_ep_register_callback+0x44>)
    f7f4:	2c00      	cmp	r4, #0
    f7f6:	bf08      	it	eq
    f7f8:	461c      	moveq	r4, r3
	if (ep_index < 0) {
    f7fa:	2800      	cmp	r0, #0
    f7fc:	db08      	blt.n	f810 <usb_d_ep_register_callback+0x28>
		return;
	}
	switch (type) {
    f7fe:	2d01      	cmp	r5, #1
    f800:	d007      	beq.n	f812 <usb_d_ep_register_callback+0x2a>
    f802:	2d02      	cmp	r5, #2
    f804:	d00a      	beq.n	f81c <usb_d_ep_register_callback+0x34>
    f806:	b91d      	cbnz	r5, f810 <usb_d_ep_register_callback+0x28>
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    f808:	4b09      	ldr	r3, [pc, #36]	; (f830 <usb_d_ep_register_callback+0x48>)
    f80a:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f80e:	6144      	str	r4, [r0, #20]
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
    f810:	bd38      	pop	{r3, r4, r5, pc}
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    f812:	4b07      	ldr	r3, [pc, #28]	; (f830 <usb_d_ep_register_callback+0x48>)
    f814:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f818:	6184      	str	r4, [r0, #24]
		break;
    f81a:	e7f9      	b.n	f810 <usb_d_ep_register_callback+0x28>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    f81c:	4b04      	ldr	r3, [pc, #16]	; (f830 <usb_d_ep_register_callback+0x48>)
    f81e:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f822:	61c4      	str	r4, [r0, #28]
		break;
    f824:	e7f4      	b.n	f810 <usb_d_ep_register_callback+0x28>
    f826:	bf00      	nop
    f828:	0000f30d 	.word	0x0000f30d
    f82c:	0000f33d 	.word	0x0000f33d
    f830:	20008b60 	.word	0x20008b60

0000f834 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    f834:	6800      	ldr	r0, [r0, #0]
    f836:	b900      	cbnz	r0, f83a <is_list_element+0x6>
    f838:	4770      	bx	lr
		if (it == element) {
    f83a:	4288      	cmp	r0, r1
    f83c:	d1fa      	bne.n	f834 <is_list_element>
			return true;
    f83e:	2001      	movs	r0, #1
		}
	}

	return false;
}
    f840:	4770      	bx	lr
	...

0000f844 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    f844:	b538      	push	{r3, r4, r5, lr}
	ASSERT(!is_list_element(list, element));
    f846:	4b07      	ldr	r3, [pc, #28]	; (f864 <list_insert_as_head+0x20>)
{
    f848:	460d      	mov	r5, r1
    f84a:	4604      	mov	r4, r0
	ASSERT(!is_list_element(list, element));
    f84c:	4798      	blx	r3
    f84e:	f080 0001 	eor.w	r0, r0, #1
    f852:	4b05      	ldr	r3, [pc, #20]	; (f868 <list_insert_as_head+0x24>)
    f854:	4905      	ldr	r1, [pc, #20]	; (f86c <list_insert_as_head+0x28>)
    f856:	2239      	movs	r2, #57	; 0x39
    f858:	b2c0      	uxtb	r0, r0
    f85a:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    f85c:	6823      	ldr	r3, [r4, #0]
    f85e:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    f860:	6025      	str	r5, [r4, #0]
}
    f862:	bd38      	pop	{r3, r4, r5, pc}
    f864:	0000f835 	.word	0x0000f835
    f868:	0000e08d 	.word	0x0000e08d
    f86c:	00017518 	.word	0x00017518

0000f870 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    f870:	6803      	ldr	r3, [r0, #0]
    f872:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    f874:	6001      	str	r1, [r0, #0]
}
    f876:	4770      	bx	lr

0000f878 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    f878:	b570      	push	{r4, r5, r6, lr}
	struct list_element *it = list->head;

	ASSERT(!is_list_element(list, element));
    f87a:	4b0c      	ldr	r3, [pc, #48]	; (f8ac <list_insert_at_end+0x34>)
	struct list_element *it = list->head;
    f87c:	6805      	ldr	r5, [r0, #0]
{
    f87e:	4606      	mov	r6, r0
    f880:	460c      	mov	r4, r1
	ASSERT(!is_list_element(list, element));
    f882:	4798      	blx	r3
    f884:	f080 0001 	eor.w	r0, r0, #1
    f888:	4b09      	ldr	r3, [pc, #36]	; (f8b0 <list_insert_at_end+0x38>)
    f88a:	490a      	ldr	r1, [pc, #40]	; (f8b4 <list_insert_at_end+0x3c>)
    f88c:	224f      	movs	r2, #79	; 0x4f
    f88e:	b2c0      	uxtb	r0, r0
    f890:	4798      	blx	r3

	if (!list->head) {
    f892:	6833      	ldr	r3, [r6, #0]
    f894:	b913      	cbnz	r3, f89c <list_insert_at_end+0x24>
		list->head                             = (struct list_element *)element;
    f896:	6034      	str	r4, [r6, #0]
		((struct list_element *)element)->next = NULL;
    f898:	6023      	str	r3, [r4, #0]
	while (it->next) {
		it = it->next;
	}
	it->next                               = (struct list_element *)element;
	((struct list_element *)element)->next = NULL;
}
    f89a:	bd70      	pop	{r4, r5, r6, pc}
	while (it->next) {
    f89c:	462b      	mov	r3, r5
    f89e:	682d      	ldr	r5, [r5, #0]
    f8a0:	2d00      	cmp	r5, #0
    f8a2:	d1fb      	bne.n	f89c <list_insert_at_end+0x24>
	it->next                               = (struct list_element *)element;
    f8a4:	601c      	str	r4, [r3, #0]
	((struct list_element *)element)->next = NULL;
    f8a6:	6025      	str	r5, [r4, #0]
    f8a8:	e7f7      	b.n	f89a <list_insert_at_end+0x22>
    f8aa:	bf00      	nop
    f8ac:	0000f835 	.word	0x0000f835
    f8b0:	0000e08d 	.word	0x0000e08d
    f8b4:	00017518 	.word	0x00017518

0000f8b8 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    f8b8:	6803      	ldr	r3, [r0, #0]
    f8ba:	b10b      	cbz	r3, f8c0 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    f8bc:	681a      	ldr	r2, [r3, #0]
    f8be:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    f8c0:	4618      	mov	r0, r3
    f8c2:	4770      	bx	lr

0000f8c4 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    f8c4:	4b03      	ldr	r3, [pc, #12]	; (f8d4 <_osc32kctrl_init_sources+0x10>)
    f8c6:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    f8c8:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    f8cc:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    f8ce:	2201      	movs	r2, #1
    f8d0:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    f8d2:	4770      	bx	lr
    f8d4:	40001400 	.word	0x40001400

0000f8d8 <hri_rtcmode0_wait_for_sync>:
typedef uint8_t  hri_rtcalarm_mask_reg_t;
typedef uint8_t  hri_rtcmode2_mask_reg_t;

static inline void hri_rtcmode0_wait_for_sync(const void *const hw, hri_rtcmode0_syncbusy_reg_t reg)
{
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    f8d8:	6903      	ldr	r3, [r0, #16]
    f8da:	420b      	tst	r3, r1
    f8dc:	d1fc      	bne.n	f8d8 <hri_rtcmode0_wait_for_sync>
	};
}
    f8de:	4770      	bx	lr

0000f8e0 <_rtc_timer_set_period>:
/**
 * \brief Set timer period
 */
void _rtc_timer_set_period(struct _timer_device *const dev, const uint32_t clock_cycles)
{
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, clock_cycles);
    f8e0:	68c0      	ldr	r0, [r0, #12]

static inline void hri_rtcmode0_write_COMP_reg(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f8e2:	4b02      	ldr	r3, [pc, #8]	; (f8ec <_rtc_timer_set_period+0xc>)
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    f8e4:	6201      	str	r1, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f8e6:	2160      	movs	r1, #96	; 0x60
    f8e8:	4718      	bx	r3
    f8ea:	bf00      	nop
    f8ec:	0000f8d9 	.word	0x0000f8d9

0000f8f0 <_rtc_timer_get_period>:

/**
 * \brief Retrieve timer period
 */
uint32_t _rtc_timer_get_period(const struct _timer_device *const dev)
{
    f8f0:	b508      	push	{r3, lr}
	return hri_rtcmode0_read_COMP_reg(dev->hw, 0);
    f8f2:	68c0      	ldr	r0, [r0, #12]
	RTC_CRITICAL_SECTION_LEAVE();
}

static inline hri_rtcmode0_comp_reg_t hri_rtcmode0_read_COMP_reg(const void *const hw, uint8_t index)
{
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f8f4:	4b02      	ldr	r3, [pc, #8]	; (f900 <_rtc_timer_get_period+0x10>)
    f8f6:	2160      	movs	r1, #96	; 0x60
    f8f8:	4798      	blx	r3
	return ((Rtc *)hw)->MODE0.COMP[index].reg;
    f8fa:	6a00      	ldr	r0, [r0, #32]
}
    f8fc:	bd08      	pop	{r3, pc}
    f8fe:	bf00      	nop
    f900:	0000f8d9 	.word	0x0000f8d9

0000f904 <_rtc_timer_is_started>:

/**
 * \brief Check if timer is running
 */
bool _rtc_timer_is_started(const struct _timer_device *const dev)
{
    f904:	b508      	push	{r3, lr}
	return hri_rtcmode0_get_CTRLA_ENABLE_bit(dev->hw);
    f906:	68c0      	ldr	r0, [r0, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f908:	4b03      	ldr	r3, [pc, #12]	; (f918 <_rtc_timer_is_started+0x14>)
    f90a:	f248 0103 	movw	r1, #32771	; 0x8003
    f90e:	4798      	blx	r3
	tmp = ((Rtc *)hw)->MODE0.CTRLA.reg;
    f910:	8800      	ldrh	r0, [r0, #0]
}
    f912:	f3c0 0040 	ubfx	r0, r0, #1, #1
    f916:	bd08      	pop	{r3, pc}
    f918:	0000f8d9 	.word	0x0000f8d9

0000f91c <_rtc_timer_set_irq>:
 * \brief Set timer IRQ
 */
void _rtc_timer_set_irq(struct _timer_device *const dev)
{
	(void)dev;
}
    f91c:	4770      	bx	lr
	...

0000f920 <_rtc_timer_stop>:
{
    f920:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f922:	4604      	mov	r4, r0
    f924:	b118      	cbz	r0, f92e <_rtc_timer_stop+0xe>
    f926:	68c0      	ldr	r0, [r0, #12]
    f928:	3800      	subs	r0, #0
    f92a:	bf18      	it	ne
    f92c:	2001      	movne	r0, #1
    f92e:	4908      	ldr	r1, [pc, #32]	; (f950 <_rtc_timer_stop+0x30>)
    f930:	4b08      	ldr	r3, [pc, #32]	; (f954 <_rtc_timer_stop+0x34>)
    f932:	226b      	movs	r2, #107	; 0x6b
    f934:	4798      	blx	r3
	hri_rtcmode0_clear_CTRLA_ENABLE_bit(dev->hw);
    f936:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg &= ~RTC_MODE0_CTRLA_ENABLE;
    f938:	8803      	ldrh	r3, [r0, #0]
    f93a:	f023 0302 	bic.w	r3, r3, #2
    f93e:	041b      	lsls	r3, r3, #16
    f940:	0c1b      	lsrs	r3, r3, #16
    f942:	8003      	strh	r3, [r0, #0]
}
    f944:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f948:	4b03      	ldr	r3, [pc, #12]	; (f958 <_rtc_timer_stop+0x38>)
    f94a:	f248 0103 	movw	r1, #32771	; 0x8003
    f94e:	4718      	bx	r3
    f950:	00017536 	.word	0x00017536
    f954:	0000e08d 	.word	0x0000e08d
    f958:	0000f8d9 	.word	0x0000f8d9

0000f95c <_rtc_timer_start>:
{
    f95c:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f95e:	4604      	mov	r4, r0
    f960:	b118      	cbz	r0, f96a <_rtc_timer_start+0xe>
    f962:	68c0      	ldr	r0, [r0, #12]
    f964:	3800      	subs	r0, #0
    f966:	bf18      	it	ne
    f968:	2001      	movne	r0, #1
    f96a:	490e      	ldr	r1, [pc, #56]	; (f9a4 <_rtc_timer_start+0x48>)
    f96c:	4b0e      	ldr	r3, [pc, #56]	; (f9a8 <_rtc_timer_start+0x4c>)
    f96e:	225e      	movs	r2, #94	; 0x5e
    f970:	4798      	blx	r3
    f972:	4b0e      	ldr	r3, [pc, #56]	; (f9ac <_rtc_timer_start+0x50>)
	hri_rtcmode0_write_COUNT_reg(dev->hw, 0);
    f974:	68e0      	ldr	r0, [r4, #12]
    f976:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f97a:	601a      	str	r2, [r3, #0]
	((Rtc *)hw)->MODE0.COUNT.reg = data;
    f97c:	2300      	movs	r3, #0
    f97e:	6183      	str	r3, [r0, #24]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COUNT);
    f980:	4a0b      	ldr	r2, [pc, #44]	; (f9b0 <_rtc_timer_start+0x54>)
    f982:	2108      	movs	r1, #8
    f984:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_COUNT);
    f986:	68e0      	ldr	r0, [r4, #12]
    f988:	2108      	movs	r1, #8
    f98a:	4790      	blx	r2
	hri_rtcmode0_set_CTRLA_ENABLE_bit(dev->hw);
    f98c:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
    f98e:	8803      	ldrh	r3, [r0, #0]
    f990:	b29b      	uxth	r3, r3
    f992:	f043 0302 	orr.w	r3, r3, #2
}
    f996:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f99a:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f99c:	f248 0103 	movw	r1, #32771	; 0x8003
    f9a0:	4710      	bx	r2
    f9a2:	bf00      	nop
    f9a4:	00017536 	.word	0x00017536
    f9a8:	0000e08d 	.word	0x0000e08d
    f9ac:	e000e100 	.word	0xe000e100
    f9b0:	0000f8d9 	.word	0x0000f8d9

0000f9b4 <_rtc_timer_deinit>:
{
    f9b4:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f9b6:	4604      	mov	r4, r0
    f9b8:	b118      	cbz	r0, f9c2 <_rtc_timer_deinit+0xe>
    f9ba:	68c0      	ldr	r0, [r0, #12]
    f9bc:	3800      	subs	r0, #0
    f9be:	bf18      	it	ne
    f9c0:	2001      	movne	r0, #1
    f9c2:	490b      	ldr	r1, [pc, #44]	; (f9f0 <_rtc_timer_deinit+0x3c>)
    f9c4:	4b0b      	ldr	r3, [pc, #44]	; (f9f4 <_rtc_timer_deinit+0x40>)
    f9c6:	2252      	movs	r2, #82	; 0x52
    f9c8:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    f9ca:	4b0b      	ldr	r3, [pc, #44]	; (f9f8 <_rtc_timer_deinit+0x44>)
    f9cc:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f9d0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    f9d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    f9d8:	f3bf 8f6f 	isb	sy
	hri_rtcmode0_write_CTRLA_reg(dev->hw, RTC_MODE0_CTRLA_SWRST);
    f9dc:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f9de:	2301      	movs	r3, #1
    f9e0:	8003      	strh	r3, [r0, #0]
}
    f9e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f9e6:	4b05      	ldr	r3, [pc, #20]	; (f9fc <_rtc_timer_deinit+0x48>)
    f9e8:	f248 0103 	movw	r1, #32771	; 0x8003
    f9ec:	4718      	bx	r3
    f9ee:	bf00      	nop
    f9f0:	00017536 	.word	0x00017536
    f9f4:	0000e08d 	.word	0x0000e08d
    f9f8:	e000e100 	.word	0xe000e100
    f9fc:	0000f8d9 	.word	0x0000f8d9

0000fa00 <_rtc_timer_init>:
{
    fa00:	b570      	push	{r4, r5, r6, lr}
	ASSERT(dev);
    fa02:	4604      	mov	r4, r0
{
    fa04:	460d      	mov	r5, r1
	ASSERT(dev);
    fa06:	3800      	subs	r0, #0
    fa08:	bf18      	it	ne
    fa0a:	2001      	movne	r0, #1
    fa0c:	4b10      	ldr	r3, [pc, #64]	; (fa50 <_rtc_timer_init+0x50>)
    fa0e:	4911      	ldr	r1, [pc, #68]	; (fa54 <_rtc_timer_init+0x54>)
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fa10:	2601      	movs	r6, #1
    fa12:	2230      	movs	r2, #48	; 0x30
    fa14:	4798      	blx	r3
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fa16:	4a10      	ldr	r2, [pc, #64]	; (fa58 <_rtc_timer_init+0x58>)
	dev->hw = hw;
    fa18:	60e5      	str	r5, [r4, #12]
    fa1a:	4628      	mov	r0, r5
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fa1c:	802e      	strh	r6, [r5, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fa1e:	f248 0103 	movw	r1, #32771	; 0x8003
    fa22:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
    fa24:	68e0      	ldr	r0, [r4, #12]
    fa26:	4631      	mov	r1, r6
    fa28:	4790      	blx	r2
	    dev->hw, RTC_MODE0_CTRLA_PRESCALER(CONF_RTC_PRESCALER) | RTC_MODE0_CTRLA_COUNTSYNC | RTC_MODE0_CTRLA_MATCHCLR);
    fa2a:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fa2c:	f248 0380 	movw	r3, #32896	; 0x8080
    fa30:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fa32:	f248 0103 	movw	r1, #32771	; 0x8003
    fa36:	4790      	blx	r2
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, CONF_RTC_COMP_VAL);
    fa38:	68e0      	ldr	r0, [r4, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fa3a:	2160      	movs	r1, #96	; 0x60
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    fa3c:	6206      	str	r6, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fa3e:	4790      	blx	r2
	hri_rtcmode0_set_INTEN_CMP0_bit(dev->hw);
    fa40:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
    fa42:	f44f 7280 	mov.w	r2, #256	; 0x100
    fa46:	815a      	strh	r2, [r3, #10]
	_rtc_dev = dev;
    fa48:	4b04      	ldr	r3, [pc, #16]	; (fa5c <_rtc_timer_init+0x5c>)
}
    fa4a:	2000      	movs	r0, #0
	_rtc_dev = dev;
    fa4c:	601c      	str	r4, [r3, #0]
}
    fa4e:	bd70      	pop	{r4, r5, r6, pc}
    fa50:	0000e08d 	.word	0x0000e08d
    fa54:	00017536 	.word	0x00017536
    fa58:	0000f8d9 	.word	0x0000f8d9
    fa5c:	20008d00 	.word	0x20008d00

0000fa60 <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return &_rtc_timer_functions;
}
    fa60:	4800      	ldr	r0, [pc, #0]	; (fa64 <_rtc_get_timer+0x4>)
    fa62:	4770      	bx	lr
    fa64:	2000050c 	.word	0x2000050c

0000fa68 <RTC_Handler>:
/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
	_rtc_timer_interrupt_handler(_rtc_dev);
    fa68:	4b07      	ldr	r3, [pc, #28]	; (fa88 <RTC_Handler+0x20>)
{
    fa6a:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
    fa6c:	681c      	ldr	r4, [r3, #0]
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
    fa6e:	68e3      	ldr	r3, [r4, #12]
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    fa70:	899b      	ldrh	r3, [r3, #12]
	if (flag & RTC_MODE0_INTFLAG_CMP0) {
    fa72:	05db      	lsls	r3, r3, #23
    fa74:	d507      	bpl.n	fa86 <RTC_Handler+0x1e>
		if (dev->timer_cb.period_expired) {
    fa76:	6823      	ldr	r3, [r4, #0]
    fa78:	b10b      	cbz	r3, fa7e <RTC_Handler+0x16>
			dev->timer_cb.period_expired(dev);
    fa7a:	4620      	mov	r0, r4
    fa7c:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    fa7e:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    fa80:	f44f 7280 	mov.w	r2, #256	; 0x100
    fa84:	819a      	strh	r2, [r3, #12]
}
    fa86:	bd10      	pop	{r4, pc}
    fa88:	20008d00 	.word	0x20008d00

0000fa8c <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    fa8c:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    fa8e:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    fa90:	b2c5      	uxtb	r5, r0
    fa92:	4b18      	ldr	r3, [pc, #96]	; (faf4 <_gpio_set_pin_function+0x68>)
    fa94:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    fa98:	ea4f 1050 	mov.w	r0, r0, lsr #5
    fa9c:	ea4f 10c0 	mov.w	r0, r0, lsl #7
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    faa0:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    faa2:	d107      	bne.n	fab4 <_gpio_set_pin_function+0x28>
    faa4:	4423      	add	r3, r4
    faa6:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    faaa:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    faae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    fab2:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    fab4:	1918      	adds	r0, r3, r4
    fab6:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    faba:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    fabe:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    fac2:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    fac6:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    faca:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    face:	f015 0f01 	tst.w	r5, #1
    fad2:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    fad4:	bf19      	ittee	ne
    fad6:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    fada:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    fade:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    fae2:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    fae6:	bf14      	ite	ne
    fae8:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    faea:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    faec:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    faf0:	e7df      	b.n	fab2 <_gpio_set_pin_function+0x26>
    faf2:	bf00      	nop
    faf4:	41008000 	.word	0x41008000

0000faf8 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    faf8:	f000 031f 	and.w	r3, r0, #31
{
    fafc:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    fafe:	2501      	movs	r5, #1
    fb00:	409d      	lsls	r5, r3
	switch (direction) {
    fb02:	0940      	lsrs	r0, r0, #5
    fb04:	4b0f      	ldr	r3, [pc, #60]	; (fb44 <gpio_set_pin_direction+0x4c>)
    fb06:	01c0      	lsls	r0, r0, #7
    fb08:	2901      	cmp	r1, #1
    fb0a:	b2ac      	uxth	r4, r5
    fb0c:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fb10:	4403      	add	r3, r0
    fb12:	d008      	beq.n	fb26 <gpio_set_pin_direction+0x2e>
    fb14:	2902      	cmp	r1, #2
    fb16:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    fb1a:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    fb1e:	d00e      	beq.n	fb3e <gpio_set_pin_direction+0x46>
    fb20:	605d      	str	r5, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    fb22:	629c      	str	r4, [r3, #40]	; 0x28
    fb24:	e009      	b.n	fb3a <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    fb26:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    fb2a:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
    fb2e:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fb32:	605d      	str	r5, [r3, #4]
    fb34:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    fb38:	629c      	str	r4, [r3, #40]	; 0x28
    fb3a:	629a      	str	r2, [r3, #40]	; 0x28
}
    fb3c:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    fb3e:	609d      	str	r5, [r3, #8]
    fb40:	e7ef      	b.n	fb22 <gpio_set_pin_direction+0x2a>
    fb42:	bf00      	nop
    fb44:	41008000 	.word	0x41008000

0000fb48 <gpio_set_pin_pull_mode>:
	switch (pull_mode) {
    fb48:	0942      	lsrs	r2, r0, #5
    fb4a:	2901      	cmp	r1, #1
    fb4c:	4b0d      	ldr	r3, [pc, #52]	; (fb84 <gpio_set_pin_pull_mode+0x3c>)
    fb4e:	f000 001f 	and.w	r0, r0, #31
    fb52:	ea4f 12c2 	mov.w	r2, r2, lsl #7
    fb56:	d008      	beq.n	fb6a <gpio_set_pin_pull_mode+0x22>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    fb58:	4413      	add	r3, r2
    fb5a:	4418      	add	r0, r3
    fb5c:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    fb60:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    fb64:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
}
    fb68:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fb6a:	4413      	add	r3, r2
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    fb6c:	4081      	lsls	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    fb6e:	4418      	add	r0, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fb70:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    fb72:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
    fb76:	f042 0204 	orr.w	r2, r2, #4
    fb7a:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    fb7e:	6199      	str	r1, [r3, #24]
}
    fb80:	4770      	bx	lr
    fb82:	bf00      	nop
    fb84:	41008000 	.word	0x41008000

0000fb88 <ADC_0_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
    fb88:	4a14      	ldr	r2, [pc, #80]	; (fbdc <ADC_0_init+0x54>)
 */
void ADC_0_init(void)
{
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fb8a:	4915      	ldr	r1, [pc, #84]	; (fbe0 <ADC_0_init+0x58>)
    fb8c:	6a13      	ldr	r3, [r2, #32]
{
    fb8e:	b5f0      	push	{r4, r5, r6, r7, lr}
    fb90:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fb94:	6213      	str	r3, [r2, #32]
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    fb96:	4b13      	ldr	r3, [pc, #76]	; (fbe4 <ADC_0_init+0x5c>)
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fb98:	4e13      	ldr	r6, [pc, #76]	; (fbe8 <ADC_0_init+0x60>)
    fb9a:	4d14      	ldr	r5, [pc, #80]	; (fbec <ADC_0_init+0x64>)
    fb9c:	4f14      	ldr	r7, [pc, #80]	; (fbf0 <ADC_0_init+0x68>)
{
    fb9e:	b085      	sub	sp, #20
    fba0:	2241      	movs	r2, #65	; 0x41
    fba2:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fba6:	4b13      	ldr	r3, [pc, #76]	; (fbf4 <ADC_0_init+0x6c>)
    fba8:	9301      	str	r3, [sp, #4]
    fbaa:	2400      	movs	r4, #0
    fbac:	2301      	movs	r3, #1
    fbae:	9300      	str	r3, [sp, #0]
    fbb0:	4632      	mov	r2, r6
    fbb2:	4623      	mov	r3, r4
    fbb4:	9402      	str	r4, [sp, #8]
    fbb6:	4628      	mov	r0, r5
    fbb8:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_0, 0, ADC_0_buffer, ADC_0_BUFFER_SIZE);
    fbba:	1c72      	adds	r2, r6, #1
    fbbc:	4621      	mov	r1, r4
    fbbe:	2310      	movs	r3, #16
    fbc0:	4628      	mov	r0, r5
    fbc2:	4d0d      	ldr	r5, [pc, #52]	; (fbf8 <ADC_0_init+0x70>)
    fbc4:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PA07, GPIO_DIRECTION_OFF);
    fbc6:	4621      	mov	r1, r4
    fbc8:	4b0c      	ldr	r3, [pc, #48]	; (fbfc <ADC_0_init+0x74>)
    fbca:	2007      	movs	r0, #7
    fbcc:	4798      	blx	r3
	_gpio_set_pin_function(pin, function);
    fbce:	490c      	ldr	r1, [pc, #48]	; (fc00 <ADC_0_init+0x78>)
    fbd0:	4b0c      	ldr	r3, [pc, #48]	; (fc04 <ADC_0_init+0x7c>)
    fbd2:	2007      	movs	r0, #7

	gpio_set_pin_function(PA07, PINMUX_PA07B_ADC0_AIN7);
}
    fbd4:	b005      	add	sp, #20
    fbd6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fbda:	4718      	bx	r3
    fbdc:	40000800 	.word	0x40000800
    fbe0:	43001c00 	.word	0x43001c00
    fbe4:	40001c00 	.word	0x40001c00
    fbe8:	20008d04 	.word	0x20008d04
    fbec:	2001cd84 	.word	0x2001cd84
    fbf0:	0000e385 	.word	0x0000e385
    fbf4:	2001ce80 	.word	0x2001ce80
    fbf8:	0000e429 	.word	0x0000e429
    fbfc:	0000faf9 	.word	0x0000faf9
    fc00:	00070001 	.word	0x00070001
    fc04:	0000fa8d 	.word	0x0000fa8d

0000fc08 <ADC_1_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
    fc08:	4a15      	ldr	r2, [pc, #84]	; (fc60 <ADC_1_init+0x58>)
 */
void ADC_1_init(void)
{
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fc0a:	4916      	ldr	r1, [pc, #88]	; (fc64 <ADC_1_init+0x5c>)
    fc0c:	6a13      	ldr	r3, [r2, #32]
{
    fc0e:	b5f0      	push	{r4, r5, r6, r7, lr}
    fc10:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    fc14:	6213      	str	r3, [r2, #32]
    fc16:	4b14      	ldr	r3, [pc, #80]	; (fc68 <ADC_1_init+0x60>)
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fc18:	4e14      	ldr	r6, [pc, #80]	; (fc6c <ADC_1_init+0x64>)
    fc1a:	4d15      	ldr	r5, [pc, #84]	; (fc70 <ADC_1_init+0x68>)
    fc1c:	4f15      	ldr	r7, [pc, #84]	; (fc74 <ADC_1_init+0x6c>)
{
    fc1e:	b085      	sub	sp, #20
    fc20:	2241      	movs	r2, #65	; 0x41
    fc22:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fc26:	4b14      	ldr	r3, [pc, #80]	; (fc78 <ADC_1_init+0x70>)
    fc28:	9301      	str	r3, [sp, #4]
    fc2a:	2400      	movs	r4, #0
    fc2c:	2301      	movs	r3, #1
    fc2e:	9300      	str	r3, [sp, #0]
    fc30:	f106 0211 	add.w	r2, r6, #17
    fc34:	4623      	mov	r3, r4
    fc36:	9402      	str	r4, [sp, #8]
    fc38:	4628      	mov	r0, r5
    fc3a:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_1, 0, ADC_1_buffer, ADC_1_BUFFER_SIZE);
    fc3c:	f106 0212 	add.w	r2, r6, #18
    fc40:	4621      	mov	r1, r4
    fc42:	2310      	movs	r3, #16
    fc44:	4628      	mov	r0, r5
    fc46:	4d0d      	ldr	r5, [pc, #52]	; (fc7c <ADC_1_init+0x74>)
    fc48:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PC02, GPIO_DIRECTION_OFF);
    fc4a:	4621      	mov	r1, r4
    fc4c:	4b0c      	ldr	r3, [pc, #48]	; (fc80 <ADC_1_init+0x78>)
    fc4e:	2042      	movs	r0, #66	; 0x42
    fc50:	4798      	blx	r3
    fc52:	490c      	ldr	r1, [pc, #48]	; (fc84 <ADC_1_init+0x7c>)
    fc54:	4b0c      	ldr	r3, [pc, #48]	; (fc88 <ADC_1_init+0x80>)
    fc56:	2042      	movs	r0, #66	; 0x42

	gpio_set_pin_function(PC02, PINMUX_PC02B_ADC1_AIN4);
}
    fc58:	b005      	add	sp, #20
    fc5a:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fc5e:	4718      	bx	r3
    fc60:	40000800 	.word	0x40000800
    fc64:	43002000 	.word	0x43002000
    fc68:	40001c00 	.word	0x40001c00
    fc6c:	20008d04 	.word	0x20008d04
    fc70:	2001cf58 	.word	0x2001cf58
    fc74:	0000e385 	.word	0x0000e385
    fc78:	2001cd18 	.word	0x2001cd18
    fc7c:	0000e429 	.word	0x0000e429
    fc80:	0000faf9 	.word	0x0000faf9
    fc84:	00420001 	.word	0x00420001
    fc88:	0000fa8d 	.word	0x0000fa8d

0000fc8c <CRC_0_init>:
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_DSU;
    fc8c:	4a04      	ldr	r2, [pc, #16]	; (fca0 <CRC_0_init+0x14>)
 * Enables CRC peripheral, clocks and initializes CRC driver
 */
void CRC_0_init(void)
{
	hri_mclk_set_APBBMASK_DSU_bit(MCLK);
	crc_sync_init(&CRC_0, DSU);
    fc8e:	4905      	ldr	r1, [pc, #20]	; (fca4 <CRC_0_init+0x18>)
    fc90:	6993      	ldr	r3, [r2, #24]
    fc92:	4805      	ldr	r0, [pc, #20]	; (fca8 <CRC_0_init+0x1c>)
    fc94:	f043 0302 	orr.w	r3, r3, #2
    fc98:	6193      	str	r3, [r2, #24]
    fc9a:	4b04      	ldr	r3, [pc, #16]	; (fcac <CRC_0_init+0x20>)
    fc9c:	4718      	bx	r3
    fc9e:	bf00      	nop
    fca0:	40000800 	.word	0x40000800
    fca4:	41002000 	.word	0x41002000
    fca8:	2001cd14 	.word	0x2001cd14
    fcac:	0000f2dd 	.word	0x0000f2dd

0000fcb0 <EVENT_SYSTEM_0_init>:
    fcb0:	4b08      	ldr	r3, [pc, #32]	; (fcd4 <EVENT_SYSTEM_0_init+0x24>)
    fcb2:	2240      	movs	r2, #64	; 0x40
    fcb4:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    fcb8:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    fcbc:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    fcc0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_EVSYS;
    fcc4:	4a04      	ldr	r2, [pc, #16]	; (fcd8 <EVENT_SYSTEM_0_init+0x28>)
    fcc6:	6993      	ldr	r3, [r2, #24]
    fcc8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fccc:	6193      	str	r3, [r2, #24]
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_2, CONF_GCLK_EVSYS_CHANNEL_2_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_3, CONF_GCLK_EVSYS_CHANNEL_3_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_EVSYS_bit(MCLK);

	event_system_init();
    fcce:	4b03      	ldr	r3, [pc, #12]	; (fcdc <EVENT_SYSTEM_0_init+0x2c>)
    fcd0:	4718      	bx	r3
    fcd2:	bf00      	nop
    fcd4:	40001c00 	.word	0x40001c00
    fcd8:	40000800 	.word	0x40000800
    fcdc:	00012d29 	.word	0x00012d29

0000fce0 <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
    fce0:	4a02      	ldr	r2, [pc, #8]	; (fcec <FLASH_0_CLOCK_init+0xc>)
    fce2:	6913      	ldr	r3, [r2, #16]
    fce4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    fce8:	6113      	str	r3, [r2, #16]

void FLASH_0_CLOCK_init(void)
{

	hri_mclk_set_AHBMASK_NVMCTRL_bit(MCLK);
}
    fcea:	4770      	bx	lr
    fcec:	40000800 	.word	0x40000800

0000fcf0 <FLASH_0_init>:

void FLASH_0_init(void)
{
    fcf0:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
    fcf2:	4b04      	ldr	r3, [pc, #16]	; (fd04 <FLASH_0_init+0x14>)
    fcf4:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
}
    fcf6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	flash_init(&FLASH_0, NVMCTRL);
    fcfa:	4903      	ldr	r1, [pc, #12]	; (fd08 <FLASH_0_init+0x18>)
    fcfc:	4803      	ldr	r0, [pc, #12]	; (fd0c <FLASH_0_init+0x1c>)
    fcfe:	4b04      	ldr	r3, [pc, #16]	; (fd10 <FLASH_0_init+0x20>)
    fd00:	4718      	bx	r3
    fd02:	bf00      	nop
    fd04:	0000fce1 	.word	0x0000fce1
    fd08:	41004000 	.word	0x41004000
    fd0c:	2001ccf8 	.word	0x2001ccf8
    fd10:	0000ed85 	.word	0x0000ed85

0000fd14 <QSPI_INSTANCE_PORT_init>:

void QSPI_INSTANCE_PORT_init(void)
{
    fd14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	// Set pin direction to input
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
    fd18:	2101      	movs	r1, #1
    fd1a:	4e24      	ldr	r6, [pc, #144]	; (fdac <QSPI_INSTANCE_PORT_init+0x98>)

	gpio_set_pin_pull_mode(PB11,
    fd1c:	4d24      	ldr	r5, [pc, #144]	; (fdb0 <QSPI_INSTANCE_PORT_init+0x9c>)
    fd1e:	4c25      	ldr	r4, [pc, #148]	; (fdb4 <QSPI_INSTANCE_PORT_init+0xa0>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    fd20:	4f25      	ldr	r7, [pc, #148]	; (fdb8 <QSPI_INSTANCE_PORT_init+0xa4>)
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
    fd22:	202b      	movs	r0, #43	; 0x2b
    fd24:	47b0      	blx	r6
	gpio_set_pin_pull_mode(PB11,
    fd26:	2100      	movs	r1, #0
    fd28:	202b      	movs	r0, #43	; 0x2b
    fd2a:	47a8      	blx	r5
    fd2c:	4923      	ldr	r1, [pc, #140]	; (fdbc <QSPI_INSTANCE_PORT_init+0xa8>)
    fd2e:	202b      	movs	r0, #43	; 0x2b
    fd30:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB11, PINMUX_PB11H_QSPI_CS);

	gpio_set_pin_direction(PA08,
    fd32:	2102      	movs	r1, #2
    fd34:	2008      	movs	r0, #8
    fd36:	47b0      	blx	r6
    fd38:	f44f 7380 	mov.w	r3, #256	; 0x100
    fd3c:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA08,
    fd3e:	2100      	movs	r1, #0
    fd40:	2008      	movs	r0, #8
    fd42:	47a8      	blx	r5
    fd44:	491e      	ldr	r1, [pc, #120]	; (fdc0 <QSPI_INSTANCE_PORT_init+0xac>)
    fd46:	2008      	movs	r0, #8
    fd48:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA08H_QSPI_DATA0);

	gpio_set_pin_direction(PA09,
    fd4a:	2102      	movs	r1, #2
    fd4c:	2009      	movs	r0, #9
    fd4e:	47b0      	blx	r6
    fd50:	f44f 7300 	mov.w	r3, #512	; 0x200
    fd54:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA09,
    fd56:	2100      	movs	r1, #0
    fd58:	2009      	movs	r0, #9
    fd5a:	47a8      	blx	r5
    fd5c:	4919      	ldr	r1, [pc, #100]	; (fdc4 <QSPI_INSTANCE_PORT_init+0xb0>)
    fd5e:	2009      	movs	r0, #9
    fd60:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA09H_QSPI_DATA1);

	gpio_set_pin_direction(PA10,
    fd62:	2102      	movs	r1, #2
    fd64:	200a      	movs	r0, #10
    fd66:	47b0      	blx	r6
    fd68:	f44f 6380 	mov.w	r3, #1024	; 0x400
    fd6c:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA10,
    fd6e:	2100      	movs	r1, #0
    fd70:	200a      	movs	r0, #10
    fd72:	47a8      	blx	r5
    fd74:	4914      	ldr	r1, [pc, #80]	; (fdc8 <QSPI_INSTANCE_PORT_init+0xb4>)
    fd76:	200a      	movs	r0, #10
    fd78:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA10H_QSPI_DATA2);

	gpio_set_pin_direction(PA11,
    fd7a:	2102      	movs	r1, #2
    fd7c:	200b      	movs	r0, #11
    fd7e:	47b0      	blx	r6
    fd80:	f44f 6300 	mov.w	r3, #2048	; 0x800
    fd84:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA11,
    fd86:	2100      	movs	r1, #0
    fd88:	200b      	movs	r0, #11
    fd8a:	47a8      	blx	r5
    fd8c:	490f      	ldr	r1, [pc, #60]	; (fdcc <QSPI_INSTANCE_PORT_init+0xb8>)
    fd8e:	200b      	movs	r0, #11
    fd90:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA11H_QSPI_DATA3);

	// Set pin direction to input
	gpio_set_pin_direction(PB10, GPIO_DIRECTION_IN);
    fd92:	2101      	movs	r1, #1
    fd94:	202a      	movs	r0, #42	; 0x2a
    fd96:	47b0      	blx	r6

	gpio_set_pin_pull_mode(PB10,
    fd98:	2100      	movs	r1, #0
    fd9a:	202a      	movs	r0, #42	; 0x2a
    fd9c:	47a8      	blx	r5
    fd9e:	4623      	mov	r3, r4
    fda0:	490b      	ldr	r1, [pc, #44]	; (fdd0 <QSPI_INSTANCE_PORT_init+0xbc>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB10, PINMUX_PB10H_QSPI_SCK);
}
    fda2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    fda6:	202a      	movs	r0, #42	; 0x2a
    fda8:	4718      	bx	r3
    fdaa:	bf00      	nop
    fdac:	0000faf9 	.word	0x0000faf9
    fdb0:	0000fb49 	.word	0x0000fb49
    fdb4:	0000fa8d 	.word	0x0000fa8d
    fdb8:	41008000 	.word	0x41008000
    fdbc:	002b0007 	.word	0x002b0007
    fdc0:	00080007 	.word	0x00080007
    fdc4:	00090007 	.word	0x00090007
    fdc8:	000a0007 	.word	0x000a0007
    fdcc:	000b0007 	.word	0x000b0007
    fdd0:	002a0007 	.word	0x002a0007

0000fdd4 <QSPI_INSTANCE_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI;
    fdd4:	4b06      	ldr	r3, [pc, #24]	; (fdf0 <QSPI_INSTANCE_CLOCK_init+0x1c>)
    fdd6:	691a      	ldr	r2, [r3, #16]
    fdd8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    fddc:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI_2X;
    fdde:	691a      	ldr	r2, [r3, #16]
    fde0:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
    fde4:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_QSPI;
    fde6:	69da      	ldr	r2, [r3, #28]
    fde8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    fdec:	61da      	str	r2, [r3, #28]
void QSPI_INSTANCE_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_QSPI_bit(MCLK);
	hri_mclk_set_AHBMASK_QSPI_2X_bit(MCLK);
	hri_mclk_set_APBCMASK_QSPI_bit(MCLK);
}
    fdee:	4770      	bx	lr
    fdf0:	40000800 	.word	0x40000800

0000fdf4 <QSPI_INSTANCE_init>:

void QSPI_INSTANCE_init(void)
{
    fdf4:	b510      	push	{r4, lr}
	QSPI_INSTANCE_CLOCK_init();
    fdf6:	4b05      	ldr	r3, [pc, #20]	; (fe0c <QSPI_INSTANCE_init+0x18>)
    fdf8:	4798      	blx	r3
	qspi_dma_init(&QSPI_INSTANCE, QSPI);
    fdfa:	4b05      	ldr	r3, [pc, #20]	; (fe10 <QSPI_INSTANCE_init+0x1c>)
    fdfc:	4905      	ldr	r1, [pc, #20]	; (fe14 <QSPI_INSTANCE_init+0x20>)
    fdfe:	4806      	ldr	r0, [pc, #24]	; (fe18 <QSPI_INSTANCE_init+0x24>)
    fe00:	4798      	blx	r3
	QSPI_INSTANCE_PORT_init();
}
    fe02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	QSPI_INSTANCE_PORT_init();
    fe06:	4b05      	ldr	r3, [pc, #20]	; (fe1c <QSPI_INSTANCE_init+0x28>)
    fe08:	4718      	bx	r3
    fe0a:	bf00      	nop
    fe0c:	0000fdd5 	.word	0x0000fdd5
    fe10:	00012495 	.word	0x00012495
    fe14:	42003400 	.word	0x42003400
    fe18:	2001cfc4 	.word	0x2001cfc4
    fe1c:	0000fd15 	.word	0x0000fd15

0000fe20 <USART_EAST_CLOCK_init>:
    fe20:	4b06      	ldr	r3, [pc, #24]	; (fe3c <USART_EAST_CLOCK_init+0x1c>)
    fe22:	2241      	movs	r2, #65	; 0x41
    fe24:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    fe28:	2242      	movs	r2, #66	; 0x42
    fe2a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
    fe2e:	4a04      	ldr	r2, [pc, #16]	; (fe40 <USART_EAST_CLOCK_init+0x20>)
    fe30:	6953      	ldr	r3, [r2, #20]
    fe32:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    fe36:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}
    fe38:	4770      	bx	lr
    fe3a:	bf00      	nop
    fe3c:	40001c00 	.word	0x40001c00
    fe40:	40000800 	.word	0x40000800

0000fe44 <USART_EAST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_EAST_PORT_init()
{
    fe44:	b510      	push	{r4, lr}
    fe46:	4c05      	ldr	r4, [pc, #20]	; (fe5c <USART_EAST_PORT_init+0x18>)
    fe48:	4905      	ldr	r1, [pc, #20]	; (fe60 <USART_EAST_PORT_init+0x1c>)
    fe4a:	2051      	movs	r0, #81	; 0x51
    fe4c:	47a0      	blx	r4
    fe4e:	4623      	mov	r3, r4
    fe50:	4904      	ldr	r1, [pc, #16]	; (fe64 <USART_EAST_PORT_init+0x20>)

	gpio_set_pin_function(PC17, PINMUX_PC17D_SERCOM0_PAD0);

	gpio_set_pin_function(PC16, PINMUX_PC16D_SERCOM0_PAD1);
}
    fe52:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fe56:	2050      	movs	r0, #80	; 0x50
    fe58:	4718      	bx	r3
    fe5a:	bf00      	nop
    fe5c:	0000fa8d 	.word	0x0000fa8d
    fe60:	00510003 	.word	0x00510003
    fe64:	00500003 	.word	0x00500003

0000fe68 <USART_EAST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_EAST_init(void)
{
    fe68:	b513      	push	{r0, r1, r4, lr}
	USART_EAST_CLOCK_init();
    fe6a:	4b07      	ldr	r3, [pc, #28]	; (fe88 <USART_EAST_init+0x20>)
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
    fe6c:	4c07      	ldr	r4, [pc, #28]	; (fe8c <USART_EAST_init+0x24>)
	USART_EAST_CLOCK_init();
    fe6e:	4798      	blx	r3
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
    fe70:	2300      	movs	r3, #0
    fe72:	9300      	str	r3, [sp, #0]
    fe74:	4a06      	ldr	r2, [pc, #24]	; (fe90 <USART_EAST_init+0x28>)
    fe76:	4907      	ldr	r1, [pc, #28]	; (fe94 <USART_EAST_init+0x2c>)
    fe78:	4807      	ldr	r0, [pc, #28]	; (fe98 <USART_EAST_init+0x30>)
    fe7a:	2310      	movs	r3, #16
    fe7c:	47a0      	blx	r4
	USART_EAST_PORT_init();
    fe7e:	4b07      	ldr	r3, [pc, #28]	; (fe9c <USART_EAST_init+0x34>)
}
    fe80:	b002      	add	sp, #8
    fe82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_EAST_PORT_init();
    fe86:	4718      	bx	r3
    fe88:	0000fe21 	.word	0x0000fe21
    fe8c:	0001077d 	.word	0x0001077d
    fe90:	20008d26 	.word	0x20008d26
    fe94:	40003000 	.word	0x40003000
    fe98:	2001cdb0 	.word	0x2001cdb0
    fe9c:	0000fe45 	.word	0x0000fe45

0000fea0 <USART_NORTH_CLOCK_init>:
    fea0:	4b06      	ldr	r3, [pc, #24]	; (febc <USART_NORTH_CLOCK_init+0x1c>)
    fea2:	2241      	movs	r2, #65	; 0x41
    fea4:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    fea8:	2242      	movs	r2, #66	; 0x42
    feaa:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
    feae:	4a04      	ldr	r2, [pc, #16]	; (fec0 <USART_NORTH_CLOCK_init+0x20>)
    feb0:	6953      	ldr	r3, [r2, #20]
    feb2:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    feb6:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}
    feb8:	4770      	bx	lr
    feba:	bf00      	nop
    febc:	40001c00 	.word	0x40001c00
    fec0:	40000800 	.word	0x40000800

0000fec4 <USART_NORTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_NORTH_PORT_init()
{
    fec4:	b510      	push	{r4, lr}
    fec6:	4c05      	ldr	r4, [pc, #20]	; (fedc <USART_NORTH_PORT_init+0x18>)
    fec8:	4905      	ldr	r1, [pc, #20]	; (fee0 <USART_NORTH_PORT_init+0x1c>)
    feca:	205b      	movs	r0, #91	; 0x5b
    fecc:	47a0      	blx	r4
    fece:	4623      	mov	r3, r4
    fed0:	4904      	ldr	r1, [pc, #16]	; (fee4 <USART_NORTH_PORT_init+0x20>)

	gpio_set_pin_function(PC27, PINMUX_PC27C_SERCOM1_PAD0);

	gpio_set_pin_function(PC28, PINMUX_PC28C_SERCOM1_PAD1);
}
    fed2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fed6:	205c      	movs	r0, #92	; 0x5c
    fed8:	4718      	bx	r3
    feda:	bf00      	nop
    fedc:	0000fa8d 	.word	0x0000fa8d
    fee0:	005b0002 	.word	0x005b0002
    fee4:	005c0002 	.word	0x005c0002

0000fee8 <USART_NORTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_NORTH_init(void)
{
    fee8:	b513      	push	{r0, r1, r4, lr}
	USART_NORTH_CLOCK_init();
    feea:	4b07      	ldr	r3, [pc, #28]	; (ff08 <USART_NORTH_init+0x20>)
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
    feec:	4c07      	ldr	r4, [pc, #28]	; (ff0c <USART_NORTH_init+0x24>)
	USART_NORTH_CLOCK_init();
    feee:	4798      	blx	r3
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
    fef0:	2300      	movs	r3, #0
    fef2:	9300      	str	r3, [sp, #0]
    fef4:	4a06      	ldr	r2, [pc, #24]	; (ff10 <USART_NORTH_init+0x28>)
    fef6:	4907      	ldr	r1, [pc, #28]	; (ff14 <USART_NORTH_init+0x2c>)
    fef8:	4807      	ldr	r0, [pc, #28]	; (ff18 <USART_NORTH_init+0x30>)
    fefa:	2310      	movs	r3, #16
    fefc:	47a0      	blx	r4
	USART_NORTH_PORT_init();
    fefe:	4b07      	ldr	r3, [pc, #28]	; (ff1c <USART_NORTH_init+0x34>)
}
    ff00:	b002      	add	sp, #8
    ff02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_NORTH_PORT_init();
    ff06:	4718      	bx	r3
    ff08:	0000fea1 	.word	0x0000fea1
    ff0c:	0001077d 	.word	0x0001077d
    ff10:	20008d36 	.word	0x20008d36
    ff14:	40003400 	.word	0x40003400
    ff18:	2001ce04 	.word	0x2001ce04
    ff1c:	0000fec5 	.word	0x0000fec5

0000ff20 <GRID_AUX_PORT_init>:

void GRID_AUX_PORT_init(void)
{
    ff20:	b510      	push	{r4, lr}
    ff22:	4c05      	ldr	r4, [pc, #20]	; (ff38 <GRID_AUX_PORT_init+0x18>)
    ff24:	4905      	ldr	r1, [pc, #20]	; (ff3c <GRID_AUX_PORT_init+0x1c>)
    ff26:	2039      	movs	r0, #57	; 0x39
    ff28:	47a0      	blx	r4
    ff2a:	4623      	mov	r3, r4
    ff2c:	4904      	ldr	r1, [pc, #16]	; (ff40 <GRID_AUX_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
    ff2e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ff32:	2038      	movs	r0, #56	; 0x38
    ff34:	4718      	bx	r3
    ff36:	bf00      	nop
    ff38:	0000fa8d 	.word	0x0000fa8d
    ff3c:	00390003 	.word	0x00390003
    ff40:	00380003 	.word	0x00380003

0000ff44 <GRID_AUX_CLOCK_init>:
    ff44:	4b06      	ldr	r3, [pc, #24]	; (ff60 <GRID_AUX_CLOCK_init+0x1c>)
    ff46:	2241      	movs	r2, #65	; 0x41
    ff48:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    ff4c:	2242      	movs	r2, #66	; 0x42
    ff4e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    ff52:	4a04      	ldr	r2, [pc, #16]	; (ff64 <GRID_AUX_CLOCK_init+0x20>)
    ff54:	6993      	ldr	r3, [r2, #24]
    ff56:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    ff5a:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    ff5c:	4770      	bx	lr
    ff5e:	bf00      	nop
    ff60:	40001c00 	.word	0x40001c00
    ff64:	40000800 	.word	0x40000800

0000ff68 <GRID_AUX_init>:

void GRID_AUX_init(void)
{
    ff68:	b510      	push	{r4, lr}
	GRID_AUX_CLOCK_init();
    ff6a:	4b05      	ldr	r3, [pc, #20]	; (ff80 <GRID_AUX_init+0x18>)
    ff6c:	4798      	blx	r3
	usart_sync_init(&GRID_AUX, SERCOM2, (void *)NULL);
    ff6e:	4b05      	ldr	r3, [pc, #20]	; (ff84 <GRID_AUX_init+0x1c>)
    ff70:	4905      	ldr	r1, [pc, #20]	; (ff88 <GRID_AUX_init+0x20>)
    ff72:	4806      	ldr	r0, [pc, #24]	; (ff8c <GRID_AUX_init+0x24>)
    ff74:	2200      	movs	r2, #0
    ff76:	4798      	blx	r3
	GRID_AUX_PORT_init();
}
    ff78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_AUX_PORT_init();
    ff7c:	4b04      	ldr	r3, [pc, #16]	; (ff90 <GRID_AUX_init+0x28>)
    ff7e:	4718      	bx	r3
    ff80:	0000ff45 	.word	0x0000ff45
    ff84:	0000ec39 	.word	0x0000ec39
    ff88:	41012000 	.word	0x41012000
    ff8c:	2001cd70 	.word	0x2001cd70
    ff90:	0000ff21 	.word	0x0000ff21

0000ff94 <UI_SPI_PORT_init>:

void UI_SPI_PORT_init(void)
{
    ff94:	b570      	push	{r4, r5, r6, lr}
    ff96:	4e12      	ldr	r6, [pc, #72]	; (ffe0 <UI_SPI_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB20, GPIO_DIRECTION_OUT);
    ff98:	4d12      	ldr	r5, [pc, #72]	; (ffe4 <UI_SPI_PORT_init+0x50>)
    ff9a:	4c13      	ldr	r4, [pc, #76]	; (ffe8 <UI_SPI_PORT_init+0x54>)
    ff9c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    ffa0:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
    ffa4:	2102      	movs	r1, #2
    ffa6:	2034      	movs	r0, #52	; 0x34
    ffa8:	47a8      	blx	r5
    ffaa:	4910      	ldr	r1, [pc, #64]	; (ffec <UI_SPI_PORT_init+0x58>)
    ffac:	2034      	movs	r0, #52	; 0x34
    ffae:	47a0      	blx	r4
    ffb0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
    ffb4:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB21, GPIO_DIRECTION_OUT);
    ffb8:	2102      	movs	r1, #2
    ffba:	2035      	movs	r0, #53	; 0x35
    ffbc:	47a8      	blx	r5
    ffbe:	490c      	ldr	r1, [pc, #48]	; (fff0 <UI_SPI_PORT_init+0x5c>)
    ffc0:	2035      	movs	r0, #53	; 0x35
    ffc2:	47a0      	blx	r4

	gpio_set_pin_function(PB21, PINMUX_PB21C_SERCOM3_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA20, GPIO_DIRECTION_IN);
    ffc4:	2101      	movs	r1, #1
    ffc6:	2014      	movs	r0, #20
    ffc8:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA20,
    ffca:	4b0a      	ldr	r3, [pc, #40]	; (fff4 <UI_SPI_PORT_init+0x60>)
    ffcc:	2100      	movs	r1, #0
    ffce:	2014      	movs	r0, #20
    ffd0:	4798      	blx	r3
    ffd2:	4623      	mov	r3, r4
    ffd4:	4908      	ldr	r1, [pc, #32]	; (fff8 <UI_SPI_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA20, PINMUX_PA20D_SERCOM3_PAD2);
}
    ffd6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ffda:	2014      	movs	r0, #20
    ffdc:	4718      	bx	r3
    ffde:	bf00      	nop
    ffe0:	41008000 	.word	0x41008000
    ffe4:	0000faf9 	.word	0x0000faf9
    ffe8:	0000fa8d 	.word	0x0000fa8d
    ffec:	00340002 	.word	0x00340002
    fff0:	00350002 	.word	0x00350002
    fff4:	0000fb49 	.word	0x0000fb49
    fff8:	00140003 	.word	0x00140003

0000fffc <UI_SPI_CLOCK_init>:
    fffc:	4b06      	ldr	r3, [pc, #24]	; (10018 <STACK_SIZE+0x18>)
    fffe:	2241      	movs	r2, #65	; 0x41
   10000:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   10004:	2243      	movs	r2, #67	; 0x43
   10006:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
   1000a:	4a04      	ldr	r2, [pc, #16]	; (1001c <STACK_SIZE+0x1c>)
   1000c:	6993      	ldr	r3, [r2, #24]
   1000e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   10012:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}
   10014:	4770      	bx	lr
   10016:	bf00      	nop
   10018:	40001c00 	.word	0x40001c00
   1001c:	40000800 	.word	0x40000800

00010020 <UI_SPI_init>:

void UI_SPI_init(void)
{
   10020:	b510      	push	{r4, lr}
	UI_SPI_CLOCK_init();
   10022:	4b05      	ldr	r3, [pc, #20]	; (10038 <UI_SPI_init+0x18>)
   10024:	4798      	blx	r3
	spi_m_async_init(&UI_SPI, SERCOM3);
   10026:	4b05      	ldr	r3, [pc, #20]	; (1003c <UI_SPI_init+0x1c>)
   10028:	4905      	ldr	r1, [pc, #20]	; (10040 <UI_SPI_init+0x20>)
   1002a:	4806      	ldr	r0, [pc, #24]	; (10044 <UI_SPI_init+0x24>)
   1002c:	4798      	blx	r3
	UI_SPI_PORT_init();
}
   1002e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UI_SPI_PORT_init();
   10032:	4b05      	ldr	r3, [pc, #20]	; (10048 <UI_SPI_init+0x28>)
   10034:	4718      	bx	r3
   10036:	bf00      	nop
   10038:	0000fffd 	.word	0x0000fffd
   1003c:	0000f0ed 	.word	0x0000f0ed
   10040:	41014000 	.word	0x41014000
   10044:	2001cc70 	.word	0x2001cc70
   10048:	0000ff95 	.word	0x0000ff95

0001004c <USART_WEST_CLOCK_init>:
   1004c:	4b06      	ldr	r3, [pc, #24]	; (10068 <USART_WEST_CLOCK_init+0x1c>)
   1004e:	2241      	movs	r2, #65	; 0x41
   10050:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   10054:	2242      	movs	r2, #66	; 0x42
   10056:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM4;
   1005a:	4a04      	ldr	r2, [pc, #16]	; (1006c <USART_WEST_CLOCK_init+0x20>)
   1005c:	6a13      	ldr	r3, [r2, #32]
   1005e:	f043 0301 	orr.w	r3, r3, #1
   10062:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM4_bit(MCLK);
}
   10064:	4770      	bx	lr
   10066:	bf00      	nop
   10068:	40001c00 	.word	0x40001c00
   1006c:	40000800 	.word	0x40000800

00010070 <USART_WEST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_WEST_PORT_init()
{
   10070:	b510      	push	{r4, lr}
   10072:	4c05      	ldr	r4, [pc, #20]	; (10088 <USART_WEST_PORT_init+0x18>)
   10074:	4905      	ldr	r1, [pc, #20]	; (1008c <USART_WEST_PORT_init+0x1c>)
   10076:	2028      	movs	r0, #40	; 0x28
   10078:	47a0      	blx	r4
   1007a:	4623      	mov	r3, r4
   1007c:	4904      	ldr	r1, [pc, #16]	; (10090 <USART_WEST_PORT_init+0x20>)

	gpio_set_pin_function(PB08, PINMUX_PB08D_SERCOM4_PAD0);

	gpio_set_pin_function(PB09, PINMUX_PB09D_SERCOM4_PAD1);
}
   1007e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10082:	2029      	movs	r0, #41	; 0x29
   10084:	4718      	bx	r3
   10086:	bf00      	nop
   10088:	0000fa8d 	.word	0x0000fa8d
   1008c:	00280003 	.word	0x00280003
   10090:	00290003 	.word	0x00290003

00010094 <USART_WEST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_WEST_init(void)
{
   10094:	b513      	push	{r0, r1, r4, lr}
	USART_WEST_CLOCK_init();
   10096:	4b08      	ldr	r3, [pc, #32]	; (100b8 <USART_WEST_init+0x24>)
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   10098:	4c08      	ldr	r4, [pc, #32]	; (100bc <USART_WEST_init+0x28>)
	USART_WEST_CLOCK_init();
   1009a:	4798      	blx	r3
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   1009c:	2300      	movs	r3, #0
   1009e:	9300      	str	r3, [sp, #0]
   100a0:	4a07      	ldr	r2, [pc, #28]	; (100c0 <USART_WEST_init+0x2c>)
   100a2:	4808      	ldr	r0, [pc, #32]	; (100c4 <USART_WEST_init+0x30>)
   100a4:	2310      	movs	r3, #16
   100a6:	f04f 4186 	mov.w	r1, #1124073472	; 0x43000000
   100aa:	47a0      	blx	r4
	USART_WEST_PORT_init();
   100ac:	4b06      	ldr	r3, [pc, #24]	; (100c8 <USART_WEST_init+0x34>)
}
   100ae:	b002      	add	sp, #8
   100b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_WEST_PORT_init();
   100b4:	4718      	bx	r3
   100b6:	bf00      	nop
   100b8:	0001004d 	.word	0x0001004d
   100bc:	0001077d 	.word	0x0001077d
   100c0:	20008d46 	.word	0x20008d46
   100c4:	2001ceb8 	.word	0x2001ceb8
   100c8:	00010071 	.word	0x00010071

000100cc <SYS_I2C_PORT_init>:

void SYS_I2C_PORT_init(void)
{
   100cc:	b570      	push	{r4, r5, r6, lr}

	gpio_set_pin_pull_mode(PA23,
   100ce:	2100      	movs	r1, #0
   100d0:	4d07      	ldr	r5, [pc, #28]	; (100f0 <SYS_I2C_PORT_init+0x24>)
   100d2:	4c08      	ldr	r4, [pc, #32]	; (100f4 <SYS_I2C_PORT_init+0x28>)
   100d4:	2017      	movs	r0, #23
   100d6:	47a8      	blx	r5
   100d8:	4907      	ldr	r1, [pc, #28]	; (100f8 <SYS_I2C_PORT_init+0x2c>)
   100da:	2017      	movs	r0, #23
   100dc:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA23, PINMUX_PA23D_SERCOM5_PAD0);

	gpio_set_pin_pull_mode(PA22,
   100de:	2100      	movs	r1, #0
   100e0:	2016      	movs	r0, #22
   100e2:	47a8      	blx	r5
   100e4:	4623      	mov	r3, r4
   100e6:	4905      	ldr	r1, [pc, #20]	; (100fc <SYS_I2C_PORT_init+0x30>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA22, PINMUX_PA22D_SERCOM5_PAD1);
}
   100e8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   100ec:	2016      	movs	r0, #22
   100ee:	4718      	bx	r3
   100f0:	0000fb49 	.word	0x0000fb49
   100f4:	0000fa8d 	.word	0x0000fa8d
   100f8:	00170003 	.word	0x00170003
   100fc:	00160003 	.word	0x00160003

00010100 <SYS_I2C_CLOCK_init>:
   10100:	4b06      	ldr	r3, [pc, #24]	; (1011c <SYS_I2C_CLOCK_init+0x1c>)
   10102:	2241      	movs	r2, #65	; 0x41
   10104:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
   10108:	2242      	movs	r2, #66	; 0x42
   1010a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM5;
   1010e:	4a04      	ldr	r2, [pc, #16]	; (10120 <SYS_I2C_CLOCK_init+0x20>)
   10110:	6a13      	ldr	r3, [r2, #32]
   10112:	f043 0302 	orr.w	r3, r3, #2
   10116:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_SLOW, CONF_GCLK_SERCOM5_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM5_bit(MCLK);
}
   10118:	4770      	bx	lr
   1011a:	bf00      	nop
   1011c:	40001c00 	.word	0x40001c00
   10120:	40000800 	.word	0x40000800

00010124 <SYS_I2C_init>:

void SYS_I2C_init(void)
{
   10124:	b510      	push	{r4, lr}
	SYS_I2C_CLOCK_init();
   10126:	4b05      	ldr	r3, [pc, #20]	; (1013c <SYS_I2C_init+0x18>)
   10128:	4798      	blx	r3
	i2c_m_async_init(&SYS_I2C, SERCOM5);
   1012a:	4b05      	ldr	r3, [pc, #20]	; (10140 <SYS_I2C_init+0x1c>)
   1012c:	4905      	ldr	r1, [pc, #20]	; (10144 <SYS_I2C_init+0x20>)
   1012e:	4806      	ldr	r0, [pc, #24]	; (10148 <SYS_I2C_init+0x24>)
   10130:	4798      	blx	r3
	SYS_I2C_PORT_init();
}
   10132:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SYS_I2C_PORT_init();
   10136:	4b05      	ldr	r3, [pc, #20]	; (1014c <SYS_I2C_init+0x28>)
   10138:	4718      	bx	r3
   1013a:	bf00      	nop
   1013c:	00010101 	.word	0x00010101
   10140:	0000b5b5 	.word	0x0000b5b5
   10144:	43000400 	.word	0x43000400
   10148:	2001cd30 	.word	0x2001cd30
   1014c:	000100cd 	.word	0x000100cd

00010150 <USART_SOUTH_CLOCK_init>:
   10150:	4b06      	ldr	r3, [pc, #24]	; (1016c <USART_SOUTH_CLOCK_init+0x1c>)
   10152:	2241      	movs	r2, #65	; 0x41
   10154:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   10158:	2242      	movs	r2, #66	; 0x42
   1015a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM6;
   1015e:	4a04      	ldr	r2, [pc, #16]	; (10170 <USART_SOUTH_CLOCK_init+0x20>)
   10160:	6a13      	ldr	r3, [r2, #32]
   10162:	f043 0304 	orr.w	r3, r3, #4
   10166:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_CORE, CONF_GCLK_SERCOM6_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_SLOW, CONF_GCLK_SERCOM6_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM6_bit(MCLK);
}
   10168:	4770      	bx	lr
   1016a:	bf00      	nop
   1016c:	40001c00 	.word	0x40001c00
   10170:	40000800 	.word	0x40000800

00010174 <USART_SOUTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_SOUTH_PORT_init()
{
   10174:	b510      	push	{r4, lr}
   10176:	4c05      	ldr	r4, [pc, #20]	; (1018c <USART_SOUTH_PORT_init+0x18>)
   10178:	4905      	ldr	r1, [pc, #20]	; (10190 <USART_SOUTH_PORT_init+0x1c>)
   1017a:	204d      	movs	r0, #77	; 0x4d
   1017c:	47a0      	blx	r4
   1017e:	4623      	mov	r3, r4
   10180:	4904      	ldr	r1, [pc, #16]	; (10194 <USART_SOUTH_PORT_init+0x20>)

	gpio_set_pin_function(PC13, PINMUX_PC13D_SERCOM6_PAD0);

	gpio_set_pin_function(PC12, PINMUX_PC12D_SERCOM6_PAD1);
}
   10182:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10186:	204c      	movs	r0, #76	; 0x4c
   10188:	4718      	bx	r3
   1018a:	bf00      	nop
   1018c:	0000fa8d 	.word	0x0000fa8d
   10190:	004d0003 	.word	0x004d0003
   10194:	004c0003 	.word	0x004c0003

00010198 <USART_SOUTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_SOUTH_init(void)
{
   10198:	b513      	push	{r0, r1, r4, lr}
	USART_SOUTH_CLOCK_init();
   1019a:	4b07      	ldr	r3, [pc, #28]	; (101b8 <USART_SOUTH_init+0x20>)
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   1019c:	4c07      	ldr	r4, [pc, #28]	; (101bc <USART_SOUTH_init+0x24>)
	USART_SOUTH_CLOCK_init();
   1019e:	4798      	blx	r3
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   101a0:	2300      	movs	r3, #0
   101a2:	9300      	str	r3, [sp, #0]
   101a4:	4a06      	ldr	r2, [pc, #24]	; (101c0 <USART_SOUTH_init+0x28>)
   101a6:	4907      	ldr	r1, [pc, #28]	; (101c4 <USART_SOUTH_init+0x2c>)
   101a8:	4807      	ldr	r0, [pc, #28]	; (101c8 <USART_SOUTH_init+0x30>)
   101aa:	2310      	movs	r3, #16
   101ac:	47a0      	blx	r4
	USART_SOUTH_PORT_init();
   101ae:	4b07      	ldr	r3, [pc, #28]	; (101cc <USART_SOUTH_init+0x34>)
}
   101b0:	b002      	add	sp, #8
   101b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_SOUTH_PORT_init();
   101b6:	4718      	bx	r3
   101b8:	00010151 	.word	0x00010151
   101bc:	0001077d 	.word	0x0001077d
   101c0:	20008d56 	.word	0x20008d56
   101c4:	43000800 	.word	0x43000800
   101c8:	2001cf08 	.word	0x2001cf08
   101cc:	00010175 	.word	0x00010175

000101d0 <GRID_LED_PORT_init>:

void GRID_LED_PORT_init(void)
{
   101d0:	b570      	push	{r4, r5, r6, lr}
   101d2:	4e12      	ldr	r6, [pc, #72]	; (1021c <GRID_LED_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB30, GPIO_DIRECTION_OUT);
   101d4:	4d12      	ldr	r5, [pc, #72]	; (10220 <GRID_LED_PORT_init+0x50>)
   101d6:	4c13      	ldr	r4, [pc, #76]	; (10224 <GRID_LED_PORT_init+0x54>)
   101d8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   101dc:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   101e0:	2102      	movs	r1, #2
   101e2:	203e      	movs	r0, #62	; 0x3e
   101e4:	47a8      	blx	r5
   101e6:	4910      	ldr	r1, [pc, #64]	; (10228 <GRID_LED_PORT_init+0x58>)
   101e8:	203e      	movs	r0, #62	; 0x3e
   101ea:	47a0      	blx	r4
   101ec:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   101f0:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB31, GPIO_DIRECTION_OUT);
   101f4:	2102      	movs	r1, #2
   101f6:	203f      	movs	r0, #63	; 0x3f
   101f8:	47a8      	blx	r5
   101fa:	490c      	ldr	r1, [pc, #48]	; (1022c <GRID_LED_PORT_init+0x5c>)
   101fc:	203f      	movs	r0, #63	; 0x3f
   101fe:	47a0      	blx	r4

	gpio_set_pin_function(PB31, PINMUX_PB31C_SERCOM7_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA30, GPIO_DIRECTION_IN);
   10200:	2101      	movs	r1, #1
   10202:	201e      	movs	r0, #30
   10204:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA30,
   10206:	4b0a      	ldr	r3, [pc, #40]	; (10230 <GRID_LED_PORT_init+0x60>)
   10208:	2100      	movs	r1, #0
   1020a:	201e      	movs	r0, #30
   1020c:	4798      	blx	r3
   1020e:	4623      	mov	r3, r4
   10210:	4908      	ldr	r1, [pc, #32]	; (10234 <GRID_LED_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA30, PINMUX_PA30C_SERCOM7_PAD2);
}
   10212:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10216:	201e      	movs	r0, #30
   10218:	4718      	bx	r3
   1021a:	bf00      	nop
   1021c:	41008000 	.word	0x41008000
   10220:	0000faf9 	.word	0x0000faf9
   10224:	0000fa8d 	.word	0x0000fa8d
   10228:	003e0002 	.word	0x003e0002
   1022c:	003f0002 	.word	0x003f0002
   10230:	0000fb49 	.word	0x0000fb49
   10234:	001e0002 	.word	0x001e0002

00010238 <GRID_LED_CLOCK_init>:
   10238:	4b06      	ldr	r3, [pc, #24]	; (10254 <GRID_LED_CLOCK_init+0x1c>)
   1023a:	2241      	movs	r2, #65	; 0x41
   1023c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   10240:	2242      	movs	r2, #66	; 0x42
   10242:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
   10246:	4a04      	ldr	r2, [pc, #16]	; (10258 <GRID_LED_CLOCK_init+0x20>)
   10248:	6a13      	ldr	r3, [r2, #32]
   1024a:	f043 0308 	orr.w	r3, r3, #8
   1024e:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}
   10250:	4770      	bx	lr
   10252:	bf00      	nop
   10254:	40001c00 	.word	0x40001c00
   10258:	40000800 	.word	0x40000800

0001025c <GRID_LED_init>:

void GRID_LED_init(void)
{
   1025c:	b510      	push	{r4, lr}
	GRID_LED_CLOCK_init();
   1025e:	4b05      	ldr	r3, [pc, #20]	; (10274 <GRID_LED_init+0x18>)
   10260:	4798      	blx	r3
	spi_m_dma_init(&GRID_LED, SERCOM7);
   10262:	4b05      	ldr	r3, [pc, #20]	; (10278 <GRID_LED_init+0x1c>)
   10264:	4905      	ldr	r1, [pc, #20]	; (1027c <GRID_LED_init+0x20>)
   10266:	4806      	ldr	r0, [pc, #24]	; (10280 <GRID_LED_init+0x24>)
   10268:	4798      	blx	r3
	GRID_LED_PORT_init();
}
   1026a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_LED_PORT_init();
   1026e:	4b05      	ldr	r3, [pc, #20]	; (10284 <GRID_LED_init+0x28>)
   10270:	4718      	bx	r3
   10272:	bf00      	nop
   10274:	00010239 	.word	0x00010239
   10278:	0000b9b1 	.word	0x0000b9b1
   1027c:	43000c00 	.word	0x43000c00
   10280:	2001ce54 	.word	0x2001ce54
   10284:	000101d1 	.word	0x000101d1

00010288 <delay_driver_init>:

void delay_driver_init(void)
{
	delay_init(SysTick);
   10288:	4801      	ldr	r0, [pc, #4]	; (10290 <delay_driver_init+0x8>)
   1028a:	4b02      	ldr	r3, [pc, #8]	; (10294 <delay_driver_init+0xc>)
   1028c:	4718      	bx	r3
   1028e:	bf00      	nop
   10290:	e000e010 	.word	0xe000e010
   10294:	0000ddcd 	.word	0x0000ddcd

00010298 <RAND_0_CLOCK_init>:
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TRNG;
   10298:	4a02      	ldr	r2, [pc, #8]	; (102a4 <RAND_0_CLOCK_init+0xc>)
   1029a:	69d3      	ldr	r3, [r2, #28]
   1029c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   102a0:	61d3      	str	r3, [r2, #28]
}

void RAND_0_CLOCK_init(void)
{
	hri_mclk_set_APBCMASK_TRNG_bit(MCLK);
}
   102a2:	4770      	bx	lr
   102a4:	40000800 	.word	0x40000800

000102a8 <RAND_0_init>:

void RAND_0_init(void)
{
   102a8:	b510      	push	{r4, lr}
	RAND_0_CLOCK_init();
   102aa:	4b04      	ldr	r3, [pc, #16]	; (102bc <RAND_0_init+0x14>)
   102ac:	4798      	blx	r3
	rand_sync_init(&RAND_0, TRNG);
}
   102ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rand_sync_init(&RAND_0, TRNG);
   102b2:	4903      	ldr	r1, [pc, #12]	; (102c0 <RAND_0_init+0x18>)
   102b4:	4803      	ldr	r0, [pc, #12]	; (102c4 <RAND_0_init+0x1c>)
   102b6:	4b04      	ldr	r3, [pc, #16]	; (102c8 <RAND_0_init+0x20>)
   102b8:	4718      	bx	r3
   102ba:	bf00      	nop
   102bc:	00010299 	.word	0x00010299
   102c0:	42002800 	.word	0x42002800
   102c4:	2001cd7c 	.word	0x2001cd7c
   102c8:	0000e7b1 	.word	0x0000e7b1

000102cc <USB_DEVICE_INSTANCE_PORT_init>:

void USB_DEVICE_INSTANCE_PORT_init(void)
{
   102cc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	gpio_set_pin_direction(PA24,
   102d0:	2102      	movs	r1, #2
   102d2:	4f0f      	ldr	r7, [pc, #60]	; (10310 <USB_DEVICE_INSTANCE_PORT_init+0x44>)
   102d4:	4e0f      	ldr	r6, [pc, #60]	; (10314 <USB_DEVICE_INSTANCE_PORT_init+0x48>)
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA24,
   102d6:	4d10      	ldr	r5, [pc, #64]	; (10318 <USB_DEVICE_INSTANCE_PORT_init+0x4c>)
   102d8:	4c10      	ldr	r4, [pc, #64]	; (1031c <USB_DEVICE_INSTANCE_PORT_init+0x50>)
	gpio_set_pin_direction(PA24,
   102da:	2018      	movs	r0, #24
   102dc:	47b8      	blx	r7
   102de:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   102e2:	6173      	str	r3, [r6, #20]
	gpio_set_pin_pull_mode(PA24,
   102e4:	2100      	movs	r1, #0
   102e6:	2018      	movs	r0, #24
   102e8:	47a8      	blx	r5
   102ea:	490d      	ldr	r1, [pc, #52]	; (10320 <USB_DEVICE_INSTANCE_PORT_init+0x54>)
   102ec:	2018      	movs	r0, #24
   102ee:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA24H_USB_DM);

	gpio_set_pin_direction(PA25,
   102f0:	2102      	movs	r1, #2
   102f2:	2019      	movs	r0, #25
   102f4:	47b8      	blx	r7
   102f6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   102fa:	6173      	str	r3, [r6, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA25,
   102fc:	2100      	movs	r1, #0
   102fe:	2019      	movs	r0, #25
   10300:	47a8      	blx	r5
   10302:	4623      	mov	r3, r4
   10304:	4907      	ldr	r1, [pc, #28]	; (10324 <USB_DEVICE_INSTANCE_PORT_init+0x58>)
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA25H_USB_DP);
}
   10306:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1030a:	2019      	movs	r0, #25
   1030c:	4718      	bx	r3
   1030e:	bf00      	nop
   10310:	0000faf9 	.word	0x0000faf9
   10314:	41008000 	.word	0x41008000
   10318:	0000fb49 	.word	0x0000fb49
   1031c:	0000fa8d 	.word	0x0000fa8d
   10320:	00180007 	.word	0x00180007
   10324:	00190007 	.word	0x00190007

00010328 <USB_DEVICE_INSTANCE_CLOCK_init>:
   10328:	4b07      	ldr	r3, [pc, #28]	; (10348 <USB_DEVICE_INSTANCE_CLOCK_init+0x20>)
   1032a:	2241      	movs	r2, #65	; 0x41
   1032c:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
   10330:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
   10334:	691a      	ldr	r2, [r3, #16]
   10336:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   1033a:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
   1033c:	699a      	ldr	r2, [r3, #24]
   1033e:	f042 0201 	orr.w	r2, r2, #1
   10342:	619a      	str	r2, [r3, #24]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, USB_GCLK_ID, CONF_GCLK_USB_SRC | GCLK_PCHCTRL_CHEN);
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}
   10344:	4770      	bx	lr
   10346:	bf00      	nop
   10348:	40001c00 	.word	0x40001c00

0001034c <USB_DEVICE_INSTANCE_init>:

void USB_DEVICE_INSTANCE_init(void)
{
   1034c:	b510      	push	{r4, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
   1034e:	4b04      	ldr	r3, [pc, #16]	; (10360 <USB_DEVICE_INSTANCE_init+0x14>)
   10350:	4798      	blx	r3
	usb_d_init();
   10352:	4b04      	ldr	r3, [pc, #16]	; (10364 <USB_DEVICE_INSTANCE_init+0x18>)
   10354:	4798      	blx	r3
	USB_DEVICE_INSTANCE_PORT_init();
}
   10356:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_DEVICE_INSTANCE_PORT_init();
   1035a:	4b03      	ldr	r3, [pc, #12]	; (10368 <USB_DEVICE_INSTANCE_init+0x1c>)
   1035c:	4718      	bx	r3
   1035e:	bf00      	nop
   10360:	00010329 	.word	0x00010329
   10364:	0000f4e1 	.word	0x0000f4e1
   10368:	000102cd 	.word	0x000102cd

0001036c <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
   1036c:	4a02      	ldr	r2, [pc, #8]	; (10378 <WDT_0_CLOCK_init+0xc>)
   1036e:	6953      	ldr	r3, [r2, #20]
   10370:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10374:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
   10376:	4770      	bx	lr
   10378:	40000800 	.word	0x40000800

0001037c <WDT_0_init>:

void WDT_0_init(void)
{
   1037c:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
   1037e:	4b07      	ldr	r3, [pc, #28]	; (1039c <WDT_0_init+0x20>)
   10380:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
   10382:	4b07      	ldr	r3, [pc, #28]	; (103a0 <WDT_0_init+0x24>)
   10384:	4907      	ldr	r1, [pc, #28]	; (103a4 <WDT_0_init+0x28>)
   10386:	2001      	movs	r0, #1
   10388:	2248      	movs	r2, #72	; 0x48
   1038a:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
   1038c:	4806      	ldr	r0, [pc, #24]	; (103a8 <WDT_0_init+0x2c>)
   1038e:	4b07      	ldr	r3, [pc, #28]	; (103ac <WDT_0_init+0x30>)
   10390:	6003      	str	r3, [r0, #0]
	wdt_init(&WDT_0, WDT);
}
   10392:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	return _wdt_init(&wdt->dev);
   10396:	4b06      	ldr	r3, [pc, #24]	; (103b0 <WDT_0_init+0x34>)
   10398:	4718      	bx	r3
   1039a:	bf00      	nop
   1039c:	0001036d 	.word	0x0001036d
   103a0:	0000e08d 	.word	0x0000e08d
   103a4:	0001754b 	.word	0x0001754b
   103a8:	2001ce00 	.word	0x2001ce00
   103ac:	40002000 	.word	0x40002000
   103b0:	0000b7dd 	.word	0x0000b7dd

000103b4 <system_init>:

void system_init(void)
{
   103b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
   103b8:	4b7c      	ldr	r3, [pc, #496]	; (105ac <system_init+0x1f8>)
   103ba:	4c7d      	ldr	r4, [pc, #500]	; (105b0 <system_init+0x1fc>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   103bc:	4d7d      	ldr	r5, [pc, #500]	; (105b4 <system_init+0x200>)
	// GPIO on PA21

	// Set pin direction to input
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);

	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   103be:	4e7e      	ldr	r6, [pc, #504]	; (105b8 <system_init+0x204>)
   103c0:	4798      	blx	r3
   103c2:	2320      	movs	r3, #32
   103c4:	6163      	str	r3, [r4, #20]
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   103c6:	2102      	movs	r1, #2
   103c8:	2005      	movs	r0, #5
   103ca:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103cc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
   103d0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103d4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);
   103d8:	2101      	movs	r1, #1
   103da:	2015      	movs	r0, #21
   103dc:	47a8      	blx	r5
	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   103de:	2100      	movs	r1, #0
   103e0:	2015      	movs	r0, #21
   103e2:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103e4:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
   103e8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103ec:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
	gpio_set_pin_function(PIN_UI_SPI_CS0, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB07

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_2, GPIO_DIRECTION_IN);
   103f0:	2101      	movs	r1, #1
   103f2:	2027      	movs	r0, #39	; 0x27
   103f4:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_2,
   103f6:	2100      	movs	r1, #0
   103f8:	2027      	movs	r0, #39	; 0x27
   103fa:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103fc:	f894 30c7 	ldrb.w	r3, [r4, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
   10400:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10404:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10408:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   1040c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_SHIFT, GPIO_DIRECTION_OUT);
   10410:	2102      	movs	r1, #2
   10412:	202d      	movs	r0, #45	; 0x2d
   10414:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10416:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1041a:	f44f 4780 	mov.w	r7, #16384	; 0x4000
	tmp &= ~PORT_PINCFG_PMUXEN;
   1041e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10422:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
   10426:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10428:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
   1042c:	202e      	movs	r0, #46	; 0x2e
   1042e:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10430:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
   10434:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10438:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	gpio_set_pin_function(HWCFG_CLOCK, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB15

	// Set pin direction to input
	gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
   1043c:	2101      	movs	r1, #1
   1043e:	202f      	movs	r0, #47	; 0x2f
   10440:	47a8      	blx	r5

	gpio_set_pin_pull_mode(HWCFG_DATA,
   10442:	2100      	movs	r1, #0
   10444:	202f      	movs	r0, #47	; 0x2f
   10446:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10448:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
   1044c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10450:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
	gpio_set_pin_function(HWCFG_DATA, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC11

	// Set pin direction to input
	gpio_set_pin_direction(MAP_MODE, GPIO_DIRECTION_IN);
   10454:	2101      	movs	r1, #1
   10456:	204b      	movs	r0, #75	; 0x4b
   10458:	47a8      	blx	r5

	gpio_set_pin_pull_mode(MAP_MODE,
   1045a:	2101      	movs	r1, #1
   1045c:	204b      	movs	r0, #75	; 0x4b
   1045e:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10460:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
   10464:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10468:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(UI_PWR_EN, GPIO_DIRECTION_OUT);
   1046c:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1046e:	f8c4 7114 	str.w	r7, [r4, #276]	; 0x114
   10472:	204e      	movs	r0, #78	; 0x4e
   10474:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10476:	f894 314e 	ldrb.w	r3, [r4, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
   1047a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1047e:	f884 314e 	strb.w	r3, [r4, #334]	; 0x14e
	gpio_set_pin_function(UI_PWR_EN, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC18

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_1, GPIO_DIRECTION_IN);
   10482:	2101      	movs	r1, #1
   10484:	2052      	movs	r0, #82	; 0x52
   10486:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_1,
   10488:	2100      	movs	r1, #0
   1048a:	2052      	movs	r0, #82	; 0x52
   1048c:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1048e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   10492:	4e4a      	ldr	r6, [pc, #296]	; (105bc <system_init+0x208>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10494:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10498:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1049c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   104a0:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_A, GPIO_DIRECTION_OUT);
   104a4:	2102      	movs	r1, #2
   104a6:	2053      	movs	r0, #83	; 0x53
   104a8:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   104aa:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
   104ae:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   104b2:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   104b6:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   104ba:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_B, GPIO_DIRECTION_OUT);
   104be:	2102      	movs	r1, #2
   104c0:	2054      	movs	r0, #84	; 0x54
   104c2:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   104c4:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
   104c8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   104cc:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   104d0:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_C, GPIO_DIRECTION_OUT);
   104d4:	2102      	movs	r1, #2
   104d6:	2055      	movs	r0, #85	; 0x55
   104d8:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
   104dc:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   104de:	f894 3155 	ldrb.w	r3, [r4, #341]	; 0x155
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   104e2:	4d37      	ldr	r5, [pc, #220]	; (105c0 <system_init+0x20c>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   104e4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   104e8:	f884 3155 	strb.w	r3, [r4, #341]	; 0x155

	gpio_set_pin_function(MUX_C, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
   104ec:	4b35      	ldr	r3, [pc, #212]	; (105c4 <system_init+0x210>)
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_RTC;
   104ee:	4c36      	ldr	r4, [pc, #216]	; (105c8 <system_init+0x214>)
   104f0:	4798      	blx	r3
	ADC_1_init();
   104f2:	4b36      	ldr	r3, [pc, #216]	; (105cc <system_init+0x218>)
   104f4:	4798      	blx	r3

	CRC_0_init();
   104f6:	4b36      	ldr	r3, [pc, #216]	; (105d0 <system_init+0x21c>)
   104f8:	4798      	blx	r3

	EVENT_SYSTEM_0_init();
   104fa:	4b36      	ldr	r3, [pc, #216]	; (105d4 <system_init+0x220>)
   104fc:	4798      	blx	r3

	FLASH_0_init();
   104fe:	4b36      	ldr	r3, [pc, #216]	; (105d8 <system_init+0x224>)
   10500:	4798      	blx	r3

	QSPI_INSTANCE_init();
   10502:	4b36      	ldr	r3, [pc, #216]	; (105dc <system_init+0x228>)
   10504:	4798      	blx	r3
   10506:	6963      	ldr	r3, [r4, #20]
   10508:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   1050c:	6163      	str	r3, [r4, #20]
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   1050e:	4b34      	ldr	r3, [pc, #208]	; (105e0 <system_init+0x22c>)
   10510:	4798      	blx	r3
   10512:	4934      	ldr	r1, [pc, #208]	; (105e4 <system_init+0x230>)
   10514:	4602      	mov	r2, r0
   10516:	4834      	ldr	r0, [pc, #208]	; (105e8 <system_init+0x234>)
   10518:	47a8      	blx	r5

	RTC_Scheduler_init();
	USART_EAST_init();
   1051a:	4b34      	ldr	r3, [pc, #208]	; (105ec <system_init+0x238>)
   1051c:	4798      	blx	r3
	USART_NORTH_init();
   1051e:	4b34      	ldr	r3, [pc, #208]	; (105f0 <system_init+0x23c>)
   10520:	4798      	blx	r3

	GRID_AUX_init();
   10522:	4b34      	ldr	r3, [pc, #208]	; (105f4 <system_init+0x240>)
   10524:	4798      	blx	r3

	UI_SPI_init();
   10526:	4b34      	ldr	r3, [pc, #208]	; (105f8 <system_init+0x244>)
   10528:	4798      	blx	r3
	USART_WEST_init();
   1052a:	4b34      	ldr	r3, [pc, #208]	; (105fc <system_init+0x248>)
   1052c:	4798      	blx	r3

	SYS_I2C_init();
   1052e:	4b34      	ldr	r3, [pc, #208]	; (10600 <system_init+0x24c>)
   10530:	4798      	blx	r3
	USART_SOUTH_init();
   10532:	4b34      	ldr	r3, [pc, #208]	; (10604 <system_init+0x250>)
   10534:	4798      	blx	r3

	GRID_LED_init();
   10536:	4b34      	ldr	r3, [pc, #208]	; (10608 <system_init+0x254>)
   10538:	4798      	blx	r3

	delay_driver_init();
   1053a:	4b34      	ldr	r3, [pc, #208]	; (1060c <system_init+0x258>)
   1053c:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
   1053e:	6963      	ldr	r3, [r4, #20]
   10540:	433b      	orrs	r3, r7
   10542:	4f33      	ldr	r7, [pc, #204]	; (10610 <system_init+0x25c>)
   10544:	6163      	str	r3, [r4, #20]
   10546:	f04f 0840 	mov.w	r8, #64	; 0x40
   1054a:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   1054e:	47b0      	blx	r6
   10550:	4930      	ldr	r1, [pc, #192]	; (10614 <system_init+0x260>)
   10552:	4602      	mov	r2, r0
   10554:	4830      	ldr	r0, [pc, #192]	; (10618 <system_init+0x264>)
   10556:	47a8      	blx	r5
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
   10558:	6963      	ldr	r3, [r4, #20]
   1055a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   1055e:	6163      	str	r3, [r4, #20]
   10560:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_1, TC1, _tc_get_timer());
   10564:	47b0      	blx	r6
   10566:	492d      	ldr	r1, [pc, #180]	; (1061c <system_init+0x268>)
   10568:	4602      	mov	r2, r0
   1056a:	482d      	ldr	r0, [pc, #180]	; (10620 <system_init+0x26c>)
   1056c:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC2;
   1056e:	69a3      	ldr	r3, [r4, #24]
   10570:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10574:	61a3      	str	r3, [r4, #24]
   10576:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_2, TC2, _tc_get_timer());
   1057a:	47b0      	blx	r6
   1057c:	4929      	ldr	r1, [pc, #164]	; (10624 <system_init+0x270>)
   1057e:	4602      	mov	r2, r0
   10580:	4829      	ldr	r0, [pc, #164]	; (10628 <system_init+0x274>)
   10582:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC3;
   10584:	69a3      	ldr	r3, [r4, #24]
   10586:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   1058a:	61a3      	str	r3, [r4, #24]
   1058c:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_3, TC3, _tc_get_timer());
   10590:	47b0      	blx	r6
   10592:	4926      	ldr	r1, [pc, #152]	; (1062c <system_init+0x278>)
   10594:	4602      	mov	r2, r0
   10596:	4826      	ldr	r0, [pc, #152]	; (10630 <system_init+0x27c>)
   10598:	47a8      	blx	r5

	TIMER_0_init();
	TIMER_1_init();
	TIMER_2_init();
	TIMER_3_init();
	RAND_0_init();
   1059a:	4b26      	ldr	r3, [pc, #152]	; (10634 <system_init+0x280>)
   1059c:	4798      	blx	r3

	USB_DEVICE_INSTANCE_init();
   1059e:	4b26      	ldr	r3, [pc, #152]	; (10638 <system_init+0x284>)
   105a0:	4798      	blx	r3

	WDT_0_init();
}
   105a2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WDT_0_init();
   105a6:	4b25      	ldr	r3, [pc, #148]	; (1063c <system_init+0x288>)
   105a8:	4718      	bx	r3
   105aa:	bf00      	nop
   105ac:	0000de01 	.word	0x0000de01
   105b0:	41008000 	.word	0x41008000
   105b4:	0000faf9 	.word	0x0000faf9
   105b8:	0000fb49 	.word	0x0000fb49
   105bc:	00013a55 	.word	0x00013a55
   105c0:	0000ca25 	.word	0x0000ca25
   105c4:	0000fb89 	.word	0x0000fb89
   105c8:	40000800 	.word	0x40000800
   105cc:	0000fc09 	.word	0x0000fc09
   105d0:	0000fc8d 	.word	0x0000fc8d
   105d4:	0000fcb1 	.word	0x0000fcb1
   105d8:	0000fcf1 	.word	0x0000fcf1
   105dc:	0000fdf5 	.word	0x0000fdf5
   105e0:	0000fa61 	.word	0x0000fa61
   105e4:	40002400 	.word	0x40002400
   105e8:	2001ccb8 	.word	0x2001ccb8
   105ec:	0000fe69 	.word	0x0000fe69
   105f0:	0000fee9 	.word	0x0000fee9
   105f4:	0000ff69 	.word	0x0000ff69
   105f8:	00010021 	.word	0x00010021
   105fc:	00010095 	.word	0x00010095
   10600:	00010125 	.word	0x00010125
   10604:	00010199 	.word	0x00010199
   10608:	0001025d 	.word	0x0001025d
   1060c:	00010289 	.word	0x00010289
   10610:	40001c00 	.word	0x40001c00
   10614:	40003800 	.word	0x40003800
   10618:	2001cfa4 	.word	0x2001cfa4
   1061c:	40003c00 	.word	0x40003c00
   10620:	2001ce98 	.word	0x2001ce98
   10624:	4101a000 	.word	0x4101a000
   10628:	2001ccd8 	.word	0x2001ccd8
   1062c:	4101c000 	.word	0x4101c000
   10630:	2001cf84 	.word	0x2001cf84
   10634:	000102a9 	.word	0x000102a9
   10638:	0001034d 	.word	0x0001034d
   1063c:	0001037d 	.word	0x0001037d

00010640 <usart_transmission_complete>:
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   10640:	2300      	movs	r3, #0
   10642:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
   10644:	69c3      	ldr	r3, [r0, #28]
   10646:	b10b      	cbz	r3, 1064c <usart_transmission_complete+0xc>
		descr->usart_cb.tx_done(descr);
   10648:	3808      	subs	r0, #8
   1064a:	4718      	bx	r3
	}
}
   1064c:	4770      	bx	lr

0001064e <usart_error>:
 */
static void usart_error(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   1064e:	2300      	movs	r3, #0
   10650:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
   10652:	6a43      	ldr	r3, [r0, #36]	; 0x24
   10654:	b10b      	cbz	r3, 1065a <usart_error+0xc>
		descr->usart_cb.error(descr);
   10656:	3808      	subs	r0, #8
   10658:	4718      	bx	r3
	}
}
   1065a:	4770      	bx	lr

0001065c <usart_fill_rx_buffer>:
{
   1065c:	b570      	push	{r4, r5, r6, lr}
   1065e:	4604      	mov	r4, r0
	ringbuffer_put(&descr->rx, data);
   10660:	4b05      	ldr	r3, [pc, #20]	; (10678 <usart_fill_rx_buffer+0x1c>)
   10662:	f1a0 0508 	sub.w	r5, r0, #8
   10666:	302c      	adds	r0, #44	; 0x2c
   10668:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
   1066a:	6a23      	ldr	r3, [r4, #32]
   1066c:	b11b      	cbz	r3, 10676 <usart_fill_rx_buffer+0x1a>
		descr->usart_cb.rx_done(descr);
   1066e:	4628      	mov	r0, r5
}
   10670:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		descr->usart_cb.rx_done(descr);
   10674:	4718      	bx	r3
}
   10676:	bd70      	pop	{r4, r5, r6, pc}
   10678:	00011af1 	.word	0x00011af1

0001067c <usart_async_write>:
{
   1067c:	b570      	push	{r4, r5, r6, lr}
   1067e:	460e      	mov	r6, r1
   10680:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
   10682:	4604      	mov	r4, r0
   10684:	b118      	cbz	r0, 1068e <usart_async_write+0x12>
   10686:	b1d9      	cbz	r1, 106c0 <usart_async_write+0x44>
   10688:	1e10      	subs	r0, r2, #0
   1068a:	bf18      	it	ne
   1068c:	2001      	movne	r0, #1
   1068e:	4b0f      	ldr	r3, [pc, #60]	; (106cc <usart_async_write+0x50>)
   10690:	490f      	ldr	r1, [pc, #60]	; (106d0 <usart_async_write+0x54>)
   10692:	f240 123b 	movw	r2, #315	; 0x13b
   10696:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
   10698:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
   1069c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
   106a0:	429a      	cmp	r2, r3
   106a2:	d10f      	bne.n	106c4 <usart_async_write+0x48>
	descr->tx_por           = 0;
   106a4:	2300      	movs	r3, #0
   106a6:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
   106aa:	2301      	movs	r3, #1
   106ac:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
   106ae:	f104 0008 	add.w	r0, r4, #8
   106b2:	4b08      	ldr	r3, [pc, #32]	; (106d4 <usart_async_write+0x58>)
	descr->tx_buffer        = (uint8_t *)buf;
   106b4:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
   106b6:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	_usart_async_enable_byte_sent_irq(&descr->device);
   106ba:	4798      	blx	r3
	return (int32_t)length;
   106bc:	4628      	mov	r0, r5
}
   106be:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
   106c0:	4608      	mov	r0, r1
   106c2:	e7e4      	b.n	1068e <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
   106c4:	f06f 001b 	mvn.w	r0, #27
   106c8:	e7f9      	b.n	106be <usart_async_write+0x42>
   106ca:	bf00      	nop
   106cc:	0000e08d 	.word	0x0000e08d
   106d0:	00017564 	.word	0x00017564
   106d4:	000110d7 	.word	0x000110d7

000106d8 <usart_process_byte_sent>:
	if (descr->tx_por != descr->tx_buffer_length) {
   106d8:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   106da:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
   106de:	429a      	cmp	r2, r3
{
   106e0:	b510      	push	{r4, lr}
   106e2:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
   106e4:	d00a      	beq.n	106fc <usart_process_byte_sent+0x24>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
   106e6:	6c02      	ldr	r2, [r0, #64]	; 0x40
   106e8:	1c59      	adds	r1, r3, #1
   106ea:	8781      	strh	r1, [r0, #60]	; 0x3c
   106ec:	5cd1      	ldrb	r1, [r2, r3]
   106ee:	4b04      	ldr	r3, [pc, #16]	; (10700 <usart_process_byte_sent+0x28>)
   106f0:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
   106f2:	4b04      	ldr	r3, [pc, #16]	; (10704 <usart_process_byte_sent+0x2c>)
   106f4:	4620      	mov	r0, r4
}
   106f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_usart_async_enable_tx_done_irq(&descr->device);
   106fa:	4718      	bx	r3
   106fc:	4b02      	ldr	r3, [pc, #8]	; (10708 <usart_process_byte_sent+0x30>)
   106fe:	e7fa      	b.n	106f6 <usart_process_byte_sent+0x1e>
   10700:	000110ab 	.word	0x000110ab
   10704:	000110d7 	.word	0x000110d7
   10708:	000110df 	.word	0x000110df

0001070c <usart_async_read>:
{
   1070c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   10710:	460e      	mov	r6, r1
   10712:	4617      	mov	r7, r2
	ASSERT(descr && buf && length);
   10714:	4604      	mov	r4, r0
   10716:	b118      	cbz	r0, 10720 <usart_async_read+0x14>
   10718:	b1e9      	cbz	r1, 10756 <usart_async_read+0x4a>
   1071a:	1e10      	subs	r0, r2, #0
   1071c:	bf18      	it	ne
   1071e:	2001      	movne	r0, #1
   10720:	4910      	ldr	r1, [pc, #64]	; (10764 <usart_async_read+0x58>)
   10722:	4b11      	ldr	r3, [pc, #68]	; (10768 <usart_async_read+0x5c>)
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   10724:	f8df 9050 	ldr.w	r9, [pc, #80]	; 10778 <usart_async_read+0x6c>
	ASSERT(descr && buf && length);
   10728:	f44f 72ac 	mov.w	r2, #344	; 0x158
   1072c:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   1072e:	3434      	adds	r4, #52	; 0x34
	CRITICAL_SECTION_ENTER()
   10730:	4b0e      	ldr	r3, [pc, #56]	; (1076c <usart_async_read+0x60>)
   10732:	a801      	add	r0, sp, #4
   10734:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   10736:	4b0e      	ldr	r3, [pc, #56]	; (10770 <usart_async_read+0x64>)
   10738:	4620      	mov	r0, r4
   1073a:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
   1073c:	4b0d      	ldr	r3, [pc, #52]	; (10774 <usart_async_read+0x68>)
	num = ringbuffer_num(&descr->rx);
   1073e:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
   10740:	a801      	add	r0, sp, #4
   10742:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
   10744:	2500      	movs	r5, #0
   10746:	45a8      	cmp	r8, r5
   10748:	d001      	beq.n	1074e <usart_async_read+0x42>
   1074a:	42bd      	cmp	r5, r7
   1074c:	d105      	bne.n	1075a <usart_async_read+0x4e>
}
   1074e:	4628      	mov	r0, r5
   10750:	b003      	add	sp, #12
   10752:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && buf && length);
   10756:	4608      	mov	r0, r1
   10758:	e7e2      	b.n	10720 <usart_async_read+0x14>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   1075a:	1971      	adds	r1, r6, r5
   1075c:	4620      	mov	r0, r4
   1075e:	47c8      	blx	r9
   10760:	3501      	adds	r5, #1
   10762:	e7f0      	b.n	10746 <usart_async_read+0x3a>
   10764:	00017564 	.word	0x00017564
   10768:	0000e08d 	.word	0x0000e08d
   1076c:	00011b59 	.word	0x00011b59
   10770:	00011b35 	.word	0x00011b35
   10774:	00011b67 	.word	0x00011b67
   10778:	00011ab1 	.word	0x00011ab1

0001077c <usart_async_init>:
{
   1077c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1077e:	460d      	mov	r5, r1
   10780:	4616      	mov	r6, r2
   10782:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   10784:	4604      	mov	r4, r0
   10786:	b120      	cbz	r0, 10792 <usart_async_init+0x16>
   10788:	b309      	cbz	r1, 107ce <usart_async_init+0x52>
   1078a:	b312      	cbz	r2, 107d2 <usart_async_init+0x56>
   1078c:	1e18      	subs	r0, r3, #0
   1078e:	bf18      	it	ne
   10790:	2001      	movne	r0, #1
   10792:	4912      	ldr	r1, [pc, #72]	; (107dc <usart_async_init+0x60>)
   10794:	4b12      	ldr	r3, [pc, #72]	; (107e0 <usart_async_init+0x64>)
   10796:	223a      	movs	r2, #58	; 0x3a
   10798:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
   1079a:	4b12      	ldr	r3, [pc, #72]	; (107e4 <usart_async_init+0x68>)
   1079c:	463a      	mov	r2, r7
   1079e:	4631      	mov	r1, r6
   107a0:	f104 0034 	add.w	r0, r4, #52	; 0x34
   107a4:	4798      	blx	r3
   107a6:	b9b0      	cbnz	r0, 107d6 <usart_async_init+0x5a>
	init_status = _usart_async_init(&descr->device, hw);
   107a8:	4b0f      	ldr	r3, [pc, #60]	; (107e8 <usart_async_init+0x6c>)
   107aa:	4629      	mov	r1, r5
   107ac:	f104 0008 	add.w	r0, r4, #8
   107b0:	4798      	blx	r3
	if (init_status) {
   107b2:	b958      	cbnz	r0, 107cc <usart_async_init+0x50>
	descr->io.read  = usart_async_read;
   107b4:	4b0d      	ldr	r3, [pc, #52]	; (107ec <usart_async_init+0x70>)
   107b6:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
   107b8:	4b0d      	ldr	r3, [pc, #52]	; (107f0 <usart_async_init+0x74>)
   107ba:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
   107bc:	4b0d      	ldr	r3, [pc, #52]	; (107f4 <usart_async_init+0x78>)
   107be:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
   107c0:	4b0d      	ldr	r3, [pc, #52]	; (107f8 <usart_async_init+0x7c>)
   107c2:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
   107c4:	4b0d      	ldr	r3, [pc, #52]	; (107fc <usart_async_init+0x80>)
   107c6:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
   107c8:	4b0d      	ldr	r3, [pc, #52]	; (10800 <usart_async_init+0x84>)
   107ca:	6163      	str	r3, [r4, #20]
}
   107cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   107ce:	4608      	mov	r0, r1
   107d0:	e7df      	b.n	10792 <usart_async_init+0x16>
   107d2:	4610      	mov	r0, r2
   107d4:	e7dd      	b.n	10792 <usart_async_init+0x16>
		return ERR_INVALID_ARG;
   107d6:	f06f 000c 	mvn.w	r0, #12
   107da:	e7f7      	b.n	107cc <usart_async_init+0x50>
   107dc:	00017564 	.word	0x00017564
   107e0:	0000e08d 	.word	0x0000e08d
   107e4:	00011a75 	.word	0x00011a75
   107e8:	00010fed 	.word	0x00010fed
   107ec:	0001070d 	.word	0x0001070d
   107f0:	0001067d 	.word	0x0001067d
   107f4:	000106d9 	.word	0x000106d9
   107f8:	0001065d 	.word	0x0001065d
   107fc:	00010641 	.word	0x00010641
   10800:	0001064f 	.word	0x0001064f

00010804 <usart_async_enable>:
{
   10804:	b510      	push	{r4, lr}
	ASSERT(descr);
   10806:	4604      	mov	r4, r0
   10808:	3800      	subs	r0, #0
   1080a:	bf18      	it	ne
   1080c:	2001      	movne	r0, #1
   1080e:	4905      	ldr	r1, [pc, #20]	; (10824 <usart_async_enable+0x20>)
   10810:	4b05      	ldr	r3, [pc, #20]	; (10828 <usart_async_enable+0x24>)
   10812:	2261      	movs	r2, #97	; 0x61
   10814:	4798      	blx	r3
	_usart_async_enable(&descr->device);
   10816:	f104 0008 	add.w	r0, r4, #8
   1081a:	4b04      	ldr	r3, [pc, #16]	; (1082c <usart_async_enable+0x28>)
   1081c:	4798      	blx	r3
}
   1081e:	2000      	movs	r0, #0
   10820:	bd10      	pop	{r4, pc}
   10822:	bf00      	nop
   10824:	00017564 	.word	0x00017564
   10828:	0000e08d 	.word	0x0000e08d
   1082c:	00011079 	.word	0x00011079

00010830 <usart_async_disable>:
{
   10830:	b510      	push	{r4, lr}
	ASSERT(descr);
   10832:	4604      	mov	r4, r0
   10834:	3800      	subs	r0, #0
   10836:	bf18      	it	ne
   10838:	2001      	movne	r0, #1
   1083a:	4905      	ldr	r1, [pc, #20]	; (10850 <usart_async_disable+0x20>)
   1083c:	4b05      	ldr	r3, [pc, #20]	; (10854 <usart_async_disable+0x24>)
   1083e:	226c      	movs	r2, #108	; 0x6c
   10840:	4798      	blx	r3
	_usart_async_disable(&descr->device);
   10842:	f104 0008 	add.w	r0, r4, #8
   10846:	4b04      	ldr	r3, [pc, #16]	; (10858 <usart_async_disable+0x28>)
   10848:	4798      	blx	r3
}
   1084a:	2000      	movs	r0, #0
   1084c:	bd10      	pop	{r4, pc}
   1084e:	bf00      	nop
   10850:	00017564 	.word	0x00017564
   10854:	0000e08d 	.word	0x0000e08d
   10858:	0001108d 	.word	0x0001108d

0001085c <usart_async_get_io_descriptor>:
{
   1085c:	b538      	push	{r3, r4, r5, lr}
   1085e:	460d      	mov	r5, r1
	ASSERT(descr && io);
   10860:	4604      	mov	r4, r0
   10862:	b110      	cbz	r0, 1086a <usart_async_get_io_descriptor+0xe>
   10864:	1e08      	subs	r0, r1, #0
   10866:	bf18      	it	ne
   10868:	2001      	movne	r0, #1
   1086a:	4903      	ldr	r1, [pc, #12]	; (10878 <usart_async_get_io_descriptor+0x1c>)
   1086c:	4b03      	ldr	r3, [pc, #12]	; (1087c <usart_async_get_io_descriptor+0x20>)
   1086e:	2277      	movs	r2, #119	; 0x77
   10870:	4798      	blx	r3
	*io = &descr->io;
   10872:	602c      	str	r4, [r5, #0]
}
   10874:	2000      	movs	r0, #0
   10876:	bd38      	pop	{r3, r4, r5, pc}
   10878:	00017564 	.word	0x00017564
   1087c:	0000e08d 	.word	0x0000e08d

00010880 <usart_async_register_callback>:
{
   10880:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
   10882:	4605      	mov	r5, r0
   10884:	3800      	subs	r0, #0
{
   10886:	460c      	mov	r4, r1
	ASSERT(descr);
   10888:	bf18      	it	ne
   1088a:	2001      	movne	r0, #1
   1088c:	4911      	ldr	r1, [pc, #68]	; (108d4 <usart_async_register_callback+0x54>)
   1088e:	4b12      	ldr	r3, [pc, #72]	; (108d8 <usart_async_register_callback+0x58>)
{
   10890:	4616      	mov	r6, r2
	ASSERT(descr);
   10892:	2283      	movs	r2, #131	; 0x83
   10894:	4798      	blx	r3
	switch (type) {
   10896:	2c01      	cmp	r4, #1
   10898:	d00d      	beq.n	108b6 <usart_async_register_callback+0x36>
   1089a:	2c02      	cmp	r4, #2
   1089c:	d011      	beq.n	108c2 <usart_async_register_callback+0x42>
   1089e:	b9b4      	cbnz	r4, 108ce <usart_async_register_callback+0x4e>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   108a0:	1e32      	subs	r2, r6, #0
		descr->usart_cb.rx_done = cb;
   108a2:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   108a4:	bf18      	it	ne
   108a6:	2201      	movne	r2, #1
   108a8:	2101      	movs	r1, #1
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   108aa:	f105 0008 	add.w	r0, r5, #8
   108ae:	4b0b      	ldr	r3, [pc, #44]	; (108dc <usart_async_register_callback+0x5c>)
   108b0:	4798      	blx	r3
	return ERR_NONE;
   108b2:	2000      	movs	r0, #0
}
   108b4:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   108b6:	1e32      	subs	r2, r6, #0
		descr->usart_cb.tx_done = cb;
   108b8:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   108ba:	bf18      	it	ne
   108bc:	2201      	movne	r2, #1
   108be:	2102      	movs	r1, #2
   108c0:	e7f3      	b.n	108aa <usart_async_register_callback+0x2a>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   108c2:	1e32      	subs	r2, r6, #0
		descr->usart_cb.error = cb;
   108c4:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   108c6:	bf18      	it	ne
   108c8:	2201      	movne	r2, #1
   108ca:	2103      	movs	r1, #3
   108cc:	e7ed      	b.n	108aa <usart_async_register_callback+0x2a>
	switch (type) {
   108ce:	f06f 000c 	mvn.w	r0, #12
   108d2:	e7ef      	b.n	108b4 <usart_async_register_callback+0x34>
   108d4:	00017564 	.word	0x00017564
   108d8:	0000e08d 	.word	0x0000e08d
   108dc:	000110e9 	.word	0x000110e9

000108e0 <usart_async_set_parity>:
{
   108e0:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr);
   108e2:	4604      	mov	r4, r0
   108e4:	3800      	subs	r0, #0
   108e6:	bf18      	it	ne
   108e8:	2001      	movne	r0, #1
{
   108ea:	460d      	mov	r5, r1
	ASSERT(descr);
   108ec:	22cb      	movs	r2, #203	; 0xcb
   108ee:	4905      	ldr	r1, [pc, #20]	; (10904 <usart_async_set_parity+0x24>)
   108f0:	4b05      	ldr	r3, [pc, #20]	; (10908 <usart_async_set_parity+0x28>)
   108f2:	4798      	blx	r3
	_usart_async_set_parity(&descr->device, parity);
   108f4:	f104 0008 	add.w	r0, r4, #8
   108f8:	4b04      	ldr	r3, [pc, #16]	; (1090c <usart_async_set_parity+0x2c>)
   108fa:	4629      	mov	r1, r5
   108fc:	4798      	blx	r3
}
   108fe:	2000      	movs	r0, #0
   10900:	bd38      	pop	{r3, r4, r5, pc}
   10902:	bf00      	nop
   10904:	00017564 	.word	0x00017564
   10908:	0000e08d 	.word	0x0000e08d
   1090c:	00011099 	.word	0x00011099

00010910 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
   10910:	69c3      	ldr	r3, [r0, #28]
   10912:	420b      	tst	r3, r1
   10914:	d1fc      	bne.n	10910 <hri_sercomi2cm_wait_for_sync>
	};
}
   10916:	4770      	bx	lr

00010918 <hri_sercomspi_wait_for_sync>:
	return ((Sercom *)hw)->I2CS.SYNCBUSY.reg & reg;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
   10918:	69c3      	ldr	r3, [r0, #28]
   1091a:	420b      	tst	r3, r1
   1091c:	d1fc      	bne.n	10918 <hri_sercomspi_wait_for_sync>
	};
}
   1091e:	4770      	bx	lr

00010920 <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
   10920:	69c3      	ldr	r3, [r0, #28]
   10922:	420b      	tst	r3, r1
   10924:	d1fc      	bne.n	10920 <hri_sercomusart_wait_for_sync>
	};
}
   10926:	4770      	bx	lr

00010928 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   10928:	6802      	ldr	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   1092a:	4b03      	ldr	r3, [pc, #12]	; (10938 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   1092c:	f022 0202 	bic.w	r2, r2, #2
   10930:	6002      	str	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10932:	2103      	movs	r1, #3
   10934:	4718      	bx	r3
   10936:	bf00      	nop
   10938:	00010911 	.word	0x00010911

0001093c <hri_sercomspi_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomspi_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   1093c:	6802      	ldr	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1093e:	4b03      	ldr	r3, [pc, #12]	; (1094c <hri_sercomspi_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   10940:	f022 0202 	bic.w	r2, r2, #2
   10944:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10946:	2103      	movs	r1, #3
   10948:	4718      	bx	r3
   1094a:	bf00      	nop
   1094c:	00010919 	.word	0x00010919

00010950 <hri_sercomusart_get_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomusart_get_CTRLA_ENABLE_bit(const void *const hw)
{
   10950:	b508      	push	{r3, lr}
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10952:	2103      	movs	r1, #3
   10954:	4b02      	ldr	r3, [pc, #8]	; (10960 <hri_sercomusart_get_CTRLA_ENABLE_bit+0x10>)
   10956:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10958:	6800      	ldr	r0, [r0, #0]
	tmp = (tmp & SERCOM_USART_CTRLA_ENABLE) >> SERCOM_USART_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}
   1095a:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1095e:	bd08      	pop	{r3, pc}
   10960:	00010921 	.word	0x00010921

00010964 <hri_sercomusart_write_CTRLA_ENABLE_bit>:

static inline void hri_sercomusart_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10964:	6803      	ldr	r3, [r0, #0]
	tmp &= ~SERCOM_USART_CTRLA_ENABLE;
   10966:	f023 0302 	bic.w	r3, r3, #2
	tmp |= value << SERCOM_USART_CTRLA_ENABLE_Pos;
   1096a:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
	((Sercom *)hw)->USART.CTRLA.reg = tmp;
   1096e:	6001      	str	r1, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10970:	4b01      	ldr	r3, [pc, #4]	; (10978 <hri_sercomusart_write_CTRLA_ENABLE_bit+0x14>)
   10972:	2103      	movs	r1, #3
   10974:	4718      	bx	r3
   10976:	bf00      	nop
   10978:	00010921 	.word	0x00010921

0001097c <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   1097c:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1097e:	4b03      	ldr	r3, [pc, #12]	; (1098c <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   10980:	f022 0202 	bic.w	r2, r2, #2
   10984:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10986:	2103      	movs	r1, #3
   10988:	4718      	bx	r3
   1098a:	bf00      	nop
   1098c:	00010921 	.word	0x00010921

00010990 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
   10990:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10992:	4d0c      	ldr	r5, [pc, #48]	; (109c4 <_sercom_get_hardware_index+0x34>)
{
   10994:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10996:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   10998:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   1099a:	466c      	mov	r4, sp
   1099c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1099e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   109a2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   109a6:	466a      	mov	r2, sp
   109a8:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
   109aa:	f852 1b04 	ldr.w	r1, [r2], #4
   109ae:	42b1      	cmp	r1, r6
   109b0:	d102      	bne.n	109b8 <_sercom_get_hardware_index+0x28>
			return i;
   109b2:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
   109b4:	b008      	add	sp, #32
   109b6:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   109b8:	3301      	adds	r3, #1
   109ba:	2b08      	cmp	r3, #8
   109bc:	d1f5      	bne.n	109aa <_sercom_get_hardware_index+0x1a>
	return 0;
   109be:	2000      	movs	r0, #0
   109c0:	e7f8      	b.n	109b4 <_sercom_get_hardware_index+0x24>
   109c2:	bf00      	nop
   109c4:	0001759c 	.word	0x0001759c

000109c8 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
   109c8:	b510      	push	{r4, lr}
	void *hw = device->hw;
   109ca:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   109cc:	7e22      	ldrb	r2, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   109ce:	07d1      	lsls	r1, r2, #31
{
   109d0:	4603      	mov	r3, r0
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   109d2:	d508      	bpl.n	109e6 <_sercom_usart_interrupt_handler+0x1e>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
   109d4:	7da2      	ldrb	r2, [r4, #22]
   109d6:	07d2      	lsls	r2, r2, #31
   109d8:	d505      	bpl.n	109e6 <_sercom_usart_interrupt_handler+0x1e>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   109da:	2201      	movs	r2, #1
   109dc:	7522      	strb	r2, [r4, #20]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
   109de:	6803      	ldr	r3, [r0, #0]
		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
		status = hri_sercomusart_read_STATUS_reg(hw);
		hri_sercomusart_clear_STATUS_reg(hw, status);
	}
}
   109e0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_byte_sent(device);
   109e4:	4718      	bx	r3
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   109e6:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
   109e8:	0790      	lsls	r0, r2, #30
   109ea:	d509      	bpl.n	10a00 <_sercom_usart_interrupt_handler+0x38>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
   109ec:	7da2      	ldrb	r2, [r4, #22]
   109ee:	0791      	lsls	r1, r2, #30
   109f0:	d506      	bpl.n	10a00 <_sercom_usart_interrupt_handler+0x38>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
   109f2:	2202      	movs	r2, #2
   109f4:	7522      	strb	r2, [r4, #20]
		device->usart_cb.tx_done_cb(device);
   109f6:	4618      	mov	r0, r3
}
   109f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_done_cb(device);
   109fc:	689a      	ldr	r2, [r3, #8]
   109fe:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   10a00:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
   10a02:	0752      	lsls	r2, r2, #29
   10a04:	d50d      	bpl.n	10a22 <_sercom_usart_interrupt_handler+0x5a>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
   10a06:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
   10a08:	f002 0237 	and.w	r2, r2, #55	; 0x37
   10a0c:	b112      	cbz	r2, 10a14 <_sercom_usart_interrupt_handler+0x4c>
	((Sercom *)hw)->USART.STATUS.reg = mask;
   10a0e:	23ff      	movs	r3, #255	; 0xff
   10a10:	8363      	strh	r3, [r4, #26]
}
   10a12:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
   10a14:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   10a16:	685a      	ldr	r2, [r3, #4]
}
   10a18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   10a1c:	b2c9      	uxtb	r1, r1
   10a1e:	4618      	mov	r0, r3
   10a20:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
   10a22:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
   10a24:	09d2      	lsrs	r2, r2, #7
   10a26:	d0f4      	beq.n	10a12 <_sercom_usart_interrupt_handler+0x4a>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
   10a28:	2280      	movs	r2, #128	; 0x80
   10a2a:	7622      	strb	r2, [r4, #24]
		device->usart_cb.error_cb(device);
   10a2c:	4618      	mov	r0, r3
   10a2e:	68da      	ldr	r2, [r3, #12]
   10a30:	4790      	blx	r2
	return ((Sercom *)hw)->USART.STATUS.reg;
   10a32:	8b63      	ldrh	r3, [r4, #26]
   10a34:	b29b      	uxth	r3, r3
   10a36:	e7eb      	b.n	10a10 <_sercom_usart_interrupt_handler+0x48>

00010a38 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM0) {
   10a38:	4b11      	ldr	r3, [pc, #68]	; (10a80 <_sercom_init_irq_param+0x48>)
   10a3a:	4298      	cmp	r0, r3
   10a3c:	d105      	bne.n	10a4a <_sercom_init_irq_param+0x12>
		_sercom0_dev = (struct _usart_async_device *)dev;
   10a3e:	4b11      	ldr	r3, [pc, #68]	; (10a84 <_sercom_init_irq_param+0x4c>)
   10a40:	6019      	str	r1, [r3, #0]

	if (hw == SERCOM5) {
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
	}

	if (hw == SERCOM6) {
   10a42:	4b11      	ldr	r3, [pc, #68]	; (10a88 <_sercom_init_irq_param+0x50>)
   10a44:	4298      	cmp	r0, r3
   10a46:	d018      	beq.n	10a7a <_sercom_init_irq_param+0x42>
   10a48:	4770      	bx	lr
	if (hw == SERCOM1) {
   10a4a:	4b10      	ldr	r3, [pc, #64]	; (10a8c <_sercom_init_irq_param+0x54>)
   10a4c:	4298      	cmp	r0, r3
   10a4e:	d00b      	beq.n	10a68 <_sercom_init_irq_param+0x30>
	if (hw == SERCOM3) {
   10a50:	4b0f      	ldr	r3, [pc, #60]	; (10a90 <_sercom_init_irq_param+0x58>)
   10a52:	4298      	cmp	r0, r3
   10a54:	d00b      	beq.n	10a6e <_sercom_init_irq_param+0x36>
	if (hw == SERCOM4) {
   10a56:	f1b0 4f86 	cmp.w	r0, #1124073472	; 0x43000000
   10a5a:	d00b      	beq.n	10a74 <_sercom_init_irq_param+0x3c>
	if (hw == SERCOM5) {
   10a5c:	4b0d      	ldr	r3, [pc, #52]	; (10a94 <_sercom_init_irq_param+0x5c>)
   10a5e:	4298      	cmp	r0, r3
   10a60:	d1ef      	bne.n	10a42 <_sercom_init_irq_param+0xa>
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
   10a62:	4b08      	ldr	r3, [pc, #32]	; (10a84 <_sercom_init_irq_param+0x4c>)
   10a64:	6119      	str	r1, [r3, #16]
	if (hw == SERCOM6) {
   10a66:	4770      	bx	lr
		_sercom1_dev = (struct _usart_async_device *)dev;
   10a68:	4b06      	ldr	r3, [pc, #24]	; (10a84 <_sercom_init_irq_param+0x4c>)
   10a6a:	6059      	str	r1, [r3, #4]
	if (hw == SERCOM5) {
   10a6c:	e7e9      	b.n	10a42 <_sercom_init_irq_param+0xa>
		_sercom3_dev = (struct _spi_async_dev *)dev;
   10a6e:	4b05      	ldr	r3, [pc, #20]	; (10a84 <_sercom_init_irq_param+0x4c>)
   10a70:	6099      	str	r1, [r3, #8]
	if (hw == SERCOM6) {
   10a72:	4770      	bx	lr
		_sercom4_dev = (struct _usart_async_device *)dev;
   10a74:	4b03      	ldr	r3, [pc, #12]	; (10a84 <_sercom_init_irq_param+0x4c>)
   10a76:	60d9      	str	r1, [r3, #12]
	if (hw == SERCOM6) {
   10a78:	4770      	bx	lr
		_sercom6_dev = (struct _usart_async_device *)dev;
   10a7a:	4b02      	ldr	r3, [pc, #8]	; (10a84 <_sercom_init_irq_param+0x4c>)
   10a7c:	6159      	str	r1, [r3, #20]
	}
}
   10a7e:	4770      	bx	lr
   10a80:	40003000 	.word	0x40003000
   10a84:	20008d68 	.word	0x20008d68
   10a88:	43000800 	.word	0x43000800
   10a8c:	40003400 	.word	0x40003400
   10a90:	41014000 	.word	0x41014000
   10a94:	43000400 	.word	0x43000400

00010a98 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
   10a98:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
   10a9a:	4b03      	ldr	r3, [pc, #12]	; (10aa8 <_sercom_get_irq_num+0x10>)
   10a9c:	4798      	blx	r3
   10a9e:	0080      	lsls	r0, r0, #2
   10aa0:	302e      	adds	r0, #46	; 0x2e
}
   10aa2:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   10aa6:	bd08      	pop	{r3, pc}
   10aa8:	00010991 	.word	0x00010991

00010aac <_spi_sync_enable>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10aac:	69c2      	ldr	r2, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10aae:	f012 0201 	ands.w	r2, r2, #1
{
   10ab2:	b508      	push	{r3, lr}
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10ab4:	d108      	bne.n	10ac8 <_spi_sync_enable+0x1c>
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   10ab6:	6803      	ldr	r3, [r0, #0]
   10ab8:	f043 0302 	orr.w	r3, r3, #2
   10abc:	6003      	str	r3, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10abe:	2103      	movs	r1, #3
   10ac0:	4b03      	ldr	r3, [pc, #12]	; (10ad0 <_spi_sync_enable+0x24>)
   10ac2:	4798      	blx	r3
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
   10ac4:	4610      	mov	r0, r2
}
   10ac6:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
   10ac8:	f06f 0003 	mvn.w	r0, #3
   10acc:	e7fb      	b.n	10ac6 <_spi_sync_enable+0x1a>
   10ace:	bf00      	nop
   10ad0:	00010919 	.word	0x00010919

00010ad4 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
   10ad4:	b508      	push	{r3, lr}
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
   10ad6:	4b08      	ldr	r3, [pc, #32]	; (10af8 <_spi_get_regs+0x24>)
   10ad8:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
		if (sercomspi_regs[i].n == n) {
   10ada:	2803      	cmp	r0, #3
   10adc:	d007      	beq.n	10aee <_spi_get_regs+0x1a>
   10ade:	2807      	cmp	r0, #7
   10ae0:	d107      	bne.n	10af2 <_spi_get_regs+0x1e>
   10ae2:	2301      	movs	r3, #1
			return &sercomspi_regs[i];
   10ae4:	4805      	ldr	r0, [pc, #20]	; (10afc <_spi_get_regs+0x28>)
   10ae6:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   10aea:	4418      	add	r0, r3
		}
	}

	return NULL;
}
   10aec:	bd08      	pop	{r3, pc}
		if (sercomspi_regs[i].n == n) {
   10aee:	2300      	movs	r3, #0
   10af0:	e7f8      	b.n	10ae4 <_spi_get_regs+0x10>
	return NULL;
   10af2:	2000      	movs	r0, #0
   10af4:	e7fa      	b.n	10aec <_spi_get_regs+0x18>
   10af6:	bf00      	nop
   10af8:	00010991 	.word	0x00010991
   10afc:	000175bc 	.word	0x000175bc

00010b00 <_spi_dma_tx_complete>:
 */
static void _spi_dma_tx_complete(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.tx) {
   10b00:	6883      	ldr	r3, [r0, #8]
   10b02:	685b      	ldr	r3, [r3, #4]
   10b04:	b103      	cbz	r3, 10b08 <_spi_dma_tx_complete+0x8>
		dev->callbacks.tx(resource);
   10b06:	4718      	bx	r3
	}
}
   10b08:	4770      	bx	lr

00010b0a <_spi_dma_error_occured>:
 */
static void _spi_dma_error_occured(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.error) {
   10b0a:	6883      	ldr	r3, [r0, #8]
   10b0c:	68db      	ldr	r3, [r3, #12]
   10b0e:	b103      	cbz	r3, 10b12 <_spi_dma_error_occured+0x8>
		dev->callbacks.error(resource);
   10b10:	4718      	bx	r3
	}
}
   10b12:	4770      	bx	lr

00010b14 <__NVIC_EnableIRQ>:
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10b14:	0942      	lsrs	r2, r0, #5
   10b16:	2301      	movs	r3, #1
   10b18:	f000 001f 	and.w	r0, r0, #31
   10b1c:	fa03 f000 	lsl.w	r0, r3, r0
   10b20:	4b01      	ldr	r3, [pc, #4]	; (10b28 <__NVIC_EnableIRQ+0x14>)
   10b22:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
   10b26:	4770      	bx	lr
   10b28:	e000e100 	.word	0xe000e100

00010b2c <_spi_async_enable>:
{
   10b2c:	b538      	push	{r3, r4, r5, lr}
   10b2e:	4604      	mov	r4, r0
	_spi_sync_enable(hw);
   10b30:	4b07      	ldr	r3, [pc, #28]	; (10b50 <_spi_async_enable+0x24>)
		NVIC_EnableIRQ((IRQn_Type)irq++);
   10b32:	4d08      	ldr	r5, [pc, #32]	; (10b54 <_spi_async_enable+0x28>)
	_spi_sync_enable(hw);
   10b34:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   10b36:	4620      	mov	r0, r4
   10b38:	4b07      	ldr	r3, [pc, #28]	; (10b58 <_spi_async_enable+0x2c>)
   10b3a:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   10b3c:	2100      	movs	r1, #0
	uint8_t irq = _sercom_get_irq_num(hw);
   10b3e:	4604      	mov	r4, r0
		NVIC_EnableIRQ((IRQn_Type)irq++);
   10b40:	1860      	adds	r0, r4, r1
   10b42:	b2c0      	uxtb	r0, r0
   10b44:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   10b46:	3101      	adds	r1, #1
   10b48:	2904      	cmp	r1, #4
   10b4a:	d1f9      	bne.n	10b40 <_spi_async_enable+0x14>
}
   10b4c:	2000      	movs	r0, #0
   10b4e:	bd38      	pop	{r3, r4, r5, pc}
   10b50:	00010aad 	.word	0x00010aad
   10b54:	00010b15 	.word	0x00010b15
   10b58:	00010a99 	.word	0x00010a99

00010b5c <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10b5c:	0943      	lsrs	r3, r0, #5
   10b5e:	2201      	movs	r2, #1
   10b60:	f000 001f 	and.w	r0, r0, #31
   10b64:	fa02 f000 	lsl.w	r0, r2, r0
   10b68:	3320      	adds	r3, #32
   10b6a:	4a04      	ldr	r2, [pc, #16]	; (10b7c <__NVIC_DisableIRQ+0x20>)
   10b6c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   10b70:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   10b74:	f3bf 8f6f 	isb	sy
}
   10b78:	4770      	bx	lr
   10b7a:	bf00      	nop
   10b7c:	e000e100 	.word	0xe000e100

00010b80 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10b80:	0943      	lsrs	r3, r0, #5
   10b82:	2201      	movs	r2, #1
   10b84:	f000 001f 	and.w	r0, r0, #31
   10b88:	fa02 f000 	lsl.w	r0, r2, r0
   10b8c:	3360      	adds	r3, #96	; 0x60
   10b8e:	4a02      	ldr	r2, [pc, #8]	; (10b98 <__NVIC_ClearPendingIRQ+0x18>)
   10b90:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   10b94:	4770      	bx	lr
   10b96:	bf00      	nop
   10b98:	e000e100 	.word	0xe000e100

00010b9c <_get_i2cm_index>:
{
   10b9c:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10b9e:	4b07      	ldr	r3, [pc, #28]	; (10bbc <_get_i2cm_index+0x20>)
   10ba0:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
   10ba2:	2805      	cmp	r0, #5
   10ba4:	d008      	beq.n	10bb8 <_get_i2cm_index+0x1c>
	ASSERT(false);
   10ba6:	2000      	movs	r0, #0
   10ba8:	4905      	ldr	r1, [pc, #20]	; (10bc0 <_get_i2cm_index+0x24>)
   10baa:	4b06      	ldr	r3, [pc, #24]	; (10bc4 <_get_i2cm_index+0x28>)
   10bac:	f240 32ed 	movw	r2, #1005	; 0x3ed
   10bb0:	4798      	blx	r3
   10bb2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   10bb6:	bd08      	pop	{r3, pc}
			return i;
   10bb8:	2000      	movs	r0, #0
   10bba:	e7fc      	b.n	10bb6 <_get_i2cm_index+0x1a>
   10bbc:	00010991 	.word	0x00010991
   10bc0:	00017581 	.word	0x00017581
   10bc4:	0000e08d 	.word	0x0000e08d

00010bc8 <_sercom_i2c_send_stop>:
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10bc8:	6842      	ldr	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10bca:	4b03      	ldr	r3, [pc, #12]	; (10bd8 <_sercom_i2c_send_stop+0x10>)
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10bcc:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
   10bd0:	6042      	str	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10bd2:	2104      	movs	r1, #4
   10bd4:	4718      	bx	r3
   10bd6:	bf00      	nop
   10bd8:	00010911 	.word	0x00010911

00010bdc <_sercom_i2c_sync_analyse_flags>:
{
   10bdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10be0:	460e      	mov	r6, r1
   10be2:	4614      	mov	r4, r2
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10be4:	2104      	movs	r1, #4
   10be6:	4a56      	ldr	r2, [pc, #344]	; (10d40 <_sercom_i2c_sync_analyse_flags+0x164>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10be8:	f8d0 8000 	ldr.w	r8, [r0]
   10bec:	4605      	mov	r5, r0
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10bee:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.STATUS.reg;
   10bf0:	8b43      	ldrh	r3, [r0, #26]
	if (flags & MB_FLAG) {
   10bf2:	f016 0f01 	tst.w	r6, #1
   10bf6:	b29b      	uxth	r3, r3
   10bf8:	4617      	mov	r7, r2
   10bfa:	d064      	beq.n	10cc6 <_sercom_i2c_sync_analyse_flags+0xea>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
   10bfc:	079f      	lsls	r7, r3, #30
   10bfe:	d516      	bpl.n	10c2e <_sercom_i2c_sync_analyse_flags+0x52>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
   10c00:	2201      	movs	r2, #1
   10c02:	7602      	strb	r2, [r0, #24]
			msg->flags |= I2C_M_FAIL;
   10c04:	8862      	ldrh	r2, [r4, #2]
   10c06:	b292      	uxth	r2, r2
   10c08:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   10c0c:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
   10c0e:	8862      	ldrh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10c10:	f003 0601 	and.w	r6, r3, #1
			msg->flags &= ~I2C_M_BUSY;
   10c14:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   10c18:	0412      	lsls	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10c1a:	f1c6 26ff 	rsb	r6, r6, #4278255360	; 0xff00ff00
			msg->flags &= ~I2C_M_BUSY;
   10c1e:	0c12      	lsrs	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10c20:	f506 067f 	add.w	r6, r6, #16711680	; 0xff0000
			msg->flags &= ~I2C_M_BUSY;
   10c24:	8062      	strh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10c26:	36fc      	adds	r6, #252	; 0xfc
}
   10c28:	4630      	mov	r0, r6
   10c2a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
   10c2e:	f013 0604 	ands.w	r6, r3, #4
   10c32:	d015      	beq.n	10c60 <_sercom_i2c_sync_analyse_flags+0x84>
				if (msg->len > 0) {
   10c34:	6863      	ldr	r3, [r4, #4]
   10c36:	2b00      	cmp	r3, #0
					msg->flags |= I2C_M_FAIL;
   10c38:	bfc1      	itttt	gt
   10c3a:	8863      	ldrhgt	r3, [r4, #2]
   10c3c:	b29b      	uxthgt	r3, r3
   10c3e:	f443 5380 	orrgt.w	r3, r3, #4096	; 0x1000
   10c42:	8063      	strhgt	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
   10c44:	8863      	ldrh	r3, [r4, #2]
   10c46:	041e      	lsls	r6, r3, #16
   10c48:	d501      	bpl.n	10c4e <_sercom_i2c_sync_analyse_flags+0x72>
					_sercom_i2c_send_stop(hw);
   10c4a:	4b3e      	ldr	r3, [pc, #248]	; (10d44 <_sercom_i2c_sync_analyse_flags+0x168>)
   10c4c:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10c4e:	8863      	ldrh	r3, [r4, #2]
   10c50:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10c54:	041b      	lsls	r3, r3, #16
   10c56:	0c1b      	lsrs	r3, r3, #16
   10c58:	8063      	strh	r3, [r4, #2]
			return I2C_NACK;
   10c5a:	f06f 0601 	mvn.w	r6, #1
   10c5e:	e7e3      	b.n	10c28 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->flags & I2C_M_TEN) {
   10c60:	8863      	ldrh	r3, [r4, #2]
   10c62:	f413 6780 	ands.w	r7, r3, #1024	; 0x400
   10c66:	d015      	beq.n	10c94 <_sercom_i2c_sync_analyse_flags+0xb8>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
   10c68:	8823      	ldrh	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10c6a:	2104      	movs	r1, #4
   10c6c:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   10c6e:	f003 0706 	and.w	r7, r3, #6
   10c72:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   10c74:	6a43      	ldr	r3, [r0, #36]	; 0x24
   10c76:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   10c7a:	433b      	orrs	r3, r7
				hri_sercomi2cm_write_ADDR_reg(hw,
   10c7c:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   10c80:	6243      	str	r3, [r0, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10c82:	2104      	movs	r1, #4
   10c84:	4790      	blx	r2
				msg->flags &= ~I2C_M_TEN;
   10c86:	8863      	ldrh	r3, [r4, #2]
   10c88:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
				msg->flags &= ~I2C_M_BUSY;
   10c8c:	041b      	lsls	r3, r3, #16
   10c8e:	0c1b      	lsrs	r3, r3, #16
   10c90:	8063      	strh	r3, [r4, #2]
   10c92:	e7c9      	b.n	10c28 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->len == 0) {
   10c94:	6866      	ldr	r6, [r4, #4]
   10c96:	b94e      	cbnz	r6, 10cac <_sercom_i2c_sync_analyse_flags+0xd0>
				if (msg->flags & I2C_M_STOP) {
   10c98:	8863      	ldrh	r3, [r4, #2]
   10c9a:	0418      	lsls	r0, r3, #16
   10c9c:	d502      	bpl.n	10ca4 <_sercom_i2c_sync_analyse_flags+0xc8>
					_sercom_i2c_send_stop(hw);
   10c9e:	4b29      	ldr	r3, [pc, #164]	; (10d44 <_sercom_i2c_sync_analyse_flags+0x168>)
   10ca0:	4628      	mov	r0, r5
   10ca2:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10ca4:	8863      	ldrh	r3, [r4, #2]
   10ca6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10caa:	e7ef      	b.n	10c8c <_sercom_i2c_sync_analyse_flags+0xb0>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
   10cac:	68a3      	ldr	r3, [r4, #8]
   10cae:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
   10cb0:	6283      	str	r3, [r0, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10cb2:	2104      	movs	r1, #4
   10cb4:	4790      	blx	r2
				msg->buffer++;
   10cb6:	68a3      	ldr	r3, [r4, #8]
   10cb8:	3301      	adds	r3, #1
   10cba:	60a3      	str	r3, [r4, #8]
				msg->len--;
   10cbc:	6863      	ldr	r3, [r4, #4]
   10cbe:	3b01      	subs	r3, #1
   10cc0:	6063      	str	r3, [r4, #4]
	return I2C_OK;
   10cc2:	2600      	movs	r6, #0
}
   10cc4:	e7b0      	b.n	10c28 <_sercom_i2c_sync_analyse_flags+0x4c>
	} else if (flags & SB_FLAG) {
   10cc6:	f016 0602 	ands.w	r6, r6, #2
   10cca:	d0ad      	beq.n	10c28 <_sercom_i2c_sync_analyse_flags+0x4c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
   10ccc:	6862      	ldr	r2, [r4, #4]
   10cce:	2a00      	cmp	r2, #0
   10cd0:	d032      	beq.n	10d38 <_sercom_i2c_sync_analyse_flags+0x15c>
   10cd2:	0759      	lsls	r1, r3, #29
   10cd4:	d430      	bmi.n	10d38 <_sercom_i2c_sync_analyse_flags+0x15c>
			msg->len--;
   10cd6:	3a01      	subs	r2, #1
   10cd8:	f3c8 61c0 	ubfx	r1, r8, #27, #1
   10cdc:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   10cde:	b99a      	cbnz	r2, 10d08 <_sercom_i2c_sync_analyse_flags+0x12c>
   10ce0:	b1a9      	cbz	r1, 10d0e <_sercom_i2c_sync_analyse_flags+0x132>
				if (msg->flags & I2C_M_STOP) {
   10ce2:	8863      	ldrh	r3, [r4, #2]
   10ce4:	041b      	lsls	r3, r3, #16
   10ce6:	d508      	bpl.n	10cfa <_sercom_i2c_sync_analyse_flags+0x11e>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
   10ce8:	686b      	ldr	r3, [r5, #4]
   10cea:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10cee:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10cf0:	2104      	movs	r1, #4
   10cf2:	4628      	mov	r0, r5
   10cf4:	47b8      	blx	r7
					_sercom_i2c_send_stop(hw);
   10cf6:	4b13      	ldr	r3, [pc, #76]	; (10d44 <_sercom_i2c_sync_analyse_flags+0x168>)
   10cf8:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10cfa:	8863      	ldrh	r3, [r4, #2]
   10cfc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10d00:	041b      	lsls	r3, r3, #16
   10d02:	0c1b      	lsrs	r3, r3, #16
   10d04:	8063      	strh	r3, [r4, #2]
   10d06:	e00c      	b.n	10d22 <_sercom_i2c_sync_analyse_flags+0x146>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   10d08:	2a01      	cmp	r2, #1
   10d0a:	d10a      	bne.n	10d22 <_sercom_i2c_sync_analyse_flags+0x146>
   10d0c:	b149      	cbz	r1, 10d22 <_sercom_i2c_sync_analyse_flags+0x146>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   10d0e:	686b      	ldr	r3, [r5, #4]
   10d10:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   10d14:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10d16:	2104      	movs	r1, #4
   10d18:	4628      	mov	r0, r5
   10d1a:	47b8      	blx	r7
			if (msg->len == 0) {
   10d1c:	6863      	ldr	r3, [r4, #4]
   10d1e:	2b00      	cmp	r3, #0
   10d20:	d0df      	beq.n	10ce2 <_sercom_i2c_sync_analyse_flags+0x106>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10d22:	2104      	movs	r1, #4
   10d24:	4628      	mov	r0, r5
   10d26:	47b8      	blx	r7
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
   10d28:	68a3      	ldr	r3, [r4, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
   10d2a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   10d2c:	1c59      	adds	r1, r3, #1
   10d2e:	60a1      	str	r1, [r4, #8]
   10d30:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   10d32:	2302      	movs	r3, #2
   10d34:	762b      	strb	r3, [r5, #24]
   10d36:	e7c4      	b.n	10cc2 <_sercom_i2c_sync_analyse_flags+0xe6>
   10d38:	2302      	movs	r3, #2
   10d3a:	762b      	strb	r3, [r5, #24]
   10d3c:	e78d      	b.n	10c5a <_sercom_i2c_sync_analyse_flags+0x7e>
   10d3e:	bf00      	nop
   10d40:	00010911 	.word	0x00010911
   10d44:	00010bc9 	.word	0x00010bc9

00010d48 <_usart_set_parity>:
{
   10d48:	b573      	push	{r0, r1, r4, r5, r6, lr}
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10d4a:	4b16      	ldr	r3, [pc, #88]	; (10da4 <_usart_set_parity+0x5c>)
{
   10d4c:	4604      	mov	r4, r0
   10d4e:	460d      	mov	r5, r1
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10d50:	4798      	blx	r3
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10d52:	4b15      	ldr	r3, [pc, #84]	; (10da8 <_usart_set_parity+0x60>)
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10d54:	4606      	mov	r6, r0
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10d56:	4620      	mov	r0, r4
   10d58:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
   10d5a:	4b14      	ldr	r3, [pc, #80]	; (10dac <_usart_set_parity+0x64>)
   10d5c:	a801      	add	r0, sp, #4
   10d5e:	4798      	blx	r3
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   10d60:	4a13      	ldr	r2, [pc, #76]	; (10db0 <_usart_set_parity+0x68>)
   10d62:	4620      	mov	r0, r4
   10d64:	2102      	movs	r1, #2
   10d66:	4790      	blx	r2
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_FORM(mask);
   10d68:	6823      	ldr	r3, [r4, #0]
	if (USART_PARITY_NONE != parity) {
   10d6a:	2d02      	cmp	r5, #2
   10d6c:	bf14      	ite	ne
   10d6e:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_FORM(mask);
   10d72:	f023 7380 	biceq.w	r3, r3, #16777216	; 0x1000000
   10d76:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10d78:	211f      	movs	r1, #31
   10d7a:	4790      	blx	r2
	tmp = ((Sercom *)hw)->USART.CTRLB.reg;
   10d7c:	6863      	ldr	r3, [r4, #4]
	hri_sercomusart_write_CTRLB_PMODE_bit(hw, parity);
   10d7e:	3d00      	subs	r5, #0
   10d80:	bf18      	it	ne
   10d82:	2501      	movne	r5, #1
	tmp &= ~SERCOM_USART_CTRLB_PMODE;
   10d84:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
	tmp |= value << SERCOM_USART_CTRLB_PMODE_Pos;
   10d88:	ea43 3545 	orr.w	r5, r3, r5, lsl #13
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10d8c:	211f      	movs	r1, #31
	((Sercom *)hw)->USART.CTRLB.reg = tmp;
   10d8e:	6065      	str	r5, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10d90:	4790      	blx	r2
	CRITICAL_SECTION_LEAVE()
   10d92:	a801      	add	r0, sp, #4
   10d94:	4b07      	ldr	r3, [pc, #28]	; (10db4 <_usart_set_parity+0x6c>)
   10d96:	4798      	blx	r3
	hri_sercomusart_write_CTRLA_ENABLE_bit(hw, enabled);
   10d98:	4b07      	ldr	r3, [pc, #28]	; (10db8 <_usart_set_parity+0x70>)
   10d9a:	4631      	mov	r1, r6
   10d9c:	4620      	mov	r0, r4
   10d9e:	4798      	blx	r3
}
   10da0:	b002      	add	sp, #8
   10da2:	bd70      	pop	{r4, r5, r6, pc}
   10da4:	00010951 	.word	0x00010951
   10da8:	0001097d 	.word	0x0001097d
   10dac:	00011b59 	.word	0x00011b59
   10db0:	00010921 	.word	0x00010921
   10db4:	00011b67 	.word	0x00011b67
   10db8:	00010965 	.word	0x00010965

00010dbc <_spi_set_mode>:
{
   10dbc:	b570      	push	{r4, r5, r6, lr}
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10dbe:	69c4      	ldr	r4, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   10dc0:	f014 0403 	ands.w	r4, r4, #3
{
   10dc4:	460a      	mov	r2, r1
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   10dc6:	d10e      	bne.n	10de6 <_spi_set_mode+0x2a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10dc8:	4e08      	ldr	r6, [pc, #32]	; (10dec <_spi_set_mode+0x30>)
   10dca:	2103      	movs	r1, #3
   10dcc:	47b0      	blx	r6
	return ((Sercom *)hw)->SPI.CTRLA.reg;
   10dce:	6803      	ldr	r3, [r0, #0]
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   10dd0:	0712      	lsls	r2, r2, #28
	ctrla &= ~(SERCOM_SPI_CTRLA_CPOL | SERCOM_SPI_CTRLA_CPHA);
   10dd2:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   10dd6:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
   10dda:	431a      	orrs	r2, r3
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   10ddc:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10dde:	2103      	movs	r1, #3
   10de0:	47b0      	blx	r6
	return ERR_NONE;
   10de2:	4620      	mov	r0, r4
}
   10de4:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
   10de6:	f06f 0003 	mvn.w	r0, #3
   10dea:	e7fb      	b.n	10de4 <_spi_set_mode+0x28>
   10dec:	00010919 	.word	0x00010919

00010df0 <_spi_load_regs_master>:
{
   10df0:	b538      	push	{r3, r4, r5, lr}
   10df2:	460d      	mov	r5, r1
	ASSERT(hw && regs);
   10df4:	4604      	mov	r4, r0
   10df6:	b110      	cbz	r0, 10dfe <_spi_load_regs_master+0xe>
   10df8:	1e08      	subs	r0, r1, #0
   10dfa:	bf18      	it	ne
   10dfc:	2001      	movne	r0, #1
   10dfe:	490f      	ldr	r1, [pc, #60]	; (10e3c <_spi_load_regs_master+0x4c>)
   10e00:	4b0f      	ldr	r3, [pc, #60]	; (10e40 <_spi_load_regs_master+0x50>)
   10e02:	f640 127a 	movw	r2, #2426	; 0x97a
   10e06:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   10e08:	682b      	ldr	r3, [r5, #0]
   10e0a:	4a0e      	ldr	r2, [pc, #56]	; (10e44 <_spi_load_regs_master+0x54>)
	hri_sercomspi_write_CTRLA_reg(
   10e0c:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   10e10:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   10e14:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10e16:	2103      	movs	r1, #3
   10e18:	4620      	mov	r0, r4
   10e1a:	4790      	blx	r2
	    (regs->ctrlb
   10e1c:	686b      	ldr	r3, [r5, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
   10e1e:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
   10e22:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
   10e26:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   10e2a:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   10e2c:	2117      	movs	r1, #23
   10e2e:	4790      	blx	r2
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
   10e30:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
   10e32:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   10e34:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   10e36:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
   10e3a:	bd38      	pop	{r3, r4, r5, pc}
   10e3c:	00017581 	.word	0x00017581
   10e40:	0000e08d 	.word	0x0000e08d
   10e44:	00010919 	.word	0x00010919

00010e48 <_i2c_m_sync_init_impl>:
{
   10e48:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10e4c:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
   10e4e:	4b23      	ldr	r3, [pc, #140]	; (10edc <_i2c_m_sync_init_impl+0x94>)
   10e50:	f8df 9094 	ldr.w	r9, [pc, #148]	; 10ee8 <_i2c_m_sync_init_impl+0xa0>
   10e54:	4d22      	ldr	r5, [pc, #136]	; (10ee0 <_i2c_m_sync_init_impl+0x98>)
{
   10e56:	4607      	mov	r7, r0
	uint8_t i = _get_i2cm_index(hw);
   10e58:	4608      	mov	r0, r1
   10e5a:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
   10e5c:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
   10e5e:	f013 0f01 	tst.w	r3, #1
   10e62:	fa5f f880 	uxtb.w	r8, r0
   10e66:	d115      	bne.n	10e94 <_i2c_m_sync_init_impl+0x4c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   10e68:	2318      	movs	r3, #24
   10e6a:	fb03 9308 	mla	r3, r3, r8, r9
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e6e:	2103      	movs	r1, #3
   10e70:	4620      	mov	r0, r4
   10e72:	6c9e      	ldr	r6, [r3, #72]	; 0x48
   10e74:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10e76:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   10e78:	079b      	lsls	r3, r3, #30
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   10e7a:	f006 061c 	and.w	r6, r6, #28
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   10e7e:	d503      	bpl.n	10e88 <_i2c_m_sync_init_impl+0x40>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
   10e80:	4b18      	ldr	r3, [pc, #96]	; (10ee4 <_i2c_m_sync_init_impl+0x9c>)
   10e82:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e84:	2102      	movs	r1, #2
   10e86:	47a8      	blx	r5
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
   10e88:	f046 0601 	orr.w	r6, r6, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   10e8c:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10e8e:	2103      	movs	r1, #3
   10e90:	4620      	mov	r0, r4
   10e92:	47a8      	blx	r5
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
   10e94:	4620      	mov	r0, r4
   10e96:	2101      	movs	r1, #1
   10e98:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
   10e9a:	2218      	movs	r2, #24
   10e9c:	fb02 9208 	mla	r2, r2, r8, r9
   10ea0:	2103      	movs	r1, #3
   10ea2:	6c96      	ldr	r6, [r2, #72]	; 0x48
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   10ea4:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10ea6:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
   10ea8:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
   10eaa:	6063      	str	r3, [r4, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10eac:	2104      	movs	r1, #4
   10eae:	47a8      	blx	r5
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
   10eb0:	6d13      	ldr	r3, [r2, #80]	; 0x50
	((Sercom *)hw)->I2CM.BAUD.reg = data;
   10eb2:	60e3      	str	r3, [r4, #12]
	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
   10eb4:	f3c6 6301 	ubfx	r3, r6, #24, #2
   10eb8:	81bb      	strh	r3, [r7, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
   10eba:	6a63      	ldr	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
   10ebc:	f3c6 6640 	ubfx	r6, r6, #25, #1
	tmp &= ~SERCOM_I2CM_ADDR_HS;
   10ec0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
   10ec4:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
   10ec8:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10eca:	2104      	movs	r1, #4
   10ecc:	47a8      	blx	r5
	service->trise = _i2cms[i].trise;
   10ece:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
   10ed2:	81fb      	strh	r3, [r7, #14]
}
   10ed4:	2000      	movs	r0, #0
   10ed6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10eda:	bf00      	nop
   10edc:	00010b9d 	.word	0x00010b9d
   10ee0:	00010911 	.word	0x00010911
   10ee4:	00010929 	.word	0x00010929
   10ee8:	0001759c 	.word	0x0001759c

00010eec <_usart_init>:
{
   10eec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10ef0:	4b2d      	ldr	r3, [pc, #180]	; (10fa8 <_usart_init+0xbc>)
{
   10ef2:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10ef4:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
   10ef6:	4605      	mov	r5, r0
   10ef8:	b170      	cbz	r0, 10f18 <_usart_init+0x2c>
   10efa:	2801      	cmp	r0, #1
   10efc:	d00c      	beq.n	10f18 <_usart_init+0x2c>
   10efe:	2802      	cmp	r0, #2
   10f00:	d00a      	beq.n	10f18 <_usart_init+0x2c>
   10f02:	2804      	cmp	r0, #4
   10f04:	d04b      	beq.n	10f9e <_usart_init+0xb2>
   10f06:	2806      	cmp	r0, #6
   10f08:	d04b      	beq.n	10fa2 <_usart_init+0xb6>
	ASSERT(false);
   10f0a:	4928      	ldr	r1, [pc, #160]	; (10fac <_usart_init+0xc0>)
   10f0c:	4b28      	ldr	r3, [pc, #160]	; (10fb0 <_usart_init+0xc4>)
   10f0e:	f240 2276 	movw	r2, #630	; 0x276
   10f12:	2000      	movs	r0, #0
   10f14:	4798      	blx	r3
	return 0;
   10f16:	2500      	movs	r5, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
   10f18:	69e3      	ldr	r3, [r4, #28]
   10f1a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 10fbc <_usart_init+0xd0>
   10f1e:	4e25      	ldr	r6, [pc, #148]	; (10fb4 <_usart_init+0xc8>)
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
   10f20:	f013 0f01 	tst.w	r3, #1
   10f24:	d115      	bne.n	10f52 <_usart_init+0x66>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   10f26:	2318      	movs	r3, #24
   10f28:	fb03 8305 	mla	r3, r3, r5, r8
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10f2c:	2103      	movs	r1, #3
   10f2e:	4620      	mov	r0, r4
   10f30:	6e1f      	ldr	r7, [r3, #96]	; 0x60
   10f32:	47b0      	blx	r6
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10f34:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   10f36:	079b      	lsls	r3, r3, #30
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   10f38:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   10f3c:	d503      	bpl.n	10f46 <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10f3e:	4b1e      	ldr	r3, [pc, #120]	; (10fb8 <_usart_init+0xcc>)
   10f40:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   10f42:	2102      	movs	r1, #2
   10f44:	47b0      	blx	r6
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
   10f46:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
   10f4a:	6027      	str	r7, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10f4c:	2103      	movs	r1, #3
   10f4e:	4620      	mov	r0, r4
   10f50:	47b0      	blx	r6
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
   10f52:	2101      	movs	r1, #1
   10f54:	4620      	mov	r0, r4
   10f56:	47b0      	blx	r6
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
   10f58:	2018      	movs	r0, #24
   10f5a:	fb00 8505 	mla	r5, r0, r5, r8
   10f5e:	2103      	movs	r1, #3
   10f60:	6e2a      	ldr	r2, [r5, #96]	; 0x60
	((Sercom *)hw)->USART.CTRLA.reg = data;
   10f62:	6022      	str	r2, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10f64:	4620      	mov	r0, r4
   10f66:	47b0      	blx	r6
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
   10f68:	6e6b      	ldr	r3, [r5, #100]	; 0x64
	((Sercom *)hw)->USART.CTRLB.reg = data;
   10f6a:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10f6c:	211f      	movs	r1, #31
   10f6e:	47b0      	blx	r6
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
   10f70:	6eab      	ldr	r3, [r5, #104]	; 0x68
	((Sercom *)hw)->USART.CTRLC.reg = data;
   10f72:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
   10f74:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
   10f78:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
   10f7c:	d008      	beq.n	10f90 <_usart_init+0xa4>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
   10f7e:	89a2      	ldrh	r2, [r4, #12]
   10f80:	f363 020c 	bfi	r2, r3, #0, #13
   10f84:	81a2      	strh	r2, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
   10f86:	89a3      	ldrh	r3, [r4, #12]
   10f88:	f895 206e 	ldrb.w	r2, [r5, #110]	; 0x6e
   10f8c:	f362 334f 	bfi	r3, r2, #13, #3
	((Sercom *)hw)->USART.RXPL.reg = data;
   10f90:	2000      	movs	r0, #0
	((Sercom *)hw)->USART.BAUD.reg = data;
   10f92:	81a3      	strh	r3, [r4, #12]
	((Sercom *)hw)->USART.RXPL.reg = data;
   10f94:	73a0      	strb	r0, [r4, #14]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
   10f96:	f884 0030 	strb.w	r0, [r4, #48]	; 0x30
}
   10f9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
   10f9e:	2503      	movs	r5, #3
   10fa0:	e7ba      	b.n	10f18 <_usart_init+0x2c>
   10fa2:	2504      	movs	r5, #4
   10fa4:	e7b8      	b.n	10f18 <_usart_init+0x2c>
   10fa6:	bf00      	nop
   10fa8:	00010991 	.word	0x00010991
   10fac:	00017581 	.word	0x00017581
   10fb0:	0000e08d 	.word	0x0000e08d
   10fb4:	00010921 	.word	0x00010921
   10fb8:	0001097d 	.word	0x0001097d
   10fbc:	0001759c 	.word	0x0001759c

00010fc0 <_usart_sync_init>:
{
   10fc0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   10fc2:	4605      	mov	r5, r0
   10fc4:	3800      	subs	r0, #0
{
   10fc6:	460c      	mov	r4, r1
	ASSERT(device);
   10fc8:	4b05      	ldr	r3, [pc, #20]	; (10fe0 <_usart_sync_init+0x20>)
   10fca:	4906      	ldr	r1, [pc, #24]	; (10fe4 <_usart_sync_init+0x24>)
   10fcc:	bf18      	it	ne
   10fce:	2001      	movne	r0, #1
   10fd0:	22c8      	movs	r2, #200	; 0xc8
   10fd2:	4798      	blx	r3
	device->hw = hw;
   10fd4:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
   10fd6:	4620      	mov	r0, r4
   10fd8:	4b03      	ldr	r3, [pc, #12]	; (10fe8 <_usart_sync_init+0x28>)
}
   10fda:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
   10fde:	4718      	bx	r3
   10fe0:	0000e08d 	.word	0x0000e08d
   10fe4:	00017581 	.word	0x00017581
   10fe8:	00010eed 	.word	0x00010eed

00010fec <_usart_async_init>:
{
   10fec:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(device);
   10ff0:	4606      	mov	r6, r0
   10ff2:	3800      	subs	r0, #0
   10ff4:	bf18      	it	ne
   10ff6:	2001      	movne	r0, #1
   10ff8:	4b12      	ldr	r3, [pc, #72]	; (11044 <_usart_async_init+0x58>)
{
   10ffa:	460c      	mov	r4, r1
	ASSERT(device);
   10ffc:	22d6      	movs	r2, #214	; 0xd6
   10ffe:	4912      	ldr	r1, [pc, #72]	; (11048 <_usart_async_init+0x5c>)
   11000:	4798      	blx	r3
	init_status = _usart_init(hw);
   11002:	4b12      	ldr	r3, [pc, #72]	; (1104c <_usart_async_init+0x60>)
   11004:	4620      	mov	r0, r4
   11006:	4798      	blx	r3
	if (init_status) {
   11008:	4605      	mov	r5, r0
   1100a:	b9b8      	cbnz	r0, 1103c <_usart_async_init+0x50>
	_sercom_init_irq_param(hw, (void *)device);
   1100c:	4631      	mov	r1, r6
	device->hw = hw;
   1100e:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
   11010:	4620      	mov	r0, r4
   11012:	4b0f      	ldr	r3, [pc, #60]	; (11050 <_usart_async_init+0x64>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11014:	f8df 8048 	ldr.w	r8, [pc, #72]	; 11060 <_usart_async_init+0x74>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11018:	4f0e      	ldr	r7, [pc, #56]	; (11054 <_usart_async_init+0x68>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   1101a:	4e0f      	ldr	r6, [pc, #60]	; (11058 <_usart_async_init+0x6c>)
	_sercom_init_irq_param(hw, (void *)device);
   1101c:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   1101e:	4b0f      	ldr	r3, [pc, #60]	; (1105c <_usart_async_init+0x70>)
   11020:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11022:	4629      	mov	r1, r5
	uint8_t irq = _sercom_get_irq_num(hw);
   11024:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11026:	1863      	adds	r3, r4, r1
   11028:	b2d8      	uxtb	r0, r3
   1102a:	9001      	str	r0, [sp, #4]
   1102c:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1102e:	9801      	ldr	r0, [sp, #4]
   11030:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   11032:	9801      	ldr	r0, [sp, #4]
   11034:	47b0      	blx	r6
	for (uint32_t i = 0; i < 4; i++) {
   11036:	3101      	adds	r1, #1
   11038:	2904      	cmp	r1, #4
   1103a:	d1f4      	bne.n	11026 <_usart_async_init+0x3a>
}
   1103c:	4628      	mov	r0, r5
   1103e:	b002      	add	sp, #8
   11040:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11044:	0000e08d 	.word	0x0000e08d
   11048:	00017581 	.word	0x00017581
   1104c:	00010eed 	.word	0x00010eed
   11050:	00010a39 	.word	0x00010a39
   11054:	00010b81 	.word	0x00010b81
   11058:	00010b15 	.word	0x00010b15
   1105c:	00010a99 	.word	0x00010a99
   11060:	00010b5d 	.word	0x00010b5d

00011064 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11064:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   11066:	6803      	ldr	r3, [r0, #0]
   11068:	f043 0302 	orr.w	r3, r3, #2
   1106c:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1106e:	2103      	movs	r1, #3
   11070:	4b00      	ldr	r3, [pc, #0]	; (11074 <_usart_sync_enable+0x10>)
   11072:	4718      	bx	r3
   11074:	00010921 	.word	0x00010921

00011078 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11078:	6980      	ldr	r0, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   1107a:	6803      	ldr	r3, [r0, #0]
   1107c:	f043 0302 	orr.w	r3, r3, #2
   11080:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11082:	2103      	movs	r1, #3
   11084:	4b00      	ldr	r3, [pc, #0]	; (11088 <_usart_async_enable+0x10>)
   11086:	4718      	bx	r3
   11088:	00010921 	.word	0x00010921

0001108c <_usart_async_disable>:
	hri_sercomusart_clear_CTRLA_ENABLE_bit(device->hw);
   1108c:	6980      	ldr	r0, [r0, #24]
   1108e:	4b01      	ldr	r3, [pc, #4]	; (11094 <_usart_async_disable+0x8>)
   11090:	4718      	bx	r3
   11092:	bf00      	nop
   11094:	0001097d 	.word	0x0001097d

00011098 <_usart_async_set_parity>:
	_usart_set_parity(device->hw, parity);
   11098:	6980      	ldr	r0, [r0, #24]
   1109a:	4b01      	ldr	r3, [pc, #4]	; (110a0 <_usart_async_set_parity+0x8>)
   1109c:	4718      	bx	r3
   1109e:	bf00      	nop
   110a0:	00010d49 	.word	0x00010d49

000110a4 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   110a4:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
   110a6:	6299      	str	r1, [r3, #40]	; 0x28
}
   110a8:	4770      	bx	lr

000110aa <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   110aa:	6983      	ldr	r3, [r0, #24]
   110ac:	6299      	str	r1, [r3, #40]	; 0x28
}
   110ae:	4770      	bx	lr

000110b0 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
   110b0:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
   110b2:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   110b4:	b2c0      	uxtb	r0, r0
   110b6:	4770      	bx	lr

000110b8 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
   110b8:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   110ba:	7e18      	ldrb	r0, [r3, #24]
}
   110bc:	f000 0001 	and.w	r0, r0, #1
   110c0:	4770      	bx	lr

000110c2 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
   110c2:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   110c4:	7e18      	ldrb	r0, [r3, #24]
}
   110c6:	f3c0 0040 	ubfx	r0, r0, #1, #1
   110ca:	4770      	bx	lr

000110cc <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
   110cc:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   110ce:	7e18      	ldrb	r0, [r3, #24]
}
   110d0:	f3c0 0080 	ubfx	r0, r0, #2, #1
   110d4:	4770      	bx	lr

000110d6 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
   110d6:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   110d8:	2201      	movs	r2, #1
   110da:	759a      	strb	r2, [r3, #22]
}
   110dc:	4770      	bx	lr

000110de <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
   110de:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
   110e0:	2202      	movs	r2, #2
   110e2:	759a      	strb	r2, [r3, #22]
}
   110e4:	4770      	bx	lr
	...

000110e8 <_usart_async_set_irq_state>:
{
   110e8:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   110ea:	4604      	mov	r4, r0
   110ec:	3800      	subs	r0, #0
{
   110ee:	460e      	mov	r6, r1
	ASSERT(device);
   110f0:	bf18      	it	ne
   110f2:	2001      	movne	r0, #1
   110f4:	490f      	ldr	r1, [pc, #60]	; (11134 <_usart_async_set_irq_state+0x4c>)
   110f6:	4b10      	ldr	r3, [pc, #64]	; (11138 <_usart_async_set_irq_state+0x50>)
{
   110f8:	4615      	mov	r5, r2
	ASSERT(device);
   110fa:	f240 2236 	movw	r2, #566	; 0x236
   110fe:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
   11100:	f016 0ffd 	tst.w	r6, #253	; 0xfd
   11104:	d109      	bne.n	1111a <_usart_async_set_irq_state+0x32>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
   11106:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   11108:	2101      	movs	r1, #1
   1110a:	2202      	movs	r2, #2
   1110c:	b915      	cbnz	r5, 11114 <_usart_async_set_irq_state+0x2c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   1110e:	7519      	strb	r1, [r3, #20]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
   11110:	751a      	strb	r2, [r3, #20]
}
   11112:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   11114:	7599      	strb	r1, [r3, #22]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
   11116:	759a      	strb	r2, [r3, #22]
   11118:	e7fb      	b.n	11112 <_usart_async_set_irq_state+0x2a>
	} else if (USART_ASYNC_RX_DONE == type) {
   1111a:	2e01      	cmp	r6, #1
   1111c:	d104      	bne.n	11128 <_usart_async_set_irq_state+0x40>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
   1111e:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   11120:	2204      	movs	r2, #4
	if (value == 0x0) {
   11122:	2d00      	cmp	r5, #0
   11124:	d1f7      	bne.n	11116 <_usart_async_set_irq_state+0x2e>
   11126:	e7f3      	b.n	11110 <_usart_async_set_irq_state+0x28>
	} else if (USART_ASYNC_ERROR == type) {
   11128:	2e03      	cmp	r6, #3
   1112a:	d1f2      	bne.n	11112 <_usart_async_set_irq_state+0x2a>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
   1112c:	69a3      	ldr	r3, [r4, #24]
   1112e:	2280      	movs	r2, #128	; 0x80
   11130:	e7f7      	b.n	11122 <_usart_async_set_irq_state+0x3a>
   11132:	bf00      	nop
   11134:	00017581 	.word	0x00017581
   11138:	0000e08d 	.word	0x0000e08d

0001113c <_i2c_m_async_init>:
{
   1113c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   11140:	4605      	mov	r5, r0
   11142:	3800      	subs	r0, #0
{
   11144:	460c      	mov	r4, r1
	ASSERT(i2c_dev);
   11146:	bf18      	it	ne
   11148:	2001      	movne	r0, #1
   1114a:	4913      	ldr	r1, [pc, #76]	; (11198 <_i2c_m_async_init+0x5c>)
   1114c:	4b13      	ldr	r3, [pc, #76]	; (1119c <_i2c_m_async_init+0x60>)
   1114e:	f240 42d3 	movw	r2, #1235	; 0x4d3
   11152:	4798      	blx	r3
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11154:	4b12      	ldr	r3, [pc, #72]	; (111a0 <_i2c_m_async_init+0x64>)
	i2c_dev->hw = hw;
   11156:	612c      	str	r4, [r5, #16]
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11158:	4621      	mov	r1, r4
   1115a:	4628      	mov	r0, r5
   1115c:	4798      	blx	r3
	if (init_status) {
   1115e:	4606      	mov	r6, r0
   11160:	b9b0      	cbnz	r0, 11190 <_i2c_m_async_init+0x54>
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11162:	4629      	mov	r1, r5
   11164:	4620      	mov	r0, r4
   11166:	4b0f      	ldr	r3, [pc, #60]	; (111a4 <_i2c_m_async_init+0x68>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11168:	f8df 8048 	ldr.w	r8, [pc, #72]	; 111b4 <_i2c_m_async_init+0x78>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1116c:	4f0e      	ldr	r7, [pc, #56]	; (111a8 <_i2c_m_async_init+0x6c>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   1116e:	4d0f      	ldr	r5, [pc, #60]	; (111ac <_i2c_m_async_init+0x70>)
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11170:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   11172:	4b0f      	ldr	r3, [pc, #60]	; (111b0 <_i2c_m_async_init+0x74>)
   11174:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11176:	4631      	mov	r1, r6
	uint8_t irq = _sercom_get_irq_num(hw);
   11178:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   1117a:	1863      	adds	r3, r4, r1
   1117c:	b2d8      	uxtb	r0, r3
   1117e:	9001      	str	r0, [sp, #4]
   11180:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11182:	9801      	ldr	r0, [sp, #4]
   11184:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   11186:	9801      	ldr	r0, [sp, #4]
   11188:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   1118a:	3101      	adds	r1, #1
   1118c:	2904      	cmp	r1, #4
   1118e:	d1f4      	bne.n	1117a <_i2c_m_async_init+0x3e>
}
   11190:	4630      	mov	r0, r6
   11192:	b002      	add	sp, #8
   11194:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11198:	00017581 	.word	0x00017581
   1119c:	0000e08d 	.word	0x0000e08d
   111a0:	00010e49 	.word	0x00010e49
   111a4:	00010a39 	.word	0x00010a39
   111a8:	00010b81 	.word	0x00010b81
   111ac:	00010b15 	.word	0x00010b15
   111b0:	00010a99 	.word	0x00010a99
   111b4:	00010b5d 	.word	0x00010b5d

000111b8 <_i2c_m_async_transfer>:
{
   111b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   111bc:	4604      	mov	r4, r0
   111be:	3800      	subs	r0, #0
   111c0:	4e3c      	ldr	r6, [pc, #240]	; (112b4 <_i2c_m_async_transfer+0xfc>)
{
   111c2:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
   111c4:	bf18      	it	ne
   111c6:	2001      	movne	r0, #1
   111c8:	493b      	ldr	r1, [pc, #236]	; (112b8 <_i2c_m_async_transfer+0x100>)
   111ca:	f240 5229 	movw	r2, #1321	; 0x529
   111ce:	47b0      	blx	r6
	ASSERT(i2c_dev->hw);
   111d0:	6920      	ldr	r0, [r4, #16]
   111d2:	4939      	ldr	r1, [pc, #228]	; (112b8 <_i2c_m_async_transfer+0x100>)
   111d4:	3800      	subs	r0, #0
   111d6:	f240 522a 	movw	r2, #1322	; 0x52a
   111da:	bf18      	it	ne
   111dc:	2001      	movne	r0, #1
   111de:	47b0      	blx	r6
	ASSERT(msg);
   111e0:	1e28      	subs	r0, r5, #0
   111e2:	bf18      	it	ne
   111e4:	2001      	movne	r0, #1
   111e6:	4934      	ldr	r1, [pc, #208]	; (112b8 <_i2c_m_async_transfer+0x100>)
   111e8:	f240 522b 	movw	r2, #1323	; 0x52b
   111ec:	47b0      	blx	r6
	if (msg->len == 0) {
   111ee:	6868      	ldr	r0, [r5, #4]
   111f0:	2800      	cmp	r0, #0
   111f2:	d048      	beq.n	11286 <_i2c_m_async_transfer+0xce>
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
   111f4:	8863      	ldrh	r3, [r4, #2]
   111f6:	05da      	lsls	r2, r3, #23
   111f8:	d458      	bmi.n	112ac <_i2c_m_async_transfer+0xf4>
	msg->flags |= I2C_M_BUSY;
   111fa:	886b      	ldrh	r3, [r5, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   111fc:	4f2f      	ldr	r7, [pc, #188]	; (112bc <_i2c_m_async_transfer+0x104>)
   111fe:	b29b      	uxth	r3, r3
   11200:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   11204:	806b      	strh	r3, [r5, #2]
	i2c_dev->service.msg = *msg;
   11206:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   1120a:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(i2c_dev->hw);
   1120e:	6920      	ldr	r0, [r4, #16]
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
   11210:	6843      	ldr	r3, [r0, #4]
   11212:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   11216:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11218:	2104      	movs	r1, #4
   1121a:	47b8      	blx	r7
	void *             hw    = i2c_dev->hw;
   1121c:	6925      	ldr	r5, [r4, #16]
	ASSERT(i2c_dev);
   1121e:	4926      	ldr	r1, [pc, #152]	; (112b8 <_i2c_m_async_transfer+0x100>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   11220:	f8d5 8000 	ldr.w	r8, [r5]
   11224:	f240 5201 	movw	r2, #1281	; 0x501
   11228:	2001      	movs	r0, #1
   1122a:	47b0      	blx	r6
	if (msg->len == 1 && sclsm) {
   1122c:	6863      	ldr	r3, [r4, #4]
   1122e:	2b01      	cmp	r3, #1
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   11230:	686b      	ldr	r3, [r5, #4]
   11232:	d12a      	bne.n	1128a <_i2c_m_async_transfer+0xd2>
   11234:	f018 6f00 	tst.w	r8, #134217728	; 0x8000000
   11238:	d027      	beq.n	1128a <_i2c_m_async_transfer+0xd2>
   1123a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1123e:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   11240:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11242:	2104      	movs	r1, #4
   11244:	47b8      	blx	r7
	if (msg->addr & I2C_M_TEN) {
   11246:	8820      	ldrh	r0, [r4, #0]
   11248:	f410 6680 	ands.w	r6, r0, #1024	; 0x400
   1124c:	ea4f 0240 	mov.w	r2, r0, lsl #1
   11250:	d01e      	beq.n	11290 <_i2c_m_async_transfer+0xd8>
		if (msg->flags & I2C_M_RD) {
   11252:	8863      	ldrh	r3, [r4, #2]
   11254:	07db      	lsls	r3, r3, #31
			msg->flags |= I2C_M_TEN;
   11256:	bf41      	itttt	mi
   11258:	8863      	ldrhmi	r3, [r4, #2]
   1125a:	b29b      	uxthmi	r3, r3
   1125c:	f443 6380 	orrmi.w	r3, r3, #1024	; 0x400
   11260:	8063      	strhmi	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11262:	2104      	movs	r1, #4
   11264:	4628      	mov	r0, r5
   11266:	47b8      	blx	r7
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11268:	6a6b      	ldr	r3, [r5, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   1126a:	f022 0201 	bic.w	r2, r2, #1
   1126e:	0552      	lsls	r2, r2, #21
   11270:	0d52      	lsrs	r2, r2, #21
   11272:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   11276:	431a      	orrs	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
   11278:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1127c:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   1127e:	626a      	str	r2, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11280:	2104      	movs	r1, #4
   11282:	47b8      	blx	r7
	return ERR_NONE;
   11284:	2000      	movs	r0, #0
}
   11286:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   1128a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
   1128e:	e7d6      	b.n	1123e <_i2c_m_async_transfer+0x86>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11290:	2104      	movs	r1, #4
   11292:	4628      	mov	r0, r5
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
   11294:	8864      	ldrh	r4, [r4, #2]
   11296:	47b8      	blx	r7
   11298:	b2a4      	uxth	r4, r4
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   1129a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1129c:	b2d2      	uxtb	r2, r2
   1129e:	f004 0401 	and.w	r4, r4, #1
   112a2:	4322      	orrs	r2, r4
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   112a4:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
   112a8:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   112aa:	e7e7      	b.n	1127c <_i2c_m_async_transfer+0xc4>
		return ERR_BUSY;
   112ac:	f06f 0003 	mvn.w	r0, #3
   112b0:	e7e9      	b.n	11286 <_i2c_m_async_transfer+0xce>
   112b2:	bf00      	nop
   112b4:	0000e08d 	.word	0x0000e08d
   112b8:	00017581 	.word	0x00017581
   112bc:	00010911 	.word	0x00010911

000112c0 <_i2c_m_async_register_callback>:
	switch (type) {
   112c0:	2901      	cmp	r1, #1
   112c2:	d005      	beq.n	112d0 <_i2c_m_async_register_callback+0x10>
   112c4:	2902      	cmp	r1, #2
   112c6:	d005      	beq.n	112d4 <_i2c_m_async_register_callback+0x14>
   112c8:	b901      	cbnz	r1, 112cc <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.error = (_i2c_error_cb_t)func;
   112ca:	6142      	str	r2, [r0, #20]
}
   112cc:	2000      	movs	r0, #0
   112ce:	4770      	bx	lr
		i2c_dev->cb.tx_complete = (_i2c_complete_cb_t)func;
   112d0:	6182      	str	r2, [r0, #24]
		break;
   112d2:	e7fb      	b.n	112cc <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.rx_complete = (_i2c_complete_cb_t)func;
   112d4:	61c2      	str	r2, [r0, #28]
		break;
   112d6:	e7f9      	b.n	112cc <_i2c_m_async_register_callback+0xc>

000112d8 <SERCOM0_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom0_dev);
   112d8:	4b01      	ldr	r3, [pc, #4]	; (112e0 <SERCOM0_0_Handler+0x8>)
   112da:	6818      	ldr	r0, [r3, #0]
   112dc:	4b01      	ldr	r3, [pc, #4]	; (112e4 <SERCOM0_0_Handler+0xc>)
   112de:	4718      	bx	r3
   112e0:	20008d68 	.word	0x20008d68
   112e4:	000109c9 	.word	0x000109c9

000112e8 <SERCOM0_1_Handler>:
   112e8:	4b00      	ldr	r3, [pc, #0]	; (112ec <SERCOM0_1_Handler+0x4>)
   112ea:	4718      	bx	r3
   112ec:	000112d9 	.word	0x000112d9

000112f0 <SERCOM0_2_Handler>:
   112f0:	4b00      	ldr	r3, [pc, #0]	; (112f4 <SERCOM0_2_Handler+0x4>)
   112f2:	4718      	bx	r3
   112f4:	000112d9 	.word	0x000112d9

000112f8 <SERCOM0_3_Handler>:
   112f8:	4b00      	ldr	r3, [pc, #0]	; (112fc <SERCOM0_3_Handler+0x4>)
   112fa:	4718      	bx	r3
   112fc:	000112d9 	.word	0x000112d9

00011300 <SERCOM1_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom1_dev);
   11300:	4b01      	ldr	r3, [pc, #4]	; (11308 <SERCOM1_0_Handler+0x8>)
   11302:	6858      	ldr	r0, [r3, #4]
   11304:	4b01      	ldr	r3, [pc, #4]	; (1130c <SERCOM1_0_Handler+0xc>)
   11306:	4718      	bx	r3
   11308:	20008d68 	.word	0x20008d68
   1130c:	000109c9 	.word	0x000109c9

00011310 <SERCOM1_1_Handler>:
   11310:	4b00      	ldr	r3, [pc, #0]	; (11314 <SERCOM1_1_Handler+0x4>)
   11312:	4718      	bx	r3
   11314:	00011301 	.word	0x00011301

00011318 <SERCOM1_2_Handler>:
   11318:	4b00      	ldr	r3, [pc, #0]	; (1131c <SERCOM1_2_Handler+0x4>)
   1131a:	4718      	bx	r3
   1131c:	00011301 	.word	0x00011301

00011320 <SERCOM1_3_Handler>:
   11320:	4b00      	ldr	r3, [pc, #0]	; (11324 <SERCOM1_3_Handler+0x4>)
   11322:	4718      	bx	r3
   11324:	00011301 	.word	0x00011301

00011328 <SERCOM3_0_Handler>:
	_spi_handler(_sercom3_dev);
   11328:	4b0f      	ldr	r3, [pc, #60]	; (11368 <SERCOM3_0_Handler+0x40>)
   1132a:	6898      	ldr	r0, [r3, #8]
	void *                      hw = dev->prvt;
   1132c:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
   1132e:	7e13      	ldrb	r3, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
   11330:	7d91      	ldrb	r1, [r2, #22]
	st &= hri_sercomspi_read_INTEN_reg(hw);
   11332:	400b      	ands	r3, r1
	if (st & SERCOM_SPI_INTFLAG_DRE) {
   11334:	07d9      	lsls	r1, r3, #31
   11336:	d501      	bpl.n	1133c <SERCOM3_0_Handler+0x14>
		dev->callbacks.tx(dev);
   11338:	6883      	ldr	r3, [r0, #8]
		dev->callbacks.rx(dev);
   1133a:	4718      	bx	r3
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
   1133c:	0759      	lsls	r1, r3, #29
   1133e:	d501      	bpl.n	11344 <SERCOM3_0_Handler+0x1c>
		dev->callbacks.rx(dev);
   11340:	68c3      	ldr	r3, [r0, #12]
   11342:	e7fa      	b.n	1133a <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
   11344:	0799      	lsls	r1, r3, #30
   11346:	d503      	bpl.n	11350 <SERCOM3_0_Handler+0x28>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11348:	2302      	movs	r3, #2
   1134a:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
   1134c:	6903      	ldr	r3, [r0, #16]
   1134e:	e7f4      	b.n	1133a <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
   11350:	061b      	lsls	r3, r3, #24
   11352:	d507      	bpl.n	11364 <SERCOM3_0_Handler+0x3c>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
   11354:	2304      	movs	r3, #4
   11356:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11358:	2380      	movs	r3, #128	; 0x80
   1135a:	7613      	strb	r3, [r2, #24]
		dev->callbacks.err(dev, ERR_OVERFLOW);
   1135c:	f06f 0112 	mvn.w	r1, #18
   11360:	6943      	ldr	r3, [r0, #20]
   11362:	4718      	bx	r3
}
   11364:	4770      	bx	lr
   11366:	bf00      	nop
   11368:	20008d68 	.word	0x20008d68

0001136c <SERCOM3_1_Handler>:
   1136c:	4b00      	ldr	r3, [pc, #0]	; (11370 <SERCOM3_1_Handler+0x4>)
   1136e:	4718      	bx	r3
   11370:	00011329 	.word	0x00011329

00011374 <SERCOM3_2_Handler>:
   11374:	4b00      	ldr	r3, [pc, #0]	; (11378 <SERCOM3_2_Handler+0x4>)
   11376:	4718      	bx	r3
   11378:	00011329 	.word	0x00011329

0001137c <SERCOM3_3_Handler>:
   1137c:	4b00      	ldr	r3, [pc, #0]	; (11380 <SERCOM3_3_Handler+0x4>)
   1137e:	4718      	bx	r3
   11380:	00011329 	.word	0x00011329

00011384 <SERCOM4_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom4_dev);
   11384:	4b01      	ldr	r3, [pc, #4]	; (1138c <SERCOM4_0_Handler+0x8>)
   11386:	68d8      	ldr	r0, [r3, #12]
   11388:	4b01      	ldr	r3, [pc, #4]	; (11390 <SERCOM4_0_Handler+0xc>)
   1138a:	4718      	bx	r3
   1138c:	20008d68 	.word	0x20008d68
   11390:	000109c9 	.word	0x000109c9

00011394 <SERCOM4_1_Handler>:
   11394:	4b00      	ldr	r3, [pc, #0]	; (11398 <SERCOM4_1_Handler+0x4>)
   11396:	4718      	bx	r3
   11398:	00011385 	.word	0x00011385

0001139c <SERCOM4_2_Handler>:
   1139c:	4b00      	ldr	r3, [pc, #0]	; (113a0 <SERCOM4_2_Handler+0x4>)
   1139e:	4718      	bx	r3
   113a0:	00011385 	.word	0x00011385

000113a4 <SERCOM4_3_Handler>:
   113a4:	4b00      	ldr	r3, [pc, #0]	; (113a8 <SERCOM4_3_Handler+0x4>)
   113a6:	4718      	bx	r3
   113a8:	00011385 	.word	0x00011385

000113ac <SERCOM5_0_Handler>:
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   113ac:	4b1f      	ldr	r3, [pc, #124]	; (1142c <SERCOM5_0_Handler+0x80>)
	ASSERT(i2c_dev);
   113ae:	4920      	ldr	r1, [pc, #128]	; (11430 <SERCOM5_0_Handler+0x84>)
{
   113b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   113b4:	691c      	ldr	r4, [r3, #16]
	ASSERT(i2c_dev);
   113b6:	4f1f      	ldr	r7, [pc, #124]	; (11434 <SERCOM5_0_Handler+0x88>)
	void *   hw    = i2c_dev->hw;
   113b8:	6926      	ldr	r6, [r4, #16]
	ASSERT(i2c_dev);
   113ba:	f240 425f 	movw	r2, #1119	; 0x45f
   113be:	2001      	movs	r0, #1
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
   113c0:	7e35      	ldrb	r5, [r6, #24]
   113c2:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
   113c4:	6920      	ldr	r0, [r4, #16]
   113c6:	491a      	ldr	r1, [pc, #104]	; (11430 <SERCOM5_0_Handler+0x84>)
   113c8:	3800      	subs	r0, #0
   113ca:	bf18      	it	ne
   113cc:	2001      	movne	r0, #1
   113ce:	b2ed      	uxtb	r5, r5
   113d0:	f44f 628c 	mov.w	r2, #1120	; 0x460
   113d4:	47b8      	blx	r7
	while (!(flags & ERROR_FLAG)) {
   113d6:	0629      	lsls	r1, r5, #24
   113d8:	d415      	bmi.n	11406 <SERCOM5_0_Handler+0x5a>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
   113da:	4629      	mov	r1, r5
   113dc:	4b16      	ldr	r3, [pc, #88]	; (11438 <SERCOM5_0_Handler+0x8c>)
   113de:	4622      	mov	r2, r4
   113e0:	4630      	mov	r0, r6
   113e2:	4798      	blx	r3
		if (ret != 0) {
   113e4:	4601      	mov	r1, r0
   113e6:	b978      	cbnz	r0, 11408 <SERCOM5_0_Handler+0x5c>
		if ((flags & MB_FLAG) && i2c_dev->cb.tx_complete) {
   113e8:	07ea      	lsls	r2, r5, #31
   113ea:	d505      	bpl.n	113f8 <SERCOM5_0_Handler+0x4c>
   113ec:	69a3      	ldr	r3, [r4, #24]
   113ee:	b11b      	cbz	r3, 113f8 <SERCOM5_0_Handler+0x4c>
			i2c_dev->cb.rx_complete(i2c_dev);
   113f0:	4620      	mov	r0, r4
}
   113f2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			i2c_dev->cb.rx_complete(i2c_dev);
   113f6:	4718      	bx	r3
		} else if ((flags & SB_FLAG) && i2c_dev->cb.rx_complete) {
   113f8:	07ab      	lsls	r3, r5, #30
   113fa:	d502      	bpl.n	11402 <SERCOM5_0_Handler+0x56>
   113fc:	69e3      	ldr	r3, [r4, #28]
   113fe:	2b00      	cmp	r3, #0
   11400:	d1f6      	bne.n	113f0 <SERCOM5_0_Handler+0x44>
}
   11402:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int32_t  ret   = I2C_OK;
   11406:	2100      	movs	r1, #0
	i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
   11408:	8863      	ldrh	r3, [r4, #2]
   1140a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1140e:	041b      	lsls	r3, r3, #16
   11410:	0c1b      	lsrs	r3, r3, #16
   11412:	8063      	strh	r3, [r4, #2]
	if (i2c_dev->cb.error) {
   11414:	6963      	ldr	r3, [r4, #20]
   11416:	2b00      	cmp	r3, #0
   11418:	d0f3      	beq.n	11402 <SERCOM5_0_Handler+0x56>
		if (ret != I2C_OK) {
   1141a:	b121      	cbz	r1, 11426 <SERCOM5_0_Handler+0x7a>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   1141c:	4620      	mov	r0, r4
   1141e:	4798      	blx	r3
	((Sercom *)hw)->I2CM.INTFLAG.reg = mask;
   11420:	2380      	movs	r3, #128	; 0x80
   11422:	7633      	strb	r3, [r6, #24]
}
   11424:	e7ed      	b.n	11402 <SERCOM5_0_Handler+0x56>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   11426:	f06f 0104 	mvn.w	r1, #4
   1142a:	e7f7      	b.n	1141c <SERCOM5_0_Handler+0x70>
   1142c:	20008d68 	.word	0x20008d68
   11430:	00017581 	.word	0x00017581
   11434:	0000e08d 	.word	0x0000e08d
   11438:	00010bdd 	.word	0x00010bdd

0001143c <SERCOM5_1_Handler>:
   1143c:	4b00      	ldr	r3, [pc, #0]	; (11440 <SERCOM5_1_Handler+0x4>)
   1143e:	4718      	bx	r3
   11440:	000113ad 	.word	0x000113ad

00011444 <SERCOM5_2_Handler>:
   11444:	4b00      	ldr	r3, [pc, #0]	; (11448 <SERCOM5_2_Handler+0x4>)
   11446:	4718      	bx	r3
   11448:	000113ad 	.word	0x000113ad

0001144c <SERCOM5_3_Handler>:
   1144c:	4b00      	ldr	r3, [pc, #0]	; (11450 <SERCOM5_3_Handler+0x4>)
   1144e:	4718      	bx	r3
   11450:	000113ad 	.word	0x000113ad

00011454 <SERCOM6_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom6_dev);
   11454:	4b01      	ldr	r3, [pc, #4]	; (1145c <SERCOM6_0_Handler+0x8>)
   11456:	6958      	ldr	r0, [r3, #20]
   11458:	4b01      	ldr	r3, [pc, #4]	; (11460 <SERCOM6_0_Handler+0xc>)
   1145a:	4718      	bx	r3
   1145c:	20008d68 	.word	0x20008d68
   11460:	000109c9 	.word	0x000109c9

00011464 <SERCOM6_1_Handler>:
   11464:	4b00      	ldr	r3, [pc, #0]	; (11468 <SERCOM6_1_Handler+0x4>)
   11466:	4718      	bx	r3
   11468:	00011455 	.word	0x00011455

0001146c <SERCOM6_2_Handler>:
   1146c:	4b00      	ldr	r3, [pc, #0]	; (11470 <SERCOM6_2_Handler+0x4>)
   1146e:	4718      	bx	r3
   11470:	00011455 	.word	0x00011455

00011474 <SERCOM6_3_Handler>:
   11474:	4b00      	ldr	r3, [pc, #0]	; (11478 <SERCOM6_3_Handler+0x4>)
   11476:	4718      	bx	r3
   11478:	00011455 	.word	0x00011455

0001147c <_spi_m_sync_init>:
{
   1147c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11480:	4b37      	ldr	r3, [pc, #220]	; (11560 <_spi_m_sync_init+0xe4>)
{
   11482:	4606      	mov	r6, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11484:	4608      	mov	r0, r1
{
   11486:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11488:	4798      	blx	r3
   1148a:	4605      	mov	r5, r0
	ASSERT(dev && hw);
   1148c:	2e00      	cmp	r6, #0
   1148e:	d05d      	beq.n	1154c <_spi_m_sync_init+0xd0>
   11490:	1e20      	subs	r0, r4, #0
   11492:	bf18      	it	ne
   11494:	2001      	movne	r0, #1
   11496:	4f33      	ldr	r7, [pc, #204]	; (11564 <_spi_m_sync_init+0xe8>)
   11498:	4933      	ldr	r1, [pc, #204]	; (11568 <_spi_m_sync_init+0xec>)
   1149a:	f640 2278 	movw	r2, #2680	; 0xa78
   1149e:	47b8      	blx	r7
	if (regs == NULL) {
   114a0:	46b9      	mov	r9, r7
   114a2:	2d00      	cmp	r5, #0
   114a4:	d058      	beq.n	11558 <_spi_m_sync_init+0xdc>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   114a6:	69e3      	ldr	r3, [r4, #28]
   114a8:	4f30      	ldr	r7, [pc, #192]	; (1156c <_spi_m_sync_init+0xf0>)
	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   114aa:	f013 0f01 	tst.w	r3, #1
   114ae:	d113      	bne.n	114d8 <_spi_m_sync_init+0x5c>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   114b0:	2103      	movs	r1, #3
   114b2:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   114b4:	f8d5 8000 	ldr.w	r8, [r5]
   114b8:	47b8      	blx	r7
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   114ba:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   114bc:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   114be:	f008 081c 	and.w	r8, r8, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   114c2:	d503      	bpl.n	114cc <_spi_m_sync_init+0x50>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   114c4:	4b2a      	ldr	r3, [pc, #168]	; (11570 <_spi_m_sync_init+0xf4>)
   114c6:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   114c8:	2102      	movs	r1, #2
   114ca:	47b8      	blx	r7
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   114cc:	f048 0301 	orr.w	r3, r8, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   114d0:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   114d2:	2103      	movs	r1, #3
   114d4:	4620      	mov	r0, r4
   114d6:	47b8      	blx	r7
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   114d8:	2101      	movs	r1, #1
   114da:	4620      	mov	r0, r4
   114dc:	47b8      	blx	r7
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   114de:	682b      	ldr	r3, [r5, #0]
	dev->prvt = hw;
   114e0:	6034      	str	r4, [r6, #0]
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   114e2:	f003 031c 	and.w	r3, r3, #28
   114e6:	2b08      	cmp	r3, #8
   114e8:	d132      	bne.n	11550 <_spi_m_sync_init+0xd4>
	ASSERT(hw && regs);
   114ea:	f640 128e 	movw	r2, #2446	; 0x98e
   114ee:	491e      	ldr	r1, [pc, #120]	; (11568 <_spi_m_sync_init+0xec>)
   114f0:	2001      	movs	r0, #1
   114f2:	47c8      	blx	r9
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   114f4:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
   114f6:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   114fa:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   114fe:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11500:	2103      	movs	r1, #3
   11502:	4620      	mov	r0, r4
   11504:	47b8      	blx	r7
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
   11506:	686b      	ldr	r3, [r5, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
   11508:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
   1150c:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
   11510:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11514:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   11518:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   1151a:	2117      	movs	r1, #23
   1151c:	47b8      	blx	r7
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
   1151e:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
   11520:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   11522:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   11524:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11528:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
   1152a:	2b00      	cmp	r3, #0
   1152c:	d1fc      	bne.n	11528 <_spi_m_sync_init+0xac>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
   1152e:	686b      	ldr	r3, [r5, #4]
   11530:	f013 0f07 	tst.w	r3, #7
   11534:	bf0c      	ite	eq
   11536:	2301      	moveq	r3, #1
   11538:	2302      	movne	r3, #2
   1153a:	7133      	strb	r3, [r6, #4]
	dev->dummy_byte = regs->dummy_byte;
   1153c:	7bab      	ldrb	r3, [r5, #14]
   1153e:	7bea      	ldrb	r2, [r5, #15]
   11540:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   11544:	80f3      	strh	r3, [r6, #6]
	return ERR_NONE;
   11546:	2000      	movs	r0, #0
}
   11548:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(dev && hw);
   1154c:	4630      	mov	r0, r6
   1154e:	e7a2      	b.n	11496 <_spi_m_sync_init+0x1a>
		_spi_load_regs_master(hw, regs);
   11550:	4b08      	ldr	r3, [pc, #32]	; (11574 <_spi_m_sync_init+0xf8>)
   11552:	4629      	mov	r1, r5
   11554:	4798      	blx	r3
   11556:	e7ea      	b.n	1152e <_spi_m_sync_init+0xb2>
		return ERR_INVALID_ARG;
   11558:	f06f 000c 	mvn.w	r0, #12
   1155c:	e7f4      	b.n	11548 <_spi_m_sync_init+0xcc>
   1155e:	bf00      	nop
   11560:	00010ad5 	.word	0x00010ad5
   11564:	0000e08d 	.word	0x0000e08d
   11568:	00017581 	.word	0x00017581
   1156c:	00010919 	.word	0x00010919
   11570:	0001093d 	.word	0x0001093d
   11574:	00010df1 	.word	0x00010df1

00011578 <_spi_m_async_init>:
{
   11578:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   1157a:	4b10      	ldr	r3, [pc, #64]	; (115bc <_spi_m_async_init+0x44>)
{
   1157c:	4605      	mov	r5, r0
   1157e:	460e      	mov	r6, r1
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11580:	4798      	blx	r3
	if (rc < 0) {
   11582:	2800      	cmp	r0, #0
   11584:	db17      	blt.n	115b6 <_spi_m_async_init+0x3e>
	_sercom_init_irq_param(hw, (void *)dev);
   11586:	4629      	mov	r1, r5
	spid->callbacks.complete = NULL;
   11588:	2400      	movs	r4, #0
	_sercom_init_irq_param(hw, (void *)dev);
   1158a:	4630      	mov	r0, r6
   1158c:	4b0c      	ldr	r3, [pc, #48]	; (115c0 <_spi_m_async_init+0x48>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   1158e:	4e0d      	ldr	r6, [pc, #52]	; (115c4 <_spi_m_async_init+0x4c>)
	_sercom_init_irq_param(hw, (void *)dev);
   11590:	4798      	blx	r3
	spid->callbacks.rx       = NULL;
   11592:	e9c5 4403 	strd	r4, r4, [r5, #12]
	spid->callbacks.tx       = NULL;
   11596:	60ac      	str	r4, [r5, #8]
	uint8_t irq              = _sercom_get_irq_num(hw);
   11598:	4b0b      	ldr	r3, [pc, #44]	; (115c8 <_spi_m_async_init+0x50>)
   1159a:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   1159c:	4621      	mov	r1, r4
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1159e:	4c0b      	ldr	r4, [pc, #44]	; (115cc <_spi_m_async_init+0x54>)
	uint8_t irq              = _sercom_get_irq_num(hw);
   115a0:	4605      	mov	r5, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   115a2:	186b      	adds	r3, r5, r1
   115a4:	b2d8      	uxtb	r0, r3
   115a6:	9001      	str	r0, [sp, #4]
   115a8:	47b0      	blx	r6
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   115aa:	9801      	ldr	r0, [sp, #4]
   115ac:	47a0      	blx	r4
	for (uint32_t i = 0; i < 4; i++) {
   115ae:	3101      	adds	r1, #1
   115b0:	2904      	cmp	r1, #4
   115b2:	d1f6      	bne.n	115a2 <_spi_m_async_init+0x2a>
   115b4:	2000      	movs	r0, #0
}
   115b6:	b002      	add	sp, #8
   115b8:	bd70      	pop	{r4, r5, r6, pc}
   115ba:	bf00      	nop
   115bc:	0001147d 	.word	0x0001147d
   115c0:	00010a39 	.word	0x00010a39
   115c4:	00010b5d 	.word	0x00010b5d
   115c8:	00010a99 	.word	0x00010a99
   115cc:	00010b81 	.word	0x00010b81

000115d0 <_spi_m_async_enable>:
{
   115d0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   115d2:	4604      	mov	r4, r0
   115d4:	b118      	cbz	r0, 115de <_spi_m_async_enable+0xe>
   115d6:	6800      	ldr	r0, [r0, #0]
   115d8:	3800      	subs	r0, #0
   115da:	bf18      	it	ne
   115dc:	2001      	movne	r0, #1
   115de:	4b05      	ldr	r3, [pc, #20]	; (115f4 <_spi_m_async_enable+0x24>)
   115e0:	4905      	ldr	r1, [pc, #20]	; (115f8 <_spi_m_async_enable+0x28>)
   115e2:	f640 22e5 	movw	r2, #2789	; 0xae5
   115e6:	4798      	blx	r3
	return _spi_async_enable(dev->prvt);
   115e8:	6820      	ldr	r0, [r4, #0]
   115ea:	4b04      	ldr	r3, [pc, #16]	; (115fc <_spi_m_async_enable+0x2c>)
}
   115ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_async_enable(dev->prvt);
   115f0:	4718      	bx	r3
   115f2:	bf00      	nop
   115f4:	0000e08d 	.word	0x0000e08d
   115f8:	00017581 	.word	0x00017581
   115fc:	00010b2d 	.word	0x00010b2d

00011600 <_spi_m_async_set_mode>:
{
   11600:	b570      	push	{r4, r5, r6, lr}
   11602:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11604:	4604      	mov	r4, r0
   11606:	b118      	cbz	r0, 11610 <_spi_m_async_set_mode+0x10>
   11608:	6800      	ldr	r0, [r0, #0]
   1160a:	3800      	subs	r0, #0
   1160c:	bf18      	it	ne
   1160e:	2001      	movne	r0, #1
   11610:	4905      	ldr	r1, [pc, #20]	; (11628 <_spi_m_async_set_mode+0x28>)
   11612:	4b06      	ldr	r3, [pc, #24]	; (1162c <_spi_m_async_set_mode+0x2c>)
   11614:	f640 3216 	movw	r2, #2838	; 0xb16
   11618:	4798      	blx	r3
	return _spi_set_mode(dev->prvt, mode);
   1161a:	6820      	ldr	r0, [r4, #0]
   1161c:	4b04      	ldr	r3, [pc, #16]	; (11630 <_spi_m_async_set_mode+0x30>)
   1161e:	4629      	mov	r1, r5
}
   11620:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_set_mode(dev->prvt, mode);
   11624:	4718      	bx	r3
   11626:	bf00      	nop
   11628:	00017581 	.word	0x00017581
   1162c:	0000e08d 	.word	0x0000e08d
   11630:	00010dbd 	.word	0x00010dbd

00011634 <_spi_m_async_set_baudrate>:
{
   11634:	b538      	push	{r3, r4, r5, lr}
   11636:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11638:	4604      	mov	r4, r0
   1163a:	b118      	cbz	r0, 11644 <_spi_m_async_set_baudrate+0x10>
   1163c:	6800      	ldr	r0, [r0, #0]
   1163e:	3800      	subs	r0, #0
   11640:	bf18      	it	ne
   11642:	2001      	movne	r0, #1
   11644:	4907      	ldr	r1, [pc, #28]	; (11664 <_spi_m_async_set_baudrate+0x30>)
   11646:	4b08      	ldr	r3, [pc, #32]	; (11668 <_spi_m_async_set_baudrate+0x34>)
   11648:	f640 3245 	movw	r2, #2885	; 0xb45
   1164c:	4798      	blx	r3
	return _spi_set_baudrate(dev->prvt, baud_val);
   1164e:	6823      	ldr	r3, [r4, #0]
   11650:	69d8      	ldr	r0, [r3, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   11652:	f010 0001 	ands.w	r0, r0, #1
	hri_sercomspi_write_BAUD_reg(hw, baud_val);
   11656:	bf06      	itte	eq
   11658:	b2ed      	uxtbeq	r5, r5
	((Sercom *)hw)->SPI.BAUD.reg = data;
   1165a:	731d      	strbeq	r5, [r3, #12]
		return ERR_BUSY;
   1165c:	f06f 0003 	mvnne.w	r0, #3
}
   11660:	bd38      	pop	{r3, r4, r5, pc}
   11662:	bf00      	nop
   11664:	00017581 	.word	0x00017581
   11668:	0000e08d 	.word	0x0000e08d

0001166c <_spi_m_async_enable_tx>:
{
   1166c:	b538      	push	{r3, r4, r5, lr}
	void *hw = dev->prvt;
   1166e:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev && hw);
   11670:	4b07      	ldr	r3, [pc, #28]	; (11690 <_spi_m_async_enable_tx+0x24>)
   11672:	1e20      	subs	r0, r4, #0
{
   11674:	460d      	mov	r5, r1
	ASSERT(dev && hw);
   11676:	f640 4208 	movw	r2, #3080	; 0xc08
   1167a:	4906      	ldr	r1, [pc, #24]	; (11694 <_spi_m_async_enable_tx+0x28>)
   1167c:	bf18      	it	ne
   1167e:	2001      	movne	r0, #1
   11680:	4798      	blx	r3
	if (state) {
   11682:	2301      	movs	r3, #1
   11684:	b115      	cbz	r5, 1168c <_spi_m_async_enable_tx+0x20>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
   11686:	75a3      	strb	r3, [r4, #22]
}
   11688:	2000      	movs	r0, #0
   1168a:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
   1168c:	7523      	strb	r3, [r4, #20]
}
   1168e:	e7fb      	b.n	11688 <_spi_m_async_enable_tx+0x1c>
   11690:	0000e08d 	.word	0x0000e08d
   11694:	00017581 	.word	0x00017581

00011698 <_spi_m_async_enable_rx>:
{
   11698:	b570      	push	{r4, r5, r6, lr}
	void *hw = dev->prvt;
   1169a:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev);
   1169c:	4e0a      	ldr	r6, [pc, #40]	; (116c8 <_spi_m_async_enable_rx+0x30>)
   1169e:	f640 421c 	movw	r2, #3100	; 0xc1c
   116a2:	2001      	movs	r0, #1
{
   116a4:	460d      	mov	r5, r1
	ASSERT(dev);
   116a6:	4909      	ldr	r1, [pc, #36]	; (116cc <_spi_m_async_enable_rx+0x34>)
   116a8:	47b0      	blx	r6
	ASSERT(hw);
   116aa:	1e20      	subs	r0, r4, #0
   116ac:	4907      	ldr	r1, [pc, #28]	; (116cc <_spi_m_async_enable_rx+0x34>)
   116ae:	f640 421d 	movw	r2, #3101	; 0xc1d
   116b2:	bf18      	it	ne
   116b4:	2001      	movne	r0, #1
   116b6:	47b0      	blx	r6
	if (state) {
   116b8:	2304      	movs	r3, #4
   116ba:	b115      	cbz	r5, 116c2 <_spi_m_async_enable_rx+0x2a>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
   116bc:	75a3      	strb	r3, [r4, #22]
}
   116be:	2000      	movs	r0, #0
   116c0:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
   116c2:	7523      	strb	r3, [r4, #20]
}
   116c4:	e7fb      	b.n	116be <_spi_m_async_enable_rx+0x26>
   116c6:	bf00      	nop
   116c8:	0000e08d 	.word	0x0000e08d
   116cc:	00017581 	.word	0x00017581

000116d0 <_spi_m_async_enable_tx_complete>:
{
   116d0:	b538      	push	{r3, r4, r5, lr}
   116d2:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   116d4:	4604      	mov	r4, r0
   116d6:	b118      	cbz	r0, 116e0 <_spi_m_async_enable_tx_complete+0x10>
   116d8:	6800      	ldr	r0, [r0, #0]
   116da:	3800      	subs	r0, #0
   116dc:	bf18      	it	ne
   116de:	2001      	movne	r0, #1
   116e0:	4b06      	ldr	r3, [pc, #24]	; (116fc <_spi_m_async_enable_tx_complete+0x2c>)
   116e2:	4907      	ldr	r1, [pc, #28]	; (11700 <_spi_m_async_enable_tx_complete+0x30>)
   116e4:	f640 422f 	movw	r2, #3119	; 0xc2f
   116e8:	4798      	blx	r3
	if (state) {
   116ea:	6823      	ldr	r3, [r4, #0]
   116ec:	2202      	movs	r2, #2
   116ee:	b115      	cbz	r5, 116f6 <_spi_m_async_enable_tx_complete+0x26>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
   116f0:	759a      	strb	r2, [r3, #22]
}
   116f2:	2000      	movs	r0, #0
   116f4:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
   116f6:	751a      	strb	r2, [r3, #20]
}
   116f8:	e7fb      	b.n	116f2 <_spi_m_async_enable_tx_complete+0x22>
   116fa:	bf00      	nop
   116fc:	0000e08d 	.word	0x0000e08d
   11700:	00017581 	.word	0x00017581

00011704 <_spi_m_async_write_one>:
{
   11704:	b538      	push	{r3, r4, r5, lr}
   11706:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11708:	4604      	mov	r4, r0
   1170a:	b118      	cbz	r0, 11714 <_spi_m_async_write_one+0x10>
   1170c:	6800      	ldr	r0, [r0, #0]
   1170e:	3800      	subs	r0, #0
   11710:	bf18      	it	ne
   11712:	2001      	movne	r0, #1
   11714:	4904      	ldr	r1, [pc, #16]	; (11728 <_spi_m_async_write_one+0x24>)
   11716:	4b05      	ldr	r3, [pc, #20]	; (1172c <_spi_m_async_write_one+0x28>)
   11718:	f640 4241 	movw	r2, #3137	; 0xc41
   1171c:	4798      	blx	r3
	hri_sercomspi_write_DATA_reg(dev->prvt, data);
   1171e:	6823      	ldr	r3, [r4, #0]
}
   11720:	2000      	movs	r0, #0
	((Sercom *)hw)->SPI.DATA.reg = data;
   11722:	629d      	str	r5, [r3, #40]	; 0x28
   11724:	bd38      	pop	{r3, r4, r5, pc}
   11726:	bf00      	nop
   11728:	00017581 	.word	0x00017581
   1172c:	0000e08d 	.word	0x0000e08d

00011730 <_spi_m_async_read_one>:
{
   11730:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11732:	4604      	mov	r4, r0
   11734:	b118      	cbz	r0, 1173e <_spi_m_async_read_one+0xe>
   11736:	6800      	ldr	r0, [r0, #0]
   11738:	3800      	subs	r0, #0
   1173a:	bf18      	it	ne
   1173c:	2001      	movne	r0, #1
   1173e:	4904      	ldr	r1, [pc, #16]	; (11750 <_spi_m_async_read_one+0x20>)
   11740:	4b04      	ldr	r3, [pc, #16]	; (11754 <_spi_m_async_read_one+0x24>)
   11742:	f640 425c 	movw	r2, #3164	; 0xc5c
   11746:	4798      	blx	r3
	return hri_sercomspi_read_DATA_reg(dev->prvt);
   11748:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
   1174a:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   1174c:	b280      	uxth	r0, r0
   1174e:	bd10      	pop	{r4, pc}
   11750:	00017581 	.word	0x00017581
   11754:	0000e08d 	.word	0x0000e08d

00011758 <_spi_m_async_register_callback>:
{
   11758:	b570      	push	{r4, r5, r6, lr}
   1175a:	460d      	mov	r5, r1
   1175c:	4616      	mov	r6, r2
	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
   1175e:	4604      	mov	r4, r0
   11760:	b118      	cbz	r0, 1176a <_spi_m_async_register_callback+0x12>
   11762:	2903      	cmp	r1, #3
   11764:	bf8c      	ite	hi
   11766:	2000      	movhi	r0, #0
   11768:	2001      	movls	r0, #1
   1176a:	4905      	ldr	r1, [pc, #20]	; (11780 <_spi_m_async_register_callback+0x28>)
   1176c:	4b05      	ldr	r3, [pc, #20]	; (11784 <_spi_m_async_register_callback+0x2c>)
   1176e:	f640 4275 	movw	r2, #3189	; 0xc75
   11772:	4798      	blx	r3
	p_ls[cb_type] = (func_t)func;
   11774:	eb04 0185 	add.w	r1, r4, r5, lsl #2
}
   11778:	2000      	movs	r0, #0
	p_ls[cb_type] = (func_t)func;
   1177a:	608e      	str	r6, [r1, #8]
}
   1177c:	bd70      	pop	{r4, r5, r6, pc}
   1177e:	bf00      	nop
   11780:	00017581 	.word	0x00017581
   11784:	0000e08d 	.word	0x0000e08d

00011788 <_spi_m_async_set_irq_state>:
{
   11788:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   1178a:	4604      	mov	r4, r0
   1178c:	3800      	subs	r0, #0
{
   1178e:	460e      	mov	r6, r1
	ASSERT(device);
   11790:	bf18      	it	ne
   11792:	2001      	movne	r0, #1
   11794:	4907      	ldr	r1, [pc, #28]	; (117b4 <_spi_m_async_set_irq_state+0x2c>)
   11796:	4b08      	ldr	r3, [pc, #32]	; (117b8 <_spi_m_async_set_irq_state+0x30>)
{
   11798:	4615      	mov	r5, r2
	ASSERT(device);
   1179a:	f640 42b6 	movw	r2, #3254	; 0xcb6
   1179e:	4798      	blx	r3
	if (SPI_DEV_CB_ERROR == type) {
   117a0:	2e03      	cmp	r6, #3
   117a2:	d103      	bne.n	117ac <_spi_m_async_set_irq_state+0x24>
		hri_sercomspi_write_INTEN_ERROR_bit(device->prvt, state);
   117a4:	6823      	ldr	r3, [r4, #0]
	if (value == 0x0) {
   117a6:	2280      	movs	r2, #128	; 0x80
   117a8:	b90d      	cbnz	r5, 117ae <_spi_m_async_set_irq_state+0x26>
		((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_ERROR;
   117aa:	751a      	strb	r2, [r3, #20]
}
   117ac:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_ERROR;
   117ae:	759a      	strb	r2, [r3, #22]
   117b0:	e7fc      	b.n	117ac <_spi_m_async_set_irq_state+0x24>
   117b2:	bf00      	nop
   117b4:	00017581 	.word	0x00017581
   117b8:	0000e08d 	.word	0x0000e08d

000117bc <_spi_m_dma_init>:

int32_t _spi_m_dma_init(struct _spi_m_dma_dev *dev, void *const hw)
{
   117bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   117c0:	4b25      	ldr	r3, [pc, #148]	; (11858 <_spi_m_dma_init+0x9c>)
{
   117c2:	4605      	mov	r5, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   117c4:	4608      	mov	r0, r1
{
   117c6:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   117c8:	4798      	blx	r3
   117ca:	4606      	mov	r6, r0

	ASSERT(dev && hw);
   117cc:	2d00      	cmp	r5, #0
   117ce:	d03e      	beq.n	1184e <_spi_m_dma_init+0x92>
   117d0:	1e20      	subs	r0, r4, #0
   117d2:	bf18      	it	ne
   117d4:	2001      	movne	r0, #1
   117d6:	4921      	ldr	r1, [pc, #132]	; (1185c <_spi_m_dma_init+0xa0>)
   117d8:	4b21      	ldr	r3, [pc, #132]	; (11860 <_spi_m_dma_init+0xa4>)
   117da:	f640 52e3 	movw	r2, #3555	; 0xde3
   117de:	4798      	blx	r3

	if (regs == NULL) {
   117e0:	2e00      	cmp	r6, #0
   117e2:	d036      	beq.n	11852 <_spi_m_dma_init+0x96>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   117e4:	69e3      	ldr	r3, [r4, #28]
   117e6:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1187c <_spi_m_dma_init+0xc0>
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   117ea:	f013 0f01 	tst.w	r3, #1
   117ee:	d112      	bne.n	11816 <_spi_m_dma_init+0x5a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   117f0:	2103      	movs	r1, #3
   117f2:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   117f4:	6837      	ldr	r7, [r6, #0]
   117f6:	47c0      	blx	r8
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   117f8:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   117fa:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   117fc:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11800:	d503      	bpl.n	1180a <_spi_m_dma_init+0x4e>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   11802:	4b18      	ldr	r3, [pc, #96]	; (11864 <_spi_m_dma_init+0xa8>)
   11804:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   11806:	2102      	movs	r1, #2
   11808:	47c0      	blx	r8
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   1180a:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   1180e:	6027      	str	r7, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11810:	2103      	movs	r1, #3
   11812:	4620      	mov	r0, r4
   11814:	47c0      	blx	r8
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
   11816:	462f      	mov	r7, r5
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   11818:	4620      	mov	r0, r4
   1181a:	2101      	movs	r1, #1
   1181c:	47c0      	blx	r8

	_spi_load_regs_master(hw, regs);
   1181e:	4631      	mov	r1, r6
	dev->prvt = hw;
   11820:	f847 4b18 	str.w	r4, [r7], #24
	_spi_load_regs_master(hw, regs);
   11824:	4b10      	ldr	r3, [pc, #64]	; (11868 <_spi_m_dma_init+0xac>)
   11826:	4798      	blx	r3
	uint8_t index = _sercom_get_hardware_index(hw);
   11828:	4b10      	ldr	r3, [pc, #64]	; (1186c <_spi_m_dma_init+0xb0>)
   1182a:	4620      	mov	r0, r4
   1182c:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   1182e:	2807      	cmp	r0, #7
		dev->resource->back                 = dev;
		dev->resource->dma_cb.transfer_done = _spi_dma_rx_complete;
		dev->resource->dma_cb.error         = _spi_dma_error_occured;
	}
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, _spi_get_tx_dma_channel(hw));
   11830:	4b0f      	ldr	r3, [pc, #60]	; (11870 <_spi_m_dma_init+0xb4>)
   11832:	bf0c      	ite	eq
   11834:	2108      	moveq	r1, #8
   11836:	2100      	movne	r1, #0
   11838:	4638      	mov	r0, r7
   1183a:	4798      	blx	r3
	dev->resource->back                 = dev;
   1183c:	69ab      	ldr	r3, [r5, #24]
	dev->resource->dma_cb.transfer_done = _spi_dma_tx_complete;
   1183e:	4a0d      	ldr	r2, [pc, #52]	; (11874 <_spi_m_dma_init+0xb8>)
   11840:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   11842:	4a0d      	ldr	r2, [pc, #52]	; (11878 <_spi_m_dma_init+0xbc>)
	dev->resource->back                 = dev;
   11844:	609d      	str	r5, [r3, #8]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   11846:	605a      	str	r2, [r3, #4]

	return ERR_NONE;
   11848:	2000      	movs	r0, #0
}
   1184a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(dev && hw);
   1184e:	4628      	mov	r0, r5
   11850:	e7c1      	b.n	117d6 <_spi_m_dma_init+0x1a>
		return ERR_INVALID_ARG;
   11852:	f06f 000c 	mvn.w	r0, #12
   11856:	e7f8      	b.n	1184a <_spi_m_dma_init+0x8e>
   11858:	00010ad5 	.word	0x00010ad5
   1185c:	00017581 	.word	0x00017581
   11860:	0000e08d 	.word	0x0000e08d
   11864:	0001093d 	.word	0x0001093d
   11868:	00010df1 	.word	0x00010df1
   1186c:	00010991 	.word	0x00010991
   11870:	0000e2d1 	.word	0x0000e2d1
   11874:	00010b01 	.word	0x00010b01
   11878:	00010b0b 	.word	0x00010b0b
   1187c:	00010919 	.word	0x00010919

00011880 <_spi_m_dma_enable>:
{
	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_dma_enable(struct _spi_m_dma_dev *dev)
{
   11880:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11882:	4604      	mov	r4, r0
   11884:	b118      	cbz	r0, 1188e <_spi_m_dma_enable+0xe>
   11886:	6800      	ldr	r0, [r0, #0]
   11888:	3800      	subs	r0, #0
   1188a:	bf18      	it	ne
   1188c:	2001      	movne	r0, #1
   1188e:	4b05      	ldr	r3, [pc, #20]	; (118a4 <_spi_m_dma_enable+0x24>)
   11890:	4905      	ldr	r1, [pc, #20]	; (118a8 <_spi_m_dma_enable+0x28>)
   11892:	f640 620e 	movw	r2, #3598	; 0xe0e
   11896:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
   11898:	6820      	ldr	r0, [r4, #0]
   1189a:	4b04      	ldr	r3, [pc, #16]	; (118ac <_spi_m_dma_enable+0x2c>)
}
   1189c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_sync_enable(dev->prvt);
   118a0:	4718      	bx	r3
   118a2:	bf00      	nop
   118a4:	0000e08d 	.word	0x0000e08d
   118a8:	00017581 	.word	0x00017581
   118ac:	00010aad 	.word	0x00010aad

000118b0 <_spi_m_dma_register_callback>:
	return size;
}

void _spi_m_dma_register_callback(struct _spi_m_dma_dev *dev, enum _spi_dma_dev_cb_type type, _spi_dma_cb_t func)
{
	switch (type) {
   118b0:	2901      	cmp	r1, #1
{
   118b2:	b573      	push	{r0, r1, r4, r5, r6, lr}
   118b4:	4605      	mov	r5, r0
   118b6:	460e      	mov	r6, r1
   118b8:	4614      	mov	r4, r2
	switch (type) {
   118ba:	d014      	beq.n	118e6 <_spi_m_dma_register_callback+0x36>
   118bc:	2902      	cmp	r1, #2
   118be:	d020      	beq.n	11902 <_spi_m_dma_register_callback+0x52>
   118c0:	2900      	cmp	r1, #0
   118c2:	d138      	bne.n	11936 <_spi_m_dma_register_callback+0x86>
	case SPI_DEV_CB_DMA_TX:
		dev->callbacks.tx = func;
   118c4:	6042      	str	r2, [r0, #4]
	uint8_t index = _sercom_get_hardware_index(hw);
   118c6:	4b1d      	ldr	r3, [pc, #116]	; (1193c <_spi_m_dma_register_callback+0x8c>)
   118c8:	6800      	ldr	r0, [r0, #0]
   118ca:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   118cc:	2807      	cmp	r0, #7
   118ce:	bf08      	it	eq
   118d0:	2608      	moveq	r6, #8
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   118d2:	1e22      	subs	r2, r4, #0
   118d4:	bf18      	it	ne
   118d6:	2201      	movne	r2, #1
   118d8:	2100      	movs	r1, #0
   118da:	4630      	mov	r0, r6
		break;
	case SPI_DEV_CB_DMA_RX:
		dev->callbacks.rx = func;
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   118dc:	4b18      	ldr	r3, [pc, #96]	; (11940 <_spi_m_dma_register_callback+0x90>)
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
		break;
	case SPI_DEV_CB_DMA_N:
		break;
	}
}
   118de:	b002      	add	sp, #8
   118e0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   118e4:	4718      	bx	r3
		dev->callbacks.rx = func;
   118e6:	6082      	str	r2, [r0, #8]
	uint8_t index = _sercom_get_hardware_index(hw);
   118e8:	4b14      	ldr	r3, [pc, #80]	; (1193c <_spi_m_dma_register_callback+0x8c>)
   118ea:	6800      	ldr	r0, [r0, #0]
   118ec:	4798      	blx	r3
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   118ee:	1e22      	subs	r2, r4, #0
   118f0:	bf18      	it	ne
   118f2:	2201      	movne	r2, #1
   118f4:	2807      	cmp	r0, #7
   118f6:	f04f 0100 	mov.w	r1, #0
   118fa:	bf8c      	ite	hi
   118fc:	2000      	movhi	r0, #0
   118fe:	2001      	movls	r0, #1
   11900:	e7ec      	b.n	118dc <_spi_m_dma_register_callback+0x2c>
		dev->callbacks.error = func;
   11902:	60c2      	str	r2, [r0, #12]
	uint8_t index = _sercom_get_hardware_index(hw);
   11904:	4e0d      	ldr	r6, [pc, #52]	; (1193c <_spi_m_dma_register_callback+0x8c>)
   11906:	6800      	ldr	r0, [r0, #0]
   11908:	47b0      	blx	r6
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   1190a:	1e22      	subs	r2, r4, #0
   1190c:	bf18      	it	ne
   1190e:	2201      	movne	r2, #1
   11910:	2807      	cmp	r0, #7
   11912:	bf8c      	ite	hi
   11914:	2000      	movhi	r0, #0
   11916:	2001      	movls	r0, #1
   11918:	2101      	movs	r1, #1
   1191a:	4c09      	ldr	r4, [pc, #36]	; (11940 <_spi_m_dma_register_callback+0x90>)
   1191c:	9201      	str	r2, [sp, #4]
   1191e:	47a0      	blx	r4
	uint8_t index = _sercom_get_hardware_index(hw);
   11920:	6828      	ldr	r0, [r5, #0]
   11922:	47b0      	blx	r6
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11924:	2807      	cmp	r0, #7
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   11926:	9a01      	ldr	r2, [sp, #4]
   11928:	f04f 0101 	mov.w	r1, #1
   1192c:	bf0c      	ite	eq
   1192e:	2008      	moveq	r0, #8
   11930:	2000      	movne	r0, #0
   11932:	4623      	mov	r3, r4
   11934:	e7d3      	b.n	118de <_spi_m_dma_register_callback+0x2e>
}
   11936:	b002      	add	sp, #8
   11938:	bd70      	pop	{r4, r5, r6, pc}
   1193a:	bf00      	nop
   1193c:	00010991 	.word	0x00010991
   11940:	0000e1ed 	.word	0x0000e1ed

00011944 <_spi_m_dma_transfer>:

int32_t _spi_m_dma_transfer(struct _spi_m_dma_dev *dev, uint8_t const *txbuf, uint8_t *const rxbuf,
                            const uint16_t length)
{
   11944:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   11948:	f8d0 8000 	ldr.w	r8, [r0]
	uint8_t index = _sercom_get_hardware_index(hw);
   1194c:	f8df 911c 	ldr.w	r9, [pc, #284]	; 11a6c <_spi_m_dma_transfer+0x128>
{
   11950:	4605      	mov	r5, r0
   11952:	461f      	mov	r7, r3
	uint8_t index = _sercom_get_hardware_index(hw);
   11954:	4640      	mov	r0, r8
   11956:	4b3d      	ldr	r3, [pc, #244]	; (11a4c <_spi_m_dma_transfer+0x108>)
{
   11958:	460e      	mov	r6, r1
   1195a:	4692      	mov	sl, r2
	uint8_t index = _sercom_get_hardware_index(hw);
   1195c:	4798      	blx	r3
	switch (index) {
   1195e:	2807      	cmp	r0, #7
   11960:	4b3b      	ldr	r3, [pc, #236]	; (11a50 <_spi_m_dma_transfer+0x10c>)
   11962:	d86a      	bhi.n	11a3a <_spi_m_dma_transfer+0xf6>
	switch (index) {
   11964:	d06c      	beq.n	11a40 <_spi_m_dma_transfer+0xfc>
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   11966:	f04f 0b01 	mov.w	fp, #1
	uint8_t                          rx_ch = _spi_get_rx_dma_channel(dev->prvt);
	uint8_t                          tx_ch = _spi_get_tx_dma_channel(dev->prvt);

	if (rxbuf) {
   1196a:	f1ba 0f00 	cmp.w	sl, #0
   1196e:	d114      	bne.n	1199a <_spi_m_dma_transfer+0x56>
   11970:	4654      	mov	r4, sl
	ASSERT(dev && dev->prvt);
   11972:	f1b8 0000 	subs.w	r0, r8, #0
   11976:	bf18      	it	ne
   11978:	2001      	movne	r0, #1
   1197a:	4936      	ldr	r1, [pc, #216]	; (11a54 <_spi_m_dma_transfer+0x110>)
   1197c:	f640 523d 	movw	r2, #3389	; 0xd3d
   11980:	4798      	blx	r3
	return _spi_sync_rx_disable(dev->prvt);
   11982:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11984:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   11986:	075b      	lsls	r3, r3, #29
   11988:	d42b      	bmi.n	119e2 <_spi_m_dma_transfer+0x9e>
	((Sercom *)hw)->SPI.CTRLB.reg &= ~SERCOM_SPI_CTRLB_RXEN;
   1198a:	6843      	ldr	r3, [r0, #4]
   1198c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   11990:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11992:	2117      	movs	r1, #23
   11994:	4b30      	ldr	r3, [pc, #192]	; (11a58 <_spi_m_dma_transfer+0x114>)
   11996:	4798      	blx	r3
}
   11998:	e023      	b.n	119e2 <_spi_m_dma_transfer+0x9e>
	if (rxbuf) {
   1199a:	2400      	movs	r4, #0
	ASSERT(dev && dev->prvt);
   1199c:	f1b8 0000 	subs.w	r0, r8, #0
   119a0:	bf18      	it	ne
   119a2:	2001      	movne	r0, #1
   119a4:	f640 5236 	movw	r2, #3382	; 0xd36
   119a8:	492a      	ldr	r1, [pc, #168]	; (11a54 <_spi_m_dma_transfer+0x110>)
   119aa:	4798      	blx	r3
	return _spi_sync_rx_enable(dev->prvt);
   119ac:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   119ae:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   119b0:	075a      	lsls	r2, r3, #29
   119b2:	d406      	bmi.n	119c2 <_spi_m_dma_transfer+0x7e>
	((Sercom *)hw)->SPI.CTRLB.reg |= SERCOM_SPI_CTRLB_RXEN;
   119b4:	6843      	ldr	r3, [r0, #4]
   119b6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   119ba:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   119bc:	2117      	movs	r1, #23
   119be:	4b26      	ldr	r3, [pc, #152]	; (11a58 <_spi_m_dma_transfer+0x114>)
   119c0:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   119c2:	6829      	ldr	r1, [r5, #0]
		/* Enable spi rx */
		_spi_m_dma_rx_enable(dev);
		_dma_set_source_address(rx_ch, (void *)_spi_m_get_source_for_dma(dev->prvt));
   119c4:	4b25      	ldr	r3, [pc, #148]	; (11a5c <_spi_m_dma_transfer+0x118>)
   119c6:	3128      	adds	r1, #40	; 0x28
   119c8:	4658      	mov	r0, fp
   119ca:	4798      	blx	r3
		_dma_set_destination_address(rx_ch, rxbuf);
   119cc:	4651      	mov	r1, sl
   119ce:	4658      	mov	r0, fp
   119d0:	47c8      	blx	r9
		_dma_set_data_amount(rx_ch, length);
   119d2:	4b23      	ldr	r3, [pc, #140]	; (11a60 <_spi_m_dma_transfer+0x11c>)
   119d4:	4639      	mov	r1, r7
   119d6:	4658      	mov	r0, fp
   119d8:	4798      	blx	r3
		_dma_enable_transaction(rx_ch, false);
   119da:	4b22      	ldr	r3, [pc, #136]	; (11a64 <_spi_m_dma_transfer+0x120>)
   119dc:	2100      	movs	r1, #0
   119de:	4658      	mov	r0, fp
   119e0:	4798      	blx	r3
	} else {
		/* Disable spi rx */
		_spi_m_dma_rx_disable(dev);
	}

	if (txbuf) {
   119e2:	f8df a07c 	ldr.w	sl, [pc, #124]	; 11a60 <_spi_m_dma_transfer+0x11c>
   119e6:	f8df b088 	ldr.w	fp, [pc, #136]	; 11a70 <_spi_m_dma_transfer+0x12c>
   119ea:	b1c6      	cbz	r6, 11a1e <_spi_m_dma_transfer+0xda>
		/* Enable spi tx */
		_dma_set_source_address(tx_ch, txbuf);
   119ec:	4b1b      	ldr	r3, [pc, #108]	; (11a5c <_spi_m_dma_transfer+0x118>)
   119ee:	4631      	mov	r1, r6
   119f0:	4620      	mov	r0, r4
   119f2:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   119f4:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   119f6:	4620      	mov	r0, r4
   119f8:	3128      	adds	r1, #40	; 0x28
   119fa:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, true);
   119fc:	2101      	movs	r1, #1
		_dma_set_data_amount(tx_ch, length);
	} else {
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
		_dma_srcinc_enable(tx_ch, false);
   119fe:	4620      	mov	r0, r4
   11a00:	47d8      	blx	fp
		_dma_set_data_amount(tx_ch, length);
   11a02:	4639      	mov	r1, r7
   11a04:	4620      	mov	r0, r4
   11a06:	47d0      	blx	sl
	}
	_dma_enable_transaction(tx_ch, false);
   11a08:	4b16      	ldr	r3, [pc, #88]	; (11a64 <_spi_m_dma_transfer+0x120>)
   11a0a:	2100      	movs	r1, #0
   11a0c:	4620      	mov	r0, r4
   11a0e:	4798      	blx	r3

	return ERR_NONE;
}
   11a10:	2000      	movs	r0, #0
   11a12:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   11a16:	f04f 0b01 	mov.w	fp, #1
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11a1a:	2408      	movs	r4, #8
   11a1c:	e7be      	b.n	1199c <_spi_m_dma_transfer+0x58>
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   11a1e:	4b12      	ldr	r3, [pc, #72]	; (11a68 <_spi_m_dma_transfer+0x124>)
   11a20:	4640      	mov	r0, r8
   11a22:	4798      	blx	r3
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
   11a24:	4b0d      	ldr	r3, [pc, #52]	; (11a5c <_spi_m_dma_transfer+0x118>)
   11a26:	f100 010e 	add.w	r1, r0, #14
   11a2a:	4620      	mov	r0, r4
   11a2c:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   11a2e:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   11a30:	4620      	mov	r0, r4
   11a32:	3128      	adds	r1, #40	; 0x28
   11a34:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, false);
   11a36:	4631      	mov	r1, r6
   11a38:	e7e1      	b.n	119fe <_spi_m_dma_transfer+0xba>
		return CONF_SERCOM_0_SPI_M_DMA_TX_CHANNEL;
   11a3a:	f04f 0b00 	mov.w	fp, #0
   11a3e:	e794      	b.n	1196a <_spi_m_dma_transfer+0x26>
	if (rxbuf) {
   11a40:	f1ba 0f00 	cmp.w	sl, #0
   11a44:	d1e7      	bne.n	11a16 <_spi_m_dma_transfer+0xd2>
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11a46:	2408      	movs	r4, #8
   11a48:	e793      	b.n	11972 <_spi_m_dma_transfer+0x2e>
   11a4a:	bf00      	nop
   11a4c:	00010991 	.word	0x00010991
   11a50:	0000e08d 	.word	0x0000e08d
   11a54:	00017581 	.word	0x00017581
   11a58:	00010919 	.word	0x00010919
   11a5c:	0000e225 	.word	0x0000e225
   11a60:	0000e251 	.word	0x0000e251
   11a64:	0000e295 	.word	0x0000e295
   11a68:	00010ad5 	.word	0x00010ad5
   11a6c:	0000e215 	.word	0x0000e215
   11a70:	0000e235 	.word	0x0000e235

00011a74 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
   11a74:	b570      	push	{r4, r5, r6, lr}
   11a76:	460e      	mov	r6, r1
   11a78:	4614      	mov	r4, r2
	ASSERT(rb && buf && size);
   11a7a:	4605      	mov	r5, r0
   11a7c:	b118      	cbz	r0, 11a86 <ringbuffer_init+0x12>
   11a7e:	b189      	cbz	r1, 11aa4 <ringbuffer_init+0x30>
   11a80:	1e10      	subs	r0, r2, #0
   11a82:	bf18      	it	ne
   11a84:	2001      	movne	r0, #1
   11a86:	4908      	ldr	r1, [pc, #32]	; (11aa8 <ringbuffer_init+0x34>)
   11a88:	4b08      	ldr	r3, [pc, #32]	; (11aac <ringbuffer_init+0x38>)
   11a8a:	2228      	movs	r2, #40	; 0x28
   11a8c:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
   11a8e:	1e63      	subs	r3, r4, #1
   11a90:	ea13 0004 	ands.w	r0, r3, r4
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
	rb->read_index  = 0;
   11a94:	bf03      	ittte	eq
   11a96:	e9c5 3001 	strdeq	r3, r0, [r5, #4]
	rb->write_index = rb->read_index;
   11a9a:	60e8      	streq	r0, [r5, #12]
	rb->buf         = (uint8_t *)buf;
   11a9c:	602e      	streq	r6, [r5, #0]
		return ERR_INVALID_ARG;
   11a9e:	f06f 000c 	mvnne.w	r0, #12

	return ERR_NONE;
}
   11aa2:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
   11aa4:	4608      	mov	r0, r1
   11aa6:	e7ee      	b.n	11a86 <ringbuffer_init+0x12>
   11aa8:	00017670 	.word	0x00017670
   11aac:	0000e08d 	.word	0x0000e08d

00011ab0 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
   11ab0:	b538      	push	{r3, r4, r5, lr}
   11ab2:	460d      	mov	r5, r1
	ASSERT(rb && data);
   11ab4:	4604      	mov	r4, r0
   11ab6:	b110      	cbz	r0, 11abe <ringbuffer_get+0xe>
   11ab8:	1e08      	subs	r0, r1, #0
   11aba:	bf18      	it	ne
   11abc:	2001      	movne	r0, #1
   11abe:	4b0a      	ldr	r3, [pc, #40]	; (11ae8 <ringbuffer_get+0x38>)
   11ac0:	490a      	ldr	r1, [pc, #40]	; (11aec <ringbuffer_get+0x3c>)
   11ac2:	2240      	movs	r2, #64	; 0x40
   11ac4:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
   11ac6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   11aca:	429a      	cmp	r2, r3
   11acc:	d009      	beq.n	11ae2 <ringbuffer_get+0x32>
		*data = rb->buf[rb->read_index & rb->size];
   11ace:	6862      	ldr	r2, [r4, #4]
   11ad0:	4013      	ands	r3, r2
   11ad2:	6822      	ldr	r2, [r4, #0]
   11ad4:	5cd3      	ldrb	r3, [r2, r3]
   11ad6:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
   11ad8:	68a3      	ldr	r3, [r4, #8]
   11ada:	3301      	adds	r3, #1
   11adc:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
   11ade:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
   11ae0:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NOT_FOUND;
   11ae2:	f06f 0009 	mvn.w	r0, #9
   11ae6:	e7fb      	b.n	11ae0 <ringbuffer_get+0x30>
   11ae8:	0000e08d 	.word	0x0000e08d
   11aec:	00017670 	.word	0x00017670

00011af0 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
   11af0:	b538      	push	{r3, r4, r5, lr}
	ASSERT(rb);
   11af2:	4604      	mov	r4, r0
   11af4:	3800      	subs	r0, #0
   11af6:	bf18      	it	ne
   11af8:	2001      	movne	r0, #1
{
   11afa:	460d      	mov	r5, r1
	ASSERT(rb);
   11afc:	4b0b      	ldr	r3, [pc, #44]	; (11b2c <ringbuffer_put+0x3c>)
   11afe:	490c      	ldr	r1, [pc, #48]	; (11b30 <ringbuffer_put+0x40>)
   11b00:	2251      	movs	r2, #81	; 0x51
   11b02:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
   11b04:	68e3      	ldr	r3, [r4, #12]
   11b06:	6862      	ldr	r2, [r4, #4]
   11b08:	4013      	ands	r3, r2
   11b0a:	6822      	ldr	r2, [r4, #0]
   11b0c:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
   11b0e:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   11b12:	68e3      	ldr	r3, [r4, #12]
   11b14:	1a59      	subs	r1, r3, r1
   11b16:	4291      	cmp	r1, r2
		rb->read_index = rb->write_index - rb->size;
   11b18:	bf88      	it	hi
   11b1a:	1a9a      	subhi	r2, r3, r2
	}

	rb->write_index++;
   11b1c:	f103 0301 	add.w	r3, r3, #1
		rb->read_index = rb->write_index - rb->size;
   11b20:	bf88      	it	hi
   11b22:	60a2      	strhi	r2, [r4, #8]
	rb->write_index++;
   11b24:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
   11b26:	2000      	movs	r0, #0
   11b28:	bd38      	pop	{r3, r4, r5, pc}
   11b2a:	bf00      	nop
   11b2c:	0000e08d 	.word	0x0000e08d
   11b30:	00017670 	.word	0x00017670

00011b34 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
   11b34:	b510      	push	{r4, lr}
	ASSERT(rb);
   11b36:	4604      	mov	r4, r0
   11b38:	3800      	subs	r0, #0
   11b3a:	bf18      	it	ne
   11b3c:	2001      	movne	r0, #1
   11b3e:	4904      	ldr	r1, [pc, #16]	; (11b50 <ringbuffer_num+0x1c>)
   11b40:	4b04      	ldr	r3, [pc, #16]	; (11b54 <ringbuffer_num+0x20>)
   11b42:	2267      	movs	r2, #103	; 0x67
   11b44:	4798      	blx	r3

	return rb->write_index - rb->read_index;
   11b46:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
}
   11b4a:	1ac0      	subs	r0, r0, r3
   11b4c:	bd10      	pop	{r4, pc}
   11b4e:	bf00      	nop
   11b50:	00017670 	.word	0x00017670
   11b54:	0000e08d 	.word	0x0000e08d

00011b58 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   11b58:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
   11b5c:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   11b5e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   11b60:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
   11b64:	4770      	bx	lr

00011b66 <atomic_leave_critical>:
   11b66:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
   11b6a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   11b6c:	f383 8810 	msr	PRIMASK, r3
}
   11b70:	4770      	bx	lr
	...

00011b74 <RTC_Scheduler_ping_cb>:
static struct timer_task RTC_Scheduler_heartbeat;

void RTC_Scheduler_ping_cb(const struct timer_task *const timer_task)
{

	pingflag++;
   11b74:	4a0d      	ldr	r2, [pc, #52]	; (11bac <RTC_Scheduler_ping_cb+0x38>)
   11b76:	7813      	ldrb	r3, [r2, #0]
   11b78:	3301      	adds	r3, #1
   11b7a:	b2db      	uxtb	r3, r3
   11b7c:	7013      	strb	r3, [r2, #0]
	
	switch (pingflag%4)
   11b7e:	7813      	ldrb	r3, [r2, #0]
   11b80:	f003 0303 	and.w	r3, r3, #3
   11b84:	2b02      	cmp	r3, #2
   11b86:	f642 7248 	movw	r2, #12104	; 0x2f48
   11b8a:	d00a      	beq.n	11ba2 <RTC_Scheduler_ping_cb+0x2e>
   11b8c:	2b03      	cmp	r3, #3
   11b8e:	d00a      	beq.n	11ba6 <RTC_Scheduler_ping_cb+0x32>
   11b90:	2b01      	cmp	r3, #1
   11b92:	d003      	beq.n	11b9c <RTC_Scheduler_ping_cb+0x28>
	{
		case 0:
			GRID_PORT_N.ping_flag = 1;
   11b94:	4b06      	ldr	r3, [pc, #24]	; (11bb0 <RTC_Scheduler_ping_cb+0x3c>)
			break;
		case 2:
			GRID_PORT_S.ping_flag = 1;
			break;
		case 3:
			GRID_PORT_W.ping_flag = 1;
   11b96:	2101      	movs	r1, #1
   11b98:	5499      	strb	r1, [r3, r2]
			break;
	}
	
}
   11b9a:	4770      	bx	lr
			GRID_PORT_E.ping_flag = 1;
   11b9c:	4905      	ldr	r1, [pc, #20]	; (11bb4 <RTC_Scheduler_ping_cb+0x40>)
   11b9e:	548b      	strb	r3, [r1, r2]
			break;
   11ba0:	4770      	bx	lr
			GRID_PORT_S.ping_flag = 1;
   11ba2:	4b05      	ldr	r3, [pc, #20]	; (11bb8 <RTC_Scheduler_ping_cb+0x44>)
   11ba4:	e7f7      	b.n	11b96 <RTC_Scheduler_ping_cb+0x22>
			GRID_PORT_W.ping_flag = 1;
   11ba6:	4b05      	ldr	r3, [pc, #20]	; (11bbc <RTC_Scheduler_ping_cb+0x48>)
   11ba8:	e7f5      	b.n	11b96 <RTC_Scheduler_ping_cb+0x22>
   11baa:	bf00      	nop
   11bac:	20008d80 	.word	0x20008d80
   11bb0:	20009150 	.word	0x20009150
   11bb4:	20019870 	.word	0x20019870
   11bb8:	200138d4 	.word	0x200138d4
   11bbc:	200102d4 	.word	0x200102d4

00011bc0 <RTC_Scheduler_heartbeat_cb>:
	}

}

void RTC_Scheduler_heartbeat_cb(const struct timer_task *const timer_task)
{
   11bc0:	b410      	push	{r4}
	
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11bc2:	4c04      	ldr	r4, [pc, #16]	; (11bd4 <RTC_Scheduler_heartbeat_cb+0x14>)
   11bc4:	4804      	ldr	r0, [pc, #16]	; (11bd8 <RTC_Scheduler_heartbeat_cb+0x18>)
   11bc6:	2200      	movs	r2, #0
   11bc8:	46a4      	mov	ip, r4
   11bca:	230c      	movs	r3, #12

}
   11bcc:	f85d 4b04 	ldr.w	r4, [sp], #4
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11bd0:	4611      	mov	r1, r2
   11bd2:	4760      	bx	ip
   11bd4:	0000a191 	.word	0x0000a191
   11bd8:	2001c7c0 	.word	0x2001c7c0

00011bdc <example_task>:
{
   11bdc:	b507      	push	{r0, r1, r2, lr}
		CRITICAL_SECTION_ENTER()
   11bde:	4e08      	ldr	r6, [pc, #32]	; (11c00 <example_task+0x24>)
		printf("ExampleTask ????... %d \r\n", globaltest);
   11be0:	4d08      	ldr	r5, [pc, #32]	; (11c04 <example_task+0x28>)
   11be2:	4c09      	ldr	r4, [pc, #36]	; (11c08 <example_task+0x2c>)
		CRITICAL_SECTION_ENTER()
   11be4:	a801      	add	r0, sp, #4
   11be6:	47b0      	blx	r6
		printf("ExampleTask ????... %d \r\n", globaltest);
   11be8:	6869      	ldr	r1, [r5, #4]
   11bea:	4b08      	ldr	r3, [pc, #32]	; (11c0c <example_task+0x30>)
   11bec:	4620      	mov	r0, r4
   11bee:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
   11bf0:	a801      	add	r0, sp, #4
   11bf2:	4b07      	ldr	r3, [pc, #28]	; (11c10 <example_task+0x34>)
   11bf4:	4798      	blx	r3
		vTaskDelay(1000*configTICK_RATE_HZ/1000);
   11bf6:	4b07      	ldr	r3, [pc, #28]	; (11c14 <example_task+0x38>)
   11bf8:	f241 3088 	movw	r0, #5000	; 0x1388
   11bfc:	4798      	blx	r3
	while (1) {
   11bfe:	e7f1      	b.n	11be4 <example_task+0x8>
   11c00:	00011b59 	.word	0x00011b59
   11c04:	20008d80 	.word	0x20008d80
   11c08:	00017694 	.word	0x00017694
   11c0c:	000146ad 	.word	0x000146ad
   11c10:	00011b67 	.word	0x00011b67
   11c14:	000129ed 	.word	0x000129ed

00011c18 <inbound_task>:
static void inbound_task(void *p){
   11c18:	b508      	push	{r3, lr}
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11c1a:	4c02      	ldr	r4, [pc, #8]	; (11c24 <inbound_task+0xc>)
   11c1c:	2005      	movs	r0, #5
   11c1e:	47a0      	blx	r4
	while (1) {
   11c20:	e7fc      	b.n	11c1c <inbound_task+0x4>
   11c22:	bf00      	nop
   11c24:	000129ed 	.word	0x000129ed

00011c28 <usb_task_inner>:
static void usb_task_inner(){
   11c28:	b570      	push	{r4, r5, r6, lr}
	grid_keyboard_tx_pop();
   11c2a:	4b2c      	ldr	r3, [pc, #176]	; (11cdc <usb_task_inner+0xb4>)
static void usb_task_inner(){
   11c2c:	b08a      	sub	sp, #40	; 0x28
	grid_keyboard_tx_pop();
   11c2e:	4798      	blx	r3
	grid_midi_tx_pop();        
   11c30:	4b2b      	ldr	r3, [pc, #172]	; (11ce0 <usb_task_inner+0xb8>)
   11c32:	4798      	blx	r3
	audiodf_midi_read(midi_rx_buffer,16);
   11c34:	4b2b      	ldr	r3, [pc, #172]	; (11ce4 <usb_task_inner+0xbc>)
   11c36:	482c      	ldr	r0, [pc, #176]	; (11ce8 <usb_task_inner+0xc0>)
   11c38:	2110      	movs	r1, #16
   11c3a:	4798      	blx	r3
		if (midi_rx_buffer[i]){
   11c3c:	492b      	ldr	r1, [pc, #172]	; (11cec <usb_task_inner+0xc4>)
	audiodf_midi_read(midi_rx_buffer,16);
   11c3e:	2200      	movs	r2, #0
	uint8_t found = 0;
   11c40:	4613      	mov	r3, r2
   11c42:	460d      	mov	r5, r1
		if (midi_rx_buffer[i]){
   11c44:	1888      	adds	r0, r1, r2
   11c46:	7a00      	ldrb	r0, [r0, #8]
   11c48:	b108      	cbz	r0, 11c4e <usb_task_inner+0x26>
			found++;
   11c4a:	3301      	adds	r3, #1
   11c4c:	b2db      	uxtb	r3, r3
	for (uint8_t i=0; i<16; i++){
   11c4e:	3201      	adds	r2, #1
   11c50:	2a10      	cmp	r2, #16
   11c52:	d1f7      	bne.n	11c44 <usb_task_inner+0x1c>
	if (found){
   11c54:	b313      	cbz	r3, 11c9c <usb_task_inner+0x74>
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c56:	7a29      	ldrb	r1, [r5, #8]
   11c58:	7a6a      	ldrb	r2, [r5, #9]
   11c5a:	7aab      	ldrb	r3, [r5, #10]
   11c5c:	7ae8      	ldrb	r0, [r5, #11]
   11c5e:	4c24      	ldr	r4, [pc, #144]	; (11cf0 <usb_task_inner+0xc8>)
   11c60:	9000      	str	r0, [sp, #0]
   11c62:	4824      	ldr	r0, [pc, #144]	; (11cf4 <usb_task_inner+0xcc>)
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c64:	4e24      	ldr	r6, [pc, #144]	; (11cf8 <usb_task_inner+0xd0>)
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c66:	47a0      	blx	r4
		uint8_t message[30] = {0};
   11c68:	2400      	movs	r4, #0
   11c6a:	4b24      	ldr	r3, [pc, #144]	; (11cfc <usb_task_inner+0xd4>)
   11c6c:	9402      	str	r4, [sp, #8]
   11c6e:	221a      	movs	r2, #26
   11c70:	4621      	mov	r1, r4
   11c72:	a803      	add	r0, sp, #12
   11c74:	4798      	blx	r3
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11c76:	7a2a      	ldrb	r2, [r5, #8]
   11c78:	7a6b      	ldrb	r3, [r5, #9]
   11c7a:	7aa9      	ldrb	r1, [r5, #10]
   11c7c:	7ae8      	ldrb	r0, [r5, #11]
   11c7e:	e9cd 1000 	strd	r1, r0, [sp]
   11c82:	491c      	ldr	r1, [pc, #112]	; (11cf4 <usb_task_inner+0xcc>)
   11c84:	a802      	add	r0, sp, #8
   11c86:	47b0      	blx	r6
		grid_debug_print_text(message);
   11c88:	4b1d      	ldr	r3, [pc, #116]	; (11d00 <usb_task_inner+0xd8>)
   11c8a:	a802      	add	r0, sp, #8
   11c8c:	4798      	blx	r3
   11c8e:	4621      	mov	r1, r4
			midi_rx_buffer[i] = 0;
   11c90:	4622      	mov	r2, r4
   11c92:	186b      	adds	r3, r5, r1
   11c94:	3101      	adds	r1, #1
		for (uint8_t i=0; i<16; i++){
   11c96:	2910      	cmp	r1, #16
			midi_rx_buffer[i] = 0;
   11c98:	721a      	strb	r2, [r3, #8]
		for (uint8_t i=0; i<16; i++){
   11c9a:	d1fa      	bne.n	11c92 <usb_task_inner+0x6a>
	cdcdf_acm_read(GRID_PORT_H.rx_double_buffer, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);			
   11c9c:	4b19      	ldr	r3, [pc, #100]	; (11d04 <usb_task_inner+0xdc>)
   11c9e:	481a      	ldr	r0, [pc, #104]	; (11d08 <usb_task_inner+0xe0>)
   11ca0:	f44f 7100 	mov.w	r1, #512	; 0x200
   11ca4:	4798      	blx	r3
	uint16_t usblength = strlen(GRID_PORT_H.rx_double_buffer);
   11ca6:	4818      	ldr	r0, [pc, #96]	; (11d08 <usb_task_inner+0xe0>)
   11ca8:	4b18      	ldr	r3, [pc, #96]	; (11d0c <usb_task_inner+0xe4>)
   11caa:	4798      	blx	r3
	if (usblength){	
   11cac:	4606      	mov	r6, r0
   11cae:	b190      	cbz	r0, 11cd6 <usb_task_inner+0xae>
		GRID_PORT_H.rx_double_buffer_status = 1;			
   11cb0:	4d17      	ldr	r5, [pc, #92]	; (11d10 <usb_task_inner+0xe8>)
   11cb2:	2301      	movs	r3, #1
   11cb4:	622b      	str	r3, [r5, #32]
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   11cb6:	2400      	movs	r4, #0
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   11cb8:	1ec3      	subs	r3, r0, #3
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   11cba:	62ac      	str	r4, [r5, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_H);
   11cbc:	4628      	mov	r0, r5
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   11cbe:	626b      	str	r3, [r5, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_H);
   11cc0:	4b14      	ldr	r3, [pc, #80]	; (11d14 <usb_task_inner+0xec>)
   11cc2:	4798      	blx	r3
		for(uint32_t i=0; i<usblength; i++){
   11cc4:	4623      	mov	r3, r4
			GRID_PORT_H.rx_double_buffer[i] = 0;
   11cc6:	f241 32b4 	movw	r2, #5044	; 0x13b4
   11cca:	4620      	mov	r0, r4
   11ccc:	18e9      	adds	r1, r5, r3
		for(uint32_t i=0; i<usblength; i++){
   11cce:	3301      	adds	r3, #1
   11cd0:	429e      	cmp	r6, r3
			GRID_PORT_H.rx_double_buffer[i] = 0;
   11cd2:	5488      	strb	r0, [r1, r2]
		for(uint32_t i=0; i<usblength; i++){
   11cd4:	d1fa      	bne.n	11ccc <usb_task_inner+0xa4>
}
   11cd6:	b00a      	add	sp, #40	; 0x28
   11cd8:	bd70      	pop	{r4, r5, r6, pc}
   11cda:	bf00      	nop
   11cdc:	0000b069 	.word	0x0000b069
   11ce0:	0000af49 	.word	0x0000af49
   11ce4:	00004565 	.word	0x00004565
   11ce8:	20008d88 	.word	0x20008d88
   11cec:	20008d80 	.word	0x20008d80
   11cf0:	000146ad 	.word	0x000146ad
   11cf4:	000176ae 	.word	0x000176ae
   11cf8:	00014ac5 	.word	0x00014ac5
   11cfc:	00014469 	.word	0x00014469
   11d00:	00009279 	.word	0x00009279
   11d04:	0000bd75 	.word	0x0000bd75
   11d08:	20017bd8 	.word	0x20017bd8
   11d0c:	00014f81 	.word	0x00014f81
   11d10:	20016824 	.word	0x20016824
   11d14:	00004d89 	.word	0x00004d89

00011d18 <usb_task>:
{
   11d18:	b508      	push	{r3, lr}
		usb_task_inner();
   11d1a:	4d03      	ldr	r5, [pc, #12]	; (11d28 <usb_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11d1c:	4c03      	ldr	r4, [pc, #12]	; (11d2c <usb_task+0x14>)
		usb_task_inner();
   11d1e:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11d20:	2005      	movs	r0, #5
   11d22:	47a0      	blx	r4
	while (1) {
   11d24:	e7fb      	b.n	11d1e <usb_task+0x6>
   11d26:	bf00      	nop
   11d28:	00011c29 	.word	0x00011c29
   11d2c:	000129ed 	.word	0x000129ed

00011d30 <receive_task_inner>:
static void receive_task_inner(){
   11d30:	b510      	push	{r4, lr}
	grid_port_receive_task(&GRID_PORT_N);
   11d32:	4806      	ldr	r0, [pc, #24]	; (11d4c <receive_task_inner+0x1c>)
   11d34:	4c06      	ldr	r4, [pc, #24]	; (11d50 <receive_task_inner+0x20>)
   11d36:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_E);
   11d38:	4806      	ldr	r0, [pc, #24]	; (11d54 <receive_task_inner+0x24>)
   11d3a:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_S);
   11d3c:	4806      	ldr	r0, [pc, #24]	; (11d58 <receive_task_inner+0x28>)
   11d3e:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_W);							
   11d40:	4623      	mov	r3, r4
   11d42:	4806      	ldr	r0, [pc, #24]	; (11d5c <receive_task_inner+0x2c>)
}
   11d44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_receive_task(&GRID_PORT_W);							
   11d48:	4718      	bx	r3
   11d4a:	bf00      	nop
   11d4c:	20009150 	.word	0x20009150
   11d50:	00004d89 	.word	0x00004d89
   11d54:	20019870 	.word	0x20019870
   11d58:	200138d4 	.word	0x200138d4
   11d5c:	200102d4 	.word	0x200102d4

00011d60 <receive_task>:
static void receive_task(void *p){
   11d60:	b508      	push	{r3, lr}
		receive_task_inner();
   11d62:	4d03      	ldr	r5, [pc, #12]	; (11d70 <receive_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11d64:	4c03      	ldr	r4, [pc, #12]	; (11d74 <receive_task+0x14>)
		receive_task_inner();
   11d66:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11d68:	2005      	movs	r0, #5
   11d6a:	47a0      	blx	r4
	while (1) {
   11d6c:	e7fb      	b.n	11d66 <receive_task+0x6>
   11d6e:	bf00      	nop
   11d70:	00011d31 	.word	0x00011d31
   11d74:	000129ed 	.word	0x000129ed

00011d78 <nvm_task_inner>:
static void nvm_task_inner(){
   11d78:	b510      	push	{r4, lr}
	if (GRID_PORT_U.rx_double_buffer_status == 0){
   11d7a:	4c1a      	ldr	r4, [pc, #104]	; (11de4 <nvm_task_inner+0x6c>)
   11d7c:	6a23      	ldr	r3, [r4, #32]
   11d7e:	b943      	cbnz	r3, 11d92 <nvm_task_inner+0x1a>
		if (grid_nvm_ui_bulk_read_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11d80:	4919      	ldr	r1, [pc, #100]	; (11de8 <nvm_task_inner+0x70>)
   11d82:	481a      	ldr	r0, [pc, #104]	; (11dec <nvm_task_inner+0x74>)
   11d84:	4b1a      	ldr	r3, [pc, #104]	; (11df0 <nvm_task_inner+0x78>)
   11d86:	4798      	blx	r3
   11d88:	b118      	cbz	r0, 11d92 <nvm_task_inner+0x1a>
			grid_nvm_ui_bulk_read_next(&grid_nvm_state, &grid_ui_state);
   11d8a:	4917      	ldr	r1, [pc, #92]	; (11de8 <nvm_task_inner+0x70>)
   11d8c:	4817      	ldr	r0, [pc, #92]	; (11dec <nvm_task_inner+0x74>)
   11d8e:	4b19      	ldr	r3, [pc, #100]	; (11df4 <nvm_task_inner+0x7c>)
   11d90:	4798      	blx	r3
	if (grid_nvm_ui_bulk_clear_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11d92:	4915      	ldr	r1, [pc, #84]	; (11de8 <nvm_task_inner+0x70>)
   11d94:	4815      	ldr	r0, [pc, #84]	; (11dec <nvm_task_inner+0x74>)
   11d96:	4b18      	ldr	r3, [pc, #96]	; (11df8 <nvm_task_inner+0x80>)
   11d98:	4798      	blx	r3
   11d9a:	b118      	cbz	r0, 11da4 <nvm_task_inner+0x2c>
		grid_nvm_ui_bulk_clear_next(&grid_nvm_state, &grid_ui_state);
   11d9c:	4912      	ldr	r1, [pc, #72]	; (11de8 <nvm_task_inner+0x70>)
   11d9e:	4813      	ldr	r0, [pc, #76]	; (11dec <nvm_task_inner+0x74>)
   11da0:	4b16      	ldr	r3, [pc, #88]	; (11dfc <nvm_task_inner+0x84>)
   11da2:	4798      	blx	r3
	if (grid_nvm_ui_bulk_store_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11da4:	4910      	ldr	r1, [pc, #64]	; (11de8 <nvm_task_inner+0x70>)
   11da6:	4811      	ldr	r0, [pc, #68]	; (11dec <nvm_task_inner+0x74>)
   11da8:	4b15      	ldr	r3, [pc, #84]	; (11e00 <nvm_task_inner+0x88>)
   11daa:	4798      	blx	r3
   11dac:	b118      	cbz	r0, 11db6 <nvm_task_inner+0x3e>
		grid_nvm_ui_bulk_store_next(&grid_nvm_state, &grid_ui_state);
   11dae:	490e      	ldr	r1, [pc, #56]	; (11de8 <nvm_task_inner+0x70>)
   11db0:	480e      	ldr	r0, [pc, #56]	; (11dec <nvm_task_inner+0x74>)
   11db2:	4b14      	ldr	r3, [pc, #80]	; (11e04 <nvm_task_inner+0x8c>)
   11db4:	4798      	blx	r3
	uint32_t nvmlength = GRID_PORT_U.rx_double_buffer_status;
   11db6:	6a23      	ldr	r3, [r4, #32]
	if (nvmlength){
   11db8:	b143      	cbz	r3, 11dcc <nvm_task_inner+0x54>
		GRID_PORT_U.rx_double_buffer_status = 1;
   11dba:	2201      	movs	r2, #1
   11dbc:	6222      	str	r2, [r4, #32]
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   11dbe:	3b01      	subs	r3, #1
		GRID_PORT_U.rx_double_buffer_read_start_index = 0;
   11dc0:	2200      	movs	r2, #0
   11dc2:	62a2      	str	r2, [r4, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_U);	
   11dc4:	4807      	ldr	r0, [pc, #28]	; (11de4 <nvm_task_inner+0x6c>)
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   11dc6:	6263      	str	r3, [r4, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_U);	
   11dc8:	4b0f      	ldr	r3, [pc, #60]	; (11e08 <nvm_task_inner+0x90>)
   11dca:	4798      	blx	r3
static void nvm_task_inner(){
   11dcc:	2300      	movs	r3, #0
		GRID_PORT_U.rx_double_buffer[i] = 0;
   11dce:	f241 32b4 	movw	r2, #5044	; 0x13b4
   11dd2:	4618      	mov	r0, r3
   11dd4:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   11dd6:	3301      	adds	r3, #1
   11dd8:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
		GRID_PORT_U.rx_double_buffer[i] = 0;
   11ddc:	5488      	strb	r0, [r1, r2]
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   11dde:	d1f9      	bne.n	11dd4 <nvm_task_inner+0x5c>
}
   11de0:	bd10      	pop	{r4, pc}
   11de2:	bf00      	nop
   11de4:	2000c0b0 	.word	0x2000c0b0
   11de8:	2000effc 	.word	0x2000effc
   11dec:	2000fa1c 	.word	0x2000fa1c
   11df0:	0000882f 	.word	0x0000882f
   11df4:	00008835 	.word	0x00008835
   11df8:	00008b07 	.word	0x00008b07
   11dfc:	00008b0d 	.word	0x00008b0d
   11e00:	00008943 	.word	0x00008943
   11e04:	00008949 	.word	0x00008949
   11e08:	00004d89 	.word	0x00004d89

00011e0c <inbound_task_inner>:
static void inbound_task_inner(){
   11e0c:	b510      	push	{r4, lr}
	grid_port_process_inbound(&GRID_PORT_U, 1); // Loopback
   11e0e:	2101      	movs	r1, #1
   11e10:	4c0a      	ldr	r4, [pc, #40]	; (11e3c <inbound_task_inner+0x30>)
   11e12:	480b      	ldr	r0, [pc, #44]	; (11e40 <inbound_task_inner+0x34>)
   11e14:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_N, 0);		
   11e16:	2100      	movs	r1, #0
   11e18:	480a      	ldr	r0, [pc, #40]	; (11e44 <inbound_task_inner+0x38>)
   11e1a:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_E, 0);		
   11e1c:	2100      	movs	r1, #0
   11e1e:	480a      	ldr	r0, [pc, #40]	; (11e48 <inbound_task_inner+0x3c>)
   11e20:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_S, 0);
   11e22:	2100      	movs	r1, #0
   11e24:	4809      	ldr	r0, [pc, #36]	; (11e4c <inbound_task_inner+0x40>)
   11e26:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_W, 0);
   11e28:	2100      	movs	r1, #0
   11e2a:	4809      	ldr	r0, [pc, #36]	; (11e50 <inbound_task_inner+0x44>)
   11e2c:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   11e2e:	4623      	mov	r3, r4
   11e30:	4808      	ldr	r0, [pc, #32]	; (11e54 <inbound_task_inner+0x48>)
}
   11e32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   11e36:	2100      	movs	r1, #0
   11e38:	4718      	bx	r3
   11e3a:	bf00      	nop
   11e3c:	00005209 	.word	0x00005209
   11e40:	2000c0b0 	.word	0x2000c0b0
   11e44:	20009150 	.word	0x20009150
   11e48:	20019870 	.word	0x20019870
   11e4c:	200138d4 	.word	0x200138d4
   11e50:	200102d4 	.word	0x200102d4
   11e54:	20016824 	.word	0x20016824

00011e58 <outbound_task_inner>:
static void outbound_task_inner(){
   11e58:	b510      	push	{r4, lr}
	grid_port_process_outbound_usart(&GRID_PORT_N);
   11e5a:	4808      	ldr	r0, [pc, #32]	; (11e7c <outbound_task_inner+0x24>)
   11e5c:	4c08      	ldr	r4, [pc, #32]	; (11e80 <outbound_task_inner+0x28>)
   11e5e:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_E);
   11e60:	4808      	ldr	r0, [pc, #32]	; (11e84 <outbound_task_inner+0x2c>)
   11e62:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_S);
   11e64:	4808      	ldr	r0, [pc, #32]	; (11e88 <outbound_task_inner+0x30>)
   11e66:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_W);
   11e68:	4808      	ldr	r0, [pc, #32]	; (11e8c <outbound_task_inner+0x34>)
   11e6a:	47a0      	blx	r4
	grid_port_process_outbound_usb(&GRID_PORT_H);
   11e6c:	4b08      	ldr	r3, [pc, #32]	; (11e90 <outbound_task_inner+0x38>)
   11e6e:	4809      	ldr	r0, [pc, #36]	; (11e94 <outbound_task_inner+0x3c>)
   11e70:	4798      	blx	r3
}
   11e72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_outbound_ui(&GRID_PORT_U);
   11e76:	4808      	ldr	r0, [pc, #32]	; (11e98 <outbound_task_inner+0x40>)
   11e78:	4b08      	ldr	r3, [pc, #32]	; (11e9c <outbound_task_inner+0x44>)
   11e7a:	4718      	bx	r3
   11e7c:	20009150 	.word	0x20009150
   11e80:	00006315 	.word	0x00006315
   11e84:	20019870 	.word	0x20019870
   11e88:	200138d4 	.word	0x200138d4
   11e8c:	200102d4 	.word	0x200102d4
   11e90:	000053cd 	.word	0x000053cd
   11e94:	20016824 	.word	0x20016824
   11e98:	2000c0b0 	.word	0x2000c0b0
   11e9c:	000056c1 	.word	0x000056c1

00011ea0 <led_task_inner>:
static void led_task_inner(){
   11ea0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (grid_sys_state.alert_state){
   11ea4:	4c45      	ldr	r4, [pc, #276]	; (11fbc <led_task_inner+0x11c>)
static void led_task_inner(){
   11ea6:	ed2d 8b02 	vpush	{d8}
	if (grid_sys_state.alert_state){
   11eaa:	8963      	ldrh	r3, [r4, #10]
   11eac:	b29b      	uxth	r3, r3
static void led_task_inner(){
   11eae:	b083      	sub	sp, #12
	if (grid_sys_state.alert_state){
   11eb0:	b98b      	cbnz	r3, 11ed6 <led_task_inner+0x36>
	grid_task_enter_task(&grid_task_state, GRID_TASK_LED);
   11eb2:	2106      	movs	r1, #6
   11eb4:	4b42      	ldr	r3, [pc, #264]	; (11fc0 <led_task_inner+0x120>)
   11eb6:	4843      	ldr	r0, [pc, #268]	; (11fc4 <led_task_inner+0x124>)
   11eb8:	4798      	blx	r3
	grid_led_tick(&grid_led_state);
   11eba:	4843      	ldr	r0, [pc, #268]	; (11fc8 <led_task_inner+0x128>)
   11ebc:	4b43      	ldr	r3, [pc, #268]	; (11fcc <led_task_inner+0x12c>)
   11ebe:	4798      	blx	r3
	grid_led_lowlevel_render_all(&grid_led_state);	
   11ec0:	4841      	ldr	r0, [pc, #260]	; (11fc8 <led_task_inner+0x128>)
   11ec2:	4b43      	ldr	r3, [pc, #268]	; (11fd0 <led_task_inner+0x130>)
   11ec4:	4798      	blx	r3
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   11ec6:	4840      	ldr	r0, [pc, #256]	; (11fc8 <led_task_inner+0x128>)
   11ec8:	4b42      	ldr	r3, [pc, #264]	; (11fd4 <led_task_inner+0x134>)
}
   11eca:	b003      	add	sp, #12
   11ecc:	ecbd 8b02 	vpop	{d8}
   11ed0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   11ed4:	4718      	bx	r3
		grid_sys_state.alert_state--;
   11ed6:	8963      	ldrh	r3, [r4, #10]
   11ed8:	3b01      	subs	r3, #1
   11eda:	b29b      	uxth	r3, r3
   11edc:	8163      	strh	r3, [r4, #10]
		if (grid_sys_alert_read_color_changed_flag(&grid_sys_state)){
   11ede:	4620      	mov	r0, r4
   11ee0:	4b3d      	ldr	r3, [pc, #244]	; (11fd8 <led_task_inner+0x138>)
   11ee2:	4798      	blx	r3
   11ee4:	b988      	cbnz	r0, 11f0a <led_task_inner+0x6a>
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11ee6:	4835      	ldr	r0, [pc, #212]	; (11fbc <led_task_inner+0x11c>)
   11ee8:	4b3c      	ldr	r3, [pc, #240]	; (11fdc <led_task_inner+0x13c>)
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   11eea:	4e37      	ldr	r6, [pc, #220]	; (11fc8 <led_task_inner+0x128>)
   11eec:	4f3c      	ldr	r7, [pc, #240]	; (11fe0 <led_task_inner+0x140>)
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11eee:	4798      	blx	r3
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11ef0:	2400      	movs	r4, #0
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11ef2:	4605      	mov	r5, r0
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11ef4:	4b34      	ldr	r3, [pc, #208]	; (11fc8 <led_task_inner+0x128>)
   11ef6:	785b      	ldrb	r3, [r3, #1]
   11ef8:	b2e1      	uxtb	r1, r4
   11efa:	428b      	cmp	r3, r1
   11efc:	d9d9      	bls.n	11eb2 <led_task_inner+0x12>
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   11efe:	462b      	mov	r3, r5
   11f00:	2200      	movs	r2, #0
   11f02:	4630      	mov	r0, r6
   11f04:	47b8      	blx	r7
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11f06:	3401      	adds	r4, #1
   11f08:	e7f4      	b.n	11ef4 <led_task_inner+0x54>
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   11f0a:	4b36      	ldr	r3, [pc, #216]	; (11fe4 <led_task_inner+0x144>)
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11f0c:	4e2e      	ldr	r6, [pc, #184]	; (11fc8 <led_task_inner+0x128>)
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   11f0e:	4620      	mov	r0, r4
   11f10:	4798      	blx	r3
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   11f12:	4b35      	ldr	r3, [pc, #212]	; (11fe8 <led_task_inner+0x148>)
   11f14:	4620      	mov	r0, r4
   11f16:	4798      	blx	r3
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11f18:	4b34      	ldr	r3, [pc, #208]	; (11fec <led_task_inner+0x14c>)
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   11f1a:	ee08 0a10 	vmov	s16, r0
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11f1e:	4620      	mov	r0, r4
   11f20:	4798      	blx	r3
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11f22:	4b33      	ldr	r3, [pc, #204]	; (11ff0 <led_task_inner+0x150>)
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11f24:	4682      	mov	sl, r0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11f26:	4620      	mov	r0, r4
   11f28:	4798      	blx	r3
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11f2a:	f04f 0900 	mov.w	r9, #0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11f2e:	4683      	mov	fp, r0
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11f30:	4b30      	ldr	r3, [pc, #192]	; (11ff4 <led_task_inner+0x154>)
   11f32:	4630      	mov	r0, r6
   11f34:	4798      	blx	r3
   11f36:	fa5f f589 	uxtb.w	r5, r9
   11f3a:	42a8      	cmp	r0, r5
   11f3c:	f109 0901 	add.w	r9, r9, #1
   11f40:	d9d1      	bls.n	11ee6 <led_task_inner+0x46>
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   11f42:	2400      	movs	r4, #0
   11f44:	4622      	mov	r2, r4
   11f46:	e9cd 4400 	strd	r4, r4, [sp]
   11f4a:	4623      	mov	r3, r4
   11f4c:	4629      	mov	r1, r5
   11f4e:	4630      	mov	r0, r6
   11f50:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 12008 <led_task_inner+0x168>
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   11f54:	4f28      	ldr	r7, [pc, #160]	; (11ff8 <led_task_inner+0x158>)
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   11f56:	47c0      	blx	r8
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   11f58:	ee18 0a10 	vmov	r0, s16
   11f5c:	4b27      	ldr	r3, [pc, #156]	; (11ffc <led_task_inner+0x15c>)
   11f5e:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 1200c <led_task_inner+0x16c>
   11f62:	4798      	blx	r3
   11f64:	4b26      	ldr	r3, [pc, #152]	; (12000 <led_task_inner+0x160>)
   11f66:	2200      	movs	r2, #0
   11f68:	47b8      	blx	r7
   11f6a:	47c0      	blx	r8
   11f6c:	4b23      	ldr	r3, [pc, #140]	; (11ffc <led_task_inner+0x15c>)
   11f6e:	b2c2      	uxtb	r2, r0
   11f70:	4658      	mov	r0, fp
   11f72:	ee08 2a90 	vmov	s17, r2
   11f76:	4798      	blx	r3
   11f78:	2200      	movs	r2, #0
   11f7a:	4b21      	ldr	r3, [pc, #132]	; (12000 <led_task_inner+0x160>)
   11f7c:	47b8      	blx	r7
   11f7e:	47c0      	blx	r8
   11f80:	b2c0      	uxtb	r0, r0
   11f82:	9001      	str	r0, [sp, #4]
   11f84:	4b1d      	ldr	r3, [pc, #116]	; (11ffc <led_task_inner+0x15c>)
   11f86:	4650      	mov	r0, sl
   11f88:	4798      	blx	r3
   11f8a:	4b1d      	ldr	r3, [pc, #116]	; (12000 <led_task_inner+0x160>)
   11f8c:	2200      	movs	r2, #0
   11f8e:	47b8      	blx	r7
   11f90:	47c0      	blx	r8
   11f92:	b2c0      	uxtb	r0, r0
   11f94:	ee18 3a90 	vmov	r3, s17
   11f98:	9000      	str	r0, [sp, #0]
   11f9a:	4622      	mov	r2, r4
   11f9c:	4629      	mov	r1, r5
   11f9e:	4630      	mov	r0, r6
   11fa0:	f8df 806c 	ldr.w	r8, [pc, #108]	; 12010 <led_task_inner+0x170>
   11fa4:	47c0      	blx	r8
				grid_led_set_max(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*1   , color_g*1   , color_b*1);
   11fa6:	4622      	mov	r2, r4
   11fa8:	e9cd ab00 	strd	sl, fp, [sp]
   11fac:	ee18 3a10 	vmov	r3, s16
   11fb0:	4c14      	ldr	r4, [pc, #80]	; (12004 <led_task_inner+0x164>)
   11fb2:	4629      	mov	r1, r5
   11fb4:	4630      	mov	r0, r6
   11fb6:	47a0      	blx	r4
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11fb8:	e7ba      	b.n	11f30 <led_task_inner+0x90>
   11fba:	bf00      	nop
   11fbc:	2000f008 	.word	0x2000f008
   11fc0:	00008d7b 	.word	0x00008d7b
   11fc4:	200102b0 	.word	0x200102b0
   11fc8:	2001c838 	.word	0x2001c838
   11fcc:	00006c89 	.word	0x00006c89
   11fd0:	00007079 	.word	0x00007079
   11fd4:	00007099 	.word	0x00007099
   11fd8:	000097c5 	.word	0x000097c5
   11fdc:	000097cf 	.word	0x000097cf
   11fe0:	00006d91 	.word	0x00006d91
   11fe4:	000097c9 	.word	0x000097c9
   11fe8:	0000982d 	.word	0x0000982d
   11fec:	00009831 	.word	0x00009831
   11ff0:	00009835 	.word	0x00009835
   11ff4:	00006c85 	.word	0x00006c85
   11ff8:	00013e69 	.word	0x00013e69
   11ffc:	00013d95 	.word	0x00013d95
   12000:	3fe00000 	.word	0x3fe00000
   12004:	00006d01 	.word	0x00006d01
   12008:	00006cc1 	.word	0x00006cc1
   1200c:	0001428d 	.word	0x0001428d
   12010:	00006ce1 	.word	0x00006ce1

00012014 <RTC_Scheduler_realtime_cb>:
{
   12014:	b537      	push	{r0, r1, r2, r4, r5, lr}
	grid_sys_rtc_tick_time(&grid_sys_state);	
   12016:	4d16      	ldr	r5, [pc, #88]	; (12070 <RTC_Scheduler_realtime_cb+0x5c>)
   12018:	4b16      	ldr	r3, [pc, #88]	; (12074 <RTC_Scheduler_realtime_cb+0x60>)
   1201a:	4628      	mov	r0, r5
   1201c:	4798      	blx	r3
	grid_task_timer_tick(&grid_task_state);
   1201e:	4816      	ldr	r0, [pc, #88]	; (12078 <RTC_Scheduler_realtime_cb+0x64>)
   12020:	4b16      	ldr	r3, [pc, #88]	; (1207c <RTC_Scheduler_realtime_cb+0x68>)
   12022:	4798      	blx	r3
	CRITICAL_SECTION_ENTER();
   12024:	4b16      	ldr	r3, [pc, #88]	; (12080 <RTC_Scheduler_realtime_cb+0x6c>)
   12026:	a801      	add	r0, sp, #4
   12028:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
   1202a:	4a16      	ldr	r2, [pc, #88]	; (12084 <RTC_Scheduler_realtime_cb+0x70>)
   1202c:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
	return ((Port *)hw)->Group[submodule_index].IN.reg;
   12030:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
   12034:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
   12038:	405c      	eors	r4, r3
   1203a:	400c      	ands	r4, r1
   1203c:	405c      	eors	r4, r3
	CRITICAL_SECTION_LEAVE();
   1203e:	a801      	add	r0, sp, #4
   12040:	4b11      	ldr	r3, [pc, #68]	; (12088 <RTC_Scheduler_realtime_cb+0x74>)
   12042:	4798      	blx	r3
	if (mapmode_value != grid_sys_state.mapmodestate){
   12044:	7c2a      	ldrb	r2, [r5, #16]
	uint8_t mapmode_value = !gpio_get_pin_level(MAP_MODE);
   12046:	f484 6300 	eor.w	r3, r4, #2048	; 0x800
   1204a:	f3c3 23c0 	ubfx	r3, r3, #11, #1
	if (mapmode_value != grid_sys_state.mapmodestate){
   1204e:	429a      	cmp	r2, r3
   12050:	d009      	beq.n	12066 <RTC_Scheduler_realtime_cb+0x52>
		grid_sys_state.mapmodestate = mapmode_value;
   12052:	742b      	strb	r3, [r5, #16]
		if (grid_sys_state.mapmodestate == 0){ // RELEASE
   12054:	7c2b      	ldrb	r3, [r5, #16]
   12056:	4c0d      	ldr	r4, [pc, #52]	; (1208c <RTC_Scheduler_realtime_cb+0x78>)
   12058:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1205c:	b92b      	cbnz	r3, 1206a <RTC_Scheduler_realtime_cb+0x56>
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_RELEASE);
   1205e:	2308      	movs	r3, #8
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   12060:	480b      	ldr	r0, [pc, #44]	; (12090 <RTC_Scheduler_realtime_cb+0x7c>)
   12062:	4611      	mov	r1, r2
   12064:	47a0      	blx	r4
}
   12066:	b003      	add	sp, #12
   12068:	bd30      	pop	{r4, r5, pc}
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   1206a:	2307      	movs	r3, #7
   1206c:	2200      	movs	r2, #0
   1206e:	e7f7      	b.n	12060 <RTC_Scheduler_realtime_cb+0x4c>
   12070:	2000f008 	.word	0x2000f008
   12074:	000097b3 	.word	0x000097b3
   12078:	200102b0 	.word	0x200102b0
   1207c:	00008d83 	.word	0x00008d83
   12080:	00011b59 	.word	0x00011b59
   12084:	41008000 	.word	0x41008000
   12088:	00011b67 	.word	0x00011b67
   1208c:	0000a191 	.word	0x0000a191
   12090:	2001c7c0 	.word	0x2001c7c0

00012094 <outbound_task>:
   12094:	b508      	push	{r3, lr}
   12096:	4c02      	ldr	r4, [pc, #8]	; (120a0 <outbound_task+0xc>)
   12098:	2005      	movs	r0, #5
   1209a:	47a0      	blx	r4
   1209c:	e7fc      	b.n	12098 <outbound_task+0x4>
   1209e:	bf00      	nop
   120a0:	000129ed 	.word	0x000129ed

000120a4 <led_task>:
{
   120a4:	b508      	push	{r3, lr}
		globaltest++;
   120a6:	4c08      	ldr	r4, [pc, #32]	; (120c8 <led_task+0x24>)
		inbound_task_inner();
   120a8:	4e08      	ldr	r6, [pc, #32]	; (120cc <led_task+0x28>)
		outbound_task_inner();
   120aa:	4d09      	ldr	r5, [pc, #36]	; (120d0 <led_task+0x2c>)
		globaltest++;
   120ac:	6863      	ldr	r3, [r4, #4]
   120ae:	3301      	adds	r3, #1
   120b0:	6063      	str	r3, [r4, #4]
		inbound_task_inner();
   120b2:	47b0      	blx	r6
		outbound_task_inner();
   120b4:	47a8      	blx	r5
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   120b6:	4807      	ldr	r0, [pc, #28]	; (120d4 <led_task+0x30>)
   120b8:	4b07      	ldr	r3, [pc, #28]	; (120d8 <led_task+0x34>)
   120ba:	4798      	blx	r3
		led_task_inner();
   120bc:	4b07      	ldr	r3, [pc, #28]	; (120dc <led_task+0x38>)
   120be:	4798      	blx	r3
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   120c0:	4b07      	ldr	r3, [pc, #28]	; (120e0 <led_task+0x3c>)
   120c2:	2005      	movs	r0, #5
   120c4:	4798      	blx	r3
	while (1) {
   120c6:	e7f1      	b.n	120ac <led_task+0x8>
   120c8:	20008d80 	.word	0x20008d80
   120cc:	00011e0d 	.word	0x00011e0d
   120d0:	00011e59 	.word	0x00011e59
   120d4:	2000c0b0 	.word	0x2000c0b0
   120d8:	0000a7a5 	.word	0x0000a7a5
   120dc:	00011ea1 	.word	0x00011ea1
   120e0:	000129ed 	.word	0x000129ed

000120e4 <vApplicationStackOverflowHook>:
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   120e4:	b583      	push	{r0, r1, r7, lr}
	CRITICAL_SECTION_ENTER()
   120e6:	4b08      	ldr	r3, [pc, #32]	; (12108 <vApplicationStackOverflowHook+0x24>)
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   120e8:	4f08      	ldr	r7, [pc, #32]	; (1210c <vApplicationStackOverflowHook+0x28>)
   120ea:	4e09      	ldr	r6, [pc, #36]	; (12110 <vApplicationStackOverflowHook+0x2c>)
   120ec:	4d09      	ldr	r5, [pc, #36]	; (12114 <vApplicationStackOverflowHook+0x30>)
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   120ee:	4604      	mov	r4, r0
	CRITICAL_SECTION_ENTER()
   120f0:	a801      	add	r0, sp, #4
   120f2:	4798      	blx	r3
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   120f4:	4620      	mov	r0, r4
   120f6:	47b8      	blx	r7
   120f8:	4601      	mov	r1, r0
   120fa:	4630      	mov	r0, r6
   120fc:	47a8      	blx	r5
		delay_ms(1000);
   120fe:	4b06      	ldr	r3, [pc, #24]	; (12118 <vApplicationStackOverflowHook+0x34>)
   12100:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   12104:	4798      	blx	r3
	while(1){
   12106:	e7f5      	b.n	120f4 <vApplicationStackOverflowHook+0x10>
   12108:	00011b59 	.word	0x00011b59
   1210c:	000127d1 	.word	0x000127d1
   12110:	000176c9 	.word	0x000176c9
   12114:	000146ad 	.word	0x000146ad
   12118:	0000dddd 	.word	0x0000dddd

0001211c <init_timer>:


void init_timer(void)
{
   1211c:	b570      	push	{r4, r5, r6, lr}
	
		
	//RTC_Scheduler_ping.interval = RTC1SEC/20; //50ms
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   1211e:	4c14      	ldr	r4, [pc, #80]	; (12170 <init_timer+0x54>)
	
	RTC_Scheduler_realtime.interval = 1;
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;

	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12120:	4d14      	ldr	r5, [pc, #80]	; (12174 <init_timer+0x58>)
   12122:	4e15      	ldr	r6, [pc, #84]	; (12178 <init_timer+0x5c>)
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   12124:	f44f 63c8 	mov.w	r3, #1600	; 0x640
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   12128:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   1212c:	6223      	str	r3, [r4, #32]
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   1212e:	6362      	str	r2, [r4, #52]	; 0x34
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   12130:	4b12      	ldr	r3, [pc, #72]	; (1217c <init_timer+0x60>)
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   12132:	4a13      	ldr	r2, [pc, #76]	; (12180 <init_timer+0x64>)
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   12134:	6263      	str	r3, [r4, #36]	; 0x24
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   12136:	63a2      	str	r2, [r4, #56]	; 0x38
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   12138:	2301      	movs	r3, #1
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   1213a:	4a12      	ldr	r2, [pc, #72]	; (12184 <init_timer+0x68>)
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   1213c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12140:	f104 0118 	add.w	r1, r4, #24
   12144:	4628      	mov	r0, r5
	RTC_Scheduler_heartbeat.mode     = TIMER_TASK_REPEAT;
   12146:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	RTC_Scheduler_realtime.interval = 1;
   1214a:	64a3      	str	r3, [r4, #72]	; 0x48
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;
   1214c:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   12150:	64e2      	str	r2, [r4, #76]	; 0x4c
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12152:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_heartbeat);
   12154:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   12158:	4628      	mov	r0, r5
   1215a:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_realtime);
   1215c:	f104 0140 	add.w	r1, r4, #64	; 0x40
   12160:	4628      	mov	r0, r5
   12162:	47b0      	blx	r6
	
	timer_start(&RTC_Scheduler);
   12164:	4628      	mov	r0, r5
   12166:	4b08      	ldr	r3, [pc, #32]	; (12188 <init_timer+0x6c>)
	
}
   12168:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	timer_start(&RTC_Scheduler);
   1216c:	4718      	bx	r3
   1216e:	bf00      	nop
   12170:	20008d80 	.word	0x20008d80
   12174:	2001ccb8 	.word	0x2001ccb8
   12178:	0000caa5 	.word	0x0000caa5
   1217c:	00011b75 	.word	0x00011b75
   12180:	00011bc1 	.word	0x00011bc1
   12184:	00012015 	.word	0x00012015
   12188:	0000ca65 	.word	0x0000ca65

0001218c <main>:

//====================== USB TEST =====================//

int main(void)
{
   1218c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	


	atmel_start_init();	
   12190:	4b81      	ldr	r3, [pc, #516]	; (12398 <main+0x20c>)
    
            
            
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   12192:	4e82      	ldr	r6, [pc, #520]	; (1239c <main+0x210>)
	// 	}
	// }


    
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   12194:	4c82      	ldr	r4, [pc, #520]	; (123a0 <main+0x214>)
   12196:	4d83      	ldr	r5, [pc, #524]	; (123a4 <main+0x218>)
{
   12198:	b085      	sub	sp, #20
	atmel_start_init();	
   1219a:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   1219c:	4982      	ldr	r1, [pc, #520]	; (123a8 <main+0x21c>)
   1219e:	4883      	ldr	r0, [pc, #524]	; (123ac <main+0x220>)
   121a0:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "D51 Init");
   121a2:	4983      	ldr	r1, [pc, #524]	; (123b0 <main+0x224>)
   121a4:	4881      	ldr	r0, [pc, #516]	; (123ac <main+0x220>)
   121a6:	47b0      	blx	r6
	grid_d51_init(); // Check User Row
   121a8:	4b82      	ldr	r3, [pc, #520]	; (123b4 <main+0x228>)
   121aa:	4798      	blx	r3
	audiodf_midi_init();
   121ac:	4b82      	ldr	r3, [pc, #520]	; (123b8 <main+0x22c>)
   121ae:	4798      	blx	r3
	composite_device_start();
   121b0:	4b82      	ldr	r3, [pc, #520]	; (123bc <main+0x230>)
   121b2:	4798      	blx	r3
	grid_usb_serial_init();
   121b4:	4b82      	ldr	r3, [pc, #520]	; (123c0 <main+0x234>)
   121b6:	4798      	blx	r3
	grid_usb_midi_init();
   121b8:	4b82      	ldr	r3, [pc, #520]	; (123c4 <main+0x238>)
   121ba:	4798      	blx	r3
	grid_keyboard_init(&grid_keyboard_state);
   121bc:	4b82      	ldr	r3, [pc, #520]	; (123c8 <main+0x23c>)
   121be:	4883      	ldr	r0, [pc, #524]	; (123cc <main+0x240>)
   121c0:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Initialized");
   121c2:	4983      	ldr	r1, [pc, #524]	; (123d0 <main+0x244>)
   121c4:	4879      	ldr	r0, [pc, #484]	; (123ac <main+0x220>)
   121c6:	47b0      	blx	r6
	rand_sync_enable(&RAND_0);	
   121c8:	4b82      	ldr	r3, [pc, #520]	; (123d4 <main+0x248>)
   121ca:	4883      	ldr	r0, [pc, #524]	; (123d8 <main+0x24c>)
   121cc:	4798      	blx	r3
	grid_expr_init(&grid_expr_state);
   121ce:	4883      	ldr	r0, [pc, #524]	; (123dc <main+0x250>)
   121d0:	4b83      	ldr	r3, [pc, #524]	; (123e0 <main+0x254>)
   121d2:	4798      	blx	r3
	grid_module_common_init();
   121d4:	4b83      	ldr	r3, [pc, #524]	; (123e4 <main+0x258>)
   121d6:	4798      	blx	r3
    grid_ui_reinit(&grid_ui_state);
   121d8:	4b83      	ldr	r3, [pc, #524]	; (123e8 <main+0x25c>)
   121da:	4884      	ldr	r0, [pc, #528]	; (123ec <main+0x260>)
   121dc:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Grid Module Initialized");
   121de:	4984      	ldr	r1, [pc, #528]	; (123f0 <main+0x264>)
   121e0:	4872      	ldr	r0, [pc, #456]	; (123ac <main+0x220>)
   121e2:	47b0      	blx	r6
	init_timer();
   121e4:	4b83      	ldr	r3, [pc, #524]	; (123f4 <main+0x268>)
   121e6:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Entering Main Loop");
   121e8:	4983      	ldr	r1, [pc, #524]	; (123f8 <main+0x26c>)
   121ea:	4870      	ldr	r0, [pc, #448]	; (123ac <main+0x220>)
   121ec:	47b0      	blx	r6
	grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
   121ee:	4983      	ldr	r1, [pc, #524]	; (123fc <main+0x270>)
   121f0:	4883      	ldr	r0, [pc, #524]	; (12400 <main+0x274>)
   121f2:	4b84      	ldr	r3, [pc, #528]	; (12404 <main+0x278>)
   121f4:	4798      	blx	r3
	grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);	
   121f6:	4981      	ldr	r1, [pc, #516]	; (123fc <main+0x270>)
   121f8:	487c      	ldr	r0, [pc, #496]	; (123ec <main+0x260>)
   121fa:	4b83      	ldr	r3, [pc, #524]	; (12408 <main+0x27c>)
   121fc:	4798      	blx	r3
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   121fe:	2301      	movs	r3, #1
   12200:	9300      	str	r3, [sp, #0]
   12202:	4982      	ldr	r1, [pc, #520]	; (1240c <main+0x280>)
   12204:	4882      	ldr	r0, [pc, #520]	; (12410 <main+0x284>)
   12206:	9401      	str	r4, [sp, #4]
   12208:	2300      	movs	r3, #0
   1220a:	f44f 7200 	mov.w	r2, #512	; 0x200
   1220e:	47a8      	blx	r5
   12210:	2801      	cmp	r0, #1
   12212:	9603      	str	r6, [sp, #12]
   12214:	d000      	beq.n	12218 <main+0x8c>
	    != pdPASS) {
		while (1) {
   12216:	e7fe      	b.n	12216 <main+0x8a>
			;
		}
	}

	if (xTaskCreate(usb_task, "Nvm Task", TASK_NVM_STACK_SIZE, NULL, TASK_NVM_PRIORITY, &xCreatedNvmTask)
   12218:	1d23      	adds	r3, r4, #4
   1221a:	2602      	movs	r6, #2
   1221c:	9301      	str	r3, [sp, #4]
   1221e:	497d      	ldr	r1, [pc, #500]	; (12414 <main+0x288>)
   12220:	487b      	ldr	r0, [pc, #492]	; (12410 <main+0x284>)
   12222:	9600      	str	r6, [sp, #0]
   12224:	2300      	movs	r3, #0
   12226:	f44f 7280 	mov.w	r2, #256	; 0x100
   1222a:	47a8      	blx	r5
   1222c:	2801      	cmp	r0, #1
   1222e:	d000      	beq.n	12232 <main+0xa6>
	    != pdPASS) {
		while (1) {
   12230:	e7fe      	b.n	12230 <main+0xa4>
			;
		}
	}

	if (xTaskCreate(usb_task, "Ui Task", TASK_UI_STACK_SIZE, NULL, TASK_UI_PRIORITY, &xCreatedUiTask)
   12232:	f104 0308 	add.w	r3, r4, #8
   12236:	9301      	str	r3, [sp, #4]
   12238:	2305      	movs	r3, #5
   1223a:	9300      	str	r3, [sp, #0]
   1223c:	4976      	ldr	r1, [pc, #472]	; (12418 <main+0x28c>)
   1223e:	4874      	ldr	r0, [pc, #464]	; (12410 <main+0x284>)
   12240:	2300      	movs	r3, #0
   12242:	f44f 6280 	mov.w	r2, #1024	; 0x400
   12246:	47a8      	blx	r5
   12248:	2801      	cmp	r0, #1
   1224a:	d000      	beq.n	1224e <main+0xc2>
	    != pdPASS) {
		while (1) {
   1224c:	e7fe      	b.n	1224c <main+0xc0>
			;
		}
	}

	if (xTaskCreate(receive_task, "Receive Task", TASK_RECEIVE_STACK_SIZE, NULL, TASK_RECEIVE_PRIORITY, &xCreatedReceiveTask)
   1224e:	f104 030c 	add.w	r3, r4, #12
   12252:	e9cd 6300 	strd	r6, r3, [sp]
   12256:	4971      	ldr	r1, [pc, #452]	; (1241c <main+0x290>)
   12258:	4871      	ldr	r0, [pc, #452]	; (12420 <main+0x294>)
   1225a:	2300      	movs	r3, #0
   1225c:	f44f 7280 	mov.w	r2, #256	; 0x100
   12260:	47a8      	blx	r5
   12262:	2801      	cmp	r0, #1
   12264:	d000      	beq.n	12268 <main+0xdc>
	    != pdPASS) {
		while (1) {
   12266:	e7fe      	b.n	12266 <main+0xda>
			;
		}
	}

	if (xTaskCreate(inbound_task, "Inbound Task", TASK_INBOUND_STACK_SIZE, NULL, TASK_INBOUND_PRIORITY, &xCreatedInboundTask)
   12268:	f104 0310 	add.w	r3, r4, #16
   1226c:	e9cd 6300 	strd	r6, r3, [sp]
   12270:	496c      	ldr	r1, [pc, #432]	; (12424 <main+0x298>)
   12272:	486d      	ldr	r0, [pc, #436]	; (12428 <main+0x29c>)
   12274:	2300      	movs	r3, #0
   12276:	f44f 7280 	mov.w	r2, #256	; 0x100
   1227a:	47a8      	blx	r5
   1227c:	2801      	cmp	r0, #1
   1227e:	d000      	beq.n	12282 <main+0xf6>
	    != pdPASS) {
		while (1) {
   12280:	e7fe      	b.n	12280 <main+0xf4>
			;
		}
	}

	if (xTaskCreate(outbound_task, "Outbound Task", TASK_OUTBOUND_STACK_SIZE, NULL, TASK_OUTBOUND_PRIORITY, &xCreatedOutboundTask)
   12282:	f104 0314 	add.w	r3, r4, #20
   12286:	e9cd 6300 	strd	r6, r3, [sp]
   1228a:	4968      	ldr	r1, [pc, #416]	; (1242c <main+0x2a0>)
   1228c:	4868      	ldr	r0, [pc, #416]	; (12430 <main+0x2a4>)
   1228e:	2300      	movs	r3, #0
   12290:	f44f 7280 	mov.w	r2, #256	; 0x100
   12294:	47a8      	blx	r5
   12296:	2801      	cmp	r0, #1
   12298:	d000      	beq.n	1229c <main+0x110>
	    != pdPASS) {
		while (1) {
   1229a:	e7fe      	b.n	1229a <main+0x10e>
			;
		}
	}


	if (xTaskCreate(led_task, "Led Task", TASK_LED_STACK_SIZE, NULL, TASK_LED_PRIORITY, &xCreatedLedTask)
   1229c:	f104 0318 	add.w	r3, r4, #24
   122a0:	9301      	str	r3, [sp, #4]
   122a2:	2304      	movs	r3, #4
   122a4:	9300      	str	r3, [sp, #0]
   122a6:	4963      	ldr	r1, [pc, #396]	; (12434 <main+0x2a8>)
   122a8:	4863      	ldr	r0, [pc, #396]	; (12438 <main+0x2ac>)
   122aa:	2300      	movs	r3, #0
   122ac:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   122b0:	47a8      	blx	r5
   122b2:	2801      	cmp	r0, #1
   122b4:	d000      	beq.n	122b8 <main+0x12c>
	    != pdPASS) {
		while (1) {
   122b6:	e7fe      	b.n	122b6 <main+0x12a>
			;
		}
	}
    
	if (xTaskCreate(example_task, "Example", TASK_EXAMPLE_STACK_SIZE, NULL, TASK_EXAMPLE_STACK_PRIORITY, &xCreatedExampleTask)
   122b8:	341c      	adds	r4, #28
   122ba:	e9cd 6400 	strd	r6, r4, [sp]
   122be:	495f      	ldr	r1, [pc, #380]	; (1243c <main+0x2b0>)
   122c0:	485f      	ldr	r0, [pc, #380]	; (12440 <main+0x2b4>)
   122c2:	2300      	movs	r3, #0
   122c4:	2280      	movs	r2, #128	; 0x80
   122c6:	47a8      	blx	r5
   122c8:	2801      	cmp	r0, #1
   122ca:	d000      	beq.n	122ce <main+0x142>
	    != pdPASS) {
		while (1) {
   122cc:	e7fe      	b.n	122cc <main+0x140>
   122ce:	4d5d      	ldr	r5, [pc, #372]	; (12444 <main+0x2b8>)
   122d0:	f8df a1b0 	ldr.w	sl, [pc, #432]	; 12484 <main+0x2f8>
	uint32_t loopcounter = 0;
   122d4:	2400      	movs	r4, #0
	
		
		if (usb_init_flag == 0){
			
			
			if (usb_d_get_frame_num() == 0){
   122d6:	4b5c      	ldr	r3, [pc, #368]	; (12448 <main+0x2bc>)
   122d8:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 12488 <main+0x2fc>
   122dc:	f8df 81ac 	ldr.w	r8, [pc, #428]	; 1248c <main+0x300>
   122e0:	4f5a      	ldr	r7, [pc, #360]	; (1244c <main+0x2c0>)
   122e2:	4e5b      	ldr	r6, [pc, #364]	; (12450 <main+0x2c4>)
   122e4:	4798      	blx	r3
   122e6:	2800      	cmp	r0, #0
   122e8:	d031      	beq.n	1234e <main+0x1c2>
				
			}
			else{			
			
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN	
   122ea:	2400      	movs	r4, #0
   122ec:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   122f0:	22ff      	movs	r2, #255	; 0xff
   122f2:	e9cd 4300 	strd	r4, r3, [sp]
   122f6:	4621      	mov	r1, r4
   122f8:	4623      	mov	r3, r4
   122fa:	4841      	ldr	r0, [pc, #260]	; (12400 <main+0x274>)
   122fc:	f8df b190 	ldr.w	fp, [pc, #400]	; 12490 <main+0x304>
   12300:	47d8      	blx	fp
				
				GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Connected");
   12302:	4954      	ldr	r1, [pc, #336]	; (12454 <main+0x2c8>)
   12304:	9b03      	ldr	r3, [sp, #12]
   12306:	4829      	ldr	r0, [pc, #164]	; (123ac <main+0x220>)
   12308:	4798      	blx	r3
				
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   1230a:	4b53      	ldr	r3, [pc, #332]	; (12458 <main+0x2cc>)
   1230c:	483c      	ldr	r0, [pc, #240]	; (12400 <main+0x274>)
   1230e:	4798      	blx	r3
   12310:	4b52      	ldr	r3, [pc, #328]	; (1245c <main+0x2d0>)
   12312:	4601      	mov	r1, r0
   12314:	483a      	ldr	r0, [pc, #232]	; (12400 <main+0x274>)
   12316:	4798      	blx	r3
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   12318:	4622      	mov	r2, r4
   1231a:	4621      	mov	r1, r4
   1231c:	4850      	ldr	r0, [pc, #320]	; (12460 <main+0x2d4>)
   1231e:	4c51      	ldr	r4, [pc, #324]	; (12464 <main+0x2d8>)
   12320:	2309      	movs	r3, #9
   12322:	47a0      	blx	r4
				
				usb_init_flag = 1;
				
				

				printf("Forever! \r\n");
   12324:	4b50      	ldr	r3, [pc, #320]	; (12468 <main+0x2dc>)
   12326:	4851      	ldr	r0, [pc, #324]	; (1246c <main+0x2e0>)
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12328:	4c51      	ldr	r4, [pc, #324]	; (12470 <main+0x2e4>)
				printf("Forever! \r\n");
   1232a:	4798      	blx	r3
				delay_ms(2);
   1232c:	2002      	movs	r0, #2
   1232e:	47a8      	blx	r5


				vTaskStartScheduler();
   12330:	4b50      	ldr	r3, [pc, #320]	; (12474 <main+0x2e8>)
   12332:	4798      	blx	r3

				while(1){
				
		
					
					usb_task_inner();
   12334:	47d0      	blx	sl
					nvm_task_inner();
   12336:	47c8      	blx	r9

					receive_task_inner();
   12338:	47c0      	blx	r8
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   1233a:	4620      	mov	r0, r4
   1233c:	47b8      	blx	r7

					ui_task_inner();

					inbound_task_inner();
   1233e:	47b0      	blx	r6

					outbound_task_inner();
   12340:	4b4d      	ldr	r3, [pc, #308]	; (12478 <main+0x2ec>)
   12342:	4798      	blx	r3

					led_task_inner();
   12344:	4b4d      	ldr	r3, [pc, #308]	; (1247c <main+0x2f0>)
   12346:	4798      	blx	r3

					delay_ms(1);
   12348:	2001      	movs	r0, #1
   1234a:	47a8      	blx	r5
				while(1){
   1234c:	e7f2      	b.n	12334 <main+0x1a8>
		
		
		
		// Request neighbor bank settings if we don't have it initialized
		
 		if (grid_sys_get_bank_valid(&grid_sys_state) == 0 && loopcounter%80 == 0){
   1234e:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 12400 <main+0x274>
   12352:	4b4b      	ldr	r3, [pc, #300]	; (12480 <main+0x2f4>)
   12354:	4658      	mov	r0, fp
   12356:	4798      	blx	r3
   12358:	b980      	cbnz	r0, 1237c <main+0x1f0>
   1235a:	2250      	movs	r2, #80	; 0x50
   1235c:	fbb4 f3f2 	udiv	r3, r4, r2
   12360:	fb02 4313 	mls	r3, r2, r3, r4
   12364:	b953      	cbnz	r3, 1237c <main+0x1f0>
 								
			if (grid_sys_state.bank_init_flag == 0)	{
   12366:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
   1236a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   1236e:	b92b      	cbnz	r3, 1237c <main+0x1f0>
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_REQUEST);
   12370:	483b      	ldr	r0, [pc, #236]	; (12460 <main+0x2d4>)
   12372:	f8df b0f0 	ldr.w	fp, [pc, #240]	; 12464 <main+0x2d8>
   12376:	230a      	movs	r3, #10
   12378:	4611      	mov	r1, r2
   1237a:	47d8      	blx	fp
	

		
		
		
		usb_task_inner();
   1237c:	47d0      	blx	sl
		


		nvm_task_inner();
   1237e:	47c8      	blx	r9
		
					


		receive_task_inner();
   12380:	47c0      	blx	r8
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12382:	483b      	ldr	r0, [pc, #236]	; (12470 <main+0x2e4>)
   12384:	47b8      	blx	r7
		
		
		
		
		
		inbound_task_inner();
   12386:	47b0      	blx	r6

		outbound_task_inner();
   12388:	4b3b      	ldr	r3, [pc, #236]	; (12478 <main+0x2ec>)
   1238a:	4798      	blx	r3

		led_task_inner();
   1238c:	4b3b      	ldr	r3, [pc, #236]	; (1247c <main+0x2f0>)
   1238e:	4798      	blx	r3

		delay_ms(1);
   12390:	2001      	movs	r0, #1
		loopcounter++;
   12392:	3401      	adds	r4, #1
		delay_ms(1);
   12394:	47a8      	blx	r5
		if (usb_init_flag == 0){
   12396:	e79e      	b.n	122d6 <main+0x14a>
   12398:	00013105 	.word	0x00013105
   1239c:	000146ad 	.word	0x000146ad
   123a0:	20008dd4 	.word	0x20008dd4
   123a4:	00012589 	.word	0x00012589
   123a8:	000176e5 	.word	0x000176e5
   123ac:	00016ae3 	.word	0x00016ae3
   123b0:	000176f7 	.word	0x000176f7
   123b4:	00006381 	.word	0x00006381
   123b8:	000044dd 	.word	0x000044dd
   123bc:	0000c94d 	.word	0x0000c94d
   123c0:	0000ace1 	.word	0x0000ace1
   123c4:	0000aed9 	.word	0x0000aed9
   123c8:	0000afc5 	.word	0x0000afc5
   123cc:	20010264 	.word	0x20010264
   123d0:	00017700 	.word	0x00017700
   123d4:	0000e7dd 	.word	0x0000e7dd
   123d8:	2001cd7c 	.word	0x2001cd7c
   123dc:	20013220 	.word	0x20013220
   123e0:	000063f1 	.word	0x000063f1
   123e4:	000070c9 	.word	0x000070c9
   123e8:	0000a0c9 	.word	0x0000a0c9
   123ec:	2000effc 	.word	0x2000effc
   123f0:	0001771d 	.word	0x0001771d
   123f4:	0001211d 	.word	0x0001211d
   123f8:	00017735 	.word	0x00017735
   123fc:	2000fa1c 	.word	0x2000fa1c
   12400:	2000f008 	.word	0x2000f008
   12404:	000090e5 	.word	0x000090e5
   12408:	00009af5 	.word	0x00009af5
   1240c:	00017748 	.word	0x00017748
   12410:	00011d19 	.word	0x00011d19
   12414:	00017751 	.word	0x00017751
   12418:	0001775a 	.word	0x0001775a
   1241c:	00017762 	.word	0x00017762
   12420:	00011d61 	.word	0x00011d61
   12424:	0001776f 	.word	0x0001776f
   12428:	00011c19 	.word	0x00011c19
   1242c:	0001777c 	.word	0x0001777c
   12430:	00012095 	.word	0x00012095
   12434:	0001778a 	.word	0x0001778a
   12438:	000120a5 	.word	0x000120a5
   1243c:	00017793 	.word	0x00017793
   12440:	00011bdd 	.word	0x00011bdd
   12444:	0000dddd 	.word	0x0000dddd
   12448:	0000f561 	.word	0x0000f561
   1244c:	0000a7a5 	.word	0x0000a7a5
   12450:	00011e0d 	.word	0x00011e0d
   12454:	0001779b 	.word	0x0001779b
   12458:	00009749 	.word	0x00009749
   1245c:	00009763 	.word	0x00009763
   12460:	2001c7c0 	.word	0x2001c7c0
   12464:	0000a191 	.word	0x0000a191
   12468:	000147bd 	.word	0x000147bd
   1246c:	000177b6 	.word	0x000177b6
   12470:	2000c0b0 	.word	0x2000c0b0
   12474:	0001272d 	.word	0x0001272d
   12478:	00011e59 	.word	0x00011e59
   1247c:	00011ea1 	.word	0x00011ea1
   12480:	0000970b 	.word	0x0000970b
   12484:	00011c29 	.word	0x00011c29
   12488:	00011d79 	.word	0x00011d79
   1248c:	00011d31 	.word	0x00011d31
   12490:	00009813 	.word	0x00009813

00012494 <qspi_dma_init>:
 * \brief Driver version
 */
#define QSPI_DMA_DRIVER_VERSION 0x00000001u

int32_t qspi_dma_init(struct qspi_dma_descriptor *qspi, void *const hw)
{
   12494:	b570      	push	{r4, r5, r6, lr}
   12496:	460d      	mov	r5, r1
	ASSERT(qspi && hw);
   12498:	4604      	mov	r4, r0
   1249a:	b110      	cbz	r0, 124a2 <qspi_dma_init+0xe>
   1249c:	1e08      	subs	r0, r1, #0
   1249e:	bf18      	it	ne
   124a0:	2001      	movne	r0, #1
   124a2:	4905      	ldr	r1, [pc, #20]	; (124b8 <qspi_dma_init+0x24>)
   124a4:	4b05      	ldr	r3, [pc, #20]	; (124bc <qspi_dma_init+0x28>)
   124a6:	2231      	movs	r2, #49	; 0x31
   124a8:	4798      	blx	r3

	return _qspi_dma_init(&qspi->dev, hw);
   124aa:	4629      	mov	r1, r5
   124ac:	4620      	mov	r0, r4
   124ae:	4b04      	ldr	r3, [pc, #16]	; (124c0 <qspi_dma_init+0x2c>)
}
   124b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _qspi_dma_init(&qspi->dev, hw);
   124b4:	4718      	bx	r3
   124b6:	bf00      	nop
   124b8:	000177c1 	.word	0x000177c1
   124bc:	0000e08d 	.word	0x0000e08d
   124c0:	0000be69 	.word	0x0000be69

000124c4 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   124c4:	4906      	ldr	r1, [pc, #24]	; (124e0 <prvIdleTask+0x1c>)
				taskYIELD();
   124c6:	4b07      	ldr	r3, [pc, #28]	; (124e4 <prvIdleTask+0x20>)
   124c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   124cc:	6808      	ldr	r0, [r1, #0]
   124ce:	2801      	cmp	r0, #1
   124d0:	d9fc      	bls.n	124cc <prvIdleTask+0x8>
				taskYIELD();
   124d2:	601a      	str	r2, [r3, #0]
   124d4:	f3bf 8f4f 	dsb	sy
   124d8:	f3bf 8f6f 	isb	sy
   124dc:	e7f6      	b.n	124cc <prvIdleTask+0x8>
   124de:	bf00      	nop
   124e0:	20008df8 	.word	0x20008df8
   124e4:	e000ed04 	.word	0xe000ed04

000124e8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   124e8:	4b07      	ldr	r3, [pc, #28]	; (12508 <prvResetNextTaskUnblockTime+0x20>)
   124ea:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   124ee:	6812      	ldr	r2, [r2, #0]
   124f0:	b922      	cbnz	r2, 124fc <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   124f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   124f6:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
	}
}
   124fa:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   124fc:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   12500:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   12502:	68d2      	ldr	r2, [r2, #12]
   12504:	6852      	ldr	r2, [r2, #4]
   12506:	e7f6      	b.n	124f6 <prvResetNextTaskUnblockTime+0xe>
   12508:	20008df8 	.word	0x20008df8

0001250c <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
   1250c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
   12510:	4f19      	ldr	r7, [pc, #100]	; (12578 <prvAddCurrentTaskToDelayedList+0x6c>)
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12512:	4b1a      	ldr	r3, [pc, #104]	; (1257c <prvAddCurrentTaskToDelayedList+0x70>)
	const TickType_t xConstTickCount = xTickCount;
   12514:	f8d7 62b0 	ldr.w	r6, [r7, #688]	; 0x2b0
{
   12518:	4605      	mov	r5, r0
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   1251a:	f8d7 02b4 	ldr.w	r0, [r7, #692]	; 0x2b4
   1251e:	3004      	adds	r0, #4
{
   12520:	4688      	mov	r8, r1
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12522:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
   12524:	1c6b      	adds	r3, r5, #1
   12526:	463c      	mov	r4, r7
   12528:	d10b      	bne.n	12542 <prvAddCurrentTaskToDelayedList+0x36>
   1252a:	f1b8 0f00 	cmp.w	r8, #0
   1252e:	d008      	beq.n	12542 <prvAddCurrentTaskToDelayedList+0x36>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
   12530:	f8d7 12b4 	ldr.w	r1, [r7, #692]	; 0x2b4
   12534:	4b12      	ldr	r3, [pc, #72]	; (12580 <prvAddCurrentTaskToDelayedList+0x74>)
   12536:	3104      	adds	r1, #4
   12538:	f507 7020 	add.w	r0, r7, #640	; 0x280

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
   1253c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   12540:	4718      	bx	r3
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
   12542:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12546:	1975      	adds	r5, r6, r5
   12548:	605d      	str	r5, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
   1254a:	4b0e      	ldr	r3, [pc, #56]	; (12584 <prvAddCurrentTaskToDelayedList+0x78>)
   1254c:	d305      	bcc.n	1255a <prvAddCurrentTaskToDelayedList+0x4e>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   1254e:	f8d4 02b8 	ldr.w	r0, [r4, #696]	; 0x2b8
   12552:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12556:	3104      	adds	r1, #4
   12558:	e7f0      	b.n	1253c <prvAddCurrentTaskToDelayedList+0x30>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   1255a:	f8d4 02a8 	ldr.w	r0, [r4, #680]	; 0x2a8
   1255e:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12562:	3104      	adds	r1, #4
   12564:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
   12566:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   1256a:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
   1256c:	bf88      	it	hi
   1256e:	f8c4 52ac 	strhi.w	r5, [r4, #684]	; 0x2ac
}
   12572:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12576:	bf00      	nop
   12578:	20008df8 	.word	0x20008df8
   1257c:	0000b1af 	.word	0x0000b1af
   12580:	0000b169 	.word	0x0000b169
   12584:	0000b181 	.word	0x0000b181

00012588 <xTaskCreate>:
{
   12588:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pxStack = (StackType_t *)pvPortMalloc(
   1258c:	0095      	lsls	r5, r2, #2
   1258e:	4c5b      	ldr	r4, [pc, #364]	; (126fc <xTaskCreate+0x174>)
{
   12590:	4607      	mov	r7, r0
		pxStack = (StackType_t *)pvPortMalloc(
   12592:	4628      	mov	r0, r5
{
   12594:	460e      	mov	r6, r1
   12596:	4698      	mov	r8, r3
		pxStack = (StackType_t *)pvPortMalloc(
   12598:	47a0      	blx	r4
		if (pxStack != NULL) {
   1259a:	4681      	mov	r9, r0
   1259c:	2800      	cmp	r0, #0
   1259e:	f000 809b 	beq.w	126d8 <xTaskCreate+0x150>
			pxNewTCB = (TCB_t *)pvPortMalloc(
   125a2:	2054      	movs	r0, #84	; 0x54
   125a4:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
   125a6:	4604      	mov	r4, r0
   125a8:	2800      	cmp	r0, #0
   125aa:	f000 8092 	beq.w	126d2 <xTaskCreate+0x14a>
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   125ae:	4b54      	ldr	r3, [pc, #336]	; (12700 <xTaskCreate+0x178>)
				pxNewTCB->pxStack = pxStack;
   125b0:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   125b4:	462a      	mov	r2, r5
   125b6:	21a5      	movs	r1, #165	; 0xa5
   125b8:	4648      	mov	r0, r9
   125ba:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   125bc:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   125c0:	1e73      	subs	r3, r6, #1
   125c2:	f104 0234 	add.w	r2, r4, #52	; 0x34
   125c6:	3607      	adds	r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
   125c8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   125cc:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
   125d0:	7819      	ldrb	r1, [r3, #0]
   125d2:	b109      	cbz	r1, 125d8 <xTaskCreate+0x50>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   125d4:	42b3      	cmp	r3, r6
   125d6:	d1f7      	bne.n	125c8 <xTaskCreate+0x40>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   125d8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   125da:	4a4a      	ldr	r2, [pc, #296]	; (12704 <xTaskCreate+0x17c>)
   125dc:	2e1f      	cmp	r6, #31
   125de:	bf28      	it	cs
   125e0:	261f      	movcs	r6, #31
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   125e2:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   125e6:	f104 0904 	add.w	r9, r4, #4
		pxNewTCB->uxMutexesHeld  = 0;
   125ea:	e9c4 6a11 	strd	r6, sl, [r4, #68]	; 0x44
	pxNewTCB->uxPriority = uxPriority;
   125ee:	62e6      	str	r6, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   125f0:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   125f2:	f884 a03b 	strb.w	sl, [r4, #59]	; 0x3b
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   125f6:	3d04      	subs	r5, #4
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   125f8:	4790      	blx	r2
	listSET_LIST_ITEM_VALUE(
   125fa:	f1c6 0620 	rsb	r6, r6, #32
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   125fe:	4a41      	ldr	r2, [pc, #260]	; (12704 <xTaskCreate+0x17c>)
   12600:	f104 0018 	add.w	r0, r4, #24
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12604:	445d      	add	r5, fp
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   12606:	4790      	blx	r2
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12608:	4b3f      	ldr	r3, [pc, #252]	; (12708 <xTaskCreate+0x180>)
		pxNewTCB->ulNotifiedValue = 0;
   1260a:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
   1260e:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
   12610:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
   12612:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
   12614:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12618:	4642      	mov	r2, r8
   1261a:	4639      	mov	r1, r7
   1261c:	f025 0007 	bic.w	r0, r5, #7
   12620:	4798      	blx	r3
	if ((void *)pxCreatedTask != NULL) {
   12622:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12624:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
   12626:	b103      	cbz	r3, 1262a <xTaskCreate+0xa2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
   12628:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
   1262a:	4d38      	ldr	r5, [pc, #224]	; (1270c <xTaskCreate+0x184>)
	taskENTER_CRITICAL();
   1262c:	4b38      	ldr	r3, [pc, #224]	; (12710 <xTaskCreate+0x188>)
   1262e:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   12630:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   12634:	3301      	adds	r3, #1
   12636:	f8c5 32bc 	str.w	r3, [r5, #700]	; 0x2bc
		if (pxCurrentTCB == NULL) {
   1263a:	f8d5 62b4 	ldr.w	r6, [r5, #692]	; 0x2b4
   1263e:	2e00      	cmp	r6, #0
   12640:	d14e      	bne.n	126e0 <xTaskCreate+0x158>
			pxCurrentTCB = pxNewTCB;
   12642:	f8c5 42b4 	str.w	r4, [r5, #692]	; 0x2b4
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
   12646:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   1264a:	2b01      	cmp	r3, #1
   1264c:	d119      	bne.n	12682 <xTaskCreate+0xfa>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   1264e:	4f31      	ldr	r7, [pc, #196]	; (12714 <xTaskCreate+0x18c>)
   12650:	46a8      	mov	r8, r5
   12652:	4640      	mov	r0, r8
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   12654:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   12656:	47b8      	blx	r7
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   12658:	2e20      	cmp	r6, #32
   1265a:	f108 0814 	add.w	r8, r8, #20
   1265e:	d1f8      	bne.n	12652 <xTaskCreate+0xca>
	vListInitialise(&xDelayedTaskList1);
   12660:	4e2d      	ldr	r6, [pc, #180]	; (12718 <xTaskCreate+0x190>)
   12662:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
   12664:	f106 0814 	add.w	r8, r6, #20
	vListInitialise(&xDelayedTaskList1);
   12668:	47b8      	blx	r7
	vListInitialise(&xDelayedTaskList2);
   1266a:	4640      	mov	r0, r8
   1266c:	47b8      	blx	r7
	vListInitialise(&xPendingReadyList);
   1266e:	f1a6 002c 	sub.w	r0, r6, #44	; 0x2c
   12672:	47b8      	blx	r7
		vListInitialise(&xSuspendedTaskList);
   12674:	f1a6 0040 	sub.w	r0, r6, #64	; 0x40
   12678:	47b8      	blx	r7
	pxDelayedTaskList         = &xDelayedTaskList1;
   1267a:	f8c5 62a8 	str.w	r6, [r5, #680]	; 0x2a8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   1267e:	f8c5 82b8 	str.w	r8, [r5, #696]	; 0x2b8
		uxTaskNumber++;
   12682:	f8d5 32ec 	ldr.w	r3, [r5, #748]	; 0x2ec
		prvAddTaskToReadyList(pxNewTCB);
   12686:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
		uxTaskNumber++;
   1268a:	3301      	adds	r3, #1
   1268c:	f8c5 32ec 	str.w	r3, [r5, #748]	; 0x2ec
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   12690:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
   12692:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   12694:	2014      	movs	r0, #20
   12696:	4293      	cmp	r3, r2
   12698:	bf88      	it	hi
   1269a:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   1269e:	fb00 5003 	mla	r0, r0, r3, r5
   126a2:	4649      	mov	r1, r9
   126a4:	4b1d      	ldr	r3, [pc, #116]	; (1271c <xTaskCreate+0x194>)
   126a6:	4798      	blx	r3
	taskEXIT_CRITICAL();
   126a8:	4b1d      	ldr	r3, [pc, #116]	; (12720 <xTaskCreate+0x198>)
   126aa:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
   126ac:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   126b0:	b16b      	cbz	r3, 126ce <xTaskCreate+0x146>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
   126b2:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   126b6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   126b8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   126ba:	429a      	cmp	r2, r3
   126bc:	d207      	bcs.n	126ce <xTaskCreate+0x146>
			taskYIELD_IF_USING_PREEMPTION();
   126be:	4b19      	ldr	r3, [pc, #100]	; (12724 <xTaskCreate+0x19c>)
   126c0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   126c4:	601a      	str	r2, [r3, #0]
   126c6:	f3bf 8f4f 	dsb	sy
   126ca:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
   126ce:	2001      	movs	r0, #1
	return xReturn;
   126d0:	e004      	b.n	126dc <xTaskCreate+0x154>
				vPortFree(pxStack);
   126d2:	4b15      	ldr	r3, [pc, #84]	; (12728 <xTaskCreate+0x1a0>)
   126d4:	4648      	mov	r0, r9
   126d6:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   126d8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   126dc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (xSchedulerRunning == pdFALSE) {
   126e0:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   126e4:	2b00      	cmp	r3, #0
   126e6:	d1cc      	bne.n	12682 <xTaskCreate+0xfa>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
   126e8:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   126ec:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   126ee:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   126f0:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
   126f2:	bf98      	it	ls
   126f4:	f8c5 42b4 	strls.w	r4, [r5, #692]	; 0x2b4
   126f8:	e7c3      	b.n	12682 <xTaskCreate+0xfa>
   126fa:	bf00      	nop
   126fc:	0000b665 	.word	0x0000b665
   12700:	00014469 	.word	0x00014469
   12704:	0000b163 	.word	0x0000b163
   12708:	0000b24d 	.word	0x0000b24d
   1270c:	20008df8 	.word	0x20008df8
   12710:	0000b2a5 	.word	0x0000b2a5
   12714:	0000b14d 	.word	0x0000b14d
   12718:	200090b8 	.word	0x200090b8
   1271c:	0000b169 	.word	0x0000b169
   12720:	0000b2e9 	.word	0x0000b2e9
   12724:	e000ed04 	.word	0xe000ed04
   12728:	0000b769 	.word	0x0000b769

0001272c <vTaskStartScheduler>:
{
   1272c:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(prvIdleTask,
   1272e:	4c1a      	ldr	r4, [pc, #104]	; (12798 <vTaskStartScheduler+0x6c>)
   12730:	491a      	ldr	r1, [pc, #104]	; (1279c <vTaskStartScheduler+0x70>)
   12732:	481b      	ldr	r0, [pc, #108]	; (127a0 <vTaskStartScheduler+0x74>)
   12734:	4e1b      	ldr	r6, [pc, #108]	; (127a4 <vTaskStartScheduler+0x78>)
   12736:	f504 733e 	add.w	r3, r4, #760	; 0x2f8
   1273a:	2500      	movs	r5, #0
   1273c:	9301      	str	r3, [sp, #4]
   1273e:	9500      	str	r5, [sp, #0]
   12740:	462b      	mov	r3, r5
   12742:	2240      	movs	r2, #64	; 0x40
   12744:	47b0      	blx	r6
		if (xReturn == pdPASS) {
   12746:	2801      	cmp	r0, #1
   12748:	d118      	bne.n	1277c <vTaskStartScheduler+0x50>
			xReturn = xTimerCreateTimerTask();
   1274a:	4b17      	ldr	r3, [pc, #92]	; (127a8 <vTaskStartScheduler+0x7c>)
   1274c:	4798      	blx	r3
	if (xReturn == pdPASS) {
   1274e:	2801      	cmp	r0, #1
   12750:	d114      	bne.n	1277c <vTaskStartScheduler+0x50>
   12752:	f04f 0380 	mov.w	r3, #128	; 0x80
   12756:	f383 8811 	msr	BASEPRI, r3
   1275a:	f3bf 8f6f 	isb	sy
   1275e:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   12762:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12766:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
		if (xPortStartScheduler() != pdFALSE) {
   1276a:	4b10      	ldr	r3, [pc, #64]	; (127ac <vTaskStartScheduler+0x80>)
		xSchedulerRunning    = pdTRUE;
   1276c:	f8c4 02e8 	str.w	r0, [r4, #744]	; 0x2e8
		xTickCount           = (TickType_t)0U;
   12770:	f8c4 52b0 	str.w	r5, [r4, #688]	; 0x2b0
}
   12774:	b002      	add	sp, #8
   12776:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (xPortStartScheduler() != pdFALSE) {
   1277a:	4718      	bx	r3
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
   1277c:	3001      	adds	r0, #1
   1277e:	d108      	bne.n	12792 <vTaskStartScheduler+0x66>
   12780:	f04f 0380 	mov.w	r3, #128	; 0x80
   12784:	f383 8811 	msr	BASEPRI, r3
   12788:	f3bf 8f6f 	isb	sy
   1278c:	f3bf 8f4f 	dsb	sy
   12790:	e7fe      	b.n	12790 <vTaskStartScheduler+0x64>
}
   12792:	b002      	add	sp, #8
   12794:	bd70      	pop	{r4, r5, r6, pc}
   12796:	bf00      	nop
   12798:	20008df8 	.word	0x20008df8
   1279c:	000177db 	.word	0x000177db
   127a0:	000124c5 	.word	0x000124c5
   127a4:	00012589 	.word	0x00012589
   127a8:	0000dac1 	.word	0x0000dac1
   127ac:	0000b3c9 	.word	0x0000b3c9

000127b0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   127b0:	4a03      	ldr	r2, [pc, #12]	; (127c0 <vTaskSuspendAll+0x10>)
   127b2:	f8d2 32f4 	ldr.w	r3, [r2, #756]	; 0x2f4
   127b6:	3301      	adds	r3, #1
   127b8:	f8c2 32f4 	str.w	r3, [r2, #756]	; 0x2f4
}
   127bc:	4770      	bx	lr
   127be:	bf00      	nop
   127c0:	20008df8 	.word	0x20008df8

000127c4 <xTaskGetTickCount>:
		xTicks = xTickCount;
   127c4:	4b01      	ldr	r3, [pc, #4]	; (127cc <xTaskGetTickCount+0x8>)
   127c6:	f8d3 02b0 	ldr.w	r0, [r3, #688]	; 0x2b0
}
   127ca:	4770      	bx	lr
   127cc:	20008df8 	.word	0x20008df8

000127d0 <pcTaskGetName>:
	pxTCB = prvGetTCBFromHandle(xTaskToQuery);
   127d0:	b960      	cbnz	r0, 127ec <pcTaskGetName+0x1c>
   127d2:	4b07      	ldr	r3, [pc, #28]	; (127f0 <pcTaskGetName+0x20>)
   127d4:	f8d3 02b4 	ldr.w	r0, [r3, #692]	; 0x2b4
	configASSERT(pxTCB);
   127d8:	b940      	cbnz	r0, 127ec <pcTaskGetName+0x1c>
   127da:	f04f 0380 	mov.w	r3, #128	; 0x80
   127de:	f383 8811 	msr	BASEPRI, r3
   127e2:	f3bf 8f6f 	isb	sy
   127e6:	f3bf 8f4f 	dsb	sy
   127ea:	e7fe      	b.n	127ea <pcTaskGetName+0x1a>
}
   127ec:	3034      	adds	r0, #52	; 0x34
   127ee:	4770      	bx	lr
   127f0:	20008df8 	.word	0x20008df8

000127f4 <xTaskIncrementTick>:
{
   127f4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   127f8:	4b3b      	ldr	r3, [pc, #236]	; (128e8 <xTaskIncrementTick+0xf4>)
   127fa:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   127fe:	461c      	mov	r4, r3
   12800:	2a00      	cmp	r2, #0
   12802:	d16a      	bne.n	128da <xTaskIncrementTick+0xe6>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
   12804:	f8d3 72b0 	ldr.w	r7, [r3, #688]	; 0x2b0
   12808:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   1280a:	f8c3 72b0 	str.w	r7, [r3, #688]	; 0x2b0
		if (xConstTickCount
   1280e:	b9df      	cbnz	r7, 12848 <xTaskIncrementTick+0x54>
			taskSWITCH_DELAYED_LISTS();
   12810:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
   12814:	681b      	ldr	r3, [r3, #0]
   12816:	b143      	cbz	r3, 1282a <xTaskIncrementTick+0x36>
   12818:	f04f 0380 	mov.w	r3, #128	; 0x80
   1281c:	f383 8811 	msr	BASEPRI, r3
   12820:	f3bf 8f6f 	isb	sy
   12824:	f3bf 8f4f 	dsb	sy
   12828:	e7fe      	b.n	12828 <xTaskIncrementTick+0x34>
   1282a:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   1282e:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
   12832:	f8c4 22a8 	str.w	r2, [r4, #680]	; 0x2a8
   12836:	f8c4 32b8 	str.w	r3, [r4, #696]	; 0x2b8
   1283a:	f8d4 32fc 	ldr.w	r3, [r4, #764]	; 0x2fc
   1283e:	3301      	adds	r3, #1
   12840:	f8c4 32fc 	str.w	r3, [r4, #764]	; 0x2fc
   12844:	4b29      	ldr	r3, [pc, #164]	; (128ec <xTaskIncrementTick+0xf8>)
   12846:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12848:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   1284c:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
   1284e:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12852:	d910      	bls.n	12876 <xTaskIncrementTick+0x82>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
   12854:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12858:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1285a:	2314      	movs	r3, #20
   1285c:	4353      	muls	r3, r2
   1285e:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
   12860:	2b02      	cmp	r3, #2
   12862:	bf28      	it	cs
   12864:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
   12866:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
			xSwitchRequired = pdTRUE;
   1286a:	2b00      	cmp	r3, #0
}
   1286c:	bf0c      	ite	eq
   1286e:	4628      	moveq	r0, r5
   12870:	2001      	movne	r0, #1
   12872:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12876:	f8df 8078 	ldr.w	r8, [pc, #120]	; 128f0 <xTaskIncrementTick+0xfc>
					prvAddTaskToReadyList(pxTCB);
   1287a:	f8df 9078 	ldr.w	r9, [pc, #120]	; 128f4 <xTaskIncrementTick+0x100>
   1287e:	f04f 0a14 	mov.w	sl, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   12882:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12886:	681b      	ldr	r3, [r3, #0]
   12888:	b923      	cbnz	r3, 12894 <xTaskIncrementTick+0xa0>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1288a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
						xNextTaskUnblockTime = xItemValue;
   1288e:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
						break;
   12892:	e7df      	b.n	12854 <xTaskIncrementTick+0x60>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   12894:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12898:	68db      	ldr	r3, [r3, #12]
   1289a:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
   1289c:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
   1289e:	429f      	cmp	r7, r3
   128a0:	d3f5      	bcc.n	1288e <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
   128a2:	f106 0b04 	add.w	fp, r6, #4
   128a6:	4658      	mov	r0, fp
   128a8:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
   128aa:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   128ac:	b113      	cbz	r3, 128b4 <xTaskIncrementTick+0xc0>
						(void)uxListRemove(&(pxTCB->xEventListItem));
   128ae:	f106 0018 	add.w	r0, r6, #24
   128b2:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
   128b4:	6af0      	ldr	r0, [r6, #44]	; 0x2c
   128b6:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   128ba:	4298      	cmp	r0, r3
   128bc:	bf88      	it	hi
   128be:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   128c2:	4659      	mov	r1, fp
   128c4:	fb0a 4000 	mla	r0, sl, r0, r4
   128c8:	47c8      	blx	r9
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   128ca:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   128ce:	6af2      	ldr	r2, [r6, #44]	; 0x2c
   128d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   128d2:	429a      	cmp	r2, r3
   128d4:	bf28      	it	cs
   128d6:	2501      	movcs	r5, #1
   128d8:	e7d3      	b.n	12882 <xTaskIncrementTick+0x8e>
		++uxPendedTicks;
   128da:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
   128de:	3301      	adds	r3, #1
   128e0:	f8c4 3300 	str.w	r3, [r4, #768]	; 0x300
	BaseType_t xSwitchRequired = pdFALSE;
   128e4:	2500      	movs	r5, #0
   128e6:	e7be      	b.n	12866 <xTaskIncrementTick+0x72>
   128e8:	20008df8 	.word	0x20008df8
   128ec:	000124e9 	.word	0x000124e9
   128f0:	0000b1af 	.word	0x0000b1af
   128f4:	0000b169 	.word	0x0000b169

000128f8 <xTaskResumeAll>:
{
   128f8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
   128fc:	4c33      	ldr	r4, [pc, #204]	; (129cc <xTaskResumeAll+0xd4>)
   128fe:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   12902:	b943      	cbnz	r3, 12916 <xTaskResumeAll+0x1e>
   12904:	f04f 0380 	mov.w	r3, #128	; 0x80
   12908:	f383 8811 	msr	BASEPRI, r3
   1290c:	f3bf 8f6f 	isb	sy
   12910:	f3bf 8f4f 	dsb	sy
   12914:	e7fe      	b.n	12914 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
   12916:	4b2e      	ldr	r3, [pc, #184]	; (129d0 <xTaskResumeAll+0xd8>)
   12918:	4798      	blx	r3
		--uxSchedulerSuspended;
   1291a:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   1291e:	3b01      	subs	r3, #1
   12920:	f8c4 32f4 	str.w	r3, [r4, #756]	; 0x2f4
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12924:	f8d4 52f4 	ldr.w	r5, [r4, #756]	; 0x2f4
   12928:	b135      	cbz	r5, 12938 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
   1292a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1292c:	4b29      	ldr	r3, [pc, #164]	; (129d4 <xTaskResumeAll+0xdc>)
   1292e:	4798      	blx	r3
}
   12930:	4620      	mov	r0, r4
   12932:	b002      	add	sp, #8
   12934:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
   12938:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
   1293c:	2b00      	cmp	r3, #0
   1293e:	d0f4      	beq.n	1292a <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12940:	4e25      	ldr	r6, [pc, #148]	; (129d8 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
   12942:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 129e8 <xTaskResumeAll+0xf0>
   12946:	2714      	movs	r7, #20
   12948:	e01d      	b.n	12986 <xTaskResumeAll+0x8e>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
   1294a:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
   1294e:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12950:	f105 0018 	add.w	r0, r5, #24
   12954:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12956:	1d29      	adds	r1, r5, #4
   12958:	4608      	mov	r0, r1
   1295a:	9101      	str	r1, [sp, #4]
   1295c:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
   1295e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   12960:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   12964:	9901      	ldr	r1, [sp, #4]
   12966:	4298      	cmp	r0, r3
   12968:	bf88      	it	hi
   1296a:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   1296e:	fb07 4000 	mla	r0, r7, r0, r4
   12972:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   12974:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12978:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   1297a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1297c:	429a      	cmp	r2, r3
   1297e:	d302      	bcc.n	12986 <xTaskResumeAll+0x8e>
						xYieldPending = pdTRUE;
   12980:	2301      	movs	r3, #1
   12982:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
   12986:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
   1298a:	2b00      	cmp	r3, #0
   1298c:	d1dd      	bne.n	1294a <xTaskResumeAll+0x52>
				if (pxTCB != NULL) {
   1298e:	b10d      	cbz	r5, 12994 <xTaskResumeAll+0x9c>
					prvResetNextTaskUnblockTime();
   12990:	4b12      	ldr	r3, [pc, #72]	; (129dc <xTaskResumeAll+0xe4>)
   12992:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   12994:	f8d4 5300 	ldr.w	r5, [r4, #768]	; 0x300
					if (uxPendedCounts > (UBaseType_t)0U) {
   12998:	b14d      	cbz	r5, 129ae <xTaskResumeAll+0xb6>
							if (xTaskIncrementTick() != pdFALSE) {
   1299a:	4e11      	ldr	r6, [pc, #68]	; (129e0 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
   1299c:	2701      	movs	r7, #1
							if (xTaskIncrementTick() != pdFALSE) {
   1299e:	47b0      	blx	r6
   129a0:	b108      	cbz	r0, 129a6 <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
   129a2:	f8c4 7304 	str.w	r7, [r4, #772]	; 0x304
						} while (uxPendedCounts > (UBaseType_t)0U);
   129a6:	3d01      	subs	r5, #1
   129a8:	d1f9      	bne.n	1299e <xTaskResumeAll+0xa6>
						uxPendedTicks = 0;
   129aa:	f8c4 5300 	str.w	r5, [r4, #768]	; 0x300
				if (xYieldPending != pdFALSE) {
   129ae:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
   129b2:	2b00      	cmp	r3, #0
   129b4:	d0b9      	beq.n	1292a <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
   129b6:	4b0b      	ldr	r3, [pc, #44]	; (129e4 <xTaskResumeAll+0xec>)
   129b8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   129bc:	601a      	str	r2, [r3, #0]
   129be:	f3bf 8f4f 	dsb	sy
   129c2:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   129c6:	2401      	movs	r4, #1
   129c8:	e7b0      	b.n	1292c <xTaskResumeAll+0x34>
   129ca:	bf00      	nop
   129cc:	20008df8 	.word	0x20008df8
   129d0:	0000b2a5 	.word	0x0000b2a5
   129d4:	0000b2e9 	.word	0x0000b2e9
   129d8:	0000b1af 	.word	0x0000b1af
   129dc:	000124e9 	.word	0x000124e9
   129e0:	000127f5 	.word	0x000127f5
   129e4:	e000ed04 	.word	0xe000ed04
   129e8:	0000b169 	.word	0x0000b169

000129ec <vTaskDelay>:
{
   129ec:	b508      	push	{r3, lr}
	if (xTicksToDelay > (TickType_t)0U) {
   129ee:	b940      	cbnz	r0, 12a02 <vTaskDelay+0x16>
		portYIELD_WITHIN_API();
   129f0:	4b0f      	ldr	r3, [pc, #60]	; (12a30 <vTaskDelay+0x44>)
   129f2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   129f6:	601a      	str	r2, [r3, #0]
   129f8:	f3bf 8f4f 	dsb	sy
   129fc:	f3bf 8f6f 	isb	sy
}
   12a00:	bd08      	pop	{r3, pc}
		configASSERT(uxSchedulerSuspended == 0);
   12a02:	4b0c      	ldr	r3, [pc, #48]	; (12a34 <vTaskDelay+0x48>)
   12a04:	f8d3 12f4 	ldr.w	r1, [r3, #756]	; 0x2f4
   12a08:	b141      	cbz	r1, 12a1c <vTaskDelay+0x30>
   12a0a:	f04f 0380 	mov.w	r3, #128	; 0x80
   12a0e:	f383 8811 	msr	BASEPRI, r3
   12a12:	f3bf 8f6f 	isb	sy
   12a16:	f3bf 8f4f 	dsb	sy
   12a1a:	e7fe      	b.n	12a1a <vTaskDelay+0x2e>
		vTaskSuspendAll();
   12a1c:	4b06      	ldr	r3, [pc, #24]	; (12a38 <vTaskDelay+0x4c>)
   12a1e:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
   12a20:	4b06      	ldr	r3, [pc, #24]	; (12a3c <vTaskDelay+0x50>)
   12a22:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
   12a24:	4b06      	ldr	r3, [pc, #24]	; (12a40 <vTaskDelay+0x54>)
   12a26:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
   12a28:	2800      	cmp	r0, #0
   12a2a:	d0e1      	beq.n	129f0 <vTaskDelay+0x4>
   12a2c:	e7e8      	b.n	12a00 <vTaskDelay+0x14>
   12a2e:	bf00      	nop
   12a30:	e000ed04 	.word	0xe000ed04
   12a34:	20008df8 	.word	0x20008df8
   12a38:	000127b1 	.word	0x000127b1
   12a3c:	0001250d 	.word	0x0001250d
   12a40:	000128f9 	.word	0x000128f9

00012a44 <vTaskSwitchContext>:
{
   12a44:	b538      	push	{r3, r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
   12a46:	4b20      	ldr	r3, [pc, #128]	; (12ac8 <vTaskSwitchContext+0x84>)
   12a48:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   12a4c:	461c      	mov	r4, r3
   12a4e:	b11a      	cbz	r2, 12a58 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
   12a50:	2201      	movs	r2, #1
   12a52:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12a56:	bd38      	pop	{r3, r4, r5, pc}
		xYieldPending = pdFALSE;
   12a58:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		taskCHECK_FOR_STACK_OVERFLOW();
   12a5c:	f8d3 22b4 	ldr.w	r2, [r3, #692]	; 0x2b4
   12a60:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
   12a64:	6812      	ldr	r2, [r2, #0]
   12a66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12a68:	429a      	cmp	r2, r3
   12a6a:	d806      	bhi.n	12a7a <vTaskSwitchContext+0x36>
   12a6c:	f8d4 02b4 	ldr.w	r0, [r4, #692]	; 0x2b4
   12a70:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12a74:	4b15      	ldr	r3, [pc, #84]	; (12acc <vTaskSwitchContext+0x88>)
   12a76:	3134      	adds	r1, #52	; 0x34
   12a78:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12a7a:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   12a7e:	2514      	movs	r5, #20
   12a80:	fb05 f302 	mul.w	r3, r5, r2
   12a84:	18e1      	adds	r1, r4, r3
   12a86:	58e0      	ldr	r0, [r4, r3]
   12a88:	b190      	cbz	r0, 12ab0 <vTaskSwitchContext+0x6c>
   12a8a:	6848      	ldr	r0, [r1, #4]
   12a8c:	3308      	adds	r3, #8
   12a8e:	6840      	ldr	r0, [r0, #4]
   12a90:	6048      	str	r0, [r1, #4]
   12a92:	4423      	add	r3, r4
   12a94:	4298      	cmp	r0, r3
   12a96:	bf04      	itt	eq
   12a98:	6843      	ldreq	r3, [r0, #4]
   12a9a:	604b      	streq	r3, [r1, #4]
   12a9c:	2314      	movs	r3, #20
   12a9e:	fb03 4302 	mla	r3, r3, r2, r4
   12aa2:	685b      	ldr	r3, [r3, #4]
   12aa4:	68db      	ldr	r3, [r3, #12]
   12aa6:	f8c4 32b4 	str.w	r3, [r4, #692]	; 0x2b4
   12aaa:	f8c4 22f0 	str.w	r2, [r4, #752]	; 0x2f0
}
   12aae:	e7d2      	b.n	12a56 <vTaskSwitchContext+0x12>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12ab0:	b942      	cbnz	r2, 12ac4 <vTaskSwitchContext+0x80>
   12ab2:	f04f 0380 	mov.w	r3, #128	; 0x80
   12ab6:	f383 8811 	msr	BASEPRI, r3
   12aba:	f3bf 8f6f 	isb	sy
   12abe:	f3bf 8f4f 	dsb	sy
   12ac2:	e7fe      	b.n	12ac2 <vTaskSwitchContext+0x7e>
   12ac4:	3a01      	subs	r2, #1
   12ac6:	e7db      	b.n	12a80 <vTaskSwitchContext+0x3c>
   12ac8:	20008df8 	.word	0x20008df8
   12acc:	000120e5 	.word	0x000120e5

00012ad0 <vTaskPlaceOnEventList>:
{
   12ad0:	b510      	push	{r4, lr}
   12ad2:	460c      	mov	r4, r1
	configASSERT(pxEventList);
   12ad4:	b940      	cbnz	r0, 12ae8 <vTaskPlaceOnEventList+0x18>
   12ad6:	f04f 0380 	mov.w	r3, #128	; 0x80
   12ada:	f383 8811 	msr	BASEPRI, r3
   12ade:	f3bf 8f6f 	isb	sy
   12ae2:	f3bf 8f4f 	dsb	sy
   12ae6:	e7fe      	b.n	12ae6 <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
   12ae8:	4b05      	ldr	r3, [pc, #20]	; (12b00 <vTaskPlaceOnEventList+0x30>)
   12aea:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   12aee:	4b05      	ldr	r3, [pc, #20]	; (12b04 <vTaskPlaceOnEventList+0x34>)
   12af0:	3118      	adds	r1, #24
   12af2:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12af4:	4620      	mov	r0, r4
   12af6:	4b04      	ldr	r3, [pc, #16]	; (12b08 <vTaskPlaceOnEventList+0x38>)
}
   12af8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12afc:	2101      	movs	r1, #1
   12afe:	4718      	bx	r3
   12b00:	20008df8 	.word	0x20008df8
   12b04:	0000b181 	.word	0x0000b181
   12b08:	0001250d 	.word	0x0001250d

00012b0c <vTaskPlaceOnEventListRestricted>:
{
   12b0c:	b570      	push	{r4, r5, r6, lr}
   12b0e:	460d      	mov	r5, r1
   12b10:	4614      	mov	r4, r2
	configASSERT(pxEventList);
   12b12:	b940      	cbnz	r0, 12b26 <vTaskPlaceOnEventListRestricted+0x1a>
   12b14:	f04f 0380 	mov.w	r3, #128	; 0x80
   12b18:	f383 8811 	msr	BASEPRI, r3
   12b1c:	f3bf 8f6f 	isb	sy
   12b20:	f3bf 8f4f 	dsb	sy
   12b24:	e7fe      	b.n	12b24 <vTaskPlaceOnEventListRestricted+0x18>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
   12b26:	4b08      	ldr	r3, [pc, #32]	; (12b48 <vTaskPlaceOnEventListRestricted+0x3c>)
   12b28:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   12b2c:	4b07      	ldr	r3, [pc, #28]	; (12b4c <vTaskPlaceOnEventListRestricted+0x40>)
   12b2e:	3118      	adds	r1, #24
   12b30:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
   12b32:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12b34:	4621      	mov	r1, r4
   12b36:	bf08      	it	eq
   12b38:	4628      	moveq	r0, r5
   12b3a:	4b05      	ldr	r3, [pc, #20]	; (12b50 <vTaskPlaceOnEventListRestricted+0x44>)
}
   12b3c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12b40:	bf18      	it	ne
   12b42:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   12b46:	4718      	bx	r3
   12b48:	20008df8 	.word	0x20008df8
   12b4c:	0000b169 	.word	0x0000b169
   12b50:	0001250d 	.word	0x0001250d

00012b54 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12b54:	68c3      	ldr	r3, [r0, #12]
{
   12b56:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12b58:	68df      	ldr	r7, [r3, #12]
	configASSERT(pxUnblockedTCB);
   12b5a:	b947      	cbnz	r7, 12b6e <xTaskRemoveFromEventList+0x1a>
   12b5c:	f04f 0380 	mov.w	r3, #128	; 0x80
   12b60:	f383 8811 	msr	BASEPRI, r3
   12b64:	f3bf 8f6f 	isb	sy
   12b68:	f3bf 8f4f 	dsb	sy
   12b6c:	e7fe      	b.n	12b6c <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12b6e:	f107 0118 	add.w	r1, r7, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12b72:	4c15      	ldr	r4, [pc, #84]	; (12bc8 <xTaskRemoveFromEventList+0x74>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12b74:	4e15      	ldr	r6, [pc, #84]	; (12bcc <xTaskRemoveFromEventList+0x78>)
   12b76:	9101      	str	r1, [sp, #4]
   12b78:	4608      	mov	r0, r1
   12b7a:	47b0      	blx	r6
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12b7c:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   12b80:	4d13      	ldr	r5, [pc, #76]	; (12bd0 <xTaskRemoveFromEventList+0x7c>)
   12b82:	9901      	ldr	r1, [sp, #4]
   12b84:	b9e3      	cbnz	r3, 12bc0 <xTaskRemoveFromEventList+0x6c>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
   12b86:	1d39      	adds	r1, r7, #4
   12b88:	4608      	mov	r0, r1
   12b8a:	9101      	str	r1, [sp, #4]
   12b8c:	47b0      	blx	r6
		prvAddTaskToReadyList(pxUnblockedTCB);
   12b8e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   12b90:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   12b94:	9901      	ldr	r1, [sp, #4]
   12b96:	4293      	cmp	r3, r2
   12b98:	f04f 0014 	mov.w	r0, #20
   12b9c:	bf88      	it	hi
   12b9e:	f8c4 32f0 	strhi.w	r3, [r4, #752]	; 0x2f0
   12ba2:	fb00 4003 	mla	r0, r0, r3, r4
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   12ba6:	47a8      	blx	r5
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
   12ba8:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12bac:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   12bae:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12bb0:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   12bb2:	bf8a      	itet	hi
   12bb4:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
   12bb6:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
   12bb8:	f8c4 0304 	strhi.w	r0, [r4, #772]	; 0x304
}
   12bbc:	b003      	add	sp, #12
   12bbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   12bc0:	f504 7025 	add.w	r0, r4, #660	; 0x294
   12bc4:	e7ef      	b.n	12ba6 <xTaskRemoveFromEventList+0x52>
   12bc6:	bf00      	nop
   12bc8:	20008df8 	.word	0x20008df8
   12bcc:	0000b1af 	.word	0x0000b1af
   12bd0:	0000b169 	.word	0x0000b169

00012bd4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   12bd4:	4b03      	ldr	r3, [pc, #12]	; (12be4 <vTaskInternalSetTimeOutState+0x10>)
   12bd6:	f8d3 22fc 	ldr.w	r2, [r3, #764]	; 0x2fc
	pxTimeOut->xTimeOnEntering = xTickCount;
   12bda:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   12bde:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   12be0:	6043      	str	r3, [r0, #4]
}
   12be2:	4770      	bx	lr
   12be4:	20008df8 	.word	0x20008df8

00012be8 <xTaskCheckForTimeOut>:
{
   12be8:	b570      	push	{r4, r5, r6, lr}
   12bea:	460c      	mov	r4, r1
	configASSERT(pxTimeOut);
   12bec:	4605      	mov	r5, r0
   12bee:	b940      	cbnz	r0, 12c02 <xTaskCheckForTimeOut+0x1a>
   12bf0:	f04f 0380 	mov.w	r3, #128	; 0x80
   12bf4:	f383 8811 	msr	BASEPRI, r3
   12bf8:	f3bf 8f6f 	isb	sy
   12bfc:	f3bf 8f4f 	dsb	sy
   12c00:	e7fe      	b.n	12c00 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
   12c02:	b941      	cbnz	r1, 12c16 <xTaskCheckForTimeOut+0x2e>
   12c04:	f04f 0380 	mov.w	r3, #128	; 0x80
   12c08:	f383 8811 	msr	BASEPRI, r3
   12c0c:	f3bf 8f6f 	isb	sy
   12c10:	f3bf 8f4f 	dsb	sy
   12c14:	e7fe      	b.n	12c14 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
   12c16:	4b11      	ldr	r3, [pc, #68]	; (12c5c <xTaskCheckForTimeOut+0x74>)
   12c18:	4798      	blx	r3
		    if (*pxTicksToWait == portMAX_DELAY) {
   12c1a:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
   12c1c:	4810      	ldr	r0, [pc, #64]	; (12c60 <xTaskCheckForTimeOut+0x78>)
		    if (*pxTicksToWait == portMAX_DELAY) {
   12c1e:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
   12c20:	f8d0 12b0 	ldr.w	r1, [r0, #688]	; 0x2b0
		    if (*pxTicksToWait == portMAX_DELAY) {
   12c24:	d010      	beq.n	12c48 <xTaskCheckForTimeOut+0x60>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   12c26:	f8d0 02fc 	ldr.w	r0, [r0, #764]	; 0x2fc
   12c2a:	682e      	ldr	r6, [r5, #0]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12c2c:	686a      	ldr	r2, [r5, #4]
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   12c2e:	4286      	cmp	r6, r0
   12c30:	d001      	beq.n	12c36 <xTaskCheckForTimeOut+0x4e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
   12c32:	428a      	cmp	r2, r1
   12c34:	d90f      	bls.n	12c56 <xTaskCheckForTimeOut+0x6e>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12c36:	1a88      	subs	r0, r1, r2
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
   12c38:	4283      	cmp	r3, r0
   12c3a:	d90a      	bls.n	12c52 <xTaskCheckForTimeOut+0x6a>
			*pxTicksToWait -= xElapsedTime;
   12c3c:	1a5b      	subs	r3, r3, r1
   12c3e:	4413      	add	r3, r2
   12c40:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
   12c42:	4628      	mov	r0, r5
   12c44:	4b07      	ldr	r3, [pc, #28]	; (12c64 <xTaskCheckForTimeOut+0x7c>)
   12c46:	4798      	blx	r3
			xReturn = pdFALSE;
   12c48:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   12c4a:	4b07      	ldr	r3, [pc, #28]	; (12c68 <xTaskCheckForTimeOut+0x80>)
   12c4c:	4798      	blx	r3
}
   12c4e:	4620      	mov	r0, r4
   12c50:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
   12c52:	2300      	movs	r3, #0
   12c54:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
   12c56:	2401      	movs	r4, #1
   12c58:	e7f7      	b.n	12c4a <xTaskCheckForTimeOut+0x62>
   12c5a:	bf00      	nop
   12c5c:	0000b2a5 	.word	0x0000b2a5
   12c60:	20008df8 	.word	0x20008df8
   12c64:	00012bd5 	.word	0x00012bd5
   12c68:	0000b2e9 	.word	0x0000b2e9

00012c6c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   12c6c:	4b02      	ldr	r3, [pc, #8]	; (12c78 <vTaskMissedYield+0xc>)
   12c6e:	2201      	movs	r2, #1
   12c70:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12c74:	4770      	bx	lr
   12c76:	bf00      	nop
   12c78:	20008df8 	.word	0x20008df8

00012c7c <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
   12c7c:	4b06      	ldr	r3, [pc, #24]	; (12c98 <xTaskGetSchedulerState+0x1c>)
   12c7e:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
   12c82:	b132      	cbz	r2, 12c92 <xTaskGetSchedulerState+0x16>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12c84:	f8d3 32f4 	ldr.w	r3, [r3, #756]	; 0x2f4
   12c88:	2b00      	cmp	r3, #0
			xReturn = taskSCHEDULER_SUSPENDED;
   12c8a:	bf0c      	ite	eq
   12c8c:	2002      	moveq	r0, #2
   12c8e:	2000      	movne	r0, #0
   12c90:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
   12c92:	2001      	movs	r0, #1
}
   12c94:	4770      	bx	lr
   12c96:	bf00      	nop
   12c98:	20008df8 	.word	0x20008df8

00012c9c <xTaskPriorityDisinherit>:
{
   12c9c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (pxMutexHolder != NULL) {
   12c9e:	b910      	cbnz	r0, 12ca6 <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
   12ca0:	2000      	movs	r0, #0
}
   12ca2:	b003      	add	sp, #12
   12ca4:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
   12ca6:	4d1d      	ldr	r5, [pc, #116]	; (12d1c <xTaskPriorityDisinherit+0x80>)
   12ca8:	f8d5 42b4 	ldr.w	r4, [r5, #692]	; 0x2b4
   12cac:	4284      	cmp	r4, r0
   12cae:	d008      	beq.n	12cc2 <xTaskPriorityDisinherit+0x26>
   12cb0:	f04f 0380 	mov.w	r3, #128	; 0x80
   12cb4:	f383 8811 	msr	BASEPRI, r3
   12cb8:	f3bf 8f6f 	isb	sy
   12cbc:	f3bf 8f4f 	dsb	sy
   12cc0:	e7fe      	b.n	12cc0 <xTaskPriorityDisinherit+0x24>
		configASSERT(pxTCB->uxMutexesHeld);
   12cc2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   12cc4:	b943      	cbnz	r3, 12cd8 <xTaskPriorityDisinherit+0x3c>
   12cc6:	f04f 0380 	mov.w	r3, #128	; 0x80
   12cca:	f383 8811 	msr	BASEPRI, r3
   12cce:	f3bf 8f6f 	isb	sy
   12cd2:	f3bf 8f4f 	dsb	sy
   12cd6:	e7fe      	b.n	12cd6 <xTaskPriorityDisinherit+0x3a>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   12cd8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   12cda:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
   12cdc:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   12cde:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
   12ce0:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   12ce2:	d0dd      	beq.n	12ca0 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
   12ce4:	2b00      	cmp	r3, #0
   12ce6:	d1db      	bne.n	12ca0 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
   12ce8:	1d21      	adds	r1, r4, #4
   12cea:	4b0d      	ldr	r3, [pc, #52]	; (12d20 <xTaskPriorityDisinherit+0x84>)
   12cec:	9101      	str	r1, [sp, #4]
   12cee:	4608      	mov	r0, r1
   12cf0:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   12cf2:	6c63      	ldr	r3, [r4, #68]	; 0x44
   12cf4:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
   12cf6:	f1c3 0220 	rsb	r2, r3, #32
   12cfa:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
   12cfc:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
   12d00:	9901      	ldr	r1, [sp, #4]
   12d02:	4293      	cmp	r3, r2
   12d04:	f04f 0014 	mov.w	r0, #20
   12d08:	fb00 5003 	mla	r0, r0, r3, r5
   12d0c:	bf88      	it	hi
   12d0e:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   12d12:	4b04      	ldr	r3, [pc, #16]	; (12d24 <xTaskPriorityDisinherit+0x88>)
   12d14:	4798      	blx	r3
				xReturn = pdTRUE;
   12d16:	2001      	movs	r0, #1
	return xReturn;
   12d18:	e7c3      	b.n	12ca2 <xTaskPriorityDisinherit+0x6>
   12d1a:	bf00      	nop
   12d1c:	20008df8 	.word	0x20008df8
   12d20:	0000b1af 	.word	0x0000b1af
   12d24:	0000b169 	.word	0x0000b169

00012d28 <event_system_init>:
/**
 * \brief Initialize event system.
 */
int32_t event_system_init(void)
{
	return _event_system_init();
   12d28:	4b00      	ldr	r3, [pc, #0]	; (12d2c <event_system_init+0x4>)
   12d2a:	4718      	bx	r3
   12d2c:	0000ba9d 	.word	0x0000ba9d

00012d30 <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
   12d30:	6b03      	ldr	r3, [r0, #48]	; 0x30
   12d32:	420b      	tst	r3, r1
   12d34:	d1fc      	bne.n	12d30 <hri_adc_wait_for_sync>
	};
}
   12d36:	4770      	bx	lr

00012d38 <hri_adc_set_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
   12d38:	8803      	ldrh	r3, [r0, #0]
   12d3a:	b29b      	uxth	r3, r3
   12d3c:	f043 0302 	orr.w	r3, r3, #2
   12d40:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12d42:	2103      	movs	r1, #3
   12d44:	4b00      	ldr	r3, [pc, #0]	; (12d48 <hri_adc_set_CTRLA_ENABLE_bit+0x10>)
   12d46:	4718      	bx	r3
   12d48:	00012d31 	.word	0x00012d31

00012d4c <hri_adc_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
   12d4c:	8803      	ldrh	r3, [r0, #0]
   12d4e:	f023 0302 	bic.w	r3, r3, #2
   12d52:	041b      	lsls	r3, r3, #16
   12d54:	0c1b      	lsrs	r3, r3, #16
   12d56:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12d58:	2103      	movs	r1, #3
   12d5a:	4b01      	ldr	r3, [pc, #4]	; (12d60 <hri_adc_clear_CTRLA_ENABLE_bit+0x14>)
   12d5c:	4718      	bx	r3
   12d5e:	bf00      	nop
   12d60:	00012d31 	.word	0x00012d31

00012d64 <_adc_interrupt_handler>:
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _adc_interrupt_handler(struct _adc_async_device *device)
{
	void *const hw      = device->hw;
   12d64:	6942      	ldr	r2, [r0, #20]
	return ((Adc *)hw)->INTFLAG.reg;
   12d66:	f892 102e 	ldrb.w	r1, [r2, #46]	; 0x2e
	return ((Adc *)hw)->INTENSET.reg;
   12d6a:	f892 302d 	ldrb.w	r3, [r2, #45]	; 0x2d
	uint8_t     intflag = hri_adc_read_INTFLAG_reg(hw);
	intflag &= hri_adc_read_INTEN_reg(hw);
   12d6e:	400b      	ands	r3, r1
{
   12d70:	b430      	push	{r4, r5}
	if (intflag & ADC_INTFLAG_RESRDY) {
   12d72:	f013 0501 	ands.w	r5, r3, #1
   12d76:	d009      	beq.n	12d8c <_adc_interrupt_handler+0x28>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_RESRDY;
   12d78:	2301      	movs	r3, #1
   12d7a:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
	return ((Adc *)hw)->RESULT.reg;
   12d7e:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
		hri_adc_clear_interrupt_RESRDY_bit(hw);
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   12d82:	6883      	ldr	r3, [r0, #8]
		device->adc_async_cb.error_cb(device, 0);
	} else if (intflag & ADC_INTFLAG_WINMON) {
		hri_adc_clear_interrupt_WINMON_bit(hw);
		device->adc_async_cb.window_cb(device, 0);
	}
}
   12d84:	bc30      	pop	{r4, r5}
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   12d86:	b292      	uxth	r2, r2
   12d88:	2100      	movs	r1, #0
   12d8a:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_OVERRUN) {
   12d8c:	f013 0102 	ands.w	r1, r3, #2
   12d90:	d006      	beq.n	12da0 <_adc_interrupt_handler+0x3c>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
   12d92:	2302      	movs	r3, #2
   12d94:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.error_cb(device, 0);
   12d98:	6843      	ldr	r3, [r0, #4]
   12d9a:	4629      	mov	r1, r5
}
   12d9c:	bc30      	pop	{r4, r5}
		device->adc_async_cb.window_cb(device, 0);
   12d9e:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_WINMON) {
   12da0:	075b      	lsls	r3, r3, #29
   12da2:	d504      	bpl.n	12dae <_adc_interrupt_handler+0x4a>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
   12da4:	2304      	movs	r3, #4
   12da6:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.window_cb(device, 0);
   12daa:	6803      	ldr	r3, [r0, #0]
   12dac:	e7f6      	b.n	12d9c <_adc_interrupt_handler+0x38>
}
   12dae:	bc30      	pop	{r4, r5}
   12db0:	4770      	bx	lr
	...

00012db4 <_adc_get_regs>:
{
   12db4:	b508      	push	{r3, lr}
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12db6:	f100 433d 	add.w	r3, r0, #3170893824	; 0xbd000000
   12dba:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
		if (_adcs[i].number == n) {
   12dbe:	f413 3f7f 	tst.w	r3, #261120	; 0x3fc00
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12dc2:	f3c3 2087 	ubfx	r0, r3, #10, #8
		if (_adcs[i].number == n) {
   12dc6:	d007      	beq.n	12dd8 <_adc_get_regs+0x24>
   12dc8:	2801      	cmp	r0, #1
   12dca:	d005      	beq.n	12dd8 <_adc_get_regs+0x24>
	ASSERT(false);
   12dcc:	2000      	movs	r0, #0
   12dce:	4903      	ldr	r1, [pc, #12]	; (12ddc <_adc_get_regs+0x28>)
   12dd0:	4b03      	ldr	r3, [pc, #12]	; (12de0 <_adc_get_regs+0x2c>)
   12dd2:	228c      	movs	r2, #140	; 0x8c
   12dd4:	4798      	blx	r3
	return 0;
   12dd6:	2000      	movs	r0, #0
}
   12dd8:	bd08      	pop	{r3, pc}
   12dda:	bf00      	nop
   12ddc:	000177ef 	.word	0x000177ef
   12de0:	0000e08d 	.word	0x0000e08d

00012de4 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12de4:	0943      	lsrs	r3, r0, #5
   12de6:	2201      	movs	r2, #1
   12de8:	f000 001f 	and.w	r0, r0, #31
   12dec:	fa02 f000 	lsl.w	r0, r2, r0
   12df0:	3360      	adds	r3, #96	; 0x60
   12df2:	4a02      	ldr	r2, [pc, #8]	; (12dfc <__NVIC_ClearPendingIRQ+0x18>)
   12df4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   12df8:	4770      	bx	lr
   12dfa:	bf00      	nop
   12dfc:	e000e100 	.word	0xe000e100

00012e00 <_adc_get_irq_num.isra.0>:
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12e00:	f100 403d 	add.w	r0, r0, #3170893824	; 0xbd000000
   12e04:	f5a0 50e0 	sub.w	r0, r0, #7168	; 0x1c00
   12e08:	0a80      	lsrs	r0, r0, #10
	return ADC0_0_IRQn + (_adc_get_hardware_index(device->hw) << 1);
   12e0a:	0040      	lsls	r0, r0, #1
   12e0c:	3076      	adds	r0, #118	; 0x76
}
   12e0e:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   12e12:	4770      	bx	lr

00012e14 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12e14:	0943      	lsrs	r3, r0, #5
   12e16:	2201      	movs	r2, #1
   12e18:	f000 001f 	and.w	r0, r0, #31
   12e1c:	fa02 f000 	lsl.w	r0, r2, r0
   12e20:	3320      	adds	r3, #32
   12e22:	4a04      	ldr	r2, [pc, #16]	; (12e34 <__NVIC_DisableIRQ+0x20>)
   12e24:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   12e28:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   12e2c:	f3bf 8f6f 	isb	sy
}
   12e30:	4770      	bx	lr
   12e32:	bf00      	nop
   12e34:	e000e100 	.word	0xe000e100

00012e38 <_adc_init>:
{
   12e38:	b538      	push	{r3, r4, r5, lr}
	if (hw == ADC0) {
   12e3a:	4b39      	ldr	r3, [pc, #228]	; (12f20 <_adc_init+0xe8>)
   12e3c:	4298      	cmp	r0, r3
{
   12e3e:	460c      	mov	r4, r1
	if (hw == ADC0) {
   12e40:	d15c      	bne.n	12efc <_adc_init+0xc4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   12e42:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   12e46:	681b      	ldr	r3, [r3, #0]
   12e48:	00da      	lsls	r2, r3, #3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   12e4a:	0919      	lsrs	r1, r3, #4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   12e4c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   12e50:	f001 0170 	and.w	r1, r1, #112	; 0x70
   12e54:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
   12e56:	f3c3 0382 	ubfx	r3, r3, #2, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12e5a:	431a      	orrs	r2, r3
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
   12e5c:	6b03      	ldr	r3, [r0, #48]	; 0x30
   12e5e:	4d31      	ldr	r5, [pc, #196]	; (12f24 <_adc_init+0xec>)
	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
   12e60:	f013 0f01 	tst.w	r3, #1
   12e64:	d10c      	bne.n	12e80 <_adc_init+0x48>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12e66:	2103      	movs	r1, #3
   12e68:	47a8      	blx	r5
	tmp = ((Adc *)hw)->CTRLA.reg;
   12e6a:	8803      	ldrh	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
   12e6c:	079b      	lsls	r3, r3, #30
   12e6e:	d503      	bpl.n	12e78 <_adc_init+0x40>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
   12e70:	4b2d      	ldr	r3, [pc, #180]	; (12f28 <_adc_init+0xf0>)
   12e72:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
   12e74:	2102      	movs	r1, #2
   12e76:	47a8      	blx	r5
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
   12e78:	2301      	movs	r3, #1
   12e7a:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12e7c:	2103      	movs	r1, #3
   12e7e:	47a8      	blx	r5
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
   12e80:	2101      	movs	r1, #1
   12e82:	47a8      	blx	r5
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
   12e84:	4929      	ldr	r1, [pc, #164]	; (12f2c <_adc_init+0xf4>)
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
   12e86:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
   12e8a:	2316      	movs	r3, #22
   12e8c:	fb03 1404 	mla	r4, r3, r4, r1
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e90:	f640 71ff 	movw	r1, #4095	; 0xfff
   12e94:	88a3      	ldrh	r3, [r4, #4]
	((Adc *)hw)->CTRLB.reg = data;
   12e96:	80c3      	strh	r3, [r0, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e98:	47a8      	blx	r5
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
   12e9a:	79a3      	ldrb	r3, [r4, #6]
	((Adc *)hw)->REFCTRL.reg = data;
   12e9c:	7203      	strb	r3, [r0, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12e9e:	f640 71ff 	movw	r1, #4095	; 0xfff
   12ea2:	47a8      	blx	r5
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
   12ea4:	79e3      	ldrb	r3, [r4, #7]
	((Adc *)hw)->EVCTRL.reg = data;
   12ea6:	7083      	strb	r3, [r0, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
   12ea8:	8923      	ldrh	r3, [r4, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
   12eaa:	8083      	strh	r3, [r0, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12eac:	f640 71ff 	movw	r1, #4095	; 0xfff
   12eb0:	47a8      	blx	r5
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
   12eb2:	7aa3      	ldrb	r3, [r4, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
   12eb4:	7283      	strb	r3, [r0, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12eb6:	f640 71ff 	movw	r1, #4095	; 0xfff
   12eba:	47a8      	blx	r5
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
   12ebc:	7ae3      	ldrb	r3, [r4, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
   12ebe:	72c3      	strb	r3, [r0, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12ec0:	f640 71ff 	movw	r1, #4095	; 0xfff
   12ec4:	47a8      	blx	r5
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
   12ec6:	89a3      	ldrh	r3, [r4, #12]
	((Adc *)hw)->WINLT.reg = data;
   12ec8:	8183      	strh	r3, [r0, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
   12eca:	2180      	movs	r1, #128	; 0x80
   12ecc:	47a8      	blx	r5
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
   12ece:	89e3      	ldrh	r3, [r4, #14]
	((Adc *)hw)->WINUT.reg = data;
   12ed0:	81c3      	strh	r3, [r0, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
   12ed2:	f44f 7180 	mov.w	r1, #256	; 0x100
   12ed6:	47a8      	blx	r5
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
   12ed8:	8a23      	ldrh	r3, [r4, #16]
	((Adc *)hw)->GAINCORR.reg = data;
   12eda:	8203      	strh	r3, [r0, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
   12edc:	f44f 7100 	mov.w	r1, #512	; 0x200
   12ee0:	47a8      	blx	r5
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
   12ee2:	8a63      	ldrh	r3, [r4, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
   12ee4:	8243      	strh	r3, [r0, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
   12ee6:	f44f 6180 	mov.w	r1, #1024	; 0x400
   12eea:	47a8      	blx	r5
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
   12eec:	7d23      	ldrb	r3, [r4, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
   12eee:	70c3      	strb	r3, [r0, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
   12ef0:	8863      	ldrh	r3, [r4, #2]
	((Adc *)hw)->CTRLA.reg = data;
   12ef2:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12ef4:	2103      	movs	r1, #3
   12ef6:	47a8      	blx	r5
}
   12ef8:	2000      	movs	r0, #0
   12efa:	bd38      	pop	{r3, r4, r5, pc}
	} else if (hw == ADC1) {
   12efc:	4b0c      	ldr	r3, [pc, #48]	; (12f30 <_adc_init+0xf8>)
   12efe:	4298      	cmp	r0, r3
   12f00:	d10c      	bne.n	12f1c <_adc_init+0xe4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12f02:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   12f06:	681b      	ldr	r3, [r3, #0]
   12f08:	0ada      	lsrs	r2, r3, #11
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   12f0a:	0c99      	lsrs	r1, r3, #18
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12f0c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   12f10:	f001 0170 	and.w	r1, r1, #112	; 0x70
   12f14:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
   12f16:	f3c3 4302 	ubfx	r3, r3, #16, #3
   12f1a:	e79e      	b.n	12e5a <_adc_init+0x22>
	uint16_t calib_reg = 0;
   12f1c:	2200      	movs	r2, #0
   12f1e:	e79d      	b.n	12e5c <_adc_init+0x24>
   12f20:	43001c00 	.word	0x43001c00
   12f24:	00012d31 	.word	0x00012d31
   12f28:	00012d4d 	.word	0x00012d4d
   12f2c:	00017804 	.word	0x00017804
   12f30:	43002000 	.word	0x43002000

00012f34 <_adc_async_init>:
{
   12f34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ASSERT(device);
   12f38:	4604      	mov	r4, r0
   12f3a:	3800      	subs	r0, #0
   12f3c:	bf18      	it	ne
   12f3e:	2001      	movne	r0, #1
{
   12f40:	460d      	mov	r5, r1
	ASSERT(device);
   12f42:	22f1      	movs	r2, #241	; 0xf1
   12f44:	4923      	ldr	r1, [pc, #140]	; (12fd4 <_adc_async_init+0xa0>)
   12f46:	4b24      	ldr	r3, [pc, #144]	; (12fd8 <_adc_async_init+0xa4>)
   12f48:	4798      	blx	r3
	init_status = _adc_init(hw, _adc_get_regs((uint32_t)hw));
   12f4a:	4b24      	ldr	r3, [pc, #144]	; (12fdc <_adc_async_init+0xa8>)
   12f4c:	4628      	mov	r0, r5
   12f4e:	4798      	blx	r3
   12f50:	4b23      	ldr	r3, [pc, #140]	; (12fe0 <_adc_async_init+0xac>)
   12f52:	4601      	mov	r1, r0
   12f54:	4628      	mov	r0, r5
   12f56:	4798      	blx	r3
	if (init_status) {
   12f58:	4606      	mov	r6, r0
   12f5a:	2800      	cmp	r0, #0
   12f5c:	d130      	bne.n	12fc0 <_adc_async_init+0x8c>
	if (hw == ADC0) {
   12f5e:	4b21      	ldr	r3, [pc, #132]	; (12fe4 <_adc_async_init+0xb0>)
	device->hw = hw;
   12f60:	6165      	str	r5, [r4, #20]
	if (hw == ADC0) {
   12f62:	429d      	cmp	r5, r3
   12f64:	d12f      	bne.n	12fc6 <_adc_async_init+0x92>
		_adc0_dev = dev;
   12f66:	4b20      	ldr	r3, [pc, #128]	; (12fe8 <_adc_async_init+0xb4>)
   12f68:	601c      	str	r4, [r3, #0]
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   12f6a:	4920      	ldr	r1, [pc, #128]	; (12fec <_adc_async_init+0xb8>)
   12f6c:	f8df 9088 	ldr.w	r9, [pc, #136]	; 12ff8 <_adc_async_init+0xc4>
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   12f70:	f8df 8088 	ldr.w	r8, [pc, #136]	; 12ffc <_adc_async_init+0xc8>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12f74:	4f1e      	ldr	r7, [pc, #120]	; (12ff0 <_adc_async_init+0xbc>)
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   12f76:	4628      	mov	r0, r5
   12f78:	4788      	blx	r1
   12f7a:	b200      	sxth	r0, r0
   12f7c:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   12f7e:	6960      	ldr	r0, [r4, #20]
   12f80:	4788      	blx	r1
   12f82:	b200      	sxth	r0, r0
   12f84:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 0);
   12f86:	6960      	ldr	r0, [r4, #20]
   12f88:	4788      	blx	r1
   12f8a:	2501      	movs	r5, #1
   12f8c:	0942      	lsrs	r2, r0, #5
   12f8e:	f000 031f 	and.w	r3, r0, #31
   12f92:	fa05 f303 	lsl.w	r3, r5, r3
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 1);
   12f96:	4428      	add	r0, r5
   12f98:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
   12f9c:	b200      	sxth	r0, r0
   12f9e:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 1);
   12fa0:	6960      	ldr	r0, [r4, #20]
   12fa2:	4788      	blx	r1
   12fa4:	4428      	add	r0, r5
   12fa6:	b200      	sxth	r0, r0
   12fa8:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 1);
   12faa:	6960      	ldr	r0, [r4, #20]
   12fac:	4788      	blx	r1
   12fae:	1943      	adds	r3, r0, r5
   12fb0:	f3c3 124a 	ubfx	r2, r3, #5, #11
   12fb4:	f003 031f 	and.w	r3, r3, #31
   12fb8:	fa05 f303 	lsl.w	r3, r5, r3
   12fbc:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
}
   12fc0:	4630      	mov	r0, r6
   12fc2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (hw == ADC1) {
   12fc6:	4b0b      	ldr	r3, [pc, #44]	; (12ff4 <_adc_async_init+0xc0>)
   12fc8:	429d      	cmp	r5, r3
		_adc1_dev = dev;
   12fca:	bf04      	itt	eq
   12fcc:	4b06      	ldreq	r3, [pc, #24]	; (12fe8 <_adc_async_init+0xb4>)
   12fce:	605c      	streq	r4, [r3, #4]
   12fd0:	e7cb      	b.n	12f6a <_adc_async_init+0x36>
   12fd2:	bf00      	nop
   12fd4:	000177ef 	.word	0x000177ef
   12fd8:	0000e08d 	.word	0x0000e08d
   12fdc:	00012db5 	.word	0x00012db5
   12fe0:	00012e39 	.word	0x00012e39
   12fe4:	43001c00 	.word	0x43001c00
   12fe8:	20009100 	.word	0x20009100
   12fec:	00012e01 	.word	0x00012e01
   12ff0:	e000e100 	.word	0xe000e100
   12ff4:	43002000 	.word	0x43002000
   12ff8:	00012e15 	.word	0x00012e15
   12ffc:	00012de5 	.word	0x00012de5

00013000 <_adc_async_enable_channel>:
	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
   13000:	6940      	ldr	r0, [r0, #20]
   13002:	4b01      	ldr	r3, [pc, #4]	; (13008 <_adc_async_enable_channel+0x8>)
   13004:	4718      	bx	r3
   13006:	bf00      	nop
   13008:	00012d39 	.word	0x00012d39

0001300c <_adc_async_get_data_size>:
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
   1300c:	6943      	ldr	r3, [r0, #20]
	tmp = ((Adc *)hw)->CTRLB.reg;
   1300e:	88db      	ldrh	r3, [r3, #6]
   13010:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   13014:	2b03      	cmp	r3, #3
}
   13016:	bf0c      	ite	eq
   13018:	2001      	moveq	r0, #1
   1301a:	2002      	movne	r0, #2
   1301c:	4770      	bx	lr
	...

00013020 <_adc_async_convert>:
	hri_adc_set_SWTRIG_START_bit(device->hw);
   13020:	6940      	ldr	r0, [r0, #20]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
   13022:	7d03      	ldrb	r3, [r0, #20]
   13024:	f043 0302 	orr.w	r3, r3, #2
   13028:	7503      	strb	r3, [r0, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   1302a:	f640 71ff 	movw	r1, #4095	; 0xfff
   1302e:	4b01      	ldr	r3, [pc, #4]	; (13034 <_adc_async_convert+0x14>)
   13030:	4718      	bx	r3
   13032:	bf00      	nop
   13034:	00012d31 	.word	0x00012d31

00013038 <_adc_async_set_irq_state>:
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   13038:	2a01      	cmp	r2, #1
	void *const hw = device->hw;
   1303a:	6941      	ldr	r1, [r0, #20]
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   1303c:	d104      	bne.n	13048 <_adc_async_set_irq_state+0x10>
	if (value == 0x0) {
   1303e:	2204      	movs	r2, #4
	if (value == 0x0) {
   13040:	b93b      	cbnz	r3, 13052 <_adc_async_set_irq_state+0x1a>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_RESRDY;
   13042:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
   13046:	4770      	bx	lr
	} else if (ADC_ASYNC_DEVICE_ERROR_CB == type) {
   13048:	2a02      	cmp	r2, #2
   1304a:	d0f9      	beq.n	13040 <_adc_async_set_irq_state+0x8>
	} else if (ADC_ASYNC_DEVICE_CONVERT_CB == type) {
   1304c:	b91a      	cbnz	r2, 13056 <_adc_async_set_irq_state+0x1e>
	if (value == 0x0) {
   1304e:	2201      	movs	r2, #1
   13050:	e7f6      	b.n	13040 <_adc_async_set_irq_state+0x8>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_RESRDY;
   13052:	f881 202d 	strb.w	r2, [r1, #45]	; 0x2d
}
   13056:	4770      	bx	lr

00013058 <ADC0_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC0_0_Handler(void)
{
	_adc_interrupt_handler(_adc0_dev);
   13058:	4b01      	ldr	r3, [pc, #4]	; (13060 <ADC0_0_Handler+0x8>)
   1305a:	6818      	ldr	r0, [r3, #0]
   1305c:	4b01      	ldr	r3, [pc, #4]	; (13064 <ADC0_0_Handler+0xc>)
   1305e:	4718      	bx	r3
   13060:	20009100 	.word	0x20009100
   13064:	00012d65 	.word	0x00012d65

00013068 <ADC0_1_Handler>:
   13068:	4b00      	ldr	r3, [pc, #0]	; (1306c <ADC0_1_Handler+0x4>)
   1306a:	4718      	bx	r3
   1306c:	00013059 	.word	0x00013059

00013070 <ADC1_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC1_0_Handler(void)
{
	_adc_interrupt_handler(_adc1_dev);
   13070:	4b01      	ldr	r3, [pc, #4]	; (13078 <ADC1_0_Handler+0x8>)
   13072:	6858      	ldr	r0, [r3, #4]
   13074:	4b01      	ldr	r3, [pc, #4]	; (1307c <ADC1_0_Handler+0xc>)
   13076:	4718      	bx	r3
   13078:	20009100 	.word	0x20009100
   1307c:	00012d65 	.word	0x00012d65

00013080 <ADC1_1_Handler>:
   13080:	4b00      	ldr	r3, [pc, #0]	; (13084 <ADC1_1_Handler+0x4>)
   13082:	4718      	bx	r3
   13084:	00013071 	.word	0x00013071

00013088 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
   13088:	e7fe      	b.n	13088 <Dummy_Handler>
	...

0001308c <Reset_Handler>:
{
   1308c:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
   1308e:	4a14      	ldr	r2, [pc, #80]	; (130e0 <Reset_Handler+0x54>)
   13090:	4b14      	ldr	r3, [pc, #80]	; (130e4 <Reset_Handler+0x58>)
   13092:	429a      	cmp	r2, r3
   13094:	d002      	beq.n	1309c <Reset_Handler+0x10>
		for (; pDest < &_erelocate;) {
   13096:	4914      	ldr	r1, [pc, #80]	; (130e8 <Reset_Handler+0x5c>)
   13098:	428b      	cmp	r3, r1
   1309a:	d318      	bcc.n	130ce <Reset_Handler+0x42>
	pSrc  = &_etext;
   1309c:	4b13      	ldr	r3, [pc, #76]	; (130ec <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
   1309e:	4a14      	ldr	r2, [pc, #80]	; (130f0 <Reset_Handler+0x64>)
		*pDest++ = 0;
   130a0:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
   130a2:	4293      	cmp	r3, r2
   130a4:	d318      	bcc.n	130d8 <Reset_Handler+0x4c>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
   130a6:	4a13      	ldr	r2, [pc, #76]	; (130f4 <Reset_Handler+0x68>)
   130a8:	4b13      	ldr	r3, [pc, #76]	; (130f8 <Reset_Handler+0x6c>)
   130aa:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   130ae:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
   130b0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   130b4:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   130b8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   130bc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   130c0:	f3bf 8f6f 	isb	sy
	__libc_init_array();
   130c4:	4b0d      	ldr	r3, [pc, #52]	; (130fc <Reset_Handler+0x70>)
   130c6:	4798      	blx	r3
	main();
   130c8:	4b0d      	ldr	r3, [pc, #52]	; (13100 <Reset_Handler+0x74>)
   130ca:	4798      	blx	r3
	while (1)
   130cc:	e7fe      	b.n	130cc <Reset_Handler+0x40>
			*pDest++ = *pSrc++;
   130ce:	f852 0b04 	ldr.w	r0, [r2], #4
   130d2:	f843 0b04 	str.w	r0, [r3], #4
   130d6:	e7df      	b.n	13098 <Reset_Handler+0xc>
		*pDest++ = 0;
   130d8:	f843 1b04 	str.w	r1, [r3], #4
   130dc:	e7e1      	b.n	130a2 <Reset_Handler+0x16>
   130de:	bf00      	nop
   130e0:	0001798c 	.word	0x0001798c
   130e4:	20000000 	.word	0x20000000
   130e8:	200005b0 	.word	0x200005b0
   130ec:	200005b0 	.word	0x200005b0
   130f0:	2001cfd8 	.word	0x2001cfd8
   130f4:	00004000 	.word	0x00004000
   130f8:	e000ed00 	.word	0xe000ed00
   130fc:	000142cd 	.word	0x000142cd
   13100:	0001218d 	.word	0x0001218d

00013104 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
   13104:	b510      	push	{r4, lr}
	system_init();
   13106:	4b04      	ldr	r3, [pc, #16]	; (13118 <atmel_start_init+0x14>)
   13108:	4798      	blx	r3
	usb_init();
   1310a:	4b04      	ldr	r3, [pc, #16]	; (1311c <atmel_start_init+0x18>)
   1310c:	4798      	blx	r3
	stdio_redirect_init();
}
   1310e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
   13112:	4b03      	ldr	r3, [pc, #12]	; (13120 <atmel_start_init+0x1c>)
   13114:	4718      	bx	r3
   13116:	bf00      	nop
   13118:	000103b5 	.word	0x000103b5
   1311c:	0000c969 	.word	0x0000c969
   13120:	0000ed1d 	.word	0x0000ed1d

00013124 <usbdc_unconfig>:
/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   13124:	4b05      	ldr	r3, [pc, #20]	; (1313c <usbdc_unconfig+0x18>)
{
   13126:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   13128:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
   1312a:	b904      	cbnz	r4, 1312e <usbdc_unconfig+0xa>
		func->ctrl(func, USBDF_DISABLE, NULL);
		func = func->next;
	}
}
   1312c:	bd10      	pop	{r4, pc}
		func->ctrl(func, USBDF_DISABLE, NULL);
   1312e:	6863      	ldr	r3, [r4, #4]
   13130:	4620      	mov	r0, r4
   13132:	2200      	movs	r2, #0
   13134:	2101      	movs	r1, #1
   13136:	4798      	blx	r3
		func = func->next;
   13138:	6824      	ldr	r4, [r4, #0]
   1313a:	e7f6      	b.n	1312a <usbdc_unconfig+0x6>
   1313c:	20009108 	.word	0x20009108

00013140 <usbdc_change_notify>:
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   13140:	4b06      	ldr	r3, [pc, #24]	; (1315c <usbdc_change_notify+0x1c>)
{
   13142:	b570      	push	{r4, r5, r6, lr}
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   13144:	68dc      	ldr	r4, [r3, #12]
{
   13146:	4605      	mov	r5, r0
   13148:	460e      	mov	r6, r1

	while (cg != NULL) {
   1314a:	b904      	cbnz	r4, 1314e <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
	}
}
   1314c:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
   1314e:	6863      	ldr	r3, [r4, #4]
   13150:	b113      	cbz	r3, 13158 <usbdc_change_notify+0x18>
			cg->cb(change, value);
   13152:	4631      	mov	r1, r6
   13154:	4628      	mov	r0, r5
   13156:	4798      	blx	r3
		cg = cg->next;
   13158:	6824      	ldr	r4, [r4, #0]
   1315a:	e7f6      	b.n	1314a <usbdc_change_notify+0xa>
   1315c:	20009108 	.word	0x20009108

00013160 <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
   13160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
   13162:	4b0c      	ldr	r3, [pc, #48]	; (13194 <usbdc_request_handler+0x34>)
   13164:	689c      	ldr	r4, [r3, #8]
{
   13166:	4605      	mov	r5, r0
   13168:	460e      	mov	r6, r1
   1316a:	4617      	mov	r7, r2
	int32_t                   rc;

	while (h != NULL) {
   1316c:	b90c      	cbnz	r4, 13172 <usbdc_request_handler+0x12>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
   1316e:	4620      	mov	r0, r4
}
   13170:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (NULL != h->cb) {
   13172:	6863      	ldr	r3, [r4, #4]
   13174:	b90b      	cbnz	r3, 1317a <usbdc_request_handler+0x1a>
		h = h->next;
   13176:	6824      	ldr	r4, [r4, #0]
   13178:	e7f8      	b.n	1316c <usbdc_request_handler+0xc>
			rc = h->cb(ep, req, stage);
   1317a:	463a      	mov	r2, r7
   1317c:	4631      	mov	r1, r6
   1317e:	4628      	mov	r0, r5
   13180:	4798      	blx	r3
			if (0 == rc) {
   13182:	b120      	cbz	r0, 1318e <usbdc_request_handler+0x2e>
			} else if (ERR_NOT_FOUND != rc) {
   13184:	300a      	adds	r0, #10
   13186:	d0f6      	beq.n	13176 <usbdc_request_handler+0x16>
				return -1;
   13188:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1318c:	e7f0      	b.n	13170 <usbdc_request_handler+0x10>
				return true;
   1318e:	2001      	movs	r0, #1
   13190:	e7ee      	b.n	13170 <usbdc_request_handler+0x10>
   13192:	bf00      	nop
   13194:	20009108 	.word	0x20009108

00013198 <usbd_sof_cb>:
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   13198:	4b04      	ldr	r3, [pc, #16]	; (131ac <usbd_sof_cb+0x14>)

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
   1319a:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   1319c:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
   1319e:	b904      	cbnz	r4, 131a2 <usbd_sof_cb+0xa>
	usbdc_sof_notify();
}
   131a0:	bd10      	pop	{r4, pc}
		if (NULL != sof->cb) {
   131a2:	6863      	ldr	r3, [r4, #4]
   131a4:	b103      	cbz	r3, 131a8 <usbd_sof_cb+0x10>
			sof->cb();
   131a6:	4798      	blx	r3
		sof = sof->next;
   131a8:	6824      	ldr	r4, [r4, #0]
   131aa:	e7f8      	b.n	1319e <usbd_sof_cb+0x6>
   131ac:	20009108 	.word	0x20009108

000131b0 <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
   131b0:	b510      	push	{r4, lr}
   131b2:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
   131b4:	460a      	mov	r2, r1
   131b6:	b119      	cbz	r1, 131c0 <usbdc_cb_ctl_done+0x10>
   131b8:	2901      	cmp	r1, #1
   131ba:	d021      	beq.n	13200 <usbdc_cb_ctl_done+0x50>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
   131bc:	2000      	movs	r0, #0
   131be:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
   131c0:	7823      	ldrb	r3, [r4, #0]
   131c2:	2b00      	cmp	r3, #0
   131c4:	d1fa      	bne.n	131bc <usbdc_cb_ctl_done+0xc>
	switch (req->bRequest) {
   131c6:	7863      	ldrb	r3, [r4, #1]
   131c8:	2b05      	cmp	r3, #5
   131ca:	d00d      	beq.n	131e8 <usbdc_cb_ctl_done+0x38>
   131cc:	2b09      	cmp	r3, #9
   131ce:	d1f5      	bne.n	131bc <usbdc_cb_ctl_done+0xc>
		usbdc.cfg_value = req->wValue;
   131d0:	8862      	ldrh	r2, [r4, #2]
   131d2:	4b0e      	ldr	r3, [pc, #56]	; (1320c <usbdc_cb_ctl_done+0x5c>)
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   131d4:	2a00      	cmp	r2, #0
		usbdc.cfg_value = req->wValue;
   131d6:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   131d8:	bf14      	ite	ne
   131da:	2104      	movne	r1, #4
   131dc:	2103      	moveq	r1, #3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   131de:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
   131e0:	2001      	movs	r0, #1
   131e2:	4b0b      	ldr	r3, [pc, #44]	; (13210 <usbdc_cb_ctl_done+0x60>)
   131e4:	4798      	blx	r3
		break;
   131e6:	e7e9      	b.n	131bc <usbdc_cb_ctl_done+0xc>
		usbdc_set_address(req->wValue);
   131e8:	8860      	ldrh	r0, [r4, #2]
	usb_d_set_address(addr);
   131ea:	4b0a      	ldr	r3, [pc, #40]	; (13214 <usbdc_cb_ctl_done+0x64>)
   131ec:	b2c0      	uxtb	r0, r0
   131ee:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   131f0:	8863      	ldrh	r3, [r4, #2]
   131f2:	2b00      	cmp	r3, #0
   131f4:	bf18      	it	ne
   131f6:	2103      	movne	r1, #3
   131f8:	4b04      	ldr	r3, [pc, #16]	; (1320c <usbdc_cb_ctl_done+0x5c>)
   131fa:	bf08      	it	eq
   131fc:	2102      	moveq	r1, #2
   131fe:	e7ee      	b.n	131de <usbdc_cb_ctl_done+0x2e>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
   13200:	4b05      	ldr	r3, [pc, #20]	; (13218 <usbdc_cb_ctl_done+0x68>)
   13202:	4621      	mov	r1, r4
   13204:	2000      	movs	r0, #0
   13206:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
   13208:	e7d8      	b.n	131bc <usbdc_cb_ctl_done+0xc>
   1320a:	bf00      	nop
   1320c:	20009108 	.word	0x20009108
   13210:	00013141 	.word	0x00013141
   13214:	0000f569 	.word	0x0000f569
   13218:	00013161 	.word	0x00013161

0001321c <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
   1321c:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();

	usbdc.state       = USBD_S_DEFAULT;
   1321e:	4d0d      	ldr	r5, [pc, #52]	; (13254 <usbdc_reset+0x38>)
	usbdc_unconfig();
   13220:	4b0d      	ldr	r3, [pc, #52]	; (13258 <usbdc_reset+0x3c>)
	usbdc.cfg_value   = 0;
	usbdc.ifc_alt_map = 0;
   13222:	2400      	movs	r4, #0
	usbdc.state       = USBD_S_DEFAULT;
   13224:	2602      	movs	r6, #2
	usbdc_unconfig();
   13226:	4798      	blx	r3
	usbdc.state       = USBD_S_DEFAULT;
   13228:	836e      	strh	r6, [r5, #26]

	// Setup EP0
	usb_d_ep_deinit(0);
   1322a:	4620      	mov	r0, r4
   1322c:	4b0b      	ldr	r3, [pc, #44]	; (1325c <usbdc_reset+0x40>)
	usbdc.ifc_alt_map = 0;
   1322e:	776c      	strb	r4, [r5, #29]
	usb_d_ep_deinit(0);
   13230:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
   13232:	4b0b      	ldr	r3, [pc, #44]	; (13260 <usbdc_reset+0x44>)
   13234:	7f28      	ldrb	r0, [r5, #28]
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   13236:	4d0b      	ldr	r5, [pc, #44]	; (13264 <usbdc_reset+0x48>)
	usb_d_ep0_init(usbdc.ctrl_size);
   13238:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   1323a:	4621      	mov	r1, r4
   1323c:	4620      	mov	r0, r4
   1323e:	4a0a      	ldr	r2, [pc, #40]	; (13268 <usbdc_reset+0x4c>)
   13240:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
   13242:	4620      	mov	r0, r4
   13244:	4631      	mov	r1, r6
   13246:	4a09      	ldr	r2, [pc, #36]	; (1326c <usbdc_reset+0x50>)
   13248:	47a8      	blx	r5
	usb_d_ep_enable(0);
   1324a:	4620      	mov	r0, r4
   1324c:	4b08      	ldr	r3, [pc, #32]	; (13270 <usbdc_reset+0x54>)
}
   1324e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_d_ep_enable(0);
   13252:	4718      	bx	r3
   13254:	20009108 	.word	0x20009108
   13258:	00013125 	.word	0x00013125
   1325c:	0000f5d5 	.word	0x0000f5d5
   13260:	0000f5c5 	.word	0x0000f5c5
   13264:	0000f7e9 	.word	0x0000f7e9
   13268:	000132ad 	.word	0x000132ad
   1326c:	000131b1 	.word	0x000131b1
   13270:	0000f601 	.word	0x0000f601

00013274 <usbd_event_cb>:
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
	(void)param;

	switch (ev) {
   13274:	b110      	cbz	r0, 1327c <usbd_event_cb+0x8>
   13276:	2801      	cmp	r0, #1
   13278:	d002      	beq.n	13280 <usbd_event_cb+0xc>
   1327a:	4770      	bx	lr
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
   1327c:	4b01      	ldr	r3, [pc, #4]	; (13284 <usbd_event_cb+0x10>)
   1327e:	4718      	bx	r3
		break;

	case USB_EV_RESET:
		usbdc_reset();
   13280:	4b01      	ldr	r3, [pc, #4]	; (13288 <usbd_event_cb+0x14>)
   13282:	4718      	bx	r3
   13284:	00013141 	.word	0x00013141
   13288:	0001321d 	.word	0x0001321d

0001328c <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
   1328c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   1328e:	f88d 000c 	strb.w	r0, [sp, #12]
   13292:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
   13296:	a801      	add	r0, sp, #4
   13298:	4b03      	ldr	r3, [pc, #12]	; (132a8 <usbdc_xfer+0x1c>)
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   1329a:	e9cd 1201 	strd	r1, r2, [sp, #4]
	return usb_d_ep_transfer(&xfer);
   1329e:	4798      	blx	r3
}
   132a0:	b005      	add	sp, #20
   132a2:	f85d fb04 	ldr.w	pc, [sp], #4
   132a6:	bf00      	nop
   132a8:	0000f641 	.word	0x0000f641

000132ac <usbdc_cb_ctl_req>:
{
   132ac:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   132b0:	4ba6      	ldr	r3, [pc, #664]	; (1354c <usbdc_cb_ctl_req+0x2a0>)
   132b2:	2200      	movs	r2, #0
{
   132b4:	4605      	mov	r5, r0
   132b6:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   132b8:	4798      	blx	r3
   132ba:	1c43      	adds	r3, r0, #1
   132bc:	d008      	beq.n	132d0 <usbdc_cb_ctl_req+0x24>
   132be:	2801      	cmp	r0, #1
   132c0:	d034      	beq.n	1332c <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
   132c2:	7823      	ldrb	r3, [r4, #0]
   132c4:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
   132c8:	d004      	beq.n	132d4 <usbdc_cb_ctl_req+0x28>
   132ca:	2a80      	cmp	r2, #128	; 0x80
   132cc:	f000 80ca 	beq.w	13464 <usbdc_cb_ctl_req+0x1b8>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   132d0:	2000      	movs	r0, #0
   132d2:	e02b      	b.n	1332c <usbdc_cb_ctl_req+0x80>
	switch (req->bRequest) {
   132d4:	7862      	ldrb	r2, [r4, #1]
   132d6:	3a01      	subs	r2, #1
   132d8:	2a0a      	cmp	r2, #10
   132da:	d8f9      	bhi.n	132d0 <usbdc_cb_ctl_req+0x24>
   132dc:	a101      	add	r1, pc, #4	; (adr r1, 132e4 <usbdc_cb_ctl_req+0x38>)
   132de:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   132e2:	bf00      	nop
   132e4:	00013397 	.word	0x00013397
   132e8:	000132d1 	.word	0x000132d1
   132ec:	000133bd 	.word	0x000133bd
   132f0:	000132d1 	.word	0x000132d1
   132f4:	0001331b 	.word	0x0001331b
   132f8:	000132d1 	.word	0x000132d1
   132fc:	000132d1 	.word	0x000132d1
   13300:	000132d1 	.word	0x000132d1
   13304:	00013311 	.word	0x00013311
   13308:	000132d1 	.word	0x000132d1
   1330c:	000133d7 	.word	0x000133d7
		if (!usbdc_set_config(req->wValue)) {
   13310:	8862      	ldrh	r2, [r4, #2]
   13312:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
   13314:	b96a      	cbnz	r2, 13332 <usbdc_cb_ctl_req+0x86>
		usbdc_unconfig();
   13316:	4b8e      	ldr	r3, [pc, #568]	; (13550 <usbdc_cb_ctl_req+0x2a4>)
   13318:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
   1331a:	2200      	movs	r2, #0
   1331c:	2301      	movs	r3, #1
   1331e:	4611      	mov	r1, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   13320:	4c8c      	ldr	r4, [pc, #560]	; (13554 <usbdc_cb_ctl_req+0x2a8>)
   13322:	4628      	mov	r0, r5
   13324:	47a0      	blx	r4
   13326:	fab0 f080 	clz	r0, r0
   1332a:	0940      	lsrs	r0, r0, #5
}
   1332c:	b004      	add	sp, #16
   1332e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
   13332:	4c89      	ldr	r4, [pc, #548]	; (13558 <usbdc_cb_ctl_req+0x2ac>)
   13334:	6823      	ldr	r3, [r4, #0]
   13336:	e9d3 0100 	ldrd	r0, r1, [r3]
   1333a:	4b88      	ldr	r3, [pc, #544]	; (1355c <usbdc_cb_ctl_req+0x2b0>)
   1333c:	4798      	blx	r3
	if (NULL == cfg_desc) {
   1333e:	2800      	cmp	r0, #0
   13340:	d0c6      	beq.n	132d0 <usbdc_cb_ctl_req+0x24>
   13342:	78c2      	ldrb	r2, [r0, #3]
   13344:	7883      	ldrb	r3, [r0, #2]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13346:	4f86      	ldr	r7, [pc, #536]	; (13560 <usbdc_cb_ctl_req+0x2b4>)
   13348:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
   1334c:	fa10 f183 	uxtah	r1, r0, r3
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13350:	2204      	movs	r2, #4
	desc.eod  = cfg_desc + total_len;
   13352:	9103      	str	r1, [sp, #12]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13354:	47b8      	blx	r7
	uint8_t                 last_iface = 0xFF;
   13356:	23ff      	movs	r3, #255	; 0xff
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13358:	9002      	str	r0, [sp, #8]
	while (NULL != desc.sod) {
   1335a:	9a02      	ldr	r2, [sp, #8]
   1335c:	2a00      	cmp	r2, #0
   1335e:	d0dc      	beq.n	1331a <usbdc_cb_ctl_req+0x6e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
   13360:	f892 8002 	ldrb.w	r8, [r2, #2]
   13364:	4598      	cmp	r8, r3
   13366:	d014      	beq.n	13392 <usbdc_cb_ctl_req+0xe6>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
   13368:	6926      	ldr	r6, [r4, #16]
			while (NULL != func) {
   1336a:	b94e      	cbnz	r6, 13380 <usbdc_cb_ctl_req+0xd4>
		desc.sod = usb_desc_next(desc.sod);
   1336c:	9802      	ldr	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   1336e:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   13370:	7803      	ldrb	r3, [r0, #0]
   13372:	2204      	movs	r2, #4
   13374:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   13376:	9002      	str	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13378:	47b8      	blx	r7
   1337a:	4643      	mov	r3, r8
   1337c:	9002      	str	r0, [sp, #8]
   1337e:	e7ec      	b.n	1335a <usbdc_cb_ctl_req+0xae>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
   13380:	6873      	ldr	r3, [r6, #4]
   13382:	aa02      	add	r2, sp, #8
   13384:	2100      	movs	r1, #0
   13386:	4630      	mov	r0, r6
   13388:	4798      	blx	r3
   1338a:	2800      	cmp	r0, #0
   1338c:	d0ee      	beq.n	1336c <usbdc_cb_ctl_req+0xc0>
					func = func->next;
   1338e:	6836      	ldr	r6, [r6, #0]
   13390:	e7eb      	b.n	1336a <usbdc_cb_ctl_req+0xbe>
   13392:	4698      	mov	r8, r3
   13394:	e7ea      	b.n	1336c <usbdc_cb_ctl_req+0xc0>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13396:	2b02      	cmp	r3, #2
   13398:	d19a      	bne.n	132d0 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   1339a:	88e2      	ldrh	r2, [r4, #6]
   1339c:	2a00      	cmp	r2, #0
   1339e:	d197      	bne.n	132d0 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
   133a0:	88a0      	ldrh	r0, [r4, #4]
   133a2:	4b70      	ldr	r3, [pc, #448]	; (13564 <usbdc_cb_ctl_req+0x2b8>)
   133a4:	9201      	str	r2, [sp, #4]
   133a6:	4611      	mov	r1, r2
   133a8:	b2c0      	uxtb	r0, r0
   133aa:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   133ac:	9a01      	ldr	r2, [sp, #4]
   133ae:	2301      	movs	r3, #1
		usbdc_xfer(ep, NULL, 0, true);
   133b0:	4611      	mov	r1, r2
   133b2:	4628      	mov	r0, r5
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   133b4:	4c67      	ldr	r4, [pc, #412]	; (13554 <usbdc_cb_ctl_req+0x2a8>)
   133b6:	47a0      	blx	r4
			return true;
   133b8:	2001      	movs	r0, #1
   133ba:	e7b7      	b.n	1332c <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   133bc:	2b02      	cmp	r3, #2
   133be:	d187      	bne.n	132d0 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   133c0:	88e6      	ldrh	r6, [r4, #6]
   133c2:	2e00      	cmp	r6, #0
   133c4:	d184      	bne.n	132d0 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
   133c6:	88a0      	ldrh	r0, [r4, #4]
   133c8:	4b66      	ldr	r3, [pc, #408]	; (13564 <usbdc_cb_ctl_req+0x2b8>)
   133ca:	2101      	movs	r1, #1
   133cc:	b2c0      	uxtb	r0, r0
   133ce:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   133d0:	2301      	movs	r3, #1
   133d2:	4632      	mov	r2, r6
   133d4:	e7ec      	b.n	133b0 <usbdc_cb_ctl_req+0x104>
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   133d6:	4d60      	ldr	r5, [pc, #384]	; (13558 <usbdc_cb_ctl_req+0x2ac>)
		return usbdc_set_interface(req->wValue, req->wIndex);
   133d8:	8866      	ldrh	r6, [r4, #2]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   133da:	682b      	ldr	r3, [r5, #0]
   133dc:	7eea      	ldrb	r2, [r5, #27]
		return usbdc_set_interface(req->wValue, req->wIndex);
   133de:	88a7      	ldrh	r7, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   133e0:	e9d3 0100 	ldrd	r0, r1, [r3]
   133e4:	4b5d      	ldr	r3, [pc, #372]	; (1355c <usbdc_cb_ctl_req+0x2b0>)
   133e6:	4798      	blx	r3
	if (NULL == ifc) {
   133e8:	2800      	cmp	r0, #0
   133ea:	f43f af71 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
	desc.sod = ifc;
   133ee:	9002      	str	r0, [sp, #8]
	return (ptr[0] + (ptr[1] << 8));
   133f0:	78c2      	ldrb	r2, [r0, #3]
   133f2:	7883      	ldrb	r3, [r0, #2]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   133f4:	4c5a      	ldr	r4, [pc, #360]	; (13560 <usbdc_cb_ctl_req+0x2b4>)
   133f6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
   133fa:	fa10 f183 	uxtah	r1, r0, r3
   133fe:	9103      	str	r1, [sp, #12]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   13400:	2204      	movs	r2, #4
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13402:	47a0      	blx	r4
		if (NULL == ifc) {
   13404:	2800      	cmp	r0, #0
   13406:	f43f af63 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
   1340a:	7883      	ldrb	r3, [r0, #2]
   1340c:	42bb      	cmp	r3, r7
   1340e:	d110      	bne.n	13432 <usbdc_cb_ctl_req+0x186>
   13410:	78c3      	ldrb	r3, [r0, #3]
   13412:	42b3      	cmp	r3, r6
   13414:	d10d      	bne.n	13432 <usbdc_cb_ctl_req+0x186>
	func     = (struct usbdf_driver *)usbdc.func_list.head;
   13416:	692c      	ldr	r4, [r5, #16]
	desc.sod = ifc;
   13418:	9002      	str	r0, [sp, #8]
	while (NULL != func) {
   1341a:	2c00      	cmp	r4, #0
   1341c:	f43f af58 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
   13420:	2101      	movs	r1, #1
   13422:	6863      	ldr	r3, [r4, #4]
   13424:	aa02      	add	r2, sp, #8
   13426:	4620      	mov	r0, r4
   13428:	4798      	blx	r3
   1342a:	4601      	mov	r1, r0
   1342c:	b140      	cbz	r0, 13440 <usbdc_cb_ctl_req+0x194>
			func = func->next;
   1342e:	6824      	ldr	r4, [r4, #0]
   13430:	e7f3      	b.n	1341a <usbdc_cb_ctl_req+0x16e>
		desc.sod = usb_desc_next(desc.sod);
   13432:	9802      	ldr	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13434:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   13436:	7803      	ldrb	r3, [r0, #0]
   13438:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   1343a:	9002      	str	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   1343c:	2204      	movs	r2, #4
   1343e:	e7e0      	b.n	13402 <usbdc_cb_ctl_req+0x156>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
   13440:	6863      	ldr	r3, [r4, #4]
   13442:	aa02      	add	r2, sp, #8
   13444:	4620      	mov	r0, r4
   13446:	4798      	blx	r3
   13448:	2800      	cmp	r0, #0
   1344a:	f47f af41 	bne.w	132d0 <usbdc_cb_ctl_req+0x24>
			if (alt_set) {
   1344e:	b126      	cbz	r6, 1345a <usbdc_cb_ctl_req+0x1ae>
				usbdc.ifc_alt_map |= 1 << ifc_id;
   13450:	2301      	movs	r3, #1
   13452:	40bb      	lsls	r3, r7
   13454:	7f6f      	ldrb	r7, [r5, #29]
   13456:	431f      	orrs	r7, r3
   13458:	776f      	strb	r7, [r5, #29]
			usbdc_xfer(0, NULL, 0, 0);
   1345a:	2300      	movs	r3, #0
   1345c:	461a      	mov	r2, r3
   1345e:	4619      	mov	r1, r3
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13460:	4618      	mov	r0, r3
   13462:	e7a7      	b.n	133b4 <usbdc_cb_ctl_req+0x108>
	switch (req->bRequest) {
   13464:	7862      	ldrb	r2, [r4, #1]
   13466:	2a0a      	cmp	r2, #10
   13468:	f63f af32 	bhi.w	132d0 <usbdc_cb_ctl_req+0x24>
   1346c:	a101      	add	r1, pc, #4	; (adr r1, 13474 <usbdc_cb_ctl_req+0x1c8>)
   1346e:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   13472:	bf00      	nop
   13474:	0001356d 	.word	0x0001356d
   13478:	000132d1 	.word	0x000132d1
   1347c:	000132d1 	.word	0x000132d1
   13480:	000132d1 	.word	0x000132d1
   13484:	000132d1 	.word	0x000132d1
   13488:	000132d1 	.word	0x000132d1
   1348c:	000134a1 	.word	0x000134a1
   13490:	000132d1 	.word	0x000132d1
   13494:	0001353d 	.word	0x0001353d
   13498:	000132d1 	.word	0x000132d1
   1349c:	0001359b 	.word	0x0001359b
	uint8_t type = (uint8_t)(req->wValue >> 8);
   134a0:	8863      	ldrh	r3, [r4, #2]
   134a2:	0a19      	lsrs	r1, r3, #8
	switch (type) {
   134a4:	2902      	cmp	r1, #2
	uint8_t type = (uint8_t)(req->wValue >> 8);
   134a6:	460a      	mov	r2, r1
	switch (type) {
   134a8:	d016      	beq.n	134d8 <usbdc_cb_ctl_req+0x22c>
   134aa:	2903      	cmp	r1, #3
   134ac:	d031      	beq.n	13512 <usbdc_cb_ctl_req+0x266>
   134ae:	2901      	cmp	r1, #1
   134b0:	f47f af0e 	bne.w	132d0 <usbdc_cb_ctl_req+0x24>
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   134b4:	4b28      	ldr	r3, [pc, #160]	; (13558 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   134b6:	88e4      	ldrh	r4, [r4, #6]
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   134b8:	681b      	ldr	r3, [r3, #0]
   134ba:	e9d3 0100 	ldrd	r0, r1, [r3]
   134be:	4b28      	ldr	r3, [pc, #160]	; (13560 <usbdc_cb_ctl_req+0x2b4>)
   134c0:	4798      	blx	r3
	if (!dev_desc) {
   134c2:	4601      	mov	r1, r0
   134c4:	2800      	cmp	r0, #0
   134c6:	f43f af03 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
   134ca:	2c12      	cmp	r4, #18
   134cc:	4622      	mov	r2, r4
   134ce:	f04f 0300 	mov.w	r3, #0
   134d2:	bf28      	it	cs
   134d4:	2212      	movcs	r2, #18
   134d6:	e723      	b.n	13320 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134d8:	4a1f      	ldr	r2, [pc, #124]	; (13558 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   134da:	88e4      	ldrh	r4, [r4, #6]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   134dc:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   134de:	7f16      	ldrb	r6, [r2, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   134e0:	1c5a      	adds	r2, r3, #1
   134e2:	e9d0 0100 	ldrd	r0, r1, [r0]
   134e6:	4b1d      	ldr	r3, [pc, #116]	; (1355c <usbdc_cb_ctl_req+0x2b0>)
   134e8:	b2d2      	uxtb	r2, r2
   134ea:	4798      	blx	r3
	if (NULL == cfg_desc) {
   134ec:	4601      	mov	r1, r0
   134ee:	2800      	cmp	r0, #0
   134f0:	f43f aeee 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
	return (ptr[0] + (ptr[1] << 8));
   134f4:	78c3      	ldrb	r3, [r0, #3]
   134f6:	7882      	ldrb	r2, [r0, #2]
   134f8:	eb02 2203 	add.w	r2, r2, r3, lsl #8
   134fc:	b292      	uxth	r2, r2
	if (length <= total_len) {
   134fe:	4294      	cmp	r4, r2
   13500:	d91a      	bls.n	13538 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13502:	3e01      	subs	r6, #1
   13504:	4226      	tst	r6, r4
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13506:	bf0c      	ite	eq
   13508:	2301      	moveq	r3, #1
   1350a:	2300      	movne	r3, #0
   1350c:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   1350e:	4622      	mov	r2, r4
   13510:	e706      	b.n	13320 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13512:	4a11      	ldr	r2, [pc, #68]	; (13558 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13514:	88e4      	ldrh	r4, [r4, #6]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   13516:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13518:	7f16      	ldrb	r6, [r2, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   1351a:	e9d0 0100 	ldrd	r0, r1, [r0]
   1351e:	b2da      	uxtb	r2, r3
   13520:	4b11      	ldr	r3, [pc, #68]	; (13568 <usbdc_cb_ctl_req+0x2bc>)
   13522:	4798      	blx	r3
	if (NULL == str_desc) {
   13524:	4601      	mov	r1, r0
   13526:	2800      	cmp	r0, #0
   13528:	f43f aed2 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
	if (length <= str_desc[0]) {
   1352c:	7802      	ldrb	r2, [r0, #0]
   1352e:	4294      	cmp	r4, r2
   13530:	d902      	bls.n	13538 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13532:	1e73      	subs	r3, r6, #1
   13534:	4223      	tst	r3, r4
   13536:	e7e6      	b.n	13506 <usbdc_cb_ctl_req+0x25a>
		need_zlp = false;
   13538:	2300      	movs	r3, #0
   1353a:	e7e8      	b.n	1350e <usbdc_cb_ctl_req+0x262>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
   1353c:	4906      	ldr	r1, [pc, #24]	; (13558 <usbdc_cb_ctl_req+0x2ac>)
   1353e:	694b      	ldr	r3, [r1, #20]
   13540:	7eca      	ldrb	r2, [r1, #27]
   13542:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
   13544:	2300      	movs	r3, #0
   13546:	2201      	movs	r2, #1
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13548:	6949      	ldr	r1, [r1, #20]
   1354a:	e732      	b.n	133b2 <usbdc_cb_ctl_req+0x106>
   1354c:	00013161 	.word	0x00013161
   13550:	00013125 	.word	0x00013125
   13554:	0001328d 	.word	0x0001328d
   13558:	20009108 	.word	0x20009108
   1355c:	0000b875 	.word	0x0000b875
   13560:	0000b83d 	.word	0x0000b83d
   13564:	0000f785 	.word	0x0000f785
   13568:	0000b8b1 	.word	0x0000b8b1
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   1356c:	f003 011f 	and.w	r1, r3, #31
   13570:	f013 031e 	ands.w	r3, r3, #30
   13574:	d00b      	beq.n	1358e <usbdc_cb_ctl_req+0x2e2>
   13576:	2902      	cmp	r1, #2
   13578:	f47f aeaa 	bne.w	132d0 <usbdc_cb_ctl_req+0x24>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
   1357c:	88a0      	ldrh	r0, [r4, #4]
   1357e:	4b17      	ldr	r3, [pc, #92]	; (135dc <usbdc_cb_ctl_req+0x330>)
   13580:	b2c0      	uxtb	r0, r0
   13582:	4798      	blx	r3
		if (st < 0) {
   13584:	1e03      	subs	r3, r0, #0
   13586:	f6ff aea3 	blt.w	132d0 <usbdc_cb_ctl_req+0x24>
		st = st & 0x1;
   1358a:	f003 0301 	and.w	r3, r3, #1
	memcpy(usbdc.ctrl_buf, &st, 2);
   1358e:	4914      	ldr	r1, [pc, #80]	; (135e0 <usbdc_cb_ctl_req+0x334>)
   13590:	694a      	ldr	r2, [r1, #20]
   13592:	8013      	strh	r3, [r2, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13594:	2300      	movs	r3, #0
   13596:	2202      	movs	r2, #2
   13598:	e7d6      	b.n	13548 <usbdc_cb_ctl_req+0x29c>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
   1359a:	4911      	ldr	r1, [pc, #68]	; (135e0 <usbdc_cb_ctl_req+0x334>)
   1359c:	88a2      	ldrh	r2, [r4, #4]
   1359e:	7f4b      	ldrb	r3, [r1, #29]
   135a0:	4113      	asrs	r3, r2
   135a2:	f013 0301 	ands.w	r3, r3, #1
   135a6:	460e      	mov	r6, r1
   135a8:	d00c      	beq.n	135c4 <usbdc_cb_ctl_req+0x318>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   135aa:	690d      	ldr	r5, [r1, #16]
	while (NULL != func) {
   135ac:	2d00      	cmp	r5, #0
   135ae:	f43f ae8f 	beq.w	132d0 <usbdc_cb_ctl_req+0x24>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
   135b2:	686b      	ldr	r3, [r5, #4]
   135b4:	4622      	mov	r2, r4
   135b6:	2102      	movs	r1, #2
   135b8:	4628      	mov	r0, r5
   135ba:	4798      	blx	r3
   135bc:	2800      	cmp	r0, #0
   135be:	da06      	bge.n	135ce <usbdc_cb_ctl_req+0x322>
			func = func->next;
   135c0:	682d      	ldr	r5, [r5, #0]
   135c2:	e7f3      	b.n	135ac <usbdc_cb_ctl_req+0x300>
		usbdc.ctrl_buf[0] = 0;
   135c4:	694a      	ldr	r2, [r1, #20]
   135c6:	7013      	strb	r3, [r2, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   135c8:	6949      	ldr	r1, [r1, #20]
   135ca:	2201      	movs	r2, #1
   135cc:	e748      	b.n	13460 <usbdc_cb_ctl_req+0x1b4>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
   135ce:	6973      	ldr	r3, [r6, #20]
   135d0:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   135d2:	6971      	ldr	r1, [r6, #20]
   135d4:	2300      	movs	r3, #0
   135d6:	2201      	movs	r2, #1
   135d8:	e742      	b.n	13460 <usbdc_cb_ctl_req+0x1b4>
   135da:	bf00      	nop
   135dc:	0000f785 	.word	0x0000f785
   135e0:	20009108 	.word	0x20009108

000135e4 <usbdc_register_handler>:
/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
	switch (type) {
   135e4:	2801      	cmp	r0, #1
   135e6:	d005      	beq.n	135f4 <usbdc_register_handler+0x10>
   135e8:	2802      	cmp	r0, #2
   135ea:	d005      	beq.n	135f8 <usbdc_register_handler+0x14>
   135ec:	b930      	cbnz	r0, 135fc <usbdc_register_handler+0x18>
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
   135ee:	4804      	ldr	r0, [pc, #16]	; (13600 <usbdc_register_handler+0x1c>)
		break;
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
		break;
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   135f0:	4b04      	ldr	r3, [pc, #16]	; (13604 <usbdc_register_handler+0x20>)
   135f2:	4718      	bx	r3
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
   135f4:	4804      	ldr	r0, [pc, #16]	; (13608 <usbdc_register_handler+0x24>)
   135f6:	e7fb      	b.n	135f0 <usbdc_register_handler+0xc>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   135f8:	4804      	ldr	r0, [pc, #16]	; (1360c <usbdc_register_handler+0x28>)
   135fa:	e7f9      	b.n	135f0 <usbdc_register_handler+0xc>
		break;
	default:
		break;
	}
}
   135fc:	4770      	bx	lr
   135fe:	bf00      	nop
   13600:	2000910c 	.word	0x2000910c
   13604:	0000f879 	.word	0x0000f879
   13608:	20009110 	.word	0x20009110
   1360c:	20009114 	.word	0x20009114

00013610 <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
   13610:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
   13612:	4604      	mov	r4, r0
   13614:	3800      	subs	r0, #0
   13616:	bf18      	it	ne
   13618:	2001      	movne	r0, #1
   1361a:	490c      	ldr	r1, [pc, #48]	; (1364c <usbdc_init+0x3c>)
   1361c:	4b0c      	ldr	r3, [pc, #48]	; (13650 <usbdc_init+0x40>)
   1361e:	f240 3255 	movw	r2, #853	; 0x355
   13622:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
   13624:	4b0b      	ldr	r3, [pc, #44]	; (13654 <usbdc_init+0x44>)
   13626:	4798      	blx	r3
	if (rc < 0) {
   13628:	2800      	cmp	r0, #0
   1362a:	db0e      	blt.n	1364a <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
   1362c:	4b0a      	ldr	r3, [pc, #40]	; (13658 <usbdc_init+0x48>)
   1362e:	4d0b      	ldr	r5, [pc, #44]	; (1365c <usbdc_init+0x4c>)
   13630:	2220      	movs	r2, #32
   13632:	4618      	mov	r0, r3
   13634:	2100      	movs	r1, #0
   13636:	47a8      	blx	r5
	usbdc.ctrl_buf = ctrl_buf;
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   13638:	4909      	ldr	r1, [pc, #36]	; (13660 <usbdc_init+0x50>)
	usbdc.ctrl_buf = ctrl_buf;
   1363a:	6144      	str	r4, [r0, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   1363c:	4c09      	ldr	r4, [pc, #36]	; (13664 <usbdc_init+0x54>)
   1363e:	2000      	movs	r0, #0
   13640:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
   13642:	2001      	movs	r0, #1
   13644:	4908      	ldr	r1, [pc, #32]	; (13668 <usbdc_init+0x58>)
   13646:	47a0      	blx	r4

	return 0;
   13648:	2000      	movs	r0, #0
}
   1364a:	bd38      	pop	{r3, r4, r5, pc}
   1364c:	00017830 	.word	0x00017830
   13650:	0000e08d 	.word	0x0000e08d
   13654:	0000f4e1 	.word	0x0000f4e1
   13658:	20009108 	.word	0x20009108
   1365c:	00014469 	.word	0x00014469
   13660:	00013199 	.word	0x00013199
   13664:	0000f549 	.word	0x0000f549
   13668:	00013275 	.word	0x00013275

0001366c <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
   1366c:	4601      	mov	r1, r0
	list_insert_at_end(&usbdc.func_list, func);
   1366e:	4b01      	ldr	r3, [pc, #4]	; (13674 <usbdc_register_function+0x8>)
   13670:	4801      	ldr	r0, [pc, #4]	; (13678 <usbdc_register_function+0xc>)
   13672:	4718      	bx	r3
   13674:	0000f879 	.word	0x0000f879
   13678:	20009118 	.word	0x20009118

0001367c <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
   1367c:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
   1367e:	4b0a      	ldr	r3, [pc, #40]	; (136a8 <usbdc_start+0x2c>)
   13680:	7e9c      	ldrb	r4, [r3, #26]
   13682:	b954      	cbnz	r4, 1369a <usbdc_start+0x1e>
		return ERR_BUSY;
	}

	if (desces) {
   13684:	b160      	cbz	r0, 136a0 <usbdc_start+0x24>
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
   13686:	6802      	ldr	r2, [r0, #0]
		usbdc.desces.ls_fs = desces;
   13688:	6018      	str	r0, [r3, #0]
	usbdc.ctrl_size = desces->sod[7];
   1368a:	79d2      	ldrb	r2, [r2, #7]
   1368c:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
   1368e:	2201      	movs	r2, #1
   13690:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
   13692:	4b06      	ldr	r3, [pc, #24]	; (136ac <usbdc_start+0x30>)
   13694:	4798      	blx	r3
	return ERR_NONE;
   13696:	4620      	mov	r0, r4
}
   13698:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
   1369a:	f06f 0003 	mvn.w	r0, #3
   1369e:	e7fb      	b.n	13698 <usbdc_start+0x1c>
		return ERR_BAD_DATA;
   136a0:	f06f 0008 	mvn.w	r0, #8
   136a4:	e7f8      	b.n	13698 <usbdc_start+0x1c>
   136a6:	bf00      	nop
   136a8:	20009108 	.word	0x20009108
   136ac:	0000f551 	.word	0x0000f551

000136b0 <usbdc_attach>:
/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
	usb_d_attach();
   136b0:	4b00      	ldr	r3, [pc, #0]	; (136b4 <usbdc_attach+0x4>)
   136b2:	4718      	bx	r3
   136b4:	0000f559 	.word	0x0000f559

000136b8 <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
   136b8:	4b01      	ldr	r3, [pc, #4]	; (136c0 <usbdc_get_ctrl_buffer+0x8>)
   136ba:	6958      	ldr	r0, [r3, #20]
   136bc:	4770      	bx	lr
   136be:	bf00      	nop
   136c0:	20009108 	.word	0x20009108

000136c4 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
   136c4:	4b03      	ldr	r3, [pc, #12]	; (136d4 <usbdc_get_state+0x10>)
   136c6:	7e98      	ldrb	r0, [r3, #26]
   136c8:	f010 0f10 	tst.w	r0, #16
		return USBD_S_SUSPEND;
	}
	return usbdc.state;
}
   136cc:	bf18      	it	ne
   136ce:	2010      	movne	r0, #16
   136d0:	4770      	bx	lr
   136d2:	bf00      	nop
   136d4:	20009108 	.word	0x20009108

000136d8 <hri_tc_wait_for_sync>:
typedef uint8_t  hri_tccount8_per_reg_t;
typedef uint8_t  hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
   136d8:	6903      	ldr	r3, [r0, #16]
   136da:	420b      	tst	r3, r1
   136dc:	d1fc      	bne.n	136d8 <hri_tc_wait_for_sync>
	};
}
   136de:	4770      	bx	lr

000136e0 <_tc_timer_start>:
/**
 * \brief Start hardware timer
 */
void _tc_timer_start(struct _timer_device *const device)
{
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
   136e0:	68c0      	ldr	r0, [r0, #12]
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
   136e2:	6803      	ldr	r3, [r0, #0]
   136e4:	f043 0302 	orr.w	r3, r3, #2
   136e8:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   136ea:	2103      	movs	r1, #3
   136ec:	4b00      	ldr	r3, [pc, #0]	; (136f0 <_tc_timer_start+0x10>)
   136ee:	4718      	bx	r3
   136f0:	000136d9 	.word	0x000136d9

000136f4 <_tc_timer_get_period>:
/**
 * \brief Retrieve timer period
 */
uint32_t _tc_timer_get_period(const struct _timer_device *const device)
{
	void *const hw = device->hw;
   136f4:	68c0      	ldr	r0, [r0, #12]
{
   136f6:	b508      	push	{r3, lr}
}

static inline hri_tc_ctrla_reg_t hri_tc_read_CTRLA_MODE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   136f8:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   136fa:	f3c3 0381 	ubfx	r3, r3, #2, #2

	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   136fe:	2b02      	cmp	r3, #2
   13700:	d104      	bne.n	1370c <_tc_timer_get_period+0x18>
	TC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tccount32_cc_reg_t hri_tccount32_read_CC_reg(const void *const hw, uint8_t index)
{
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13702:	4b0e      	ldr	r3, [pc, #56]	; (1373c <_tc_timer_get_period+0x48>)
   13704:	21c0      	movs	r1, #192	; 0xc0
   13706:	4798      	blx	r3
	return ((Tc *)hw)->COUNT32.CC[index].reg;
   13708:	69c0      	ldr	r0, [r0, #28]
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
		return hri_tccount8_read_PER_reg(hw);
	}

	return 0;
}
   1370a:	bd08      	pop	{r3, pc}
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1370c:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1370e:	f013 0f0c 	tst.w	r3, #12
   13712:	d105      	bne.n	13720 <_tc_timer_get_period+0x2c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13714:	4b09      	ldr	r3, [pc, #36]	; (1373c <_tc_timer_get_period+0x48>)
   13716:	21c0      	movs	r1, #192	; 0xc0
   13718:	4798      	blx	r3
	return ((Tc *)hw)->COUNT16.CC[index].reg;
   1371a:	8b80      	ldrh	r0, [r0, #28]
   1371c:	b280      	uxth	r0, r0
		return hri_tccount16_read_CC_reg(hw, 0);
   1371e:	e7f4      	b.n	1370a <_tc_timer_get_period+0x16>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13720:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13722:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13726:	2b01      	cmp	r3, #1
   13728:	d105      	bne.n	13736 <_tc_timer_get_period+0x42>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   1372a:	4b04      	ldr	r3, [pc, #16]	; (1373c <_tc_timer_get_period+0x48>)
   1372c:	2120      	movs	r1, #32
   1372e:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.PER.reg;
   13730:	7ec0      	ldrb	r0, [r0, #27]
   13732:	b2c0      	uxtb	r0, r0
		return hri_tccount8_read_PER_reg(hw);
   13734:	e7e9      	b.n	1370a <_tc_timer_get_period+0x16>
	return 0;
   13736:	2000      	movs	r0, #0
   13738:	e7e7      	b.n	1370a <_tc_timer_get_period+0x16>
   1373a:	bf00      	nop
   1373c:	000136d9 	.word	0x000136d9

00013740 <_tc_timer_is_started>:
/**
 * \brief Check if timer is running
 */
bool _tc_timer_is_started(const struct _timer_device *const device)
{
   13740:	b508      	push	{r3, lr}
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
   13742:	68c0      	ldr	r0, [r0, #12]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13744:	4b03      	ldr	r3, [pc, #12]	; (13754 <_tc_timer_is_started+0x14>)
   13746:	2103      	movs	r1, #3
   13748:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1374a:	6800      	ldr	r0, [r0, #0]
}
   1374c:	f3c0 0040 	ubfx	r0, r0, #1, #1
   13750:	bd08      	pop	{r3, pc}
   13752:	bf00      	nop
   13754:	000136d9 	.word	0x000136d9

00013758 <tc_interrupt_handler>:
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
	void *const hw = device->hw;
   13758:	68c2      	ldr	r2, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
   1375a:	7a91      	ldrb	r1, [r2, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
   1375c:	07c9      	lsls	r1, r1, #31
   1375e:	d503      	bpl.n	13768 <tc_interrupt_handler+0x10>
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
   13760:	2101      	movs	r1, #1
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
   13762:	6803      	ldr	r3, [r0, #0]
   13764:	7291      	strb	r1, [r2, #10]
   13766:	4718      	bx	r3
	}
}
   13768:	4770      	bx	lr
	...

0001376c <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
   1376c:	b570      	push	{r4, r5, r6, lr}
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   1376e:	4d15      	ldr	r5, [pc, #84]	; (137c4 <get_tc_index+0x58>)
{
   13770:	4606      	mov	r6, r0
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13772:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   13774:	b088      	sub	sp, #32
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13776:	466c      	mov	r4, sp
   13778:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1377a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1377e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   13782:	466a      	mov	r2, sp
   13784:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
   13786:	f852 1b04 	ldr.w	r1, [r2], #4
   1378a:	42b1      	cmp	r1, r6
   1378c:	d104      	bne.n	13798 <get_tc_index+0x2c>
			return i;
   1378e:	b2d8      	uxtb	r0, r3
		if (_tcs[i].number == index) {
   13790:	b93b      	cbnz	r3, 137a2 <get_tc_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   13792:	4618      	mov	r0, r3
			return i;
   13794:	b240      	sxtb	r0, r0
   13796:	e012      	b.n	137be <get_tc_index+0x52>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   13798:	3301      	adds	r3, #1
   1379a:	2b08      	cmp	r3, #8
   1379c:	d1f3      	bne.n	13786 <get_tc_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   1379e:	2000      	movs	r0, #0
   137a0:	e7f8      	b.n	13794 <get_tc_index+0x28>
		if (_tcs[i].number == index) {
   137a2:	2801      	cmp	r0, #1
   137a4:	d0f6      	beq.n	13794 <get_tc_index+0x28>
   137a6:	2802      	cmp	r0, #2
   137a8:	d0f4      	beq.n	13794 <get_tc_index+0x28>
   137aa:	2803      	cmp	r0, #3
   137ac:	d0f2      	beq.n	13794 <get_tc_index+0x28>
	ASSERT(false);
   137ae:	2000      	movs	r0, #0
   137b0:	4905      	ldr	r1, [pc, #20]	; (137c8 <get_tc_index+0x5c>)
   137b2:	4b06      	ldr	r3, [pc, #24]	; (137cc <get_tc_index+0x60>)
   137b4:	f240 1267 	movw	r2, #359	; 0x167
   137b8:	4798      	blx	r3
	return -1;
   137ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   137be:	b008      	add	sp, #32
   137c0:	bd70      	pop	{r4, r5, r6, pc}
   137c2:	bf00      	nop
   137c4:	0001785c 	.word	0x0001785c
   137c8:	00017846 	.word	0x00017846
   137cc:	0000e08d 	.word	0x0000e08d

000137d0 <_tc_timer_set_irq>:
{
   137d0:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
   137d2:	4b0a      	ldr	r3, [pc, #40]	; (137fc <_tc_timer_set_irq+0x2c>)
   137d4:	68c0      	ldr	r0, [r0, #12]
   137d6:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   137d8:	4b09      	ldr	r3, [pc, #36]	; (13800 <_tc_timer_set_irq+0x30>)
   137da:	490a      	ldr	r1, [pc, #40]	; (13804 <_tc_timer_set_irq+0x34>)
	int8_t      i  = get_tc_index(hw);
   137dc:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
   137de:	f44f 7291 	mov.w	r2, #290	; 0x122
   137e2:	2001      	movs	r0, #1
   137e4:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
   137e6:	4808      	ldr	r0, [pc, #32]	; (13808 <_tc_timer_set_irq+0x38>)
   137e8:	2314      	movs	r3, #20
   137ea:	fb03 0404 	mla	r4, r3, r4, r0
   137ee:	4b07      	ldr	r3, [pc, #28]	; (1380c <_tc_timer_set_irq+0x3c>)
   137f0:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
}
   137f4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_irq_set(_tcs[i].irq);
   137f8:	4718      	bx	r3
   137fa:	bf00      	nop
   137fc:	0001376d 	.word	0x0001376d
   13800:	0000e08d 	.word	0x0000e08d
   13804:	00017846 	.word	0x00017846
   13808:	0001785c 	.word	0x0001785c
   1380c:	0000baf9 	.word	0x0000baf9

00013810 <_tc_timer_stop>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
   13810:	68c0      	ldr	r0, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13812:	6803      	ldr	r3, [r0, #0]
   13814:	f023 0302 	bic.w	r3, r3, #2
   13818:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   1381a:	2103      	movs	r1, #3
   1381c:	4b00      	ldr	r3, [pc, #0]	; (13820 <_tc_timer_stop+0x10>)
   1381e:	4718      	bx	r3
   13820:	000136d9 	.word	0x000136d9

00013824 <_tc_timer_deinit>:
{
   13824:	b570      	push	{r4, r5, r6, lr}
	void *const hw = device->hw;
   13826:	68c4      	ldr	r4, [r0, #12]
	int8_t      i  = get_tc_index(hw);
   13828:	4b17      	ldr	r3, [pc, #92]	; (13888 <_tc_timer_deinit+0x64>)
   1382a:	4620      	mov	r0, r4
   1382c:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   1382e:	4b17      	ldr	r3, [pc, #92]	; (1388c <_tc_timer_deinit+0x68>)
   13830:	4917      	ldr	r1, [pc, #92]	; (13890 <_tc_timer_deinit+0x6c>)
	int8_t      i  = get_tc_index(hw);
   13832:	4605      	mov	r5, r0
	ASSERT(ARRAY_SIZE(_tcs));
   13834:	22cd      	movs	r2, #205	; 0xcd
   13836:	2001      	movs	r0, #1
   13838:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
   1383a:	4816      	ldr	r0, [pc, #88]	; (13894 <_tc_timer_deinit+0x70>)
   1383c:	2314      	movs	r3, #20
   1383e:	fb03 0505 	mla	r5, r3, r5, r0
   13842:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13846:	2b00      	cmp	r3, #0
   13848:	db0d      	blt.n	13866 <_tc_timer_deinit+0x42>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1384a:	095a      	lsrs	r2, r3, #5
   1384c:	2101      	movs	r1, #1
   1384e:	f003 031f 	and.w	r3, r3, #31
   13852:	fa01 f303 	lsl.w	r3, r1, r3
   13856:	3220      	adds	r2, #32
   13858:	490f      	ldr	r1, [pc, #60]	; (13898 <_tc_timer_deinit+0x74>)
   1385a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1385e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13862:	f3bf 8f6f 	isb	sy
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13866:	6823      	ldr	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13868:	4a0c      	ldr	r2, [pc, #48]	; (1389c <_tc_timer_deinit+0x78>)
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   1386a:	f023 0302 	bic.w	r3, r3, #2
   1386e:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13870:	2103      	movs	r1, #3
   13872:	4620      	mov	r0, r4
   13874:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_SWRST;
   13876:	6823      	ldr	r3, [r4, #0]
   13878:	f043 0301 	orr.w	r3, r3, #1
   1387c:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   1387e:	2101      	movs	r1, #1
}
   13880:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   13884:	4710      	bx	r2
   13886:	bf00      	nop
   13888:	0001376d 	.word	0x0001376d
   1388c:	0000e08d 	.word	0x0000e08d
   13890:	00017846 	.word	0x00017846
   13894:	0001785c 	.word	0x0001785c
   13898:	e000e100 	.word	0xe000e100
   1389c:	000136d9 	.word	0x000136d9

000138a0 <_tc_timer_init>:
{
   138a0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int8_t i = get_tc_index(hw);
   138a4:	4b51      	ldr	r3, [pc, #324]	; (139ec <_tc_timer_init+0x14c>)
{
   138a6:	4607      	mov	r7, r0
	int8_t i = get_tc_index(hw);
   138a8:	4608      	mov	r0, r1
{
   138aa:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
   138ac:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   138ae:	4b50      	ldr	r3, [pc, #320]	; (139f0 <_tc_timer_init+0x150>)
   138b0:	4950      	ldr	r1, [pc, #320]	; (139f4 <_tc_timer_init+0x154>)
	device->hw = hw;
   138b2:	60fc      	str	r4, [r7, #12]
	ASSERT(ARRAY_SIZE(_tcs));
   138b4:	22a0      	movs	r2, #160	; 0xa0
	int8_t i = get_tc_index(hw);
   138b6:	4606      	mov	r6, r0
	ASSERT(ARRAY_SIZE(_tcs));
   138b8:	2001      	movs	r0, #1
   138ba:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
   138bc:	6923      	ldr	r3, [r4, #16]
   138be:	4a4e      	ldr	r2, [pc, #312]	; (139f8 <_tc_timer_init+0x158>)
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
   138c0:	f013 0f01 	tst.w	r3, #1
   138c4:	d112      	bne.n	138ec <_tc_timer_init+0x4c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   138c6:	2103      	movs	r1, #3
   138c8:	4620      	mov	r0, r4
   138ca:	4790      	blx	r2
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   138cc:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
   138ce:	079b      	lsls	r3, r3, #30
   138d0:	d507      	bpl.n	138e2 <_tc_timer_init+0x42>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   138d2:	6823      	ldr	r3, [r4, #0]
   138d4:	f023 0302 	bic.w	r3, r3, #2
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   138d8:	2103      	movs	r1, #3
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   138da:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   138dc:	4790      	blx	r2
			hri_tc_wait_for_sync(hw, TC_SYNCBUSY_ENABLE);
   138de:	2102      	movs	r1, #2
   138e0:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   138e2:	2301      	movs	r3, #1
   138e4:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   138e6:	2103      	movs	r1, #3
   138e8:	4620      	mov	r0, r4
   138ea:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   138ec:	f8df 9124 	ldr.w	r9, [pc, #292]	; 13a14 <_tc_timer_init+0x174>
   138f0:	2514      	movs	r5, #20
   138f2:	fb05 9506 	mla	r5, r5, r6, r9
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   138f6:	2101      	movs	r1, #1
   138f8:	4620      	mov	r0, r4
   138fa:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   138fc:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   13900:	f8c4 8000 	str.w	r8, [r4]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13904:	2103      	movs	r1, #3
   13906:	4790      	blx	r2
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
   13908:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
   1390c:	73e3      	strb	r3, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
   1390e:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
   13910:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
   13912:	2301      	movs	r3, #1
   13914:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
   13916:	f008 030c 	and.w	r3, r8, #12
   1391a:	2b08      	cmp	r3, #8
   1391c:	d13b      	bne.n	13996 <_tc_timer_init+0xf6>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
   1391e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13920:	61e3      	str	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13922:	21c0      	movs	r1, #192	; 0xc0
   13924:	4790      	blx	r2
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
   13926:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13928:	6223      	str	r3, [r4, #32]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1392a:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   1392c:	4620      	mov	r0, r4
   1392e:	4790      	blx	r2
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
   13930:	2301      	movs	r3, #1
   13932:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
   13934:	4b31      	ldr	r3, [pc, #196]	; (139fc <_tc_timer_init+0x15c>)
   13936:	429c      	cmp	r4, r3
   13938:	d146      	bne.n	139c8 <_tc_timer_init+0x128>
		_tc0_dev = (struct _timer_device *)dev;
   1393a:	4b31      	ldr	r3, [pc, #196]	; (13a00 <_tc_timer_init+0x160>)
   1393c:	601f      	str	r7, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
   1393e:	2314      	movs	r3, #20
   13940:	fb03 9306 	mla	r3, r3, r6, r9
   13944:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13948:	2b00      	cmp	r3, #0
   1394a:	db0d      	blt.n	13968 <_tc_timer_init+0xc8>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1394c:	095a      	lsrs	r2, r3, #5
   1394e:	2101      	movs	r1, #1
   13950:	f003 031f 	and.w	r3, r3, #31
   13954:	fa01 f303 	lsl.w	r3, r1, r3
   13958:	3220      	adds	r2, #32
   1395a:	492a      	ldr	r1, [pc, #168]	; (13a04 <_tc_timer_init+0x164>)
   1395c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   13960:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13964:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
   13968:	2014      	movs	r0, #20
   1396a:	fb00 9606 	mla	r6, r0, r6, r9
   1396e:	f9b6 3022 	ldrsh.w	r3, [r6, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13972:	2b00      	cmp	r3, #0
   13974:	db0c      	blt.n	13990 <_tc_timer_init+0xf0>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13976:	f003 011f 	and.w	r1, r3, #31
   1397a:	095b      	lsrs	r3, r3, #5
   1397c:	009b      	lsls	r3, r3, #2
   1397e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   13982:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   13986:	2201      	movs	r2, #1
   13988:	408a      	lsls	r2, r1
   1398a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1398e:	601a      	str	r2, [r3, #0]
}
   13990:	2000      	movs	r0, #0
   13992:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
   13996:	b933      	cbnz	r3, 139a6 <_tc_timer_init+0x106>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
   13998:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   1399a:	83a3      	strh	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1399c:	21c0      	movs	r1, #192	; 0xc0
   1399e:	4790      	blx	r2
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
   139a0:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   139a2:	83e3      	strh	r3, [r4, #30]
   139a4:	e7c1      	b.n	1392a <_tc_timer_init+0x8a>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
   139a6:	2b04      	cmp	r3, #4
   139a8:	d1c2      	bne.n	13930 <_tc_timer_init+0x90>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
   139aa:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   139ae:	7723      	strb	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   139b0:	21c0      	movs	r1, #192	; 0xc0
   139b2:	4790      	blx	r2
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
   139b4:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   139b8:	7763      	strb	r3, [r4, #29]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   139ba:	21c0      	movs	r1, #192	; 0xc0
   139bc:	4790      	blx	r2
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
   139be:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
   139c2:	76e3      	strb	r3, [r4, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   139c4:	2120      	movs	r1, #32
   139c6:	e7b1      	b.n	1392c <_tc_timer_init+0x8c>
	if (hw == TC1) {
   139c8:	4b0f      	ldr	r3, [pc, #60]	; (13a08 <_tc_timer_init+0x168>)
   139ca:	429c      	cmp	r4, r3
   139cc:	d008      	beq.n	139e0 <_tc_timer_init+0x140>
	if (hw == TC2) {
   139ce:	4b0f      	ldr	r3, [pc, #60]	; (13a0c <_tc_timer_init+0x16c>)
   139d0:	429c      	cmp	r4, r3
   139d2:	d008      	beq.n	139e6 <_tc_timer_init+0x146>
	if (hw == TC3) {
   139d4:	4b0e      	ldr	r3, [pc, #56]	; (13a10 <_tc_timer_init+0x170>)
   139d6:	429c      	cmp	r4, r3
   139d8:	d1b1      	bne.n	1393e <_tc_timer_init+0x9e>
		_tc3_dev = (struct _timer_device *)dev;
   139da:	4b09      	ldr	r3, [pc, #36]	; (13a00 <_tc_timer_init+0x160>)
   139dc:	60df      	str	r7, [r3, #12]
   139de:	e7ae      	b.n	1393e <_tc_timer_init+0x9e>
		_tc1_dev = (struct _timer_device *)dev;
   139e0:	4b07      	ldr	r3, [pc, #28]	; (13a00 <_tc_timer_init+0x160>)
   139e2:	605f      	str	r7, [r3, #4]
	if (hw == TC3) {
   139e4:	e7ab      	b.n	1393e <_tc_timer_init+0x9e>
		_tc2_dev = (struct _timer_device *)dev;
   139e6:	4b06      	ldr	r3, [pc, #24]	; (13a00 <_tc_timer_init+0x160>)
   139e8:	609f      	str	r7, [r3, #8]
	if (hw == TC3) {
   139ea:	e7a8      	b.n	1393e <_tc_timer_init+0x9e>
   139ec:	0001376d 	.word	0x0001376d
   139f0:	0000e08d 	.word	0x0000e08d
   139f4:	00017846 	.word	0x00017846
   139f8:	000136d9 	.word	0x000136d9
   139fc:	40003800 	.word	0x40003800
   13a00:	20009128 	.word	0x20009128
   13a04:	e000e100 	.word	0xe000e100
   13a08:	40003c00 	.word	0x40003c00
   13a0c:	4101a000 	.word	0x4101a000
   13a10:	4101c000 	.word	0x4101c000
   13a14:	0001785c 	.word	0x0001785c

00013a18 <_tc_timer_set_period>:
	void *const hw = device->hw;
   13a18:	68c0      	ldr	r0, [r0, #12]
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13a1a:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13a1c:	f3c3 0381 	ubfx	r3, r3, #2, #2
	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13a20:	2b02      	cmp	r3, #2
   13a22:	d103      	bne.n	13a2c <_tc_timer_set_period+0x14>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13a24:	61c1      	str	r1, [r0, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13a26:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13a28:	4b09      	ldr	r3, [pc, #36]	; (13a50 <_tc_timer_set_period+0x38>)
   13a2a:	4718      	bx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13a2c:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13a2e:	f013 0f0c 	tst.w	r3, #12
   13a32:	d102      	bne.n	13a3a <_tc_timer_set_period+0x22>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)clock_cycles);
   13a34:	b289      	uxth	r1, r1
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   13a36:	8381      	strh	r1, [r0, #28]
   13a38:	e7f5      	b.n	13a26 <_tc_timer_set_period+0xe>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13a3a:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13a3c:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13a40:	2b01      	cmp	r3, #1
   13a42:	d103      	bne.n	13a4c <_tc_timer_set_period+0x34>
		hri_tccount8_write_PER_reg(hw, clock_cycles);
   13a44:	b2c9      	uxtb	r1, r1
	((Tc *)hw)->COUNT8.PER.reg = data;
   13a46:	76c1      	strb	r1, [r0, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13a48:	2120      	movs	r1, #32
   13a4a:	e7ed      	b.n	13a28 <_tc_timer_set_period+0x10>
}
   13a4c:	4770      	bx	lr
   13a4e:	bf00      	nop
   13a50:	000136d9 	.word	0x000136d9

00013a54 <_tc_get_timer>:
}
   13a54:	4800      	ldr	r0, [pc, #0]	; (13a58 <_tc_get_timer+0x4>)
   13a56:	4770      	bx	lr
   13a58:	2000052c 	.word	0x2000052c

00013a5c <TC0_Handler>:
	tc_interrupt_handler(_tc0_dev);
   13a5c:	4b01      	ldr	r3, [pc, #4]	; (13a64 <TC0_Handler+0x8>)
   13a5e:	6818      	ldr	r0, [r3, #0]
   13a60:	4b01      	ldr	r3, [pc, #4]	; (13a68 <TC0_Handler+0xc>)
   13a62:	4718      	bx	r3
   13a64:	20009128 	.word	0x20009128
   13a68:	00013759 	.word	0x00013759

00013a6c <TC1_Handler>:
	tc_interrupt_handler(_tc1_dev);
   13a6c:	4b01      	ldr	r3, [pc, #4]	; (13a74 <TC1_Handler+0x8>)
   13a6e:	6858      	ldr	r0, [r3, #4]
   13a70:	4b01      	ldr	r3, [pc, #4]	; (13a78 <TC1_Handler+0xc>)
   13a72:	4718      	bx	r3
   13a74:	20009128 	.word	0x20009128
   13a78:	00013759 	.word	0x00013759

00013a7c <TC2_Handler>:
	tc_interrupt_handler(_tc2_dev);
   13a7c:	4b01      	ldr	r3, [pc, #4]	; (13a84 <TC2_Handler+0x8>)
   13a7e:	6898      	ldr	r0, [r3, #8]
   13a80:	4b01      	ldr	r3, [pc, #4]	; (13a88 <TC2_Handler+0xc>)
   13a82:	4718      	bx	r3
   13a84:	20009128 	.word	0x20009128
   13a88:	00013759 	.word	0x00013759

00013a8c <TC3_Handler>:
	tc_interrupt_handler(_tc3_dev);
   13a8c:	4b01      	ldr	r3, [pc, #4]	; (13a94 <TC3_Handler+0x8>)
   13a8e:	68d8      	ldr	r0, [r3, #12]
   13a90:	4b01      	ldr	r3, [pc, #4]	; (13a98 <TC3_Handler+0xc>)
   13a92:	4718      	bx	r3
   13a94:	20009128 	.word	0x20009128
   13a98:	00013759 	.word	0x00013759

00013a9c <_delay_init>:
   13a9c:	4b03      	ldr	r3, [pc, #12]	; (13aac <_delay_init+0x10>)
   13a9e:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   13aa2:	605a      	str	r2, [r3, #4]
   13aa4:	2205      	movs	r2, #5
   13aa6:	601a      	str	r2, [r3, #0]
   13aa8:	4770      	bx	lr
   13aaa:	bf00      	nop
   13aac:	e000e010 	.word	0xe000e010

00013ab0 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
   13ab0:	0e0b      	lsrs	r3, r1, #24
   13ab2:	4a0c      	ldr	r2, [pc, #48]	; (13ae4 <_delay_cycles+0x34>)
{
   13ab4:	b530      	push	{r4, r5, lr}
	uint8_t  n   = cycles >> 24;
   13ab6:	4618      	mov	r0, r3
	uint32_t buf = cycles;

	while (n--) {
		SysTick->LOAD = 0xFFFFFF;
   13ab8:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
	while (n--) {
   13abc:	3801      	subs	r0, #1
   13abe:	b2c0      	uxtb	r0, r0
   13ac0:	28ff      	cmp	r0, #255	; 0xff
   13ac2:	d108      	bne.n	13ad6 <_delay_cycles+0x26>
   13ac4:	eba3 6303 	sub.w	r3, r3, r3, lsl #24
   13ac8:	4419      	add	r1, r3
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			;
		buf -= 0xFFFFFF;
	}

	SysTick->LOAD = buf;
   13aca:	6051      	str	r1, [r2, #4]
	SysTick->VAL  = buf;
   13acc:	6091      	str	r1, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   13ace:	6813      	ldr	r3, [r2, #0]
   13ad0:	03db      	lsls	r3, r3, #15
   13ad2:	d5fc      	bpl.n	13ace <_delay_cycles+0x1e>
		;
}
   13ad4:	bd30      	pop	{r4, r5, pc}
		SysTick->LOAD = 0xFFFFFF;
   13ad6:	6054      	str	r4, [r2, #4]
		SysTick->VAL  = 0xFFFFFF;
   13ad8:	6094      	str	r4, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   13ada:	6815      	ldr	r5, [r2, #0]
   13adc:	03ed      	lsls	r5, r5, #15
   13ade:	d5fc      	bpl.n	13ada <_delay_cycles+0x2a>
   13ae0:	e7ec      	b.n	13abc <_delay_cycles+0xc>
   13ae2:	bf00      	nop
   13ae4:	e000e010 	.word	0xe000e010

00013ae8 <_crc_sync_init>:
/**
 * \brief Initialize CRC.
 */
int32_t _crc_sync_init(struct _crc_sync_device *const device, void *const hw)
{
	device->hw = hw;
   13ae8:	6001      	str	r1, [r0, #0]

	return ERR_NONE;
}
   13aea:	2000      	movs	r0, #0
   13aec:	4770      	bx	lr
	...

00013af0 <__aeabi_drsub>:
   13af0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   13af4:	e002      	b.n	13afc <__adddf3>
   13af6:	bf00      	nop

00013af8 <__aeabi_dsub>:
   13af8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00013afc <__adddf3>:
   13afc:	b530      	push	{r4, r5, lr}
   13afe:	ea4f 0441 	mov.w	r4, r1, lsl #1
   13b02:	ea4f 0543 	mov.w	r5, r3, lsl #1
   13b06:	ea94 0f05 	teq	r4, r5
   13b0a:	bf08      	it	eq
   13b0c:	ea90 0f02 	teqeq	r0, r2
   13b10:	bf1f      	itttt	ne
   13b12:	ea54 0c00 	orrsne.w	ip, r4, r0
   13b16:	ea55 0c02 	orrsne.w	ip, r5, r2
   13b1a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   13b1e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   13b22:	f000 80e2 	beq.w	13cea <__adddf3+0x1ee>
   13b26:	ea4f 5454 	mov.w	r4, r4, lsr #21
   13b2a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   13b2e:	bfb8      	it	lt
   13b30:	426d      	neglt	r5, r5
   13b32:	dd0c      	ble.n	13b4e <__adddf3+0x52>
   13b34:	442c      	add	r4, r5
   13b36:	ea80 0202 	eor.w	r2, r0, r2
   13b3a:	ea81 0303 	eor.w	r3, r1, r3
   13b3e:	ea82 0000 	eor.w	r0, r2, r0
   13b42:	ea83 0101 	eor.w	r1, r3, r1
   13b46:	ea80 0202 	eor.w	r2, r0, r2
   13b4a:	ea81 0303 	eor.w	r3, r1, r3
   13b4e:	2d36      	cmp	r5, #54	; 0x36
   13b50:	bf88      	it	hi
   13b52:	bd30      	pophi	{r4, r5, pc}
   13b54:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   13b58:	ea4f 3101 	mov.w	r1, r1, lsl #12
   13b5c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   13b60:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   13b64:	d002      	beq.n	13b6c <__adddf3+0x70>
   13b66:	4240      	negs	r0, r0
   13b68:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13b6c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   13b70:	ea4f 3303 	mov.w	r3, r3, lsl #12
   13b74:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   13b78:	d002      	beq.n	13b80 <__adddf3+0x84>
   13b7a:	4252      	negs	r2, r2
   13b7c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   13b80:	ea94 0f05 	teq	r4, r5
   13b84:	f000 80a7 	beq.w	13cd6 <__adddf3+0x1da>
   13b88:	f1a4 0401 	sub.w	r4, r4, #1
   13b8c:	f1d5 0e20 	rsbs	lr, r5, #32
   13b90:	db0d      	blt.n	13bae <__adddf3+0xb2>
   13b92:	fa02 fc0e 	lsl.w	ip, r2, lr
   13b96:	fa22 f205 	lsr.w	r2, r2, r5
   13b9a:	1880      	adds	r0, r0, r2
   13b9c:	f141 0100 	adc.w	r1, r1, #0
   13ba0:	fa03 f20e 	lsl.w	r2, r3, lr
   13ba4:	1880      	adds	r0, r0, r2
   13ba6:	fa43 f305 	asr.w	r3, r3, r5
   13baa:	4159      	adcs	r1, r3
   13bac:	e00e      	b.n	13bcc <__adddf3+0xd0>
   13bae:	f1a5 0520 	sub.w	r5, r5, #32
   13bb2:	f10e 0e20 	add.w	lr, lr, #32
   13bb6:	2a01      	cmp	r2, #1
   13bb8:	fa03 fc0e 	lsl.w	ip, r3, lr
   13bbc:	bf28      	it	cs
   13bbe:	f04c 0c02 	orrcs.w	ip, ip, #2
   13bc2:	fa43 f305 	asr.w	r3, r3, r5
   13bc6:	18c0      	adds	r0, r0, r3
   13bc8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   13bcc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13bd0:	d507      	bpl.n	13be2 <__adddf3+0xe6>
   13bd2:	f04f 0e00 	mov.w	lr, #0
   13bd6:	f1dc 0c00 	rsbs	ip, ip, #0
   13bda:	eb7e 0000 	sbcs.w	r0, lr, r0
   13bde:	eb6e 0101 	sbc.w	r1, lr, r1
   13be2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   13be6:	d31b      	bcc.n	13c20 <__adddf3+0x124>
   13be8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   13bec:	d30c      	bcc.n	13c08 <__adddf3+0x10c>
   13bee:	0849      	lsrs	r1, r1, #1
   13bf0:	ea5f 0030 	movs.w	r0, r0, rrx
   13bf4:	ea4f 0c3c 	mov.w	ip, ip, rrx
   13bf8:	f104 0401 	add.w	r4, r4, #1
   13bfc:	ea4f 5244 	mov.w	r2, r4, lsl #21
   13c00:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   13c04:	f080 809a 	bcs.w	13d3c <__adddf3+0x240>
   13c08:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   13c0c:	bf08      	it	eq
   13c0e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   13c12:	f150 0000 	adcs.w	r0, r0, #0
   13c16:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13c1a:	ea41 0105 	orr.w	r1, r1, r5
   13c1e:	bd30      	pop	{r4, r5, pc}
   13c20:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   13c24:	4140      	adcs	r0, r0
   13c26:	eb41 0101 	adc.w	r1, r1, r1
   13c2a:	3c01      	subs	r4, #1
   13c2c:	bf28      	it	cs
   13c2e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   13c32:	d2e9      	bcs.n	13c08 <__adddf3+0x10c>
   13c34:	f091 0f00 	teq	r1, #0
   13c38:	bf04      	itt	eq
   13c3a:	4601      	moveq	r1, r0
   13c3c:	2000      	moveq	r0, #0
   13c3e:	fab1 f381 	clz	r3, r1
   13c42:	bf08      	it	eq
   13c44:	3320      	addeq	r3, #32
   13c46:	f1a3 030b 	sub.w	r3, r3, #11
   13c4a:	f1b3 0220 	subs.w	r2, r3, #32
   13c4e:	da0c      	bge.n	13c6a <__adddf3+0x16e>
   13c50:	320c      	adds	r2, #12
   13c52:	dd08      	ble.n	13c66 <__adddf3+0x16a>
   13c54:	f102 0c14 	add.w	ip, r2, #20
   13c58:	f1c2 020c 	rsb	r2, r2, #12
   13c5c:	fa01 f00c 	lsl.w	r0, r1, ip
   13c60:	fa21 f102 	lsr.w	r1, r1, r2
   13c64:	e00c      	b.n	13c80 <__adddf3+0x184>
   13c66:	f102 0214 	add.w	r2, r2, #20
   13c6a:	bfd8      	it	le
   13c6c:	f1c2 0c20 	rsble	ip, r2, #32
   13c70:	fa01 f102 	lsl.w	r1, r1, r2
   13c74:	fa20 fc0c 	lsr.w	ip, r0, ip
   13c78:	bfdc      	itt	le
   13c7a:	ea41 010c 	orrle.w	r1, r1, ip
   13c7e:	4090      	lslle	r0, r2
   13c80:	1ae4      	subs	r4, r4, r3
   13c82:	bfa2      	ittt	ge
   13c84:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   13c88:	4329      	orrge	r1, r5
   13c8a:	bd30      	popge	{r4, r5, pc}
   13c8c:	ea6f 0404 	mvn.w	r4, r4
   13c90:	3c1f      	subs	r4, #31
   13c92:	da1c      	bge.n	13cce <__adddf3+0x1d2>
   13c94:	340c      	adds	r4, #12
   13c96:	dc0e      	bgt.n	13cb6 <__adddf3+0x1ba>
   13c98:	f104 0414 	add.w	r4, r4, #20
   13c9c:	f1c4 0220 	rsb	r2, r4, #32
   13ca0:	fa20 f004 	lsr.w	r0, r0, r4
   13ca4:	fa01 f302 	lsl.w	r3, r1, r2
   13ca8:	ea40 0003 	orr.w	r0, r0, r3
   13cac:	fa21 f304 	lsr.w	r3, r1, r4
   13cb0:	ea45 0103 	orr.w	r1, r5, r3
   13cb4:	bd30      	pop	{r4, r5, pc}
   13cb6:	f1c4 040c 	rsb	r4, r4, #12
   13cba:	f1c4 0220 	rsb	r2, r4, #32
   13cbe:	fa20 f002 	lsr.w	r0, r0, r2
   13cc2:	fa01 f304 	lsl.w	r3, r1, r4
   13cc6:	ea40 0003 	orr.w	r0, r0, r3
   13cca:	4629      	mov	r1, r5
   13ccc:	bd30      	pop	{r4, r5, pc}
   13cce:	fa21 f004 	lsr.w	r0, r1, r4
   13cd2:	4629      	mov	r1, r5
   13cd4:	bd30      	pop	{r4, r5, pc}
   13cd6:	f094 0f00 	teq	r4, #0
   13cda:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   13cde:	bf06      	itte	eq
   13ce0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   13ce4:	3401      	addeq	r4, #1
   13ce6:	3d01      	subne	r5, #1
   13ce8:	e74e      	b.n	13b88 <__adddf3+0x8c>
   13cea:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   13cee:	bf18      	it	ne
   13cf0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   13cf4:	d029      	beq.n	13d4a <__adddf3+0x24e>
   13cf6:	ea94 0f05 	teq	r4, r5
   13cfa:	bf08      	it	eq
   13cfc:	ea90 0f02 	teqeq	r0, r2
   13d00:	d005      	beq.n	13d0e <__adddf3+0x212>
   13d02:	ea54 0c00 	orrs.w	ip, r4, r0
   13d06:	bf04      	itt	eq
   13d08:	4619      	moveq	r1, r3
   13d0a:	4610      	moveq	r0, r2
   13d0c:	bd30      	pop	{r4, r5, pc}
   13d0e:	ea91 0f03 	teq	r1, r3
   13d12:	bf1e      	ittt	ne
   13d14:	2100      	movne	r1, #0
   13d16:	2000      	movne	r0, #0
   13d18:	bd30      	popne	{r4, r5, pc}
   13d1a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   13d1e:	d105      	bne.n	13d2c <__adddf3+0x230>
   13d20:	0040      	lsls	r0, r0, #1
   13d22:	4149      	adcs	r1, r1
   13d24:	bf28      	it	cs
   13d26:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   13d2a:	bd30      	pop	{r4, r5, pc}
   13d2c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   13d30:	bf3c      	itt	cc
   13d32:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   13d36:	bd30      	popcc	{r4, r5, pc}
   13d38:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13d3c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   13d40:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   13d44:	f04f 0000 	mov.w	r0, #0
   13d48:	bd30      	pop	{r4, r5, pc}
   13d4a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   13d4e:	bf1a      	itte	ne
   13d50:	4619      	movne	r1, r3
   13d52:	4610      	movne	r0, r2
   13d54:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   13d58:	bf1c      	itt	ne
   13d5a:	460b      	movne	r3, r1
   13d5c:	4602      	movne	r2, r0
   13d5e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   13d62:	bf06      	itte	eq
   13d64:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   13d68:	ea91 0f03 	teqeq	r1, r3
   13d6c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   13d70:	bd30      	pop	{r4, r5, pc}
   13d72:	bf00      	nop

00013d74 <__aeabi_ui2d>:
   13d74:	f090 0f00 	teq	r0, #0
   13d78:	bf04      	itt	eq
   13d7a:	2100      	moveq	r1, #0
   13d7c:	4770      	bxeq	lr
   13d7e:	b530      	push	{r4, r5, lr}
   13d80:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13d84:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13d88:	f04f 0500 	mov.w	r5, #0
   13d8c:	f04f 0100 	mov.w	r1, #0
   13d90:	e750      	b.n	13c34 <__adddf3+0x138>
   13d92:	bf00      	nop

00013d94 <__aeabi_i2d>:
   13d94:	f090 0f00 	teq	r0, #0
   13d98:	bf04      	itt	eq
   13d9a:	2100      	moveq	r1, #0
   13d9c:	4770      	bxeq	lr
   13d9e:	b530      	push	{r4, r5, lr}
   13da0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13da4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13da8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   13dac:	bf48      	it	mi
   13dae:	4240      	negmi	r0, r0
   13db0:	f04f 0100 	mov.w	r1, #0
   13db4:	e73e      	b.n	13c34 <__adddf3+0x138>
   13db6:	bf00      	nop

00013db8 <__aeabi_f2d>:
   13db8:	0042      	lsls	r2, r0, #1
   13dba:	ea4f 01e2 	mov.w	r1, r2, asr #3
   13dbe:	ea4f 0131 	mov.w	r1, r1, rrx
   13dc2:	ea4f 7002 	mov.w	r0, r2, lsl #28
   13dc6:	bf1f      	itttt	ne
   13dc8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   13dcc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   13dd0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   13dd4:	4770      	bxne	lr
   13dd6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   13dda:	bf08      	it	eq
   13ddc:	4770      	bxeq	lr
   13dde:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   13de2:	bf04      	itt	eq
   13de4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   13de8:	4770      	bxeq	lr
   13dea:	b530      	push	{r4, r5, lr}
   13dec:	f44f 7460 	mov.w	r4, #896	; 0x380
   13df0:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13df4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   13df8:	e71c      	b.n	13c34 <__adddf3+0x138>
   13dfa:	bf00      	nop

00013dfc <__aeabi_ul2d>:
   13dfc:	ea50 0201 	orrs.w	r2, r0, r1
   13e00:	bf08      	it	eq
   13e02:	4770      	bxeq	lr
   13e04:	b530      	push	{r4, r5, lr}
   13e06:	f04f 0500 	mov.w	r5, #0
   13e0a:	e00a      	b.n	13e22 <__aeabi_l2d+0x16>

00013e0c <__aeabi_l2d>:
   13e0c:	ea50 0201 	orrs.w	r2, r0, r1
   13e10:	bf08      	it	eq
   13e12:	4770      	bxeq	lr
   13e14:	b530      	push	{r4, r5, lr}
   13e16:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   13e1a:	d502      	bpl.n	13e22 <__aeabi_l2d+0x16>
   13e1c:	4240      	negs	r0, r0
   13e1e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13e22:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13e26:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13e2a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   13e2e:	f43f aed8 	beq.w	13be2 <__adddf3+0xe6>
   13e32:	f04f 0203 	mov.w	r2, #3
   13e36:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   13e3a:	bf18      	it	ne
   13e3c:	3203      	addne	r2, #3
   13e3e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   13e42:	bf18      	it	ne
   13e44:	3203      	addne	r2, #3
   13e46:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   13e4a:	f1c2 0320 	rsb	r3, r2, #32
   13e4e:	fa00 fc03 	lsl.w	ip, r0, r3
   13e52:	fa20 f002 	lsr.w	r0, r0, r2
   13e56:	fa01 fe03 	lsl.w	lr, r1, r3
   13e5a:	ea40 000e 	orr.w	r0, r0, lr
   13e5e:	fa21 f102 	lsr.w	r1, r1, r2
   13e62:	4414      	add	r4, r2
   13e64:	e6bd      	b.n	13be2 <__adddf3+0xe6>
   13e66:	bf00      	nop

00013e68 <__aeabi_dmul>:
   13e68:	b570      	push	{r4, r5, r6, lr}
   13e6a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   13e6e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   13e72:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   13e76:	bf1d      	ittte	ne
   13e78:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   13e7c:	ea94 0f0c 	teqne	r4, ip
   13e80:	ea95 0f0c 	teqne	r5, ip
   13e84:	f000 f8de 	bleq	14044 <__aeabi_dmul+0x1dc>
   13e88:	442c      	add	r4, r5
   13e8a:	ea81 0603 	eor.w	r6, r1, r3
   13e8e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   13e92:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   13e96:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   13e9a:	bf18      	it	ne
   13e9c:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   13ea0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13ea4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   13ea8:	d038      	beq.n	13f1c <__aeabi_dmul+0xb4>
   13eaa:	fba0 ce02 	umull	ip, lr, r0, r2
   13eae:	f04f 0500 	mov.w	r5, #0
   13eb2:	fbe1 e502 	umlal	lr, r5, r1, r2
   13eb6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   13eba:	fbe0 e503 	umlal	lr, r5, r0, r3
   13ebe:	f04f 0600 	mov.w	r6, #0
   13ec2:	fbe1 5603 	umlal	r5, r6, r1, r3
   13ec6:	f09c 0f00 	teq	ip, #0
   13eca:	bf18      	it	ne
   13ecc:	f04e 0e01 	orrne.w	lr, lr, #1
   13ed0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   13ed4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   13ed8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   13edc:	d204      	bcs.n	13ee8 <__aeabi_dmul+0x80>
   13ede:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   13ee2:	416d      	adcs	r5, r5
   13ee4:	eb46 0606 	adc.w	r6, r6, r6
   13ee8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   13eec:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   13ef0:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   13ef4:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   13ef8:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   13efc:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   13f00:	bf88      	it	hi
   13f02:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   13f06:	d81e      	bhi.n	13f46 <__aeabi_dmul+0xde>
   13f08:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   13f0c:	bf08      	it	eq
   13f0e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   13f12:	f150 0000 	adcs.w	r0, r0, #0
   13f16:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13f1a:	bd70      	pop	{r4, r5, r6, pc}
   13f1c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   13f20:	ea46 0101 	orr.w	r1, r6, r1
   13f24:	ea40 0002 	orr.w	r0, r0, r2
   13f28:	ea81 0103 	eor.w	r1, r1, r3
   13f2c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   13f30:	bfc2      	ittt	gt
   13f32:	ebd4 050c 	rsbsgt	r5, r4, ip
   13f36:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   13f3a:	bd70      	popgt	{r4, r5, r6, pc}
   13f3c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13f40:	f04f 0e00 	mov.w	lr, #0
   13f44:	3c01      	subs	r4, #1
   13f46:	f300 80ab 	bgt.w	140a0 <__aeabi_dmul+0x238>
   13f4a:	f114 0f36 	cmn.w	r4, #54	; 0x36
   13f4e:	bfde      	ittt	le
   13f50:	2000      	movle	r0, #0
   13f52:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   13f56:	bd70      	pople	{r4, r5, r6, pc}
   13f58:	f1c4 0400 	rsb	r4, r4, #0
   13f5c:	3c20      	subs	r4, #32
   13f5e:	da35      	bge.n	13fcc <__aeabi_dmul+0x164>
   13f60:	340c      	adds	r4, #12
   13f62:	dc1b      	bgt.n	13f9c <__aeabi_dmul+0x134>
   13f64:	f104 0414 	add.w	r4, r4, #20
   13f68:	f1c4 0520 	rsb	r5, r4, #32
   13f6c:	fa00 f305 	lsl.w	r3, r0, r5
   13f70:	fa20 f004 	lsr.w	r0, r0, r4
   13f74:	fa01 f205 	lsl.w	r2, r1, r5
   13f78:	ea40 0002 	orr.w	r0, r0, r2
   13f7c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   13f80:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   13f84:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   13f88:	fa21 f604 	lsr.w	r6, r1, r4
   13f8c:	eb42 0106 	adc.w	r1, r2, r6
   13f90:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13f94:	bf08      	it	eq
   13f96:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13f9a:	bd70      	pop	{r4, r5, r6, pc}
   13f9c:	f1c4 040c 	rsb	r4, r4, #12
   13fa0:	f1c4 0520 	rsb	r5, r4, #32
   13fa4:	fa00 f304 	lsl.w	r3, r0, r4
   13fa8:	fa20 f005 	lsr.w	r0, r0, r5
   13fac:	fa01 f204 	lsl.w	r2, r1, r4
   13fb0:	ea40 0002 	orr.w	r0, r0, r2
   13fb4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13fb8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   13fbc:	f141 0100 	adc.w	r1, r1, #0
   13fc0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13fc4:	bf08      	it	eq
   13fc6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13fca:	bd70      	pop	{r4, r5, r6, pc}
   13fcc:	f1c4 0520 	rsb	r5, r4, #32
   13fd0:	fa00 f205 	lsl.w	r2, r0, r5
   13fd4:	ea4e 0e02 	orr.w	lr, lr, r2
   13fd8:	fa20 f304 	lsr.w	r3, r0, r4
   13fdc:	fa01 f205 	lsl.w	r2, r1, r5
   13fe0:	ea43 0302 	orr.w	r3, r3, r2
   13fe4:	fa21 f004 	lsr.w	r0, r1, r4
   13fe8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13fec:	fa21 f204 	lsr.w	r2, r1, r4
   13ff0:	ea20 0002 	bic.w	r0, r0, r2
   13ff4:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   13ff8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13ffc:	bf08      	it	eq
   13ffe:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14002:	bd70      	pop	{r4, r5, r6, pc}
   14004:	f094 0f00 	teq	r4, #0
   14008:	d10f      	bne.n	1402a <__aeabi_dmul+0x1c2>
   1400a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   1400e:	0040      	lsls	r0, r0, #1
   14010:	eb41 0101 	adc.w	r1, r1, r1
   14014:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14018:	bf08      	it	eq
   1401a:	3c01      	subeq	r4, #1
   1401c:	d0f7      	beq.n	1400e <__aeabi_dmul+0x1a6>
   1401e:	ea41 0106 	orr.w	r1, r1, r6
   14022:	f095 0f00 	teq	r5, #0
   14026:	bf18      	it	ne
   14028:	4770      	bxne	lr
   1402a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   1402e:	0052      	lsls	r2, r2, #1
   14030:	eb43 0303 	adc.w	r3, r3, r3
   14034:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   14038:	bf08      	it	eq
   1403a:	3d01      	subeq	r5, #1
   1403c:	d0f7      	beq.n	1402e <__aeabi_dmul+0x1c6>
   1403e:	ea43 0306 	orr.w	r3, r3, r6
   14042:	4770      	bx	lr
   14044:	ea94 0f0c 	teq	r4, ip
   14048:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1404c:	bf18      	it	ne
   1404e:	ea95 0f0c 	teqne	r5, ip
   14052:	d00c      	beq.n	1406e <__aeabi_dmul+0x206>
   14054:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14058:	bf18      	it	ne
   1405a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1405e:	d1d1      	bne.n	14004 <__aeabi_dmul+0x19c>
   14060:	ea81 0103 	eor.w	r1, r1, r3
   14064:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14068:	f04f 0000 	mov.w	r0, #0
   1406c:	bd70      	pop	{r4, r5, r6, pc}
   1406e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14072:	bf06      	itte	eq
   14074:	4610      	moveq	r0, r2
   14076:	4619      	moveq	r1, r3
   14078:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   1407c:	d019      	beq.n	140b2 <__aeabi_dmul+0x24a>
   1407e:	ea94 0f0c 	teq	r4, ip
   14082:	d102      	bne.n	1408a <__aeabi_dmul+0x222>
   14084:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   14088:	d113      	bne.n	140b2 <__aeabi_dmul+0x24a>
   1408a:	ea95 0f0c 	teq	r5, ip
   1408e:	d105      	bne.n	1409c <__aeabi_dmul+0x234>
   14090:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   14094:	bf1c      	itt	ne
   14096:	4610      	movne	r0, r2
   14098:	4619      	movne	r1, r3
   1409a:	d10a      	bne.n	140b2 <__aeabi_dmul+0x24a>
   1409c:	ea81 0103 	eor.w	r1, r1, r3
   140a0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   140a4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   140a8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   140ac:	f04f 0000 	mov.w	r0, #0
   140b0:	bd70      	pop	{r4, r5, r6, pc}
   140b2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   140b6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   140ba:	bd70      	pop	{r4, r5, r6, pc}

000140bc <__aeabi_ddiv>:
   140bc:	b570      	push	{r4, r5, r6, lr}
   140be:	f04f 0cff 	mov.w	ip, #255	; 0xff
   140c2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   140c6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   140ca:	bf1d      	ittte	ne
   140cc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   140d0:	ea94 0f0c 	teqne	r4, ip
   140d4:	ea95 0f0c 	teqne	r5, ip
   140d8:	f000 f8a7 	bleq	1422a <__aeabi_ddiv+0x16e>
   140dc:	eba4 0405 	sub.w	r4, r4, r5
   140e0:	ea81 0e03 	eor.w	lr, r1, r3
   140e4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   140e8:	ea4f 3101 	mov.w	r1, r1, lsl #12
   140ec:	f000 8088 	beq.w	14200 <__aeabi_ddiv+0x144>
   140f0:	ea4f 3303 	mov.w	r3, r3, lsl #12
   140f4:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   140f8:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   140fc:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   14100:	ea4f 2202 	mov.w	r2, r2, lsl #8
   14104:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   14108:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   1410c:	ea4f 2600 	mov.w	r6, r0, lsl #8
   14110:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   14114:	429d      	cmp	r5, r3
   14116:	bf08      	it	eq
   14118:	4296      	cmpeq	r6, r2
   1411a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   1411e:	f504 7440 	add.w	r4, r4, #768	; 0x300
   14122:	d202      	bcs.n	1412a <__aeabi_ddiv+0x6e>
   14124:	085b      	lsrs	r3, r3, #1
   14126:	ea4f 0232 	mov.w	r2, r2, rrx
   1412a:	1ab6      	subs	r6, r6, r2
   1412c:	eb65 0503 	sbc.w	r5, r5, r3
   14130:	085b      	lsrs	r3, r3, #1
   14132:	ea4f 0232 	mov.w	r2, r2, rrx
   14136:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   1413a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   1413e:	ebb6 0e02 	subs.w	lr, r6, r2
   14142:	eb75 0e03 	sbcs.w	lr, r5, r3
   14146:	bf22      	ittt	cs
   14148:	1ab6      	subcs	r6, r6, r2
   1414a:	4675      	movcs	r5, lr
   1414c:	ea40 000c 	orrcs.w	r0, r0, ip
   14150:	085b      	lsrs	r3, r3, #1
   14152:	ea4f 0232 	mov.w	r2, r2, rrx
   14156:	ebb6 0e02 	subs.w	lr, r6, r2
   1415a:	eb75 0e03 	sbcs.w	lr, r5, r3
   1415e:	bf22      	ittt	cs
   14160:	1ab6      	subcs	r6, r6, r2
   14162:	4675      	movcs	r5, lr
   14164:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   14168:	085b      	lsrs	r3, r3, #1
   1416a:	ea4f 0232 	mov.w	r2, r2, rrx
   1416e:	ebb6 0e02 	subs.w	lr, r6, r2
   14172:	eb75 0e03 	sbcs.w	lr, r5, r3
   14176:	bf22      	ittt	cs
   14178:	1ab6      	subcs	r6, r6, r2
   1417a:	4675      	movcs	r5, lr
   1417c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   14180:	085b      	lsrs	r3, r3, #1
   14182:	ea4f 0232 	mov.w	r2, r2, rrx
   14186:	ebb6 0e02 	subs.w	lr, r6, r2
   1418a:	eb75 0e03 	sbcs.w	lr, r5, r3
   1418e:	bf22      	ittt	cs
   14190:	1ab6      	subcs	r6, r6, r2
   14192:	4675      	movcs	r5, lr
   14194:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   14198:	ea55 0e06 	orrs.w	lr, r5, r6
   1419c:	d018      	beq.n	141d0 <__aeabi_ddiv+0x114>
   1419e:	ea4f 1505 	mov.w	r5, r5, lsl #4
   141a2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   141a6:	ea4f 1606 	mov.w	r6, r6, lsl #4
   141aa:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   141ae:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   141b2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   141b6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   141ba:	d1c0      	bne.n	1413e <__aeabi_ddiv+0x82>
   141bc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   141c0:	d10b      	bne.n	141da <__aeabi_ddiv+0x11e>
   141c2:	ea41 0100 	orr.w	r1, r1, r0
   141c6:	f04f 0000 	mov.w	r0, #0
   141ca:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   141ce:	e7b6      	b.n	1413e <__aeabi_ddiv+0x82>
   141d0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   141d4:	bf04      	itt	eq
   141d6:	4301      	orreq	r1, r0
   141d8:	2000      	moveq	r0, #0
   141da:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   141de:	bf88      	it	hi
   141e0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   141e4:	f63f aeaf 	bhi.w	13f46 <__aeabi_dmul+0xde>
   141e8:	ebb5 0c03 	subs.w	ip, r5, r3
   141ec:	bf04      	itt	eq
   141ee:	ebb6 0c02 	subseq.w	ip, r6, r2
   141f2:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   141f6:	f150 0000 	adcs.w	r0, r0, #0
   141fa:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   141fe:	bd70      	pop	{r4, r5, r6, pc}
   14200:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   14204:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   14208:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   1420c:	bfc2      	ittt	gt
   1420e:	ebd4 050c 	rsbsgt	r5, r4, ip
   14212:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   14216:	bd70      	popgt	{r4, r5, r6, pc}
   14218:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   1421c:	f04f 0e00 	mov.w	lr, #0
   14220:	3c01      	subs	r4, #1
   14222:	e690      	b.n	13f46 <__aeabi_dmul+0xde>
   14224:	ea45 0e06 	orr.w	lr, r5, r6
   14228:	e68d      	b.n	13f46 <__aeabi_dmul+0xde>
   1422a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   1422e:	ea94 0f0c 	teq	r4, ip
   14232:	bf08      	it	eq
   14234:	ea95 0f0c 	teqeq	r5, ip
   14238:	f43f af3b 	beq.w	140b2 <__aeabi_dmul+0x24a>
   1423c:	ea94 0f0c 	teq	r4, ip
   14240:	d10a      	bne.n	14258 <__aeabi_ddiv+0x19c>
   14242:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14246:	f47f af34 	bne.w	140b2 <__aeabi_dmul+0x24a>
   1424a:	ea95 0f0c 	teq	r5, ip
   1424e:	f47f af25 	bne.w	1409c <__aeabi_dmul+0x234>
   14252:	4610      	mov	r0, r2
   14254:	4619      	mov	r1, r3
   14256:	e72c      	b.n	140b2 <__aeabi_dmul+0x24a>
   14258:	ea95 0f0c 	teq	r5, ip
   1425c:	d106      	bne.n	1426c <__aeabi_ddiv+0x1b0>
   1425e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14262:	f43f aefd 	beq.w	14060 <__aeabi_dmul+0x1f8>
   14266:	4610      	mov	r0, r2
   14268:	4619      	mov	r1, r3
   1426a:	e722      	b.n	140b2 <__aeabi_dmul+0x24a>
   1426c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14270:	bf18      	it	ne
   14272:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14276:	f47f aec5 	bne.w	14004 <__aeabi_dmul+0x19c>
   1427a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   1427e:	f47f af0d 	bne.w	1409c <__aeabi_dmul+0x234>
   14282:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   14286:	f47f aeeb 	bne.w	14060 <__aeabi_dmul+0x1f8>
   1428a:	e712      	b.n	140b2 <__aeabi_dmul+0x24a>

0001428c <__aeabi_d2uiz>:
   1428c:	004a      	lsls	r2, r1, #1
   1428e:	d211      	bcs.n	142b4 <__aeabi_d2uiz+0x28>
   14290:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   14294:	d211      	bcs.n	142ba <__aeabi_d2uiz+0x2e>
   14296:	d50d      	bpl.n	142b4 <__aeabi_d2uiz+0x28>
   14298:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   1429c:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   142a0:	d40e      	bmi.n	142c0 <__aeabi_d2uiz+0x34>
   142a2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   142a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   142aa:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   142ae:	fa23 f002 	lsr.w	r0, r3, r2
   142b2:	4770      	bx	lr
   142b4:	f04f 0000 	mov.w	r0, #0
   142b8:	4770      	bx	lr
   142ba:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   142be:	d102      	bne.n	142c6 <__aeabi_d2uiz+0x3a>
   142c0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   142c4:	4770      	bx	lr
   142c6:	f04f 0000 	mov.w	r0, #0
   142ca:	4770      	bx	lr

000142cc <__libc_init_array>:
   142cc:	b570      	push	{r4, r5, r6, lr}
   142ce:	4e0d      	ldr	r6, [pc, #52]	; (14304 <__libc_init_array+0x38>)
   142d0:	4d0d      	ldr	r5, [pc, #52]	; (14308 <__libc_init_array+0x3c>)
   142d2:	1b76      	subs	r6, r6, r5
   142d4:	10b6      	asrs	r6, r6, #2
   142d6:	d006      	beq.n	142e6 <__libc_init_array+0x1a>
   142d8:	2400      	movs	r4, #0
   142da:	3401      	adds	r4, #1
   142dc:	f855 3b04 	ldr.w	r3, [r5], #4
   142e0:	4798      	blx	r3
   142e2:	42a6      	cmp	r6, r4
   142e4:	d1f9      	bne.n	142da <__libc_init_array+0xe>
   142e6:	4e09      	ldr	r6, [pc, #36]	; (1430c <__libc_init_array+0x40>)
   142e8:	4d09      	ldr	r5, [pc, #36]	; (14310 <__libc_init_array+0x44>)
   142ea:	1b76      	subs	r6, r6, r5
   142ec:	f003 fb3e 	bl	1796c <_init>
   142f0:	10b6      	asrs	r6, r6, #2
   142f2:	d006      	beq.n	14302 <__libc_init_array+0x36>
   142f4:	2400      	movs	r4, #0
   142f6:	3401      	adds	r4, #1
   142f8:	f855 3b04 	ldr.w	r3, [r5], #4
   142fc:	4798      	blx	r3
   142fe:	42a6      	cmp	r6, r4
   14300:	d1f9      	bne.n	142f6 <__libc_init_array+0x2a>
   14302:	bd70      	pop	{r4, r5, r6, pc}
   14304:	00017978 	.word	0x00017978
   14308:	00017978 	.word	0x00017978
   1430c:	0001797c 	.word	0x0001797c
   14310:	00017978 	.word	0x00017978

00014314 <malloc>:
   14314:	4b02      	ldr	r3, [pc, #8]	; (14320 <malloc+0xc>)
   14316:	4601      	mov	r1, r0
   14318:	6818      	ldr	r0, [r3, #0]
   1431a:	f000 b94b 	b.w	145b4 <_malloc_r>
   1431e:	bf00      	nop
   14320:	2000054c 	.word	0x2000054c

00014324 <free>:
   14324:	4b02      	ldr	r3, [pc, #8]	; (14330 <free+0xc>)
   14326:	4601      	mov	r1, r0
   14328:	6818      	ldr	r0, [r3, #0]
   1432a:	f000 b8ed 	b.w	14508 <_free_r>
   1432e:	bf00      	nop
   14330:	2000054c 	.word	0x2000054c

00014334 <memcpy>:
   14334:	4684      	mov	ip, r0
   14336:	ea41 0300 	orr.w	r3, r1, r0
   1433a:	f013 0303 	ands.w	r3, r3, #3
   1433e:	d16d      	bne.n	1441c <memcpy+0xe8>
   14340:	3a40      	subs	r2, #64	; 0x40
   14342:	d341      	bcc.n	143c8 <memcpy+0x94>
   14344:	f851 3b04 	ldr.w	r3, [r1], #4
   14348:	f840 3b04 	str.w	r3, [r0], #4
   1434c:	f851 3b04 	ldr.w	r3, [r1], #4
   14350:	f840 3b04 	str.w	r3, [r0], #4
   14354:	f851 3b04 	ldr.w	r3, [r1], #4
   14358:	f840 3b04 	str.w	r3, [r0], #4
   1435c:	f851 3b04 	ldr.w	r3, [r1], #4
   14360:	f840 3b04 	str.w	r3, [r0], #4
   14364:	f851 3b04 	ldr.w	r3, [r1], #4
   14368:	f840 3b04 	str.w	r3, [r0], #4
   1436c:	f851 3b04 	ldr.w	r3, [r1], #4
   14370:	f840 3b04 	str.w	r3, [r0], #4
   14374:	f851 3b04 	ldr.w	r3, [r1], #4
   14378:	f840 3b04 	str.w	r3, [r0], #4
   1437c:	f851 3b04 	ldr.w	r3, [r1], #4
   14380:	f840 3b04 	str.w	r3, [r0], #4
   14384:	f851 3b04 	ldr.w	r3, [r1], #4
   14388:	f840 3b04 	str.w	r3, [r0], #4
   1438c:	f851 3b04 	ldr.w	r3, [r1], #4
   14390:	f840 3b04 	str.w	r3, [r0], #4
   14394:	f851 3b04 	ldr.w	r3, [r1], #4
   14398:	f840 3b04 	str.w	r3, [r0], #4
   1439c:	f851 3b04 	ldr.w	r3, [r1], #4
   143a0:	f840 3b04 	str.w	r3, [r0], #4
   143a4:	f851 3b04 	ldr.w	r3, [r1], #4
   143a8:	f840 3b04 	str.w	r3, [r0], #4
   143ac:	f851 3b04 	ldr.w	r3, [r1], #4
   143b0:	f840 3b04 	str.w	r3, [r0], #4
   143b4:	f851 3b04 	ldr.w	r3, [r1], #4
   143b8:	f840 3b04 	str.w	r3, [r0], #4
   143bc:	f851 3b04 	ldr.w	r3, [r1], #4
   143c0:	f840 3b04 	str.w	r3, [r0], #4
   143c4:	3a40      	subs	r2, #64	; 0x40
   143c6:	d2bd      	bcs.n	14344 <memcpy+0x10>
   143c8:	3230      	adds	r2, #48	; 0x30
   143ca:	d311      	bcc.n	143f0 <memcpy+0xbc>
   143cc:	f851 3b04 	ldr.w	r3, [r1], #4
   143d0:	f840 3b04 	str.w	r3, [r0], #4
   143d4:	f851 3b04 	ldr.w	r3, [r1], #4
   143d8:	f840 3b04 	str.w	r3, [r0], #4
   143dc:	f851 3b04 	ldr.w	r3, [r1], #4
   143e0:	f840 3b04 	str.w	r3, [r0], #4
   143e4:	f851 3b04 	ldr.w	r3, [r1], #4
   143e8:	f840 3b04 	str.w	r3, [r0], #4
   143ec:	3a10      	subs	r2, #16
   143ee:	d2ed      	bcs.n	143cc <memcpy+0x98>
   143f0:	320c      	adds	r2, #12
   143f2:	d305      	bcc.n	14400 <memcpy+0xcc>
   143f4:	f851 3b04 	ldr.w	r3, [r1], #4
   143f8:	f840 3b04 	str.w	r3, [r0], #4
   143fc:	3a04      	subs	r2, #4
   143fe:	d2f9      	bcs.n	143f4 <memcpy+0xc0>
   14400:	3204      	adds	r2, #4
   14402:	d008      	beq.n	14416 <memcpy+0xe2>
   14404:	07d2      	lsls	r2, r2, #31
   14406:	bf1c      	itt	ne
   14408:	f811 3b01 	ldrbne.w	r3, [r1], #1
   1440c:	f800 3b01 	strbne.w	r3, [r0], #1
   14410:	d301      	bcc.n	14416 <memcpy+0xe2>
   14412:	880b      	ldrh	r3, [r1, #0]
   14414:	8003      	strh	r3, [r0, #0]
   14416:	4660      	mov	r0, ip
   14418:	4770      	bx	lr
   1441a:	bf00      	nop
   1441c:	2a08      	cmp	r2, #8
   1441e:	d313      	bcc.n	14448 <memcpy+0x114>
   14420:	078b      	lsls	r3, r1, #30
   14422:	d08d      	beq.n	14340 <memcpy+0xc>
   14424:	f010 0303 	ands.w	r3, r0, #3
   14428:	d08a      	beq.n	14340 <memcpy+0xc>
   1442a:	f1c3 0304 	rsb	r3, r3, #4
   1442e:	1ad2      	subs	r2, r2, r3
   14430:	07db      	lsls	r3, r3, #31
   14432:	bf1c      	itt	ne
   14434:	f811 3b01 	ldrbne.w	r3, [r1], #1
   14438:	f800 3b01 	strbne.w	r3, [r0], #1
   1443c:	d380      	bcc.n	14340 <memcpy+0xc>
   1443e:	f831 3b02 	ldrh.w	r3, [r1], #2
   14442:	f820 3b02 	strh.w	r3, [r0], #2
   14446:	e77b      	b.n	14340 <memcpy+0xc>
   14448:	3a04      	subs	r2, #4
   1444a:	d3d9      	bcc.n	14400 <memcpy+0xcc>
   1444c:	3a01      	subs	r2, #1
   1444e:	f811 3b01 	ldrb.w	r3, [r1], #1
   14452:	f800 3b01 	strb.w	r3, [r0], #1
   14456:	d2f9      	bcs.n	1444c <memcpy+0x118>
   14458:	780b      	ldrb	r3, [r1, #0]
   1445a:	7003      	strb	r3, [r0, #0]
   1445c:	784b      	ldrb	r3, [r1, #1]
   1445e:	7043      	strb	r3, [r0, #1]
   14460:	788b      	ldrb	r3, [r1, #2]
   14462:	7083      	strb	r3, [r0, #2]
   14464:	4660      	mov	r0, ip
   14466:	4770      	bx	lr

00014468 <memset>:
   14468:	b4f0      	push	{r4, r5, r6, r7}
   1446a:	0786      	lsls	r6, r0, #30
   1446c:	d046      	beq.n	144fc <memset+0x94>
   1446e:	1e54      	subs	r4, r2, #1
   14470:	2a00      	cmp	r2, #0
   14472:	d03c      	beq.n	144ee <memset+0x86>
   14474:	b2ca      	uxtb	r2, r1
   14476:	4603      	mov	r3, r0
   14478:	e002      	b.n	14480 <memset+0x18>
   1447a:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
   1447e:	d336      	bcc.n	144ee <memset+0x86>
   14480:	f803 2b01 	strb.w	r2, [r3], #1
   14484:	079d      	lsls	r5, r3, #30
   14486:	d1f8      	bne.n	1447a <memset+0x12>
   14488:	2c03      	cmp	r4, #3
   1448a:	d929      	bls.n	144e0 <memset+0x78>
   1448c:	b2cd      	uxtb	r5, r1
   1448e:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   14492:	2c0f      	cmp	r4, #15
   14494:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   14498:	d933      	bls.n	14502 <memset+0x9a>
   1449a:	f1a4 0610 	sub.w	r6, r4, #16
   1449e:	0936      	lsrs	r6, r6, #4
   144a0:	f103 0720 	add.w	r7, r3, #32
   144a4:	eb07 1706 	add.w	r7, r7, r6, lsl #4
   144a8:	f103 0210 	add.w	r2, r3, #16
   144ac:	e942 5504 	strd	r5, r5, [r2, #-16]
   144b0:	e942 5502 	strd	r5, r5, [r2, #-8]
   144b4:	3210      	adds	r2, #16
   144b6:	42ba      	cmp	r2, r7
   144b8:	d1f8      	bne.n	144ac <memset+0x44>
   144ba:	1c72      	adds	r2, r6, #1
   144bc:	f014 0f0c 	tst.w	r4, #12
   144c0:	eb03 1202 	add.w	r2, r3, r2, lsl #4
   144c4:	f004 060f 	and.w	r6, r4, #15
   144c8:	d013      	beq.n	144f2 <memset+0x8a>
   144ca:	1f33      	subs	r3, r6, #4
   144cc:	f023 0303 	bic.w	r3, r3, #3
   144d0:	3304      	adds	r3, #4
   144d2:	4413      	add	r3, r2
   144d4:	f842 5b04 	str.w	r5, [r2], #4
   144d8:	4293      	cmp	r3, r2
   144da:	d1fb      	bne.n	144d4 <memset+0x6c>
   144dc:	f006 0403 	and.w	r4, r6, #3
   144e0:	b12c      	cbz	r4, 144ee <memset+0x86>
   144e2:	b2c9      	uxtb	r1, r1
   144e4:	441c      	add	r4, r3
   144e6:	f803 1b01 	strb.w	r1, [r3], #1
   144ea:	429c      	cmp	r4, r3
   144ec:	d1fb      	bne.n	144e6 <memset+0x7e>
   144ee:	bcf0      	pop	{r4, r5, r6, r7}
   144f0:	4770      	bx	lr
   144f2:	4634      	mov	r4, r6
   144f4:	4613      	mov	r3, r2
   144f6:	2c00      	cmp	r4, #0
   144f8:	d1f3      	bne.n	144e2 <memset+0x7a>
   144fa:	e7f8      	b.n	144ee <memset+0x86>
   144fc:	4614      	mov	r4, r2
   144fe:	4603      	mov	r3, r0
   14500:	e7c2      	b.n	14488 <memset+0x20>
   14502:	461a      	mov	r2, r3
   14504:	4626      	mov	r6, r4
   14506:	e7e0      	b.n	144ca <memset+0x62>

00014508 <_free_r>:
   14508:	2900      	cmp	r1, #0
   1450a:	d03c      	beq.n	14586 <_free_r+0x7e>
   1450c:	b538      	push	{r3, r4, r5, lr}
   1450e:	f851 3c04 	ldr.w	r3, [r1, #-4]
   14512:	1f0c      	subs	r4, r1, #4
   14514:	2b00      	cmp	r3, #0
   14516:	bfb8      	it	lt
   14518:	18e4      	addlt	r4, r4, r3
   1451a:	4605      	mov	r5, r0
   1451c:	f001 f926 	bl	1576c <__malloc_lock>
   14520:	4b23      	ldr	r3, [pc, #140]	; (145b0 <_free_r+0xa8>)
   14522:	681a      	ldr	r2, [r3, #0]
   14524:	b12a      	cbz	r2, 14532 <_free_r+0x2a>
   14526:	42a2      	cmp	r2, r4
   14528:	d90d      	bls.n	14546 <_free_r+0x3e>
   1452a:	6821      	ldr	r1, [r4, #0]
   1452c:	1860      	adds	r0, r4, r1
   1452e:	4282      	cmp	r2, r0
   14530:	d023      	beq.n	1457a <_free_r+0x72>
   14532:	6062      	str	r2, [r4, #4]
   14534:	4628      	mov	r0, r5
   14536:	601c      	str	r4, [r3, #0]
   14538:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   1453c:	f001 b918 	b.w	15770 <__malloc_unlock>
   14540:	42a3      	cmp	r3, r4
   14542:	d803      	bhi.n	1454c <_free_r+0x44>
   14544:	461a      	mov	r2, r3
   14546:	6853      	ldr	r3, [r2, #4]
   14548:	2b00      	cmp	r3, #0
   1454a:	d1f9      	bne.n	14540 <_free_r+0x38>
   1454c:	6811      	ldr	r1, [r2, #0]
   1454e:	1850      	adds	r0, r2, r1
   14550:	42a0      	cmp	r0, r4
   14552:	d019      	beq.n	14588 <_free_r+0x80>
   14554:	d824      	bhi.n	145a0 <_free_r+0x98>
   14556:	6821      	ldr	r1, [r4, #0]
   14558:	1860      	adds	r0, r4, r1
   1455a:	4283      	cmp	r3, r0
   1455c:	d006      	beq.n	1456c <_free_r+0x64>
   1455e:	6063      	str	r3, [r4, #4]
   14560:	6054      	str	r4, [r2, #4]
   14562:	4628      	mov	r0, r5
   14564:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14568:	f001 b902 	b.w	15770 <__malloc_unlock>
   1456c:	e9d3 0300 	ldrd	r0, r3, [r3]
   14570:	4401      	add	r1, r0
   14572:	6063      	str	r3, [r4, #4]
   14574:	6021      	str	r1, [r4, #0]
   14576:	6054      	str	r4, [r2, #4]
   14578:	e7f3      	b.n	14562 <_free_r+0x5a>
   1457a:	e9d2 0200 	ldrd	r0, r2, [r2]
   1457e:	4401      	add	r1, r0
   14580:	6062      	str	r2, [r4, #4]
   14582:	6021      	str	r1, [r4, #0]
   14584:	e7d6      	b.n	14534 <_free_r+0x2c>
   14586:	4770      	bx	lr
   14588:	6820      	ldr	r0, [r4, #0]
   1458a:	4401      	add	r1, r0
   1458c:	1850      	adds	r0, r2, r1
   1458e:	4283      	cmp	r3, r0
   14590:	6011      	str	r1, [r2, #0]
   14592:	d1e6      	bne.n	14562 <_free_r+0x5a>
   14594:	e9d3 0300 	ldrd	r0, r3, [r3]
   14598:	4401      	add	r1, r0
   1459a:	6053      	str	r3, [r2, #4]
   1459c:	6011      	str	r1, [r2, #0]
   1459e:	e7e0      	b.n	14562 <_free_r+0x5a>
   145a0:	230c      	movs	r3, #12
   145a2:	602b      	str	r3, [r5, #0]
   145a4:	4628      	mov	r0, r5
   145a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   145aa:	f001 b8e1 	b.w	15770 <__malloc_unlock>
   145ae:	bf00      	nop
   145b0:	20009138 	.word	0x20009138

000145b4 <_malloc_r>:
   145b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   145b6:	1ccd      	adds	r5, r1, #3
   145b8:	f025 0503 	bic.w	r5, r5, #3
   145bc:	3508      	adds	r5, #8
   145be:	2d0c      	cmp	r5, #12
   145c0:	bf38      	it	cc
   145c2:	250c      	movcc	r5, #12
   145c4:	2d00      	cmp	r5, #0
   145c6:	4606      	mov	r6, r0
   145c8:	db33      	blt.n	14632 <_malloc_r+0x7e>
   145ca:	42a9      	cmp	r1, r5
   145cc:	d831      	bhi.n	14632 <_malloc_r+0x7e>
   145ce:	4f2a      	ldr	r7, [pc, #168]	; (14678 <_malloc_r+0xc4>)
   145d0:	f001 f8cc 	bl	1576c <__malloc_lock>
   145d4:	683a      	ldr	r2, [r7, #0]
   145d6:	b152      	cbz	r2, 145ee <_malloc_r+0x3a>
   145d8:	6813      	ldr	r3, [r2, #0]
   145da:	1b5b      	subs	r3, r3, r5
   145dc:	d404      	bmi.n	145e8 <_malloc_r+0x34>
   145de:	e03f      	b.n	14660 <_malloc_r+0xac>
   145e0:	6823      	ldr	r3, [r4, #0]
   145e2:	1b5b      	subs	r3, r3, r5
   145e4:	d529      	bpl.n	1463a <_malloc_r+0x86>
   145e6:	4622      	mov	r2, r4
   145e8:	6854      	ldr	r4, [r2, #4]
   145ea:	2c00      	cmp	r4, #0
   145ec:	d1f8      	bne.n	145e0 <_malloc_r+0x2c>
   145ee:	6879      	ldr	r1, [r7, #4]
   145f0:	2900      	cmp	r1, #0
   145f2:	d03b      	beq.n	1466c <_malloc_r+0xb8>
   145f4:	4629      	mov	r1, r5
   145f6:	4630      	mov	r0, r6
   145f8:	f000 f8e8 	bl	147cc <_sbrk_r>
   145fc:	1c43      	adds	r3, r0, #1
   145fe:	d028      	beq.n	14652 <_malloc_r+0x9e>
   14600:	1cc4      	adds	r4, r0, #3
   14602:	f024 0403 	bic.w	r4, r4, #3
   14606:	42a0      	cmp	r0, r4
   14608:	d005      	beq.n	14616 <_malloc_r+0x62>
   1460a:	1a21      	subs	r1, r4, r0
   1460c:	4630      	mov	r0, r6
   1460e:	f000 f8dd 	bl	147cc <_sbrk_r>
   14612:	3001      	adds	r0, #1
   14614:	d01d      	beq.n	14652 <_malloc_r+0x9e>
   14616:	6025      	str	r5, [r4, #0]
   14618:	4630      	mov	r0, r6
   1461a:	f001 f8a9 	bl	15770 <__malloc_unlock>
   1461e:	f104 000b 	add.w	r0, r4, #11
   14622:	f020 0007 	bic.w	r0, r0, #7
   14626:	1d23      	adds	r3, r4, #4
   14628:	1ac2      	subs	r2, r0, r3
   1462a:	d001      	beq.n	14630 <_malloc_r+0x7c>
   1462c:	1a1b      	subs	r3, r3, r0
   1462e:	50a3      	str	r3, [r4, r2]
   14630:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14632:	220c      	movs	r2, #12
   14634:	6032      	str	r2, [r6, #0]
   14636:	2000      	movs	r0, #0
   14638:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1463a:	2b0b      	cmp	r3, #11
   1463c:	d805      	bhi.n	1464a <_malloc_r+0x96>
   1463e:	42a2      	cmp	r2, r4
   14640:	6863      	ldr	r3, [r4, #4]
   14642:	d011      	beq.n	14668 <_malloc_r+0xb4>
   14644:	6053      	str	r3, [r2, #4]
   14646:	e7e7      	b.n	14618 <_malloc_r+0x64>
   14648:	4614      	mov	r4, r2
   1464a:	6023      	str	r3, [r4, #0]
   1464c:	441c      	add	r4, r3
   1464e:	6025      	str	r5, [r4, #0]
   14650:	e7e2      	b.n	14618 <_malloc_r+0x64>
   14652:	230c      	movs	r3, #12
   14654:	4630      	mov	r0, r6
   14656:	6033      	str	r3, [r6, #0]
   14658:	f001 f88a 	bl	15770 <__malloc_unlock>
   1465c:	2000      	movs	r0, #0
   1465e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14660:	2b0b      	cmp	r3, #11
   14662:	d8f1      	bhi.n	14648 <_malloc_r+0x94>
   14664:	6853      	ldr	r3, [r2, #4]
   14666:	4614      	mov	r4, r2
   14668:	603b      	str	r3, [r7, #0]
   1466a:	e7d5      	b.n	14618 <_malloc_r+0x64>
   1466c:	4630      	mov	r0, r6
   1466e:	f000 f8ad 	bl	147cc <_sbrk_r>
   14672:	6078      	str	r0, [r7, #4]
   14674:	e7be      	b.n	145f4 <_malloc_r+0x40>
   14676:	bf00      	nop
   14678:	20009138 	.word	0x20009138

0001467c <_iprintf_r>:
   1467c:	b40e      	push	{r1, r2, r3}
   1467e:	b510      	push	{r4, lr}
   14680:	4604      	mov	r4, r0
   14682:	b083      	sub	sp, #12
   14684:	b108      	cbz	r0, 1468a <_iprintf_r+0xe>
   14686:	6983      	ldr	r3, [r0, #24]
   14688:	b163      	cbz	r3, 146a4 <_iprintf_r+0x28>
   1468a:	a806      	add	r0, sp, #24
   1468c:	4603      	mov	r3, r0
   1468e:	9001      	str	r0, [sp, #4]
   14690:	9a05      	ldr	r2, [sp, #20]
   14692:	68a1      	ldr	r1, [r4, #8]
   14694:	4620      	mov	r0, r4
   14696:	f001 fac5 	bl	15c24 <_vfiprintf_r>
   1469a:	b003      	add	sp, #12
   1469c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   146a0:	b003      	add	sp, #12
   146a2:	4770      	bx	lr
   146a4:	f000 ff7a 	bl	1559c <__sinit>
   146a8:	e7ef      	b.n	1468a <_iprintf_r+0xe>
   146aa:	bf00      	nop

000146ac <iprintf>:
   146ac:	b40f      	push	{r0, r1, r2, r3}
   146ae:	b510      	push	{r4, lr}
   146b0:	4b0b      	ldr	r3, [pc, #44]	; (146e0 <iprintf+0x34>)
   146b2:	681c      	ldr	r4, [r3, #0]
   146b4:	b082      	sub	sp, #8
   146b6:	b10c      	cbz	r4, 146bc <iprintf+0x10>
   146b8:	69a3      	ldr	r3, [r4, #24]
   146ba:	b163      	cbz	r3, 146d6 <iprintf+0x2a>
   146bc:	a805      	add	r0, sp, #20
   146be:	4603      	mov	r3, r0
   146c0:	9001      	str	r0, [sp, #4]
   146c2:	9a04      	ldr	r2, [sp, #16]
   146c4:	68a1      	ldr	r1, [r4, #8]
   146c6:	4620      	mov	r0, r4
   146c8:	f001 faac 	bl	15c24 <_vfiprintf_r>
   146cc:	b002      	add	sp, #8
   146ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   146d2:	b004      	add	sp, #16
   146d4:	4770      	bx	lr
   146d6:	4620      	mov	r0, r4
   146d8:	f000 ff60 	bl	1559c <__sinit>
   146dc:	e7ee      	b.n	146bc <iprintf+0x10>
   146de:	bf00      	nop
   146e0:	2000054c 	.word	0x2000054c

000146e4 <_puts_r>:
   146e4:	6983      	ldr	r3, [r0, #24]
   146e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   146ea:	4680      	mov	r8, r0
   146ec:	460e      	mov	r6, r1
   146ee:	b333      	cbz	r3, 1473e <_puts_r+0x5a>
   146f0:	6884      	ldr	r4, [r0, #8]
   146f2:	4b2f      	ldr	r3, [pc, #188]	; (147b0 <_puts_r+0xcc>)
   146f4:	429c      	cmp	r4, r3
   146f6:	d030      	beq.n	1475a <_puts_r+0x76>
   146f8:	4b2e      	ldr	r3, [pc, #184]	; (147b4 <_puts_r+0xd0>)
   146fa:	429c      	cmp	r4, r3
   146fc:	d039      	beq.n	14772 <_puts_r+0x8e>
   146fe:	4b2e      	ldr	r3, [pc, #184]	; (147b8 <_puts_r+0xd4>)
   14700:	429c      	cmp	r4, r3
   14702:	bf08      	it	eq
   14704:	f8d8 400c 	ldreq.w	r4, [r8, #12]
   14708:	89a3      	ldrh	r3, [r4, #12]
   1470a:	071b      	lsls	r3, r3, #28
   1470c:	d52a      	bpl.n	14764 <_puts_r+0x80>
   1470e:	6923      	ldr	r3, [r4, #16]
   14710:	b343      	cbz	r3, 14764 <_puts_r+0x80>
   14712:	3e01      	subs	r6, #1
   14714:	68a3      	ldr	r3, [r4, #8]
   14716:	f816 5f01 	ldrb.w	r5, [r6, #1]!
   1471a:	3b01      	subs	r3, #1
   1471c:	60a3      	str	r3, [r4, #8]
   1471e:	b39d      	cbz	r5, 14788 <_puts_r+0xa4>
   14720:	2b00      	cmp	r3, #0
   14722:	da07      	bge.n	14734 <_puts_r+0x50>
   14724:	69a7      	ldr	r7, [r4, #24]
   14726:	429f      	cmp	r7, r3
   14728:	4622      	mov	r2, r4
   1472a:	4629      	mov	r1, r5
   1472c:	4640      	mov	r0, r8
   1472e:	dc23      	bgt.n	14778 <_puts_r+0x94>
   14730:	2d0a      	cmp	r5, #10
   14732:	d021      	beq.n	14778 <_puts_r+0x94>
   14734:	6823      	ldr	r3, [r4, #0]
   14736:	1c5a      	adds	r2, r3, #1
   14738:	6022      	str	r2, [r4, #0]
   1473a:	701d      	strb	r5, [r3, #0]
   1473c:	e7ea      	b.n	14714 <_puts_r+0x30>
   1473e:	f000 ff2d 	bl	1559c <__sinit>
   14742:	f8d8 3018 	ldr.w	r3, [r8, #24]
   14746:	f8d8 4008 	ldr.w	r4, [r8, #8]
   1474a:	2b00      	cmp	r3, #0
   1474c:	d1d1      	bne.n	146f2 <_puts_r+0xe>
   1474e:	4640      	mov	r0, r8
   14750:	f000 ff24 	bl	1559c <__sinit>
   14754:	4b16      	ldr	r3, [pc, #88]	; (147b0 <_puts_r+0xcc>)
   14756:	429c      	cmp	r4, r3
   14758:	d1ce      	bne.n	146f8 <_puts_r+0x14>
   1475a:	f8d8 4004 	ldr.w	r4, [r8, #4]
   1475e:	89a3      	ldrh	r3, [r4, #12]
   14760:	071b      	lsls	r3, r3, #28
   14762:	d4d4      	bmi.n	1470e <_puts_r+0x2a>
   14764:	4621      	mov	r1, r4
   14766:	4640      	mov	r0, r8
   14768:	f000 fcd8 	bl	1511c <__swsetup_r>
   1476c:	2800      	cmp	r0, #0
   1476e:	d0d0      	beq.n	14712 <_puts_r+0x2e>
   14770:	e006      	b.n	14780 <_puts_r+0x9c>
   14772:	f8d8 4008 	ldr.w	r4, [r8, #8]
   14776:	e7c7      	b.n	14708 <_puts_r+0x24>
   14778:	f000 fc70 	bl	1505c <__swbuf_r>
   1477c:	3001      	adds	r0, #1
   1477e:	d1c9      	bne.n	14714 <_puts_r+0x30>
   14780:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14784:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14788:	2b00      	cmp	r3, #0
   1478a:	da09      	bge.n	147a0 <_puts_r+0xbc>
   1478c:	4622      	mov	r2, r4
   1478e:	4640      	mov	r0, r8
   14790:	210a      	movs	r1, #10
   14792:	f000 fc63 	bl	1505c <__swbuf_r>
   14796:	3001      	adds	r0, #1
   14798:	d0f2      	beq.n	14780 <_puts_r+0x9c>
   1479a:	200a      	movs	r0, #10
   1479c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   147a0:	6823      	ldr	r3, [r4, #0]
   147a2:	220a      	movs	r2, #10
   147a4:	1c59      	adds	r1, r3, #1
   147a6:	6021      	str	r1, [r4, #0]
   147a8:	701a      	strb	r2, [r3, #0]
   147aa:	4610      	mov	r0, r2
   147ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   147b0:	00017910 	.word	0x00017910
   147b4:	000178f0 	.word	0x000178f0
   147b8:	000178d0 	.word	0x000178d0

000147bc <puts>:
   147bc:	4b02      	ldr	r3, [pc, #8]	; (147c8 <puts+0xc>)
   147be:	4601      	mov	r1, r0
   147c0:	6818      	ldr	r0, [r3, #0]
   147c2:	f7ff bf8f 	b.w	146e4 <_puts_r>
   147c6:	bf00      	nop
   147c8:	2000054c 	.word	0x2000054c

000147cc <_sbrk_r>:
   147cc:	b538      	push	{r3, r4, r5, lr}
   147ce:	4c07      	ldr	r4, [pc, #28]	; (147ec <_sbrk_r+0x20>)
   147d0:	2300      	movs	r3, #0
   147d2:	4605      	mov	r5, r0
   147d4:	4608      	mov	r0, r1
   147d6:	6023      	str	r3, [r4, #0]
   147d8:	f7f7 fb18 	bl	be0c <_sbrk>
   147dc:	1c43      	adds	r3, r0, #1
   147de:	d000      	beq.n	147e2 <_sbrk_r+0x16>
   147e0:	bd38      	pop	{r3, r4, r5, pc}
   147e2:	6823      	ldr	r3, [r4, #0]
   147e4:	2b00      	cmp	r3, #0
   147e6:	d0fb      	beq.n	147e0 <_sbrk_r+0x14>
   147e8:	602b      	str	r3, [r5, #0]
   147ea:	bd38      	pop	{r3, r4, r5, pc}
   147ec:	2001cfd4 	.word	0x2001cfd4

000147f0 <setbuf>:
   147f0:	2900      	cmp	r1, #0
   147f2:	bf0c      	ite	eq
   147f4:	2202      	moveq	r2, #2
   147f6:	2200      	movne	r2, #0
   147f8:	f44f 6380 	mov.w	r3, #1024	; 0x400
   147fc:	f000 b800 	b.w	14800 <setvbuf>

00014800 <setvbuf>:
   14800:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14804:	4c58      	ldr	r4, [pc, #352]	; (14968 <setvbuf+0x168>)
   14806:	6825      	ldr	r5, [r4, #0]
   14808:	b083      	sub	sp, #12
   1480a:	4604      	mov	r4, r0
   1480c:	460f      	mov	r7, r1
   1480e:	4690      	mov	r8, r2
   14810:	461e      	mov	r6, r3
   14812:	b115      	cbz	r5, 1481a <setvbuf+0x1a>
   14814:	69ab      	ldr	r3, [r5, #24]
   14816:	2b00      	cmp	r3, #0
   14818:	d062      	beq.n	148e0 <setvbuf+0xe0>
   1481a:	4b54      	ldr	r3, [pc, #336]	; (1496c <setvbuf+0x16c>)
   1481c:	429c      	cmp	r4, r3
   1481e:	d065      	beq.n	148ec <setvbuf+0xec>
   14820:	4b53      	ldr	r3, [pc, #332]	; (14970 <setvbuf+0x170>)
   14822:	429c      	cmp	r4, r3
   14824:	d064      	beq.n	148f0 <setvbuf+0xf0>
   14826:	4b53      	ldr	r3, [pc, #332]	; (14974 <setvbuf+0x174>)
   14828:	429c      	cmp	r4, r3
   1482a:	bf08      	it	eq
   1482c:	68ec      	ldreq	r4, [r5, #12]
   1482e:	f1b8 0f02 	cmp.w	r8, #2
   14832:	d006      	beq.n	14842 <setvbuf+0x42>
   14834:	f1b8 0f01 	cmp.w	r8, #1
   14838:	f200 8093 	bhi.w	14962 <setvbuf+0x162>
   1483c:	2e00      	cmp	r6, #0
   1483e:	f2c0 8090 	blt.w	14962 <setvbuf+0x162>
   14842:	4621      	mov	r1, r4
   14844:	4628      	mov	r0, r5
   14846:	f000 fd7f 	bl	15348 <_fflush_r>
   1484a:	6b61      	ldr	r1, [r4, #52]	; 0x34
   1484c:	b141      	cbz	r1, 14860 <setvbuf+0x60>
   1484e:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14852:	4299      	cmp	r1, r3
   14854:	d002      	beq.n	1485c <setvbuf+0x5c>
   14856:	4628      	mov	r0, r5
   14858:	f7ff fe56 	bl	14508 <_free_r>
   1485c:	2300      	movs	r3, #0
   1485e:	6363      	str	r3, [r4, #52]	; 0x34
   14860:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14864:	2200      	movs	r2, #0
   14866:	61a2      	str	r2, [r4, #24]
   14868:	6062      	str	r2, [r4, #4]
   1486a:	061a      	lsls	r2, r3, #24
   1486c:	d44f      	bmi.n	1490e <setvbuf+0x10e>
   1486e:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
   14872:	f023 0303 	bic.w	r3, r3, #3
   14876:	f1b8 0f02 	cmp.w	r8, #2
   1487a:	81a3      	strh	r3, [r4, #12]
   1487c:	d04e      	beq.n	1491c <setvbuf+0x11c>
   1487e:	ab01      	add	r3, sp, #4
   14880:	466a      	mov	r2, sp
   14882:	4621      	mov	r1, r4
   14884:	4628      	mov	r0, r5
   14886:	f000 fef9 	bl	1567c <__swhatbuf_r>
   1488a:	89a3      	ldrh	r3, [r4, #12]
   1488c:	4318      	orrs	r0, r3
   1488e:	81a0      	strh	r0, [r4, #12]
   14890:	2e00      	cmp	r6, #0
   14892:	d12f      	bne.n	148f4 <setvbuf+0xf4>
   14894:	9e00      	ldr	r6, [sp, #0]
   14896:	4630      	mov	r0, r6
   14898:	f7ff fd3c 	bl	14314 <malloc>
   1489c:	4607      	mov	r7, r0
   1489e:	2800      	cmp	r0, #0
   148a0:	d04f      	beq.n	14942 <setvbuf+0x142>
   148a2:	89a3      	ldrh	r3, [r4, #12]
   148a4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   148a8:	81a3      	strh	r3, [r4, #12]
   148aa:	69ab      	ldr	r3, [r5, #24]
   148ac:	b33b      	cbz	r3, 148fe <setvbuf+0xfe>
   148ae:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   148b2:	6027      	str	r7, [r4, #0]
   148b4:	f1b8 0f01 	cmp.w	r8, #1
   148b8:	bf04      	itt	eq
   148ba:	f043 0301 	orreq.w	r3, r3, #1
   148be:	81a3      	strheq	r3, [r4, #12]
   148c0:	b29b      	uxth	r3, r3
   148c2:	f013 0008 	ands.w	r0, r3, #8
   148c6:	e9c4 7604 	strd	r7, r6, [r4, #16]
   148ca:	d01c      	beq.n	14906 <setvbuf+0x106>
   148cc:	f013 0001 	ands.w	r0, r3, #1
   148d0:	d033      	beq.n	1493a <setvbuf+0x13a>
   148d2:	2000      	movs	r0, #0
   148d4:	4276      	negs	r6, r6
   148d6:	61a6      	str	r6, [r4, #24]
   148d8:	60a0      	str	r0, [r4, #8]
   148da:	b003      	add	sp, #12
   148dc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   148e0:	4628      	mov	r0, r5
   148e2:	f000 fe5b 	bl	1559c <__sinit>
   148e6:	4b21      	ldr	r3, [pc, #132]	; (1496c <setvbuf+0x16c>)
   148e8:	429c      	cmp	r4, r3
   148ea:	d199      	bne.n	14820 <setvbuf+0x20>
   148ec:	686c      	ldr	r4, [r5, #4]
   148ee:	e79e      	b.n	1482e <setvbuf+0x2e>
   148f0:	68ac      	ldr	r4, [r5, #8]
   148f2:	e79c      	b.n	1482e <setvbuf+0x2e>
   148f4:	2f00      	cmp	r7, #0
   148f6:	d0ce      	beq.n	14896 <setvbuf+0x96>
   148f8:	69ab      	ldr	r3, [r5, #24]
   148fa:	2b00      	cmp	r3, #0
   148fc:	d1d7      	bne.n	148ae <setvbuf+0xae>
   148fe:	4628      	mov	r0, r5
   14900:	f000 fe4c 	bl	1559c <__sinit>
   14904:	e7d3      	b.n	148ae <setvbuf+0xae>
   14906:	60a0      	str	r0, [r4, #8]
   14908:	b003      	add	sp, #12
   1490a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1490e:	6921      	ldr	r1, [r4, #16]
   14910:	4628      	mov	r0, r5
   14912:	f7ff fdf9 	bl	14508 <_free_r>
   14916:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1491a:	e7a8      	b.n	1486e <setvbuf+0x6e>
   1491c:	2000      	movs	r0, #0
   1491e:	f104 0247 	add.w	r2, r4, #71	; 0x47
   14922:	f043 0302 	orr.w	r3, r3, #2
   14926:	2500      	movs	r5, #0
   14928:	2101      	movs	r1, #1
   1492a:	81a3      	strh	r3, [r4, #12]
   1492c:	60a5      	str	r5, [r4, #8]
   1492e:	6022      	str	r2, [r4, #0]
   14930:	e9c4 2104 	strd	r2, r1, [r4, #16]
   14934:	b003      	add	sp, #12
   14936:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1493a:	60a6      	str	r6, [r4, #8]
   1493c:	b003      	add	sp, #12
   1493e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14942:	f8dd 9000 	ldr.w	r9, [sp]
   14946:	45b1      	cmp	r9, r6
   14948:	d006      	beq.n	14958 <setvbuf+0x158>
   1494a:	4648      	mov	r0, r9
   1494c:	f7ff fce2 	bl	14314 <malloc>
   14950:	4607      	mov	r7, r0
   14952:	b108      	cbz	r0, 14958 <setvbuf+0x158>
   14954:	464e      	mov	r6, r9
   14956:	e7a4      	b.n	148a2 <setvbuf+0xa2>
   14958:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1495c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14960:	e7dd      	b.n	1491e <setvbuf+0x11e>
   14962:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14966:	e7cf      	b.n	14908 <setvbuf+0x108>
   14968:	2000054c 	.word	0x2000054c
   1496c:	00017910 	.word	0x00017910
   14970:	000178f0 	.word	0x000178f0
   14974:	000178d0 	.word	0x000178d0

00014978 <_sniprintf_r>:
   14978:	b408      	push	{r3}
   1497a:	b530      	push	{r4, r5, lr}
   1497c:	2a00      	cmp	r2, #0
   1497e:	b09c      	sub	sp, #112	; 0x70
   14980:	4604      	mov	r4, r0
   14982:	db35      	blt.n	149f0 <_sniprintf_r+0x78>
   14984:	f44f 7302 	mov.w	r3, #520	; 0x208
   14988:	9102      	str	r1, [sp, #8]
   1498a:	9106      	str	r1, [sp, #24]
   1498c:	f8ad 3014 	strh.w	r3, [sp, #20]
   14990:	a920      	add	r1, sp, #128	; 0x80
   14992:	d018      	beq.n	149c6 <_sniprintf_r+0x4e>
   14994:	3a01      	subs	r2, #1
   14996:	460b      	mov	r3, r1
   14998:	9204      	str	r2, [sp, #16]
   1499a:	9207      	str	r2, [sp, #28]
   1499c:	9101      	str	r1, [sp, #4]
   1499e:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   149a0:	f64f 75ff 	movw	r5, #65535	; 0xffff
   149a4:	a902      	add	r1, sp, #8
   149a6:	f8ad 5016 	strh.w	r5, [sp, #22]
   149aa:	f000 ffbf 	bl	1592c <_svfiprintf_r>
   149ae:	1c42      	adds	r2, r0, #1
   149b0:	da01      	bge.n	149b6 <_sniprintf_r+0x3e>
   149b2:	238b      	movs	r3, #139	; 0x8b
   149b4:	6023      	str	r3, [r4, #0]
   149b6:	9b02      	ldr	r3, [sp, #8]
   149b8:	2200      	movs	r2, #0
   149ba:	701a      	strb	r2, [r3, #0]
   149bc:	b01c      	add	sp, #112	; 0x70
   149be:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   149c2:	b001      	add	sp, #4
   149c4:	4770      	bx	lr
   149c6:	460b      	mov	r3, r1
   149c8:	9204      	str	r2, [sp, #16]
   149ca:	9207      	str	r2, [sp, #28]
   149cc:	9101      	str	r1, [sp, #4]
   149ce:	f64f 75ff 	movw	r5, #65535	; 0xffff
   149d2:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   149d4:	f8ad 5016 	strh.w	r5, [sp, #22]
   149d8:	a902      	add	r1, sp, #8
   149da:	f000 ffa7 	bl	1592c <_svfiprintf_r>
   149de:	1c43      	adds	r3, r0, #1
   149e0:	da01      	bge.n	149e6 <_sniprintf_r+0x6e>
   149e2:	238b      	movs	r3, #139	; 0x8b
   149e4:	6023      	str	r3, [r4, #0]
   149e6:	b01c      	add	sp, #112	; 0x70
   149e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   149ec:	b001      	add	sp, #4
   149ee:	4770      	bx	lr
   149f0:	228b      	movs	r2, #139	; 0x8b
   149f2:	6002      	str	r2, [r0, #0]
   149f4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   149f8:	e7f5      	b.n	149e6 <_sniprintf_r+0x6e>
   149fa:	bf00      	nop

000149fc <sniprintf>:
   149fc:	b40c      	push	{r2, r3}
   149fe:	b530      	push	{r4, r5, lr}
   14a00:	4b20      	ldr	r3, [pc, #128]	; (14a84 <sniprintf+0x88>)
   14a02:	2900      	cmp	r1, #0
   14a04:	b09d      	sub	sp, #116	; 0x74
   14a06:	681c      	ldr	r4, [r3, #0]
   14a08:	db37      	blt.n	14a7a <sniprintf+0x7e>
   14a0a:	f44f 7302 	mov.w	r3, #520	; 0x208
   14a0e:	9002      	str	r0, [sp, #8]
   14a10:	9006      	str	r0, [sp, #24]
   14a12:	f8ad 3014 	strh.w	r3, [sp, #20]
   14a16:	a821      	add	r0, sp, #132	; 0x84
   14a18:	d019      	beq.n	14a4e <sniprintf+0x52>
   14a1a:	3901      	subs	r1, #1
   14a1c:	4603      	mov	r3, r0
   14a1e:	9a20      	ldr	r2, [sp, #128]	; 0x80
   14a20:	9104      	str	r1, [sp, #16]
   14a22:	9107      	str	r1, [sp, #28]
   14a24:	9001      	str	r0, [sp, #4]
   14a26:	f64f 75ff 	movw	r5, #65535	; 0xffff
   14a2a:	a902      	add	r1, sp, #8
   14a2c:	4620      	mov	r0, r4
   14a2e:	f8ad 5016 	strh.w	r5, [sp, #22]
   14a32:	f000 ff7b 	bl	1592c <_svfiprintf_r>
   14a36:	1c42      	adds	r2, r0, #1
   14a38:	da01      	bge.n	14a3e <sniprintf+0x42>
   14a3a:	238b      	movs	r3, #139	; 0x8b
   14a3c:	6023      	str	r3, [r4, #0]
   14a3e:	9b02      	ldr	r3, [sp, #8]
   14a40:	2200      	movs	r2, #0
   14a42:	701a      	strb	r2, [r3, #0]
   14a44:	b01d      	add	sp, #116	; 0x74
   14a46:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14a4a:	b002      	add	sp, #8
   14a4c:	4770      	bx	lr
   14a4e:	4603      	mov	r3, r0
   14a50:	9104      	str	r1, [sp, #16]
   14a52:	9107      	str	r1, [sp, #28]
   14a54:	9001      	str	r0, [sp, #4]
   14a56:	f64f 75ff 	movw	r5, #65535	; 0xffff
   14a5a:	9a20      	ldr	r2, [sp, #128]	; 0x80
   14a5c:	f8ad 5016 	strh.w	r5, [sp, #22]
   14a60:	a902      	add	r1, sp, #8
   14a62:	4620      	mov	r0, r4
   14a64:	f000 ff62 	bl	1592c <_svfiprintf_r>
   14a68:	1c43      	adds	r3, r0, #1
   14a6a:	da01      	bge.n	14a70 <sniprintf+0x74>
   14a6c:	238b      	movs	r3, #139	; 0x8b
   14a6e:	6023      	str	r3, [r4, #0]
   14a70:	b01d      	add	sp, #116	; 0x74
   14a72:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14a76:	b002      	add	sp, #8
   14a78:	4770      	bx	lr
   14a7a:	238b      	movs	r3, #139	; 0x8b
   14a7c:	6023      	str	r3, [r4, #0]
   14a7e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14a82:	e7f5      	b.n	14a70 <sniprintf+0x74>
   14a84:	2000054c 	.word	0x2000054c

00014a88 <_siprintf_r>:
   14a88:	b40c      	push	{r2, r3}
   14a8a:	b570      	push	{r4, r5, r6, lr}
   14a8c:	b09c      	sub	sp, #112	; 0x70
   14a8e:	ac20      	add	r4, sp, #128	; 0x80
   14a90:	4e0b      	ldr	r6, [pc, #44]	; (14ac0 <_siprintf_r+0x38>)
   14a92:	f854 2b04 	ldr.w	r2, [r4], #4
   14a96:	9102      	str	r1, [sp, #8]
   14a98:	4623      	mov	r3, r4
   14a9a:	9106      	str	r1, [sp, #24]
   14a9c:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   14aa0:	a902      	add	r1, sp, #8
   14aa2:	9401      	str	r4, [sp, #4]
   14aa4:	9507      	str	r5, [sp, #28]
   14aa6:	e9cd 5604 	strd	r5, r6, [sp, #16]
   14aaa:	f000 ff3f 	bl	1592c <_svfiprintf_r>
   14aae:	9b02      	ldr	r3, [sp, #8]
   14ab0:	2200      	movs	r2, #0
   14ab2:	701a      	strb	r2, [r3, #0]
   14ab4:	b01c      	add	sp, #112	; 0x70
   14ab6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   14aba:	b002      	add	sp, #8
   14abc:	4770      	bx	lr
   14abe:	bf00      	nop
   14ac0:	ffff0208 	.word	0xffff0208

00014ac4 <siprintf>:
   14ac4:	b40e      	push	{r1, r2, r3}
   14ac6:	b530      	push	{r4, r5, lr}
   14ac8:	b09c      	sub	sp, #112	; 0x70
   14aca:	ab1f      	add	r3, sp, #124	; 0x7c
   14acc:	4c0c      	ldr	r4, [pc, #48]	; (14b00 <siprintf+0x3c>)
   14ace:	4d0d      	ldr	r5, [pc, #52]	; (14b04 <siprintf+0x40>)
   14ad0:	f853 2b04 	ldr.w	r2, [r3], #4
   14ad4:	9301      	str	r3, [sp, #4]
   14ad6:	4601      	mov	r1, r0
   14ad8:	9102      	str	r1, [sp, #8]
   14ada:	9106      	str	r1, [sp, #24]
   14adc:	6820      	ldr	r0, [r4, #0]
   14ade:	a902      	add	r1, sp, #8
   14ae0:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
   14ae4:	9407      	str	r4, [sp, #28]
   14ae6:	e9cd 4504 	strd	r4, r5, [sp, #16]
   14aea:	f000 ff1f 	bl	1592c <_svfiprintf_r>
   14aee:	9b02      	ldr	r3, [sp, #8]
   14af0:	2200      	movs	r2, #0
   14af2:	701a      	strb	r2, [r3, #0]
   14af4:	b01c      	add	sp, #112	; 0x70
   14af6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14afa:	b003      	add	sp, #12
   14afc:	4770      	bx	lr
   14afe:	bf00      	nop
   14b00:	2000054c 	.word	0x2000054c
   14b04:	ffff0208 	.word	0xffff0208

00014b08 <strchr>:
   14b08:	b2c9      	uxtb	r1, r1
   14b0a:	f000 0303 	and.w	r3, r0, #3
   14b0e:	2900      	cmp	r1, #0
   14b10:	d035      	beq.n	14b7e <strchr+0x76>
   14b12:	b17b      	cbz	r3, 14b34 <strchr+0x2c>
   14b14:	7803      	ldrb	r3, [r0, #0]
   14b16:	2b00      	cmp	r3, #0
   14b18:	d057      	beq.n	14bca <strchr+0xc2>
   14b1a:	4299      	cmp	r1, r3
   14b1c:	d052      	beq.n	14bc4 <strchr+0xbc>
   14b1e:	1c43      	adds	r3, r0, #1
   14b20:	e005      	b.n	14b2e <strchr+0x26>
   14b22:	f813 2b01 	ldrb.w	r2, [r3], #1
   14b26:	2a00      	cmp	r2, #0
   14b28:	d04d      	beq.n	14bc6 <strchr+0xbe>
   14b2a:	428a      	cmp	r2, r1
   14b2c:	d04a      	beq.n	14bc4 <strchr+0xbc>
   14b2e:	079a      	lsls	r2, r3, #30
   14b30:	4618      	mov	r0, r3
   14b32:	d1f6      	bne.n	14b22 <strchr+0x1a>
   14b34:	b470      	push	{r4, r5, r6}
   14b36:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
   14b3a:	6804      	ldr	r4, [r0, #0]
   14b3c:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
   14b40:	e001      	b.n	14b46 <strchr+0x3e>
   14b42:	f850 4f04 	ldr.w	r4, [r0, #4]!
   14b46:	ea86 0504 	eor.w	r5, r6, r4
   14b4a:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
   14b4e:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
   14b52:	ea22 0205 	bic.w	r2, r2, r5
   14b56:	ea23 0304 	bic.w	r3, r3, r4
   14b5a:	4313      	orrs	r3, r2
   14b5c:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   14b60:	d0ef      	beq.n	14b42 <strchr+0x3a>
   14b62:	7803      	ldrb	r3, [r0, #0]
   14b64:	b143      	cbz	r3, 14b78 <strchr+0x70>
   14b66:	4299      	cmp	r1, r3
   14b68:	d102      	bne.n	14b70 <strchr+0x68>
   14b6a:	e006      	b.n	14b7a <strchr+0x72>
   14b6c:	428b      	cmp	r3, r1
   14b6e:	d004      	beq.n	14b7a <strchr+0x72>
   14b70:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   14b74:	2b00      	cmp	r3, #0
   14b76:	d1f9      	bne.n	14b6c <strchr+0x64>
   14b78:	4618      	mov	r0, r3
   14b7a:	bc70      	pop	{r4, r5, r6}
   14b7c:	4770      	bx	lr
   14b7e:	b14b      	cbz	r3, 14b94 <strchr+0x8c>
   14b80:	7803      	ldrb	r3, [r0, #0]
   14b82:	b1fb      	cbz	r3, 14bc4 <strchr+0xbc>
   14b84:	1c43      	adds	r3, r0, #1
   14b86:	e002      	b.n	14b8e <strchr+0x86>
   14b88:	7802      	ldrb	r2, [r0, #0]
   14b8a:	3301      	adds	r3, #1
   14b8c:	b1d2      	cbz	r2, 14bc4 <strchr+0xbc>
   14b8e:	0799      	lsls	r1, r3, #30
   14b90:	4618      	mov	r0, r3
   14b92:	d1f9      	bne.n	14b88 <strchr+0x80>
   14b94:	6802      	ldr	r2, [r0, #0]
   14b96:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
   14b9a:	ea23 0302 	bic.w	r3, r3, r2
   14b9e:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   14ba2:	d108      	bne.n	14bb6 <strchr+0xae>
   14ba4:	f850 2f04 	ldr.w	r2, [r0, #4]!
   14ba8:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
   14bac:	ea23 0302 	bic.w	r3, r3, r2
   14bb0:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   14bb4:	d0f6      	beq.n	14ba4 <strchr+0x9c>
   14bb6:	7803      	ldrb	r3, [r0, #0]
   14bb8:	b123      	cbz	r3, 14bc4 <strchr+0xbc>
   14bba:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   14bbe:	2b00      	cmp	r3, #0
   14bc0:	d1fb      	bne.n	14bba <strchr+0xb2>
   14bc2:	4770      	bx	lr
   14bc4:	4770      	bx	lr
   14bc6:	4610      	mov	r0, r2
   14bc8:	4770      	bx	lr
   14bca:	4618      	mov	r0, r3
   14bcc:	4770      	bx	lr
   14bce:	bf00      	nop
	...
   14be0:	eba2 0003 	sub.w	r0, r2, r3
   14be4:	4770      	bx	lr
   14be6:	bf00      	nop

00014be8 <strcmp>:
   14be8:	7802      	ldrb	r2, [r0, #0]
   14bea:	780b      	ldrb	r3, [r1, #0]
   14bec:	2a01      	cmp	r2, #1
   14bee:	bf28      	it	cs
   14bf0:	429a      	cmpcs	r2, r3
   14bf2:	d1f5      	bne.n	14be0 <strchr+0xd8>
   14bf4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
   14bf8:	ea40 0401 	orr.w	r4, r0, r1
   14bfc:	e9cd 6702 	strd	r6, r7, [sp, #8]
   14c00:	f06f 0c00 	mvn.w	ip, #0
   14c04:	ea4f 7244 	mov.w	r2, r4, lsl #29
   14c08:	b312      	cbz	r2, 14c50 <strcmp+0x68>
   14c0a:	ea80 0401 	eor.w	r4, r0, r1
   14c0e:	f014 0f07 	tst.w	r4, #7
   14c12:	d16a      	bne.n	14cea <strcmp+0x102>
   14c14:	f000 0407 	and.w	r4, r0, #7
   14c18:	f020 0007 	bic.w	r0, r0, #7
   14c1c:	f004 0503 	and.w	r5, r4, #3
   14c20:	f021 0107 	bic.w	r1, r1, #7
   14c24:	ea4f 05c5 	mov.w	r5, r5, lsl #3
   14c28:	e8f0 2304 	ldrd	r2, r3, [r0], #16
   14c2c:	f014 0f04 	tst.w	r4, #4
   14c30:	e8f1 6704 	ldrd	r6, r7, [r1], #16
   14c34:	fa0c f405 	lsl.w	r4, ip, r5
   14c38:	ea62 0204 	orn	r2, r2, r4
   14c3c:	ea66 0604 	orn	r6, r6, r4
   14c40:	d00a      	beq.n	14c58 <strcmp+0x70>
   14c42:	ea63 0304 	orn	r3, r3, r4
   14c46:	4662      	mov	r2, ip
   14c48:	ea67 0704 	orn	r7, r7, r4
   14c4c:	4666      	mov	r6, ip
   14c4e:	e003      	b.n	14c58 <strcmp+0x70>
   14c50:	e8f0 2304 	ldrd	r2, r3, [r0], #16
   14c54:	e8f1 6704 	ldrd	r6, r7, [r1], #16
   14c58:	fa82 f54c 	uadd8	r5, r2, ip
   14c5c:	ea82 0406 	eor.w	r4, r2, r6
   14c60:	faa4 f48c 	sel	r4, r4, ip
   14c64:	bb6c      	cbnz	r4, 14cc2 <strcmp+0xda>
   14c66:	fa83 f54c 	uadd8	r5, r3, ip
   14c6a:	ea83 0507 	eor.w	r5, r3, r7
   14c6e:	faa5 f58c 	sel	r5, r5, ip
   14c72:	b995      	cbnz	r5, 14c9a <strcmp+0xb2>
   14c74:	e950 2302 	ldrd	r2, r3, [r0, #-8]
   14c78:	e951 6702 	ldrd	r6, r7, [r1, #-8]
   14c7c:	fa82 f54c 	uadd8	r5, r2, ip
   14c80:	ea82 0406 	eor.w	r4, r2, r6
   14c84:	faa4 f48c 	sel	r4, r4, ip
   14c88:	fa83 f54c 	uadd8	r5, r3, ip
   14c8c:	ea83 0507 	eor.w	r5, r3, r7
   14c90:	faa5 f58c 	sel	r5, r5, ip
   14c94:	4325      	orrs	r5, r4
   14c96:	d0db      	beq.n	14c50 <strcmp+0x68>
   14c98:	b99c      	cbnz	r4, 14cc2 <strcmp+0xda>
   14c9a:	ba2d      	rev	r5, r5
   14c9c:	fab5 f485 	clz	r4, r5
   14ca0:	f024 0407 	bic.w	r4, r4, #7
   14ca4:	fa27 f104 	lsr.w	r1, r7, r4
   14ca8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   14cac:	fa23 f304 	lsr.w	r3, r3, r4
   14cb0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   14cb4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   14cb8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14cbc:	eba0 0001 	sub.w	r0, r0, r1
   14cc0:	4770      	bx	lr
   14cc2:	ba24      	rev	r4, r4
   14cc4:	fab4 f484 	clz	r4, r4
   14cc8:	f024 0407 	bic.w	r4, r4, #7
   14ccc:	fa26 f104 	lsr.w	r1, r6, r4
   14cd0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   14cd4:	fa22 f204 	lsr.w	r2, r2, r4
   14cd8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
   14cdc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   14ce0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14ce4:	eba0 0001 	sub.w	r0, r0, r1
   14ce8:	4770      	bx	lr
   14cea:	f014 0f03 	tst.w	r4, #3
   14cee:	d13c      	bne.n	14d6a <strcmp+0x182>
   14cf0:	f010 0403 	ands.w	r4, r0, #3
   14cf4:	d128      	bne.n	14d48 <strcmp+0x160>
   14cf6:	f850 2b08 	ldr.w	r2, [r0], #8
   14cfa:	f851 3b08 	ldr.w	r3, [r1], #8
   14cfe:	fa82 f54c 	uadd8	r5, r2, ip
   14d02:	ea82 0503 	eor.w	r5, r2, r3
   14d06:	faa5 f58c 	sel	r5, r5, ip
   14d0a:	b95d      	cbnz	r5, 14d24 <strcmp+0x13c>
   14d0c:	f850 2c04 	ldr.w	r2, [r0, #-4]
   14d10:	f851 3c04 	ldr.w	r3, [r1, #-4]
   14d14:	fa82 f54c 	uadd8	r5, r2, ip
   14d18:	ea82 0503 	eor.w	r5, r2, r3
   14d1c:	faa5 f58c 	sel	r5, r5, ip
   14d20:	2d00      	cmp	r5, #0
   14d22:	d0e8      	beq.n	14cf6 <strcmp+0x10e>
   14d24:	ba2d      	rev	r5, r5
   14d26:	fab5 f485 	clz	r4, r5
   14d2a:	f024 0407 	bic.w	r4, r4, #7
   14d2e:	fa23 f104 	lsr.w	r1, r3, r4
   14d32:	fa22 f204 	lsr.w	r2, r2, r4
   14d36:	f002 00ff 	and.w	r0, r2, #255	; 0xff
   14d3a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   14d3e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14d42:	eba0 0001 	sub.w	r0, r0, r1
   14d46:	4770      	bx	lr
   14d48:	ea4f 04c4 	mov.w	r4, r4, lsl #3
   14d4c:	f020 0003 	bic.w	r0, r0, #3
   14d50:	f850 2b08 	ldr.w	r2, [r0], #8
   14d54:	f021 0103 	bic.w	r1, r1, #3
   14d58:	f851 3b08 	ldr.w	r3, [r1], #8
   14d5c:	fa0c f404 	lsl.w	r4, ip, r4
   14d60:	ea62 0204 	orn	r2, r2, r4
   14d64:	ea63 0304 	orn	r3, r3, r4
   14d68:	e7c9      	b.n	14cfe <strcmp+0x116>
   14d6a:	f010 0403 	ands.w	r4, r0, #3
   14d6e:	d01a      	beq.n	14da6 <strcmp+0x1be>
   14d70:	eba1 0104 	sub.w	r1, r1, r4
   14d74:	f020 0003 	bic.w	r0, r0, #3
   14d78:	07e4      	lsls	r4, r4, #31
   14d7a:	f850 2b04 	ldr.w	r2, [r0], #4
   14d7e:	d006      	beq.n	14d8e <strcmp+0x1a6>
   14d80:	d20f      	bcs.n	14da2 <strcmp+0x1ba>
   14d82:	788b      	ldrb	r3, [r1, #2]
   14d84:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
   14d88:	1ae4      	subs	r4, r4, r3
   14d8a:	d106      	bne.n	14d9a <strcmp+0x1b2>
   14d8c:	b12b      	cbz	r3, 14d9a <strcmp+0x1b2>
   14d8e:	78cb      	ldrb	r3, [r1, #3]
   14d90:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
   14d94:	1ae4      	subs	r4, r4, r3
   14d96:	d100      	bne.n	14d9a <strcmp+0x1b2>
   14d98:	b91b      	cbnz	r3, 14da2 <strcmp+0x1ba>
   14d9a:	4620      	mov	r0, r4
   14d9c:	f85d 4b10 	ldr.w	r4, [sp], #16
   14da0:	4770      	bx	lr
   14da2:	f101 0104 	add.w	r1, r1, #4
   14da6:	f850 2b04 	ldr.w	r2, [r0], #4
   14daa:	07cc      	lsls	r4, r1, #31
   14dac:	f021 0103 	bic.w	r1, r1, #3
   14db0:	f851 3b04 	ldr.w	r3, [r1], #4
   14db4:	d848      	bhi.n	14e48 <strcmp+0x260>
   14db6:	d224      	bcs.n	14e02 <strcmp+0x21a>
   14db8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
   14dbc:	fa82 f54c 	uadd8	r5, r2, ip
   14dc0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
   14dc4:	faa5 f58c 	sel	r5, r5, ip
   14dc8:	d10a      	bne.n	14de0 <strcmp+0x1f8>
   14dca:	b965      	cbnz	r5, 14de6 <strcmp+0x1fe>
   14dcc:	f851 3b04 	ldr.w	r3, [r1], #4
   14dd0:	ea84 0402 	eor.w	r4, r4, r2
   14dd4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
   14dd8:	d10e      	bne.n	14df8 <strcmp+0x210>
   14dda:	f850 2b04 	ldr.w	r2, [r0], #4
   14dde:	e7eb      	b.n	14db8 <strcmp+0x1d0>
   14de0:	ea4f 2313 	mov.w	r3, r3, lsr #8
   14de4:	e055      	b.n	14e92 <strcmp+0x2aa>
   14de6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
   14dea:	d14d      	bne.n	14e88 <strcmp+0x2a0>
   14dec:	7808      	ldrb	r0, [r1, #0]
   14dee:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14df2:	f1c0 0000 	rsb	r0, r0, #0
   14df6:	4770      	bx	lr
   14df8:	ea4f 6212 	mov.w	r2, r2, lsr #24
   14dfc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   14e00:	e047      	b.n	14e92 <strcmp+0x2aa>
   14e02:	ea02 441c 	and.w	r4, r2, ip, lsr #16
   14e06:	fa82 f54c 	uadd8	r5, r2, ip
   14e0a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
   14e0e:	faa5 f58c 	sel	r5, r5, ip
   14e12:	d10a      	bne.n	14e2a <strcmp+0x242>
   14e14:	b965      	cbnz	r5, 14e30 <strcmp+0x248>
   14e16:	f851 3b04 	ldr.w	r3, [r1], #4
   14e1a:	ea84 0402 	eor.w	r4, r4, r2
   14e1e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
   14e22:	d10c      	bne.n	14e3e <strcmp+0x256>
   14e24:	f850 2b04 	ldr.w	r2, [r0], #4
   14e28:	e7eb      	b.n	14e02 <strcmp+0x21a>
   14e2a:	ea4f 4313 	mov.w	r3, r3, lsr #16
   14e2e:	e030      	b.n	14e92 <strcmp+0x2aa>
   14e30:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
   14e34:	d128      	bne.n	14e88 <strcmp+0x2a0>
   14e36:	880b      	ldrh	r3, [r1, #0]
   14e38:	ea4f 4212 	mov.w	r2, r2, lsr #16
   14e3c:	e029      	b.n	14e92 <strcmp+0x2aa>
   14e3e:	ea4f 4212 	mov.w	r2, r2, lsr #16
   14e42:	ea03 431c 	and.w	r3, r3, ip, lsr #16
   14e46:	e024      	b.n	14e92 <strcmp+0x2aa>
   14e48:	f002 04ff 	and.w	r4, r2, #255	; 0xff
   14e4c:	fa82 f54c 	uadd8	r5, r2, ip
   14e50:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
   14e54:	faa5 f58c 	sel	r5, r5, ip
   14e58:	d10a      	bne.n	14e70 <strcmp+0x288>
   14e5a:	b965      	cbnz	r5, 14e76 <strcmp+0x28e>
   14e5c:	f851 3b04 	ldr.w	r3, [r1], #4
   14e60:	ea84 0402 	eor.w	r4, r4, r2
   14e64:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
   14e68:	d109      	bne.n	14e7e <strcmp+0x296>
   14e6a:	f850 2b04 	ldr.w	r2, [r0], #4
   14e6e:	e7eb      	b.n	14e48 <strcmp+0x260>
   14e70:	ea4f 6313 	mov.w	r3, r3, lsr #24
   14e74:	e00d      	b.n	14e92 <strcmp+0x2aa>
   14e76:	f015 0fff 	tst.w	r5, #255	; 0xff
   14e7a:	d105      	bne.n	14e88 <strcmp+0x2a0>
   14e7c:	680b      	ldr	r3, [r1, #0]
   14e7e:	ea4f 2212 	mov.w	r2, r2, lsr #8
   14e82:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   14e86:	e004      	b.n	14e92 <strcmp+0x2aa>
   14e88:	f04f 0000 	mov.w	r0, #0
   14e8c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14e90:	4770      	bx	lr
   14e92:	ba12      	rev	r2, r2
   14e94:	ba1b      	rev	r3, r3
   14e96:	fa82 f44c 	uadd8	r4, r2, ip
   14e9a:	ea82 0403 	eor.w	r4, r2, r3
   14e9e:	faa4 f58c 	sel	r5, r4, ip
   14ea2:	fab5 f485 	clz	r4, r5
   14ea6:	fa02 f204 	lsl.w	r2, r2, r4
   14eaa:	fa03 f304 	lsl.w	r3, r3, r4
   14eae:	ea4f 6012 	mov.w	r0, r2, lsr #24
   14eb2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14eb6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
   14eba:	4770      	bx	lr

00014ebc <strcpy>:
   14ebc:	ea80 0201 	eor.w	r2, r0, r1
   14ec0:	4684      	mov	ip, r0
   14ec2:	f012 0f03 	tst.w	r2, #3
   14ec6:	d14f      	bne.n	14f68 <strcpy+0xac>
   14ec8:	f011 0f03 	tst.w	r1, #3
   14ecc:	d132      	bne.n	14f34 <strcpy+0x78>
   14ece:	f84d 4d04 	str.w	r4, [sp, #-4]!
   14ed2:	f011 0f04 	tst.w	r1, #4
   14ed6:	f851 3b04 	ldr.w	r3, [r1], #4
   14eda:	d00b      	beq.n	14ef4 <strcpy+0x38>
   14edc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   14ee0:	439a      	bics	r2, r3
   14ee2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   14ee6:	bf04      	itt	eq
   14ee8:	f84c 3b04 	streq.w	r3, [ip], #4
   14eec:	f851 3b04 	ldreq.w	r3, [r1], #4
   14ef0:	d116      	bne.n	14f20 <strcpy+0x64>
   14ef2:	bf00      	nop
   14ef4:	f851 4b04 	ldr.w	r4, [r1], #4
   14ef8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   14efc:	439a      	bics	r2, r3
   14efe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   14f02:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   14f06:	d10b      	bne.n	14f20 <strcpy+0x64>
   14f08:	f84c 3b04 	str.w	r3, [ip], #4
   14f0c:	43a2      	bics	r2, r4
   14f0e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   14f12:	bf04      	itt	eq
   14f14:	f851 3b04 	ldreq.w	r3, [r1], #4
   14f18:	f84c 4b04 	streq.w	r4, [ip], #4
   14f1c:	d0ea      	beq.n	14ef4 <strcpy+0x38>
   14f1e:	4623      	mov	r3, r4
   14f20:	f80c 3b01 	strb.w	r3, [ip], #1
   14f24:	f013 0fff 	tst.w	r3, #255	; 0xff
   14f28:	ea4f 2333 	mov.w	r3, r3, ror #8
   14f2c:	d1f8      	bne.n	14f20 <strcpy+0x64>
   14f2e:	f85d 4b04 	ldr.w	r4, [sp], #4
   14f32:	4770      	bx	lr
   14f34:	f011 0f01 	tst.w	r1, #1
   14f38:	d006      	beq.n	14f48 <strcpy+0x8c>
   14f3a:	f811 2b01 	ldrb.w	r2, [r1], #1
   14f3e:	f80c 2b01 	strb.w	r2, [ip], #1
   14f42:	2a00      	cmp	r2, #0
   14f44:	bf08      	it	eq
   14f46:	4770      	bxeq	lr
   14f48:	f011 0f02 	tst.w	r1, #2
   14f4c:	d0bf      	beq.n	14ece <strcpy+0x12>
   14f4e:	f831 2b02 	ldrh.w	r2, [r1], #2
   14f52:	f012 0fff 	tst.w	r2, #255	; 0xff
   14f56:	bf16      	itet	ne
   14f58:	f82c 2b02 	strhne.w	r2, [ip], #2
   14f5c:	f88c 2000 	strbeq.w	r2, [ip]
   14f60:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   14f64:	d1b3      	bne.n	14ece <strcpy+0x12>
   14f66:	4770      	bx	lr
   14f68:	f811 2b01 	ldrb.w	r2, [r1], #1
   14f6c:	f80c 2b01 	strb.w	r2, [ip], #1
   14f70:	2a00      	cmp	r2, #0
   14f72:	d1f9      	bne.n	14f68 <strcpy+0xac>
   14f74:	4770      	bx	lr
   14f76:	bf00      	nop
	...

00014f80 <strlen>:
   14f80:	f890 f000 	pld	[r0]
   14f84:	e96d 4502 	strd	r4, r5, [sp, #-8]!
   14f88:	f020 0107 	bic.w	r1, r0, #7
   14f8c:	f06f 0c00 	mvn.w	ip, #0
   14f90:	f010 0407 	ands.w	r4, r0, #7
   14f94:	f891 f020 	pld	[r1, #32]
   14f98:	f040 8049 	bne.w	1502e <strlen+0xae>
   14f9c:	f04f 0400 	mov.w	r4, #0
   14fa0:	f06f 0007 	mvn.w	r0, #7
   14fa4:	e9d1 2300 	ldrd	r2, r3, [r1]
   14fa8:	f891 f040 	pld	[r1, #64]	; 0x40
   14fac:	f100 0008 	add.w	r0, r0, #8
   14fb0:	fa82 f24c 	uadd8	r2, r2, ip
   14fb4:	faa4 f28c 	sel	r2, r4, ip
   14fb8:	fa83 f34c 	uadd8	r3, r3, ip
   14fbc:	faa2 f38c 	sel	r3, r2, ip
   14fc0:	bb4b      	cbnz	r3, 15016 <strlen+0x96>
   14fc2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
   14fc6:	fa82 f24c 	uadd8	r2, r2, ip
   14fca:	f100 0008 	add.w	r0, r0, #8
   14fce:	faa4 f28c 	sel	r2, r4, ip
   14fd2:	fa83 f34c 	uadd8	r3, r3, ip
   14fd6:	faa2 f38c 	sel	r3, r2, ip
   14fda:	b9e3      	cbnz	r3, 15016 <strlen+0x96>
   14fdc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
   14fe0:	fa82 f24c 	uadd8	r2, r2, ip
   14fe4:	f100 0008 	add.w	r0, r0, #8
   14fe8:	faa4 f28c 	sel	r2, r4, ip
   14fec:	fa83 f34c 	uadd8	r3, r3, ip
   14ff0:	faa2 f38c 	sel	r3, r2, ip
   14ff4:	b97b      	cbnz	r3, 15016 <strlen+0x96>
   14ff6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
   14ffa:	f101 0120 	add.w	r1, r1, #32
   14ffe:	fa82 f24c 	uadd8	r2, r2, ip
   15002:	f100 0008 	add.w	r0, r0, #8
   15006:	faa4 f28c 	sel	r2, r4, ip
   1500a:	fa83 f34c 	uadd8	r3, r3, ip
   1500e:	faa2 f38c 	sel	r3, r2, ip
   15012:	2b00      	cmp	r3, #0
   15014:	d0c6      	beq.n	14fa4 <strlen+0x24>
   15016:	2a00      	cmp	r2, #0
   15018:	bf04      	itt	eq
   1501a:	3004      	addeq	r0, #4
   1501c:	461a      	moveq	r2, r3
   1501e:	ba12      	rev	r2, r2
   15020:	fab2 f282 	clz	r2, r2
   15024:	e8fd 4502 	ldrd	r4, r5, [sp], #8
   15028:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
   1502c:	4770      	bx	lr
   1502e:	e9d1 2300 	ldrd	r2, r3, [r1]
   15032:	f004 0503 	and.w	r5, r4, #3
   15036:	f1c4 0000 	rsb	r0, r4, #0
   1503a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
   1503e:	f014 0f04 	tst.w	r4, #4
   15042:	f891 f040 	pld	[r1, #64]	; 0x40
   15046:	fa0c f505 	lsl.w	r5, ip, r5
   1504a:	ea62 0205 	orn	r2, r2, r5
   1504e:	bf1c      	itt	ne
   15050:	ea63 0305 	ornne	r3, r3, r5
   15054:	4662      	movne	r2, ip
   15056:	f04f 0400 	mov.w	r4, #0
   1505a:	e7a9      	b.n	14fb0 <strlen+0x30>

0001505c <__swbuf_r>:
   1505c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1505e:	460d      	mov	r5, r1
   15060:	4614      	mov	r4, r2
   15062:	4606      	mov	r6, r0
   15064:	b108      	cbz	r0, 1506a <__swbuf_r+0xe>
   15066:	6983      	ldr	r3, [r0, #24]
   15068:	b343      	cbz	r3, 150bc <__swbuf_r+0x60>
   1506a:	4b25      	ldr	r3, [pc, #148]	; (15100 <__swbuf_r+0xa4>)
   1506c:	429c      	cmp	r4, r3
   1506e:	d02a      	beq.n	150c6 <__swbuf_r+0x6a>
   15070:	4b24      	ldr	r3, [pc, #144]	; (15104 <__swbuf_r+0xa8>)
   15072:	429c      	cmp	r4, r3
   15074:	d029      	beq.n	150ca <__swbuf_r+0x6e>
   15076:	4b24      	ldr	r3, [pc, #144]	; (15108 <__swbuf_r+0xac>)
   15078:	429c      	cmp	r4, r3
   1507a:	bf08      	it	eq
   1507c:	68f4      	ldreq	r4, [r6, #12]
   1507e:	89a3      	ldrh	r3, [r4, #12]
   15080:	69a2      	ldr	r2, [r4, #24]
   15082:	60a2      	str	r2, [r4, #8]
   15084:	071a      	lsls	r2, r3, #28
   15086:	d522      	bpl.n	150ce <__swbuf_r+0x72>
   15088:	6923      	ldr	r3, [r4, #16]
   1508a:	b303      	cbz	r3, 150ce <__swbuf_r+0x72>
   1508c:	6822      	ldr	r2, [r4, #0]
   1508e:	6961      	ldr	r1, [r4, #20]
   15090:	1ad3      	subs	r3, r2, r3
   15092:	b2ed      	uxtb	r5, r5
   15094:	4299      	cmp	r1, r3
   15096:	462f      	mov	r7, r5
   15098:	dd29      	ble.n	150ee <__swbuf_r+0x92>
   1509a:	3301      	adds	r3, #1
   1509c:	68a1      	ldr	r1, [r4, #8]
   1509e:	1c50      	adds	r0, r2, #1
   150a0:	3901      	subs	r1, #1
   150a2:	60a1      	str	r1, [r4, #8]
   150a4:	6020      	str	r0, [r4, #0]
   150a6:	7015      	strb	r5, [r2, #0]
   150a8:	6962      	ldr	r2, [r4, #20]
   150aa:	429a      	cmp	r2, r3
   150ac:	d016      	beq.n	150dc <__swbuf_r+0x80>
   150ae:	89a3      	ldrh	r3, [r4, #12]
   150b0:	07db      	lsls	r3, r3, #31
   150b2:	d501      	bpl.n	150b8 <__swbuf_r+0x5c>
   150b4:	2d0a      	cmp	r5, #10
   150b6:	d011      	beq.n	150dc <__swbuf_r+0x80>
   150b8:	4638      	mov	r0, r7
   150ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   150bc:	f000 fa6e 	bl	1559c <__sinit>
   150c0:	4b0f      	ldr	r3, [pc, #60]	; (15100 <__swbuf_r+0xa4>)
   150c2:	429c      	cmp	r4, r3
   150c4:	d1d4      	bne.n	15070 <__swbuf_r+0x14>
   150c6:	6874      	ldr	r4, [r6, #4]
   150c8:	e7d9      	b.n	1507e <__swbuf_r+0x22>
   150ca:	68b4      	ldr	r4, [r6, #8]
   150cc:	e7d7      	b.n	1507e <__swbuf_r+0x22>
   150ce:	4621      	mov	r1, r4
   150d0:	4630      	mov	r0, r6
   150d2:	f000 f823 	bl	1511c <__swsetup_r>
   150d6:	b938      	cbnz	r0, 150e8 <__swbuf_r+0x8c>
   150d8:	6923      	ldr	r3, [r4, #16]
   150da:	e7d7      	b.n	1508c <__swbuf_r+0x30>
   150dc:	4621      	mov	r1, r4
   150de:	4630      	mov	r0, r6
   150e0:	f000 f932 	bl	15348 <_fflush_r>
   150e4:	2800      	cmp	r0, #0
   150e6:	d0e7      	beq.n	150b8 <__swbuf_r+0x5c>
   150e8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   150ec:	e7e4      	b.n	150b8 <__swbuf_r+0x5c>
   150ee:	4621      	mov	r1, r4
   150f0:	4630      	mov	r0, r6
   150f2:	f000 f929 	bl	15348 <_fflush_r>
   150f6:	2800      	cmp	r0, #0
   150f8:	d1f6      	bne.n	150e8 <__swbuf_r+0x8c>
   150fa:	6822      	ldr	r2, [r4, #0]
   150fc:	2301      	movs	r3, #1
   150fe:	e7cd      	b.n	1509c <__swbuf_r+0x40>
   15100:	00017910 	.word	0x00017910
   15104:	000178f0 	.word	0x000178f0
   15108:	000178d0 	.word	0x000178d0

0001510c <__swbuf>:
   1510c:	4b02      	ldr	r3, [pc, #8]	; (15118 <__swbuf+0xc>)
   1510e:	460a      	mov	r2, r1
   15110:	4601      	mov	r1, r0
   15112:	6818      	ldr	r0, [r3, #0]
   15114:	f7ff bfa2 	b.w	1505c <__swbuf_r>
   15118:	2000054c 	.word	0x2000054c

0001511c <__swsetup_r>:
   1511c:	4b3b      	ldr	r3, [pc, #236]	; (1520c <__swsetup_r+0xf0>)
   1511e:	b570      	push	{r4, r5, r6, lr}
   15120:	681d      	ldr	r5, [r3, #0]
   15122:	4606      	mov	r6, r0
   15124:	460c      	mov	r4, r1
   15126:	b10d      	cbz	r5, 1512c <__swsetup_r+0x10>
   15128:	69ab      	ldr	r3, [r5, #24]
   1512a:	b1db      	cbz	r3, 15164 <__swsetup_r+0x48>
   1512c:	4b38      	ldr	r3, [pc, #224]	; (15210 <__swsetup_r+0xf4>)
   1512e:	429c      	cmp	r4, r3
   15130:	d01e      	beq.n	15170 <__swsetup_r+0x54>
   15132:	4b38      	ldr	r3, [pc, #224]	; (15214 <__swsetup_r+0xf8>)
   15134:	429c      	cmp	r4, r3
   15136:	d04a      	beq.n	151ce <__swsetup_r+0xb2>
   15138:	4b37      	ldr	r3, [pc, #220]	; (15218 <__swsetup_r+0xfc>)
   1513a:	429c      	cmp	r4, r3
   1513c:	bf08      	it	eq
   1513e:	68ec      	ldreq	r4, [r5, #12]
   15140:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   15144:	b293      	uxth	r3, r2
   15146:	0719      	lsls	r1, r3, #28
   15148:	d518      	bpl.n	1517c <__swsetup_r+0x60>
   1514a:	6920      	ldr	r0, [r4, #16]
   1514c:	b308      	cbz	r0, 15192 <__swsetup_r+0x76>
   1514e:	f013 0201 	ands.w	r2, r3, #1
   15152:	d02c      	beq.n	151ae <__swsetup_r+0x92>
   15154:	6963      	ldr	r3, [r4, #20]
   15156:	2200      	movs	r2, #0
   15158:	425b      	negs	r3, r3
   1515a:	61a3      	str	r3, [r4, #24]
   1515c:	60a2      	str	r2, [r4, #8]
   1515e:	b360      	cbz	r0, 151ba <__swsetup_r+0x9e>
   15160:	2000      	movs	r0, #0
   15162:	bd70      	pop	{r4, r5, r6, pc}
   15164:	4628      	mov	r0, r5
   15166:	f000 fa19 	bl	1559c <__sinit>
   1516a:	4b29      	ldr	r3, [pc, #164]	; (15210 <__swsetup_r+0xf4>)
   1516c:	429c      	cmp	r4, r3
   1516e:	d1e0      	bne.n	15132 <__swsetup_r+0x16>
   15170:	686c      	ldr	r4, [r5, #4]
   15172:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   15176:	b293      	uxth	r3, r2
   15178:	0719      	lsls	r1, r3, #28
   1517a:	d4e6      	bmi.n	1514a <__swsetup_r+0x2e>
   1517c:	06dd      	lsls	r5, r3, #27
   1517e:	d53c      	bpl.n	151fa <__swsetup_r+0xde>
   15180:	0758      	lsls	r0, r3, #29
   15182:	d426      	bmi.n	151d2 <__swsetup_r+0xb6>
   15184:	6920      	ldr	r0, [r4, #16]
   15186:	f042 0308 	orr.w	r3, r2, #8
   1518a:	81a3      	strh	r3, [r4, #12]
   1518c:	b29b      	uxth	r3, r3
   1518e:	2800      	cmp	r0, #0
   15190:	d1dd      	bne.n	1514e <__swsetup_r+0x32>
   15192:	f403 7220 	and.w	r2, r3, #640	; 0x280
   15196:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   1519a:	d0d8      	beq.n	1514e <__swsetup_r+0x32>
   1519c:	4630      	mov	r0, r6
   1519e:	4621      	mov	r1, r4
   151a0:	f000 fa9a 	bl	156d8 <__smakebuf_r>
   151a4:	89a3      	ldrh	r3, [r4, #12]
   151a6:	6920      	ldr	r0, [r4, #16]
   151a8:	f013 0201 	ands.w	r2, r3, #1
   151ac:	d1d2      	bne.n	15154 <__swsetup_r+0x38>
   151ae:	0799      	lsls	r1, r3, #30
   151b0:	bf58      	it	pl
   151b2:	6962      	ldrpl	r2, [r4, #20]
   151b4:	60a2      	str	r2, [r4, #8]
   151b6:	2800      	cmp	r0, #0
   151b8:	d1d2      	bne.n	15160 <__swsetup_r+0x44>
   151ba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   151be:	061a      	lsls	r2, r3, #24
   151c0:	d5cf      	bpl.n	15162 <__swsetup_r+0x46>
   151c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   151c6:	81a3      	strh	r3, [r4, #12]
   151c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   151cc:	bd70      	pop	{r4, r5, r6, pc}
   151ce:	68ac      	ldr	r4, [r5, #8]
   151d0:	e7b6      	b.n	15140 <__swsetup_r+0x24>
   151d2:	6b61      	ldr	r1, [r4, #52]	; 0x34
   151d4:	b151      	cbz	r1, 151ec <__swsetup_r+0xd0>
   151d6:	f104 0344 	add.w	r3, r4, #68	; 0x44
   151da:	4299      	cmp	r1, r3
   151dc:	d004      	beq.n	151e8 <__swsetup_r+0xcc>
   151de:	4630      	mov	r0, r6
   151e0:	f7ff f992 	bl	14508 <_free_r>
   151e4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   151e8:	2300      	movs	r3, #0
   151ea:	6363      	str	r3, [r4, #52]	; 0x34
   151ec:	2300      	movs	r3, #0
   151ee:	6920      	ldr	r0, [r4, #16]
   151f0:	6063      	str	r3, [r4, #4]
   151f2:	f022 0224 	bic.w	r2, r2, #36	; 0x24
   151f6:	6020      	str	r0, [r4, #0]
   151f8:	e7c5      	b.n	15186 <__swsetup_r+0x6a>
   151fa:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   151fe:	2309      	movs	r3, #9
   15200:	6033      	str	r3, [r6, #0]
   15202:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15206:	81a2      	strh	r2, [r4, #12]
   15208:	bd70      	pop	{r4, r5, r6, pc}
   1520a:	bf00      	nop
   1520c:	2000054c 	.word	0x2000054c
   15210:	00017910 	.word	0x00017910
   15214:	000178f0 	.word	0x000178f0
   15218:	000178d0 	.word	0x000178d0

0001521c <__sflush_r>:
   1521c:	898b      	ldrh	r3, [r1, #12]
   1521e:	071a      	lsls	r2, r3, #28
   15220:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15224:	460c      	mov	r4, r1
   15226:	4680      	mov	r8, r0
   15228:	d441      	bmi.n	152ae <__sflush_r+0x92>
   1522a:	684a      	ldr	r2, [r1, #4]
   1522c:	2a00      	cmp	r2, #0
   1522e:	dd59      	ble.n	152e4 <__sflush_r+0xc8>
   15230:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   15232:	2e00      	cmp	r6, #0
   15234:	d053      	beq.n	152de <__sflush_r+0xc2>
   15236:	2200      	movs	r2, #0
   15238:	f8d8 5000 	ldr.w	r5, [r8]
   1523c:	6a21      	ldr	r1, [r4, #32]
   1523e:	f8c8 2000 	str.w	r2, [r8]
   15242:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
   15246:	d151      	bne.n	152ec <__sflush_r+0xd0>
   15248:	2301      	movs	r3, #1
   1524a:	4640      	mov	r0, r8
   1524c:	47b0      	blx	r6
   1524e:	1c43      	adds	r3, r0, #1
   15250:	d05f      	beq.n	15312 <__sflush_r+0xf6>
   15252:	89a3      	ldrh	r3, [r4, #12]
   15254:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   15256:	6a21      	ldr	r1, [r4, #32]
   15258:	075f      	lsls	r7, r3, #29
   1525a:	d505      	bpl.n	15268 <__sflush_r+0x4c>
   1525c:	6862      	ldr	r2, [r4, #4]
   1525e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   15260:	1a80      	subs	r0, r0, r2
   15262:	b10b      	cbz	r3, 15268 <__sflush_r+0x4c>
   15264:	6c23      	ldr	r3, [r4, #64]	; 0x40
   15266:	1ac0      	subs	r0, r0, r3
   15268:	4602      	mov	r2, r0
   1526a:	2300      	movs	r3, #0
   1526c:	4640      	mov	r0, r8
   1526e:	47b0      	blx	r6
   15270:	1c46      	adds	r6, r0, #1
   15272:	d145      	bne.n	15300 <__sflush_r+0xe4>
   15274:	f8d8 3000 	ldr.w	r3, [r8]
   15278:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   1527c:	2b00      	cmp	r3, #0
   1527e:	d055      	beq.n	1532c <__sflush_r+0x110>
   15280:	2b1d      	cmp	r3, #29
   15282:	d001      	beq.n	15288 <__sflush_r+0x6c>
   15284:	2b16      	cmp	r3, #22
   15286:	d15a      	bne.n	1533e <__sflush_r+0x122>
   15288:	6923      	ldr	r3, [r4, #16]
   1528a:	2200      	movs	r2, #0
   1528c:	e9c4 3200 	strd	r3, r2, [r4]
   15290:	6b61      	ldr	r1, [r4, #52]	; 0x34
   15292:	f8c8 5000 	str.w	r5, [r8]
   15296:	b311      	cbz	r1, 152de <__sflush_r+0xc2>
   15298:	f104 0344 	add.w	r3, r4, #68	; 0x44
   1529c:	4299      	cmp	r1, r3
   1529e:	d002      	beq.n	152a6 <__sflush_r+0x8a>
   152a0:	4640      	mov	r0, r8
   152a2:	f7ff f931 	bl	14508 <_free_r>
   152a6:	2000      	movs	r0, #0
   152a8:	6360      	str	r0, [r4, #52]	; 0x34
   152aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   152ae:	690e      	ldr	r6, [r1, #16]
   152b0:	b1ae      	cbz	r6, 152de <__sflush_r+0xc2>
   152b2:	680d      	ldr	r5, [r1, #0]
   152b4:	600e      	str	r6, [r1, #0]
   152b6:	0799      	lsls	r1, r3, #30
   152b8:	bf0c      	ite	eq
   152ba:	6963      	ldreq	r3, [r4, #20]
   152bc:	2300      	movne	r3, #0
   152be:	1bad      	subs	r5, r5, r6
   152c0:	60a3      	str	r3, [r4, #8]
   152c2:	e00a      	b.n	152da <__sflush_r+0xbe>
   152c4:	462b      	mov	r3, r5
   152c6:	4632      	mov	r2, r6
   152c8:	6aa7      	ldr	r7, [r4, #40]	; 0x28
   152ca:	6a21      	ldr	r1, [r4, #32]
   152cc:	4640      	mov	r0, r8
   152ce:	47b8      	blx	r7
   152d0:	2800      	cmp	r0, #0
   152d2:	eba5 0500 	sub.w	r5, r5, r0
   152d6:	4406      	add	r6, r0
   152d8:	dd0a      	ble.n	152f0 <__sflush_r+0xd4>
   152da:	2d00      	cmp	r5, #0
   152dc:	dcf2      	bgt.n	152c4 <__sflush_r+0xa8>
   152de:	2000      	movs	r0, #0
   152e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   152e4:	6c0a      	ldr	r2, [r1, #64]	; 0x40
   152e6:	2a00      	cmp	r2, #0
   152e8:	dca2      	bgt.n	15230 <__sflush_r+0x14>
   152ea:	e7f8      	b.n	152de <__sflush_r+0xc2>
   152ec:	6d60      	ldr	r0, [r4, #84]	; 0x54
   152ee:	e7b3      	b.n	15258 <__sflush_r+0x3c>
   152f0:	89a3      	ldrh	r3, [r4, #12]
   152f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   152f6:	81a3      	strh	r3, [r4, #12]
   152f8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   152fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15300:	6922      	ldr	r2, [r4, #16]
   15302:	89a3      	ldrh	r3, [r4, #12]
   15304:	6022      	str	r2, [r4, #0]
   15306:	2200      	movs	r2, #0
   15308:	6062      	str	r2, [r4, #4]
   1530a:	04da      	lsls	r2, r3, #19
   1530c:	d5c0      	bpl.n	15290 <__sflush_r+0x74>
   1530e:	6560      	str	r0, [r4, #84]	; 0x54
   15310:	e7be      	b.n	15290 <__sflush_r+0x74>
   15312:	f8d8 3000 	ldr.w	r3, [r8]
   15316:	2b00      	cmp	r3, #0
   15318:	d09b      	beq.n	15252 <__sflush_r+0x36>
   1531a:	2b1d      	cmp	r3, #29
   1531c:	d00c      	beq.n	15338 <__sflush_r+0x11c>
   1531e:	2b16      	cmp	r3, #22
   15320:	d00a      	beq.n	15338 <__sflush_r+0x11c>
   15322:	89a3      	ldrh	r3, [r4, #12]
   15324:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   15328:	81a3      	strh	r3, [r4, #12]
   1532a:	e7d9      	b.n	152e0 <__sflush_r+0xc4>
   1532c:	6921      	ldr	r1, [r4, #16]
   1532e:	e9c4 1300 	strd	r1, r3, [r4]
   15332:	04d3      	lsls	r3, r2, #19
   15334:	d5ac      	bpl.n	15290 <__sflush_r+0x74>
   15336:	e7ea      	b.n	1530e <__sflush_r+0xf2>
   15338:	f8c8 5000 	str.w	r5, [r8]
   1533c:	e7cf      	b.n	152de <__sflush_r+0xc2>
   1533e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   15342:	81a2      	strh	r2, [r4, #12]
   15344:	e7cc      	b.n	152e0 <__sflush_r+0xc4>
   15346:	bf00      	nop

00015348 <_fflush_r>:
   15348:	690b      	ldr	r3, [r1, #16]
   1534a:	b323      	cbz	r3, 15396 <_fflush_r+0x4e>
   1534c:	b510      	push	{r4, lr}
   1534e:	4604      	mov	r4, r0
   15350:	b082      	sub	sp, #8
   15352:	b108      	cbz	r0, 15358 <_fflush_r+0x10>
   15354:	6983      	ldr	r3, [r0, #24]
   15356:	b1bb      	cbz	r3, 15388 <_fflush_r+0x40>
   15358:	4b10      	ldr	r3, [pc, #64]	; (1539c <_fflush_r+0x54>)
   1535a:	4299      	cmp	r1, r3
   1535c:	d012      	beq.n	15384 <_fflush_r+0x3c>
   1535e:	4b10      	ldr	r3, [pc, #64]	; (153a0 <_fflush_r+0x58>)
   15360:	4299      	cmp	r1, r3
   15362:	d016      	beq.n	15392 <_fflush_r+0x4a>
   15364:	4b0f      	ldr	r3, [pc, #60]	; (153a4 <_fflush_r+0x5c>)
   15366:	4299      	cmp	r1, r3
   15368:	bf08      	it	eq
   1536a:	68e1      	ldreq	r1, [r4, #12]
   1536c:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
   15370:	b12b      	cbz	r3, 1537e <_fflush_r+0x36>
   15372:	4620      	mov	r0, r4
   15374:	b002      	add	sp, #8
   15376:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1537a:	f7ff bf4f 	b.w	1521c <__sflush_r>
   1537e:	2000      	movs	r0, #0
   15380:	b002      	add	sp, #8
   15382:	bd10      	pop	{r4, pc}
   15384:	6861      	ldr	r1, [r4, #4]
   15386:	e7f1      	b.n	1536c <_fflush_r+0x24>
   15388:	9101      	str	r1, [sp, #4]
   1538a:	f000 f907 	bl	1559c <__sinit>
   1538e:	9901      	ldr	r1, [sp, #4]
   15390:	e7e2      	b.n	15358 <_fflush_r+0x10>
   15392:	68a1      	ldr	r1, [r4, #8]
   15394:	e7ea      	b.n	1536c <_fflush_r+0x24>
   15396:	2000      	movs	r0, #0
   15398:	4770      	bx	lr
   1539a:	bf00      	nop
   1539c:	00017910 	.word	0x00017910
   153a0:	000178f0 	.word	0x000178f0
   153a4:	000178d0 	.word	0x000178d0

000153a8 <fflush>:
   153a8:	b120      	cbz	r0, 153b4 <fflush+0xc>
   153aa:	4b05      	ldr	r3, [pc, #20]	; (153c0 <fflush+0x18>)
   153ac:	4601      	mov	r1, r0
   153ae:	6818      	ldr	r0, [r3, #0]
   153b0:	f7ff bfca 	b.w	15348 <_fflush_r>
   153b4:	4b03      	ldr	r3, [pc, #12]	; (153c4 <fflush+0x1c>)
   153b6:	4904      	ldr	r1, [pc, #16]	; (153c8 <fflush+0x20>)
   153b8:	6818      	ldr	r0, [r3, #0]
   153ba:	f000 b935 	b.w	15628 <_fwalk_reent>
   153be:	bf00      	nop
   153c0:	2000054c 	.word	0x2000054c
   153c4:	000178cc 	.word	0x000178cc
   153c8:	00015349 	.word	0x00015349

000153cc <__fp_lock>:
   153cc:	2000      	movs	r0, #0
   153ce:	4770      	bx	lr

000153d0 <_cleanup_r>:
   153d0:	4901      	ldr	r1, [pc, #4]	; (153d8 <_cleanup_r+0x8>)
   153d2:	f000 b929 	b.w	15628 <_fwalk_reent>
   153d6:	bf00      	nop
   153d8:	00015349 	.word	0x00015349

000153dc <__fp_unlock>:
   153dc:	2000      	movs	r0, #0
   153de:	4770      	bx	lr

000153e0 <__sfmoreglue>:
   153e0:	b570      	push	{r4, r5, r6, lr}
   153e2:	1e4a      	subs	r2, r1, #1
   153e4:	2568      	movs	r5, #104	; 0x68
   153e6:	fb05 f502 	mul.w	r5, r5, r2
   153ea:	460e      	mov	r6, r1
   153ec:	f105 0174 	add.w	r1, r5, #116	; 0x74
   153f0:	f7ff f8e0 	bl	145b4 <_malloc_r>
   153f4:	4604      	mov	r4, r0
   153f6:	b140      	cbz	r0, 1540a <__sfmoreglue+0x2a>
   153f8:	2100      	movs	r1, #0
   153fa:	300c      	adds	r0, #12
   153fc:	6066      	str	r6, [r4, #4]
   153fe:	f105 0268 	add.w	r2, r5, #104	; 0x68
   15402:	6021      	str	r1, [r4, #0]
   15404:	60a0      	str	r0, [r4, #8]
   15406:	f7ff f82f 	bl	14468 <memset>
   1540a:	4620      	mov	r0, r4
   1540c:	bd70      	pop	{r4, r5, r6, pc}
   1540e:	bf00      	nop

00015410 <__sfp>:
   15410:	4b1e      	ldr	r3, [pc, #120]	; (1548c <__sfp+0x7c>)
   15412:	b570      	push	{r4, r5, r6, lr}
   15414:	681d      	ldr	r5, [r3, #0]
   15416:	69ab      	ldr	r3, [r5, #24]
   15418:	4606      	mov	r6, r0
   1541a:	b343      	cbz	r3, 1546e <__sfp+0x5e>
   1541c:	3548      	adds	r5, #72	; 0x48
   1541e:	e9d5 3401 	ldrd	r3, r4, [r5, #4]
   15422:	3b01      	subs	r3, #1
   15424:	d505      	bpl.n	15432 <__sfp+0x22>
   15426:	e01e      	b.n	15466 <__sfp+0x56>
   15428:	3b01      	subs	r3, #1
   1542a:	1c5a      	adds	r2, r3, #1
   1542c:	f104 0468 	add.w	r4, r4, #104	; 0x68
   15430:	d019      	beq.n	15466 <__sfp+0x56>
   15432:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   15436:	2a00      	cmp	r2, #0
   15438:	d1f6      	bne.n	15428 <__sfp+0x18>
   1543a:	2500      	movs	r5, #0
   1543c:	4b14      	ldr	r3, [pc, #80]	; (15490 <__sfp+0x80>)
   1543e:	6665      	str	r5, [r4, #100]	; 0x64
   15440:	e9c4 5500 	strd	r5, r5, [r4]
   15444:	60a5      	str	r5, [r4, #8]
   15446:	e9c4 5504 	strd	r5, r5, [r4, #16]
   1544a:	61a5      	str	r5, [r4, #24]
   1544c:	4629      	mov	r1, r5
   1544e:	60e3      	str	r3, [r4, #12]
   15450:	2208      	movs	r2, #8
   15452:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   15456:	f7ff f807 	bl	14468 <memset>
   1545a:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   1545e:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   15462:	4620      	mov	r0, r4
   15464:	bd70      	pop	{r4, r5, r6, pc}
   15466:	682c      	ldr	r4, [r5, #0]
   15468:	b12c      	cbz	r4, 15476 <__sfp+0x66>
   1546a:	4625      	mov	r5, r4
   1546c:	e7d7      	b.n	1541e <__sfp+0xe>
   1546e:	4628      	mov	r0, r5
   15470:	f000 f810 	bl	15494 <__sinit.part.0>
   15474:	e7d2      	b.n	1541c <__sfp+0xc>
   15476:	2104      	movs	r1, #4
   15478:	4630      	mov	r0, r6
   1547a:	f7ff ffb1 	bl	153e0 <__sfmoreglue>
   1547e:	4604      	mov	r4, r0
   15480:	6028      	str	r0, [r5, #0]
   15482:	2800      	cmp	r0, #0
   15484:	d1f1      	bne.n	1546a <__sfp+0x5a>
   15486:	230c      	movs	r3, #12
   15488:	6033      	str	r3, [r6, #0]
   1548a:	e7ea      	b.n	15462 <__sfp+0x52>
   1548c:	000178cc 	.word	0x000178cc
   15490:	ffff0001 	.word	0xffff0001

00015494 <__sinit.part.0>:
   15494:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15498:	4b33      	ldr	r3, [pc, #204]	; (15568 <__sinit.part.0+0xd4>)
   1549a:	4934      	ldr	r1, [pc, #208]	; (1556c <__sinit.part.0+0xd8>)
   1549c:	681a      	ldr	r2, [r3, #0]
   1549e:	6281      	str	r1, [r0, #40]	; 0x28
   154a0:	4290      	cmp	r0, r2
   154a2:	f04f 0300 	mov.w	r3, #0
   154a6:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
   154aa:	6503      	str	r3, [r0, #80]	; 0x50
   154ac:	bf04      	itt	eq
   154ae:	2301      	moveq	r3, #1
   154b0:	6183      	streq	r3, [r0, #24]
   154b2:	4605      	mov	r5, r0
   154b4:	f7ff ffac 	bl	15410 <__sfp>
   154b8:	6068      	str	r0, [r5, #4]
   154ba:	4628      	mov	r0, r5
   154bc:	f7ff ffa8 	bl	15410 <__sfp>
   154c0:	60a8      	str	r0, [r5, #8]
   154c2:	4628      	mov	r0, r5
   154c4:	f7ff ffa4 	bl	15410 <__sfp>
   154c8:	686e      	ldr	r6, [r5, #4]
   154ca:	60e8      	str	r0, [r5, #12]
   154cc:	2400      	movs	r4, #0
   154ce:	2304      	movs	r3, #4
   154d0:	60f3      	str	r3, [r6, #12]
   154d2:	6674      	str	r4, [r6, #100]	; 0x64
   154d4:	e9c6 4400 	strd	r4, r4, [r6]
   154d8:	60b4      	str	r4, [r6, #8]
   154da:	e9c6 4404 	strd	r4, r4, [r6, #16]
   154de:	61b4      	str	r4, [r6, #24]
   154e0:	4621      	mov	r1, r4
   154e2:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   154e6:	2208      	movs	r2, #8
   154e8:	f7fe ffbe 	bl	14468 <memset>
   154ec:	f8df b088 	ldr.w	fp, [pc, #136]	; 15578 <__sinit.part.0+0xe4>
   154f0:	68af      	ldr	r7, [r5, #8]
   154f2:	f8df a088 	ldr.w	sl, [pc, #136]	; 1557c <__sinit.part.0+0xe8>
   154f6:	f8df 9088 	ldr.w	r9, [pc, #136]	; 15580 <__sinit.part.0+0xec>
   154fa:	f8df 8088 	ldr.w	r8, [pc, #136]	; 15584 <__sinit.part.0+0xf0>
   154fe:	4b1c      	ldr	r3, [pc, #112]	; (15570 <__sinit.part.0+0xdc>)
   15500:	f8c6 8030 	str.w	r8, [r6, #48]	; 0x30
   15504:	e9c6 6b08 	strd	r6, fp, [r6, #32]
   15508:	e9c6 a90a 	strd	sl, r9, [r6, #40]	; 0x28
   1550c:	4621      	mov	r1, r4
   1550e:	60fb      	str	r3, [r7, #12]
   15510:	2208      	movs	r2, #8
   15512:	667c      	str	r4, [r7, #100]	; 0x64
   15514:	e9c7 4400 	strd	r4, r4, [r7]
   15518:	60bc      	str	r4, [r7, #8]
   1551a:	e9c7 4404 	strd	r4, r4, [r7, #16]
   1551e:	61bc      	str	r4, [r7, #24]
   15520:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   15524:	f7fe ffa0 	bl	14468 <memset>
   15528:	68ee      	ldr	r6, [r5, #12]
   1552a:	4b12      	ldr	r3, [pc, #72]	; (15574 <__sinit.part.0+0xe0>)
   1552c:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
   15530:	e9c7 7b08 	strd	r7, fp, [r7, #32]
   15534:	e9c7 a90a 	strd	sl, r9, [r7, #40]	; 0x28
   15538:	4621      	mov	r1, r4
   1553a:	60f3      	str	r3, [r6, #12]
   1553c:	6674      	str	r4, [r6, #100]	; 0x64
   1553e:	e9c6 4400 	strd	r4, r4, [r6]
   15542:	60b4      	str	r4, [r6, #8]
   15544:	e9c6 4404 	strd	r4, r4, [r6, #16]
   15548:	61b4      	str	r4, [r6, #24]
   1554a:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   1554e:	2208      	movs	r2, #8
   15550:	f7fe ff8a 	bl	14468 <memset>
   15554:	2301      	movs	r3, #1
   15556:	e9c6 6b08 	strd	r6, fp, [r6, #32]
   1555a:	e9c6 a90a 	strd	sl, r9, [r6, #40]	; 0x28
   1555e:	f8c6 8030 	str.w	r8, [r6, #48]	; 0x30
   15562:	61ab      	str	r3, [r5, #24]
   15564:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15568:	000178cc 	.word	0x000178cc
   1556c:	000153d1 	.word	0x000153d1
   15570:	00010009 	.word	0x00010009
   15574:	00020012 	.word	0x00020012
   15578:	000162c5 	.word	0x000162c5
   1557c:	000162ed 	.word	0x000162ed
   15580:	0001632d 	.word	0x0001632d
   15584:	0001634d 	.word	0x0001634d

00015588 <_cleanup>:
   15588:	4b02      	ldr	r3, [pc, #8]	; (15594 <_cleanup+0xc>)
   1558a:	4903      	ldr	r1, [pc, #12]	; (15598 <_cleanup+0x10>)
   1558c:	6818      	ldr	r0, [r3, #0]
   1558e:	f000 b84b 	b.w	15628 <_fwalk_reent>
   15592:	bf00      	nop
   15594:	000178cc 	.word	0x000178cc
   15598:	00015349 	.word	0x00015349

0001559c <__sinit>:
   1559c:	6983      	ldr	r3, [r0, #24]
   1559e:	b903      	cbnz	r3, 155a2 <__sinit+0x6>
   155a0:	e778      	b.n	15494 <__sinit.part.0>
   155a2:	4770      	bx	lr

000155a4 <__sfp_lock_acquire>:
   155a4:	4770      	bx	lr
   155a6:	bf00      	nop

000155a8 <__sfp_lock_release>:
   155a8:	4770      	bx	lr
   155aa:	bf00      	nop

000155ac <__sinit_lock_acquire>:
   155ac:	4770      	bx	lr
   155ae:	bf00      	nop

000155b0 <__sinit_lock_release>:
   155b0:	4770      	bx	lr
   155b2:	bf00      	nop

000155b4 <__fp_lock_all>:
   155b4:	4b02      	ldr	r3, [pc, #8]	; (155c0 <__fp_lock_all+0xc>)
   155b6:	4903      	ldr	r1, [pc, #12]	; (155c4 <__fp_lock_all+0x10>)
   155b8:	6818      	ldr	r0, [r3, #0]
   155ba:	f000 b80f 	b.w	155dc <_fwalk>
   155be:	bf00      	nop
   155c0:	2000054c 	.word	0x2000054c
   155c4:	000153cd 	.word	0x000153cd

000155c8 <__fp_unlock_all>:
   155c8:	4b02      	ldr	r3, [pc, #8]	; (155d4 <__fp_unlock_all+0xc>)
   155ca:	4903      	ldr	r1, [pc, #12]	; (155d8 <__fp_unlock_all+0x10>)
   155cc:	6818      	ldr	r0, [r3, #0]
   155ce:	f000 b805 	b.w	155dc <_fwalk>
   155d2:	bf00      	nop
   155d4:	2000054c 	.word	0x2000054c
   155d8:	000153dd 	.word	0x000153dd

000155dc <_fwalk>:
   155dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   155e0:	f110 0748 	adds.w	r7, r0, #72	; 0x48
   155e4:	d01b      	beq.n	1561e <_fwalk+0x42>
   155e6:	4688      	mov	r8, r1
   155e8:	2600      	movs	r6, #0
   155ea:	e9d7 5401 	ldrd	r5, r4, [r7, #4]
   155ee:	3d01      	subs	r5, #1
   155f0:	d40f      	bmi.n	15612 <_fwalk+0x36>
   155f2:	89a3      	ldrh	r3, [r4, #12]
   155f4:	2b01      	cmp	r3, #1
   155f6:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   155fa:	d906      	bls.n	1560a <_fwalk+0x2e>
   155fc:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
   15600:	3301      	adds	r3, #1
   15602:	4620      	mov	r0, r4
   15604:	d001      	beq.n	1560a <_fwalk+0x2e>
   15606:	47c0      	blx	r8
   15608:	4306      	orrs	r6, r0
   1560a:	1c6b      	adds	r3, r5, #1
   1560c:	f104 0468 	add.w	r4, r4, #104	; 0x68
   15610:	d1ef      	bne.n	155f2 <_fwalk+0x16>
   15612:	683f      	ldr	r7, [r7, #0]
   15614:	2f00      	cmp	r7, #0
   15616:	d1e8      	bne.n	155ea <_fwalk+0xe>
   15618:	4630      	mov	r0, r6
   1561a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1561e:	463e      	mov	r6, r7
   15620:	4630      	mov	r0, r6
   15622:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15626:	bf00      	nop

00015628 <_fwalk_reent>:
   15628:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1562c:	f110 0748 	adds.w	r7, r0, #72	; 0x48
   15630:	d01f      	beq.n	15672 <_fwalk_reent+0x4a>
   15632:	4688      	mov	r8, r1
   15634:	4606      	mov	r6, r0
   15636:	f04f 0900 	mov.w	r9, #0
   1563a:	e9d7 5401 	ldrd	r5, r4, [r7, #4]
   1563e:	3d01      	subs	r5, #1
   15640:	d411      	bmi.n	15666 <_fwalk_reent+0x3e>
   15642:	89a3      	ldrh	r3, [r4, #12]
   15644:	2b01      	cmp	r3, #1
   15646:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   1564a:	d908      	bls.n	1565e <_fwalk_reent+0x36>
   1564c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
   15650:	3301      	adds	r3, #1
   15652:	4621      	mov	r1, r4
   15654:	4630      	mov	r0, r6
   15656:	d002      	beq.n	1565e <_fwalk_reent+0x36>
   15658:	47c0      	blx	r8
   1565a:	ea49 0900 	orr.w	r9, r9, r0
   1565e:	1c6b      	adds	r3, r5, #1
   15660:	f104 0468 	add.w	r4, r4, #104	; 0x68
   15664:	d1ed      	bne.n	15642 <_fwalk_reent+0x1a>
   15666:	683f      	ldr	r7, [r7, #0]
   15668:	2f00      	cmp	r7, #0
   1566a:	d1e6      	bne.n	1563a <_fwalk_reent+0x12>
   1566c:	4648      	mov	r0, r9
   1566e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   15672:	46b9      	mov	r9, r7
   15674:	4648      	mov	r0, r9
   15676:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1567a:	bf00      	nop

0001567c <__swhatbuf_r>:
   1567c:	b570      	push	{r4, r5, r6, lr}
   1567e:	460c      	mov	r4, r1
   15680:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15684:	2900      	cmp	r1, #0
   15686:	b096      	sub	sp, #88	; 0x58
   15688:	4616      	mov	r6, r2
   1568a:	461d      	mov	r5, r3
   1568c:	db13      	blt.n	156b6 <__swhatbuf_r+0x3a>
   1568e:	466a      	mov	r2, sp
   15690:	f000 fe88 	bl	163a4 <_fstat_r>
   15694:	2800      	cmp	r0, #0
   15696:	db0e      	blt.n	156b6 <__swhatbuf_r+0x3a>
   15698:	9a01      	ldr	r2, [sp, #4]
   1569a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   1569e:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
   156a2:	fab2 f282 	clz	r2, r2
   156a6:	0952      	lsrs	r2, r2, #5
   156a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
   156ac:	2000      	movs	r0, #0
   156ae:	602a      	str	r2, [r5, #0]
   156b0:	6033      	str	r3, [r6, #0]
   156b2:	b016      	add	sp, #88	; 0x58
   156b4:	bd70      	pop	{r4, r5, r6, pc}
   156b6:	89a3      	ldrh	r3, [r4, #12]
   156b8:	2200      	movs	r2, #0
   156ba:	061b      	lsls	r3, r3, #24
   156bc:	602a      	str	r2, [r5, #0]
   156be:	d504      	bpl.n	156ca <__swhatbuf_r+0x4e>
   156c0:	2340      	movs	r3, #64	; 0x40
   156c2:	2000      	movs	r0, #0
   156c4:	6033      	str	r3, [r6, #0]
   156c6:	b016      	add	sp, #88	; 0x58
   156c8:	bd70      	pop	{r4, r5, r6, pc}
   156ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
   156ce:	2000      	movs	r0, #0
   156d0:	6033      	str	r3, [r6, #0]
   156d2:	b016      	add	sp, #88	; 0x58
   156d4:	bd70      	pop	{r4, r5, r6, pc}
   156d6:	bf00      	nop

000156d8 <__smakebuf_r>:
   156d8:	898a      	ldrh	r2, [r1, #12]
   156da:	0792      	lsls	r2, r2, #30
   156dc:	460b      	mov	r3, r1
   156de:	d506      	bpl.n	156ee <__smakebuf_r+0x16>
   156e0:	f101 0247 	add.w	r2, r1, #71	; 0x47
   156e4:	2101      	movs	r1, #1
   156e6:	601a      	str	r2, [r3, #0]
   156e8:	e9c3 2104 	strd	r2, r1, [r3, #16]
   156ec:	4770      	bx	lr
   156ee:	b570      	push	{r4, r5, r6, lr}
   156f0:	b082      	sub	sp, #8
   156f2:	ab01      	add	r3, sp, #4
   156f4:	466a      	mov	r2, sp
   156f6:	460c      	mov	r4, r1
   156f8:	4606      	mov	r6, r0
   156fa:	f7ff ffbf 	bl	1567c <__swhatbuf_r>
   156fe:	9900      	ldr	r1, [sp, #0]
   15700:	4605      	mov	r5, r0
   15702:	4630      	mov	r0, r6
   15704:	f7fe ff56 	bl	145b4 <_malloc_r>
   15708:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1570c:	b170      	cbz	r0, 1572c <__smakebuf_r+0x54>
   1570e:	4916      	ldr	r1, [pc, #88]	; (15768 <__smakebuf_r+0x90>)
   15710:	62b1      	str	r1, [r6, #40]	; 0x28
   15712:	9a01      	ldr	r2, [sp, #4]
   15714:	9900      	ldr	r1, [sp, #0]
   15716:	6020      	str	r0, [r4, #0]
   15718:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1571c:	81a3      	strh	r3, [r4, #12]
   1571e:	e9c4 0104 	strd	r0, r1, [r4, #16]
   15722:	b98a      	cbnz	r2, 15748 <__smakebuf_r+0x70>
   15724:	432b      	orrs	r3, r5
   15726:	81a3      	strh	r3, [r4, #12]
   15728:	b002      	add	sp, #8
   1572a:	bd70      	pop	{r4, r5, r6, pc}
   1572c:	059a      	lsls	r2, r3, #22
   1572e:	d4fb      	bmi.n	15728 <__smakebuf_r+0x50>
   15730:	f023 0303 	bic.w	r3, r3, #3
   15734:	f104 0247 	add.w	r2, r4, #71	; 0x47
   15738:	f043 0302 	orr.w	r3, r3, #2
   1573c:	2101      	movs	r1, #1
   1573e:	81a3      	strh	r3, [r4, #12]
   15740:	6022      	str	r2, [r4, #0]
   15742:	e9c4 2104 	strd	r2, r1, [r4, #16]
   15746:	e7ef      	b.n	15728 <__smakebuf_r+0x50>
   15748:	4630      	mov	r0, r6
   1574a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   1574e:	f000 ffc1 	bl	166d4 <_isatty_r>
   15752:	b910      	cbnz	r0, 1575a <__smakebuf_r+0x82>
   15754:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15758:	e7e4      	b.n	15724 <__smakebuf_r+0x4c>
   1575a:	89a3      	ldrh	r3, [r4, #12]
   1575c:	f023 0303 	bic.w	r3, r3, #3
   15760:	f043 0301 	orr.w	r3, r3, #1
   15764:	b21b      	sxth	r3, r3
   15766:	e7dd      	b.n	15724 <__smakebuf_r+0x4c>
   15768:	000153d1 	.word	0x000153d1

0001576c <__malloc_lock>:
   1576c:	4770      	bx	lr
   1576e:	bf00      	nop

00015770 <__malloc_unlock>:
   15770:	4770      	bx	lr
   15772:	bf00      	nop

00015774 <__ssputs_r>:
   15774:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15778:	688e      	ldr	r6, [r1, #8]
   1577a:	461d      	mov	r5, r3
   1577c:	42ae      	cmp	r6, r5
   1577e:	460c      	mov	r4, r1
   15780:	680b      	ldr	r3, [r1, #0]
   15782:	4617      	mov	r7, r2
   15784:	d836      	bhi.n	157f4 <__ssputs_r+0x80>
   15786:	4680      	mov	r8, r0
   15788:	8988      	ldrh	r0, [r1, #12]
   1578a:	f410 6f90 	tst.w	r0, #1152	; 0x480
   1578e:	d10e      	bne.n	157ae <__ssputs_r+0x3a>
   15790:	4635      	mov	r5, r6
   15792:	4618      	mov	r0, r3
   15794:	462a      	mov	r2, r5
   15796:	4639      	mov	r1, r7
   15798:	f001 f81a 	bl	167d0 <memmove>
   1579c:	68a2      	ldr	r2, [r4, #8]
   1579e:	6823      	ldr	r3, [r4, #0]
   157a0:	1b96      	subs	r6, r2, r6
   157a2:	442b      	add	r3, r5
   157a4:	60a6      	str	r6, [r4, #8]
   157a6:	6023      	str	r3, [r4, #0]
   157a8:	2000      	movs	r0, #0
   157aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   157ae:	e9d1 1604 	ldrd	r1, r6, [r1, #16]
   157b2:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   157b6:	eba3 0901 	sub.w	r9, r3, r1
   157ba:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
   157be:	1c6b      	adds	r3, r5, #1
   157c0:	1076      	asrs	r6, r6, #1
   157c2:	444b      	add	r3, r9
   157c4:	42b3      	cmp	r3, r6
   157c6:	4632      	mov	r2, r6
   157c8:	bf84      	itt	hi
   157ca:	461e      	movhi	r6, r3
   157cc:	4632      	movhi	r2, r6
   157ce:	0543      	lsls	r3, r0, #21
   157d0:	d512      	bpl.n	157f8 <__ssputs_r+0x84>
   157d2:	4611      	mov	r1, r2
   157d4:	4640      	mov	r0, r8
   157d6:	f7fe feed 	bl	145b4 <_malloc_r>
   157da:	4682      	mov	sl, r0
   157dc:	b300      	cbz	r0, 15820 <__ssputs_r+0xac>
   157de:	464a      	mov	r2, r9
   157e0:	6921      	ldr	r1, [r4, #16]
   157e2:	f7fe fda7 	bl	14334 <memcpy>
   157e6:	89a3      	ldrh	r3, [r4, #12]
   157e8:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   157ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   157f0:	81a3      	strh	r3, [r4, #12]
   157f2:	e006      	b.n	15802 <__ssputs_r+0x8e>
   157f4:	462e      	mov	r6, r5
   157f6:	e7cc      	b.n	15792 <__ssputs_r+0x1e>
   157f8:	4640      	mov	r0, r8
   157fa:	f001 f851 	bl	168a0 <_realloc_r>
   157fe:	4682      	mov	sl, r0
   15800:	b150      	cbz	r0, 15818 <__ssputs_r+0xa4>
   15802:	eba6 0209 	sub.w	r2, r6, r9
   15806:	eb0a 0309 	add.w	r3, sl, r9
   1580a:	6166      	str	r6, [r4, #20]
   1580c:	f8c4 a010 	str.w	sl, [r4, #16]
   15810:	6023      	str	r3, [r4, #0]
   15812:	60a2      	str	r2, [r4, #8]
   15814:	462e      	mov	r6, r5
   15816:	e7bc      	b.n	15792 <__ssputs_r+0x1e>
   15818:	6921      	ldr	r1, [r4, #16]
   1581a:	4640      	mov	r0, r8
   1581c:	f7fe fe74 	bl	14508 <_free_r>
   15820:	230c      	movs	r3, #12
   15822:	f8c8 3000 	str.w	r3, [r8]
   15826:	89a3      	ldrh	r3, [r4, #12]
   15828:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1582c:	81a3      	strh	r3, [r4, #12]
   1582e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15832:	e7ba      	b.n	157aa <__ssputs_r+0x36>

00015834 <__ssprint_r>:
   15834:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15838:	6893      	ldr	r3, [r2, #8]
   1583a:	b083      	sub	sp, #12
   1583c:	4690      	mov	r8, r2
   1583e:	2b00      	cmp	r3, #0
   15840:	d06d      	beq.n	1591e <__ssprint_r+0xea>
   15842:	6817      	ldr	r7, [r2, #0]
   15844:	688d      	ldr	r5, [r1, #8]
   15846:	4682      	mov	sl, r0
   15848:	460c      	mov	r4, r1
   1584a:	6808      	ldr	r0, [r1, #0]
   1584c:	3708      	adds	r7, #8
   1584e:	e043      	b.n	158d8 <__ssprint_r+0xa4>
   15850:	89a3      	ldrh	r3, [r4, #12]
   15852:	f413 6f90 	tst.w	r3, #1152	; 0x480
   15856:	d02e      	beq.n	158b6 <__ssprint_r+0x82>
   15858:	e9d4 1504 	ldrd	r1, r5, [r4, #16]
   1585c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   15860:	eba0 0b01 	sub.w	fp, r0, r1
   15864:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   15868:	eb0b 0006 	add.w	r0, fp, r6
   1586c:	106d      	asrs	r5, r5, #1
   1586e:	3001      	adds	r0, #1
   15870:	42a8      	cmp	r0, r5
   15872:	462a      	mov	r2, r5
   15874:	bf84      	itt	hi
   15876:	4605      	movhi	r5, r0
   15878:	462a      	movhi	r2, r5
   1587a:	055b      	lsls	r3, r3, #21
   1587c:	d536      	bpl.n	158ec <__ssprint_r+0xb8>
   1587e:	4611      	mov	r1, r2
   15880:	4650      	mov	r0, sl
   15882:	f7fe fe97 	bl	145b4 <_malloc_r>
   15886:	2800      	cmp	r0, #0
   15888:	d03a      	beq.n	15900 <__ssprint_r+0xcc>
   1588a:	465a      	mov	r2, fp
   1588c:	6921      	ldr	r1, [r4, #16]
   1588e:	9001      	str	r0, [sp, #4]
   15890:	f7fe fd50 	bl	14334 <memcpy>
   15894:	89a2      	ldrh	r2, [r4, #12]
   15896:	9b01      	ldr	r3, [sp, #4]
   15898:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   1589c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   158a0:	81a2      	strh	r2, [r4, #12]
   158a2:	eba5 020b 	sub.w	r2, r5, fp
   158a6:	eb03 000b 	add.w	r0, r3, fp
   158aa:	6165      	str	r5, [r4, #20]
   158ac:	6123      	str	r3, [r4, #16]
   158ae:	6020      	str	r0, [r4, #0]
   158b0:	60a2      	str	r2, [r4, #8]
   158b2:	4635      	mov	r5, r6
   158b4:	46b3      	mov	fp, r6
   158b6:	465a      	mov	r2, fp
   158b8:	4649      	mov	r1, r9
   158ba:	f000 ff89 	bl	167d0 <memmove>
   158be:	f8d8 3008 	ldr.w	r3, [r8, #8]
   158c2:	68a2      	ldr	r2, [r4, #8]
   158c4:	6820      	ldr	r0, [r4, #0]
   158c6:	1b55      	subs	r5, r2, r5
   158c8:	4458      	add	r0, fp
   158ca:	1b9e      	subs	r6, r3, r6
   158cc:	60a5      	str	r5, [r4, #8]
   158ce:	6020      	str	r0, [r4, #0]
   158d0:	f8c8 6008 	str.w	r6, [r8, #8]
   158d4:	b31e      	cbz	r6, 1591e <__ssprint_r+0xea>
   158d6:	3708      	adds	r7, #8
   158d8:	e957 9602 	ldrd	r9, r6, [r7, #-8]
   158dc:	46ab      	mov	fp, r5
   158de:	2e00      	cmp	r6, #0
   158e0:	d0f9      	beq.n	158d6 <__ssprint_r+0xa2>
   158e2:	42ae      	cmp	r6, r5
   158e4:	d2b4      	bcs.n	15850 <__ssprint_r+0x1c>
   158e6:	4635      	mov	r5, r6
   158e8:	46b3      	mov	fp, r6
   158ea:	e7e4      	b.n	158b6 <__ssprint_r+0x82>
   158ec:	4650      	mov	r0, sl
   158ee:	f000 ffd7 	bl	168a0 <_realloc_r>
   158f2:	4603      	mov	r3, r0
   158f4:	2800      	cmp	r0, #0
   158f6:	d1d4      	bne.n	158a2 <__ssprint_r+0x6e>
   158f8:	6921      	ldr	r1, [r4, #16]
   158fa:	4650      	mov	r0, sl
   158fc:	f7fe fe04 	bl	14508 <_free_r>
   15900:	230c      	movs	r3, #12
   15902:	f8ca 3000 	str.w	r3, [sl]
   15906:	89a3      	ldrh	r3, [r4, #12]
   15908:	2200      	movs	r2, #0
   1590a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1590e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15912:	81a3      	strh	r3, [r4, #12]
   15914:	e9c8 2201 	strd	r2, r2, [r8, #4]
   15918:	b003      	add	sp, #12
   1591a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1591e:	2000      	movs	r0, #0
   15920:	f8c8 0004 	str.w	r0, [r8, #4]
   15924:	b003      	add	sp, #12
   15926:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1592a:	bf00      	nop

0001592c <_svfiprintf_r>:
   1592c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15930:	4690      	mov	r8, r2
   15932:	898a      	ldrh	r2, [r1, #12]
   15934:	b09f      	sub	sp, #124	; 0x7c
   15936:	0614      	lsls	r4, r2, #24
   15938:	468b      	mov	fp, r1
   1593a:	9002      	str	r0, [sp, #8]
   1593c:	d503      	bpl.n	15946 <_svfiprintf_r+0x1a>
   1593e:	690a      	ldr	r2, [r1, #16]
   15940:	2a00      	cmp	r2, #0
   15942:	f000 810b 	beq.w	15b5c <_svfiprintf_r+0x230>
   15946:	9305      	str	r3, [sp, #20]
   15948:	2330      	movs	r3, #48	; 0x30
   1594a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
   1594e:	f898 3000 	ldrb.w	r3, [r8]
   15952:	4e8e      	ldr	r6, [pc, #568]	; (15b8c <_svfiprintf_r+0x260>)
   15954:	2100      	movs	r1, #0
   15956:	2220      	movs	r2, #32
   15958:	910b      	str	r1, [sp, #44]	; 0x2c
   1595a:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   1595e:	2701      	movs	r7, #1
   15960:	2b00      	cmp	r3, #0
   15962:	f000 8084 	beq.w	15a6e <_svfiprintf_r+0x142>
   15966:	2b25      	cmp	r3, #37	; 0x25
   15968:	f000 80f6 	beq.w	15b58 <_svfiprintf_r+0x22c>
   1596c:	4645      	mov	r5, r8
   1596e:	e003      	b.n	15978 <_svfiprintf_r+0x4c>
   15970:	2b25      	cmp	r3, #37	; 0x25
   15972:	f000 8086 	beq.w	15a82 <_svfiprintf_r+0x156>
   15976:	4625      	mov	r5, r4
   15978:	786b      	ldrb	r3, [r5, #1]
   1597a:	1c6c      	adds	r4, r5, #1
   1597c:	2b00      	cmp	r3, #0
   1597e:	d1f7      	bne.n	15970 <_svfiprintf_r+0x44>
   15980:	ebb4 0a08 	subs.w	sl, r4, r8
   15984:	d073      	beq.n	15a6e <_svfiprintf_r+0x142>
   15986:	4642      	mov	r2, r8
   15988:	4653      	mov	r3, sl
   1598a:	4659      	mov	r1, fp
   1598c:	9802      	ldr	r0, [sp, #8]
   1598e:	f7ff fef1 	bl	15774 <__ssputs_r>
   15992:	3001      	adds	r0, #1
   15994:	d06b      	beq.n	15a6e <_svfiprintf_r+0x142>
   15996:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15998:	786a      	ldrb	r2, [r5, #1]
   1599a:	4453      	add	r3, sl
   1599c:	930b      	str	r3, [sp, #44]	; 0x2c
   1599e:	2a00      	cmp	r2, #0
   159a0:	d065      	beq.n	15a6e <_svfiprintf_r+0x142>
   159a2:	2300      	movs	r3, #0
   159a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   159a8:	3401      	adds	r4, #1
   159aa:	9306      	str	r3, [sp, #24]
   159ac:	e9cd 3308 	strd	r3, r3, [sp, #32]
   159b0:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
   159b4:	931c      	str	r3, [sp, #112]	; 0x70
   159b6:	9207      	str	r2, [sp, #28]
   159b8:	e005      	b.n	159c6 <_svfiprintf_r+0x9a>
   159ba:	9a06      	ldr	r2, [sp, #24]
   159bc:	fa07 f303 	lsl.w	r3, r7, r3
   159c0:	4313      	orrs	r3, r2
   159c2:	462c      	mov	r4, r5
   159c4:	9306      	str	r3, [sp, #24]
   159c6:	4625      	mov	r5, r4
   159c8:	2205      	movs	r2, #5
   159ca:	f815 1b01 	ldrb.w	r1, [r5], #1
   159ce:	4630      	mov	r0, r6
   159d0:	f000 feae 	bl	16730 <memchr>
   159d4:	46aa      	mov	sl, r5
   159d6:	1b83      	subs	r3, r0, r6
   159d8:	2800      	cmp	r0, #0
   159da:	d1ee      	bne.n	159ba <_svfiprintf_r+0x8e>
   159dc:	9b06      	ldr	r3, [sp, #24]
   159de:	06d9      	lsls	r1, r3, #27
   159e0:	bf44      	itt	mi
   159e2:	2220      	movmi	r2, #32
   159e4:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   159e8:	7821      	ldrb	r1, [r4, #0]
   159ea:	071a      	lsls	r2, r3, #28
   159ec:	bf44      	itt	mi
   159ee:	222b      	movmi	r2, #43	; 0x2b
   159f0:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   159f4:	292a      	cmp	r1, #42	; 0x2a
   159f6:	d148      	bne.n	15a8a <_svfiprintf_r+0x15e>
   159f8:	9a05      	ldr	r2, [sp, #20]
   159fa:	6811      	ldr	r1, [r2, #0]
   159fc:	3204      	adds	r2, #4
   159fe:	2900      	cmp	r1, #0
   15a00:	9205      	str	r2, [sp, #20]
   15a02:	db7e      	blt.n	15b02 <_svfiprintf_r+0x1d6>
   15a04:	9109      	str	r1, [sp, #36]	; 0x24
   15a06:	7861      	ldrb	r1, [r4, #1]
   15a08:	1ca5      	adds	r5, r4, #2
   15a0a:	292e      	cmp	r1, #46	; 0x2e
   15a0c:	d056      	beq.n	15abc <_svfiprintf_r+0x190>
   15a0e:	4c60      	ldr	r4, [pc, #384]	; (15b90 <_svfiprintf_r+0x264>)
   15a10:	2203      	movs	r2, #3
   15a12:	4620      	mov	r0, r4
   15a14:	f000 fe8c 	bl	16730 <memchr>
   15a18:	2800      	cmp	r0, #0
   15a1a:	d068      	beq.n	15aee <_svfiprintf_r+0x1c2>
   15a1c:	1b00      	subs	r0, r0, r4
   15a1e:	9b06      	ldr	r3, [sp, #24]
   15a20:	2440      	movs	r4, #64	; 0x40
   15a22:	fa04 f000 	lsl.w	r0, r4, r0
   15a26:	4303      	orrs	r3, r0
   15a28:	9306      	str	r3, [sp, #24]
   15a2a:	f105 0801 	add.w	r8, r5, #1
   15a2e:	7829      	ldrb	r1, [r5, #0]
   15a30:	4858      	ldr	r0, [pc, #352]	; (15b94 <_svfiprintf_r+0x268>)
   15a32:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   15a36:	2206      	movs	r2, #6
   15a38:	f000 fe7a 	bl	16730 <memchr>
   15a3c:	2800      	cmp	r0, #0
   15a3e:	d066      	beq.n	15b0e <_svfiprintf_r+0x1e2>
   15a40:	4b55      	ldr	r3, [pc, #340]	; (15b98 <_svfiprintf_r+0x26c>)
   15a42:	2b00      	cmp	r3, #0
   15a44:	d056      	beq.n	15af4 <_svfiprintf_r+0x1c8>
   15a46:	ab05      	add	r3, sp, #20
   15a48:	9300      	str	r3, [sp, #0]
   15a4a:	465a      	mov	r2, fp
   15a4c:	4b53      	ldr	r3, [pc, #332]	; (15b9c <_svfiprintf_r+0x270>)
   15a4e:	9802      	ldr	r0, [sp, #8]
   15a50:	a906      	add	r1, sp, #24
   15a52:	f3af 8000 	nop.w
   15a56:	4681      	mov	r9, r0
   15a58:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   15a5c:	d007      	beq.n	15a6e <_svfiprintf_r+0x142>
   15a5e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15a60:	444b      	add	r3, r9
   15a62:	930b      	str	r3, [sp, #44]	; 0x2c
   15a64:	f898 3000 	ldrb.w	r3, [r8]
   15a68:	2b00      	cmp	r3, #0
   15a6a:	f47f af7c 	bne.w	15966 <_svfiprintf_r+0x3a>
   15a6e:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15a72:	065b      	lsls	r3, r3, #25
   15a74:	bf54      	ite	pl
   15a76:	980b      	ldrpl	r0, [sp, #44]	; 0x2c
   15a78:	f04f 30ff 	movmi.w	r0, #4294967295	; 0xffffffff
   15a7c:	b01f      	add	sp, #124	; 0x7c
   15a7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15a82:	ebb4 0a08 	subs.w	sl, r4, r8
   15a86:	d08c      	beq.n	159a2 <_svfiprintf_r+0x76>
   15a88:	e77d      	b.n	15986 <_svfiprintf_r+0x5a>
   15a8a:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15a8e:	2a09      	cmp	r2, #9
   15a90:	bf88      	it	hi
   15a92:	46a2      	movhi	sl, r4
   15a94:	d8b9      	bhi.n	15a0a <_svfiprintf_r+0xde>
   15a96:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15a98:	e001      	b.n	15a9e <_svfiprintf_r+0x172>
   15a9a:	462c      	mov	r4, r5
   15a9c:	3501      	adds	r5, #1
   15a9e:	7829      	ldrb	r1, [r5, #0]
   15aa0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15aa4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   15aa8:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15aac:	2a09      	cmp	r2, #9
   15aae:	46aa      	mov	sl, r5
   15ab0:	d9f3      	bls.n	15a9a <_svfiprintf_r+0x16e>
   15ab2:	292e      	cmp	r1, #46	; 0x2e
   15ab4:	f104 0502 	add.w	r5, r4, #2
   15ab8:	9309      	str	r3, [sp, #36]	; 0x24
   15aba:	d1a8      	bne.n	15a0e <_svfiprintf_r+0xe2>
   15abc:	f89a 1001 	ldrb.w	r1, [sl, #1]
   15ac0:	292a      	cmp	r1, #42	; 0x2a
   15ac2:	d12e      	bne.n	15b22 <_svfiprintf_r+0x1f6>
   15ac4:	9b05      	ldr	r3, [sp, #20]
   15ac6:	f89a 1002 	ldrb.w	r1, [sl, #2]
   15aca:	681a      	ldr	r2, [r3, #0]
   15acc:	9207      	str	r2, [sp, #28]
   15ace:	3304      	adds	r3, #4
   15ad0:	2a00      	cmp	r2, #0
   15ad2:	9305      	str	r3, [sp, #20]
   15ad4:	f10a 0503 	add.w	r5, sl, #3
   15ad8:	f10a 0302 	add.w	r3, sl, #2
   15adc:	db37      	blt.n	15b4e <_svfiprintf_r+0x222>
   15ade:	4c2c      	ldr	r4, [pc, #176]	; (15b90 <_svfiprintf_r+0x264>)
   15ae0:	2203      	movs	r2, #3
   15ae2:	4620      	mov	r0, r4
   15ae4:	469a      	mov	sl, r3
   15ae6:	f000 fe23 	bl	16730 <memchr>
   15aea:	2800      	cmp	r0, #0
   15aec:	d196      	bne.n	15a1c <_svfiprintf_r+0xf0>
   15aee:	46a8      	mov	r8, r5
   15af0:	4655      	mov	r5, sl
   15af2:	e79c      	b.n	15a2e <_svfiprintf_r+0x102>
   15af4:	9b05      	ldr	r3, [sp, #20]
   15af6:	3307      	adds	r3, #7
   15af8:	f023 0307 	bic.w	r3, r3, #7
   15afc:	3308      	adds	r3, #8
   15afe:	9305      	str	r3, [sp, #20]
   15b00:	e7ad      	b.n	15a5e <_svfiprintf_r+0x132>
   15b02:	4249      	negs	r1, r1
   15b04:	f043 0302 	orr.w	r3, r3, #2
   15b08:	9109      	str	r1, [sp, #36]	; 0x24
   15b0a:	9306      	str	r3, [sp, #24]
   15b0c:	e77b      	b.n	15a06 <_svfiprintf_r+0xda>
   15b0e:	ab05      	add	r3, sp, #20
   15b10:	9300      	str	r3, [sp, #0]
   15b12:	465a      	mov	r2, fp
   15b14:	4b21      	ldr	r3, [pc, #132]	; (15b9c <_svfiprintf_r+0x270>)
   15b16:	9802      	ldr	r0, [sp, #8]
   15b18:	a906      	add	r1, sp, #24
   15b1a:	f000 fa87 	bl	1602c <_printf_i>
   15b1e:	4681      	mov	r9, r0
   15b20:	e79a      	b.n	15a58 <_svfiprintf_r+0x12c>
   15b22:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15b26:	2300      	movs	r3, #0
   15b28:	2a09      	cmp	r2, #9
   15b2a:	9307      	str	r3, [sp, #28]
   15b2c:	d901      	bls.n	15b32 <_svfiprintf_r+0x206>
   15b2e:	e023      	b.n	15b78 <_svfiprintf_r+0x24c>
   15b30:	4655      	mov	r5, sl
   15b32:	7869      	ldrb	r1, [r5, #1]
   15b34:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15b38:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   15b3c:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15b40:	2a09      	cmp	r2, #9
   15b42:	f105 0a01 	add.w	sl, r5, #1
   15b46:	d9f3      	bls.n	15b30 <_svfiprintf_r+0x204>
   15b48:	3502      	adds	r5, #2
   15b4a:	9307      	str	r3, [sp, #28]
   15b4c:	e75f      	b.n	15a0e <_svfiprintf_r+0xe2>
   15b4e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15b52:	469a      	mov	sl, r3
   15b54:	9207      	str	r2, [sp, #28]
   15b56:	e75a      	b.n	15a0e <_svfiprintf_r+0xe2>
   15b58:	4644      	mov	r4, r8
   15b5a:	e722      	b.n	159a2 <_svfiprintf_r+0x76>
   15b5c:	2140      	movs	r1, #64	; 0x40
   15b5e:	9303      	str	r3, [sp, #12]
   15b60:	f7fe fd28 	bl	145b4 <_malloc_r>
   15b64:	9b03      	ldr	r3, [sp, #12]
   15b66:	f8cb 0000 	str.w	r0, [fp]
   15b6a:	f8cb 0010 	str.w	r0, [fp, #16]
   15b6e:	b130      	cbz	r0, 15b7e <_svfiprintf_r+0x252>
   15b70:	2240      	movs	r2, #64	; 0x40
   15b72:	f8cb 2014 	str.w	r2, [fp, #20]
   15b76:	e6e6      	b.n	15946 <_svfiprintf_r+0x1a>
   15b78:	46aa      	mov	sl, r5
   15b7a:	3501      	adds	r5, #1
   15b7c:	e747      	b.n	15a0e <_svfiprintf_r+0xe2>
   15b7e:	9a02      	ldr	r2, [sp, #8]
   15b80:	230c      	movs	r3, #12
   15b82:	6013      	str	r3, [r2, #0]
   15b84:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15b88:	e778      	b.n	15a7c <_svfiprintf_r+0x150>
   15b8a:	bf00      	nop
   15b8c:	00017930 	.word	0x00017930
   15b90:	00017938 	.word	0x00017938
   15b94:	0001793c 	.word	0x0001793c
   15b98:	00000000 	.word	0x00000000
   15b9c:	00015775 	.word	0x00015775

00015ba0 <__sfputc_r>:
   15ba0:	6893      	ldr	r3, [r2, #8]
   15ba2:	3b01      	subs	r3, #1
   15ba4:	2b00      	cmp	r3, #0
   15ba6:	6093      	str	r3, [r2, #8]
   15ba8:	da0f      	bge.n	15bca <__sfputc_r+0x2a>
   15baa:	b410      	push	{r4}
   15bac:	6994      	ldr	r4, [r2, #24]
   15bae:	42a3      	cmp	r3, r4
   15bb0:	db08      	blt.n	15bc4 <__sfputc_r+0x24>
   15bb2:	290a      	cmp	r1, #10
   15bb4:	d006      	beq.n	15bc4 <__sfputc_r+0x24>
   15bb6:	6813      	ldr	r3, [r2, #0]
   15bb8:	1c58      	adds	r0, r3, #1
   15bba:	6010      	str	r0, [r2, #0]
   15bbc:	7019      	strb	r1, [r3, #0]
   15bbe:	4608      	mov	r0, r1
   15bc0:	bc10      	pop	{r4}
   15bc2:	4770      	bx	lr
   15bc4:	bc10      	pop	{r4}
   15bc6:	f7ff ba49 	b.w	1505c <__swbuf_r>
   15bca:	6813      	ldr	r3, [r2, #0]
   15bcc:	1c58      	adds	r0, r3, #1
   15bce:	6010      	str	r0, [r2, #0]
   15bd0:	7019      	strb	r1, [r3, #0]
   15bd2:	4608      	mov	r0, r1
   15bd4:	4770      	bx	lr
   15bd6:	bf00      	nop

00015bd8 <__sfputs_r>:
   15bd8:	b19b      	cbz	r3, 15c02 <__sfputs_r+0x2a>
   15bda:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15bdc:	4413      	add	r3, r2
   15bde:	460f      	mov	r7, r1
   15be0:	4606      	mov	r6, r0
   15be2:	1e5d      	subs	r5, r3, #1
   15be4:	1e54      	subs	r4, r2, #1
   15be6:	e001      	b.n	15bec <__sfputs_r+0x14>
   15be8:	42ac      	cmp	r4, r5
   15bea:	d008      	beq.n	15bfe <__sfputs_r+0x26>
   15bec:	463a      	mov	r2, r7
   15bee:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   15bf2:	4630      	mov	r0, r6
   15bf4:	f7ff ffd4 	bl	15ba0 <__sfputc_r>
   15bf8:	1c43      	adds	r3, r0, #1
   15bfa:	d1f5      	bne.n	15be8 <__sfputs_r+0x10>
   15bfc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15bfe:	2000      	movs	r0, #0
   15c00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15c02:	2000      	movs	r0, #0
   15c04:	4770      	bx	lr
   15c06:	bf00      	nop

00015c08 <__sprint_r>:
   15c08:	6893      	ldr	r3, [r2, #8]
   15c0a:	b510      	push	{r4, lr}
   15c0c:	4614      	mov	r4, r2
   15c0e:	b913      	cbnz	r3, 15c16 <__sprint_r+0xe>
   15c10:	6053      	str	r3, [r2, #4]
   15c12:	4618      	mov	r0, r3
   15c14:	bd10      	pop	{r4, pc}
   15c16:	f000 fbd9 	bl	163cc <__sfvwrite_r>
   15c1a:	2300      	movs	r3, #0
   15c1c:	e9c4 3301 	strd	r3, r3, [r4, #4]
   15c20:	bd10      	pop	{r4, pc}
   15c22:	bf00      	nop

00015c24 <_vfiprintf_r>:
   15c24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15c28:	b09f      	sub	sp, #124	; 0x7c
   15c2a:	468b      	mov	fp, r1
   15c2c:	4690      	mov	r8, r2
   15c2e:	461c      	mov	r4, r3
   15c30:	9003      	str	r0, [sp, #12]
   15c32:	b118      	cbz	r0, 15c3c <_vfiprintf_r+0x18>
   15c34:	6983      	ldr	r3, [r0, #24]
   15c36:	2b00      	cmp	r3, #0
   15c38:	f000 80b7 	beq.w	15daa <_vfiprintf_r+0x186>
   15c3c:	4ba2      	ldr	r3, [pc, #648]	; (15ec8 <_vfiprintf_r+0x2a4>)
   15c3e:	459b      	cmp	fp, r3
   15c40:	f000 80b9 	beq.w	15db6 <_vfiprintf_r+0x192>
   15c44:	4ba1      	ldr	r3, [pc, #644]	; (15ecc <_vfiprintf_r+0x2a8>)
   15c46:	459b      	cmp	fp, r3
   15c48:	f000 80c7 	beq.w	15dda <_vfiprintf_r+0x1b6>
   15c4c:	4ba0      	ldr	r3, [pc, #640]	; (15ed0 <_vfiprintf_r+0x2ac>)
   15c4e:	459b      	cmp	fp, r3
   15c50:	bf04      	itt	eq
   15c52:	9b03      	ldreq	r3, [sp, #12]
   15c54:	f8d3 b00c 	ldreq.w	fp, [r3, #12]
   15c58:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15c5c:	0718      	lsls	r0, r3, #28
   15c5e:	f140 80b2 	bpl.w	15dc6 <_vfiprintf_r+0x1a2>
   15c62:	f8db 3010 	ldr.w	r3, [fp, #16]
   15c66:	2b00      	cmp	r3, #0
   15c68:	f000 80ad 	beq.w	15dc6 <_vfiprintf_r+0x1a2>
   15c6c:	2330      	movs	r3, #48	; 0x30
   15c6e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
   15c72:	f898 3000 	ldrb.w	r3, [r8]
   15c76:	9405      	str	r4, [sp, #20]
   15c78:	2100      	movs	r1, #0
   15c7a:	2220      	movs	r2, #32
   15c7c:	910b      	str	r1, [sp, #44]	; 0x2c
   15c7e:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   15c82:	4e94      	ldr	r6, [pc, #592]	; (15ed4 <_vfiprintf_r+0x2b0>)
   15c84:	2701      	movs	r7, #1
   15c86:	2b00      	cmp	r3, #0
   15c88:	f000 8087 	beq.w	15d9a <_vfiprintf_r+0x176>
   15c8c:	2b25      	cmp	r3, #37	; 0x25
   15c8e:	f000 8115 	beq.w	15ebc <_vfiprintf_r+0x298>
   15c92:	4645      	mov	r5, r8
   15c94:	e003      	b.n	15c9e <_vfiprintf_r+0x7a>
   15c96:	2b25      	cmp	r3, #37	; 0x25
   15c98:	f000 80a3 	beq.w	15de2 <_vfiprintf_r+0x1be>
   15c9c:	4625      	mov	r5, r4
   15c9e:	786b      	ldrb	r3, [r5, #1]
   15ca0:	1c6c      	adds	r4, r5, #1
   15ca2:	2b00      	cmp	r3, #0
   15ca4:	d1f7      	bne.n	15c96 <_vfiprintf_r+0x72>
   15ca6:	ebb4 0a08 	subs.w	sl, r4, r8
   15caa:	d076      	beq.n	15d9a <_vfiprintf_r+0x176>
   15cac:	4642      	mov	r2, r8
   15cae:	4653      	mov	r3, sl
   15cb0:	4659      	mov	r1, fp
   15cb2:	9803      	ldr	r0, [sp, #12]
   15cb4:	f7ff ff90 	bl	15bd8 <__sfputs_r>
   15cb8:	3001      	adds	r0, #1
   15cba:	d06e      	beq.n	15d9a <_vfiprintf_r+0x176>
   15cbc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15cbe:	786a      	ldrb	r2, [r5, #1]
   15cc0:	4453      	add	r3, sl
   15cc2:	930b      	str	r3, [sp, #44]	; 0x2c
   15cc4:	2a00      	cmp	r2, #0
   15cc6:	d068      	beq.n	15d9a <_vfiprintf_r+0x176>
   15cc8:	2300      	movs	r3, #0
   15cca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15cce:	3401      	adds	r4, #1
   15cd0:	9306      	str	r3, [sp, #24]
   15cd2:	e9cd 3308 	strd	r3, r3, [sp, #32]
   15cd6:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
   15cda:	931c      	str	r3, [sp, #112]	; 0x70
   15cdc:	9207      	str	r2, [sp, #28]
   15cde:	e005      	b.n	15cec <_vfiprintf_r+0xc8>
   15ce0:	9a06      	ldr	r2, [sp, #24]
   15ce2:	fa07 f303 	lsl.w	r3, r7, r3
   15ce6:	4313      	orrs	r3, r2
   15ce8:	462c      	mov	r4, r5
   15cea:	9306      	str	r3, [sp, #24]
   15cec:	4625      	mov	r5, r4
   15cee:	2205      	movs	r2, #5
   15cf0:	f815 1b01 	ldrb.w	r1, [r5], #1
   15cf4:	4630      	mov	r0, r6
   15cf6:	f000 fd1b 	bl	16730 <memchr>
   15cfa:	46aa      	mov	sl, r5
   15cfc:	1b83      	subs	r3, r0, r6
   15cfe:	2800      	cmp	r0, #0
   15d00:	d1ee      	bne.n	15ce0 <_vfiprintf_r+0xbc>
   15d02:	9b06      	ldr	r3, [sp, #24]
   15d04:	06d9      	lsls	r1, r3, #27
   15d06:	bf44      	itt	mi
   15d08:	2220      	movmi	r2, #32
   15d0a:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   15d0e:	7821      	ldrb	r1, [r4, #0]
   15d10:	071a      	lsls	r2, r3, #28
   15d12:	bf44      	itt	mi
   15d14:	222b      	movmi	r2, #43	; 0x2b
   15d16:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   15d1a:	292a      	cmp	r1, #42	; 0x2a
   15d1c:	d166      	bne.n	15dec <_vfiprintf_r+0x1c8>
   15d1e:	9a05      	ldr	r2, [sp, #20]
   15d20:	6811      	ldr	r1, [r2, #0]
   15d22:	3204      	adds	r2, #4
   15d24:	2900      	cmp	r1, #0
   15d26:	9205      	str	r2, [sp, #20]
   15d28:	f2c0 809d 	blt.w	15e66 <_vfiprintf_r+0x242>
   15d2c:	9109      	str	r1, [sp, #36]	; 0x24
   15d2e:	7861      	ldrb	r1, [r4, #1]
   15d30:	1ca5      	adds	r5, r4, #2
   15d32:	292e      	cmp	r1, #46	; 0x2e
   15d34:	d073      	beq.n	15e1e <_vfiprintf_r+0x1fa>
   15d36:	4c68      	ldr	r4, [pc, #416]	; (15ed8 <_vfiprintf_r+0x2b4>)
   15d38:	2203      	movs	r2, #3
   15d3a:	4620      	mov	r0, r4
   15d3c:	f000 fcf8 	bl	16730 <memchr>
   15d40:	2800      	cmp	r0, #0
   15d42:	f000 8086 	beq.w	15e52 <_vfiprintf_r+0x22e>
   15d46:	1b00      	subs	r0, r0, r4
   15d48:	9b06      	ldr	r3, [sp, #24]
   15d4a:	2440      	movs	r4, #64	; 0x40
   15d4c:	fa04 f000 	lsl.w	r0, r4, r0
   15d50:	4303      	orrs	r3, r0
   15d52:	9306      	str	r3, [sp, #24]
   15d54:	f105 0801 	add.w	r8, r5, #1
   15d58:	7829      	ldrb	r1, [r5, #0]
   15d5a:	4860      	ldr	r0, [pc, #384]	; (15edc <_vfiprintf_r+0x2b8>)
   15d5c:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   15d60:	2206      	movs	r2, #6
   15d62:	f000 fce5 	bl	16730 <memchr>
   15d66:	2800      	cmp	r0, #0
   15d68:	f000 8083 	beq.w	15e72 <_vfiprintf_r+0x24e>
   15d6c:	4b5c      	ldr	r3, [pc, #368]	; (15ee0 <_vfiprintf_r+0x2bc>)
   15d6e:	2b00      	cmp	r3, #0
   15d70:	d072      	beq.n	15e58 <_vfiprintf_r+0x234>
   15d72:	ab05      	add	r3, sp, #20
   15d74:	9300      	str	r3, [sp, #0]
   15d76:	465a      	mov	r2, fp
   15d78:	4b5a      	ldr	r3, [pc, #360]	; (15ee4 <_vfiprintf_r+0x2c0>)
   15d7a:	9803      	ldr	r0, [sp, #12]
   15d7c:	a906      	add	r1, sp, #24
   15d7e:	f3af 8000 	nop.w
   15d82:	4681      	mov	r9, r0
   15d84:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   15d88:	d007      	beq.n	15d9a <_vfiprintf_r+0x176>
   15d8a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15d8c:	444b      	add	r3, r9
   15d8e:	930b      	str	r3, [sp, #44]	; 0x2c
   15d90:	f898 3000 	ldrb.w	r3, [r8]
   15d94:	2b00      	cmp	r3, #0
   15d96:	f47f af79 	bne.w	15c8c <_vfiprintf_r+0x68>
   15d9a:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15d9e:	065b      	lsls	r3, r3, #25
   15da0:	d418      	bmi.n	15dd4 <_vfiprintf_r+0x1b0>
   15da2:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15da4:	b01f      	add	sp, #124	; 0x7c
   15da6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15daa:	f7ff fbf7 	bl	1559c <__sinit>
   15dae:	4b46      	ldr	r3, [pc, #280]	; (15ec8 <_vfiprintf_r+0x2a4>)
   15db0:	459b      	cmp	fp, r3
   15db2:	f47f af47 	bne.w	15c44 <_vfiprintf_r+0x20>
   15db6:	9b03      	ldr	r3, [sp, #12]
   15db8:	f8d3 b004 	ldr.w	fp, [r3, #4]
   15dbc:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15dc0:	0718      	lsls	r0, r3, #28
   15dc2:	f53f af4e 	bmi.w	15c62 <_vfiprintf_r+0x3e>
   15dc6:	4659      	mov	r1, fp
   15dc8:	9803      	ldr	r0, [sp, #12]
   15dca:	f7ff f9a7 	bl	1511c <__swsetup_r>
   15dce:	2800      	cmp	r0, #0
   15dd0:	f43f af4c 	beq.w	15c6c <_vfiprintf_r+0x48>
   15dd4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15dd8:	e7e4      	b.n	15da4 <_vfiprintf_r+0x180>
   15dda:	9b03      	ldr	r3, [sp, #12]
   15ddc:	f8d3 b008 	ldr.w	fp, [r3, #8]
   15de0:	e73a      	b.n	15c58 <_vfiprintf_r+0x34>
   15de2:	ebb4 0a08 	subs.w	sl, r4, r8
   15de6:	f43f af6f 	beq.w	15cc8 <_vfiprintf_r+0xa4>
   15dea:	e75f      	b.n	15cac <_vfiprintf_r+0x88>
   15dec:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15df0:	2a09      	cmp	r2, #9
   15df2:	bf88      	it	hi
   15df4:	46a2      	movhi	sl, r4
   15df6:	d89c      	bhi.n	15d32 <_vfiprintf_r+0x10e>
   15df8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15dfa:	e001      	b.n	15e00 <_vfiprintf_r+0x1dc>
   15dfc:	462c      	mov	r4, r5
   15dfe:	3501      	adds	r5, #1
   15e00:	7829      	ldrb	r1, [r5, #0]
   15e02:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15e06:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   15e0a:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15e0e:	2a09      	cmp	r2, #9
   15e10:	46aa      	mov	sl, r5
   15e12:	d9f3      	bls.n	15dfc <_vfiprintf_r+0x1d8>
   15e14:	292e      	cmp	r1, #46	; 0x2e
   15e16:	f104 0502 	add.w	r5, r4, #2
   15e1a:	9309      	str	r3, [sp, #36]	; 0x24
   15e1c:	d18b      	bne.n	15d36 <_vfiprintf_r+0x112>
   15e1e:	f89a 1001 	ldrb.w	r1, [sl, #1]
   15e22:	292a      	cmp	r1, #42	; 0x2a
   15e24:	d12f      	bne.n	15e86 <_vfiprintf_r+0x262>
   15e26:	9b05      	ldr	r3, [sp, #20]
   15e28:	f89a 1002 	ldrb.w	r1, [sl, #2]
   15e2c:	681a      	ldr	r2, [r3, #0]
   15e2e:	9207      	str	r2, [sp, #28]
   15e30:	3304      	adds	r3, #4
   15e32:	2a00      	cmp	r2, #0
   15e34:	9305      	str	r3, [sp, #20]
   15e36:	f10a 0503 	add.w	r5, sl, #3
   15e3a:	f10a 0302 	add.w	r3, sl, #2
   15e3e:	db38      	blt.n	15eb2 <_vfiprintf_r+0x28e>
   15e40:	4c25      	ldr	r4, [pc, #148]	; (15ed8 <_vfiprintf_r+0x2b4>)
   15e42:	2203      	movs	r2, #3
   15e44:	4620      	mov	r0, r4
   15e46:	469a      	mov	sl, r3
   15e48:	f000 fc72 	bl	16730 <memchr>
   15e4c:	2800      	cmp	r0, #0
   15e4e:	f47f af7a 	bne.w	15d46 <_vfiprintf_r+0x122>
   15e52:	46a8      	mov	r8, r5
   15e54:	4655      	mov	r5, sl
   15e56:	e77f      	b.n	15d58 <_vfiprintf_r+0x134>
   15e58:	9b05      	ldr	r3, [sp, #20]
   15e5a:	3307      	adds	r3, #7
   15e5c:	f023 0307 	bic.w	r3, r3, #7
   15e60:	3308      	adds	r3, #8
   15e62:	9305      	str	r3, [sp, #20]
   15e64:	e791      	b.n	15d8a <_vfiprintf_r+0x166>
   15e66:	4249      	negs	r1, r1
   15e68:	f043 0302 	orr.w	r3, r3, #2
   15e6c:	9109      	str	r1, [sp, #36]	; 0x24
   15e6e:	9306      	str	r3, [sp, #24]
   15e70:	e75d      	b.n	15d2e <_vfiprintf_r+0x10a>
   15e72:	ab05      	add	r3, sp, #20
   15e74:	9300      	str	r3, [sp, #0]
   15e76:	465a      	mov	r2, fp
   15e78:	4b1a      	ldr	r3, [pc, #104]	; (15ee4 <_vfiprintf_r+0x2c0>)
   15e7a:	9803      	ldr	r0, [sp, #12]
   15e7c:	a906      	add	r1, sp, #24
   15e7e:	f000 f8d5 	bl	1602c <_printf_i>
   15e82:	4681      	mov	r9, r0
   15e84:	e77e      	b.n	15d84 <_vfiprintf_r+0x160>
   15e86:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15e8a:	2300      	movs	r3, #0
   15e8c:	2a09      	cmp	r2, #9
   15e8e:	9307      	str	r3, [sp, #28]
   15e90:	d901      	bls.n	15e96 <_vfiprintf_r+0x272>
   15e92:	e015      	b.n	15ec0 <_vfiprintf_r+0x29c>
   15e94:	4655      	mov	r5, sl
   15e96:	7869      	ldrb	r1, [r5, #1]
   15e98:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15e9c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   15ea0:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15ea4:	2a09      	cmp	r2, #9
   15ea6:	f105 0a01 	add.w	sl, r5, #1
   15eaa:	d9f3      	bls.n	15e94 <_vfiprintf_r+0x270>
   15eac:	3502      	adds	r5, #2
   15eae:	9307      	str	r3, [sp, #28]
   15eb0:	e741      	b.n	15d36 <_vfiprintf_r+0x112>
   15eb2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15eb6:	469a      	mov	sl, r3
   15eb8:	9207      	str	r2, [sp, #28]
   15eba:	e73c      	b.n	15d36 <_vfiprintf_r+0x112>
   15ebc:	4644      	mov	r4, r8
   15ebe:	e703      	b.n	15cc8 <_vfiprintf_r+0xa4>
   15ec0:	46aa      	mov	sl, r5
   15ec2:	3501      	adds	r5, #1
   15ec4:	e737      	b.n	15d36 <_vfiprintf_r+0x112>
   15ec6:	bf00      	nop
   15ec8:	00017910 	.word	0x00017910
   15ecc:	000178f0 	.word	0x000178f0
   15ed0:	000178d0 	.word	0x000178d0
   15ed4:	00017930 	.word	0x00017930
   15ed8:	00017938 	.word	0x00017938
   15edc:	0001793c 	.word	0x0001793c
   15ee0:	00000000 	.word	0x00000000
   15ee4:	00015bd9 	.word	0x00015bd9

00015ee8 <vfiprintf>:
   15ee8:	b410      	push	{r4}
   15eea:	4c04      	ldr	r4, [pc, #16]	; (15efc <vfiprintf+0x14>)
   15eec:	4613      	mov	r3, r2
   15eee:	460a      	mov	r2, r1
   15ef0:	4601      	mov	r1, r0
   15ef2:	6820      	ldr	r0, [r4, #0]
   15ef4:	bc10      	pop	{r4}
   15ef6:	f7ff be95 	b.w	15c24 <_vfiprintf_r>
   15efa:	bf00      	nop
   15efc:	2000054c 	.word	0x2000054c

00015f00 <_printf_common>:
   15f00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15f04:	460c      	mov	r4, r1
   15f06:	4691      	mov	r9, r2
   15f08:	690a      	ldr	r2, [r1, #16]
   15f0a:	6889      	ldr	r1, [r1, #8]
   15f0c:	f8dd 8020 	ldr.w	r8, [sp, #32]
   15f10:	428a      	cmp	r2, r1
   15f12:	bfb8      	it	lt
   15f14:	460a      	movlt	r2, r1
   15f16:	f8c9 2000 	str.w	r2, [r9]
   15f1a:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
   15f1e:	4606      	mov	r6, r0
   15f20:	461f      	mov	r7, r3
   15f22:	b111      	cbz	r1, 15f2a <_printf_common+0x2a>
   15f24:	3201      	adds	r2, #1
   15f26:	f8c9 2000 	str.w	r2, [r9]
   15f2a:	6823      	ldr	r3, [r4, #0]
   15f2c:	0699      	lsls	r1, r3, #26
   15f2e:	d55c      	bpl.n	15fea <_printf_common+0xea>
   15f30:	f8d9 2000 	ldr.w	r2, [r9]
   15f34:	3202      	adds	r2, #2
   15f36:	f8c9 2000 	str.w	r2, [r9]
   15f3a:	6823      	ldr	r3, [r4, #0]
   15f3c:	f013 0f06 	tst.w	r3, #6
   15f40:	4619      	mov	r1, r3
   15f42:	d11d      	bne.n	15f80 <_printf_common+0x80>
   15f44:	68e1      	ldr	r1, [r4, #12]
   15f46:	1a8a      	subs	r2, r1, r2
   15f48:	2a00      	cmp	r2, #0
   15f4a:	bfd8      	it	le
   15f4c:	4619      	movle	r1, r3
   15f4e:	dd17      	ble.n	15f80 <_printf_common+0x80>
   15f50:	f104 0a19 	add.w	sl, r4, #25
   15f54:	2500      	movs	r5, #0
   15f56:	e005      	b.n	15f64 <_printf_common+0x64>
   15f58:	68e3      	ldr	r3, [r4, #12]
   15f5a:	f8d9 2000 	ldr.w	r2, [r9]
   15f5e:	1a9b      	subs	r3, r3, r2
   15f60:	42ab      	cmp	r3, r5
   15f62:	dd0c      	ble.n	15f7e <_printf_common+0x7e>
   15f64:	2301      	movs	r3, #1
   15f66:	4652      	mov	r2, sl
   15f68:	4639      	mov	r1, r7
   15f6a:	4630      	mov	r0, r6
   15f6c:	47c0      	blx	r8
   15f6e:	3001      	adds	r0, #1
   15f70:	f105 0501 	add.w	r5, r5, #1
   15f74:	d1f0      	bne.n	15f58 <_printf_common+0x58>
   15f76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15f7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15f7e:	6821      	ldr	r1, [r4, #0]
   15f80:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   15f84:	3300      	adds	r3, #0
   15f86:	bf18      	it	ne
   15f88:	2301      	movne	r3, #1
   15f8a:	068a      	lsls	r2, r1, #26
   15f8c:	d50a      	bpl.n	15fa4 <_printf_common+0xa4>
   15f8e:	18e1      	adds	r1, r4, r3
   15f90:	1c5a      	adds	r2, r3, #1
   15f92:	2030      	movs	r0, #48	; 0x30
   15f94:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   15f98:	4422      	add	r2, r4
   15f9a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   15f9e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   15fa2:	3302      	adds	r3, #2
   15fa4:	f104 0243 	add.w	r2, r4, #67	; 0x43
   15fa8:	4639      	mov	r1, r7
   15faa:	4630      	mov	r0, r6
   15fac:	47c0      	blx	r8
   15fae:	3001      	adds	r0, #1
   15fb0:	d0e1      	beq.n	15f76 <_printf_common+0x76>
   15fb2:	6823      	ldr	r3, [r4, #0]
   15fb4:	68a2      	ldr	r2, [r4, #8]
   15fb6:	6921      	ldr	r1, [r4, #16]
   15fb8:	f003 0306 	and.w	r3, r3, #6
   15fbc:	2b04      	cmp	r3, #4
   15fbe:	d01d      	beq.n	15ffc <_printf_common+0xfc>
   15fc0:	428a      	cmp	r2, r1
   15fc2:	dd26      	ble.n	16012 <_printf_common+0x112>
   15fc4:	f04f 0900 	mov.w	r9, #0
   15fc8:	1a52      	subs	r2, r2, r1
   15fca:	4491      	add	r9, r2
   15fcc:	341a      	adds	r4, #26
   15fce:	2500      	movs	r5, #0
   15fd0:	e001      	b.n	15fd6 <_printf_common+0xd6>
   15fd2:	454d      	cmp	r5, r9
   15fd4:	da1d      	bge.n	16012 <_printf_common+0x112>
   15fd6:	2301      	movs	r3, #1
   15fd8:	4622      	mov	r2, r4
   15fda:	4639      	mov	r1, r7
   15fdc:	4630      	mov	r0, r6
   15fde:	47c0      	blx	r8
   15fe0:	3001      	adds	r0, #1
   15fe2:	f105 0501 	add.w	r5, r5, #1
   15fe6:	d1f4      	bne.n	15fd2 <_printf_common+0xd2>
   15fe8:	e7c5      	b.n	15f76 <_printf_common+0x76>
   15fea:	f013 0f06 	tst.w	r3, #6
   15fee:	d013      	beq.n	16018 <_printf_common+0x118>
   15ff0:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   15ff4:	3300      	adds	r3, #0
   15ff6:	bf18      	it	ne
   15ff8:	2301      	movne	r3, #1
   15ffa:	e7d3      	b.n	15fa4 <_printf_common+0xa4>
   15ffc:	f8d9 0000 	ldr.w	r0, [r9]
   16000:	68e3      	ldr	r3, [r4, #12]
   16002:	428a      	cmp	r2, r1
   16004:	eba3 0300 	sub.w	r3, r3, r0
   16008:	ea23 79e3 	bic.w	r9, r3, r3, asr #31
   1600c:	dcdc      	bgt.n	15fc8 <_printf_common+0xc8>
   1600e:	2b00      	cmp	r3, #0
   16010:	dcdc      	bgt.n	15fcc <_printf_common+0xcc>
   16012:	2000      	movs	r0, #0
   16014:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   16018:	68e1      	ldr	r1, [r4, #12]
   1601a:	f8d9 2000 	ldr.w	r2, [r9]
   1601e:	1a8a      	subs	r2, r1, r2
   16020:	2a00      	cmp	r2, #0
   16022:	bfd8      	it	le
   16024:	4619      	movle	r1, r3
   16026:	dc93      	bgt.n	15f50 <_printf_common+0x50>
   16028:	e7aa      	b.n	15f80 <_printf_common+0x80>
   1602a:	bf00      	nop

0001602c <_printf_i>:
   1602c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   16030:	460c      	mov	r4, r1
   16032:	7e09      	ldrb	r1, [r1, #24]
   16034:	b085      	sub	sp, #20
   16036:	296e      	cmp	r1, #110	; 0x6e
   16038:	4606      	mov	r6, r0
   1603a:	4617      	mov	r7, r2
   1603c:	980c      	ldr	r0, [sp, #48]	; 0x30
   1603e:	4698      	mov	r8, r3
   16040:	f104 0e43 	add.w	lr, r4, #67	; 0x43
   16044:	d06d      	beq.n	16122 <_printf_i+0xf6>
   16046:	d939      	bls.n	160bc <_printf_i+0x90>
   16048:	2973      	cmp	r1, #115	; 0x73
   1604a:	f000 80f6 	beq.w	1623a <_printf_i+0x20e>
   1604e:	d944      	bls.n	160da <_printf_i+0xae>
   16050:	2975      	cmp	r1, #117	; 0x75
   16052:	f000 8104 	beq.w	1625e <_printf_i+0x232>
   16056:	2978      	cmp	r1, #120	; 0x78
   16058:	f040 8111 	bne.w	1627e <_printf_i+0x252>
   1605c:	2378      	movs	r3, #120	; 0x78
   1605e:	6822      	ldr	r2, [r4, #0]
   16060:	f8df c258 	ldr.w	ip, [pc, #600]	; 162bc <_printf_i+0x290>
   16064:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   16068:	6801      	ldr	r1, [r0, #0]
   1606a:	0615      	lsls	r5, r2, #24
   1606c:	f851 3b04 	ldr.w	r3, [r1], #4
   16070:	6001      	str	r1, [r0, #0]
   16072:	f140 80a1 	bpl.w	161b8 <_printf_i+0x18c>
   16076:	07d1      	lsls	r1, r2, #31
   16078:	bf44      	itt	mi
   1607a:	f042 0220 	orrmi.w	r2, r2, #32
   1607e:	6022      	strmi	r2, [r4, #0]
   16080:	2b00      	cmp	r3, #0
   16082:	f000 8093 	beq.w	161ac <_printf_i+0x180>
   16086:	2210      	movs	r2, #16
   16088:	2100      	movs	r1, #0
   1608a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   1608e:	6860      	ldr	r0, [r4, #4]
   16090:	60a0      	str	r0, [r4, #8]
   16092:	2800      	cmp	r0, #0
   16094:	f2c0 80c8 	blt.w	16228 <_printf_i+0x1fc>
   16098:	6821      	ldr	r1, [r4, #0]
   1609a:	f021 0104 	bic.w	r1, r1, #4
   1609e:	6021      	str	r1, [r4, #0]
   160a0:	2b00      	cmp	r3, #0
   160a2:	f040 80a3 	bne.w	161ec <_printf_i+0x1c0>
   160a6:	2800      	cmp	r0, #0
   160a8:	f040 80c0 	bne.w	1622c <_printf_i+0x200>
   160ac:	4675      	mov	r5, lr
   160ae:	2a08      	cmp	r2, #8
   160b0:	f000 80ac 	beq.w	1620c <_printf_i+0x1e0>
   160b4:	ebae 0305 	sub.w	r3, lr, r5
   160b8:	6123      	str	r3, [r4, #16]
   160ba:	e041      	b.n	16140 <_printf_i+0x114>
   160bc:	2963      	cmp	r1, #99	; 0x63
   160be:	f000 80e5 	beq.w	1628c <_printf_i+0x260>
   160c2:	d81a      	bhi.n	160fa <_printf_i+0xce>
   160c4:	2900      	cmp	r1, #0
   160c6:	d038      	beq.n	1613a <_printf_i+0x10e>
   160c8:	2958      	cmp	r1, #88	; 0x58
   160ca:	f040 80d8 	bne.w	1627e <_printf_i+0x252>
   160ce:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
   160d2:	6822      	ldr	r2, [r4, #0]
   160d4:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 162c0 <_printf_i+0x294>
   160d8:	e7c6      	b.n	16068 <_printf_i+0x3c>
   160da:	296f      	cmp	r1, #111	; 0x6f
   160dc:	f000 80bf 	beq.w	1625e <_printf_i+0x232>
   160e0:	2970      	cmp	r1, #112	; 0x70
   160e2:	f040 80cc 	bne.w	1627e <_printf_i+0x252>
   160e6:	6822      	ldr	r2, [r4, #0]
   160e8:	f8df c1d0 	ldr.w	ip, [pc, #464]	; 162bc <_printf_i+0x290>
   160ec:	f042 0220 	orr.w	r2, r2, #32
   160f0:	2378      	movs	r3, #120	; 0x78
   160f2:	6022      	str	r2, [r4, #0]
   160f4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   160f8:	e7b6      	b.n	16068 <_printf_i+0x3c>
   160fa:	2964      	cmp	r1, #100	; 0x64
   160fc:	d002      	beq.n	16104 <_printf_i+0xd8>
   160fe:	2969      	cmp	r1, #105	; 0x69
   16100:	f040 80bd 	bne.w	1627e <_printf_i+0x252>
   16104:	6822      	ldr	r2, [r4, #0]
   16106:	6803      	ldr	r3, [r0, #0]
   16108:	0611      	lsls	r1, r2, #24
   1610a:	f103 0504 	add.w	r5, r3, #4
   1610e:	d557      	bpl.n	161c0 <_printf_i+0x194>
   16110:	6819      	ldr	r1, [r3, #0]
   16112:	6005      	str	r5, [r0, #0]
   16114:	460b      	mov	r3, r1
   16116:	2900      	cmp	r1, #0
   16118:	db59      	blt.n	161ce <_printf_i+0x1a2>
   1611a:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 162c0 <_printf_i+0x294>
   1611e:	220a      	movs	r2, #10
   16120:	e7b5      	b.n	1608e <_printf_i+0x62>
   16122:	6803      	ldr	r3, [r0, #0]
   16124:	6822      	ldr	r2, [r4, #0]
   16126:	6961      	ldr	r1, [r4, #20]
   16128:	1d1d      	adds	r5, r3, #4
   1612a:	6005      	str	r5, [r0, #0]
   1612c:	0615      	lsls	r5, r2, #24
   1612e:	681b      	ldr	r3, [r3, #0]
   16130:	d402      	bmi.n	16138 <_printf_i+0x10c>
   16132:	0650      	lsls	r0, r2, #25
   16134:	f100 80bd 	bmi.w	162b2 <_printf_i+0x286>
   16138:	6019      	str	r1, [r3, #0]
   1613a:	2300      	movs	r3, #0
   1613c:	4675      	mov	r5, lr
   1613e:	6123      	str	r3, [r4, #16]
   16140:	f8cd 8000 	str.w	r8, [sp]
   16144:	463b      	mov	r3, r7
   16146:	aa03      	add	r2, sp, #12
   16148:	4621      	mov	r1, r4
   1614a:	4630      	mov	r0, r6
   1614c:	f7ff fed8 	bl	15f00 <_printf_common>
   16150:	3001      	adds	r0, #1
   16152:	d020      	beq.n	16196 <_printf_i+0x16a>
   16154:	462a      	mov	r2, r5
   16156:	6923      	ldr	r3, [r4, #16]
   16158:	4639      	mov	r1, r7
   1615a:	4630      	mov	r0, r6
   1615c:	47c0      	blx	r8
   1615e:	3001      	adds	r0, #1
   16160:	d019      	beq.n	16196 <_printf_i+0x16a>
   16162:	6822      	ldr	r2, [r4, #0]
   16164:	9803      	ldr	r0, [sp, #12]
   16166:	68e3      	ldr	r3, [r4, #12]
   16168:	0792      	lsls	r2, r2, #30
   1616a:	d519      	bpl.n	161a0 <_printf_i+0x174>
   1616c:	1a1a      	subs	r2, r3, r0
   1616e:	2a00      	cmp	r2, #0
   16170:	dd16      	ble.n	161a0 <_printf_i+0x174>
   16172:	f104 0919 	add.w	r9, r4, #25
   16176:	2500      	movs	r5, #0
   16178:	e004      	b.n	16184 <_printf_i+0x158>
   1617a:	68e3      	ldr	r3, [r4, #12]
   1617c:	9803      	ldr	r0, [sp, #12]
   1617e:	1a1a      	subs	r2, r3, r0
   16180:	42aa      	cmp	r2, r5
   16182:	dd0d      	ble.n	161a0 <_printf_i+0x174>
   16184:	2301      	movs	r3, #1
   16186:	464a      	mov	r2, r9
   16188:	4639      	mov	r1, r7
   1618a:	4630      	mov	r0, r6
   1618c:	47c0      	blx	r8
   1618e:	3001      	adds	r0, #1
   16190:	f105 0501 	add.w	r5, r5, #1
   16194:	d1f1      	bne.n	1617a <_printf_i+0x14e>
   16196:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1619a:	b005      	add	sp, #20
   1619c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   161a0:	4298      	cmp	r0, r3
   161a2:	bfb8      	it	lt
   161a4:	4618      	movlt	r0, r3
   161a6:	b005      	add	sp, #20
   161a8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   161ac:	6822      	ldr	r2, [r4, #0]
   161ae:	f022 0220 	bic.w	r2, r2, #32
   161b2:	6022      	str	r2, [r4, #0]
   161b4:	2210      	movs	r2, #16
   161b6:	e767      	b.n	16088 <_printf_i+0x5c>
   161b8:	0650      	lsls	r0, r2, #25
   161ba:	bf48      	it	mi
   161bc:	b29b      	uxthmi	r3, r3
   161be:	e75a      	b.n	16076 <_printf_i+0x4a>
   161c0:	0651      	lsls	r1, r2, #25
   161c2:	d5a5      	bpl.n	16110 <_printf_i+0xe4>
   161c4:	f9b3 3000 	ldrsh.w	r3, [r3]
   161c8:	6005      	str	r5, [r0, #0]
   161ca:	4619      	mov	r1, r3
   161cc:	e7a3      	b.n	16116 <_printf_i+0xea>
   161ce:	6861      	ldr	r1, [r4, #4]
   161d0:	60a1      	str	r1, [r4, #8]
   161d2:	202d      	movs	r0, #45	; 0x2d
   161d4:	2900      	cmp	r1, #0
   161d6:	f1c3 0300 	rsb	r3, r3, #0
   161da:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
   161de:	db02      	blt.n	161e6 <_printf_i+0x1ba>
   161e0:	f022 0204 	bic.w	r2, r2, #4
   161e4:	6022      	str	r2, [r4, #0]
   161e6:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 162c0 <_printf_i+0x294>
   161ea:	220a      	movs	r2, #10
   161ec:	4675      	mov	r5, lr
   161ee:	e000      	b.n	161f2 <_printf_i+0x1c6>
   161f0:	460b      	mov	r3, r1
   161f2:	fbb3 f1f2 	udiv	r1, r3, r2
   161f6:	fb02 3011 	mls	r0, r2, r1, r3
   161fa:	4293      	cmp	r3, r2
   161fc:	f81c 0000 	ldrb.w	r0, [ip, r0]
   16200:	f805 0d01 	strb.w	r0, [r5, #-1]!
   16204:	d2f4      	bcs.n	161f0 <_printf_i+0x1c4>
   16206:	2a08      	cmp	r2, #8
   16208:	f47f af54 	bne.w	160b4 <_printf_i+0x88>
   1620c:	6823      	ldr	r3, [r4, #0]
   1620e:	07db      	lsls	r3, r3, #31
   16210:	f57f af50 	bpl.w	160b4 <_printf_i+0x88>
   16214:	6862      	ldr	r2, [r4, #4]
   16216:	6923      	ldr	r3, [r4, #16]
   16218:	429a      	cmp	r2, r3
   1621a:	f73f af4b 	bgt.w	160b4 <_printf_i+0x88>
   1621e:	2330      	movs	r3, #48	; 0x30
   16220:	f805 3c01 	strb.w	r3, [r5, #-1]
   16224:	3d01      	subs	r5, #1
   16226:	e745      	b.n	160b4 <_printf_i+0x88>
   16228:	2b00      	cmp	r3, #0
   1622a:	d1df      	bne.n	161ec <_printf_i+0x1c0>
   1622c:	f89c 3000 	ldrb.w	r3, [ip]
   16230:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   16234:	f104 0542 	add.w	r5, r4, #66	; 0x42
   16238:	e739      	b.n	160ae <_printf_i+0x82>
   1623a:	6803      	ldr	r3, [r0, #0]
   1623c:	6862      	ldr	r2, [r4, #4]
   1623e:	1d19      	adds	r1, r3, #4
   16240:	6001      	str	r1, [r0, #0]
   16242:	681d      	ldr	r5, [r3, #0]
   16244:	2100      	movs	r1, #0
   16246:	4628      	mov	r0, r5
   16248:	f000 fa72 	bl	16730 <memchr>
   1624c:	2800      	cmp	r0, #0
   1624e:	d032      	beq.n	162b6 <_printf_i+0x28a>
   16250:	1b40      	subs	r0, r0, r5
   16252:	6060      	str	r0, [r4, #4]
   16254:	6120      	str	r0, [r4, #16]
   16256:	2300      	movs	r3, #0
   16258:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   1625c:	e770      	b.n	16140 <_printf_i+0x114>
   1625e:	6822      	ldr	r2, [r4, #0]
   16260:	6803      	ldr	r3, [r0, #0]
   16262:	f012 0f80 	tst.w	r2, #128	; 0x80
   16266:	f103 0504 	add.w	r5, r3, #4
   1626a:	d01a      	beq.n	162a2 <_printf_i+0x276>
   1626c:	681b      	ldr	r3, [r3, #0]
   1626e:	6005      	str	r5, [r0, #0]
   16270:	296f      	cmp	r1, #111	; 0x6f
   16272:	bf0c      	ite	eq
   16274:	2208      	moveq	r2, #8
   16276:	220a      	movne	r2, #10
   16278:	f8df c044 	ldr.w	ip, [pc, #68]	; 162c0 <_printf_i+0x294>
   1627c:	e704      	b.n	16088 <_printf_i+0x5c>
   1627e:	2301      	movs	r3, #1
   16280:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
   16284:	6123      	str	r3, [r4, #16]
   16286:	f104 0542 	add.w	r5, r4, #66	; 0x42
   1628a:	e7e4      	b.n	16256 <_printf_i+0x22a>
   1628c:	6803      	ldr	r3, [r0, #0]
   1628e:	681a      	ldr	r2, [r3, #0]
   16290:	1d19      	adds	r1, r3, #4
   16292:	2301      	movs	r3, #1
   16294:	6001      	str	r1, [r0, #0]
   16296:	f104 0542 	add.w	r5, r4, #66	; 0x42
   1629a:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
   1629e:	6123      	str	r3, [r4, #16]
   162a0:	e7d9      	b.n	16256 <_printf_i+0x22a>
   162a2:	f012 0f40 	tst.w	r2, #64	; 0x40
   162a6:	bf0d      	iteet	eq
   162a8:	681b      	ldreq	r3, [r3, #0]
   162aa:	6005      	strne	r5, [r0, #0]
   162ac:	881b      	ldrhne	r3, [r3, #0]
   162ae:	6005      	streq	r5, [r0, #0]
   162b0:	e7de      	b.n	16270 <_printf_i+0x244>
   162b2:	8019      	strh	r1, [r3, #0]
   162b4:	e741      	b.n	1613a <_printf_i+0x10e>
   162b6:	6860      	ldr	r0, [r4, #4]
   162b8:	e7cc      	b.n	16254 <_printf_i+0x228>
   162ba:	bf00      	nop
   162bc:	00017958 	.word	0x00017958
   162c0:	00017944 	.word	0x00017944

000162c4 <__sread>:
   162c4:	b510      	push	{r4, lr}
   162c6:	460c      	mov	r4, r1
   162c8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   162cc:	f000 fb0e 	bl	168ec <_read_r>
   162d0:	2800      	cmp	r0, #0
   162d2:	db03      	blt.n	162dc <__sread+0x18>
   162d4:	6d63      	ldr	r3, [r4, #84]	; 0x54
   162d6:	4403      	add	r3, r0
   162d8:	6563      	str	r3, [r4, #84]	; 0x54
   162da:	bd10      	pop	{r4, pc}
   162dc:	89a3      	ldrh	r3, [r4, #12]
   162de:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   162e2:	81a3      	strh	r3, [r4, #12]
   162e4:	bd10      	pop	{r4, pc}
   162e6:	bf00      	nop

000162e8 <__seofread>:
   162e8:	2000      	movs	r0, #0
   162ea:	4770      	bx	lr

000162ec <__swrite>:
   162ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   162f0:	4616      	mov	r6, r2
   162f2:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
   162f6:	461f      	mov	r7, r3
   162f8:	05d3      	lsls	r3, r2, #23
   162fa:	460c      	mov	r4, r1
   162fc:	4605      	mov	r5, r0
   162fe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16302:	d409      	bmi.n	16318 <__swrite+0x2c>
   16304:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
   16308:	81a2      	strh	r2, [r4, #12]
   1630a:	463b      	mov	r3, r7
   1630c:	4632      	mov	r2, r6
   1630e:	4628      	mov	r0, r5
   16310:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   16314:	f000 b81e 	b.w	16354 <_write_r>
   16318:	2200      	movs	r2, #0
   1631a:	2302      	movs	r3, #2
   1631c:	f000 f9ec 	bl	166f8 <_lseek_r>
   16320:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   16324:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   16328:	e7ec      	b.n	16304 <__swrite+0x18>
   1632a:	bf00      	nop

0001632c <__sseek>:
   1632c:	b510      	push	{r4, lr}
   1632e:	460c      	mov	r4, r1
   16330:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16334:	f000 f9e0 	bl	166f8 <_lseek_r>
   16338:	89a3      	ldrh	r3, [r4, #12]
   1633a:	1c42      	adds	r2, r0, #1
   1633c:	bf0e      	itee	eq
   1633e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   16342:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   16346:	6560      	strne	r0, [r4, #84]	; 0x54
   16348:	81a3      	strh	r3, [r4, #12]
   1634a:	bd10      	pop	{r4, pc}

0001634c <__sclose>:
   1634c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16350:	f000 b816 	b.w	16380 <_close_r>

00016354 <_write_r>:
   16354:	b570      	push	{r4, r5, r6, lr}
   16356:	460d      	mov	r5, r1
   16358:	4c08      	ldr	r4, [pc, #32]	; (1637c <_write_r+0x28>)
   1635a:	4611      	mov	r1, r2
   1635c:	4606      	mov	r6, r0
   1635e:	461a      	mov	r2, r3
   16360:	4628      	mov	r0, r5
   16362:	2300      	movs	r3, #0
   16364:	6023      	str	r3, [r4, #0]
   16366:	f7f5 fb87 	bl	ba78 <_write>
   1636a:	1c43      	adds	r3, r0, #1
   1636c:	d000      	beq.n	16370 <_write_r+0x1c>
   1636e:	bd70      	pop	{r4, r5, r6, pc}
   16370:	6823      	ldr	r3, [r4, #0]
   16372:	2b00      	cmp	r3, #0
   16374:	d0fb      	beq.n	1636e <_write_r+0x1a>
   16376:	6033      	str	r3, [r6, #0]
   16378:	bd70      	pop	{r4, r5, r6, pc}
   1637a:	bf00      	nop
   1637c:	2001cfd4 	.word	0x2001cfd4

00016380 <_close_r>:
   16380:	b538      	push	{r3, r4, r5, lr}
   16382:	4c07      	ldr	r4, [pc, #28]	; (163a0 <_close_r+0x20>)
   16384:	2300      	movs	r3, #0
   16386:	4605      	mov	r5, r0
   16388:	4608      	mov	r0, r1
   1638a:	6023      	str	r3, [r4, #0]
   1638c:	f7f5 fd4c 	bl	be28 <_close>
   16390:	1c43      	adds	r3, r0, #1
   16392:	d000      	beq.n	16396 <_close_r+0x16>
   16394:	bd38      	pop	{r3, r4, r5, pc}
   16396:	6823      	ldr	r3, [r4, #0]
   16398:	2b00      	cmp	r3, #0
   1639a:	d0fb      	beq.n	16394 <_close_r+0x14>
   1639c:	602b      	str	r3, [r5, #0]
   1639e:	bd38      	pop	{r3, r4, r5, pc}
   163a0:	2001cfd4 	.word	0x2001cfd4

000163a4 <_fstat_r>:
   163a4:	b538      	push	{r3, r4, r5, lr}
   163a6:	460b      	mov	r3, r1
   163a8:	4c07      	ldr	r4, [pc, #28]	; (163c8 <_fstat_r+0x24>)
   163aa:	4605      	mov	r5, r0
   163ac:	4611      	mov	r1, r2
   163ae:	4618      	mov	r0, r3
   163b0:	2300      	movs	r3, #0
   163b2:	6023      	str	r3, [r4, #0]
   163b4:	f7f5 fd3b 	bl	be2e <_fstat>
   163b8:	1c43      	adds	r3, r0, #1
   163ba:	d000      	beq.n	163be <_fstat_r+0x1a>
   163bc:	bd38      	pop	{r3, r4, r5, pc}
   163be:	6823      	ldr	r3, [r4, #0]
   163c0:	2b00      	cmp	r3, #0
   163c2:	d0fb      	beq.n	163bc <_fstat_r+0x18>
   163c4:	602b      	str	r3, [r5, #0]
   163c6:	bd38      	pop	{r3, r4, r5, pc}
   163c8:	2001cfd4 	.word	0x2001cfd4

000163cc <__sfvwrite_r>:
   163cc:	6893      	ldr	r3, [r2, #8]
   163ce:	2b00      	cmp	r3, #0
   163d0:	f000 8102 	beq.w	165d8 <__sfvwrite_r+0x20c>
   163d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   163d8:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
   163dc:	b29b      	uxth	r3, r3
   163de:	460c      	mov	r4, r1
   163e0:	0719      	lsls	r1, r3, #28
   163e2:	b083      	sub	sp, #12
   163e4:	4682      	mov	sl, r0
   163e6:	4690      	mov	r8, r2
   163e8:	d535      	bpl.n	16456 <__sfvwrite_r+0x8a>
   163ea:	6922      	ldr	r2, [r4, #16]
   163ec:	b39a      	cbz	r2, 16456 <__sfvwrite_r+0x8a>
   163ee:	f013 0202 	ands.w	r2, r3, #2
   163f2:	f8d8 6000 	ldr.w	r6, [r8]
   163f6:	d03d      	beq.n	16474 <__sfvwrite_r+0xa8>
   163f8:	2700      	movs	r7, #0
   163fa:	f8d4 b028 	ldr.w	fp, [r4, #40]	; 0x28
   163fe:	f8d4 c020 	ldr.w	ip, [r4, #32]
   16402:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 166d0 <__sfvwrite_r+0x304>
   16406:	463d      	mov	r5, r7
   16408:	454d      	cmp	r5, r9
   1640a:	462b      	mov	r3, r5
   1640c:	463a      	mov	r2, r7
   1640e:	bf28      	it	cs
   16410:	464b      	movcs	r3, r9
   16412:	4661      	mov	r1, ip
   16414:	4650      	mov	r0, sl
   16416:	b1d5      	cbz	r5, 1644e <__sfvwrite_r+0x82>
   16418:	47d8      	blx	fp
   1641a:	2800      	cmp	r0, #0
   1641c:	f340 80d2 	ble.w	165c4 <__sfvwrite_r+0x1f8>
   16420:	f8d8 3008 	ldr.w	r3, [r8, #8]
   16424:	1a1b      	subs	r3, r3, r0
   16426:	4407      	add	r7, r0
   16428:	1a2d      	subs	r5, r5, r0
   1642a:	f8c8 3008 	str.w	r3, [r8, #8]
   1642e:	2b00      	cmp	r3, #0
   16430:	f000 80b7 	beq.w	165a2 <__sfvwrite_r+0x1d6>
   16434:	f8d4 c020 	ldr.w	ip, [r4, #32]
   16438:	f8d4 b028 	ldr.w	fp, [r4, #40]	; 0x28
   1643c:	454d      	cmp	r5, r9
   1643e:	462b      	mov	r3, r5
   16440:	463a      	mov	r2, r7
   16442:	bf28      	it	cs
   16444:	464b      	movcs	r3, r9
   16446:	4661      	mov	r1, ip
   16448:	4650      	mov	r0, sl
   1644a:	2d00      	cmp	r5, #0
   1644c:	d1e4      	bne.n	16418 <__sfvwrite_r+0x4c>
   1644e:	e9d6 7500 	ldrd	r7, r5, [r6]
   16452:	3608      	adds	r6, #8
   16454:	e7d8      	b.n	16408 <__sfvwrite_r+0x3c>
   16456:	4621      	mov	r1, r4
   16458:	4650      	mov	r0, sl
   1645a:	f7fe fe5f 	bl	1511c <__swsetup_r>
   1645e:	2800      	cmp	r0, #0
   16460:	f040 8130 	bne.w	166c4 <__sfvwrite_r+0x2f8>
   16464:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   16468:	f8d8 6000 	ldr.w	r6, [r8]
   1646c:	b29b      	uxth	r3, r3
   1646e:	f013 0202 	ands.w	r2, r3, #2
   16472:	d1c1      	bne.n	163f8 <__sfvwrite_r+0x2c>
   16474:	f013 0901 	ands.w	r9, r3, #1
   16478:	f040 80b0 	bne.w	165dc <__sfvwrite_r+0x210>
   1647c:	68a7      	ldr	r7, [r4, #8]
   1647e:	6820      	ldr	r0, [r4, #0]
   16480:	464d      	mov	r5, r9
   16482:	2d00      	cmp	r5, #0
   16484:	d054      	beq.n	16530 <__sfvwrite_r+0x164>
   16486:	059a      	lsls	r2, r3, #22
   16488:	f140 80bc 	bpl.w	16604 <__sfvwrite_r+0x238>
   1648c:	42af      	cmp	r7, r5
   1648e:	46bb      	mov	fp, r7
   16490:	f200 80e7 	bhi.w	16662 <__sfvwrite_r+0x296>
   16494:	f413 6f90 	tst.w	r3, #1152	; 0x480
   16498:	d02f      	beq.n	164fa <__sfvwrite_r+0x12e>
   1649a:	e9d4 1704 	ldrd	r1, r7, [r4, #16]
   1649e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   164a2:	eba0 0b01 	sub.w	fp, r0, r1
   164a6:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
   164aa:	1c68      	adds	r0, r5, #1
   164ac:	107f      	asrs	r7, r7, #1
   164ae:	4458      	add	r0, fp
   164b0:	42b8      	cmp	r0, r7
   164b2:	463a      	mov	r2, r7
   164b4:	bf84      	itt	hi
   164b6:	4607      	movhi	r7, r0
   164b8:	463a      	movhi	r2, r7
   164ba:	055b      	lsls	r3, r3, #21
   164bc:	f140 80e9 	bpl.w	16692 <__sfvwrite_r+0x2c6>
   164c0:	4611      	mov	r1, r2
   164c2:	4650      	mov	r0, sl
   164c4:	f7fe f876 	bl	145b4 <_malloc_r>
   164c8:	2800      	cmp	r0, #0
   164ca:	f000 80f5 	beq.w	166b8 <__sfvwrite_r+0x2ec>
   164ce:	465a      	mov	r2, fp
   164d0:	6921      	ldr	r1, [r4, #16]
   164d2:	9001      	str	r0, [sp, #4]
   164d4:	f7fd ff2e 	bl	14334 <memcpy>
   164d8:	89a2      	ldrh	r2, [r4, #12]
   164da:	9b01      	ldr	r3, [sp, #4]
   164dc:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   164e0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   164e4:	81a2      	strh	r2, [r4, #12]
   164e6:	eba7 020b 	sub.w	r2, r7, fp
   164ea:	eb03 000b 	add.w	r0, r3, fp
   164ee:	6167      	str	r7, [r4, #20]
   164f0:	6123      	str	r3, [r4, #16]
   164f2:	6020      	str	r0, [r4, #0]
   164f4:	60a2      	str	r2, [r4, #8]
   164f6:	462f      	mov	r7, r5
   164f8:	46ab      	mov	fp, r5
   164fa:	465a      	mov	r2, fp
   164fc:	4649      	mov	r1, r9
   164fe:	f000 f967 	bl	167d0 <memmove>
   16502:	68a2      	ldr	r2, [r4, #8]
   16504:	6823      	ldr	r3, [r4, #0]
   16506:	1bd2      	subs	r2, r2, r7
   16508:	445b      	add	r3, fp
   1650a:	462f      	mov	r7, r5
   1650c:	60a2      	str	r2, [r4, #8]
   1650e:	6023      	str	r3, [r4, #0]
   16510:	2500      	movs	r5, #0
   16512:	f8d8 3008 	ldr.w	r3, [r8, #8]
   16516:	1bdb      	subs	r3, r3, r7
   16518:	44b9      	add	r9, r7
   1651a:	f8c8 3008 	str.w	r3, [r8, #8]
   1651e:	2b00      	cmp	r3, #0
   16520:	d03f      	beq.n	165a2 <__sfvwrite_r+0x1d6>
   16522:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   16526:	68a7      	ldr	r7, [r4, #8]
   16528:	6820      	ldr	r0, [r4, #0]
   1652a:	b29b      	uxth	r3, r3
   1652c:	2d00      	cmp	r5, #0
   1652e:	d1aa      	bne.n	16486 <__sfvwrite_r+0xba>
   16530:	e9d6 9500 	ldrd	r9, r5, [r6]
   16534:	3608      	adds	r6, #8
   16536:	e7a4      	b.n	16482 <__sfvwrite_r+0xb6>
   16538:	f10b 0308 	add.w	r3, fp, #8
   1653c:	e953 6702 	ldrd	r6, r7, [r3, #-8]
   16540:	469b      	mov	fp, r3
   16542:	3308      	adds	r3, #8
   16544:	2f00      	cmp	r7, #0
   16546:	d0f9      	beq.n	1653c <__sfvwrite_r+0x170>
   16548:	463a      	mov	r2, r7
   1654a:	210a      	movs	r1, #10
   1654c:	4630      	mov	r0, r6
   1654e:	f000 f8ef 	bl	16730 <memchr>
   16552:	2800      	cmp	r0, #0
   16554:	d053      	beq.n	165fe <__sfvwrite_r+0x232>
   16556:	3001      	adds	r0, #1
   16558:	eba0 0906 	sub.w	r9, r0, r6
   1655c:	464b      	mov	r3, r9
   1655e:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
   16562:	6820      	ldr	r0, [r4, #0]
   16564:	42bb      	cmp	r3, r7
   16566:	bf28      	it	cs
   16568:	463b      	movcs	r3, r7
   1656a:	4288      	cmp	r0, r1
   1656c:	d903      	bls.n	16576 <__sfvwrite_r+0x1aa>
   1656e:	68a5      	ldr	r5, [r4, #8]
   16570:	4415      	add	r5, r2
   16572:	42ab      	cmp	r3, r5
   16574:	dc19      	bgt.n	165aa <__sfvwrite_r+0x1de>
   16576:	429a      	cmp	r2, r3
   16578:	dc7d      	bgt.n	16676 <__sfvwrite_r+0x2aa>
   1657a:	4613      	mov	r3, r2
   1657c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
   1657e:	6a21      	ldr	r1, [r4, #32]
   16580:	4632      	mov	r2, r6
   16582:	4650      	mov	r0, sl
   16584:	47a8      	blx	r5
   16586:	1e05      	subs	r5, r0, #0
   16588:	dd1c      	ble.n	165c4 <__sfvwrite_r+0x1f8>
   1658a:	ebb9 0905 	subs.w	r9, r9, r5
   1658e:	d06b      	beq.n	16668 <__sfvwrite_r+0x29c>
   16590:	2001      	movs	r0, #1
   16592:	f8d8 3008 	ldr.w	r3, [r8, #8]
   16596:	1b5b      	subs	r3, r3, r5
   16598:	442e      	add	r6, r5
   1659a:	1b7f      	subs	r7, r7, r5
   1659c:	f8c8 3008 	str.w	r3, [r8, #8]
   165a0:	bb13      	cbnz	r3, 165e8 <__sfvwrite_r+0x21c>
   165a2:	2000      	movs	r0, #0
   165a4:	b003      	add	sp, #12
   165a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   165aa:	4631      	mov	r1, r6
   165ac:	462a      	mov	r2, r5
   165ae:	f000 f90f 	bl	167d0 <memmove>
   165b2:	6823      	ldr	r3, [r4, #0]
   165b4:	442b      	add	r3, r5
   165b6:	6023      	str	r3, [r4, #0]
   165b8:	4621      	mov	r1, r4
   165ba:	4650      	mov	r0, sl
   165bc:	f7fe fec4 	bl	15348 <_fflush_r>
   165c0:	2800      	cmp	r0, #0
   165c2:	d0e2      	beq.n	1658a <__sfvwrite_r+0x1be>
   165c4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   165c8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   165cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   165d0:	81a3      	strh	r3, [r4, #12]
   165d2:	b003      	add	sp, #12
   165d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   165d8:	2000      	movs	r0, #0
   165da:	4770      	bx	lr
   165dc:	4633      	mov	r3, r6
   165de:	4691      	mov	r9, r2
   165e0:	4610      	mov	r0, r2
   165e2:	4617      	mov	r7, r2
   165e4:	464e      	mov	r6, r9
   165e6:	469b      	mov	fp, r3
   165e8:	2f00      	cmp	r7, #0
   165ea:	d0a5      	beq.n	16538 <__sfvwrite_r+0x16c>
   165ec:	2800      	cmp	r0, #0
   165ee:	d1b5      	bne.n	1655c <__sfvwrite_r+0x190>
   165f0:	463a      	mov	r2, r7
   165f2:	210a      	movs	r1, #10
   165f4:	4630      	mov	r0, r6
   165f6:	f000 f89b 	bl	16730 <memchr>
   165fa:	2800      	cmp	r0, #0
   165fc:	d1ab      	bne.n	16556 <__sfvwrite_r+0x18a>
   165fe:	1c7b      	adds	r3, r7, #1
   16600:	4699      	mov	r9, r3
   16602:	e7ac      	b.n	1655e <__sfvwrite_r+0x192>
   16604:	6923      	ldr	r3, [r4, #16]
   16606:	4283      	cmp	r3, r0
   16608:	d315      	bcc.n	16636 <__sfvwrite_r+0x26a>
   1660a:	6961      	ldr	r1, [r4, #20]
   1660c:	42a9      	cmp	r1, r5
   1660e:	d812      	bhi.n	16636 <__sfvwrite_r+0x26a>
   16610:	4b2e      	ldr	r3, [pc, #184]	; (166cc <__sfvwrite_r+0x300>)
   16612:	6aa7      	ldr	r7, [r4, #40]	; 0x28
   16614:	429d      	cmp	r5, r3
   16616:	bf94      	ite	ls
   16618:	462b      	movls	r3, r5
   1661a:	f06f 4300 	mvnhi.w	r3, #2147483648	; 0x80000000
   1661e:	464a      	mov	r2, r9
   16620:	fb93 f3f1 	sdiv	r3, r3, r1
   16624:	4650      	mov	r0, sl
   16626:	fb01 f303 	mul.w	r3, r1, r3
   1662a:	6a21      	ldr	r1, [r4, #32]
   1662c:	47b8      	blx	r7
   1662e:	1e07      	subs	r7, r0, #0
   16630:	ddc8      	ble.n	165c4 <__sfvwrite_r+0x1f8>
   16632:	1bed      	subs	r5, r5, r7
   16634:	e76d      	b.n	16512 <__sfvwrite_r+0x146>
   16636:	42af      	cmp	r7, r5
   16638:	bf28      	it	cs
   1663a:	462f      	movcs	r7, r5
   1663c:	463a      	mov	r2, r7
   1663e:	4649      	mov	r1, r9
   16640:	f000 f8c6 	bl	167d0 <memmove>
   16644:	68a3      	ldr	r3, [r4, #8]
   16646:	6822      	ldr	r2, [r4, #0]
   16648:	1bdb      	subs	r3, r3, r7
   1664a:	443a      	add	r2, r7
   1664c:	60a3      	str	r3, [r4, #8]
   1664e:	6022      	str	r2, [r4, #0]
   16650:	2b00      	cmp	r3, #0
   16652:	d1ee      	bne.n	16632 <__sfvwrite_r+0x266>
   16654:	4621      	mov	r1, r4
   16656:	4650      	mov	r0, sl
   16658:	f7fe fe76 	bl	15348 <_fflush_r>
   1665c:	2800      	cmp	r0, #0
   1665e:	d0e8      	beq.n	16632 <__sfvwrite_r+0x266>
   16660:	e7b0      	b.n	165c4 <__sfvwrite_r+0x1f8>
   16662:	462f      	mov	r7, r5
   16664:	46ab      	mov	fp, r5
   16666:	e748      	b.n	164fa <__sfvwrite_r+0x12e>
   16668:	4621      	mov	r1, r4
   1666a:	4650      	mov	r0, sl
   1666c:	f7fe fe6c 	bl	15348 <_fflush_r>
   16670:	2800      	cmp	r0, #0
   16672:	d08e      	beq.n	16592 <__sfvwrite_r+0x1c6>
   16674:	e7a6      	b.n	165c4 <__sfvwrite_r+0x1f8>
   16676:	461a      	mov	r2, r3
   16678:	4631      	mov	r1, r6
   1667a:	9301      	str	r3, [sp, #4]
   1667c:	f000 f8a8 	bl	167d0 <memmove>
   16680:	9b01      	ldr	r3, [sp, #4]
   16682:	68a1      	ldr	r1, [r4, #8]
   16684:	6822      	ldr	r2, [r4, #0]
   16686:	1ac9      	subs	r1, r1, r3
   16688:	441a      	add	r2, r3
   1668a:	60a1      	str	r1, [r4, #8]
   1668c:	6022      	str	r2, [r4, #0]
   1668e:	461d      	mov	r5, r3
   16690:	e77b      	b.n	1658a <__sfvwrite_r+0x1be>
   16692:	4650      	mov	r0, sl
   16694:	f000 f904 	bl	168a0 <_realloc_r>
   16698:	4603      	mov	r3, r0
   1669a:	2800      	cmp	r0, #0
   1669c:	f47f af23 	bne.w	164e6 <__sfvwrite_r+0x11a>
   166a0:	6921      	ldr	r1, [r4, #16]
   166a2:	4650      	mov	r0, sl
   166a4:	f7fd ff30 	bl	14508 <_free_r>
   166a8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   166ac:	220c      	movs	r2, #12
   166ae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   166b2:	f8ca 2000 	str.w	r2, [sl]
   166b6:	e787      	b.n	165c8 <__sfvwrite_r+0x1fc>
   166b8:	230c      	movs	r3, #12
   166ba:	f8ca 3000 	str.w	r3, [sl]
   166be:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   166c2:	e781      	b.n	165c8 <__sfvwrite_r+0x1fc>
   166c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   166c8:	e76c      	b.n	165a4 <__sfvwrite_r+0x1d8>
   166ca:	bf00      	nop
   166cc:	7ffffffe 	.word	0x7ffffffe
   166d0:	7ffffc00 	.word	0x7ffffc00

000166d4 <_isatty_r>:
   166d4:	b538      	push	{r3, r4, r5, lr}
   166d6:	4c07      	ldr	r4, [pc, #28]	; (166f4 <_isatty_r+0x20>)
   166d8:	2300      	movs	r3, #0
   166da:	4605      	mov	r5, r0
   166dc:	4608      	mov	r0, r1
   166de:	6023      	str	r3, [r4, #0]
   166e0:	f7f5 fbaa 	bl	be38 <_isatty>
   166e4:	1c43      	adds	r3, r0, #1
   166e6:	d000      	beq.n	166ea <_isatty_r+0x16>
   166e8:	bd38      	pop	{r3, r4, r5, pc}
   166ea:	6823      	ldr	r3, [r4, #0]
   166ec:	2b00      	cmp	r3, #0
   166ee:	d0fb      	beq.n	166e8 <_isatty_r+0x14>
   166f0:	602b      	str	r3, [r5, #0]
   166f2:	bd38      	pop	{r3, r4, r5, pc}
   166f4:	2001cfd4 	.word	0x2001cfd4

000166f8 <_lseek_r>:
   166f8:	b570      	push	{r4, r5, r6, lr}
   166fa:	460d      	mov	r5, r1
   166fc:	4c08      	ldr	r4, [pc, #32]	; (16720 <_lseek_r+0x28>)
   166fe:	4611      	mov	r1, r2
   16700:	4606      	mov	r6, r0
   16702:	461a      	mov	r2, r3
   16704:	4628      	mov	r0, r5
   16706:	2300      	movs	r3, #0
   16708:	6023      	str	r3, [r4, #0]
   1670a:	f7f5 fb97 	bl	be3c <_lseek>
   1670e:	1c43      	adds	r3, r0, #1
   16710:	d000      	beq.n	16714 <_lseek_r+0x1c>
   16712:	bd70      	pop	{r4, r5, r6, pc}
   16714:	6823      	ldr	r3, [r4, #0]
   16716:	2b00      	cmp	r3, #0
   16718:	d0fb      	beq.n	16712 <_lseek_r+0x1a>
   1671a:	6033      	str	r3, [r6, #0]
   1671c:	bd70      	pop	{r4, r5, r6, pc}
   1671e:	bf00      	nop
   16720:	2001cfd4 	.word	0x2001cfd4
	...

00016730 <memchr>:
   16730:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   16734:	2a10      	cmp	r2, #16
   16736:	db2b      	blt.n	16790 <memchr+0x60>
   16738:	f010 0f07 	tst.w	r0, #7
   1673c:	d008      	beq.n	16750 <memchr+0x20>
   1673e:	f810 3b01 	ldrb.w	r3, [r0], #1
   16742:	3a01      	subs	r2, #1
   16744:	428b      	cmp	r3, r1
   16746:	d02d      	beq.n	167a4 <memchr+0x74>
   16748:	f010 0f07 	tst.w	r0, #7
   1674c:	b342      	cbz	r2, 167a0 <memchr+0x70>
   1674e:	d1f6      	bne.n	1673e <memchr+0xe>
   16750:	b4f0      	push	{r4, r5, r6, r7}
   16752:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   16756:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   1675a:	f022 0407 	bic.w	r4, r2, #7
   1675e:	f07f 0700 	mvns.w	r7, #0
   16762:	2300      	movs	r3, #0
   16764:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   16768:	3c08      	subs	r4, #8
   1676a:	ea85 0501 	eor.w	r5, r5, r1
   1676e:	ea86 0601 	eor.w	r6, r6, r1
   16772:	fa85 f547 	uadd8	r5, r5, r7
   16776:	faa3 f587 	sel	r5, r3, r7
   1677a:	fa86 f647 	uadd8	r6, r6, r7
   1677e:	faa5 f687 	sel	r6, r5, r7
   16782:	b98e      	cbnz	r6, 167a8 <memchr+0x78>
   16784:	d1ee      	bne.n	16764 <memchr+0x34>
   16786:	bcf0      	pop	{r4, r5, r6, r7}
   16788:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1678c:	f002 0207 	and.w	r2, r2, #7
   16790:	b132      	cbz	r2, 167a0 <memchr+0x70>
   16792:	f810 3b01 	ldrb.w	r3, [r0], #1
   16796:	3a01      	subs	r2, #1
   16798:	ea83 0301 	eor.w	r3, r3, r1
   1679c:	b113      	cbz	r3, 167a4 <memchr+0x74>
   1679e:	d1f8      	bne.n	16792 <memchr+0x62>
   167a0:	2000      	movs	r0, #0
   167a2:	4770      	bx	lr
   167a4:	3801      	subs	r0, #1
   167a6:	4770      	bx	lr
   167a8:	2d00      	cmp	r5, #0
   167aa:	bf06      	itte	eq
   167ac:	4635      	moveq	r5, r6
   167ae:	3803      	subeq	r0, #3
   167b0:	3807      	subne	r0, #7
   167b2:	f015 0f01 	tst.w	r5, #1
   167b6:	d107      	bne.n	167c8 <memchr+0x98>
   167b8:	3001      	adds	r0, #1
   167ba:	f415 7f80 	tst.w	r5, #256	; 0x100
   167be:	bf02      	ittt	eq
   167c0:	3001      	addeq	r0, #1
   167c2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   167c6:	3001      	addeq	r0, #1
   167c8:	bcf0      	pop	{r4, r5, r6, r7}
   167ca:	3801      	subs	r0, #1
   167cc:	4770      	bx	lr
   167ce:	bf00      	nop

000167d0 <memmove>:
   167d0:	4288      	cmp	r0, r1
   167d2:	b4f0      	push	{r4, r5, r6, r7}
   167d4:	d90d      	bls.n	167f2 <memmove+0x22>
   167d6:	188b      	adds	r3, r1, r2
   167d8:	4283      	cmp	r3, r0
   167da:	d90a      	bls.n	167f2 <memmove+0x22>
   167dc:	1884      	adds	r4, r0, r2
   167de:	b132      	cbz	r2, 167ee <memmove+0x1e>
   167e0:	4622      	mov	r2, r4
   167e2:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   167e6:	f802 4d01 	strb.w	r4, [r2, #-1]!
   167ea:	4299      	cmp	r1, r3
   167ec:	d1f9      	bne.n	167e2 <memmove+0x12>
   167ee:	bcf0      	pop	{r4, r5, r6, r7}
   167f0:	4770      	bx	lr
   167f2:	2a0f      	cmp	r2, #15
   167f4:	d80e      	bhi.n	16814 <memmove+0x44>
   167f6:	4603      	mov	r3, r0
   167f8:	1e54      	subs	r4, r2, #1
   167fa:	2a00      	cmp	r2, #0
   167fc:	d0f7      	beq.n	167ee <memmove+0x1e>
   167fe:	3401      	adds	r4, #1
   16800:	440c      	add	r4, r1
   16802:	3b01      	subs	r3, #1
   16804:	f811 2b01 	ldrb.w	r2, [r1], #1
   16808:	f803 2f01 	strb.w	r2, [r3, #1]!
   1680c:	42a1      	cmp	r1, r4
   1680e:	d1f9      	bne.n	16804 <memmove+0x34>
   16810:	bcf0      	pop	{r4, r5, r6, r7}
   16812:	4770      	bx	lr
   16814:	ea40 0301 	orr.w	r3, r0, r1
   16818:	079b      	lsls	r3, r3, #30
   1681a:	d13b      	bne.n	16894 <memmove+0xc4>
   1681c:	f1a2 0710 	sub.w	r7, r2, #16
   16820:	093f      	lsrs	r7, r7, #4
   16822:	f101 0620 	add.w	r6, r1, #32
   16826:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   1682a:	f101 0310 	add.w	r3, r1, #16
   1682e:	f100 0410 	add.w	r4, r0, #16
   16832:	f853 5c10 	ldr.w	r5, [r3, #-16]
   16836:	f844 5c10 	str.w	r5, [r4, #-16]
   1683a:	f853 5c0c 	ldr.w	r5, [r3, #-12]
   1683e:	f844 5c0c 	str.w	r5, [r4, #-12]
   16842:	f853 5c08 	ldr.w	r5, [r3, #-8]
   16846:	f844 5c08 	str.w	r5, [r4, #-8]
   1684a:	f853 5c04 	ldr.w	r5, [r3, #-4]
   1684e:	f844 5c04 	str.w	r5, [r4, #-4]
   16852:	3310      	adds	r3, #16
   16854:	42b3      	cmp	r3, r6
   16856:	f104 0410 	add.w	r4, r4, #16
   1685a:	d1ea      	bne.n	16832 <memmove+0x62>
   1685c:	1c7b      	adds	r3, r7, #1
   1685e:	011b      	lsls	r3, r3, #4
   16860:	f012 0f0c 	tst.w	r2, #12
   16864:	4419      	add	r1, r3
   16866:	f002 050f 	and.w	r5, r2, #15
   1686a:	4403      	add	r3, r0
   1686c:	d015      	beq.n	1689a <memmove+0xca>
   1686e:	3d04      	subs	r5, #4
   16870:	08ad      	lsrs	r5, r5, #2
   16872:	eb03 0c85 	add.w	ip, r3, r5, lsl #2
   16876:	1f1c      	subs	r4, r3, #4
   16878:	460e      	mov	r6, r1
   1687a:	f856 7b04 	ldr.w	r7, [r6], #4
   1687e:	f844 7f04 	str.w	r7, [r4, #4]!
   16882:	4564      	cmp	r4, ip
   16884:	d1f9      	bne.n	1687a <memmove+0xaa>
   16886:	3501      	adds	r5, #1
   16888:	00ad      	lsls	r5, r5, #2
   1688a:	442b      	add	r3, r5
   1688c:	4429      	add	r1, r5
   1688e:	f002 0203 	and.w	r2, r2, #3
   16892:	e7b1      	b.n	167f8 <memmove+0x28>
   16894:	1e54      	subs	r4, r2, #1
   16896:	4603      	mov	r3, r0
   16898:	e7b1      	b.n	167fe <memmove+0x2e>
   1689a:	462a      	mov	r2, r5
   1689c:	e7ac      	b.n	167f8 <memmove+0x28>
   1689e:	bf00      	nop

000168a0 <_realloc_r>:
   168a0:	b309      	cbz	r1, 168e6 <_realloc_r+0x46>
   168a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   168a4:	4614      	mov	r4, r2
   168a6:	b1ca      	cbz	r2, 168dc <_realloc_r+0x3c>
   168a8:	4606      	mov	r6, r0
   168aa:	460d      	mov	r5, r1
   168ac:	f000 f834 	bl	16918 <_malloc_usable_size_r>
   168b0:	42a0      	cmp	r0, r4
   168b2:	d302      	bcc.n	168ba <_realloc_r+0x1a>
   168b4:	462f      	mov	r7, r5
   168b6:	4638      	mov	r0, r7
   168b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   168ba:	4621      	mov	r1, r4
   168bc:	4630      	mov	r0, r6
   168be:	f7fd fe79 	bl	145b4 <_malloc_r>
   168c2:	4607      	mov	r7, r0
   168c4:	2800      	cmp	r0, #0
   168c6:	d0f6      	beq.n	168b6 <_realloc_r+0x16>
   168c8:	4622      	mov	r2, r4
   168ca:	4629      	mov	r1, r5
   168cc:	f7fd fd32 	bl	14334 <memcpy>
   168d0:	4630      	mov	r0, r6
   168d2:	4629      	mov	r1, r5
   168d4:	f7fd fe18 	bl	14508 <_free_r>
   168d8:	4638      	mov	r0, r7
   168da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   168dc:	4627      	mov	r7, r4
   168de:	f7fd fe13 	bl	14508 <_free_r>
   168e2:	4638      	mov	r0, r7
   168e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   168e6:	4611      	mov	r1, r2
   168e8:	f7fd be64 	b.w	145b4 <_malloc_r>

000168ec <_read_r>:
   168ec:	b570      	push	{r4, r5, r6, lr}
   168ee:	460d      	mov	r5, r1
   168f0:	4c08      	ldr	r4, [pc, #32]	; (16914 <_read_r+0x28>)
   168f2:	4611      	mov	r1, r2
   168f4:	4606      	mov	r6, r0
   168f6:	461a      	mov	r2, r3
   168f8:	4628      	mov	r0, r5
   168fa:	2300      	movs	r3, #0
   168fc:	6023      	str	r3, [r4, #0]
   168fe:	f7f7 f88b 	bl	da18 <_read>
   16902:	1c43      	adds	r3, r0, #1
   16904:	d000      	beq.n	16908 <_read_r+0x1c>
   16906:	bd70      	pop	{r4, r5, r6, pc}
   16908:	6823      	ldr	r3, [r4, #0]
   1690a:	2b00      	cmp	r3, #0
   1690c:	d0fb      	beq.n	16906 <_read_r+0x1a>
   1690e:	6033      	str	r3, [r6, #0]
   16910:	bd70      	pop	{r4, r5, r6, pc}
   16912:	bf00      	nop
   16914:	2001cfd4 	.word	0x2001cfd4

00016918 <_malloc_usable_size_r>:
   16918:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1691c:	1f18      	subs	r0, r3, #4
   1691e:	2b00      	cmp	r3, #0
   16920:	bfbc      	itt	lt
   16922:	580b      	ldrlt	r3, [r1, r0]
   16924:	18c0      	addlt	r0, r0, r3
   16926:	4770      	bx	lr
   16928:	6d617246 	.word	0x6d617246
   1692c:	74532065 	.word	0x74532065
   16930:	20747261 	.word	0x20747261
   16934:	7366664f 	.word	0x7366664f
   16938:	7b007465 	.word	0x7b007465
   1693c:	70797422 	.word	0x70797422
   16940:	223a2265 	.word	0x223a2265
   16944:	4e524157 	.word	0x4e524157
   16948:	22474e49 	.word	0x22474e49
   1694c:	6422202c 	.word	0x6422202c
   16950:	22617461 	.word	0x22617461
   16954:	225b203a 	.word	0x225b203a
   16958:	5d227325 	.word	0x5d227325
   1695c:	000a0d7d 	.word	0x000a0d7d
   16960:	6e6e6f43 	.word	0x6e6e6f43
   16964:	00746365 	.word	0x00746365
   16968:	7974227b 	.word	0x7974227b
   1696c:	3a226570 	.word	0x3a226570
   16970:	41572220 	.word	0x41572220
   16974:	4e494e52 	.word	0x4e494e52
   16978:	202c2247 	.word	0x202c2247
   1697c:	74616422 	.word	0x74616422
   16980:	203a2261 	.word	0x203a2261
   16984:	6e55225b 	.word	0x6e55225b
   16988:	776f6e6b 	.word	0x776f6e6b
   1698c:	73654d20 	.word	0x73654d20
   16990:	65676173 	.word	0x65676173
   16994:	70795420 	.word	0x70795420
   16998:	7d5d2265 	.word	0x7d5d2265
   1699c:	227b000d 	.word	0x227b000d
   169a0:	65707974 	.word	0x65707974
   169a4:	22203a22 	.word	0x22203a22
   169a8:	4e524157 	.word	0x4e524157
   169ac:	22474e49 	.word	0x22474e49
   169b0:	6422202c 	.word	0x6422202c
   169b4:	22617461 	.word	0x22617461
   169b8:	225b203a 	.word	0x225b203a
   169bc:	61766e49 	.word	0x61766e49
   169c0:	2064696c 	.word	0x2064696c
   169c4:	63656843 	.word	0x63656843
   169c8:	6d75736b 	.word	0x6d75736b
   169cc:	0d7d5d22 	.word	0x0d7d5d22
   169d0:	6d695400 	.word	0x6d695400
   169d4:	74756f65 	.word	0x74756f65
   169d8:	73694420 	.word	0x73694420
   169dc:	6e6e6f63 	.word	0x6e6e6f63
   169e0:	20746365 	.word	0x20746365
   169e4:	65522026 	.word	0x65522026
   169e8:	20746573 	.word	0x20746573
   169ec:	65636552 	.word	0x65636552
   169f0:	72657669 	.word	0x72657669
   169f4:	6d695400 	.word	0x6d695400
   169f8:	74756f65 	.word	0x74756f65
   169fc:	52202620 	.word	0x52202620
   16a00:	74657365 	.word	0x74657365
   16a04:	63655220 	.word	0x63655220
   16a08:	65766965 	.word	0x65766965
   16a0c:	63250072 	.word	0x63250072
   16a10:	63256325 	.word	0x63256325
   16a14:	30256325 	.word	0x30256325
   16a18:	30257832 	.word	0x30257832
   16a1c:	30257832 	.word	0x30257832
   16a20:	63257832 	.word	0x63257832
   16a24:	000a3030 	.word	0x000a3030
   16a28:	30256325 	.word	0x30256325
   16a2c:	2e5f7833 	.word	0x2e5f7833
   16a30:	2e2e2e2e 	.word	0x2e2e2e2e
   16a34:	2e2e2e2e 	.word	0x2e2e2e2e
   16a38:	2e2e2e2e 	.word	0x2e2e2e2e
   16a3c:	2e2e2e2e 	.word	0x2e2e2e2e
   16a40:	2e2e2e2e 	.word	0x2e2e2e2e
   16a44:	2e2e2e2e 	.word	0x2e2e2e2e
   16a48:	2e2e2e2e 	.word	0x2e2e2e2e
   16a4c:	252e2e2e 	.word	0x252e2e2e
   16a50:	63250063 	.word	0x63250063
   16a54:	78333025 	.word	0x78333025
   16a58:	2e2e2e5f 	.word	0x2e2e2e5f
   16a5c:	2e2e2e2e 	.word	0x2e2e2e2e
   16a60:	0063252e 	.word	0x0063252e
   16a64:	30256325 	.word	0x30256325
   16a68:	2e5f7833 	.word	0x2e5f7833
   16a6c:	0063252e 	.word	0x0063252e
   16a70:	30256325 	.word	0x30256325
   16a74:	2e5f7833 	.word	0x2e5f7833
   16a78:	2e2e2e2e 	.word	0x2e2e2e2e
   16a7c:	0063252e 	.word	0x0063252e
   16a80:	7974227b 	.word	0x7974227b
   16a84:	3a226570 	.word	0x3a226570
   16a88:	43574822 	.word	0x43574822
   16a8c:	2c224746 	.word	0x2c224746
   16a90:	61642220 	.word	0x61642220
   16a94:	3a226174 	.word	0x3a226174
   16a98:	64252220 	.word	0x64252220
   16a9c:	0a0d7d22 	.word	0x0a0d7d22
   16aa0:	204f4e00 	.word	0x204f4e00
   16aa4:	52455355 	.word	0x52455355
   16aa8:	574f5220 	.word	0x574f5220
   16aac:	45484320 	.word	0x45484320
   16ab0:	00214b43 	.word	0x00214b43
   16ab4:	55206f4e 	.word	0x55206f4e
   16ab8:	2074696e 	.word	0x2074696e
   16abc:	74736554 	.word	0x74736554
   16ac0:	206f4e00 	.word	0x206f4e00
   16ac4:	64726148 	.word	0x64726148
   16ac8:	65726177 	.word	0x65726177
   16acc:	73655420 	.word	0x73655420
   16ad0:	65520074 	.word	0x65520074
   16ad4:	6e696461 	.word	0x6e696461
   16ad8:	73552067 	.word	0x73552067
   16adc:	52207265 	.word	0x52207265
   16ae0:	7b00776f 	.word	0x7b00776f
   16ae4:	70797422 	.word	0x70797422
   16ae8:	223a2265 	.word	0x223a2265
   16aec:	22474f4c 	.word	0x22474f4c
   16af0:	6422202c 	.word	0x6422202c
   16af4:	22617461 	.word	0x22617461
   16af8:	225b203a 	.word	0x225b203a
   16afc:	5d227325 	.word	0x5d227325
   16b00:	000a0d7d 	.word	0x000a0d7d
   16b04:	69726556 	.word	0x69726556
   16b08:	6e697966 	.word	0x6e697966
   16b0c:	73552067 	.word	0x73552067
   16b10:	52207265 	.word	0x52207265
   16b14:	5500776f 	.word	0x5500776f
   16b18:	74616470 	.word	0x74616470
   16b1c:	20676e69 	.word	0x20676e69
   16b20:	72657355 	.word	0x72657355
   16b24:	776f5220 	.word	0x776f5220
   16b28:	73795300 	.word	0x73795300
   16b2c:	206d6574 	.word	0x206d6574
   16b30:	65736552 	.word	0x65736552
   16b34:	6e550074 	.word	0x6e550074
   16b38:	6e616863 	.word	0x6e616863
   16b3c:	20646567 	.word	0x20646567
   16b40:	72657355 	.word	0x72657355
   16b44:	776f5220 	.word	0x776f5220
   16b48:	00          	.byte	0x00
   16b49:	45          	.byte	0x45
   16b4a:	5252      	.short	0x5252
   16b4c:	6920524f 	.word	0x6920524f
   16b50:	7865206e 	.word	0x7865206e
   16b54:	6c5f7270 	.word	0x6c5f7270
   16b58:	6c657665 	.word	0x6c657665
   16b5c:	2928335f 	.word	0x2928335f
   16b60:	73626100 	.word	0x73626100
   16b64:	78697300 	.word	0x78697300
   16b68:	64646100 	.word	0x64646100
   16b6c:	69727000 	.word	0x69727000
   16b70:	6900746e 	.word	0x6900746e
   16b74:	75460066 	.word	0x75460066
   16b78:	6974636e 	.word	0x6974636e
   16b7c:	22206e6f 	.word	0x22206e6f
   16b80:	20227325 	.word	0x20227325
   16b84:	20746f6e 	.word	0x20746f6e
   16b88:	6e756f66 	.word	0x6e756f66
   16b8c:	000a2164 	.word	0x000a2164
   16b90:	29642528 	.word	0x29642528
   16b94:	32302500 	.word	0x32302500
   16b98:	0078      	.short	0x0078
   16b9a:	3002      	.short	0x3002
   16b9c:	7b653035 	.word	0x7b653035
   16ba0:	305a2870 	.word	0x305a2870
   16ba4:	30307d29 	.word	0x30307d29
   16ba8:	30306330 	.word	0x30306330
   16bac:	30020003 	.word	0x30020003
   16bb0:	7b653035 	.word	0x7b653035
   16bb4:	305a2870 	.word	0x305a2870
   16bb8:	30307d29 	.word	0x30307d29
   16bbc:	707b3830 	.word	0x707b3830
   16bc0:	29345a28 	.word	0x29345a28
   16bc4:	3002037d 	.word	0x3002037d
   16bc8:	7b653033 	.word	0x7b653033
   16bcc:	355a2870 	.word	0x355a2870
   16bd0:	00037d29 	.word	0x00037d29
   16bd4:	30353002 	.word	0x30353002
   16bd8:	28707b65 	.word	0x28707b65
   16bdc:	7d29305a 	.word	0x7d29305a
   16be0:	39303030 	.word	0x39303030
   16be4:	5a28707b 	.word	0x5a28707b
   16be8:	037d2934 	.word	0x037d2934
   16bec:	35300200 	.word	0x35300200
   16bf0:	707b6530 	.word	0x707b6530
   16bf4:	29305a28 	.word	0x29305a28
   16bf8:	3030307d 	.word	0x3030307d
   16bfc:	28707b61 	.word	0x28707b61
   16c00:	7d29345a 	.word	0x7d29345a
   16c04:	33300203 	.word	0x33300203
   16c08:	707b6530 	.word	0x707b6530
   16c0c:	29305a28 	.word	0x29305a28
   16c10:	0200037d 	.word	0x0200037d
   16c14:	65303530 	.word	0x65303530
   16c18:	5a28707b 	.word	0x5a28707b
   16c1c:	307d2930 	.word	0x307d2930
   16c20:	7b623030 	.word	0x7b623030
   16c24:	345a2870 	.word	0x345a2870
   16c28:	02037d29 	.word	0x02037d29
   16c2c:	66303330 	.word	0x66303330
   16c30:	5a28707b 	.word	0x5a28707b
   16c34:	037d2930 	.word	0x037d2930
   16c38:	20495500 	.word	0x20495500
   16c3c:	65776f50 	.word	0x65776f50
   16c40:	6e452072 	.word	0x6e452072
   16c44:	656c6261 	.word	0x656c6261
   16c48:	696e4900 	.word	0x696e4900
   16c4c:	6f4d2074 	.word	0x6f4d2074
   16c50:	656c7564 	.word	0x656c7564
   16c54:	4f50203a 	.word	0x4f50203a
   16c58:	49003631 	.word	0x49003631
   16c5c:	2074696e 	.word	0x2074696e
   16c60:	75646f4d 	.word	0x75646f4d
   16c64:	203a656c 	.word	0x203a656c
   16c68:	36315542 	.word	0x36315542
   16c6c:	696e4900 	.word	0x696e4900
   16c70:	6f4d2074 	.word	0x6f4d2074
   16c74:	656c7564 	.word	0x656c7564
   16c78:	4250203a 	.word	0x4250203a
   16c7c:	49003446 	.word	0x49003446
   16c80:	2074696e 	.word	0x2074696e
   16c84:	75646f4d 	.word	0x75646f4d
   16c88:	203a656c 	.word	0x203a656c
   16c8c:	36314e45 	.word	0x36314e45
   16c90:	696e4900 	.word	0x696e4900
   16c94:	6f4d2074 	.word	0x6f4d2074
   16c98:	656c7564 	.word	0x656c7564
   16c9c:	6e55203a 	.word	0x6e55203a
   16ca0:	776f6e6b 	.word	0x776f6e6b
   16ca4:	6f4d206e 	.word	0x6f4d206e
   16ca8:	656c7564 	.word	0x656c7564
   16cac:	43574800 	.word	0x43574800
   16cb0:	4d204746 	.word	0x4d204746
   16cb4:	616d7369 	.word	0x616d7369
   16cb8:	00686374 	.word	0x00686374
   16cbc:	0f0e0d0c 	.word	0x0f0e0d0c
   16cc0:	0b0a0908 	.word	0x0b0a0908
   16cc4:	07060504 	.word	0x07060504
   16cc8:	03020100 	.word	0x03020100
   16ccc:	0f0e0d0c 	.word	0x0f0e0d0c
   16cd0:	0b0a0908 	.word	0x0b0a0908
   16cd4:	07060504 	.word	0x07060504
   16cd8:	03020100 	.word	0x03020100
   16cdc:	0f0e0d0c 	.word	0x0f0e0d0c
   16ce0:	0b0a0908 	.word	0x0b0a0908
   16ce4:	07060504 	.word	0x07060504
   16ce8:	03020100 	.word	0x03020100
   16cec:	0f0e0d0c 	.word	0x0f0e0d0c
   16cf0:	0b0a0908 	.word	0x0b0a0908
   16cf4:	07060504 	.word	0x07060504
   16cf8:	03020100 	.word	0x03020100
   16cfc:	63256325 	.word	0x63256325
   16d00:	2e2e2e2e 	.word	0x2e2e2e2e
   16d04:	2e2e2e2e 	.word	0x2e2e2e2e
   16d08:	2e2e2e2e 	.word	0x2e2e2e2e
   16d0c:	6325      	.short	0x6325
   16d0e:	00          	.byte	0x00
   16d0f:	25          	.byte	0x25
   16d10:	33302563 	.word	0x33302563
   16d14:	63256578 	.word	0x63256578
   16d18:	00          	.byte	0x00
   16d19:	25          	.byte	0x25
   16d1a:	2563      	.short	0x2563
   16d1c:	5f783330 	.word	0x5f783330
   16d20:	2e2e2e2e 	.word	0x2e2e2e2e
   16d24:	25006325 	.word	0x25006325
   16d28:	33302563 	.word	0x33302563
   16d2c:	23006578 	.word	0x23006578
   16d30:	23200020 	.word	0x23200020
   16d34:	38302500 	.word	0x38302500
   16d38:	72670078 	.word	0x72670078
   16d3c:	735f6469 	.word	0x735f6469
   16d40:	3a3a7379 	.word	0x3a3a7379
   16d44:	63656863 	.word	0x63656863
   16d48:	6d75736b 	.word	0x6d75736b
   16d4c:	65684300 	.word	0x65684300
   16d50:	75736b63 	.word	0x75736b63
   16d54:	6552206d 	.word	0x6552206d
   16d58:	432f6461 	.word	0x432f6461
   16d5c:	75636c61 	.word	0x75636c61
   16d60:	6574616c 	.word	0x6574616c
   16d64:	63617000 	.word	0x63617000
   16d68:	7b74656b 	.word	0x7b74656b
   16d6c:	202c6425 	.word	0x202c6425
   16d70:	202c6425 	.word	0x202c6425
   16d74:	202c6425 	.word	0x202c6425
   16d78:	202c6425 	.word	0x202c6425
   16d7c:	202c6425 	.word	0x202c6425
   16d80:	202c6425 	.word	0x202c6425
   16d84:	202c6425 	.word	0x202c6425
   16d88:	207d6425 	.word	0x207d6425
   16d8c:	64616552 	.word	0x64616552
   16d90:	6425203a 	.word	0x6425203a
   16d94:	6143202c 	.word	0x6143202c
   16d98:	6c75636c 	.word	0x6c75636c
   16d9c:	3a657461 	.word	0x3a657461
   16da0:	00642520 	.word	0x00642520
   16da4:	63656843 	.word	0x63656843
   16da8:	6d75736b 	.word	0x6d75736b
   16dac:	69725720 	.word	0x69725720
   16db0:	432f6574 	.word	0x432f6574
   16db4:	75636c61 	.word	0x75636c61
   16db8:	6574616c 	.word	0x6574616c
   16dbc:	65684300 	.word	0x65684300
   16dc0:	75736b63 	.word	0x75736b63
   16dc4:	764f206d 	.word	0x764f206d
   16dc8:	72777265 	.word	0x72777265
   16dcc:	00657469 	.word	0x00657469
   16dd0:	61726150 	.word	0x61726150
   16dd4:	72706170 	.word	0x72706170
   16dd8:	73616b69 	.word	0x73616b69
   16ddc:	00          	.byte	0x00
   16ddd:	25          	.byte	0x25
   16dde:	2563      	.short	0x2563
   16de0:	5f783330 	.word	0x5f783330
   16de4:	2e2e2e2e 	.word	0x2e2e2e2e
   16de8:	02002e2e 	.word	0x02002e2e
   16dec:	65313430 	.word	0x65313430
   16df0:	5428707b 	.word	0x5428707b
   16df4:	307d2930 	.word	0x307d2930
   16df8:	28707b31 	.word	0x28707b31
   16dfc:	7d29315a 	.word	0x7d29315a
   16e00:	5a28707b 	.word	0x5a28707b
   16e04:	7b7d2932 	.word	0x7b7d2932
   16e08:	335a2870 	.word	0x335a2870
   16e0c:	00037d29 	.word	0x00037d29
   16e10:	30303002 	.word	0x30303002
   16e14:	39303065 	.word	0x39303065
   16e18:	28707b30 	.word	0x28707b30
   16e1c:	7d293054 	.word	0x7d293054
   16e20:	5428707b 	.word	0x5428707b
   16e24:	037d2932 	.word	0x037d2932
   16e28:	30343002 	.word	0x30343002
   16e2c:	28707b65 	.word	0x28707b65
   16e30:	7d293054 	.word	0x7d293054
   16e34:	707b3130 	.word	0x707b3130
   16e38:	29325428 	.word	0x29325428
   16e3c:	0200037d 	.word	0x0200037d
   16e40:	65303030 	.word	0x65303030
   16e44:	30383030 	.word	0x30383030
   16e48:	5428707b 	.word	0x5428707b
   16e4c:	7b7d2930 	.word	0x7b7d2930
   16e50:	32542870 	.word	0x32542870
   16e54:	02037d29 	.word	0x02037d29
   16e58:	65303430 	.word	0x65303430
   16e5c:	5428707b 	.word	0x5428707b
   16e60:	307d2930 	.word	0x307d2930
   16e64:	28707b31 	.word	0x28707b31
   16e68:	7d293254 	.word	0x7d293254
   16e6c:	30020003 	.word	0x30020003
   16e70:	30653030 	.word	0x30653030
   16e74:	7b306230 	.word	0x7b306230
   16e78:	30542870 	.word	0x30542870
   16e7c:	707b7d29 	.word	0x707b7d29
   16e80:	29325428 	.word	0x29325428
   16e84:	3002037d 	.word	0x3002037d
   16e88:	7b653034 	.word	0x7b653034
   16e8c:	30542870 	.word	0x30542870
   16e90:	31307d29 	.word	0x31307d29
   16e94:	5428707b 	.word	0x5428707b
   16e98:	037d2932 	.word	0x037d2932
   16e9c:	34300200 	.word	0x34300200
   16ea0:	707b6531 	.word	0x707b6531
   16ea4:	29305428 	.word	0x29305428
   16ea8:	7b31307d 	.word	0x7b31307d
   16eac:	315a2870 	.word	0x315a2870
   16eb0:	707b7d29 	.word	0x707b7d29
   16eb4:	29325a28 	.word	0x29325a28
   16eb8:	28707b7d 	.word	0x28707b7d
   16ebc:	7d29335a 	.word	0x7d29335a
   16ec0:	34300203 	.word	0x34300203
   16ec4:	707b6531 	.word	0x707b6531
   16ec8:	29305428 	.word	0x29305428
   16ecc:	7b32307d 	.word	0x7b32307d
   16ed0:	315a2870 	.word	0x315a2870
   16ed4:	707b7d29 	.word	0x707b7d29
   16ed8:	29325a28 	.word	0x29325a28
   16edc:	28707b7d 	.word	0x28707b7d
   16ee0:	7d29335a 	.word	0x7d29335a
   16ee4:	30020003 	.word	0x30020003
   16ee8:	30653030 	.word	0x30653030
   16eec:	7b306230 	.word	0x7b306230
   16ef0:	30542870 	.word	0x30542870
   16ef4:	707b7d29 	.word	0x707b7d29
   16ef8:	29385428 	.word	0x29385428
   16efc:	4923037d 	.word	0x4923037d
   16f00:	305a7b46 	.word	0x305a7b46
   16f04:	7d333d3d 	.word	0x7d333d3d
   16f08:	02485423 	.word	0x02485423
   16f0c:	65313430 	.word	0x65313430
   16f10:	5428707b 	.word	0x5428707b
   16f14:	307d2930 	.word	0x307d2930
   16f18:	28707b31 	.word	0x28707b31
   16f1c:	7d293854 	.word	0x7d293854
   16f20:	5a28707b 	.word	0x5a28707b
   16f24:	7b7d2932 	.word	0x7b7d2932
   16f28:	32312870 	.word	0x32312870
   16f2c:	38542d38 	.word	0x38542d38
   16f30:	23037d29 	.word	0x23037d29
   16f34:	45234c45 	.word	0x45234c45
   16f38:	3430024e 	.word	0x3430024e
   16f3c:	707b6530 	.word	0x707b6530
   16f40:	29305428 	.word	0x29305428
   16f44:	7b31307d 	.word	0x7b31307d
   16f48:	38542870 	.word	0x38542870
   16f4c:	00037d29 	.word	0x00037d29
   16f50:	30303002 	.word	0x30303002
   16f54:	62303065 	.word	0x62303065
   16f58:	28707b30 	.word	0x28707b30
   16f5c:	7d293054 	.word	0x7d293054
   16f60:	5428707b 	.word	0x5428707b
   16f64:	037d2938 	.word	0x037d2938
   16f68:	30343002 	.word	0x30343002
   16f6c:	28707b65 	.word	0x28707b65
   16f70:	7d293054 	.word	0x7d293054
   16f74:	707b3130 	.word	0x707b3130
   16f78:	29385428 	.word	0x29385428
   16f7c:	0200037d 	.word	0x0200037d
   16f80:	65303030 	.word	0x65303030
   16f84:	30393030 	.word	0x30393030
   16f88:	5428707b 	.word	0x5428707b
   16f8c:	7b7d2930 	.word	0x7b7d2930
   16f90:	32542870 	.word	0x32542870
   16f94:	02037d29 	.word	0x02037d29
   16f98:	65303430 	.word	0x65303430
   16f9c:	5428707b 	.word	0x5428707b
   16fa0:	307d2930 	.word	0x307d2930
   16fa4:	28707b32 	.word	0x28707b32
   16fa8:	7d293254 	.word	0x7d293254
   16fac:	30020003 	.word	0x30020003
   16fb0:	30653030 	.word	0x30653030
   16fb4:	7b303830 	.word	0x7b303830
   16fb8:	30542870 	.word	0x30542870
   16fbc:	707b7d29 	.word	0x707b7d29
   16fc0:	29325428 	.word	0x29325428
   16fc4:	3002037d 	.word	0x3002037d
   16fc8:	7b653034 	.word	0x7b653034
   16fcc:	30542870 	.word	0x30542870
   16fd0:	32307d29 	.word	0x32307d29
   16fd4:	5428707b 	.word	0x5428707b
   16fd8:	037d2932 	.word	0x037d2932
   16fdc:	67655200 	.word	0x67655200
   16fe0:	65747369 	.word	0x65747369
   16fe4:	63412072 	.word	0x63412072
   16fe8:	6e6f6974 	.word	0x6e6f6974
   16fec:	65764500 	.word	0x65764500
   16ff0:	4e20746e 	.word	0x4e20746e
   16ff4:	4620746f 	.word	0x4620746f
   16ff8:	646e756f 	.word	0x646e756f
   16ffc:	73452000 	.word	0x73452000
   17000:	65706163 	.word	0x65706163
   17004:	68432064 	.word	0x68432064
   17008:	46207261 	.word	0x46207261
   1700c:	646e756f 	.word	0x646e756f
   17010:	30020020 	.word	0x30020020
   17014:	7b653035 	.word	0x7b653035
   17018:	305a2870 	.word	0x305a2870
   1701c:	707b7d29 	.word	0x707b7d29
   17020:	29305428 	.word	0x29305428
   17024:	3030307d 	.word	0x3030307d
   17028:	02000330 	.word	0x02000330
   1702c:	65303530 	.word	0x65303530
   17030:	5a28707b 	.word	0x5a28707b
   17034:	7b7d2930 	.word	0x7b7d2930
   17038:	30542870 	.word	0x30542870
   1703c:	34307d29 	.word	0x34307d29
   17040:	5428707b 	.word	0x5428707b
   17044:	037d2932 	.word	0x037d2932
   17048:	35300200 	.word	0x35300200
   1704c:	707b6530 	.word	0x707b6530
   17050:	29305a28 	.word	0x29305a28
   17054:	28707b7d 	.word	0x28707b7d
   17058:	7d293054 	.word	0x7d293054
   1705c:	707b3530 	.word	0x707b3530
   17060:	29325428 	.word	0x29325428
   17064:	0200037d 	.word	0x0200037d
   17068:	65303530 	.word	0x65303530
   1706c:	5a28707b 	.word	0x5a28707b
   17070:	7b7d2930 	.word	0x7b7d2930
   17074:	30542870 	.word	0x30542870
   17078:	31307d29 	.word	0x31307d29
   1707c:	5428707b 	.word	0x5428707b
   17080:	037d2932 	.word	0x037d2932
   17084:	35300200 	.word	0x35300200
   17088:	707b6530 	.word	0x707b6530
   1708c:	29305a28 	.word	0x29305a28
   17090:	28707b7d 	.word	0x28707b7d
   17094:	7d293054 	.word	0x7d293054
   17098:	707b3130 	.word	0x707b3130
   1709c:	29355428 	.word	0x29355428
   170a0:	0200037d 	.word	0x0200037d
   170a4:	65303530 	.word	0x65303530
   170a8:	5a28707b 	.word	0x5a28707b
   170ac:	7b7d2930 	.word	0x7b7d2930
   170b0:	30542870 	.word	0x30542870
   170b4:	64307d29 	.word	0x64307d29
   170b8:	5428707b 	.word	0x5428707b
   170bc:	037d2935 	.word	0x037d2935
   170c0:	6e795300 	.word	0x6e795300
   170c4:	20786174 	.word	0x20786174
   170c8:	6f727245 	.word	0x6f727245
   170cc:	000d2172 	.word	0x000d2172
   170d0:	20009150 	.word	0x20009150
   170d4:	20019870 	.word	0x20019870
   170d8:	200138d4 	.word	0x200138d4
   170dc:	200102d4 	.word	0x200102d4
   170e0:	682f2e2e 	.word	0x682f2e2e
   170e4:	732f6c61 	.word	0x732f6c61
   170e8:	682f6372 	.word	0x682f6372
   170ec:	695f6c61 	.word	0x695f6c61
   170f0:	00632e6f 	.word	0x00632e6f
   170f4:	682f2e2e 	.word	0x682f2e2e
   170f8:	732f6c61 	.word	0x732f6c61
   170fc:	682f6372 	.word	0x682f6372
   17100:	695f6c61 	.word	0x695f6c61
   17104:	6d5f6332 	.word	0x6d5f6332
   17108:	7973615f 	.word	0x7973615f
   1710c:	632e636e 	.word	0x632e636e
   17110:	00          	.byte	0x00
   17111:	2e          	.byte	0x2e
   17112:	2f2e      	.short	0x2f2e
   17114:	2f6c7068 	.word	0x2f6c7068
   17118:	2f746477 	.word	0x2f746477
   1711c:	5f6c7068 	.word	0x5f6c7068
   17120:	2e746477 	.word	0x2e746477
   17124:	0063      	.short	0x0063
   17126:	2e2e      	.short	0x2e2e
   17128:	6c61682f 	.word	0x6c61682f
   1712c:	6372732f 	.word	0x6372732f
   17130:	6c61682f 	.word	0x6c61682f
   17134:	6970735f 	.word	0x6970735f
   17138:	645f6d5f 	.word	0x645f6d5f
   1713c:	632e616d 	.word	0x632e616d
   17140:	00000000 	.word	0x00000000

00017144 <user_mux_confs>:
	...
   17170:	04030201 04030201 00000000 00000000     ................
	...

00017188 <channel_confs>:
   17188:	05230522 05250524 00000000 00000000     ".#.$.%.........
	...

000171c8 <interrupt_cfg>:
   171c8:	00000002 00000002 00000002 00000002     ................
	...
   17248:	682f2e2e 712f6c70 2f697073 5f6c7068     ../hpl/qspi/hpl_
   17258:	69707371 2e00632e 70682f2e 766e2f6c     qspi.c.../hpl/nv
   17268:	7274636d 70682f6c 766e5f6c 7274636d     mctrl/hpl_nvmctr
   17278:	00632e6c 682f2e2e 732f6c61 682f6372     l.c.../hal/src/h
   17288:	745f6c61 72656d69 0000632e              al_timer.c..

00017294 <_usb_ep_cfgs>:
   17294:	20008928 00000000 00000040 00000000     (.. ....@.......
	...
   172ac:	20008920 00000000 00000008 200088e0      .. ........... 
   172bc:	200088d8 00080040 00000000 00000000     ... @...........
	...
   172d4:	20008898 00400000 20726d54 00637653     ... ..@.Tmr Svc.

000172e4 <mouse_report_desc>:
   172e4:	02090105 010901a1 090500a1 03290119     ..............).
   172f4:	01250015 03950175 05750281 01810195     ..%.u.....u.....
   17304:	30090105 38093109 7f258115 03950875     ...0.1.8..%.u...
   17314:	c0c00681                                ....

00017318 <_cfgs>:
   17318:	00200600 08068000 00200400 08068000     .. ....... .....
   17328:	00201000 08068000 00200c00 08068000     .. ....... .....
	...
   17348:	00200b00 14000003 00200a00 08000002     .. ....... .....
   17358:	00201300 14000003 00000000 00000000     .. .............
	...
   17408:	00005400 1c000000 00005300 0c000000     .T.......S......
   17418:	682f2e2e 732f6c61 682f6372 615f6c61     ../hal/src/hal_a
   17428:	615f6364 636e7973 2e00632e 61682f2e     dc_async.c.../ha
   17438:	72732f6c 61682f63 61725f6c 735f646e     l/src/hal_rand_s
   17448:	2e636e79 2e2e0063 6c70682f 6e72742f     ync.c.../hpl/trn
   17458:	70682f67 72745f6c 632e676e               g/hpl_trng.c.

00017465 <keyboard_report_desc>:
   17465:	06090105 070501a1 e729e019 01250015     ..........)...%.
   17475:	08950175 01810281 65290019 65250015     u.........)e..%e
   17485:	06950875 08050081 05290119 01250015     u.........)...%.
   17495:	05950175 03950291 2ec00191 61682f2e     u............/ha
   174a5:	72732f6c 61682f63 73755f6c 5f747261     l/src/hal_usart_
   174b5:	636e7973 2e00632e 61682f2e 72732f6c     sync.c.../hal/sr
   174c5:	61682f63 6c665f6c 2e687361 2e2e0063     c/hal_flash.c...
   174d5:	6c61682f 6372732f 6c61682f 6970735f     /hal/src/hal_spi
   174e5:	615f6d5f 636e7973 2e00632e 61682f2e     _m_async.c.../ha
   174f5:	72732f6c 61682f63 72635f6c 79735f63     l/src/hal_crc_sy
   17505:	632e636e                                 nc.c.

0001750a <CSWTCH.37>:
   1750a:	010101ed                                 .......

00017511 <CSWTCH.40>:
   17511:	010100ed 2ef00201 61682f2e 74752f6c     ........./hal/ut
   17521:	2f736c69 2f637273 6c697475 696c5f73     ils/src/utils_li
   17531:	632e7473 2f2e2e00 2f6c7068 2f637472     st.c.../hpl/rtc/
   17541:	5f6c7068 2e637472 2e2e0063 6c61682f     hpl_rtc.c.../hal
   17551:	636e692f 6564756c 6c61682f 7464775f     /include/hal_wdt
   17561:	2e00682e 61682f2e 72732f6c 61682f63     .h.../hal/src/ha
   17571:	73755f6c 5f747261 6e797361 00632e63     l_usart_async.c.
   17581:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
   17591:	65735f6c 6d6f6372 0000632e 00400030     l_sercom.c..0.@.
   175a1:	00400034 00410120 00410140 00430000     4.@. .A.@.A...C.
   175b1:	00430004 00430008                        ..C...C...C

000175bc <sercomspi_regs>:
   175bc:	3020000c 00020000 00000000 01ff0005     .. 0............
   175cc:	20000c03 00000000 00000000 ff000600     ... ............
   175dc:	00000701                                ....

000175e0 <_i2cms>:
   175e0:	00000005 00200014 00000100 0000e6e5     ...... .........
   175f0:	00d70000 02dc6c00                       .....l..

000175f8 <_usarts>:
   175f8:	00000000 40100004 00030000 00700002     .......@......p.
   17608:	0000aaaa 00000000 00000001 40100004     ...............@
   17618:	00030000 00700002 0000aaaa 00000000     ......p.........
   17628:	00000002 40100004 00030000 00700002     .......@......p.
   17638:	00005555 00000000 00000004 40100004     UU.............@
   17648:	00030000 00700002 0000aaaa 00000000     ......p.........
   17658:	00000006 40100004 00030000 00700002     .......@......p.
   17668:	0000aaaa 00000000 682f2e2e 752f6c61     ........../hal/u
   17678:	736c6974 6372732f 6974752f 725f736c     tils/src/utils_r
   17688:	62676e69 65666675 00632e72 6d617845     ingbuffer.c.Exam
   17698:	54656c70 206b7361 3f3f3f3f 202e2e2e     pleTask ????... 
   176a8:	0d206425 494d000a 203a4944 78323025     %d ...MIDI: %02x
   176b8:	32302520 30252078 25207832 0a783230      %02x %02x %02x.
   176c8:	61745300 6f206b63 66726576 20776f6c     .Stack overflow 
   176d8:	74206e69 206b7361 0a0d7325 61745300     in task %s...Sta
   176e8:	49207472 6974696e 7a696c61 44006465     rt Initialized.D
   176f8:	49203135 0074696e 706d6f43 7469736f     51 Init.Composit
   17708:	65442065 65636976 696e4920 6c616974     e Device Initial
   17718:	64657a69 69724700 6f4d2064 656c7564     ized.Grid Module
   17728:	696e4920 6c616974 64657a69 746e4500      Initialized.Ent
   17738:	6e697265 614d2067 4c206e69 00706f6f     ering Main Loop.
   17748:	20627355 6b736154 6d764e00 73615420     Usb Task.Nvm Tas
   17758:	6955006b 73615420 6552006b 76696563     k.Ui Task.Receiv
   17768:	61542065 49006b73 756f626e 5420646e     e Task.Inbound T
   17778:	006b7361 6274754f 646e756f 73615420     ask.Outbound Tas
   17788:	654c006b 61542064 45006b73 706d6178     k.Led Task.Examp
   17798:	4300656c 6f706d6f 65746973 76654420     le.Composite Dev
   177a8:	20656369 6e6e6f43 65746365 6f460064     ice Connected.Fo
   177b8:	65766572 0d202172 2f2e2e00 2f6c6168     rever! ..../hal/
   177c8:	2f637273 5f6c6168 69707371 616d645f     src/hal_qspi_dma
   177d8:	4900632e 00454c44 09632509 25097525     .c.IDLE..%c.%u.%
   177e8:	75250975 2e000a0d 70682f2e 64612f6c     u.%u...../hpl/ad
   177f8:	70682f63 64615f6c 00632e63              c/hpl_adc.c.

00017804 <_adcs>:
   17804:	01000000 0003000c 00041807 00000000     ................
   17814:	0014080b 00010000 000c0100 18040003     ................
   17824:	00000004 080b0000 00000014 752f2e2e     ............../u
   17834:	642f6273 63697665 73752f65 2e636462     sb/device/usbdc.
   17844:	2e2e0063 6c70682f 2f63742f 5f6c7068     c.../hpl/tc/hpl_
   17854:	632e6374 00000000 40003800 40003c00     tc.c.....8.@.<.@
   17864:	4101a000 4101c000 42001400 42001800     ...A...A...B...B
   17874:	43001400 43001800                       ...C...C

0001787c <_tcs>:
   1787c:	006b0000 00000308 00000021 00003a98     ..k.....!....:..
   1788c:	00000000 006c0001 00000308 00000021     ......l.....!...
   1789c:	00003a98 00000000 006d0002 00000308     .:........m.....
   178ac:	00000021 00003a98 00000000 006e0003     !....:........n.
   178bc:	00000308 00000021 00003a98 00000000     ....!....:......

000178cc <_global_impure_ptr>:
   178cc:	20000550                                P.. 

000178d0 <__sf_fake_stderr>:
	...

000178f0 <__sf_fake_stdout>:
	...

00017910 <__sf_fake_stdin>:
	...
   17930:	2b302d23 00000020 004c6c68 45676665     #-0+ ...hlL.efgE
   17940:	00004746 33323130 37363534 42413938     FG..0123456789AB
   17950:	46454443 00000000 33323130 37363534     CDEF....01234567
   17960:	62613938 66656463 00000000              89abcdef....

0001796c <_init>:
   1796c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1796e:	bf00      	nop
   17970:	bcf8      	pop	{r3, r4, r5, r6, r7}
   17972:	bc08      	pop	{r3}
   17974:	469e      	mov	lr, r3
   17976:	4770      	bx	lr

00017978 <__frame_dummy_init_array_entry>:
   17978:	42cd 0000                                   .B..

0001797c <_fini>:
   1797c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1797e:	bf00      	nop
   17980:	bcf8      	pop	{r3, r4, r5, r6, r7}
   17982:	bc08      	pop	{r3}
   17984:	469e      	mov	lr, r3
   17986:	4770      	bx	lr

00017988 <__do_global_dtors_aux_fini_array_entry>:
   17988:	42a5 0000                                   .B..
