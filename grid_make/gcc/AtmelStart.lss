
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0001362c  00004000  00004000  00004000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000005b0  20000000  0001762c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  000205b0  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  000205b0  2**0
                  CONTENTS
  4 .bss          00015448  200005b0  00017be0  000205b0  2**4
                  ALLOC
  5 .stack        00010000  200159f8  0002d028  000205b0  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000205b0  2**0
                  CONTENTS, READONLY
  7 .comment      000000a7  00000000  00000000  000205de  2**0
                  CONTENTS, READONLY
  8 .debug_info   000cbefe  00000000  00000000  00020685  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 00016322  00000000  00000000  000ec583  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    00036568  00000000  00000000  001028a5  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00003120  00000000  00000000  00138e10  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 000088d8  00000000  00000000  0013bf30  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  0004edf0  00000000  00000000  00144808  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00060dba  00000000  00000000  001935f8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00129882  00000000  00000000  001f43b2  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00008920  00000000  00000000  0031dc34  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00004000 <exception_table>:
    4000:	f8 59 02 20 99 2d 01 00 95 2d 01 00 95 2d 01 00     .Y. .-...-...-..
    4010:	95 2d 01 00 95 2d 01 00 95 2d 01 00 00 00 00 00     .-...-...-......
	...
    402c:	f1 b2 00 00 95 2d 01 00 00 00 00 00 81 b3 00 00     .....-..........
    403c:	e5 b3 00 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .....-...-...-..
    404c:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    405c:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    406c:	21 f9 00 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     !....-...-...-..
    407c:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    408c:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    409c:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    40ac:	95 2d 01 00 95 2d 01 00 ed bf 00 00 19 c0 00 00     .-...-..........
    40bc:	9d e1 00 00 a5 e1 00 00 ad e1 00 00 b5 e1 00 00     ................
    40cc:	bd e1 00 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .....-...-...-..
    40dc:	95 2d 01 00 95 2d 01 00 95 2d 01 00 00 00 00 00     .-...-...-......
	...
    40f4:	15 dd 00 00 91 11 01 00 a1 11 01 00 a9 11 01 00     ................
    4104:	b1 11 01 00 b9 11 01 00 c9 11 01 00 d1 11 01 00     ................
    4114:	d9 11 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .....-...-...-..
    4124:	95 2d 01 00 e1 11 01 00 25 12 01 00 2d 12 01 00     .-......%...-...
    4134:	35 12 01 00 3d 12 01 00 4d 12 01 00 55 12 01 00     5...=...M...U...
    4144:	5d 12 01 00 65 12 01 00 f5 12 01 00 fd 12 01 00     ]...e...........
    4154:	05 13 01 00 0d 13 01 00 1d 13 01 00 25 13 01 00     ............%...
    4164:	2d 13 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     -....-...-...-..
    4174:	95 2d 01 00 00 00 00 00 00 00 00 00 b1 d8 00 00     .-..............
    4184:	b9 d8 00 00 c1 d8 00 00 c9 d8 00 00 00 00 00 00     ................
    4194:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    41a4:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    41b4:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    41c4:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    41d4:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    41e4:	95 2d 01 00 95 2d 01 00 69 37 01 00 79 37 01 00     .-...-..i7..y7..
    41f4:	89 37 01 00 99 37 01 00 95 2d 01 00 95 2d 01 00     .7...7...-...-..
    4204:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    4214:	95 2d 01 00 65 2d 01 00 75 2d 01 00 7d 2d 01 00     .-..e-..u-..}-..
    4224:	8d 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    4234:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    4244:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..
    4254:	95 2d 01 00 95 2d 01 00 95 2d 01 00 95 2d 01 00     .-...-...-...-..

00004264 <deregister_tm_clones>:
    4264:	4803      	ldr	r0, [pc, #12]	; (4274 <deregister_tm_clones+0x10>)
    4266:	4b04      	ldr	r3, [pc, #16]	; (4278 <deregister_tm_clones+0x14>)
    4268:	4283      	cmp	r3, r0
    426a:	d002      	beq.n	4272 <deregister_tm_clones+0xe>
    426c:	4b03      	ldr	r3, [pc, #12]	; (427c <deregister_tm_clones+0x18>)
    426e:	b103      	cbz	r3, 4272 <deregister_tm_clones+0xe>
    4270:	4718      	bx	r3
    4272:	4770      	bx	lr
    4274:	0001762c 	.word	0x0001762c
    4278:	0001762c 	.word	0x0001762c
    427c:	00000000 	.word	0x00000000

00004280 <register_tm_clones>:
    4280:	4805      	ldr	r0, [pc, #20]	; (4298 <register_tm_clones+0x18>)
    4282:	4906      	ldr	r1, [pc, #24]	; (429c <register_tm_clones+0x1c>)
    4284:	1a0b      	subs	r3, r1, r0
    4286:	0fd9      	lsrs	r1, r3, #31
    4288:	eb01 01a3 	add.w	r1, r1, r3, asr #2
    428c:	1049      	asrs	r1, r1, #1
    428e:	d002      	beq.n	4296 <register_tm_clones+0x16>
    4290:	4b03      	ldr	r3, [pc, #12]	; (42a0 <register_tm_clones+0x20>)
    4292:	b103      	cbz	r3, 4296 <register_tm_clones+0x16>
    4294:	4718      	bx	r3
    4296:	4770      	bx	lr
    4298:	0001762c 	.word	0x0001762c
    429c:	0001762c 	.word	0x0001762c
    42a0:	00000000 	.word	0x00000000

000042a4 <__do_global_dtors_aux>:
    42a4:	b510      	push	{r4, lr}
    42a6:	4c06      	ldr	r4, [pc, #24]	; (42c0 <__do_global_dtors_aux+0x1c>)
    42a8:	7823      	ldrb	r3, [r4, #0]
    42aa:	b943      	cbnz	r3, 42be <__do_global_dtors_aux+0x1a>
    42ac:	f7ff ffda 	bl	4264 <deregister_tm_clones>
    42b0:	4b04      	ldr	r3, [pc, #16]	; (42c4 <__do_global_dtors_aux+0x20>)
    42b2:	b113      	cbz	r3, 42ba <__do_global_dtors_aux+0x16>
    42b4:	4804      	ldr	r0, [pc, #16]	; (42c8 <__do_global_dtors_aux+0x24>)
    42b6:	f3af 8000 	nop.w
    42ba:	2301      	movs	r3, #1
    42bc:	7023      	strb	r3, [r4, #0]
    42be:	bd10      	pop	{r4, pc}
    42c0:	200005b0 	.word	0x200005b0
    42c4:	00000000 	.word	0x00000000
    42c8:	0001762c 	.word	0x0001762c

000042cc <frame_dummy>:
    42cc:	b508      	push	{r3, lr}
    42ce:	4b04      	ldr	r3, [pc, #16]	; (42e0 <frame_dummy+0x14>)
    42d0:	b11b      	cbz	r3, 42da <frame_dummy+0xe>
    42d2:	4904      	ldr	r1, [pc, #16]	; (42e4 <frame_dummy+0x18>)
    42d4:	4804      	ldr	r0, [pc, #16]	; (42e8 <frame_dummy+0x1c>)
    42d6:	f3af 8000 	nop.w
    42da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    42de:	e7cf      	b.n	4280 <register_tm_clones>
    42e0:	00000000 	.word	0x00000000
    42e4:	200005b4 	.word	0x200005b4
    42e8:	0001762c 	.word	0x0001762c

000042ec <audio_midi_req>:
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */

static int32_t audio_midi_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    42ec:	b410      	push	{r4}
		
	//return ERR_NOT_FOUND;	
		
	if ((0x81 == req->bmRequestType) && (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1])) {
    42ee:	780b      	ldrb	r3, [r1, #0]
    42f0:	2b81      	cmp	r3, #129	; 0x81
    42f2:	d110      	bne.n	4316 <audio_midi_req+0x2a>
    42f4:	4b1a      	ldr	r3, [pc, #104]	; (4360 <audio_midi_req+0x74>)
    42f6:	888a      	ldrh	r2, [r1, #4]
    42f8:	7919      	ldrb	r1, [r3, #4]
    42fa:	4291      	cmp	r1, r2
    42fc:	4619      	mov	r1, r3
    42fe:	d002      	beq.n	4306 <audio_midi_req+0x1a>
    4300:	795b      	ldrb	r3, [r3, #5]
    4302:	4293      	cmp	r3, r2
    4304:	d128      	bne.n	4358 <audio_midi_req+0x6c>
	return usbdc_xfer(ep, _audiodf_midi_funcd.audio_desc, _audiodf_midi_funcd.audio_desc[0], false);
    4306:	6809      	ldr	r1, [r1, #0]
    4308:	780a      	ldrb	r2, [r1, #0]
    430a:	2300      	movs	r3, #0
			switch (req->bRequest) {
				case 0x03: /* Get Protocol */
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
				case 0x0B: /* Set Protocol */
				_audiodf_midi_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
    430c:	4c15      	ldr	r4, [pc, #84]	; (4364 <audio_midi_req+0x78>)
    430e:	46a4      	mov	ip, r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    4310:	f85d 4b04 	ldr.w	r4, [sp], #4
				return usbdc_xfer(ep, NULL, 0, 0);
    4314:	4760      	bx	ip
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    4316:	f3c3 1341 	ubfx	r3, r3, #5, #2
    431a:	2b01      	cmp	r3, #1
    431c:	d11c      	bne.n	4358 <audio_midi_req+0x6c>
		if (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1]) {
    431e:	4b10      	ldr	r3, [pc, #64]	; (4360 <audio_midi_req+0x74>)
    4320:	888a      	ldrh	r2, [r1, #4]
    4322:	791c      	ldrb	r4, [r3, #4]
    4324:	4294      	cmp	r4, r2
    4326:	461c      	mov	r4, r3
    4328:	d002      	beq.n	4330 <audio_midi_req+0x44>
    432a:	795b      	ldrb	r3, [r3, #5]
    432c:	4293      	cmp	r3, r2
    432e:	d113      	bne.n	4358 <audio_midi_req+0x6c>
			switch (req->bRequest) {
    4330:	784b      	ldrb	r3, [r1, #1]
    4332:	2b03      	cmp	r3, #3
    4334:	d006      	beq.n	4344 <audio_midi_req+0x58>
    4336:	2b0b      	cmp	r3, #11
    4338:	d008      	beq.n	434c <audio_midi_req+0x60>
    433a:	f06f 000c 	mvn.w	r0, #12
}
    433e:	f85d 4b04 	ldr.w	r4, [sp], #4
    4342:	4770      	bx	lr
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
    4344:	4908      	ldr	r1, [pc, #32]	; (4368 <audio_midi_req+0x7c>)
    4346:	2300      	movs	r3, #0
    4348:	2201      	movs	r2, #1
    434a:	e7df      	b.n	430c <audio_midi_req+0x20>
				_audiodf_midi_funcd.protocol = req->wValue;
    434c:	884b      	ldrh	r3, [r1, #2]
    434e:	7223      	strb	r3, [r4, #8]
				return usbdc_xfer(ep, NULL, 0, 0);
    4350:	2300      	movs	r3, #0
    4352:	461a      	mov	r2, r3
    4354:	4619      	mov	r1, r3
    4356:	e7d9      	b.n	430c <audio_midi_req+0x20>
			return ERR_NOT_FOUND; // Never hit breakpoint here
    4358:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    435c:	e7ef      	b.n	433e <audio_midi_req+0x52>
    435e:	bf00      	nop
    4360:	200005cc 	.word	0x200005cc
    4364:	00012f99 	.word	0x00012f99
    4368:	200005d4 	.word	0x200005d4

0000436c <audio_midi_ctrl>:
	switch (ctrl) {
    436c:	2901      	cmp	r1, #1
{
    436e:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4372:	460d      	mov	r5, r1
    4374:	4614      	mov	r4, r2
	switch (ctrl) {
    4376:	d070      	beq.n	445a <audio_midi_ctrl+0xee>
    4378:	2902      	cmp	r1, #2
    437a:	f000 8092 	beq.w	44a2 <audio_midi_ctrl+0x136>
    437e:	2900      	cmp	r1, #0
    4380:	f040 8092 	bne.w	44a8 <audio_midi_ctrl+0x13c>
		return audio_midi_enable(drv, (struct usbd_descriptors *)param);
    4384:	6886      	ldr	r6, [r0, #8]
	ifc = desc->sod;
    4386:	f8df 8148 	ldr.w	r8, [pc, #328]	; 44d0 <audio_midi_ctrl+0x164>
    438a:	6810      	ldr	r0, [r2, #0]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    438c:	f8df 9144 	ldr.w	r9, [pc, #324]	; 44d4 <audio_midi_ctrl+0x168>
    4390:	1d37      	adds	r7, r6, #4
		if (NULL == ifc) {
    4392:	b920      	cbnz	r0, 439e <audio_midi_ctrl+0x32>
			return ERR_NOT_FOUND;
    4394:	f06f 0009 	mvn.w	r0, #9
}
    4398:	b003      	add	sp, #12
    439a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    439e:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    43a0:	7882      	ldrb	r2, [r0, #2]
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    43a2:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    43a6:	2b01      	cmp	r3, #1
    43a8:	d1f4      	bne.n	4394 <audio_midi_ctrl+0x28>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    43aa:	783b      	ldrb	r3, [r7, #0]
    43ac:	429a      	cmp	r2, r3
    43ae:	d07e      	beq.n	44ae <audio_midi_ctrl+0x142>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    43b0:	2bff      	cmp	r3, #255	; 0xff
    43b2:	d17f      	bne.n	44b4 <audio_midi_ctrl+0x148>
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    43b4:	2d01      	cmp	r5, #1
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    43b6:	f807 2b01 	strb.w	r2, [r7], #1
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    43ba:	d009      	beq.n	43d0 <audio_midi_ctrl+0x64>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);		
    43bc:	6823      	ldr	r3, [r4, #0]
    43be:	6861      	ldr	r1, [r4, #4]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    43c0:	7818      	ldrb	r0, [r3, #0]
    43c2:	2204      	movs	r2, #4
    43c4:	4418      	add	r0, r3
    43c6:	47c0      	blx	r8
	for (i=0; i<2; i++){
    43c8:	2d01      	cmp	r5, #1
    43ca:	d042      	beq.n	4452 <audio_midi_ctrl+0xe6>
    43cc:	2501      	movs	r5, #1
    43ce:	e7e0      	b.n	4392 <audio_midi_ctrl+0x26>
			ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    43d0:	6861      	ldr	r1, [r4, #4]
    43d2:	f8df a104 	ldr.w	sl, [pc, #260]	; 44d8 <audio_midi_ctrl+0x16c>
    43d6:	2205      	movs	r2, #5
    43d8:	47c0      	blx	r8
    43da:	4683      	mov	fp, r0
			while (NULL != ep) {
    43dc:	f1bb 0f00 	cmp.w	fp, #0
    43e0:	d0ec      	beq.n	43bc <audio_midi_ctrl+0x50>
				ep_desc.bEndpointAddress = ep[2];
    43e2:	f89b 2002 	ldrb.w	r2, [fp, #2]
    43e6:	f88d 2002 	strb.w	r2, [sp, #2]
				ep_desc.bmAttributes     = ep[3];
    43ea:	f89b 2003 	ldrb.w	r2, [fp, #3]
    43ee:	f88d 2003 	strb.w	r2, [sp, #3]
	return (ptr[0] + (ptr[1] << 8));
    43f2:	f89b 1005 	ldrb.w	r1, [fp, #5]
    43f6:	f89b 2004 	ldrb.w	r2, [fp, #4]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43fa:	4b31      	ldr	r3, [pc, #196]	; (44c0 <audio_midi_ctrl+0x154>)
    43fc:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    4400:	b292      	uxth	r2, r2
				ep_desc.wMaxPacketSize   = usb_get_u16(ep + 4);
    4402:	f8ad 2004 	strh.w	r2, [sp, #4]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    4406:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    440a:	b2d2      	uxtb	r2, r2
    440c:	f889 2004 	strb.w	r2, [r9, #4]
				usb_debug2[0] = i;
    4410:	2201      	movs	r2, #1
    4412:	f889 2000 	strb.w	r2, [r9]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    4416:	f89d 0002 	ldrb.w	r0, [sp, #2]
    441a:	f89d 1003 	ldrb.w	r1, [sp, #3]
    441e:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    4422:	b292      	uxth	r2, r2
    4424:	4798      	blx	r3
    4426:	2800      	cmp	r0, #0
    4428:	d147      	bne.n	44ba <audio_midi_ctrl+0x14e>
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    442a:	f89d 2002 	ldrb.w	r2, [sp, #2]
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    442e:	f89d 0002 	ldrb.w	r0, [sp, #2]
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    4432:	0613      	lsls	r3, r2, #24
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    4434:	b2c0      	uxtb	r0, r0
    4436:	bf4c      	ite	mi
    4438:	71b0      	strbmi	r0, [r6, #6]
					func_data->func_ep_out = ep_desc.bEndpointAddress;
    443a:	71f0      	strbpl	r0, [r6, #7]
					usb_d_ep_enable(func_data->func_ep_out);
    443c:	47d0      	blx	sl
				desc->sod = ep;
    443e:	f8c4 b000 	str.w	fp, [r4]
	return (desc + usb_desc_len(desc));
    4442:	f89b 0000 	ldrb.w	r0, [fp]
				ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    4446:	6861      	ldr	r1, [r4, #4]
    4448:	4b1e      	ldr	r3, [pc, #120]	; (44c4 <audio_midi_ctrl+0x158>)
    444a:	4458      	add	r0, fp
    444c:	4798      	blx	r3
    444e:	4683      	mov	fp, r0
    4450:	e7c4      	b.n	43dc <audio_midi_ctrl+0x70>
	_audiodf_midi_funcd.enabled = true;
    4452:	4b1d      	ldr	r3, [pc, #116]	; (44c8 <audio_midi_ctrl+0x15c>)
	return ERR_NONE;
    4454:	2000      	movs	r0, #0
	_audiodf_midi_funcd.enabled = true;
    4456:	745d      	strb	r5, [r3, #17]
	return ERR_NONE;
    4458:	e79e      	b.n	4398 <audio_midi_ctrl+0x2c>
		return audio_midi_disable(drv, (struct usbd_descriptors *)param);
    445a:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    445c:	b12a      	cbz	r2, 446a <audio_midi_ctrl+0xfe>
		ifc_desc.bInterfaceClass = desc->sod[5];
    445e:	6813      	ldr	r3, [r2, #0]
		if ((AUDIO_AC_SUBCLASS != ifc_desc.bInterfaceClass) && (AUDIO_MS_SUBCLASS != ifc_desc.bInterfaceClass)) {
    4460:	795b      	ldrb	r3, [r3, #5]
    4462:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    4466:	2b01      	cmp	r3, #1
    4468:	d194      	bne.n	4394 <audio_midi_ctrl+0x28>
	if (func_data->func_iface[0] != 0xFF) {
    446a:	792b      	ldrb	r3, [r5, #4]
	if (func_data->func_ep_in != 0xFF) {
    446c:	79a8      	ldrb	r0, [r5, #6]
	if (func_data->func_iface[0] != 0xFF) {
    446e:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[0] = 0xFF;
    4470:	bf1c      	itt	ne
    4472:	23ff      	movne	r3, #255	; 0xff
    4474:	712b      	strbne	r3, [r5, #4]
	if (func_data->func_iface[1] != 0xFF) {
    4476:	796b      	ldrb	r3, [r5, #5]
    4478:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[1] = 0xFF;
    447a:	bf1c      	itt	ne
    447c:	23ff      	movne	r3, #255	; 0xff
    447e:	716b      	strbne	r3, [r5, #5]
	if (func_data->func_ep_in != 0xFF) {
    4480:	28ff      	cmp	r0, #255	; 0xff
    4482:	d003      	beq.n	448c <audio_midi_ctrl+0x120>
		usb_d_ep_deinit(func_data->func_ep_in);
    4484:	4b11      	ldr	r3, [pc, #68]	; (44cc <audio_midi_ctrl+0x160>)
    4486:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    4488:	23ff      	movs	r3, #255	; 0xff
    448a:	71ab      	strb	r3, [r5, #6]
	if (func_data->func_ep_out != 0xFF) {
    448c:	79e8      	ldrb	r0, [r5, #7]
    448e:	28ff      	cmp	r0, #255	; 0xff
    4490:	d003      	beq.n	449a <audio_midi_ctrl+0x12e>
		usb_d_ep_deinit(func_data->func_ep_out);
    4492:	4b0e      	ldr	r3, [pc, #56]	; (44cc <audio_midi_ctrl+0x160>)
    4494:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    4496:	23ff      	movs	r3, #255	; 0xff
    4498:	71eb      	strb	r3, [r5, #7]
	_audiodf_midi_funcd.enabled = false;
    449a:	4b0b      	ldr	r3, [pc, #44]	; (44c8 <audio_midi_ctrl+0x15c>)
    449c:	2000      	movs	r0, #0
    449e:	7458      	strb	r0, [r3, #17]
	return ERR_NONE;
    44a0:	e77a      	b.n	4398 <audio_midi_ctrl+0x2c>
		return ERR_UNSUPPORTED_OP;
    44a2:	f06f 001a 	mvn.w	r0, #26
    44a6:	e777      	b.n	4398 <audio_midi_ctrl+0x2c>
	switch (ctrl) {
    44a8:	f06f 000c 	mvn.w	r0, #12
    44ac:	e774      	b.n	4398 <audio_midi_ctrl+0x2c>
				return ERR_ALREADY_INITIALIZED;
    44ae:	f06f 0011 	mvn.w	r0, #17
    44b2:	e771      	b.n	4398 <audio_midi_ctrl+0x2c>
				return ERR_NO_RESOURCE;
    44b4:	f06f 001b 	mvn.w	r0, #27
    44b8:	e76e      	b.n	4398 <audio_midi_ctrl+0x2c>
					return ERR_NOT_INITIALIZED;
    44ba:	f06f 0013 	mvn.w	r0, #19
    44be:	e76b      	b.n	4398 <audio_midi_ctrl+0x2c>
    44c0:	0000f429 	.word	0x0000f429
    44c4:	0000b70f 	.word	0x0000b70f
    44c8:	200005cc 	.word	0x200005cc
    44cc:	0000f48d 	.word	0x0000f48d
    44d0:	0000b6f5 	.word	0x0000b6f5
    44d4:	20001b5c 	.word	0x20001b5c
    44d8:	0000f4b9 	.word	0x0000f4b9

000044dc <audiodf_midi_init>:

/**
 * \brief Initialize the USB Audio Midi Function Driver
 */
int32_t audiodf_midi_init(void)
{
    44dc:	b508      	push	{r3, lr}
	
	
	if (usbdc_get_state() > USBD_S_POWER) {
    44de:	4b0a      	ldr	r3, [pc, #40]	; (4508 <audiodf_midi_init+0x2c>)
    44e0:	4798      	blx	r3
    44e2:	2801      	cmp	r0, #1
    44e4:	d80c      	bhi.n	4500 <audiodf_midi_init+0x24>
		return ERR_DENIED;
	}
	
	_audiodf_midi.ctrl      = audio_midi_ctrl;
    44e6:	4809      	ldr	r0, [pc, #36]	; (450c <audiodf_midi_init+0x30>)
    44e8:	4b09      	ldr	r3, [pc, #36]	; (4510 <audiodf_midi_init+0x34>)
	_audiodf_midi.func_data = &_audiodf_midi_funcd;
    44ea:	e9c0 3006 	strd	r3, r0, [r0, #24]
	
	usbdc_register_function(&_audiodf_midi);
    44ee:	4b09      	ldr	r3, [pc, #36]	; (4514 <audiodf_midi_init+0x38>)
    44f0:	3014      	adds	r0, #20
    44f2:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &audio_midi_req_h);
    44f4:	2001      	movs	r0, #1
    44f6:	4908      	ldr	r1, [pc, #32]	; (4518 <audiodf_midi_init+0x3c>)
    44f8:	4b08      	ldr	r3, [pc, #32]	; (451c <audiodf_midi_init+0x40>)
    44fa:	4798      	blx	r3
	return ERR_NONE;
    44fc:	2000      	movs	r0, #0
}
    44fe:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    4500:	f06f 0010 	mvn.w	r0, #16
    4504:	e7fb      	b.n	44fe <audiodf_midi_init+0x22>
    4506:	bf00      	nop
    4508:	000133d1 	.word	0x000133d1
    450c:	200005cc 	.word	0x200005cc
    4510:	0000436d 	.word	0x0000436d
    4514:	00013379 	.word	0x00013379
    4518:	20000000 	.word	0x20000000
    451c:	000132f1 	.word	0x000132f1

00004520 <audiodf_midi_write>:
}



int32_t audiodf_midi_write(uint8_t byte0, uint8_t byte1, uint8_t byte2, uint8_t byte3)
{
    4520:	b410      	push	{r4}
		return ERR_DENIED;
	}
	
	// if previous xfer is completed
	
	_audiodf_midi_funcd.midi_report[0] = byte0;
    4522:	4c07      	ldr	r4, [pc, #28]	; (4540 <audiodf_midi_write+0x20>)
    4524:	7260      	strb	r0, [r4, #9]
	_audiodf_midi_funcd.midi_report[1] = byte1;
    4526:	72a1      	strb	r1, [r4, #10]
	_audiodf_midi_funcd.midi_report[2] = byte2;
    4528:	72e2      	strb	r2, [r4, #11]
	_audiodf_midi_funcd.midi_report[3] = byte3;
    452a:	7323      	strb	r3, [r4, #12]

	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    452c:	79a0      	ldrb	r0, [r4, #6]
    452e:	f104 0109 	add.w	r1, r4, #9
    4532:	4c04      	ldr	r4, [pc, #16]	; (4544 <audiodf_midi_write+0x24>)
    4534:	2300      	movs	r3, #0
    4536:	46a4      	mov	ip, r4
    4538:	2204      	movs	r2, #4
	
}
    453a:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    453e:	4760      	bx	ip
    4540:	200005cc 	.word	0x200005cc
    4544:	00012f99 	.word	0x00012f99

00004548 <audiodf_midi_write_status>:

int32_t audiodf_midi_write_status(){
    4548:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	
	struct usb_d_ep_status epstat;
	return usb_d_ep_get_status(_audiodf_midi_funcd.func_ep_in, &epstat);
    454a:	4b04      	ldr	r3, [pc, #16]	; (455c <audiodf_midi_write_status+0x14>)
    454c:	a901      	add	r1, sp, #4
    454e:	7998      	ldrb	r0, [r3, #6]
    4550:	4b03      	ldr	r3, [pc, #12]	; (4560 <audiodf_midi_write_status+0x18>)
    4552:	4798      	blx	r3
	
}
    4554:	b005      	add	sp, #20
    4556:	f85d fb04 	ldr.w	pc, [sp], #4
    455a:	bf00      	nop
    455c:	200005cc 	.word	0x200005cc
    4560:	0000f5e1 	.word	0x0000f5e1

00004564 <audiodf_midi_read>:



int32_t audiodf_midi_read(uint8_t *buf, uint32_t size)
{
    4564:	b410      	push	{r4}
    4566:	460a      	mov	r2, r1
	if (!audiodf_midi_is_enabled()) {
		return ERR_DENIED;
	}
		
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4568:	4c04      	ldr	r4, [pc, #16]	; (457c <audiodf_midi_read+0x18>)
    456a:	4601      	mov	r1, r0
    456c:	4804      	ldr	r0, [pc, #16]	; (4580 <audiodf_midi_read+0x1c>)
    456e:	46a4      	mov	ip, r4
    4570:	79c0      	ldrb	r0, [r0, #7]
}
    4572:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4576:	2300      	movs	r3, #0
    4578:	4760      	bx	ip
    457a:	bf00      	nop
    457c:	00012f99 	.word	0x00012f99
    4580:	200005cc 	.word	0x200005cc

00004584 <audiodf_midi_register_callback>:


int32_t audiodf_midi_register_callback(enum audiodf_midi_cb_type cb_type, FUNC_PTR func)
{
    4584:	b510      	push	{r4, lr}
    4586:	460a      	mov	r2, r1
	switch (cb_type) {
    4588:	b120      	cbz	r0, 4594 <audiodf_midi_register_callback+0x10>
    458a:	2801      	cmp	r0, #1
    458c:	d009      	beq.n	45a2 <audiodf_midi_register_callback+0x1e>
    458e:	f06f 000c 	mvn.w	r0, #12
		break;
		default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
}
    4592:	bd10      	pop	{r4, pc}
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    4594:	4b05      	ldr	r3, [pc, #20]	; (45ac <audiodf_midi_register_callback+0x28>)
    4596:	79d8      	ldrb	r0, [r3, #7]
    4598:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    459a:	4b05      	ldr	r3, [pc, #20]	; (45b0 <audiodf_midi_register_callback+0x2c>)
    459c:	4798      	blx	r3
	return ERR_NONE;
    459e:	2000      	movs	r0, #0
		break;
    45a0:	e7f7      	b.n	4592 <audiodf_midi_register_callback+0xe>
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    45a2:	4b02      	ldr	r3, [pc, #8]	; (45ac <audiodf_midi_register_callback+0x28>)
    45a4:	2102      	movs	r1, #2
    45a6:	7998      	ldrb	r0, [r3, #6]
    45a8:	e7f7      	b.n	459a <audiodf_midi_register_callback+0x16>
    45aa:	bf00      	nop
    45ac:	200005cc 	.word	0x200005cc
    45b0:	0000f6a1 	.word	0x0000f6a1

000045b4 <grid_ain_channel_init>:

struct AIN_Channel* ain_channel_buffer;



uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    45b4:	b570      	push	{r4, r5, r6, lr}
	instance->buffer_depth = buffer_depth;
	
	instance->result_format = result_format;
	instance->result_resolution = result_resolution;
	
	instance->result_average = 0;
    45b6:	2500      	movs	r5, #0
	instance->result_format = result_format;
    45b8:	7142      	strb	r2, [r0, #5]
	instance->result_resolution = result_resolution;
    45ba:	7183      	strb	r3, [r0, #6]
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    45bc:	4604      	mov	r4, r0
	
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45be:	4b0a      	ldr	r3, [pc, #40]	; (45e8 <grid_ain_channel_init+0x34>)
	instance->buffer_depth = buffer_depth;
    45c0:	7101      	strb	r1, [r0, #4]
	instance->result_average = 0;
    45c2:	8145      	strh	r5, [r0, #10]
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45c4:	0048      	lsls	r0, r1, #1
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    45c6:	460e      	mov	r6, r1
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45c8:	4798      	blx	r3
	
	// Init the whole buffer with zeros
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    45ca:	462b      	mov	r3, r5
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    45cc:	6020      	str	r0, [r4, #0]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    45ce:	462a      	mov	r2, r5
    45d0:	b2d9      	uxtb	r1, r3
    45d2:	428e      	cmp	r6, r1
    45d4:	d803      	bhi.n	45de <grid_ain_channel_init+0x2a>
		instance->buffer[i] = 0;
	}
	
	instance->result_changed = 0;
    45d6:	81a2      	strh	r2, [r4, #12]
	instance->result_value = 0;
    45d8:	8122      	strh	r2, [r4, #8]
		
	return 0;
}
    45da:	2000      	movs	r0, #0
    45dc:	bd70      	pop	{r4, r5, r6, pc}
		instance->buffer[i] = 0;
    45de:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    45e2:	3301      	adds	r3, #1
    45e4:	e7f4      	b.n	45d0 <grid_ain_channel_init+0x1c>
    45e6:	bf00      	nop
    45e8:	00014021 	.word	0x00014021

000045ec <grid_ain_init>:
	}
}


/** Initialize ain buffer for a given number of analog channels */
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    45f0:	4605      	mov	r5, r0
    45f2:	4699      	mov	r9, r3
	
	// ain_channel_result_resolution = resolution
	
	
	// 2D buffer, example: 16 potentiometers, last 32 samples stored for each
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45f4:	0100      	lsls	r0, r0, #4
    45f6:	4b0b      	ldr	r3, [pc, #44]	; (4624 <grid_ain_init+0x38>)
    45f8:	4e0b      	ldr	r6, [pc, #44]	; (4628 <grid_ain_init+0x3c>)

	for (uint8_t i=0; i<length; i++){
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45fa:	f8df a030 	ldr.w	sl, [pc, #48]	; 462c <grid_ain_init+0x40>
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45fe:	460f      	mov	r7, r1
    4600:	4690      	mov	r8, r2
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    4602:	4798      	blx	r3
	for (uint8_t i=0; i<length; i++){
    4604:	2400      	movs	r4, #0
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    4606:	6030      	str	r0, [r6, #0]
	for (uint8_t i=0; i<length; i++){
    4608:	42a5      	cmp	r5, r4
    460a:	d102      	bne.n	4612 <grid_ain_init+0x26>
	}

	return 0;
}
    460c:	2000      	movs	r0, #0
    460e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    4612:	6830      	ldr	r0, [r6, #0]
    4614:	464b      	mov	r3, r9
    4616:	eb00 1004 	add.w	r0, r0, r4, lsl #4
    461a:	4642      	mov	r2, r8
    461c:	4639      	mov	r1, r7
    461e:	47d0      	blx	sl
	for (uint8_t i=0; i<length; i++){
    4620:	3401      	adds	r4, #1
    4622:	e7f1      	b.n	4608 <grid_ain_init+0x1c>
    4624:	00014021 	.word	0x00014021
    4628:	20004ac4 	.word	0x20004ac4
    462c:	000045b5 	.word	0x000045b5

00004630 <grid_ain_add_sample>:

uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    4630:	4b30      	ldr	r3, [pc, #192]	; (46f4 <grid_ain_add_sample+0xc4>)
uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
    4632:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    4636:	681a      	ldr	r2, [r3, #0]
    4638:	0104      	lsls	r4, r0, #4
    463a:	eb02 1300 	add.w	r3, r2, r0, lsl #4
	uint16_t maximum = 0;

	uint8_t minimum_index = 0;
	uint8_t maximum_index = 0;
	
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    463e:	5914      	ldr	r4, [r2, r4]
    4640:	f893 e004 	ldrb.w	lr, [r3, #4]
    4644:	2200      	movs	r2, #0
	uint8_t maximum_index = 0;
    4646:	4615      	mov	r5, r2
	uint8_t minimum_index = 0;
    4648:	4616      	mov	r6, r2
	uint16_t maximum = 0;
    464a:	4691      	mov	r9, r2
	uint16_t minimum = -1; // -1 trick to get the largest possible number
    464c:	f64f 78ff 	movw	r8, #65535	; 0xffff
	uint32_t sum = 0;
    4650:	4610      	mov	r0, r2
    4652:	fa5f fc82 	uxtb.w	ip, r2
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    4656:	45e6      	cmp	lr, ip
    4658:	d83c      	bhi.n	46d4 <grid_ain_add_sample+0xa4>
	
	}
	
	uint16_t average = sum/instance->buffer_depth;
	
	if (value>average){		
    465a:	180a      	adds	r2, r1, r0
	uint16_t average = sum/instance->buffer_depth;
    465c:	fbb0 f0fe 	udiv	r0, r0, lr
	if (value>average){		
    4660:	b280      	uxth	r0, r0
    4662:	4288      	cmp	r0, r1
		// Replace minimum in the buffer and recalculate sum
		sum = sum - instance->buffer[minimum_index] + value;
    4664:	bf34      	ite	cc
    4666:	b230      	sxthcc	r0, r6
		instance->buffer[minimum_index] = value;		
	}else{
		// Replace maximum in the buffer and recalculate sum
		sum = sum - instance->buffer[maximum_index] + value;
    4668:	b228      	sxthcs	r0, r5
    466a:	f834 5010 	ldrh.w	r5, [r4, r0, lsl #1]
		instance->buffer[maximum_index] = value;
    466e:	f824 1010 	strh.w	r1, [r4, r0, lsl #1]
		sum = sum - instance->buffer[maximum_index] + value;
    4672:	1b52      	subs	r2, r2, r5
	}
	
	// Recalculate average
	average = sum/instance->buffer_depth;
    4674:	7919      	ldrb	r1, [r3, #4]
    4676:	fbb2 f2f1 	udiv	r2, r2, r1
	
	
	uint8_t downscale_factor = (16-instance->result_resolution);
    467a:	7999      	ldrb	r1, [r3, #6]
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    467c:	795c      	ldrb	r4, [r3, #5]
	
	uint16_t downsampled = average>>downscale_factor;
	uint16_t upscaled    = downsampled<<upscale_factor;
	
	uint8_t criteria_a = instance->result_value != upscaled;
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    467e:	895e      	ldrh	r6, [r3, #10]
	
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
	uint8_t criteria_d = upscaled==0;
	
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4680:	f8b3 e008 	ldrh.w	lr, [r3, #8]
	uint8_t downscale_factor = (16-instance->result_resolution);
    4684:	f1c1 0710 	rsb	r7, r1, #16
	uint16_t downsampled = average>>downscale_factor;
    4688:	b295      	uxth	r5, r2
    468a:	b2ff      	uxtb	r7, r7
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    468c:	1a61      	subs	r1, r4, r1
	uint16_t upscaled    = downsampled<<upscale_factor;
    468e:	b2c8      	uxtb	r0, r1
	uint16_t downsampled = average>>downscale_factor;
    4690:	fa45 f107 	asr.w	r1, r5, r7
	uint16_t upscaled    = downsampled<<upscale_factor;
    4694:	b289      	uxth	r1, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4696:	1b76      	subs	r6, r6, r5
	uint16_t upscaled    = downsampled<<upscale_factor;
    4698:	4081      	lsls	r1, r0
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    469a:	2e00      	cmp	r6, #0
	uint16_t upscaled    = downsampled<<upscale_factor;
    469c:	fa1f fc81 	uxth.w	ip, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    46a0:	bfb8      	it	lt
    46a2:	4276      	neglt	r6, r6
    46a4:	2501      	movs	r5, #1
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    46a6:	45e6      	cmp	lr, ip
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    46a8:	fa05 f707 	lsl.w	r7, r5, r7
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    46ac:	d01f      	beq.n	46ee <grid_ain_add_sample+0xbe>
    46ae:	42be      	cmp	r6, r7
    46b0:	dc09      	bgt.n	46c6 <grid_ain_add_sample+0x96>
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
    46b2:	fa05 f404 	lsl.w	r4, r5, r4
    46b6:	fa05 f000 	lsl.w	r0, r5, r0
    46ba:	1a20      	subs	r0, r4, r0
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    46bc:	4560      	cmp	r0, ip
    46be:	d002      	beq.n	46c6 <grid_ain_add_sample+0x96>
    46c0:	f1bc 0f00 	cmp.w	ip, #0
    46c4:	d113      	bne.n	46ee <grid_ain_add_sample+0xbe>
		
		instance->result_average = average;
		instance->result_value = upscaled;
		instance->result_changed = 1;
    46c6:	2001      	movs	r0, #1
	average = sum/instance->buffer_depth;
    46c8:	815a      	strh	r2, [r3, #10]
		instance->result_value = upscaled;
    46ca:	f8a3 c008 	strh.w	ip, [r3, #8]
		instance->result_changed = 1;
    46ce:	8198      	strh	r0, [r3, #12]
		return 1;
	}else{		
		return 0;
	}
	
}
    46d0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		uint16_t current = instance->buffer[i];
    46d4:	f834 7012 	ldrh.w	r7, [r4, r2, lsl #1]
		if (current > maximum){
    46d8:	45b9      	cmp	r9, r7
    46da:	bf3c      	itt	cc
    46dc:	4665      	movcc	r5, ip
    46de:	46b9      	movcc	r9, r7
		if (current < minimum){
    46e0:	45b8      	cmp	r8, r7
		sum += current;
    46e2:	4438      	add	r0, r7
		if (current < minimum){
    46e4:	bf84      	itt	hi
    46e6:	4666      	movhi	r6, ip
    46e8:	46b8      	movhi	r8, r7
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    46ea:	3201      	adds	r2, #1
    46ec:	e7b1      	b.n	4652 <grid_ain_add_sample+0x22>
		return 0;
    46ee:	2000      	movs	r0, #0
    46f0:	e7ee      	b.n	46d0 <grid_ain_add_sample+0xa0>
    46f2:	bf00      	nop
    46f4:	20004ac4 	.word	0x20004ac4

000046f8 <grid_ain_get_changed>:

uint8_t grid_ain_get_changed(uint8_t channel){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
	return instance->result_changed;
    46f8:	4b02      	ldr	r3, [pc, #8]	; (4704 <grid_ain_get_changed+0xc>)
    46fa:	681b      	ldr	r3, [r3, #0]
    46fc:	eb03 1000 	add.w	r0, r3, r0, lsl #4
}
    4700:	7b00      	ldrb	r0, [r0, #12]
    4702:	4770      	bx	lr
    4704:	20004ac4 	.word	0x20004ac4

00004708 <grid_ain_get_average>:
	
uint16_t grid_ain_get_average(uint8_t channel, uint8_t resolution){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    4708:	4b08      	ldr	r3, [pc, #32]	; (472c <grid_ain_get_average+0x24>)
    470a:	681a      	ldr	r2, [r3, #0]
	instance->result_changed = 0;
	
	if (resolution>6 && resolution<15){
    470c:	1fcb      	subs	r3, r1, #7
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    470e:	eb02 1200 	add.w	r2, r2, r0, lsl #4
	if (resolution>6 && resolution<15){
    4712:	2b07      	cmp	r3, #7
	instance->result_changed = 0;
    4714:	f04f 0000 	mov.w	r0, #0
    4718:	8190      	strh	r0, [r2, #12]
	if (resolution>6 && resolution<15){
    471a:	d805      	bhi.n	4728 <grid_ain_get_average+0x20>
		

		
		return (instance->result_value)/(1<<(instance->result_format-resolution));
    471c:	7950      	ldrb	r0, [r2, #5]
    471e:	8913      	ldrh	r3, [r2, #8]
    4720:	1a40      	subs	r0, r0, r1
    4722:	fa43 f000 	asr.w	r0, r3, r0
    4726:	b280      	uxth	r0, r0
		
	}
	else{
		return 0;
	}
}
    4728:	4770      	bx	lr
    472a:	bf00      	nop
    472c:	20004ac4 	.word	0x20004ac4

00004730 <grid_port_reset_receiver>:
#include "grid_buf.h"

// PORTS


void grid_port_reset_receiver(struct grid_port* por){
    4730:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	usart_async_disable(por->usart);
    4732:	4b24      	ldr	r3, [pc, #144]	; (47c4 <grid_port_reset_receiver+0x94>)
	
	
	por->ping_partner_token = 255;
	por->ping_local_token = 255;
	
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4734:	4e24      	ldr	r6, [pc, #144]	; (47c8 <grid_port_reset_receiver+0x98>)
void grid_port_reset_receiver(struct grid_port* por){
    4736:	4604      	mov	r4, r0
	usart_async_disable(por->usart);
    4738:	6840      	ldr	r0, [r0, #4]
    473a:	4798      	blx	r3
	por->partner_status = 0;
    473c:	f642 734b 	movw	r3, #12107	; 0x2f4b
	por->rx_double_buffer_seek_start_index = 0;
    4740:	2500      	movs	r5, #0
	por->rx_double_buffer_read_start_index = 0;
    4742:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	por->ping_local_token = 255;
    4746:	f642 7731 	movw	r7, #12081	; 0x2f31
	por->partner_status = 0;
    474a:	54e5      	strb	r5, [r4, r3]
	por->ping_partner_token = 255;
    474c:	f642 7332 	movw	r3, #12082	; 0x2f32
    4750:	22ff      	movs	r2, #255	; 0xff
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4752:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
	por->ping_partner_token = 255;
    4756:	54e2      	strb	r2, [r4, r3]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4758:	2102      	movs	r1, #2
	por->ping_local_token = 255;
    475a:	55e2      	strb	r2, [r4, r7]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    475c:	303b      	adds	r0, #59	; 0x3b
    475e:	47b0      	blx	r6
	grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4760:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4764:	5de2      	ldrb	r2, [r4, r7]
    4766:	2102      	movs	r1, #2
    4768:	3039      	adds	r0, #57	; 0x39
    476a:	47b0      	blx	r6
	grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    476c:	f642 7347 	movw	r3, #12103	; 0x2f47
    4770:	f504 563c 	add.w	r6, r4, #12032	; 0x2f00
    4774:	3633      	adds	r6, #51	; 0x33
    4776:	5ce1      	ldrb	r1, [r4, r3]
    4778:	4b14      	ldr	r3, [pc, #80]	; (47cc <grid_port_reset_receiver+0x9c>)
    477a:	9101      	str	r1, [sp, #4]
    477c:	4630      	mov	r0, r6
    477e:	4798      	blx	r3
    4780:	9901      	ldr	r1, [sp, #4]
    4782:	4b13      	ldr	r3, [pc, #76]	; (47d0 <grid_port_reset_receiver+0xa0>)
    4784:	4602      	mov	r2, r0
    4786:	4630      	mov	r0, r6
    4788:	4798      	blx	r3


	
	por->rx_double_buffer_timeout = 0;
	grid_sys_port_reset_dma(por);
    478a:	4b12      	ldr	r3, [pc, #72]	; (47d4 <grid_port_reset_receiver+0xa4>)
	por->rx_double_buffer_timeout = 0;
    478c:	61e5      	str	r5, [r4, #28]
	grid_sys_port_reset_dma(por);
    478e:	4620      	mov	r0, r4
    4790:	4798      	blx	r3
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    4792:	f504 539d 	add.w	r3, r4, #5024	; 0x13a0
    4796:	3314      	adds	r3, #20
    4798:	f504 521c 	add.w	r2, r4, #9984	; 0x2700
    479c:	323c      	adds	r2, #60	; 0x3c
    479e:	4619      	mov	r1, r3
		por->rx_double_buffer[i] = 0;
    47a0:	f803 5b01 	strb.w	r5, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    47a4:	4293      	cmp	r3, r2
    47a6:	d1fb      	bne.n	47a0 <grid_port_reset_receiver+0x70>
    47a8:	f104 032c 	add.w	r3, r4, #44	; 0x2c
	}
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
		por->tx_double_buffer[i] = 0;
    47ac:	2200      	movs	r2, #0
    47ae:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    47b2:	428b      	cmp	r3, r1
    47b4:	d1fb      	bne.n	47ae <grid_port_reset_receiver+0x7e>
	}
	
	usart_async_enable(por->usart);
    47b6:	6860      	ldr	r0, [r4, #4]
    47b8:	4b07      	ldr	r3, [pc, #28]	; (47d8 <grid_port_reset_receiver+0xa8>)
	
}
    47ba:	b003      	add	sp, #12
    47bc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	usart_async_enable(por->usart);
    47c0:	4718      	bx	r3
    47c2:	bf00      	nop
    47c4:	000106e9 	.word	0x000106e9
    47c8:	00009889 	.word	0x00009889
    47cc:	000099d1 	.word	0x000099d1
    47d0:	00009a05 	.word	0x00009a05
    47d4:	00009415 	.word	0x00009415
    47d8:	000106bd 	.word	0x000106bd

000047dc <grid_buffer_init>:



uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
	
	grid_buffer_error_count = 0;
    47dc:	4a0f      	ldr	r2, [pc, #60]	; (481c <grid_buffer_init+0x40>)
    47de:	2300      	movs	r3, #0
uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
    47e0:	b510      	push	{r4, lr}
    47e2:	3002      	adds	r0, #2
	grid_buffer_error_count = 0;
    47e4:	7013      	strb	r3, [r2, #0]
	
	buf->buffer_length = length;
	
	buf->read_length   = 0;
    47e6:	f8a0 33ee 	strh.w	r3, [r0, #1006]	; 0x3ee
	buf->buffer_length = length;
    47ea:	f820 1c02 	strh.w	r1, [r0, #-2]
	
	buf->read_start    = 0;
    47ee:	f8a0 33e8 	strh.w	r3, [r0, #1000]	; 0x3e8
	buf->read_stop     = 0;
    47f2:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
	buf->read_active   = 0;
    47f6:	f8a0 33ec 	strh.w	r3, [r0, #1004]	; 0x3ec
	
	buf->write_start    = 0;
    47fa:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
	buf->write_stop     = 0;
    47fe:	f8a0 33f2 	strh.w	r3, [r0, #1010]	; 0x3f2
	buf->write_active   = 0;
    4802:	f8a0 33f4 	strh.w	r3, [r0, #1012]	; 0x3f4
	

	for (uint16_t i=0; i<buf->buffer_length; i++){
		buf->buffer_storage[i] = 0;
    4806:	461c      	mov	r4, r3
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4808:	b29a      	uxth	r2, r3
    480a:	4291      	cmp	r1, r2
    480c:	d801      	bhi.n	4812 <grid_buffer_init+0x36>
	}
	
	return 1;
	
}
    480e:	2001      	movs	r0, #1
    4810:	bd10      	pop	{r4, pc}
		buf->buffer_storage[i] = 0;
    4812:	f800 4b01 	strb.w	r4, [r0], #1
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4816:	3301      	adds	r3, #1
    4818:	e7f6      	b.n	4808 <grid_buffer_init+0x2c>
    481a:	bf00      	nop
    481c:	20004ab8 	.word	0x20004ab8

00004820 <grid_buffer_get_space>:

uint16_t grid_buffer_get_space(struct grid_buffer* buf){
	
	uint16_t space = 0;
		
	if (buf->read_start > buf->write_start){
    4820:	f8b0 33ea 	ldrh.w	r3, [r0, #1002]	; 0x3ea
    4824:	f8b0 23f2 	ldrh.w	r2, [r0, #1010]	; 0x3f2
    4828:	4293      	cmp	r3, r2
		space = buf->read_start - buf->write_start;
	}
	else{
		space = buf->buffer_length - buf->write_start + buf->read_start;
    482a:	bf9b      	ittet	ls
    482c:	8800      	ldrhls	r0, [r0, #0]
    482e:	18c0      	addls	r0, r0, r3
		space = buf->read_start - buf->write_start;
    4830:	1a98      	subhi	r0, r3, r2
		space = buf->buffer_length - buf->write_start + buf->read_start;
    4832:	1a80      	subls	r0, r0, r2
    4834:	b280      	uxth	r0, r0
	}
	
	return space;
}
    4836:	4770      	bx	lr

00004838 <grid_buffer_write_init>:





uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    4838:	b510      	push	{r4, lr}
	
	
	
	uint16_t space = grid_buffer_get_space(buf);
    483a:	4b0c      	ldr	r3, [pc, #48]	; (486c <grid_buffer_write_init+0x34>)
uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    483c:	4604      	mov	r4, r0
	uint16_t space = grid_buffer_get_space(buf);
    483e:	4798      	blx	r3

	
	if (space>length){
    4840:	4288      	cmp	r0, r1
    4842:	d90b      	bls.n	485c <grid_buffer_write_init+0x24>
		
		buf->write_stop = (buf->write_start+length)%buf->buffer_length;
    4844:	f8b4 33f2 	ldrh.w	r3, [r4, #1010]	; 0x3f2
    4848:	8820      	ldrh	r0, [r4, #0]
    484a:	440b      	add	r3, r1
    484c:	fbb3 f2f0 	udiv	r2, r3, r0
    4850:	fb00 3312 	mls	r3, r0, r2, r3
    4854:	f8a4 33f4 	strh.w	r3, [r4, #1012]	; 0x3f4
	}
	
	
	
	
}
    4858:	4608      	mov	r0, r1
    485a:	bd10      	pop	{r4, pc}
		grid_buffer_error_count++;
    485c:	4a04      	ldr	r2, [pc, #16]	; (4870 <grid_buffer_write_init+0x38>)
    485e:	7813      	ldrb	r3, [r2, #0]
    4860:	3301      	adds	r3, #1
    4862:	b2db      	uxtb	r3, r3
    4864:	7013      	strb	r3, [r2, #0]
		return 0; // failed
    4866:	2100      	movs	r1, #0
    4868:	e7f6      	b.n	4858 <grid_buffer_write_init+0x20>
    486a:	bf00      	nop
    486c:	00004821 	.word	0x00004821
    4870:	20004ab8 	.word	0x20004ab8

00004874 <grid_buffer_write_character>:

uint8_t grid_buffer_write_character(struct grid_buffer* buf, uint8_t character){
	

		
	buf->buffer_storage[buf->write_active] = character;
    4874:	f8b0 33f6 	ldrh.w	r3, [r0, #1014]	; 0x3f6
    4878:	18c2      	adds	r2, r0, r3
		
	buf->write_active++;
    487a:	3301      	adds	r3, #1
	buf->buffer_storage[buf->write_active] = character;
    487c:	7091      	strb	r1, [r2, #2]
	buf->write_active %= buf->buffer_length;
    487e:	8801      	ldrh	r1, [r0, #0]
    4880:	b29b      	uxth	r3, r3
    4882:	fbb3 f2f1 	udiv	r2, r3, r1
    4886:	fb01 3312 	mls	r3, r1, r2, r3
    488a:	f8a0 33f6 	strh.w	r3, [r0, #1014]	; 0x3f6
		
	return 1;
		

}
    488e:	2001      	movs	r0, #1
    4890:	4770      	bx	lr
	...

00004894 <grid_buffer_write_acknowledge>:

uint8_t grid_buffer_write_acknowledge(struct grid_buffer* buf){
	
	if (buf->write_active == buf->write_stop){
    4894:	f8b0 33f4 	ldrh.w	r3, [r0, #1012]	; 0x3f4
    4898:	f8b0 23f6 	ldrh.w	r2, [r0, #1014]	; 0x3f6
    489c:	4293      	cmp	r3, r2
		buf->write_start = buf->write_active;
		return 1;
	}
	else{
		
		grid_buffer_error_count++;
    489e:	bf17      	itett	ne
    48a0:	4a05      	ldrne	r2, [pc, #20]	; (48b8 <grid_buffer_write_acknowledge+0x24>)
		buf->write_start = buf->write_active;
    48a2:	f8a0 33f2 	strheq.w	r3, [r0, #1010]	; 0x3f2
		grid_buffer_error_count++;
    48a6:	7813      	ldrbne	r3, [r2, #0]
    48a8:	3301      	addne	r3, #1
    48aa:	bf17      	itett	ne
    48ac:	b2db      	uxtbne	r3, r3
		return 1;
    48ae:	2001      	moveq	r0, #1
		grid_buffer_error_count++;
    48b0:	7013      	strbne	r3, [r2, #0]
    48b2:	2000      	movne	r0, #0
		return 0;
	}
	
	
}
    48b4:	4770      	bx	lr
    48b6:	bf00      	nop
    48b8:	20004ab8 	.word	0x20004ab8

000048bc <grid_port_receive_decode>:
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    48c0:	ed2d 8b02 	vpush	{d8}
	uint8_t buffer[length];
    48c4:	1dd3      	adds	r3, r2, #7
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48c6:	b08b      	sub	sp, #44	; 0x2c
    48c8:	4690      	mov	r8, r2
	uint8_t buffer[length];
    48ca:	08db      	lsrs	r3, r3, #3
    48cc:	466a      	mov	r2, sp
    48ce:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
	for (uint16_t i = 0; i<length; i++){
    48d2:	2200      	movs	r2, #0
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48d4:	af02      	add	r7, sp, #8
	uint8_t buffer[length];
    48d6:	469d      	mov	sp, r3
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    48d8:	4604      	mov	r4, r0
    48da:	6a83      	ldr	r3, [r0, #40]	; 0x28
	uint8_t buffer[length];
    48dc:	f10d 0908 	add.w	r9, sp, #8
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    48e0:	f241 3088 	movw	r0, #5000	; 0x1388
    48e4:	f241 35b4 	movw	r5, #5044	; 0x13b4
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    48e8:	4694      	mov	ip, r2
	for (uint16_t i = 0; i<length; i++){
    48ea:	b291      	uxth	r1, r2
    48ec:	4588      	cmp	r8, r1
    48ee:	f200 80e3 	bhi.w	4ab8 <grid_port_receive_decode+0x1fc>
	for (uint16_t i = 0; i<length; i++){
    48f2:	2200      	movs	r2, #0
	message = &buffer[0];
    48f4:	464d      	mov	r5, r9
	for (uint16_t i = 0; i<length; i++){
    48f6:	f241 3088 	movw	r0, #5000	; 0x1388
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    48fa:	f241 3cb4 	movw	ip, #5044	; 0x13b4
    48fe:	4696      	mov	lr, r2
	for (uint16_t i = 0; i<length; i++){
    4900:	b291      	uxth	r1, r2
    4902:	4588      	cmp	r8, r1
    4904:	f200 80e5 	bhi.w	4ad2 <grid_port_receive_decode+0x216>
	por->rx_double_buffer_read_start_index = (por->rx_double_buffer_read_start_index + length)%GRID_DOUBLE_BUFFER_RX_SIZE;
    4908:	4443      	add	r3, r8
    490a:	fbb3 f2f0 	udiv	r2, r3, r0
    490e:	fb00 3312 	mls	r3, r0, r2, r3
	por->rx_double_buffer_seek_start_index =  por->rx_double_buffer_read_start_index;
    4912:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
	por->rx_double_buffer_status = 0;
    4916:	2300      	movs	r3, #0
    4918:	6223      	str	r3, [r4, #32]
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    491a:	f8df a250 	ldr.w	sl, [pc, #592]	; 4b6c <grid_port_receive_decode+0x2b0>
    491e:	f8df b250 	ldr.w	fp, [pc, #592]	; 4b70 <grid_port_receive_decode+0x2b4>
    4922:	4b88      	ldr	r3, [pc, #544]	; (4b44 <grid_port_receive_decode+0x288>)
	for (uint16_t i = 1; i<length; i++){
    4924:	2601      	movs	r6, #1
    4926:	45b0      	cmp	r8, r6
    4928:	f200 80dd 	bhi.w	4ae6 <grid_port_receive_decode+0x22a>
	if (message[0] == GRID_CONST_SOH && message[length-1] == GRID_CONST_LF){
    492c:	782b      	ldrb	r3, [r5, #0]
    492e:	2b01      	cmp	r3, #1
    4930:	f040 80bc 	bne.w	4aac <grid_port_receive_decode+0x1f0>
    4934:	eb05 0308 	add.w	r3, r5, r8
    4938:	f813 9c01 	ldrb.w	r9, [r3, #-1]
    493c:	f1b9 0f0a 	cmp.w	r9, #10
    4940:	f040 80b4 	bne.w	4aac <grid_port_receive_decode+0x1f0>
		checksum_received = grid_msg_checksum_read(message, length);
    4944:	4b80      	ldr	r3, [pc, #512]	; (4b48 <grid_port_receive_decode+0x28c>)
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4946:	4e81      	ldr	r6, [pc, #516]	; (4b4c <grid_port_receive_decode+0x290>)
		checksum_received = grid_msg_checksum_read(message, length);
    4948:	4641      	mov	r1, r8
    494a:	4628      	mov	r0, r5
    494c:	4798      	blx	r3
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    494e:	4641      	mov	r1, r8
		checksum_received = grid_msg_checksum_read(message, length);
    4950:	4682      	mov	sl, r0
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4952:	4628      	mov	r0, r5
    4954:	47b0      	blx	r6
		if (checksum_calculated == checksum_received && error_flag == 0){
    4956:	4582      	cmp	sl, r0
    4958:	f040 81fc 	bne.w	4d54 <grid_port_receive_decode+0x498>
			if (message[1] == GRID_CONST_BRC){ // Broadcast message
    495c:	786b      	ldrb	r3, [r5, #1]
    495e:	2b0f      	cmp	r3, #15
    4960:	f040 810c 	bne.w	4b7c <grid_port_receive_decode+0x2c0>
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4964:	f107 061f 	add.w	r6, r7, #31
				uint8_t error=0;
    4968:	f04f 0300 	mov.w	r3, #0
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    496c:	f8df b204 	ldr.w	fp, [pc, #516]	; 4b74 <grid_port_receive_decode+0x2b8>
				uint8_t error=0;
    4970:	77fb      	strb	r3, [r7, #31]
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4972:	2202      	movs	r2, #2
    4974:	4633      	mov	r3, r6
    4976:	2104      	movs	r1, #4
    4978:	4628      	mov	r0, r5
    497a:	47d8      	blx	fp
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    497c:	4649      	mov	r1, r9
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    497e:	6078      	str	r0, [r7, #4]
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4980:	4633      	mov	r3, r6
    4982:	2202      	movs	r2, #2
    4984:	4628      	mov	r0, r5
    4986:	47d8      	blx	fp
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4988:	4633      	mov	r3, r6
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    498a:	6038      	str	r0, [r7, #0]
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    498c:	2202      	movs	r2, #2
    498e:	2106      	movs	r1, #6
    4990:	4628      	mov	r0, r5
    4992:	47d8      	blx	fp
    4994:	b2c3      	uxtb	r3, r0
    4996:	617b      	str	r3, [r7, #20]
    4998:	f1a3 0a7f 	sub.w	sl, r3, #127	; 0x7f
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    499c:	2202      	movs	r2, #2
    499e:	4633      	mov	r3, r6
    49a0:	2108      	movs	r1, #8
    49a2:	4628      	mov	r0, r5
    49a4:	47d8      	blx	fp
    49a6:	b2c3      	uxtb	r3, r0
    49a8:	613b      	str	r3, [r7, #16]
    49aa:	f1a3 097f 	sub.w	r9, r3, #127	; 0x7f
				uint8_t received_rot = grid_msg_get_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
    49ae:	2202      	movs	r2, #2
    49b0:	4633      	mov	r3, r6
    49b2:	210c      	movs	r1, #12
    49b4:	4628      	mov	r0, r5
    49b6:	47d8      	blx	fp
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    49b8:	f642 7330 	movw	r3, #12080	; 0x2f30
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    49bc:	fa4f fa8a 	sxtb.w	sl, sl
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    49c0:	5ce3      	ldrb	r3, [r4, r3]
    49c2:	4418      	add	r0, r3
    49c4:	f000 0203 	and.w	r2, r0, #3
    49c8:	ee08 2a10 	vmov	s16, r2
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    49cc:	fa4f f989 	sxtb.w	r9, r9
				if (por->partner_fi == 0){ // 0 deg
    49d0:	b143      	cbz	r3, 49e4 <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 1){ // 90 deg
    49d2:	2b01      	cmp	r3, #1
    49d4:	f040 8098 	bne.w	4b08 <grid_port_receive_decode+0x24c>
					rotated_dx  -= received_dy;
    49d8:	693b      	ldr	r3, [r7, #16]
    49da:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dy  += received_dx;
    49de:	46d1      	mov	r9, sl
					rotated_dx  -= received_dy;
    49e0:	fa4f fa83 	sxtb.w	sl, r3
				uint8_t updated_dx = rotated_dx + GRID_SYS_DEFAULT_POSITION + por->dx;
    49e4:	f642 7349 	movw	r3, #12105	; 0x2f49
    49e8:	f897 b000 	ldrb.w	fp, [r7]
    49ec:	5ce3      	ldrb	r3, [r4, r3]
    49ee:	337f      	adds	r3, #127	; 0x7f
    49f0:	449a      	add	sl, r3
    49f2:	fa5f f38a 	uxtb.w	r3, sl
    49f6:	60fb      	str	r3, [r7, #12]
				uint8_t updated_dy = rotated_dy + GRID_SYS_DEFAULT_POSITION + por->dy;
    49f8:	f642 734a 	movw	r3, #12106	; 0x2f4a
    49fc:	f814 a003 	ldrb.w	sl, [r4, r3]
    4a00:	f10a 0a7f 	add.w	sl, sl, #127	; 0x7f
    4a04:	44d1      	add	r9, sl
    4a06:	fa5f f389 	uxtb.w	r3, r9
    4a0a:	60bb      	str	r3, [r7, #8]
				if (received_dx + GRID_SYS_DEFAULT_POSITION == 0 && received_dy + GRID_SYS_DEFAULT_POSITION == 0)
    4a0c:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    4a10:	4313      	orrs	r3, r2
    4a12:	f897 a004 	ldrb.w	sl, [r7, #4]
    4a16:	d020      	beq.n	4a5a <grid_port_receive_decode+0x19e>
					grid_msg_set_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, updated_id, &error);
    4a18:	f8df 915c 	ldr.w	r9, [pc, #348]	; 4b78 <grid_port_receive_decode+0x2bc>
    4a1c:	9600      	str	r6, [sp, #0]
    4a1e:	4653      	mov	r3, sl
    4a20:	2202      	movs	r2, #2
    4a22:	2104      	movs	r1, #4
    4a24:	4628      	mov	r0, r5
    4a26:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, updated_dx, &error);
    4a28:	9600      	str	r6, [sp, #0]
    4a2a:	68fb      	ldr	r3, [r7, #12]
    4a2c:	2202      	movs	r2, #2
    4a2e:	2106      	movs	r1, #6
    4a30:	4628      	mov	r0, r5
    4a32:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, updated_dy, &error);
    4a34:	9600      	str	r6, [sp, #0]
    4a36:	68bb      	ldr	r3, [r7, #8]
    4a38:	2202      	movs	r2, #2
    4a3a:	2108      	movs	r1, #8
    4a3c:	4628      	mov	r0, r5
    4a3e:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, updated_age, &error);
    4a40:	465b      	mov	r3, fp
    4a42:	2202      	movs	r2, #2
    4a44:	210a      	movs	r1, #10
    4a46:	9600      	str	r6, [sp, #0]
    4a48:	4628      	mov	r0, r5
    4a4a:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, updated_rot, &error);
    4a4c:	ee18 3a10 	vmov	r3, s16
    4a50:	9600      	str	r6, [sp, #0]
    4a52:	2202      	movs	r2, #2
    4a54:	210c      	movs	r1, #12
    4a56:	4628      	mov	r0, r5
    4a58:	47c8      	blx	r9
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a5a:	68fb      	ldr	r3, [r7, #12]
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a5c:	483c      	ldr	r0, [pc, #240]	; (4b50 <grid_port_receive_decode+0x294>)
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a5e:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a62:	68bb      	ldr	r3, [r7, #8]
    4a64:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a68:	eb0b 2a0a 	add.w	sl, fp, sl, lsl #8
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a6c:	4b39      	ldr	r3, [pc, #228]	; (4b54 <grid_port_receive_decode+0x298>)
    4a6e:	4651      	mov	r1, sl
    4a70:	4798      	blx	r3
    4a72:	b9d8      	cbnz	r0, 4aac <grid_port_receive_decode+0x1f0>
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a74:	4b35      	ldr	r3, [pc, #212]	; (4b4c <grid_port_receive_decode+0x290>)
    4a76:	4641      	mov	r1, r8
    4a78:	4628      	mov	r0, r5
    4a7a:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a7c:	f504 542c 	add.w	r4, r4, #11008	; 0x2b00
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a80:	4b35      	ldr	r3, [pc, #212]	; (4b58 <grid_port_receive_decode+0x29c>)
    4a82:	4602      	mov	r2, r0
    4a84:	4641      	mov	r1, r8
    4a86:	4628      	mov	r0, r5
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a88:	3434      	adds	r4, #52	; 0x34
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a8a:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a8c:	4b33      	ldr	r3, [pc, #204]	; (4b5c <grid_port_receive_decode+0x2a0>)
    4a8e:	4641      	mov	r1, r8
    4a90:	4620      	mov	r0, r4
    4a92:	4798      	blx	r3
    4a94:	b150      	cbz	r0, 4aac <grid_port_receive_decode+0x1f0>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4a96:	4e32      	ldr	r6, [pc, #200]	; (4b60 <grid_port_receive_decode+0x2a4>)
    4a98:	44a8      	add	r8, r5
						for (uint16_t i=0; i<length; i++){
    4a9a:	45a8      	cmp	r8, r5
    4a9c:	d14d      	bne.n	4b3a <grid_port_receive_decode+0x27e>
						grid_buffer_write_acknowledge(&por->rx_buffer);
    4a9e:	4b31      	ldr	r3, [pc, #196]	; (4b64 <grid_port_receive_decode+0x2a8>)
    4aa0:	4620      	mov	r0, r4
    4aa2:	4798      	blx	r3
						grid_msg_push_recent(&grid_sys_state, fingerprint);
    4aa4:	482a      	ldr	r0, [pc, #168]	; (4b50 <grid_port_receive_decode+0x294>)
    4aa6:	4b30      	ldr	r3, [pc, #192]	; (4b68 <grid_port_receive_decode+0x2ac>)
    4aa8:	4651      	mov	r1, sl
    4aaa:	4798      	blx	r3
}
    4aac:	3724      	adds	r7, #36	; 0x24
    4aae:	46bd      	mov	sp, r7
    4ab0:	ecbd 8b02 	vpop	{d8}
    4ab4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4ab8:	18d6      	adds	r6, r2, r3
    4aba:	fbb6 f1f0 	udiv	r1, r6, r0
    4abe:	fb00 6111 	mls	r1, r0, r1, r6
    4ac2:	4421      	add	r1, r4
    4ac4:	5d4e      	ldrb	r6, [r1, r5]
    4ac6:	f809 6002 	strb.w	r6, [r9, r2]
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    4aca:	f801 c005 	strb.w	ip, [r1, r5]
	for (uint16_t i = 0; i<length; i++){
    4ace:	3201      	adds	r2, #1
    4ad0:	e70b      	b.n	48ea <grid_port_receive_decode+0x2e>
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    4ad2:	18d6      	adds	r6, r2, r3
    4ad4:	fbb6 f1f0 	udiv	r1, r6, r0
    4ad8:	fb00 6111 	mls	r1, r0, r1, r6
    4adc:	4421      	add	r1, r4
    4ade:	3201      	adds	r2, #1
    4ae0:	f801 e00c 	strb.w	lr, [r1, ip]
	for (uint16_t i = 0; i<length; i++){
    4ae4:	e70c      	b.n	4900 <grid_port_receive_decode+0x44>
		if (buffer[i] == GRID_CONST_SOH){
    4ae6:	f819 2006 	ldrb.w	r2, [r9, r6]
    4aea:	2a01      	cmp	r2, #1
    4aec:	d109      	bne.n	4b02 <grid_port_receive_decode+0x246>
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4aee:	4651      	mov	r1, sl
    4af0:	4658      	mov	r0, fp
    4af2:	4798      	blx	r3
			length -= i;
    4af4:	eba8 0806 	sub.w	r8, r8, r6
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4af8:	4b12      	ldr	r3, [pc, #72]	; (4b44 <grid_port_receive_decode+0x288>)
			length -= i;
    4afa:	fa1f f888 	uxth.w	r8, r8
			message = &buffer[i];
    4afe:	eb09 0506 	add.w	r5, r9, r6
	for (uint16_t i = 1; i<length; i++){
    4b02:	3601      	adds	r6, #1
    4b04:	b2b6      	uxth	r6, r6
    4b06:	e70e      	b.n	4926 <grid_port_receive_decode+0x6a>
				else if(por->partner_fi == 2){ // 180 deg
    4b08:	2b02      	cmp	r3, #2
    4b0a:	d10a      	bne.n	4b22 <grid_port_receive_decode+0x266>
					rotated_dx  -= received_dx;
    4b0c:	697b      	ldr	r3, [r7, #20]
    4b0e:	f1c3 0a7f 	rsb	sl, r3, #127	; 0x7f
					rotated_dy  -= received_dy;
    4b12:	693b      	ldr	r3, [r7, #16]
					rotated_dx  -= received_dx;
    4b14:	fa4f fa8a 	sxtb.w	sl, sl
					rotated_dy  -= received_dy;
    4b18:	f1c3 097f 	rsb	r9, r3, #127	; 0x7f
					rotated_dy  -= received_dx;
    4b1c:	fa4f f989 	sxtb.w	r9, r9
    4b20:	e760      	b.n	49e4 <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 3){ // 270 deg
    4b22:	2b03      	cmp	r3, #3
    4b24:	d105      	bne.n	4b32 <grid_port_receive_decode+0x276>
					rotated_dy  -= received_dx;
    4b26:	697b      	ldr	r3, [r7, #20]
    4b28:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dx  += received_dy;
    4b2c:	46ca      	mov	sl, r9
					rotated_dy  -= received_dx;
    4b2e:	4699      	mov	r9, r3
    4b30:	e7f4      	b.n	4b1c <grid_port_receive_decode+0x260>
				int8_t rotated_dy = 0;
    4b32:	f04f 0900 	mov.w	r9, #0
				int8_t rotated_dx = 0;
    4b36:	46ca      	mov	sl, r9
    4b38:	e754      	b.n	49e4 <grid_port_receive_decode+0x128>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4b3a:	f815 1b01 	ldrb.w	r1, [r5], #1
    4b3e:	4620      	mov	r0, r4
    4b40:	47b0      	blx	r6
						for (uint16_t i=0; i<length; i++){
    4b42:	e7aa      	b.n	4a9a <grid_port_receive_decode+0x1de>
    4b44:	000143b9 	.word	0x000143b9
    4b48:	000099e9 	.word	0x000099e9
    4b4c:	000099d1 	.word	0x000099d1
    4b50:	20007a24 	.word	0x20007a24
    4b54:	00009a41 	.word	0x00009a41
    4b58:	00009a05 	.word	0x00009a05
    4b5c:	00004839 	.word	0x00004839
    4b60:	00004875 	.word	0x00004875
    4b64:	00004895 	.word	0x00004895
    4b68:	00009a5b 	.word	0x00009a5b
    4b6c:	00016628 	.word	0x00016628
    4b70:	0001663b 	.word	0x0001663b
    4b74:	00009a15 	.word	0x00009a15
    4b78:	00009a2d 	.word	0x00009a2d
			else if (message[1] == GRID_CONST_DCT){ // Direct Message
    4b7c:	2b0e      	cmp	r3, #14
    4b7e:	f040 80e5 	bne.w	4d4c <grid_port_receive_decode+0x490>
				if (message[2] == GRID_CONST_ACK){
    4b82:	78ab      	ldrb	r3, [r5, #2]
    4b84:	2b07      	cmp	r3, #7
    4b86:	d191      	bne.n	4aac <grid_port_receive_decode+0x1f0>
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b88:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4d68 <grid_port_receive_decode+0x4ac>
    4b8c:	2200      	movs	r2, #0
    4b8e:	2102      	movs	r1, #2
    4b90:	f105 0008 	add.w	r0, r5, #8
    4b94:	47c8      	blx	r9
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b96:	2200      	movs	r2, #0
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b98:	fa5f fa80 	uxtb.w	sl, r0
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b9c:	2102      	movs	r1, #2
    4b9e:	1da8      	adds	r0, r5, #6
    4ba0:	47c8      	blx	r9
					if (por->partner_status == 0){
    4ba2:	f642 724b 	movw	r2, #12107	; 0x2f4b
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4ba6:	fa5f fb80 	uxtb.w	fp, r0
					if (por->partner_status == 0){
    4baa:	5ca2      	ldrb	r2, [r4, r2]
    4bac:	2a00      	cmp	r2, #0
    4bae:	d172      	bne.n	4c96 <grid_port_receive_decode+0x3da>
						if (por->ping_local_token == 255){ // I have no clue
    4bb0:	f642 7931 	movw	r9, #12081	; 0x2f31
    4bb4:	f814 2009 	ldrb.w	r2, [r4, r9]
    4bb8:	2aff      	cmp	r2, #255	; 0xff
    4bba:	d11b      	bne.n	4bf4 <grid_port_receive_decode+0x338>
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4bbc:	4a66      	ldr	r2, [pc, #408]	; (4d58 <grid_port_receive_decode+0x49c>)
    4bbe:	4867      	ldr	r0, [pc, #412]	; (4d5c <grid_port_receive_decode+0x4a0>)
    4bc0:	4790      	blx	r2
    4bc2:	f000 027f 	and.w	r2, r0, #127	; 0x7f
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4bc6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4bca:	f804 2009 	strb.w	r2, [r4, r9]
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4bce:	4b64      	ldr	r3, [pc, #400]	; (4d60 <grid_port_receive_decode+0x4a4>)
    4bd0:	2102      	movs	r1, #2
    4bd2:	3039      	adds	r0, #57	; 0x39
    4bd4:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4bd6:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4bda:	f642 7247 	movw	r2, #12103	; 0x2f47
    4bde:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4be2:	5ca1      	ldrb	r1, [r4, r2]
    4be4:	6179      	str	r1, [r7, #20]
    4be6:	4648      	mov	r0, r9
    4be8:	47b0      	blx	r6
    4bea:	6979      	ldr	r1, [r7, #20]
    4bec:	4b5d      	ldr	r3, [pc, #372]	; (4d64 <grid_port_receive_decode+0x4a8>)
    4bee:	4602      	mov	r2, r0
    4bf0:	4648      	mov	r0, r9
    4bf2:	4798      	blx	r3
						if (partner_token_received != por->ping_partner_token){
    4bf4:	f642 7232 	movw	r2, #12082	; 0x2f32
    4bf8:	5ca1      	ldrb	r1, [r4, r2]
    4bfa:	4559      	cmp	r1, fp
    4bfc:	d017      	beq.n	4c2e <grid_port_receive_decode+0x372>
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bfe:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = partner_token_received;							
    4c02:	f804 b002 	strb.w	fp, [r4, r2]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4c06:	4b56      	ldr	r3, [pc, #344]	; (4d60 <grid_port_receive_decode+0x4a4>)
    4c08:	465a      	mov	r2, fp
    4c0a:	2102      	movs	r1, #2
    4c0c:	303b      	adds	r0, #59	; 0x3b
    4c0e:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4c10:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4c14:	f642 7347 	movw	r3, #12103	; 0x2f47
    4c18:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4c1c:	5ce1      	ldrb	r1, [r4, r3]
    4c1e:	6179      	str	r1, [r7, #20]
    4c20:	4648      	mov	r0, r9
    4c22:	47b0      	blx	r6
    4c24:	6979      	ldr	r1, [r7, #20]
    4c26:	4b4f      	ldr	r3, [pc, #316]	; (4d64 <grid_port_receive_decode+0x4a8>)
    4c28:	4602      	mov	r2, r0
    4c2a:	4648      	mov	r0, r9
    4c2c:	4798      	blx	r3
						if (por->ping_local_token != local_token_received){
    4c2e:	f642 7331 	movw	r3, #12081	; 0x2f31
    4c32:	5ce3      	ldrb	r3, [r4, r3]
    4c34:	4553      	cmp	r3, sl
    4c36:	d129      	bne.n	4c8c <grid_port_receive_decode+0x3d0>
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c38:	7a62      	ldrb	r2, [r4, #9]
    4c3a:	78eb      	ldrb	r3, [r5, #3]
    4c3c:	1a9b      	subs	r3, r3, r2
    4c3e:	3306      	adds	r3, #6
    4c40:	425a      	negs	r2, r3
    4c42:	f002 0203 	and.w	r2, r2, #3
    4c46:	f003 0303 	and.w	r3, r3, #3
    4c4a:	bf58      	it	pl
    4c4c:	4253      	negpl	r3, r2
    4c4e:	f642 7230 	movw	r2, #12080	; 0x2f30
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c52:	f1a8 000a 	sub.w	r0, r8, #10
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c56:	54a3      	strb	r3, [r4, r2]
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c58:	2102      	movs	r1, #2
    4c5a:	4b43      	ldr	r3, [pc, #268]	; (4d68 <grid_port_receive_decode+0x4ac>)
    4c5c:	2200      	movs	r2, #0
    4c5e:	4428      	add	r0, r5
    4c60:	4798      	blx	r3
    4c62:	f642 732c 	movw	r3, #12076	; 0x2f2c
							por->partner_status = 1;
    4c66:	2201      	movs	r2, #1
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c68:	50e0      	str	r0, [r4, r3]
							por->partner_status = 1;
    4c6a:	f642 734b 	movw	r3, #12107	; 0x2f4b
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c6e:	493f      	ldr	r1, [pc, #252]	; (4d6c <grid_port_receive_decode+0x4b0>)
							por->partner_status = 1;
    4c70:	54e2      	strb	r2, [r4, r3]
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c72:	483f      	ldr	r0, [pc, #252]	; (4d70 <grid_port_receive_decode+0x4b4>)
    4c74:	4b3f      	ldr	r3, [pc, #252]	; (4d74 <grid_port_receive_decode+0x4b8>)
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c76:	4d40      	ldr	r5, [pc, #256]	; (4d78 <grid_port_receive_decode+0x4bc>)
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c78:	4798      	blx	r3
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c7a:	2300      	movs	r3, #0
    4c7c:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    4c80:	e9cd 3200 	strd	r3, r2, [sp]
    4c84:	4835      	ldr	r0, [pc, #212]	; (4d5c <grid_port_receive_decode+0x4a0>)
    4c86:	22ff      	movs	r2, #255	; 0xff
    4c88:	4619      	mov	r1, r3
    4c8a:	47a8      	blx	r5
						por->ping_flag = 1;
    4c8c:	f642 7348 	movw	r3, #12104	; 0x2f48
    4c90:	2201      	movs	r2, #1
    4c92:	54e2      	strb	r2, [r4, r3]
    4c94:	e70a      	b.n	4aac <grid_port_receive_decode+0x1f0>
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c96:	7a61      	ldrb	r1, [r4, #9]
    4c98:	78ea      	ldrb	r2, [r5, #3]
    4c9a:	1a52      	subs	r2, r2, r1
    4c9c:	3206      	adds	r2, #6
    4c9e:	4251      	negs	r1, r2
						validator &= local_token_received == por->ping_local_token;
    4ca0:	f642 7031 	movw	r0, #12081	; 0x2f31
						validator &= partner_token_received == por->ping_partner_token;
    4ca4:	f642 7c32 	movw	ip, #12082	; 0x2f32
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4ca8:	f001 0103 	and.w	r1, r1, #3
						validator &= local_token_received == por->ping_local_token;
    4cac:	5c20      	ldrb	r0, [r4, r0]
						validator &= partner_token_received == por->ping_partner_token;
    4cae:	f814 c00c 	ldrb.w	ip, [r4, ip]
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4cb2:	f002 0203 	and.w	r2, r2, #3
    4cb6:	bf58      	it	pl
    4cb8:	424a      	negpl	r2, r1
    4cba:	f642 7130 	movw	r1, #12080	; 0x2f30
    4cbe:	4550      	cmp	r0, sl
    4cc0:	bf08      	it	eq
    4cc2:	45dc      	cmpeq	ip, fp
    4cc4:	5c61      	ldrb	r1, [r4, r1]
    4cc6:	bf0c      	ite	eq
    4cc8:	f04f 0a01 	moveq.w	sl, #1
    4ccc:	f04f 0a00 	movne.w	sl, #0
						validator &= por->partner_hwcfg == grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4cd0:	f642 732c 	movw	r3, #12076	; 0x2f2c
    4cd4:	f1a8 000a 	sub.w	r0, r8, #10
    4cd8:	428a      	cmp	r2, r1
    4cda:	bf14      	ite	ne
    4cdc:	f04f 0a00 	movne.w	sl, #0
    4ce0:	f00a 0a01 	andeq.w	sl, sl, #1
    4ce4:	4428      	add	r0, r5
    4ce6:	2200      	movs	r2, #0
    4ce8:	2102      	movs	r1, #2
    4cea:	f854 b003 	ldr.w	fp, [r4, r3]
    4cee:	47c8      	blx	r9
						if (validator == 1){
    4cf0:	4558      	cmp	r0, fp
    4cf2:	d103      	bne.n	4cfc <grid_port_receive_decode+0x440>
    4cf4:	f1ba 0f00 	cmp.w	sl, #0
    4cf8:	f47f aed8 	bne.w	4aac <grid_port_receive_decode+0x1f0>
							por->partner_status = 0;
    4cfc:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4d00:	2200      	movs	r2, #0
    4d02:	54e2      	strb	r2, [r4, r3]
							por->ping_local_token = 255;
    4d04:	f642 7831 	movw	r8, #12081	; 0x2f31
							por->ping_partner_token = 255;
    4d08:	f642 7332 	movw	r3, #12082	; 0x2f32
    4d0c:	22ff      	movs	r2, #255	; 0xff
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4d0e:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = 255;
    4d12:	54e2      	strb	r2, [r4, r3]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4d14:	4d12      	ldr	r5, [pc, #72]	; (4d60 <grid_port_receive_decode+0x4a4>)
							por->ping_local_token = 255;
    4d16:	f804 2008 	strb.w	r2, [r4, r8]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4d1a:	2102      	movs	r1, #2
    4d1c:	303b      	adds	r0, #59	; 0x3b
    4d1e:	47a8      	blx	r5
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4d20:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4d24:	f814 2008 	ldrb.w	r2, [r4, r8]
    4d28:	2102      	movs	r1, #2
    4d2a:	3039      	adds	r0, #57	; 0x39
    4d2c:	47a8      	blx	r5
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4d2e:	f642 7347 	movw	r3, #12103	; 0x2f47
    4d32:	f504 553c 	add.w	r5, r4, #12032	; 0x2f00
    4d36:	3533      	adds	r5, #51	; 0x33
    4d38:	5ce1      	ldrb	r1, [r4, r3]
    4d3a:	6179      	str	r1, [r7, #20]
    4d3c:	4628      	mov	r0, r5
    4d3e:	47b0      	blx	r6
    4d40:	6979      	ldr	r1, [r7, #20]
    4d42:	4b08      	ldr	r3, [pc, #32]	; (4d64 <grid_port_receive_decode+0x4a8>)
    4d44:	4602      	mov	r2, r0
    4d46:	4628      	mov	r0, r5
    4d48:	4798      	blx	r3
    4d4a:	e6af      	b.n	4aac <grid_port_receive_decode+0x1f0>
				printf("{\"type\": \"WARNING\", \"data\": [\"Unknow Message Type\"]}\r\n");
    4d4c:	480b      	ldr	r0, [pc, #44]	; (4d7c <grid_port_receive_decode+0x4c0>)
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d4e:	4b0c      	ldr	r3, [pc, #48]	; (4d80 <grid_port_receive_decode+0x4c4>)
    4d50:	4798      	blx	r3
	return;
    4d52:	e6ab      	b.n	4aac <grid_port_receive_decode+0x1f0>
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d54:	480b      	ldr	r0, [pc, #44]	; (4d84 <grid_port_receive_decode+0x4c8>)
    4d56:	e7fa      	b.n	4d4e <grid_port_receive_decode+0x492>
    4d58:	000097a9 	.word	0x000097a9
    4d5c:	20007a24 	.word	0x20007a24
    4d60:	00009889 	.word	0x00009889
    4d64:	00009a05 	.word	0x00009a05
    4d68:	00009861 	.word	0x00009861
    4d6c:	00016660 	.word	0x00016660
    4d70:	0001663b 	.word	0x0001663b
    4d74:	000143b9 	.word	0x000143b9
    4d78:	00009813 	.word	0x00009813
    4d7c:	00016668 	.word	0x00016668
    4d80:	000144c9 	.word	0x000144c9
    4d84:	0001669e 	.word	0x0001669e

00004d88 <grid_port_receive_task>:
void grid_port_receive_task(struct grid_port* por){
    4d88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (por->usart_error_flag == 1){
    4d8a:	7e03      	ldrb	r3, [r0, #24]
    4d8c:	2b01      	cmp	r3, #1
void grid_port_receive_task(struct grid_port* por){
    4d8e:	4604      	mov	r4, r0
	if (por->usart_error_flag == 1){
    4d90:	d10d      	bne.n	4dae <grid_port_receive_task+0x26>
		por->usart_error_flag = 0;
    4d92:	2500      	movs	r5, #0
    4d94:	7605      	strb	r5, [r0, #24]
		grid_port_reset_receiver(por);
    4d96:	4b53      	ldr	r3, [pc, #332]	; (4ee4 <grid_port_receive_task+0x15c>)
    4d98:	4798      	blx	r3
		grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500); // White triangle
    4d9a:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d9e:	e9cd 5300 	strd	r5, r3, [sp]
    4da2:	23ff      	movs	r3, #255	; 0xff
    4da4:	4850      	ldr	r0, [pc, #320]	; (4ee8 <grid_port_receive_task+0x160>)
    4da6:	4d51      	ldr	r5, [pc, #324]	; (4eec <grid_port_receive_task+0x164>)
    4da8:	461a      	mov	r2, r3
    4daa:	4619      	mov	r1, r3
    4dac:	47a8      	blx	r5
	if	(por->rx_double_buffer_status == 0){
    4dae:	6a25      	ldr	r5, [r4, #32]
    4db0:	bb7d      	cbnz	r5, 4e12 <grid_port_receive_task+0x8a>
		if (por->usart!=NULL){ // His is GRID usart port
    4db2:	6863      	ldr	r3, [r4, #4]
    4db4:	b1cb      	cbz	r3, 4dea <grid_port_receive_task+0x62>
			if (por->rx_double_buffer_timeout > 1000){
    4db6:	69e3      	ldr	r3, [r4, #28]
    4db8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4dbc:	d93e      	bls.n	4e3c <grid_port_receive_task+0xb4>
				if (por->partner_status == 1){
    4dbe:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4dc2:	5ce3      	ldrb	r3, [r4, r3]
    4dc4:	2b01      	cmp	r3, #1
    4dc6:	d12c      	bne.n	4e22 <grid_port_receive_task+0x9a>
					GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout Disconnect & Reset Receiver");
    4dc8:	4949      	ldr	r1, [pc, #292]	; (4ef0 <grid_port_receive_task+0x168>)
    4dca:	4b4a      	ldr	r3, [pc, #296]	; (4ef4 <grid_port_receive_task+0x16c>)
    4dcc:	484a      	ldr	r0, [pc, #296]	; (4ef8 <grid_port_receive_task+0x170>)
    4dce:	4798      	blx	r3
					grid_port_reset_receiver(por);
    4dd0:	4b44      	ldr	r3, [pc, #272]	; (4ee4 <grid_port_receive_task+0x15c>)
    4dd2:	4620      	mov	r0, r4
    4dd4:	4798      	blx	r3
					grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500);
    4dd6:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4dda:	e9cd 5300 	strd	r5, r3, [sp]
    4dde:	23ff      	movs	r3, #255	; 0xff
    4de0:	4841      	ldr	r0, [pc, #260]	; (4ee8 <grid_port_receive_task+0x160>)
    4de2:	4d42      	ldr	r5, [pc, #264]	; (4eec <grid_port_receive_task+0x164>)
    4de4:	461a      	mov	r2, r3
    4de6:	4619      	mov	r1, r3
    4de8:	47a8      	blx	r5
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4dea:	f241 3687 	movw	r6, #4999	; 0x1387
void grid_port_receive_task(struct grid_port* por){
    4dee:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4df2:	f241 30b4 	movw	r0, #5044	; 0x13b4
    4df6:	46b4      	mov	ip, r6
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4df8:	f241 3788 	movw	r7, #5000	; 0x1388
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4dfc:	f241 3e86 	movw	lr, #4998	; 0x1386
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4e00:	6a62      	ldr	r2, [r4, #36]	; 0x24
    4e02:	18a3      	adds	r3, r4, r2
    4e04:	5c1b      	ldrb	r3, [r3, r0]
    4e06:	2b0a      	cmp	r3, #10
    4e08:	d11b      	bne.n	4e42 <grid_port_receive_task+0xba>
				por->rx_double_buffer_timeout = 0;
    4e0a:	2300      	movs	r3, #0
    4e0c:	2501      	movs	r5, #1
    4e0e:	e9c4 3507 	strd	r3, r5, [r4, #28]
	if (por->rx_double_buffer_read_start_index < por->rx_double_buffer_seek_start_index){
    4e12:	e9d4 2109 	ldrd	r2, r1, [r4, #36]	; 0x24
    4e16:	4291      	cmp	r1, r2
    4e18:	d359      	bcc.n	4ece <grid_port_receive_task+0x146>
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e1a:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
    4e1e:	3209      	adds	r2, #9
    4e20:	e056      	b.n	4ed0 <grid_port_receive_task+0x148>
					if (por->rx_double_buffer_read_start_index == 0 && por->rx_double_buffer_seek_start_index == 0){
    4e22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4e24:	b913      	cbnz	r3, 4e2c <grid_port_receive_task+0xa4>
    4e26:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4e28:	2b00      	cmp	r3, #0
    4e2a:	d0de      	beq.n	4dea <grid_port_receive_task+0x62>
						GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout & Reset Receiver");
    4e2c:	4933      	ldr	r1, [pc, #204]	; (4efc <grid_port_receive_task+0x174>)
    4e2e:	4b31      	ldr	r3, [pc, #196]	; (4ef4 <grid_port_receive_task+0x16c>)
    4e30:	4831      	ldr	r0, [pc, #196]	; (4ef8 <grid_port_receive_task+0x170>)
    4e32:	4798      	blx	r3
						grid_port_reset_receiver(por);
    4e34:	4b2b      	ldr	r3, [pc, #172]	; (4ee4 <grid_port_receive_task+0x15c>)
    4e36:	4620      	mov	r0, r4
    4e38:	4798      	blx	r3
    4e3a:	e7d6      	b.n	4dea <grid_port_receive_task+0x62>
				por->rx_double_buffer_timeout++;
    4e3c:	3301      	adds	r3, #1
    4e3e:	61e3      	str	r3, [r4, #28]
    4e40:	e7d3      	b.n	4dea <grid_port_receive_task+0x62>
			else if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 0){
    4e42:	b923      	cbnz	r3, 4e4e <grid_port_receive_task+0xc6>
	if (por->rx_double_buffer_status == 0){
    4e44:	6a23      	ldr	r3, [r4, #32]
    4e46:	2b00      	cmp	r3, #0
    4e48:	d1e3      	bne.n	4e12 <grid_port_receive_task+0x8a>
}
    4e4a:	b003      	add	sp, #12
    4e4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (por->rx_double_buffer_seek_start_index == por->rx_double_buffer_read_start_index-1)
    4e4e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    4e50:	1e6b      	subs	r3, r5, #1
    4e52:	429a      	cmp	r2, r3
    4e54:	d10d      	bne.n	4e72 <grid_port_receive_task+0xea>
				grid_port_reset_receiver(por);	
    4e56:	4b23      	ldr	r3, [pc, #140]	; (4ee4 <grid_port_receive_task+0x15c>)
    4e58:	4620      	mov	r0, r4
    4e5a:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 255, 0, 0, 2, 200); // RED
    4e5c:	2302      	movs	r3, #2
    4e5e:	20c8      	movs	r0, #200	; 0xc8
    4e60:	e9cd 3000 	strd	r3, r0, [sp]
    4e64:	2300      	movs	r3, #0
    4e66:	461a      	mov	r2, r3
    4e68:	21ff      	movs	r1, #255	; 0xff
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e6a:	481f      	ldr	r0, [pc, #124]	; (4ee8 <grid_port_receive_task+0x160>)
    4e6c:	4c1f      	ldr	r4, [pc, #124]	; (4eec <grid_port_receive_task+0x164>)
    4e6e:	47a0      	blx	r4
				return;
    4e70:	e7eb      	b.n	4e4a <grid_port_receive_task+0xc2>
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4e72:	42b2      	cmp	r2, r6
    4e74:	d10b      	bne.n	4e8e <grid_port_receive_task+0x106>
    4e76:	b955      	cbnz	r5, 4e8e <grid_port_receive_task+0x106>
				grid_port_reset_receiver(por);
    4e78:	4b1a      	ldr	r3, [pc, #104]	; (4ee4 <grid_port_receive_task+0x15c>)
    4e7a:	4620      	mov	r0, r4
    4e7c:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 2, 200); // RED
    4e7e:	2302      	movs	r3, #2
    4e80:	21c8      	movs	r1, #200	; 0xc8
    4e82:	e9cd 3100 	strd	r3, r1, [sp]
    4e86:	22ff      	movs	r2, #255	; 0xff
    4e88:	462b      	mov	r3, r5
    4e8a:	4629      	mov	r1, r5
    4e8c:	e7ed      	b.n	4e6a <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4e8e:	4465      	add	r5, ip
    4e90:	fbb5 f3f7 	udiv	r3, r5, r7
    4e94:	fb07 5513 	mls	r5, r7, r3, r5
    4e98:	4425      	add	r5, r4
    4e9a:	5c2b      	ldrb	r3, [r5, r0]
    4e9c:	b153      	cbz	r3, 4eb4 <grid_port_receive_task+0x12c>
				grid_port_reset_receiver(por);
    4e9e:	4b11      	ldr	r3, [pc, #68]	; (4ee4 <grid_port_receive_task+0x15c>)
    4ea0:	4620      	mov	r0, r4
    4ea2:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4ea4:	2302      	movs	r3, #2
    4ea6:	22c8      	movs	r2, #200	; 0xc8
    4ea8:	e9cd 3200 	strd	r3, r2, [sp]
    4eac:	2200      	movs	r2, #0
    4eae:	23ff      	movs	r3, #255	; 0xff
    4eb0:	4611      	mov	r1, r2
    4eb2:	e7da      	b.n	4e6a <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4eb4:	4572      	cmp	r2, lr
				por->rx_double_buffer_seek_start_index++;
    4eb6:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
    4eba:	bf98      	it	ls
    4ebc:	3201      	addls	r2, #1
    4ebe:	b289      	uxth	r1, r1
				por->rx_double_buffer_timeout = 0;
    4ec0:	61e3      	str	r3, [r4, #28]
				por->rx_double_buffer_seek_start_index++;
    4ec2:	bf94      	ite	ls
    4ec4:	6262      	strls	r2, [r4, #36]	; 0x24
				por->rx_double_buffer_seek_start_index=0;
    4ec6:	6263      	strhi	r3, [r4, #36]	; 0x24
		for(uint16_t i = 0; i<490; i++){
    4ec8:	2900      	cmp	r1, #0
    4eca:	d199      	bne.n	4e00 <grid_port_receive_task+0x78>
    4ecc:	e7ba      	b.n	4e44 <grid_port_receive_task+0xbc>
		length = por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4ece:	3201      	adds	r2, #1
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4ed0:	1a52      	subs	r2, r2, r1
	grid_port_receive_decode(por, por->rx_double_buffer_read_start_index, length);
    4ed2:	4b0b      	ldr	r3, [pc, #44]	; (4f00 <grid_port_receive_task+0x178>)
    4ed4:	b292      	uxth	r2, r2
    4ed6:	b289      	uxth	r1, r1
    4ed8:	4620      	mov	r0, r4
    4eda:	4798      	blx	r3
	por->rx_double_buffer_status = 0;
    4edc:	2300      	movs	r3, #0
    4ede:	6223      	str	r3, [r4, #32]
    4ee0:	e7b3      	b.n	4e4a <grid_port_receive_task+0xc2>
    4ee2:	bf00      	nop
    4ee4:	00004731 	.word	0x00004731
    4ee8:	20007a24 	.word	0x20007a24
    4eec:	00009813 	.word	0x00009813
    4ef0:	000166d1 	.word	0x000166d1
    4ef4:	000143b9 	.word	0x000143b9
    4ef8:	0001663b 	.word	0x0001663b
    4efc:	000166f5 	.word	0x000166f5
    4f00:	000048bd 	.word	0x000048bd

00004f04 <grid_buffer_read_size>:
	return 1;
}

uint16_t grid_buffer_read_size(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f04:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4f08:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f0c:	428b      	cmp	r3, r1
uint16_t grid_buffer_read_size(struct grid_buffer* buf){
    4f0e:	b5f0      	push	{r4, r5, r6, r7, lr}
    4f10:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop) {
    4f12:	d000      	beq.n	4f16 <grid_buffer_read_size+0x12>
		while(1){
    4f14:	e7fe      	b.n	4f14 <grid_buffer_read_size+0x10>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f16:	f8b0 63ea 	ldrh.w	r6, [r0, #1002]	; 0x3ea
    4f1a:	42b3      	cmp	r3, r6
    4f1c:	d000      	beq.n	4f20 <grid_buffer_read_size+0x1c>
		while(1){
    4f1e:	e7fe      	b.n	4f1e <grid_buffer_read_size+0x1a>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	if (buf->read_start == buf->write_start) {
    4f20:	f8b0 73f2 	ldrh.w	r7, [r0, #1010]	; 0x3f2
    4f24:	42be      	cmp	r6, r7
    4f26:	d016      	beq.n	4f56 <grid_buffer_read_size+0x52>
	}
	
	
	
	// Seek message end character
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f28:	8805      	ldrh	r5, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f2a:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f2c:	b2a3      	uxth	r3, r4
    4f2e:	429d      	cmp	r5, r3
    4f30:	d800      	bhi.n	4f34 <grid_buffer_read_size+0x30>
		}
		
		
	}
	
	while(1){
    4f32:	e7fe      	b.n	4f32 <grid_buffer_read_size+0x2e>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f34:	1930      	adds	r0, r6, r4
    4f36:	fbb0 f1f5 	udiv	r1, r0, r5
    4f3a:	fb05 0111 	mls	r1, r5, r1, r0
		if (index == buf->write_start) return 0;
    4f3e:	b288      	uxth	r0, r1
    4f40:	4287      	cmp	r7, r0
    4f42:	d008      	beq.n	4f56 <grid_buffer_read_size+0x52>
		if (buf->buffer_storage[index] == '\n'){
    4f44:	4411      	add	r1, r2
    4f46:	3301      	adds	r3, #1
    4f48:	b298      	uxth	r0, r3
    4f4a:	788b      	ldrb	r3, [r1, #2]
    4f4c:	2b0a      	cmp	r3, #10
    4f4e:	f104 0401 	add.w	r4, r4, #1
    4f52:	d1eb      	bne.n	4f2c <grid_buffer_read_size+0x28>
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f54:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f56:	2000      	movs	r0, #0
    4f58:	e7fc      	b.n	4f54 <grid_buffer_read_size+0x50>

00004f5a <grid_buffer_read_init>:

uint16_t grid_buffer_read_init(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f5a:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4f5e:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f62:	4293      	cmp	r3, r2
uint16_t grid_buffer_read_init(struct grid_buffer* buf){
    4f64:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->read_active != buf->read_stop) {
    4f66:	d000      	beq.n	4f6a <grid_buffer_read_init+0x10>
		while(1){
    4f68:	e7fe      	b.n	4f68 <grid_buffer_read_init+0xe>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f6a:	f8b0 53ea 	ldrh.w	r5, [r0, #1002]	; 0x3ea
    4f6e:	42ab      	cmp	r3, r5
    4f70:	d000      	beq.n	4f74 <grid_buffer_read_init+0x1a>
		while(1){
    4f72:	e7fe      	b.n	4f72 <grid_buffer_read_init+0x18>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	if (buf->read_start == buf->write_start) {
    4f74:	f8b0 63f2 	ldrh.w	r6, [r0, #1010]	; 0x3f2
    4f78:	42b5      	cmp	r5, r6
    4f7a:	d020      	beq.n	4fbe <grid_buffer_read_init+0x64>
	}
	
	
	
	// Seek message end character	
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f7c:	8801      	ldrh	r1, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f7e:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f80:	b2a3      	uxth	r3, r4
    4f82:	4299      	cmp	r1, r3
    4f84:	d800      	bhi.n	4f88 <grid_buffer_read_init+0x2e>
		}
		
		
	}
		
	while(1){
    4f86:	e7fe      	b.n	4f86 <grid_buffer_read_init+0x2c>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f88:	192f      	adds	r7, r5, r4
    4f8a:	fbb7 f2f1 	udiv	r2, r7, r1
    4f8e:	fb01 7212 	mls	r2, r1, r2, r7
		if (index == buf->write_start) return 0;	
    4f92:	b297      	uxth	r7, r2
    4f94:	42be      	cmp	r6, r7
    4f96:	d012      	beq.n	4fbe <grid_buffer_read_init+0x64>
		if (buf->buffer_storage[index] == '\n'){
    4f98:	1887      	adds	r7, r0, r2
    4f9a:	3301      	adds	r3, #1
    4f9c:	78bf      	ldrb	r7, [r7, #2]
    4f9e:	2f0a      	cmp	r7, #10
    4fa0:	b29b      	uxth	r3, r3
    4fa2:	f104 0401 	add.w	r4, r4, #1
    4fa6:	d1eb      	bne.n	4f80 <grid_buffer_read_init+0x26>
			buf->read_stop = (index+1)%buf->buffer_length;
    4fa8:	3201      	adds	r2, #1
    4faa:	fbb2 f4f1 	udiv	r4, r2, r1
    4fae:	fb01 2214 	mls	r2, r1, r4, r2
    4fb2:	f8a0 23ec 	strh.w	r2, [r0, #1004]	; 0x3ec
			buf->read_length = i+1;
    4fb6:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4fba:	4618      	mov	r0, r3
    4fbc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4fbe:	2300      	movs	r3, #0
    4fc0:	e7fb      	b.n	4fba <grid_buffer_read_init+0x60>

00004fc2 <grid_buffer_read_character>:

uint8_t grid_buffer_read_character(struct grid_buffer* buf){
	
	// Check if packet is not over
	if (buf->read_active != buf->read_stop){
    4fc2:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4fc6:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4fca:	4299      	cmp	r1, r3
uint8_t grid_buffer_read_character(struct grid_buffer* buf){
    4fcc:	b510      	push	{r4, lr}
    4fce:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop){
    4fd0:	d00b      	beq.n	4fea <grid_buffer_read_character+0x28>
		
		uint8_t character = buf->buffer_storage[buf->read_active];
		
		buf->read_active++;
		buf->read_active %= buf->buffer_length;
    4fd2:	8814      	ldrh	r4, [r2, #0]
		uint8_t character = buf->buffer_storage[buf->read_active];
    4fd4:	18c1      	adds	r1, r0, r3
		buf->read_active++;
    4fd6:	3301      	adds	r3, #1
		buf->read_active %= buf->buffer_length;
    4fd8:	b29b      	uxth	r3, r3
		uint8_t character = buf->buffer_storage[buf->read_active];
    4fda:	7888      	ldrb	r0, [r1, #2]
		buf->read_active %= buf->buffer_length;
    4fdc:	fbb3 f1f4 	udiv	r1, r3, r4
    4fe0:	fb04 3311 	mls	r3, r4, r1, r3
    4fe4:	f8a2 33ee 	strh.w	r3, [r2, #1006]	; 0x3ee
			// TRAP: TRANSMISSION WAS OVER ALREADY
		}
	}
	

}
    4fe8:	bd10      	pop	{r4, pc}
		while(1){
    4fea:	e7fe      	b.n	4fea <grid_buffer_read_character+0x28>

00004fec <grid_buffer_read_acknowledge>:

// TRANSMISSION WAS ACKNOWLEDGED, PACKET CAN BE DELETED
uint8_t grid_buffer_read_acknowledge(struct grid_buffer* buf){
	
	// Check if packet is really over
	if (buf->read_active == buf->read_stop){
    4fec:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4ff0:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4ff4:	4293      	cmp	r3, r2
    4ff6:	d000      	beq.n	4ffa <grid_buffer_read_acknowledge+0xe>
		buf->read_start = buf->read_stop;
		return 1;
	}else{
		
		while(1){
    4ff8:	e7fe      	b.n	4ff8 <grid_buffer_read_acknowledge+0xc>
		buf->read_start = buf->read_stop;
    4ffa:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	

}
    4ffe:	2001      	movs	r0, #1
    5000:	4770      	bx	lr
	...

00005004 <grid_port_init>:
	buf->read_start  = buf->read_stop;
	
	return 1;
}

void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    5004:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    5008:	4604      	mov	r4, r0
	
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    500a:	f500 501c 	add.w	r0, r0, #9984	; 0x2700
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    500e:	b087      	sub	sp, #28
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    5010:	f8df 8148 	ldr.w	r8, [pc, #328]	; 515c <grid_port_init+0x158>
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    5014:	460d      	mov	r5, r1
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    5016:	303c      	adds	r0, #60	; 0x3c
    5018:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    501c:	4616      	mov	r6, r2
    501e:	461f      	mov	r7, r3
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    5020:	47c0      	blx	r8
	grid_buffer_init(&por->rx_buffer, GRID_BUFFER_SIZE);
    5022:	f504 502c 	add.w	r0, r4, #11008	; 0x2b00
    5026:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    502a:	3034      	adds	r0, #52	; 0x34
    502c:	47c0      	blx	r8
	
	
	por->cooldown = 0;
    502e:	2000      	movs	r0, #0
	
	por->dma_channel = dma;
    5030:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
	por->cooldown = 0;
    5034:	6020      	str	r0, [r4, #0]
	
	por->tx_double_buffer_status	= 0;
	por->rx_double_buffer_status	= 0;
	
	
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5036:	f241 3288 	movw	r2, #5000	; 0x1388
	por->dma_channel = dma;
    503a:	72a3      	strb	r3, [r4, #10]
	por->direction = dir;
    503c:	7267      	strb	r7, [r4, #9]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    503e:	4603      	mov	r3, r0
	por->usart	= usart;
    5040:	6065      	str	r5, [r4, #4]
	por->type		= type;
    5042:	7226      	strb	r6, [r4, #8]
	por->tx_double_buffer_status	= 0;
    5044:	81a0      	strh	r0, [r4, #12]
	por->rx_double_buffer_status	= 0;
    5046:	6220      	str	r0, [r4, #32]
		por->tx_double_buffer[i] = 0;		
    5048:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    504a:	3301      	adds	r3, #1
    504c:	4293      	cmp	r3, r2
		por->tx_double_buffer[i] = 0;		
    504e:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5052:	d1f9      	bne.n	5048 <grid_port_init+0x44>
	}
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5054:	2300      	movs	r3, #0
		por->rx_double_buffer[i] = 0;
    5056:	f241 31b4 	movw	r1, #5044	; 0x13b4
    505a:	461d      	mov	r5, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    505c:	f241 3288 	movw	r2, #5000	; 0x1388
		por->rx_double_buffer[i] = 0;
    5060:	18e0      	adds	r0, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5062:	3301      	adds	r3, #1
    5064:	4293      	cmp	r3, r2
		por->rx_double_buffer[i] = 0;
    5066:	5445      	strb	r5, [r0, r1]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5068:	d1fa      	bne.n	5060 <grid_port_init+0x5c>
	}
	
	por->partner_fi = 0;
	
	por->partner_hwcfg = 0;
    506a:	f642 732c 	movw	r3, #12076	; 0x2f2c
	por->partner_fi = 0;
    506e:	f642 7130 	movw	r1, #12080	; 0x2f30
	por->partner_status = 1;
	
	por->ping_local_token = 255;
    5072:	f642 7031 	movw	r0, #12081	; 0x2f31
	por->partner_fi = 0;
    5076:	5465      	strb	r5, [r4, r1]
	por->partner_hwcfg = 0;
    5078:	50e5      	str	r5, [r4, r3]
	por->partner_status = 1;
    507a:	f642 734b 	movw	r3, #12107	; 0x2f4b
    507e:	2201      	movs	r2, #1
	por->ping_local_token = 255;
    5080:	27ff      	movs	r7, #255	; 0xff
	por->partner_status = 1;
    5082:	54e2      	strb	r2, [r4, r3]
	por->ping_local_token = 255;
    5084:	5427      	strb	r7, [r4, r0]
	por->ping_partner_token = 255;
    5086:	f642 7032 	movw	r0, #12082	; 0x2f32
	
	por->ping_flag = 0;
	
	if (type == GRID_PORT_TYPE_USART){	
    508a:	4296      	cmp	r6, r2
	por->ping_partner_token = 255;
    508c:	5427      	strb	r7, [r4, r0]
	por->ping_flag = 0;
    508e:	f642 7048 	movw	r0, #12104	; 0x2f48
    5092:	5425      	strb	r5, [r4, r0]
	if (type == GRID_PORT_TYPE_USART){	
    5094:	d156      	bne.n	5144 <grid_port_init+0x140>
		
		por->partner_status = 0;
    5096:	54e5      	strb	r5, [r4, r3]
		por->partner_fi = 0;
    5098:	5465      	strb	r5, [r4, r1]
		
		
		sprintf(por->ping_packet, "%c%c%c%c%02x%02x%02x%c00\n", GRID_CONST_SOH, GRID_CONST_DCT, GRID_CONST_BELL, por->direction, grid_sys_get_hwcfg(), 255, 255, GRID_CONST_EOT);
    509a:	4b2b      	ldr	r3, [pc, #172]	; (5148 <grid_port_init+0x144>)
    509c:	f894 9009 	ldrb.w	r9, [r4, #9]
    50a0:	4798      	blx	r3
    50a2:	f504 583c 	add.w	r8, r4, #12032	; 0x2f00
    50a6:	2304      	movs	r3, #4
    50a8:	f108 0833 	add.w	r8, r8, #51	; 0x33
    50ac:	e9cd 7304 	strd	r7, r3, [sp, #16]
    50b0:	fa5f f989 	uxtb.w	r9, r9
    50b4:	2307      	movs	r3, #7
    50b6:	4632      	mov	r2, r6
    50b8:	4924      	ldr	r1, [pc, #144]	; (514c <grid_port_init+0x148>)
    50ba:	f8cd 9004 	str.w	r9, [sp, #4]
    50be:	e9cd 0702 	strd	r0, r7, [sp, #8]
    50c2:	f8df 909c 	ldr.w	r9, [pc, #156]	; 5160 <grid_port_init+0x15c>
    50c6:	9300      	str	r3, [sp, #0]
    50c8:	4640      	mov	r0, r8
    50ca:	230e      	movs	r3, #14
    50cc:	47c8      	blx	r9
		
		por->ping_packet_length = strlen(por->ping_packet);	
    50ce:	4b20      	ldr	r3, [pc, #128]	; (5150 <grid_port_init+0x14c>)
    50d0:	4640      	mov	r0, r8
    50d2:	4798      	blx	r3
    50d4:	f642 7347 	movw	r3, #12103	; 0x2f47
    50d8:	b2c0      	uxtb	r0, r0
    50da:	54e0      	strb	r0, [r4, r3]
			
		grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    50dc:	4640      	mov	r0, r8
    50de:	f814 9003 	ldrb.w	r9, [r4, r3]
    50e2:	5ce1      	ldrb	r1, [r4, r3]
    50e4:	4b1b      	ldr	r3, [pc, #108]	; (5154 <grid_port_init+0x150>)
    50e6:	4798      	blx	r3
    50e8:	fa5f f989 	uxtb.w	r9, r9
    50ec:	4b1a      	ldr	r3, [pc, #104]	; (5158 <grid_port_init+0x154>)
    50ee:	4602      	mov	r2, r0
    50f0:	4649      	mov	r1, r9
    50f2:	4640      	mov	r0, r8
    50f4:	4798      	blx	r3
		

		
		if (por->direction == GRID_CONST_NORTH){
    50f6:	7a63      	ldrb	r3, [r4, #9]
    50f8:	2b11      	cmp	r3, #17
    50fa:	d108      	bne.n	510e <grid_port_init+0x10a>
			por->dx = 0;
    50fc:	f642 7349 	movw	r3, #12105	; 0x2f49
    5100:	54e5      	strb	r5, [r4, r3]
			por->dy = 1;
    5102:	f642 734a 	movw	r3, #12106	; 0x2f4a
    5106:	54e6      	strb	r6, [r4, r3]
	}
	else{
		por->partner_status = 1; //UI AND USB are considered to be connected by default
	}
	
}
    5108:	b007      	add	sp, #28
    510a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if (por->direction == GRID_CONST_EAST){
    510e:	7a63      	ldrb	r3, [r4, #9]
    5110:	2b12      	cmp	r3, #18
    5112:	d106      	bne.n	5122 <grid_port_init+0x11e>
			por->dx = 1;
    5114:	f642 7349 	movw	r3, #12105	; 0x2f49
    5118:	54e6      	strb	r6, [r4, r3]
			por->dy = 0;
    511a:	f642 734a 	movw	r3, #12106	; 0x2f4a
    511e:	54e5      	strb	r5, [r4, r3]
    5120:	e7f2      	b.n	5108 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_SOUTH){
    5122:	7a63      	ldrb	r3, [r4, #9]
    5124:	2b13      	cmp	r3, #19
    5126:	d106      	bne.n	5136 <grid_port_init+0x132>
			por->dx = 0;
    5128:	f642 7349 	movw	r3, #12105	; 0x2f49
    512c:	54e5      	strb	r5, [r4, r3]
			por->dy = -1;
    512e:	f642 734a 	movw	r3, #12106	; 0x2f4a
    5132:	54e7      	strb	r7, [r4, r3]
    5134:	e7e8      	b.n	5108 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_WEST){
    5136:	7a63      	ldrb	r3, [r4, #9]
    5138:	2b14      	cmp	r3, #20
    513a:	d1e5      	bne.n	5108 <grid_port_init+0x104>
			por->dx = -1;
    513c:	f642 7349 	movw	r3, #12105	; 0x2f49
    5140:	54e7      	strb	r7, [r4, r3]
    5142:	e7ea      	b.n	511a <grid_port_init+0x116>
		por->partner_status = 1; //UI AND USB are considered to be connected by default
    5144:	54e2      	strb	r2, [r4, r3]
}
    5146:	e7df      	b.n	5108 <grid_port_init+0x104>
    5148:	000098ed 	.word	0x000098ed
    514c:	0001670e 	.word	0x0001670e
    5150:	00014c81 	.word	0x00014c81
    5154:	000099d1 	.word	0x000099d1
    5158:	00009a05 	.word	0x00009a05
    515c:	000047dd 	.word	0x000047dd
    5160:	000147d1 	.word	0x000147d1

00005164 <grid_port_init_all>:

void grid_port_init_all(void){
    5164:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5168:	2600      	movs	r6, #0
    516a:	4d1c      	ldr	r5, [pc, #112]	; (51dc <grid_port_init_all+0x78>)
    516c:	491c      	ldr	r1, [pc, #112]	; (51e0 <grid_port_init_all+0x7c>)
    516e:	481d      	ldr	r0, [pc, #116]	; (51e4 <grid_port_init_all+0x80>)
    5170:	9600      	str	r6, [sp, #0]
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    5172:	2401      	movs	r4, #1
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5174:	2311      	movs	r3, #17
    5176:	2201      	movs	r2, #1
    5178:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    517a:	f04f 0902 	mov.w	r9, #2
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    517e:	4622      	mov	r2, r4
    5180:	4919      	ldr	r1, [pc, #100]	; (51e8 <grid_port_init_all+0x84>)
    5182:	481a      	ldr	r0, [pc, #104]	; (51ec <grid_port_init_all+0x88>)
    5184:	9400      	str	r4, [sp, #0]
    5186:	2312      	movs	r3, #18
    5188:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    518a:	2703      	movs	r7, #3
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    518c:	4622      	mov	r2, r4
    518e:	4918      	ldr	r1, [pc, #96]	; (51f0 <grid_port_init_all+0x8c>)
    5190:	4818      	ldr	r0, [pc, #96]	; (51f4 <grid_port_init_all+0x90>)
    5192:	f8cd 9000 	str.w	r9, [sp]
    5196:	2313      	movs	r3, #19
    5198:	47a8      	blx	r5
	
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    519a:	f8df 8068 	ldr.w	r8, [pc, #104]	; 5204 <grid_port_init_all+0xa0>
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    519e:	9700      	str	r7, [sp, #0]
    51a0:	4622      	mov	r2, r4
    51a2:	4915      	ldr	r1, [pc, #84]	; (51f8 <grid_port_init_all+0x94>)
    51a4:	4815      	ldr	r0, [pc, #84]	; (51fc <grid_port_init_all+0x98>)
    51a6:	2314      	movs	r3, #20
    51a8:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    51aa:	f04f 0aff 	mov.w	sl, #255	; 0xff
    51ae:	463a      	mov	r2, r7
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    51b0:	4f13      	ldr	r7, [pc, #76]	; (5200 <grid_port_init_all+0x9c>)
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    51b2:	f8cd a000 	str.w	sl, [sp]
    51b6:	4633      	mov	r3, r6
    51b8:	4631      	mov	r1, r6
    51ba:	4640      	mov	r0, r8
    51bc:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    51be:	4633      	mov	r3, r6
    51c0:	f8cd a000 	str.w	sl, [sp]
    51c4:	464a      	mov	r2, r9
    51c6:	4631      	mov	r1, r6
    51c8:	4638      	mov	r0, r7
    51ca:	47a8      	blx	r5
	
	GRID_PORT_U.partner_status = 1; // UI IS ALWAYS CONNECTED
    51cc:	f642 734b 	movw	r3, #12107	; 0x2f4b
    51d0:	f808 4003 	strb.w	r4, [r8, r3]
	GRID_PORT_H.partner_status = 1; // HOST IS ALWAYS CONNECTED (Not really!)
    51d4:	54fc      	strb	r4, [r7, r3]
	
	
}
    51d6:	b002      	add	sp, #8
    51d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    51dc:	00005005 	.word	0x00005005
    51e0:	20015824 	.word	0x20015824
    51e4:	20001b6c 	.word	0x20001b6c
    51e8:	200157d0 	.word	0x200157d0
    51ec:	2001228c 	.word	0x2001228c
    51f0:	20015928 	.word	0x20015928
    51f4:	2000c2f0 	.word	0x2000c2f0
    51f8:	200158d8 	.word	0x200158d8
    51fc:	20008cf0 	.word	0x20008cf0
    5200:	2000f240 	.word	0x2000f240
    5204:	20004acc 	.word	0x20004acc

00005208 <grid_port_process_inbound>:


//=============================== PROCESS INBOUND ==============================//


uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    5208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    520c:	f500 582c 	add.w	r8, r0, #11008	; 0x2b00
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    5210:	b091      	sub	sp, #68	; 0x44
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    5212:	f108 0834 	add.w	r8, r8, #52	; 0x34
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    5216:	af02      	add	r7, sp, #8
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    5218:	4b5c      	ldr	r3, [pc, #368]	; (538c <grid_port_process_inbound+0x184>)
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    521a:	6079      	str	r1, [r7, #4]
    521c:	4606      	mov	r6, r0
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    521e:	4640      	mov	r0, r8
    5220:	4798      	blx	r3
	
	if (!packet_size){
    5222:	4605      	mov	r5, r0
    5224:	2800      	cmp	r0, #0
    5226:	f000 80af 	beq.w	5388 <grid_port_process_inbound+0x180>
		uint8_t port_count = 6;
		struct grid_port* port_array_default[port_count];
		struct grid_port* port_array[port_count];
		
		
		port_array_default[0] = &GRID_PORT_N;
    522a:	4b59      	ldr	r3, [pc, #356]	; (5390 <grid_port_process_inbound+0x188>)
    522c:	60bb      	str	r3, [r7, #8]
		port_array_default[1] = &GRID_PORT_E;
    522e:	4b59      	ldr	r3, [pc, #356]	; (5394 <grid_port_process_inbound+0x18c>)
    5230:	60fb      	str	r3, [r7, #12]
		port_array_default[2] = &GRID_PORT_S;
    5232:	4b59      	ldr	r3, [pc, #356]	; (5398 <grid_port_process_inbound+0x190>)
    5234:	613b      	str	r3, [r7, #16]
		port_array_default[3] = &GRID_PORT_W;
    5236:	4b59      	ldr	r3, [pc, #356]	; (539c <grid_port_process_inbound+0x194>)
    5238:	617b      	str	r3, [r7, #20]
		
		port_array_default[4] = &GRID_PORT_U;
    523a:	4b59      	ldr	r3, [pc, #356]	; (53a0 <grid_port_process_inbound+0x198>)
    523c:	61bb      	str	r3, [r7, #24]
		port_array_default[5] = &GRID_PORT_H;
    523e:	4b59      	ldr	r3, [pc, #356]	; (53a4 <grid_port_process_inbound+0x19c>)
    5240:	61fb      	str	r3, [r7, #28]
	}else{
    5242:	46eb      	mov	fp, sp
		
		uint8_t j=0;
		
		for(uint8_t i=0; i<port_count; i++){
    5244:	f107 0308 	add.w	r3, r7, #8
		port_array_default[5] = &GRID_PORT_H;
    5248:	f04f 0906 	mov.w	r9, #6
		uint8_t j=0;
    524c:	2400      	movs	r4, #0
			if (port_array_default[i]->partner_status != 0){
    524e:	f642 714b 	movw	r1, #12107	; 0x2f4b
    5252:	f853 2b04 	ldr.w	r2, [r3], #4
    5256:	5c50      	ldrb	r0, [r2, r1]
    5258:	b138      	cbz	r0, 526a <grid_port_process_inbound+0x62>
				port_array[j] = port_array_default[i];
    525a:	f107 0038 	add.w	r0, r7, #56	; 0x38
    525e:	eb00 0084 	add.w	r0, r0, r4, lsl #2
				j++;
    5262:	3401      	adds	r4, #1
				port_array[j] = port_array_default[i];
    5264:	f840 2c18 	str.w	r2, [r0, #-24]
				j++;
    5268:	b2e4      	uxtb	r4, r4
		for(uint8_t i=0; i<port_count; i++){
    526a:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    526e:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
    5272:	d1ee      	bne.n	5252 <grid_port_process_inbound+0x4a>
		
		for (uint8_t i=0; i<port_count; i++)
		{
			if (port_array[i] != por || loopback){
			
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5274:	4a4c      	ldr	r2, [pc, #304]	; (53a8 <grid_port_process_inbound+0x1a0>)
    5276:	4649      	mov	r1, r9
			if (port_array[i] != por || loopback){
    5278:	f107 0a20 	add.w	sl, r7, #32
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    527c:	f242 7c3c 	movw	ip, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5280:	b2c8      	uxtb	r0, r1
    5282:	4284      	cmp	r4, r0
    5284:	d805      	bhi.n	5292 <grid_port_process_inbound+0x8a>
					return 0;
				}	
			}	
		}
		
		if (packet_size != grid_buffer_read_init(&por->rx_buffer)){
    5286:	4b49      	ldr	r3, [pc, #292]	; (53ac <grid_port_process_inbound+0x1a4>)
    5288:	4640      	mov	r0, r8
    528a:	4798      	blx	r3
    528c:	42a8      	cmp	r0, r5
    528e:	d047      	beq.n	5320 <grid_port_process_inbound+0x118>
			while(1){			
    5290:	e7fe      	b.n	5290 <grid_port_process_inbound+0x88>
			if (port_array[i] != por || loopback){
    5292:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
    5296:	42b0      	cmp	r0, r6
    5298:	d101      	bne.n	529e <grid_port_process_inbound+0x96>
    529a:	687b      	ldr	r3, [r7, #4]
    529c:	b1b3      	cbz	r3, 52cc <grid_port_process_inbound+0xc4>
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    529e:	4460      	add	r0, ip
    52a0:	4790      	blx	r2
    52a2:	42a8      	cmp	r0, r5
    52a4:	4a40      	ldr	r2, [pc, #256]	; (53a8 <grid_port_process_inbound+0x1a0>)
    52a6:	f242 7c3c 	movw	ip, #10044	; 0x273c
    52aa:	d20f      	bcs.n	52cc <grid_port_process_inbound+0xc4>
					grid_sys_alert_set_alert(&grid_sys_state, 100,100,0,2,200);
    52ac:	2302      	movs	r3, #2
    52ae:	22c8      	movs	r2, #200	; 0xc8
    52b0:	e9cd 3200 	strd	r3, r2, [sp]
    52b4:	2264      	movs	r2, #100	; 0x64
    52b6:	483e      	ldr	r0, [pc, #248]	; (53b0 <grid_port_process_inbound+0x1a8>)
    52b8:	4c3e      	ldr	r4, [pc, #248]	; (53b4 <grid_port_process_inbound+0x1ac>)
    52ba:	2300      	movs	r3, #0
    52bc:	4611      	mov	r1, r2
    52be:	47a0      	blx	r4
					return 0;
    52c0:	46dd      	mov	sp, fp
		}	

		return 1;
	}
		
}
    52c2:	4648      	mov	r0, r9
    52c4:	373c      	adds	r7, #60	; 0x3c
    52c6:	46bd      	mov	sp, r7
    52c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (uint8_t i=0; i<port_count; i++)
    52cc:	3101      	adds	r1, #1
    52ce:	e7d7      	b.n	5280 <grid_port_process_inbound+0x78>
			if (port_array[i] != por || loopback){
    52d0:	f85a 0029 	ldr.w	r0, [sl, r9, lsl #2]
    52d4:	42b0      	cmp	r0, r6
    52d6:	d101      	bne.n	52dc <grid_port_process_inbound+0xd4>
    52d8:	6879      	ldr	r1, [r7, #4]
    52da:	b129      	cbz	r1, 52e8 <grid_port_process_inbound+0xe0>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52dc:	4418      	add	r0, r3
    52de:	4629      	mov	r1, r5
    52e0:	4790      	blx	r2
    52e2:	4a35      	ldr	r2, [pc, #212]	; (53b8 <grid_port_process_inbound+0x1b0>)
    52e4:	f242 733c 	movw	r3, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52e8:	f109 0901 	add.w	r9, r9, #1
    52ec:	fa5f f189 	uxtb.w	r1, r9
    52f0:	428c      	cmp	r4, r1
    52f2:	d8ed      	bhi.n	52d0 <grid_port_process_inbound+0xc8>
    52f4:	f04f 0a00 	mov.w	sl, #0
		for (uint16_t j=0; j<packet_size; j++)
    52f8:	fa1f f38a 	uxth.w	r3, sl
    52fc:	429d      	cmp	r5, r3
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52fe:	4640      	mov	r0, r8
		for (uint16_t j=0; j<packet_size; j++)
    5300:	d816      	bhi.n	5330 <grid_port_process_inbound+0x128>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    5302:	4b2e      	ldr	r3, [pc, #184]	; (53bc <grid_port_process_inbound+0x1b4>)
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5304:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 53c8 <grid_port_process_inbound+0x1c0>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    5308:	4798      	blx	r3
			if (port_array[i] != por || loopback){
    530a:	f107 0520 	add.w	r5, r7, #32
		for (uint8_t i=0; i<port_count; i++)
    530e:	2100      	movs	r1, #0
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5310:	f242 783c 	movw	r8, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5314:	b2cb      	uxtb	r3, r1
    5316:	429c      	cmp	r4, r3
    5318:	d82c      	bhi.n	5374 <grid_port_process_inbound+0x16c>
		return 1;
    531a:	f04f 0901 	mov.w	r9, #1
    531e:	e7cf      	b.n	52c0 <grid_port_process_inbound+0xb8>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    5320:	4a25      	ldr	r2, [pc, #148]	; (53b8 <grid_port_process_inbound+0x1b0>)
    5322:	f04f 0900 	mov.w	r9, #0
			if (port_array[i] != por || loopback){
    5326:	f107 0a20 	add.w	sl, r7, #32
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    532a:	f242 733c 	movw	r3, #10044	; 0x273c
    532e:	e7dd      	b.n	52ec <grid_port_process_inbound+0xe4>
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    5330:	4b23      	ldr	r3, [pc, #140]	; (53c0 <grid_port_process_inbound+0x1b8>)
    5332:	4798      	blx	r3
			for (uint8_t i=0; i<port_count; i++){
    5334:	f04f 0900 	mov.w	r9, #0
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    5338:	4601      	mov	r1, r0
				if (port_array[i] != por || loopback){
    533a:	f107 0320 	add.w	r3, r7, #32
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    533e:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    5342:	fa5f f089 	uxtb.w	r0, r9
    5346:	4284      	cmp	r4, r0
    5348:	d802      	bhi.n	5350 <grid_port_process_inbound+0x148>
		for (uint16_t j=0; j<packet_size; j++)
    534a:	f10a 0a01 	add.w	sl, sl, #1
    534e:	e7d3      	b.n	52f8 <grid_port_process_inbound+0xf0>
				if (port_array[i] != por || loopback){
    5350:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
    5354:	42b0      	cmp	r0, r6
    5356:	d101      	bne.n	535c <grid_port_process_inbound+0x154>
    5358:	687a      	ldr	r2, [r7, #4]
    535a:	b142      	cbz	r2, 536e <grid_port_process_inbound+0x166>
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    535c:	4b19      	ldr	r3, [pc, #100]	; (53c4 <grid_port_process_inbound+0x1bc>)
    535e:	6039      	str	r1, [r7, #0]
    5360:	4460      	add	r0, ip
    5362:	4798      	blx	r3
    5364:	6839      	ldr	r1, [r7, #0]
    5366:	f107 0320 	add.w	r3, r7, #32
    536a:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    536e:	f109 0901 	add.w	r9, r9, #1
    5372:	e7e6      	b.n	5342 <grid_port_process_inbound+0x13a>
			if (port_array[i] != por || loopback){
    5374:	f855 0021 	ldr.w	r0, [r5, r1, lsl #2]
    5378:	42b0      	cmp	r0, r6
    537a:	d101      	bne.n	5380 <grid_port_process_inbound+0x178>
    537c:	687b      	ldr	r3, [r7, #4]
    537e:	b10b      	cbz	r3, 5384 <grid_port_process_inbound+0x17c>
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5380:	4440      	add	r0, r8
    5382:	47c8      	blx	r9
		for (uint8_t i=0; i<port_count; i++)
    5384:	3101      	adds	r1, #1
    5386:	e7c5      	b.n	5314 <grid_port_process_inbound+0x10c>
		return 0;
    5388:	4681      	mov	r9, r0
    538a:	e79a      	b.n	52c2 <grid_port_process_inbound+0xba>
    538c:	00004f05 	.word	0x00004f05
    5390:	20001b6c 	.word	0x20001b6c
    5394:	2001228c 	.word	0x2001228c
    5398:	2000c2f0 	.word	0x2000c2f0
    539c:	20008cf0 	.word	0x20008cf0
    53a0:	20004acc 	.word	0x20004acc
    53a4:	2000f240 	.word	0x2000f240
    53a8:	00004821 	.word	0x00004821
    53ac:	00004f5b 	.word	0x00004f5b
    53b0:	20007a24 	.word	0x20007a24
    53b4:	00009813 	.word	0x00009813
    53b8:	00004839 	.word	0x00004839
    53bc:	00004fed 	.word	0x00004fed
    53c0:	00004fc3 	.word	0x00004fc3
    53c4:	00004875 	.word	0x00004875
    53c8:	00004895 	.word	0x00004895

000053cc <grid_port_process_outbound_usb>:



//=============================== PROCESS OUTBOUND ==============================//

uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    53cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			

	// OLD DEBUG IMPLEMENTATION
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    53d0:	f500 551c 	add.w	r5, r0, #9984	; 0x2700
    53d4:	353c      	adds	r5, #60	; 0x3c
    53d6:	4ba7      	ldr	r3, [pc, #668]	; (5674 <grid_port_process_outbound_usb+0x2a8>)
uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    53d8:	b0ed      	sub	sp, #436	; 0x1b4
    53da:	4680      	mov	r8, r0
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    53dc:	4628      	mov	r0, r5
    53de:	4798      	blx	r3
	
	if (!length){		
    53e0:	4604      	mov	r4, r0
    53e2:	b910      	cbnz	r0, 53ea <grid_port_process_outbound_usb+0x1e>
			
	// Let's send the packet through USB
	cdcdf_acm_write(por->tx_double_buffer, packet_length);

	
}
    53e4:	b06d      	add	sp, #436	; 0x1b4
    53e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    53ea:	f108 0b2c 	add.w	fp, r8, #44	; 0x2c
    53ee:	f508 539d 	add.w	r3, r8, #5024	; 0x13a0
    53f2:	3314      	adds	r3, #20
	if (!length){		
    53f4:	465a      	mov	r2, fp
		por->tx_double_buffer[i] = 0;
    53f6:	2100      	movs	r1, #0
    53f8:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    53fc:	429a      	cmp	r2, r3
    53fe:	d1fb      	bne.n	53f8 <grid_port_process_outbound_usb+0x2c>
	grid_msg_init(&message);
    5400:	4b9d      	ldr	r3, [pc, #628]	; (5678 <grid_port_process_outbound_usb+0x2ac>)
		grid_msg_packet_receive_char(&message, nextchar);
    5402:	f8df 92b8 	ldr.w	r9, [pc, #696]	; 56bc <grid_port_process_outbound_usb+0x2f0>
	grid_msg_init(&message);
    5406:	a805      	add	r0, sp, #20
    5408:	4798      	blx	r3
	grid_buffer_read_init(&por->tx_buffer);
    540a:	4b9c      	ldr	r3, [pc, #624]	; (567c <grid_port_process_outbound_usb+0x2b0>)
    540c:	4628      	mov	r0, r5
    540e:	4798      	blx	r3
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    5410:	4b9b      	ldr	r3, [pc, #620]	; (5680 <grid_port_process_outbound_usb+0x2b4>)
	for (uint16_t i = 0; i<length; i++){
    5412:	46da      	mov	sl, fp
    5414:	2700      	movs	r7, #0
    5416:	b2ba      	uxth	r2, r7
    5418:	4294      	cmp	r4, r2
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    541a:	4628      	mov	r0, r5
	for (uint16_t i = 0; i<length; i++){
    541c:	d825      	bhi.n	546a <grid_port_process_outbound_usb+0x9e>
	grid_buffer_read_acknowledge(&por->tx_buffer);
    541e:	4b99      	ldr	r3, [pc, #612]	; (5684 <grid_port_process_outbound_usb+0x2b8>)
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5420:	4c99      	ldr	r4, [pc, #612]	; (5688 <grid_port_process_outbound_usb+0x2bc>)
	grid_buffer_read_acknowledge(&por->tx_buffer);
    5422:	4798      	blx	r3
	int8_t dx = grid_msg_header_get_dx(&message) - GRID_SYS_DEFAULT_POSITION;
    5424:	4b99      	ldr	r3, [pc, #612]	; (568c <grid_port_process_outbound_usb+0x2c0>)
    5426:	a805      	add	r0, sp, #20
    5428:	4798      	blx	r3
    542a:	387f      	subs	r0, #127	; 0x7f
    542c:	b243      	sxtb	r3, r0
    542e:	9300      	str	r3, [sp, #0]
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    5430:	a805      	add	r0, sp, #20
    5432:	4b97      	ldr	r3, [pc, #604]	; (5690 <grid_port_process_outbound_usb+0x2c4>)
    5434:	4798      	blx	r3
    5436:	387f      	subs	r0, #127	; 0x7f
    5438:	b243      	sxtb	r3, r0
	for (uint16_t i=0; i<message.body_length; i++){
    543a:	f04f 0a00 	mov.w	sl, #0
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    543e:	9301      	str	r3, [sp, #4]
	uint8_t current_start		= 0;
    5440:	4656      	mov	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    5442:	9a6a      	ldr	r2, [sp, #424]	; 0x1a8
    5444:	fa1f f38a 	uxth.w	r3, sl
    5448:	429a      	cmp	r2, r3
    544a:	d818      	bhi.n	547e <grid_port_process_outbound_usb+0xb2>
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    544c:	4b91      	ldr	r3, [pc, #580]	; (5694 <grid_port_process_outbound_usb+0x2c8>)
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    544e:	4e92      	ldr	r6, [pc, #584]	; (5698 <grid_port_process_outbound_usb+0x2cc>)
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5450:	a805      	add	r0, sp, #20
    5452:	4798      	blx	r3
	for (uint32_t i=0; i<packet_length; i++){
    5454:	2400      	movs	r4, #0
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5456:	4605      	mov	r5, r0
	for (uint32_t i=0; i<packet_length; i++){
    5458:	42ac      	cmp	r4, r5
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    545a:	4621      	mov	r1, r4
	for (uint32_t i=0; i<packet_length; i++){
    545c:	f040 8104 	bne.w	5668 <grid_port_process_outbound_usb+0x29c>
	cdcdf_acm_write(por->tx_double_buffer, packet_length);
    5460:	4b8e      	ldr	r3, [pc, #568]	; (569c <grid_port_process_outbound_usb+0x2d0>)
    5462:	f108 002c 	add.w	r0, r8, #44	; 0x2c
    5466:	4798      	blx	r3
}
    5468:	e7bc      	b.n	53e4 <grid_port_process_outbound_usb+0x18>
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    546a:	4798      	blx	r3
    546c:	4606      	mov	r6, r0
		grid_msg_packet_receive_char(&message, nextchar);
    546e:	4601      	mov	r1, r0
    5470:	a805      	add	r0, sp, #20
    5472:	47c8      	blx	r9
		por->tx_double_buffer[i] = nextchar;	
    5474:	3701      	adds	r7, #1
    5476:	f80a 6b01 	strb.w	r6, [sl], #1
	for (uint16_t i = 0; i<length; i++){
    547a:	4b81      	ldr	r3, [pc, #516]	; (5680 <grid_port_process_outbound_usb+0x2b4>)
    547c:	e7cb      	b.n	5416 <grid_port_process_outbound_usb+0x4a>
		if (message.body[i] == GRID_CONST_STX){
    547e:	aa05      	add	r2, sp, #20
    5480:	4413      	add	r3, r2
    5482:	7d1b      	ldrb	r3, [r3, #20]
    5484:	2b02      	cmp	r3, #2
    5486:	d104      	bne.n	5492 <grid_port_process_outbound_usb+0xc6>
			current_start = i;
    5488:	fa5f f68a 	uxtb.w	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    548c:	f10a 0a01 	add.w	sl, sl, #1
    5490:	e7d7      	b.n	5442 <grid_port_process_outbound_usb+0x76>
		else if (message.body[i] == GRID_CONST_ETX && current_start!=0){
    5492:	2b03      	cmp	r3, #3
    5494:	d1fa      	bne.n	548c <grid_port_process_outbound_usb+0xc0>
    5496:	b90e      	cbnz	r6, 549c <grid_port_process_outbound_usb+0xd0>
			current_start = 0;
    5498:	2600      	movs	r6, #0
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    549a:	e7f7      	b.n	548c <grid_port_process_outbound_usb+0xc0>
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    549c:	4631      	mov	r1, r6
    549e:	2201      	movs	r2, #1
    54a0:	a805      	add	r0, sp, #20
    54a2:	47a0      	blx	r4
    54a4:	4635      	mov	r5, r6
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    54a6:	2301      	movs	r3, #1
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    54a8:	b2c6      	uxtb	r6, r0
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    54aa:	2204      	movs	r2, #4
    54ac:	4629      	mov	r1, r5
    54ae:	a805      	add	r0, sp, #20
    54b0:	47a0      	blx	r4
    54b2:	b2c0      	uxtb	r0, r0
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54b4:	2e00      	cmp	r6, #0
    54b6:	d13f      	bne.n	5538 <grid_port_process_outbound_usb+0x16c>
    54b8:	280e      	cmp	r0, #14
    54ba:	d1ed      	bne.n	5498 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_offset,		GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_length);
    54bc:	4629      	mov	r1, r5
    54be:	2302      	movs	r3, #2
    54c0:	2205      	movs	r2, #5
    54c2:	a805      	add	r0, sp, #20
    54c4:	47a0      	blx	r4
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    54c6:	4629      	mov	r1, r5
    54c8:	2302      	movs	r3, #2
    54ca:	2207      	movs	r2, #7
    54cc:	a805      	add	r0, sp, #20
    54ce:	47a0      	blx	r4
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    54d0:	4629      	mov	r1, r5
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    54d2:	4681      	mov	r9, r0
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    54d4:	2302      	movs	r3, #2
    54d6:	2209      	movs	r2, #9
    54d8:	a805      	add	r0, sp, #20
    54da:	47a0      	blx	r4
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54dc:	4629      	mov	r1, r5
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    54de:	4607      	mov	r7, r0
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54e0:	2302      	movs	r3, #2
    54e2:	220b      	movs	r2, #11
    54e4:	a805      	add	r0, sp, #20
    54e6:	47a0      	blx	r4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54e8:	9901      	ldr	r1, [sp, #4]
    54ea:	4a6d      	ldr	r2, [pc, #436]	; (56a0 <grid_port_process_outbound_usb+0x2d4>)
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54ec:	f88d 000f 	strb.w	r0, [sp, #15]
				uint8_t midi_command = 	(midi_commandchannel&0xF0)>>4;
    54f0:	f3c9 1303 	ubfx	r3, r9, #4, #4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54f4:	7bd2      	ldrb	r2, [r2, #15]
				midievent.byte0 = 0<<4|midi_command;
    54f6:	f88d 300c 	strb.w	r3, [sp, #12]
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54fa:	f1c1 0900 	rsb	r9, r1, #0
    54fe:	f009 0903 	and.w	r9, r9, #3
    5502:	eb09 0982 	add.w	r9, r9, r2, lsl #2
    5506:	f009 090f 	and.w	r9, r9, #15
				midievent.byte1 = midi_command<<4|midi_channel;
    550a:	ea49 1903 	orr.w	r9, r9, r3, lsl #4
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    550e:	b2ff      	uxtb	r7, r7
    5510:	9b00      	ldr	r3, [sp, #0]
				midievent.byte1 = midi_command<<4|midi_channel;
    5512:	f88d 900d 	strb.w	r9, [sp, #13]
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    5516:	37e0      	adds	r7, #224	; 0xe0
    5518:	2260      	movs	r2, #96	; 0x60
    551a:	eb07 1703 	add.w	r7, r7, r3, lsl #4
    551e:	fb97 f3f2 	sdiv	r3, r7, r2
    5522:	fb02 7713 	mls	r7, r2, r3, r7
    5526:	f88d 700e 	strb.w	r7, [sp, #14]
				grid_midi_tx_push(midievent);
    552a:	9803      	ldr	r0, [sp, #12]
    552c:	4b5d      	ldr	r3, [pc, #372]	; (56a4 <grid_port_process_outbound_usb+0x2d8>)
    552e:	4798      	blx	r3
				grid_midi_tx_pop(midievent);				
    5530:	9803      	ldr	r0, [sp, #12]
    5532:	4b5d      	ldr	r3, [pc, #372]	; (56a8 <grid_port_process_outbound_usb+0x2dc>)
    5534:	4798      	blx	r3
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5536:	e7a9      	b.n	548c <grid_port_process_outbound_usb+0xc0>
			else if (msg_class == GRID_CLASS_MIDIABSOLUTE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5538:	2e01      	cmp	r6, #1
    553a:	d127      	bne.n	558c <grid_port_process_outbound_usb+0x1c0>
    553c:	280e      	cmp	r0, #14
    553e:	d1ab      	bne.n	5498 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5540:	4629      	mov	r1, r5
    5542:	2302      	movs	r3, #2
    5544:	2205      	movs	r2, #5
    5546:	a805      	add	r0, sp, #20
    5548:	47a0      	blx	r4
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    554a:	4629      	mov	r1, r5
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    554c:	4681      	mov	r9, r0
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    554e:	2302      	movs	r3, #2
    5550:	2207      	movs	r2, #7
    5552:	a805      	add	r0, sp, #20
    5554:	47a0      	blx	r4
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5556:	4629      	mov	r1, r5
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5558:	4607      	mov	r7, r0
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    555a:	2302      	movs	r3, #2
    555c:	2209      	movs	r2, #9
    555e:	a805      	add	r0, sp, #20
    5560:	47a0      	blx	r4
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5562:	220b      	movs	r2, #11
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5564:	4606      	mov	r6, r0
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5566:	4629      	mov	r1, r5
    5568:	2302      	movs	r3, #2
    556a:	a805      	add	r0, sp, #20
    556c:	47a0      	blx	r4
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    556e:	f88d 900c 	strb.w	r9, [sp, #12]
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5572:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5576:	f88d 600e 	strb.w	r6, [sp, #14]
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    557a:	f88d 000f 	strb.w	r0, [sp, #15]
				grid_midi_tx_push(midievent);
    557e:	9803      	ldr	r0, [sp, #12]
    5580:	4b48      	ldr	r3, [pc, #288]	; (56a4 <grid_port_process_outbound_usb+0x2d8>)
    5582:	4798      	blx	r3
				grid_midi_tx_pop(midievent);	
    5584:	9803      	ldr	r0, [sp, #12]
    5586:	4b48      	ldr	r3, [pc, #288]	; (56a8 <grid_port_process_outbound_usb+0x2dc>)
    5588:	4798      	blx	r3
    558a:	e785      	b.n	5498 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    558c:	2e90      	cmp	r6, #144	; 0x90
    558e:	d11d      	bne.n	55cc <grid_port_process_outbound_usb+0x200>
    5590:	280e      	cmp	r0, #14
    5592:	d181      	bne.n	5498 <grid_port_process_outbound_usb+0xcc>
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5594:	4629      	mov	r1, r5
    5596:	2302      	movs	r3, #2
    5598:	2205      	movs	r2, #5
    559a:	a805      	add	r0, sp, #20
    559c:	47a0      	blx	r4
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    559e:	4629      	mov	r1, r5
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    55a0:	4607      	mov	r7, r0
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    55a2:	2302      	movs	r3, #2
    55a4:	2207      	movs	r2, #7
    55a6:	a805      	add	r0, sp, #20
    55a8:	47a0      	blx	r4
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    55aa:	4629      	mov	r1, r5
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    55ac:	4606      	mov	r6, r0
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    55ae:	2302      	movs	r3, #2
    55b0:	2209      	movs	r2, #9
    55b2:	a805      	add	r0, sp, #20
    55b4:	47a0      	blx	r4
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    55b6:	4b3d      	ldr	r3, [pc, #244]	; (56ac <grid_port_process_outbound_usb+0x2e0>)
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    55b8:	f88d 000e 	strb.w	r0, [sp, #14]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    55bc:	a903      	add	r1, sp, #12
    55be:	483c      	ldr	r0, [pc, #240]	; (56b0 <grid_port_process_outbound_usb+0x2e4>)
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    55c0:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    55c4:	f88d 600c 	strb.w	r6, [sp, #12]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    55c8:	4798      	blx	r3
    55ca:	e765      	b.n	5498 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYMACRO_code && msg_instr == GRID_INSTR_EXECUTE_code){
    55cc:	2e91      	cmp	r6, #145	; 0x91
    55ce:	f47f af63 	bne.w	5498 <grid_port_process_outbound_usb+0xcc>
    55d2:	280e      	cmp	r0, #14
    55d4:	f47f af60 	bne.w	5498 <grid_port_process_outbound_usb+0xcc>
    55d8:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55da:	2302      	movs	r3, #2
    55dc:	4632      	mov	r2, r6
    55de:	4629      	mov	r1, r5
    55e0:	a805      	add	r0, sp, #20
    55e2:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e4:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55e6:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e8:	2302      	movs	r3, #2
    55ea:	b2d2      	uxtb	r2, r2
    55ec:	4629      	mov	r1, r5
    55ee:	a805      	add	r0, sp, #20
    55f0:	47a0      	blx	r4
    55f2:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55f4:	28ff      	cmp	r0, #255	; 0xff
    55f6:	d00d      	beq.n	5614 <grid_port_process_outbound_usb+0x248>
                        key.ispressed = 1;
    55f8:	2201      	movs	r2, #1
    55fa:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    55fe:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    5600:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5602:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5606:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    560a:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    560c:	e893 0003 	ldmia.w	r3, {r0, r1}
    5610:	4b28      	ldr	r3, [pc, #160]	; (56b4 <grid_port_process_outbound_usb+0x2e8>)
    5612:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    5614:	3604      	adds	r6, #4
    5616:	b2f6      	uxtb	r6, r6
    5618:	2e1d      	cmp	r6, #29
    561a:	d1de      	bne.n	55da <grid_port_process_outbound_usb+0x20e>
                delay_ms(5);
    561c:	4b26      	ldr	r3, [pc, #152]	; (56b8 <grid_port_process_outbound_usb+0x2ec>)
    561e:	2005      	movs	r0, #5
    5620:	4798      	blx	r3
    5622:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5624:	2302      	movs	r3, #2
    5626:	4632      	mov	r2, r6
    5628:	4629      	mov	r1, r5
    562a:	a805      	add	r0, sp, #20
    562c:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    562e:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5630:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    5632:	2302      	movs	r3, #2
    5634:	b2d2      	uxtb	r2, r2
    5636:	4629      	mov	r1, r5
    5638:	a805      	add	r0, sp, #20
    563a:	47a0      	blx	r4
    563c:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    563e:	28ff      	cmp	r0, #255	; 0xff
    5640:	d00d      	beq.n	565e <grid_port_process_outbound_usb+0x292>
                        key.ispressed = 0;
    5642:	2200      	movs	r2, #0
    5644:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    5648:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    564a:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    564c:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5650:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    5654:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    5656:	e893 0003 	ldmia.w	r3, {r0, r1}
    565a:	4b16      	ldr	r3, [pc, #88]	; (56b4 <grid_port_process_outbound_usb+0x2e8>)
    565c:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    565e:	3604      	adds	r6, #4
    5660:	b2f6      	uxtb	r6, r6
    5662:	2e1d      	cmp	r6, #29
    5664:	d1de      	bne.n	5624 <grid_port_process_outbound_usb+0x258>
    5666:	e717      	b.n	5498 <grid_port_process_outbound_usb+0xcc>
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5668:	a805      	add	r0, sp, #20
    566a:	47b0      	blx	r6
	for (uint32_t i=0; i<packet_length; i++){
    566c:	3401      	adds	r4, #1
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    566e:	f80b 0b01 	strb.w	r0, [fp], #1
	for (uint32_t i=0; i<packet_length; i++){
    5672:	e6f1      	b.n	5458 <grid_port_process_outbound_usb+0x8c>
    5674:	00004f05 	.word	0x00004f05
    5678:	000085c5 	.word	0x000085c5
    567c:	00004f5b 	.word	0x00004f5b
    5680:	00004fc3 	.word	0x00004fc3
    5684:	00004fed 	.word	0x00004fed
    5688:	0000858d 	.word	0x0000858d
    568c:	00008481 	.word	0x00008481
    5690:	000084c1 	.word	0x000084c1
    5694:	00008521 	.word	0x00008521
    5698:	000086bb 	.word	0x000086bb
    569c:	0000bc59 	.word	0x0000bc59
    56a0:	20007a24 	.word	0x20007a24
    56a4:	0000af21 	.word	0x0000af21
    56a8:	0000af49 	.word	0x0000af49
    56ac:	0000ad59 	.word	0x0000ad59
    56b0:	20008c80 	.word	0x20008c80
    56b4:	0000b031 	.word	0x0000b031
    56b8:	0000dc95 	.word	0x0000dc95
    56bc:	0000866d 	.word	0x0000866d

000056c0 <grid_port_process_outbound_ui>:

uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    56c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    56c4:	ed2d 8b02 	vpush	{d8}
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    56c8:	f500 541c 	add.w	r4, r0, #9984	; 0x2700
    56cc:	343c      	adds	r4, #60	; 0x3c
uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    56ce:	f5ad 7d7b 	sub.w	sp, sp, #1004	; 0x3ec
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    56d2:	4bb5      	ldr	r3, [pc, #724]	; (59a8 <grid_port_process_outbound_ui+0x2e8>)
    56d4:	4620      	mov	r0, r4
    56d6:	4798      	blx	r3
	
	if (!length){
    56d8:	2500      	movs	r5, #0
    56da:	9006      	str	r0, [sp, #24]
    56dc:	b928      	cbnz	r0, 56ea <grid_port_process_outbound_ui+0x2a>

		
	}
	
	
}
    56de:	f50d 7d7b 	add.w	sp, sp, #1004	; 0x3ec
    56e2:	ecbd 8b02 	vpop	{d8}
    56e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56ea:	4bb0      	ldr	r3, [pc, #704]	; (59ac <grid_port_process_outbound_ui+0x2ec>)
    56ec:	952f      	str	r5, [sp, #188]	; 0xbc
    56ee:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    56f2:	4629      	mov	r1, r5
    56f4:	a830      	add	r0, sp, #192	; 0xc0
    56f6:	4798      	blx	r3
		grid_buffer_read_init(&por->tx_buffer);
    56f8:	4bad      	ldr	r3, [pc, #692]	; (59b0 <grid_port_process_outbound_ui+0x2f0>)
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56fa:	4fae      	ldr	r7, [pc, #696]	; (59b4 <grid_port_process_outbound_ui+0x2f4>)
		grid_buffer_read_init(&por->tx_buffer);
    56fc:	4620      	mov	r0, r4
    56fe:	4798      	blx	r3
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    5700:	ae2f      	add	r6, sp, #188	; 0xbc
		for (uint16_t i = 0; i<length; i++){
    5702:	9a06      	ldr	r2, [sp, #24]
    5704:	b2ab      	uxth	r3, r5
    5706:	429a      	cmp	r2, r3
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5708:	4620      	mov	r0, r4
		for (uint16_t i = 0; i<length; i++){
    570a:	d839      	bhi.n	5780 <grid_port_process_outbound_ui+0xc0>
		grid_buffer_read_acknowledge(&por->tx_buffer);
    570c:	4baa      	ldr	r3, [pc, #680]	; (59b8 <grid_port_process_outbound_ui+0x2f8>)
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    570e:	4fab      	ldr	r7, [pc, #684]	; (59bc <grid_port_process_outbound_ui+0x2fc>)
		grid_buffer_read_acknowledge(&por->tx_buffer);
    5710:	4798      	blx	r3
		uint8_t error=0;
    5712:	2500      	movs	r5, #0
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    5714:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    5718:	2202      	movs	r2, #2
    571a:	2106      	movs	r1, #6
    571c:	4630      	mov	r0, r6
		uint8_t error=0;
    571e:	f88d 5026 	strb.w	r5, [sp, #38]	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    5722:	47b8      	blx	r7
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    5724:	f10d 0326 	add.w	r3, sp, #38	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    5728:	fa5f fb80 	uxtb.w	fp, r0
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    572c:	2202      	movs	r2, #2
    572e:	2108      	movs	r1, #8
    5730:	4630      	mov	r0, r6
    5732:	47b8      	blx	r7
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    5734:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    5738:	b2c0      	uxtb	r0, r0
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    573a:	d125      	bne.n	5788 <grid_port_process_outbound_ui+0xc8>
			position_is_me = 1;
    573c:	f1a0 027f 	sub.w	r2, r0, #127	; 0x7f
    5740:	f1d2 0b00 	rsbs	fp, r2, #0
    5744:	eb4b 0b02 	adc.w	fp, fp, r2
		uint8_t position_is_local = 0;
    5748:	462c      	mov	r4, r5
		uint8_t position_is_global = 0;
    574a:	9502      	str	r5, [sp, #8]
		uint8_t error_flag = 0;	
    574c:	2300      	movs	r3, #0
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    574e:	4d9c      	ldr	r5, [pc, #624]	; (59c0 <grid_port_process_outbound_ui+0x300>)
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5750:	f8df a298 	ldr.w	sl, [pc, #664]	; 59ec <grid_port_process_outbound_ui+0x32c>
		uint8_t error_flag = 0;	
    5754:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5758:	9303      	str	r3, [sp, #12]
		uint8_t current_start		= 0;
    575a:	4698      	mov	r8, r3
			if (message[i] == GRID_CONST_STX){
    575c:	9b03      	ldr	r3, [sp, #12]
    575e:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
    5762:	f813 1009 	ldrb.w	r1, [r3, r9]
    5766:	2902      	cmp	r1, #2
    5768:	d120      	bne.n	57ac <grid_port_process_outbound_ui+0xec>
				current_start = i;
    576a:	f89d 800c 	ldrb.w	r8, [sp, #12]
		for (uint16_t i=0; i<length; i++){
    576e:	9b03      	ldr	r3, [sp, #12]
    5770:	9a06      	ldr	r2, [sp, #24]
    5772:	3301      	adds	r3, #1
    5774:	9303      	str	r3, [sp, #12]
    5776:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    577a:	429a      	cmp	r2, r3
    577c:	d8ee      	bhi.n	575c <grid_port_process_outbound_ui+0x9c>
    577e:	e7ae      	b.n	56de <grid_port_process_outbound_ui+0x1e>
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5780:	47b8      	blx	r7
    5782:	5570      	strb	r0, [r6, r5]
		for (uint16_t i = 0; i<length; i++){
    5784:	3501      	adds	r5, #1
    5786:	e7bc      	b.n	5702 <grid_port_process_outbound_ui+0x42>
		else if (dx == GRID_SYS_GLOBAL_POSITION && dy==GRID_SYS_GLOBAL_POSITION){
    5788:	f1bb 0f00 	cmp.w	fp, #0
    578c:	d105      	bne.n	579a <grid_port_process_outbound_ui+0xda>
		uint8_t position_is_global = 0;
    578e:	fab0 f380 	clz	r3, r0
    5792:	095b      	lsrs	r3, r3, #5
    5794:	9302      	str	r3, [sp, #8]
		uint8_t position_is_local = 0;
    5796:	465c      	mov	r4, fp
    5798:	e7d8      	b.n	574c <grid_port_process_outbound_ui+0x8c>
		else if (dx == GRID_SYS_LOCAL_POSITION && dy==GRID_SYS_LOCAL_POSITION){
    579a:	ea0b 0000 	and.w	r0, fp, r0
    579e:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    57a2:	425c      	negs	r4, r3
    57a4:	415c      	adcs	r4, r3
		uint8_t position_is_global = 0;
    57a6:	46ab      	mov	fp, r5
		uint8_t position_is_me = 0;
    57a8:	9502      	str	r5, [sp, #8]
    57aa:	e7cf      	b.n	574c <grid_port_process_outbound_ui+0x8c>
			else if (message[i] == GRID_CONST_ETX && current_start!=0){
    57ac:	2903      	cmp	r1, #3
    57ae:	d1de      	bne.n	576e <grid_port_process_outbound_ui+0xae>
    57b0:	f1b8 0f00 	cmp.w	r8, #0
    57b4:	d102      	bne.n	57bc <grid_port_process_outbound_ui+0xfc>
				current_start = 0;
    57b6:	f04f 0800 	mov.w	r8, #0
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    57ba:	e7d8      	b.n	576e <grid_port_process_outbound_ui+0xae>
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    57bc:	f108 0001 	add.w	r0, r8, #1
    57c0:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57c4:	4448      	add	r0, r9
    57c6:	47a8      	blx	r5
    57c8:	b2c6      	uxtb	r6, r0
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    57ca:	f108 0004 	add.w	r0, r8, #4
    57ce:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57d2:	2101      	movs	r1, #1
    57d4:	4448      	add	r0, r9
    57d6:	47a8      	blx	r5
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    57d8:	2e30      	cmp	r6, #48	; 0x30
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    57da:	b2c7      	uxtb	r7, r0
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    57dc:	d126      	bne.n	582c <grid_port_process_outbound_ui+0x16c>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57de:	f108 0005 	add.w	r0, r8, #5
    57e2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57e6:	2102      	movs	r1, #2
    57e8:	4448      	add	r0, r9
    57ea:	47a8      	blx	r5
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57ec:	2f0e      	cmp	r7, #14
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57ee:	4606      	mov	r6, r0
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57f0:	d10e      	bne.n	5810 <grid_port_process_outbound_ui+0x150>
						if (grid_sys_get_bank_valid(&grid_sys_state) == 0){
    57f2:	4874      	ldr	r0, [pc, #464]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    57f4:	4b74      	ldr	r3, [pc, #464]	; (59c8 <grid_port_process_outbound_ui+0x308>)
    57f6:	4798      	blx	r3
    57f8:	4602      	mov	r2, r0
    57fa:	b920      	cbnz	r0, 5806 <grid_port_process_outbound_ui+0x146>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
    57fc:	4601      	mov	r1, r0
    57fe:	4f73      	ldr	r7, [pc, #460]	; (59cc <grid_port_process_outbound_ui+0x30c>)
    5800:	4873      	ldr	r0, [pc, #460]	; (59d0 <grid_port_process_outbound_ui+0x310>)
    5802:	230c      	movs	r3, #12
    5804:	47b8      	blx	r7
						grid_sys_set_bank(&grid_sys_state, banknumber);
    5806:	486f      	ldr	r0, [pc, #444]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5808:	b2f1      	uxtb	r1, r6
								grid_sys_set_bank(&grid_sys_state, banknumber);
    580a:	4b72      	ldr	r3, [pc, #456]	; (59d4 <grid_port_process_outbound_ui+0x314>)
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    580c:	4798      	blx	r3
    580e:	e7d2      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
					else if (msg_instr == GRID_INSTR_FETCH_code){ //GET BANK
    5810:	2f0f      	cmp	r7, #15
    5812:	d1d0      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_valid(&grid_sys_state) != 0){
    5814:	486b      	ldr	r0, [pc, #428]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5816:	4b6c      	ldr	r3, [pc, #432]	; (59c8 <grid_port_process_outbound_ui+0x308>)
    5818:	4798      	blx	r3
    581a:	2800      	cmp	r0, #0
    581c:	d0cb      	beq.n	57b6 <grid_port_process_outbound_ui+0xf6>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
    581e:	2200      	movs	r2, #0
    5820:	486b      	ldr	r0, [pc, #428]	; (59d0 <grid_port_process_outbound_ui+0x310>)
    5822:	4e6a      	ldr	r6, [pc, #424]	; (59cc <grid_port_process_outbound_ui+0x30c>)
    5824:	2309      	movs	r3, #9
    5826:	4611      	mov	r1, r2
    5828:	47b0      	blx	r6
    582a:	e7c4      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_BANKENABLED_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    582c:	2e31      	cmp	r6, #49	; 0x31
    582e:	d140      	bne.n	58b2 <grid_port_process_outbound_ui+0x1f2>
    5830:	2f0e      	cmp	r7, #14
    5832:	d1c0      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
    5834:	9b02      	ldr	r3, [sp, #8]
    5836:	ea4b 0303 	orr.w	r3, fp, r3
    583a:	4323      	orrs	r3, r4
    583c:	d0bb      	beq.n	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_BANKNUMBER_offset], GRID_CLASS_BANKENABLED_BANKNUMBER_length, &error_flag);
    583e:	f108 0005 	add.w	r0, r8, #5
    5842:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5846:	2102      	movs	r1, #2
    5848:	4448      	add	r0, r9
    584a:	47a8      	blx	r5
    584c:	b2c6      	uxtb	r6, r0
					uint8_t isenabled  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_ISENABLED_offset], GRID_CLASS_BANKENABLED_ISENABLED_length, &error_flag);
    584e:	f108 0007 	add.w	r0, r8, #7
    5852:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5856:	2102      	movs	r1, #2
    5858:	4448      	add	r0, r9
    585a:	47a8      	blx	r5
    585c:	fa5f f880 	uxtb.w	r8, r0
					if (isenabled == 1){
    5860:	f1b8 0f01 	cmp.w	r8, #1
    5864:	d110      	bne.n	5888 <grid_port_process_outbound_ui+0x1c8>
						grid_sys_bank_enable(&grid_sys_state, banknumber);
    5866:	4f57      	ldr	r7, [pc, #348]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5868:	4b5b      	ldr	r3, [pc, #364]	; (59d8 <grid_port_process_outbound_ui+0x318>)
    586a:	4631      	mov	r1, r6
    586c:	4638      	mov	r0, r7
    586e:	4798      	blx	r3
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5870:	4b5a      	ldr	r3, [pc, #360]	; (59dc <grid_port_process_outbound_ui+0x31c>)
    5872:	4638      	mov	r0, r7
    5874:	4798      	blx	r3
    5876:	42b0      	cmp	r0, r6
    5878:	d19d      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
							if (grid_sys_state.bank_activebank_valid == 1){
    587a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    587e:	2b01      	cmp	r3, #1
    5880:	d199      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
								grid_sys_set_bank(&grid_sys_state, banknumber);
    5882:	4631      	mov	r1, r6
    5884:	4638      	mov	r0, r7
    5886:	e7c0      	b.n	580a <grid_port_process_outbound_ui+0x14a>
					}else if (isenabled == 0){	
    5888:	f1b8 0f00 	cmp.w	r8, #0
    588c:	d193      	bne.n	57b6 <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    588e:	484d      	ldr	r0, [pc, #308]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5890:	4b52      	ldr	r3, [pc, #328]	; (59dc <grid_port_process_outbound_ui+0x31c>)
    5892:	4798      	blx	r3
    5894:	42b0      	cmp	r0, r6
    5896:	d107      	bne.n	58a8 <grid_port_process_outbound_ui+0x1e8>
							if (grid_sys_state.bank_activebank_valid == 1){
    5898:	484a      	ldr	r0, [pc, #296]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    589a:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    589e:	2b01      	cmp	r3, #1
    58a0:	d102      	bne.n	58a8 <grid_port_process_outbound_ui+0x1e8>
								grid_sys_set_bank(&grid_sys_state, 255);
    58a2:	4b4c      	ldr	r3, [pc, #304]	; (59d4 <grid_port_process_outbound_ui+0x314>)
    58a4:	21ff      	movs	r1, #255	; 0xff
    58a6:	4798      	blx	r3
						grid_sys_bank_disable(&grid_sys_state, banknumber);
    58a8:	4b4d      	ldr	r3, [pc, #308]	; (59e0 <grid_port_process_outbound_ui+0x320>)
    58aa:	4846      	ldr	r0, [pc, #280]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    58ac:	4631      	mov	r1, r6
    58ae:	4798      	blx	r3
    58b0:	e75d      	b.n	576e <grid_port_process_outbound_ui+0xae>
				else if (msg_class == GRID_CLASS_BANKCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    58b2:	2e32      	cmp	r6, #50	; 0x32
    58b4:	d147      	bne.n	5946 <grid_port_process_outbound_ui+0x286>
    58b6:	2f0e      	cmp	r7, #14
    58b8:	f47f af7d 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    58bc:	9b02      	ldr	r3, [sp, #8]
    58be:	ea4b 0303 	orr.w	r3, fp, r3
    58c2:	4323      	orrs	r3, r4
    58c4:	f43f af77 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    58c8:	f108 0005 	add.w	r0, r8, #5
    58cc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58d0:	2102      	movs	r1, #2
    58d2:	4448      	add	r0, r9
    58d4:	47a8      	blx	r5
    58d6:	b2c3      	uxtb	r3, r0
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58d8:	f108 0007 	add.w	r0, r8, #7
    58dc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58e0:	2102      	movs	r1, #2
    58e2:	4448      	add	r0, r9
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    58e4:	ee08 3a10 	vmov	s16, r3
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58e8:	47a8      	blx	r5
    58ea:	4606      	mov	r6, r0
					uint8_t green	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_GRE_offset], GRID_CLASS_BANKCOLOR_GRE_length, &error_flag);
    58ec:	f108 0009 	add.w	r0, r8, #9
    58f0:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58f4:	2102      	movs	r1, #2
    58f6:	4448      	add	r0, r9
    58f8:	47a8      	blx	r5
    58fa:	4607      	mov	r7, r0
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58fc:	f108 000b 	add.w	r0, r8, #11
    5900:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5904:	2102      	movs	r1, #2
    5906:	4448      	add	r0, r9
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    5908:	0436      	lsls	r6, r6, #16
    590a:	023f      	lsls	r7, r7, #8
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    590c:	47a8      	blx	r5
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    590e:	b2bf      	uxth	r7, r7
    5910:	f406 067f 	and.w	r6, r6, #16711680	; 0xff0000
    5914:	433e      	orrs	r6, r7
    5916:	4f2b      	ldr	r7, [pc, #172]	; (59c4 <grid_port_process_outbound_ui+0x304>)
    5918:	4b32      	ldr	r3, [pc, #200]	; (59e4 <grid_port_process_outbound_ui+0x324>)
    591a:	fa56 f280 	uxtab	r2, r6, r0
    591e:	ee18 1a10 	vmov	r1, s16
    5922:	4638      	mov	r0, r7
    5924:	4798      	blx	r3
					if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5926:	4b2d      	ldr	r3, [pc, #180]	; (59dc <grid_port_process_outbound_ui+0x31c>)
    5928:	4638      	mov	r0, r7
    592a:	4798      	blx	r3
    592c:	ee18 3a10 	vmov	r3, s16
    5930:	4298      	cmp	r0, r3
    5932:	f47f af40 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_state.bank_activebank_valid == 1){
    5936:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    593a:	2b01      	cmp	r3, #1
    593c:	f47f af3b 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
							grid_sys_set_bank(&grid_sys_state, banknumber);
    5940:	ee18 1a10 	vmov	r1, s16
    5944:	e79e      	b.n	5884 <grid_port_process_outbound_ui+0x1c4>
				else if (msg_class == GRID_CLASS_LEDPHASE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    5946:	2e40      	cmp	r6, #64	; 0x40
    5948:	d154      	bne.n	59f4 <grid_port_process_outbound_ui+0x334>
    594a:	2f0e      	cmp	r7, #14
    594c:	f47f af33 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5950:	ea5b 0304 	orrs.w	r3, fp, r4
    5954:	f43f af2f 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_NUM_offset], GRID_CLASS_LEDPHASE_NUM_length, &error_flag);
    5958:	f108 0005 	add.w	r0, r8, #5
    595c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5960:	2102      	movs	r1, #2
    5962:	4448      	add	r0, r9
    5964:	47a8      	blx	r5
    5966:	b2c6      	uxtb	r6, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_LAY_offset], GRID_CLASS_LEDPHASE_LAY_length, &error_flag);
    5968:	f108 0007 	add.w	r0, r8, #7
    596c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5970:	2102      	movs	r1, #2
    5972:	4448      	add	r0, r9
    5974:	47a8      	blx	r5
    5976:	b2c7      	uxtb	r7, r0
					uint16_t led_pha  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_PHA_offset], GRID_CLASS_LEDPHASE_PHA_length, &error_flag);
    5978:	f108 0009 	add.w	r0, r8, #9
    597c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5980:	2102      	movs	r1, #2
    5982:	4448      	add	r0, r9
    5984:	47a8      	blx	r5
					if (led_pha*2 > 255){
    5986:	b283      	uxth	r3, r0
    5988:	005b      	lsls	r3, r3, #1
    598a:	2bff      	cmp	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    598c:	bfdc      	itt	le
    598e:	0040      	lslle	r0, r0, #1
    5990:	f000 03fe 	andle.w	r3, r0, #254	; 0xfe
    5994:	f8df 8058 	ldr.w	r8, [pc, #88]	; 59f0 <grid_port_process_outbound_ui+0x330>
    5998:	4813      	ldr	r0, [pc, #76]	; (59e8 <grid_port_process_outbound_ui+0x328>)
						grid_led_set_phase(&grid_led_state, led_num, led_lay, 255);
    599a:	bfc8      	it	gt
    599c:	23ff      	movgt	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    599e:	463a      	mov	r2, r7
    59a0:	4631      	mov	r1, r6
    59a2:	47c0      	blx	r8
    59a4:	e707      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
    59a6:	bf00      	nop
    59a8:	00004f05 	.word	0x00004f05
    59ac:	00014175 	.word	0x00014175
    59b0:	00004f5b 	.word	0x00004f5b
    59b4:	00004fc3 	.word	0x00004fc3
    59b8:	00004fed 	.word	0x00004fed
    59bc:	00009a15 	.word	0x00009a15
    59c0:	00009861 	.word	0x00009861
    59c4:	20007a24 	.word	0x20007a24
    59c8:	0000970b 	.word	0x0000970b
    59cc:	0000a191 	.word	0x0000a191
    59d0:	200151dc 	.word	0x200151dc
    59d4:	00009763 	.word	0x00009763
    59d8:	000096d9 	.word	0x000096d9
    59dc:	00009707 	.word	0x00009707
    59e0:	000096e5 	.word	0x000096e5
    59e4:	000096f1 	.word	0x000096f1
    59e8:	20015254 	.word	0x20015254
    59ec:	20007a18 	.word	0x20007a18
    59f0:	00006d91 	.word	0x00006d91
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    59f4:	2e41      	cmp	r6, #65	; 0x41
    59f6:	d13a      	bne.n	5a6e <grid_port_process_outbound_ui+0x3ae>
    59f8:	2f0e      	cmp	r7, #14
    59fa:	f47f aedc 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    59fe:	ea5b 0304 	orrs.w	r3, fp, r4
    5a02:	f43f aed8 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_NUM_offset], GRID_CLASS_LEDCOLOR_NUM_length, &error_flag);
    5a06:	f108 0005 	add.w	r0, r8, #5
    5a0a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a0e:	2102      	movs	r1, #2
    5a10:	4448      	add	r0, r9
    5a12:	47a8      	blx	r5
    5a14:	4607      	mov	r7, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_LAY_offset], GRID_CLASS_LEDCOLOR_LAY_length, &error_flag);
    5a16:	f108 0007 	add.w	r0, r8, #7
    5a1a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a1e:	2102      	movs	r1, #2
    5a20:	4448      	add	r0, r9
    5a22:	47a8      	blx	r5
    5a24:	9004      	str	r0, [sp, #16]
					uint8_t led_red	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_RED_offset], GRID_CLASS_LEDCOLOR_RED_length, &error_flag);
    5a26:	f108 0009 	add.w	r0, r8, #9
    5a2a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a2e:	2102      	movs	r1, #2
    5a30:	4448      	add	r0, r9
    5a32:	47a8      	blx	r5
    5a34:	9005      	str	r0, [sp, #20]
					uint8_t led_gre	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_GRE_offset], GRID_CLASS_LEDCOLOR_GRE_length, &error_flag);
    5a36:	f108 000b 	add.w	r0, r8, #11
    5a3a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a3e:	2102      	movs	r1, #2
    5a40:	4448      	add	r0, r9
    5a42:	47a8      	blx	r5
    5a44:	4606      	mov	r6, r0
					uint8_t led_blu	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_BLU_offset], GRID_CLASS_LEDCOLOR_BLU_length, &error_flag);
    5a46:	f108 000d 	add.w	r0, r8, #13
    5a4a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a4e:	2102      	movs	r1, #2
    5a50:	4448      	add	r0, r9
    5a52:	47a8      	blx	r5
					grid_led_set_color(&grid_led_state, led_num, led_lay, led_red, led_gre, led_blu);
    5a54:	9b05      	ldr	r3, [sp, #20]
    5a56:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5a5a:	b2c0      	uxtb	r0, r0
    5a5c:	b2f6      	uxtb	r6, r6
    5a5e:	9001      	str	r0, [sp, #4]
    5a60:	9600      	str	r6, [sp, #0]
    5a62:	48a9      	ldr	r0, [pc, #676]	; (5d08 <grid_port_process_outbound_ui+0x648>)
    5a64:	4ea9      	ldr	r6, [pc, #676]	; (5d0c <grid_port_process_outbound_ui+0x64c>)
    5a66:	b2db      	uxtb	r3, r3
    5a68:	b2f9      	uxtb	r1, r7
    5a6a:	47b0      	blx	r6
    5a6c:	e6a3      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if(msg_class == GRID_CLASS_SERIALNUMBER_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5a6e:	2e11      	cmp	r6, #17
    5a70:	d15d      	bne.n	5b2e <grid_port_process_outbound_ui+0x46e>
    5a72:	2f0f      	cmp	r7, #15
    5a74:	f47f ae9f 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5a78:	9b02      	ldr	r3, [sp, #8]
    5a7a:	ea5b 0303 	orrs.w	r3, fp, r3
    5a7e:	f43f ae9a 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint32_t uniqueid[4] = {0};
    5a82:	2210      	movs	r2, #16
    5a84:	2100      	movs	r1, #0
    5a86:	4fa2      	ldr	r7, [pc, #648]	; (5d10 <grid_port_process_outbound_ui+0x650>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a88:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 5d38 <grid_port_process_outbound_ui+0x678>
					uint32_t uniqueid[4] = {0};
    5a8c:	a80a      	add	r0, sp, #40	; 0x28
    5a8e:	47b8      	blx	r7
					grid_sys_get_id(uniqueid);					
    5a90:	4ba0      	ldr	r3, [pc, #640]	; (5d14 <grid_port_process_outbound_ui+0x654>)
    5a92:	a80a      	add	r0, sp, #40	; 0x28
    5a94:	4798      	blx	r3
					grid_msg_init(&response);
    5a96:	4ba0      	ldr	r3, [pc, #640]	; (5d18 <grid_port_process_outbound_ui+0x658>)
    5a98:	a893      	add	r0, sp, #588	; 0x24c
    5a9a:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a9c:	227f      	movs	r2, #127	; 0x7f
    5a9e:	2300      	movs	r3, #0
    5aa0:	4611      	mov	r1, r2
    5aa2:	a893      	add	r0, sp, #588	; 0x24c
    5aa4:	47c0      	blx	r8
					uint8_t response_payload[50] = {0};
    5aa6:	f04f 0800 	mov.w	r8, #0
    5aaa:	222e      	movs	r2, #46	; 0x2e
    5aac:	4641      	mov	r1, r8
    5aae:	a80f      	add	r0, sp, #60	; 0x3c
    5ab0:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5ab4:	47b8      	blx	r7
					snprintf(response_payload, 49, GRID_CLASS_SERIALNUMBER_frame);
    5ab6:	2303      	movs	r3, #3
    5ab8:	e9cd 6300 	strd	r6, r3, [sp]
    5abc:	4a97      	ldr	r2, [pc, #604]	; (5d1c <grid_port_process_outbound_ui+0x65c>)
    5abe:	4e98      	ldr	r6, [pc, #608]	; (5d20 <grid_port_process_outbound_ui+0x660>)
    5ac0:	2131      	movs	r1, #49	; 0x31
    5ac2:	2302      	movs	r3, #2
    5ac4:	a80e      	add	r0, sp, #56	; 0x38
    5ac6:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5ac8:	4b96      	ldr	r3, [pc, #600]	; (5d24 <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5aca:	4e97      	ldr	r6, [pc, #604]	; (5d28 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5acc:	a80e      	add	r0, sp, #56	; 0x38
    5ace:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5ad0:	270d      	movs	r7, #13
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5ad2:	4602      	mov	r2, r0
    5ad4:	4b95      	ldr	r3, [pc, #596]	; (5d2c <grid_port_process_outbound_ui+0x66c>)
    5ad6:	a90e      	add	r1, sp, #56	; 0x38
    5ad8:	a893      	add	r0, sp, #588	; 0x24c
    5ada:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5adc:	2301      	movs	r3, #1
    5ade:	2204      	movs	r2, #4
    5ae0:	4641      	mov	r1, r8
    5ae2:	a893      	add	r0, sp, #588	; 0x24c
    5ae4:	9700      	str	r7, [sp, #0]
    5ae6:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD0_offset, GRID_CLASS_SERIALNUMBER_WORD0_length, uniqueid[0]);
    5ae8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5aea:	9300      	str	r3, [sp, #0]
    5aec:	2205      	movs	r2, #5
    5aee:	2308      	movs	r3, #8
    5af0:	4641      	mov	r1, r8
    5af2:	a893      	add	r0, sp, #588	; 0x24c
    5af4:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD1_offset, GRID_CLASS_SERIALNUMBER_WORD1_length, uniqueid[1]);
    5af6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5af8:	9300      	str	r3, [sp, #0]
    5afa:	463a      	mov	r2, r7
    5afc:	2308      	movs	r3, #8
    5afe:	4641      	mov	r1, r8
    5b00:	a893      	add	r0, sp, #588	; 0x24c
    5b02:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD2_offset, GRID_CLASS_SERIALNUMBER_WORD2_length, uniqueid[2]);
    5b04:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5b06:	9300      	str	r3, [sp, #0]
    5b08:	2215      	movs	r2, #21
    5b0a:	2308      	movs	r3, #8
    5b0c:	4641      	mov	r1, r8
    5b0e:	a893      	add	r0, sp, #588	; 0x24c
    5b10:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD3_offset, GRID_CLASS_SERIALNUMBER_WORD3_length, uniqueid[3]);
    5b12:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5b14:	9300      	str	r3, [sp, #0]
    5b16:	221d      	movs	r2, #29
    5b18:	2308      	movs	r3, #8
    5b1a:	4641      	mov	r1, r8
    5b1c:	a893      	add	r0, sp, #588	; 0x24c
    5b1e:	47b0      	blx	r6
					grid_msg_packet_close(&response);
    5b20:	4b83      	ldr	r3, [pc, #524]	; (5d30 <grid_port_process_outbound_ui+0x670>)
    5b22:	a893      	add	r0, sp, #588	; 0x24c
    5b24:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    5b26:	4b83      	ldr	r3, [pc, #524]	; (5d34 <grid_port_process_outbound_ui+0x674>)
    5b28:	a893      	add	r0, sp, #588	; 0x24c
    5b2a:	4798      	blx	r3
				else if(msg_class == GRID_CLASS_UPTIME_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5b2c:	e61f      	b.n	576e <grid_port_process_outbound_ui+0xae>
    5b2e:	2e14      	cmp	r6, #20
    5b30:	d13f      	bne.n	5bb2 <grid_port_process_outbound_ui+0x4f2>
    5b32:	2f0f      	cmp	r7, #15
    5b34:	f47f ae3f 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5b38:	9b02      	ldr	r3, [sp, #8]
    5b3a:	ea5b 0303 	orrs.w	r3, fp, r3
    5b3e:	f43f ae3a 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5b42:	4b75      	ldr	r3, [pc, #468]	; (5d18 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b44:	4f7c      	ldr	r7, [pc, #496]	; (5d38 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5b46:	a893      	add	r0, sp, #588	; 0x24c
    5b48:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b4a:	227f      	movs	r2, #127	; 0x7f
					uint8_t response_payload[50] = {0};
    5b4c:	f04f 0800 	mov.w	r8, #0
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b50:	4611      	mov	r1, r2
    5b52:	2300      	movs	r3, #0
    5b54:	a893      	add	r0, sp, #588	; 0x24c
    5b56:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b58:	4b6d      	ldr	r3, [pc, #436]	; (5d10 <grid_port_process_outbound_ui+0x650>)
    5b5a:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5b5e:	222e      	movs	r2, #46	; 0x2e
    5b60:	4641      	mov	r1, r8
    5b62:	a80f      	add	r0, sp, #60	; 0x3c
    5b64:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b66:	2303      	movs	r3, #3
    5b68:	e9cd 6300 	strd	r6, r3, [sp]
    5b6c:	4a73      	ldr	r2, [pc, #460]	; (5d3c <grid_port_process_outbound_ui+0x67c>)
    5b6e:	4e6c      	ldr	r6, [pc, #432]	; (5d20 <grid_port_process_outbound_ui+0x660>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b70:	4f6d      	ldr	r7, [pc, #436]	; (5d28 <grid_port_process_outbound_ui+0x668>)
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b72:	2131      	movs	r1, #49	; 0x31
    5b74:	2302      	movs	r3, #2
    5b76:	a80e      	add	r0, sp, #56	; 0x38
    5b78:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b7a:	4b6a      	ldr	r3, [pc, #424]	; (5d24 <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b7c:	4e70      	ldr	r6, [pc, #448]	; (5d40 <grid_port_process_outbound_ui+0x680>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b7e:	a80e      	add	r0, sp, #56	; 0x38
    5b80:	4798      	blx	r3
    5b82:	4b6a      	ldr	r3, [pc, #424]	; (5d2c <grid_port_process_outbound_ui+0x66c>)
    5b84:	4602      	mov	r2, r0
    5b86:	a90e      	add	r1, sp, #56	; 0x38
    5b88:	a893      	add	r0, sp, #588	; 0x24c
    5b8a:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b8c:	230d      	movs	r3, #13
    5b8e:	9300      	str	r3, [sp, #0]
    5b90:	2204      	movs	r2, #4
    5b92:	2301      	movs	r3, #1
    5b94:	4641      	mov	r1, r8
    5b96:	a893      	add	r0, sp, #588	; 0x24c
    5b98:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b9a:	6833      	ldr	r3, [r6, #0]
    5b9c:	9300      	str	r3, [sp, #0]
    5b9e:	2205      	movs	r2, #5
    5ba0:	2308      	movs	r3, #8
    5ba2:	4641      	mov	r1, r8
    5ba4:	a893      	add	r0, sp, #588	; 0x24c
    5ba6:	47b8      	blx	r7
					uint32_t milliseconds = grid_sys_state.uptime/RTC1MS%1000;
    5ba8:	6833      	ldr	r3, [r6, #0]
					uint32_t seconds =		grid_sys_state.uptime/RTC1MS/1000%60;
    5baa:	6833      	ldr	r3, [r6, #0]
					uint32_t minutes =		grid_sys_state.uptime/RTC1MS/1000/60%60;
    5bac:	6833      	ldr	r3, [r6, #0]
					uint32_t hours =		grid_sys_state.uptime/RTC1MS/1000/60/60%60;
    5bae:	6833      	ldr	r3, [r6, #0]
    5bb0:	e7b6      	b.n	5b20 <grid_port_process_outbound_ui+0x460>
				else if(msg_class == GRID_CLASS_RESETCAUSE_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5bb2:	2e12      	cmp	r6, #18
    5bb4:	d137      	bne.n	5c26 <grid_port_process_outbound_ui+0x566>
    5bb6:	2f0f      	cmp	r7, #15
    5bb8:	f47f adfd 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5bbc:	9b02      	ldr	r3, [sp, #8]
    5bbe:	ea5b 0303 	orrs.w	r3, fp, r3
    5bc2:	f43f adf8 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5bc6:	4b54      	ldr	r3, [pc, #336]	; (5d18 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5bc8:	4f5b      	ldr	r7, [pc, #364]	; (5d38 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5bca:	a893      	add	r0, sp, #588	; 0x24c
    5bcc:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5bce:	227f      	movs	r2, #127	; 0x7f
    5bd0:	4611      	mov	r1, r2
    5bd2:	2300      	movs	r3, #0
    5bd4:	a893      	add	r0, sp, #588	; 0x24c
    5bd6:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5bd8:	2700      	movs	r7, #0
    5bda:	4b4d      	ldr	r3, [pc, #308]	; (5d10 <grid_port_process_outbound_ui+0x650>)
    5bdc:	970e      	str	r7, [sp, #56]	; 0x38
    5bde:	222e      	movs	r2, #46	; 0x2e
    5be0:	4639      	mov	r1, r7
    5be2:	a80f      	add	r0, sp, #60	; 0x3c
    5be4:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_RESETCAUSE_frame);
    5be6:	2303      	movs	r3, #3
    5be8:	e9cd 6300 	strd	r6, r3, [sp]
    5bec:	4a55      	ldr	r2, [pc, #340]	; (5d44 <grid_port_process_outbound_ui+0x684>)
    5bee:	4e4c      	ldr	r6, [pc, #304]	; (5d20 <grid_port_process_outbound_ui+0x660>)
    5bf0:	2131      	movs	r1, #49	; 0x31
    5bf2:	2302      	movs	r3, #2
    5bf4:	a80e      	add	r0, sp, #56	; 0x38
    5bf6:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bf8:	4b4a      	ldr	r3, [pc, #296]	; (5d24 <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bfa:	4e4b      	ldr	r6, [pc, #300]	; (5d28 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bfc:	a80e      	add	r0, sp, #56	; 0x38
    5bfe:	4798      	blx	r3
    5c00:	4b4a      	ldr	r3, [pc, #296]	; (5d2c <grid_port_process_outbound_ui+0x66c>)
    5c02:	4602      	mov	r2, r0
    5c04:	a90e      	add	r1, sp, #56	; 0x38
    5c06:	a893      	add	r0, sp, #588	; 0x24c
    5c08:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5c0a:	230d      	movs	r3, #13
    5c0c:	9300      	str	r3, [sp, #0]
    5c0e:	2204      	movs	r2, #4
    5c10:	2301      	movs	r3, #1
    5c12:	4639      	mov	r1, r7
    5c14:	a893      	add	r0, sp, #588	; 0x24c
    5c16:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_RESETCAUSE_CAUSE_offset, GRID_CLASS_RESETCAUSE_CAUSE_length,grid_sys_state.reset_cause);
    5c18:	4b49      	ldr	r3, [pc, #292]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c1a:	791b      	ldrb	r3, [r3, #4]
    5c1c:	9300      	str	r3, [sp, #0]
    5c1e:	2205      	movs	r2, #5
    5c20:	2302      	movs	r3, #2
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5c22:	4639      	mov	r1, r7
    5c24:	e26e      	b.n	6104 <grid_port_process_outbound_ui+0xa44>
				else if(msg_class == GRID_CLASS_RESET_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me)){
    5c26:	2e13      	cmp	r6, #19
    5c28:	d113      	bne.n	5c52 <grid_port_process_outbound_ui+0x592>
    5c2a:	2f0e      	cmp	r7, #14
    5c2c:	f47f adc3 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5c30:	f1bb 0f00 	cmp.w	fp, #0
    5c34:	f43f adbf 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5c38:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5c3c:	4942      	ldr	r1, [pc, #264]	; (5d48 <grid_port_process_outbound_ui+0x688>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5c3e:	4b43      	ldr	r3, [pc, #268]	; (5d4c <grid_port_process_outbound_ui+0x68c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5c40:	68ca      	ldr	r2, [r1, #12]
    5c42:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5c46:	4313      	orrs	r3, r2
    5c48:	60cb      	str	r3, [r1, #12]
    5c4a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    5c4e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    5c50:	e7fd      	b.n	5c4e <grid_port_process_outbound_ui+0x58e>
				else if (msg_class == GRID_CLASS_GLOBALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c52:	2e61      	cmp	r6, #97	; 0x61
    5c54:	d10c      	bne.n	5c70 <grid_port_process_outbound_ui+0x5b0>
    5c56:	2f0e      	cmp	r7, #14
    5c58:	f47f adad 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5c5c:	9b02      	ldr	r3, [sp, #8]
    5c5e:	ea5b 0303 	orrs.w	r3, fp, r3
    5c62:	f43f ada8 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
    5c66:	493a      	ldr	r1, [pc, #232]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5c68:	4835      	ldr	r0, [pc, #212]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c6a:	4b3a      	ldr	r3, [pc, #232]	; (5d54 <grid_port_process_outbound_ui+0x694>)
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5c6c:	4798      	blx	r3
    5c6e:	e5a2      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c70:	2e60      	cmp	r6, #96	; 0x60
    5c72:	d117      	bne.n	5ca4 <grid_port_process_outbound_ui+0x5e4>
    5c74:	2f0e      	cmp	r7, #14
    5c76:	f47f ad9e 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5c7a:	9b02      	ldr	r3, [sp, #8]
    5c7c:	ea5b 0303 	orrs.w	r3, fp, r3
    5c80:	f43f ad99 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_store_configuration(&grid_sys_state, &grid_nvm_state);
    5c84:	4932      	ldr	r1, [pc, #200]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5c86:	482e      	ldr	r0, [pc, #184]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c88:	4b33      	ldr	r3, [pc, #204]	; (5d58 <grid_port_process_outbound_ui+0x698>)
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c8a:	4e34      	ldr	r6, [pc, #208]	; (5d5c <grid_port_process_outbound_ui+0x69c>)
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c8c:	4798      	blx	r3
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c8e:	2700      	movs	r7, #0
    5c90:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5c94:	e9cd 7300 	strd	r7, r3, [sp]
    5c98:	4829      	ldr	r0, [pc, #164]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5c9a:	463b      	mov	r3, r7
    5c9c:	22ff      	movs	r2, #255	; 0xff
    5c9e:	4639      	mov	r1, r7
    5ca0:	47b0      	blx	r6
    5ca2:	e588      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5ca4:	2e62      	cmp	r6, #98	; 0x62
    5ca6:	d10b      	bne.n	5cc0 <grid_port_process_outbound_ui+0x600>
    5ca8:	2f0e      	cmp	r7, #14
    5caa:	f47f ad84 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5cae:	9b02      	ldr	r3, [sp, #8]
    5cb0:	ea5b 0303 	orrs.w	r3, fp, r3
    5cb4:	f43f ad7f 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5cb8:	4925      	ldr	r1, [pc, #148]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5cba:	4b29      	ldr	r3, [pc, #164]	; (5d60 <grid_port_process_outbound_ui+0x6a0>)
    5cbc:	4650      	mov	r0, sl
    5cbe:	e7e4      	b.n	5c8a <grid_port_process_outbound_ui+0x5ca>
				else if (msg_class == GRID_CLASS_GLOBALRECALL_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5cc0:	2e63      	cmp	r6, #99	; 0x63
    5cc2:	d112      	bne.n	5cea <grid_port_process_outbound_ui+0x62a>
    5cc4:	2f0e      	cmp	r7, #14
    5cc6:	f47f ad76 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5cca:	9b02      	ldr	r3, [sp, #8]
    5ccc:	ea5b 0303 	orrs.w	r3, fp, r3
    5cd0:	f43f ad71 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_GLOBALRECALL_BANKNUMBER_offset], GRID_CLASS_GLOBALRECALL_BANKNUMBER_length	, &error_flag);
    5cd4:	f108 0005 	add.w	r0, r8, #5
    5cd8:	2102      	movs	r1, #2
    5cda:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5cde:	4448      	add	r0, r9
    5ce0:	47a8      	blx	r5
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    5ce2:	4b20      	ldr	r3, [pc, #128]	; (5d64 <grid_port_process_outbound_ui+0x6a4>)
    5ce4:	b2c1      	uxtb	r1, r0
    5ce6:	4816      	ldr	r0, [pc, #88]	; (5d40 <grid_port_process_outbound_ui+0x680>)
    5ce8:	e590      	b.n	580c <grid_port_process_outbound_ui+0x14c>
				else if (msg_class == GRID_CLASS_LOCALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5cea:	2e71      	cmp	r6, #113	; 0x71
    5cec:	d13e      	bne.n	5d6c <grid_port_process_outbound_ui+0x6ac>
    5cee:	2f0e      	cmp	r7, #14
    5cf0:	f47f ad61 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5cf4:	9b02      	ldr	r3, [sp, #8]
    5cf6:	ea5b 0303 	orrs.w	r3, fp, r3
    5cfa:	f43f ad5c 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);						
    5cfe:	4914      	ldr	r1, [pc, #80]	; (5d50 <grid_port_process_outbound_ui+0x690>)
    5d00:	4b19      	ldr	r3, [pc, #100]	; (5d68 <grid_port_process_outbound_ui+0x6a8>)
    5d02:	4650      	mov	r0, sl
    5d04:	e7b2      	b.n	5c6c <grid_port_process_outbound_ui+0x5ac>
    5d06:	bf00      	nop
    5d08:	20015254 	.word	0x20015254
    5d0c:	00006d21 	.word	0x00006d21
    5d10:	00014175 	.word	0x00014175
    5d14:	000098c1 	.word	0x000098c1
    5d18:	000085c5 	.word	0x000085c5
    5d1c:	00016728 	.word	0x00016728
    5d20:	00014709 	.word	0x00014709
    5d24:	00014c81 	.word	0x00014c81
    5d28:	000085a9 	.word	0x000085a9
    5d2c:	00008535 	.word	0x00008535
    5d30:	000086f1 	.word	0x000086f1
    5d34:	000087c5 	.word	0x000087c5
    5d38:	000085f9 	.word	0x000085f9
    5d3c:	00016752 	.word	0x00016752
    5d40:	20007a24 	.word	0x20007a24
    5d44:	00016764 	.word	0x00016764
    5d48:	e000ed00 	.word	0xe000ed00
    5d4c:	05fa0004 	.word	0x05fa0004
    5d50:	20008438 	.word	0x20008438
    5d54:	000090e5 	.word	0x000090e5
    5d58:	00008d91 	.word	0x00008d91
    5d5c:	00009813 	.word	0x00009813
    5d60:	000091dd 	.word	0x000091dd
    5d64:	00008f89 	.word	0x00008f89
    5d68:	00009af5 	.word	0x00009af5
				else if (msg_class == GRID_CLASS_LOCALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d6c:	2e70      	cmp	r6, #112	; 0x70
    5d6e:	d10b      	bne.n	5d88 <grid_port_process_outbound_ui+0x6c8>
    5d70:	2f0e      	cmp	r7, #14
    5d72:	f47f ad20 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5d76:	9b02      	ldr	r3, [sp, #8]
    5d78:	ea5b 0303 	orrs.w	r3, fp, r3
    5d7c:	f43f ad1b 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_store_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d80:	49b4      	ldr	r1, [pc, #720]	; (6054 <grid_port_process_outbound_ui+0x994>)
    5d82:	4bb5      	ldr	r3, [pc, #724]	; (6058 <grid_port_process_outbound_ui+0x998>)
    5d84:	4650      	mov	r0, sl
    5d86:	e771      	b.n	5c6c <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_LOCALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d88:	2e72      	cmp	r6, #114	; 0x72
    5d8a:	d10b      	bne.n	5da4 <grid_port_process_outbound_ui+0x6e4>
    5d8c:	2f0e      	cmp	r7, #14
    5d8e:	f47f ad12 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5d92:	9b02      	ldr	r3, [sp, #8]
    5d94:	ea5b 0303 	orrs.w	r3, fp, r3
    5d98:	f43f ad0d 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d9c:	49ad      	ldr	r1, [pc, #692]	; (6054 <grid_port_process_outbound_ui+0x994>)
    5d9e:	4baf      	ldr	r3, [pc, #700]	; (605c <grid_port_process_outbound_ui+0x99c>)
    5da0:	4650      	mov	r0, sl
    5da2:	e763      	b.n	5c6c <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5da4:	2e80      	cmp	r6, #128	; 0x80
    5da6:	f040 81b0 	bne.w	610a <grid_port_process_outbound_ui+0xa4a>
    5daa:	2f0f      	cmp	r7, #15
    5dac:	d122      	bne.n	5df4 <grid_port_process_outbound_ui+0x734>
    5dae:	9b02      	ldr	r3, [sp, #8]
    5db0:	ea5b 0303 	orrs.w	r3, fp, r3
    5db4:	f43f acff 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5db8:	f108 0005 	add.w	r0, r8, #5
    5dbc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dc0:	2102      	movs	r1, #2
    5dc2:	4448      	add	r0, r9
    5dc4:	47a8      	blx	r5
    5dc6:	4606      	mov	r6, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5dc8:	f108 0007 	add.w	r0, r8, #7
    5dcc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dd0:	2102      	movs	r1, #2
    5dd2:	4448      	add	r0, r9
    5dd4:	47a8      	blx	r5
    5dd6:	4607      	mov	r7, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5dd8:	f108 0009 	add.w	r0, r8, #9
    5ddc:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5de0:	2102      	movs	r1, #2
    5de2:	4448      	add	r0, r9
    5de4:	47a8      	blx	r5
					grid_ui_recall_event_configuration(&grid_ui_state, banknumber, elementnumber, eventtype);
    5de6:	b2f1      	uxtb	r1, r6
    5de8:	b2c3      	uxtb	r3, r0
    5dea:	4e9d      	ldr	r6, [pc, #628]	; (6060 <grid_port_process_outbound_ui+0x9a0>)
    5dec:	b2fa      	uxtb	r2, r7
    5dee:	4650      	mov	r0, sl
    5df0:	47b0      	blx	r6
    5df2:	e4e0      	b.n	57b6 <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    5df4:	2f0e      	cmp	r7, #14
    5df6:	f47f acde 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    5dfa:	f1bb 0f00 	cmp.w	fp, #0
    5dfe:	f040 80e0 	bne.w	5fc2 <grid_port_process_outbound_ui+0x902>
    5e02:	2c00      	cmp	r4, #0
    5e04:	f000 8150 	beq.w	60a8 <grid_port_process_outbound_ui+0x9e8>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5e08:	ab2f      	add	r3, sp, #188	; 0xbc
    5e0a:	f108 0005 	add.w	r0, r8, #5
    5e0e:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5e12:	2102      	movs	r1, #2
    5e14:	4418      	add	r0, r3
    5e16:	47a8      	blx	r5
    5e18:	b2c3      	uxtb	r3, r0
    5e1a:	9305      	str	r3, [sp, #20]
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5e1c:	f108 0007 	add.w	r0, r8, #7
    5e20:	ab2f      	add	r3, sp, #188	; 0xbc
    5e22:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5e26:	2102      	movs	r1, #2
    5e28:	4418      	add	r0, r3
    5e2a:	47a8      	blx	r5
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e2c:	ab2f      	add	r3, sp, #188	; 0xbc
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5e2e:	9007      	str	r0, [sp, #28]
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e30:	f108 0009 	add.w	r0, r8, #9
    5e34:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5e38:	2102      	movs	r1, #2
    5e3a:	4418      	add	r0, r3
    5e3c:	47a8      	blx	r5
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e3e:	2700      	movs	r7, #0
    5e40:	4b88      	ldr	r3, [pc, #544]	; (6064 <grid_port_process_outbound_ui+0x9a4>)
    5e42:	970e      	str	r7, [sp, #56]	; 0x38
    5e44:	227e      	movs	r2, #126	; 0x7e
    5e46:	4639      	mov	r1, r7
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e48:	fa5f f980 	uxtb.w	r9, r0
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e4c:	a80f      	add	r0, sp, #60	; 0x3c
    5e4e:	4798      	blx	r3
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e50:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5e54:	f108 000b 	add.w	r0, r8, #11
    5e58:	eba3 0308 	sub.w	r3, r3, r8
    5e5c:	aa2f      	add	r2, sp, #188	; 0xbc
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e5e:	ae0e      	add	r6, sp, #56	; 0x38
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e60:	3b0b      	subs	r3, #11
					for(uint32_t j = 0; j<actionstring_length; j++){
    5e62:	eb02 0800 	add.w	r8, r2, r0
    5e66:	4639      	mov	r1, r7
    5e68:	4299      	cmp	r1, r3
    5e6a:	f0c0 80ed 	bcc.w	6048 <grid_port_process_outbound_ui+0x988>
					grid_ui_event_register_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype, actionstring, actionstring_length);
    5e6e:	9905      	ldr	r1, [sp, #20]
    5e70:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e74:	f89d 801c 	ldrb.w	r8, [sp, #28]
    5e78:	4f7b      	ldr	r7, [pc, #492]	; (6068 <grid_port_process_outbound_ui+0x9a8>)
    5e7a:	0109      	lsls	r1, r1, #4
    5e7c:	9104      	str	r1, [sp, #16]
    5e7e:	9905      	ldr	r1, [sp, #20]
    5e80:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    5e84:	2664      	movs	r6, #100	; 0x64
    5e86:	68d0      	ldr	r0, [r2, #12]
    5e88:	fb06 f608 	mul.w	r6, r6, r8
    5e8c:	aa0e      	add	r2, sp, #56	; 0x38
    5e8e:	4649      	mov	r1, r9
    5e90:	4430      	add	r0, r6
    5e92:	47b8      	blx	r7
					if (banknumber == grid_sys_state.bank_activebank_number){
    5e94:	4b75      	ldr	r3, [pc, #468]	; (606c <grid_port_process_outbound_ui+0x9ac>)
    5e96:	9a05      	ldr	r2, [sp, #20]
    5e98:	7bdb      	ldrb	r3, [r3, #15]
    5e9a:	4293      	cmp	r3, r2
    5e9c:	d105      	bne.n	5eaa <grid_port_process_outbound_ui+0x7ea>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    5e9e:	9905      	ldr	r1, [sp, #20]
    5ea0:	4f73      	ldr	r7, [pc, #460]	; (6070 <grid_port_process_outbound_ui+0x9b0>)
    5ea2:	464b      	mov	r3, r9
    5ea4:	4642      	mov	r2, r8
    5ea6:	4650      	mov	r0, sl
    5ea8:	47b8      	blx	r7
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5eaa:	f8da 3004 	ldr.w	r3, [sl, #4]
    5eae:	9a04      	ldr	r2, [sp, #16]
    5eb0:	4413      	add	r3, r2
    5eb2:	4649      	mov	r1, r9
    5eb4:	68d8      	ldr	r0, [r3, #12]
    5eb6:	4b6f      	ldr	r3, [pc, #444]	; (6074 <grid_port_process_outbound_ui+0x9b4>)
    5eb8:	4430      	add	r0, r6
    5eba:	4798      	blx	r3
					if (event_index != 255){
    5ebc:	28ff      	cmp	r0, #255	; 0xff
    5ebe:	d03d      	beq.n	5f3c <grid_port_process_outbound_ui+0x87c>
						if (position_is_local){
    5ec0:	b304      	cbz	r4, 5f04 <grid_port_process_outbound_ui+0x844>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5ec2:	f8da 2004 	ldr.w	r2, [sl, #4]
    5ec6:	9904      	ldr	r1, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5ec8:	9f04      	ldr	r7, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5eca:	440a      	add	r2, r1
    5ecc:	23bc      	movs	r3, #188	; 0xbc
    5ece:	68d2      	ldr	r2, [r2, #12]
    5ed0:	4432      	add	r2, r6
    5ed2:	fb10 f303 	smulbb	r3, r0, r3
    5ed6:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5ed8:	441a      	add	r2, r3
    5eda:	2100      	movs	r1, #0
    5edc:	f882 10b8 	strb.w	r1, [r2, #184]	; 0xb8
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5ee0:	f8da 2004 	ldr.w	r2, [sl, #4]
    5ee4:	443a      	add	r2, r7
    5ee6:	68d2      	ldr	r2, [r2, #12]
    5ee8:	4432      	add	r2, r6
    5eea:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5eec:	441a      	add	r2, r3
    5eee:	f882 10b6 	strb.w	r1, [r2, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5ef2:	f8da 2004 	ldr.w	r2, [sl, #4]
    5ef6:	443a      	add	r2, r7
    5ef8:	68d2      	ldr	r2, [r2, #12]
    5efa:	4432      	add	r2, r6
    5efc:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5efe:	4413      	add	r3, r2
    5f00:	f883 10b7 	strb.w	r1, [r3, #183]	; 0xb7
						if (position_is_me){
    5f04:	f1bb 0f00 	cmp.w	fp, #0
    5f08:	d018      	beq.n	5f3c <grid_port_process_outbound_ui+0x87c>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    5f0a:	22bc      	movs	r2, #188	; 0xbc
    5f0c:	fb10 f002 	smulbb	r0, r0, r2
    5f10:	f8da 3004 	ldr.w	r3, [sl, #4]
    5f14:	9a04      	ldr	r2, [sp, #16]
    5f16:	4413      	add	r3, r2
    5f18:	2201      	movs	r2, #1
    5f1a:	68db      	ldr	r3, [r3, #12]
    5f1c:	4433      	add	r3, r6
    5f1e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    5f20:	4403      	add	r3, r0
    5f22:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5f26:	f8da 3004 	ldr.w	r3, [sl, #4]
    5f2a:	9a04      	ldr	r2, [sp, #16]
    5f2c:	441a      	add	r2, r3
    5f2e:	68d3      	ldr	r3, [r2, #12]
    5f30:	441e      	add	r6, r3
    5f32:	6e33      	ldr	r3, [r6, #96]	; 0x60
    5f34:	4418      	add	r0, r3
    5f36:	2300      	movs	r3, #0
    5f38:	f880 30b7 	strb.w	r3, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    5f3c:	4b4e      	ldr	r3, [pc, #312]	; (6078 <grid_port_process_outbound_ui+0x9b8>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f3e:	4e4f      	ldr	r6, [pc, #316]	; (607c <grid_port_process_outbound_ui+0x9bc>)
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f40:	4f4f      	ldr	r7, [pc, #316]	; (6080 <grid_port_process_outbound_ui+0x9c0>)
					grid_msg_init(&response);
    5f42:	a893      	add	r0, sp, #588	; 0x24c
    5f44:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f46:	227f      	movs	r2, #127	; 0x7f
    5f48:	4611      	mov	r1, r2
    5f4a:	2300      	movs	r3, #0
    5f4c:	a893      	add	r0, sp, #588	; 0x24c
    5f4e:	47b0      	blx	r6
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f50:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    5f52:	2600      	movs	r6, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f54:	494b      	ldr	r1, [pc, #300]	; (6084 <grid_port_process_outbound_ui+0x9c4>)
    5f56:	9300      	str	r3, [sp, #0]
    5f58:	2202      	movs	r2, #2
    5f5a:	2380      	movs	r3, #128	; 0x80
    5f5c:	a80a      	add	r0, sp, #40	; 0x28
					uint8_t response_payload[10] = {0};
    5f5e:	e9cd 660a 	strd	r6, r6, [sp, #40]	; 0x28
    5f62:	f8ad 6030 	strh.w	r6, [sp, #48]	; 0x30
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f66:	47b8      	blx	r7
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f68:	4b47      	ldr	r3, [pc, #284]	; (6088 <grid_port_process_outbound_ui+0x9c8>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f6a:	4f48      	ldr	r7, [pc, #288]	; (608c <grid_port_process_outbound_ui+0x9cc>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f6c:	a80a      	add	r0, sp, #40	; 0x28
    5f6e:	4798      	blx	r3
    5f70:	4b47      	ldr	r3, [pc, #284]	; (6090 <grid_port_process_outbound_ui+0x9d0>)
    5f72:	4602      	mov	r2, r0
    5f74:	a90a      	add	r1, sp, #40	; 0x28
    5f76:	a893      	add	r0, sp, #588	; 0x24c
    5f78:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f7a:	9b05      	ldr	r3, [sp, #20]
    5f7c:	9300      	str	r3, [sp, #0]
    5f7e:	2205      	movs	r2, #5
    5f80:	2302      	movs	r3, #2
    5f82:	4631      	mov	r1, r6
    5f84:	a893      	add	r0, sp, #588	; 0x24c
    5f86:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    5f88:	2302      	movs	r3, #2
    5f8a:	2207      	movs	r2, #7
    5f8c:	4631      	mov	r1, r6
    5f8e:	a893      	add	r0, sp, #588	; 0x24c
    5f90:	f8cd 8000 	str.w	r8, [sp]
    5f94:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    5f96:	2302      	movs	r3, #2
    5f98:	2209      	movs	r2, #9
    5f9a:	4631      	mov	r1, r6
    5f9c:	a893      	add	r0, sp, #588	; 0x24c
    5f9e:	f8cd 9000 	str.w	r9, [sp]
    5fa2:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5fa4:	230a      	movs	r3, #10
    5fa6:	9300      	str	r3, [sp, #0]
    5fa8:	2204      	movs	r2, #4
    5faa:	2301      	movs	r3, #1
    5fac:	4631      	mov	r1, r6
    5fae:	a893      	add	r0, sp, #588	; 0x24c
    5fb0:	47b8      	blx	r7
                        grid_msg_packet_close(&response);
    5fb2:	4b38      	ldr	r3, [pc, #224]	; (6094 <grid_port_process_outbound_ui+0x9d4>)
    5fb4:	a893      	add	r0, sp, #588	; 0x24c
    5fb6:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5fb8:	4b37      	ldr	r3, [pc, #220]	; (6098 <grid_port_process_outbound_ui+0x9d8>)
    5fba:	a893      	add	r0, sp, #588	; 0x24c
    5fbc:	4798      	blx	r3
    5fbe:	f7ff bbfa 	b.w	57b6 <grid_port_process_outbound_ui+0xf6>
                    if (!position_is_local){
    5fc2:	2c00      	cmp	r4, #0
    5fc4:	f47f af20 	bne.w	5e08 <grid_port_process_outbound_ui+0x748>
                        grid_keyboard_state.isenabled = 0;             
    5fc8:	4e34      	ldr	r6, [pc, #208]	; (609c <grid_port_process_outbound_ui+0x9dc>)
                        grid_msg_init(&response);
    5fca:	4b2b      	ldr	r3, [pc, #172]	; (6078 <grid_port_process_outbound_ui+0x9b8>)
                        grid_keyboard_state.isenabled = 0;             
    5fcc:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    5fd0:	a893      	add	r0, sp, #588	; 0x24c
    5fd2:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5fd4:	227f      	movs	r2, #127	; 0x7f
    5fd6:	4623      	mov	r3, r4
    5fd8:	4611      	mov	r1, r2
    5fda:	a893      	add	r0, sp, #588	; 0x24c
    5fdc:	4f27      	ldr	r7, [pc, #156]	; (607c <grid_port_process_outbound_ui+0x9bc>)
    5fde:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fe0:	2303      	movs	r3, #3
    5fe2:	492f      	ldr	r1, [pc, #188]	; (60a0 <grid_port_process_outbound_ui+0x9e0>)
    5fe4:	9300      	str	r3, [sp, #0]
    5fe6:	2202      	movs	r2, #2
    5fe8:	4f25      	ldr	r7, [pc, #148]	; (6080 <grid_port_process_outbound_ui+0x9c0>)
                        uint8_t response_payload[10] = {0};
    5fea:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fee:	2392      	movs	r3, #146	; 0x92
    5ff0:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    5ff2:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5ff6:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5ff8:	4b23      	ldr	r3, [pc, #140]	; (6088 <grid_port_process_outbound_ui+0x9c8>)
    5ffa:	a80e      	add	r0, sp, #56	; 0x38
    5ffc:	4798      	blx	r3
    5ffe:	a90e      	add	r1, sp, #56	; 0x38
    6000:	4602      	mov	r2, r0
    6002:	4b23      	ldr	r3, [pc, #140]	; (6090 <grid_port_process_outbound_ui+0x9d0>)
    6004:	a893      	add	r0, sp, #588	; 0x24c
    6006:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    6008:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    600c:	9300      	str	r3, [sp, #0]
    600e:	4e1f      	ldr	r6, [pc, #124]	; (608c <grid_port_process_outbound_ui+0x9cc>)
    6010:	4621      	mov	r1, r4
    6012:	a893      	add	r0, sp, #588	; 0x24c
    6014:	2302      	movs	r3, #2
    6016:	2205      	movs	r2, #5
    6018:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    601a:	230d      	movs	r3, #13
    601c:	4621      	mov	r1, r4
    601e:	2204      	movs	r2, #4
    6020:	9300      	str	r3, [sp, #0]
    6022:	a893      	add	r0, sp, #588	; 0x24c
    6024:	2301      	movs	r3, #1
    6026:	47b0      	blx	r6
                        grid_msg_packet_close(&response);
    6028:	4b1a      	ldr	r3, [pc, #104]	; (6094 <grid_port_process_outbound_ui+0x9d4>)
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    602a:	4e1e      	ldr	r6, [pc, #120]	; (60a4 <grid_port_process_outbound_ui+0x9e4>)
                        grid_msg_packet_close(&response);
    602c:	a893      	add	r0, sp, #588	; 0x24c
    602e:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    6030:	4b19      	ldr	r3, [pc, #100]	; (6098 <grid_port_process_outbound_ui+0x9d8>)
    6032:	a893      	add	r0, sp, #588	; 0x24c
    6034:	4798      	blx	r3
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    6036:	23fa      	movs	r3, #250	; 0xfa
    6038:	e9cd 4300 	strd	r4, r3, [sp]
    603c:	2364      	movs	r3, #100	; 0x64
    603e:	480b      	ldr	r0, [pc, #44]	; (606c <grid_port_process_outbound_ui+0x9ac>)
    6040:	461a      	mov	r2, r3
    6042:	4619      	mov	r1, r3
    6044:	47b0      	blx	r6
    6046:	e6df      	b.n	5e08 <grid_port_process_outbound_ui+0x748>
						actionstring[j] = message[current_start+GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset + j];
    6048:	f818 2b01 	ldrb.w	r2, [r8], #1
    604c:	558a      	strb	r2, [r1, r6]
					for(uint32_t j = 0; j<actionstring_length; j++){
    604e:	3101      	adds	r1, #1
    6050:	e70a      	b.n	5e68 <grid_port_process_outbound_ui+0x7a8>
    6052:	bf00      	nop
    6054:	20008438 	.word	0x20008438
    6058:	00009ae5 	.word	0x00009ae5
    605c:	00009b05 	.word	0x00009b05
    6060:	00009b15 	.word	0x00009b15
    6064:	00014175 	.word	0x00014175
    6068:	00009f35 	.word	0x00009f35
    606c:	20007a24 	.word	0x20007a24
    6070:	0000a191 	.word	0x0000a191
    6074:	0000a145 	.word	0x0000a145
    6078:	000085c5 	.word	0x000085c5
    607c:	000085f9 	.word	0x000085f9
    6080:	000147d1 	.word	0x000147d1
    6084:	00016770 	.word	0x00016770
    6088:	00014c81 	.word	0x00014c81
    608c:	000085a9 	.word	0x000085a9
    6090:	00008535 	.word	0x00008535
    6094:	000086f1 	.word	0x000086f1
    6098:	000087c5 	.word	0x000087c5
    609c:	20008c80 	.word	0x20008c80
    60a0:	00016764 	.word	0x00016764
    60a4:	00009813 	.word	0x00009813
                        grid_keyboard_state.isenabled = 0;             
    60a8:	4e8b      	ldr	r6, [pc, #556]	; (62d8 <grid_port_process_outbound_ui+0xc18>)
                        grid_msg_init(&response);
    60aa:	4b8c      	ldr	r3, [pc, #560]	; (62dc <grid_port_process_outbound_ui+0xc1c>)
                        grid_keyboard_state.isenabled = 0;             
    60ac:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    60b0:	a893      	add	r0, sp, #588	; 0x24c
    60b2:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    60b4:	227f      	movs	r2, #127	; 0x7f
    60b6:	4611      	mov	r1, r2
    60b8:	4f89      	ldr	r7, [pc, #548]	; (62e0 <grid_port_process_outbound_ui+0xc20>)
    60ba:	4623      	mov	r3, r4
    60bc:	a893      	add	r0, sp, #588	; 0x24c
    60be:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60c0:	2303      	movs	r3, #3
    60c2:	4988      	ldr	r1, [pc, #544]	; (62e4 <grid_port_process_outbound_ui+0xc24>)
    60c4:	9300      	str	r3, [sp, #0]
    60c6:	2202      	movs	r2, #2
    60c8:	2392      	movs	r3, #146	; 0x92
    60ca:	4f87      	ldr	r7, [pc, #540]	; (62e8 <grid_port_process_outbound_ui+0xc28>)
                        uint8_t response_payload[10] = {0};
    60cc:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60d0:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    60d2:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60d6:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    60d8:	4b84      	ldr	r3, [pc, #528]	; (62ec <grid_port_process_outbound_ui+0xc2c>)
    60da:	a80e      	add	r0, sp, #56	; 0x38
    60dc:	4798      	blx	r3
    60de:	4b84      	ldr	r3, [pc, #528]	; (62f0 <grid_port_process_outbound_ui+0xc30>)
    60e0:	4602      	mov	r2, r0
    60e2:	a90e      	add	r1, sp, #56	; 0x38
    60e4:	a893      	add	r0, sp, #588	; 0x24c
    60e6:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    60e8:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    60ec:	9300      	str	r3, [sp, #0]
    60ee:	2205      	movs	r2, #5
    60f0:	2302      	movs	r3, #2
    60f2:	4621      	mov	r1, r4
    60f4:	4e7f      	ldr	r6, [pc, #508]	; (62f4 <grid_port_process_outbound_ui+0xc34>)
    60f6:	a893      	add	r0, sp, #588	; 0x24c
    60f8:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    60fa:	230d      	movs	r3, #13
    60fc:	9300      	str	r3, [sp, #0]
    60fe:	2204      	movs	r2, #4
    6100:	2301      	movs	r3, #1
    6102:	4621      	mov	r1, r4
    6104:	a893      	add	r0, sp, #588	; 0x24c
    6106:	47b0      	blx	r6
    6108:	e753      	b.n	5fb2 <grid_port_process_outbound_ui+0x8f2>
                else if (msg_class == GRID_CLASS_HIDKEYSTATUS_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    610a:	2e92      	cmp	r6, #146	; 0x92
    610c:	d13e      	bne.n	618c <grid_port_process_outbound_ui+0xacc>
    610e:	2f0e      	cmp	r7, #14
    6110:	f47f ab51 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    6114:	9b02      	ldr	r3, [sp, #8]
    6116:	ea5b 0303 	orrs.w	r3, fp, r3
    611a:	f43f ab4c 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    611e:	f108 0005 	add.w	r0, r8, #5
    6122:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6126:	2102      	movs	r1, #2
    6128:	4448      	add	r0, r9
    612a:	47a8      	blx	r5
                    grid_keyboard_state.isenabled = isenabled;
    612c:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 62d8 <grid_port_process_outbound_ui+0xc18>
                    grid_msg_init(&response);
    6130:	4b6a      	ldr	r3, [pc, #424]	; (62dc <grid_port_process_outbound_ui+0xc1c>)
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    6132:	f888 0045 	strb.w	r0, [r8, #69]	; 0x45
                    grid_msg_init(&response);
    6136:	a893      	add	r0, sp, #588	; 0x24c
    6138:	4798      	blx	r3
                    grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    613a:	227f      	movs	r2, #127	; 0x7f
    613c:	4611      	mov	r1, r2
    613e:	4f68      	ldr	r7, [pc, #416]	; (62e0 <grid_port_process_outbound_ui+0xc20>)
    6140:	2300      	movs	r3, #0
    6142:	a893      	add	r0, sp, #588	; 0x24c
    6144:	47b8      	blx	r7
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6146:	2303      	movs	r3, #3
    6148:	4966      	ldr	r1, [pc, #408]	; (62e4 <grid_port_process_outbound_ui+0xc24>)
    614a:	9300      	str	r3, [sp, #0]
                    uint8_t response_payload[10] = {0};
    614c:	2700      	movs	r7, #0
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    614e:	4633      	mov	r3, r6
    6150:	2202      	movs	r2, #2
    6152:	4e65      	ldr	r6, [pc, #404]	; (62e8 <grid_port_process_outbound_ui+0xc28>)
                    uint8_t response_payload[10] = {0};
    6154:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6158:	a80e      	add	r0, sp, #56	; 0x38
                    uint8_t response_payload[10] = {0};
    615a:	e9cd 770e 	strd	r7, r7, [sp, #56]	; 0x38
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    615e:	47b0      	blx	r6
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6160:	4b62      	ldr	r3, [pc, #392]	; (62ec <grid_port_process_outbound_ui+0xc2c>)
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    6162:	4e64      	ldr	r6, [pc, #400]	; (62f4 <grid_port_process_outbound_ui+0xc34>)
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6164:	a80e      	add	r0, sp, #56	; 0x38
    6166:	4798      	blx	r3
    6168:	4b61      	ldr	r3, [pc, #388]	; (62f0 <grid_port_process_outbound_ui+0xc30>)
    616a:	4602      	mov	r2, r0
    616c:	a90e      	add	r1, sp, #56	; 0x38
    616e:	a893      	add	r0, sp, #588	; 0x24c
    6170:	4798      	blx	r3
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    6172:	f898 3045 	ldrb.w	r3, [r8, #69]	; 0x45
    6176:	9300      	str	r3, [sp, #0]
    6178:	2205      	movs	r2, #5
    617a:	2302      	movs	r3, #2
    617c:	4639      	mov	r1, r7
    617e:	a893      	add	r0, sp, #588	; 0x24c
    6180:	47b0      	blx	r6
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    6182:	230a      	movs	r3, #10
    6184:	9300      	str	r3, [sp, #0]
    6186:	2204      	movs	r2, #4
    6188:	2301      	movs	r3, #1
    618a:	e54a      	b.n	5c22 <grid_port_process_outbound_ui+0x562>
				else if (msg_class == GRID_CLASS_CONFIGDEFAULT_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    618c:	2e81      	cmp	r6, #129	; 0x81
    618e:	f47f ab12 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    6192:	2f0e      	cmp	r7, #14
    6194:	f47f ab0f 	bne.w	57b6 <grid_port_process_outbound_ui+0xf6>
    6198:	ea5b 0304 	orrs.w	r3, fp, r4
    619c:	f43f ab0b 	beq.w	57b6 <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    61a0:	f108 0005 	add.w	r0, r8, #5
    61a4:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    61a8:	2102      	movs	r1, #2
    61aa:	4448      	add	r0, r9
    61ac:	47a8      	blx	r5
    61ae:	b2c7      	uxtb	r7, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    61b0:	f108 0007 	add.w	r0, r8, #7
    61b4:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    61b8:	2102      	movs	r1, #2
    61ba:	4448      	add	r0, r9
    61bc:	47a8      	blx	r5
    61be:	4606      	mov	r6, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    61c0:	f108 0009 	add.w	r0, r8, #9
    61c4:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    61c8:	2102      	movs	r1, #2
    61ca:	4448      	add	r0, r9
    61cc:	47a8      	blx	r5
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61ce:	f8da 3004 	ldr.w	r3, [sl, #4]
    61d2:	eb03 1307 	add.w	r3, r3, r7, lsl #4
    61d6:	b2f2      	uxtb	r2, r6
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    61d8:	fa5f f880 	uxtb.w	r8, r0
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61dc:	f04f 0964 	mov.w	r9, #100	; 0x64
    61e0:	68d8      	ldr	r0, [r3, #12]
    61e2:	4b45      	ldr	r3, [pc, #276]	; (62f8 <grid_port_process_outbound_ui+0xc38>)
    61e4:	9204      	str	r2, [sp, #16]
    61e6:	fb09 f902 	mul.w	r9, r9, r2
    61ea:	4641      	mov	r1, r8
    61ec:	4448      	add	r0, r9
    61ee:	4798      	blx	r3
					if (banknumber == grid_sys_state.bank_activebank_number){
    61f0:	4b42      	ldr	r3, [pc, #264]	; (62fc <grid_port_process_outbound_ui+0xc3c>)
    61f2:	7bdb      	ldrb	r3, [r3, #15]
    61f4:	42bb      	cmp	r3, r7
    61f6:	d105      	bne.n	6204 <grid_port_process_outbound_ui+0xb44>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    61f8:	9a04      	ldr	r2, [sp, #16]
    61fa:	4e41      	ldr	r6, [pc, #260]	; (6300 <grid_port_process_outbound_ui+0xc40>)
    61fc:	4643      	mov	r3, r8
    61fe:	4639      	mov	r1, r7
    6200:	4650      	mov	r0, sl
    6202:	47b0      	blx	r6
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6204:	f8da 3004 	ldr.w	r3, [sl, #4]
    6208:	013a      	lsls	r2, r7, #4
    620a:	4413      	add	r3, r2
    620c:	4641      	mov	r1, r8
    620e:	68d8      	ldr	r0, [r3, #12]
    6210:	4b3c      	ldr	r3, [pc, #240]	; (6304 <grid_port_process_outbound_ui+0xc44>)
    6212:	4448      	add	r0, r9
    6214:	4798      	blx	r3
					if (event_index != 255){
    6216:	28ff      	cmp	r0, #255	; 0xff
    6218:	d018      	beq.n	624c <grid_port_process_outbound_ui+0xb8c>
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    621a:	f8da 3004 	ldr.w	r3, [sl, #4]
    621e:	22bc      	movs	r2, #188	; 0xbc
    6220:	fb10 f002 	smulbb	r0, r0, r2
    6224:	013a      	lsls	r2, r7, #4
    6226:	4413      	add	r3, r2
    6228:	2201      	movs	r2, #1
    622a:	68db      	ldr	r3, [r3, #12]
    622c:	444b      	add	r3, r9
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    622e:	0139      	lsls	r1, r7, #4
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    6230:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    6232:	4403      	add	r3, r0
    6234:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    6238:	f8da 3004 	ldr.w	r3, [sl, #4]
    623c:	440b      	add	r3, r1
    623e:	68db      	ldr	r3, [r3, #12]
    6240:	4499      	add	r9, r3
    6242:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
    6246:	4418      	add	r0, r3
    6248:	f880 20b7 	strb.w	r2, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    624c:	4b23      	ldr	r3, [pc, #140]	; (62dc <grid_port_process_outbound_ui+0xc1c>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    624e:	f8df 9090 	ldr.w	r9, [pc, #144]	; 62e0 <grid_port_process_outbound_ui+0xc20>
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6252:	4e25      	ldr	r6, [pc, #148]	; (62e8 <grid_port_process_outbound_ui+0xc28>)
					grid_msg_init(&response);
    6254:	a893      	add	r0, sp, #588	; 0x24c
    6256:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6258:	227f      	movs	r2, #127	; 0x7f
    625a:	4611      	mov	r1, r2
    625c:	2300      	movs	r3, #0
    625e:	a893      	add	r0, sp, #588	; 0x24c
    6260:	47c8      	blx	r9
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6262:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    6264:	f04f 0900 	mov.w	r9, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6268:	4927      	ldr	r1, [pc, #156]	; (6308 <grid_port_process_outbound_ui+0xc48>)
    626a:	9300      	str	r3, [sp, #0]
    626c:	2202      	movs	r2, #2
    626e:	2380      	movs	r3, #128	; 0x80
    6270:	a80e      	add	r0, sp, #56	; 0x38
					uint8_t response_payload[10] = {0};
    6272:	e9cd 990e 	strd	r9, r9, [sp, #56]	; 0x38
    6276:	f8ad 9040 	strh.w	r9, [sp, #64]	; 0x40
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    627a:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    627c:	4b1b      	ldr	r3, [pc, #108]	; (62ec <grid_port_process_outbound_ui+0xc2c>)
    627e:	a80e      	add	r0, sp, #56	; 0x38
    6280:	4798      	blx	r3
    6282:	4b1b      	ldr	r3, [pc, #108]	; (62f0 <grid_port_process_outbound_ui+0xc30>)
    6284:	4602      	mov	r2, r0
    6286:	a90e      	add	r1, sp, #56	; 0x38
    6288:	a893      	add	r0, sp, #588	; 0x24c
    628a:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    628c:	9700      	str	r7, [sp, #0]
    628e:	2302      	movs	r3, #2
    6290:	4f18      	ldr	r7, [pc, #96]	; (62f4 <grid_port_process_outbound_ui+0xc34>)
    6292:	2205      	movs	r2, #5
    6294:	4649      	mov	r1, r9
    6296:	a893      	add	r0, sp, #588	; 0x24c
    6298:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    629a:	9b04      	ldr	r3, [sp, #16]
    629c:	9300      	str	r3, [sp, #0]
    629e:	2207      	movs	r2, #7
    62a0:	2302      	movs	r3, #2
    62a2:	4649      	mov	r1, r9
    62a4:	a893      	add	r0, sp, #588	; 0x24c
    62a6:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    62a8:	f8cd 8000 	str.w	r8, [sp]
    62ac:	2302      	movs	r3, #2
    62ae:	2209      	movs	r2, #9
    62b0:	4649      	mov	r1, r9
    62b2:	a893      	add	r0, sp, #588	; 0x24c
    62b4:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    62b6:	230a      	movs	r3, #10
    62b8:	2204      	movs	r2, #4
    62ba:	4649      	mov	r1, r9
    62bc:	9300      	str	r3, [sp, #0]
    62be:	a893      	add	r0, sp, #588	; 0x24c
    62c0:	2301      	movs	r3, #1
    62c2:	47b8      	blx	r7
					grid_msg_packet_close(&response);
    62c4:	4b11      	ldr	r3, [pc, #68]	; (630c <grid_port_process_outbound_ui+0xc4c>)
    62c6:	a893      	add	r0, sp, #588	; 0x24c
    62c8:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    62ca:	4b11      	ldr	r3, [pc, #68]	; (6310 <grid_port_process_outbound_ui+0xc50>)
    62cc:	a893      	add	r0, sp, #588	; 0x24c
    62ce:	4798      	blx	r3
				current_start = 0;
    62d0:	46c8      	mov	r8, r9
    62d2:	f7ff ba4c 	b.w	576e <grid_port_process_outbound_ui+0xae>
    62d6:	bf00      	nop
    62d8:	20008c80 	.word	0x20008c80
    62dc:	000085c5 	.word	0x000085c5
    62e0:	000085f9 	.word	0x000085f9
    62e4:	00016764 	.word	0x00016764
    62e8:	000147d1 	.word	0x000147d1
    62ec:	00014c81 	.word	0x00014c81
    62f0:	00008535 	.word	0x00008535
    62f4:	000085a9 	.word	0x000085a9
    62f8:	00009fa1 	.word	0x00009fa1
    62fc:	20007a24 	.word	0x20007a24
    6300:	0000a191 	.word	0x0000a191
    6304:	0000a145 	.word	0x0000a145
    6308:	00016770 	.word	0x00016770
    630c:	000086f1 	.word	0x000086f1
    6310:	000087c5 	.word	0x000087c5

00006314 <grid_port_process_outbound_usart>:

uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    6314:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    6318:	8987      	ldrh	r7, [r0, #12]
uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    631a:	4605      	mov	r5, r0
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    631c:	bb1f      	cbnz	r7, 6366 <grid_port_process_outbound_usart+0x52>
		
		uint16_t packet_size = grid_buffer_read_size(&por->tx_buffer);
    631e:	f500 561c 	add.w	r6, r0, #9984	; 0x2700
    6322:	363c      	adds	r6, #60	; 0x3c
    6324:	4b11      	ldr	r3, [pc, #68]	; (636c <grid_port_process_outbound_usart+0x58>)
    6326:	4630      	mov	r0, r6
    6328:	4798      	blx	r3
		
		if (!packet_size){
    632a:	4604      	mov	r4, r0
    632c:	b1a0      	cbz	r0, 6358 <grid_port_process_outbound_usart+0x44>
			// NO PACKET IN RX BUFFER
			return 0;
		}else{
			
			// Let's transfer the packet to local memory
			grid_buffer_read_init(&por->tx_buffer);
    632e:	4b10      	ldr	r3, [pc, #64]	; (6370 <grid_port_process_outbound_usart+0x5c>)
			
			por->tx_double_buffer_status = packet_size;
			
			for (uint16_t i = 0; i<packet_size; i++){
				
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6330:	f8df a048 	ldr.w	sl, [pc, #72]	; 637c <grid_port_process_outbound_usart+0x68>
			grid_buffer_read_init(&por->tx_buffer);
    6334:	4630      	mov	r0, r6
    6336:	f105 082c 	add.w	r8, r5, #44	; 0x2c
    633a:	4798      	blx	r3
			por->tx_double_buffer_status = packet_size;
    633c:	46c1      	mov	r9, r8
    633e:	81ac      	strh	r4, [r5, #12]
			for (uint16_t i = 0; i<packet_size; i++){
    6340:	b2bb      	uxth	r3, r7
    6342:	429c      	cmp	r4, r3
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6344:	4630      	mov	r0, r6
			for (uint16_t i = 0; i<packet_size; i++){
    6346:	d809      	bhi.n	635c <grid_port_process_outbound_usart+0x48>
				por->tx_double_buffer[i] = character;
				
			}
		
			// Let's acknowledge the transaction
			grid_buffer_read_acknowledge(&por->tx_buffer);
    6348:	4b0a      	ldr	r3, [pc, #40]	; (6374 <grid_port_process_outbound_usart+0x60>)
    634a:	4798      	blx	r3
			
			// Let's send the packet through USART
			io_write(&por->usart->io, por->tx_double_buffer, por->tx_double_buffer_status);		
    634c:	89aa      	ldrh	r2, [r5, #12]
    634e:	6868      	ldr	r0, [r5, #4]
    6350:	4b09      	ldr	r3, [pc, #36]	; (6378 <grid_port_process_outbound_usart+0x64>)
    6352:	4649      	mov	r1, r9
    6354:	4798      	blx	r3
			
			return 1;
    6356:	2001      	movs	r0, #1
		}
		
	}
	
	return 0;
}
    6358:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    635c:	47d0      	blx	sl
				por->tx_double_buffer[i] = character;
    635e:	3701      	adds	r7, #1
    6360:	f808 0b01 	strb.w	r0, [r8], #1
			for (uint16_t i = 0; i<packet_size; i++){
    6364:	e7ec      	b.n	6340 <grid_port_process_outbound_usart+0x2c>
	return 0;
    6366:	2000      	movs	r0, #0
    6368:	e7f6      	b.n	6358 <grid_port_process_outbound_usart+0x44>
    636a:	bf00      	nop
    636c:	00004f05 	.word	0x00004f05
    6370:	00004f5b 	.word	0x00004f5b
    6374:	00004fed 	.word	0x00004fed
    6378:	0000b0ed 	.word	0x0000b0ed
    637c:	00004fc3 	.word	0x00004fc3

00006380 <grid_d51_init>:
	
}



void grid_d51_init(){
    6380:	b570      	push	{r4, r5, r6, lr}
	
	uint32_t hwid = grid_sys_get_hwcfg();
    6382:	4b09      	ldr	r3, [pc, #36]	; (63a8 <grid_d51_init+0x28>)
	
	#ifdef NDEBUG		
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "USER ROW CHECK!");
	grid_d51_verify_user_row();
	#else
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6384:	4d09      	ldr	r5, [pc, #36]	; (63ac <grid_d51_init+0x2c>)
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    6386:	4c0a      	ldr	r4, [pc, #40]	; (63b0 <grid_d51_init+0x30>)
	uint32_t hwid = grid_sys_get_hwcfg();
    6388:	4798      	blx	r3
    638a:	4601      	mov	r1, r0
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    638c:	4809      	ldr	r0, [pc, #36]	; (63b4 <grid_d51_init+0x34>)
    638e:	47a0      	blx	r4
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6390:	4909      	ldr	r1, [pc, #36]	; (63b8 <grid_d51_init+0x38>)
    6392:	4628      	mov	r0, r5
    6394:	47a0      	blx	r4
	{
	}
	
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Unit Test");
    6396:	4909      	ldr	r1, [pc, #36]	; (63bc <grid_d51_init+0x3c>)
    6398:	4628      	mov	r0, r5
    639a:	47a0      	blx	r4
	while (1)
	{
	}
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    639c:	4628      	mov	r0, r5
    639e:	4623      	mov	r3, r4
    63a0:	4907      	ldr	r1, [pc, #28]	; (63c0 <grid_d51_init+0x40>)
	#endif
		
}
    63a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    63a6:	4718      	bx	r3
    63a8:	000098ed 	.word	0x000098ed
    63ac:	0001663b 	.word	0x0001663b
    63b0:	000143b9 	.word	0x000143b9
    63b4:	00016780 	.word	0x00016780
    63b8:	000167a1 	.word	0x000167a1
    63bc:	000167b4 	.word	0x000167b4
    63c0:	000167c1 	.word	0x000167c1

000063c4 <grid_expr_clear_input>:
}


grid_expr_clear_input(struct grid_expr_model* expr){

    expr->input_string_length = 0;
    63c4:	2300      	movs	r3, #0
    63c6:	f880 30fe 	strb.w	r3, [r0, #254]	; 0xfe

    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    63ca:	1d02      	adds	r2, r0, #4
    63cc:	30fe      	adds	r0, #254	; 0xfe

        expr->input_string[i] = 0;
    63ce:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    63d2:	4282      	cmp	r2, r0
    63d4:	d1fb      	bne.n	63ce <grid_expr_clear_input+0xa>

    }

}
    63d6:	4770      	bx	lr

000063d8 <grid_expr_clear_output>:

grid_expr_clear_output(struct grid_expr_model* expr){


    expr->output_string_length = 0;
    63d8:	2300      	movs	r3, #0
    63da:	f880 31fa 	strb.w	r3, [r0, #506]	; 0x1fa

    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    63de:	f100 02ff 	add.w	r2, r0, #255	; 0xff
    63e2:	f200 10f9 	addw	r0, r0, #505	; 0x1f9

        expr->output_string[i] = 0;
    63e6:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    63ea:	4282      	cmp	r2, r0
    63ec:	d1fb      	bne.n	63e6 <grid_expr_clear_output+0xe>

    }

}
    63ee:	4770      	bx	lr

000063f0 <grid_expr_init>:
void grid_expr_init(struct grid_expr_model* expr){
    63f0:	b510      	push	{r4, lr}
    expr->current_event = NULL;
    63f2:	2300      	movs	r3, #0
    63f4:	6003      	str	r3, [r0, #0]
    grid_expr_clear_input(expr);
    63f6:	4b04      	ldr	r3, [pc, #16]	; (6408 <grid_expr_init+0x18>)
void grid_expr_init(struct grid_expr_model* expr){
    63f8:	4601      	mov	r1, r0
    grid_expr_clear_input(expr);
    63fa:	4798      	blx	r3
}
    63fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_expr_clear_output(expr);
    6400:	4b02      	ldr	r3, [pc, #8]	; (640c <grid_expr_init+0x1c>)
    6402:	4608      	mov	r0, r1
    6404:	4718      	bx	r3
    6406:	bf00      	nop
    6408:	000063c5 	.word	0x000063c5
    640c:	000063d9 	.word	0x000063d9

00006410 <grid_expr_set_current_event>:



grid_expr_set_current_event(struct grid_expr_model* expr, struct grid_ui_event* eve){

    expr->current_event = eve;
    6410:	6001      	str	r1, [r0, #0]
}
    6412:	4770      	bx	lr

00006414 <get>:
}


char get(char** e)
{
    char ret = **e;
    6414:	6802      	ldr	r2, [r0, #0]
{
    6416:	4603      	mov	r3, r0
    char ret = **e;
    6418:	f812 0b01 	ldrb.w	r0, [r2], #1
    ++*e;
    641c:	601a      	str	r2, [r3, #0]
    return ret;
}
    641e:	4770      	bx	lr

00006420 <number>:

int number(char** e)
{
    6420:	b530      	push	{r4, r5, lr}
    char ret = **e;
    6422:	6801      	ldr	r1, [r0, #0]
    6424:	f811 3b01 	ldrb.w	r3, [r1], #1
    ++*e;
    6428:	6001      	str	r1, [r0, #0]
{
    642a:	4602      	mov	r2, r0
    int result = get(e) - '0';
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    {
        result = 10*result + get(e) - '0'; // HEX para
    642c:	250a      	movs	r5, #10
    int result = get(e) - '0';
    642e:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    return **e;
    6432:	6811      	ldr	r1, [r2, #0]
    6434:	780b      	ldrb	r3, [r1, #0]
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    6436:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
    643a:	2c09      	cmp	r4, #9
    643c:	d900      	bls.n	6440 <number+0x20>
    }
    return result;
}
    643e:	bd30      	pop	{r4, r5, pc}
    ++*e;
    6440:	3101      	adds	r1, #1
        result = 10*result + get(e) - '0'; // HEX para
    6442:	fb05 3300 	mla	r3, r5, r0, r3
    ++*e;
    6446:	6011      	str	r1, [r2, #0]
        result = 10*result + get(e) - '0'; // HEX para
    6448:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    644c:	e7f1      	b.n	6432 <number+0x12>
	...

00006450 <expr_level_0>:
            result -= expr_level_2(e);
    return result;
}

int expr_level_0(char ** e) // equality
{
    6450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_1(e);
    6452:	4e2a      	ldr	r6, [pc, #168]	; (64fc <expr_level_0+0xac>)
        else if (peeked == '=' && peeked2 == '='){
            get(e); // burn the second character
            result = (result == expr_level_1(e));
        }
        else if (peeked == '!' && peeked2 == '='){
            get(e); // burn the second character
    6454:	4f2a      	ldr	r7, [pc, #168]	; (6500 <expr_level_0+0xb0>)
{
    6456:	4605      	mov	r5, r0
    int result = expr_level_1(e);
    6458:	47b0      	blx	r6
    645a:	4604      	mov	r4, r0
    return **e;
    645c:	682a      	ldr	r2, [r5, #0]
    645e:	7813      	ldrb	r3, [r2, #0]
    while (     (peek(e) == '>' && peek2(e) != '=') || 
    6460:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
    6464:	293c      	cmp	r1, #60	; 0x3c
    6466:	d004      	beq.n	6472 <expr_level_0+0x22>
                (peek(e) == '<' && peek2(e) != '=') || 
    6468:	2b3d      	cmp	r3, #61	; 0x3d
    646a:	d143      	bne.n	64f4 <expr_level_0+0xa4>
                (peek(e) == '!' && peek2(e) == '=') ||
    646c:	7851      	ldrb	r1, [r2, #1]
    646e:	293d      	cmp	r1, #61	; 0x3d
    6470:	d142      	bne.n	64f8 <expr_level_0+0xa8>
    ++*e;
    6472:	1c51      	adds	r1, r2, #1
    6474:	6029      	str	r1, [r5, #0]
        if ((peeked == '>' && peeked2 != '=')){
    6476:	2b3e      	cmp	r3, #62	; 0x3e
    return **e;
    6478:	7852      	ldrb	r2, [r2, #1]
        if ((peeked == '>' && peeked2 != '=')){
    647a:	d108      	bne.n	648e <expr_level_0+0x3e>
    647c:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result>expr_level_1(e));
    647e:	4628      	mov	r0, r5
        if ((peeked == '>' && peeked2 != '=')){
    6480:	d028      	beq.n	64d4 <expr_level_0+0x84>
            result = (result>expr_level_1(e));
    6482:	47b0      	blx	r6
    6484:	42a0      	cmp	r0, r4
    6486:	bfac      	ite	ge
    6488:	2400      	movge	r4, #0
    648a:	2401      	movlt	r4, #1
    648c:	e7e6      	b.n	645c <expr_level_0+0xc>
        else if (peeked == '<' && peeked2 != '='){
    648e:	2b3c      	cmp	r3, #60	; 0x3c
    6490:	d108      	bne.n	64a4 <expr_level_0+0x54>
    6492:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result<expr_level_1(e));
    6494:	4628      	mov	r0, r5
        else if (peeked == '<' && peeked2 != '='){
    6496:	d025      	beq.n	64e4 <expr_level_0+0x94>
            result = (result<expr_level_1(e));
    6498:	47b0      	blx	r6
    649a:	42a0      	cmp	r0, r4
    649c:	bfd4      	ite	le
    649e:	2400      	movle	r4, #0
    64a0:	2401      	movgt	r4, #1
    64a2:	e7db      	b.n	645c <expr_level_0+0xc>
        else if (peeked == '=' && peeked2 == '='){
    64a4:	2b3d      	cmp	r3, #61	; 0x3d
    64a6:	d109      	bne.n	64bc <expr_level_0+0x6c>
    64a8:	2a3d      	cmp	r2, #61	; 0x3d
    64aa:	d1d7      	bne.n	645c <expr_level_0+0xc>
            get(e); // burn the second character
    64ac:	4628      	mov	r0, r5
    64ae:	47b8      	blx	r7
            result = (result == expr_level_1(e));
    64b0:	4628      	mov	r0, r5
    64b2:	47b0      	blx	r6
    64b4:	1b03      	subs	r3, r0, r4
    64b6:	425c      	negs	r4, r3
    64b8:	415c      	adcs	r4, r3
    64ba:	e7cf      	b.n	645c <expr_level_0+0xc>
        else if (peeked == '!' && peeked2 == '='){
    64bc:	2b21      	cmp	r3, #33	; 0x21
    64be:	d1cd      	bne.n	645c <expr_level_0+0xc>
    64c0:	2a3d      	cmp	r2, #61	; 0x3d
    64c2:	d1cb      	bne.n	645c <expr_level_0+0xc>
            get(e); // burn the second character
    64c4:	4628      	mov	r0, r5
    64c6:	47b8      	blx	r7
            result = (result != expr_level_1(e));
    64c8:	4628      	mov	r0, r5
    64ca:	47b0      	blx	r6
    64cc:	1b04      	subs	r4, r0, r4
    64ce:	bf18      	it	ne
    64d0:	2401      	movne	r4, #1
    64d2:	e7c3      	b.n	645c <expr_level_0+0xc>
        }
        else if (peeked == '>' && peeked2 == '='){
            get(e); // burn the second character
    64d4:	47b8      	blx	r7
            result = (result >= expr_level_1(e));
    64d6:	4628      	mov	r0, r5
    64d8:	47b0      	blx	r6
    64da:	42a0      	cmp	r0, r4
    64dc:	bfcc      	ite	gt
    64de:	2400      	movgt	r4, #0
    64e0:	2401      	movle	r4, #1
    64e2:	e7bb      	b.n	645c <expr_level_0+0xc>
        }
        else if (peeked == '<' && peeked2 == '='){
            get(e); // burn the second character
    64e4:	47b8      	blx	r7
            result = (result <= expr_level_1(e));
    64e6:	4628      	mov	r0, r5
    64e8:	47b0      	blx	r6
    64ea:	42a0      	cmp	r0, r4
    64ec:	bfb4      	ite	lt
    64ee:	2400      	movlt	r4, #0
    64f0:	2401      	movge	r4, #1
    64f2:	e7b3      	b.n	645c <expr_level_0+0xc>
                (peek(e) == '=' && peek2(e) == '=') ||
    64f4:	2b21      	cmp	r3, #33	; 0x21
    64f6:	d0b9      	beq.n	646c <expr_level_0+0x1c>
        }
    }
    return result;
}
    64f8:	4620      	mov	r0, r4
    64fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    64fc:	000065bd 	.word	0x000065bd
    6500:	00006415 	.word	0x00006415

00006504 <expr_level_3>:
        get(e);
    6504:	4913      	ldr	r1, [pc, #76]	; (6554 <expr_level_3+0x50>)
{
    6506:	b570      	push	{r4, r5, r6, lr}
    6508:	4604      	mov	r4, r0
    650a:	2501      	movs	r5, #1
    return **e;
    650c:	6823      	ldr	r3, [r4, #0]
    650e:	781b      	ldrb	r3, [r3, #0]
    if (peek(e) >= '0' && peek(e) <= '9') // HEX para
    6510:	2b2f      	cmp	r3, #47	; 0x2f
    6512:	d908      	bls.n	6526 <expr_level_3+0x22>
    6514:	2b39      	cmp	r3, #57	; 0x39
    6516:	d818      	bhi.n	654a <expr_level_3+0x46>
        return number(e);
    6518:	4b0f      	ldr	r3, [pc, #60]	; (6558 <expr_level_3+0x54>)
    651a:	4620      	mov	r0, r4
    651c:	4798      	blx	r3
    651e:	4601      	mov	r1, r0
}
    6520:	fb05 f001 	mul.w	r0, r5, r1
    6524:	bd70      	pop	{r4, r5, r6, pc}
    else if (peek(e) == '(')
    6526:	2b28      	cmp	r3, #40	; 0x28
    6528:	d109      	bne.n	653e <expr_level_3+0x3a>
        get(e); // '('
    652a:	4e0a      	ldr	r6, [pc, #40]	; (6554 <expr_level_3+0x50>)
    652c:	4620      	mov	r0, r4
    652e:	47b0      	blx	r6
        int result = expr_level_0(e);
    6530:	4b0a      	ldr	r3, [pc, #40]	; (655c <expr_level_3+0x58>)
    6532:	4620      	mov	r0, r4
    6534:	4798      	blx	r3
    6536:	4601      	mov	r1, r0
        get(e); // ')'
    6538:	4620      	mov	r0, r4
    653a:	47b0      	blx	r6
        return result;
    653c:	e7f0      	b.n	6520 <expr_level_3+0x1c>
    else if (peek(e) == '-')
    653e:	2b2d      	cmp	r3, #45	; 0x2d
    6540:	d103      	bne.n	654a <expr_level_3+0x46>
        get(e);
    6542:	4620      	mov	r0, r4
    6544:	4788      	blx	r1
        return -expr_level_3(e);
    6546:	426d      	negs	r5, r5
    6548:	e7e0      	b.n	650c <expr_level_3+0x8>
    printf("ERROR in expr_level_3()\n");
    654a:	4805      	ldr	r0, [pc, #20]	; (6560 <expr_level_3+0x5c>)
    654c:	4b05      	ldr	r3, [pc, #20]	; (6564 <expr_level_3+0x60>)
    654e:	4798      	blx	r3
    return 0; // error
    6550:	2100      	movs	r1, #0
    6552:	e7e5      	b.n	6520 <expr_level_3+0x1c>
    6554:	00006415 	.word	0x00006415
    6558:	00006421 	.word	0x00006421
    655c:	00006451 	.word	0x00006451
    6560:	00016849 	.word	0x00016849
    6564:	000144c9 	.word	0x000144c9

00006568 <expr_level_2>:
{
    6568:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_3(e);
    656a:	4e13      	ldr	r6, [pc, #76]	; (65b8 <expr_level_2+0x50>)
{
    656c:	4605      	mov	r5, r0
    int result = expr_level_3(e);
    656e:	47b0      	blx	r6
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6570:	f240 4721 	movw	r7, #1057	; 0x421
    int result = expr_level_3(e);
    6574:	4604      	mov	r4, r0
    return **e;
    6576:	682a      	ldr	r2, [r5, #0]
    6578:	7811      	ldrb	r1, [r2, #0]
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    657a:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
    657e:	b2db      	uxtb	r3, r3
    6580:	2b0a      	cmp	r3, #10
    6582:	d803      	bhi.n	658c <expr_level_2+0x24>
    6584:	fa27 f303 	lsr.w	r3, r7, r3
    6588:	07db      	lsls	r3, r3, #31
    658a:	d401      	bmi.n	6590 <expr_level_2+0x28>
}
    658c:	4620      	mov	r0, r4
    658e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ++*e;
    6590:	3201      	adds	r2, #1
        if (peeked == '*'){
    6592:	292a      	cmp	r1, #42	; 0x2a
    ++*e;
    6594:	602a      	str	r2, [r5, #0]
            result *= expr_level_3(e);
    6596:	4628      	mov	r0, r5
        if (peeked == '*'){
    6598:	d102      	bne.n	65a0 <expr_level_2+0x38>
            result *= expr_level_3(e);
    659a:	47b0      	blx	r6
    659c:	4344      	muls	r4, r0
    659e:	e7ea      	b.n	6576 <expr_level_2+0xe>
        else if (peeked == '%'){
    65a0:	2925      	cmp	r1, #37	; 0x25
    65a2:	d105      	bne.n	65b0 <expr_level_2+0x48>
            result %= expr_level_3(e);
    65a4:	47b0      	blx	r6
    65a6:	fb94 f3f0 	sdiv	r3, r4, r0
    65aa:	fb03 4410 	mls	r4, r3, r0, r4
    65ae:	e7e2      	b.n	6576 <expr_level_2+0xe>
            result /= expr_level_3(e);
    65b0:	47b0      	blx	r6
    65b2:	fb94 f4f0 	sdiv	r4, r4, r0
    65b6:	e7de      	b.n	6576 <expr_level_2+0xe>
    65b8:	00006505 	.word	0x00006505

000065bc <expr_level_1>:
{
    65bc:	b570      	push	{r4, r5, r6, lr}
    int result = expr_level_2(e);
    65be:	4e0b      	ldr	r6, [pc, #44]	; (65ec <expr_level_1+0x30>)
{
    65c0:	4605      	mov	r5, r0
    int result = expr_level_2(e);
    65c2:	47b0      	blx	r6
    65c4:	4604      	mov	r4, r0
    return **e;
    65c6:	682b      	ldr	r3, [r5, #0]
    65c8:	781a      	ldrb	r2, [r3, #0]
    while (peek(e) == '+' || peek(e) == '-')
    65ca:	2a2b      	cmp	r2, #43	; 0x2b
    65cc:	d003      	beq.n	65d6 <expr_level_1+0x1a>
    65ce:	2a2d      	cmp	r2, #45	; 0x2d
    65d0:	d001      	beq.n	65d6 <expr_level_1+0x1a>
}
    65d2:	4620      	mov	r0, r4
    65d4:	bd70      	pop	{r4, r5, r6, pc}
    ++*e;
    65d6:	3301      	adds	r3, #1
        if (get(e) == '+')
    65d8:	2a2b      	cmp	r2, #43	; 0x2b
    ++*e;
    65da:	602b      	str	r3, [r5, #0]
            result += expr_level_2(e);
    65dc:	4628      	mov	r0, r5
        if (get(e) == '+')
    65de:	d102      	bne.n	65e6 <expr_level_1+0x2a>
            result += expr_level_2(e);
    65e0:	47b0      	blx	r6
    65e2:	4404      	add	r4, r0
    65e4:	e7ef      	b.n	65c6 <expr_level_1+0xa>
            result -= expr_level_2(e);
    65e6:	47b0      	blx	r6
    65e8:	1a24      	subs	r4, r4, r0
    65ea:	e7ec      	b.n	65c6 <expr_level_1+0xa>
    65ec:	00006569 	.word	0x00006569

000065f0 <insertTo>:


    return expression_inner(&str);
}

void insertTo(char* start,int length,char* that){
    65f0:	b570      	push	{r4, r5, r6, lr}
    65f2:	b09a      	sub	sp, #104	; 0x68
    65f4:	4604      	mov	r4, r0
    
    char ending[100] = {0};
    65f6:	4b0b      	ldr	r3, [pc, #44]	; (6624 <insertTo+0x34>)
void insertTo(char* start,int length,char* that){
    65f8:	4615      	mov	r5, r2
    65fa:	460e      	mov	r6, r1
    char ending[100] = {0};
    65fc:	2260      	movs	r2, #96	; 0x60
    65fe:	2100      	movs	r1, #0
    6600:	a802      	add	r0, sp, #8
    6602:	9101      	str	r1, [sp, #4]
    6604:	4798      	blx	r3
    
    //printf("insertTo: Hova: %s Milyen hosszú helyre: %d Mit: %s\n", start, length, that);
    
    sprintf(ending,"%s",start+length);
    6606:	19a1      	adds	r1, r4, r6
    6608:	a801      	add	r0, sp, #4
    660a:	4e07      	ldr	r6, [pc, #28]	; (6628 <insertTo+0x38>)
    660c:	47b0      	blx	r6
    sprintf(start,"%s",that);
    660e:	4629      	mov	r1, r5
    6610:	4620      	mov	r0, r4
    6612:	47b0      	blx	r6
    sprintf(start+strlen(that),"%s",ending);
    6614:	4b05      	ldr	r3, [pc, #20]	; (662c <insertTo+0x3c>)
    6616:	4628      	mov	r0, r5
    6618:	4798      	blx	r3
    661a:	a901      	add	r1, sp, #4
    661c:	4420      	add	r0, r4
    661e:	47b0      	blx	r6
}
    6620:	b01a      	add	sp, #104	; 0x68
    6622:	bd70      	pop	{r4, r5, r6, pc}
    6624:	00014175 	.word	0x00014175
    6628:	00014bbd 	.word	0x00014bbd
    662c:	00014c81 	.word	0x00014c81

00006630 <brack_len>:
        // START: SUKU
    
    int nyitCount = 0;
    int zarCount = 0;
    
    for(int i=0; i<maxLen; i++){
    6630:	2300      	movs	r3, #0
int brack_len(char* funcDesc,int maxLen){ //pl.: almafa(6*(2+2))*45
    6632:	b530      	push	{r4, r5, lr}
    int nyitCount = 0;
    6634:	461a      	mov	r2, r3
    int zarCount = 0;
    6636:	461c      	mov	r4, r3
    for(int i=0; i<maxLen; i++){
    6638:	428b      	cmp	r3, r1
    663a:	da0c      	bge.n	6656 <brack_len+0x26>
        
        if (funcDesc[i] == '('){
    663c:	5cc5      	ldrb	r5, [r0, r3]
    663e:	2d28      	cmp	r5, #40	; 0x28
    6640:	f103 0301 	add.w	r3, r3, #1
    6644:	d101      	bne.n	664a <brack_len+0x1a>
            
            nyitCount++;
    6646:	3201      	adds	r2, #1
    6648:	e7f6      	b.n	6638 <brack_len+0x8>
        }
        else if (funcDesc[i] == ')'){
    664a:	2d29      	cmp	r5, #41	; 0x29
    664c:	d1f4      	bne.n	6638 <brack_len+0x8>
            zarCount++;
    664e:	3401      	adds	r4, #1
            
            if (zarCount == nyitCount){
    6650:	42a2      	cmp	r2, r4
    6652:	d1f1      	bne.n	6638 <brack_len+0x8>
                return i+1;
    6654:	4618      	mov	r0, r3
            }
        }
        
    }
}
    6656:	bd30      	pop	{r4, r5, pc}

00006658 <calcSubFnc>:



void calcSubFnc(char* startposition){
    6658:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    uint8_t debug_level = 0; 

    char* fName = startposition;
    char* fNameEnd = strstr(fName,"(");
    665c:	4b82      	ldr	r3, [pc, #520]	; (6868 <calcSubFnc+0x210>)
void calcSubFnc(char* startposition){
    665e:	b0ab      	sub	sp, #172	; 0xac
    char* fNameEnd = strstr(fName,"(");
    6660:	2128      	movs	r1, #40	; 0x28
void calcSubFnc(char* startposition){
    6662:	4680      	mov	r8, r0
    char* fNameEnd = strstr(fName,"(");
    6664:	4798      	blx	r3


    if (debug_level) printf("FNC name: ");
    if (debug_level) delay_ms(1);

    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6666:	eba0 0208 	sub.w	r2, r0, r8
    char* fNameEnd = strstr(fName,"(");
    666a:	4681      	mov	r9, r0
    for(uint8_t i=0; i<fNameEnd-fName; i++){
    666c:	2300      	movs	r3, #0
    666e:	9200      	str	r2, [sp, #0]
    6670:	9900      	ldr	r1, [sp, #0]
    6672:	b2da      	uxtb	r2, r3
    6674:	428a      	cmp	r2, r1
    6676:	f103 0301 	add.w	r3, r3, #1
    667a:	dbf9      	blt.n	6670 <calcSubFnc+0x18>
    }

    if (debug_level) printf("\r\n");
    if (debug_level) delay_ms(1);
    
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    667c:	4b7b      	ldr	r3, [pc, #492]	; (686c <calcSubFnc+0x214>)
    
    if (debug_level) printf("calcSubFnc Maxoffset: %d  ## \r\n", max_offset);
    if (debug_level) delay_ms(5);;
    
    int param_expr_results[10] = {0};
    667e:	4f7c      	ldr	r7, [pc, #496]	; (6870 <calcSubFnc+0x218>)
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6680:	4648      	mov	r0, r9
    6682:	4798      	blx	r3
    6684:	4b7b      	ldr	r3, [pc, #492]	; (6874 <calcSubFnc+0x21c>)
    6686:	4601      	mov	r1, r0
    6688:	4648      	mov	r0, r9
    668a:	4798      	blx	r3
    int param_expr_results[10] = {0};
    668c:	2228      	movs	r2, #40	; 0x28
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    668e:	1e86      	subs	r6, r0, #2
    int param_expr_results[10] = {0};
    6690:	2100      	movs	r1, #0
    6692:	a807      	add	r0, sp, #28
    6694:	47b8      	blx	r7
    char* comma = strstr(start, ",");
    int commaoffset = -1;
    
    
    
    for (int i=0; i<max_offset; i=i){
    6696:	2500      	movs	r5, #0
    int param_expr_results_count = 0;
    6698:	462c      	mov	r4, r5
    for (int i=0; i<max_offset; i=i){
    669a:	42b5      	cmp	r5, r6
    669c:	da2a      	bge.n	66f4 <calcSubFnc+0x9c>
    669e:	eb09 0a05 	add.w	sl, r9, r5
    66a2:	4652      	mov	r2, sl
    66a4:	46ab      	mov	fp, r5
        
        int commaoffset = -1;
        
        for(int j=i; j<max_offset; j++){
            
            if (start[j] == ','){
    66a6:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    66aa:	f8cd b004 	str.w	fp, [sp, #4]
    66ae:	292c      	cmp	r1, #44	; 0x2c
    66b0:	f10b 0b01 	add.w	fp, fp, #1
    66b4:	f000 80cc 	beq.w	6850 <calcSubFnc+0x1f8>
        for(int j=i; j<max_offset; j++){
    66b8:	455e      	cmp	r6, fp
    66ba:	dcf4      	bgt.n	66a6 <calcSubFnc+0x4e>
 
        if (commaoffset==-1){
            
           // printf("No more commas! \r\n");
            
            char param_expr[20] = {0};
    66bc:	f04f 0900 	mov.w	r9, #0
    66c0:	4649      	mov	r1, r9
    66c2:	2210      	movs	r2, #16
    66c4:	a812      	add	r0, sp, #72	; 0x48
    66c6:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
            
            for (int j=0; j<(max_offset-i); j++){
    66ca:	1b75      	subs	r5, r6, r5
            char param_expr[20] = {0};
    66cc:	47b8      	blx	r7
            for (int j=0; j<(max_offset-i); j++){
    66ce:	4649      	mov	r1, r9
    66d0:	ab11      	add	r3, sp, #68	; 0x44
    66d2:	e003      	b.n	66dc <calcSubFnc+0x84>
                param_expr[j] = start[i+j];
    66d4:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
    66d8:	545a      	strb	r2, [r3, r1]
            for (int j=0; j<(max_offset-i); j++){
    66da:	3101      	adds	r1, #1
    66dc:	428d      	cmp	r5, r1
    66de:	dcf9      	bgt.n	66d4 <calcSubFnc+0x7c>
            }
            
            if (debug_level) printf("Parameter: \"%s\", ", param_expr);
            if (debug_level) delay_ms(2);
            
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66e0:	9304      	str	r3, [sp, #16]
    int result = expr_level_0(e);
    66e2:	a804      	add	r0, sp, #16
    66e4:	4b64      	ldr	r3, [pc, #400]	; (6878 <calcSubFnc+0x220>)
    66e6:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66e8:	ab2a      	add	r3, sp, #168	; 0xa8
    66ea:	eb03 0384 	add.w	r3, r3, r4, lsl #2
            
            
            if (debug_level) printf("Result: \"%d\" \r\n", param_expr_results[param_expr_results_count]);
            if (debug_level) delay_ms(2);
            
            param_expr_results_count++;
    66ee:	3401      	adds	r4, #1
            param_expr_results[param_expr_results_count] = expression(param_expr);
    66f0:	f843 0c8c 	str.w	r0, [r3, #-140]
    
    
    // START: CALC BUILTIN


    char justName[10] = {0};
    66f4:	2300      	movs	r3, #0
    66f6:	aa04      	add	r2, sp, #16
    66f8:	e9cd 3304 	strd	r3, r3, [sp, #16]
    66fc:	f8ad 3018 	strh.w	r3, [sp, #24]
    
    for (int i=0; i<9; i++){
    6700:	f108 0008 	add.w	r0, r8, #8
    6704:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    6708:	4693      	mov	fp, r2
        
        if (fName[i] == '('){
    670a:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    670e:	2928      	cmp	r1, #40	; 0x28
    6710:	d127      	bne.n	6762 <calcSubFnc+0x10a>
        }
        
    }

    
    if(strcmp(justName,"abs")==0){
    6712:	495a      	ldr	r1, [pc, #360]	; (687c <calcSubFnc+0x224>)
    6714:	4d5a      	ldr	r5, [pc, #360]	; (6880 <calcSubFnc+0x228>)
    6716:	f8df a19c 	ldr.w	sl, [pc, #412]	; 68b4 <calcSubFnc+0x25c>
    671a:	4658      	mov	r0, fp
    671c:	47a8      	blx	r5
    671e:	f10d 0944 	add.w	r9, sp, #68	; 0x44
    6722:	b318      	cbz	r0, 676c <calcSubFnc+0x114>
        resultOfFnc = abs(param_expr_results[0]);
    }
    else if(strcmp(justName,"six")==0){
    6724:	4957      	ldr	r1, [pc, #348]	; (6884 <calcSubFnc+0x22c>)
    6726:	4658      	mov	r0, fp
    6728:	47a8      	blx	r5
    672a:	2800      	cmp	r0, #0
    672c:	f000 808e 	beq.w	684c <calcSubFnc+0x1f4>
        resultOfFnc = 666666;
    }
    else if(strcmp(justName,"add")==0){
    6730:	4955      	ldr	r1, [pc, #340]	; (6888 <calcSubFnc+0x230>)
    6732:	4658      	mov	r0, fp
    6734:	47a8      	blx	r5
    6736:	2800      	cmp	r0, #0
    6738:	d130      	bne.n	679c <calcSubFnc+0x144>
        resultOfFnc = param_expr_results[0] + param_expr_results[1];
    673a:	e9dd 5307 	ldrd	r5, r3, [sp, #28]
    673e:	441d      	add	r5, r3
    6740:	e018      	b.n	6774 <calcSubFnc+0x11c>
                param_expr[j] = start[i+j];
    6742:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
    6746:	5488      	strb	r0, [r1, r2]
            for (int j=0; j<commaoffset-i; j++){
    6748:	3201      	adds	r2, #1
    674a:	4295      	cmp	r5, r2
    674c:	dcf9      	bgt.n	6742 <calcSubFnc+0xea>
    int result = expr_level_0(e);
    674e:	4b4a      	ldr	r3, [pc, #296]	; (6878 <calcSubFnc+0x220>)
    6750:	9104      	str	r1, [sp, #16]
    6752:	a804      	add	r0, sp, #16
    6754:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6756:	ab07      	add	r3, sp, #28
    6758:	465d      	mov	r5, fp
    675a:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
            param_expr_results_count++;
    675e:	3401      	adds	r4, #1
    for (int i=0; i<max_offset; i=i){
    6760:	e79b      	b.n	669a <calcSubFnc+0x42>
    for (int i=0; i<9; i++){
    6762:	4283      	cmp	r3, r0
            justName[i] = fName[i];
    6764:	f802 1b01 	strb.w	r1, [r2], #1
    for (int i=0; i<9; i++){
    6768:	d1cf      	bne.n	670a <calcSubFnc+0xb2>
    676a:	e7d2      	b.n	6712 <calcSubFnc+0xba>
        resultOfFnc = abs(param_expr_results[0]);
    676c:	9d07      	ldr	r5, [sp, #28]
    676e:	2d00      	cmp	r5, #0
    6770:	bfb8      	it	lt
    6772:	426d      	neglt	r5, r5
    
    //printf("resultOfFnc: %d\n", resultOfFnc);
    

    
    char buff[100] = {0};
    6774:	2100      	movs	r1, #0
    6776:	2260      	movs	r2, #96	; 0x60
    6778:	a812      	add	r0, sp, #72	; 0x48
    677a:	9111      	str	r1, [sp, #68]	; 0x44
    677c:	47b8      	blx	r7
    
    sprintf(buff,"(%d)",resultOfFnc); //HEX para, sign para
    677e:	462a      	mov	r2, r5
    6780:	4942      	ldr	r1, [pc, #264]	; (688c <calcSubFnc+0x234>)
    6782:	4648      	mov	r0, r9
    6784:	47d0      	blx	sl
    
    // hova, milyen hosszan, mit
    insertTo(startposition,(fNameEnd-fName)+max_offset+2,buff);
    6786:	9b00      	ldr	r3, [sp, #0]
    6788:	4433      	add	r3, r6
    678a:	4619      	mov	r1, r3
    678c:	464a      	mov	r2, r9
    678e:	4b40      	ldr	r3, [pc, #256]	; (6890 <calcSubFnc+0x238>)
    6790:	3102      	adds	r1, #2
    6792:	4640      	mov	r0, r8
    6794:	4798      	blx	r3
    
        
    //printf(" @@ debug: %s @@\n", startposition);
}
    6796:	b02b      	add	sp, #172	; 0xac
    6798:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    679c:	493d      	ldr	r1, [pc, #244]	; (6894 <calcSubFnc+0x23c>)
    679e:	4658      	mov	r0, fp
    67a0:	47a8      	blx	r5
    67a2:	b120      	cbz	r0, 67ae <calcSubFnc+0x156>
    67a4:	493c      	ldr	r1, [pc, #240]	; (6898 <calcSubFnc+0x240>)
    67a6:	4658      	mov	r0, fp
    67a8:	47a8      	blx	r5
    67aa:	2800      	cmp	r0, #0
    67ac:	d13e      	bne.n	682c <calcSubFnc+0x1d4>
        char fmt_str[] = "%02x";
    67ae:	4b3b      	ldr	r3, [pc, #236]	; (689c <calcSubFnc+0x244>)
        if (param_expr_results_count>1){
    67b0:	2c01      	cmp	r4, #1
        char fmt_str[] = "%02x";
    67b2:	6818      	ldr	r0, [r3, #0]
    67b4:	791b      	ldrb	r3, [r3, #4]
    67b6:	9002      	str	r0, [sp, #8]
    67b8:	f88d 300c 	strb.w	r3, [sp, #12]
        if (param_expr_results_count>1){
    67bc:	dd0a      	ble.n	67d4 <calcSubFnc+0x17c>
            if (param_expr_results[param_expr_results_count-1]<=8){
    67be:	ab2a      	add	r3, sp, #168	; 0xa8
    67c0:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    67c4:	f853 3c90 	ldr.w	r3, [r3, #-144]
    67c8:	2b08      	cmp	r3, #8
                fmt_str[2] = param_expr_results[param_expr_results_count-1]+'0';
    67ca:	bfd4      	ite	le
    67cc:	3330      	addle	r3, #48	; 0x30
                fmt_str[2] = 8+'0';
    67ce:	2338      	movgt	r3, #56	; 0x38
    67d0:	f88d 300a 	strb.w	r3, [sp, #10]
        uint8_t temp_array[20] = {0};
    67d4:	2100      	movs	r1, #0
    67d6:	2210      	movs	r2, #16
    67d8:	a812      	add	r0, sp, #72	; 0x48
    67da:	9111      	str	r1, [sp, #68]	; 0x44
    67dc:	47b8      	blx	r7
        sprintf(temp_array, fmt_str, param_expr_results[0]);
    67de:	9d07      	ldr	r5, [sp, #28]
    67e0:	a902      	add	r1, sp, #8
    67e2:	462a      	mov	r2, r5
    67e4:	4648      	mov	r0, r9
    67e6:	47d0      	blx	sl
        if (param_expr_results_count>1){
    67e8:	2c01      	cmp	r4, #1
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67ea:	4a2d      	ldr	r2, [pc, #180]	; (68a0 <calcSubFnc+0x248>)
            temp_array_length = param_expr_results[param_expr_results_count-1];
    67ec:	bfc4      	itt	gt
    67ee:	ab2a      	addgt	r3, sp, #168	; 0xa8
    67f0:	eb03 0484 	addgt.w	r4, r3, r4, lsl #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67f4:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
            temp_array_length = param_expr_results[param_expr_results_count-1];
    67f8:	bfc8      	it	gt
    67fa:	f814 1c90 	ldrbgt.w	r1, [r4, #-144]
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    67fe:	b2d8      	uxtb	r0, r3
    6800:	f5c3 73fc 	rsb	r3, r3, #504	; 0x1f8
            temp_array_length = 2; // default print length
    6804:	bfd8      	it	le
    6806:	2102      	movle	r1, #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6808:	3301      	adds	r3, #1
    680a:	1a5b      	subs	r3, r3, r1
    680c:	4413      	add	r3, r2
        for (uint8_t i=0; i<temp_array_length; i++){
    680e:	2400      	movs	r4, #0
    6810:	fa5f fc84 	uxtb.w	ip, r4
    6814:	458c      	cmp	ip, r1
    6816:	d303      	bcc.n	6820 <calcSubFnc+0x1c8>
        expr->output_string_length += temp_array_length;
    6818:	4401      	add	r1, r0
    681a:	f882 11fa 	strb.w	r1, [r2, #506]	; 0x1fa
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    681e:	e7a9      	b.n	6774 <calcSubFnc+0x11c>
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6820:	f819 c004 	ldrb.w	ip, [r9, r4]
    6824:	f803 cb01 	strb.w	ip, [r3], #1
        for (uint8_t i=0; i<temp_array_length; i++){
    6828:	3401      	adds	r4, #1
    682a:	e7f1      	b.n	6810 <calcSubFnc+0x1b8>
    else if(strcmp(justName,"if")==0){
    682c:	491d      	ldr	r1, [pc, #116]	; (68a4 <calcSubFnc+0x24c>)
    682e:	4658      	mov	r0, fp
    6830:	47a8      	blx	r5
    6832:	b928      	cbnz	r0, 6840 <calcSubFnc+0x1e8>
        if (param_expr_results[0]){
    6834:	9b07      	ldr	r3, [sp, #28]
    6836:	b10b      	cbz	r3, 683c <calcSubFnc+0x1e4>
            resultOfFnc = param_expr_results[1];
    6838:	9d08      	ldr	r5, [sp, #32]
    683a:	e79b      	b.n	6774 <calcSubFnc+0x11c>
            resultOfFnc = param_expr_results[2];
    683c:	9d09      	ldr	r5, [sp, #36]	; 0x24
    683e:	e799      	b.n	6774 <calcSubFnc+0x11c>
        printf("Function \"%s\" not found!\n", justName);
    6840:	4819      	ldr	r0, [pc, #100]	; (68a8 <calcSubFnc+0x250>)
    6842:	4b1a      	ldr	r3, [pc, #104]	; (68ac <calcSubFnc+0x254>)
    6844:	4659      	mov	r1, fp
    6846:	4798      	blx	r3
        resultOfFnc = 0;
    6848:	2500      	movs	r5, #0
    684a:	e793      	b.n	6774 <calcSubFnc+0x11c>
        resultOfFnc = 666666;
    684c:	4d18      	ldr	r5, [pc, #96]	; (68b0 <calcSubFnc+0x258>)
    684e:	e791      	b.n	6774 <calcSubFnc+0x11c>
            char param_expr[20] = {0};
    6850:	2300      	movs	r3, #0
    6852:	4619      	mov	r1, r3
    6854:	9311      	str	r3, [sp, #68]	; 0x44
    6856:	2210      	movs	r2, #16
    6858:	4b05      	ldr	r3, [pc, #20]	; (6870 <calcSubFnc+0x218>)
    685a:	a812      	add	r0, sp, #72	; 0x48
    685c:	4798      	blx	r3
            for (int j=0; j<commaoffset-i; j++){
    685e:	9b01      	ldr	r3, [sp, #4]
    6860:	2200      	movs	r2, #0
    6862:	1b5d      	subs	r5, r3, r5
    6864:	a911      	add	r1, sp, #68	; 0x44
    6866:	e770      	b.n	674a <calcSubFnc+0xf2>
    6868:	00014815 	.word	0x00014815
    686c:	00014c81 	.word	0x00014c81
    6870:	00014175 	.word	0x00014175
    6874:	00006631 	.word	0x00006631
    6878:	00006451 	.word	0x00006451
    687c:	00016861 	.word	0x00016861
    6880:	000148e9 	.word	0x000148e9
    6884:	00016865 	.word	0x00016865
    6888:	00016869 	.word	0x00016869
    688c:	00016890 	.word	0x00016890
    6890:	000065f1 	.word	0x000065f1
    6894:	0001686d 	.word	0x0001686d
    6898:	0001742a 	.word	0x0001742a
    689c:	00016895 	.word	0x00016895
    68a0:	2000bc3c 	.word	0x2000bc3c
    68a4:	00016873 	.word	0x00016873
    68a8:	00016876 	.word	0x00016876
    68ac:	000143b9 	.word	0x000143b9
    68b0:	000a2c2a 	.word	0x000a2c2a
    68b4:	000147d1 	.word	0x000147d1

000068b8 <char_is_valid_name>:


uint8_t char_is_valid_name(uint8_t ch){


    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_')){
    68b8:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    68bc:	2b09      	cmp	r3, #9
    68be:	d909      	bls.n	68d4 <char_is_valid_name+0x1c>
    68c0:	f020 0320 	bic.w	r3, r0, #32
    68c4:	3b41      	subs	r3, #65	; 0x41
    68c6:	2b19      	cmp	r3, #25
    68c8:	d904      	bls.n	68d4 <char_is_valid_name+0x1c>

                    return 1;
    68ca:	f1a0 035f 	sub.w	r3, r0, #95	; 0x5f
    68ce:	4258      	negs	r0, r3
    68d0:	4158      	adcs	r0, r3
    68d2:	4770      	bx	lr
    68d4:	2001      	movs	r0, #1
                }
    
    return 0;


}
    68d6:	4770      	bx	lr

000068d8 <subst_all_variables_starting_from_the_back>:


void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    68dc:	ed2d 8b02 	vpush	{d8}
    uint8_t variable_name_valid = 0;
    

    int izgi = 0;
    int var_end_pos = -1;
    char var_name[10] = {0};
    68e0:	2200      	movs	r2, #0
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68e2:	b0a1      	sub	sp, #132	; 0x84
    char var_name[10] = {0};
    68e4:	e9cd 2201 	strd	r2, r2, [sp, #4]
    68e8:	f8df a23c 	ldr.w	sl, [pc, #572]	; 6b28 <subst_all_variables_starting_from_the_back+0x250>
    68ec:	f8ad 200c 	strh.w	r2, [sp, #12]
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    68f0:	460d      	mov	r5, r1
    68f2:	1846      	adds	r6, r0, r1
    int var_end_pos = -1;
    68f4:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    uint8_t variable_name_found = 0;
    68f8:	4611      	mov	r1, r2
    uint8_t function_name_found = 0;
    68fa:	4691      	mov	r9, r2
    
    if (debug_level) printf("Subst Vars\r\n");
    
    // i must be signed int
    for(int i = len; i>=0; i--){
    68fc:	2d00      	cmp	r5, #0
    68fe:	da04      	bge.n	690a <subst_all_variables_starting_from_the_back+0x32>
    if (debug_level ==2) printf("i%d %d %d %d\r\n",i, function_name_found, variable_name_found, variable_name_valid);
    if (debug_level ==2) delay_ms(5);
        
    }
    
}
    6900:	b021      	add	sp, #132	; 0x84
    6902:	ecbd 8b02 	vpop	{d8}
    6906:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (function_name_found){
    690a:	ee08 6a10 	vmov	s16, r6
    690e:	f816 4901 	ldrb.w	r4, [r6], #-1
    6912:	4620      	mov	r0, r4
    6914:	47d0      	blx	sl
    6916:	f1b9 0f00 	cmp.w	r9, #0
    691a:	d011      	beq.n	6940 <subst_all_variables_starting_from_the_back+0x68>
                function_name_found=0;
    691c:	f1b0 0900 	subs.w	r9, r0, #0
    6920:	bf18      	it	ne
    6922:	f04f 0901 	movne.w	r9, #1
        if (variable_name_found){
    6926:	2900      	cmp	r1, #0
    6928:	d144      	bne.n	69b4 <subst_all_variables_starting_from_the_back+0xdc>
                for (int j = 0; j<10; j++){
    692a:	2300      	movs	r3, #0
    692c:	aa01      	add	r2, sp, #4
                var_name[j] = 0;
    692e:	4619      	mov	r1, r3
            for (int j = 0; j<10; j++){
    6930:	3301      	adds	r3, #1
    6932:	2b0a      	cmp	r3, #10
                var_name[j] = 0;
    6934:	f802 1b01 	strb.w	r1, [r2], #1
            for (int j = 0; j<10; j++){
    6938:	d1fa      	bne.n	6930 <subst_all_variables_starting_from_the_back+0x58>
            variable_name_valid = 0;
    693a:	2200      	movs	r2, #0
            variable_name_found = 0;
    693c:	4611      	mov	r1, r2
    693e:	e04c      	b.n	69da <subst_all_variables_starting_from_the_back+0x102>
        else if (variable_name_found == 0){
    6940:	2900      	cmp	r1, #0
    6942:	d137      	bne.n	69b4 <subst_all_variables_starting_from_the_back+0xdc>
            if  (char_is_valid_name(expr_string[i])){
    6944:	2800      	cmp	r0, #0
    6946:	d0f0      	beq.n	692a <subst_all_variables_starting_from_the_back+0x52>
                if (expr_string[i+1] == '('){
    6948:	78b3      	ldrb	r3, [r6, #2]
    694a:	2b28      	cmp	r3, #40	; 0x28
    694c:	f000 80cd 	beq.w	6aea <subst_all_variables_starting_from_the_back+0x212>
                    if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6950:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
                        variable_name_valid = 1; 
    6954:	2b09      	cmp	r3, #9
    6956:	bf88      	it	hi
    6958:	2201      	movhi	r2, #1
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    695a:	46ab      	mov	fp, r5
                var_name[var_end_pos-i] = expr_string[i];
    695c:	ebab 0305 	sub.w	r3, fp, r5
    6960:	a920      	add	r1, sp, #128	; 0x80
    6962:	440b      	add	r3, r1
    6964:	f803 4c7c 	strb.w	r4, [r3, #-124]
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6968:	3c30      	subs	r4, #48	; 0x30
    696a:	2c09      	cmp	r4, #9
    696c:	d924      	bls.n	69b8 <subst_all_variables_starting_from_the_back+0xe0>
                if (i==0){
    696e:	b125      	cbz	r5, 697a <subst_all_variables_starting_from_the_back+0xa2>
                    if (!char_is_valid_name(expr_string[i-1])){
    6970:	7830      	ldrb	r0, [r6, #0]
    6972:	47d0      	blx	sl
    6974:	2800      	cmp	r0, #0
    6976:	f040 80b6 	bne.w	6ae6 <subst_all_variables_starting_from_the_back+0x20e>
                    int var_name_len = strlen(var_name);
    697a:	4b5e      	ldr	r3, [pc, #376]	; (6af4 <subst_all_variables_starting_from_the_back+0x21c>)
    697c:	a801      	add	r0, sp, #4
    697e:	4798      	blx	r3
                    char var_name_good[10] = {0};
    6980:	2300      	movs	r3, #0
    6982:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6986:	aa01      	add	r2, sp, #4
                    int var_name_len = strlen(var_name);
    6988:	4680      	mov	r8, r0
                    char var_name_good[10] = {0};
    698a:	4402      	add	r2, r0
    698c:	f8ad 3018 	strh.w	r3, [sp, #24]
                    for (int j = 0; j<var_name_len; j++){
    6990:	a904      	add	r1, sp, #16
                        var_name_good[j+1] = 0;
    6992:	4618      	mov	r0, r3
                    for (int j = 0; j<var_name_len; j++){
    6994:	4543      	cmp	r3, r8
    6996:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
    699a:	db20      	blt.n	69de <subst_all_variables_starting_from_the_back+0x106>
                    if (var_name_len == 2 || var_name_len == 3){
    699c:	f1a8 0302 	sub.w	r3, r8, #2
    69a0:	2b01      	cmp	r3, #1
    69a2:	d864      	bhi.n	6a6e <subst_all_variables_starting_from_the_back+0x196>
                        if (var_name_good[0] == 'T'){
    69a4:	f89d 3010 	ldrb.w	r3, [sp, #16]
    69a8:	2b54      	cmp	r3, #84	; 0x54
    69aa:	d15e      	bne.n	6a6a <subst_all_variables_starting_from_the_back+0x192>
                            for (uint8_t j = 1; j<var_name_len; j++){
    69ac:	2301      	movs	r3, #1
                            uint8_t index = 0;
    69ae:	2200      	movs	r2, #0
                            uint8_t is_template_var = 1;
    69b0:	4618      	mov	r0, r3
    69b2:	e02d      	b.n	6a10 <subst_all_variables_starting_from_the_back+0x138>
            if (char_is_valid_name(expr_string[i])){
    69b4:	2800      	cmp	r0, #0
    69b6:	d1d1      	bne.n	695c <subst_all_variables_starting_from_the_back+0x84>
            if (variable_name_valid){
    69b8:	2a00      	cmp	r2, #0
    69ba:	d1d8      	bne.n	696e <subst_all_variables_starting_from_the_back+0x96>
    69bc:	2401      	movs	r4, #1
            if (!char_is_valid_name(expr_string[i])){
    69be:	7870      	ldrb	r0, [r6, #1]
    69c0:	47d0      	blx	sl
    69c2:	4601      	mov	r1, r0
    69c4:	2800      	cmp	r0, #0
    69c6:	f040 8093 	bne.w	6af0 <subst_all_variables_starting_from_the_back+0x218>
    69ca:	aa01      	add	r2, sp, #4
                for (int j = 0; j<10; j++){
    69cc:	4603      	mov	r3, r0
    69ce:	3301      	adds	r3, #1
    69d0:	2b0a      	cmp	r3, #10
                    var_name[j] = 0;
    69d2:	f802 0b01 	strb.w	r0, [r2], #1
                for (int j = 0; j<10; j++){
    69d6:	d1fa      	bne.n	69ce <subst_all_variables_starting_from_the_back+0xf6>
                variable_name_valid = 0;
    69d8:	2200      	movs	r2, #0
    for(int i = len; i>=0; i--){
    69da:	3d01      	subs	r5, #1
    69dc:	e78e      	b.n	68fc <subst_all_variables_starting_from_the_back+0x24>
                        var_name_good[j] = var_name[var_name_len-1-j];
    69de:	7814      	ldrb	r4, [r2, #0]
    69e0:	700c      	strb	r4, [r1, #0]
                        var_name_good[j+1] = 0;
    69e2:	3301      	adds	r3, #1
    69e4:	f801 0f01 	strb.w	r0, [r1, #1]!
                    for (int j = 0; j<var_name_len; j++){
    69e8:	e7d4      	b.n	6994 <subst_all_variables_starting_from_the_back+0xbc>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    69ea:	a920      	add	r1, sp, #128	; 0x80
    69ec:	4419      	add	r1, r3
                            for (uint8_t j = 1; j<var_name_len; j++){
    69ee:	3301      	adds	r3, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    69f0:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    69f4:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    69f8:	2c09      	cmp	r4, #9
                                    index = index*10;
    69fa:	bf9f      	itttt	ls
    69fc:	eb02 0282 	addls.w	r2, r2, r2, lsl #2
    6a00:	eb01 0242 	addls.w	r2, r1, r2, lsl #1
                                    index += var_name_good[j] - '0'; 
    6a04:	3a30      	subls	r2, #48	; 0x30
    6a06:	f002 02ff 	andls.w	r2, r2, #255	; 0xff
                                    is_template_var = 0;
    6a0a:	bf88      	it	hi
    6a0c:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a0e:	b2db      	uxtb	r3, r3
    6a10:	4543      	cmp	r3, r8
    6a12:	dbea      	blt.n	69ea <subst_all_variables_starting_from_the_back+0x112>
                            if (is_template_var){
    6a14:	b358      	cbz	r0, 6a6e <subst_all_variables_starting_from_the_back+0x196>
                                variable_value = grid_expr_state.current_event->parent->template_parameter_list[index];
    6a16:	4b38      	ldr	r3, [pc, #224]	; (6af8 <subst_all_variables_starting_from_the_back+0x220>)
    6a18:	681b      	ldr	r3, [r3, #0]
    6a1a:	685b      	ldr	r3, [r3, #4]
    6a1c:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    6a20:	68d4      	ldr	r4, [r2, #12]
                    char buff[100] = {0};
    6a22:	4b36      	ldr	r3, [pc, #216]	; (6afc <subst_all_variables_starting_from_the_back+0x224>)
    6a24:	2700      	movs	r7, #0
    6a26:	2260      	movs	r2, #96	; 0x60
    6a28:	4639      	mov	r1, r7
    6a2a:	a808      	add	r0, sp, #32
    6a2c:	9707      	str	r7, [sp, #28]
    6a2e:	4798      	blx	r3
                    sprintf(buff,"%d",variable_value); // HEX para
    6a30:	4933      	ldr	r1, [pc, #204]	; (6b00 <subst_all_variables_starting_from_the_back+0x228>)
    6a32:	4b34      	ldr	r3, [pc, #208]	; (6b04 <subst_all_variables_starting_from_the_back+0x22c>)
    6a34:	4622      	mov	r2, r4
    6a36:	a807      	add	r0, sp, #28
    6a38:	4798      	blx	r3
                    insertTo(found,var_name_len,buff);
    6a3a:	4b33      	ldr	r3, [pc, #204]	; (6b08 <subst_all_variables_starting_from_the_back+0x230>)
    6a3c:	aa07      	add	r2, sp, #28
    6a3e:	4641      	mov	r1, r8
    6a40:	ee18 0a10 	vmov	r0, s16
    6a44:	4798      	blx	r3
                    for (int j = 0; j<10; j++){
    6a46:	ab01      	add	r3, sp, #4
                    insertTo(found,var_name_len,buff);
    6a48:	461a      	mov	r2, r3
                        var_name[j] = 0;
    6a4a:	4639      	mov	r1, r7
                    for (int j = 0; j<10; j++){
    6a4c:	3701      	adds	r7, #1
    6a4e:	2f0a      	cmp	r7, #10
                        var_name[j] = 0;
    6a50:	f802 1b01 	strb.w	r1, [r2], #1
                    for (int j = 0; j<10; j++){
    6a54:	d1fa      	bne.n	6a4c <subst_all_variables_starting_from_the_back+0x174>
                    for (int j = 0; j<10; j++){
    6a56:	2200      	movs	r2, #0
                        var_name[j] = 0;
    6a58:	4611      	mov	r1, r2
                    for (int j = 0; j<10; j++){
    6a5a:	3201      	adds	r2, #1
    6a5c:	2a0a      	cmp	r2, #10
                        var_name[j] = 0;
    6a5e:	f803 1b01 	strb.w	r1, [r3], #1
                    for (int j = 0; j<10; j++){
    6a62:	d1fa      	bne.n	6a5a <subst_all_variables_starting_from_the_back+0x182>
                    variable_name_valid = 0;
    6a64:	2200      	movs	r2, #0
    6a66:	4614      	mov	r4, r2
    6a68:	e7a9      	b.n	69be <subst_all_variables_starting_from_the_back+0xe6>
                        else if (var_name_good[0] == 'Z'){
    6a6a:	2b5a      	cmp	r3, #90	; 0x5a
    6a6c:	d01e      	beq.n	6aac <subst_all_variables_starting_from_the_back+0x1d4>
                    int32_t variable_value = 1;
    6a6e:	2401      	movs	r4, #1
    6a70:	e7d7      	b.n	6a22 <subst_all_variables_starting_from_the_back+0x14a>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6a72:	a920      	add	r1, sp, #128	; 0x80
    6a74:	4411      	add	r1, r2
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a76:	3201      	adds	r2, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6a78:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6a7c:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6a80:	2c09      	cmp	r4, #9
                                    index = index*10;
    6a82:	bf9f      	itttt	ls
    6a84:	eb03 0383 	addls.w	r3, r3, r3, lsl #2
    6a88:	eb01 0343 	addls.w	r3, r1, r3, lsl #1
                                    index += var_name_good[j] - '0'; 
    6a8c:	3b30      	subls	r3, #48	; 0x30
    6a8e:	f003 03ff 	andls.w	r3, r3, #255	; 0xff
                                    is_template_var = 0;
    6a92:	bf88      	it	hi
    6a94:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6a96:	b2d2      	uxtb	r2, r2
    6a98:	4542      	cmp	r2, r8
    6a9a:	dbea      	blt.n	6a72 <subst_all_variables_starting_from_the_back+0x19a>
                            if (is_template_var){
    6a9c:	2800      	cmp	r0, #0
    6a9e:	d0e6      	beq.n	6a6e <subst_all_variables_starting_from_the_back+0x196>
                                if (index == 0){
    6aa0:	b943      	cbnz	r3, 6ab4 <subst_all_variables_starting_from_the_back+0x1dc>
                                    variable_value = grid_sys_get_bank_num(&grid_sys_state);
    6aa2:	481a      	ldr	r0, [pc, #104]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6aa4:	4b1a      	ldr	r3, [pc, #104]	; (6b10 <subst_all_variables_starting_from_the_back+0x238>)
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6aa6:	4798      	blx	r3
    6aa8:	4604      	mov	r4, r0
    6aaa:	e7ba      	b.n	6a22 <subst_all_variables_starting_from_the_back+0x14a>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6aac:	2201      	movs	r2, #1
                            uint8_t index = 0;
    6aae:	2300      	movs	r3, #0
                            uint8_t is_template_var = 1;
    6ab0:	4610      	mov	r0, r2
    6ab2:	e7f1      	b.n	6a98 <subst_all_variables_starting_from_the_back+0x1c0>
                                else if (index == 1){
    6ab4:	2b01      	cmp	r3, #1
    6ab6:	d102      	bne.n	6abe <subst_all_variables_starting_from_the_back+0x1e6>
                                    variable_value = grid_sys_get_bank_red(&grid_sys_state);
    6ab8:	4814      	ldr	r0, [pc, #80]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6aba:	4b16      	ldr	r3, [pc, #88]	; (6b14 <subst_all_variables_starting_from_the_back+0x23c>)
    6abc:	e7f3      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 2){
    6abe:	2b02      	cmp	r3, #2
    6ac0:	d102      	bne.n	6ac8 <subst_all_variables_starting_from_the_back+0x1f0>
                                    variable_value = grid_sys_get_bank_gre(&grid_sys_state);
    6ac2:	4812      	ldr	r0, [pc, #72]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ac4:	4b14      	ldr	r3, [pc, #80]	; (6b18 <subst_all_variables_starting_from_the_back+0x240>)
    6ac6:	e7ee      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 3){
    6ac8:	2b03      	cmp	r3, #3
    6aca:	d102      	bne.n	6ad2 <subst_all_variables_starting_from_the_back+0x1fa>
                                    variable_value = grid_sys_get_bank_blu(&grid_sys_state);
    6acc:	480f      	ldr	r0, [pc, #60]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ace:	4b13      	ldr	r3, [pc, #76]	; (6b1c <subst_all_variables_starting_from_the_back+0x244>)
    6ad0:	e7e9      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 4){
    6ad2:	2b04      	cmp	r3, #4
    6ad4:	d102      	bne.n	6adc <subst_all_variables_starting_from_the_back+0x204>
                                    variable_value = grid_sys_get_map_state(&grid_sys_state);
    6ad6:	480d      	ldr	r0, [pc, #52]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ad8:	4b11      	ldr	r3, [pc, #68]	; (6b20 <subst_all_variables_starting_from_the_back+0x248>)
    6ada:	e7e4      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 5){
    6adc:	2b05      	cmp	r3, #5
    6ade:	d1c6      	bne.n	6a6e <subst_all_variables_starting_from_the_back+0x196>
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6ae0:	480a      	ldr	r0, [pc, #40]	; (6b0c <subst_all_variables_starting_from_the_back+0x234>)
    6ae2:	4b10      	ldr	r3, [pc, #64]	; (6b24 <subst_all_variables_starting_from_the_back+0x24c>)
    6ae4:	e7df      	b.n	6aa6 <subst_all_variables_starting_from_the_back+0x1ce>
    6ae6:	2201      	movs	r2, #1
    6ae8:	e7bd      	b.n	6a66 <subst_all_variables_starting_from_the_back+0x18e>
                    function_name_found = 1;                    
    6aea:	f04f 0901 	mov.w	r9, #1
    6aee:	e71c      	b.n	692a <subst_all_variables_starting_from_the_back+0x52>
    6af0:	4621      	mov	r1, r4
    6af2:	e772      	b.n	69da <subst_all_variables_starting_from_the_back+0x102>
    6af4:	00014c81 	.word	0x00014c81
    6af8:	2000bc3c 	.word	0x2000bc3c
    6afc:	00014175 	.word	0x00014175
    6b00:	00016aa1 	.word	0x00016aa1
    6b04:	000147d1 	.word	0x000147d1
    6b08:	000065f1 	.word	0x000065f1
    6b0c:	20007a24 	.word	0x20007a24
    6b10:	00009707 	.word	0x00009707
    6b14:	00009711 	.word	0x00009711
    6b18:	00009717 	.word	0x00009717
    6b1c:	0000971d 	.word	0x0000971d
    6b20:	00009723 	.word	0x00009723
    6b24:	00009727 	.word	0x00009727
    6b28:	000068b9 	.word	0x000068b9

00006b2c <subst_all_functions_starting_from_the_back>:



void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6b2c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    if (debug_level) printf("Subst Fncs in %s\r\n", expr_string);
    if (debug_level) delay_ms(5);
    
    uint8_t function_name_found = 0;
    uint8_t function_name_valid = 0;
    6b30:	2200      	movs	r2, #0

            
        }
        else if (function_name_found){
            
            if (char_is_valid_name(expr_string[i])){
    6b32:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6b9c <subst_all_functions_starting_from_the_back+0x70>
                //printf("izgi=%d, i=%d\n", izgi, i);  
                
            }
            else if (function_name_valid){
                
                calcSubFnc(&expr_string[i+1]);
    6b36:	4f18      	ldr	r7, [pc, #96]	; (6b98 <subst_all_functions_starting_from_the_back+0x6c>)
    6b38:	1844      	adds	r4, r0, r1
void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6b3a:	4605      	mov	r5, r0
    uint8_t function_name_found = 0;
    6b3c:	4611      	mov	r1, r2
    for(int i= len; i>=0; i--){
    6b3e:	ebb4 0a05 	subs.w	sl, r4, r5
    6b42:	d501      	bpl.n	6b48 <subst_all_functions_starting_from_the_back+0x1c>

        if (debug_level) printf("i%d %d %d\r\n",i, function_name_found, function_name_valid);
        if (debug_level) delay_ms(1);
    }
    
}
    6b44:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (expr_string[i] == '(' && function_name_valid == 0){
    6b48:	7826      	ldrb	r6, [r4, #0]
    6b4a:	2e28      	cmp	r6, #40	; 0x28
    6b4c:	d100      	bne.n	6b50 <subst_all_functions_starting_from_the_back+0x24>
    6b4e:	b1e2      	cbz	r2, 6b8a <subst_all_functions_starting_from_the_back+0x5e>
        else if (function_name_found){
    6b50:	b1c9      	cbz	r1, 6b86 <subst_all_functions_starting_from_the_back+0x5a>
            if (char_is_valid_name(expr_string[i])){
    6b52:	4630      	mov	r0, r6
    6b54:	47c0      	blx	r8
    6b56:	4681      	mov	r9, r0
    6b58:	b158      	cbz	r0, 6b72 <subst_all_functions_starting_from_the_back+0x46>
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6b5a:	3e30      	subs	r6, #48	; 0x30
    6b5c:	2e09      	cmp	r6, #9
    6b5e:	d816      	bhi.n	6b8e <subst_all_functions_starting_from_the_back+0x62>
                if (i==0 && function_name_valid){ // start of expr string special case
    6b60:	f1ba 0f00 	cmp.w	sl, #0
    6b64:	d10f      	bne.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
    6b66:	b172      	cbz	r2, 6b86 <subst_all_functions_starting_from_the_back+0x5a>
                    calcSubFnc(&expr_string[i]);
    6b68:	4620      	mov	r0, r4
    6b6a:	47b8      	blx	r7
                    function_name_valid = 0;
    6b6c:	2200      	movs	r2, #0
                function_name_found = 0;
    6b6e:	4611      	mov	r1, r2
    6b70:	e009      	b.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
            else if (function_name_valid){
    6b72:	2a00      	cmp	r2, #0
    6b74:	d0fb      	beq.n	6b6e <subst_all_functions_starting_from_the_back+0x42>
                calcSubFnc(&expr_string[i+1]);
    6b76:	1c60      	adds	r0, r4, #1
    6b78:	47b8      	blx	r7
                function_name_found = (expr_string[i] == '(');
    6b7a:	7821      	ldrb	r1, [r4, #0]
    6b7c:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
    6b80:	4259      	negs	r1, r3
    6b82:	4159      	adcs	r1, r3
                function_name_valid = 0;
    6b84:	464a      	mov	r2, r9
    for(int i= len; i>=0; i--){
    6b86:	3c01      	subs	r4, #1
    6b88:	e7d9      	b.n	6b3e <subst_all_functions_starting_from_the_back+0x12>
            function_name_found = 1;
    6b8a:	2101      	movs	r1, #1
    6b8c:	e7fb      	b.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
                if (i==0 && function_name_valid){ // start of expr string special case
    6b8e:	f1ba 0f00 	cmp.w	sl, #0
    6b92:	d0e9      	beq.n	6b68 <subst_all_functions_starting_from_the_back+0x3c>
                    function_name_valid = 1;
    6b94:	460a      	mov	r2, r1
    6b96:	e7f6      	b.n	6b86 <subst_all_functions_starting_from_the_back+0x5a>
    6b98:	00006659 	.word	0x00006659
    6b9c:	000068b9 	.word	0x000068b9

00006ba0 <grid_expr_evaluate>:
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6ba0:	b573      	push	{r0, r1, r4, r5, r6, lr}
    grid_expr_clear_input(expr);
    6ba2:	4b12      	ldr	r3, [pc, #72]	; (6bec <grid_expr_evaluate+0x4c>)
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6ba4:	4604      	mov	r4, r0
    6ba6:	460e      	mov	r6, r1
    6ba8:	4611      	mov	r1, r2
    grid_expr_clear_input(expr);
    6baa:	4798      	blx	r3
    grid_expr_clear_output(expr);
    6bac:	4b10      	ldr	r3, [pc, #64]	; (6bf0 <grid_expr_evaluate+0x50>)
    6bae:	4620      	mov	r0, r4
    6bb0:	4798      	blx	r3
    for (uint32_t i=0; i<input_length; i++){
    6bb2:	1d22      	adds	r2, r4, #4
    6bb4:	2300      	movs	r3, #0
    6bb6:	4615      	mov	r5, r2
    6bb8:	4299      	cmp	r1, r3
    6bba:	d811      	bhi.n	6be0 <grid_expr_evaluate+0x40>
    expr->input_string_length = input_length;
    6bbc:	f884 10fe 	strb.w	r1, [r4, #254]	; 0xfe
    subst_all_variables_starting_from_the_back(expr->input_string, expr->input_string_length);    
    6bc0:	4b0c      	ldr	r3, [pc, #48]	; (6bf4 <grid_expr_evaluate+0x54>)
    6bc2:	4628      	mov	r0, r5
    6bc4:	4798      	blx	r3
    subst_all_functions_starting_from_the_back(expr->input_string, expr->input_string_length);
    6bc6:	f894 10fe 	ldrb.w	r1, [r4, #254]	; 0xfe
    6bca:	4b0b      	ldr	r3, [pc, #44]	; (6bf8 <grid_expr_evaluate+0x58>)
    6bcc:	4628      	mov	r0, r5
    6bce:	4798      	blx	r3
    int result = expr_level_0(e);
    6bd0:	4b0a      	ldr	r3, [pc, #40]	; (6bfc <grid_expr_evaluate+0x5c>)
    6bd2:	9501      	str	r5, [sp, #4]
    6bd4:	a801      	add	r0, sp, #4
    6bd6:	4798      	blx	r3
    expr->return_value = result;
    6bd8:	f8c4 01fc 	str.w	r0, [r4, #508]	; 0x1fc
}
    6bdc:	b002      	add	sp, #8
    6bde:	bd70      	pop	{r4, r5, r6, pc}
        expr->input_string[i] = input_str[i];
    6be0:	5cf0      	ldrb	r0, [r6, r3]
    6be2:	f802 0b01 	strb.w	r0, [r2], #1
    for (uint32_t i=0; i<input_length; i++){
    6be6:	3301      	adds	r3, #1
    6be8:	e7e6      	b.n	6bb8 <grid_expr_evaluate+0x18>
    6bea:	bf00      	nop
    6bec:	000063c5 	.word	0x000063c5
    6bf0:	000063d9 	.word	0x000063d9
    6bf4:	000068d9 	.word	0x000068d9
    6bf8:	00006b2d 	.word	0x00006b2d
    6bfc:	00006451 	.word	0x00006451

00006c00 <grid_led_lowlevel_hardware_transfer_complete_cb>:


void grid_led_lowlevel_hardware_transfer_complete_cb(struct _dma_resource *resource){
	

	grid_led_hardware_transfer_done = 1;
    6c00:	4b01      	ldr	r3, [pc, #4]	; (6c08 <grid_led_lowlevel_hardware_transfer_complete_cb+0x8>)
    6c02:	2201      	movs	r2, #1
    6c04:	701a      	strb	r2, [r3, #0]
	
	
}
    6c06:	4770      	bx	lr
    6c08:	20001b68 	.word	0x20001b68

00006c0c <grid_led_lowlevel_set_color>:
uint8_t grid_led_lowlevel_set_color(struct grid_led_model* mod, uint32_t led_index, uint16_t led_r, uint16_t led_g, uint16_t led_b){
    6c0c:	b510      	push	{r4, lr}
	if (led_index<mod->led_number){
    6c0e:	7844      	ldrb	r4, [r0, #1]
    6c10:	428c      	cmp	r4, r1
    6c12:	d91c      	bls.n	6c4e <grid_led_lowlevel_set_color+0x42>
		mod->led_frame_buffer_usable[led_index*3 + 0] = grid_led_color_code[led_g];
    6c14:	2bff      	cmp	r3, #255	; 0xff
    6c16:	f04f 040c 	mov.w	r4, #12
    6c1a:	fb04 f101 	mul.w	r1, r4, r1
    6c1e:	bf28      	it	cs
    6c20:	23ff      	movcs	r3, #255	; 0xff
    6c22:	4c0c      	ldr	r4, [pc, #48]	; (6c54 <grid_led_lowlevel_set_color+0x48>)
    6c24:	68c0      	ldr	r0, [r0, #12]
    6c26:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6c2a:	5043      	str	r3, [r0, r1]
		mod->led_frame_buffer_usable[led_index*3 + 1] = grid_led_color_code[led_r];
    6c2c:	2aff      	cmp	r2, #255	; 0xff
    6c2e:	bf28      	it	cs
    6c30:	22ff      	movcs	r2, #255	; 0xff
    6c32:	4401      	add	r1, r0
    6c34:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
    6c38:	604b      	str	r3, [r1, #4]
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6c3a:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6c3e:	2bff      	cmp	r3, #255	; 0xff
    6c40:	bf28      	it	cs
    6c42:	23ff      	movcs	r3, #255	; 0xff
		return 0;
    6c44:	2000      	movs	r0, #0
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6c46:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6c4a:	608b      	str	r3, [r1, #8]
}
    6c4c:	bd10      	pop	{r4, pc}
		return -1;		
    6c4e:	20ff      	movs	r0, #255	; 0xff
    6c50:	e7fc      	b.n	6c4c <grid_led_lowlevel_set_color+0x40>
    6c52:	bf00      	nop
    6c54:	2000887c 	.word	0x2000887c

00006c58 <grid_led_hardware_init>:


}


void grid_led_hardware_init(struct grid_led_model* mod){
    6c58:	b510      	push	{r4, lr}
	
	spi_m_dma_get_io_descriptor(&GRID_LED, &mod->hardware_io_descriptor);
    6c5a:	4c06      	ldr	r4, [pc, #24]	; (6c74 <grid_led_hardware_init+0x1c>)
    6c5c:	4b06      	ldr	r3, [pc, #24]	; (6c78 <grid_led_hardware_init+0x20>)
    6c5e:	f100 0114 	add.w	r1, r0, #20
    6c62:	4620      	mov	r0, r4
    6c64:	4798      	blx	r3
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    6c66:	4620      	mov	r0, r4
    6c68:	4a04      	ldr	r2, [pc, #16]	; (6c7c <grid_led_hardware_init+0x24>)
    6c6a:	4b05      	ldr	r3, [pc, #20]	; (6c80 <grid_led_hardware_init+0x28>)
	

		
}
    6c6c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    6c70:	2100      	movs	r1, #0
    6c72:	4718      	bx	r3
    6c74:	20015874 	.word	0x20015874
    6c78:	0000b909 	.word	0x0000b909
    6c7c:	00006c01 	.word	0x00006c01
    6c80:	0000b8d5 	.word	0x0000b8d5

00006c84 <grid_led_get_led_number>:

uint32_t grid_led_get_led_number(struct grid_led_model* mod){

	return mod->led_number;

}
    6c84:	7840      	ldrb	r0, [r0, #1]
    6c86:	4770      	bx	lr

00006c88 <grid_led_tick>:

/** ================== ANIMATION ==================  */


void grid_led_tick(struct grid_led_model* mod){
    6c88:	b5f0      	push	{r4, r5, r6, r7, lr}
	

	/** ATOMI - all phase registers must be updated  */
	for (uint8_t j=0; j<mod->led_number; j++){
    6c8a:	7846      	ldrb	r6, [r0, #1]
    6c8c:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    6c90:	eb06 0282 	add.w	r2, r6, r2, lsl #2
    6c94:	2400      	movs	r4, #0
    6c96:	270d      	movs	r7, #13
    6c98:	b2e3      	uxtb	r3, r4
    6c9a:	429e      	cmp	r6, r3
    6c9c:	d800      	bhi.n	6ca0 <grid_led_tick+0x18>
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
		}	
	}
	/** END */
	
}
    6c9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    6ca0:	6903      	ldr	r3, [r0, #16]
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    6ca2:	2103      	movs	r1, #3
    6ca4:	fb07 3304 	mla	r3, r7, r4, r3
    6ca8:	7add      	ldrb	r5, [r3, #11]
    6caa:	f893 c00c 	ldrb.w	ip, [r3, #12]
    6cae:	3901      	subs	r1, #1
    6cb0:	4465      	add	r5, ip
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    6cb2:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    6cb6:	72dd      	strb	r5, [r3, #11]
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    6cb8:	4413      	add	r3, r2
    6cba:	d1f5      	bne.n	6ca8 <grid_led_tick+0x20>
	for (uint8_t j=0; j<mod->led_number; j++){
    6cbc:	3401      	adds	r4, #1
    6cbe:	e7eb      	b.n	6c98 <grid_led_tick+0x10>

00006cc0 <grid_led_set_min>:
	grid_led_set_max(mod, num, layer, r, g, b);

}


void grid_led_set_min(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6cc0:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r = r;
    6cc2:	7844      	ldrb	r4, [r0, #1]
    6cc4:	6900      	ldr	r0, [r0, #16]
    6cc6:	fb04 1202 	mla	r2, r4, r2, r1
    6cca:	240d      	movs	r4, #13
    6ccc:	4362      	muls	r2, r4
    6cce:	1881      	adds	r1, r0, r2
    6cd0:	5483      	strb	r3, [r0, r2]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g = g;
    6cd2:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cd6:	704b      	strb	r3, [r1, #1]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b = b;	
    6cd8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cdc:	708b      	strb	r3, [r1, #2]
}
    6cde:	bd10      	pop	{r4, pc}

00006ce0 <grid_led_set_mid>:

void grid_led_set_mid(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6ce0:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.r = r;
    6ce2:	7844      	ldrb	r4, [r0, #1]
    6ce4:	fb04 1102 	mla	r1, r4, r2, r1
    6ce8:	6902      	ldr	r2, [r0, #16]
    6cea:	200d      	movs	r0, #13
    6cec:	fb00 2201 	mla	r2, r0, r1, r2
    6cf0:	70d3      	strb	r3, [r2, #3]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.g = g;
    6cf2:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6cf6:	7113      	strb	r3, [r2, #4]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.b = b;	
    6cf8:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cfc:	7153      	strb	r3, [r2, #5]
}
    6cfe:	bd10      	pop	{r4, pc}

00006d00 <grid_led_set_max>:

void grid_led_set_max(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d00:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r = r;
    6d02:	7844      	ldrb	r4, [r0, #1]
    6d04:	fb04 1102 	mla	r1, r4, r2, r1
    6d08:	6902      	ldr	r2, [r0, #16]
    6d0a:	200d      	movs	r0, #13
    6d0c:	fb00 2201 	mla	r2, r0, r1, r2
    6d10:	7193      	strb	r3, [r2, #6]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g = g;
    6d12:	f89d 3008 	ldrb.w	r3, [sp, #8]
    6d16:	71d3      	strb	r3, [r2, #7]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b = b;	
    6d18:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6d1c:	7213      	strb	r3, [r2, #8]
}
    6d1e:	bd10      	pop	{r4, pc}

00006d20 <grid_led_set_color>:
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d20:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    6d24:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
    6d28:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d2c:	f8df a058 	ldr.w	sl, [pc, #88]	; 6d88 <grid_led_set_color+0x68>
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d30:	461c      	mov	r4, r3
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d32:	2314      	movs	r3, #20
    6d34:	fbb9 fcf3 	udiv	ip, r9, r3
    6d38:	f8cd c004 	str.w	ip, [sp, #4]
    6d3c:	fbb8 fcf3 	udiv	ip, r8, r3
    6d40:	fbb4 f3f3 	udiv	r3, r4, r3
    6d44:	f8cd c000 	str.w	ip, [sp]
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    6d48:	4605      	mov	r5, r0
    6d4a:	460e      	mov	r6, r1
    6d4c:	4617      	mov	r7, r2
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    6d4e:	47d0      	blx	sl
	grid_led_set_mid(mod, num, layer, r/2, g/2, b/2);
    6d50:	ea4f 0359 	mov.w	r3, r9, lsr #1
    6d54:	9301      	str	r3, [sp, #4]
    6d56:	ea4f 0358 	mov.w	r3, r8, lsr #1
    6d5a:	9300      	str	r3, [sp, #0]
    6d5c:	463a      	mov	r2, r7
    6d5e:	0863      	lsrs	r3, r4, #1
    6d60:	4631      	mov	r1, r6
    6d62:	4628      	mov	r0, r5
    6d64:	f8df a024 	ldr.w	sl, [pc, #36]	; 6d8c <grid_led_set_color+0x6c>
    6d68:	47d0      	blx	sl
	grid_led_set_max(mod, num, layer, r, g, b);
    6d6a:	4623      	mov	r3, r4
    6d6c:	4c05      	ldr	r4, [pc, #20]	; (6d84 <grid_led_set_color+0x64>)
    6d6e:	463a      	mov	r2, r7
    6d70:	4631      	mov	r1, r6
    6d72:	4628      	mov	r0, r5
    6d74:	46a4      	mov	ip, r4
    6d76:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
}
    6d7a:	b002      	add	sp, #8
    6d7c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_led_set_max(mod, num, layer, r, g, b);
    6d80:	4760      	bx	ip
    6d82:	bf00      	nop
    6d84:	00006d01 	.word	0x00006d01
    6d88:	00006cc1 	.word	0x00006cc1
    6d8c:	00006ce1 	.word	0x00006ce1

00006d90 <grid_led_set_phase>:

void grid_led_set_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    6d90:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].pha = val;
    6d92:	7844      	ldrb	r4, [r0, #1]
    6d94:	fb04 1102 	mla	r1, r4, r2, r1
    6d98:	6902      	ldr	r2, [r0, #16]
    6d9a:	200d      	movs	r0, #13
    6d9c:	fb00 2101 	mla	r1, r0, r1, r2
    6da0:	72cb      	strb	r3, [r1, #11]
}
    6da2:	bd10      	pop	{r4, pc}

00006da4 <grid_led_set_frequency>:
uint8_t grid_led_get_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer){
	
	return mod->led_smart_buffer[num+(mod->led_number*layer)].pha;
}

void grid_led_set_frequency(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    6da4:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].fre = val;
    6da6:	7844      	ldrb	r4, [r0, #1]
    6da8:	fb04 1102 	mla	r1, r4, r2, r1
    6dac:	6902      	ldr	r2, [r0, #16]
    6dae:	200d      	movs	r0, #13
    6db0:	fb00 2101 	mla	r1, r0, r1, r2
    6db4:	730b      	strb	r3, [r1, #12]
}
    6db6:	bd10      	pop	{r4, pc}

00006db8 <grid_led_buffer_init>:
void grid_led_buffer_init(struct grid_led_model* mod, uint32_t length){
    6db8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6dbc:	4604      	mov	r4, r0
	mod->led_number = length;
    6dbe:	7041      	strb	r1, [r0, #1]
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    6dc0:	b2cd      	uxtb	r5, r1
    6dc2:	200c      	movs	r0, #12
    6dc4:	4368      	muls	r0, r5
    6dc6:	3090      	adds	r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6dc8:	4f4c      	ldr	r7, [pc, #304]	; (6efc <grid_led_buffer_init+0x144>)
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    6dca:	6060      	str	r0, [r4, #4]
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6dcc:	47b8      	blx	r7
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    6dce:	f100 0390 	add.w	r3, r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    6dd2:	60a0      	str	r0, [r4, #8]
    6dd4:	4606      	mov	r6, r0
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    6dd6:	2027      	movs	r0, #39	; 0x27
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    6dd8:	60e3      	str	r3, [r4, #12]
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    6dda:	4368      	muls	r0, r5
    6ddc:	47b8      	blx	r7
    6dde:	6120      	str	r0, [r4, #16]
	if(mod->led_frame_buffer==NULL || mod->led_smart_buffer==NULL){
    6de0:	b106      	cbz	r6, 6de4 <grid_led_buffer_init+0x2c>
    6de2:	b900      	cbnz	r0, 6de6 <grid_led_buffer_init+0x2e>
		while(1){
    6de4:	e7fe      	b.n	6de4 <grid_led_buffer_init+0x2c>
    6de6:	2300      	movs	r3, #0
		mod->led_frame_buffer[i] = LED_CODE_R;
    6de8:	4619      	mov	r1, r3
    6dea:	68a2      	ldr	r2, [r4, #8]
    6dec:	54d1      	strb	r1, [r2, r3]
	for (uint8_t i = 0; i<GRID_LED_RESET_LENGTH; i++){
    6dee:	3301      	adds	r3, #1
    6df0:	2b90      	cmp	r3, #144	; 0x90
    6df2:	d1fa      	bne.n	6dea <grid_led_buffer_init+0x32>
	for (uint32_t i = 0; i<mod->led_number; i++){
    6df4:	2500      	movs	r5, #0
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    6df6:	4f42      	ldr	r7, [pc, #264]	; (6f00 <grid_led_buffer_init+0x148>)
    6df8:	462e      	mov	r6, r5
	for (uint32_t i = 0; i<mod->led_number; i++){
    6dfa:	7863      	ldrb	r3, [r4, #1]
    6dfc:	429d      	cmp	r5, r3
    6dfe:	d30c      	bcc.n	6e1a <grid_led_buffer_init+0x62>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    6e00:	4d40      	ldr	r5, [pc, #256]	; (6f04 <grid_led_buffer_init+0x14c>)
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    6e02:	4e41      	ldr	r6, [pc, #260]	; (6f08 <grid_led_buffer_init+0x150>)
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    6e04:	4f41      	ldr	r7, [pc, #260]	; (6f0c <grid_led_buffer_init+0x154>)
    6e06:	f04f 0b00 	mov.w	fp, #0
	for(uint8_t i = 0; i<mod->led_number; i++){
    6e0a:	7863      	ldrb	r3, [r4, #1]
    6e0c:	fa5f fa8b 	uxtb.w	sl, fp
    6e10:	4553      	cmp	r3, sl
    6e12:	d80a      	bhi.n	6e2a <grid_led_buffer_init+0x72>
}
    6e14:	b003      	add	sp, #12
    6e16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    6e1a:	2300      	movs	r3, #0
    6e1c:	4629      	mov	r1, r5
    6e1e:	9600      	str	r6, [sp, #0]
    6e20:	461a      	mov	r2, r3
    6e22:	4620      	mov	r0, r4
    6e24:	47b8      	blx	r7
	for (uint32_t i = 0; i<mod->led_number; i++){
    6e26:	3501      	adds	r5, #1
    6e28:	e7e7      	b.n	6dfa <grid_led_buffer_init+0x42>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    6e2a:	2300      	movs	r3, #0
    6e2c:	e9cd 3300 	strd	r3, r3, [sp]
    6e30:	2201      	movs	r2, #1
    6e32:	4651      	mov	r1, sl
    6e34:	4620      	mov	r0, r4
    6e36:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    6e38:	2300      	movs	r3, #0
    6e3a:	227f      	movs	r2, #127	; 0x7f
    6e3c:	e9cd 2300 	strd	r2, r3, [sp]
    6e40:	4651      	mov	r1, sl
    6e42:	2201      	movs	r2, #1
    6e44:	4620      	mov	r0, r4
    6e46:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    6e48:	2300      	movs	r3, #0
    6e4a:	22ff      	movs	r2, #255	; 0xff
    6e4c:	e9cd 2300 	strd	r2, r3, [sp]
    6e50:	4651      	mov	r1, sl
    6e52:	2201      	movs	r2, #1
    6e54:	4620      	mov	r0, r4
    6e56:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e58:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 6f10 <grid_led_buffer_init+0x158>
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e5c:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 6f14 <grid_led_buffer_init+0x15c>
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e60:	2300      	movs	r3, #0
    6e62:	2201      	movs	r2, #1
    6e64:	4651      	mov	r1, sl
    6e66:	4620      	mov	r0, r4
    6e68:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    6e6a:	2300      	movs	r3, #0
    6e6c:	2201      	movs	r2, #1
    6e6e:	4651      	mov	r1, sl
    6e70:	4620      	mov	r0, r4
    6e72:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x00, 0x00);
    6e74:	2300      	movs	r3, #0
    6e76:	e9cd 3300 	strd	r3, r3, [sp]
    6e7a:	2202      	movs	r2, #2
    6e7c:	4651      	mov	r1, sl
    6e7e:	4620      	mov	r0, r4
    6e80:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x7F, 0x00);
    6e82:	2300      	movs	r3, #0
    6e84:	227f      	movs	r2, #127	; 0x7f
    6e86:	e9cd 2300 	strd	r2, r3, [sp]
    6e8a:	4651      	mov	r1, sl
    6e8c:	2202      	movs	r2, #2
    6e8e:	4620      	mov	r0, r4
    6e90:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0xFF, 0x00);
    6e92:	2300      	movs	r3, #0
    6e94:	22ff      	movs	r2, #255	; 0xff
    6e96:	e9cd 2300 	strd	r2, r3, [sp]
    6e9a:	4651      	mov	r1, sl
    6e9c:	2202      	movs	r2, #2
    6e9e:	4620      	mov	r0, r4
    6ea0:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_B, 0);
    6ea2:	2300      	movs	r3, #0
    6ea4:	2202      	movs	r2, #2
    6ea6:	4651      	mov	r1, sl
    6ea8:	4620      	mov	r0, r4
    6eaa:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_B, 0);
    6eac:	2300      	movs	r3, #0
    6eae:	2202      	movs	r2, #2
    6eb0:	4651      	mov	r1, sl
    6eb2:	4620      	mov	r0, r4
    6eb4:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6eb6:	2300      	movs	r3, #0
    6eb8:	461a      	mov	r2, r3
    6eba:	e9cd 3300 	strd	r3, r3, [sp]
    6ebe:	4651      	mov	r1, sl
    6ec0:	4620      	mov	r0, r4
    6ec2:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6ec4:	2300      	movs	r3, #0
    6ec6:	461a      	mov	r2, r3
    6ec8:	e9cd 3300 	strd	r3, r3, [sp]
    6ecc:	4651      	mov	r1, sl
    6ece:	4620      	mov	r0, r4
    6ed0:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    6ed2:	2300      	movs	r3, #0
    6ed4:	461a      	mov	r2, r3
    6ed6:	e9cd 3300 	strd	r3, r3, [sp]
    6eda:	4651      	mov	r1, sl
    6edc:	4620      	mov	r0, r4
    6ede:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_ALERT, 0);
    6ee0:	2300      	movs	r3, #0
    6ee2:	461a      	mov	r2, r3
    6ee4:	4651      	mov	r1, sl
    6ee6:	4620      	mov	r0, r4
    6ee8:	47c8      	blx	r9
		grid_led_set_phase(mod, i, GRID_LED_LAYER_ALERT, 0);
    6eea:	2300      	movs	r3, #0
    6eec:	461a      	mov	r2, r3
    6eee:	4651      	mov	r1, sl
    6ef0:	4620      	mov	r0, r4
    6ef2:	47c0      	blx	r8
	for(uint8_t i = 0; i<mod->led_number; i++){
    6ef4:	f10b 0b01 	add.w	fp, fp, #1
    6ef8:	e787      	b.n	6e0a <grid_led_buffer_init+0x52>
    6efa:	bf00      	nop
    6efc:	00014021 	.word	0x00014021
    6f00:	00006c0d 	.word	0x00006c0d
    6f04:	00006cc1 	.word	0x00006cc1
    6f08:	00006ce1 	.word	0x00006ce1
    6f0c:	00006d01 	.word	0x00006d01
    6f10:	00006da5 	.word	0x00006da5
    6f14:	00006d91 	.word	0x00006d91

00006f18 <grid_led_lowlevel_init>:
uint8_t grid_led_lowlevel_init(struct grid_led_model* mod, uint8_t num){
    6f18:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    6f1a:	4e29      	ldr	r6, [pc, #164]	; (6fc0 <grid_led_lowlevel_init+0xa8>)
	for(uint16_t i=0; i<256; i++){
    6f1c:	2300      	movs	r3, #0
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    6f1e:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
		temp |= (i/2%2)   ? (LED_CODE_O<<28) : (LED_CODE_Z<<28);
    6f22:	f013 0f02 	tst.w	r3, #2
    6f26:	bf0c      	ite	eq
    6f28:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    6f2c:	f04f 4560 	movne.w	r5, #3758096384	; 0xe0000000
		temp |= (i/4%2)   ? (LED_CODE_O<<16) : (LED_CODE_Z<<16);
    6f30:	f013 0f04 	tst.w	r3, #4
    6f34:	bf0c      	ite	eq
    6f36:	f44f 2400 	moveq.w	r4, #524288	; 0x80000
    6f3a:	f44f 2460 	movne.w	r4, #917504	; 0xe0000
		temp |= (i/8%2)   ? (LED_CODE_O<<20) : (LED_CODE_Z<<20);
    6f3e:	f013 0f08 	tst.w	r3, #8
    6f42:	ea45 0504 	orr.w	r5, r5, r4
    6f46:	bf0c      	ite	eq
    6f48:	f44f 0400 	moveq.w	r4, #8388608	; 0x800000
    6f4c:	f44f 0460 	movne.w	r4, #14680064	; 0xe00000
		temp |= (i/16%2)  ? (LED_CODE_O<<8)  : (LED_CODE_Z<<8);
    6f50:	f013 0f10 	tst.w	r3, #16
    6f54:	ea45 0504 	orr.w	r5, r5, r4
    6f58:	bf0c      	ite	eq
    6f5a:	f44f 6400 	moveq.w	r4, #2048	; 0x800
    6f5e:	f44f 6460 	movne.w	r4, #3584	; 0xe00
		temp |= (i/32%2)  ? (LED_CODE_O<<12) : (LED_CODE_Z<<12);
    6f62:	f013 0f20 	tst.w	r3, #32
    6f66:	bf0c      	ite	eq
    6f68:	f44f 4200 	moveq.w	r2, #32768	; 0x8000
    6f6c:	f44f 4260 	movne.w	r2, #57344	; 0xe000
    6f70:	432c      	orrs	r4, r5
		temp |= (i/64%2)  ? (LED_CODE_O<<0)  : (LED_CODE_Z<<0);
    6f72:	f013 0f40 	tst.w	r3, #64	; 0x40
    6f76:	ea44 0402 	orr.w	r4, r4, r2
    6f7a:	bf0c      	ite	eq
    6f7c:	2208      	moveq	r2, #8
    6f7e:	220e      	movne	r2, #14
    6f80:	4314      	orrs	r4, r2
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f82:	09da      	lsrs	r2, r3, #7
    6f84:	bf14      	ite	ne
    6f86:	22e0      	movne	r2, #224	; 0xe0
    6f88:	2280      	moveq	r2, #128	; 0x80
	for(uint16_t i=0; i<256; i++){
    6f8a:	3301      	adds	r3, #1
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f8c:	4322      	orrs	r2, r4
	for(uint16_t i=0; i<256; i++){
    6f8e:	b29b      	uxth	r3, r3
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    6f90:	433a      	orrs	r2, r7
	for(uint16_t i=0; i<256; i++){
    6f92:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		grid_led_color_code[i] = temp;
    6f96:	f846 2b04 	str.w	r2, [r6], #4
	for(uint16_t i=0; i<256; i++){
    6f9a:	d108      	bne.n	6fae <grid_led_lowlevel_init+0x96>
	grid_led_buffer_init(mod, num);		
    6f9c:	4b09      	ldr	r3, [pc, #36]	; (6fc4 <grid_led_lowlevel_init+0xac>)
    6f9e:	9001      	str	r0, [sp, #4]
    6fa0:	4798      	blx	r3
	grid_led_hardware_init(mod);
    6fa2:	9801      	ldr	r0, [sp, #4]
    6fa4:	4b08      	ldr	r3, [pc, #32]	; (6fc8 <grid_led_lowlevel_init+0xb0>)
    6fa6:	4798      	blx	r3
}
    6fa8:	2000      	movs	r0, #0
    6faa:	b003      	add	sp, #12
    6fac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    6fae:	f013 0f01 	tst.w	r3, #1
    6fb2:	bf14      	ite	ne
    6fb4:	f04f 6760 	movne.w	r7, #234881024	; 0xe000000
    6fb8:	f04f 6700 	moveq.w	r7, #134217728	; 0x8000000
    6fbc:	e7b1      	b.n	6f22 <grid_led_lowlevel_init+0xa>
    6fbe:	bf00      	nop
    6fc0:	2000887c 	.word	0x2000887c
    6fc4:	00006db9 	.word	0x00006db9
    6fc8:	00006c59 	.word	0x00006c59

00006fcc <grid_led_lowlevel_render>:


void grid_led_lowlevel_render(struct grid_led_model* mod, uint32_t num){
    6fcc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6fd0:	7847      	ldrb	r7, [r0, #1]
		uint8_t layer = i;
				
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
		uint8_t min_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g;
		uint8_t min_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b;
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fd2:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 7074 <grid_led_lowlevel_render+0xa8>
    6fd6:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    6fda:	eb07 0783 	add.w	r7, r7, r3, lsl #2
    6fde:	6903      	ldr	r3, [r0, #16]
	uint32_t mix_b = 0;
    6fe0:	2500      	movs	r5, #0
    6fe2:	240d      	movs	r4, #13
    6fe4:	fb04 3401 	mla	r4, r4, r1, r3
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
    6fe8:	2603      	movs	r6, #3
	uint32_t mix_g = 0;
    6fea:	462b      	mov	r3, r5
	uint32_t mix_r = 0;
    6fec:	462a      	mov	r2, r5
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6fee:	f894 900b 	ldrb.w	r9, [r4, #11]
		uint8_t max_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r;
		uint8_t max_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g;
		uint8_t max_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b;
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
				
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    6ff2:	f894 b003 	ldrb.w	fp, [r4, #3]
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6ff6:	f818 e009 	ldrb.w	lr, [r8, r9]
		uint8_t mid_a = mid_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    6ffa:	44c1      	add	r9, r8
    6ffc:	3e01      	subs	r6, #1
    6ffe:	f899 a100 	ldrb.w	sl, [r9, #256]	; 0x100
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    7002:	f899 c200 	ldrb.w	ip, [r9, #512]	; 0x200
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    7006:	f894 9000 	ldrb.w	r9, [r4]
    700a:	fb1b fb0a 	smulbb	fp, fp, sl
    700e:	fb09 bb0e 	mla	fp, r9, lr, fp
    7012:	f894 9006 	ldrb.w	r9, [r4, #6]
    7016:	fb09 b90c 	mla	r9, r9, ip, fp
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    701a:	f894 b004 	ldrb.w	fp, [r4, #4]
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    701e:	444a      	add	r2, r9
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    7020:	f894 9001 	ldrb.w	r9, [r4, #1]
    7024:	fb1b fb0a 	smulbb	fp, fp, sl
    7028:	fb09 bb0e 	mla	fp, r9, lr, fp
    702c:	f894 9007 	ldrb.w	r9, [r4, #7]
    7030:	fb09 b90c 	mla	r9, r9, ip, fp
    7034:	444b      	add	r3, r9
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    7036:	f894 9005 	ldrb.w	r9, [r4, #5]
    703a:	f894 b002 	ldrb.w	fp, [r4, #2]
    703e:	fb19 f90a 	smulbb	r9, r9, sl
    7042:	fb0b 9e0e 	mla	lr, fp, lr, r9
    7046:	f894 9008 	ldrb.w	r9, [r4, #8]
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    704a:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    704e:	fb09 ec0c 	mla	ip, r9, ip, lr
    7052:	4465      	add	r5, ip
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    7054:	443c      	add	r4, r7
    7056:	d1ca      	bne.n	6fee <grid_led_lowlevel_render+0x22>

	mix_r = (mix_r)/2/256;
	mix_g = (mix_g)/2/256;
	mix_b = (mix_b)/2/256;
				
	grid_led_lowlevel_set_color(mod, num, mix_r, mix_g, mix_b);
    7058:	f3c5 254f 	ubfx	r5, r5, #9, #16
    705c:	4c04      	ldr	r4, [pc, #16]	; (7070 <grid_led_lowlevel_render+0xa4>)
    705e:	9500      	str	r5, [sp, #0]
    7060:	f3c3 234f 	ubfx	r3, r3, #9, #16
    7064:	f3c2 224f 	ubfx	r2, r2, #9, #16
    7068:	47a0      	blx	r4
	
}
    706a:	b003      	add	sp, #12
    706c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7070:	00006c0d 	.word	0x00006c0d
    7074:	20000008 	.word	0x20000008

00007078 <grid_led_lowlevel_render_all>:


void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7078:	b570      	push	{r4, r5, r6, lr}
	
	for (uint32_t i=0; i<mod->led_number; i++){
		
		grid_led_lowlevel_render(mod, i);
    707a:	4e06      	ldr	r6, [pc, #24]	; (7094 <grid_led_lowlevel_render_all+0x1c>)
void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    707c:	4605      	mov	r5, r0
	for (uint32_t i=0; i<mod->led_number; i++){
    707e:	2400      	movs	r4, #0
    7080:	786b      	ldrb	r3, [r5, #1]
    7082:	42a3      	cmp	r3, r4
    7084:	d800      	bhi.n	7088 <grid_led_lowlevel_render_all+0x10>
	}
	
}
    7086:	bd70      	pop	{r4, r5, r6, pc}
		grid_led_lowlevel_render(mod, i);
    7088:	4621      	mov	r1, r4
    708a:	4628      	mov	r0, r5
    708c:	47b0      	blx	r6
	for (uint32_t i=0; i<mod->led_number; i++){
    708e:	3401      	adds	r4, #1
    7090:	e7f6      	b.n	7080 <grid_led_lowlevel_render_all+0x8>
    7092:	bf00      	nop
    7094:	00006fcd 	.word	0x00006fcd

00007098 <grid_led_lowlevel_hardware_start_transfer>:
			
	}
	
}

void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    7098:	b510      	push	{r4, lr}
	
	// SEND DATA TO LEDs
	grid_led_hardware_transfer_done = 0;
    709a:	4b07      	ldr	r3, [pc, #28]	; (70b8 <grid_led_lowlevel_hardware_start_transfer+0x20>)
void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    709c:	4604      	mov	r4, r0
	grid_led_hardware_transfer_done = 0;
    709e:	2200      	movs	r2, #0
    70a0:	701a      	strb	r2, [r3, #0]
	spi_m_dma_enable(&GRID_LED);
    70a2:	4806      	ldr	r0, [pc, #24]	; (70bc <grid_led_lowlevel_hardware_start_transfer+0x24>)
    70a4:	4b06      	ldr	r3, [pc, #24]	; (70c0 <grid_led_lowlevel_hardware_start_transfer+0x28>)
    70a6:	4798      	blx	r3
			
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    70a8:	88a2      	ldrh	r2, [r4, #4]
    70aa:	68a1      	ldr	r1, [r4, #8]
    70ac:	6960      	ldr	r0, [r4, #20]
    70ae:	4b05      	ldr	r3, [pc, #20]	; (70c4 <grid_led_lowlevel_hardware_start_transfer+0x2c>)

}
    70b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    70b4:	4718      	bx	r3
    70b6:	bf00      	nop
    70b8:	20001b68 	.word	0x20001b68
    70bc:	20015874 	.word	0x20015874
    70c0:	0000b8ad 	.word	0x0000b8ad
    70c4:	0000b0ed 	.word	0x0000b0ed

000070c8 <grid_module_common_init>:

	
/* ============================== GRID_MODULE_INIT() ================================ */


void grid_module_common_init(void){
    70c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	grid_ui_model_init(&grid_core_state, 1);
    70cc:	4d70      	ldr	r5, [pc, #448]	; (7290 <grid_module_common_init+0x1c8>)
    70ce:	4b71      	ldr	r3, [pc, #452]	; (7294 <grid_module_common_init+0x1cc>)
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
	
		
	if (1){	// INIT CORE_STATE->hearbeat	
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70d0:	f8df 9240 	ldr.w	r9, [pc, #576]	; 7314 <grid_module_common_init+0x24c>
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
		payload_length = strlen(payload_template);
    70d4:	f8df 8240 	ldr.w	r8, [pc, #576]	; 7318 <grid_module_common_init+0x250>
	
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    70d8:	4f6f      	ldr	r7, [pc, #444]	; (7298 <grid_module_common_init+0x1d0>)
		uint8_t error = 0;
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    70da:	f8df a240 	ldr.w	sl, [pc, #576]	; 731c <grid_module_common_init+0x254>
void grid_module_common_init(void){
    70de:	b0a5      	sub	sp, #148	; 0x94
	grid_ui_model_init(&grid_core_state, 1);
    70e0:	4628      	mov	r0, r5
    70e2:	2101      	movs	r1, #1
    70e4:	4798      	blx	r3
	grid_ui_bank_init(&grid_core_state, 0, 1);
    70e6:	4628      	mov	r0, r5
    70e8:	4b6c      	ldr	r3, [pc, #432]	; (729c <grid_module_common_init+0x1d4>)
    70ea:	2201      	movs	r2, #1
    70ec:	2100      	movs	r1, #0
    70ee:	4798      	blx	r3
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    70f0:	2200      	movs	r2, #0
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70f2:	2400      	movs	r4, #0
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    70f4:	6868      	ldr	r0, [r5, #4]
    70f6:	4b6a      	ldr	r3, [pc, #424]	; (72a0 <grid_module_common_init+0x1d8>)
    70f8:	4611      	mov	r1, r2
    70fa:	4798      	blx	r3
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    70fc:	227e      	movs	r2, #126	; 0x7e
    70fe:	4621      	mov	r1, r4
    7100:	a804      	add	r0, sp, #16
    7102:	9403      	str	r4, [sp, #12]
    7104:	47c8      	blx	r9
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
    7106:	4967      	ldr	r1, [pc, #412]	; (72a4 <grid_module_common_init+0x1dc>)
    7108:	4b67      	ldr	r3, [pc, #412]	; (72a8 <grid_module_common_init+0x1e0>)
    710a:	a803      	add	r0, sp, #12
    710c:	4798      	blx	r3
		payload_length = strlen(payload_template);
    710e:	a803      	add	r0, sp, #12
    7110:	47c0      	blx	r8
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    7112:	aa03      	add	r2, sp, #12
    7114:	1816      	adds	r6, r2, r0
    7116:	2303      	movs	r3, #3
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7118:	f10d 0b0b 	add.w	fp, sp, #11
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    711c:	4963      	ldr	r1, [pc, #396]	; (72ac <grid_module_common_init+0x1e4>)
    711e:	9300      	str	r3, [sp, #0]
    7120:	2202      	movs	r2, #2
    7122:	2310      	movs	r3, #16
    7124:	4630      	mov	r0, r6
    7126:	47b8      	blx	r7
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7128:	230e      	movs	r3, #14
    712a:	2201      	movs	r2, #1
    712c:	2104      	movs	r1, #4
	
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    712e:	4f60      	ldr	r7, [pc, #384]	; (72b0 <grid_module_common_init+0x1e8>)
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7130:	f8cd b000 	str.w	fp, [sp]
    7134:	4630      	mov	r0, r6
		uint8_t error = 0;
    7136:	f88d 400b 	strb.w	r4, [sp, #11]
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    713a:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    713c:	47b8      	blx	r7
    713e:	2202      	movs	r2, #2
    7140:	4603      	mov	r3, r0
    7142:	2105      	movs	r1, #5
    7144:	4630      	mov	r0, r6
    7146:	f8cd b000 	str.w	fp, [sp]
    714a:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMAJOR_offset, GRID_CLASS_HEARTBEAT_VMAJOR_length , GRID_PROTOCOL_VERSION_MAJOR, &error);
    714c:	2301      	movs	r3, #1
    714e:	2202      	movs	r2, #2
    7150:	2107      	movs	r1, #7
    7152:	4630      	mov	r0, r6
    7154:	f8cd b000 	str.w	fp, [sp]
    7158:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMINOR_offset, GRID_CLASS_HEARTBEAT_VMINOR_length  , GRID_PROTOCOL_VERSION_MINOR, &error);
    715a:	2301      	movs	r3, #1
    715c:	2202      	movs	r2, #2
    715e:	2109      	movs	r1, #9
    7160:	4630      	mov	r0, r6
    7162:	f8cd b000 	str.w	fp, [sp]
    7166:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VPATCH_offset, GRID_CLASS_HEARTBEAT_VPATCH_length  , GRID_PROTOCOL_VERSION_PATCH, &error);
    7168:	2309      	movs	r3, #9
    716a:	2202      	movs	r2, #2
    716c:	210b      	movs	r1, #11
    716e:	4630      	mov	r0, r6
    7170:	f8cd b000 	str.w	fp, [sp]
    7174:	47d0      	blx	sl
	
		payload_length = strlen(payload_template);
    7176:	a803      	add	r0, sp, #12
    7178:	47c0      	blx	r8
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    717a:	686e      	ldr	r6, [r5, #4]
		payload_length = strlen(payload_template);
    717c:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    717e:	aa03      	add	r2, sp, #12
    7180:	68f0      	ldr	r0, [r6, #12]
    7182:	4e4c      	ldr	r6, [pc, #304]	; (72b4 <grid_module_common_init+0x1ec>)
    7184:	210c      	movs	r1, #12
    7186:	47b0      	blx	r6
		
	}

	if (1){	// INIT CORE_STATE->mapmode press
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7188:	227e      	movs	r2, #126	; 0x7e
    718a:	4621      	mov	r1, r4
    718c:	a804      	add	r0, sp, #16
    718e:	9403      	str	r4, [sp, #12]
    7190:	47c8      	blx	r9
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_PRESS GRID_ACTIONSTRING_MAPMODE_PRESS);
    7192:	4949      	ldr	r1, [pc, #292]	; (72b8 <grid_module_common_init+0x1f0>)
    7194:	4b44      	ldr	r3, [pc, #272]	; (72a8 <grid_module_common_init+0x1e0>)
    7196:	a803      	add	r0, sp, #12
    7198:	4798      	blx	r3
		payload_length = strlen(payload_template);
    719a:	a803      	add	r0, sp, #12
    719c:	47c0      	blx	r8
    719e:	4603      	mov	r3, r0
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_PRESS, payload_template, payload_length);			
    71a0:	6868      	ldr	r0, [r5, #4]
    71a2:	aa03      	add	r2, sp, #12
    71a4:	68c0      	ldr	r0, [r0, #12]
    71a6:	2107      	movs	r1, #7
    71a8:	47b0      	blx	r6
		
	}	

	if (1){ // INIT CORE_STATE->mapmode release
			
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71aa:	227e      	movs	r2, #126	; 0x7e
    71ac:	4621      	mov	r1, r4
    71ae:	a804      	add	r0, sp, #16
    71b0:	9403      	str	r4, [sp, #12]
    71b2:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_RELEASE GRID_ACTIONSTRING_MAPMODE_RELEASE);
    71b4:	4941      	ldr	r1, [pc, #260]	; (72bc <grid_module_common_init+0x1f4>)
    71b6:	4b3c      	ldr	r3, [pc, #240]	; (72a8 <grid_module_common_init+0x1e0>)
    71b8:	a803      	add	r0, sp, #12
    71ba:	4798      	blx	r3
		payload_length = strlen(payload_template);
    71bc:	a803      	add	r0, sp, #12
    71be:	47c0      	blx	r8
    71c0:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_RELEASE, payload_template, payload_length);
    71c2:	6868      	ldr	r0, [r5, #4]
    71c4:	aa03      	add	r2, sp, #12
    71c6:	68c0      	ldr	r0, [r0, #12]
    71c8:	2108      	movs	r1, #8
    71ca:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgresponse
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71cc:	227e      	movs	r2, #126	; 0x7e
    71ce:	4621      	mov	r1, r4
    71d0:	a804      	add	r0, sp, #16
    71d2:	9403      	str	r4, [sp, #12]
    71d4:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_RESPONES GRID_ACTIONSTRING_CFG_RESPONSE);
    71d6:	493a      	ldr	r1, [pc, #232]	; (72c0 <grid_module_common_init+0x1f8>)
    71d8:	4b33      	ldr	r3, [pc, #204]	; (72a8 <grid_module_common_init+0x1e0>)
    71da:	a803      	add	r0, sp, #12
    71dc:	4798      	blx	r3
		payload_length = strlen(payload_template);
    71de:	a803      	add	r0, sp, #12
    71e0:	47c0      	blx	r8
    71e2:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_RESPONSE, payload_template, payload_length);
    71e4:	6868      	ldr	r0, [r5, #4]
    71e6:	aa03      	add	r2, sp, #12
    71e8:	68c0      	ldr	r0, [r0, #12]
    71ea:	2109      	movs	r1, #9
    71ec:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgrequest
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    71ee:	227e      	movs	r2, #126	; 0x7e
    71f0:	4621      	mov	r1, r4
    71f2:	a804      	add	r0, sp, #16
    71f4:	9403      	str	r4, [sp, #12]
    71f6:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_REQUEST GRID_ACTIONSTRING_CFG_REQUEST);
    71f8:	4932      	ldr	r1, [pc, #200]	; (72c4 <grid_module_common_init+0x1fc>)
    71fa:	4b2b      	ldr	r3, [pc, #172]	; (72a8 <grid_module_common_init+0x1e0>)
    71fc:	a803      	add	r0, sp, #12
    71fe:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7200:	a803      	add	r0, sp, #12
    7202:	47c0      	blx	r8
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7204:	686c      	ldr	r4, [r5, #4]
		payload_length = strlen(payload_template);
    7206:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7208:	aa03      	add	r2, sp, #12
    720a:	68e0      	ldr	r0, [r4, #12]
	}	
	
	
	//enable pwr!
	
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    720c:	4c2e      	ldr	r4, [pc, #184]	; (72c8 <grid_module_common_init+0x200>)
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    720e:	210a      	movs	r1, #10
    7210:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    7212:	492e      	ldr	r1, [pc, #184]	; (72cc <grid_module_common_init+0x204>)
    7214:	482e      	ldr	r0, [pc, #184]	; (72d0 <grid_module_common_init+0x208>)
    7216:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTTGL.reg = PORT_OUT_OUT(mask);
}

static inline void hri_port_set_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7218:	4b2e      	ldr	r3, [pc, #184]	; (72d4 <grid_module_common_init+0x20c>)
    721a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    721e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(UI_PWR_EN, true);

	// ADC SETUP	
	
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    7222:	47b8      	blx	r7
    7224:	4625      	mov	r5, r4
    7226:	b970      	cbnz	r0, 7246 <grid_module_common_init+0x17e>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PO16");
    7228:	492b      	ldr	r1, [pc, #172]	; (72d8 <grid_module_common_init+0x210>)
    722a:	4829      	ldr	r0, [pc, #164]	; (72d0 <grid_module_common_init+0x208>)
    722c:	47a8      	blx	r5
		grid_module_po16_revb_init();
    722e:	4b2b      	ldr	r3, [pc, #172]	; (72dc <grid_module_common_init+0x214>)
	}
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
		grid_module_bu16_revb_init();
    7230:	4798      	blx	r3
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
	}


	grid_sys_init(&grid_sys_state);
    7232:	4b2b      	ldr	r3, [pc, #172]	; (72e0 <grid_module_common_init+0x218>)
    7234:	482b      	ldr	r0, [pc, #172]	; (72e4 <grid_module_common_init+0x21c>)
    7236:	4798      	blx	r3


	grid_nvm_init(&grid_nvm_state, &FLASH_0);
    7238:	492b      	ldr	r1, [pc, #172]	; (72e8 <grid_module_common_init+0x220>)
    723a:	482c      	ldr	r0, [pc, #176]	; (72ec <grid_module_common_init+0x224>)
    723c:	4b2c      	ldr	r3, [pc, #176]	; (72f0 <grid_module_common_init+0x228>)
    723e:	4798      	blx	r3
	
		
}
    7240:	b025      	add	sp, #148	; 0x94
    7242:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    7246:	47b8      	blx	r7
    7248:	2808      	cmp	r0, #8
    724a:	d0ed      	beq.n	7228 <grid_module_common_init+0x160>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    724c:	47b8      	blx	r7
    724e:	2880      	cmp	r0, #128	; 0x80
    7250:	d104      	bne.n	725c <grid_module_common_init+0x194>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
    7252:	4928      	ldr	r1, [pc, #160]	; (72f4 <grid_module_common_init+0x22c>)
    7254:	481e      	ldr	r0, [pc, #120]	; (72d0 <grid_module_common_init+0x208>)
    7256:	47a8      	blx	r5
		grid_module_bu16_revb_init();
    7258:	4b27      	ldr	r3, [pc, #156]	; (72f8 <grid_module_common_init+0x230>)
    725a:	e7e9      	b.n	7230 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    725c:	47b8      	blx	r7
    725e:	2888      	cmp	r0, #136	; 0x88
    7260:	d0f7      	beq.n	7252 <grid_module_common_init+0x18a>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_PBF4_RevA){
    7262:	47b8      	blx	r7
    7264:	2840      	cmp	r0, #64	; 0x40
    7266:	d104      	bne.n	7272 <grid_module_common_init+0x1aa>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PBF4");					
    7268:	4924      	ldr	r1, [pc, #144]	; (72fc <grid_module_common_init+0x234>)
    726a:	4819      	ldr	r0, [pc, #100]	; (72d0 <grid_module_common_init+0x208>)
    726c:	47a0      	blx	r4
		grid_module_pbf4_reva_init();			
    726e:	4b24      	ldr	r3, [pc, #144]	; (7300 <grid_module_common_init+0x238>)
    7270:	e7de      	b.n	7230 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_EN16_RevA){
    7272:	47b8      	blx	r7
    7274:	28c0      	cmp	r0, #192	; 0xc0
    7276:	d104      	bne.n	7282 <grid_module_common_init+0x1ba>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: EN16");
    7278:	4922      	ldr	r1, [pc, #136]	; (7304 <grid_module_common_init+0x23c>)
    727a:	4815      	ldr	r0, [pc, #84]	; (72d0 <grid_module_common_init+0x208>)
    727c:	47a0      	blx	r4
		grid_module_en16_reva_init();	
    727e:	4b22      	ldr	r3, [pc, #136]	; (7308 <grid_module_common_init+0x240>)
    7280:	e7d6      	b.n	7230 <grid_module_common_init+0x168>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
    7282:	4922      	ldr	r1, [pc, #136]	; (730c <grid_module_common_init+0x244>)
    7284:	4812      	ldr	r0, [pc, #72]	; (72d0 <grid_module_common_init+0x208>)
    7286:	47a0      	blx	r4
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
    7288:	4921      	ldr	r1, [pc, #132]	; (7310 <grid_module_common_init+0x248>)
    728a:	4811      	ldr	r0, [pc, #68]	; (72d0 <grid_module_common_init+0x208>)
    728c:	47a0      	blx	r4
    728e:	e7d0      	b.n	7232 <grid_module_common_init+0x16a>
    7290:	200151dc 	.word	0x200151dc
    7294:	00009a71 	.word	0x00009a71
    7298:	000147d1 	.word	0x000147d1
    729c:	00009aa5 	.word	0x00009aa5
    72a0:	0000a3d1 	.word	0x0000a3d1
    72a4:	0001689a 	.word	0x0001689a
    72a8:	00014bbd 	.word	0x00014bbd
    72ac:	00016752 	.word	0x00016752
    72b0:	000098ed 	.word	0x000098ed
    72b4:	00009f35 	.word	0x00009f35
    72b8:	000168ae 	.word	0x000168ae
    72bc:	000168d4 	.word	0x000168d4
    72c0:	000168ed 	.word	0x000168ed
    72c4:	00016913 	.word	0x00016913
    72c8:	000143b9 	.word	0x000143b9
    72cc:	00016939 	.word	0x00016939
    72d0:	000167e3 	.word	0x000167e3
    72d4:	41008000 	.word	0x41008000
    72d8:	00016949 	.word	0x00016949
    72dc:	000083a1 	.word	0x000083a1
    72e0:	00009651 	.word	0x00009651
    72e4:	20007a24 	.word	0x20007a24
    72e8:	20015718 	.word	0x20015718
    72ec:	20008438 	.word	0x20008438
    72f0:	00008cf9 	.word	0x00008cf9
    72f4:	0001695b 	.word	0x0001695b
    72f8:	00007651 	.word	0x00007651
    72fc:	0001696d 	.word	0x0001696d
    7300:	00008045 	.word	0x00008045
    7304:	0001697f 	.word	0x0001697f
    7308:	00007b69 	.word	0x00007b69
    730c:	00016991 	.word	0x00016991
    7310:	000169ad 	.word	0x000169ad
    7314:	00014175 	.word	0x00014175
    7318:	00014c81 	.word	0x00014c81
    731c:	00009a2d 	.word	0x00009a2d

00007320 <grid_module_bu16_revb_hardware_start_transfer>:

static uint8_t grid_bu16_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_bu16_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};
	
	
void grid_module_bu16_revb_hardware_start_transfer(void){
    7320:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7322:	4c04      	ldr	r4, [pc, #16]	; (7334 <grid_module_bu16_revb_hardware_start_transfer+0x14>)
    7324:	4804      	ldr	r0, [pc, #16]	; (7338 <grid_module_bu16_revb_hardware_start_transfer+0x18>)
    7326:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7328:	4623      	mov	r3, r4
    732a:	4804      	ldr	r0, [pc, #16]	; (733c <grid_module_bu16_revb_hardware_start_transfer+0x1c>)

}
    732c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7330:	4718      	bx	r3
    7332:	bf00      	nop
    7334:	0000e4fd 	.word	0x0000e4fd
    7338:	200157a4 	.word	0x200157a4
    733c:	20015978 	.word	0x20015978

00007340 <grid_module_bu16_revb_hardware_transfer_complete_cb>:

static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7340:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    7344:	4aa4      	ldr	r2, [pc, #656]	; (75d8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x298>)
    7346:	7813      	ldrb	r3, [r2, #0]
static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7348:	b08b      	sub	sp, #44	; 0x2c
    734a:	4614      	mov	r4, r2
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    734c:	b933      	cbnz	r3, 735c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_bu16_revb_hardware_transfer_complete++;
    734e:	7813      	ldrb	r3, [r2, #0]
    7350:	3301      	adds	r3, #1
    7352:	b2db      	uxtb	r3, r3
    7354:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_bu16_revb_hardware_transfer_complete = 0;
	grid_module_bu16_revb_hardware_start_transfer();
}
    7356:	b00b      	add	sp, #44	; 0x2c
    7358:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    735c:	4b9f      	ldr	r3, [pc, #636]	; (75dc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x29c>)
    735e:	48a0      	ldr	r0, [pc, #640]	; (75e0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7360:	4d9f      	ldr	r5, [pc, #636]	; (75e0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7362:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7364:	7c6a      	ldrb	r2, [r5, #17]
		bank=0;
    7366:	28ff      	cmp	r0, #255	; 0xff
    7368:	bf14      	ite	ne
    736a:	4603      	movne	r3, r0
    736c:	2300      	moveq	r3, #0
	if (bank_changed){
    736e:	b9fa      	cbnz	r2, 73b0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x70>
	uint16_t adcresult_0 = 0;
    7370:	2300      	movs	r3, #0
    7372:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7376:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    737a:	7863      	ldrb	r3, [r4, #1]
    737c:	4a99      	ldr	r2, [pc, #612]	; (75e4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a4>)
    737e:	3308      	adds	r3, #8
    7380:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7382:	7863      	ldrb	r3, [r4, #1]
    7384:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    7386:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7388:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_bu16_revb_mux++;
    738a:	7863      	ldrb	r3, [r4, #1]
    738c:	3301      	adds	r3, #1
    738e:	b2db      	uxtb	r3, r3
    7390:	7063      	strb	r3, [r4, #1]
	grid_module_bu16_revb_mux%=8;
    7392:	7863      	ldrb	r3, [r4, #1]
    7394:	f003 0307 	and.w	r3, r3, #7
    7398:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_bu16_revb_mux/1%2);
    739a:	7863      	ldrb	r3, [r4, #1]
/**
 * \brief Set output level on port with mask
 */
static inline void _gpio_set_level(const enum gpio_port port, const uint32_t mask, const bool level)
{
	if (level) {
    739c:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    73a0:	b2f6      	uxtb	r6, r6
    73a2:	4b91      	ldr	r3, [pc, #580]	; (75e8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    73a4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    73a8:	d141      	bne.n	742e <grid_module_bu16_revb_hardware_transfer_complete_cb+0xee>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = ~data;
}

static inline void hri_port_clear_OUT_reg(const void *const hw, uint8_t submodule_index, hri_port_out_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    73aa:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    73ae:	e040      	b.n	7432 <grid_module_bu16_revb_hardware_transfer_complete_cb+0xf2>
		grid_sys_state.bank_active_changed = 0;
    73b0:	f04f 0900 	mov.w	r9, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73b4:	fa0f fa83 	sxth.w	sl, r3
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    73b8:	f8df 823c 	ldr.w	r8, [pc, #572]	; 75f8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>
		grid_sys_state.bank_active_changed = 0;
    73bc:	f885 9011 	strb.w	r9, [r5, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73c0:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73c4:	eb04 1703 	add.w	r7, r4, r3, lsl #4
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    73c8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    73cc:	7bea      	ldrb	r2, [r5, #15]
    73ce:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    73d2:	fa5f f689 	uxtb.w	r6, r9
    73d6:	7a5b      	ldrb	r3, [r3, #9]
    73d8:	42b3      	cmp	r3, r6
    73da:	d9c9      	bls.n	7370 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x30>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73dc:	f8d8 2004 	ldr.w	r2, [r8, #4]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    73e0:	f8df b220 	ldr.w	fp, [pc, #544]	; 7604 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c4>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73e4:	4452      	add	r2, sl
    73e6:	2364      	movs	r3, #100	; 0x64
    73e8:	68d2      	ldr	r2, [r2, #12]
    73ea:	4373      	muls	r3, r6
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73ec:	19b9      	adds	r1, r7, r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    73ee:	441a      	add	r2, r3
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73f0:	7888      	ldrb	r0, [r1, #2]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    73f2:	f891 1042 	ldrb.w	r1, [r1, #66]	; 0x42
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    73f6:	6190      	str	r0, [r2, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    73f8:	61d1      	str	r1, [r2, #28]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    73fa:	f8d8 2004 	ldr.w	r2, [r8, #4]
    73fe:	7be9      	ldrb	r1, [r5, #15]
    7400:	eb02 1201 	add.w	r2, r2, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7404:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7406:	68d2      	ldr	r2, [r2, #12]
    7408:	4413      	add	r3, r2
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    740a:	4632      	mov	r2, r6
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    740c:	60de      	str	r6, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    740e:	7be9      	ldrb	r1, [r5, #15]
    7410:	2300      	movs	r3, #0
    7412:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7414:	7be9      	ldrb	r1, [r5, #15]
    7416:	2304      	movs	r3, #4
    7418:	4632      	mov	r2, r6
    741a:	4640      	mov	r0, r8
    741c:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    741e:	7be9      	ldrb	r1, [r5, #15]
    7420:	2305      	movs	r3, #5
    7422:	4632      	mov	r2, r6
    7424:	4640      	mov	r0, r8
    7426:	47d8      	blx	fp
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7428:	f109 0901 	add.w	r9, r9, #1
    742c:	e7cc      	b.n	73c8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x88>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    742e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_bu16_revb_mux/2%2);
    7432:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7434:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 7608 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c8>
    7438:	486c      	ldr	r0, [pc, #432]	; (75ec <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2ac>)
    743a:	f013 0f02 	tst.w	r3, #2
    743e:	4b6a      	ldr	r3, [pc, #424]	; (75e8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7440:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7444:	bf14      	ite	ne
    7446:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    744a:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_bu16_revb_mux/4%2);
    744e:	7863      	ldrb	r3, [r4, #1]
    7450:	f013 0f04 	tst.w	r3, #4
    7454:	4b64      	ldr	r3, [pc, #400]	; (75e8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7456:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    745a:	bf14      	ite	ne
    745c:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7460:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7464:	2100      	movs	r1, #0
    7466:	2302      	movs	r3, #2
    7468:	aa05      	add	r2, sp, #20
    746a:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    746c:	2302      	movs	r3, #2
    746e:	f10d 0216 	add.w	r2, sp, #22
    7472:	485f      	ldr	r0, [pc, #380]	; (75f0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b0>)
    7474:	2100      	movs	r1, #0
    7476:	47c0      	blx	r8
	uint8_t result_value[2] = {0};
    7478:	2300      	movs	r3, #0
    747a:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint8_t result_valid[2] = {0};
    747e:	f8ad 3010 	strh.w	r3, [sp, #16]
	if (adcresult_0>60000){
    7482:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	result_index[0] = adc_index_0;
    7486:	f88d 7008 	strb.w	r7, [sp, #8]
	if (adcresult_0>60000){
    748a:	f64e 2260 	movw	r2, #60000	; 0xea60
    748e:	4293      	cmp	r3, r2
	result_index[1] = adc_index_1;
    7490:	f88d 6009 	strb.w	r6, [sp, #9]
	if (adcresult_0>60000){
    7494:	d978      	bls.n	7588 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x248>
		result_valid[0] = 1;
    7496:	2301      	movs	r3, #1
    7498:	f88d 3010 	strb.w	r3, [sp, #16]
	if (adcresult_1>60000){
    749c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    74a0:	f64e 2260 	movw	r2, #60000	; 0xea60
    74a4:	4293      	cmp	r3, r2
    74a6:	d975      	bls.n	7594 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x254>
		result_value[1] = 0;
    74a8:	2300      	movs	r3, #0
		result_value[1] = 127;
    74aa:	f88d 300d 	strb.w	r3, [sp, #13]
		result_valid[1] = 1;
    74ae:	2301      	movs	r3, #1
    74b0:	f88d 3011 	strb.w	r3, [sp, #17]
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    74b4:	4b4f      	ldr	r3, [pc, #316]	; (75f4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b4>)
    74b6:	ae06      	add	r6, sp, #24
    74b8:	f103 0710 	add.w	r7, r3, #16
    74bc:	6818      	ldr	r0, [r3, #0]
    74be:	6859      	ldr	r1, [r3, #4]
    74c0:	4632      	mov	r2, r6
    74c2:	c203      	stmia	r2!, {r0, r1}
    74c4:	3308      	adds	r3, #8
    74c6:	42bb      	cmp	r3, r7
    74c8:	4616      	mov	r6, r2
    74ca:	d1f7      	bne.n	74bc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74cc:	484a      	ldr	r0, [pc, #296]	; (75f8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    74ce:	2300      	movs	r3, #0
    74d0:	f10d 0908 	add.w	r9, sp, #8
    74d4:	f10d 0b0c 	add.w	fp, sp, #12
    74d8:	9301      	str	r3, [sp, #4]
    74da:	4682      	mov	sl, r0
		uint8_t res_index = result_index[i];
    74dc:	f819 6b01 	ldrb.w	r6, [r9], #1
		uint8_t res_value = result_value[i];
    74e0:	f81b 8b01 	ldrb.w	r8, [fp], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74e4:	6843      	ldr	r3, [r0, #4]
    74e6:	7bea      	ldrb	r2, [r5, #15]
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74e8:	19a1      	adds	r1, r4, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74ea:	b2d2      	uxtb	r2, r2
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74ec:	f891 c082 	ldrb.w	ip, [r1, #130]	; 0x82
    74f0:	45e0      	cmp	r8, ip
    74f2:	d042      	beq.n	757a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
    74f4:	9f01      	ldr	r7, [sp, #4]
		uint8_t res_valid = result_valid[i];
    74f6:	a904      	add	r1, sp, #16
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    74f8:	5c79      	ldrb	r1, [r7, r1]
    74fa:	2901      	cmp	r1, #1
    74fc:	d13d      	bne.n	757a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    74fe:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    7502:	2164      	movs	r1, #100	; 0x64
    7504:	68db      	ldr	r3, [r3, #12]
    7506:	fb16 f101 	smulbb	r1, r6, r1
    750a:	440b      	add	r3, r1
			if (grid_bu16_helper_template_b_abs[res_index] == 0){ // Button Press Event
    750c:	f1bc 0f00 	cmp.w	ip, #0
    7510:	d14d      	bne.n	75ae <grid_module_bu16_revb_hardware_transfer_complete_cb+0x26e>
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7512:	699a      	ldr	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7514:	f8d3 e01c 	ldr.w	lr, [r3, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7518:	2a00      	cmp	r2, #0
    751a:	bf0c      	ite	eq
    751c:	227f      	moveq	r2, #127	; 0x7f
    751e:	2200      	movne	r2, #0
    7520:	619a      	str	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7522:	f1be 0f00 	cmp.w	lr, #0
    7526:	d13c      	bne.n	75a2 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x262>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7528:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    752c:	f8c3 c01c 	str.w	ip, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7530:	f895 c00f 	ldrb.w	ip, [r5, #15]
    7534:	9f01      	ldr	r7, [sp, #4]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7536:	69db      	ldr	r3, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7538:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
    753c:	44bc      	add	ip, r7
    753e:	f88c 2002 	strb.w	r2, [ip, #2]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7542:	7bea      	ldrb	r2, [r5, #15]
    7544:	eb04 1202 	add.w	r2, r4, r2, lsl #4
    7548:	443a      	add	r2, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    754a:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    754e:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
    7552:	2300      	movs	r3, #0
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7554:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7558:	441a      	add	r2, r3
    755a:	3310      	adds	r3, #16
    755c:	68d2      	ldr	r2, [r2, #12]
    755e:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7560:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7562:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7566:	d1f5      	bne.n	7554 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x214>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7568:	7be9      	ldrb	r1, [r5, #15]
    756a:	2304      	movs	r3, #4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    756c:	4632      	mov	r2, r6
    756e:	4f23      	ldr	r7, [pc, #140]	; (75fc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2bc>)
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7570:	4426      	add	r6, r4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7572:	47b8      	blx	r7
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7574:	4820      	ldr	r0, [pc, #128]	; (75f8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
    7576:	f886 8082 	strb.w	r8, [r6, #130]	; 0x82
	for (uint8_t i=0; i<2; i++)
    757a:	9b01      	ldr	r3, [sp, #4]
    757c:	b173      	cbz	r3, 759c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x25c>
	grid_module_bu16_revb_hardware_transfer_complete = 0;
    757e:	2300      	movs	r3, #0
    7580:	7023      	strb	r3, [r4, #0]
	grid_module_bu16_revb_hardware_start_transfer();
    7582:	4b1f      	ldr	r3, [pc, #124]	; (7600 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c0>)
    7584:	4798      	blx	r3
    7586:	e6e6      	b.n	7356 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16>
	else if (adcresult_0<200){
    7588:	2bc7      	cmp	r3, #199	; 0xc7
    758a:	d887      	bhi.n	749c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x15c>
		result_value[0] = 127;
    758c:	237f      	movs	r3, #127	; 0x7f
    758e:	f88d 300c 	strb.w	r3, [sp, #12]
    7592:	e780      	b.n	7496 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x156>
	else if (adcresult_1<200){
    7594:	2bc7      	cmp	r3, #199	; 0xc7
    7596:	d88d      	bhi.n	74b4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x174>
		result_value[1] = 127;
    7598:	237f      	movs	r3, #127	; 0x7f
    759a:	e786      	b.n	74aa <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16a>
    759c:	2301      	movs	r3, #1
    759e:	9301      	str	r3, [sp, #4]
    75a0:	e79c      	b.n	74dc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x19c>
				else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    75a2:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    75a6:	bf08      	it	eq
    75a8:	f04f 0c7f 	moveq.w	ip, #127	; 0x7f
    75ac:	e7be      	b.n	752c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1ec>
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    75ae:	aa0a      	add	r2, sp, #40	; 0x28
    75b0:	4432      	add	r2, r6
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    75b2:	60de      	str	r6, [r3, #12]
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    75b4:	f812 2c10 	ldrb.w	r2, [r2, #-16]
    75b8:	611a      	str	r2, [r3, #16]
    75ba:	2300      	movs	r3, #0
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    75bc:	469c      	mov	ip, r3
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    75be:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    75c2:	441a      	add	r2, r3
    75c4:	3310      	adds	r3, #16
    75c6:	68d2      	ldr	r2, [r2, #12]
    75c8:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    75ca:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    75cc:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    75d0:	d1f5      	bne.n	75be <grid_module_bu16_revb_hardware_transfer_complete_cb+0x27e>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    75d2:	7be9      	ldrb	r1, [r5, #15]
    75d4:	2305      	movs	r3, #5
    75d6:	e7c9      	b.n	756c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x22c>
    75d8:	200005ec 	.word	0x200005ec
    75dc:	00009707 	.word	0x00009707
    75e0:	20007a24 	.word	0x20007a24
    75e4:	20000308 	.word	0x20000308
    75e8:	41008000 	.word	0x41008000
    75ec:	200157a4 	.word	0x200157a4
    75f0:	20015978 	.word	0x20015978
    75f4:	000169bc 	.word	0x000169bc
    75f8:	20007a18 	.word	0x20007a18
    75fc:	0000a191 	.word	0x0000a191
    7600:	00007321 	.word	0x00007321
    7604:	0000a4e5 	.word	0x0000a4e5
    7608:	0000e441 	.word	0x0000e441

0000760c <grid_module_bu16_revb_hardware_init>:

void grid_module_bu16_revb_hardware_init(void){
    760c:	b570      	push	{r4, r5, r6, lr}
	

	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    760e:	4c0b      	ldr	r4, [pc, #44]	; (763c <grid_module_bu16_revb_hardware_init+0x30>)
    7610:	4e0b      	ldr	r6, [pc, #44]	; (7640 <grid_module_bu16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7612:	4d0c      	ldr	r5, [pc, #48]	; (7644 <grid_module_bu16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7614:	4b0c      	ldr	r3, [pc, #48]	; (7648 <grid_module_bu16_revb_hardware_init+0x3c>)
    7616:	2200      	movs	r2, #0
    7618:	4611      	mov	r1, r2
    761a:	4620      	mov	r0, r4
    761c:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    761e:	2200      	movs	r2, #0
    7620:	4b09      	ldr	r3, [pc, #36]	; (7648 <grid_module_bu16_revb_hardware_init+0x3c>)
    7622:	4611      	mov	r1, r2
    7624:	4628      	mov	r0, r5
    7626:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    7628:	4620      	mov	r0, r4
    762a:	4c08      	ldr	r4, [pc, #32]	; (764c <grid_module_bu16_revb_hardware_init+0x40>)
    762c:	2100      	movs	r1, #0
    762e:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    7630:	4628      	mov	r0, r5
    7632:	4623      	mov	r3, r4
    7634:	2100      	movs	r1, #0

}
    7636:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    763a:	4718      	bx	r3
    763c:	200157a4 	.word	0x200157a4
    7640:	0000e3c9 	.word	0x0000e3c9
    7644:	20015978 	.word	0x20015978
    7648:	00007341 	.word	0x00007341
    764c:	0000e389 	.word	0x0000e389

00007650 <grid_module_bu16_revb_init>:



void grid_module_bu16_revb_init(){
    7650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	grid_led_lowlevel_init(&grid_led_state, 16);
    7654:	4b12      	ldr	r3, [pc, #72]	; (76a0 <grid_module_bu16_revb_init+0x50>)
    7656:	4813      	ldr	r0, [pc, #76]	; (76a4 <grid_module_bu16_revb_init+0x54>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7658:	4e13      	ldr	r6, [pc, #76]	; (76a8 <grid_module_bu16_revb_init+0x58>)
    765a:	4f14      	ldr	r7, [pc, #80]	; (76ac <grid_module_bu16_revb_init+0x5c>)
		
		for (uint8_t j=0; j<16; j++){

			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    765c:	f8df 805c 	ldr.w	r8, [pc, #92]	; 76bc <grid_module_bu16_revb_init+0x6c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7660:	2110      	movs	r1, #16
    7662:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    7664:	4810      	ldr	r0, [pc, #64]	; (76a8 <grid_module_bu16_revb_init+0x58>)
    7666:	4b12      	ldr	r3, [pc, #72]	; (76b0 <grid_module_bu16_revb_init+0x60>)
    7668:	2104      	movs	r1, #4
    766a:	4798      	blx	r3
    766c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    766e:	2210      	movs	r2, #16
    7670:	b2e1      	uxtb	r1, r4
    7672:	4630      	mov	r0, r6
    7674:	47b8      	blx	r7
		for (uint8_t j=0; j<16; j++){
    7676:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    767a:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    767c:	6870      	ldr	r0, [r6, #4]
    767e:	b2e9      	uxtb	r1, r5
    7680:	2202      	movs	r2, #2
    7682:	4448      	add	r0, r9
    7684:	3501      	adds	r5, #1
    7686:	47c0      	blx	r8
		for (uint8_t j=0; j<16; j++){
    7688:	2d10      	cmp	r5, #16
    768a:	d1f7      	bne.n	767c <grid_module_bu16_revb_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    768c:	3401      	adds	r4, #1
    768e:	2c04      	cmp	r4, #4
    7690:	d1ed      	bne.n	766e <grid_module_bu16_revb_init+0x1e>

		}		
		
	}
				
	grid_module_bu16_revb_hardware_init();
    7692:	4b08      	ldr	r3, [pc, #32]	; (76b4 <grid_module_bu16_revb_init+0x64>)
    7694:	4798      	blx	r3
	grid_module_bu16_revb_hardware_start_transfer();

};
    7696:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_bu16_revb_hardware_start_transfer();
    769a:	4b07      	ldr	r3, [pc, #28]	; (76b8 <grid_module_bu16_revb_init+0x68>)
    769c:	4718      	bx	r3
    769e:	bf00      	nop
    76a0:	00006f19 	.word	0x00006f19
    76a4:	20015254 	.word	0x20015254
    76a8:	20007a18 	.word	0x20007a18
    76ac:	00009aa5 	.word	0x00009aa5
    76b0:	00009a71 	.word	0x00009a71
    76b4:	0000760d 	.word	0x0000760d
    76b8:	00007321 	.word	0x00007321
    76bc:	0000a3d1 	.word	0x0000a3d1

000076c0 <grid_module_en16_reva_hardware_start_transfer>:





void grid_module_en16_reva_hardware_start_transfer(void){
    76c0:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    76c2:	4b08      	ldr	r3, [pc, #32]	; (76e4 <grid_module_en16_reva_hardware_start_transfer+0x24>)
	

	gpio_set_pin_level(PIN_UI_SPI_CS0, true);

	spi_m_async_enable(&UI_SPI);
    76c4:	4808      	ldr	r0, [pc, #32]	; (76e8 <grid_module_en16_reva_hardware_start_transfer+0x28>)

	//io_write(io, UI_SPI_TX_BUFFER, 8);
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    76c6:	4c09      	ldr	r4, [pc, #36]	; (76ec <grid_module_en16_reva_hardware_start_transfer+0x2c>)
    76c8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    76cc:	619a      	str	r2, [r3, #24]
	spi_m_async_enable(&UI_SPI);
    76ce:	4b08      	ldr	r3, [pc, #32]	; (76f0 <grid_module_en16_reva_hardware_start_transfer+0x30>)
    76d0:	4798      	blx	r3
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    76d2:	4a08      	ldr	r2, [pc, #32]	; (76f4 <grid_module_en16_reva_hardware_start_transfer+0x34>)
    76d4:	4804      	ldr	r0, [pc, #16]	; (76e8 <grid_module_en16_reva_hardware_start_transfer+0x28>)
    76d6:	46a4      	mov	ip, r4
    76d8:	2308      	movs	r3, #8

}
    76da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    76de:	f102 010e 	add.w	r1, r2, #14
    76e2:	4760      	bx	ip
    76e4:	41008000 	.word	0x41008000
    76e8:	20015690 	.word	0x20015690
    76ec:	0000f0c5 	.word	0x0000f0c5
    76f0:	0000f025 	.word	0x0000f025
    76f4:	2000067e 	.word	0x2000067e

000076f8 <grid_module_en16_reva_hardware_transfer_complete_cb>:

void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    76f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    76fc:	4ba8      	ldr	r3, [pc, #672]	; (79a0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2a8>)
	
	// Set the shift registers to continuously load data until new transaction is issued
	gpio_set_pin_level(PIN_UI_SPI_CS0, false);


	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    76fe:	48a9      	ldr	r0, [pc, #676]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
	if (bank == 255){
		bank=0;
	}


	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7700:	4fa8      	ldr	r7, [pc, #672]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7702:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7706:	615a      	str	r2, [r3, #20]
void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    7708:	b089      	sub	sp, #36	; 0x24
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    770a:	4ba7      	ldr	r3, [pc, #668]	; (79a8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b0>)
    770c:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    770e:	7c7b      	ldrb	r3, [r7, #17]
		bank=0;
    7710:	28ff      	cmp	r0, #255	; 0xff
    7712:	bf14      	ite	ne
    7714:	4606      	movne	r6, r0
    7716:	2600      	moveq	r6, #0
		
	if (bank_changed){
    7718:	2b00      	cmp	r3, #0
    771a:	f040 815f 	bne.w	79dc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e4>
		

		uint8_t i = UI_ENCODER_LOOKUP[j];
		

		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    771e:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 79d8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e0>
				uint8_t controlnumber = i;
 
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 

				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    7722:	0133      	lsls	r3, r6, #4
    7724:	9302      	str	r3, [sp, #8]
    7726:	eb08 1306 	add.w	r3, r8, r6, lsl #4
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    772a:	f04f 0b00 	mov.w	fp, #0
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    772e:	9303      	str	r3, [sp, #12]
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7730:	f3cb 0346 	ubfx	r3, fp, #1, #7
    7734:	f00b 0201 	and.w	r2, fp, #1
    7738:	f818 3003 	ldrb.w	r3, [r8, r3]
    773c:	0092      	lsls	r2, r2, #2
    773e:	4113      	asrs	r3, r2
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    7740:	eb08 020b 	add.w	r2, r8, fp
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7744:	b2de      	uxtb	r6, r3
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    7746:	f892 015c 	ldrb.w	r0, [r2, #348]	; 0x15c
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    774a:	f003 030f 	and.w	r3, r3, #15
		if (old_value != new_value){
    774e:	4283      	cmp	r3, r0
    7750:	fa5f f18b 	uxtb.w	r1, fp
    7754:	f000 8115 	beq.w	7982 <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7758:	4894      	ldr	r0, [pc, #592]	; (79ac <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b4>)
            UI_SPI_RX_BUFFER_LAST[j] = new_value;
    775a:	f882 315c 	strb.w	r3, [r2, #348]	; 0x15c
			UI_SPI_DEBUG = j;
    775e:	4a94      	ldr	r2, [pc, #592]	; (79b0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b8>)
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7760:	f81b 4000 	ldrb.w	r4, [fp, r0]
			UI_SPI_DEBUG = j;
    7764:	7011      	strb	r1, [r2, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    7766:	4d93      	ldr	r5, [pc, #588]	; (79b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2bc>)
			uint8_t button_value = (new_value&0b00000100)?1:0;
    7768:	f3c3 0280 	ubfx	r2, r3, #2, #1
    776c:	9201      	str	r2, [sp, #4]
            uint8_t phase_a      = (new_value&0b00000010)?1:0;
    776e:	f3c3 0240 	ubfx	r2, r3, #1, #1
    7772:	9200      	str	r2, [sp, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    7774:	eb05 1204 	add.w	r2, r5, r4, lsl #4
    7778:	9801      	ldr	r0, [sp, #4]
    777a:	7851      	ldrb	r1, [r2, #1]
    777c:	4281      	cmp	r1, r0
			uint8_t phase_b      = (new_value&0b00000001)?1:0;
    777e:	f006 0601 	and.w	r6, r6, #1
			if (button_value != grid_ui_encoder_array[i].button_value){
    7782:	ea4f 1704 	mov.w	r7, r4, lsl #4
    7786:	d04d      	beq.n	7824 <grid_module_en16_reva_hardware_transfer_complete_cb+0x12c>
				grid_ui_encoder_array[i].button_changed = 1;
    7788:	2101      	movs	r1, #1
				grid_ui_encoder_array[i].button_value = new_value>>2;
    778a:	089b      	lsrs	r3, r3, #2
				grid_ui_encoder_array[i].button_changed = 1;
    778c:	7091      	strb	r1, [r2, #2]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    778e:	f8df a214 	ldr.w	sl, [pc, #532]	; 79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>
				grid_ui_encoder_array[i].button_value = new_value>>2;
    7792:	7053      	strb	r3, [r2, #1]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7794:	4a88      	ldr	r2, [pc, #544]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7796:	f8df c230 	ldr.w	ip, [pc, #560]	; 79c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    779a:	6852      	ldr	r2, [r2, #4]
    779c:	f89a 100f 	ldrb.w	r1, [sl, #15]
    77a0:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    77a4:	2164      	movs	r1, #100	; 0x64
    77a6:	68d2      	ldr	r2, [r2, #12]
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    77a8:	f10d 0910 	add.w	r9, sp, #16
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    77ac:	fb04 2201 	mla	r2, r4, r1, r2
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    77b0:	f8dc 1004 	ldr.w	r1, [ip, #4]
    77b4:	f8dc 0000 	ldr.w	r0, [ip]
    77b8:	46ce      	mov	lr, r9
    77ba:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    77be:	497f      	ldr	r1, [pc, #508]	; (79bc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    77c0:	f10c 0c08 	add.w	ip, ip, #8
    77c4:	458c      	cmp	ip, r1
    77c6:	46f1      	mov	r9, lr
    77c8:	d1f2      	bne.n	77b0 <grid_module_en16_reva_hardware_transfer_complete_cb+0xb8>
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    77ca:	a908      	add	r1, sp, #32
    77cc:	4421      	add	r1, r4
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    77ce:	60d4      	str	r4, [r2, #12]
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    77d0:	2b00      	cmp	r3, #0
    77d2:	f040 8152 	bne.w	7a7a <grid_module_en16_reva_hardware_transfer_complete_cb+0x382>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    77d6:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    77da:	6111      	str	r1, [r2, #16]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    77dc:	6991      	ldr	r1, [r2, #24]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    77de:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    77e2:	2900      	cmp	r1, #0
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    77e4:	69d1      	ldr	r1, [r2, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    77e6:	f8c2 c014 	str.w	ip, [r2, #20]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    77ea:	bf0c      	ite	eq
    77ec:	4660      	moveq	r0, ip
    77ee:	2000      	movne	r0, #0
    77f0:	6190      	str	r0, [r2, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    77f2:	2900      	cmp	r1, #0
    77f4:	f040 813d 	bne.w	7a72 <grid_module_en16_reva_hardware_transfer_complete_cb+0x37a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    77f8:	233f      	movs	r3, #63	; 0x3f
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    77fa:	496a      	ldr	r1, [pc, #424]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    77fc:	61d3      	str	r3, [r2, #28]
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    77fe:	7bcb      	ldrb	r3, [r1, #15]
    7800:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    7804:	4423      	add	r3, r4
    7806:	7718      	strb	r0, [r3, #28]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7808:	7bcb      	ldrb	r3, [r1, #15]
    780a:	69d2      	ldr	r2, [r2, #28]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    780c:	7bc9      	ldrb	r1, [r1, #15]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    780e:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    7812:	4423      	add	r3, r4
    7814:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7818:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    781a:	4867      	ldr	r0, [pc, #412]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    781c:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 79cc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>
    7820:	4622      	mov	r2, r4
    7822:	47c8      	blx	r9
            if (a_now == 1 && b_now == 1){ //detent found
    7824:	9b00      	ldr	r3, [sp, #0]
    7826:	2b00      	cmp	r3, #0
    7828:	f000 8155 	beq.w	7ad6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3de>
    782c:	2e00      	cmp	r6, #0
    782e:	f000 8155 	beq.w	7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
			uint8_t b_prev = grid_ui_encoder_array[i].phase_b_previous;
    7832:	19eb      	adds	r3, r5, r7
                if (b_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7834:	7b9a      	ldrb	r2, [r3, #14]
    7836:	2a00      	cmp	r2, #0
    7838:	f040 8128 	bne.w	7a8c <grid_module_en16_reva_hardware_transfer_complete_cb+0x394>
    783c:	7bd9      	ldrb	r1, [r3, #15]
    783e:	2900      	cmp	r1, #0
    7840:	f040 814c 	bne.w	7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7844:	2201      	movs	r2, #1
    7846:	73da      	strb	r2, [r3, #15]
                    delta = -1;
    7848:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			grid_ui_encoder_array[i].phase_a_previous = a_now;
    784c:	442f      	add	r7, r5
    784e:	9b00      	ldr	r3, [sp, #0]
    7850:	737b      	strb	r3, [r7, #13]
			grid_ui_encoder_array[i].phase_b_previous = b_now;
    7852:	73be      	strb	r6, [r7, #14]
			if (delta != 0){
    7854:	f1b9 0f00 	cmp.w	r9, #0
    7858:	f000 8093 	beq.w	7982 <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
				uint32_t elapsed_time = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_ui_encoder_array[i].last_real_time);
    785c:	68b9      	ldr	r1, [r7, #8]
    785e:	4851      	ldr	r0, [pc, #324]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7860:	4b57      	ldr	r3, [pc, #348]	; (79c0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c8>)
    7862:	4798      	blx	r3
				if (elapsed_ms>25){
    7864:	f5b0 7fd0 	cmp.w	r0, #416	; 0x1a0
    7868:	f080 811b 	bcs.w	7aa2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3aa>
                uint32_t elapsed_ms = elapsed_time/RTC1MS;
    786c:	0900      	lsrs	r0, r0, #4
    786e:	2801      	cmp	r0, #1
    7870:	bf38      	it	cc
    7872:	2001      	movcc	r0, #1
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7874:	4e4b      	ldr	r6, [pc, #300]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7876:	4b53      	ldr	r3, [pc, #332]	; (79c4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2cc>)
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7878:	f240 2771 	movw	r7, #625	; 0x271
    787c:	fb00 7010 	mls	r0, r0, r0, r7
    7880:	2796      	movs	r7, #150	; 0x96
    7882:	fbb0 f7f7 	udiv	r7, r0, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7886:	4630      	mov	r0, r6
    7888:	4798      	blx	r3
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    788a:	4a4b      	ldr	r2, [pc, #300]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    788c:	6852      	ldr	r2, [r2, #4]
    788e:	7bf1      	ldrb	r1, [r6, #15]
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7890:	4e4d      	ldr	r6, [pc, #308]	; (79c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>)
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7892:	eb02 1201 	add.w	r2, r2, r1, lsl #4
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7896:	3701      	adds	r7, #1
    7898:	b2ff      	uxtb	r7, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    789a:	eb05 1504 	add.w	r5, r5, r4, lsl #4
				delta_high = delta * (velocityfactor * 2 - 1);
    789e:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    78a2:	eb0a 0a47 	add.w	sl, sl, r7, lsl #1
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    78a6:	68d2      	ldr	r2, [r2, #12]
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    78a8:	60a8      	str	r0, [r5, #8]
				delta_high = delta * (velocityfactor * 2 - 1);
    78aa:	fb0a fa09 	mul.w	sl, sl, r9
				delta_low =  delta * velocityfactor;			
    78ae:	fb07 f509 	mul.w	r5, r7, r9
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    78b2:	2164      	movs	r1, #100	; 0x64
				delta_low =  delta * velocityfactor;			
    78b4:	b2ab      	uxth	r3, r5
				delta_high = delta * (velocityfactor * 2 - 1);
    78b6:	fa1f f78a 	uxth.w	r7, sl
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    78ba:	fb04 2201 	mla	r2, r4, r1, r2
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    78be:	f10d 0e10 	add.w	lr, sp, #16
    78c2:	6871      	ldr	r1, [r6, #4]
    78c4:	6830      	ldr	r0, [r6, #0]
    78c6:	46f4      	mov	ip, lr
    78c8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    78cc:	493b      	ldr	r1, [pc, #236]	; (79bc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    78ce:	3608      	adds	r6, #8
    78d0:	428e      	cmp	r6, r1
    78d2:	46e6      	mov	lr, ip
    78d4:	d1f5      	bne.n	78c2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x1ca>
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    78d6:	a908      	add	r1, sp, #32
    78d8:	4421      	add	r1, r4
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    78da:	6214      	str	r4, [r2, #32]
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    78dc:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    78e0:	6251      	str	r1, [r2, #36]	; 0x24
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    78e2:	9903      	ldr	r1, [sp, #12]
    78e4:	4421      	add	r1, r4
    78e6:	f891 c09c 	ldrb.w	ip, [r1, #156]	; 0x9c
				uint8_t new_abs_low_velocity_value = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    78ea:	f891 60dc 	ldrb.w	r6, [r1, #220]	; 0xdc
				uint8_t new_abs_high_velocity_value = grid_en16_helper_template_e_abs_high_velocity[bank][i];
    78ee:	f891 011c 	ldrb.w	r0, [r1, #284]	; 0x11c
                
				uint8_t new_rel_no_velocity_value =  template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL];
    78f2:	f892 1034 	ldrb.w	r1, [r2, #52]	; 0x34
				
				if (delta != 0){
                    
                    
                    // ABSOLUTE NO VELOCITY						
					if (new_abs_no_velocity_value + delta < 0){
    78f6:	44cc      	add	ip, r9
    78f8:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
    78fc:	f000 80d3 	beq.w	7aa6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ae>
						new_abs_no_velocity_value = 0;
					}
					else if (new_abs_no_velocity_value + delta > 127){
    7900:	f1bc 0f7f 	cmp.w	ip, #127	; 0x7f
    7904:	f300 80d2 	bgt.w	7aac <grid_module_en16_reva_hardware_transfer_complete_cb+0x3b4>
						new_abs_no_velocity_value = 127;
					}
					else{
						new_abs_no_velocity_value += delta;
    7908:	fa5f fc8c 	uxtb.w	ip, ip
					}	
                    
                    // ABSOLUTE LOW VELOCITY						
					if (new_abs_low_velocity_value + delta_low < 0){
    790c:	1975      	adds	r5, r6, r5
    790e:	b2db      	uxtb	r3, r3
    7910:	f100 80cf 	bmi.w	7ab2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ba>
						new_abs_low_velocity_value = 0;
					}
					else if (new_abs_low_velocity_value + delta_low > 127){
    7914:	2d7f      	cmp	r5, #127	; 0x7f
    7916:	f300 80ce 	bgt.w	7ab6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3be>
						new_abs_low_velocity_value = 127;
					}
					else{
						new_abs_low_velocity_value += delta_low;
    791a:	441e      	add	r6, r3
    791c:	b2f6      	uxtb	r6, r6
					}	
  					
                    // ABSOLUTE HIGH VELOCITY						
					if (new_abs_high_velocity_value + delta_high < 0){
    791e:	eb10 0a0a 	adds.w	sl, r0, sl
    7922:	b2ff      	uxtb	r7, r7
    7924:	f100 80c9 	bmi.w	7aba <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c2>
						new_abs_high_velocity_value = 0;
					}
					else if (new_abs_high_velocity_value + delta_high > 127){
    7928:	f1ba 0f7f 	cmp.w	sl, #127	; 0x7f
    792c:	f300 80c7 	bgt.w	7abe <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c6>
						new_abs_high_velocity_value = 127;
					}
					else{
						new_abs_high_velocity_value += delta_high;
    7930:	4438      	add	r0, r7
    7932:	b2c0      	uxtb	r0, r0
					}	



                    // RELATIVE NO VELOCITY
					if (new_rel_no_velocity_value == 255){
    7934:	29ff      	cmp	r1, #255	; 0xff
    7936:	f040 80c4 	bne.w	7ac2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ca>
						if (delta>0){
							new_rel_no_velocity_value = 65;
						}
						else{
							new_rel_no_velocity_value = 63;
    793a:	f1b9 0f01 	cmp.w	r9, #1
					}
                    
                    // RELATIVE LOW VELOCITY
					if (new_rel_low_velocity_value == 255){
                        
                        new_rel_low_velocity_value = 64 + delta_low;
    793e:	f103 0340 	add.w	r3, r3, #64	; 0x40
							new_rel_no_velocity_value = 63;
    7942:	bf0c      	ite	eq
    7944:	2541      	moveq	r5, #65	; 0x41
    7946:	253f      	movne	r5, #63	; 0x3f
                        new_rel_low_velocity_value = 64 + delta_low;
    7948:	b2db      	uxtb	r3, r3
					}
                    
                    // RELATIVE HIGH VELOCITY
					if (new_rel_high_velocity_value == 255){
				
                        new_rel_high_velocity_value = 64 + delta_high;
    794a:	3740      	adds	r7, #64	; 0x40
	
                    
                    
					
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = new_rel_no_velocity_value;
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = new_rel_low_velocity_value;
    794c:	e9c2 530d 	strd	r5, r3, [r2, #52]	; 0x34
                    
                    
                    
                    
                    
                    if (button_value == 1){
    7950:	9b01      	ldr	r3, [sp, #4]
    7952:	4914      	ldr	r1, [pc, #80]	; (79a4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7954:	4d1d      	ldr	r5, [pc, #116]	; (79cc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>)
						new_rel_high_velocity_value += delta_high;
    7956:	b2ff      	uxtb	r7, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = new_rel_high_velocity_value;
    7958:	63d7      	str	r7, [r2, #60]	; 0x3c
                    if (button_value == 1){
    795a:	2b00      	cmp	r3, #0
    795c:	f000 80b8 	beq.w	7ad0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3d8>
                        
                        // ABS is only updated if nonpush rotation event happened
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7960:	9b02      	ldr	r3, [sp, #8]
                        
                        // ABS high velocity
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
                        
                        
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    7962:	7bc9      	ldrb	r1, [r1, #15]
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7964:	4443      	add	r3, r8
    7966:	4423      	add	r3, r4
    7968:	f883 c09c 	strb.w	ip, [r3, #156]	; 0x9c
                        grid_en16_helper_template_e_abs_low_velocity[bank][i] = new_abs_low_velocity_value;
    796c:	f883 60dc 	strb.w	r6, [r3, #220]	; 0xdc
                        grid_en16_helper_template_e_abs_high_velocity[bank][i] = new_abs_high_velocity_value;
    7970:	f883 011c 	strb.w	r0, [r3, #284]	; 0x11c
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = new_abs_low_velocity_value;
    7974:	e9c2 c60a 	strd	ip, r6, [r2, #40]	; 0x28
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
    7978:	6310      	str	r0, [r2, #48]	; 0x30
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    797a:	2301      	movs	r3, #1
                    }
                    else{
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    797c:	480e      	ldr	r0, [pc, #56]	; (79b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    797e:	4622      	mov	r2, r4
    7980:	47a8      	blx	r5
	for (uint8_t j=0; j<16; j++){
    7982:	f10b 0b01 	add.w	fp, fp, #1
    7986:	f1bb 0f10 	cmp.w	fp, #16
    798a:	f47f aed1 	bne.w	7730 <grid_module_en16_reva_hardware_transfer_complete_cb+0x38>

			
	}
		

	grid_module_en16_reva_hardware_transfer_complete = 0;
    798e:	4b10      	ldr	r3, [pc, #64]	; (79d0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d8>)
    7990:	2200      	movs	r2, #0
    7992:	701a      	strb	r2, [r3, #0]
	grid_module_en16_reva_hardware_start_transfer();
    7994:	4b0f      	ldr	r3, [pc, #60]	; (79d4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2dc>)
}
    7996:	b009      	add	sp, #36	; 0x24
    7998:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_module_en16_reva_hardware_start_transfer();
    799c:	4718      	bx	r3
    799e:	bf00      	nop
    79a0:	41008000 	.word	0x41008000
    79a4:	20007a24 	.word	0x20007a24
    79a8:	00009707 	.word	0x00009707
    79ac:	20000318 	.word	0x20000318
    79b0:	20004ab9 	.word	0x20004ab9
    79b4:	2001218c 	.word	0x2001218c
    79b8:	20007a18 	.word	0x20007a18
    79bc:	000169dc 	.word	0x000169dc
    79c0:	000097ad 	.word	0x000097ad
    79c4:	000097a9 	.word	0x000097a9
    79c8:	000169cc 	.word	0x000169cc
    79cc:	0000a191 	.word	0x0000a191
    79d0:	20015270 	.word	0x20015270
    79d4:	000076c1 	.word	0x000076c1
    79d8:	2000067e 	.word	0x2000067e
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79dc:	b233      	sxth	r3, r6
		grid_sys_state.bank_active_changed = 0;
    79de:	2400      	movs	r4, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79e0:	ea4f 1b03 	mov.w	fp, r3, lsl #4
    79e4:	f8df 8108 	ldr.w	r8, [pc, #264]	; 7af0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f8>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    79e8:	f8df a108 	ldr.w	sl, [pc, #264]	; 7af4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3fc>
		grid_sys_state.bank_active_changed = 0;
    79ec:	747c      	strb	r4, [r7, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79ee:	465d      	mov	r5, fp
    79f0:	f8d8 3004 	ldr.w	r3, [r8, #4]
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    79f4:	f8df c100 	ldr.w	ip, [pc, #256]	; 7af8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x400>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    79f8:	445b      	add	r3, fp
    79fa:	2164      	movs	r1, #100	; 0x64
    79fc:	68db      	ldr	r3, [r3, #12]
    79fe:	b2e2      	uxtb	r2, r4
    7a00:	fb01 3304 	mla	r3, r1, r4, r3
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7a04:	f10d 0e10 	add.w	lr, sp, #16
    7a08:	f8dc 1004 	ldr.w	r1, [ip, #4]
    7a0c:	f8dc 0000 	ldr.w	r0, [ip]
    7a10:	46f1      	mov	r9, lr
    7a12:	e8a9 0003 	stmia.w	r9!, {r0, r1}
    7a16:	4933      	ldr	r1, [pc, #204]	; (7ae4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ec>)
    7a18:	f10c 0c08 	add.w	ip, ip, #8
    7a1c:	458c      	cmp	ip, r1
    7a1e:	46ce      	mov	lr, r9
    7a20:	d1f2      	bne.n	7a08 <grid_module_en16_reva_hardware_transfer_complete_cb+0x310>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a22:	a904      	add	r1, sp, #16
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7a24:	60dc      	str	r4, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a26:	5d09      	ldrb	r1, [r1, r4]
    7a28:	6119      	str	r1, [r3, #16]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    7a2a:	f815 000a 	ldrb.w	r0, [r5, sl]
    7a2e:	6198      	str	r0, [r3, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    7a30:	482d      	ldr	r0, [pc, #180]	; (7ae8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f0>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a32:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 7afc <grid_module_en16_reva_hardware_transfer_complete_cb+0x404>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    7a36:	5c28      	ldrb	r0, [r5, r0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a38:	6259      	str	r1, [r3, #36]	; 0x24
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7a3a:	e9c3 0407 	strd	r0, r4, [r3, #28]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    7a3e:	492b      	ldr	r1, [pc, #172]	; (7aec <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f4>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a40:	9200      	str	r2, [sp, #0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    7a42:	5c68      	ldrb	r0, [r5, r1]
    7a44:	6298      	str	r0, [r3, #40]	; 0x28
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7a46:	f101 0040 	add.w	r0, r1, #64	; 0x40
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7a4a:	3180      	adds	r1, #128	; 0x80
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7a4c:	5c28      	ldrb	r0, [r5, r0]
    7a4e:	62d8      	str	r0, [r3, #44]	; 0x2c
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7a50:	5c69      	ldrb	r1, [r5, r1]
    7a52:	6319      	str	r1, [r3, #48]	; 0x30
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7a54:	4640      	mov	r0, r8
    7a56:	7bf9      	ldrb	r1, [r7, #15]
    7a58:	2300      	movs	r3, #0
    7a5a:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7a5c:	3401      	adds	r4, #1
    7a5e:	7bf9      	ldrb	r1, [r7, #15]
    7a60:	9a00      	ldr	r2, [sp, #0]
    7a62:	2301      	movs	r3, #1
    7a64:	4640      	mov	r0, r8
    7a66:	47c8      	blx	r9
		for (uint8_t i = 0; i<16; i++)
    7a68:	2c10      	cmp	r4, #16
    7a6a:	f105 0501 	add.w	r5, r5, #1
    7a6e:	d1bf      	bne.n	79f0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2f8>
    7a70:	e655      	b.n	771e <grid_module_en16_reva_hardware_transfer_complete_cb+0x26>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7a72:	293f      	cmp	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7a74:	bf08      	it	eq
    7a76:	4663      	moveq	r3, ip
    7a78:	e6bf      	b.n	77fa <grid_module_en16_reva_hardware_transfer_complete_cb+0x102>
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7a7a:	f811 3c10 	ldrb.w	r3, [r1, #-16]
    7a7e:	6113      	str	r3, [r2, #16]
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;
    7a80:	2300      	movs	r3, #0
    7a82:	6153      	str	r3, [r2, #20]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7a84:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7a88:	2305      	movs	r3, #5
    7a8a:	e6c6      	b.n	781a <grid_module_en16_reva_hardware_transfer_complete_cb+0x122>
                if (a_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7a8c:	7b5a      	ldrb	r2, [r3, #13]
    7a8e:	bb2a      	cbnz	r2, 7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
    7a90:	7bd9      	ldrb	r1, [r3, #15]
    7a92:	b921      	cbnz	r1, 7a9e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3a6>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7a94:	f04f 0901 	mov.w	r9, #1
    7a98:	f883 900f 	strb.w	r9, [r3, #15]
    7a9c:	e6d6      	b.n	784c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
			int16_t delta = 0;
    7a9e:	4691      	mov	r9, r2
    7aa0:	e6d4      	b.n	784c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
					elapsed_ms = 25;
    7aa2:	2019      	movs	r0, #25
    7aa4:	e6e6      	b.n	7874 <grid_module_en16_reva_hardware_transfer_complete_cb+0x17c>
						new_abs_no_velocity_value = 0;
    7aa6:	f04f 0c00 	mov.w	ip, #0
    7aaa:	e72f      	b.n	790c <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_no_velocity_value = 127;
    7aac:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
    7ab0:	e72c      	b.n	790c <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_low_velocity_value = 0;
    7ab2:	2600      	movs	r6, #0
    7ab4:	e733      	b.n	791e <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_low_velocity_value = 127;
    7ab6:	267f      	movs	r6, #127	; 0x7f
    7ab8:	e731      	b.n	791e <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_high_velocity_value = 0;
    7aba:	2000      	movs	r0, #0
    7abc:	e73a      	b.n	7934 <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_abs_high_velocity_value = 127;
    7abe:	207f      	movs	r0, #127	; 0x7f
    7ac0:	e738      	b.n	7934 <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_rel_no_velocity_value += delta;
    7ac2:	4489      	add	r9, r1
						new_rel_low_velocity_value += delta_low;
    7ac4:	440b      	add	r3, r1
						new_rel_no_velocity_value += delta;
    7ac6:	fa5f f589 	uxtb.w	r5, r9
						new_rel_low_velocity_value += delta_low;
    7aca:	b2db      	uxtb	r3, r3
						new_rel_high_velocity_value += delta_high;
    7acc:	440f      	add	r7, r1
    7ace:	e73d      	b.n	794c <grid_module_en16_reva_hardware_transfer_complete_cb+0x254>
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    7ad0:	7bc9      	ldrb	r1, [r1, #15]
    7ad2:	230d      	movs	r3, #13
    7ad4:	e752      	b.n	797c <grid_module_en16_reva_hardware_transfer_complete_cb+0x284>
            if (a_now == 0 && b_now == 0){
    7ad6:	b90e      	cbnz	r6, 7adc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                grid_ui_encoder_array[i].phase_change_lock = 0;
    7ad8:	19eb      	adds	r3, r5, r7
    7ada:	73de      	strb	r6, [r3, #15]
			int16_t delta = 0;
    7adc:	f04f 0900 	mov.w	r9, #0
    7ae0:	e6b4      	b.n	784c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
    7ae2:	bf00      	nop
    7ae4:	000169dc 	.word	0x000169dc
    7ae8:	200006da 	.word	0x200006da
    7aec:	2000071a 	.word	0x2000071a
    7af0:	20007a18 	.word	0x20007a18
    7af4:	2000069a 	.word	0x2000069a
    7af8:	000169cc 	.word	0x000169cc
    7afc:	0000a4e5 	.word	0x0000a4e5

00007b00 <grid_module_en16_reva_hardware_init>:
    7b00:	4b0f      	ldr	r3, [pc, #60]	; (7b40 <grid_module_en16_reva_hardware_init+0x40>)
    7b02:	f44f 1200 	mov.w	r2, #2097152	; 0x200000

void grid_module_en16_reva_hardware_init(void){
    7b06:	b510      	push	{r4, lr}
    7b08:	615a      	str	r2, [r3, #20]
	
	
	
	
	
	spi_m_async_set_mode(&UI_SPI, SPI_MODE_3);
    7b0a:	4c0e      	ldr	r4, [pc, #56]	; (7b44 <grid_module_en16_reva_hardware_init+0x44>)
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    7b0c:	609a      	str	r2, [r3, #8]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    7b0e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    7b12:	629a      	str	r2, [r3, #40]	; 0x28
    7b14:	4a0c      	ldr	r2, [pc, #48]	; (7b48 <grid_module_en16_reva_hardware_init+0x48>)
    7b16:	629a      	str	r2, [r3, #40]	; 0x28
    7b18:	2103      	movs	r1, #3
    7b1a:	4b0c      	ldr	r3, [pc, #48]	; (7b4c <grid_module_en16_reva_hardware_init+0x4c>)
    7b1c:	4620      	mov	r0, r4
    7b1e:	4798      	blx	r3
	spi_m_async_set_baudrate(&UI_SPI, 1000000); // was 400000 check clock div setting
    7b20:	490b      	ldr	r1, [pc, #44]	; (7b50 <grid_module_en16_reva_hardware_init+0x50>)
    7b22:	4b0c      	ldr	r3, [pc, #48]	; (7b54 <grid_module_en16_reva_hardware_init+0x54>)
    7b24:	4620      	mov	r0, r4
    7b26:	4798      	blx	r3
	
	spi_m_async_get_io_descriptor(&UI_SPI, &grid_module_en16_reva_hardware_io);
    7b28:	490b      	ldr	r1, [pc, #44]	; (7b58 <grid_module_en16_reva_hardware_init+0x58>)
    7b2a:	4b0c      	ldr	r3, [pc, #48]	; (7b5c <grid_module_en16_reva_hardware_init+0x5c>)
    7b2c:	4620      	mov	r0, r4
    7b2e:	4798      	blx	r3


	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7b30:	4620      	mov	r0, r4
    7b32:	4a0b      	ldr	r2, [pc, #44]	; (7b60 <grid_module_en16_reva_hardware_init+0x60>)
    7b34:	4b0b      	ldr	r3, [pc, #44]	; (7b64 <grid_module_en16_reva_hardware_init+0x64>)


}
    7b36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7b3a:	2100      	movs	r1, #0
    7b3c:	4718      	bx	r3
    7b3e:	bf00      	nop
    7b40:	41008000 	.word	0x41008000
    7b44:	20015690 	.word	0x20015690
    7b48:	c0000020 	.word	0xc0000020
    7b4c:	0000f089 	.word	0x0000f089
    7b50:	000f4240 	.word	0x000f4240
    7b54:	0000f04d 	.word	0x0000f04d
    7b58:	20004abc 	.word	0x20004abc
    7b5c:	0000f16d 	.word	0x0000f16d
    7b60:	000076f9 	.word	0x000076f9
    7b64:	0000f129 	.word	0x0000f129

00007b68 <grid_module_en16_reva_init>:

void grid_module_en16_reva_init(){
    7b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	grid_led_lowlevel_init(&grid_led_state, 16);
    7b6c:	4b1d      	ldr	r3, [pc, #116]	; (7be4 <grid_module_en16_reva_init+0x7c>)
    7b6e:	481e      	ldr	r0, [pc, #120]	; (7be8 <grid_module_en16_reva_init+0x80>)

	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
	{
		
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b70:	4e1e      	ldr	r6, [pc, #120]	; (7bec <grid_module_en16_reva_init+0x84>)
    7b72:	4f1f      	ldr	r7, [pc, #124]	; (7bf0 <grid_module_en16_reva_init+0x88>)
		
		for(uint8_t j=0; j<16; j++){
		
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7b74:	f8df 808c 	ldr.w	r8, [pc, #140]	; 7c04 <grid_module_en16_reva_init+0x9c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7b78:	2110      	movs	r1, #16
    7b7a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);	
    7b7c:	481b      	ldr	r0, [pc, #108]	; (7bec <grid_module_en16_reva_init+0x84>)
    7b7e:	4b1d      	ldr	r3, [pc, #116]	; (7bf4 <grid_module_en16_reva_init+0x8c>)
    7b80:	2104      	movs	r1, #4
    7b82:	4798      	blx	r3
    7b84:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b86:	2210      	movs	r2, #16
    7b88:	b2e1      	uxtb	r1, r4
    7b8a:	4630      	mov	r0, r6
    7b8c:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    7b8e:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7b92:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7b94:	6870      	ldr	r0, [r6, #4]
    7b96:	b2e9      	uxtb	r1, r5
    7b98:	2203      	movs	r2, #3
    7b9a:	4448      	add	r0, r9
    7b9c:	3501      	adds	r5, #1
    7b9e:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    7ba0:	2d10      	cmp	r5, #16
    7ba2:	d1f7      	bne.n	7b94 <grid_module_en16_reva_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
    7ba4:	3401      	adds	r4, #1
    7ba6:	2c04      	cmp	r4, #4
    7ba8:	d1ed      	bne.n	7b86 <grid_module_en16_reva_init+0x1e>
    7baa:	2200      	movs	r2, #0
    7bac:	4b12      	ldr	r3, [pc, #72]	; (7bf8 <grid_module_en16_reva_init+0x90>)
	// initialize local encoder helper struct
	for (uint8_t j = 0; j<16; j++)
	{
		grid_ui_encoder_array[j].controller_number = j;
		
		grid_ui_encoder_array[j].button_value = 1;
    7bae:	2001      	movs	r0, #1
		grid_ui_encoder_array[j].button_changed = 0; 
    7bb0:	4611      	mov	r1, r2
		grid_ui_encoder_array[j].rotation_value = 0;
		grid_ui_encoder_array[j].rotation_changed = 1;
		grid_ui_encoder_array[j].rotation_direction = 0;
		grid_ui_encoder_array[j].last_real_time = -1;
    7bb2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		grid_ui_encoder_array[j].controller_number = j;
    7bb6:	701a      	strb	r2, [r3, #0]
		grid_ui_encoder_array[j].button_value = 1;
    7bb8:	3201      	adds	r2, #1
	for (uint8_t j = 0; j<16; j++)
    7bba:	2a10      	cmp	r2, #16
		grid_ui_encoder_array[j].button_value = 1;
    7bbc:	7058      	strb	r0, [r3, #1]
		grid_ui_encoder_array[j].button_changed = 0; 
    7bbe:	7099      	strb	r1, [r3, #2]
		grid_ui_encoder_array[j].rotation_value = 0;
    7bc0:	70d9      	strb	r1, [r3, #3]
		grid_ui_encoder_array[j].rotation_changed = 1;
    7bc2:	7118      	strb	r0, [r3, #4]
		grid_ui_encoder_array[j].rotation_direction = 0;
    7bc4:	7159      	strb	r1, [r3, #5]
		grid_ui_encoder_array[j].last_real_time = -1;
    7bc6:	609c      	str	r4, [r3, #8]
		grid_ui_encoder_array[j].velocity = 0;
    7bc8:	7319      	strb	r1, [r3, #12]
		grid_ui_encoder_array[j].phase_a_previous = 1;
    7bca:	7358      	strb	r0, [r3, #13]
		grid_ui_encoder_array[j].phase_b_previous = 1;	
    7bcc:	7398      	strb	r0, [r3, #14]
        
        grid_ui_encoder_array[j].phase_change_lock = 0;
    7bce:	73d9      	strb	r1, [r3, #15]
	for (uint8_t j = 0; j<16; j++)
    7bd0:	f103 0310 	add.w	r3, r3, #16
    7bd4:	d1ef      	bne.n	7bb6 <grid_module_en16_reva_init+0x4e>
		
	}
	
	
	grid_module_en16_reva_hardware_init();
    7bd6:	4b09      	ldr	r3, [pc, #36]	; (7bfc <grid_module_en16_reva_init+0x94>)
    7bd8:	4798      	blx	r3
	
	
	grid_module_en16_reva_hardware_start_transfer();
	
}
    7bda:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_en16_reva_hardware_start_transfer();
    7bde:	4b08      	ldr	r3, [pc, #32]	; (7c00 <grid_module_en16_reva_init+0x98>)
    7be0:	4718      	bx	r3
    7be2:	bf00      	nop
    7be4:	00006f19 	.word	0x00006f19
    7be8:	20015254 	.word	0x20015254
    7bec:	20007a18 	.word	0x20007a18
    7bf0:	00009aa5 	.word	0x00009aa5
    7bf4:	00009a71 	.word	0x00009a71
    7bf8:	2001218c 	.word	0x2001218c
    7bfc:	00007b01 	.word	0x00007b01
    7c00:	000076c1 	.word	0x000076c1
    7c04:	0000a3d1 	.word	0x0000a3d1

00007c08 <grid_module_pbf4_reva_hardware_start_transfer>:
static uint8_t grid_pbf4_helper_template_b_abs[16] = {0};
	
static uint8_t grid_pbf4_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_pbf4_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};

void grid_module_pbf4_reva_hardware_start_transfer(void){
    7c08:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7c0a:	4c04      	ldr	r4, [pc, #16]	; (7c1c <grid_module_pbf4_reva_hardware_start_transfer+0x14>)
    7c0c:	4804      	ldr	r0, [pc, #16]	; (7c20 <grid_module_pbf4_reva_hardware_start_transfer+0x18>)
    7c0e:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7c10:	4623      	mov	r3, r4
    7c12:	4804      	ldr	r0, [pc, #16]	; (7c24 <grid_module_pbf4_reva_hardware_start_transfer+0x1c>)
	
}
    7c14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7c18:	4718      	bx	r3
    7c1a:	bf00      	nop
    7c1c:	0000e4fd 	.word	0x0000e4fd
    7c20:	200157a4 	.word	0x200157a4
    7c24:	20015978 	.word	0x20015978

00007c28 <grid_module_pbf4_reva_hardware_transfer_complete_cb>:

void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7c28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7c2c:	4aa8      	ldr	r2, [pc, #672]	; (7ed0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7c2e:	7813      	ldrb	r3, [r2, #0]
void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7c30:	b08b      	sub	sp, #44	; 0x2c
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7c32:	b933      	cbnz	r3, 7c42 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a>
		grid_module_pbf4_reva_hardware_transfer_complete++;
    7c34:	7813      	ldrb	r3, [r2, #0]
    7c36:	3301      	adds	r3, #1
    7c38:	b2db      	uxtb	r3, r3
    7c3a:	7013      	strb	r3, [r2, #0]
	
	
	
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
	grid_module_pbf4_reva_hardware_start_transfer();
}
    7c3c:	b00b      	add	sp, #44	; 0x2c
    7c3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    7c42:	4ba4      	ldr	r3, [pc, #656]	; (7ed4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ac>)
    7c44:	7c5a      	ldrb	r2, [r3, #17]
    7c46:	469a      	mov	sl, r3
    7c48:	bb02      	cbnz	r2, 7c8c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x64>
	uint16_t adcresult_0 = 0;
    7c4a:	2300      	movs	r3, #0
    7c4c:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7c50:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7c54:	4ba0      	ldr	r3, [pc, #640]	; (7ed8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b0>)
    7c56:	49a1      	ldr	r1, [pc, #644]	; (7edc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b4>)
    7c58:	781a      	ldrb	r2, [r3, #0]
    7c5a:	3208      	adds	r2, #8
    7c5c:	5c8d      	ldrb	r5, [r1, r2]
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c5e:	781a      	ldrb	r2, [r3, #0]
    7c60:	b2d2      	uxtb	r2, r2
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7c62:	b2ed      	uxtb	r5, r5
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c64:	5c8c      	ldrb	r4, [r1, r2]
	grid_module_pbf4_reva_mux++;
    7c66:	781a      	ldrb	r2, [r3, #0]
    7c68:	3201      	adds	r2, #1
    7c6a:	b2d2      	uxtb	r2, r2
    7c6c:	701a      	strb	r2, [r3, #0]
	grid_module_pbf4_reva_mux%=8;
    7c6e:	781a      	ldrb	r2, [r3, #0]
    7c70:	f002 0207 	and.w	r2, r2, #7
    7c74:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(MUX_A, grid_module_pbf4_reva_mux/1%2);
    7c76:	781a      	ldrb	r2, [r3, #0]
    7c78:	f012 0f01 	tst.w	r2, #1
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    7c7c:	b2e4      	uxtb	r4, r4
    7c7e:	4a98      	ldr	r2, [pc, #608]	; (7ee0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7c80:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    7c84:	d133      	bne.n	7cee <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xc6>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7c86:	f8c2 1114 	str.w	r1, [r2, #276]	; 0x114
}
    7c8a:	e032      	b.n	7cf2 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xca>
		grid_sys_state.bank_active_changed = 0;
    7c8c:	2500      	movs	r5, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7c8e:	4c95      	ldr	r4, [pc, #596]	; (7ee4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7c90:	4e95      	ldr	r6, [pc, #596]	; (7ee8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c0>)
		grid_sys_state.bank_active_changed = 0;
    7c92:	745d      	strb	r5, [r3, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7c94:	2764      	movs	r7, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7c96:	6863      	ldr	r3, [r4, #4]
    7c98:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7c9c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    7ca0:	b2ea      	uxtb	r2, r5
    7ca2:	7a5b      	ldrb	r3, [r3, #9]
    7ca4:	4293      	cmp	r3, r2
    7ca6:	d9d0      	bls.n	7c4a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7ca8:	6863      	ldr	r3, [r4, #4]
    7caa:	f89a 100f 	ldrb.w	r1, [sl, #15]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cae:	9201      	str	r2, [sp, #4]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7cb0:	eb03 1301 	add.w	r3, r3, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cb4:	4620      	mov	r0, r4
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7cb6:	68db      	ldr	r3, [r3, #12]
    7cb8:	fb07 3302 	mla	r3, r7, r2, r3
    7cbc:	3501      	adds	r5, #1
    7cbe:	60da      	str	r2, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cc0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7cc4:	2300      	movs	r3, #0
    7cc6:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7cc8:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7ccc:	9a01      	ldr	r2, [sp, #4]
    7cce:	2301      	movs	r3, #1
    7cd0:	4620      	mov	r0, r4
    7cd2:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7cd4:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7cd8:	9a01      	ldr	r2, [sp, #4]
    7cda:	2304      	movs	r3, #4
    7cdc:	4620      	mov	r0, r4
    7cde:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7ce0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7ce4:	9a01      	ldr	r2, [sp, #4]
    7ce6:	2305      	movs	r3, #5
    7ce8:	4620      	mov	r0, r4
    7cea:	47b0      	blx	r6
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7cec:	e7d3      	b.n	7c96 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x6e>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7cee:	f8c2 1118 	str.w	r1, [r2, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_pbf4_reva_mux/2%2);
    7cf2:	781a      	ldrb	r2, [r3, #0]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7cf4:	4e7d      	ldr	r6, [pc, #500]	; (7eec <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c4>)
    7cf6:	487e      	ldr	r0, [pc, #504]	; (7ef0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c8>)
	uint32_t input_0 = adcresult_0*1.03;
    7cf8:	f8df b210 	ldr.w	fp, [pc, #528]	; 7f0c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e4>
    7cfc:	f8df 9210 	ldr.w	r9, [pc, #528]	; 7f10 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e8>
    7d00:	f012 0f02 	tst.w	r2, #2
    7d04:	4a76      	ldr	r2, [pc, #472]	; (7ee0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7d06:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    7d0a:	bf14      	ite	ne
    7d0c:	f8c2 1118 	strne.w	r1, [r2, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7d10:	f8c2 1114 	streq.w	r1, [r2, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_pbf4_reva_mux/4%2);
    7d14:	781b      	ldrb	r3, [r3, #0]
    7d16:	f013 0f04 	tst.w	r3, #4
    7d1a:	4b71      	ldr	r3, [pc, #452]	; (7ee0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    7d1c:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7d20:	bf14      	ite	ne
    7d22:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7d26:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7d2a:	2100      	movs	r1, #0
    7d2c:	2302      	movs	r3, #2
    7d2e:	aa05      	add	r2, sp, #20
    7d30:	47b0      	blx	r6
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    7d32:	2302      	movs	r3, #2
    7d34:	f10d 0216 	add.w	r2, sp, #22
    7d38:	2100      	movs	r1, #0
    7d3a:	486e      	ldr	r0, [pc, #440]	; (7ef4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2cc>)
    7d3c:	47b0      	blx	r6
	uint32_t input_0 = adcresult_0*1.03;
    7d3e:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    7d42:	4e6d      	ldr	r6, [pc, #436]	; (7ef8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d0>)
    7d44:	47d8      	blx	fp
    7d46:	a360      	add	r3, pc, #384	; (adr r3, 7ec8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    7d48:	e9d3 2300 	ldrd	r2, r3, [r3]
    7d4c:	47b0      	blx	r6
    7d4e:	47c8      	blx	r9
    7d50:	f64f 77ff 	movw	r7, #65535	; 0xffff
    7d54:	42b8      	cmp	r0, r7
    7d56:	4680      	mov	r8, r0
    7d58:	bf28      	it	cs
    7d5a:	46b8      	movcs	r8, r7
    7d5c:	9001      	str	r0, [sp, #4]
	adcresult_0 = input_0;
    7d5e:	f8ad 8014 	strh.w	r8, [sp, #20]
	uint32_t input_1 = adcresult_1*1.03;
    7d62:	f8bd 0016 	ldrh.w	r0, [sp, #22]
    7d66:	47d8      	blx	fp
    7d68:	a357      	add	r3, pc, #348	; (adr r3, 7ec8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    7d6a:	e9d3 2300 	ldrd	r2, r3, [r3]
    7d6e:	47b0      	blx	r6
    7d70:	47c8      	blx	r9
	adcresult_1 = input_1;
    7d72:	42b8      	cmp	r0, r7
    7d74:	4603      	mov	r3, r0
    7d76:	bf28      	it	cs
    7d78:	463b      	movcs	r3, r7
    7d7a:	f8ad 3016 	strh.w	r3, [sp, #22]
	if (adc_index_1 == 8 || adc_index_1 == 9){
    7d7e:	f1a4 0308 	sub.w	r3, r4, #8
    7d82:	2b01      	cmp	r3, #1
    7d84:	d972      	bls.n	7e6c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
	else if (adc_index_0 > 13){ // BUTTON
    7d86:	2d0d      	cmp	r5, #13
    7d88:	f8df 9188 	ldr.w	r9, [pc, #392]	; 7f14 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ec>
    7d8c:	f240 80c4 	bls.w	7f18 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2f0>
		uint8_t result_value[2] = {0};
    7d90:	2300      	movs	r3, #0
		if (adcresult_0>60000){
    7d92:	9a01      	ldr	r2, [sp, #4]
		uint8_t result_value[2] = {0};
    7d94:	f8ad 300c 	strh.w	r3, [sp, #12]
		uint8_t result_valid[2] = {0};
    7d98:	f8ad 3010 	strh.w	r3, [sp, #16]
		if (adcresult_0>60000){
    7d9c:	f64e 2360 	movw	r3, #60000	; 0xea60
		result_index[0] = adc_index_0-4;
    7da0:	3d04      	subs	r5, #4
		result_index[1] = adc_index_1-4;
    7da2:	3c04      	subs	r4, #4
		if (adcresult_0>60000){
    7da4:	429a      	cmp	r2, r3
		result_index[0] = adc_index_0-4;
    7da6:	f88d 5008 	strb.w	r5, [sp, #8]
		result_index[1] = adc_index_1-4;
    7daa:	f88d 4009 	strb.w	r4, [sp, #9]
		if (adcresult_0>60000){
    7dae:	d963      	bls.n	7e78 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x250>
			result_valid[0] = 1;
    7db0:	2301      	movs	r3, #1
    7db2:	f88d 3010 	strb.w	r3, [sp, #16]
		if (adcresult_1>60000){
    7db6:	f64e 2360 	movw	r3, #60000	; 0xea60
    7dba:	4298      	cmp	r0, r3
    7dbc:	d963      	bls.n	7e86 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x25e>
			result_value[1] = 0;
    7dbe:	2300      	movs	r3, #0
			result_value[1] = 127;
    7dc0:	f88d 300d 	strb.w	r3, [sp, #13]
			result_valid[1] = 1;
    7dc4:	2301      	movs	r3, #1
    7dc6:	f88d 3011 	strb.w	r3, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7dca:	4b4c      	ldr	r3, [pc, #304]	; (7efc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d4>)
    7dcc:	ac06      	add	r4, sp, #24
    7dce:	6818      	ldr	r0, [r3, #0]
    7dd0:	6859      	ldr	r1, [r3, #4]
    7dd2:	4622      	mov	r2, r4
    7dd4:	c203      	stmia	r2!, {r0, r1}
    7dd6:	3308      	adds	r3, #8
    7dd8:	454b      	cmp	r3, r9
    7dda:	4614      	mov	r4, r2
    7ddc:	d1f7      	bne.n	7dce <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a6>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7dde:	f8df b104 	ldr.w	fp, [pc, #260]	; 7ee4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>
    7de2:	ab03      	add	r3, sp, #12
    7de4:	f10d 0808 	add.w	r8, sp, #8
    7de8:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7dea:	2400      	movs	r4, #0
    7dec:	46d9      	mov	r9, fp
			uint8_t res_value = result_value[i];
    7dee:	9b01      	ldr	r3, [sp, #4]
			uint8_t res_index = result_index[i];
    7df0:	f818 7b01 	ldrb.w	r7, [r8], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7df4:	4a42      	ldr	r2, [pc, #264]	; (7f00 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
			uint8_t res_value = result_value[i];
    7df6:	f813 6b01 	ldrb.w	r6, [r3], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7dfa:	5dd2      	ldrb	r2, [r2, r7]
			uint8_t res_value = result_value[i];
    7dfc:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7dfe:	f8db 3004 	ldr.w	r3, [fp, #4]
    7e02:	f89a 100f 	ldrb.w	r1, [sl, #15]
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7e06:	4296      	cmp	r6, r2
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7e08:	b2c9      	uxtb	r1, r1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7e0a:	d02e      	beq.n	7e6a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			uint8_t res_valid = result_valid[i];
    7e0c:	a804      	add	r0, sp, #16
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    7e0e:	5c20      	ldrb	r0, [r4, r0]
    7e10:	2801      	cmp	r0, #1
    7e12:	d12a      	bne.n	7e6a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7e14:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    7e18:	2064      	movs	r0, #100	; 0x64
    7e1a:	68db      	ldr	r3, [r3, #12]
    7e1c:	fb17 f000 	smulbb	r0, r7, r0
    7e20:	4403      	add	r3, r0
				if (grid_pbf4_helper_template_b_abs[res_index] == 0){ // Button Press Event
    7e22:	2a00      	cmp	r2, #0
    7e24:	d13b      	bne.n	7e9e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x276>
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7e26:	6999      	ldr	r1, [r3, #24]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7e28:	2900      	cmp	r1, #0
    7e2a:	bf0c      	ite	eq
    7e2c:	217f      	moveq	r1, #127	; 0x7f
    7e2e:	2100      	movne	r1, #0
    7e30:	6199      	str	r1, [r3, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7e32:	69d9      	ldr	r1, [r3, #28]
    7e34:	bb69      	cbnz	r1, 7e92 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x26a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7e36:	213f      	movs	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7e38:	61d9      	str	r1, [r3, #28]
					grid_pbf4_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7e3a:	f89a 300f 	ldrb.w	r3, [sl, #15]
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e3e:	f89a 300f 	ldrb.w	r3, [sl, #15]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e42:	227f      	movs	r2, #127	; 0x7f
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e44:	2300      	movs	r3, #0
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7e46:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e4a:	4419      	add	r1, r3
    7e4c:	3310      	adds	r3, #16
    7e4e:	68c9      	ldr	r1, [r1, #12]
    7e50:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e52:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e54:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e56:	d1f6      	bne.n	7e46 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x21e>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7e58:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7e5c:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7e5e:	4d29      	ldr	r5, [pc, #164]	; (7f04 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2dc>)
    7e60:	463a      	mov	r2, r7
    7e62:	4658      	mov	r0, fp
    7e64:	47a8      	blx	r5
					grid_pbf4_helper_template_b_abs[result_index[i]] = res_value;
    7e66:	4b26      	ldr	r3, [pc, #152]	; (7f00 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
    7e68:	55de      	strb	r6, [r3, r7]
		for (uint8_t i=0; i<2; i++)
    7e6a:	b184      	cbz	r4, 7e8e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x266>
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
    7e6c:	4a18      	ldr	r2, [pc, #96]	; (7ed0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7e6e:	2300      	movs	r3, #0
    7e70:	7013      	strb	r3, [r2, #0]
	grid_module_pbf4_reva_hardware_start_transfer();
    7e72:	4b25      	ldr	r3, [pc, #148]	; (7f08 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e0>)
    7e74:	4798      	blx	r3
    7e76:	e6e1      	b.n	7c3c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x14>
		else if (adcresult_0<200){
    7e78:	9b01      	ldr	r3, [sp, #4]
    7e7a:	2bc7      	cmp	r3, #199	; 0xc7
    7e7c:	d89b      	bhi.n	7db6 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x18e>
			result_value[0] = 127;
    7e7e:	237f      	movs	r3, #127	; 0x7f
    7e80:	f88d 300c 	strb.w	r3, [sp, #12]
    7e84:	e794      	b.n	7db0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x188>
		else if (adcresult_1<200){
    7e86:	28c7      	cmp	r0, #199	; 0xc7
    7e88:	d89f      	bhi.n	7dca <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a2>
			result_value[1] = 127;
    7e8a:	237f      	movs	r3, #127	; 0x7f
    7e8c:	e798      	b.n	7dc0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x198>
    7e8e:	2401      	movs	r4, #1
    7e90:	e7ad      	b.n	7dee <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1c6>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7e92:	293f      	cmp	r1, #63	; 0x3f
    7e94:	d101      	bne.n	7e9a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x272>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7e96:	217f      	movs	r1, #127	; 0x7f
    7e98:	e7ce      	b.n	7e38 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x210>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    7e9a:	61da      	str	r2, [r3, #28]
    7e9c:	e7cd      	b.n	7e3a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x212>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7e9e:	aa0a      	add	r2, sp, #40	; 0x28
    7ea0:	19d1      	adds	r1, r2, r7
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7ea2:	60df      	str	r7, [r3, #12]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7ea4:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7ea8:	6119      	str	r1, [r3, #16]
    7eaa:	2300      	movs	r3, #0
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7eac:	461a      	mov	r2, r3
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7eae:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7eb2:	4419      	add	r1, r3
    7eb4:	3310      	adds	r3, #16
    7eb6:	68c9      	ldr	r1, [r1, #12]
    7eb8:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7eba:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7ebc:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7ebe:	d1f6      	bne.n	7eae <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x286>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7ec0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7ec4:	2305      	movs	r3, #5
    7ec6:	e7ca      	b.n	7e5e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x236>
    7ec8:	47ae147b 	.word	0x47ae147b
    7ecc:	3ff07ae1 	.word	0x3ff07ae1
    7ed0:	20004ac8 	.word	0x20004ac8
    7ed4:	20007a24 	.word	0x20007a24
    7ed8:	200151e4 	.word	0x200151e4
    7edc:	20000329 	.word	0x20000329
    7ee0:	41008000 	.word	0x41008000
    7ee4:	20007a18 	.word	0x20007a18
    7ee8:	0000a4e5 	.word	0x0000a4e5
    7eec:	0000e441 	.word	0x0000e441
    7ef0:	200157a4 	.word	0x200157a4
    7ef4:	20015978 	.word	0x20015978
    7ef8:	00013b75 	.word	0x00013b75
    7efc:	000169dc 	.word	0x000169dc
    7f00:	200007eb 	.word	0x200007eb
    7f04:	0000a191 	.word	0x0000a191
    7f08:	00007c09 	.word	0x00007c09
    7f0c:	00013aa1 	.word	0x00013aa1
    7f10:	00013f99 	.word	0x00013f99
    7f14:	000169ec 	.word	0x000169ec
		if (adc_index_1 == 0 || adc_index_1 == 1){
    7f18:	2c01      	cmp	r4, #1
    7f1a:	4e33      	ldr	r6, [pc, #204]	; (7fe8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c0>)
    7f1c:	d85e      	bhi.n	7fdc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3b4>
			grid_ain_add_sample(adc_index_0, (1<<16)-1-adcresult_0);
    7f1e:	ea88 0107 	eor.w	r1, r8, r7
    7f22:	4628      	mov	r0, r5
    7f24:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, (1<<16)-1-adcresult_1);
    7f26:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    7f2a:	1a79      	subs	r1, r7, r1
			grid_ain_add_sample(adc_index_1, adcresult_1);
    7f2c:	4620      	mov	r0, r4
    7f2e:	47b0      	blx	r6
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f30:	4a2e      	ldr	r2, [pc, #184]	; (7fec <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c4>)
		result_index[0] = adc_index_0;
    7f32:	f88d 5010 	strb.w	r5, [sp, #16]
		result_index[1] = adc_index_1;
    7f36:	f88d 4011 	strb.w	r4, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f3a:	ab06      	add	r3, sp, #24
    7f3c:	6810      	ldr	r0, [r2, #0]
    7f3e:	6851      	ldr	r1, [r2, #4]
    7f40:	461c      	mov	r4, r3
    7f42:	c403      	stmia	r4!, {r0, r1}
    7f44:	3208      	adds	r2, #8
    7f46:	454a      	cmp	r2, r9
    7f48:	4623      	mov	r3, r4
    7f4a:	d1f7      	bne.n	7f3c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x314>
		for (uint8_t i=0; i<2; i++)
    7f4c:	ab04      	add	r3, sp, #16
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f4e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 7ff8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>
    7f52:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7f54:	f04f 0902 	mov.w	r9, #2
			uint8_t res_index = result_index[i];
    7f58:	9b01      	ldr	r3, [sp, #4]
    7f5a:	f813 4b01 	ldrb.w	r4, [r3], #1
    7f5e:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f60:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7f64:	f89a 200f 	ldrb.w	r2, [sl, #15]
    7f68:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			if (grid_ain_get_changed(res_index)){
    7f6c:	4620      	mov	r0, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f6e:	68dd      	ldr	r5, [r3, #12]
			if (grid_ain_get_changed(res_index)){
    7f70:	4b1f      	ldr	r3, [pc, #124]	; (7ff0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c8>)
    7f72:	4798      	blx	r3
    7f74:	b358      	cbz	r0, 7fce <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3a6>
				uint8_t res_value = grid_ain_get_average(res_index, 7);
    7f76:	4e1f      	ldr	r6, [pc, #124]	; (7ff4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3cc>)
    7f78:	2107      	movs	r1, #7
    7f7a:	4620      	mov	r0, r4
    7f7c:	47b0      	blx	r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f7e:	2764      	movs	r7, #100	; 0x64
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f80:	ab0a      	add	r3, sp, #40	; 0x28
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f82:	fb14 f707 	smulbb	r7, r4, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f86:	4423      	add	r3, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7f88:	443d      	add	r5, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f8a:	f813 3c10 	ldrb.w	r3, [r3, #-16]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7f8e:	60ec      	str	r4, [r5, #12]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    7f90:	612b      	str	r3, [r5, #16]
    7f92:	2500      	movs	r5, #0
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f94:	4b18      	ldr	r3, [pc, #96]	; (7ff8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>)
    7f96:	685a      	ldr	r2, [r3, #4]
    7f98:	442a      	add	r2, r5
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f9a:	2107      	movs	r1, #7
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7f9c:	68d2      	ldr	r2, [r2, #12]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7f9e:	4620      	mov	r0, r4
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7fa0:	eb02 0b07 	add.w	fp, r2, r7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7fa4:	47b0      	blx	r6
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7fa6:	2107      	movs	r1, #7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    7fa8:	f8cb 0014 	str.w	r0, [fp, #20]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7fac:	4620      	mov	r0, r4
    7fae:	47b0      	blx	r6
    7fb0:	3510      	adds	r5, #16
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    7fb2:	2300      	movs	r3, #0
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7fb4:	2d40      	cmp	r5, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    7fb6:	f8cb 0018 	str.w	r0, [fp, #24]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    7fba:	f8cb 301c 	str.w	r3, [fp, #28]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7fbe:	d1e9      	bne.n	7f94 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x36c>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);
    7fc0:	4622      	mov	r2, r4
    7fc2:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7fc6:	4c0d      	ldr	r4, [pc, #52]	; (7ffc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d4>)
    7fc8:	2301      	movs	r3, #1
    7fca:	4640      	mov	r0, r8
    7fcc:	47a0      	blx	r4
		for (uint8_t i=0; i<2; i++)
    7fce:	f1b9 0f01 	cmp.w	r9, #1
    7fd2:	f43f af4b 	beq.w	7e6c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
    7fd6:	f04f 0901 	mov.w	r9, #1
    7fda:	e7bd      	b.n	7f58 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x330>
			grid_ain_add_sample(adc_index_0, adcresult_0);
    7fdc:	4641      	mov	r1, r8
    7fde:	4628      	mov	r0, r5
    7fe0:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, adcresult_1);
    7fe2:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    7fe6:	e7a1      	b.n	7f2c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x304>
    7fe8:	00004631 	.word	0x00004631
    7fec:	000169dc 	.word	0x000169dc
    7ff0:	000046f9 	.word	0x000046f9
    7ff4:	00004709 	.word	0x00004709
    7ff8:	20007a18 	.word	0x20007a18
    7ffc:	0000a191 	.word	0x0000a191

00008000 <grid_module_pbf4_reva_hardware_init>:

void grid_module_pbf4_reva_hardware_init(void){
    8000:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8002:	4c0b      	ldr	r4, [pc, #44]	; (8030 <grid_module_pbf4_reva_hardware_init+0x30>)
    8004:	4e0b      	ldr	r6, [pc, #44]	; (8034 <grid_module_pbf4_reva_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8006:	4d0c      	ldr	r5, [pc, #48]	; (8038 <grid_module_pbf4_reva_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8008:	4b0c      	ldr	r3, [pc, #48]	; (803c <grid_module_pbf4_reva_hardware_init+0x3c>)
    800a:	2200      	movs	r2, #0
    800c:	4611      	mov	r1, r2
    800e:	4620      	mov	r0, r4
    8010:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8012:	2200      	movs	r2, #0
    8014:	4b09      	ldr	r3, [pc, #36]	; (803c <grid_module_pbf4_reva_hardware_init+0x3c>)
    8016:	4611      	mov	r1, r2
    8018:	4628      	mov	r0, r5
    801a:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    801c:	4620      	mov	r0, r4
    801e:	4c08      	ldr	r4, [pc, #32]	; (8040 <grid_module_pbf4_reva_hardware_init+0x40>)
    8020:	2100      	movs	r1, #0
    8022:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8024:	4628      	mov	r0, r5
    8026:	4623      	mov	r3, r4
    8028:	2100      	movs	r1, #0

}
    802a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    802e:	4718      	bx	r3
    8030:	200157a4 	.word	0x200157a4
    8034:	0000e3c9 	.word	0x0000e3c9
    8038:	20015978 	.word	0x20015978
    803c:	00007c29 	.word	0x00007c29
    8040:	0000e389 	.word	0x0000e389

00008044 <grid_module_pbf4_reva_init>:




void grid_module_pbf4_reva_init(){
    8044:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    8048:	220e      	movs	r2, #14
    804a:	4c16      	ldr	r4, [pc, #88]	; (80a4 <grid_module_pbf4_reva_init+0x60>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);

	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 12);
    804c:	4e16      	ldr	r6, [pc, #88]	; (80a8 <grid_module_pbf4_reva_init+0x64>)
    804e:	f8df 9074 	ldr.w	r9, [pc, #116]	; 80c4 <grid_module_pbf4_reva_init+0x80>
    8052:	4f16      	ldr	r7, [pc, #88]	; (80ac <grid_module_pbf4_reva_init+0x68>)
	grid_ain_init(16, 5, 14, 7);
    8054:	2307      	movs	r3, #7
    8056:	2105      	movs	r1, #5
    8058:	2010      	movs	r0, #16
    805a:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 12);	
    805c:	4b14      	ldr	r3, [pc, #80]	; (80b0 <grid_module_pbf4_reva_init+0x6c>)
    805e:	4815      	ldr	r0, [pc, #84]	; (80b4 <grid_module_pbf4_reva_init+0x70>)
    8060:	210c      	movs	r1, #12
    8062:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    8064:	4810      	ldr	r0, [pc, #64]	; (80a8 <grid_module_pbf4_reva_init+0x64>)
    8066:	4b14      	ldr	r3, [pc, #80]	; (80b8 <grid_module_pbf4_reva_init+0x74>)
    8068:	2104      	movs	r1, #4
    806a:	4798      	blx	r3
    806c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 12);
    806e:	220c      	movs	r2, #12
    8070:	b2e1      	uxtb	r1, r4
    8072:	4630      	mov	r0, r6
    8074:	47c8      	blx	r9
		
		for(uint8_t j=0; j<12; j++){
    8076:	ea4f 1804 	mov.w	r8, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 12);
    807a:	2500      	movs	r5, #0
			
				
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    807c:	6870      	ldr	r0, [r6, #4]
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
    807e:	2d07      	cmp	r5, #7
    8080:	b2e9      	uxtb	r1, r5
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8082:	bf94      	ite	ls
    8084:	2201      	movls	r2, #1
			
			}
			else{ // BUTTONS -> MIDI Note On/Off
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    8086:	2202      	movhi	r2, #2
    8088:	4440      	add	r0, r8
    808a:	3501      	adds	r5, #1
    808c:	47b8      	blx	r7
		for(uint8_t j=0; j<12; j++){
    808e:	2d0c      	cmp	r5, #12
    8090:	d1f4      	bne.n	807c <grid_module_pbf4_reva_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    8092:	3401      	adds	r4, #1
    8094:	2c04      	cmp	r4, #4
    8096:	d1ea      	bne.n	806e <grid_module_pbf4_reva_init+0x2a>
			}
			
		}	
	}
			
	grid_module_pbf4_reva_hardware_init();
    8098:	4b08      	ldr	r3, [pc, #32]	; (80bc <grid_module_pbf4_reva_init+0x78>)
    809a:	4798      	blx	r3
	grid_module_pbf4_reva_hardware_start_transfer();
	
    809c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_pbf4_reva_hardware_start_transfer();
    80a0:	4b07      	ldr	r3, [pc, #28]	; (80c0 <grid_module_pbf4_reva_init+0x7c>)
    80a2:	4718      	bx	r3
    80a4:	000045ed 	.word	0x000045ed
    80a8:	20007a18 	.word	0x20007a18
    80ac:	0000a3d1 	.word	0x0000a3d1
    80b0:	00006f19 	.word	0x00006f19
    80b4:	20015254 	.word	0x20015254
    80b8:	00009a71 	.word	0x00009a71
    80bc:	00008001 	.word	0x00008001
    80c0:	00007c09 	.word	0x00007c09
    80c4:	00009aa5 	.word	0x00009aa5

000080c8 <grid_module_po16_revb_hardware_start_transfer>:

volatile uint8_t grid_module_po16_revb_hardware_transfer_complete = 0;
volatile uint8_t grid_module_po16_revb_mux =0;
volatile uint8_t grid_module_po16_revb_mux_lookup[16] = {0, 1, 4, 5, 8, 9, 12, 13, 2, 3, 6, 7, 10, 11, 14, 15};

void grid_module_po16_revb_hardware_start_transfer(void){
    80c8:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    80ca:	4c04      	ldr	r4, [pc, #16]	; (80dc <grid_module_po16_revb_hardware_start_transfer+0x14>)
    80cc:	4804      	ldr	r0, [pc, #16]	; (80e0 <grid_module_po16_revb_hardware_start_transfer+0x18>)
    80ce:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    80d0:	4623      	mov	r3, r4
    80d2:	4804      	ldr	r0, [pc, #16]	; (80e4 <grid_module_po16_revb_hardware_start_transfer+0x1c>)
	
}
    80d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    80d8:	4718      	bx	r3
    80da:	bf00      	nop
    80dc:	0000e4fd 	.word	0x0000e4fd
    80e0:	200157a4 	.word	0x200157a4
    80e4:	20015978 	.word	0x20015978

000080e8 <grid_module_po16_revb_hardware_transfer_complete_cb>:

static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    80e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    80ec:	4a88      	ldr	r2, [pc, #544]	; (8310 <grid_module_po16_revb_hardware_transfer_complete_cb+0x228>)
    80ee:	7813      	ldrb	r3, [r2, #0]
static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    80f0:	b089      	sub	sp, #36	; 0x24
    80f2:	4614      	mov	r4, r2
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    80f4:	b933      	cbnz	r3, 8104 <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_po16_revb_hardware_transfer_complete++;
    80f6:	7813      	ldrb	r3, [r2, #0]
    80f8:	3301      	adds	r3, #1
    80fa:	b2db      	uxtb	r3, r3
    80fc:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_po16_revb_hardware_transfer_complete = 0;
	grid_module_po16_revb_hardware_start_transfer();
}
    80fe:	b009      	add	sp, #36	; 0x24
    8100:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    8104:	4d83      	ldr	r5, [pc, #524]	; (8314 <grid_module_po16_revb_hardware_transfer_complete_cb+0x22c>)
    8106:	7c6b      	ldrb	r3, [r5, #17]
    8108:	b9fb      	cbnz	r3, 814a <grid_module_po16_revb_hardware_transfer_complete_cb+0x62>
	uint16_t adcresult_0 = 0;
    810a:	2300      	movs	r3, #0
    810c:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint16_t adcresult_1 = 0;
    8110:	f8ad 300e 	strh.w	r3, [sp, #14]
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    8114:	7863      	ldrb	r3, [r4, #1]
    8116:	4a80      	ldr	r2, [pc, #512]	; (8318 <grid_module_po16_revb_hardware_transfer_complete_cb+0x230>)
    8118:	3308      	adds	r3, #8
    811a:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    811c:	7863      	ldrb	r3, [r4, #1]
    811e:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    8120:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    8122:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_po16_revb_mux++;
    8124:	7863      	ldrb	r3, [r4, #1]
    8126:	3301      	adds	r3, #1
    8128:	b2db      	uxtb	r3, r3
    812a:	7063      	strb	r3, [r4, #1]
	grid_module_po16_revb_mux%=8;
    812c:	7863      	ldrb	r3, [r4, #1]
    812e:	f003 0307 	and.w	r3, r3, #7
    8132:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_po16_revb_mux/1%2);
    8134:	7863      	ldrb	r3, [r4, #1]
    8136:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    813a:	b2f6      	uxtb	r6, r6
    813c:	4b77      	ldr	r3, [pc, #476]	; (831c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    813e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    8142:	d128      	bne.n	8196 <grid_module_po16_revb_hardware_transfer_complete_cb+0xae>
    8144:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    8148:	e027      	b.n	819a <grid_module_po16_revb_hardware_transfer_complete_cb+0xb2>
		grid_sys_state.bank_active_changed = 0;
    814a:	2600      	movs	r6, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    814c:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 8334 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8150:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8344 <grid_module_po16_revb_hardware_transfer_complete_cb+0x25c>
		grid_sys_state.bank_active_changed = 0;
    8154:	746e      	strb	r6, [r5, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8156:	f04f 0a64 	mov.w	sl, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    815a:	f8d8 3004 	ldr.w	r3, [r8, #4]
    815e:	7bea      	ldrb	r2, [r5, #15]
    8160:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    8164:	b2f7      	uxtb	r7, r6
    8166:	7a5b      	ldrb	r3, [r3, #9]
    8168:	42bb      	cmp	r3, r7
    816a:	d9ce      	bls.n	810a <grid_module_po16_revb_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    816c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8170:	7bea      	ldrb	r2, [r5, #15]
    8172:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8176:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8178:	68db      	ldr	r3, [r3, #12]
    817a:	fb0a 3307 	mla	r3, sl, r7, r3
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    817e:	463a      	mov	r2, r7
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8180:	60df      	str	r7, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8182:	7be9      	ldrb	r1, [r5, #15]
    8184:	2300      	movs	r3, #0
    8186:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    8188:	7be9      	ldrb	r1, [r5, #15]
    818a:	2301      	movs	r3, #1
    818c:	463a      	mov	r2, r7
    818e:	4640      	mov	r0, r8
    8190:	47c8      	blx	r9
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8192:	3601      	adds	r6, #1
    8194:	e7e1      	b.n	815a <grid_module_po16_revb_hardware_transfer_complete_cb+0x72>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8196:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_po16_revb_mux/2%2);
    819a:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    819c:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8348 <grid_module_po16_revb_hardware_transfer_complete_cb+0x260>
    81a0:	485f      	ldr	r0, [pc, #380]	; (8320 <grid_module_po16_revb_hardware_transfer_complete_cb+0x238>)
	uint32_t input_0 = adcresult_0*1.03;	
    81a2:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 834c <grid_module_po16_revb_hardware_transfer_complete_cb+0x264>
    81a6:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 8350 <grid_module_po16_revb_hardware_transfer_complete_cb+0x268>
    81aa:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 8354 <grid_module_po16_revb_hardware_transfer_complete_cb+0x26c>
    81ae:	f013 0f02 	tst.w	r3, #2
    81b2:	4b5a      	ldr	r3, [pc, #360]	; (831c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    81b4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    81b8:	bf14      	ite	ne
    81ba:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    81be:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_po16_revb_mux/4%2);
    81c2:	7863      	ldrb	r3, [r4, #1]
    81c4:	f013 0f04 	tst.w	r3, #4
    81c8:	4b54      	ldr	r3, [pc, #336]	; (831c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    81ca:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    81ce:	bf14      	ite	ne
    81d0:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    81d4:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    81d8:	2100      	movs	r1, #0
    81da:	2302      	movs	r3, #2
    81dc:	aa03      	add	r2, sp, #12
    81de:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    81e0:	2302      	movs	r3, #2
    81e2:	f10d 020e 	add.w	r2, sp, #14
    81e6:	2100      	movs	r1, #0
    81e8:	484e      	ldr	r0, [pc, #312]	; (8324 <grid_module_po16_revb_hardware_transfer_complete_cb+0x23c>)
    81ea:	47c0      	blx	r8
	uint32_t input_0 = adcresult_0*1.03;	
    81ec:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    81f0:	47d8      	blx	fp
    81f2:	a345      	add	r3, pc, #276	; (adr r3, 8308 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    81f4:	e9d3 2300 	ldrd	r2, r3, [r3]
    81f8:	47d0      	blx	sl
    81fa:	47c8      	blx	r9
	adcresult_0 = input_0;
    81fc:	f64f 78ff 	movw	r8, #65535	; 0xffff
    8200:	4540      	cmp	r0, r8
    8202:	bf28      	it	cs
    8204:	4640      	movcs	r0, r8
    8206:	f8ad 000c 	strh.w	r0, [sp, #12]
	uint32_t input_1 = adcresult_1*1.03;	
    820a:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    820e:	47d8      	blx	fp
    8210:	a33d      	add	r3, pc, #244	; (adr r3, 8308 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    8212:	e9d3 2300 	ldrd	r2, r3, [r3]
    8216:	47d0      	blx	sl
    8218:	47c8      	blx	r9
	adcresult_1 = input_1;
    821a:	4540      	cmp	r0, r8
    821c:	bf28      	it	cs
    821e:	4640      	movcs	r0, r8
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    8220:	4b41      	ldr	r3, [pc, #260]	; (8328 <grid_module_po16_revb_hardware_transfer_complete_cb+0x240>)
	adcresult_1 = input_1;
    8222:	f8ad 000e 	strh.w	r0, [sp, #14]
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    8226:	4798      	blx	r3
    8228:	2808      	cmp	r0, #8
    822a:	d109      	bne.n	8240 <grid_module_po16_revb_hardware_transfer_complete_cb+0x158>
		adcresult_0	= 65535 - adcresult_0;
    822c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    8230:	43db      	mvns	r3, r3
    8232:	f8ad 300c 	strh.w	r3, [sp, #12]
		adcresult_1 = 65535 - adcresult_1;
    8236:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    823a:	43db      	mvns	r3, r3
    823c:	f8ad 300e 	strh.w	r3, [sp, #14]
	grid_ain_add_sample(adc_index_0, adcresult_0);
    8240:	f8bd 100c 	ldrh.w	r1, [sp, #12]
    8244:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8358 <grid_module_po16_revb_hardware_transfer_complete_cb+0x270>
    8248:	4638      	mov	r0, r7
    824a:	47c0      	blx	r8
	grid_ain_add_sample(adc_index_1, adcresult_1);
    824c:	4630      	mov	r0, r6
    824e:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    8252:	47c0      	blx	r8
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8254:	4b35      	ldr	r3, [pc, #212]	; (832c <grid_module_po16_revb_hardware_transfer_complete_cb+0x244>)
	result_index[0] = adc_index_0;
    8256:	f88d 7008 	strb.w	r7, [sp, #8]
	result_index[1] = adc_index_1;
    825a:	f88d 6009 	strb.w	r6, [sp, #9]
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    825e:	f103 0710 	add.w	r7, r3, #16
    8262:	ae04      	add	r6, sp, #16
    8264:	6818      	ldr	r0, [r3, #0]
    8266:	6859      	ldr	r1, [r3, #4]
    8268:	4632      	mov	r2, r6
    826a:	c203      	stmia	r2!, {r0, r1}
    826c:	3308      	adds	r3, #8
    826e:	42bb      	cmp	r3, r7
    8270:	4616      	mov	r6, r2
    8272:	d1f7      	bne.n	8264 <grid_module_po16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8274:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 8334 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
    8278:	f10d 0a08 	add.w	sl, sp, #8
	for (uint8_t i=0; i<2; i++)
    827c:	f04f 0900 	mov.w	r9, #0
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8280:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8284:	7bea      	ldrb	r2, [r5, #15]
		uint8_t res_index = result_index[i];
    8286:	f81a 6b01 	ldrb.w	r6, [sl], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    828a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		if (grid_ain_get_changed(res_index)){
    828e:	4630      	mov	r0, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8290:	68df      	ldr	r7, [r3, #12]
		if (grid_ain_get_changed(res_index)){
    8292:	4b27      	ldr	r3, [pc, #156]	; (8330 <grid_module_po16_revb_hardware_transfer_complete_cb+0x248>)
    8294:	4798      	blx	r3
    8296:	b350      	cbz	r0, 82ee <grid_module_po16_revb_hardware_transfer_complete_cb+0x206>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8298:	2264      	movs	r2, #100	; 0x64
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    829a:	a908      	add	r1, sp, #32
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    829c:	fb16 f202 	smulbb	r2, r6, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    82a0:	4431      	add	r1, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    82a2:	18bb      	adds	r3, r7, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    82a4:	f811 1c10 	ldrb.w	r1, [r1, #-16]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    82a8:	60de      	str	r6, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    82aa:	6119      	str	r1, [r3, #16]
    82ac:	2700      	movs	r7, #0
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    82ae:	4b21      	ldr	r3, [pc, #132]	; (8334 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>)
    82b0:	9201      	str	r2, [sp, #4]
    82b2:	685b      	ldr	r3, [r3, #4]
    82b4:	443b      	add	r3, r7
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82b6:	2107      	movs	r1, #7
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    82b8:	68db      	ldr	r3, [r3, #12]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82ba:	4630      	mov	r0, r6
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    82bc:	eb03 0b02 	add.w	fp, r3, r2
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82c0:	4b1d      	ldr	r3, [pc, #116]	; (8338 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
    82c2:	4798      	blx	r3
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    82c4:	4b1c      	ldr	r3, [pc, #112]	; (8338 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    82c6:	f8cb 0014 	str.w	r0, [fp, #20]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    82ca:	2107      	movs	r1, #7
    82cc:	4630      	mov	r0, r6
    82ce:	4798      	blx	r3
    82d0:	3710      	adds	r7, #16
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    82d2:	2300      	movs	r3, #0
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    82d4:	2f40      	cmp	r7, #64	; 0x40
    82d6:	9a01      	ldr	r2, [sp, #4]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    82d8:	f8cb 0018 	str.w	r0, [fp, #24]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    82dc:	f8cb 301c 	str.w	r3, [fp, #28]
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    82e0:	d1e5      	bne.n	82ae <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c6>
			grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);		
    82e2:	4632      	mov	r2, r6
    82e4:	7be9      	ldrb	r1, [r5, #15]
    82e6:	4e15      	ldr	r6, [pc, #84]	; (833c <grid_module_po16_revb_hardware_transfer_complete_cb+0x254>)
    82e8:	2301      	movs	r3, #1
    82ea:	4640      	mov	r0, r8
    82ec:	47b0      	blx	r6
	for (uint8_t i=0; i<2; i++)
    82ee:	f1b9 0f00 	cmp.w	r9, #0
    82f2:	d004      	beq.n	82fe <grid_module_po16_revb_hardware_transfer_complete_cb+0x216>
	grid_module_po16_revb_hardware_transfer_complete = 0;
    82f4:	2300      	movs	r3, #0
    82f6:	7023      	strb	r3, [r4, #0]
	grid_module_po16_revb_hardware_start_transfer();
    82f8:	4b11      	ldr	r3, [pc, #68]	; (8340 <grid_module_po16_revb_hardware_transfer_complete_cb+0x258>)
    82fa:	4798      	blx	r3
    82fc:	e6ff      	b.n	80fe <grid_module_po16_revb_hardware_transfer_complete_cb+0x16>
    82fe:	f04f 0901 	mov.w	r9, #1
    8302:	e7bd      	b.n	8280 <grid_module_po16_revb_hardware_transfer_complete_cb+0x198>
    8304:	f3af 8000 	nop.w
    8308:	47ae147b 	.word	0x47ae147b
    830c:	3ff07ae1 	.word	0x3ff07ae1
    8310:	200007fd 	.word	0x200007fd
    8314:	20007a24 	.word	0x20007a24
    8318:	20000339 	.word	0x20000339
    831c:	41008000 	.word	0x41008000
    8320:	200157a4 	.word	0x200157a4
    8324:	20015978 	.word	0x20015978
    8328:	000098ed 	.word	0x000098ed
    832c:	000169ec 	.word	0x000169ec
    8330:	000046f9 	.word	0x000046f9
    8334:	20007a18 	.word	0x20007a18
    8338:	00004709 	.word	0x00004709
    833c:	0000a191 	.word	0x0000a191
    8340:	000080c9 	.word	0x000080c9
    8344:	0000a4e5 	.word	0x0000a4e5
    8348:	0000e441 	.word	0x0000e441
    834c:	00013aa1 	.word	0x00013aa1
    8350:	00013b75 	.word	0x00013b75
    8354:	00013f99 	.word	0x00013f99
    8358:	00004631 	.word	0x00004631

0000835c <grid_module_po16_revb_hardware_init>:

void grid_module_po16_revb_hardware_init(void){
    835c:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    835e:	4c0b      	ldr	r4, [pc, #44]	; (838c <grid_module_po16_revb_hardware_init+0x30>)
    8360:	4e0b      	ldr	r6, [pc, #44]	; (8390 <grid_module_po16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8362:	4d0c      	ldr	r5, [pc, #48]	; (8394 <grid_module_po16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8364:	4b0c      	ldr	r3, [pc, #48]	; (8398 <grid_module_po16_revb_hardware_init+0x3c>)
    8366:	2200      	movs	r2, #0
    8368:	4611      	mov	r1, r2
    836a:	4620      	mov	r0, r4
    836c:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    836e:	2200      	movs	r2, #0
    8370:	4b09      	ldr	r3, [pc, #36]	; (8398 <grid_module_po16_revb_hardware_init+0x3c>)
    8372:	4611      	mov	r1, r2
    8374:	4628      	mov	r0, r5
    8376:	47b0      	blx	r6
		
	adc_async_enable_channel(&ADC_0, 0);
    8378:	4620      	mov	r0, r4
    837a:	4c08      	ldr	r4, [pc, #32]	; (839c <grid_module_po16_revb_hardware_init+0x40>)
    837c:	2100      	movs	r1, #0
    837e:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8380:	4628      	mov	r0, r5
    8382:	4623      	mov	r3, r4
    8384:	2100      	movs	r1, #0

}
    8386:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    838a:	4718      	bx	r3
    838c:	200157a4 	.word	0x200157a4
    8390:	0000e3c9 	.word	0x0000e3c9
    8394:	20015978 	.word	0x20015978
    8398:	000080e9 	.word	0x000080e9
    839c:	0000e389 	.word	0x0000e389

000083a0 <grid_module_po16_revb_init>:




void grid_module_po16_revb_init(){
    83a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    83a4:	220e      	movs	r2, #14
    83a6:	4c15      	ldr	r4, [pc, #84]	; (83fc <grid_module_po16_revb_init+0x5c>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    83a8:	4e15      	ldr	r6, [pc, #84]	; (8400 <grid_module_po16_revb_init+0x60>)
    83aa:	4f16      	ldr	r7, [pc, #88]	; (8404 <grid_module_po16_revb_init+0x64>)
		
		for(uint8_t j=0; j<16; j++){
			
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    83ac:	f8df 806c 	ldr.w	r8, [pc, #108]	; 841c <grid_module_po16_revb_init+0x7c>
	grid_ain_init(16, 5, 14, 7);
    83b0:	2307      	movs	r3, #7
    83b2:	2105      	movs	r1, #5
    83b4:	2010      	movs	r0, #16
    83b6:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 16);
    83b8:	4b13      	ldr	r3, [pc, #76]	; (8408 <grid_module_po16_revb_init+0x68>)
    83ba:	4814      	ldr	r0, [pc, #80]	; (840c <grid_module_po16_revb_init+0x6c>)
    83bc:	2110      	movs	r1, #16
    83be:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    83c0:	480f      	ldr	r0, [pc, #60]	; (8400 <grid_module_po16_revb_init+0x60>)
    83c2:	4b13      	ldr	r3, [pc, #76]	; (8410 <grid_module_po16_revb_init+0x70>)
    83c4:	2104      	movs	r1, #4
    83c6:	4798      	blx	r3
    83c8:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    83ca:	2210      	movs	r2, #16
    83cc:	b2e1      	uxtb	r1, r4
    83ce:	4630      	mov	r0, r6
    83d0:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    83d2:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    83d6:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    83d8:	6870      	ldr	r0, [r6, #4]
    83da:	b2e9      	uxtb	r1, r5
    83dc:	2201      	movs	r2, #1
    83de:	4448      	add	r0, r9
    83e0:	3501      	adds	r5, #1
    83e2:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    83e4:	2d10      	cmp	r5, #16
    83e6:	d1f7      	bne.n	83d8 <grid_module_po16_revb_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
    83e8:	3401      	adds	r4, #1
    83ea:	2c04      	cmp	r4, #4
    83ec:	d1ed      	bne.n	83ca <grid_module_po16_revb_init+0x2a>

		}
	}
	
	grid_module_po16_revb_hardware_init();
    83ee:	4b09      	ldr	r3, [pc, #36]	; (8414 <grid_module_po16_revb_init+0x74>)
    83f0:	4798      	blx	r3
	grid_module_po16_revb_hardware_start_transfer();
	
    83f2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_po16_revb_hardware_start_transfer();
    83f6:	4b08      	ldr	r3, [pc, #32]	; (8418 <grid_module_po16_revb_init+0x78>)
    83f8:	4718      	bx	r3
    83fa:	bf00      	nop
    83fc:	000045ed 	.word	0x000045ed
    8400:	20007a18 	.word	0x20007a18
    8404:	00009aa5 	.word	0x00009aa5
    8408:	00006f19 	.word	0x00006f19
    840c:	20015254 	.word	0x20015254
    8410:	00009a71 	.word	0x00009a71
    8414:	0000835d 	.word	0x0000835d
    8418:	000080c9 	.word	0x000080c9
    841c:	0000a3d1 	.word	0x0000a3d1

00008420 <grid_msg_header_set_len>:

#include "grid_msg.h"


// ======================= GRID MSG LEN ======================//
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    8420:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8422:	2200      	movs	r2, #0
    8424:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    8428:	f10d 020f 	add.w	r2, sp, #15
    842c:	9200      	str	r2, [sp, #0]
    842e:	2202      	movs	r2, #2
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    8430:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    8432:	4c02      	ldr	r4, [pc, #8]	; (843c <grid_msg_header_set_len+0x1c>)
    8434:	4611      	mov	r1, r2
    8436:	47a0      	blx	r4
	
}
    8438:	b004      	add	sp, #16
    843a:	bd10      	pop	{r4, pc}
    843c:	00009a2d 	.word	0x00009a2d

00008440 <grid_msg_header_set_id>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, &error);
}

// ======================= GRID MSG ID ======================//
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    8440:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8442:	2200      	movs	r2, #0
    8444:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    8448:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    844c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    844e:	9200      	str	r2, [sp, #0]
    8450:	4c02      	ldr	r4, [pc, #8]	; (845c <grid_msg_header_set_id+0x1c>)
    8452:	2202      	movs	r2, #2
    8454:	2104      	movs	r1, #4
    8456:	47a0      	blx	r4
	
}
    8458:	b004      	add	sp, #16
    845a:	bd10      	pop	{r4, pc}
    845c:	00009a2d 	.word	0x00009a2d

00008460 <grid_msg_header_set_dx>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
}

// ======================= GRID MSG DX ======================//
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8460:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8462:	2200      	movs	r2, #0
    8464:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8468:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    846c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    846e:	9200      	str	r2, [sp, #0]
    8470:	4c02      	ldr	r4, [pc, #8]	; (847c <grid_msg_header_set_dx+0x1c>)
    8472:	2202      	movs	r2, #2
    8474:	2106      	movs	r1, #6
    8476:	47a0      	blx	r4
	
}
    8478:	b004      	add	sp, #16
    847a:	bd10      	pop	{r4, pc}
    847c:	00009a2d 	.word	0x00009a2d

00008480 <grid_msg_header_get_dx>:


uint8_t grid_msg_header_get_dx(struct grid_msg* msg){
    8480:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    8482:	2300      	movs	r3, #0
    8484:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    8488:	4c04      	ldr	r4, [pc, #16]	; (849c <grid_msg_header_get_dx+0x1c>)
    848a:	f10d 0307 	add.w	r3, sp, #7
    848e:	2202      	movs	r2, #2
    8490:	2106      	movs	r1, #6
    8492:	47a0      	blx	r4
}
    8494:	b2c0      	uxtb	r0, r0
    8496:	b002      	add	sp, #8
    8498:	bd10      	pop	{r4, pc}
    849a:	bf00      	nop
    849c:	00009a15 	.word	0x00009a15

000084a0 <grid_msg_header_set_dy>:

// ======================= GRID MSG DY ======================//
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    84a0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    84a2:	2200      	movs	r2, #0
    84a4:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    84a8:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    84ac:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    84ae:	9200      	str	r2, [sp, #0]
    84b0:	4c02      	ldr	r4, [pc, #8]	; (84bc <grid_msg_header_set_dy+0x1c>)
    84b2:	2202      	movs	r2, #2
    84b4:	2108      	movs	r1, #8
    84b6:	47a0      	blx	r4
	
}
    84b8:	b004      	add	sp, #16
    84ba:	bd10      	pop	{r4, pc}
    84bc:	00009a2d 	.word	0x00009a2d

000084c0 <grid_msg_header_get_dy>:


uint8_t grid_msg_header_get_dy(struct grid_msg* msg){
    84c0:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    84c2:	2300      	movs	r3, #0
    84c4:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    84c8:	4c04      	ldr	r4, [pc, #16]	; (84dc <grid_msg_header_get_dy+0x1c>)
    84ca:	f10d 0307 	add.w	r3, sp, #7
    84ce:	2202      	movs	r2, #2
    84d0:	2108      	movs	r1, #8
    84d2:	47a0      	blx	r4
}
    84d4:	b2c0      	uxtb	r0, r0
    84d6:	b002      	add	sp, #8
    84d8:	bd10      	pop	{r4, pc}
    84da:	bf00      	nop
    84dc:	00009a15 	.word	0x00009a15

000084e0 <grid_msg_header_set_rot>:

// ======================= GRID MSG ROT ======================//
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    84e0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    84e2:	2200      	movs	r2, #0
    84e4:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    84e8:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    84ec:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    84ee:	9200      	str	r2, [sp, #0]
    84f0:	4c02      	ldr	r4, [pc, #8]	; (84fc <grid_msg_header_set_rot+0x1c>)
    84f2:	2202      	movs	r2, #2
    84f4:	210c      	movs	r1, #12
    84f6:	47a0      	blx	r4
	
}
    84f8:	b004      	add	sp, #16
    84fa:	bd10      	pop	{r4, pc}
    84fc:	00009a2d 	.word	0x00009a2d

00008500 <grid_msg_header_set_age>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
}

// ======================= GRID MSG AGE ======================//
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    8500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8502:	2200      	movs	r2, #0
    8504:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    8508:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    850c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    850e:	9200      	str	r2, [sp, #0]
    8510:	4c02      	ldr	r4, [pc, #8]	; (851c <grid_msg_header_set_age+0x1c>)
    8512:	2202      	movs	r2, #2
    8514:	210a      	movs	r1, #10
    8516:	47a0      	blx	r4
	
}
    8518:	b004      	add	sp, #16
    851a:	bd10      	pop	{r4, pc}
    851c:	00009a2d 	.word	0x00009a2d

00008520 <grid_msg_packet_get_length>:
}

// ======================= MSG GET PACKET LENGTH ======================//
uint32_t grid_msg_packet_get_length(struct grid_msg* msg){
	
	return (msg->header_length + msg->body_length + msg->footer_length);
    8520:	e9d0 3264 	ldrd	r3, r2, [r0, #400]	; 0x190
    8524:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    8528:	4413      	add	r3, r2
}
    852a:	4418      	add	r0, r3
    852c:	4770      	bx	lr

0000852e <grid_msg_body_get_length>:

// ======================= MSG GET BODY LENGTH ======================//
uint32_t grid_msg_body_get_length(struct grid_msg* msg){
	
	return (msg->body_length);
}
    852e:	f8d0 0194 	ldr.w	r0, [r0, #404]	; 0x194
    8532:	4770      	bx	lr

00008534 <grid_msg_body_append_text>:
	
	return (msg->footer_length);
}


void	grid_msg_body_append_text(struct grid_msg* msg, uint8_t* str, uint32_t len){
    8534:	b570      	push	{r4, r5, r6, lr}
    8536:	f8d0 5194 	ldr.w	r5, [r0, #404]	; 0x194

	
	for(uint32_t i=0; i<len; i++){
    853a:	2300      	movs	r3, #0
    853c:	4293      	cmp	r3, r2
    853e:	d103      	bne.n	8548 <grid_msg_body_append_text+0x14>
		
		msg->body[msg->body_length + i] = str[i];
	}
	
	msg->body_length += len;
    8540:	442b      	add	r3, r5
    8542:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    8546:	bd70      	pop	{r4, r5, r6, pc}
		msg->body[msg->body_length + i] = str[i];
    8548:	18c4      	adds	r4, r0, r3
    854a:	442c      	add	r4, r5
    854c:	5cce      	ldrb	r6, [r1, r3]
    854e:	7526      	strb	r6, [r4, #20]
	for(uint32_t i=0; i<len; i++){
    8550:	3301      	adds	r3, #1
    8552:	e7f3      	b.n	853c <grid_msg_body_append_text+0x8>

00008554 <grid_msg_body_append_text_escaped>:

void	grid_msg_body_append_text_escaped(struct grid_msg* msg, uint8_t* str, uint32_t len){
    8554:	b5f0      	push	{r4, r5, r6, r7, lr}
    8556:	f8d0 6194 	ldr.w	r6, [r0, #404]	; 0x194
	
	for(uint32_t i=0; i<len; i++){
    855a:	2400      	movs	r4, #0
		
		if (str[i] == GRID_CONST_STX){
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
		}
		else if (str[i] == GRID_CONST_ETX){
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    855c:	2783      	movs	r7, #131	; 0x83
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    855e:	f04f 0c82 	mov.w	ip, #130	; 0x82
	for(uint32_t i=0; i<len; i++){
    8562:	4294      	cmp	r4, r2
    8564:	eb04 0306 	add.w	r3, r4, r6
    8568:	d102      	bne.n	8570 <grid_msg_body_append_text_escaped+0x1c>
			msg->body[msg->body_length + i] = str[i];
		}
		
	}
	
	msg->body_length += len;
    856a:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    856e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (str[i] == GRID_CONST_STX){
    8570:	5d0d      	ldrb	r5, [r1, r4]
    8572:	2d02      	cmp	r5, #2
    8574:	4403      	add	r3, r0
    8576:	d103      	bne.n	8580 <grid_msg_body_append_text_escaped+0x2c>
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8578:	f883 c014 	strb.w	ip, [r3, #20]
	for(uint32_t i=0; i<len; i++){
    857c:	3401      	adds	r4, #1
    857e:	e7f0      	b.n	8562 <grid_msg_body_append_text_escaped+0xe>
		else if (str[i] == GRID_CONST_ETX){
    8580:	2d03      	cmp	r5, #3
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    8582:	bf0c      	ite	eq
    8584:	751f      	strbeq	r7, [r3, #20]
			msg->body[msg->body_length + i] = str[i];
    8586:	751d      	strbne	r5, [r3, #20]
    8588:	e7f8      	b.n	857c <grid_msg_body_append_text_escaped+0x28>
	...

0000858c <grid_msg_text_get_parameter>:


uint32_t grid_msg_text_get_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length){
    858c:	b420      	push	{r5}
	
	uint8_t error;
	
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    858e:	f101 0514 	add.w	r5, r1, #20
    8592:	4415      	add	r5, r2
    8594:	4619      	mov	r1, r3
    8596:	4428      	add	r0, r5
    8598:	4b02      	ldr	r3, [pc, #8]	; (85a4 <grid_msg_text_get_parameter+0x18>)
	
}
    859a:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    859e:	2200      	movs	r2, #0
    85a0:	4718      	bx	r3
    85a2:	bf00      	nop
    85a4:	00009861 	.word	0x00009861

000085a8 <grid_msg_text_set_parameter>:

void grid_msg_text_set_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length, uint32_t value){
    85a8:	b420      	push	{r5}
	
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    85aa:	f101 0514 	add.w	r5, r1, #20
    85ae:	4415      	add	r5, r2
    85b0:	4619      	mov	r1, r3
    85b2:	9a01      	ldr	r2, [sp, #4]
    85b4:	4b02      	ldr	r3, [pc, #8]	; (85c0 <grid_msg_text_set_parameter+0x18>)
    85b6:	4428      	add	r0, r5
	
}
    85b8:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    85bc:	4718      	bx	r3
    85be:	bf00      	nop
    85c0:	00009889 	.word	0x00009889

000085c4 <grid_msg_init>:


// ======================= GRID MSG INIT ======================//
void	grid_msg_init(struct grid_msg* msg){
	
	msg->header_length = 0;
    85c4:	2300      	movs	r3, #0
	msg->body_length = 0;
    85c6:	e9c0 3364 	strd	r3, r3, [r0, #400]	; 0x190
	msg->footer_length = 0;
    85ca:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
	
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    85ce:	1e42      	subs	r2, r0, #1
    85d0:	f100 0113 	add.w	r1, r0, #19
	{
		msg->header[i] = 0;
    85d4:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    85d8:	4291      	cmp	r1, r2
    85da:	d1fb      	bne.n	85d4 <grid_msg_init+0x10>
    85dc:	f100 0214 	add.w	r2, r0, #20
    85e0:	f200 118b 	addw	r1, r0, #395	; 0x18b
	}
	
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
	{
		msg->body[i] = 0;
    85e4:	2300      	movs	r3, #0
    85e6:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
    85ea:	428a      	cmp	r2, r1
    85ec:	d1fb      	bne.n	85e6 <grid_msg_init+0x22>
	}
	
	for (uint32_t i=0; i<GRID_MSG_FOOTER_maxlength; i++)
	{
		msg->footer[i] = 0;
    85ee:	f880 318b 	strb.w	r3, [r0, #395]	; 0x18b
    85f2:	f8c0 318c 	str.w	r3, [r0, #396]	; 0x18c
	}
	
		
}
    85f6:	4770      	bx	lr

000085f8 <grid_msg_init_header>:

// ======================= MSG INIT HEADER======================//

void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    85f8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    85fc:	461e      	mov	r6, r3
	
    
    uint8_t age = grid_sys_state.sessionid;
    85fe:	4b13      	ldr	r3, [pc, #76]	; (864c <grid_msg_init_header+0x54>)
    
	sprintf(msg->header, GRID_BRC_frame);
    8600:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8668 <grid_msg_init_header+0x70>
    uint8_t age = grid_sys_state.sessionid;
    8604:	795d      	ldrb	r5, [r3, #5]
	sprintf(msg->header, GRID_BRC_frame);
    8606:	2317      	movs	r3, #23
void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    8608:	4604      	mov	r4, r0
    860a:	4688      	mov	r8, r1
    860c:	4617      	mov	r7, r2
	sprintf(msg->header, GRID_BRC_frame);
    860e:	4910      	ldr	r1, [pc, #64]	; (8650 <grid_msg_init_header+0x58>)
    8610:	9300      	str	r3, [sp, #0]
    8612:	2201      	movs	r2, #1
    8614:	230f      	movs	r3, #15
    8616:	47c8      	blx	r9
	msg->header_length = strlen(msg->header);
    8618:	4b0e      	ldr	r3, [pc, #56]	; (8654 <grid_msg_init_header+0x5c>)
    861a:	4620      	mov	r0, r4
    861c:	4798      	blx	r3
	
	grid_msg_header_set_dx(msg, dx);
    861e:	4641      	mov	r1, r8
	msg->header_length = strlen(msg->header);
    8620:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	grid_msg_header_set_dx(msg, dx);
    8624:	4b0c      	ldr	r3, [pc, #48]	; (8658 <grid_msg_init_header+0x60>)
    8626:	4620      	mov	r0, r4
    8628:	4798      	blx	r3
	grid_msg_header_set_dy(msg, dy);
    862a:	4639      	mov	r1, r7
    862c:	4620      	mov	r0, r4
    862e:	4b0b      	ldr	r3, [pc, #44]	; (865c <grid_msg_init_header+0x64>)
    8630:	4798      	blx	r3
	grid_msg_header_set_rot(msg, rot);
    8632:	4631      	mov	r1, r6
    8634:	4620      	mov	r0, r4
    8636:	4b0a      	ldr	r3, [pc, #40]	; (8660 <grid_msg_init_header+0x68>)
    8638:	4798      	blx	r3
    uint8_t age = grid_sys_state.sessionid;
    863a:	b2ed      	uxtb	r5, r5
	grid_msg_header_set_age(msg, age);
    863c:	4b09      	ldr	r3, [pc, #36]	; (8664 <grid_msg_init_header+0x6c>)
    863e:	4629      	mov	r1, r5
    8640:	4620      	mov	r0, r4
	
	
}
    8642:	b003      	add	sp, #12
    8644:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	grid_msg_header_set_age(msg, age);
    8648:	4718      	bx	r3
    864a:	bf00      	nop
    864c:	20007a24 	.word	0x20007a24
    8650:	000169fc 	.word	0x000169fc
    8654:	00014c81 	.word	0x00014c81
    8658:	00008461 	.word	0x00008461
    865c:	000084a1 	.word	0x000084a1
    8660:	000084e1 	.word	0x000084e1
    8664:	00008501 	.word	0x00008501
    8668:	000147d1 	.word	0x000147d1

0000866c <grid_msg_packet_receive_char>:

// ======================= MSG RECEIVE CHAR ======================//
void	grid_msg_packet_receive_char(struct grid_msg* msg, uint8_t nextchar){
	
	if (msg->body_length == 0){
    866c:	f8d0 2194 	ldr.w	r2, [r0, #404]	; 0x194
    8670:	b96a      	cbnz	r2, 868e <grid_msg_packet_receive_char+0x22>
		
		if (nextchar != GRID_CONST_EOB){
    8672:	2917      	cmp	r1, #23
			msg->header[msg->header_length] = nextchar;
    8674:	bf15      	itete	ne
    8676:	f8d0 3190 	ldrne.w	r3, [r0, #400]	; 0x190
			msg->header_length++;
		}
		else{
			msg->body[msg->body_length] = nextchar;
    867a:	7501      	strbeq	r1, [r0, #20]
			msg->header[msg->header_length] = nextchar;
    867c:	54c1      	strbne	r1, [r0, r3]
			msg->body_length++;
    867e:	2301      	moveq	r3, #1
			msg->header_length++;
    8680:	bf1a      	itte	ne
    8682:	3301      	addne	r3, #1
    8684:	f8c0 3190 	strne.w	r3, [r0, #400]	; 0x190
			msg->body_length++;
    8688:	f8c0 3194 	streq.w	r3, [r0, #404]	; 0x194
    868c:	4770      	bx	lr
			
		}
		
	}
	else if(msg->footer_length == 0){
    868e:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
    8692:	b96b      	cbnz	r3, 86b0 <grid_msg_packet_receive_char+0x44>
		
		if (nextchar != GRID_CONST_EOT){
    8694:	2904      	cmp	r1, #4
    8696:	d005      	beq.n	86a4 <grid_msg_packet_receive_char+0x38>
			msg->body[msg->body_length] = nextchar;
    8698:	1883      	adds	r3, r0, r2
			msg->body_length++;
    869a:	3201      	adds	r2, #1
			msg->body[msg->body_length] = nextchar;
    869c:	7519      	strb	r1, [r3, #20]
			msg->body_length++;
    869e:	f8c0 2194 	str.w	r2, [r0, #404]	; 0x194
    86a2:	4770      	bx	lr
		}
		else{
			msg->footer[msg->footer_length] = nextchar;
    86a4:	f880 118b 	strb.w	r1, [r0, #395]	; 0x18b
			msg->footer_length++;
    86a8:	2301      	movs	r3, #1
		
	}
	else{
		
		msg->footer[msg->footer_length] = nextchar;
		msg->footer_length++;
    86aa:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
		
	}
	
}
    86ae:	4770      	bx	lr
		msg->footer[msg->footer_length] = nextchar;
    86b0:	18c2      	adds	r2, r0, r3
		msg->footer_length++;
    86b2:	3301      	adds	r3, #1
		msg->footer[msg->footer_length] = nextchar;
    86b4:	f882 118b 	strb.w	r1, [r2, #395]	; 0x18b
		msg->footer_length++;
    86b8:	e7f7      	b.n	86aa <grid_msg_packet_receive_char+0x3e>

000086ba <grid_msg_packet_send_char>:

// ======================= GRID MSG SEND CHAR ======================//

uint8_t	grid_msg_packet_send_char(struct grid_msg* msg, uint32_t charindex){
	
	if (charindex < msg->header_length){
    86ba:	f8d0 2190 	ldr.w	r2, [r0, #400]	; 0x190
    86be:	428a      	cmp	r2, r1
    86c0:	d901      	bls.n	86c6 <grid_msg_packet_send_char+0xc>
		
		return msg->header[charindex];
    86c2:	5c40      	ldrb	r0, [r0, r1]
    86c4:	4770      	bx	lr
	}
	else if (charindex < msg->body_length + msg->header_length){
    86c6:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
    86ca:	4413      	add	r3, r2
    86cc:	428b      	cmp	r3, r1
    86ce:	d903      	bls.n	86d8 <grid_msg_packet_send_char+0x1e>
	
		return msg->body[charindex - msg->header_length];
    86d0:	1a89      	subs	r1, r1, r2
    86d2:	4408      	add	r0, r1
    86d4:	7d00      	ldrb	r0, [r0, #20]
    86d6:	4770      	bx	lr
	}
	else if (charindex < msg->footer_length + msg->body_length + msg->header_length){
    86d8:	f8d0 2198 	ldr.w	r2, [r0, #408]	; 0x198
    86dc:	441a      	add	r2, r3
    86de:	428a      	cmp	r2, r1
	
		return msg->footer[charindex - msg->header_length - msg->body_length];
    86e0:	bf83      	ittte	hi
    86e2:	1ac9      	subhi	r1, r1, r3
    86e4:	1840      	addhi	r0, r0, r1
    86e6:	f890 018b 	ldrbhi.w	r0, [r0, #395]	; 0x18b
	}
	else{
		// OVERRUN
		return -1;
    86ea:	20ff      	movls	r0, #255	; 0xff
	}
	
	
}
    86ec:	4770      	bx	lr
	...

000086f0 <grid_msg_packet_close>:



uint8_t	grid_msg_packet_close(struct grid_msg* msg){
    86f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    86f2:	4604      	mov	r4, r0
	
	
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    86f4:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    86f8:	492b      	ldr	r1, [pc, #172]	; (87a8 <grid_msg_packet_close+0xb8>)
    86fa:	4d2c      	ldr	r5, [pc, #176]	; (87ac <grid_msg_packet_close+0xbc>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    86fc:	4e2c      	ldr	r6, [pc, #176]	; (87b0 <grid_msg_packet_close+0xc0>)
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    86fe:	f200 108b 	addw	r0, r0, #395	; 0x18b
    8702:	2204      	movs	r2, #4
    8704:	4420      	add	r0, r4
    8706:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8708:	f8d4 7198 	ldr.w	r7, [r4, #408]	; 0x198
    870c:	f207 108b 	addw	r0, r7, #395	; 0x18b
    8710:	4420      	add	r0, r4
    8712:	47b0      	blx	r6
	
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8714:	e9d4 3164 	ldrd	r3, r1, [r4, #400]	; 0x190
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8718:	4438      	add	r0, r7
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    871a:	440b      	add	r3, r1
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    871c:	4f25      	ldr	r7, [pc, #148]	; (87b4 <grid_msg_packet_close+0xc4>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    871e:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8722:	1819      	adds	r1, r3, r0
    8724:	b2c9      	uxtb	r1, r1
    8726:	4b24      	ldr	r3, [pc, #144]	; (87b8 <grid_msg_packet_close+0xc8>)
    8728:	4620      	mov	r0, r4
    872a:	4798      	blx	r3
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    872c:	f897 10ad 	ldrb.w	r1, [r7, #173]	; 0xad
    8730:	4b22      	ldr	r3, [pc, #136]	; (87bc <grid_msg_packet_close+0xcc>)
    8732:	4620      	mov	r0, r4
    8734:	4798      	blx	r3
	
	grid_sys_state.next_broadcast_message_id++;
    8736:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
    873a:	3301      	adds	r3, #1
    873c:	b2db      	uxtb	r3, r3
    873e:	f887 30ad 	strb.w	r3, [r7, #173]	; 0xad
	
	
	uint8_t checksum = 0;
	
	for (uint32_t i=0; i<msg->header_length; i++){
    8742:	f8d4 3190 	ldr.w	r3, [r4, #400]	; 0x190
    8746:	4621      	mov	r1, r4
    8748:	4423      	add	r3, r4
	uint8_t checksum = 0;
    874a:	2200      	movs	r2, #0
	for (uint32_t i=0; i<msg->header_length; i++){
    874c:	4299      	cmp	r1, r3
    874e:	d11f      	bne.n	8790 <grid_msg_packet_close+0xa0>
    8750:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
    8754:	4423      	add	r3, r4
    8756:	f104 0114 	add.w	r1, r4, #20
    875a:	3314      	adds	r3, #20
		checksum ^= msg->header[i];
	}
		
	for (uint32_t i=0; i<msg->body_length; i++){
    875c:	4299      	cmp	r1, r3
    875e:	d11b      	bne.n	8798 <grid_msg_packet_close+0xa8>
		checksum ^= msg->body[i];
	}
		
	for (uint32_t i=0; i<msg->footer_length; i++){
    8760:	f8d4 0198 	ldr.w	r0, [r4, #408]	; 0x198
    8764:	1823      	adds	r3, r4, r0
    8766:	f204 118b 	addw	r1, r4, #395	; 0x18b
    876a:	f203 138b 	addw	r3, r3, #395	; 0x18b
    876e:	4299      	cmp	r1, r3
    8770:	d116      	bne.n	87a0 <grid_msg_packet_close+0xb0>
		checksum ^= msg->footer[i];
	}
	
	sprintf(&msg->footer[msg->footer_length], "%02x\n", checksum);
    8772:	f200 108b 	addw	r0, r0, #395	; 0x18b
    8776:	4912      	ldr	r1, [pc, #72]	; (87c0 <grid_msg_packet_close+0xd0>)
    8778:	4420      	add	r0, r4
    877a:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    877c:	f8d4 5198 	ldr.w	r5, [r4, #408]	; 0x198
    8780:	f205 108b 	addw	r0, r5, #395	; 0x18b
    8784:	4420      	add	r0, r4
    8786:	47b0      	blx	r6
    8788:	4428      	add	r0, r5
    878a:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	
	
}
    878e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		checksum ^= msg->header[i];
    8790:	f811 0b01 	ldrb.w	r0, [r1], #1
    8794:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->header_length; i++){
    8796:	e7d9      	b.n	874c <grid_msg_packet_close+0x5c>
		checksum ^= msg->body[i];
    8798:	f811 0b01 	ldrb.w	r0, [r1], #1
    879c:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->body_length; i++){
    879e:	e7dd      	b.n	875c <grid_msg_packet_close+0x6c>
		checksum ^= msg->footer[i];
    87a0:	f811 7b01 	ldrb.w	r7, [r1], #1
    87a4:	407a      	eors	r2, r7
	for (uint32_t i=0; i<msg->footer_length; i++){
    87a6:	e7e2      	b.n	876e <grid_msg_packet_close+0x7e>
    87a8:	0001674f 	.word	0x0001674f
    87ac:	000147d1 	.word	0x000147d1
    87b0:	00014c81 	.word	0x00014c81
    87b4:	20007a24 	.word	0x20007a24
    87b8:	00008421 	.word	0x00008421
    87bc:	00008441 	.word	0x00008441
    87c0:	000173c3 	.word	0x000173c3

000087c4 <grid_msg_packet_send_everywhere>:

uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    87c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	
	uint32_t message_length = grid_msg_packet_get_length(msg);
    87c8:	4b0f      	ldr	r3, [pc, #60]	; (8808 <grid_msg_packet_send_everywhere+0x44>)
uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    87ca:	4606      	mov	r6, r0
	uint32_t message_length = grid_msg_packet_get_length(msg);
    87cc:	4798      	blx	r3
	
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    87ce:	4b0f      	ldr	r3, [pc, #60]	; (880c <grid_msg_packet_send_everywhere+0x48>)
	uint32_t message_length = grid_msg_packet_get_length(msg);
    87d0:	4604      	mov	r4, r0
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    87d2:	b281      	uxth	r1, r0
    87d4:	480e      	ldr	r0, [pc, #56]	; (8810 <grid_msg_packet_send_everywhere+0x4c>)
    87d6:	4798      	blx	r3
    87d8:	b978      	cbnz	r0, 87fa <grid_msg_packet_send_everywhere+0x36>
		
		return 0;
	}
	
	
}
    87da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    87de:	4629      	mov	r1, r5
    87e0:	4630      	mov	r0, r6
    87e2:	47b8      	blx	r7
    87e4:	4601      	mov	r1, r0
    87e6:	4640      	mov	r0, r8
    87e8:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    87ea:	3501      	adds	r5, #1
    87ec:	42a5      	cmp	r5, r4
    87ee:	d1f6      	bne.n	87de <grid_msg_packet_send_everywhere+0x1a>
		grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    87f0:	4807      	ldr	r0, [pc, #28]	; (8810 <grid_msg_packet_send_everywhere+0x4c>)
    87f2:	4b08      	ldr	r3, [pc, #32]	; (8814 <grid_msg_packet_send_everywhere+0x50>)
    87f4:	4798      	blx	r3
		return 1;
    87f6:	2001      	movs	r0, #1
    87f8:	e7ef      	b.n	87da <grid_msg_packet_send_everywhere+0x16>
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    87fa:	4f07      	ldr	r7, [pc, #28]	; (8818 <grid_msg_packet_send_everywhere+0x54>)
    87fc:	f8df 8010 	ldr.w	r8, [pc, #16]	; 8810 <grid_msg_packet_send_everywhere+0x4c>
    8800:	f8df 9018 	ldr.w	r9, [pc, #24]	; 881c <grid_msg_packet_send_everywhere+0x58>
		for(uint32_t i = 0; i<message_length; i++){
    8804:	2500      	movs	r5, #0
    8806:	e7f1      	b.n	87ec <grid_msg_packet_send_everywhere+0x28>
    8808:	00008521 	.word	0x00008521
    880c:	00004839 	.word	0x00004839
    8810:	20007600 	.word	0x20007600
    8814:	00004895 	.word	0x00004895
    8818:	000086bb 	.word	0x000086bb
    881c:	00004875 	.word	0x00004875

00008820 <grid_nvm_ui_bulk_read_init>:
}


void grid_nvm_ui_bulk_read_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->read_bulk_page_index = 0;
    8820:	2300      	movs	r3, #0
    8822:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 1;
    8826:	2301      	movs	r3, #1
    8828:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
			
}
    882c:	4770      	bx	lr

0000882e <grid_nvm_ui_bulk_read_is_in_progress>:

uint8_t grid_nvm_ui_bulk_read_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->read_bulk_status;
	
}
    882e:	f890 0428 	ldrb.w	r0, [r0, #1064]	; 0x428
    8832:	4770      	bx	lr

00008834 <grid_nvm_ui_bulk_read_next>:

void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8834:	b5f0      	push	{r4, r5, r6, r7, lr}
    8836:	4604      	mov	r4, r0
    8838:	b0ed      	sub	sp, #436	; 0x1b4
	
	if (nvm->read_bulk_status == 1){
    883a:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
    883e:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8840:	4608      	mov	r0, r1
	if (nvm->read_bulk_status == 1){
    8842:	d12f      	bne.n	88a4 <grid_nvm_ui_bulk_read_next+0x70>
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8844:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8846:	f8d4 2424 	ldr.w	r2, [r4, #1060]	; 0x424
    884a:	23a0      	movs	r3, #160	; 0xa0
    884c:	fbb2 f3f3 	udiv	r3, r2, r3
    8850:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8854:	4299      	cmp	r1, r3
    8856:	d91c      	bls.n	8892 <grid_nvm_ui_bulk_read_next+0x5e>
			
			if (element < ui->bank_list[bank].element_list_length){
    8858:	6845      	ldr	r5, [r0, #4]
    885a:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    885e:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8860:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8862:	fbb2 f1f7 	udiv	r1, r2, r7
    8866:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    886a:	42b5      	cmp	r5, r6
    886c:	d911      	bls.n	8892 <grid_nvm_ui_bulk_read_next+0x5e>
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    886e:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8872:	68da      	ldr	r2, [r3, #12]
    8874:	2364      	movs	r3, #100	; 0x64
    8876:	fb06 2303 	mla	r3, r6, r3, r2
    887a:	b2ca      	uxtb	r2, r1
    887c:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8880:	4295      	cmp	r5, r2
    8882:	d906      	bls.n	8892 <grid_nvm_ui_bulk_read_next+0x5e>
					// Valid memory location
					
					int status = grid_ui_nvm_load_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);
    8884:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8886:	22bc      	movs	r2, #188	; 0xbc
    8888:	fb02 3201 	mla	r2, r2, r1, r3
    888c:	4b1f      	ldr	r3, [pc, #124]	; (890c <grid_nvm_ui_bulk_read_next+0xd8>)
    888e:	4621      	mov	r1, r4
    8890:	4798      	blx	r3
			}
	
		}
		
		
		if (nvm->read_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8892:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
    8896:	f240 227e 	movw	r2, #638	; 0x27e
    889a:	4293      	cmp	r3, r2
    889c:	d804      	bhi.n	88a8 <grid_nvm_ui_bulk_read_next+0x74>
			
			nvm->read_bulk_page_index++;
    889e:	3301      	adds	r3, #1
    88a0:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
	}
	
	
	
	
}
    88a4:	b06d      	add	sp, #436	; 0x1b4
    88a6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			nvm->read_bulk_page_index = 0;
    88a8:	2500      	movs	r5, #0
    88aa:	f8c4 5424 	str.w	r5, [r4, #1060]	; 0x424
			nvm->read_bulk_status = 0;
    88ae:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
			grid_msg_init(&response);
    88b2:	a805      	add	r0, sp, #20
    88b4:	4b16      	ldr	r3, [pc, #88]	; (8910 <grid_nvm_ui_bulk_read_next+0xdc>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    88b6:	4c17      	ldr	r4, [pc, #92]	; (8914 <grid_nvm_ui_bulk_read_next+0xe0>)
			grid_msg_init(&response);
    88b8:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    88ba:	227f      	movs	r2, #127	; 0x7f
    88bc:	462b      	mov	r3, r5
    88be:	4611      	mov	r1, r2
    88c0:	a805      	add	r0, sp, #20
    88c2:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    88c4:	2303      	movs	r3, #3
    88c6:	4914      	ldr	r1, [pc, #80]	; (8918 <grid_nvm_ui_bulk_read_next+0xe4>)
    88c8:	9300      	str	r3, [sp, #0]
    88ca:	2202      	movs	r2, #2
    88cc:	4c13      	ldr	r4, [pc, #76]	; (891c <grid_nvm_ui_bulk_read_next+0xe8>)
			uint8_t response_payload[10] = {0};
    88ce:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    88d2:	2371      	movs	r3, #113	; 0x71
    88d4:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    88d6:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    88da:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    88dc:	4b10      	ldr	r3, [pc, #64]	; (8920 <grid_nvm_ui_bulk_read_next+0xec>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    88de:	4c11      	ldr	r4, [pc, #68]	; (8924 <grid_nvm_ui_bulk_read_next+0xf0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    88e0:	a802      	add	r0, sp, #8
    88e2:	4798      	blx	r3
    88e4:	a902      	add	r1, sp, #8
    88e6:	4602      	mov	r2, r0
    88e8:	4b0f      	ldr	r3, [pc, #60]	; (8928 <grid_nvm_ui_bulk_read_next+0xf4>)
    88ea:	a805      	add	r0, sp, #20
    88ec:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    88ee:	230a      	movs	r3, #10
    88f0:	9300      	str	r3, [sp, #0]
    88f2:	2204      	movs	r2, #4
    88f4:	4629      	mov	r1, r5
    88f6:	a805      	add	r0, sp, #20
    88f8:	2301      	movs	r3, #1
    88fa:	47a0      	blx	r4
			grid_msg_packet_close(&response);
    88fc:	4b0b      	ldr	r3, [pc, #44]	; (892c <grid_nvm_ui_bulk_read_next+0xf8>)
    88fe:	a805      	add	r0, sp, #20
    8900:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8902:	4b0b      	ldr	r3, [pc, #44]	; (8930 <grid_nvm_ui_bulk_read_next+0xfc>)
    8904:	a805      	add	r0, sp, #20
    8906:	4798      	blx	r3
}
    8908:	e7cc      	b.n	88a4 <grid_nvm_ui_bulk_read_next+0x70>
    890a:	bf00      	nop
    890c:	00009e95 	.word	0x00009e95
    8910:	000085c5 	.word	0x000085c5
    8914:	000085f9 	.word	0x000085f9
    8918:	00016a0f 	.word	0x00016a0f
    891c:	000147d1 	.word	0x000147d1
    8920:	00014c81 	.word	0x00014c81
    8924:	000085a9 	.word	0x000085a9
    8928:	00008535 	.word	0x00008535
    892c:	000086f1 	.word	0x000086f1
    8930:	000087c5 	.word	0x000087c5

00008934 <grid_nvm_ui_bulk_store_init>:


void grid_nvm_ui_bulk_store_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->store_bulk_page_index = 0;
    8934:	2300      	movs	r3, #0
    8936:	f8c0 3434 	str.w	r3, [r0, #1076]	; 0x434
	nvm->store_bulk_status = 1;
    893a:	2301      	movs	r3, #1
    893c:	f880 3438 	strb.w	r3, [r0, #1080]	; 0x438
	
}
    8940:	4770      	bx	lr

00008942 <grid_nvm_ui_bulk_store_is_in_progress>:

uint8_t grid_nvm_ui_bulk_store_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->store_bulk_status;
	
}
    8942:	f890 0438 	ldrb.w	r0, [r0, #1080]	; 0x438
    8946:	4770      	bx	lr

00008948 <grid_nvm_ui_bulk_store_next>:

// DO THIS!!
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8948:	b5f0      	push	{r4, r5, r6, r7, lr}
     
    // START: NEW
    
    
	if (nvm->store_bulk_status == 1){
    894a:	f890 3438 	ldrb.w	r3, [r0, #1080]	; 0x438
    894e:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8950:	b0ed      	sub	sp, #436	; 0x1b4
    8952:	4604      	mov	r4, r0
    8954:	460d      	mov	r5, r1
	if (nvm->store_bulk_status == 1){
    8956:	d168      	bne.n	8a2a <grid_nvm_ui_bulk_store_next+0xe2>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];

                        if (eve->cfg_changed_flag == 1){


                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    8958:	4f53      	ldr	r7, [pc, #332]	; (8aa8 <grid_nvm_ui_bulk_store_next+0x160>)
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    895a:	26a0      	movs	r6, #160	; 0xa0
            if (bank < ui->bank_list_length){
    895c:	786a      	ldrb	r2, [r5, #1]
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    895e:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    8962:	fbb3 f1f6 	udiv	r1, r3, r6
    8966:	f001 0003 	and.w	r0, r1, #3
            if (bank < ui->bank_list_length){
    896a:	4282      	cmp	r2, r0
    896c:	d95f      	bls.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                if (element < ui->bank_list[bank].element_list_length){
    896e:	6869      	ldr	r1, [r5, #4]
    8970:	eb01 1100 	add.w	r1, r1, r0, lsl #4
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8974:	f04f 0e0a 	mov.w	lr, #10
                if (element < ui->bank_list[bank].element_list_length){
    8978:	7a48      	ldrb	r0, [r1, #9]
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    897a:	fbb3 f2fe 	udiv	r2, r3, lr
    897e:	f002 0c0f 	and.w	ip, r2, #15
                if (element < ui->bank_list[bank].element_list_length){
    8982:	4560      	cmp	r0, ip
    8984:	d953      	bls.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8986:	68c9      	ldr	r1, [r1, #12]
            uint8_t event   = nvm->store_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8988:	fb0e 3212 	mls	r2, lr, r2, r3
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    898c:	2364      	movs	r3, #100	; 0x64
    898e:	fb0c 1303 	mla	r3, ip, r3, r1
    8992:	b2d1      	uxtb	r1, r2
    8994:	f893 005c 	ldrb.w	r0, [r3, #92]	; 0x5c
    8998:	4288      	cmp	r0, r1
    899a:	d948      	bls.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];
    899c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    899e:	21bc      	movs	r1, #188	; 0xbc
    89a0:	fb01 3202 	mla	r2, r1, r2, r3
                        if (eve->cfg_changed_flag == 1){
    89a4:	f892 30b6 	ldrb.w	r3, [r2, #182]	; 0xb6
    89a8:	2b01      	cmp	r3, #1
    89aa:	d140      	bne.n	8a2e <grid_nvm_ui_bulk_store_next+0xe6>
                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    89ac:	4621      	mov	r1, r4
    89ae:	4628      	mov	r0, r5
    89b0:	47b8      	blx	r7
    89b2:	3800      	subs	r0, #0
    89b4:	bf18      	it	ne
    89b6:	2001      	movne	r0, #1

            }
            
            

            if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    89b8:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    89bc:	f240 227e 	movw	r2, #638	; 0x27e
    89c0:	4293      	cmp	r3, r2
    89c2:	d804      	bhi.n	89ce <grid_nvm_ui_bulk_store_next+0x86>



                nvm->store_bulk_page_index++;       
    89c4:	3301      	adds	r3, #1
    89c6:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        while (something_was_stored == 0){
    89ca:	2800      	cmp	r0, #0
    89cc:	d0c6      	beq.n	895c <grid_nvm_ui_bulk_store_next+0x14>
		

		
		
		
		if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    89ce:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    89d2:	4e36      	ldr	r6, [pc, #216]	; (8aac <grid_nvm_ui_bulk_store_next+0x164>)
    89d4:	f240 227e 	movw	r2, #638	; 0x27e
    89d8:	4293      	cmp	r3, r2
    89da:	d82a      	bhi.n	8a32 <grid_nvm_ui_bulk_store_next+0xea>
			
            
            uint8_t intensity = abs(nvm->store_bulk_page_index%100 - 50)/1.5 + 40;
    89dc:	2264      	movs	r2, #100	; 0x64
    89de:	fbb3 f0f2 	udiv	r0, r3, r2
    89e2:	fb02 3010 	mls	r0, r2, r0, r3
    89e6:	3832      	subs	r0, #50	; 0x32
    89e8:	2800      	cmp	r0, #0
    89ea:	bfb8      	it	lt
    89ec:	4240      	neglt	r0, r0
    89ee:	4f30      	ldr	r7, [pc, #192]	; (8ab0 <grid_nvm_ui_bulk_store_next+0x168>)
    89f0:	4c30      	ldr	r4, [pc, #192]	; (8ab4 <grid_nvm_ui_bulk_store_next+0x16c>)
    89f2:	4d31      	ldr	r5, [pc, #196]	; (8ab8 <grid_nvm_ui_bulk_store_next+0x170>)
    89f4:	47b8      	blx	r7
    89f6:	4b31      	ldr	r3, [pc, #196]	; (8abc <grid_nvm_ui_bulk_store_next+0x174>)
    89f8:	2200      	movs	r2, #0
    89fa:	47a0      	blx	r4
    89fc:	4b30      	ldr	r3, [pc, #192]	; (8ac0 <grid_nvm_ui_bulk_store_next+0x178>)
    89fe:	4c31      	ldr	r4, [pc, #196]	; (8ac4 <grid_nvm_ui_bulk_store_next+0x17c>)
    8a00:	2200      	movs	r2, #0
    8a02:	47a0      	blx	r4
    8a04:	47a8      	blx	r5
    8a06:	b2c4      	uxtb	r4, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, 0, intensity*0.75, intensity, 1, 1000);
    8a08:	4620      	mov	r0, r4
    8a0a:	47b8      	blx	r7
    8a0c:	4b2e      	ldr	r3, [pc, #184]	; (8ac8 <grid_nvm_ui_bulk_store_next+0x180>)
    8a0e:	4f2f      	ldr	r7, [pc, #188]	; (8acc <grid_nvm_ui_bulk_store_next+0x184>)
    8a10:	2200      	movs	r2, #0
    8a12:	47b8      	blx	r7
    8a14:	47a8      	blx	r5
    8a16:	2301      	movs	r3, #1
    8a18:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8a1c:	e9cd 3200 	strd	r3, r2, [sp]
    8a20:	2100      	movs	r1, #0
    8a22:	b2c2      	uxtb	r2, r0
    8a24:	4623      	mov	r3, r4
    8a26:	482a      	ldr	r0, [pc, #168]	; (8ad0 <grid_nvm_ui_bulk_store_next+0x188>)
    8a28:	47b0      	blx	r6
	}
	
	
	
	
}
    8a2a:	b06d      	add	sp, #436	; 0x1b4
    8a2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8a2e:	2000      	movs	r0, #0
    8a30:	e7c2      	b.n	89b8 <grid_nvm_ui_bulk_store_next+0x70>
			nvm->store_bulk_page_index = 0;
    8a32:	2500      	movs	r5, #0
    8a34:	f8c4 5434 	str.w	r5, [r4, #1076]	; 0x434
			nvm->store_bulk_status = 0;
    8a38:	f884 5438 	strb.w	r5, [r4, #1080]	; 0x438
			grid_msg_init(&response);
    8a3c:	a805      	add	r0, sp, #20
    8a3e:	4b25      	ldr	r3, [pc, #148]	; (8ad4 <grid_nvm_ui_bulk_store_next+0x18c>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8a40:	4c25      	ldr	r4, [pc, #148]	; (8ad8 <grid_nvm_ui_bulk_store_next+0x190>)
			grid_msg_init(&response);
    8a42:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8a44:	227f      	movs	r2, #127	; 0x7f
    8a46:	462b      	mov	r3, r5
    8a48:	4611      	mov	r1, r2
    8a4a:	a805      	add	r0, sp, #20
    8a4c:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a4e:	2303      	movs	r3, #3
    8a50:	4922      	ldr	r1, [pc, #136]	; (8adc <grid_nvm_ui_bulk_store_next+0x194>)
    8a52:	9300      	str	r3, [sp, #0]
    8a54:	2202      	movs	r2, #2
    8a56:	4c22      	ldr	r4, [pc, #136]	; (8ae0 <grid_nvm_ui_bulk_store_next+0x198>)
			uint8_t response_payload[10] = {0};
    8a58:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a5c:	2370      	movs	r3, #112	; 0x70
    8a5e:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8a60:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8a64:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8a66:	4b1f      	ldr	r3, [pc, #124]	; (8ae4 <grid_nvm_ui_bulk_store_next+0x19c>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8a68:	4c1f      	ldr	r4, [pc, #124]	; (8ae8 <grid_nvm_ui_bulk_store_next+0x1a0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8a6a:	a802      	add	r0, sp, #8
    8a6c:	4798      	blx	r3
    8a6e:	a902      	add	r1, sp, #8
    8a70:	4602      	mov	r2, r0
    8a72:	4b1e      	ldr	r3, [pc, #120]	; (8aec <grid_nvm_ui_bulk_store_next+0x1a4>)
    8a74:	a805      	add	r0, sp, #20
    8a76:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8a78:	230a      	movs	r3, #10
    8a7a:	9300      	str	r3, [sp, #0]
    8a7c:	4629      	mov	r1, r5
    8a7e:	a805      	add	r0, sp, #20
    8a80:	2301      	movs	r3, #1
    8a82:	2204      	movs	r2, #4
    8a84:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8a86:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8a8a:	e9cd 5300 	strd	r5, r3, [sp]
    8a8e:	22ff      	movs	r2, #255	; 0xff
    8a90:	462b      	mov	r3, r5
    8a92:	4629      	mov	r1, r5
    8a94:	480e      	ldr	r0, [pc, #56]	; (8ad0 <grid_nvm_ui_bulk_store_next+0x188>)
    8a96:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8a98:	4b15      	ldr	r3, [pc, #84]	; (8af0 <grid_nvm_ui_bulk_store_next+0x1a8>)
    8a9a:	a805      	add	r0, sp, #20
    8a9c:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8a9e:	4b15      	ldr	r3, [pc, #84]	; (8af4 <grid_nvm_ui_bulk_store_next+0x1ac>)
    8aa0:	a805      	add	r0, sp, #20
    8aa2:	4798      	blx	r3
}
    8aa4:	e7c1      	b.n	8a2a <grid_nvm_ui_bulk_store_next+0xe2>
    8aa6:	bf00      	nop
    8aa8:	00009cf9 	.word	0x00009cf9
    8aac:	00009813 	.word	0x00009813
    8ab0:	00013aa1 	.word	0x00013aa1
    8ab4:	00013dc9 	.word	0x00013dc9
    8ab8:	00013f99 	.word	0x00013f99
    8abc:	3ff80000 	.word	0x3ff80000
    8ac0:	40440000 	.word	0x40440000
    8ac4:	00013809 	.word	0x00013809
    8ac8:	3fe80000 	.word	0x3fe80000
    8acc:	00013b75 	.word	0x00013b75
    8ad0:	20007a24 	.word	0x20007a24
    8ad4:	000085c5 	.word	0x000085c5
    8ad8:	000085f9 	.word	0x000085f9
    8adc:	00016a0f 	.word	0x00016a0f
    8ae0:	000147d1 	.word	0x000147d1
    8ae4:	00014c81 	.word	0x00014c81
    8ae8:	000085a9 	.word	0x000085a9
    8aec:	00008535 	.word	0x00008535
    8af0:	000086f1 	.word	0x000086f1
    8af4:	000087c5 	.word	0x000087c5

00008af8 <grid_nvm_ui_bulk_clear_init>:



void grid_nvm_ui_bulk_clear_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->clear_bulk_page_index = 0;
    8af8:	2300      	movs	r3, #0
    8afa:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 1;
    8afe:	2301      	movs	r3, #1
    8b00:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	
}
    8b04:	4770      	bx	lr

00008b06 <grid_nvm_ui_bulk_clear_is_in_progress>:

uint8_t grid_nvm_ui_bulk_clear_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->clear_bulk_status;
	
}
    8b06:	f890 0430 	ldrb.w	r0, [r0, #1072]	; 0x430
    8b0a:	4770      	bx	lr

00008b0c <grid_nvm_ui_bulk_clear_next>:


void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8b0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8b10:	4604      	mov	r4, r0
    8b12:	b0ec      	sub	sp, #432	; 0x1b0
	
	if (nvm->clear_bulk_status == 1){
    8b14:	f894 3430 	ldrb.w	r3, [r4, #1072]	; 0x430
    8b18:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8b1a:	4608      	mov	r0, r1
	if (nvm->clear_bulk_status == 1){
    8b1c:	d15b      	bne.n	8bd6 <grid_nvm_ui_bulk_clear_next+0xca>
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8b1e:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8b20:	f8d4 242c 	ldr.w	r2, [r4, #1068]	; 0x42c
    8b24:	23a0      	movs	r3, #160	; 0xa0
    8b26:	fbb2 f3f3 	udiv	r3, r2, r3
    8b2a:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8b2e:	4299      	cmp	r1, r3
    8b30:	d91c      	bls.n	8b6c <grid_nvm_ui_bulk_clear_next+0x60>
			
			if (element < ui->bank_list[bank].element_list_length){
    8b32:	6845      	ldr	r5, [r0, #4]
    8b34:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8b38:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8b3a:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8b3c:	fbb2 f1f7 	udiv	r1, r2, r7
    8b40:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    8b44:	42b5      	cmp	r5, r6
    8b46:	d911      	bls.n	8b6c <grid_nvm_ui_bulk_clear_next+0x60>
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8b48:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8b4c:	68da      	ldr	r2, [r3, #12]
    8b4e:	2364      	movs	r3, #100	; 0x64
    8b50:	fb06 2303 	mla	r3, r6, r3, r2
    8b54:	b2ca      	uxtb	r2, r1
    8b56:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8b5a:	4295      	cmp	r5, r2
    8b5c:	d906      	bls.n	8b6c <grid_nvm_ui_bulk_clear_next+0x60>
					// Valid memory location
					
					grid_ui_nvm_clear_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);		
    8b5e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8b60:	22bc      	movs	r2, #188	; 0xbc
    8b62:	fb02 3201 	mla	r2, r2, r1, r3
    8b66:	4b3c      	ldr	r3, [pc, #240]	; (8c58 <grid_nvm_ui_bulk_clear_next+0x14c>)
    8b68:	4621      	mov	r1, r4
    8b6a:	4798      	blx	r3
	
		}
		
		
		
		if (nvm->clear_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8b6c:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8b70:	4e3a      	ldr	r6, [pc, #232]	; (8c5c <grid_nvm_ui_bulk_clear_next+0x150>)
    8b72:	f240 227e 	movw	r2, #638	; 0x27e
    8b76:	4293      	cmp	r3, r2
    8b78:	d830      	bhi.n	8bdc <grid_nvm_ui_bulk_clear_next+0xd0>
			
            
            uint8_t intensity = abs(nvm->clear_bulk_page_index%100 - 50)/1.5 + 40;
    8b7a:	2264      	movs	r2, #100	; 0x64
    8b7c:	fbb3 f0f2 	udiv	r0, r3, r2
    8b80:	fb02 3010 	mls	r0, r2, r0, r3
    8b84:	3832      	subs	r0, #50	; 0x32
    8b86:	2800      	cmp	r0, #0
    8b88:	bfb8      	it	lt
    8b8a:	4240      	neglt	r0, r0
    8b8c:	f8df 8118 	ldr.w	r8, [pc, #280]	; 8ca8 <grid_nvm_ui_bulk_clear_next+0x19c>
    8b90:	4d33      	ldr	r5, [pc, #204]	; (8c60 <grid_nvm_ui_bulk_clear_next+0x154>)
    8b92:	4f34      	ldr	r7, [pc, #208]	; (8c64 <grid_nvm_ui_bulk_clear_next+0x158>)
    8b94:	47c0      	blx	r8
    8b96:	4b34      	ldr	r3, [pc, #208]	; (8c68 <grid_nvm_ui_bulk_clear_next+0x15c>)
    8b98:	2200      	movs	r2, #0
    8b9a:	47a8      	blx	r5
    8b9c:	4b33      	ldr	r3, [pc, #204]	; (8c6c <grid_nvm_ui_bulk_clear_next+0x160>)
    8b9e:	4d34      	ldr	r5, [pc, #208]	; (8c70 <grid_nvm_ui_bulk_clear_next+0x164>)
    8ba0:	2200      	movs	r2, #0
    8ba2:	47a8      	blx	r5
    8ba4:	47b8      	blx	r7
    8ba6:	b2c5      	uxtb	r5, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, intensity, intensity*0.75, 0, 1, 1000);
    8ba8:	4628      	mov	r0, r5
    8baa:	47c0      	blx	r8
    8bac:	4b31      	ldr	r3, [pc, #196]	; (8c74 <grid_nvm_ui_bulk_clear_next+0x168>)
    8bae:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8cac <grid_nvm_ui_bulk_clear_next+0x1a0>
    8bb2:	2200      	movs	r2, #0
    8bb4:	47c0      	blx	r8
    8bb6:	47b8      	blx	r7
    8bb8:	2301      	movs	r3, #1
    8bba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8bbe:	e9cd 3200 	strd	r3, r2, [sp]
    8bc2:	4629      	mov	r1, r5
    8bc4:	2300      	movs	r3, #0
    8bc6:	b2c2      	uxtb	r2, r0
    8bc8:	482b      	ldr	r0, [pc, #172]	; (8c78 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8bca:	47b0      	blx	r6


            
            nvm->clear_bulk_page_index++;
    8bcc:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8bd0:	3301      	adds	r3, #1
    8bd2:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	}
	
	
	
	
}
    8bd6:	b06c      	add	sp, #432	; 0x1b0
    8bd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			nvm->clear_bulk_page_index = 0;
    8bdc:	2500      	movs	r5, #0
    8bde:	f8c4 542c 	str.w	r5, [r4, #1068]	; 0x42c
			nvm->clear_bulk_status = 0;
    8be2:	f884 5430 	strb.w	r5, [r4, #1072]	; 0x430
			grid_msg_init(&response);
    8be6:	a805      	add	r0, sp, #20
    8be8:	4b24      	ldr	r3, [pc, #144]	; (8c7c <grid_nvm_ui_bulk_clear_next+0x170>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8bea:	4c25      	ldr	r4, [pc, #148]	; (8c80 <grid_nvm_ui_bulk_clear_next+0x174>)
			grid_msg_init(&response);
    8bec:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8bee:	227f      	movs	r2, #127	; 0x7f
    8bf0:	462b      	mov	r3, r5
    8bf2:	4611      	mov	r1, r2
    8bf4:	a805      	add	r0, sp, #20
    8bf6:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8bf8:	2303      	movs	r3, #3
    8bfa:	4922      	ldr	r1, [pc, #136]	; (8c84 <grid_nvm_ui_bulk_clear_next+0x178>)
    8bfc:	9300      	str	r3, [sp, #0]
    8bfe:	2202      	movs	r2, #2
    8c00:	4c21      	ldr	r4, [pc, #132]	; (8c88 <grid_nvm_ui_bulk_clear_next+0x17c>)
			uint8_t response_payload[10] = {0};
    8c02:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8c06:	2372      	movs	r3, #114	; 0x72
    8c08:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8c0a:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8c0e:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8c10:	4b1e      	ldr	r3, [pc, #120]	; (8c8c <grid_nvm_ui_bulk_clear_next+0x180>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8c12:	4c1f      	ldr	r4, [pc, #124]	; (8c90 <grid_nvm_ui_bulk_clear_next+0x184>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8c14:	a802      	add	r0, sp, #8
    8c16:	4798      	blx	r3
    8c18:	a902      	add	r1, sp, #8
    8c1a:	4602      	mov	r2, r0
    8c1c:	4b1d      	ldr	r3, [pc, #116]	; (8c94 <grid_nvm_ui_bulk_clear_next+0x188>)
    8c1e:	a805      	add	r0, sp, #20
    8c20:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8c22:	230a      	movs	r3, #10
    8c24:	9300      	str	r3, [sp, #0]
    8c26:	4629      	mov	r1, r5
    8c28:	a805      	add	r0, sp, #20
    8c2a:	2301      	movs	r3, #1
    8c2c:	2204      	movs	r2, #4
    8c2e:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8c30:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8c34:	22ff      	movs	r2, #255	; 0xff
    8c36:	4629      	mov	r1, r5
    8c38:	e9cd 5300 	strd	r5, r3, [sp]
    8c3c:	480e      	ldr	r0, [pc, #56]	; (8c78 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8c3e:	462b      	mov	r3, r5
    8c40:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8c42:	4b15      	ldr	r3, [pc, #84]	; (8c98 <grid_nvm_ui_bulk_clear_next+0x18c>)
    8c44:	a805      	add	r0, sp, #20
    8c46:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8c48:	4b14      	ldr	r3, [pc, #80]	; (8c9c <grid_nvm_ui_bulk_clear_next+0x190>)
    8c4a:	a805      	add	r0, sp, #20
    8c4c:	4798      	blx	r3
            grid_ui_reinit_local(&grid_ui_state);
    8c4e:	4814      	ldr	r0, [pc, #80]	; (8ca0 <grid_nvm_ui_bulk_clear_next+0x194>)
    8c50:	4b14      	ldr	r3, [pc, #80]	; (8ca4 <grid_nvm_ui_bulk_clear_next+0x198>)
    8c52:	4798      	blx	r3
}
    8c54:	e7bf      	b.n	8bd6 <grid_nvm_ui_bulk_clear_next+0xca>
    8c56:	bf00      	nop
    8c58:	00009f0d 	.word	0x00009f0d
    8c5c:	00009813 	.word	0x00009813
    8c60:	00013dc9 	.word	0x00013dc9
    8c64:	00013f99 	.word	0x00013f99
    8c68:	3ff80000 	.word	0x3ff80000
    8c6c:	40440000 	.word	0x40440000
    8c70:	00013809 	.word	0x00013809
    8c74:	3fe80000 	.word	0x3fe80000
    8c78:	20007a24 	.word	0x20007a24
    8c7c:	000085c5 	.word	0x000085c5
    8c80:	000085f9 	.word	0x000085f9
    8c84:	00016a0f 	.word	0x00016a0f
    8c88:	000147d1 	.word	0x000147d1
    8c8c:	00014c81 	.word	0x00014c81
    8c90:	000085a9 	.word	0x000085a9
    8c94:	00008535 	.word	0x00008535
    8c98:	000086f1 	.word	0x000086f1
    8c9c:	000087c5 	.word	0x000087c5
    8ca0:	20007a18 	.word	0x20007a18
    8ca4:	0000a519 	.word	0x0000a519
    8ca8:	00013aa1 	.word	0x00013aa1
    8cac:	00013b75 	.word	0x00013b75

00008cb0 <grid_nvm_clear_read_buffer>:



void grid_nvm_clear_read_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cb0:	f100 0309 	add.w	r3, r0, #9
    8cb4:	f200 2209 	addw	r2, r0, #521	; 0x209
		
		mod->read_buffer[i] = 255;
    8cb8:	21ff      	movs	r1, #255	; 0xff
    8cba:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cbe:	4293      	cmp	r3, r2
    8cc0:	d1fb      	bne.n	8cba <grid_nvm_clear_read_buffer+0xa>
		
	}

	mod->read_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    8cc2:	2302      	movs	r3, #2
    8cc4:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	mod->read_buffer_length = 0;
    8cc8:	2300      	movs	r3, #0
    8cca:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
	
}
    8cce:	4770      	bx	lr

00008cd0 <grid_nvm_clear_write_buffer>:

void grid_nvm_clear_write_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cd0:	f500 7306 	add.w	r3, r0, #536	; 0x218
    8cd4:	f500 6283 	add.w	r2, r0, #1048	; 0x418
		
		mod->write_buffer[i] = 255;
    8cd8:	21ff      	movs	r1, #255	; 0xff
    8cda:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    8cde:	4293      	cmp	r3, r2
    8ce0:	d1fb      	bne.n	8cda <grid_nvm_clear_write_buffer+0xa>
		
	}
	
	mod->write_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    8ce2:	2302      	movs	r3, #2
    8ce4:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	mod->write_buffer_length = 0;
    8ce8:	2300      	movs	r3, #0
    8cea:	f8c0 3418 	str.w	r3, [r0, #1048]	; 0x418
	mod->write_target_address = -1;
    8cee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    8cf2:	f8c0 3420 	str.w	r3, [r0, #1056]	; 0x420
}
    8cf6:	4770      	bx	lr

00008cf8 <grid_nvm_init>:
void grid_nvm_init(struct grid_nvm_model* nvm, struct flash_descriptor* flash_instance){
    8cf8:	b510      	push	{r4, lr}
	nvm->bank_settings_page_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8cfa:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
	nvm->flash = flash_instance;
    8cfe:	e9c0 1300 	strd	r1, r3, [r0]
	nvm->status = 1;
    8d02:	2301      	movs	r3, #1
    8d04:	7203      	strb	r3, [r0, #8]
	nvm->read_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    8d06:	2300      	movs	r3, #0
    8d08:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	nvm->write_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    8d0c:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	nvm->read_bulk_page_index = 0;
    8d10:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 0;
    8d14:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
	nvm->clear_bulk_page_index = 0;
    8d18:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 0;	
    8d1c:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	nvm->write_bulk_page_index = 0;
    8d20:	f8c0 343c 	str.w	r3, [r0, #1084]	; 0x43c
	nvm->write_bulk_status = 0;
    8d24:	f880 3440 	strb.w	r3, [r0, #1088]	; 0x440
	grid_nvm_clear_read_buffer(nvm);
    8d28:	4b02      	ldr	r3, [pc, #8]	; (8d34 <grid_nvm_init+0x3c>)
    8d2a:	4798      	blx	r3
}
    8d2c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_nvm_clear_write_buffer(nvm);
    8d30:	4b01      	ldr	r3, [pc, #4]	; (8d38 <grid_nvm_init+0x40>)
    8d32:	4718      	bx	r3
    8d34:	00008cb1 	.word	0x00008cb1
    8d38:	00008cd1 	.word	0x00008cd1

00008d3c <grid_nvm_calculate_event_page_offset>:


uint32_t grid_nvm_calculate_event_page_offset(struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    8d3c:	b510      	push	{r4, lr}
	
	
	
	uint8_t bank_number		= eve->parent->parent->index;
    8d3e:	684a      	ldr	r2, [r1, #4]
    8d40:	6853      	ldr	r3, [r2, #4]
	uint8_t element_number	= eve->parent->index;
	uint8_t event_number	= eve->index;

	return GRID_NVM_STRATEGY_BANK_size * bank_number + GRID_NVM_STRATEGY_ELEMENT_size * element_number + GRID_NVM_STRATEGY_EVENT_size * event_number;
    8d42:	7a1c      	ldrb	r4, [r3, #8]
    8d44:	7a13      	ldrb	r3, [r2, #8]
    8d46:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    8d4a:	20a0      	movs	r0, #160	; 0xa0
    8d4c:	005b      	lsls	r3, r3, #1
    8d4e:	fb10 3304 	smlabb	r3, r0, r4, r3
    8d52:	7a08      	ldrb	r0, [r1, #8]
	
    8d54:	4418      	add	r0, r3
    8d56:	bd10      	pop	{r4, pc}

00008d58 <_gpio_set_pin_pull_mode.constprop.0>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    8d58:	01c0      	lsls	r0, r0, #7
    8d5a:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    8d5e:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
		break;

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    8d62:	2301      	movs	r3, #1
    8d64:	408b      	lsls	r3, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    8d66:	4401      	add	r1, r0
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    8d68:	6043      	str	r3, [r0, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    8d6a:	f891 2040 	ldrb.w	r2, [r1, #64]	; 0x40
    8d6e:	f042 0204 	orr.w	r2, r2, #4
    8d72:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8d76:	6183      	str	r3, [r0, #24]

	default:
		ASSERT(false);
		break;
	}
}
    8d78:	4770      	bx	lr

00008d7a <grid_task_enter_task>:
 * Author : SUKU WC
*/

#include "grid_sys.h"

enum grid_task grid_task_enter_task(struct grid_task_model* mod, enum grid_task next_task){
    8d7a:	4603      	mov	r3, r0
	
	
	enum grid_task previous_task = mod->current_task;
    8d7c:	7840      	ldrb	r0, [r0, #1]
	mod->current_task = next_task;
    8d7e:	7059      	strb	r1, [r3, #1]
	return previous_task;
	
}
    8d80:	4770      	bx	lr

00008d82 <grid_task_timer_tick>:
	
}

void grid_task_timer_tick(struct grid_task_model* mod){
	
	mod->timer[mod->current_task]++;
    8d82:	7843      	ldrb	r3, [r0, #1]
    8d84:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    8d88:	6843      	ldr	r3, [r0, #4]
    8d8a:	3301      	adds	r3, #1
    8d8c:	6043      	str	r3, [r0, #4]
	
}
    8d8e:	4770      	bx	lr

00008d90 <grid_sys_nvm_store_configuration>:
}




void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8d90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8d94:	f2ad 4dec 	subw	sp, sp, #1260	; 0x4ec

	struct grid_msg message;
	
	grid_msg_init(&message);
    8d98:	4b6a      	ldr	r3, [pc, #424]	; (8f44 <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8d9a:	4c6b      	ldr	r4, [pc, #428]	; (8f48 <grid_sys_nvm_store_configuration+0x1b8>)
	for(uint8_t i=0; i<4; i++){
		
		// BANK ENABLED	
		offset = grid_msg_body_get_length(&message);
			
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8d9c:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 8f70 <grid_sys_nvm_store_configuration+0x1e0>
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8da0:	4606      	mov	r6, r0
	grid_msg_init(&message);
    8da2:	a86c      	add	r0, sp, #432	; 0x1b0
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    8da4:	460f      	mov	r7, r1
	grid_msg_init(&message);
    8da6:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8da8:	22ff      	movs	r2, #255	; 0xff
    8daa:	4611      	mov	r1, r2
    8dac:	2300      	movs	r3, #0
    8dae:	a86c      	add	r0, sp, #432	; 0x1b0
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8db0:	2500      	movs	r5, #0
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8db2:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8db4:	4b65      	ldr	r3, [pc, #404]	; (8f4c <grid_sys_nvm_store_configuration+0x1bc>)
    8db6:	9508      	str	r5, [sp, #32]
    8db8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    8dbc:	4629      	mov	r1, r5
    8dbe:	a809      	add	r0, sp, #36	; 0x24
    8dc0:	4798      	blx	r3
	for(uint8_t i=0; i<4; i++){
    8dc2:	3613      	adds	r6, #19
		offset = grid_msg_body_get_length(&message);
    8dc4:	4b62      	ldr	r3, [pc, #392]	; (8f50 <grid_sys_nvm_store_configuration+0x1c0>)
		payload_length = strlen(payload);
    8dc6:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 8f7c <grid_sys_nvm_store_configuration+0x1ec>
			
		grid_msg_body_append_text(&message, payload, payload_length);
    8dca:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 8f80 <grid_sys_nvm_store_configuration+0x1f0>
			
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8dce:	4c61      	ldr	r4, [pc, #388]	; (8f54 <grid_sys_nvm_store_configuration+0x1c4>)
		offset = grid_msg_body_get_length(&message);
    8dd0:	a86c      	add	r0, sp, #432	; 0x1b0
    8dd2:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8dd4:	2203      	movs	r2, #3
		offset = grid_msg_body_get_length(&message);
    8dd6:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8dd8:	2331      	movs	r3, #49	; 0x31
    8dda:	495f      	ldr	r1, [pc, #380]	; (8f58 <grid_sys_nvm_store_configuration+0x1c8>)
    8ddc:	9200      	str	r2, [sp, #0]
    8dde:	a808      	add	r0, sp, #32
    8de0:	2202      	movs	r2, #2
    8de2:	47d0      	blx	sl
		payload_length = strlen(payload);
    8de4:	a808      	add	r0, sp, #32
    8de6:	47d8      	blx	fp
		grid_msg_body_append_text(&message, payload, payload_length);
    8de8:	a908      	add	r1, sp, #32
    8dea:	b2c2      	uxtb	r2, r0
    8dec:	a86c      	add	r0, sp, #432	; 0x1b0
    8dee:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8df0:	220e      	movs	r2, #14
    8df2:	4641      	mov	r1, r8
    8df4:	9200      	str	r2, [sp, #0]
    8df6:	2301      	movs	r3, #1
    8df8:	2204      	movs	r2, #4
    8dfa:	a86c      	add	r0, sp, #432	; 0x1b0
    8dfc:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    8dfe:	4641      	mov	r1, r8
    8e00:	9500      	str	r5, [sp, #0]
    8e02:	2302      	movs	r3, #2
    8e04:	2205      	movs	r2, #5
    8e06:	a86c      	add	r0, sp, #432	; 0x1b0
    8e08:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);		
    8e0a:	f816 3b01 	ldrb.w	r3, [r6], #1
    8e0e:	9300      	str	r3, [sp, #0]
    8e10:	4641      	mov	r1, r8
    8e12:	2207      	movs	r2, #7
    8e14:	2302      	movs	r3, #2
    8e16:	a86c      	add	r0, sp, #432	; 0x1b0
    8e18:	47a0      	blx	r4
			
		// BANK COLOR	
		offset = grid_msg_body_get_length(&message);
    8e1a:	4b4d      	ldr	r3, [pc, #308]	; (8f50 <grid_sys_nvm_store_configuration+0x1c0>)
    8e1c:	a86c      	add	r0, sp, #432	; 0x1b0
    8e1e:	4798      	blx	r3
		
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8e20:	2303      	movs	r3, #3
		offset = grid_msg_body_get_length(&message);
    8e22:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    8e24:	494d      	ldr	r1, [pc, #308]	; (8f5c <grid_sys_nvm_store_configuration+0x1cc>)
    8e26:	9300      	str	r3, [sp, #0]
    8e28:	2202      	movs	r2, #2
    8e2a:	2332      	movs	r3, #50	; 0x32
    8e2c:	a808      	add	r0, sp, #32
    8e2e:	47d0      	blx	sl
		payload_length = strlen(payload);
    8e30:	a808      	add	r0, sp, #32
    8e32:	47d8      	blx	fp
		
		grid_msg_body_append_text(&message, payload, payload_length);
    8e34:	a908      	add	r1, sp, #32
    8e36:	b2c2      	uxtb	r2, r0
    8e38:	a86c      	add	r0, sp, #432	; 0x1b0
    8e3a:	47c8      	blx	r9

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    8e3c:	230e      	movs	r3, #14
    8e3e:	4641      	mov	r1, r8
    8e40:	9300      	str	r3, [sp, #0]
    8e42:	2204      	movs	r2, #4
    8e44:	2301      	movs	r3, #1
    8e46:	a86c      	add	r0, sp, #432	; 0x1b0
    8e48:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    8e4a:	4641      	mov	r1, r8
    8e4c:	9500      	str	r5, [sp, #0]
    8e4e:	2302      	movs	r3, #2
    8e50:	2205      	movs	r2, #5
    8e52:	a86c      	add	r0, sp, #432	; 0x1b0
    8e54:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    8e56:	78f3      	ldrb	r3, [r6, #3]
    8e58:	9300      	str	r3, [sp, #0]
    8e5a:	4641      	mov	r1, r8
    8e5c:	2302      	movs	r3, #2
    8e5e:	2207      	movs	r2, #7
    8e60:	a86c      	add	r0, sp, #432	; 0x1b0
    8e62:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    8e64:	79f3      	ldrb	r3, [r6, #7]
    8e66:	9300      	str	r3, [sp, #0]
    8e68:	4641      	mov	r1, r8
    8e6a:	2302      	movs	r3, #2
    8e6c:	2209      	movs	r2, #9
    8e6e:	a86c      	add	r0, sp, #432	; 0x1b0
    8e70:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    8e72:	7af3      	ldrb	r3, [r6, #11]
    8e74:	9300      	str	r3, [sp, #0]
    8e76:	4641      	mov	r1, r8
    8e78:	2302      	movs	r3, #2
    8e7a:	220b      	movs	r2, #11
    8e7c:	a86c      	add	r0, sp, #432	; 0x1b0
    8e7e:	3501      	adds	r5, #1
    8e80:	47a0      	blx	r4
	for(uint8_t i=0; i<4; i++){
    8e82:	2d04      	cmp	r5, #4
    8e84:	46d8      	mov	r8, fp
    8e86:	d19d      	bne.n	8dc4 <grid_sys_nvm_store_configuration+0x34>
		
		
	}
	
	grid_msg_packet_close(&message);
    8e88:	4e35      	ldr	r6, [pc, #212]	; (8f60 <grid_sys_nvm_store_configuration+0x1d0>)

	grid_nvm_clear_write_buffer(nvm);
	
	uint8_t acknowledge = 0;
	
	if (grid_msg_packet_get_length(&message)){
    8e8a:	4d36      	ldr	r5, [pc, #216]	; (8f64 <grid_sys_nvm_store_configuration+0x1d4>)
	grid_msg_packet_close(&message);
    8e8c:	a86c      	add	r0, sp, #432	; 0x1b0
    8e8e:	47b0      	blx	r6
	grid_nvm_clear_write_buffer(nvm);
    8e90:	4b35      	ldr	r3, [pc, #212]	; (8f68 <grid_sys_nvm_store_configuration+0x1d8>)
    8e92:	4638      	mov	r0, r7
    8e94:	4798      	blx	r3
	if (grid_msg_packet_get_length(&message)){
    8e96:	a86c      	add	r0, sp, #432	; 0x1b0
    8e98:	47a8      	blx	r5
    8e9a:	9602      	str	r6, [sp, #8]
    8e9c:	2800      	cmp	r0, #0
    8e9e:	d04c      	beq.n	8f3a <grid_sys_nvm_store_configuration+0x1aa>

		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    8ea0:	a86c      	add	r0, sp, #432	; 0x1b0
    8ea2:	47a8      	blx	r5
    8ea4:	f507 7a06 	add.w	sl, r7, #536	; 0x218
		
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
			
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8ea8:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 8f84 <grid_sys_nvm_store_configuration+0x1f4>
		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    8eac:	f8c7 0418 	str.w	r0, [r7, #1048]	; 0x418
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8eb0:	2500      	movs	r5, #0
    8eb2:	4652      	mov	r2, sl
    8eb4:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
    8eb8:	42ab      	cmp	r3, r5
    8eba:	d835      	bhi.n	8f28 <grid_sys_nvm_store_configuration+0x198>
		}
		
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8ebc:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    8ec0:	4d2a      	ldr	r5, [pc, #168]	; (8f6c <grid_sys_nvm_store_configuration+0x1dc>)
    8ec2:	6838      	ldr	r0, [r7, #0]
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    8ec4:	f8c7 1420 	str.w	r1, [r7, #1056]	; 0x420
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    8ec8:	47a8      	blx	r5
		
		acknowledge = 1;
    8eca:	2501      	movs	r5, #1

	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    8ecc:	4b1d      	ldr	r3, [pc, #116]	; (8f44 <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8ece:	4f1e      	ldr	r7, [pc, #120]	; (8f48 <grid_sys_nvm_store_configuration+0x1b8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ed0:	4e27      	ldr	r6, [pc, #156]	; (8f70 <grid_sys_nvm_store_configuration+0x1e0>)
	grid_msg_init(&response);
    8ed2:	a8d3      	add	r0, sp, #844	; 0x34c
    8ed4:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8ed6:	227f      	movs	r2, #127	; 0x7f
    8ed8:	4611      	mov	r1, r2
    8eda:	2300      	movs	r3, #0
    8edc:	a8d3      	add	r0, sp, #844	; 0x34c
    8ede:	47b8      	blx	r7
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ee0:	2303      	movs	r3, #3
    8ee2:	4924      	ldr	r1, [pc, #144]	; (8f74 <grid_sys_nvm_store_configuration+0x1e4>)
    8ee4:	9300      	str	r3, [sp, #0]
    8ee6:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    8ee8:	2700      	movs	r7, #0
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8eea:	2360      	movs	r3, #96	; 0x60
    8eec:	a805      	add	r0, sp, #20
	uint8_t response_payload[10] = {0};
    8eee:	e9cd 7705 	strd	r7, r7, [sp, #20]
    8ef2:	f8ad 701c 	strh.w	r7, [sp, #28]
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    8ef6:	47b0      	blx	r6

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8ef8:	a805      	add	r0, sp, #20
    8efa:	47c0      	blx	r8
    8efc:	a905      	add	r1, sp, #20
    8efe:	4602      	mov	r2, r0
    8f00:	a8d3      	add	r0, sp, #844	; 0x34c
    8f02:	47c8      	blx	r9
	
	if (acknowledge == 1){
    8f04:	b1dd      	cbz	r5, 8f3e <grid_sys_nvm_store_configuration+0x1ae>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);	
    8f06:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    8f08:	2204      	movs	r2, #4
    8f0a:	4639      	mov	r1, r7
    8f0c:	9300      	str	r3, [sp, #0]
    8f0e:	a8d3      	add	r0, sp, #844	; 0x34c
    8f10:	2301      	movs	r3, #1
    8f12:	47a0      	blx	r4
	}

	
	grid_msg_packet_close(&response);
    8f14:	9b02      	ldr	r3, [sp, #8]
    8f16:	a8d3      	add	r0, sp, #844	; 0x34c
    8f18:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    8f1a:	4b17      	ldr	r3, [pc, #92]	; (8f78 <grid_sys_nvm_store_configuration+0x1e8>)
    8f1c:	a8d3      	add	r0, sp, #844	; 0x34c
    8f1e:	4798      	blx	r3
		
	
}
    8f20:	f20d 4dec 	addw	sp, sp, #1260	; 0x4ec
    8f24:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8f28:	4629      	mov	r1, r5
    8f2a:	a86c      	add	r0, sp, #432	; 0x1b0
    8f2c:	9203      	str	r2, [sp, #12]
    8f2e:	47d8      	blx	fp
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8f30:	3501      	adds	r5, #1
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    8f32:	f80a 0b01 	strb.w	r0, [sl], #1
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    8f36:	9a03      	ldr	r2, [sp, #12]
    8f38:	e7bc      	b.n	8eb4 <grid_sys_nvm_store_configuration+0x124>
	uint8_t acknowledge = 0;
    8f3a:	4605      	mov	r5, r0
    8f3c:	e7c6      	b.n	8ecc <grid_sys_nvm_store_configuration+0x13c>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    8f3e:	230b      	movs	r3, #11
    8f40:	e7e2      	b.n	8f08 <grid_sys_nvm_store_configuration+0x178>
    8f42:	bf00      	nop
    8f44:	000085c5 	.word	0x000085c5
    8f48:	000085f9 	.word	0x000085f9
    8f4c:	00014175 	.word	0x00014175
    8f50:	0000852f 	.word	0x0000852f
    8f54:	000085a9 	.word	0x000085a9
    8f58:	00016a19 	.word	0x00016a19
    8f5c:	00016752 	.word	0x00016752
    8f60:	000086f1 	.word	0x000086f1
    8f64:	00008521 	.word	0x00008521
    8f68:	00008cd1 	.word	0x00008cd1
    8f6c:	0000ece9 	.word	0x0000ece9
    8f70:	000147d1 	.word	0x000147d1
    8f74:	00016a0f 	.word	0x00016a0f
    8f78:	000087c5 	.word	0x000087c5
    8f7c:	00014c81 	.word	0x00014c81
    8f80:	00008535 	.word	0x00008535
    8f84:	000086bb 	.word	0x000086bb

00008f88 <grid_sys_recall_configuration>:


void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8f8c:	f5ad 7d51 	sub.w	sp, sp, #836	; 0x344

	struct grid_msg message;
	
	grid_msg_init(&message);
    8f90:	4b48      	ldr	r3, [pc, #288]	; (90b4 <grid_sys_recall_configuration+0x12c>)
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f92:	4c49      	ldr	r4, [pc, #292]	; (90b8 <grid_sys_recall_configuration+0x130>)
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f94:	4605      	mov	r5, r0
	grid_msg_init(&message);
    8f96:	a869      	add	r0, sp, #420	; 0x1a4
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    8f98:	468a      	mov	sl, r1
	grid_msg_init(&message);
    8f9a:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f9c:	227f      	movs	r2, #127	; 0x7f
    8f9e:	4611      	mov	r1, r2
    8fa0:	2300      	movs	r3, #0
    8fa2:	a869      	add	r0, sp, #420	; 0x1a4
    8fa4:	47a0      	blx	r4


	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8fa6:	2400      	movs	r4, #0
    8fa8:	4b44      	ldr	r3, [pc, #272]	; (90bc <grid_sys_recall_configuration+0x134>)
    8faa:	9405      	str	r4, [sp, #20]
    8fac:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    8fb0:	4621      	mov	r1, r4
    8fb2:	a806      	add	r0, sp, #24
    8fb4:	4798      	blx	r3
	uint8_t payload_length = 0;
	uint32_t offset = 0;
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    8fb6:	3513      	adds	r5, #19
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    8fb8:	9403      	str	r4, [sp, #12]
		
		if (bank > GRID_SYS_BANK_MAXNUMBER || bank == i){
    8fba:	f1ba 0f04 	cmp.w	sl, #4
    8fbe:	d803      	bhi.n	8fc8 <grid_sys_recall_configuration+0x40>
    8fc0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    8fc4:	459a      	cmp	sl, r3
    8fc6:	d164      	bne.n	9092 <grid_sys_recall_configuration+0x10a>
			
			// BANK ENABLED
			offset = grid_msg_body_get_length(&message);
    8fc8:	4b3d      	ldr	r3, [pc, #244]	; (90c0 <grid_sys_recall_configuration+0x138>)
		
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fca:	4e3e      	ldr	r6, [pc, #248]	; (90c4 <grid_sys_recall_configuration+0x13c>)
			payload_length = strlen(payload);
		
			grid_msg_body_append_text(&message, payload, payload_length);
    8fcc:	f8df 9110 	ldr.w	r9, [pc, #272]	; 90e0 <grid_sys_recall_configuration+0x158>
			offset = grid_msg_body_get_length(&message);
    8fd0:	a869      	add	r0, sp, #420	; 0x1a4
    8fd2:	4798      	blx	r3
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fd4:	f04f 0b03 	mov.w	fp, #3
			offset = grid_msg_body_get_length(&message);
    8fd8:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8fda:	2331      	movs	r3, #49	; 0x31
    8fdc:	493a      	ldr	r1, [pc, #232]	; (90c8 <grid_sys_recall_configuration+0x140>)
    8fde:	f8cd b000 	str.w	fp, [sp]
    8fe2:	2202      	movs	r2, #2
    8fe4:	a805      	add	r0, sp, #20
    8fe6:	47b0      	blx	r6
			payload_length = strlen(payload);
    8fe8:	4a38      	ldr	r2, [pc, #224]	; (90cc <grid_sys_recall_configuration+0x144>)
    8fea:	a805      	add	r0, sp, #20
    8fec:	4790      	blx	r2
		
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    8fee:	f04f 080d 	mov.w	r8, #13
			grid_msg_body_append_text(&message, payload, payload_length);
    8ff2:	b2c2      	uxtb	r2, r0
    8ff4:	a905      	add	r1, sp, #20
    8ff6:	a869      	add	r0, sp, #420	; 0x1a4
    8ff8:	47c8      	blx	r9
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    8ffa:	4634      	mov	r4, r6
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    8ffc:	4639      	mov	r1, r7
    8ffe:	4e34      	ldr	r6, [pc, #208]	; (90d0 <grid_sys_recall_configuration+0x148>)
    9000:	f8cd 8000 	str.w	r8, [sp]
    9004:	2301      	movs	r3, #1
    9006:	2204      	movs	r2, #4
    9008:	a869      	add	r0, sp, #420	; 0x1a4
    900a:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    900c:	9b03      	ldr	r3, [sp, #12]
    900e:	9300      	str	r3, [sp, #0]
    9010:	4639      	mov	r1, r7
    9012:	2302      	movs	r3, #2
    9014:	2205      	movs	r2, #5
    9016:	a869      	add	r0, sp, #420	; 0x1a4
    9018:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);
    901a:	782b      	ldrb	r3, [r5, #0]
    901c:	9300      	str	r3, [sp, #0]
    901e:	4639      	mov	r1, r7
    9020:	2207      	movs	r2, #7
    9022:	2302      	movs	r3, #2
    9024:	a869      	add	r0, sp, #420	; 0x1a4
    9026:	47b0      	blx	r6
		
			// BANK COLOR
			offset = grid_msg_body_get_length(&message);
    9028:	4b25      	ldr	r3, [pc, #148]	; (90c0 <grid_sys_recall_configuration+0x138>)
    902a:	a869      	add	r0, sp, #420	; 0x1a4
    902c:	4798      	blx	r3
		
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    902e:	2332      	movs	r3, #50	; 0x32
			offset = grid_msg_body_get_length(&message);
    9030:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    9032:	4928      	ldr	r1, [pc, #160]	; (90d4 <grid_sys_recall_configuration+0x14c>)
    9034:	f8cd b000 	str.w	fp, [sp]
    9038:	2202      	movs	r2, #2
    903a:	a805      	add	r0, sp, #20
    903c:	47a0      	blx	r4
			payload_length = strlen(payload);
    903e:	4a23      	ldr	r2, [pc, #140]	; (90cc <grid_sys_recall_configuration+0x144>)
    9040:	a805      	add	r0, sp, #20
    9042:	4790      	blx	r2
		
			grid_msg_body_append_text(&message, payload, payload_length);
    9044:	a905      	add	r1, sp, #20
    9046:	b2c2      	uxtb	r2, r0
    9048:	a869      	add	r0, sp, #420	; 0x1a4
    904a:	47c8      	blx	r9

			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    904c:	2301      	movs	r3, #1
    904e:	2204      	movs	r2, #4
    9050:	4639      	mov	r1, r7
    9052:	a869      	add	r0, sp, #420	; 0x1a4
    9054:	f8cd 8000 	str.w	r8, [sp]
    9058:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    905a:	9b03      	ldr	r3, [sp, #12]
    905c:	9300      	str	r3, [sp, #0]
    905e:	2205      	movs	r2, #5
    9060:	2302      	movs	r3, #2
    9062:	4639      	mov	r1, r7
    9064:	a869      	add	r0, sp, #420	; 0x1a4
    9066:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    9068:	792b      	ldrb	r3, [r5, #4]
    906a:	9300      	str	r3, [sp, #0]
    906c:	2207      	movs	r2, #7
    906e:	2302      	movs	r3, #2
    9070:	4639      	mov	r1, r7
    9072:	a869      	add	r0, sp, #420	; 0x1a4
    9074:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    9076:	7a2b      	ldrb	r3, [r5, #8]
    9078:	9300      	str	r3, [sp, #0]
    907a:	2209      	movs	r2, #9
    907c:	2302      	movs	r3, #2
    907e:	4639      	mov	r1, r7
    9080:	a869      	add	r0, sp, #420	; 0x1a4
    9082:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    9084:	7b2b      	ldrb	r3, [r5, #12]
    9086:	9300      	str	r3, [sp, #0]
    9088:	220b      	movs	r2, #11
    908a:	2302      	movs	r3, #2
    908c:	4639      	mov	r1, r7
    908e:	a869      	add	r0, sp, #420	; 0x1a4
    9090:	47b0      	blx	r6
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9092:	9b03      	ldr	r3, [sp, #12]
    9094:	3301      	adds	r3, #1
    9096:	2b04      	cmp	r3, #4
    9098:	9303      	str	r3, [sp, #12]
    909a:	f105 0501 	add.w	r5, r5, #1
    909e:	d18c      	bne.n	8fba <grid_sys_recall_configuration+0x32>
		}

		
	}
	
	grid_msg_packet_close(&message);
    90a0:	4b0d      	ldr	r3, [pc, #52]	; (90d8 <grid_sys_recall_configuration+0x150>)
    90a2:	a869      	add	r0, sp, #420	; 0x1a4
    90a4:	4798      	blx	r3

	grid_msg_packet_send_everywhere(&message);
    90a6:	4b0d      	ldr	r3, [pc, #52]	; (90dc <grid_sys_recall_configuration+0x154>)
    90a8:	a869      	add	r0, sp, #420	; 0x1a4
    90aa:	4798      	blx	r3
// 	
// 	grid_msg_packet_close(&response);
// 	grid_msg_packet_send_everywhere(&response);
	
	
}
    90ac:	f50d 7d51 	add.w	sp, sp, #836	; 0x344
    90b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    90b4:	000085c5 	.word	0x000085c5
    90b8:	000085f9 	.word	0x000085f9
    90bc:	00014175 	.word	0x00014175
    90c0:	0000852f 	.word	0x0000852f
    90c4:	000147d1 	.word	0x000147d1
    90c8:	00016a19 	.word	0x00016a19
    90cc:	00014c81 	.word	0x00014c81
    90d0:	000085a9 	.word	0x000085a9
    90d4:	00016752 	.word	0x00016752
    90d8:	000086f1 	.word	0x000086f1
    90dc:	000087c5 	.word	0x000087c5
    90e0:	00008535 	.word	0x00008535

000090e4 <grid_sys_nvm_load_configuration>:


void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    90e4:	b5f0      	push	{r4, r5, r6, r7, lr}
    90e6:	f5ad 7d6d 	sub.w	sp, sp, #948	; 0x3b4
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    90ea:	2400      	movs	r4, #0
void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    90ec:	460e      	mov	r6, r1
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    90ee:	4b2f      	ldr	r3, [pc, #188]	; (91ac <grid_sys_nvm_load_configuration+0xc8>)
    90f0:	946c      	str	r4, [sp, #432]	; 0x1b0
    90f2:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
    90f6:	4621      	mov	r1, r4
    90f8:	a86d      	add	r0, sp, #436	; 0x1b4
    90fa:	4798      	blx	r3
    90fc:	ad6c      	add	r5, sp, #432	; 0x1b0
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    90fe:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
    9102:	f8c6 1214 	str.w	r1, [r6, #532]	; 0x214
	
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    9106:	6830      	ldr	r0, [r6, #0]
    9108:	4e29      	ldr	r6, [pc, #164]	; (91b0 <grid_sys_nvm_load_configuration+0xcc>)
    910a:	f44f 7300 	mov.w	r3, #512	; 0x200
    910e:	462a      	mov	r2, r5
    9110:	47b0      	blx	r6
			}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9112:	4a28      	ldr	r2, [pc, #160]	; (91b4 <grid_sys_nvm_load_configuration+0xd0>)
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    9114:	4621      	mov	r1, r4
	uint8_t acknowledge = 0;	
    9116:	4626      	mov	r6, r4
	uint8_t copydone = 0;
    9118:	4623      	mov	r3, r4
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    911a:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    911e:	1c4c      	adds	r4, r1, #1
    9120:	b943      	cbnz	r3, 9134 <grid_sys_nvm_load_configuration+0x50>
			if (temp[i] == '\n'){ // END OF PACKET, copy newline character
    9122:	5c68      	ldrb	r0, [r5, r1]
    9124:	280a      	cmp	r0, #10
    9126:	d139      	bne.n	919c <grid_sys_nvm_load_configuration+0xb8>
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9128:	4411      	add	r1, r2
    912a:	55c8      	strb	r0, [r1, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    912c:	6214      	str	r4, [r2, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    912e:	6293      	str	r3, [r2, #40]	; 0x28
				acknowledge = 1;
    9130:	2301      	movs	r3, #1
				copydone = 1;
    9132:	461e      	mov	r6, r3
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){		
    9134:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    9138:	4621      	mov	r1, r4
    913a:	d1f0      	bne.n	911e <grid_sys_nvm_load_configuration+0x3a>
	
	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    913c:	4b1e      	ldr	r3, [pc, #120]	; (91b8 <grid_sys_nvm_load_configuration+0xd4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    913e:	4c1f      	ldr	r4, [pc, #124]	; (91bc <grid_sys_nvm_load_configuration+0xd8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9140:	4d1f      	ldr	r5, [pc, #124]	; (91c0 <grid_sys_nvm_load_configuration+0xdc>)
	grid_msg_init(&response);
    9142:	a805      	add	r0, sp, #20
    9144:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9146:	227f      	movs	r2, #127	; 0x7f
    9148:	4611      	mov	r1, r2
    914a:	2300      	movs	r3, #0
    914c:	a805      	add	r0, sp, #20
    914e:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9150:	2303      	movs	r3, #3
    9152:	491c      	ldr	r1, [pc, #112]	; (91c4 <grid_sys_nvm_load_configuration+0xe0>)
    9154:	9300      	str	r3, [sp, #0]
    9156:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    9158:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    915a:	2361      	movs	r3, #97	; 0x61
    915c:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    915e:	e9cd 4402 	strd	r4, r4, [sp, #8]
    9162:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9166:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9168:	4b17      	ldr	r3, [pc, #92]	; (91c8 <grid_sys_nvm_load_configuration+0xe4>)
    916a:	4d18      	ldr	r5, [pc, #96]	; (91cc <grid_sys_nvm_load_configuration+0xe8>)
    916c:	a802      	add	r0, sp, #8
    916e:	4798      	blx	r3
    9170:	4b17      	ldr	r3, [pc, #92]	; (91d0 <grid_sys_nvm_load_configuration+0xec>)
    9172:	4602      	mov	r2, r0
    9174:	a902      	add	r1, sp, #8
    9176:	a805      	add	r0, sp, #20
    9178:	4798      	blx	r3
	
	if (acknowledge == 1){
    917a:	b1ae      	cbz	r6, 91a8 <grid_sys_nvm_load_configuration+0xc4>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    917c:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    917e:	2204      	movs	r2, #4
    9180:	4621      	mov	r1, r4
    9182:	9300      	str	r3, [sp, #0]
    9184:	a805      	add	r0, sp, #20
    9186:	2301      	movs	r3, #1
    9188:	47a8      	blx	r5
	}

	
	grid_msg_packet_close(&response);
    918a:	4b12      	ldr	r3, [pc, #72]	; (91d4 <grid_sys_nvm_load_configuration+0xf0>)
    918c:	a805      	add	r0, sp, #20
    918e:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9190:	4b11      	ldr	r3, [pc, #68]	; (91d8 <grid_sys_nvm_load_configuration+0xf4>)
    9192:	a805      	add	r0, sp, #20
    9194:	4798      	blx	r3
	
}
    9196:	f50d 7d6d 	add.w	sp, sp, #948	; 0x3b4
    919a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    919c:	28ff      	cmp	r0, #255	; 0xff
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    919e:	bf16      	itet	ne
    91a0:	1889      	addne	r1, r1, r2
				copydone = 1;
    91a2:	2301      	moveq	r3, #1
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    91a4:	55c8      	strbne	r0, [r1, r7]
    91a6:	e7c5      	b.n	9134 <grid_sys_nvm_load_configuration+0x50>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    91a8:	230b      	movs	r3, #11
    91aa:	e7e8      	b.n	917e <grid_sys_nvm_load_configuration+0x9a>
    91ac:	00014175 	.word	0x00014175
    91b0:	0000ec7d 	.word	0x0000ec7d
    91b4:	20004acc 	.word	0x20004acc
    91b8:	000085c5 	.word	0x000085c5
    91bc:	000085f9 	.word	0x000085f9
    91c0:	000147d1 	.word	0x000147d1
    91c4:	00016a0f 	.word	0x00016a0f
    91c8:	00014c81 	.word	0x00014c81
    91cc:	000085a9 	.word	0x000085a9
    91d0:	00008535 	.word	0x00008535
    91d4:	000086f1 	.word	0x000086f1
    91d8:	000087c5 	.word	0x000087c5

000091dc <grid_sys_nvm_clear_configuration>:

void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    91dc:	b530      	push	{r4, r5, lr}
    91de:	460b      	mov	r3, r1
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    91e0:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    91e4:	b0ed      	sub	sp, #436	; 0x1b4
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    91e6:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    91ea:	2201      	movs	r2, #1
    91ec:	6818      	ldr	r0, [r3, #0]
    91ee:	4b18      	ldr	r3, [pc, #96]	; (9250 <grid_sys_nvm_clear_configuration+0x74>)

	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
		
	grid_msg_init(&response);
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91f0:	4c18      	ldr	r4, [pc, #96]	; (9254 <grid_sys_nvm_clear_configuration+0x78>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    91f2:	4d19      	ldr	r5, [pc, #100]	; (9258 <grid_sys_nvm_clear_configuration+0x7c>)
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    91f4:	4798      	blx	r3
	grid_msg_init(&response);
    91f6:	a805      	add	r0, sp, #20
    91f8:	4b18      	ldr	r3, [pc, #96]	; (925c <grid_sys_nvm_clear_configuration+0x80>)
    91fa:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91fc:	227f      	movs	r2, #127	; 0x7f
    91fe:	4611      	mov	r1, r2
    9200:	a805      	add	r0, sp, #20
    9202:	2300      	movs	r3, #0
    9204:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    9206:	2303      	movs	r3, #3
	uint8_t response_payload[10] = {0};
    9208:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    920a:	4915      	ldr	r1, [pc, #84]	; (9260 <grid_sys_nvm_clear_configuration+0x84>)
    920c:	9300      	str	r3, [sp, #0]
    920e:	2202      	movs	r2, #2
    9210:	2362      	movs	r3, #98	; 0x62
    9212:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    9214:	e9cd 4402 	strd	r4, r4, [sp, #8]
    9218:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    921c:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    921e:	4b11      	ldr	r3, [pc, #68]	; (9264 <grid_sys_nvm_clear_configuration+0x88>)
    9220:	a802      	add	r0, sp, #8
    9222:	4798      	blx	r3
    9224:	a902      	add	r1, sp, #8
    9226:	4602      	mov	r2, r0
    9228:	4b0f      	ldr	r3, [pc, #60]	; (9268 <grid_sys_nvm_clear_configuration+0x8c>)
    922a:	a805      	add	r0, sp, #20
    922c:	4798      	blx	r3
		
	if (acknowledge == 1){
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    922e:	230a      	movs	r3, #10
    9230:	4621      	mov	r1, r4
    9232:	2204      	movs	r2, #4
    9234:	9300      	str	r3, [sp, #0]
    9236:	a805      	add	r0, sp, #20
    9238:	4c0c      	ldr	r4, [pc, #48]	; (926c <grid_sys_nvm_clear_configuration+0x90>)
    923a:	2301      	movs	r3, #1
    923c:	47a0      	blx	r4
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
	}

		
	grid_msg_packet_close(&response);
    923e:	4b0c      	ldr	r3, [pc, #48]	; (9270 <grid_sys_nvm_clear_configuration+0x94>)
    9240:	a805      	add	r0, sp, #20
    9242:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9244:	4b0b      	ldr	r3, [pc, #44]	; (9274 <grid_sys_nvm_clear_configuration+0x98>)
    9246:	a805      	add	r0, sp, #20
    9248:	4798      	blx	r3
	
	
}
    924a:	b06d      	add	sp, #436	; 0x1b4
    924c:	bd30      	pop	{r4, r5, pc}
    924e:	bf00      	nop
    9250:	0000ed69 	.word	0x0000ed69
    9254:	000085f9 	.word	0x000085f9
    9258:	000147d1 	.word	0x000147d1
    925c:	000085c5 	.word	0x000085c5
    9260:	00016a0f 	.word	0x00016a0f
    9264:	00014c81 	.word	0x00014c81
    9268:	00008535 	.word	0x00008535
    926c:	000085a9 	.word	0x000085a9
    9270:	000086f1 	.word	0x000086f1
    9274:	000087c5 	.word	0x000087c5

00009278 <grid_debug_print_text>:



void grid_debug_print_text(uint8_t* debug_string){
    9278:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	uint32_t debug_string_length = strlen(debug_string);
    927c:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 9360 <grid_debug_print_text+0xe8>
	
	struct grid_msg message;
	
	grid_msg_init(&message);
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9280:	4c2b      	ldr	r4, [pc, #172]	; (9330 <grid_debug_print_text+0xb8>)
	
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
	uint32_t offset = 0;
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    9282:	4e2c      	ldr	r6, [pc, #176]	; (9334 <grid_debug_print_text+0xbc>)
	offset += strlen(&payload[offset]);
		
	sprintf(&payload[offset], "# ");
    9284:	4f2c      	ldr	r7, [pc, #176]	; (9338 <grid_debug_print_text+0xc0>)
void grid_debug_print_text(uint8_t* debug_string){
    9286:	f5ad 7d4c 	sub.w	sp, sp, #816	; 0x330
    928a:	4681      	mov	r9, r0
	uint32_t debug_string_length = strlen(debug_string);
    928c:	47d0      	blx	sl
	grid_msg_init(&message);
    928e:	4b2b      	ldr	r3, [pc, #172]	; (933c <grid_debug_print_text+0xc4>)
	uint32_t debug_string_length = strlen(debug_string);
    9290:	4680      	mov	r8, r0
	grid_msg_init(&message);
    9292:	a865      	add	r0, sp, #404	; 0x194
    9294:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9296:	227f      	movs	r2, #127	; 0x7f
    9298:	4611      	mov	r1, r2
    929a:	2300      	movs	r3, #0
    929c:	a865      	add	r0, sp, #404	; 0x194
    929e:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    92a0:	2400      	movs	r4, #0
    92a2:	4621      	mov	r1, r4
    92a4:	4b26      	ldr	r3, [pc, #152]	; (9340 <grid_debug_print_text+0xc8>)
    92a6:	9401      	str	r4, [sp, #4]
    92a8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    92ac:	a802      	add	r0, sp, #8
    92ae:	4798      	blx	r3
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    92b0:	2202      	movs	r2, #2
    92b2:	4924      	ldr	r1, [pc, #144]	; (9344 <grid_debug_print_text+0xcc>)
    92b4:	2320      	movs	r3, #32
    92b6:	a801      	add	r0, sp, #4
    92b8:	47b0      	blx	r6
	offset += strlen(&payload[offset]);
    92ba:	a801      	add	r0, sp, #4
    92bc:	47d0      	blx	sl
	sprintf(&payload[offset], "# ");
    92be:	ab01      	add	r3, sp, #4
    92c0:	4403      	add	r3, r0
    92c2:	4921      	ldr	r1, [pc, #132]	; (9348 <grid_debug_print_text+0xd0>)
	offset += strlen(&payload[offset]);
    92c4:	4605      	mov	r5, r0
	sprintf(&payload[offset], "# ");
    92c6:	4618      	mov	r0, r3
    92c8:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    92ca:	47d0      	blx	sl
    92cc:	ab01      	add	r3, sp, #4
    92ce:	4405      	add	r5, r0

	for(uint32_t i=0; i<debug_string_length; i++){
    92d0:	1958      	adds	r0, r3, r5
    92d2:	4621      	mov	r1, r4
    92d4:	4603      	mov	r3, r0
    92d6:	4654      	mov	r4, sl
    92d8:	4541      	cmp	r1, r8
    92da:	d006      	beq.n	92ea <grid_debug_print_text+0x72>
		
		payload[offset+i] = debug_string[i];
    92dc:	f819 2001 	ldrb.w	r2, [r9, r1]
    92e0:	f803 2b01 	strb.w	r2, [r3], #1
		
		if (offset + i > GRID_PARAMETER_PACKET_marign)
    92e4:	194a      	adds	r2, r1, r5
    92e6:	2ac8      	cmp	r2, #200	; 0xc8
    92e8:	d91f      	bls.n	932a <grid_debug_print_text+0xb2>
		{
			break;
		}
	}
	offset += strlen(&payload[offset]);
    92ea:	47a0      	blx	r4
	
	
	sprintf(&payload[offset], " #");
    92ec:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    92ee:	4405      	add	r5, r0
	sprintf(&payload[offset], " #");
    92f0:	442b      	add	r3, r5
    92f2:	4916      	ldr	r1, [pc, #88]	; (934c <grid_debug_print_text+0xd4>)
    92f4:	4618      	mov	r0, r3
    92f6:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    92f8:	47a0      	blx	r4
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    92fa:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    92fc:	4405      	add	r5, r0
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    92fe:	195f      	adds	r7, r3, r5
    9300:	4913      	ldr	r1, [pc, #76]	; (9350 <grid_debug_print_text+0xd8>)
    9302:	2203      	movs	r2, #3
    9304:	4638      	mov	r0, r7
    9306:	47b0      	blx	r6
	offset += strlen(&payload[offset]);	
    9308:	4638      	mov	r0, r7
    930a:	47a0      	blx	r4
	
	grid_msg_body_append_text(&message, payload, offset);
    930c:	a901      	add	r1, sp, #4
    930e:	1942      	adds	r2, r0, r5
    9310:	4b10      	ldr	r3, [pc, #64]	; (9354 <grid_debug_print_text+0xdc>)
    9312:	a865      	add	r0, sp, #404	; 0x194
    9314:	4798      	blx	r3
	grid_msg_packet_close(&message);
    9316:	4b10      	ldr	r3, [pc, #64]	; (9358 <grid_debug_print_text+0xe0>)
    9318:	a865      	add	r0, sp, #404	; 0x194
    931a:	4798      	blx	r3
	
	grid_msg_packet_send_everywhere(&message);
    931c:	4b0f      	ldr	r3, [pc, #60]	; (935c <grid_debug_print_text+0xe4>)
    931e:	a865      	add	r0, sp, #404	; 0x194
    9320:	4798      	blx	r3
	

	
	
}
    9322:	f50d 7d4c 	add.w	sp, sp, #816	; 0x330
    9326:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for(uint32_t i=0; i<debug_string_length; i++){
    932a:	3101      	adds	r1, #1
    932c:	e7d4      	b.n	92d8 <grid_debug_print_text+0x60>
    932e:	bf00      	nop
    9330:	000085f9 	.word	0x000085f9
    9334:	000147d1 	.word	0x000147d1
    9338:	00014bbd 	.word	0x00014bbd
    933c:	000085c5 	.word	0x000085c5
    9340:	00014175 	.word	0x00014175
    9344:	00016a27 	.word	0x00016a27
    9348:	00016a2f 	.word	0x00016a2f
    934c:	00016a32 	.word	0x00016a32
    9350:	0001674f 	.word	0x0001674f
    9354:	00008535 	.word	0x00008535
    9358:	000086f1 	.word	0x000086f1
    935c:	000087c5 	.word	0x000087c5
    9360:	00014c81 	.word	0x00014c81

00009364 <tx_cb_USART_GRID>:
static void tx_cb_USART_GRID_W(const struct usart_async_descriptor *const descr)
{
	tx_cb_USART_GRID(&GRID_PORT_W);
}

void tx_cb_USART_GRID(struct grid_port* const por){
    9364:	b530      	push	{r4, r5, lr}
	
	
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    9366:	f06f 052b 	mvn.w	r5, #43	; 0x2b
    936a:	8984      	ldrh	r4, [r0, #12]
    936c:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9370:	1a2d      	subs	r5, r5, r0
    9372:	2200      	movs	r2, #0
    9374:	18e9      	adds	r1, r5, r3
    9376:	428c      	cmp	r4, r1
    9378:	d801      	bhi.n	937e <tx_cb_USART_GRID+0x1a>
		por->tx_double_buffer[i] = 0;
	}
	por->tx_double_buffer_status = 0;	
    937a:	8182      	strh	r2, [r0, #12]
}
    937c:	bd30      	pop	{r4, r5, pc}
		por->tx_double_buffer[i] = 0;
    937e:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    9382:	e7f7      	b.n	9374 <tx_cb_USART_GRID+0x10>

00009384 <tx_cb_USART_GRID_W>:
	tx_cb_USART_GRID(&GRID_PORT_W);
    9384:	4801      	ldr	r0, [pc, #4]	; (938c <tx_cb_USART_GRID_W+0x8>)
    9386:	4b02      	ldr	r3, [pc, #8]	; (9390 <tx_cb_USART_GRID_W+0xc>)
    9388:	4718      	bx	r3
    938a:	bf00      	nop
    938c:	20008cf0 	.word	0x20008cf0
    9390:	00009365 	.word	0x00009365

00009394 <tx_cb_USART_GRID_S>:
	tx_cb_USART_GRID(&GRID_PORT_S);
    9394:	4801      	ldr	r0, [pc, #4]	; (939c <tx_cb_USART_GRID_S+0x8>)
    9396:	4b02      	ldr	r3, [pc, #8]	; (93a0 <tx_cb_USART_GRID_S+0xc>)
    9398:	4718      	bx	r3
    939a:	bf00      	nop
    939c:	2000c2f0 	.word	0x2000c2f0
    93a0:	00009365 	.word	0x00009365

000093a4 <tx_cb_USART_GRID_E>:
	tx_cb_USART_GRID(&GRID_PORT_E);
    93a4:	4801      	ldr	r0, [pc, #4]	; (93ac <tx_cb_USART_GRID_E+0x8>)
    93a6:	4b02      	ldr	r3, [pc, #8]	; (93b0 <tx_cb_USART_GRID_E+0xc>)
    93a8:	4718      	bx	r3
    93aa:	bf00      	nop
    93ac:	2001228c 	.word	0x2001228c
    93b0:	00009365 	.word	0x00009365

000093b4 <tx_cb_USART_GRID_N>:
	tx_cb_USART_GRID(&GRID_PORT_N);
    93b4:	4801      	ldr	r0, [pc, #4]	; (93bc <tx_cb_USART_GRID_N+0x8>)
    93b6:	4b02      	ldr	r3, [pc, #8]	; (93c0 <tx_cb_USART_GRID_N+0xc>)
    93b8:	4718      	bx	r3
    93ba:	bf00      	nop
    93bc:	20001b6c 	.word	0x20001b6c
    93c0:	00009365 	.word	0x00009365

000093c4 <err_cb_USART_GRID>:
	err_cb_USART_GRID(&GRID_PORT_W);
}


void err_cb_USART_GRID(struct grid_port* const por){
	por->usart_error_flag = 1;	
    93c4:	2301      	movs	r3, #1
    93c6:	7603      	strb	r3, [r0, #24]
	
	usart_async_disable(por->usart);
    93c8:	6840      	ldr	r0, [r0, #4]
    93ca:	4b01      	ldr	r3, [pc, #4]	; (93d0 <err_cb_USART_GRID+0xc>)
    93cc:	4718      	bx	r3
    93ce:	bf00      	nop
    93d0:	000106e9 	.word	0x000106e9

000093d4 <err_cb_USART_GRID_W>:
	err_cb_USART_GRID(&GRID_PORT_W);
    93d4:	4801      	ldr	r0, [pc, #4]	; (93dc <err_cb_USART_GRID_W+0x8>)
    93d6:	4b02      	ldr	r3, [pc, #8]	; (93e0 <err_cb_USART_GRID_W+0xc>)
    93d8:	4718      	bx	r3
    93da:	bf00      	nop
    93dc:	20008cf0 	.word	0x20008cf0
    93e0:	000093c5 	.word	0x000093c5

000093e4 <err_cb_USART_GRID_S>:
	err_cb_USART_GRID(&GRID_PORT_S);
    93e4:	4801      	ldr	r0, [pc, #4]	; (93ec <err_cb_USART_GRID_S+0x8>)
    93e6:	4b02      	ldr	r3, [pc, #8]	; (93f0 <err_cb_USART_GRID_S+0xc>)
    93e8:	4718      	bx	r3
    93ea:	bf00      	nop
    93ec:	2000c2f0 	.word	0x2000c2f0
    93f0:	000093c5 	.word	0x000093c5

000093f4 <err_cb_USART_GRID_E>:
	err_cb_USART_GRID(&GRID_PORT_E);
    93f4:	4801      	ldr	r0, [pc, #4]	; (93fc <err_cb_USART_GRID_E+0x8>)
    93f6:	4b02      	ldr	r3, [pc, #8]	; (9400 <err_cb_USART_GRID_E+0xc>)
    93f8:	4718      	bx	r3
    93fa:	bf00      	nop
    93fc:	2001228c 	.word	0x2001228c
    9400:	000093c5 	.word	0x000093c5

00009404 <err_cb_USART_GRID_N>:
	err_cb_USART_GRID(&GRID_PORT_N);
    9404:	4801      	ldr	r0, [pc, #4]	; (940c <err_cb_USART_GRID_N+0x8>)
    9406:	4b02      	ldr	r3, [pc, #8]	; (9410 <err_cb_USART_GRID_N+0xc>)
    9408:	4718      	bx	r3
    940a:	bf00      	nop
    940c:	20001b6c 	.word	0x20001b6c
    9410:	000093c5 	.word	0x000093c5

00009414 <grid_sys_port_reset_dma>:
#define DMA_SOUTH_RX_CHANNEL	2
#define DMA_WEST_RX_CHANNEL		3

void grid_sys_port_reset_dma(struct grid_port* por){
	
	hri_dmac_clear_CHCTRLA_ENABLE_bit(DMAC, por->dma_channel);
    9414:	7a80      	ldrb	r0, [r0, #10]
}

static inline void hri_dmac_clear_CHCTRLA_ENABLE_bit(const void *const hw, uint8_t submodule_index)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    9416:	0103      	lsls	r3, r0, #4
    9418:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    941c:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
	_dma_enable_transaction(por->dma_channel, false);
    9420:	2100      	movs	r1, #0
    9422:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    9424:	f022 0202 	bic.w	r2, r2, #2
    9428:	641a      	str	r2, [r3, #64]	; 0x40
    942a:	4b01      	ldr	r3, [pc, #4]	; (9430 <grid_sys_port_reset_dma+0x1c>)
    942c:	4718      	bx	r3
    942e:	bf00      	nop
    9430:	0000e14d 	.word	0x0000e14d

00009434 <dma_transfer_complete_n_cb>:
	grid_sys_port_reset_dma(por);
    9434:	4801      	ldr	r0, [pc, #4]	; (943c <dma_transfer_complete_n_cb+0x8>)
    9436:	4b02      	ldr	r3, [pc, #8]	; (9440 <dma_transfer_complete_n_cb+0xc>)
    9438:	4718      	bx	r3
    943a:	bf00      	nop
    943c:	20001b6c 	.word	0x20001b6c
    9440:	00009415 	.word	0x00009415

00009444 <dma_transfer_complete_e_cb>:
    9444:	4801      	ldr	r0, [pc, #4]	; (944c <dma_transfer_complete_e_cb+0x8>)
    9446:	4b02      	ldr	r3, [pc, #8]	; (9450 <dma_transfer_complete_e_cb+0xc>)
    9448:	4718      	bx	r3
    944a:	bf00      	nop
    944c:	2001228c 	.word	0x2001228c
    9450:	00009415 	.word	0x00009415

00009454 <dma_transfer_complete_s_cb>:
    9454:	4801      	ldr	r0, [pc, #4]	; (945c <dma_transfer_complete_s_cb+0x8>)
    9456:	4b02      	ldr	r3, [pc, #8]	; (9460 <dma_transfer_complete_s_cb+0xc>)
    9458:	4718      	bx	r3
    945a:	bf00      	nop
    945c:	2000c2f0 	.word	0x2000c2f0
    9460:	00009415 	.word	0x00009415

00009464 <dma_transfer_complete_w_cb>:
    9464:	4801      	ldr	r0, [pc, #4]	; (946c <dma_transfer_complete_w_cb+0x8>)
    9466:	4b02      	ldr	r3, [pc, #8]	; (9470 <dma_transfer_complete_w_cb+0xc>)
    9468:	4718      	bx	r3
    946a:	bf00      	nop
    946c:	20008cf0 	.word	0x20008cf0
    9470:	00009415 	.word	0x00009415

00009474 <grid_sys_uart_init>:

}


void grid_sys_uart_init(){
    9474:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *                      GPIO_PULL_UP   = Pull pin high with internal resistor
 *                      GPIO_PULL_OFF  = Disable pin pull mode
 */
static inline void gpio_set_pin_pull_mode(const uint8_t pin, const enum gpio_pull_mode pull_mode)
{
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    9478:	211c      	movs	r1, #28
    947a:	4c2c      	ldr	r4, [pc, #176]	; (952c <grid_sys_uart_init+0xb8>)
	gpio_set_pin_pull_mode(PC28, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC16, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC12, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PB09, GPIO_PULL_UP);
	
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    947c:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 9578 <grid_sys_uart_init+0x104>
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9480:	4f2b      	ldr	r7, [pc, #172]	; (9530 <grid_sys_uart_init+0xbc>)
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    9482:	4e2c      	ldr	r6, [pc, #176]	; (9534 <grid_sys_uart_init+0xc0>)
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    9484:	4d2c      	ldr	r5, [pc, #176]	; (9538 <grid_sys_uart_init+0xc4>)
			
	// Set parity for grid uart communication
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    9486:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 957c <grid_sys_uart_init+0x108>
    948a:	2002      	movs	r0, #2
    948c:	47a0      	blx	r4
    948e:	2110      	movs	r1, #16
    9490:	2002      	movs	r0, #2
    9492:	47a0      	blx	r4
    9494:	210c      	movs	r1, #12
    9496:	2002      	movs	r0, #2
    9498:	47a0      	blx	r4
    949a:	2109      	movs	r1, #9
    949c:	2001      	movs	r0, #1
    949e:	47a0      	blx	r4
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    94a0:	4c26      	ldr	r4, [pc, #152]	; (953c <grid_sys_uart_init+0xc8>)
    94a2:	4a27      	ldr	r2, [pc, #156]	; (9540 <grid_sys_uart_init+0xcc>)
    94a4:	2101      	movs	r1, #1
    94a6:	4640      	mov	r0, r8
    94a8:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    94aa:	4a26      	ldr	r2, [pc, #152]	; (9544 <grid_sys_uart_init+0xd0>)
    94ac:	2101      	movs	r1, #1
    94ae:	4638      	mov	r0, r7
    94b0:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    94b2:	4a25      	ldr	r2, [pc, #148]	; (9548 <grid_sys_uart_init+0xd4>)
    94b4:	2101      	movs	r1, #1
    94b6:	4630      	mov	r0, r6
    94b8:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    94ba:	4a24      	ldr	r2, [pc, #144]	; (954c <grid_sys_uart_init+0xd8>)
    94bc:	2101      	movs	r1, #1
    94be:	4628      	mov	r0, r5
    94c0:	47a0      	blx	r4
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    94c2:	2101      	movs	r1, #1
    94c4:	4640      	mov	r0, r8
    94c6:	47c8      	blx	r9
	usart_async_set_parity(&USART_EAST, USART_PARITY_ODD);	
    94c8:	2101      	movs	r1, #1
    94ca:	4638      	mov	r0, r7
    94cc:	47c8      	blx	r9
	usart_async_set_parity(&USART_SOUTH, USART_PARITY_ODD);
    94ce:	2101      	movs	r1, #1
    94d0:	4630      	mov	r0, r6
    94d2:	47c8      	blx	r9
	usart_async_set_parity(&USART_WEST, USART_PARITY_ODD);
    94d4:	2101      	movs	r1, #1
    94d6:	4628      	mov	r0, r5
    94d8:	47c8      	blx	r9
	
	// Set callback function for parity error
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_N);
    94da:	4a1d      	ldr	r2, [pc, #116]	; (9550 <grid_sys_uart_init+0xdc>)
    94dc:	2102      	movs	r1, #2
    94de:	4640      	mov	r0, r8
    94e0:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_E);
    94e2:	4a1c      	ldr	r2, [pc, #112]	; (9554 <grid_sys_uart_init+0xe0>)
    94e4:	2102      	movs	r1, #2
    94e6:	4638      	mov	r0, r7
    94e8:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_S);
    94ea:	4a1b      	ldr	r2, [pc, #108]	; (9558 <grid_sys_uart_init+0xe4>)
    94ec:	2102      	movs	r1, #2
    94ee:	4630      	mov	r0, r6
    94f0:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_W);
    94f2:	4a1a      	ldr	r2, [pc, #104]	; (955c <grid_sys_uart_init+0xe8>)
    94f4:	2102      	movs	r1, #2
    94f6:	4628      	mov	r0, r5
    94f8:	47a0      	blx	r4
// 	usart_async_register_callback(&USART_EAST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_E);
// 	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_RXC_CB, rx_cb_USART_GRID_S);
// 	usart_async_register_callback(&USART_WEST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_W);

	
	usart_async_get_io_descriptor(&USART_NORTH, &grid_sys_north_io);
    94fa:	4c19      	ldr	r4, [pc, #100]	; (9560 <grid_sys_uart_init+0xec>)
    94fc:	4919      	ldr	r1, [pc, #100]	; (9564 <grid_sys_uart_init+0xf0>)
    94fe:	4640      	mov	r0, r8
    9500:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_EAST,  &grid_sys_east_io);
    9502:	4919      	ldr	r1, [pc, #100]	; (9568 <grid_sys_uart_init+0xf4>)
    9504:	4638      	mov	r0, r7
    9506:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_SOUTH, &grid_sys_south_io);
    9508:	4918      	ldr	r1, [pc, #96]	; (956c <grid_sys_uart_init+0xf8>)
    950a:	4630      	mov	r0, r6
    950c:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_WEST,  &grid_sys_west_io);
    950e:	4918      	ldr	r1, [pc, #96]	; (9570 <grid_sys_uart_init+0xfc>)
    9510:	4628      	mov	r0, r5
    9512:	47a0      	blx	r4
	
	
	usart_async_enable(&USART_NORTH);
    9514:	4c17      	ldr	r4, [pc, #92]	; (9574 <grid_sys_uart_init+0x100>)
    9516:	4640      	mov	r0, r8
    9518:	47a0      	blx	r4
	usart_async_enable(&USART_EAST);
    951a:	4638      	mov	r0, r7
    951c:	47a0      	blx	r4
	usart_async_enable(&USART_SOUTH);
    951e:	4630      	mov	r0, r6
    9520:	47a0      	blx	r4
	usart_async_enable(&USART_WEST);
    9522:	4628      	mov	r0, r5
    9524:	4623      	mov	r3, r4




}
    9526:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	usart_async_enable(&USART_WEST);
    952a:	4718      	bx	r3
    952c:	00008d59 	.word	0x00008d59
    9530:	200157d0 	.word	0x200157d0
    9534:	20015928 	.word	0x20015928
    9538:	200158d8 	.word	0x200158d8
    953c:	00010739 	.word	0x00010739
    9540:	000093b5 	.word	0x000093b5
    9544:	000093a5 	.word	0x000093a5
    9548:	00009395 	.word	0x00009395
    954c:	00009385 	.word	0x00009385
    9550:	00009405 	.word	0x00009405
    9554:	000093f5 	.word	0x000093f5
    9558:	000093e5 	.word	0x000093e5
    955c:	000093d5 	.word	0x000093d5
    9560:	00010715 	.word	0x00010715
    9564:	20007a20 	.word	0x20007a20
    9568:	2000c2ec 	.word	0x2000c2ec
    956c:	2000f23c 	.word	0x2000f23c
    9570:	2001526c 	.word	0x2001526c
    9574:	000106bd 	.word	0x000106bd
    9578:	20015824 	.word	0x20015824
    957c:	00010799 	.word	0x00010799

00009580 <grid_sys_dma_rx_init_one>:



void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9580:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	
	uint8_t dma_rx_channel = por->dma_channel;
	
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9582:	6843      	ldr	r3, [r0, #4]
	uint8_t dma_rx_channel = por->dma_channel;
    9584:	7a84      	ldrb	r4, [r0, #10]
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9586:	460f      	mov	r7, r1
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9588:	6a19      	ldr	r1, [r3, #32]
    958a:	4b10      	ldr	r3, [pc, #64]	; (95cc <grid_sys_dma_rx_init_one+0x4c>)
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    958c:	4605      	mov	r5, r0
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    958e:	3128      	adds	r1, #40	; 0x28
    9590:	4620      	mov	r0, r4
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9592:	4616      	mov	r6, r2
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9594:	4798      	blx	r3
	_dma_set_destination_address(dma_rx_channel, (uint32_t *)por->rx_double_buffer);
    9596:	f505 519d 	add.w	r1, r5, #5024	; 0x13a0
    959a:	4b0d      	ldr	r3, [pc, #52]	; (95d0 <grid_sys_dma_rx_init_one+0x50>)
    959c:	3114      	adds	r1, #20
    959e:	4620      	mov	r0, r4
    95a0:	4798      	blx	r3
	_dma_set_data_amount(dma_rx_channel, (uint32_t)buffer_length);
    95a2:	4639      	mov	r1, r7
    95a4:	4b0b      	ldr	r3, [pc, #44]	; (95d4 <grid_sys_dma_rx_init_one+0x54>)
    95a6:	4620      	mov	r0, r4
    95a8:	4798      	blx	r3
	
	struct _dma_resource *resource_rx;
	_dma_get_channel_resource(&resource_rx, dma_rx_channel);
    95aa:	4621      	mov	r1, r4
    95ac:	4b0a      	ldr	r3, [pc, #40]	; (95d8 <grid_sys_dma_rx_init_one+0x58>)
    95ae:	a801      	add	r0, sp, #4
    95b0:	4798      	blx	r3
	
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    95b2:	9b01      	ldr	r3, [sp, #4]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    95b4:	2201      	movs	r2, #1
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    95b6:	601e      	str	r6, [r3, #0]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    95b8:	4620      	mov	r0, r4
    95ba:	4b08      	ldr	r3, [pc, #32]	; (95dc <grid_sys_dma_rx_init_one+0x5c>)
    95bc:	2100      	movs	r1, #0
    95be:	4798      	blx	r3
	
	//resource_rx->dma_cb.error         = function_cb;
	_dma_enable_transaction(dma_rx_channel, false);
    95c0:	4b07      	ldr	r3, [pc, #28]	; (95e0 <grid_sys_dma_rx_init_one+0x60>)
    95c2:	2100      	movs	r1, #0
    95c4:	4620      	mov	r0, r4
    95c6:	4798      	blx	r3
	

}
    95c8:	b003      	add	sp, #12
    95ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    95cc:	0000e0dd 	.word	0x0000e0dd
    95d0:	0000e0cd 	.word	0x0000e0cd
    95d4:	0000e109 	.word	0x0000e109
    95d8:	0000e189 	.word	0x0000e189
    95dc:	0000e0a5 	.word	0x0000e0a5
    95e0:	0000e14d 	.word	0x0000e14d

000095e4 <grid_sys_dma_rx_init>:

void grid_sys_dma_rx_init(){
    95e4:	b510      	push	{r4, lr}
	
	grid_sys_dma_rx_init_one(&GRID_PORT_N, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_n_cb);
    95e6:	4a10      	ldr	r2, [pc, #64]	; (9628 <grid_sys_dma_rx_init+0x44>)
    95e8:	4c10      	ldr	r4, [pc, #64]	; (962c <grid_sys_dma_rx_init+0x48>)
    95ea:	4811      	ldr	r0, [pc, #68]	; (9630 <grid_sys_dma_rx_init+0x4c>)
    95ec:	f241 3188 	movw	r1, #5000	; 0x1388
    95f0:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_E, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_e_cb);
    95f2:	4a10      	ldr	r2, [pc, #64]	; (9634 <grid_sys_dma_rx_init+0x50>)
    95f4:	4810      	ldr	r0, [pc, #64]	; (9638 <grid_sys_dma_rx_init+0x54>)
    95f6:	f241 3188 	movw	r1, #5000	; 0x1388
    95fa:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_S, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_s_cb);
    95fc:	4a0f      	ldr	r2, [pc, #60]	; (963c <grid_sys_dma_rx_init+0x58>)
    95fe:	4810      	ldr	r0, [pc, #64]	; (9640 <grid_sys_dma_rx_init+0x5c>)
    9600:	f241 3188 	movw	r1, #5000	; 0x1388
    9604:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_W, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_w_cb);
    9606:	4a0f      	ldr	r2, [pc, #60]	; (9644 <grid_sys_dma_rx_init+0x60>)
    9608:	480f      	ldr	r0, [pc, #60]	; (9648 <grid_sys_dma_rx_init+0x64>)
    960a:	f241 3188 	movw	r1, #5000	; 0x1388
    960e:	47a0      	blx	r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9610:	4b0e      	ldr	r3, [pc, #56]	; (964c <grid_sys_dma_rx_init+0x68>)
    9612:	2200      	movs	r2, #0
    9614:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
    9618:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
    961c:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
    9620:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
	NVIC_SetPriority(DMAC_0_IRQn, 0);
	NVIC_SetPriority(DMAC_1_IRQn, 0);
	NVIC_SetPriority(DMAC_2_IRQn, 0);
	NVIC_SetPriority(DMAC_3_IRQn, 0);
	
}
    9624:	bd10      	pop	{r4, pc}
    9626:	bf00      	nop
    9628:	00009435 	.word	0x00009435
    962c:	00009581 	.word	0x00009581
    9630:	20001b6c 	.word	0x20001b6c
    9634:	00009445 	.word	0x00009445
    9638:	2001228c 	.word	0x2001228c
    963c:	00009455 	.word	0x00009455
    9640:	2000c2f0 	.word	0x2000c2f0
    9644:	00009465 	.word	0x00009465
    9648:	20008cf0 	.word	0x20008cf0
    964c:	e000e100 	.word	0xe000e100

00009650 <grid_sys_init>:
	return tmp;
}

static inline hri_rstc_rcause_reg_t hri_rstc_read_RCAUSE_reg(const void *const hw)
{
	return ((Rstc *)hw)->RCAUSE.reg;
    9650:	4b16      	ldr	r3, [pc, #88]	; (96ac <grid_sys_init+0x5c>)

void grid_sys_init(struct grid_sys_model* mod){
    9652:	b570      	push	{r4, r5, r6, lr}
    9654:	781b      	ldrb	r3, [r3, #0]
	
	mod->uptime = 0;
	mod->reset_cause = hri_rstc_read_RCAUSE_reg(RSTC);
    9656:	7103      	strb	r3, [r0, #4]
	mod->uptime = 0;
    9658:	2500      	movs	r5, #0
void grid_sys_init(struct grid_sys_model* mod){
    965a:	4604      	mov	r4, r0
	mod->uptime = 0;
    965c:	6005      	str	r5, [r0, #0]
	
    
	mod->sessionid = rand_sync_read8(&RAND_0);
    965e:	4b14      	ldr	r3, [pc, #80]	; (96b0 <grid_sys_init+0x60>)
    9660:	4814      	ldr	r0, [pc, #80]	; (96b4 <grid_sys_init+0x64>)
    9662:	4798      	blx	r3
	mod->bank_color_r[3] = 100;
	mod->bank_color_g[3] = 0;
	mod->bank_color_b[3] = 200;
	
	mod->bank_enabled[0] = 1;
	mod->bank_enabled[1] = 1;
    9664:	4a14      	ldr	r2, [pc, #80]	; (96b8 <grid_sys_init+0x68>)
    9666:	4b15      	ldr	r3, [pc, #84]	; (96bc <grid_sys_init+0x6c>)
	mod->bank_color_g[1] = 100;
    9668:	4915      	ldr	r1, [pc, #84]	; (96c0 <grid_sys_init+0x70>)
	mod->sessionid = rand_sync_read8(&RAND_0);
    966a:	7160      	strb	r0, [r4, #5]
	mod->bank_enabled[1] = 1;
    966c:	e9c4 2304 	strd	r2, r3, [r4, #16]
	mod->bank_color_g[1] = 100;
    9670:	4b14      	ldr	r3, [pc, #80]	; (96c4 <grid_sys_init+0x74>)
	mod->bank_setting_changed_flag = 0;
	
	mod->bank_init_flag = 0;


	mod->bank_activebank_number = 0;
    9672:	73e5      	strb	r5, [r4, #15]
	mod->bank_color_g[1] = 100;
    9674:	e9c4 1306 	strd	r1, r3, [r4, #24]
	mod->bank_color_b[1] = 0;
    9678:	f44f 5348 	mov.w	r3, #12800	; 0x3200
    967c:	8423      	strh	r3, [r4, #32]
	mod->bank_color_b[3] = 200;
    967e:	23c8      	movs	r3, #200	; 0xc8
    9680:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	if (banknumber == 255){
			
		//mod->bank_activebank_number = 0;
		mod->bank_activebank_valid = 0;
		
		mod->bank_active_changed = 1;
    9684:	4b10      	ldr	r3, [pc, #64]	; (96c8 <grid_sys_init+0x78>)
	mod->bank_activebank_color_r = 0;
    9686:	6265      	str	r5, [r4, #36]	; 0x24
		mod->bank_active_changed = 1;
    9688:	2201      	movs	r2, #1
    968a:	745a      	strb	r2, [r3, #17]
				
		mod->bank_activebank_color_r = 127;
    968c:	f647 727f 	movw	r2, #32639	; 0x7f7f
		mod->bank_activebank_valid = 0;
    9690:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9694:	849a      	strh	r2, [r3, #36]	; 0x24
		mod->bank_activebank_color_g = 127;
		mod->bank_activebank_color_b = 127;
    9696:	227f      	movs	r2, #127	; 0x7f
    9698:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	grid_port_init_all();
    969c:	4b0b      	ldr	r3, [pc, #44]	; (96cc <grid_sys_init+0x7c>)
    969e:	4798      	blx	r3
	grid_sys_uart_init();
    96a0:	4b0b      	ldr	r3, [pc, #44]	; (96d0 <grid_sys_init+0x80>)
    96a2:	4798      	blx	r3
}
    96a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	grid_sys_dma_rx_init();
    96a8:	4b0a      	ldr	r3, [pc, #40]	; (96d4 <grid_sys_init+0x84>)
    96aa:	4718      	bx	r3
    96ac:	40000c00 	.word	0x40000c00
    96b0:	0000e6bd 	.word	0x0000e6bd
    96b4:	2001579c 	.word	0x2001579c
    96b8:	01000001 	.word	0x01000001
    96bc:	00010101 	.word	0x00010101
    96c0:	646432c8 	.word	0x646432c8
    96c4:	c800c864 	.word	0xc800c864
    96c8:	20007a24 	.word	0x20007a24
    96cc:	00005165 	.word	0x00005165
    96d0:	00009475 	.word	0x00009475
    96d4:	000095e5 	.word	0x000095e5

000096d8 <grid_sys_bank_enable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    96d8:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 1;
    96da:	bf9e      	ittt	ls
    96dc:	1809      	addls	r1, r1, r0
    96de:	2301      	movls	r3, #1
    96e0:	74cb      	strbls	r3, [r1, #19]
}
    96e2:	4770      	bx	lr

000096e4 <grid_sys_bank_disable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    96e4:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 0;
    96e6:	bf9e      	ittt	ls
    96e8:	1809      	addls	r1, r1, r0
    96ea:	2300      	movls	r3, #0
    96ec:	74cb      	strbls	r3, [r1, #19]
}
    96ee:	4770      	bx	lr

000096f0 <grid_sys_bank_set_color>:
	if (banknumber>GRID_SYS_BANK_MAXNUMBER){
    96f0:	2904      	cmp	r1, #4
    96f2:	d901      	bls.n	96f8 <grid_sys_bank_set_color+0x8>
		return false;
    96f4:	2000      	movs	r0, #0
    96f6:	4770      	bx	lr
	mod->bank_color_r[banknumber] = ((rgb&0x00FF0000)>>16);
    96f8:	4401      	add	r1, r0
    96fa:	0c13      	lsrs	r3, r2, #16
    96fc:	75cb      	strb	r3, [r1, #23]
	mod->bank_color_g[banknumber] = ((rgb&0x0000FF00)>>8);
    96fe:	0a13      	lsrs	r3, r2, #8
    9700:	76cb      	strb	r3, [r1, #27]
	mod->bank_color_b[banknumber] = ((rgb&0x000000FF)>>0);
    9702:	77ca      	strb	r2, [r1, #31]
}
    9704:	4770      	bx	lr

00009706 <grid_sys_get_bank_num>:
}
    9706:	7bc0      	ldrb	r0, [r0, #15]
    9708:	4770      	bx	lr

0000970a <grid_sys_get_bank_valid>:
}
    970a:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
    970e:	4770      	bx	lr

00009710 <grid_sys_get_bank_red>:
}
    9710:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    9714:	4770      	bx	lr

00009716 <grid_sys_get_bank_gre>:
}
    9716:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
    971a:	4770      	bx	lr

0000971c <grid_sys_get_bank_blu>:
}
    971c:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
    9720:	4770      	bx	lr

00009722 <grid_sys_get_map_state>:
}
    9722:	7c00      	ldrb	r0, [r0, #16]
    9724:	4770      	bx	lr

00009726 <grid_sys_get_bank_next>:
uint8_t grid_sys_get_bank_next(struct grid_sys_model* mod){
    9726:	b530      	push	{r4, r5, lr}
    9728:	4602      	mov	r2, r0
	return mod->bank_activebank_number;
    972a:	7bc0      	ldrb	r0, [r0, #15]
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    972c:	1c43      	adds	r3, r0, #1
    972e:	1d44      	adds	r4, r0, #5
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    9730:	f003 0103 	and.w	r1, r3, #3
		if (mod->bank_enabled[bank_check] == 1){
    9734:	1855      	adds	r5, r2, r1
    9736:	7ced      	ldrb	r5, [r5, #19]
    9738:	2d01      	cmp	r5, #1
    973a:	d003      	beq.n	9744 <grid_sys_get_bank_next+0x1e>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    973c:	3301      	adds	r3, #1
    973e:	42a3      	cmp	r3, r4
    9740:	d1f6      	bne.n	9730 <grid_sys_get_bank_next+0xa>
}
    9742:	bd30      	pop	{r4, r5, pc}
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    9744:	b2c8      	uxtb	r0, r1
    9746:	e7fc      	b.n	9742 <grid_sys_get_bank_next+0x1c>

00009748 <grid_sys_get_bank_number_of_first_valid>:
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9748:	f100 0213 	add.w	r2, r0, #19
uint8_t grid_sys_get_bank_number_of_first_valid(struct grid_sys_model* mod){
    974c:	2300      	movs	r3, #0
		if (mod->bank_enabled[i] == 1){
    974e:	f812 1b01 	ldrb.w	r1, [r2], #1
    9752:	2901      	cmp	r1, #1
    9754:	b2d8      	uxtb	r0, r3
    9756:	d003      	beq.n	9760 <grid_sys_get_bank_number_of_first_valid+0x18>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9758:	3301      	adds	r3, #1
    975a:	2b04      	cmp	r3, #4
    975c:	d1f7      	bne.n	974e <grid_sys_get_bank_number_of_first_valid+0x6>
	return 255;
    975e:	20ff      	movs	r0, #255	; 0xff
}
    9760:	4770      	bx	lr

00009762 <grid_sys_set_bank>:
	if (banknumber == 255){
    9762:	29ff      	cmp	r1, #255	; 0xff
    9764:	d10b      	bne.n	977e <grid_sys_set_bank+0x1c>
		mod->bank_active_changed = 1;
    9766:	2301      	movs	r3, #1
    9768:	7443      	strb	r3, [r0, #17]
		mod->bank_activebank_valid = 0;
    976a:	2300      	movs	r3, #0
    976c:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9770:	f647 737f 	movw	r3, #32639	; 0x7f7f
    9774:	8483      	strh	r3, [r0, #36]	; 0x24
		mod->bank_activebank_color_b = 127;
    9776:	237f      	movs	r3, #127	; 0x7f
			
			mod->bank_active_changed = 1;
			
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    9778:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
		//grid_debug_print_text("Invalid Bank Number");	
				
	}

	
}
    977c:	4770      	bx	lr
	else if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    977e:	2903      	cmp	r1, #3
    9780:	d8fc      	bhi.n	977c <grid_sys_set_bank+0x1a>
		mod->bank_init_flag = 1;
    9782:	2301      	movs	r3, #1
    9784:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
		if (mod->bank_enabled[banknumber] == 1){
    9788:	1843      	adds	r3, r0, r1
    978a:	7cda      	ldrb	r2, [r3, #19]
    978c:	2a01      	cmp	r2, #1
    978e:	d1f5      	bne.n	977c <grid_sys_set_bank+0x1a>
			mod->bank_activebank_number = banknumber;
    9790:	73c1      	strb	r1, [r0, #15]
			mod->bank_activebank_valid = 1;
    9792:	f880 2023 	strb.w	r2, [r0, #35]	; 0x23
			mod->bank_active_changed = 1;
    9796:	7442      	strb	r2, [r0, #17]
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
    9798:	7dda      	ldrb	r2, [r3, #23]
    979a:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
    979e:	7eda      	ldrb	r2, [r3, #27]
    97a0:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    97a4:	7fdb      	ldrb	r3, [r3, #31]
    97a6:	e7e7      	b.n	9778 <grid_sys_set_bank+0x16>

000097a8 <grid_sys_rtc_get_time>:

// REALTIME

uint32_t grid_sys_rtc_get_time(struct grid_sys_model* mod){
	return mod->realtime;
}
    97a8:	6a80      	ldr	r0, [r0, #40]	; 0x28
    97aa:	4770      	bx	lr

000097ac <grid_sys_rtc_get_elapsed_time>:
	mod->realtime = tvalue;
}

uint32_t grid_sys_rtc_get_elapsed_time(struct grid_sys_model* mod, uint32_t t_old){
	
	return mod->realtime-t_old;
    97ac:	6a80      	ldr	r0, [r0, #40]	; 0x28
	
	

}
    97ae:	1a40      	subs	r0, r0, r1
    97b0:	4770      	bx	lr

000097b2 <grid_sys_rtc_tick_time>:

void grid_sys_rtc_tick_time(struct grid_sys_model* mod){
	
	mod->realtime++;
    97b2:	6a83      	ldr	r3, [r0, #40]	; 0x28
    97b4:	3301      	adds	r3, #1
    97b6:	6283      	str	r3, [r0, #40]	; 0x28
	if (mod->uptime != -1){
    97b8:	6803      	ldr	r3, [r0, #0]
    97ba:	1c5a      	adds	r2, r3, #1
		mod->uptime++;
    97bc:	bf1c      	itt	ne
    97be:	3301      	addne	r3, #1
    97c0:	6003      	strne	r3, [r0, #0]
	}
	
}
    97c2:	4770      	bx	lr

000097c4 <grid_sys_alert_read_color_changed_flag>:

uint8_t grid_sys_alert_read_color_changed_flag(struct grid_sys_model* mod){
		
	return mod->alert_color_changed;
	
}
    97c4:	7b80      	ldrb	r0, [r0, #14]
    97c6:	4770      	bx	lr

000097c8 <grid_sys_alert_clear_color_changed_flag>:
	
}

void grid_sys_alert_clear_color_changed_flag(struct grid_sys_model* mod){
	
	mod->alert_color_changed = 0;
    97c8:	2300      	movs	r3, #0
    97ca:	7383      	strb	r3, [r0, #14]
	
}
    97cc:	4770      	bx	lr

000097ce <grid_sys_alert_get_color_intensity>:

uint8_t grid_sys_alert_get_color_intensity(struct grid_sys_model* mod){
	
	if (mod->alert_style == 0){ // TRIANGLE
    97ce:	7b03      	ldrb	r3, [r0, #12]
    97d0:	b963      	cbnz	r3, 97ec <grid_sys_alert_get_color_intensity+0x1e>
		
		return (250-abs(mod->alert_state/2-250))/2;
    97d2:	8940      	ldrh	r0, [r0, #10]
    97d4:	0840      	lsrs	r0, r0, #1
    97d6:	38fa      	subs	r0, #250	; 0xfa
    97d8:	2800      	cmp	r0, #0
    97da:	bfb8      	it	lt
    97dc:	4240      	neglt	r0, r0
    97de:	f1c0 00fa 	rsb	r0, r0, #250	; 0xfa
    97e2:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    97e6:	f3c0 0047 	ubfx	r0, r0, #1, #8
    97ea:	4770      	bx	lr
	}
	else if (mod->alert_style == 1){ // SQUARE
    97ec:	2b01      	cmp	r3, #1
    97ee:	d107      	bne.n	9800 <grid_sys_alert_get_color_intensity+0x32>
		
		return 255*(mod->alert_state/250%2);
    97f0:	8940      	ldrh	r0, [r0, #10]
    97f2:	23fa      	movs	r3, #250	; 0xfa
    97f4:	fbb0 f0f3 	udiv	r0, r0, r3
    97f8:	f340 0000 	sbfx	r0, r0, #0, #1
    97fc:	b2c0      	uxtb	r0, r0
    97fe:	4770      	bx	lr
	}
	else if (mod->alert_style == 2){ // CONST
    9800:	2b02      	cmp	r3, #2
    9802:	d105      	bne.n	9810 <grid_sys_alert_get_color_intensity+0x42>
		
		return 255*(mod->alert_state>100);
    9804:	8940      	ldrh	r0, [r0, #10]
    9806:	2864      	cmp	r0, #100	; 0x64
    9808:	bf8c      	ite	hi
    980a:	20ff      	movhi	r0, #255	; 0xff
    980c:	2000      	movls	r0, #0
    980e:	4770      	bx	lr
	}
	
	
}
    9810:	4770      	bx	lr

00009812 <grid_sys_alert_set_alert>:
	mod->alert_color_green = green;
	mod->alert_color_blue = blue;
		
}

void grid_sys_alert_set_alert(struct grid_sys_model* mod, uint8_t red, uint8_t green, uint8_t blue, uint8_t style, uint16_t duration){
    9812:	b510      	push	{r4, lr}
	mod->alert_color_blue = blue;
    9814:	7203      	strb	r3, [r0, #8]
	
	grid_sys_alert_set_color(mod, red, green, blue);

	
	mod->alert_state = duration;
    9816:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    981a:	8143      	strh	r3, [r0, #10]
	mod->alert_color_changed = 1;
    981c:	2401      	movs	r4, #1
	mod->alert_style = style;
    981e:	f89d 3008 	ldrb.w	r3, [sp, #8]
	mod->alert_color_changed = 1;
    9822:	7384      	strb	r4, [r0, #14]
	mod->alert_color_red = red;
    9824:	7181      	strb	r1, [r0, #6]
	mod->alert_color_green = green;
    9826:	71c2      	strb	r2, [r0, #7]
	mod->alert_style = style;
    9828:	7303      	strb	r3, [r0, #12]
	
}
    982a:	bd10      	pop	{r4, pc}

0000982c <grid_sys_alert_get_color_r>:

uint8_t grid_sys_alert_get_color_r(struct grid_sys_model* mod){
	
	return mod->alert_color_red;
}
    982c:	7980      	ldrb	r0, [r0, #6]
    982e:	4770      	bx	lr

00009830 <grid_sys_alert_get_color_g>:

uint8_t grid_sys_alert_get_color_g(struct grid_sys_model* mod){
	
	return mod->alert_color_green;
}
    9830:	79c0      	ldrb	r0, [r0, #7]
    9832:	4770      	bx	lr

00009834 <grid_sys_alert_get_color_b>:

uint8_t grid_sys_alert_get_color_b(struct grid_sys_model* mod){
	
	return mod->alert_color_blue;
}
    9834:	7a00      	ldrb	r0, [r0, #8]
    9836:	4770      	bx	lr

00009838 <grid_sys_read_hex_char_value>:

uint8_t grid_sys_read_hex_char_value(uint8_t ascii, uint8_t* error_flag){
		
	uint8_t result = 0;
	
	if (ascii>47 && ascii<58){
    9838:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    983c:	b2db      	uxtb	r3, r3
    983e:	2b09      	cmp	r3, #9
    9840:	d905      	bls.n	984e <grid_sys_read_hex_char_value+0x16>
		result = ascii-48;
	}
	else if(ascii>96 && ascii<103){
    9842:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
    9846:	2b05      	cmp	r3, #5
    9848:	d803      	bhi.n	9852 <grid_sys_read_hex_char_value+0x1a>
		result = ascii - 97 + 10;
    984a:	3857      	subs	r0, #87	; 0x57
    984c:	b2c3      	uxtb	r3, r0
			*error_flag = ascii;
		}
	}
	
	return result;	
}
    984e:	4618      	mov	r0, r3
    9850:	4770      	bx	lr
		if (error_flag != NULL){
    9852:	b111      	cbz	r1, 985a <grid_sys_read_hex_char_value+0x22>
			*error_flag = ascii;
    9854:	7008      	strb	r0, [r1, #0]
	uint8_t result = 0;
    9856:	2300      	movs	r3, #0
    9858:	e7f9      	b.n	984e <grid_sys_read_hex_char_value+0x16>
    985a:	460b      	mov	r3, r1
    985c:	e7f7      	b.n	984e <grid_sys_read_hex_char_value+0x16>
	...

00009860 <grid_sys_read_hex_string_value>:

uint32_t grid_sys_read_hex_string_value(uint8_t* start_location, uint8_t length, uint8_t* error_flag){
    9860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	uint32_t result  = 0;
	
	for(uint8_t i=0; i<length; i++){
		
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    9862:	4f08      	ldr	r7, [pc, #32]	; (9884 <grid_sys_read_hex_string_value+0x24>)
    9864:	1e45      	subs	r5, r0, #1
    9866:	008c      	lsls	r4, r1, #2
	uint32_t result  = 0;
    9868:	2600      	movs	r6, #0
	for(uint8_t i=0; i<length; i++){
    986a:	3c04      	subs	r4, #4
    986c:	1d23      	adds	r3, r4, #4
    986e:	d101      	bne.n	9874 <grid_sys_read_hex_string_value+0x14>

		
	}

	return result;
}
    9870:	4630      	mov	r0, r6
    9872:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    9874:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    9878:	4611      	mov	r1, r2
    987a:	47b8      	blx	r7
    987c:	40a0      	lsls	r0, r4
    987e:	4406      	add	r6, r0
	for(uint8_t i=0; i<length; i++){
    9880:	e7f3      	b.n	986a <grid_sys_read_hex_string_value+0xa>
    9882:	bf00      	nop
    9884:	00009839 	.word	0x00009839

00009888 <grid_sys_write_hex_string_value>:

void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    9888:	b530      	push	{r4, r5, lr}
    988a:	b085      	sub	sp, #20
	
	uint8_t str[10];
	
	sprintf(str, "%08x", value);
    988c:	4b0a      	ldr	r3, [pc, #40]	; (98b8 <grid_sys_write_hex_string_value+0x30>)
void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    988e:	460c      	mov	r4, r1
    9890:	4605      	mov	r5, r0
	sprintf(str, "%08x", value);
    9892:	490a      	ldr	r1, [pc, #40]	; (98bc <grid_sys_write_hex_string_value+0x34>)
    9894:	a801      	add	r0, sp, #4
    9896:	4798      	blx	r3
		
	for(uint8_t i=0; i<size; i++){	
    9898:	aa01      	add	r2, sp, #4
    989a:	f1c4 0308 	rsb	r3, r4, #8
    989e:	4413      	add	r3, r2
    98a0:	2200      	movs	r2, #0
    98a2:	b2d1      	uxtb	r1, r2
    98a4:	428c      	cmp	r4, r1
    98a6:	d801      	bhi.n	98ac <grid_sys_write_hex_string_value+0x24>
		start_location[i] = str[8-size+i];	
	}

}
    98a8:	b005      	add	sp, #20
    98aa:	bd30      	pop	{r4, r5, pc}
		start_location[i] = str[8-size+i];	
    98ac:	f813 1b01 	ldrb.w	r1, [r3], #1
    98b0:	54a9      	strb	r1, [r5, r2]
	for(uint8_t i=0; i<size; i++){	
    98b2:	3201      	adds	r2, #1
    98b4:	e7f5      	b.n	98a2 <grid_sys_write_hex_string_value+0x1a>
    98b6:	bf00      	nop
    98b8:	000147d1 	.word	0x000147d1
    98bc:	00016a35 	.word	0x00016a35

000098c0 <grid_sys_get_id>:



uint32_t grid_sys_get_id(uint32_t* return_array){
			
	return_array[0] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_0);
    98c0:	4b06      	ldr	r3, [pc, #24]	; (98dc <grid_sys_get_id+0x1c>)
    98c2:	681b      	ldr	r3, [r3, #0]
    98c4:	6003      	str	r3, [r0, #0]
	return_array[1] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_1);
    98c6:	4b06      	ldr	r3, [pc, #24]	; (98e0 <grid_sys_get_id+0x20>)
    98c8:	681b      	ldr	r3, [r3, #0]
    98ca:	6043      	str	r3, [r0, #4]
	return_array[2] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_2);
    98cc:	4b05      	ldr	r3, [pc, #20]	; (98e4 <grid_sys_get_id+0x24>)
    98ce:	681b      	ldr	r3, [r3, #0]
    98d0:	6083      	str	r3, [r0, #8]
	return_array[3] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_3);
    98d2:	4b05      	ldr	r3, [pc, #20]	; (98e8 <grid_sys_get_id+0x28>)
    98d4:	681b      	ldr	r3, [r3, #0]
    98d6:	60c3      	str	r3, [r0, #12]
	
	return 1;
	
}
    98d8:	2001      	movs	r0, #1
    98da:	4770      	bx	lr
    98dc:	008061fc 	.word	0x008061fc
    98e0:	00806010 	.word	0x00806010
    98e4:	00806014 	.word	0x00806014
    98e8:	00806018 	.word	0x00806018

000098ec <grid_sys_get_hwcfg>:

uint32_t grid_sys_get_hwcfg(){
    98ec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	// Read the register for the first time, then later just return the saved value

	if (grid_sys_hwfcg == -1){
    98f0:	4e30      	ldr	r6, [pc, #192]	; (99b4 <grid_sys_get_hwcfg+0xc8>)
    98f2:	6833      	ldr	r3, [r6, #0]
    98f4:	3301      	adds	r3, #1
    98f6:	d158      	bne.n	99aa <grid_sys_get_hwcfg+0xbe>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    98f8:	4c2f      	ldr	r4, [pc, #188]	; (99b8 <grid_sys_get_hwcfg+0xcc>)
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    98fa:	4b30      	ldr	r3, [pc, #192]	; (99bc <grid_sys_get_hwcfg+0xd0>)
		gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
		gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
			
		// LOAD DATA
		gpio_set_pin_level(HWCFG_SHIFT, 0);
		delay_ms(1);
    98fc:	4f30      	ldr	r7, [pc, #192]	; (99c0 <grid_sys_get_hwcfg+0xd4>)
	CRITICAL_SECTION_ENTER();
    98fe:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 99cc <grid_sys_get_hwcfg+0xe0>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9902:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    9906:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    990a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    990e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9912:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    9916:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    991a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    991e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    9922:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
    9926:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    992a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    992e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9932:	4b24      	ldr	r3, [pc, #144]	; (99c4 <grid_sys_get_hwcfg+0xd8>)
    9934:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9938:	f1a3 2380 	sub.w	r3, r3, #2147516416	; 0x80008000
    993c:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9940:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9942:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    9946:	47b8      	blx	r7
    9948:	f04f 0a00 	mov.w	sl, #0
			
			
			
		uint8_t hwcfg_value = 0;
    994c:	46d3      	mov	fp, sl
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    994e:	46a8      	mov	r8, r5
			
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
				
			// SHIFT DATA
			gpio_set_pin_level(HWCFG_SHIFT, 1); //This outputs the first value to HWCFG_DATA
			delay_ms(1);
    9950:	2001      	movs	r0, #1
    9952:	f8c4 8098 	str.w	r8, [r4, #152]	; 0x98
    9956:	47b8      	blx	r7
    9958:	a801      	add	r0, sp, #4
    995a:	47c8      	blx	r9
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    995c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    9960:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    9964:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    9968:	405d      	eors	r5, r3
    996a:	4015      	ands	r5, r2
    996c:	405d      	eors	r5, r3
	CRITICAL_SECTION_LEAVE();
    996e:	a801      	add	r0, sp, #4
    9970:	4b15      	ldr	r3, [pc, #84]	; (99c8 <grid_sys_get_hwcfg+0xdc>)
    9972:	4798      	blx	r3
				
				
			if(gpio_get_pin_level(HWCFG_DATA)){
    9974:	042b      	lsls	r3, r5, #16
					
				hwcfg_value |= (1<<i);
    9976:	bf41      	itttt	mi
    9978:	2301      	movmi	r3, #1
    997a:	fa03 f30a 	lslmi.w	r3, r3, sl
    997e:	ea43 0b0b 	orrmi.w	fp, r3, fp
    9982:	fa5f fb8b 	uxtbmi.w	fp, fp
				}else{
					
					
			}
				
			if(i!=7){
    9986:	f1ba 0f07 	cmp.w	sl, #7
    998a:	d007      	beq.n	999c <grid_sys_get_hwcfg+0xb0>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    998c:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    9990:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
					
				// Clock rise
				gpio_set_pin_level(HWCFG_CLOCK, 1);
					
				delay_ms(1);
    9994:	2001      	movs	r0, #1
    9996:	47b8      	blx	r7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9998:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
    999c:	f10a 0a01 	add.w	sl, sl, #1
    99a0:	f1ba 0f08 	cmp.w	sl, #8
    99a4:	d1d4      	bne.n	9950 <grid_sys_get_hwcfg+0x64>
				gpio_set_pin_level(HWCFG_CLOCK, 0);
			}
							
		}
		
		grid_sys_hwfcg = hwcfg_value;
    99a6:	f8c6 b000 	str.w	fp, [r6]
	}

	
	return grid_sys_hwfcg;

}
    99aa:	6830      	ldr	r0, [r6, #0]
    99ac:	b003      	add	sp, #12
    99ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    99b2:	bf00      	nop
    99b4:	2000034c 	.word	0x2000034c
    99b8:	41008000 	.word	0x41008000
    99bc:	40002000 	.word	0x40002000
    99c0:	0000dc95 	.word	0x0000dc95
    99c4:	40028000 	.word	0x40028000
    99c8:	00011a1f 	.word	0x00011a1f
    99cc:	00011a11 	.word	0x00011a11

000099d0 <grid_msg_calculate_checksum_of_packet_string>:
	grid_sys_ping(&GRID_PORT_S);
	grid_sys_ping(&GRID_PORT_W);
	
}

uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    99d0:	b510      	push	{r4, lr}
	
	uint8_t checksum = 0;
	for (uint32_t i=0; i<length-3; i++){
    99d2:	2300      	movs	r3, #0
uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    99d4:	4602      	mov	r2, r0
	for (uint32_t i=0; i<length-3; i++){
    99d6:	3903      	subs	r1, #3
	uint8_t checksum = 0;
    99d8:	4618      	mov	r0, r3
	for (uint32_t i=0; i<length-3; i++){
    99da:	4299      	cmp	r1, r3
    99dc:	d800      	bhi.n	99e0 <grid_msg_calculate_checksum_of_packet_string+0x10>
		checksum ^= str[i];
	}
	
	return checksum;
	
}
    99de:	bd10      	pop	{r4, pc}
		checksum ^= str[i];
    99e0:	5cd4      	ldrb	r4, [r2, r3]
	for (uint32_t i=0; i<length-3; i++){
    99e2:	3301      	adds	r3, #1
		checksum ^= str[i];
    99e4:	4060      	eors	r0, r4
	for (uint32_t i=0; i<length-3; i++){
    99e6:	e7f8      	b.n	99da <grid_msg_calculate_checksum_of_packet_string+0xa>

000099e8 <grid_msg_checksum_read>:
	return checksum;
	
}


uint8_t grid_msg_checksum_read(uint8_t* str, uint32_t length){
    99e8:	b507      	push	{r0, r1, r2, lr}
	uint8_t error_flag;
	return grid_sys_read_hex_string_value(&str[length-3], 2, &error_flag);
    99ea:	1ecb      	subs	r3, r1, #3
    99ec:	f10d 0207 	add.w	r2, sp, #7
    99f0:	2102      	movs	r1, #2
    99f2:	4418      	add	r0, r3
    99f4:	4b02      	ldr	r3, [pc, #8]	; (9a00 <grid_msg_checksum_read+0x18>)
    99f6:	4798      	blx	r3
}
    99f8:	b2c0      	uxtb	r0, r0
    99fa:	b003      	add	sp, #12
    99fc:	f85d fb04 	ldr.w	pc, [sp], #4
    9a00:	00009861 	.word	0x00009861

00009a04 <grid_msg_checksum_write>:
// 	sprintf(checksum_string, "%02x", checksum);
// 
// 	message[length-3] = checksum_string[0];
// 	message[length-2] = checksum_string[1];
	
	grid_sys_write_hex_string_value(&message[length-3], 2, checksum);
    9a04:	1ecb      	subs	r3, r1, #3
    9a06:	4418      	add	r0, r3
    9a08:	2102      	movs	r1, #2
    9a0a:	4b01      	ldr	r3, [pc, #4]	; (9a10 <grid_msg_checksum_write+0xc>)
    9a0c:	4718      	bx	r3
    9a0e:	bf00      	nop
    9a10:	00009889 	.word	0x00009889

00009a14 <grid_msg_get_parameter>:
}


// MESSAGE PARAMETER FUNCTIONS

uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    9a14:	b410      	push	{r4}
    9a16:	460c      	mov	r4, r1
		
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    9a18:	4420      	add	r0, r4
uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    9a1a:	4611      	mov	r1, r2
}
    9a1c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    9a20:	461a      	mov	r2, r3
    9a22:	4b01      	ldr	r3, [pc, #4]	; (9a28 <grid_msg_get_parameter+0x14>)
    9a24:	4718      	bx	r3
    9a26:	bf00      	nop
    9a28:	00009861 	.word	0x00009861

00009a2c <grid_msg_set_parameter>:

uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    9a2c:	b510      	push	{r4, lr}
    9a2e:	460c      	mov	r4, r1
	
	grid_sys_write_hex_string_value(&message[offset], length, value);
    9a30:	4420      	add	r0, r4
uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    9a32:	4611      	mov	r1, r2
	grid_sys_write_hex_string_value(&message[offset], length, value);
    9a34:	461a      	mov	r2, r3
    9a36:	4b01      	ldr	r3, [pc, #4]	; (9a3c <grid_msg_set_parameter+0x10>)
    9a38:	4798      	blx	r3
	
}
    9a3a:	bd10      	pop	{r4, pc}
    9a3c:	00009889 	.word	0x00009889

00009a40 <grid_msg_find_recent>:

uint8_t grid_msg_find_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
    //uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9a40:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9a44:	30ac      	adds	r0, #172	; 0xac
		
		if (model->recent_messages[i%GRID_SYS_RECENT_MESSAGES_LENGTH] == fingerprint){
    9a46:	f853 2b04 	ldr.w	r2, [r3], #4
    9a4a:	428a      	cmp	r2, r1
    9a4c:	d003      	beq.n	9a56 <grid_msg_find_recent+0x16>
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9a4e:	4283      	cmp	r3, r0
    9a50:	d1f9      	bne.n	9a46 <grid_msg_find_recent+0x6>
			
		}
		
	}
	
	return 0;
    9a52:	2000      	movs	r0, #0
    9a54:	4770      	bx	lr
			return 1;
    9a56:	2001      	movs	r0, #1
}
    9a58:	4770      	bx	lr

00009a5a <grid_msg_push_recent>:

void grid_msg_push_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
	model->recent_messages_index+=1;
    9a5a:	f890 30ac 	ldrb.w	r3, [r0, #172]	; 0xac
    9a5e:	3301      	adds	r3, #1
	model->recent_messages_index%=GRID_SYS_RECENT_MESSAGES_LENGTH;
    9a60:	f003 031f 	and.w	r3, r3, #31
    9a64:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
	
	model->recent_messages[model->recent_messages_index] = fingerprint;
    9a68:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    9a6c:	62c1      	str	r1, [r0, #44]	; 0x2c
	
}
    9a6e:	4770      	bx	lr

00009a70 <grid_ui_model_init>:
	}
	
}


void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a70:	b538      	push	{r3, r4, r5, lr}
	
	mod->status = GRID_UI_STATUS_INITIALIZED;
    9a72:	2301      	movs	r3, #1
    9a74:	7003      	strb	r3, [r0, #0]
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a76:	4605      	mov	r5, r0
	
	mod->bank_list_length = bank_list_length;	
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a78:	4b09      	ldr	r3, [pc, #36]	; (9aa0 <grid_ui_model_init+0x30>)
	mod->bank_list_length = bank_list_length;	
    9a7a:	7041      	strb	r1, [r0, #1]
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a7c:	0108      	lsls	r0, r1, #4
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9a7e:	460c      	mov	r4, r1
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a80:	4798      	blx	r3
	
	for(uint8_t i=0; i<bank_list_length; i++){
    9a82:	2300      	movs	r3, #0
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9a84:	6068      	str	r0, [r5, #4]
		
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9a86:	461a      	mov	r2, r3
	for(uint8_t i=0; i<bank_list_length; i++){
    9a88:	b2d9      	uxtb	r1, r3
    9a8a:	428c      	cmp	r4, r1
    9a8c:	f100 0010 	add.w	r0, r0, #16
    9a90:	d800      	bhi.n	9a94 <grid_ui_model_init+0x24>
		mod->bank_list[i].element_list_length = 0;
		
	}
	
}
    9a92:	bd38      	pop	{r3, r4, r5, pc}
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9a94:	f800 2c10 	strb.w	r2, [r0, #-16]
		mod->bank_list[i].element_list_length = 0;
    9a98:	f800 2c07 	strb.w	r2, [r0, #-7]
	for(uint8_t i=0; i<bank_list_length; i++){
    9a9c:	3301      	adds	r3, #1
    9a9e:	e7f3      	b.n	9a88 <grid_ui_model_init+0x18>
    9aa0:	00014021 	.word	0x00014021

00009aa4 <grid_ui_bank_init>:

void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9aa4:	b538      	push	{r3, r4, r5, lr}
	
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9aa6:	6843      	ldr	r3, [r0, #4]
    9aa8:	eb03 1501 	add.w	r5, r3, r1, lsl #4
void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9aac:	4614      	mov	r4, r2
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9aae:	010a      	lsls	r2, r1, #4
	bank->parent = parent;
    9ab0:	6068      	str	r0, [r5, #4]
	bank->index = index;
    9ab2:	7229      	strb	r1, [r5, #8]
	
	
	bank->status = GRID_UI_STATUS_INITIALIZED;
	
	bank->element_list_length = element_list_length;
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9ab4:	2064      	movs	r0, #100	; 0x64
	bank->status = GRID_UI_STATUS_INITIALIZED;
    9ab6:	2101      	movs	r1, #1
    9ab8:	5499      	strb	r1, [r3, r2]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9aba:	4360      	muls	r0, r4
    9abc:	4b08      	ldr	r3, [pc, #32]	; (9ae0 <grid_ui_bank_init+0x3c>)
	bank->element_list_length = element_list_length;
    9abe:	726c      	strb	r4, [r5, #9]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9ac0:	4798      	blx	r3
	
	for(uint8_t i=0; i<element_list_length; i++){
    9ac2:	2300      	movs	r3, #0
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9ac4:	60e8      	str	r0, [r5, #12]
		
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9ac6:	461a      	mov	r2, r3
	for(uint8_t i=0; i<element_list_length; i++){
    9ac8:	b2d9      	uxtb	r1, r3
    9aca:	428c      	cmp	r4, r1
    9acc:	f100 0064 	add.w	r0, r0, #100	; 0x64
    9ad0:	d800      	bhi.n	9ad4 <grid_ui_bank_init+0x30>
		bank->element_list[i].event_list_length = 0;
		
	}
	
}
    9ad2:	bd38      	pop	{r3, r4, r5, pc}
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9ad4:	f800 2c64 	strb.w	r2, [r0, #-100]
		bank->element_list[i].event_list_length = 0;
    9ad8:	f800 2c08 	strb.w	r2, [r0, #-8]
	for(uint8_t i=0; i<element_list_length; i++){
    9adc:	3301      	adds	r3, #1
    9ade:	e7f3      	b.n	9ac8 <grid_ui_bank_init+0x24>
    9ae0:	00014021 	.word	0x00014021

00009ae4 <grid_ui_nvm_store_all_configuration>:
	
}



void grid_ui_nvm_store_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9ae4:	460b      	mov	r3, r1
	
    grid_nvm_ui_bulk_store_init(nvm, ui);
    9ae6:	4601      	mov	r1, r0
    9ae8:	4618      	mov	r0, r3
    9aea:	4b01      	ldr	r3, [pc, #4]	; (9af0 <grid_ui_nvm_store_all_configuration+0xc>)
    9aec:	4718      	bx	r3
    9aee:	bf00      	nop
    9af0:	00008935 	.word	0x00008935

00009af4 <grid_ui_nvm_load_all_configuration>:

}

void grid_ui_nvm_load_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9af4:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_read_init(nvm, ui);
    9af6:	4601      	mov	r1, r0
    9af8:	4618      	mov	r0, r3
    9afa:	4b01      	ldr	r3, [pc, #4]	; (9b00 <grid_ui_nvm_load_all_configuration+0xc>)
    9afc:	4718      	bx	r3
    9afe:	bf00      	nop
    9b00:	00008821 	.word	0x00008821

00009b04 <grid_ui_nvm_clear_all_configuration>:

		
	
}

void grid_ui_nvm_clear_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9b04:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_clear_init(nvm, ui);
    9b06:	4601      	mov	r1, r0
    9b08:	4618      	mov	r0, r3
    9b0a:	4b01      	ldr	r3, [pc, #4]	; (9b10 <grid_ui_nvm_clear_all_configuration+0xc>)
    9b0c:	4718      	bx	r3
    9b0e:	bf00      	nop
    9b10:	00008af9 	.word	0x00008af9

00009b14 <grid_ui_recall_event_configuration>:

}


uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9b14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9b18:	4698      	mov	r8, r3
	
	struct grid_ui_element* ele = NULL;
	struct grid_ui_event* eve = NULL;
	uint8_t event_index = 255;
	
	if (bank < ui->bank_list_length){
    9b1a:	7843      	ldrb	r3, [r0, #1]
    9b1c:	428b      	cmp	r3, r1
uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9b1e:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
    9b22:	460e      	mov	r6, r1
    9b24:	4615      	mov	r5, r2
	if (bank < ui->bank_list_length){
    9b26:	f240 8082 	bls.w	9c2e <grid_ui_recall_event_configuration+0x11a>
		
		if (element < ui->bank_list[bank].element_list_length){
    9b2a:	6843      	ldr	r3, [r0, #4]
    9b2c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    9b30:	7a5a      	ldrb	r2, [r3, #9]
    9b32:	42aa      	cmp	r2, r5
    9b34:	d97b      	bls.n	9c2e <grid_ui_recall_event_configuration+0x11a>
			
			ele = &ui->bank_list[bank].element_list[element];
    9b36:	68da      	ldr	r2, [r3, #12]
    9b38:	2364      	movs	r3, #100	; 0x64
    9b3a:	fb05 2303 	mla	r3, r5, r3, r2
			
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9b3e:	2200      	movs	r2, #0
    9b40:	f893 c05c 	ldrb.w	ip, [r3, #92]	; 0x5c
	uint8_t event_index = 255;
    9b44:	20ff      	movs	r0, #255	; 0xff
	struct grid_ui_event* eve = NULL;
    9b46:	4614      	mov	r4, r2
				if (ele->event_list[i].type == event_type){
    9b48:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9b4c:	b2d7      	uxtb	r7, r2
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9b4e:	45bc      	cmp	ip, r7
    9b50:	d862      	bhi.n	9c18 <grid_ui_recall_event_configuration+0x104>
		
		
	}
	
	
	if (event_index != 255){ // OK
    9b52:	28ff      	cmp	r0, #255	; 0xff
    9b54:	d06b      	beq.n	9c2e <grid_ui_recall_event_configuration+0x11a>
		
		struct grid_msg message;

		grid_msg_init(&message);
    9b56:	4b5b      	ldr	r3, [pc, #364]	; (9cc4 <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b58:	4d5b      	ldr	r5, [pc, #364]	; (9cc8 <grid_ui_recall_event_configuration+0x1b4>)
		uint32_t offset = 0;



		// BANK ENABLED
		offset = grid_msg_body_get_length(&message);
    9b5a:	f8df a190 	ldr.w	sl, [pc, #400]	; 9cec <grid_ui_recall_event_configuration+0x1d8>

		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b5e:	f8df 9190 	ldr.w	r9, [pc, #400]	; 9cf0 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9b62:	f8df 8190 	ldr.w	r8, [pc, #400]	; 9cf4 <grid_ui_recall_event_configuration+0x1e0>

		grid_msg_body_append_text(&message, payload, payload_length);
    9b66:	4f59      	ldr	r7, [pc, #356]	; (9ccc <grid_ui_recall_event_configuration+0x1b8>)

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9b68:	4e59      	ldr	r6, [pc, #356]	; (9cd0 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9b6a:	a867      	add	r0, sp, #412	; 0x19c
    9b6c:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b6e:	227f      	movs	r2, #127	; 0x7f
    9b70:	4611      	mov	r1, r2
    9b72:	2300      	movs	r3, #0
    9b74:	a867      	add	r0, sp, #412	; 0x19c
    9b76:	47a8      	blx	r5
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9b78:	2100      	movs	r1, #0
    9b7a:	4b56      	ldr	r3, [pc, #344]	; (9cd4 <grid_ui_recall_event_configuration+0x1c0>)
    9b7c:	9103      	str	r1, [sp, #12]
    9b7e:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9b82:	a804      	add	r0, sp, #16
    9b84:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9b86:	a867      	add	r0, sp, #412	; 0x19c
    9b88:	47d0      	blx	sl
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b8a:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9b8c:	4605      	mov	r5, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9b8e:	4952      	ldr	r1, [pc, #328]	; (9cd8 <grid_ui_recall_event_configuration+0x1c4>)
    9b90:	2202      	movs	r2, #2
    9b92:	a803      	add	r0, sp, #12
    9b94:	47c8      	blx	r9
		payload_length = strlen(payload);
    9b96:	a803      	add	r0, sp, #12
    9b98:	47c0      	blx	r8
		grid_msg_body_append_text(&message, payload, payload_length);
    9b9a:	a903      	add	r1, sp, #12
    9b9c:	b2c2      	uxtb	r2, r0
    9b9e:	a867      	add	r0, sp, #412	; 0x19c
    9ba0:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9ba2:	230d      	movs	r3, #13
    9ba4:	9300      	str	r3, [sp, #0]
    9ba6:	2204      	movs	r2, #4
    9ba8:	2301      	movs	r3, #1
    9baa:	4629      	mov	r1, r5
    9bac:	a867      	add	r0, sp, #412	; 0x19c
    9bae:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9bb0:	6863      	ldr	r3, [r4, #4]
    9bb2:	685b      	ldr	r3, [r3, #4]
    9bb4:	7a1b      	ldrb	r3, [r3, #8]
    9bb6:	9300      	str	r3, [sp, #0]
    9bb8:	2205      	movs	r2, #5
    9bba:	2302      	movs	r3, #2
    9bbc:	4629      	mov	r1, r5
    9bbe:	a867      	add	r0, sp, #412	; 0x19c
    9bc0:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9bc2:	6863      	ldr	r3, [r4, #4]
    9bc4:	7a1b      	ldrb	r3, [r3, #8]
    9bc6:	9300      	str	r3, [sp, #0]
    9bc8:	2207      	movs	r2, #7
    9bca:	2302      	movs	r3, #2
    9bcc:	4629      	mov	r1, r5
    9bce:	a867      	add	r0, sp, #412	; 0x19c
    9bd0:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9bd2:	7aa3      	ldrb	r3, [r4, #10]
    9bd4:	9300      	str	r3, [sp, #0]
    9bd6:	2209      	movs	r2, #9
    9bd8:	2302      	movs	r3, #2
    9bda:	4629      	mov	r1, r5
    9bdc:	a867      	add	r0, sp, #412	; 0x19c
    9bde:	47b0      	blx	r6

		offset = grid_msg_body_get_length(&message);
    9be0:	a867      	add	r0, sp, #412	; 0x19c
    9be2:	47d0      	blx	sl
		grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9be4:	4b3d      	ldr	r3, [pc, #244]	; (9cdc <grid_ui_recall_event_configuration+0x1c8>)
    9be6:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9be8:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9bec:	a867      	add	r0, sp, #412	; 0x19c
    9bee:	4798      	blx	r3





		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9bf0:	493b      	ldr	r1, [pc, #236]	; (9ce0 <grid_ui_recall_event_configuration+0x1cc>)
    9bf2:	2203      	movs	r2, #3
    9bf4:	a803      	add	r0, sp, #12
    9bf6:	47c8      	blx	r9
		payload_length = strlen(payload);
    9bf8:	a803      	add	r0, sp, #12
    9bfa:	47c0      	blx	r8

		grid_msg_body_append_text(&message, payload, payload_length);
    9bfc:	a903      	add	r1, sp, #12
    9bfe:	b2c2      	uxtb	r2, r0
    9c00:	a867      	add	r0, sp, #412	; 0x19c
    9c02:	47b8      	blx	r7
		payload_length = strlen(payload);

		grid_msg_body_append_text(&message, payload, payload_length);


		grid_msg_packet_close(&message);
    9c04:	4b37      	ldr	r3, [pc, #220]	; (9ce4 <grid_ui_recall_event_configuration+0x1d0>)
    9c06:	a867      	add	r0, sp, #412	; 0x19c
    9c08:	4798      	blx	r3
		grid_msg_packet_send_everywhere(&message);		
    9c0a:	4b37      	ldr	r3, [pc, #220]	; (9ce8 <grid_ui_recall_event_configuration+0x1d4>)
    9c0c:	a867      	add	r0, sp, #412	; 0x19c
    9c0e:	4798      	blx	r3
		
		
	}

	
}
    9c10:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9c14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (ele->event_list[i].type == event_type){
    9c18:	6e19      	ldr	r1, [r3, #96]	; 0x60
    9c1a:	fb0e 1102 	mla	r1, lr, r2, r1
    9c1e:	3201      	adds	r2, #1
    9c20:	f891 900a 	ldrb.w	r9, [r1, #10]
    9c24:	45c1      	cmp	r9, r8
    9c26:	bf04      	itt	eq
    9c28:	4638      	moveq	r0, r7
    9c2a:	460c      	moveq	r4, r1
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9c2c:	e78e      	b.n	9b4c <grid_ui_recall_event_configuration+0x38>
		grid_msg_init(&message);
    9c2e:	a867      	add	r0, sp, #412	; 0x19c
    9c30:	4b24      	ldr	r3, [pc, #144]	; (9cc4 <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9c32:	4c25      	ldr	r4, [pc, #148]	; (9cc8 <grid_ui_recall_event_configuration+0x1b4>)
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c34:	f8df b0b8 	ldr.w	fp, [pc, #184]	; 9cf0 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9c38:	f8df a0b8 	ldr.w	sl, [pc, #184]	; 9cf4 <grid_ui_recall_event_configuration+0x1e0>
		grid_msg_body_append_text(&message, payload, payload_length);
    9c3c:	f8df 908c 	ldr.w	r9, [pc, #140]	; 9ccc <grid_ui_recall_event_configuration+0x1b8>
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9c40:	4f23      	ldr	r7, [pc, #140]	; (9cd0 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9c42:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9c44:	227f      	movs	r2, #127	; 0x7f
    9c46:	4611      	mov	r1, r2
    9c48:	a867      	add	r0, sp, #412	; 0x19c
    9c4a:	2300      	movs	r3, #0
    9c4c:	47a0      	blx	r4
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9c4e:	2100      	movs	r1, #0
    9c50:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9c54:	4b1f      	ldr	r3, [pc, #124]	; (9cd4 <grid_ui_recall_event_configuration+0x1c0>)
    9c56:	9103      	str	r1, [sp, #12]
    9c58:	a804      	add	r0, sp, #16
    9c5a:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9c5c:	4b23      	ldr	r3, [pc, #140]	; (9cec <grid_ui_recall_event_configuration+0x1d8>)
    9c5e:	a867      	add	r0, sp, #412	; 0x19c
    9c60:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c62:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9c64:	4604      	mov	r4, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9c66:	491c      	ldr	r1, [pc, #112]	; (9cd8 <grid_ui_recall_event_configuration+0x1c4>)
    9c68:	2202      	movs	r2, #2
    9c6a:	a803      	add	r0, sp, #12
    9c6c:	47d8      	blx	fp
		payload_length = strlen(payload);
    9c6e:	a803      	add	r0, sp, #12
    9c70:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    9c72:	a903      	add	r1, sp, #12
    9c74:	b2c2      	uxtb	r2, r0
    9c76:	a867      	add	r0, sp, #412	; 0x19c
    9c78:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9c7a:	230b      	movs	r3, #11
    9c7c:	9300      	str	r3, [sp, #0]
    9c7e:	4621      	mov	r1, r4
    9c80:	a867      	add	r0, sp, #412	; 0x19c
    9c82:	2301      	movs	r3, #1
    9c84:	2204      	movs	r2, #4
    9c86:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, bank);
    9c88:	4621      	mov	r1, r4
    9c8a:	a867      	add	r0, sp, #412	; 0x19c
    9c8c:	9600      	str	r6, [sp, #0]
    9c8e:	2302      	movs	r3, #2
    9c90:	2205      	movs	r2, #5
    9c92:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, element);
    9c94:	4621      	mov	r1, r4
    9c96:	a867      	add	r0, sp, #412	; 0x19c
    9c98:	9500      	str	r5, [sp, #0]
    9c9a:	2302      	movs	r3, #2
    9c9c:	2207      	movs	r2, #7
    9c9e:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, event_type);
    9ca0:	2302      	movs	r3, #2
    9ca2:	4621      	mov	r1, r4
    9ca4:	a867      	add	r0, sp, #412	; 0x19c
    9ca6:	f8cd 8000 	str.w	r8, [sp]
    9caa:	2209      	movs	r2, #9
    9cac:	47b8      	blx	r7
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9cae:	490c      	ldr	r1, [pc, #48]	; (9ce0 <grid_ui_recall_event_configuration+0x1cc>)
    9cb0:	2203      	movs	r2, #3
    9cb2:	a803      	add	r0, sp, #12
    9cb4:	47d8      	blx	fp
		payload_length = strlen(payload);
    9cb6:	a803      	add	r0, sp, #12
    9cb8:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    9cba:	a903      	add	r1, sp, #12
    9cbc:	b2c2      	uxtb	r2, r0
    9cbe:	a867      	add	r0, sp, #412	; 0x19c
    9cc0:	47c8      	blx	r9
    9cc2:	e79f      	b.n	9c04 <grid_ui_recall_event_configuration+0xf0>
    9cc4:	000085c5 	.word	0x000085c5
    9cc8:	000085f9 	.word	0x000085f9
    9ccc:	00008535 	.word	0x00008535
    9cd0:	000085a9 	.word	0x000085a9
    9cd4:	00014175 	.word	0x00014175
    9cd8:	00016add 	.word	0x00016add
    9cdc:	00008555 	.word	0x00008555
    9ce0:	0001674f 	.word	0x0001674f
    9ce4:	000086f1 	.word	0x000086f1
    9ce8:	000087c5 	.word	0x000087c5
    9cec:	0000852f 	.word	0x0000852f
    9cf0:	000147d1 	.word	0x000147d1
    9cf4:	00014c81 	.word	0x00014c81

00009cf8 <grid_ui_nvm_store_event_configuration>:



uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9cfc:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
	

	struct grid_msg message;

	grid_msg_init(&message);
    9d00:	4b52      	ldr	r3, [pc, #328]	; (9e4c <grid_ui_nvm_store_event_configuration+0x154>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9d02:	4e53      	ldr	r6, [pc, #332]	; (9e50 <grid_ui_nvm_store_event_configuration+0x158>)
	uint32_t offset = 0;



	// BANK ENABLED
	offset = grid_msg_body_get_length(&message);
    9d04:	f8df b178 	ldr.w	fp, [pc, #376]	; 9e80 <grid_ui_nvm_store_event_configuration+0x188>

	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9d08:	f8df a178 	ldr.w	sl, [pc, #376]	; 9e84 <grid_ui_nvm_store_event_configuration+0x18c>
	payload_length = strlen(payload);

	grid_msg_body_append_text(&message, payload, payload_length);
    9d0c:	f8df 9178 	ldr.w	r9, [pc, #376]	; 9e88 <grid_ui_nvm_store_event_configuration+0x190>

	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9d10:	f8df 8178 	ldr.w	r8, [pc, #376]	; 9e8c <grid_ui_nvm_store_event_configuration+0x194>
	grid_msg_init(&message);
    9d14:	a867      	add	r0, sp, #412	; 0x19c
uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9d16:	4614      	mov	r4, r2
    9d18:	460d      	mov	r5, r1
	grid_msg_init(&message);
    9d1a:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9d1c:	22ff      	movs	r2, #255	; 0xff
    9d1e:	4611      	mov	r1, r2
    9d20:	2300      	movs	r3, #0
    9d22:	a867      	add	r0, sp, #412	; 0x19c
    9d24:	47b0      	blx	r6
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9d26:	2600      	movs	r6, #0
    9d28:	4b4a      	ldr	r3, [pc, #296]	; (9e54 <grid_ui_nvm_store_event_configuration+0x15c>)
    9d2a:	9603      	str	r6, [sp, #12]
    9d2c:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9d30:	4631      	mov	r1, r6
    9d32:	a804      	add	r0, sp, #16
    9d34:	4798      	blx	r3
	offset = grid_msg_body_get_length(&message);
    9d36:	a867      	add	r0, sp, #412	; 0x19c
    9d38:	47d8      	blx	fp
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9d3a:	4947      	ldr	r1, [pc, #284]	; (9e58 <grid_ui_nvm_store_event_configuration+0x160>)
	offset = grid_msg_body_get_length(&message);
    9d3c:	4607      	mov	r7, r0
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9d3e:	2202      	movs	r2, #2
    9d40:	2380      	movs	r3, #128	; 0x80
    9d42:	a803      	add	r0, sp, #12
    9d44:	47d0      	blx	sl
	payload_length = strlen(payload);
    9d46:	4b45      	ldr	r3, [pc, #276]	; (9e5c <grid_ui_nvm_store_event_configuration+0x164>)
    9d48:	a803      	add	r0, sp, #12
    9d4a:	4798      	blx	r3
	grid_msg_body_append_text(&message, payload, payload_length);
    9d4c:	a903      	add	r1, sp, #12
    9d4e:	b2c2      	uxtb	r2, r0
    9d50:	a867      	add	r0, sp, #412	; 0x19c
    9d52:	47c8      	blx	r9
	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9d54:	230e      	movs	r3, #14
    9d56:	4639      	mov	r1, r7
    9d58:	9300      	str	r3, [sp, #0]
    9d5a:	2204      	movs	r2, #4
    9d5c:	2301      	movs	r3, #1
    9d5e:	a867      	add	r0, sp, #412	; 0x19c
    9d60:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9d62:	6863      	ldr	r3, [r4, #4]
    9d64:	685b      	ldr	r3, [r3, #4]
    9d66:	7a1b      	ldrb	r3, [r3, #8]
    9d68:	9300      	str	r3, [sp, #0]
    9d6a:	4639      	mov	r1, r7
    9d6c:	2302      	movs	r3, #2
    9d6e:	2205      	movs	r2, #5
    9d70:	a867      	add	r0, sp, #412	; 0x19c
    9d72:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9d74:	6863      	ldr	r3, [r4, #4]
    9d76:	7a1b      	ldrb	r3, [r3, #8]
    9d78:	9300      	str	r3, [sp, #0]
    9d7a:	4639      	mov	r1, r7
    9d7c:	2302      	movs	r3, #2
    9d7e:	2207      	movs	r2, #7
    9d80:	a867      	add	r0, sp, #412	; 0x19c
    9d82:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9d84:	7aa3      	ldrb	r3, [r4, #10]
    9d86:	9300      	str	r3, [sp, #0]
    9d88:	4639      	mov	r1, r7
    9d8a:	2302      	movs	r3, #2
    9d8c:	2209      	movs	r2, #9
    9d8e:	a867      	add	r0, sp, #412	; 0x19c
    9d90:	47c0      	blx	r8

	offset = grid_msg_body_get_length(&message);
    9d92:	a867      	add	r0, sp, #412	; 0x19c
    9d94:	47d8      	blx	fp
	grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9d96:	4b32      	ldr	r3, [pc, #200]	; (9e60 <grid_ui_nvm_store_event_configuration+0x168>)
    9d98:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9d9a:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9d9e:	a867      	add	r0, sp, #412	; 0x19c
    9da0:	4798      	blx	r3





	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9da2:	4930      	ldr	r1, [pc, #192]	; (9e64 <grid_ui_nvm_store_event_configuration+0x16c>)
    9da4:	2203      	movs	r2, #3
    9da6:	a803      	add	r0, sp, #12
    9da8:	47d0      	blx	sl
	payload_length = strlen(payload);
    9daa:	4b2c      	ldr	r3, [pc, #176]	; (9e5c <grid_ui_nvm_store_event_configuration+0x164>)
    9dac:	a803      	add	r0, sp, #12
    9dae:	4798      	blx	r3

	grid_msg_body_append_text(&message, payload, payload_length);
    9db0:	a903      	add	r1, sp, #12
    9db2:	b2c2      	uxtb	r2, r0
    9db4:	a867      	add	r0, sp, #412	; 0x19c
    9db6:	47c8      	blx	r9


	grid_msg_packet_close(&message);
    9db8:	4b2b      	ldr	r3, [pc, #172]	; (9e68 <grid_ui_nvm_store_event_configuration+0x170>)
    9dba:	a867      	add	r0, sp, #412	; 0x19c
    9dbc:	4798      	blx	r3

	grid_nvm_clear_write_buffer(nvm);
    9dbe:	4b2b      	ldr	r3, [pc, #172]	; (9e6c <grid_ui_nvm_store_event_configuration+0x174>)
    9dc0:	4628      	mov	r0, r5
    9dc2:	4798      	blx	r3

	uint32_t message_length = grid_msg_packet_get_length(&message);
    9dc4:	4b2a      	ldr	r3, [pc, #168]	; (9e70 <grid_ui_nvm_store_event_configuration+0x178>)
    9dc6:	a867      	add	r0, sp, #412	; 0x19c
    9dc8:	4798      	blx	r3

	if (message_length){
    9dca:	4607      	mov	r7, r0
    9dcc:	b970      	cbnz	r0, 9dec <grid_ui_nvm_store_event_configuration+0xf4>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
		}

	}

	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    9dce:	4621      	mov	r1, r4
    9dd0:	4b28      	ldr	r3, [pc, #160]	; (9e74 <grid_ui_nvm_store_event_configuration+0x17c>)
    9dd2:	4628      	mov	r0, r5
    9dd4:	4798      	blx	r3
	nvm->write_target_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;
    9dd6:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9dda:	0241      	lsls	r1, r0, #9
    9ddc:	f8c5 1420 	str.w	r1, [r5, #1056]	; 0x420
	int status = 0;
	
	
	uint8_t debugtext[200] = {0};

	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    9de0:	f894 60b7 	ldrb.w	r6, [r4, #183]	; 0xb7
    9de4:	2e01      	cmp	r6, #1
    9de6:	d010      	beq.n	9e0a <grid_ui_nvm_store_event_configuration+0x112>
	int status = 0;
    9de8:	2000      	movs	r0, #0
    9dea:	e019      	b.n	9e20 <grid_ui_nvm_store_event_configuration+0x128>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9dec:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 9e90 <grid_ui_nvm_store_event_configuration+0x198>
		nvm->write_buffer_length = message_length;
    9df0:	f8c5 0418 	str.w	r0, [r5, #1048]	; 0x418
		for(uint32_t i = 0; i<message_length; i++){
    9df4:	f505 7806 	add.w	r8, r5, #536	; 0x218
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9df8:	4631      	mov	r1, r6
    9dfa:	a867      	add	r0, sp, #412	; 0x19c
    9dfc:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    9dfe:	3601      	adds	r6, #1
    9e00:	42b7      	cmp	r7, r6
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9e02:	f808 0b01 	strb.w	r0, [r8], #1
		for(uint32_t i = 0; i<message_length; i++){
    9e06:	d1f7      	bne.n	9df8 <grid_ui_nvm_store_event_configuration+0x100>
    9e08:	e7e1      	b.n	9dce <grid_ui_nvm_store_event_configuration+0xd6>
	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    9e0a:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    9e0e:	2b00      	cmp	r3, #0
    9e10:	d1ea      	bne.n	9de8 <grid_ui_nvm_store_event_configuration+0xf0>
		
		//sprintf(debugtext, "Cfg: Default B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);
		flash_erase(nvm->flash, nvm->write_target_address, 1);
    9e12:	6828      	ldr	r0, [r5, #0]
    9e14:	4b18      	ldr	r3, [pc, #96]	; (9e78 <grid_ui_nvm_store_event_configuration+0x180>)
    9e16:	4632      	mov	r2, r6
    9e18:	4798      	blx	r3
		eve->cfg_flashempty_flag = 1;
    9e1a:	f884 60b8 	strb.w	r6, [r4, #184]	; 0xb8
		status = 1;
    9e1e:	4630      	mov	r0, r6
	}
	
	
	if (eve->cfg_default_flag == 0 && eve->cfg_changed_flag == 1){
    9e20:	f8b4 60b6 	ldrh.w	r6, [r4, #182]	; 0xb6
    9e24:	2e01      	cmp	r6, #1
    9e26:	d109      	bne.n	9e3c <grid_ui_nvm_store_event_configuration+0x144>
		
		//sprintf(debugtext, "Cfg: Store B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);		
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, GRID_NVM_PAGE_SIZE);
    9e28:	f8d5 1420 	ldr.w	r1, [r5, #1056]	; 0x420
    9e2c:	6828      	ldr	r0, [r5, #0]
    9e2e:	f505 7206 	add.w	r2, r5, #536	; 0x218
    9e32:	f44f 7300 	mov.w	r3, #512	; 0x200
    9e36:	4d11      	ldr	r5, [pc, #68]	; (9e7c <grid_ui_nvm_store_event_configuration+0x184>)
    9e38:	47a8      	blx	r5
		status = 1;
    9e3a:	4630      	mov	r0, r6
	}


	//grid_debug_print_text(debugtext);

	eve->cfg_changed_flag = 0;
    9e3c:	2300      	movs	r3, #0
    9e3e:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	
	return status;
	
}
    9e42:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9e46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9e4a:	bf00      	nop
    9e4c:	000085c5 	.word	0x000085c5
    9e50:	000085f9 	.word	0x000085f9
    9e54:	00014175 	.word	0x00014175
    9e58:	00016add 	.word	0x00016add
    9e5c:	00014c81 	.word	0x00014c81
    9e60:	00008555 	.word	0x00008555
    9e64:	0001674f 	.word	0x0001674f
    9e68:	000086f1 	.word	0x000086f1
    9e6c:	00008cd1 	.word	0x00008cd1
    9e70:	00008521 	.word	0x00008521
    9e74:	00008d3d 	.word	0x00008d3d
    9e78:	0000ed69 	.word	0x0000ed69
    9e7c:	0000ece9 	.word	0x0000ece9
    9e80:	0000852f 	.word	0x0000852f
    9e84:	000147d1 	.word	0x000147d1
    9e88:	00008535 	.word	0x00008535
    9e8c:	000085a9 	.word	0x000085a9
    9e90:	000086bb 	.word	0x000086bb

00009e94 <grid_ui_nvm_load_event_configuration>:



uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9e94:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
		
	grid_nvm_clear_read_buffer(nvm);
    9e96:	4b19      	ldr	r3, [pc, #100]	; (9efc <grid_ui_nvm_load_event_configuration+0x68>)
uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9e98:	9201      	str	r2, [sp, #4]
    9e9a:	460c      	mov	r4, r1
	grid_nvm_clear_read_buffer(nvm);
    9e9c:	4608      	mov	r0, r1
    9e9e:	4798      	blx	r3
	
	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);	
    9ea0:	9901      	ldr	r1, [sp, #4]
    9ea2:	4b17      	ldr	r3, [pc, #92]	; (9f00 <grid_ui_nvm_load_event_configuration+0x6c>)
    9ea4:	4620      	mov	r0, r4
    9ea6:	4798      	blx	r3
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    9ea8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9eac:	0241      	lsls	r1, r0, #9
	

	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    9eae:	f104 0609 	add.w	r6, r4, #9
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    9eb2:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    9eb6:	6820      	ldr	r0, [r4, #0]
    9eb8:	4c12      	ldr	r4, [pc, #72]	; (9f04 <grid_ui_nvm_load_event_configuration+0x70>)
    9eba:	f44f 7300 	mov.w	r3, #512	; 0x200
    9ebe:	4632      	mov	r2, r6
    9ec0:	47a0      	blx	r4
    9ec2:	2300      	movs	r3, #0
			}
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9ec4:	4c10      	ldr	r4, [pc, #64]	; (9f08 <grid_ui_nvm_load_event_configuration+0x74>)
	uint8_t cfgfound = 0;
    9ec6:	4618      	mov	r0, r3
	uint8_t copydone = 0;
    9ec8:	4619      	mov	r1, r3
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9eca:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    9ece:	1c5a      	adds	r2, r3, #1
    9ed0:	b971      	cbnz	r1, 9ef0 <grid_ui_nvm_load_event_configuration+0x5c>
			if (nvm->read_buffer[i] == '\n'){ // END OF PACKET, copy newline character
    9ed2:	5cf5      	ldrb	r5, [r6, r3]
    9ed4:	2d0a      	cmp	r5, #10
    9ed6:	d106      	bne.n	9ee6 <grid_ui_nvm_load_event_configuration+0x52>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9ed8:	4423      	add	r3, r4
				cfgfound=2;
    9eda:	2002      	movs	r0, #2
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9edc:	55dd      	strb	r5, [r3, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    9ede:	6222      	str	r2, [r4, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    9ee0:	62a1      	str	r1, [r4, #40]	; 0x28
				copydone = 1;
    9ee2:	2101      	movs	r1, #1
    9ee4:	e004      	b.n	9ef0 <grid_ui_nvm_load_event_configuration+0x5c>
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    9ee6:	2dff      	cmp	r5, #255	; 0xff
    9ee8:	d0fb      	beq.n	9ee2 <grid_ui_nvm_load_event_configuration+0x4e>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9eea:	4423      	add	r3, r4
				
				cfgfound=1;
    9eec:	2001      	movs	r0, #1
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    9eee:	55dd      	strb	r5, [r3, r7]
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9ef0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    9ef4:	4613      	mov	r3, r2
    9ef6:	d1ea      	bne.n	9ece <grid_ui_nvm_load_event_configuration+0x3a>
	}
	
	return cfgfound;
	
	
}
    9ef8:	b003      	add	sp, #12
    9efa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9efc:	00008cb1 	.word	0x00008cb1
    9f00:	00008d3d 	.word	0x00008d3d
    9f04:	0000ec7d 	.word	0x0000ec7d
    9f08:	20004acc 	.word	0x20004acc

00009f0c <grid_ui_nvm_clear_event_configuration>:
uint8_t grid_ui_nvm_clear_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    9f0c:	b510      	push	{r4, lr}
    9f0e:	460c      	mov	r4, r1
		
		uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    9f10:	4b06      	ldr	r3, [pc, #24]	; (9f2c <grid_ui_nvm_clear_event_configuration+0x20>)
    9f12:	4611      	mov	r1, r2
    9f14:	4620      	mov	r0, r4
    9f16:	4798      	blx	r3
		
		

		flash_erase(nvm->flash, GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset, 1);
    9f18:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    9f1c:	0241      	lsls	r1, r0, #9
    9f1e:	4b04      	ldr	r3, [pc, #16]	; (9f30 <grid_ui_nvm_clear_event_configuration+0x24>)
    9f20:	6820      	ldr	r0, [r4, #0]
    9f22:	2201      	movs	r2, #1
    9f24:	4798      	blx	r3

		
		
		return 1;
		
}
    9f26:	2001      	movs	r0, #1
    9f28:	bd10      	pop	{r4, pc}
    9f2a:	bf00      	nop
    9f2c:	00008d3d 	.word	0x00008d3d
    9f30:	0000ed69 	.word	0x0000ed69

00009f34 <grid_ui_event_register_actionstring>:
	ele->event_list[event_index].cfg_default_flag = 1;	
	
}


void grid_ui_event_register_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* action_string, uint32_t action_string_length){
    9f34:	b5f0      	push	{r4, r5, r6, r7, lr}
		
	uint8_t event_index = 255;
	
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f36:	f890 c05c 	ldrb.w	ip, [r0, #92]	; 0x5c
    9f3a:	2500      	movs	r5, #0
	uint8_t event_index = 255;
    9f3c:	24ff      	movs	r4, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    9f3e:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9f42:	b2ef      	uxtb	r7, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f44:	45bc      	cmp	ip, r7
    9f46:	d819      	bhi.n	9f7c <grid_ui_event_register_actionstring+0x48>
			event_index = i;
		}
	}
	
	if (event_index == 255){
    9f48:	2cff      	cmp	r4, #255	; 0xff
    9f4a:	d016      	beq.n	9f7a <grid_ui_event_register_actionstring+0x46>
	
	
	
	// Clear Action String
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
		ele->event_list[event_index].action_string[i] = 0;
    9f4c:	21bc      	movs	r1, #188	; 0xbc
    9f4e:	fb14 f401 	smulbb	r4, r4, r1
    9f52:	6e01      	ldr	r1, [r0, #96]	; 0x60
    9f54:	4421      	add	r1, r4
    9f56:	f101 0434 	add.w	r4, r1, #52	; 0x34
    9f5a:	f101 06b6 	add.w	r6, r1, #182	; 0xb6
    9f5e:	4620      	mov	r0, r4
    9f60:	2500      	movs	r5, #0
    9f62:	f800 5b01 	strb.w	r5, [r0], #1
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    9f66:	4286      	cmp	r6, r0
    9f68:	d1fb      	bne.n	9f62 <grid_ui_event_register_actionstring+0x2e>
	}
	ele->event_list[event_index].action_string_length = 0;
    9f6a:	630d      	str	r5, [r1, #48]	; 0x30
	

	uint8_t escaped_characters = 0;
	
	for (uint32_t i=0; i<action_string_length; i++){
    9f6c:	2000      	movs	r0, #0
    9f6e:	4298      	cmp	r0, r3
    9f70:	d10d      	bne.n	9f8e <grid_ui_event_register_actionstring+0x5a>
	}
	

	ele->event_list[event_index].action_string_length = action_string_length;
	
	ele->event_list[event_index].cfg_changed_flag = 1;
    9f72:	2301      	movs	r3, #1
	ele->event_list[event_index].action_string_length = action_string_length;
    9f74:	6308      	str	r0, [r1, #48]	; 0x30
	ele->event_list[event_index].cfg_changed_flag = 1;
    9f76:	f881 30b6 	strb.w	r3, [r1, #182]	; 0xb6
	
	
}
    9f7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    9f7c:	6e06      	ldr	r6, [r0, #96]	; 0x60
    9f7e:	fb0e 6605 	mla	r6, lr, r5, r6
    9f82:	3501      	adds	r5, #1
    9f84:	7ab6      	ldrb	r6, [r6, #10]
    9f86:	428e      	cmp	r6, r1
    9f88:	bf08      	it	eq
    9f8a:	463c      	moveq	r4, r7
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9f8c:	e7d9      	b.n	9f42 <grid_ui_event_register_actionstring+0xe>
		if (ele->event_list[event_index].action_string[i] > 127){
    9f8e:	5616      	ldrsb	r6, [r2, r0]
		ele->event_list[event_index].action_string[i] = action_string[i];
    9f90:	5c15      	ldrb	r5, [r2, r0]
		if (ele->event_list[event_index].action_string[i] > 127){
    9f92:	2e00      	cmp	r6, #0
			ele->event_list[event_index].action_string[i] -= 128;
    9f94:	bfb8      	it	lt
    9f96:	3d80      	sublt	r5, #128	; 0x80
    9f98:	7025      	strb	r5, [r4, #0]
	for (uint32_t i=0; i<action_string_length; i++){
    9f9a:	3001      	adds	r0, #1
    9f9c:	3401      	adds	r4, #1
    9f9e:	e7e6      	b.n	9f6e <grid_ui_event_register_actionstring+0x3a>

00009fa0 <grid_ui_event_generate_actionstring>:
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    9fa0:	b5f0      	push	{r4, r5, r6, r7, lr}
    9fa2:	4605      	mov	r5, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fa4:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    9fa8:	b0a3      	sub	sp, #140	; 0x8c
    9faa:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fac:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    9fae:	26ff      	movs	r6, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    9fb0:	27bc      	movs	r7, #188	; 0xbc
    9fb2:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    9fb4:	4288      	cmp	r0, r1
    9fb6:	d82a      	bhi.n	a00e <grid_ui_event_generate_actionstring+0x6e>
	if (event_index == 255){
    9fb8:	2eff      	cmp	r6, #255	; 0xff
    9fba:	d026      	beq.n	a00a <grid_ui_event_generate_actionstring+0x6a>
	uint8_t action_string[GRID_UI_ACTION_STRING_maxlength] = {0};
    9fbc:	4b35      	ldr	r3, [pc, #212]	; (a094 <grid_ui_event_generate_actionstring+0xf4>)
    9fbe:	2100      	movs	r1, #0
    9fc0:	227e      	movs	r2, #126	; 0x7e
    9fc2:	a802      	add	r0, sp, #8
    9fc4:	9101      	str	r1, [sp, #4]
    9fc6:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    9fc8:	7a6b      	ldrb	r3, [r5, #9]
    9fca:	2b02      	cmp	r3, #2
    9fcc:	d12c      	bne.n	a028 <grid_ui_event_generate_actionstring+0x88>
		switch(event_type){
    9fce:	2c04      	cmp	r4, #4
    9fd0:	d026      	beq.n	a020 <grid_ui_event_generate_actionstring+0x80>
    9fd2:	2c05      	cmp	r4, #5
    9fd4:	d026      	beq.n	a024 <grid_ui_event_generate_actionstring+0x84>
    9fd6:	b91c      	cbnz	r4, 9fe0 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_INIT:	sprintf(action_string, GRID_ACTIONSTRING_INIT_BUT);		break;
    9fd8:	492f      	ldr	r1, [pc, #188]	; (a098 <grid_ui_event_generate_actionstring+0xf8>)
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    9fda:	4b30      	ldr	r3, [pc, #192]	; (a09c <grid_ui_event_generate_actionstring+0xfc>)
    9fdc:	a801      	add	r0, sp, #4
    9fde:	4798      	blx	r3
	if (strlen(action_string)){
    9fe0:	f89d 3004 	ldrb.w	r3, [sp, #4]
    9fe4:	b143      	cbz	r3, 9ff8 <grid_ui_event_generate_actionstring+0x58>
		grid_ui_event_register_actionstring(ele, event_type, action_string, strlen(action_string));
    9fe6:	4b2e      	ldr	r3, [pc, #184]	; (a0a0 <grid_ui_event_generate_actionstring+0x100>)
    9fe8:	a801      	add	r0, sp, #4
    9fea:	4798      	blx	r3
    9fec:	4621      	mov	r1, r4
    9fee:	4603      	mov	r3, r0
    9ff0:	4c2c      	ldr	r4, [pc, #176]	; (a0a4 <grid_ui_event_generate_actionstring+0x104>)
    9ff2:	aa01      	add	r2, sp, #4
    9ff4:	4628      	mov	r0, r5
    9ff6:	47a0      	blx	r4
	ele->event_list[event_index].cfg_changed_flag = 0;
    9ff8:	23bc      	movs	r3, #188	; 0xbc
    9ffa:	fb16 f603 	smulbb	r6, r6, r3
    9ffe:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    a000:	441e      	add	r6, r3
    a002:	f44f 7380 	mov.w	r3, #256	; 0x100
    a006:	f8a6 30b6 	strh.w	r3, [r6, #182]	; 0xb6
}
    a00a:	b023      	add	sp, #140	; 0x8c
    a00c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a00e:	6e2a      	ldr	r2, [r5, #96]	; 0x60
    a010:	fb07 2203 	mla	r2, r7, r3, r2
    a014:	3301      	adds	r3, #1
    a016:	7a92      	ldrb	r2, [r2, #10]
    a018:	42a2      	cmp	r2, r4
    a01a:	bf08      	it	eq
    a01c:	460e      	moveq	r6, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a01e:	e7c8      	b.n	9fb2 <grid_ui_event_generate_actionstring+0x12>
			case GRID_UI_EVENT_DP:		sprintf(action_string, GRID_ACTIONSTRING_DP_BUT);		break;
    a020:	4921      	ldr	r1, [pc, #132]	; (a0a8 <grid_ui_event_generate_actionstring+0x108>)
    a022:	e7da      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:		sprintf(action_string, GRID_ACTIONSTRING_DR_BUT);		break;
    a024:	4921      	ldr	r1, [pc, #132]	; (a0ac <grid_ui_event_generate_actionstring+0x10c>)
    a026:	e7d8      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a028:	2b01      	cmp	r3, #1
    a02a:	d105      	bne.n	a038 <grid_ui_event_generate_actionstring+0x98>
		switch(event_type){
    a02c:	2c00      	cmp	r4, #0
    a02e:	d0d3      	beq.n	9fd8 <grid_ui_event_generate_actionstring+0x38>
    a030:	2c01      	cmp	r4, #1
    a032:	d1d5      	bne.n	9fe0 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_AVC7:	sprintf(action_string, GRID_ACTIONSTRING_AVC7_POT);		break;
    a034:	491e      	ldr	r1, [pc, #120]	; (a0b0 <grid_ui_event_generate_actionstring+0x110>)
    a036:	e7d0      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a038:	2b03      	cmp	r3, #3
    a03a:	d1d1      	bne.n	9fe0 <grid_ui_event_generate_actionstring+0x40>
		switch(event_type){
    a03c:	2c0d      	cmp	r4, #13
    a03e:	d8cf      	bhi.n	9fe0 <grid_ui_event_generate_actionstring+0x40>
    a040:	a301      	add	r3, pc, #4	; (adr r3, a048 <grid_ui_event_generate_actionstring+0xa8>)
    a042:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
    a046:	bf00      	nop
    a048:	0000a081 	.word	0x0000a081
    a04c:	0000a085 	.word	0x0000a085
    a050:	00009fe1 	.word	0x00009fe1
    a054:	00009fe1 	.word	0x00009fe1
    a058:	0000a08d 	.word	0x0000a08d
    a05c:	0000a091 	.word	0x0000a091
    a060:	00009fe1 	.word	0x00009fe1
    a064:	00009fe1 	.word	0x00009fe1
    a068:	00009fe1 	.word	0x00009fe1
    a06c:	00009fe1 	.word	0x00009fe1
    a070:	00009fe1 	.word	0x00009fe1
    a074:	00009fe1 	.word	0x00009fe1
    a078:	00009fe1 	.word	0x00009fe1
    a07c:	0000a089 	.word	0x0000a089
			case GRID_UI_EVENT_INIT:        sprintf(action_string, GRID_ACTIONSTRING_INIT_ENC);	break;
    a080:	490c      	ldr	r1, [pc, #48]	; (a0b4 <grid_ui_event_generate_actionstring+0x114>)
    a082:	e7aa      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_AVC7:        sprintf(action_string, GRID_ACTIONSTRING_AVC7_ENC);	break;
    a084:	490c      	ldr	r1, [pc, #48]	; (a0b8 <grid_ui_event_generate_actionstring+0x118>)
    a086:	e7a8      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_ENCPUSHROT:	sprintf(action_string, GRID_ACTIONSTRING_PUSHROT_ENC);	break;
    a088:	490c      	ldr	r1, [pc, #48]	; (a0bc <grid_ui_event_generate_actionstring+0x11c>)
    a08a:	e7a6      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DP:          sprintf(action_string, GRID_ACTIONSTRING_DP_ENC);	break;
    a08c:	490c      	ldr	r1, [pc, #48]	; (a0c0 <grid_ui_event_generate_actionstring+0x120>)
    a08e:	e7a4      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a090:	490c      	ldr	r1, [pc, #48]	; (a0c4 <grid_ui_event_generate_actionstring+0x124>)
    a092:	e7a2      	b.n	9fda <grid_ui_event_generate_actionstring+0x3a>
    a094:	00014175 	.word	0x00014175
    a098:	00016aeb 	.word	0x00016aeb
    a09c:	00014bbd 	.word	0x00014bbd
    a0a0:	00014c81 	.word	0x00014c81
    a0a4:	00009f35 	.word	0x00009f35
    a0a8:	00016b10 	.word	0x00016b10
    a0ac:	00016b3f 	.word	0x00016b3f
    a0b0:	00016b6e 	.word	0x00016b6e
    a0b4:	00016b9d 	.word	0x00016b9d
    a0b8:	00016be6 	.word	0x00016be6
    a0bc:	00016c50 	.word	0x00016c50
    a0c0:	00016c7f 	.word	0x00016c7f
    a0c4:	00016cae 	.word	0x00016cae

0000a0c8 <grid_ui_reinit>:
void grid_ui_reinit(struct grid_ui_model* ui){
    a0c8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a0cc:	4606      	mov	r6, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a0ce:	2700      	movs	r7, #0
    a0d0:	7873      	ldrb	r3, [r6, #1]
    a0d2:	b2fc      	uxtb	r4, r7
    a0d4:	42a3      	cmp	r3, r4
    a0d6:	d805      	bhi.n	a0e4 <grid_ui_reinit+0x1c>
	grid_sys_state.bank_active_changed = 1;
    a0d8:	4b18      	ldr	r3, [pc, #96]	; (a13c <grid_ui_reinit+0x74>)
    a0da:	2201      	movs	r2, #1
    a0dc:	745a      	strb	r2, [r3, #17]
}
    a0de:	b003      	add	sp, #12
    a0e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a0e4:	6873      	ldr	r3, [r6, #4]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a0e6:	f04f 0800 	mov.w	r8, #0
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a0ea:	eb03 1404 	add.w	r4, r3, r4, lsl #4
			struct grid_ui_element* ele = &bank->element_list[j];
    a0ee:	f04f 0b64 	mov.w	fp, #100	; 0x64
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a0f2:	7a63      	ldrb	r3, [r4, #9]
    a0f4:	fa5f f088 	uxtb.w	r0, r8
    a0f8:	4283      	cmp	r3, r0
    a0fa:	d801      	bhi.n	a100 <grid_ui_reinit+0x38>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a0fc:	3701      	adds	r7, #1
    a0fe:	e7e7      	b.n	a0d0 <grid_ui_reinit+0x8>
			struct grid_ui_element* ele = &bank->element_list[j];
    a100:	68e3      	ldr	r3, [r4, #12]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a102:	f04f 0900 	mov.w	r9, #0
			struct grid_ui_element* ele = &bank->element_list[j];
    a106:	fb0b 3000 	mla	r0, fp, r0, r3
				struct grid_ui_event* eve = &ele->event_list[k];
    a10a:	f04f 0abc 	mov.w	sl, #188	; 0xbc
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a10e:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
    a112:	fa5f f589 	uxtb.w	r5, r9
    a116:	42a9      	cmp	r1, r5
    a118:	d802      	bhi.n	a120 <grid_ui_reinit+0x58>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a11a:	f108 0801 	add.w	r8, r8, #1
    a11e:	e7e8      	b.n	a0f2 <grid_ui_reinit+0x2a>
				struct grid_ui_event* eve = &ele->event_list[k];
    a120:	6e01      	ldr	r1, [r0, #96]	; 0x60
				grid_ui_event_generate_actionstring(ele, eve->type);
    a122:	4b07      	ldr	r3, [pc, #28]	; (a140 <grid_ui_reinit+0x78>)
    a124:	9001      	str	r0, [sp, #4]
				struct grid_ui_event* eve = &ele->event_list[k];
    a126:	fb0a 1505 	mla	r5, sl, r5, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a12a:	f109 0901 	add.w	r9, r9, #1
    a12e:	7aa9      	ldrb	r1, [r5, #10]
    a130:	4798      	blx	r3
}


void grid_ui_event_reset(struct grid_ui_event* eve){
	
	eve->trigger = GRID_UI_STATUS_READY;
    a132:	2204      	movs	r2, #4
    a134:	9801      	ldr	r0, [sp, #4]
    a136:	726a      	strb	r2, [r5, #9]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a138:	e7e9      	b.n	a10e <grid_ui_reinit+0x46>
    a13a:	bf00      	nop
    a13c:	20007a24 	.word	0x20007a24
    a140:	00009fa1 	.word	0x00009fa1

0000a144 <grid_ui_event_find>:
uint8_t grid_ui_event_find(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a144:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a146:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
    a14a:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a14c:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a14e:	27bc      	movs	r7, #188	; 0xbc
    a150:	b2dd      	uxtb	r5, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a152:	42ae      	cmp	r6, r5
    a154:	d801      	bhi.n	a15a <grid_ui_event_find+0x16>
}
    a156:	4610      	mov	r0, r2
    a158:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a15a:	6e04      	ldr	r4, [r0, #96]	; 0x60
    a15c:	fb07 4403 	mla	r4, r7, r3, r4
    a160:	3301      	adds	r3, #1
    a162:	7aa4      	ldrb	r4, [r4, #10]
    a164:	428c      	cmp	r4, r1
    a166:	bf08      	it	eq
    a168:	462a      	moveq	r2, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a16a:	e7f1      	b.n	a150 <grid_ui_event_find+0xc>

0000a16c <grid_ui_event_trigger>:
	if (event_index == 255){
    a16c:	29ff      	cmp	r1, #255	; 0xff
    a16e:	d005      	beq.n	a17c <grid_ui_event_trigger+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED;
    a170:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a172:	23bc      	movs	r3, #188	; 0xbc
    a174:	fb01 2103 	mla	r1, r1, r3, r2
    a178:	2305      	movs	r3, #5
    a17a:	724b      	strb	r3, [r1, #9]
}
    a17c:	4770      	bx	lr

0000a17e <grid_ui_event_trigger_local>:
	if (event_index == 255){
    a17e:	29ff      	cmp	r1, #255	; 0xff
    a180:	d005      	beq.n	a18e <grid_ui_event_trigger_local+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED_LOCAL;
    a182:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a184:	23bc      	movs	r3, #188	; 0xbc
    a186:	fb01 2103 	mla	r1, r1, r3, r2
    a18a:	2306      	movs	r3, #6
    a18c:	724b      	strb	r3, [r1, #9]
}
    a18e:	4770      	bx	lr

0000a190 <grid_ui_smart_trigger>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a190:	6840      	ldr	r0, [r0, #4]
    a192:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a196:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a198:	68c4      	ldr	r4, [r0, #12]
    a19a:	2064      	movs	r0, #100	; 0x64
    a19c:	fb02 4400 	mla	r4, r2, r0, r4
    a1a0:	4619      	mov	r1, r3
    a1a2:	4620      	mov	r0, r4
    a1a4:	4b05      	ldr	r3, [pc, #20]	; (a1bc <grid_ui_smart_trigger+0x2c>)
    a1a6:	4798      	blx	r3
	if (event_index == 255){
    a1a8:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a1aa:	4601      	mov	r1, r0
	if (event_index == 255){
    a1ac:	d004      	beq.n	a1b8 <grid_ui_smart_trigger+0x28>
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a1ae:	4620      	mov	r0, r4
    a1b0:	4b03      	ldr	r3, [pc, #12]	; (a1c0 <grid_ui_smart_trigger+0x30>)
}
    a1b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a1b6:	4718      	bx	r3
}
    a1b8:	bd10      	pop	{r4, pc}
    a1ba:	bf00      	nop
    a1bc:	0000a145 	.word	0x0000a145
    a1c0:	0000a16d 	.word	0x0000a16d

0000a1c4 <grid_ui_event_register_eventstring>:
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a1c4:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a1c8:	4604      	mov	r4, r0
	grid_debug_print_text("Register Action");
    a1ca:	4e28      	ldr	r6, [pc, #160]	; (a26c <grid_ui_event_register_eventstring+0xa8>)
    a1cc:	4828      	ldr	r0, [pc, #160]	; (a270 <grid_ui_event_register_eventstring+0xac>)
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a1ce:	4699      	mov	r9, r3
    a1d0:	4688      	mov	r8, r1
    a1d2:	4692      	mov	sl, r2
	grid_debug_print_text("Register Action");
    a1d4:	47b0      	blx	r6
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a1d6:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    a1da:	46b3      	mov	fp, r6
    a1dc:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a1de:	25ff      	movs	r5, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a1e0:	26bc      	movs	r6, #188	; 0xbc
    a1e2:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a1e4:	4288      	cmp	r0, r1
    a1e6:	d807      	bhi.n	a1f8 <grid_ui_event_register_eventstring+0x34>
	if (event_index == 255){
    a1e8:	2dff      	cmp	r5, #255	; 0xff
    a1ea:	d10e      	bne.n	a20a <grid_ui_event_register_eventstring+0x46>
		grid_debug_print_text("Event Not Found");
    a1ec:	4821      	ldr	r0, [pc, #132]	; (a274 <grid_ui_event_register_eventstring+0xb0>)
    a1ee:	465b      	mov	r3, fp
}
    a1f0:	b001      	add	sp, #4
    a1f2:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		grid_debug_print_text("Event Not Found");
    a1f6:	4718      	bx	r3
		if (ele->event_list[i].type == event_type){
    a1f8:	6e22      	ldr	r2, [r4, #96]	; 0x60
    a1fa:	fb06 2203 	mla	r2, r6, r3, r2
    a1fe:	3301      	adds	r3, #1
    a200:	7a92      	ldrb	r2, [r2, #10]
    a202:	4542      	cmp	r2, r8
    a204:	bf08      	it	eq
    a206:	460d      	moveq	r5, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a208:	e7eb      	b.n	a1e2 <grid_ui_event_register_eventstring+0x1e>
		ele->event_list[event_index].event_string[i] = 0;
    a20a:	23bc      	movs	r3, #188	; 0xbc
    a20c:	fb15 f503 	smulbb	r5, r5, r3
    a210:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a212:	442b      	add	r3, r5
    a214:	f103 0210 	add.w	r2, r3, #16
    a218:	f103 002e 	add.w	r0, r3, #46	; 0x2e
    a21c:	2100      	movs	r1, #0
    a21e:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a222:	4282      	cmp	r2, r0
    a224:	d1fb      	bne.n	a21e <grid_ui_event_register_eventstring+0x5a>
			grid_debug_print_text(" Escaped Char Found ");
    a226:	4814      	ldr	r0, [pc, #80]	; (a278 <grid_ui_event_register_eventstring+0xb4>)
	ele->event_list[event_index].event_string_length = 0;
    a228:	60d9      	str	r1, [r3, #12]
	for (uint32_t i=0; i<event_string_length; i++){
    a22a:	2600      	movs	r6, #0
    a22c:	6e27      	ldr	r7, [r4, #96]	; 0x60
    a22e:	454e      	cmp	r6, r9
    a230:	442f      	add	r7, r5
    a232:	d10b      	bne.n	a24c <grid_ui_event_register_eventstring+0x88>
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a234:	6860      	ldr	r0, [r4, #4]
	ele->event_list[event_index].event_string_length = event_string_length;
    a236:	60fe      	str	r6, [r7, #12]
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a238:	7a22      	ldrb	r2, [r4, #8]
    a23a:	4c10      	ldr	r4, [pc, #64]	; (a27c <grid_ui_event_register_eventstring+0xb8>)
    a23c:	7a01      	ldrb	r1, [r0, #8]
    a23e:	6840      	ldr	r0, [r0, #4]
    a240:	4643      	mov	r3, r8
    a242:	46a4      	mov	ip, r4
}
    a244:	b001      	add	sp, #4
    a246:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a24a:	4760      	bx	ip
		ele->event_list[event_index].event_string[i] = event_string[i];
    a24c:	f81a 3006 	ldrb.w	r3, [sl, r6]
    a250:	4437      	add	r7, r6
    a252:	743b      	strb	r3, [r7, #16]
		if (ele->event_list[event_index].event_string[i] > 127){
    a254:	061b      	lsls	r3, r3, #24
    a256:	d507      	bpl.n	a268 <grid_ui_event_register_eventstring+0xa4>
			grid_debug_print_text(" Escaped Char Found ");
    a258:	47d8      	blx	fp
			ele->event_list[event_index].event_string[i] -= 128;
    a25a:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a25c:	4806      	ldr	r0, [pc, #24]	; (a278 <grid_ui_event_register_eventstring+0xb4>)
    a25e:	442b      	add	r3, r5
    a260:	4433      	add	r3, r6
    a262:	7c1a      	ldrb	r2, [r3, #16]
    a264:	3a80      	subs	r2, #128	; 0x80
    a266:	741a      	strb	r2, [r3, #16]
	for (uint32_t i=0; i<event_string_length; i++){
    a268:	3601      	adds	r6, #1
    a26a:	e7df      	b.n	a22c <grid_ui_event_register_eventstring+0x68>
    a26c:	00009279 	.word	0x00009279
    a270:	00016cdd 	.word	0x00016cdd
    a274:	00016ced 	.word	0x00016ced
    a278:	00016cfd 	.word	0x00016cfd
    a27c:	0000a191 	.word	0x0000a191

0000a280 <grid_ui_event_generate_eventstring>:
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a280:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a282:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a286:	b089      	sub	sp, #36	; 0x24
    a288:	4605      	mov	r5, r0
    a28a:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a28c:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a28e:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a290:	27bc      	movs	r7, #188	; 0xbc
    a292:	b2d8      	uxtb	r0, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a294:	4286      	cmp	r6, r0
    a296:	d81a      	bhi.n	a2ce <grid_ui_event_generate_eventstring+0x4e>
	if (event_index == 255){
    a298:	2aff      	cmp	r2, #255	; 0xff
    a29a:	d016      	beq.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
	uint8_t event_string[GRID_UI_EVENT_STRING_maxlength] = {0};	
    a29c:	4b27      	ldr	r3, [pc, #156]	; (a33c <grid_ui_event_generate_eventstring+0xbc>)
    a29e:	2100      	movs	r1, #0
    a2a0:	221a      	movs	r2, #26
    a2a2:	a801      	add	r0, sp, #4
    a2a4:	9100      	str	r1, [sp, #0]
    a2a6:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    a2a8:	7a6b      	ldrb	r3, [r5, #9]
    a2aa:	2b02      	cmp	r3, #2
    a2ac:	d132      	bne.n	a314 <grid_ui_event_generate_eventstring+0x94>
		if (event_type == GRID_UI_EVENT_INIT){
    a2ae:	b9bc      	cbnz	r4, a2e0 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_INIT_BUT); // !!
    a2b0:	4923      	ldr	r1, [pc, #140]	; (a340 <grid_ui_event_generate_eventstring+0xc0>)
    a2b2:	4b24      	ldr	r3, [pc, #144]	; (a344 <grid_ui_event_generate_eventstring+0xc4>)
    a2b4:	4668      	mov	r0, sp
    a2b6:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2b8:	4b23      	ldr	r3, [pc, #140]	; (a348 <grid_ui_event_generate_eventstring+0xc8>)
    a2ba:	4668      	mov	r0, sp
    a2bc:	4798      	blx	r3
    a2be:	466a      	mov	r2, sp
    a2c0:	4603      	mov	r3, r0
    a2c2:	2100      	movs	r1, #0
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2c4:	4c21      	ldr	r4, [pc, #132]	; (a34c <grid_ui_event_generate_eventstring+0xcc>)
    a2c6:	4628      	mov	r0, r5
    a2c8:	47a0      	blx	r4
}
    a2ca:	b009      	add	sp, #36	; 0x24
    a2cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a2ce:	6e29      	ldr	r1, [r5, #96]	; 0x60
    a2d0:	fb07 1103 	mla	r1, r7, r3, r1
    a2d4:	3301      	adds	r3, #1
    a2d6:	7a89      	ldrb	r1, [r1, #10]
    a2d8:	42a1      	cmp	r1, r4
    a2da:	bf08      	it	eq
    a2dc:	4602      	moveq	r2, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a2de:	e7d8      	b.n	a292 <grid_ui_event_generate_eventstring+0x12>
		else if (event_type == GRID_UI_EVENT_DP){
    a2e0:	2c04      	cmp	r4, #4
    a2e2:	d10a      	bne.n	a2fa <grid_ui_event_generate_eventstring+0x7a>
			sprintf(event_string, GRID_EVENTSTRING_DP_BUT); // !!
    a2e4:	491a      	ldr	r1, [pc, #104]	; (a350 <grid_ui_event_generate_eventstring+0xd0>)
    a2e6:	4b17      	ldr	r3, [pc, #92]	; (a344 <grid_ui_event_generate_eventstring+0xc4>)
    a2e8:	4668      	mov	r0, sp
    a2ea:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a2ec:	4b16      	ldr	r3, [pc, #88]	; (a348 <grid_ui_event_generate_eventstring+0xc8>)
    a2ee:	4668      	mov	r0, sp
    a2f0:	4798      	blx	r3
    a2f2:	466a      	mov	r2, sp
    a2f4:	4603      	mov	r3, r0
    a2f6:	2104      	movs	r1, #4
    a2f8:	e7e4      	b.n	a2c4 <grid_ui_event_generate_eventstring+0x44>
		else if (event_type == GRID_UI_EVENT_DR){
    a2fa:	2c05      	cmp	r4, #5
    a2fc:	d1e5      	bne.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_DR_BUT); // !!
    a2fe:	4915      	ldr	r1, [pc, #84]	; (a354 <grid_ui_event_generate_eventstring+0xd4>)
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a300:	4b10      	ldr	r3, [pc, #64]	; (a344 <grid_ui_event_generate_eventstring+0xc4>)
    a302:	4668      	mov	r0, sp
    a304:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a306:	4b10      	ldr	r3, [pc, #64]	; (a348 <grid_ui_event_generate_eventstring+0xc8>)
    a308:	4668      	mov	r0, sp
    a30a:	4798      	blx	r3
    a30c:	466a      	mov	r2, sp
    a30e:	4603      	mov	r3, r0
    a310:	4621      	mov	r1, r4
    a312:	e7d7      	b.n	a2c4 <grid_ui_event_generate_eventstring+0x44>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a314:	2b01      	cmp	r3, #1
    a316:	d105      	bne.n	a324 <grid_ui_event_generate_eventstring+0xa4>
		if (event_type == GRID_UI_EVENT_INIT){
    a318:	2c00      	cmp	r4, #0
    a31a:	d0c9      	beq.n	a2b0 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a31c:	2c01      	cmp	r4, #1
    a31e:	d1d4      	bne.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_POT); // !!
    a320:	490d      	ldr	r1, [pc, #52]	; (a358 <grid_ui_event_generate_eventstring+0xd8>)
    a322:	e7ed      	b.n	a300 <grid_ui_event_generate_eventstring+0x80>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a324:	2b03      	cmp	r3, #3
    a326:	d1d0      	bne.n	a2ca <grid_ui_event_generate_eventstring+0x4a>
		if (event_type == GRID_UI_EVENT_INIT){
    a328:	2c00      	cmp	r4, #0
    a32a:	d0c1      	beq.n	a2b0 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a32c:	2c01      	cmp	r4, #1
    a32e:	d101      	bne.n	a334 <grid_ui_event_generate_eventstring+0xb4>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_ENC); // !!
    a330:	490a      	ldr	r1, [pc, #40]	; (a35c <grid_ui_event_generate_eventstring+0xdc>)
    a332:	e7e5      	b.n	a300 <grid_ui_event_generate_eventstring+0x80>
		else if (event_type == GRID_UI_EVENT_ENCPUSHROT){
    a334:	2c0d      	cmp	r4, #13
    a336:	d1d3      	bne.n	a2e0 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a338:	4909      	ldr	r1, [pc, #36]	; (a360 <grid_ui_event_generate_eventstring+0xe0>)
    a33a:	e7e1      	b.n	a300 <grid_ui_event_generate_eventstring+0x80>
    a33c:	00014175 	.word	0x00014175
    a340:	00016d12 	.word	0x00016d12
    a344:	00014bbd 	.word	0x00014bbd
    a348:	00014c81 	.word	0x00014c81
    a34c:	0000a1c5 	.word	0x0000a1c5
    a350:	00016d2b 	.word	0x00016d2b
    a354:	00016d49 	.word	0x00016d49
    a358:	00016d67 	.word	0x00016d67
    a35c:	00016d85 	.word	0x00016d85
    a360:	00016da3 	.word	0x00016da3

0000a364 <grid_ui_event_init>:
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a364:	b570      	push	{r4, r5, r6, lr}
	struct grid_ui_event* eve = &parent->event_list[index];
    a366:	6e06      	ldr	r6, [r0, #96]	; 0x60
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a368:	4615      	mov	r5, r2
	struct grid_ui_event* eve = &parent->event_list[index];
    a36a:	22bc      	movs	r2, #188	; 0xbc
    a36c:	fb11 f202 	smulbb	r2, r1, r2
    a370:	18b4      	adds	r4, r6, r2
	eve->cfg_changed_flag = 0;
    a372:	2300      	movs	r3, #0
	eve->index = index;
    a374:	7221      	strb	r1, [r4, #8]
	eve->status = GRID_UI_STATUS_READY;
    a376:	2104      	movs	r1, #4
	eve->parent = parent;
    a378:	6060      	str	r0, [r4, #4]
	eve->cfg_changed_flag = 0;
    a37a:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	eve->type   = event_type;	
    a37e:	72a5      	strb	r5, [r4, #10]
	eve->status = GRID_UI_STATUS_READY;
    a380:	54b1      	strb	r1, [r6, r2]
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a382:	f104 0210 	add.w	r2, r4, #16
    a386:	f104 012e 	add.w	r1, r4, #46	; 0x2e
		eve->event_string[i] = 0;
    a38a:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a38e:	428a      	cmp	r2, r1
    a390:	d1fb      	bne.n	a38a <grid_ui_event_init+0x26>
	eve->event_string_length = 0;
    a392:	60e3      	str	r3, [r4, #12]
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a394:	f104 01b6 	add.w	r1, r4, #182	; 0xb6
    a398:	f104 0334 	add.w	r3, r4, #52	; 0x34
		eve->action_string[i] = 0;
    a39c:	2200      	movs	r2, #0
    a39e:	f803 2b01 	strb.w	r2, [r3], #1
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a3a2:	4299      	cmp	r1, r3
    a3a4:	d1fb      	bne.n	a39e <grid_ui_event_init+0x3a>
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a3a6:	4b08      	ldr	r3, [pc, #32]	; (a3c8 <grid_ui_event_init+0x64>)
	eve->action_string_length = 0;
    a3a8:	6322      	str	r2, [r4, #48]	; 0x30
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a3aa:	4629      	mov	r1, r5
    a3ac:	4798      	blx	r3
	grid_ui_event_generate_actionstring(eve->parent, event_type);	
    a3ae:	4b07      	ldr	r3, [pc, #28]	; (a3cc <grid_ui_event_init+0x68>)
    a3b0:	6860      	ldr	r0, [r4, #4]
    a3b2:	4629      	mov	r1, r5
    a3b4:	4798      	blx	r3
	eve->cfg_changed_flag = 0;
    a3b6:	f44f 7380 	mov.w	r3, #256	; 0x100
    a3ba:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
	eve->cfg_flashempty_flag = 1;
    a3be:	2301      	movs	r3, #1
    a3c0:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
}
    a3c4:	bd70      	pop	{r4, r5, r6, pc}
    a3c6:	bf00      	nop
    a3c8:	0000a281 	.word	0x0000a281
    a3cc:	00009fa1 	.word	0x00009fa1

0000a3d0 <grid_ui_element_init>:
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a3d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct grid_ui_element* ele = &parent->element_list[index];
    a3d4:	2364      	movs	r3, #100	; 0x64
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a3d6:	4615      	mov	r5, r2
	struct grid_ui_element* ele = &parent->element_list[index];
    a3d8:	68c2      	ldr	r2, [r0, #12]
    a3da:	fb11 f303 	smulbb	r3, r1, r3
    a3de:	18d4      	adds	r4, r2, r3
	ele->index = index;
    a3e0:	7221      	strb	r1, [r4, #8]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a3e2:	2101      	movs	r1, #1
	ele->parent = parent;
    a3e4:	6060      	str	r0, [r4, #4]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a3e6:	54d1      	strb	r1, [r2, r3]
	ele->type = element_type;
    a3e8:	7265      	strb	r5, [r4, #9]
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a3ea:	f104 030c 	add.w	r3, r4, #12
    a3ee:	f104 025c 	add.w	r2, r4, #92	; 0x5c
		ele->template_parameter_list[i] = 0;
    a3f2:	2100      	movs	r1, #0
    a3f4:	f843 1b04 	str.w	r1, [r3], #4
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a3f8:	429a      	cmp	r2, r3
    a3fa:	d1fb      	bne.n	a3f4 <grid_ui_element_init+0x24>
	if (element_type == GRID_UI_ELEMENT_SYSTEM){
    a3fc:	bb1d      	cbnz	r5, a446 <grid_ui_element_init+0x76>
		ele->event_list_length = 6;
    a3fe:	2306      	movs	r3, #6
    a400:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a404:	f44f 608d 	mov.w	r0, #1128	; 0x468
    a408:	4b34      	ldr	r3, [pc, #208]	; (a4dc <grid_ui_element_init+0x10c>)
    a40a:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a40c:	462a      	mov	r2, r5
    a40e:	4629      	mov	r1, r5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a410:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a412:	4d33      	ldr	r5, [pc, #204]	; (a4e0 <grid_ui_element_init+0x110>)
    a414:	4620      	mov	r0, r4
    a416:	47a8      	blx	r5
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_HEARTBEAT); // Heartbeat
    a418:	220c      	movs	r2, #12
    a41a:	2101      	movs	r1, #1
    a41c:	4620      	mov	r0, r4
    a41e:	47a8      	blx	r5
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_MAPMODE_PRESS); // Mapmode press
    a420:	2207      	movs	r2, #7
    a422:	2102      	movs	r1, #2
    a424:	4620      	mov	r0, r4
    a426:	47a8      	blx	r5
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_MAPMODE_RELEASE); // Mapmode release
    a428:	2208      	movs	r2, #8
    a42a:	2103      	movs	r1, #3
    a42c:	4620      	mov	r0, r4
    a42e:	47a8      	blx	r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_CFG_RESPONSE); //
    a430:	2209      	movs	r2, #9
    a432:	2104      	movs	r1, #4
    a434:	4620      	mov	r0, r4
    a436:	47a8      	blx	r5
		grid_ui_event_init(ele, 5, GRID_UI_EVENT_CFG_REQUEST); //
    a438:	220a      	movs	r2, #10
    a43a:	2105      	movs	r1, #5
    a43c:	4620      	mov	r0, r4
    a43e:	462b      	mov	r3, r5
}
    a440:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a444:	4718      	bx	r3
	else if (element_type == GRID_UI_ELEMENT_POTENTIOMETER){
    a446:	2d01      	cmp	r5, #1
    a448:	d111      	bne.n	a46e <grid_ui_element_init+0x9e>
		ele->event_list_length = 2;
    a44a:	2302      	movs	r3, #2
    a44c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a450:	f44f 70bc 	mov.w	r0, #376	; 0x178
    a454:	4b21      	ldr	r3, [pc, #132]	; (a4dc <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a456:	4e22      	ldr	r6, [pc, #136]	; (a4e0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a458:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a45a:	2200      	movs	r2, #0
    a45c:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a45e:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a460:	4620      	mov	r0, r4
    a462:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a464:	462a      	mov	r2, r5
    a466:	4629      	mov	r1, r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a468:	4620      	mov	r0, r4
    a46a:	4633      	mov	r3, r6
    a46c:	e7e8      	b.n	a440 <grid_ui_element_init+0x70>
	else if (element_type == GRID_UI_ELEMENT_BUTTON){
    a46e:	2d02      	cmp	r5, #2
    a470:	d113      	bne.n	a49a <grid_ui_element_init+0xca>
		ele->event_list_length = 3;
    a472:	2303      	movs	r3, #3
    a474:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a478:	f44f 700d 	mov.w	r0, #564	; 0x234
    a47c:	4b17      	ldr	r3, [pc, #92]	; (a4dc <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a47e:	4e18      	ldr	r6, [pc, #96]	; (a4e0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a480:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a482:	2200      	movs	r2, #0
    a484:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a486:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a488:	4620      	mov	r0, r4
    a48a:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a48c:	2204      	movs	r2, #4
    a48e:	2101      	movs	r1, #1
    a490:	4620      	mov	r0, r4
    a492:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a494:	2205      	movs	r2, #5
    a496:	4629      	mov	r1, r5
    a498:	e7e6      	b.n	a468 <grid_ui_element_init+0x98>
	else if (element_type == GRID_UI_ELEMENT_ENCODER){
    a49a:	2d03      	cmp	r5, #3
    a49c:	d11b      	bne.n	a4d6 <grid_ui_element_init+0x106>
		ele->event_list_length = 5;
    a49e:	2705      	movs	r7, #5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a4a0:	4b0e      	ldr	r3, [pc, #56]	; (a4dc <grid_ui_element_init+0x10c>)
		ele->event_list_length = 5;
    a4a2:	f884 705c 	strb.w	r7, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a4a6:	f44f 706b 	mov.w	r0, #940	; 0x3ac
    a4aa:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a4ac:	2200      	movs	r2, #0
    a4ae:	4e0c      	ldr	r6, [pc, #48]	; (a4e0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a4b0:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a4b2:	4611      	mov	r1, r2
    a4b4:	4620      	mov	r0, r4
    a4b6:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a4b8:	2204      	movs	r2, #4
    a4ba:	2101      	movs	r1, #1
    a4bc:	4620      	mov	r0, r4
    a4be:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a4c0:	463a      	mov	r2, r7
    a4c2:	2102      	movs	r1, #2
    a4c4:	4620      	mov	r0, r4
    a4c6:	47b0      	blx	r6
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a4c8:	2201      	movs	r2, #1
    a4ca:	4629      	mov	r1, r5
    a4cc:	4620      	mov	r0, r4
    a4ce:	47b0      	blx	r6
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a4d0:	220d      	movs	r2, #13
    a4d2:	2104      	movs	r1, #4
    a4d4:	e7c8      	b.n	a468 <grid_ui_element_init+0x98>
}
    a4d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a4da:	bf00      	nop
    a4dc:	00014021 	.word	0x00014021
    a4e0:	0000a365 	.word	0x0000a365

0000a4e4 <grid_ui_smart_trigger_local>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4e4:	6840      	ldr	r0, [r0, #4]
    a4e6:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger_local(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a4ea:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4ec:	68c4      	ldr	r4, [r0, #12]
    a4ee:	2064      	movs	r0, #100	; 0x64
    a4f0:	fb02 4400 	mla	r4, r2, r0, r4
    a4f4:	4619      	mov	r1, r3
    a4f6:	4620      	mov	r0, r4
    a4f8:	4b05      	ldr	r3, [pc, #20]	; (a510 <grid_ui_smart_trigger_local+0x2c>)
    a4fa:	4798      	blx	r3
	if (event_index == 255){
    a4fc:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a4fe:	4601      	mov	r1, r0
	if (event_index == 255){
    a500:	d004      	beq.n	a50c <grid_ui_smart_trigger_local+0x28>
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a502:	4620      	mov	r0, r4
    a504:	4b03      	ldr	r3, [pc, #12]	; (a514 <grid_ui_smart_trigger_local+0x30>)
}
    a506:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a50a:	4718      	bx	r3
}
    a50c:	bd10      	pop	{r4, pc}
    a50e:	bf00      	nop
    a510:	0000a145 	.word	0x0000a145
    a514:	0000a17f 	.word	0x0000a17f

0000a518 <grid_ui_reinit_local>:
void grid_ui_reinit_local(struct grid_ui_model* ui){
    a518:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a51c:	4604      	mov	r4, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a51e:	f04f 0800 	mov.w	r8, #0
    a522:	7863      	ldrb	r3, [r4, #1]
    a524:	fa5f f788 	uxtb.w	r7, r8
    a528:	42bb      	cmp	r3, r7
    a52a:	d805      	bhi.n	a538 <grid_ui_reinit_local+0x20>
	grid_sys_state.bank_active_changed = 1;
    a52c:	4b1c      	ldr	r3, [pc, #112]	; (a5a0 <grid_ui_reinit_local+0x88>)
    a52e:	2201      	movs	r2, #1
    a530:	745a      	strb	r2, [r3, #17]
}
    a532:	b003      	add	sp, #12
    a534:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a538:	6866      	ldr	r6, [r4, #4]
    a53a:	eb06 1307 	add.w	r3, r6, r7, lsl #4
    a53e:	9300      	str	r3, [sp, #0]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a540:	f04f 0900 	mov.w	r9, #0
    a544:	9b00      	ldr	r3, [sp, #0]
    a546:	7a5b      	ldrb	r3, [r3, #9]
    a548:	fa5f fb89 	uxtb.w	fp, r9
    a54c:	455b      	cmp	r3, fp
    a54e:	d802      	bhi.n	a556 <grid_ui_reinit_local+0x3e>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a550:	f108 0801 	add.w	r8, r8, #1
    a554:	e7e5      	b.n	a522 <grid_ui_reinit_local+0xa>
			struct grid_ui_element* ele = &bank->element_list[j];
    a556:	9b00      	ldr	r3, [sp, #0]
    a558:	68db      	ldr	r3, [r3, #12]
    a55a:	2564      	movs	r5, #100	; 0x64
    a55c:	fb05 350b 	mla	r5, r5, fp, r3
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a560:	f04f 0a00 	mov.w	sl, #0
    a564:	f895 105c 	ldrb.w	r1, [r5, #92]	; 0x5c
    a568:	fa5f f38a 	uxtb.w	r3, sl
    a56c:	4299      	cmp	r1, r3
    a56e:	d802      	bhi.n	a576 <grid_ui_reinit_local+0x5e>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a570:	f109 0901 	add.w	r9, r9, #1
    a574:	e7e6      	b.n	a544 <grid_ui_reinit_local+0x2c>
				struct grid_ui_event* eve = &ele->event_list[k];
    a576:	6e29      	ldr	r1, [r5, #96]	; 0x60
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a578:	4e0a      	ldr	r6, [pc, #40]	; (a5a4 <grid_ui_reinit_local+0x8c>)
				struct grid_ui_event* eve = &ele->event_list[k];
    a57a:	22bc      	movs	r2, #188	; 0xbc
    a57c:	fb02 1303 	mla	r3, r2, r3, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a580:	9301      	str	r3, [sp, #4]
    a582:	7a99      	ldrb	r1, [r3, #10]
    a584:	4b08      	ldr	r3, [pc, #32]	; (a5a8 <grid_ui_reinit_local+0x90>)
    a586:	4628      	mov	r0, r5
    a588:	4798      	blx	r3
	eve->trigger = GRID_UI_STATUS_READY;
    a58a:	9b01      	ldr	r3, [sp, #4]
    a58c:	2104      	movs	r1, #4
    a58e:	7259      	strb	r1, [r3, #9]
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a590:	465a      	mov	r2, fp
    a592:	7a9b      	ldrb	r3, [r3, #10]
    a594:	4639      	mov	r1, r7
    a596:	4620      	mov	r0, r4
    a598:	47b0      	blx	r6
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a59a:	f10a 0a01 	add.w	sl, sl, #1
    a59e:	e7e1      	b.n	a564 <grid_ui_reinit_local+0x4c>
    a5a0:	20007a24 	.word	0x20007a24
    a5a4:	0000a4e5 	.word	0x0000a4e5
    a5a8:	00009fa1 	.word	0x00009fa1

0000a5ac <grid_ui_event_render_action>:
		return 0;
	}
			
}

uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a5ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a5b0:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
    a5b4:	4606      	mov	r6, r0

	
	uint8_t temp[500] = {0};
    a5b6:	ac05      	add	r4, sp, #20
    a5b8:	4b74      	ldr	r3, [pc, #464]	; (a78c <grid_ui_event_render_action+0x1e0>)
uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a5ba:	9102      	str	r1, [sp, #8]
	uint8_t temp[500] = {0};
    a5bc:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
    a5c0:	2100      	movs	r1, #0
    a5c2:	a806      	add	r0, sp, #24
    a5c4:	6021      	str	r1, [r4, #0]
    a5c6:	4798      	blx	r3

	uint32_t i=0;
	
	// copy event string
	for(true; i<eve->event_string_length; i++){
    a5c8:	68f3      	ldr	r3, [r6, #12]
    a5ca:	18f1      	adds	r1, r6, r3
    a5cc:	f106 0210 	add.w	r2, r6, #16
    a5d0:	4620      	mov	r0, r4
    a5d2:	3110      	adds	r1, #16
    a5d4:	4291      	cmp	r1, r2
    a5d6:	d11e      	bne.n	a616 <grid_ui_event_render_action+0x6a>
		temp[i] = eve->event_string[i];
	
	}

	// copy action string
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a5d8:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a5da:	f106 0134 	add.w	r1, r6, #52	; 0x34
    a5de:	441a      	add	r2, r3
    a5e0:	429a      	cmp	r2, r3
    a5e2:	d81d      	bhi.n	a620 <grid_ui_event_render_action+0x74>


	uint32_t total_substituted_length = 0;

	uint8_t condition_state = 0;
	uint8_t condition_istrue = 0;
    a5e4:	2700      	movs	r7, #0
	uint8_t condition_state = 0;
    a5e6:	9701      	str	r7, [sp, #4]
	uint32_t total_substituted_length = 0;
    a5e8:	463d      	mov	r5, r7
	uint32_t block_start = 0;
    a5ea:	9700      	str	r7, [sp, #0]


	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a5ec:	463c      	mov	r4, r7
    a5ee:	68f0      	ldr	r0, [r6, #12]
    a5f0:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a5f2:	4418      	add	r0, r3
    a5f4:	42a0      	cmp	r0, r4
    a5f6:	d818      	bhi.n	a62a <grid_ui_event_render_action+0x7e>

	}
	
	
	// RESET ENCODER RELATIVE TEMPLATE PARAMETER VALUES
	if(eve->parent->type == GRID_UI_ELEMENT_ENCODER){	
    a5f8:	6873      	ldr	r3, [r6, #4]
    a5fa:	7a5a      	ldrb	r2, [r3, #9]
    a5fc:	2a03      	cmp	r2, #3
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = 255;	
    a5fe:	bf08      	it	eq
    a600:	22ff      	moveq	r2, #255	; 0xff
    }
	
	
	return eve->event_string_length + eve->action_string_length - total_substituted_length;
		
}
    a602:	eba0 0005 	sub.w	r0, r0, r5
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = 255;	
    a606:	bf04      	itt	eq
    a608:	e9c3 220d 	strdeq	r2, r2, [r3, #52]	; 0x34
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = 255;	
    a60c:	63da      	streq	r2, [r3, #60]	; 0x3c
}
    a60e:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
    a612:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		temp[i] = eve->event_string[i];
    a616:	f812 5b01 	ldrb.w	r5, [r2], #1
    a61a:	f800 5b01 	strb.w	r5, [r0], #1
	for(true; i<eve->event_string_length; i++){
    a61e:	e7d9      	b.n	a5d4 <grid_ui_event_render_action+0x28>
		temp[i] = eve->action_string[i - eve->event_string_length];
    a620:	f811 0b01 	ldrb.w	r0, [r1], #1
    a624:	54e0      	strb	r0, [r4, r3]
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a626:	3301      	adds	r3, #1
    a628:	e7da      	b.n	a5e0 <grid_ui_event_render_action+0x34>
		target_string[i-total_substituted_length] = temp[i];
    a62a:	f10d 0914 	add.w	r9, sp, #20
    a62e:	9a02      	ldr	r2, [sp, #8]
    a630:	f819 3004 	ldrb.w	r3, [r9, r4]
    a634:	eba4 0805 	sub.w	r8, r4, r5
		if (temp[i] == '{'){
    a638:	2b7b      	cmp	r3, #123	; 0x7b
		target_string[i-total_substituted_length] = temp[i];
    a63a:	f802 3008 	strb.w	r3, [r2, r8]
		if (temp[i] == '{'){
    a63e:	f000 80a2 	beq.w	a786 <grid_ui_event_render_action+0x1da>
		else if (temp[i] == '}'){
    a642:	2b7d      	cmp	r3, #125	; 0x7d
    a644:	f104 0a01 	add.w	sl, r4, #1
    a648:	d145      	bne.n	a6d6 <grid_ui_event_render_action+0x12a>
			if (block_length){
    a64a:	9b00      	ldr	r3, [sp, #0]
    a64c:	ebba 0b03 	subs.w	fp, sl, r3
    a650:	d030      	beq.n	a6b4 <grid_ui_event_render_action+0x108>
				grid_expr_set_current_event(&grid_expr_state, eve);
    a652:	4b4f      	ldr	r3, [pc, #316]	; (a790 <grid_ui_event_render_action+0x1e4>)
    a654:	484f      	ldr	r0, [pc, #316]	; (a794 <grid_ui_event_render_action+0x1e8>)
    a656:	4631      	mov	r1, r6
    a658:	4798      	blx	r3
				grid_expr_evaluate(&grid_expr_state, &temp[block_start+1], block_length-2); // -2 to not include {
    a65a:	9b00      	ldr	r3, [sp, #0]
    a65c:	484d      	ldr	r0, [pc, #308]	; (a794 <grid_ui_event_render_action+0x1e8>)
    a65e:	3301      	adds	r3, #1
    a660:	f1ab 0202 	sub.w	r2, fp, #2
    a664:	eb09 0103 	add.w	r1, r9, r3
    a668:	b2d2      	uxtb	r2, r2
    a66a:	f8df 9134 	ldr.w	r9, [pc, #308]	; a7a0 <grid_ui_event_render_action+0x1f4>
    a66e:	9303      	str	r3, [sp, #12]
    a670:	47c8      	blx	r9
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a672:	9b03      	ldr	r3, [sp, #12]
				for (uint8_t j = 0; j<block_length; j++){
    a674:	2100      	movs	r1, #0
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a676:	eb08 0003 	add.w	r0, r8, r3
    a67a:	eba0 0e0a 	sub.w	lr, r0, sl
    a67e:	468c      	mov	ip, r1
				for (uint8_t j = 0; j<block_length; j++){
    a680:	b2ca      	uxtb	r2, r1
    a682:	4593      	cmp	fp, r2
    a684:	f101 0101 	add.w	r1, r1, #1
    a688:	d816      	bhi.n	a6b8 <grid_ui_event_render_action+0x10c>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a68a:	4498      	add	r8, r3
    a68c:	9b02      	ldr	r3, [sp, #8]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a68e:	4a41      	ldr	r2, [pc, #260]	; (a794 <grid_ui_event_render_action+0x1e8>)
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a690:	eba8 0a0a 	sub.w	sl, r8, sl
    a694:	2000      	movs	r0, #0
    a696:	449a      	add	sl, r3
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a698:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
    a69c:	b2c1      	uxtb	r1, r0
    a69e:	428b      	cmp	r3, r1
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a6a0:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a6a4:	d80d      	bhi.n	a6c2 <grid_ui_event_render_action+0x116>
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    a6a6:	1aed      	subs	r5, r5, r3
				if (condition_state == 1){
    a6a8:	9b01      	ldr	r3, [sp, #4]
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    a6aa:	445d      	add	r5, fp
				if (condition_state == 1){
    a6ac:	b113      	cbz	r3, a6b4 <grid_ui_event_render_action+0x108>
					condition_istrue = grid_expr_state.return_value;
    a6ae:	f8d2 71fc 	ldr.w	r7, [r2, #508]	; 0x1fc
    a6b2:	b2ff      	uxtb	r7, r7
	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a6b4:	3401      	adds	r4, #1
    a6b6:	e79a      	b.n	a5ee <grid_ui_event_render_action+0x42>
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    a6b8:	9802      	ldr	r0, [sp, #8]
    a6ba:	4402      	add	r2, r0
    a6bc:	f802 c00e 	strb.w	ip, [r2, lr]
				for (uint8_t j = 0; j<block_length; j++){
    a6c0:	e7de      	b.n	a680 <grid_ui_event_render_action+0xd4>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    a6c2:	f1c3 03fa 	rsb	r3, r3, #250	; 0xfa
    a6c6:	440b      	add	r3, r1
    a6c8:	4413      	add	r3, r2
    a6ca:	3001      	adds	r0, #1
    a6cc:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
    a6d0:	f80a 3001 	strb.w	r3, [sl, r1]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    a6d4:	e7e0      	b.n	a698 <grid_ui_event_render_action+0xec>
		else if(temp[i] == '#'){
    a6d6:	2b23      	cmp	r3, #35	; 0x23
    a6d8:	d1ec      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
			if (temp[i+1] == 'I' && temp[i+2] == 'F' ){
    a6da:	f819 300a 	ldrb.w	r3, [r9, sl]
    a6de:	2b49      	cmp	r3, #73	; 0x49
    a6e0:	d109      	bne.n	a6f6 <grid_ui_event_render_action+0x14a>
    a6e2:	1ca3      	adds	r3, r4, #2
    a6e4:	f819 2003 	ldrb.w	r2, [r9, r3]
    a6e8:	2a46      	cmp	r2, #70	; 0x46
    a6ea:	d1e3      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
				i+=2;
    a6ec:	461c      	mov	r4, r3
				condition_state = 1;
    a6ee:	2301      	movs	r3, #1
				total_substituted_length += 3;
    a6f0:	3503      	adds	r5, #3
				condition_state = 1;
    a6f2:	9301      	str	r3, [sp, #4]
    a6f4:	e7de      	b.n	a6b4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'T' && temp[i+2] == 'H' ){
    a6f6:	2b54      	cmp	r3, #84	; 0x54
    a6f8:	d121      	bne.n	a73e <grid_ui_event_render_action+0x192>
    a6fa:	1ca3      	adds	r3, r4, #2
    a6fc:	f819 2003 	ldrb.w	r2, [r9, r3]
    a700:	2a48      	cmp	r2, #72	; 0x48
    a702:	d1d7      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
				if (!condition_istrue){
    a704:	bbaf      	cbnz	r7, a772 <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a706:	f04f 0801 	mov.w	r8, #1
    a70a:	e009      	b.n	a720 <grid_ui_event_render_action+0x174>
						else if(j==(eve->event_string_length + eve->action_string_length)-i-1){
    a70c:	3b01      	subs	r3, #1
    a70e:	4543      	cmp	r3, r8
    a710:	d102      	bne.n	a718 <grid_ui_event_render_action+0x16c>
							printf("Syntax Error!\r\n");
    a712:	4821      	ldr	r0, [pc, #132]	; (a798 <grid_ui_event_render_action+0x1ec>)
    a714:	4b21      	ldr	r3, [pc, #132]	; (a79c <grid_ui_event_render_action+0x1f0>)
    a716:	4798      	blx	r3
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a718:	f108 0801 	add.w	r8, r8, #1
    a71c:	fa5f f888 	uxtb.w	r8, r8
    a720:	68f3      	ldr	r3, [r6, #12]
    a722:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a724:	4413      	add	r3, r2
    a726:	1b1b      	subs	r3, r3, r4
    a728:	4598      	cmp	r8, r3
    a72a:	d2c3      	bcs.n	a6b4 <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    a72c:	eb08 0204 	add.w	r2, r8, r4
    a730:	f819 1002 	ldrb.w	r1, [r9, r2]
    a734:	2923      	cmp	r1, #35	; 0x23
    a736:	d1e9      	bne.n	a70c <grid_ui_event_render_action+0x160>
							total_substituted_length += j;
    a738:	4445      	add	r5, r8
							i+=j-1;
    a73a:	1e54      	subs	r4, r2, #1
							break;
    a73c:	e7ba      	b.n	a6b4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'L' ){
    a73e:	2b45      	cmp	r3, #69	; 0x45
    a740:	d1b8      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
    a742:	1ca3      	adds	r3, r4, #2
    a744:	f819 2003 	ldrb.w	r2, [r9, r3]
    a748:	2a4c      	cmp	r2, #76	; 0x4c
    a74a:	d115      	bne.n	a778 <grid_ui_event_render_action+0x1cc>
				if (condition_istrue){
    a74c:	b18f      	cbz	r7, a772 <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a74e:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a750:	68f3      	ldr	r3, [r6, #12]
    a752:	4413      	add	r3, r2
    a754:	1b1a      	subs	r2, r3, r4
    a756:	2301      	movs	r3, #1
    a758:	4293      	cmp	r3, r2
    a75a:	d2ab      	bcs.n	a6b4 <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    a75c:	1919      	adds	r1, r3, r4
    a75e:	f819 0001 	ldrb.w	r0, [r9, r1]
    a762:	2823      	cmp	r0, #35	; 0x23
    a764:	d102      	bne.n	a76c <grid_ui_event_render_action+0x1c0>
							total_substituted_length += j;
    a766:	441d      	add	r5, r3
							i+=j-1;
    a768:	1e4c      	subs	r4, r1, #1
							break;
    a76a:	e7a3      	b.n	a6b4 <grid_ui_event_render_action+0x108>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    a76c:	3301      	adds	r3, #1
    a76e:	b2db      	uxtb	r3, r3
    a770:	e7f2      	b.n	a758 <grid_ui_event_render_action+0x1ac>
					total_substituted_length += 3;
    a772:	3503      	adds	r5, #3
					i+=2;
    a774:	461c      	mov	r4, r3
    a776:	e79d      	b.n	a6b4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'N' ){
    a778:	2a4e      	cmp	r2, #78	; 0x4e
    a77a:	d19b      	bne.n	a6b4 <grid_ui_event_render_action+0x108>
				condition_istrue = 0;
    a77c:	2700      	movs	r7, #0
				total_substituted_length += 3;
    a77e:	3503      	adds	r5, #3
				i+=2;
    a780:	461c      	mov	r4, r3
				condition_state = 0;
    a782:	9701      	str	r7, [sp, #4]
    a784:	e796      	b.n	a6b4 <grid_ui_event_render_action+0x108>
    a786:	9400      	str	r4, [sp, #0]
    a788:	e794      	b.n	a6b4 <grid_ui_event_render_action+0x108>
    a78a:	bf00      	nop
    a78c:	00014175 	.word	0x00014175
    a790:	00006411 	.word	0x00006411
    a794:	2000bc3c 	.word	0x2000bc3c
    a798:	00016dc1 	.word	0x00016dc1
    a79c:	000144c9 	.word	0x000144c9
    a7a0:	00006ba1 	.word	0x00006ba1

0000a7a4 <grid_port_process_ui>:
void grid_port_process_ui(struct grid_port* por){
    a7a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7a8:	4fb1      	ldr	r7, [pc, #708]	; (aa70 <grid_port_process_ui+0x2cc>)
void grid_port_process_ui(struct grid_port* por){
    a7aa:	f5ad 7d57 	sub.w	sp, sp, #860	; 0x35c
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7ae:	2100      	movs	r1, #0
void grid_port_process_ui(struct grid_port* por){
    a7b0:	9001      	str	r0, [sp, #4]
	uint8_t message_local_action_available = 0;
    a7b2:	4688      	mov	r8, r1
	uint8_t message_broadcast_action_available = 0;
    a7b4:	460d      	mov	r5, r1
    a7b6:	46ba      	mov	sl, r7
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a7b8:	f04f 0c64 	mov.w	ip, #100	; 0x64
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7bc:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a7c0:	787a      	ldrb	r2, [r7, #1]
    a7c2:	b2cb      	uxtb	r3, r1
    a7c4:	429a      	cmp	r2, r3
    a7c6:	d95e      	bls.n	a886 <grid_port_process_ui+0xe2>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a7c8:	011b      	lsls	r3, r3, #4
    a7ca:	2400      	movs	r4, #0
    a7cc:	e02e      	b.n	a82c <grid_port_process_ui+0x88>
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7ce:	f8da 9004 	ldr.w	r9, [sl, #4]
    a7d2:	4499      	add	r9, r3
    a7d4:	fb0e f000 	mul.w	r0, lr, r0
    a7d8:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a7dc:	4491      	add	r9, r2
    a7de:	3601      	adds	r6, #1
    a7e0:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    a7e4:	4481      	add	r9, r0
    a7e6:	f899 9009 	ldrb.w	r9, [r9, #9]
    a7ea:	f1b9 0f05 	cmp.w	r9, #5
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7ee:	f8da 9004 	ldr.w	r9, [sl, #4]
    a7f2:	4499      	add	r9, r3
					message_broadcast_action_available++;
    a7f4:	bf08      	it	eq
    a7f6:	3501      	addeq	r5, #1
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a7f8:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a7fc:	4491      	add	r9, r2
					message_broadcast_action_available++;
    a7fe:	bf08      	it	eq
    a800:	b2ed      	uxtbeq	r5, r5
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a802:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    a806:	4448      	add	r0, r9
    a808:	7a40      	ldrb	r0, [r0, #9]
    a80a:	2806      	cmp	r0, #6
                    message_local_action_available++;
    a80c:	bf04      	itt	eq
    a80e:	f108 0801 	addeq.w	r8, r8, #1
    a812:	fa5f f888 	uxtbeq.w	r8, r8
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a816:	f8da 0004 	ldr.w	r0, [sl, #4]
    a81a:	4418      	add	r0, r3
    a81c:	68c0      	ldr	r0, [r0, #12]
    a81e:	4410      	add	r0, r2
    a820:	f890 905c 	ldrb.w	r9, [r0, #92]	; 0x5c
    a824:	b2f0      	uxtb	r0, r6
    a826:	4581      	cmp	r9, r0
    a828:	d8d1      	bhi.n	a7ce <grid_port_process_ui+0x2a>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a82a:	3401      	adds	r4, #1
    a82c:	f8da 2004 	ldr.w	r2, [sl, #4]
    a830:	441a      	add	r2, r3
    a832:	7a50      	ldrb	r0, [r2, #9]
    a834:	b2e2      	uxtb	r2, r4
    a836:	4290      	cmp	r0, r2
    a838:	d903      	bls.n	a842 <grid_port_process_ui+0x9e>
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a83a:	fb0c f202 	mul.w	r2, ip, r2
    a83e:	2600      	movs	r6, #0
    a840:	e7e9      	b.n	a816 <grid_port_process_ui+0x72>
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    a842:	3101      	adds	r1, #1
    a844:	e7bc      	b.n	a7c0 <grid_port_process_ui+0x1c>
			if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    a846:	6870      	ldr	r0, [r6, #4]
    a848:	68c0      	ldr	r0, [r0, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a84a:	eb00 0e03 	add.w	lr, r0, r3
    a84e:	3201      	adds	r2, #1
    a850:	f8de 0060 	ldr.w	r0, [lr, #96]	; 0x60
    a854:	fb0c 0009 	mla	r0, ip, r9, r0
    a858:	7a40      	ldrb	r0, [r0, #9]
    a85a:	2805      	cmp	r0, #5
				message_broadcast_action_available++;
    a85c:	bf04      	itt	eq
    a85e:	3501      	addeq	r5, #1
    a860:	b2ed      	uxtbeq	r5, r5
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a862:	6870      	ldr	r0, [r6, #4]
    a864:	68c0      	ldr	r0, [r0, #12]
    a866:	4418      	add	r0, r3
    a868:	fa5f f982 	uxtb.w	r9, r2
    a86c:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
    a870:	4548      	cmp	r0, r9
    a872:	d8e8      	bhi.n	a846 <grid_port_process_ui+0xa2>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a874:	3101      	adds	r1, #1
    a876:	6863      	ldr	r3, [r4, #4]
    a878:	7a5a      	ldrb	r2, [r3, #9]
    a87a:	b2cb      	uxtb	r3, r1
    a87c:	429a      	cmp	r2, r3
    a87e:	d909      	bls.n	a894 <grid_port_process_ui+0xf0>
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a880:	437b      	muls	r3, r7
    a882:	2200      	movs	r2, #0
    a884:	e7ed      	b.n	a862 <grid_port_process_ui+0xbe>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    a886:	4c7b      	ldr	r4, [pc, #492]	; (aa74 <grid_port_process_ui+0x2d0>)
    a888:	2100      	movs	r1, #0
    a88a:	4626      	mov	r6, r4
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    a88c:	2764      	movs	r7, #100	; 0x64
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    a88e:	f04f 0cbc 	mov.w	ip, #188	; 0xbc
    a892:	e7f0      	b.n	a876 <grid_port_process_ui+0xd2>
	struct grid_port* port[4] = {&GRID_PORT_N, &GRID_PORT_E, &GRID_PORT_S, &GRID_PORT_W};
    a894:	4b78      	ldr	r3, [pc, #480]	; (aa78 <grid_port_process_ui+0x2d4>)
    a896:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    a898:	ae07      	add	r6, sp, #28
    a89a:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    a89e:	2404      	movs	r4, #4
		if (port[k]->ping_flag == 1){
    a8a0:	f856 7b04 	ldr.w	r7, [r6], #4
    a8a4:	f642 7348 	movw	r3, #12104	; 0x2f48
    a8a8:	5cfb      	ldrb	r3, [r7, r3]
    a8aa:	2b01      	cmp	r3, #1
    a8ac:	d11f      	bne.n	a8ee <grid_port_process_ui+0x14a>
			if (grid_buffer_write_init(&port[k]->tx_buffer, port[k]->ping_packet_length)){
    a8ae:	f642 7347 	movw	r3, #12103	; 0x2f47
    a8b2:	f507 591c 	add.w	r9, r7, #9984	; 0x2700
    a8b6:	f109 093c 	add.w	r9, r9, #60	; 0x3c
    a8ba:	18fa      	adds	r2, r7, r3
    a8bc:	5cf9      	ldrb	r1, [r7, r3]
    a8be:	4b6f      	ldr	r3, [pc, #444]	; (aa7c <grid_port_process_ui+0x2d8>)
    a8c0:	9202      	str	r2, [sp, #8]
    a8c2:	4648      	mov	r0, r9
    a8c4:	4798      	blx	r3
    a8c6:	b170      	cbz	r0, a8e6 <grid_port_process_ui+0x142>
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    a8c8:	4b6d      	ldr	r3, [pc, #436]	; (aa80 <grid_port_process_ui+0x2dc>)
    a8ca:	f507 5b3c 	add.w	fp, r7, #12032	; 0x2f00
    a8ce:	f10b 0b33 	add.w	fp, fp, #51	; 0x33
    a8d2:	1bdb      	subs	r3, r3, r7
    a8d4:	9a02      	ldr	r2, [sp, #8]
    a8d6:	7811      	ldrb	r1, [r2, #0]
    a8d8:	eb03 020b 	add.w	r2, r3, fp
    a8dc:	4291      	cmp	r1, r2
    a8de:	d826      	bhi.n	a92e <grid_port_process_ui+0x18a>
				grid_buffer_write_acknowledge(&port[k]->tx_buffer);
    a8e0:	4b68      	ldr	r3, [pc, #416]	; (aa84 <grid_port_process_ui+0x2e0>)
    a8e2:	4648      	mov	r0, r9
    a8e4:	4798      	blx	r3
			port[k]->ping_flag = 0;
    a8e6:	f642 7248 	movw	r2, #12104	; 0x2f48
    a8ea:	2300      	movs	r3, #0
    a8ec:	54bb      	strb	r3, [r7, r2]
	for (uint8_t k = 0; k<4; k++){
    a8ee:	3c01      	subs	r4, #1
    a8f0:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    a8f4:	d1d4      	bne.n	a8a0 <grid_port_process_ui+0xfc>
	if (message_local_action_available){
    a8f6:	f1b8 0f00 	cmp.w	r8, #0
    a8fa:	d07e      	beq.n	a9fa <grid_port_process_ui+0x256>
		grid_msg_init(&message);
    a8fc:	4b62      	ldr	r3, [pc, #392]	; (aa88 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a8fe:	4e63      	ldr	r6, [pc, #396]	; (aa8c <grid_port_process_ui+0x2e8>)
		grid_msg_init(&message);
    a900:	a86f      	add	r0, sp, #444	; 0x1bc
    a902:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a904:	227f      	movs	r2, #127	; 0x7f
    a906:	4611      	mov	r1, r2
    a908:	4623      	mov	r3, r4
    a90a:	a86f      	add	r0, sp, #444	; 0x1bc
    a90c:	47b0      	blx	r6
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};				
    a90e:	4b60      	ldr	r3, [pc, #384]	; (aa90 <grid_port_process_ui+0x2ec>)
    a910:	940b      	str	r4, [sp, #44]	; 0x2c
    a912:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a916:	4621      	mov	r1, r4
    a918:	a80c      	add	r0, sp, #48	; 0x30
    a91a:	4798      	blx	r3
		uint32_t offset=0;
    a91c:	46a0      	mov	r8, r4
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    a91e:	f89a 3001 	ldrb.w	r3, [sl, #1]
    a922:	b2e6      	uxtb	r6, r4
    a924:	42b3      	cmp	r3, r6
    a926:	d956      	bls.n	a9d6 <grid_port_process_ui+0x232>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a928:	0136      	lsls	r6, r6, #4
    a92a:	2300      	movs	r3, #0
    a92c:	e043      	b.n	a9b6 <grid_port_process_ui+0x212>
    a92e:	9303      	str	r3, [sp, #12]
					grid_buffer_write_character(&port[k]->tx_buffer, port[k]->ping_packet[i]);
    a930:	f81b 1b01 	ldrb.w	r1, [fp], #1
    a934:	4b57      	ldr	r3, [pc, #348]	; (aa94 <grid_port_process_ui+0x2f0>)
    a936:	4648      	mov	r0, r9
    a938:	4798      	blx	r3
    a93a:	9b03      	ldr	r3, [sp, #12]
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    a93c:	e7ca      	b.n	a8d4 <grid_port_process_ui+0x130>
					if (offset>GRID_PARAMETER_PACKET_marign){
    a93e:	f1b8 0fc8 	cmp.w	r8, #200	; 0xc8
    a942:	d829      	bhi.n	a998 <grid_port_process_ui+0x1f4>
						CRITICAL_SECTION_ENTER()
    a944:	4b54      	ldr	r3, [pc, #336]	; (aa98 <grid_port_process_ui+0x2f4>)
    a946:	a805      	add	r0, sp, #20
    a948:	4798      	blx	r3
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a94a:	f8da 3004 	ldr.w	r3, [sl, #4]
    a94e:	4433      	add	r3, r6
    a950:	22bc      	movs	r2, #188	; 0xbc
    a952:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a954:	443b      	add	r3, r7
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    a956:	fb02 fb0b 	mul.w	fp, r2, fp
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    a95a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    a95c:	445b      	add	r3, fp
    a95e:	7a5b      	ldrb	r3, [r3, #9]
    a960:	2b06      	cmp	r3, #6
    a962:	d116      	bne.n	a992 <grid_port_process_ui+0x1ee>
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    a964:	f8da 3004 	ldr.w	r3, [sl, #4]
    a968:	4433      	add	r3, r6
    a96a:	68db      	ldr	r3, [r3, #12]
    a96c:	443b      	add	r3, r7
    a96e:	6e18      	ldr	r0, [r3, #96]	; 0x60
    a970:	ab0b      	add	r3, sp, #44	; 0x2c
    a972:	eb03 0108 	add.w	r1, r3, r8
    a976:	4458      	add	r0, fp
    a978:	4b48      	ldr	r3, [pc, #288]	; (aa9c <grid_port_process_ui+0x2f8>)
    a97a:	4798      	blx	r3
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    a97c:	f8da 3004 	ldr.w	r3, [sl, #4]
    a980:	4433      	add	r3, r6
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    a982:	4480      	add	r8, r0
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    a984:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    a986:	443b      	add	r3, r7
    a988:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    a98a:	449b      	add	fp, r3
    a98c:	2304      	movs	r3, #4
    a98e:	f88b 3009 	strb.w	r3, [fp, #9]
						CRITICAL_SECTION_LEAVE()
    a992:	4b43      	ldr	r3, [pc, #268]	; (aaa0 <grid_port_process_ui+0x2fc>)
    a994:	a805      	add	r0, sp, #20
    a996:	4798      	blx	r3
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a998:	f109 0901 	add.w	r9, r9, #1
    a99c:	f8da 3004 	ldr.w	r3, [sl, #4]
    a9a0:	4433      	add	r3, r6
    a9a2:	fa5f fb89 	uxtb.w	fp, r9
    a9a6:	68db      	ldr	r3, [r3, #12]
    a9a8:	443b      	add	r3, r7
    a9aa:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    a9ae:	455b      	cmp	r3, fp
    a9b0:	d8c5      	bhi.n	a93e <grid_port_process_ui+0x19a>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    a9b2:	9b02      	ldr	r3, [sp, #8]
    a9b4:	3301      	adds	r3, #1
    a9b6:	9302      	str	r3, [sp, #8]
    a9b8:	f8da 3004 	ldr.w	r3, [sl, #4]
    a9bc:	4433      	add	r3, r6
    a9be:	7a5a      	ldrb	r2, [r3, #9]
    a9c0:	f89d 3008 	ldrb.w	r3, [sp, #8]
    a9c4:	429a      	cmp	r2, r3
    a9c6:	d904      	bls.n	a9d2 <grid_port_process_ui+0x22e>
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    a9c8:	2764      	movs	r7, #100	; 0x64
    a9ca:	435f      	muls	r7, r3
    a9cc:	f04f 0900 	mov.w	r9, #0
    a9d0:	e7e4      	b.n	a99c <grid_port_process_ui+0x1f8>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    a9d2:	3401      	adds	r4, #1
    a9d4:	e7a3      	b.n	a91e <grid_port_process_ui+0x17a>
		grid_msg_body_append_text(&message, payload, offset);
    a9d6:	a90b      	add	r1, sp, #44	; 0x2c
    a9d8:	4642      	mov	r2, r8
    a9da:	4b32      	ldr	r3, [pc, #200]	; (aaa4 <grid_port_process_ui+0x300>)
    a9dc:	a86f      	add	r0, sp, #444	; 0x1bc
    a9de:	4798      	blx	r3
		grid_msg_packet_close(&message);
    a9e0:	4b31      	ldr	r3, [pc, #196]	; (aaa8 <grid_port_process_ui+0x304>)
    a9e2:	a86f      	add	r0, sp, #444	; 0x1bc
    a9e4:	4798      	blx	r3
		uint32_t message_length = grid_msg_packet_get_length(&message);
    a9e6:	4b31      	ldr	r3, [pc, #196]	; (aaac <grid_port_process_ui+0x308>)
    a9e8:	a86f      	add	r0, sp, #444	; 0x1bc
    a9ea:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    a9ec:	4b23      	ldr	r3, [pc, #140]	; (aa7c <grid_port_process_ui+0x2d8>)
		uint32_t message_length = grid_msg_packet_get_length(&message);
    a9ee:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    a9f0:	b281      	uxth	r1, r0
    a9f2:	482f      	ldr	r0, [pc, #188]	; (aab0 <grid_port_process_ui+0x30c>)
    a9f4:	4798      	blx	r3
    a9f6:	2800      	cmp	r0, #0
    a9f8:	d132      	bne.n	aa60 <grid_port_process_ui+0x2bc>
	if (por->cooldown > 0){
    a9fa:	9b01      	ldr	r3, [sp, #4]
    a9fc:	681b      	ldr	r3, [r3, #0]
    a9fe:	b12b      	cbz	r3, aa0c <grid_port_process_ui+0x268>
		por->cooldown--;
    aa00:	3b01      	subs	r3, #1
    aa02:	9a01      	ldr	r2, [sp, #4]
	if (por->cooldown > 10){
    aa04:	2b0a      	cmp	r3, #10
		por->cooldown--;
    aa06:	6013      	str	r3, [r2, #0]
	if (por->cooldown > 10){
    aa08:	f200 80fc 	bhi.w	ac04 <grid_port_process_ui+0x460>
	if (message_broadcast_action_available){
    aa0c:	2d00      	cmp	r5, #0
    aa0e:	f000 80f9 	beq.w	ac04 <grid_port_process_ui+0x460>
		grid_msg_init(&message);
    aa12:	4b1d      	ldr	r3, [pc, #116]	; (aa88 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    aa14:	4c1d      	ldr	r4, [pc, #116]	; (aa8c <grid_port_process_ui+0x2e8>)
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    aa16:	f8df 805c 	ldr.w	r8, [pc, #92]	; aa74 <grid_port_process_ui+0x2d0>
		grid_msg_init(&message);
    aa1a:	a86f      	add	r0, sp, #444	; 0x1bc
    aa1c:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    aa1e:	227f      	movs	r2, #127	; 0x7f
    aa20:	2300      	movs	r3, #0
    aa22:	4611      	mov	r1, r2
    aa24:	a86f      	add	r0, sp, #444	; 0x1bc
    aa26:	47a0      	blx	r4
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    aa28:	2700      	movs	r7, #0
    aa2a:	4645      	mov	r5, r8
    aa2c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    aa30:	7a5a      	ldrb	r2, [r3, #9]
    aa32:	b2fb      	uxtb	r3, r7
    aa34:	429a      	cmp	r2, r3
    aa36:	f240 80d2 	bls.w	abde <grid_port_process_ui+0x43a>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    aa3a:	2464      	movs	r4, #100	; 0x64
					CRITICAL_SECTION_LEAVE()
    aa3c:	f8df b060 	ldr.w	fp, [pc, #96]	; aaa0 <grid_port_process_ui+0x2fc>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    aa40:	435c      	muls	r4, r3
    aa42:	2600      	movs	r6, #0
    aa44:	e067      	b.n	ab16 <grid_port_process_ui+0x372>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    aa46:	4631      	mov	r1, r6
    aa48:	a86f      	add	r0, sp, #444	; 0x1bc
    aa4a:	47b8      	blx	r7
    aa4c:	4601      	mov	r1, r0
    aa4e:	4640      	mov	r0, r8
    aa50:	47c8      	blx	r9
			for(uint32_t i = 0; i<message_length; i++){
    aa52:	3601      	adds	r6, #1
    aa54:	42a6      	cmp	r6, r4
    aa56:	d1f6      	bne.n	aa46 <grid_port_process_ui+0x2a2>
			grid_buffer_write_acknowledge(&GRID_PORT_U.tx_buffer);
    aa58:	4b0a      	ldr	r3, [pc, #40]	; (aa84 <grid_port_process_ui+0x2e0>)
    aa5a:	4815      	ldr	r0, [pc, #84]	; (aab0 <grid_port_process_ui+0x30c>)
    aa5c:	4798      	blx	r3
		}
    aa5e:	e7cc      	b.n	a9fa <grid_port_process_ui+0x256>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    aa60:	4f14      	ldr	r7, [pc, #80]	; (aab4 <grid_port_process_ui+0x310>)
    aa62:	f8df 804c 	ldr.w	r8, [pc, #76]	; aab0 <grid_port_process_ui+0x30c>
    aa66:	f8df 902c 	ldr.w	r9, [pc, #44]	; aa94 <grid_port_process_ui+0x2f0>
			for(uint32_t i = 0; i<message_length; i++){
    aa6a:	2600      	movs	r6, #0
    aa6c:	e7f2      	b.n	aa54 <grid_port_process_ui+0x2b0>
    aa6e:	bf00      	nop
    aa70:	20007a18 	.word	0x20007a18
    aa74:	200151dc 	.word	0x200151dc
    aa78:	00016dd0 	.word	0x00016dd0
    aa7c:	00004839 	.word	0x00004839
    aa80:	ffffd0cd 	.word	0xffffd0cd
    aa84:	00004895 	.word	0x00004895
    aa88:	000085c5 	.word	0x000085c5
    aa8c:	000085f9 	.word	0x000085f9
    aa90:	00014175 	.word	0x00014175
    aa94:	00004875 	.word	0x00004875
    aa98:	00011a11 	.word	0x00011a11
    aa9c:	0000a5ad 	.word	0x0000a5ad
    aaa0:	00011a1f 	.word	0x00011a1f
    aaa4:	00008535 	.word	0x00008535
    aaa8:	000086f1 	.word	0x000086f1
    aaac:	00008521 	.word	0x00008521
    aab0:	20007208 	.word	0x20007208
    aab4:	000086bb 	.word	0x000086bb
				if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    aab8:	4b5e      	ldr	r3, [pc, #376]	; (ac34 <grid_port_process_ui+0x490>)
    aaba:	a86f      	add	r0, sp, #444	; 0x1bc
    aabc:	4798      	blx	r3
    aabe:	28c8      	cmp	r0, #200	; 0xc8
    aac0:	d828      	bhi.n	ab14 <grid_port_process_ui+0x370>
					CRITICAL_SECTION_ENTER()
    aac2:	4b5d      	ldr	r3, [pc, #372]	; (ac38 <grid_port_process_ui+0x494>)
    aac4:	a806      	add	r0, sp, #24
    aac6:	4798      	blx	r3
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aac8:	686b      	ldr	r3, [r5, #4]
    aaca:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aacc:	4423      	add	r3, r4
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aace:	22bc      	movs	r2, #188	; 0xbc
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aad0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    aad2:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aad6:	444b      	add	r3, r9
    aad8:	7a5b      	ldrb	r3, [r3, #9]
    aada:	2b05      	cmp	r3, #5
    aadc:	d118      	bne.n	ab10 <grid_port_process_ui+0x36c>
						uint32_t offset = grid_msg_body_get_length(&message); 
    aade:	4b57      	ldr	r3, [pc, #348]	; (ac3c <grid_port_process_ui+0x498>)
    aae0:	a86f      	add	r0, sp, #444	; 0x1bc
    aae2:	4798      	blx	r3
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    aae4:	686b      	ldr	r3, [r5, #4]
    aae6:	68db      	ldr	r3, [r3, #12]
    aae8:	4423      	add	r3, r4
    aaea:	3014      	adds	r0, #20
    aaec:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    aaee:	aa6f      	add	r2, sp, #444	; 0x1bc
    aaf0:	1811      	adds	r1, r2, r0
    aaf2:	eb03 0009 	add.w	r0, r3, r9
    aaf6:	4b52      	ldr	r3, [pc, #328]	; (ac40 <grid_port_process_ui+0x49c>)
    aaf8:	4798      	blx	r3
    aafa:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    aafc:	4418      	add	r0, r3
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    aafe:	686b      	ldr	r3, [r5, #4]
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    ab00:	90d4      	str	r0, [sp, #848]	; 0x350
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    ab02:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    ab04:	4423      	add	r3, r4
    ab06:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab08:	4499      	add	r9, r3
    ab0a:	2304      	movs	r3, #4
    ab0c:	f889 3009 	strb.w	r3, [r9, #9]
					CRITICAL_SECTION_LEAVE()
    ab10:	a806      	add	r0, sp, #24
    ab12:	47d8      	blx	fp
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ab14:	3601      	adds	r6, #1
    ab16:	686b      	ldr	r3, [r5, #4]
    ab18:	68db      	ldr	r3, [r3, #12]
    ab1a:	4423      	add	r3, r4
    ab1c:	fa5f f986 	uxtb.w	r9, r6
    ab20:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    ab24:	454b      	cmp	r3, r9
    ab26:	d8c7      	bhi.n	aab8 <grid_port_process_ui+0x314>
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    ab28:	3701      	adds	r7, #1
    ab2a:	e77f      	b.n	aa2c <grid_port_process_ui+0x288>
					if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    ab2c:	4b41      	ldr	r3, [pc, #260]	; (ac34 <grid_port_process_ui+0x490>)
    ab2e:	a86f      	add	r0, sp, #444	; 0x1bc
    ab30:	4798      	blx	r3
    ab32:	28c8      	cmp	r0, #200	; 0xc8
    ab34:	d82e      	bhi.n	ab94 <grid_port_process_ui+0x3f0>
						CRITICAL_SECTION_ENTER()
    ab36:	4b40      	ldr	r3, [pc, #256]	; (ac38 <grid_port_process_ui+0x494>)
    ab38:	a80b      	add	r0, sp, #44	; 0x2c
    ab3a:	4798      	blx	r3
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab3c:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab40:	4423      	add	r3, r4
    ab42:	22bc      	movs	r2, #188	; 0xbc
    ab44:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ab46:	442b      	add	r3, r5
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab48:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ab4c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab4e:	444b      	add	r3, r9
    ab50:	7a5b      	ldrb	r3, [r3, #9]
    ab52:	2b05      	cmp	r3, #5
    ab54:	d11c      	bne.n	ab90 <grid_port_process_ui+0x3ec>
							uint32_t offset = grid_msg_body_get_length(&message); 
    ab56:	4b39      	ldr	r3, [pc, #228]	; (ac3c <grid_port_process_ui+0x498>)
    ab58:	a86f      	add	r0, sp, #444	; 0x1bc
    ab5a:	4798      	blx	r3
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    ab5c:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab60:	4423      	add	r3, r4
    ab62:	3014      	adds	r0, #20
    ab64:	68db      	ldr	r3, [r3, #12]
    ab66:	442b      	add	r3, r5
    ab68:	aa6f      	add	r2, sp, #444	; 0x1bc
    ab6a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab6c:	1811      	adds	r1, r2, r0
    ab6e:	eb03 0009 	add.w	r0, r3, r9
    ab72:	4b33      	ldr	r3, [pc, #204]	; (ac40 <grid_port_process_ui+0x49c>)
    ab74:	4798      	blx	r3
    ab76:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    ab78:	4418      	add	r0, r3
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ab7a:	f8da 3004 	ldr.w	r3, [sl, #4]
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    ab7e:	90d4      	str	r0, [sp, #848]	; 0x350
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ab80:	4423      	add	r3, r4
    ab82:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    ab84:	442b      	add	r3, r5
    ab86:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ab88:	4499      	add	r9, r3
    ab8a:	2304      	movs	r3, #4
    ab8c:	f889 3009 	strb.w	r3, [r9, #9]
						CRITICAL_SECTION_LEAVE()
    ab90:	a80b      	add	r0, sp, #44	; 0x2c
    ab92:	47d8      	blx	fp
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    ab94:	f108 0801 	add.w	r8, r8, #1
    ab98:	f8da 3004 	ldr.w	r3, [sl, #4]
    ab9c:	4423      	add	r3, r4
    ab9e:	fa5f f988 	uxtb.w	r9, r8
    aba2:	68db      	ldr	r3, [r3, #12]
    aba4:	442b      	add	r3, r5
    aba6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    abaa:	454b      	cmp	r3, r9
    abac:	d8be      	bhi.n	ab2c <grid_port_process_ui+0x388>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    abae:	3601      	adds	r6, #1
    abb0:	f8da 3004 	ldr.w	r3, [sl, #4]
    abb4:	4423      	add	r3, r4
    abb6:	7a5a      	ldrb	r2, [r3, #9]
    abb8:	b2f3      	uxtb	r3, r6
    abba:	429a      	cmp	r2, r3
    abbc:	d906      	bls.n	abcc <grid_port_process_ui+0x428>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    abbe:	2564      	movs	r5, #100	; 0x64
						CRITICAL_SECTION_LEAVE()
    abc0:	f8df b094 	ldr.w	fp, [pc, #148]	; ac58 <grid_port_process_ui+0x4b4>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    abc4:	435d      	muls	r5, r3
    abc6:	f04f 0800 	mov.w	r8, #0
    abca:	e7e5      	b.n	ab98 <grid_port_process_ui+0x3f4>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    abcc:	3701      	adds	r7, #1
    abce:	f89a 3001 	ldrb.w	r3, [sl, #1]
    abd2:	b2fc      	uxtb	r4, r7
    abd4:	42a3      	cmp	r3, r4
    abd6:	d904      	bls.n	abe2 <grid_port_process_ui+0x43e>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    abd8:	0124      	lsls	r4, r4, #4
    abda:	2600      	movs	r6, #0
    abdc:	e7e8      	b.n	abb0 <grid_port_process_ui+0x40c>
    abde:	2700      	movs	r7, #0
    abe0:	e7f5      	b.n	abce <grid_port_process_ui+0x42a>
		por->cooldown += 10;
    abe2:	9b01      	ldr	r3, [sp, #4]
    abe4:	9a01      	ldr	r2, [sp, #4]
    abe6:	681b      	ldr	r3, [r3, #0]
    abe8:	330a      	adds	r3, #10
    abea:	6013      	str	r3, [r2, #0]
		grid_msg_packet_close(&message);
    abec:	a86f      	add	r0, sp, #444	; 0x1bc
    abee:	4b15      	ldr	r3, [pc, #84]	; (ac44 <grid_port_process_ui+0x4a0>)
    abf0:	4798      	blx	r3
		uint32_t length = grid_msg_packet_get_length(&message);
    abf2:	4b10      	ldr	r3, [pc, #64]	; (ac34 <grid_port_process_ui+0x490>)
    abf4:	a86f      	add	r0, sp, #444	; 0x1bc
    abf6:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    abf8:	4b13      	ldr	r3, [pc, #76]	; (ac48 <grid_port_process_ui+0x4a4>)
		uint32_t length = grid_msg_packet_get_length(&message);
    abfa:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    abfc:	b281      	uxth	r1, r0
    abfe:	4813      	ldr	r0, [pc, #76]	; (ac4c <grid_port_process_ui+0x4a8>)
    ac00:	4798      	blx	r3
    ac02:	b988      	cbnz	r0, ac28 <grid_port_process_ui+0x484>
}
    ac04:	f50d 7d57 	add.w	sp, sp, #860	; 0x35c
    ac08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    ac0c:	a86f      	add	r0, sp, #444	; 0x1bc
    ac0e:	47b0      	blx	r6
    ac10:	4601      	mov	r1, r0
    ac12:	4638      	mov	r0, r7
    ac14:	47c0      	blx	r8
			for(uint16_t i = 0; i<length; i++){
    ac16:	b2a9      	uxth	r1, r5
    ac18:	428c      	cmp	r4, r1
    ac1a:	f105 0501 	add.w	r5, r5, #1
    ac1e:	d8f5      	bhi.n	ac0c <grid_port_process_ui+0x468>
			grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    ac20:	4b0b      	ldr	r3, [pc, #44]	; (ac50 <grid_port_process_ui+0x4ac>)
    ac22:	480a      	ldr	r0, [pc, #40]	; (ac4c <grid_port_process_ui+0x4a8>)
    ac24:	4798      	blx	r3
		}
    ac26:	e7ed      	b.n	ac04 <grid_port_process_ui+0x460>
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    ac28:	4e0a      	ldr	r6, [pc, #40]	; (ac54 <grid_port_process_ui+0x4b0>)
    ac2a:	4f08      	ldr	r7, [pc, #32]	; (ac4c <grid_port_process_ui+0x4a8>)
    ac2c:	f8df 802c 	ldr.w	r8, [pc, #44]	; ac5c <grid_port_process_ui+0x4b8>
    ac30:	2500      	movs	r5, #0
    ac32:	e7f0      	b.n	ac16 <grid_port_process_ui+0x472>
    ac34:	00008521 	.word	0x00008521
    ac38:	00011a11 	.word	0x00011a11
    ac3c:	0000852f 	.word	0x0000852f
    ac40:	0000a5ad 	.word	0x0000a5ad
    ac44:	000086f1 	.word	0x000086f1
    ac48:	00004839 	.word	0x00004839
    ac4c:	20007600 	.word	0x20007600
    ac50:	00004895 	.word	0x00004895
    ac54:	000086bb 	.word	0x000086bb
    ac58:	00011a1f 	.word	0x00011a1f
    ac5c:	00004875 	.word	0x00004875

0000ac60 <grid_usb_serial_bulkout_cb>:
	//grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	
	//cdcdf_acm_write(cdcdf_demo_buf, count); /* Echo data */
	return false;                           /* No error. */
}
    ac60:	2000      	movs	r0, #0
    ac62:	4770      	bx	lr

0000ac64 <grid_usb_serial_statechange_cb>:

//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS); /* Another read */
	return false;                                                                                 /* No error. */
}
static bool grid_usb_serial_statechange_cb(usb_cdc_control_signal_t state)
{
    ac64:	b513      	push	{r0, r1, r4, lr}
	
	//grid_sys_alert_set_alert(&grid_sys_state, 0,255,255,2,300);
	
	if (state.rs232.DTR || 1) {
		/* After connection the R/W callbacks can be registered */
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    ac66:	4c06      	ldr	r4, [pc, #24]	; (ac80 <grid_usb_serial_statechange_cb+0x1c>)
{
    ac68:	f8ad 0004 	strh.w	r0, [sp, #4]
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    ac6c:	4905      	ldr	r1, [pc, #20]	; (ac84 <grid_usb_serial_statechange_cb+0x20>)
    ac6e:	2000      	movs	r0, #0
    ac70:	47a0      	blx	r4
		cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE, (FUNC_PTR)grid_usb_serial_bulkin_cb);
    ac72:	4905      	ldr	r1, [pc, #20]	; (ac88 <grid_usb_serial_statechange_cb+0x24>)
    ac74:	2001      	movs	r0, #1
    ac76:	47a0      	blx	r4
		/* Start Rx */
		//cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	}
	return false; /* No error. */
}
    ac78:	2000      	movs	r0, #0
    ac7a:	b002      	add	sp, #8
    ac7c:	bd10      	pop	{r4, pc}
    ac7e:	bf00      	nop
    ac80:	0000bc85 	.word	0x0000bc85
    ac84:	0000ac61 	.word	0x0000ac61
    ac88:	0000acdd 	.word	0x0000acdd

0000ac8c <grid_usb_midi_bulkin_cb>:

	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
	return false;
}
static bool grid_usb_midi_bulkin_cb(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
    ac8c:	b513      	push	{r0, r1, r4, lr}

	grid_sys_alert_set_alert(&grid_sys_state, 255,0,255,2,300);
    ac8e:	2302      	movs	r3, #2
    ac90:	f44f 7296 	mov.w	r2, #300	; 0x12c
    ac94:	e9cd 3200 	strd	r3, r2, [sp]
    ac98:	23ff      	movs	r3, #255	; 0xff
    ac9a:	4804      	ldr	r0, [pc, #16]	; (acac <grid_usb_midi_bulkin_cb+0x20>)
    ac9c:	4c04      	ldr	r4, [pc, #16]	; (acb0 <grid_usb_midi_bulkin_cb+0x24>)
    ac9e:	2200      	movs	r2, #0
    aca0:	4619      	mov	r1, r3
    aca2:	47a0      	blx	r4
	return false;
}
    aca4:	2000      	movs	r0, #0
    aca6:	b002      	add	sp, #8
    aca8:	bd10      	pop	{r4, pc}
    acaa:	bf00      	nop
    acac:	20007a24 	.word	0x20007a24
    acb0:	00009813 	.word	0x00009813

0000acb4 <grid_usb_midi_bulkout_cb>:
{
    acb4:	b513      	push	{r0, r1, r4, lr}
	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
    acb6:	2302      	movs	r3, #2
    acb8:	f44f 7296 	mov.w	r2, #300	; 0x12c
    acbc:	e9cd 3200 	strd	r3, r2, [sp]
    acc0:	22ff      	movs	r2, #255	; 0xff
    acc2:	4804      	ldr	r0, [pc, #16]	; (acd4 <grid_usb_midi_bulkout_cb+0x20>)
    acc4:	4c04      	ldr	r4, [pc, #16]	; (acd8 <grid_usb_midi_bulkout_cb+0x24>)
    acc6:	2300      	movs	r3, #0
    acc8:	4611      	mov	r1, r2
    acca:	47a0      	blx	r4
}
    accc:	2000      	movs	r0, #0
    acce:	b002      	add	sp, #8
    acd0:	bd10      	pop	{r4, pc}
    acd2:	bf00      	nop
    acd4:	20007a24 	.word	0x20007a24
    acd8:	00009813 	.word	0x00009813

0000acdc <grid_usb_serial_bulkin_cb>:
    acdc:	2000      	movs	r0, #0
    acde:	4770      	bx	lr

0000ace0 <grid_usb_serial_init>:
	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)grid_usb_serial_statechange_cb);
    ace0:	4901      	ldr	r1, [pc, #4]	; (ace8 <grid_usb_serial_init+0x8>)
    ace2:	4b02      	ldr	r3, [pc, #8]	; (acec <grid_usb_serial_init+0xc>)
    ace4:	2003      	movs	r0, #3
    ace6:	4718      	bx	r3
    ace8:	0000ac65 	.word	0x0000ac65
    acec:	0000bc85 	.word	0x0000bc85

0000acf0 <grid_keyboard_cleanup>:
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
	
	uint8_t changed_flag = 0;
	
	// Remove all inactive (released) keys
	for(uint8_t i=0; i<kb->key_active_count; i++){
    acf0:	2300      	movs	r3, #0
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    acf2:	b5f0      	push	{r4, r5, r6, r7, lr}
			
			changed_flag = 1;
			
			kb->key_list[i].ismodifier = 0;
			kb->key_list[i].ispressed = 0;
			kb->key_list[i].keycode = 255;	
    acf4:	f04f 0cff 	mov.w	ip, #255	; 0xff
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    acf8:	4604      	mov	r4, r0
			// Pop item, move each remaining after this forvard one index
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
				
				kb->key_list[j-1] = kb->key_list[j];
				
				kb->key_list[j].ismodifier = 0;
    acfa:	469e      	mov	lr, r3
	uint8_t changed_flag = 0;
    acfc:	4618      	mov	r0, r3
	for(uint8_t i=0; i<kb->key_active_count; i++){
    acfe:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    ad02:	429d      	cmp	r5, r3
    ad04:	d800      	bhi.n	ad08 <grid_keyboard_cleanup+0x18>
		// USB SEND
	}
	
	return changed_flag;
	
}
    ad06:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (kb->key_list[i].ispressed == false){
    ad08:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    ad0c:	7d8f      	ldrb	r7, [r1, #22]
    ad0e:	b98f      	cbnz	r7, ad34 <grid_keyboard_cleanup+0x44>
    ad10:	1c5a      	adds	r2, r3, #1
    ad12:	b2d6      	uxtb	r6, r2
			kb->key_list[i].ismodifier = 0;
    ad14:	754f      	strb	r7, [r1, #21]
			kb->key_list[i].ispressed = 0;
    ad16:	758f      	strb	r7, [r1, #22]
			kb->key_list[i].keycode = 255;	
    ad18:	f881 c014 	strb.w	ip, [r1, #20]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad1c:	eb04 02c6 	add.w	r2, r4, r6, lsl #3
    ad20:	42b5      	cmp	r5, r6
    ad22:	f102 0208 	add.w	r2, r2, #8
    ad26:	d108      	bne.n	ad3a <grid_keyboard_cleanup+0x4a>
			kb->key_active_count--;
    ad28:	3d01      	subs	r5, #1
			i--; // Retest this index, because it now points to a new item
    ad2a:	3b01      	subs	r3, #1
			kb->key_active_count--;
    ad2c:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
			i--; // Retest this index, because it now points to a new item
    ad30:	b2db      	uxtb	r3, r3
			changed_flag = 1;
    ad32:	2001      	movs	r0, #1
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad34:	3301      	adds	r3, #1
    ad36:	b2db      	uxtb	r3, r3
    ad38:	e7e1      	b.n	acfe <grid_keyboard_cleanup+0xe>
				kb->key_list[j-1] = kb->key_list[j];
    ad3a:	e9d2 0103 	ldrd	r0, r1, [r2, #12]
    ad3e:	1d17      	adds	r7, r2, #4
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad40:	3601      	adds	r6, #1
				kb->key_list[j-1] = kb->key_list[j];
    ad42:	e887 0003 	stmia.w	r7, {r0, r1}
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad46:	b2f6      	uxtb	r6, r6
				kb->key_list[j].ismodifier = 0;
    ad48:	f882 e00d 	strb.w	lr, [r2, #13]
				kb->key_list[j].ispressed = 0;
    ad4c:	f882 e00e 	strb.w	lr, [r2, #14]
				kb->key_list[j].keycode = 255;
    ad50:	f882 c00c 	strb.w	ip, [r2, #12]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    ad54:	e7e4      	b.n	ad20 <grid_keyboard_cleanup+0x30>
	...

0000ad58 <grid_keyboard_keychange>:


uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    ad58:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ad5c:	4604      	mov	r4, r0
	uint8_t item_index = 255;
	uint8_t remove_flag = 0;
	uint8_t changed_flag = 0;
	

	grid_keyboard_cleanup(kb);
    ad5e:	f8df 814c 	ldr.w	r8, [pc, #332]	; aeac <grid_keyboard_keychange+0x154>
uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    ad62:	b0ec      	sub	sp, #432	; 0x1b0
    ad64:	460d      	mov	r5, r1
	grid_keyboard_cleanup(kb);
    ad66:	47c0      	blx	r8
	

	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad68:	2200      	movs	r2, #0
    ad6a:	f894 c044 	ldrb.w	ip, [r4, #68]	; 0x44
    ad6e:	4626      	mov	r6, r4
    ad70:	4623      	mov	r3, r4
	uint8_t changed_flag = 0;
    ad72:	4691      	mov	r9, r2
	uint8_t item_index = 255;
    ad74:	27ff      	movs	r7, #255	; 0xff
				if (key->ispressed == true){
					// OK nothing to do here
				}
				else{
					// Release the damn key
					kb->key_list[i].ispressed = false;
    ad76:	4696      	mov	lr, r2
    ad78:	b2d1      	uxtb	r1, r2
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ad7a:	458c      	cmp	ip, r1
    ad7c:	d82e      	bhi.n	addc <grid_keyboard_keychange+0x84>
		}
		
	}
	
	
	uint8_t print_happened = grid_keyboard_cleanup(kb);
    ad7e:	4620      	mov	r0, r4
    ad80:	47c0      	blx	r8
	
	
	if (item_index == 255){
    ad82:	2fff      	cmp	r7, #255	; 0xff
    ad84:	d143      	bne.n	ae0e <grid_keyboard_keychange+0xb6>
		
		// item not in list
		
		if (kb->key_active_count< GRID_KEYBOARD_KEY_maxcount){
    ad86:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    ad8a:	2b05      	cmp	r3, #5
    ad8c:	d83f      	bhi.n	ae0e <grid_keyboard_keychange+0xb6>
			
			if (key->ispressed == true){
    ad8e:	78aa      	ldrb	r2, [r5, #2]
    ad90:	2a01      	cmp	r2, #1
    ad92:	d13c      	bne.n	ae0e <grid_keyboard_keychange+0xb6>
				
				kb->key_list[kb->key_active_count] = *key;
    ad94:	e895 0003 	ldmia.w	r5, {r0, r1}
    ad98:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    ad9c:	3214      	adds	r2, #20
				kb->key_active_count++;
    ad9e:	3301      	adds	r3, #1
				kb->key_list[kb->key_active_count] = *key;
    ada0:	e882 0003 	stmia.w	r2, {r0, r1}
				kb->key_active_count++;
    ada4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		}
		
	}
	
	
	if (changed_flag == 1){
    ada8:	f104 0112 	add.w	r1, r4, #18
	uint8_t item_index = 255;
    adac:	4623      	mov	r3, r4
//		}
			
		
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
		
			kb->hid_key_array[i].b_modifier = kb->key_list[i].ismodifier;
    adae:	7d72      	ldrb	r2, [r6, #21]
    adb0:	3a00      	subs	r2, #0
    adb2:	bf18      	it	ne
    adb4:	2201      	movne	r2, #1
    adb6:	705a      	strb	r2, [r3, #1]
			kb->hid_key_array[i].key_id = kb->key_list[i].keycode;
    adb8:	7d32      	ldrb	r2, [r6, #20]
    adba:	701a      	strb	r2, [r3, #0]
			kb->hid_key_array[i].state = kb->key_list[i].ispressed;
    adbc:	7db2      	ldrb	r2, [r6, #22]
    adbe:	709a      	strb	r2, [r3, #2]
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
    adc0:	3303      	adds	r3, #3
    adc2:	428b      	cmp	r3, r1
    adc4:	f106 0608 	add.w	r6, r6, #8
    adc8:	d1f1      	bne.n	adae <grid_keyboard_keychange+0x56>
		
		}
        
        
        if (kb->isenabled){
    adca:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    adce:	b325      	cbz	r5, ae1a <grid_keyboard_keychange+0xc2>
            
            
    		hiddf_keyboard_keys_state_change(kb->hid_key_array, kb->key_active_count);    
    add0:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    add4:	4b2b      	ldr	r3, [pc, #172]	; (ae84 <grid_keyboard_keychange+0x12c>)
    add6:	4620      	mov	r0, r4
    add8:	4798      	blx	r3
    adda:	e01b      	b.n	ae14 <grid_keyboard_keychange+0xbc>
		if (kb->key_list[i].keycode == key->keycode && kb->key_list[i].ismodifier == key->ismodifier){
    addc:	f893 a014 	ldrb.w	sl, [r3, #20]
    ade0:	7828      	ldrb	r0, [r5, #0]
    ade2:	4582      	cmp	sl, r0
    ade4:	d111      	bne.n	ae0a <grid_keyboard_keychange+0xb2>
    ade6:	f893 a015 	ldrb.w	sl, [r3, #21]
    adea:	7868      	ldrb	r0, [r5, #1]
    adec:	4582      	cmp	sl, r0
    adee:	d10c      	bne.n	ae0a <grid_keyboard_keychange+0xb2>
			if (kb->key_list[i].ispressed == true){
    adf0:	7d98      	ldrb	r0, [r3, #22]
    adf2:	2801      	cmp	r0, #1
    adf4:	d105      	bne.n	ae02 <grid_keyboard_keychange+0xaa>
				if (key->ispressed == true){
    adf6:	78af      	ldrb	r7, [r5, #2]
    adf8:	2f01      	cmp	r7, #1
    adfa:	d002      	beq.n	ae02 <grid_keyboard_keychange+0xaa>
					kb->key_list[i].ispressed = false;
    adfc:	f883 e016 	strb.w	lr, [r3, #22]
					changed_flag = 1;
    ae00:	4681      	mov	r9, r0
	for(uint8_t i=0; i<kb->key_active_count; i++){
    ae02:	3201      	adds	r2, #1
    ae04:	3308      	adds	r3, #8
	uint8_t item_index = 255;
    ae06:	460f      	mov	r7, r1
    ae08:	e7b6      	b.n	ad78 <grid_keyboard_keychange+0x20>
    ae0a:	4639      	mov	r1, r7
    ae0c:	e7f9      	b.n	ae02 <grid_keyboard_keychange+0xaa>
	if (changed_flag == 1){
    ae0e:	f1b9 0f00 	cmp.w	r9, #0
    ae12:	d1c9      	bne.n	ada8 <grid_keyboard_keychange+0x50>
		
		
		// USB SEND
	}
	
}
    ae14:	b06c      	add	sp, #432	; 0x1b0
    ae16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            grid_msg_init(&response);
    ae1a:	a805      	add	r0, sp, #20
    ae1c:	4b1a      	ldr	r3, [pc, #104]	; (ae88 <grid_keyboard_keychange+0x130>)
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    ae1e:	4e1b      	ldr	r6, [pc, #108]	; (ae8c <grid_keyboard_keychange+0x134>)
            grid_msg_init(&response);
    ae20:	4798      	blx	r3
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    ae22:	227f      	movs	r2, #127	; 0x7f
    ae24:	462b      	mov	r3, r5
    ae26:	4611      	mov	r1, r2
    ae28:	a805      	add	r0, sp, #20
    ae2a:	47b0      	blx	r6
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ae2c:	2303      	movs	r3, #3
    ae2e:	4918      	ldr	r1, [pc, #96]	; (ae90 <grid_keyboard_keychange+0x138>)
    ae30:	9300      	str	r3, [sp, #0]
    ae32:	2202      	movs	r2, #2
    ae34:	4e17      	ldr	r6, [pc, #92]	; (ae94 <grid_keyboard_keychange+0x13c>)
            uint8_t response_payload[10] = {0};
    ae36:	f8ad 5010 	strh.w	r5, [sp, #16]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ae3a:	2392      	movs	r3, #146	; 0x92
    ae3c:	a802      	add	r0, sp, #8
            uint8_t response_payload[10] = {0};
    ae3e:	e9cd 5502 	strd	r5, r5, [sp, #8]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    ae42:	47b0      	blx	r6
            grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    ae44:	4b14      	ldr	r3, [pc, #80]	; (ae98 <grid_keyboard_keychange+0x140>)
    ae46:	a802      	add	r0, sp, #8
    ae48:	4798      	blx	r3
    ae4a:	a902      	add	r1, sp, #8
    ae4c:	4602      	mov	r2, r0
    ae4e:	4b13      	ldr	r3, [pc, #76]	; (ae9c <grid_keyboard_keychange+0x144>)
    ae50:	a805      	add	r0, sp, #20
    ae52:	4798      	blx	r3
            grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, kb->isenabled);
    ae54:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    ae58:	9300      	str	r3, [sp, #0]
    ae5a:	4c11      	ldr	r4, [pc, #68]	; (aea0 <grid_keyboard_keychange+0x148>)
    ae5c:	4629      	mov	r1, r5
    ae5e:	a805      	add	r0, sp, #20
    ae60:	2302      	movs	r3, #2
    ae62:	2205      	movs	r2, #5
    ae64:	47a0      	blx	r4
            grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    ae66:	230d      	movs	r3, #13
    ae68:	9300      	str	r3, [sp, #0]
    ae6a:	2204      	movs	r2, #4
    ae6c:	4629      	mov	r1, r5
    ae6e:	a805      	add	r0, sp, #20
    ae70:	2301      	movs	r3, #1
    ae72:	47a0      	blx	r4
            grid_msg_packet_close(&response);
    ae74:	4b0b      	ldr	r3, [pc, #44]	; (aea4 <grid_keyboard_keychange+0x14c>)
    ae76:	a805      	add	r0, sp, #20
    ae78:	4798      	blx	r3
            grid_msg_packet_send_everywhere(&response);
    ae7a:	4b0b      	ldr	r3, [pc, #44]	; (aea8 <grid_keyboard_keychange+0x150>)
    ae7c:	a805      	add	r0, sp, #20
    ae7e:	4798      	blx	r3
    ae80:	e7c8      	b.n	ae14 <grid_keyboard_keychange+0xbc>
    ae82:	bf00      	nop
    ae84:	0000e989 	.word	0x0000e989
    ae88:	000085c5 	.word	0x000085c5
    ae8c:	000085f9 	.word	0x000085f9
    ae90:	00016764 	.word	0x00016764
    ae94:	000147d1 	.word	0x000147d1
    ae98:	00014c81 	.word	0x00014c81
    ae9c:	00008535 	.word	0x00008535
    aea0:	000085a9 	.word	0x000085a9
    aea4:	000086f1 	.word	0x000086f1
    aea8:	000087c5 	.word	0x000087c5
    aeac:	0000acf1 	.word	0x0000acf1

0000aeb0 <grid_midi_buffer_init>:



void grid_midi_buffer_init(struct grid_midi_event_desc* buf, uint16_t length){
    aeb0:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    aeb2:	2300      	movs	r3, #0
	{
		buf[i].byte0 = 0;
    aeb4:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    aeb6:	b29c      	uxth	r4, r3
    aeb8:	42a1      	cmp	r1, r4
    aeba:	f100 0004 	add.w	r0, r0, #4
    aebe:	d800      	bhi.n	aec2 <grid_midi_buffer_init+0x12>
		buf[i].byte1 = 0;
		buf[i].byte2 = 0;
		buf[i].byte3 = 0;
	}
	
}
    aec0:	bd10      	pop	{r4, pc}
		buf[i].byte0 = 0;
    aec2:	f800 2c04 	strb.w	r2, [r0, #-4]
		buf[i].byte1 = 0;
    aec6:	f800 2c03 	strb.w	r2, [r0, #-3]
		buf[i].byte2 = 0;
    aeca:	f800 2c02 	strb.w	r2, [r0, #-2]
		buf[i].byte3 = 0;
    aece:	f800 2c01 	strb.w	r2, [r0, #-1]
	for (uint16_t i=0; i<length; i++)
    aed2:	3301      	adds	r3, #1
    aed4:	e7ef      	b.n	aeb6 <grid_midi_buffer_init+0x6>
	...

0000aed8 <grid_usb_midi_init>:
	grid_midi_tx_write_index = 0;
    aed8:	4b0a      	ldr	r3, [pc, #40]	; (af04 <grid_usb_midi_init+0x2c>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aeda:	480b      	ldr	r0, [pc, #44]	; (af08 <grid_usb_midi_init+0x30>)
{
    aedc:	b510      	push	{r4, lr}
	grid_midi_tx_write_index = 0;
    aede:	2400      	movs	r4, #0
    aee0:	801c      	strh	r4, [r3, #0]
	grid_midi_tx_read_index = 0;
    aee2:	4b0a      	ldr	r3, [pc, #40]	; (af0c <grid_usb_midi_init+0x34>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aee4:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_midi_tx_read_index = 0;
    aee8:	801c      	strh	r4, [r3, #0]
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    aeea:	4b09      	ldr	r3, [pc, #36]	; (af10 <grid_usb_midi_init+0x38>)
    aeec:	4798      	blx	r3
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_READ, (FUNC_PTR)grid_usb_midi_bulkout_cb);
    aeee:	4620      	mov	r0, r4
    aef0:	4c08      	ldr	r4, [pc, #32]	; (af14 <grid_usb_midi_init+0x3c>)
    aef2:	4909      	ldr	r1, [pc, #36]	; (af18 <grid_usb_midi_init+0x40>)
    aef4:	47a0      	blx	r4
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    aef6:	4623      	mov	r3, r4
    aef8:	4908      	ldr	r1, [pc, #32]	; (af1c <grid_usb_midi_init+0x44>)
}
    aefa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    aefe:	2001      	movs	r0, #1
    af00:	4718      	bx	r3
    af02:	bf00      	nop
    af04:	20004ac0 	.word	0x20004ac0
    af08:	2000be3c 	.word	0x2000be3c
    af0c:	20008c7c 	.word	0x20008c7c
    af10:	0000aeb1 	.word	0x0000aeb1
    af14:	00004585 	.word	0x00004585
    af18:	0000acb5 	.word	0x0000acb5
    af1c:	0000ac8d 	.word	0x0000ac8d

0000af20 <grid_midi_tx_push>:

uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){


	grid_midi_tx_buffer[grid_midi_tx_write_index] = midi_event;
    af20:	4907      	ldr	r1, [pc, #28]	; (af40 <grid_midi_tx_push+0x20>)
    af22:	4a08      	ldr	r2, [pc, #32]	; (af44 <grid_midi_tx_push+0x24>)
    af24:	880b      	ldrh	r3, [r1, #0]
    af26:	f842 0023 	str.w	r0, [r2, r3, lsl #2]

	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    af2a:	f44f 7096 	mov.w	r0, #300	; 0x12c
    af2e:	3301      	adds	r3, #1
uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){
    af30:	b082      	sub	sp, #8
	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    af32:	fbb3 f2f0 	udiv	r2, r3, r0
    af36:	fb00 3312 	mls	r3, r0, r2, r3
    af3a:	800b      	strh	r3, [r1, #0]




}
    af3c:	b002      	add	sp, #8
    af3e:	4770      	bx	lr
    af40:	20004ac0 	.word	0x20004ac0
    af44:	2000be3c 	.word	0x2000be3c

0000af48 <grid_midi_tx_pop>:

uint8_t grid_midi_tx_pop(){
    af48:	b538      	push	{r3, r4, r5, lr}

	if (grid_midi_tx_read_index != grid_midi_tx_write_index){
    af4a:	4c0f      	ldr	r4, [pc, #60]	; (af88 <grid_midi_tx_pop+0x40>)
    af4c:	4b0f      	ldr	r3, [pc, #60]	; (af8c <grid_midi_tx_pop+0x44>)
    af4e:	8822      	ldrh	r2, [r4, #0]
    af50:	881b      	ldrh	r3, [r3, #0]
    af52:	429a      	cmp	r2, r3
    af54:	d017      	beq.n	af86 <grid_midi_tx_pop+0x3e>
		
		if (audiodf_midi_write_status() != USB_BUSY){
    af56:	4b0e      	ldr	r3, [pc, #56]	; (af90 <grid_midi_tx_pop+0x48>)
    af58:	4798      	blx	r3
    af5a:	2801      	cmp	r0, #1
    af5c:	d013      	beq.n	af86 <grid_midi_tx_pop+0x3e>

			uint8_t byte0 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte0;
    af5e:	8825      	ldrh	r5, [r4, #0]
			uint8_t byte1 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte1;
			uint8_t byte2 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte2;
			uint8_t byte3 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte3;
    af60:	480c      	ldr	r0, [pc, #48]	; (af94 <grid_midi_tx_pop+0x4c>)
    af62:	eb00 0185 	add.w	r1, r0, r5, lsl #2
			
			audiodf_midi_write(byte0, byte1, byte2, byte3);
    af66:	f810 0025 	ldrb.w	r0, [r0, r5, lsl #2]
    af6a:	78cb      	ldrb	r3, [r1, #3]
    af6c:	788a      	ldrb	r2, [r1, #2]
    af6e:	4d0a      	ldr	r5, [pc, #40]	; (af98 <grid_midi_tx_pop+0x50>)
    af70:	7849      	ldrb	r1, [r1, #1]
    af72:	47a8      	blx	r5

			grid_midi_tx_read_index = (grid_midi_tx_read_index+1)%GRID_MIDI_TX_BUFFER_length;
    af74:	8823      	ldrh	r3, [r4, #0]
    af76:	f44f 7196 	mov.w	r1, #300	; 0x12c
    af7a:	3301      	adds	r3, #1
    af7c:	fbb3 f2f1 	udiv	r2, r3, r1
    af80:	fb01 3312 	mls	r3, r1, r2, r3
    af84:	8023      	strh	r3, [r4, #0]

		}
		
	}

}
    af86:	bd38      	pop	{r3, r4, r5, pc}
    af88:	20008c7c 	.word	0x20008c7c
    af8c:	20004ac0 	.word	0x20004ac0
    af90:	00004549 	.word	0x00004549
    af94:	2000be3c 	.word	0x2000be3c
    af98:	00004521 	.word	0x00004521

0000af9c <grid_keyboard_buffer_init>:


void grid_keyboard_buffer_init(struct grid_keyboard_event_desc* buf, uint16_t length){
    af9c:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    af9e:	2300      	movs	r3, #0
	{
		buf[i].ismodifier = 0;
    afa0:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    afa2:	b29c      	uxth	r4, r3
    afa4:	42a1      	cmp	r1, r4
    afa6:	f100 0008 	add.w	r0, r0, #8
    afaa:	d800      	bhi.n	afae <grid_keyboard_buffer_init+0x12>
		buf[i].keycode = 0;
		buf[i].ispressed = 0;
		buf[i].delay = 0;
	}
	
}
    afac:	bd10      	pop	{r4, pc}
		buf[i].ismodifier = 0;
    afae:	f800 2c07 	strb.w	r2, [r0, #-7]
		buf[i].keycode = 0;
    afb2:	f800 2c08 	strb.w	r2, [r0, #-8]
		buf[i].ispressed = 0;
    afb6:	f800 2c06 	strb.w	r2, [r0, #-6]
		buf[i].delay = 0;
    afba:	f840 2c04 	str.w	r2, [r0, #-4]
	for (uint16_t i=0; i<length; i++)
    afbe:	3301      	adds	r3, #1
    afc0:	e7ef      	b.n	afa2 <grid_keyboard_buffer_init+0x6>
	...

0000afc4 <grid_keyboard_init>:
void grid_keyboard_init(struct grid_keyboard_model* kb){
    afc4:	b570      	push	{r4, r5, r6, lr}
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    afc6:	4b13      	ldr	r3, [pc, #76]	; (b014 <grid_keyboard_init+0x50>)
void grid_keyboard_init(struct grid_keyboard_model* kb){
    afc8:	4605      	mov	r5, r0
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    afca:	4813      	ldr	r0, [pc, #76]	; (b018 <grid_keyboard_init+0x54>)
    afcc:	4798      	blx	r3
    afce:	4b13      	ldr	r3, [pc, #76]	; (b01c <grid_keyboard_init+0x58>)
    afd0:	6018      	str	r0, [r3, #0]
    grid_keyboard_tx_write_index = 0;
    afd2:	4b13      	ldr	r3, [pc, #76]	; (b020 <grid_keyboard_init+0x5c>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afd4:	4813      	ldr	r0, [pc, #76]	; (b024 <grid_keyboard_init+0x60>)
    grid_keyboard_tx_write_index = 0;
    afd6:	2400      	movs	r4, #0
    afd8:	801c      	strh	r4, [r3, #0]
	grid_keyboard_tx_read_index = 0;
    afda:	4b13      	ldr	r3, [pc, #76]	; (b028 <grid_keyboard_init+0x64>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afdc:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_keyboard_tx_read_index = 0;
    afe0:	801c      	strh	r4, [r3, #0]
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afe2:	4b12      	ldr	r3, [pc, #72]	; (b02c <grid_keyboard_init+0x68>)
    afe4:	4798      	blx	r3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    afe6:	f105 0612 	add.w	r6, r5, #18
    afea:	462a      	mov	r2, r5
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    afec:	4629      	mov	r1, r5
		kb->hid_key_array[i].b_modifier = false;
    afee:	4623      	mov	r3, r4
		kb->hid_key_array[i].key_id = 255;
    aff0:	20ff      	movs	r0, #255	; 0xff
		kb->hid_key_array[i].b_modifier = false;
    aff2:	7053      	strb	r3, [r2, #1]
		kb->hid_key_array[i].key_id = 255;
    aff4:	7010      	strb	r0, [r2, #0]
		kb->hid_key_array[i].state = HID_KB_KEY_UP;
    aff6:	7093      	strb	r3, [r2, #2]
		kb->key_list[i].ismodifier = 0;
    aff8:	3203      	adds	r2, #3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    affa:	42b2      	cmp	r2, r6
		kb->key_list[i].ismodifier = 0;
    affc:	754b      	strb	r3, [r1, #21]
		kb->key_list[i].ispressed = 0;
    affe:	758b      	strb	r3, [r1, #22]
		kb->key_list[i].keycode = 255;
    b000:	7508      	strb	r0, [r1, #20]
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b002:	f101 0108 	add.w	r1, r1, #8
    b006:	d1f4      	bne.n	aff2 <grid_keyboard_init+0x2e>
	kb->key_active_count = 0;
    b008:	f44f 7380 	mov.w	r3, #256	; 0x100
    b00c:	f8a5 3044 	strh.w	r3, [r5, #68]	; 0x44
}
    b010:	bd70      	pop	{r4, r5, r6, pc}
    b012:	bf00      	nop
    b014:	000097a9 	.word	0x000097a9
    b018:	20007a24 	.word	0x20007a24
    b01c:	200151e8 	.word	0x200151e8
    b020:	20007ad4 	.word	0x20007ad4
    b024:	20007ad8 	.word	0x20007ad8
    b028:	20008cc8 	.word	0x20008cc8
    b02c:	0000af9d 	.word	0x0000af9d

0000b030 <grid_keyboard_tx_push>:

uint8_t grid_keyboard_tx_push(struct grid_keyboard_event_desc keyboard_event){
    b030:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b032:	466c      	mov	r4, sp
    b034:	e884 0003 	stmia.w	r4, {r0, r1}


	grid_keyboard_tx_buffer[grid_keyboard_tx_write_index] = keyboard_event;
    b038:	4d09      	ldr	r5, [pc, #36]	; (b060 <grid_keyboard_tx_push+0x30>)
    b03a:	4a0a      	ldr	r2, [pc, #40]	; (b064 <grid_keyboard_tx_push+0x34>)
    b03c:	882b      	ldrh	r3, [r5, #0]
    b03e:	e894 0003 	ldmia.w	r4, {r0, r1}
    b042:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    b046:	e882 0003 	stmia.w	r2, {r0, r1}

	grid_keyboard_tx_write_index = (grid_keyboard_tx_write_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b04a:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b04e:	3301      	adds	r3, #1
    b050:	fbb3 f2f1 	udiv	r2, r3, r1
    b054:	fb01 3312 	mls	r3, r1, r2, r3
    b058:	802b      	strh	r3, [r5, #0]



}
    b05a:	b003      	add	sp, #12
    b05c:	bd30      	pop	{r4, r5, pc}
    b05e:	bf00      	nop
    b060:	20007ad4 	.word	0x20007ad4
    b064:	20007ad8 	.word	0x20007ad8

0000b068 <grid_keyboard_tx_pop>:

uint8_t grid_keyboard_tx_pop(){
    b068:	b573      	push	{r0, r1, r4, r5, r6, lr}

	if (grid_keyboard_tx_read_index != grid_keyboard_tx_write_index){
    b06a:	4b17      	ldr	r3, [pc, #92]	; (b0c8 <grid_keyboard_tx_pop+0x60>)
    b06c:	4c17      	ldr	r4, [pc, #92]	; (b0cc <grid_keyboard_tx_pop+0x64>)
    b06e:	881b      	ldrh	r3, [r3, #0]
    b070:	8822      	ldrh	r2, [r4, #0]
    b072:	429a      	cmp	r2, r3
    b074:	d026      	beq.n	b0c4 <grid_keyboard_tx_pop+0x5c>
		
        
        
        uint32_t elapsed = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_keyboard_tx_rtc_lasttimestamp);
    b076:	4d16      	ldr	r5, [pc, #88]	; (b0d0 <grid_keyboard_tx_pop+0x68>)
    b078:	4b16      	ldr	r3, [pc, #88]	; (b0d4 <grid_keyboard_tx_pop+0x6c>)
    b07a:	6829      	ldr	r1, [r5, #0]
    b07c:	4816      	ldr	r0, [pc, #88]	; (b0d8 <grid_keyboard_tx_pop+0x70>)
    b07e:	4798      	blx	r3
        
        
		if (elapsed > grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].delay*RTC1MS){
    b080:	8822      	ldrh	r2, [r4, #0]
    b082:	4b16      	ldr	r3, [pc, #88]	; (b0dc <grid_keyboard_tx_pop+0x74>)
    b084:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    b088:	684e      	ldr	r6, [r1, #4]
    b08a:	ebb0 1f06 	cmp.w	r0, r6, lsl #4
    b08e:	d919      	bls.n	b0c4 <grid_keyboard_tx_pop+0x5c>
            
            struct grid_keyboard_event_desc key;
            
            key.ismodifier = grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ismodifier;
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b090:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b094:	7889      	ldrb	r1, [r1, #2]
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b096:	f8ad 3000 	strh.w	r3, [sp]
            key.delay = 0;
    b09a:	2300      	movs	r3, #0
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b09c:	f88d 1002 	strb.w	r1, [sp, #2]
            key.delay = 0;
    b0a0:	9301      	str	r3, [sp, #4]
            
                  
            //grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 50);
            
            grid_keyboard_keychange(&grid_keyboard_state, &key);
    b0a2:	4669      	mov	r1, sp
    b0a4:	4b0e      	ldr	r3, [pc, #56]	; (b0e0 <grid_keyboard_tx_pop+0x78>)
    b0a6:	480f      	ldr	r0, [pc, #60]	; (b0e4 <grid_keyboard_tx_pop+0x7c>)
    b0a8:	4798      	blx	r3

			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b0aa:	8823      	ldrh	r3, [r4, #0]
            
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b0ac:	480a      	ldr	r0, [pc, #40]	; (b0d8 <grid_keyboard_tx_pop+0x70>)
			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b0ae:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b0b2:	3301      	adds	r3, #1
    b0b4:	fbb3 f2f1 	udiv	r2, r3, r1
    b0b8:	fb01 3312 	mls	r3, r1, r2, r3
    b0bc:	8023      	strh	r3, [r4, #0]
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b0be:	4b0a      	ldr	r3, [pc, #40]	; (b0e8 <grid_keyboard_tx_pop+0x80>)
    b0c0:	4798      	blx	r3
    b0c2:	6028      	str	r0, [r5, #0]

		}
		
	}

}
    b0c4:	b002      	add	sp, #8
    b0c6:	bd70      	pop	{r4, r5, r6, pc}
    b0c8:	20007ad4 	.word	0x20007ad4
    b0cc:	20008cc8 	.word	0x20008cc8
    b0d0:	200151e8 	.word	0x200151e8
    b0d4:	000097ad 	.word	0x000097ad
    b0d8:	20007a24 	.word	0x20007a24
    b0dc:	20007ad8 	.word	0x20007ad8
    b0e0:	0000ad59 	.word	0x0000ad59
    b0e4:	20008c80 	.word	0x20008c80
    b0e8:	000097a9 	.word	0x000097a9

0000b0ec <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    b0ec:	b570      	push	{r4, r5, r6, lr}
    b0ee:	460d      	mov	r5, r1
    b0f0:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b0f2:	4604      	mov	r4, r0
    b0f4:	b110      	cbz	r0, b0fc <io_write+0x10>
    b0f6:	1e08      	subs	r0, r1, #0
    b0f8:	bf18      	it	ne
    b0fa:	2001      	movne	r0, #1
    b0fc:	4905      	ldr	r1, [pc, #20]	; (b114 <io_write+0x28>)
    b0fe:	4b06      	ldr	r3, [pc, #24]	; (b118 <io_write+0x2c>)
    b100:	2234      	movs	r2, #52	; 0x34
    b102:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    b104:	6823      	ldr	r3, [r4, #0]
    b106:	4632      	mov	r2, r6
    b108:	4629      	mov	r1, r5
    b10a:	4620      	mov	r0, r4
}
    b10c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    b110:	4718      	bx	r3
    b112:	bf00      	nop
    b114:	00016de0 	.word	0x00016de0
    b118:	0000df45 	.word	0x0000df45

0000b11c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    b11c:	b570      	push	{r4, r5, r6, lr}
    b11e:	460d      	mov	r5, r1
    b120:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b122:	4604      	mov	r4, r0
    b124:	b110      	cbz	r0, b12c <io_read+0x10>
    b126:	1e08      	subs	r0, r1, #0
    b128:	bf18      	it	ne
    b12a:	2001      	movne	r0, #1
    b12c:	4905      	ldr	r1, [pc, #20]	; (b144 <io_read+0x28>)
    b12e:	4b06      	ldr	r3, [pc, #24]	; (b148 <io_read+0x2c>)
    b130:	223d      	movs	r2, #61	; 0x3d
    b132:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    b134:	6863      	ldr	r3, [r4, #4]
    b136:	4632      	mov	r2, r6
    b138:	4629      	mov	r1, r5
    b13a:	4620      	mov	r0, r4
}
    b13c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    b140:	4718      	bx	r3
    b142:	bf00      	nop
    b144:	00016de0 	.word	0x00016de0
    b148:	0000df45 	.word	0x0000df45

0000b14c <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    b14c:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    b150:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    b154:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    b158:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    b15a:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    b15c:	2300      	movs	r3, #0
    b15e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    b160:	4770      	bx	lr

0000b162 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    b162:	2300      	movs	r3, #0
    b164:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    b166:	4770      	bx	lr

0000b168 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    b168:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    b16a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    b16c:	689a      	ldr	r2, [r3, #8]
    b16e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    b170:	689a      	ldr	r2, [r3, #8]
    b172:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    b174:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b176:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b178:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b17a:	3301      	adds	r3, #1
    b17c:	6003      	str	r3, [r0, #0]
}
    b17e:	4770      	bx	lr

0000b180 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    b180:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    b182:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    b184:	1c63      	adds	r3, r4, #1
    b186:	d10a      	bne.n	b19e <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    b188:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    b18a:	685a      	ldr	r2, [r3, #4]
    b18c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    b18e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    b190:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    b192:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b194:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b196:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b198:	3301      	adds	r3, #1
    b19a:	6003      	str	r3, [r0, #0]
}
    b19c:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    b19e:	f100 0208 	add.w	r2, r0, #8
    b1a2:	4613      	mov	r3, r2
    b1a4:	6852      	ldr	r2, [r2, #4]
    b1a6:	6815      	ldr	r5, [r2, #0]
    b1a8:	42a5      	cmp	r5, r4
    b1aa:	d9fa      	bls.n	b1a2 <vListInsert+0x22>
    b1ac:	e7ed      	b.n	b18a <vListInsert+0xa>

0000b1ae <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b1ae:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    b1b2:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b1b4:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    b1b6:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    b1b8:	6859      	ldr	r1, [r3, #4]
    b1ba:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    b1bc:	bf08      	it	eq
    b1be:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    b1c0:	2200      	movs	r2, #0
    b1c2:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    b1c4:	681a      	ldr	r2, [r3, #0]
    b1c6:	3a01      	subs	r2, #1
    b1c8:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    b1ca:	6818      	ldr	r0, [r3, #0]
}
    b1cc:	4770      	bx	lr
	...

0000b1d0 <pvPortMalloc>:
static size_t xNextFreeByte = (size_t)0;

/*-----------------------------------------------------------*/

void *pvPortMalloc(size_t xWantedSize)
{
    b1d0:	b538      	push	{r3, r4, r5, lr}
	static uint8_t *pucAlignedHeap = NULL;

/* Ensure that blocks are always aligned to the required number of bytes. */
#if (portBYTE_ALIGNMENT != 1)
	{
		if (xWantedSize & portBYTE_ALIGNMENT_MASK) {
    b1d2:	0743      	lsls	r3, r0, #29
{
    b1d4:	4604      	mov	r4, r0
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
		}
	}
#endif

	vTaskSuspendAll();
    b1d6:	4b10      	ldr	r3, [pc, #64]	; (b218 <pvPortMalloc+0x48>)
			xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    b1d8:	bf1c      	itt	ne
    b1da:	f020 0407 	bicne.w	r4, r0, #7
    b1de:	3408      	addne	r4, #8
	vTaskSuspendAll();
    b1e0:	4798      	blx	r3
	{
		if (pucAlignedHeap == NULL) {
    b1e2:	4b0e      	ldr	r3, [pc, #56]	; (b21c <pvPortMalloc+0x4c>)
    b1e4:	681a      	ldr	r2, [r3, #0]
    b1e6:	b922      	cbnz	r2, b1f2 <pvPortMalloc+0x22>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    b1e8:	f103 020c 	add.w	r2, r3, #12
			                             & (~((portPOINTER_SIZE_TYPE)portBYTE_ALIGNMENT_MASK)));
    b1ec:	f022 0207 	bic.w	r2, r2, #7
			pucAlignedHeap = (uint8_t *)(((portPOINTER_SIZE_TYPE)&ucHeap[portBYTE_ALIGNMENT])
    b1f0:	601a      	str	r2, [r3, #0]
		}

		/* Check there is enough room left for the allocation. */
		if (((xNextFreeByte + xWantedSize) < configADJUSTED_HEAP_SIZE)
    b1f2:	f8d3 2964 	ldr.w	r2, [r3, #2404]	; 0x964
    b1f6:	f640 1157 	movw	r1, #2391	; 0x957
    b1fa:	4414      	add	r4, r2
    b1fc:	428c      	cmp	r4, r1
    b1fe:	d809      	bhi.n	b214 <pvPortMalloc+0x44>
		    && ((xNextFreeByte + xWantedSize) > xNextFreeByte)) /* Check for overflow. */
    b200:	42a2      	cmp	r2, r4
    b202:	d207      	bcs.n	b214 <pvPortMalloc+0x44>
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    b204:	681d      	ldr	r5, [r3, #0]
			xNextFreeByte += xWantedSize;
    b206:	f8c3 4964 	str.w	r4, [r3, #2404]	; 0x964
			pvReturn = pucAlignedHeap + xNextFreeByte;
    b20a:	4415      	add	r5, r2
		}

		traceMALLOC(pvReturn, xWantedSize);
	}
	(void)xTaskResumeAll();
    b20c:	4b04      	ldr	r3, [pc, #16]	; (b220 <pvPortMalloc+0x50>)
    b20e:	4798      	blx	r3
		}
	}
#endif

	return pvReturn;
}
    b210:	4628      	mov	r0, r5
    b212:	bd38      	pop	{r3, r4, r5, pc}
	void *          pvReturn       = NULL;
    b214:	2500      	movs	r5, #0
    b216:	e7f9      	b.n	b20c <pvPortMalloc+0x3c>
    b218:	00012505 	.word	0x00012505
    b21c:	20000800 	.word	0x20000800
    b220:	00012629 	.word	0x00012629

0000b224 <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	(void)pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT(pv == NULL);
    b224:	b140      	cbz	r0, b238 <vPortFree+0x14>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    b226:	f04f 0380 	mov.w	r3, #128	; 0x80
    b22a:	f383 8811 	msr	BASEPRI, r3
    b22e:	f3bf 8f6f 	isb	sy
    b232:	f3bf 8f4f 	dsb	sy
    b236:	e7fe      	b.n	b236 <vPortFree+0x12>
}
    b238:	4770      	bx	lr
	...

0000b23c <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    b23c:	4808      	ldr	r0, [pc, #32]	; (b260 <prvPortStartFirstTask+0x24>)
    b23e:	6800      	ldr	r0, [r0, #0]
    b240:	6800      	ldr	r0, [r0, #0]
    b242:	f380 8808 	msr	MSP, r0
    b246:	f04f 0000 	mov.w	r0, #0
    b24a:	f380 8814 	msr	CONTROL, r0
    b24e:	b662      	cpsie	i
    b250:	b661      	cpsie	f
    b252:	f3bf 8f4f 	dsb	sy
    b256:	f3bf 8f6f 	isb	sy
    b25a:	df00      	svc	0
    b25c:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    b25e:	0000      	.short	0x0000
    b260:	e000ed08 	.word	0xe000ed08

0000b264 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    b264:	f8df 000c 	ldr.w	r0, [pc, #12]	; b274 <vPortEnableVFP+0x10>
    b268:	6801      	ldr	r1, [r0, #0]
    b26a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b26e:	6001      	str	r1, [r0, #0]
    b270:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    b272:	0000      	.short	0x0000
    b274:	e000ed88 	.word	0xe000ed88

0000b278 <prvTaskExitError>:
{
    b278:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
    b27a:	2300      	movs	r3, #0
    b27c:	9301      	str	r3, [sp, #4]
	configASSERT(uxCriticalNesting == ~0UL);
    b27e:	4b0d      	ldr	r3, [pc, #52]	; (b2b4 <prvTaskExitError+0x3c>)
    b280:	681b      	ldr	r3, [r3, #0]
    b282:	3301      	adds	r3, #1
    b284:	d008      	beq.n	b298 <prvTaskExitError+0x20>
    b286:	f04f 0380 	mov.w	r3, #128	; 0x80
    b28a:	f383 8811 	msr	BASEPRI, r3
    b28e:	f3bf 8f6f 	isb	sy
    b292:	f3bf 8f4f 	dsb	sy
    b296:	e7fe      	b.n	b296 <prvTaskExitError+0x1e>
    b298:	f04f 0380 	mov.w	r3, #128	; 0x80
    b29c:	f383 8811 	msr	BASEPRI, r3
    b2a0:	f3bf 8f6f 	isb	sy
    b2a4:	f3bf 8f4f 	dsb	sy
	while (ulDummy == 0) {
    b2a8:	9b01      	ldr	r3, [sp, #4]
    b2aa:	2b00      	cmp	r3, #0
    b2ac:	d0fc      	beq.n	b2a8 <prvTaskExitError+0x30>
}
    b2ae:	b002      	add	sp, #8
    b2b0:	4770      	bx	lr
    b2b2:	bf00      	nop
    b2b4:	20000350 	.word	0x20000350

0000b2b8 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    b2b8:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    b2bc:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    b2c0:	4b07      	ldr	r3, [pc, #28]	; (b2e0 <pxPortInitialiseStack+0x28>)
    b2c2:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b2c6:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b2ca:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b2ce:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    b2d2:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b2d6:	f840 3c24 	str.w	r3, [r0, #-36]
}
    b2da:	3844      	subs	r0, #68	; 0x44
    b2dc:	4770      	bx	lr
    b2de:	bf00      	nop
    b2e0:	0000b279 	.word	0x0000b279
	...

0000b2f0 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    b2f0:	4b07      	ldr	r3, [pc, #28]	; (b310 <pxCurrentTCBConst2>)
    b2f2:	6819      	ldr	r1, [r3, #0]
    b2f4:	6808      	ldr	r0, [r1, #0]
    b2f6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b2fa:	f380 8809 	msr	PSP, r0
    b2fe:	f3bf 8f6f 	isb	sy
    b302:	f04f 0000 	mov.w	r0, #0
    b306:	f380 8811 	msr	BASEPRI, r0
    b30a:	4770      	bx	lr
    b30c:	f3af 8000 	nop.w

0000b310 <pxCurrentTCBConst2>:
    b310:	20001ac8 	.word	0x20001ac8

0000b314 <vPortEnterCritical>:
    b314:	f04f 0380 	mov.w	r3, #128	; 0x80
    b318:	f383 8811 	msr	BASEPRI, r3
    b31c:	f3bf 8f6f 	isb	sy
    b320:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    b324:	4a0a      	ldr	r2, [pc, #40]	; (b350 <vPortEnterCritical+0x3c>)
    b326:	6813      	ldr	r3, [r2, #0]
    b328:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    b32a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    b32c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    b32e:	d10d      	bne.n	b34c <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    b330:	4b08      	ldr	r3, [pc, #32]	; (b354 <vPortEnterCritical+0x40>)
    b332:	681b      	ldr	r3, [r3, #0]
    b334:	f013 0fff 	tst.w	r3, #255	; 0xff
    b338:	d008      	beq.n	b34c <vPortEnterCritical+0x38>
    b33a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b33e:	f383 8811 	msr	BASEPRI, r3
    b342:	f3bf 8f6f 	isb	sy
    b346:	f3bf 8f4f 	dsb	sy
    b34a:	e7fe      	b.n	b34a <vPortEnterCritical+0x36>
}
    b34c:	4770      	bx	lr
    b34e:	bf00      	nop
    b350:	20000350 	.word	0x20000350
    b354:	e000ed04 	.word	0xe000ed04

0000b358 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    b358:	4a08      	ldr	r2, [pc, #32]	; (b37c <vPortExitCritical+0x24>)
    b35a:	6813      	ldr	r3, [r2, #0]
    b35c:	b943      	cbnz	r3, b370 <vPortExitCritical+0x18>
    b35e:	f04f 0380 	mov.w	r3, #128	; 0x80
    b362:	f383 8811 	msr	BASEPRI, r3
    b366:	f3bf 8f6f 	isb	sy
    b36a:	f3bf 8f4f 	dsb	sy
    b36e:	e7fe      	b.n	b36e <vPortExitCritical+0x16>
	uxCriticalNesting--;
    b370:	3b01      	subs	r3, #1
    b372:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    b374:	b90b      	cbnz	r3, b37a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b376:	f383 8811 	msr	BASEPRI, r3
}
    b37a:	4770      	bx	lr
    b37c:	20000350 	.word	0x20000350

0000b380 <PendSV_Handler>:
	__asm volatile(
    b380:	f3ef 8009 	mrs	r0, PSP
    b384:	f3bf 8f6f 	isb	sy
    b388:	4b15      	ldr	r3, [pc, #84]	; (b3e0 <pxCurrentTCBConst>)
    b38a:	681a      	ldr	r2, [r3, #0]
    b38c:	f01e 0f10 	tst.w	lr, #16
    b390:	bf08      	it	eq
    b392:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    b396:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b39a:	6010      	str	r0, [r2, #0]
    b39c:	e92d 0009 	stmdb	sp!, {r0, r3}
    b3a0:	f04f 0080 	mov.w	r0, #128	; 0x80
    b3a4:	f380 8811 	msr	BASEPRI, r0
    b3a8:	f3bf 8f4f 	dsb	sy
    b3ac:	f3bf 8f6f 	isb	sy
    b3b0:	f007 f9de 	bl	12770 <vTaskSwitchContext>
    b3b4:	f04f 0000 	mov.w	r0, #0
    b3b8:	f380 8811 	msr	BASEPRI, r0
    b3bc:	bc09      	pop	{r0, r3}
    b3be:	6819      	ldr	r1, [r3, #0]
    b3c0:	6808      	ldr	r0, [r1, #0]
    b3c2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b3c6:	f01e 0f10 	tst.w	lr, #16
    b3ca:	bf08      	it	eq
    b3cc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    b3d0:	f380 8809 	msr	PSP, r0
    b3d4:	f3bf 8f6f 	isb	sy
    b3d8:	4770      	bx	lr
    b3da:	bf00      	nop
    b3dc:	f3af 8000 	nop.w

0000b3e0 <pxCurrentTCBConst>:
    b3e0:	20001ac8 	.word	0x20001ac8

0000b3e4 <SysTick_Handler>:
{
    b3e4:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
    b3e6:	f04f 0380 	mov.w	r3, #128	; 0x80
    b3ea:	f383 8811 	msr	BASEPRI, r3
    b3ee:	f3bf 8f6f 	isb	sy
    b3f2:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    b3f6:	4b05      	ldr	r3, [pc, #20]	; (b40c <SysTick_Handler+0x28>)
    b3f8:	4798      	blx	r3
    b3fa:	b118      	cbz	r0, b404 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    b3fc:	4b04      	ldr	r3, [pc, #16]	; (b410 <SysTick_Handler+0x2c>)
    b3fe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    b402:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b404:	2300      	movs	r3, #0
    b406:	f383 8811 	msr	BASEPRI, r3
}
    b40a:	bd08      	pop	{r3, pc}
    b40c:	00012525 	.word	0x00012525
    b410:	e000ed04 	.word	0xe000ed04

0000b414 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b414:	4b05      	ldr	r3, [pc, #20]	; (b42c <vPortSetupTimerInterrupt+0x18>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b416:	4906      	ldr	r1, [pc, #24]	; (b430 <vPortSetupTimerInterrupt+0x1c>)
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b418:	2200      	movs	r2, #0
    b41a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b41c:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    b41e:	4a05      	ldr	r2, [pc, #20]	; (b434 <vPortSetupTimerInterrupt+0x20>)
    b420:	4905      	ldr	r1, [pc, #20]	; (b438 <vPortSetupTimerInterrupt+0x24>)
    b422:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    b424:	2207      	movs	r2, #7
    b426:	601a      	str	r2, [r3, #0]
}
    b428:	4770      	bx	lr
    b42a:	bf00      	nop
    b42c:	e000e010 	.word	0xe000e010
    b430:	e000e018 	.word	0xe000e018
    b434:	e000e014 	.word	0xe000e014
    b438:	0001d4bf 	.word	0x0001d4bf

0000b43c <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b43c:	4b37      	ldr	r3, [pc, #220]	; (b51c <xPortStartScheduler+0xe0>)
    b43e:	4a38      	ldr	r2, [pc, #224]	; (b520 <xPortStartScheduler+0xe4>)
{
    b440:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b442:	6819      	ldr	r1, [r3, #0]
    b444:	4291      	cmp	r1, r2
    b446:	d108      	bne.n	b45a <xPortStartScheduler+0x1e>
	__asm volatile("	mov %0, %1												\n"
    b448:	f04f 0380 	mov.w	r3, #128	; 0x80
    b44c:	f383 8811 	msr	BASEPRI, r3
    b450:	f3bf 8f6f 	isb	sy
    b454:	f3bf 8f4f 	dsb	sy
    b458:	e7fe      	b.n	b458 <xPortStartScheduler+0x1c>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    b45a:	681a      	ldr	r2, [r3, #0]
    b45c:	4b31      	ldr	r3, [pc, #196]	; (b524 <xPortStartScheduler+0xe8>)
    b45e:	429a      	cmp	r2, r3
    b460:	d108      	bne.n	b474 <xPortStartScheduler+0x38>
    b462:	f04f 0380 	mov.w	r3, #128	; 0x80
    b466:	f383 8811 	msr	BASEPRI, r3
    b46a:	f3bf 8f6f 	isb	sy
    b46e:	f3bf 8f4f 	dsb	sy
    b472:	e7fe      	b.n	b472 <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    b474:	4b2c      	ldr	r3, [pc, #176]	; (b528 <xPortStartScheduler+0xec>)
    b476:	781a      	ldrb	r2, [r3, #0]
    b478:	b2d2      	uxtb	r2, r2
    b47a:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    b47c:	22ff      	movs	r2, #255	; 0xff
    b47e:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b480:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b482:	4a2a      	ldr	r2, [pc, #168]	; (b52c <xPortStartScheduler+0xf0>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b484:	b2db      	uxtb	r3, r3
    b486:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b48a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b48e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    b492:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    b494:	2307      	movs	r3, #7
    b496:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    b498:	2100      	movs	r1, #0
    b49a:	f89d 0003 	ldrb.w	r0, [sp, #3]
    b49e:	0600      	lsls	r0, r0, #24
    b4a0:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    b4a4:	d40c      	bmi.n	b4c0 <xPortStartScheduler+0x84>
    b4a6:	b111      	cbz	r1, b4ae <xPortStartScheduler+0x72>
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
    b4a8:	2b04      	cmp	r3, #4
    b4aa:	6053      	str	r3, [r2, #4]
    b4ac:	d011      	beq.n	b4d2 <xPortStartScheduler+0x96>
    b4ae:	f04f 0380 	mov.w	r3, #128	; 0x80
    b4b2:	f383 8811 	msr	BASEPRI, r3
    b4b6:	f3bf 8f6f 	isb	sy
    b4ba:	f3bf 8f4f 	dsb	sy
    b4be:	e7fe      	b.n	b4be <xPortStartScheduler+0x82>
			ucMaxPriorityValue <<= (uint8_t)0x01;
    b4c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b4c4:	005b      	lsls	r3, r3, #1
    b4c6:	b2db      	uxtb	r3, r3
    b4c8:	f88d 3003 	strb.w	r3, [sp, #3]
    b4cc:	2101      	movs	r1, #1
    b4ce:	4623      	mov	r3, r4
    b4d0:	e7e3      	b.n	b49a <xPortStartScheduler+0x5e>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    b4d2:	f44f 6380 	mov.w	r3, #1024	; 0x400
    b4d6:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    b4d8:	9b01      	ldr	r3, [sp, #4]
    b4da:	4a13      	ldr	r2, [pc, #76]	; (b528 <xPortStartScheduler+0xec>)
    b4dc:	b2db      	uxtb	r3, r3
    b4de:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    b4e0:	4b13      	ldr	r3, [pc, #76]	; (b530 <xPortStartScheduler+0xf4>)
    b4e2:	681a      	ldr	r2, [r3, #0]
    b4e4:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    b4e8:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    b4ea:	681a      	ldr	r2, [r3, #0]
    b4ec:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    b4f0:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    b4f2:	4b10      	ldr	r3, [pc, #64]	; (b534 <xPortStartScheduler+0xf8>)
    b4f4:	4798      	blx	r3
	uxCriticalNesting = 0;
    b4f6:	4b10      	ldr	r3, [pc, #64]	; (b538 <xPortStartScheduler+0xfc>)
    b4f8:	2400      	movs	r4, #0
    b4fa:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
    b4fc:	4b0f      	ldr	r3, [pc, #60]	; (b53c <xPortStartScheduler+0x100>)
    b4fe:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    b500:	4a0f      	ldr	r2, [pc, #60]	; (b540 <xPortStartScheduler+0x104>)
    b502:	6813      	ldr	r3, [r2, #0]
    b504:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    b508:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    b50a:	4b0e      	ldr	r3, [pc, #56]	; (b544 <xPortStartScheduler+0x108>)
    b50c:	4798      	blx	r3
	vTaskSwitchContext();
    b50e:	4b0e      	ldr	r3, [pc, #56]	; (b548 <xPortStartScheduler+0x10c>)
    b510:	4798      	blx	r3
	prvTaskExitError();
    b512:	4b0e      	ldr	r3, [pc, #56]	; (b54c <xPortStartScheduler+0x110>)
    b514:	4798      	blx	r3
}
    b516:	4620      	mov	r0, r4
    b518:	b002      	add	sp, #8
    b51a:	bd10      	pop	{r4, pc}
    b51c:	e000ed00 	.word	0xe000ed00
    b520:	410fc271 	.word	0x410fc271
    b524:	410fc270 	.word	0x410fc270
    b528:	e000e400 	.word	0xe000e400
    b52c:	20001168 	.word	0x20001168
    b530:	e000ed20 	.word	0xe000ed20
    b534:	0000b415 	.word	0x0000b415
    b538:	20000350 	.word	0x20000350
    b53c:	0000b265 	.word	0x0000b265
    b540:	e000ef34 	.word	0xe000ef34
    b544:	0000b23d 	.word	0x0000b23d
    b548:	00012771 	.word	0x00012771
    b54c:	0000b279 	.word	0x0000b279

0000b550 <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
    b550:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    b554:	2b0f      	cmp	r3, #15
    b556:	4a10      	ldr	r2, [pc, #64]	; (b598 <vPortValidateInterruptPriority+0x48>)
    b558:	d90d      	bls.n	b576 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    b55a:	4910      	ldr	r1, [pc, #64]	; (b59c <vPortValidateInterruptPriority+0x4c>)
    b55c:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    b55e:	7811      	ldrb	r1, [r2, #0]
    b560:	4299      	cmp	r1, r3
    b562:	d908      	bls.n	b576 <vPortValidateInterruptPriority+0x26>
    b564:	f04f 0380 	mov.w	r3, #128	; 0x80
    b568:	f383 8811 	msr	BASEPRI, r3
    b56c:	f3bf 8f6f 	isb	sy
    b570:	f3bf 8f4f 	dsb	sy
    b574:	e7fe      	b.n	b574 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    b576:	4b0a      	ldr	r3, [pc, #40]	; (b5a0 <vPortValidateInterruptPriority+0x50>)
    b578:	6852      	ldr	r2, [r2, #4]
    b57a:	681b      	ldr	r3, [r3, #0]
    b57c:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    b580:	4293      	cmp	r3, r2
    b582:	d908      	bls.n	b596 <vPortValidateInterruptPriority+0x46>
    b584:	f04f 0380 	mov.w	r3, #128	; 0x80
    b588:	f383 8811 	msr	BASEPRI, r3
    b58c:	f3bf 8f6f 	isb	sy
    b590:	f3bf 8f4f 	dsb	sy
    b594:	e7fe      	b.n	b594 <vPortValidateInterruptPriority+0x44>
}
    b596:	4770      	bx	lr
    b598:	20001168 	.word	0x20001168
    b59c:	e000e3f0 	.word	0xe000e3f0
    b5a0:	e000ed0c 	.word	0xe000ed0c

0000b5a4 <i2c_m_async_write>:

/**
 * \brief Async version of I2C I/O write
 */
static int32_t i2c_m_async_write(struct io_descriptor *const io, const uint8_t *buf, const uint16_t n)
{
    b5a4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct i2c_m_async_desc *i2c = CONTAINER_OF(io, struct i2c_m_async_desc, io);
	struct _i2c_m_msg        msg;
	int32_t                  ret;

	msg.addr   = i2c->slave_addr;
    b5a6:	8a83      	ldrh	r3, [r0, #20]
    b5a8:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
    b5ac:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    b5b0:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
    b5b4:	9103      	str	r1, [sp, #12]

	/* start transfer then return */
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b5b6:	4b05      	ldr	r3, [pc, #20]	; (b5cc <i2c_m_async_write+0x28>)
	msg.len    = n;
    b5b8:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b5ba:	a901      	add	r1, sp, #4
    b5bc:	3828      	subs	r0, #40	; 0x28
{
    b5be:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b5c0:	4798      	blx	r3
		/* error occurred */
		return ret;
	}

	return (int32_t)n;
}
    b5c2:	2800      	cmp	r0, #0
    b5c4:	bf08      	it	eq
    b5c6:	4620      	moveq	r0, r4
    b5c8:	b004      	add	sp, #16
    b5ca:	bd10      	pop	{r4, pc}
    b5cc:	00011071 	.word	0x00011071

0000b5d0 <i2c_m_async_read>:
{
    b5d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.addr   = i2c->slave_addr;
    b5d2:	8a83      	ldrh	r3, [r0, #20]
    b5d4:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    b5d8:	f248 0301 	movw	r3, #32769	; 0x8001
    b5dc:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
    b5e0:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b5e2:	4b05      	ldr	r3, [pc, #20]	; (b5f8 <i2c_m_async_read+0x28>)
	msg.len    = n;
    b5e4:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b5e6:	a901      	add	r1, sp, #4
    b5e8:	3828      	subs	r0, #40	; 0x28
{
    b5ea:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b5ec:	4798      	blx	r3
}
    b5ee:	2800      	cmp	r0, #0
    b5f0:	bf08      	it	eq
    b5f2:	4620      	moveq	r0, r4
    b5f4:	b004      	add	sp, #16
    b5f6:	bd10      	pop	{r4, pc}
    b5f8:	00011071 	.word	0x00011071

0000b5fc <i2c_tx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b5fc:	8842      	ldrh	r2, [r0, #2]
    b5fe:	05d2      	lsls	r2, r2, #23
    b600:	d402      	bmi.n	b608 <i2c_tx_complete+0xc>
		if (i2c->i2c_cb.tx_complete) {
    b602:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b604:	b103      	cbz	r3, b608 <i2c_tx_complete+0xc>
			i2c->i2c_cb.tx_complete(i2c);
    b606:	4718      	bx	r3
}
    b608:	4770      	bx	lr

0000b60a <i2c_rx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b60a:	8842      	ldrh	r2, [r0, #2]
    b60c:	05d2      	lsls	r2, r2, #23
    b60e:	d402      	bmi.n	b616 <i2c_rx_complete+0xc>
		if (i2c->i2c_cb.rx_complete) {
    b610:	6b83      	ldr	r3, [r0, #56]	; 0x38
    b612:	b103      	cbz	r3, b616 <i2c_rx_complete+0xc>
			i2c->i2c_cb.rx_complete(i2c);
    b614:	4718      	bx	r3
}
    b616:	4770      	bx	lr

0000b618 <i2c_error>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b618:	8842      	ldrh	r2, [r0, #2]
    b61a:	05d2      	lsls	r2, r2, #23
    b61c:	d402      	bmi.n	b624 <i2c_error+0xc>
		if (i2c->i2c_cb.error) {
    b61e:	6b03      	ldr	r3, [r0, #48]	; 0x30
    b620:	b103      	cbz	r3, b624 <i2c_error+0xc>
			i2c->i2c_cb.error(i2c, error);
    b622:	4718      	bx	r3
}
    b624:	4770      	bx	lr
	...

0000b628 <i2c_m_async_init>:

/**
 * \brief Async version of i2c initialize
 */
int32_t i2c_m_async_init(struct i2c_m_async_desc *const i2c, void *const hw)
{
    b628:	b570      	push	{r4, r5, r6, lr}
	int32_t init_status;
	ASSERT(i2c);
    b62a:	4604      	mov	r4, r0
    b62c:	3800      	subs	r0, #0
{
    b62e:	460d      	mov	r5, r1
	ASSERT(i2c);
    b630:	bf18      	it	ne
    b632:	2001      	movne	r0, #1
    b634:	490e      	ldr	r1, [pc, #56]	; (b670 <i2c_m_async_init+0x48>)
    b636:	4b0f      	ldr	r3, [pc, #60]	; (b674 <i2c_m_async_init+0x4c>)
    b638:	2289      	movs	r2, #137	; 0x89
    b63a:	4798      	blx	r3

	init_status = _i2c_m_async_init(&i2c->device, hw);
    b63c:	4629      	mov	r1, r5
    b63e:	4b0e      	ldr	r3, [pc, #56]	; (b678 <i2c_m_async_init+0x50>)
    b640:	4620      	mov	r0, r4
    b642:	4798      	blx	r3
	if (init_status) {
    b644:	4605      	mov	r5, r0
    b646:	b980      	cbnz	r0, b66a <i2c_m_async_init+0x42>
		return init_status;
	}
	/* Init I/O */
	i2c->io.read  = i2c_m_async_read;
    b648:	4b0c      	ldr	r3, [pc, #48]	; (b67c <i2c_m_async_init+0x54>)
    b64a:	62e3      	str	r3, [r4, #44]	; 0x2c
	i2c->io.write = i2c_m_async_write;
    b64c:	4b0c      	ldr	r3, [pc, #48]	; (b680 <i2c_m_async_init+0x58>)

	/* Init callbacks */
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b64e:	4a0d      	ldr	r2, [pc, #52]	; (b684 <i2c_m_async_init+0x5c>)
    b650:	4e0d      	ldr	r6, [pc, #52]	; (b688 <i2c_m_async_init+0x60>)
	i2c->io.write = i2c_m_async_write;
    b652:	62a3      	str	r3, [r4, #40]	; 0x28
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b654:	2101      	movs	r1, #1
    b656:	4620      	mov	r0, r4
    b658:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_RX_COMPLETE, (FUNC_PTR)i2c_rx_complete);
    b65a:	4a0c      	ldr	r2, [pc, #48]	; (b68c <i2c_m_async_init+0x64>)
    b65c:	2102      	movs	r1, #2
    b65e:	4620      	mov	r0, r4
    b660:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_ERROR, (FUNC_PTR)i2c_error);
    b662:	4a0b      	ldr	r2, [pc, #44]	; (b690 <i2c_m_async_init+0x68>)
    b664:	4629      	mov	r1, r5
    b666:	4620      	mov	r0, r4
    b668:	47b0      	blx	r6

	return ERR_NONE;
}
    b66a:	4628      	mov	r0, r5
    b66c:	bd70      	pop	{r4, r5, r6, pc}
    b66e:	bf00      	nop
    b670:	00016df4 	.word	0x00016df4
    b674:	0000df45 	.word	0x0000df45
    b678:	00010ff5 	.word	0x00010ff5
    b67c:	0000b5d1 	.word	0x0000b5d1
    b680:	0000b5a5 	.word	0x0000b5a5
    b684:	0000b5fd 	.word	0x0000b5fd
    b688:	00011179 	.word	0x00011179
    b68c:	0000b60b 	.word	0x0000b60b
    b690:	0000b619 	.word	0x0000b619

0000b694 <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    b694:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    b696:	4604      	mov	r4, r0
    b698:	b118      	cbz	r0, b6a2 <_wdt_init+0xe>
    b69a:	6800      	ldr	r0, [r0, #0]
    b69c:	3800      	subs	r0, #0
    b69e:	bf18      	it	ne
    b6a0:	2001      	movne	r0, #1
    b6a2:	4b12      	ldr	r3, [pc, #72]	; (b6ec <_wdt_init+0x58>)
    b6a4:	4912      	ldr	r1, [pc, #72]	; (b6f0 <_wdt_init+0x5c>)
    b6a6:	2250      	movs	r2, #80	; 0x50
    b6a8:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    b6aa:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b6ac:	689a      	ldr	r2, [r3, #8]
    b6ae:	f012 0f0e 	tst.w	r2, #14
    b6b2:	d1fb      	bne.n	b6ac <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    b6b4:	781a      	ldrb	r2, [r3, #0]
    b6b6:	09d2      	lsrs	r2, r2, #7
    b6b8:	d115      	bne.n	b6e6 <_wdt_init+0x52>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b6ba:	689a      	ldr	r2, [r3, #8]
    b6bc:	f012 0f0e 	tst.w	r2, #14
    b6c0:	d1fb      	bne.n	b6ba <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    b6c2:	781a      	ldrb	r2, [r3, #0]
    b6c4:	0792      	lsls	r2, r2, #30
    b6c6:	d40e      	bmi.n	b6e6 <_wdt_init+0x52>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    b6c8:	781a      	ldrb	r2, [r3, #0]
    b6ca:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    b6ce:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    b6d0:	6898      	ldr	r0, [r3, #8]
    b6d2:	f010 000e 	ands.w	r0, r0, #14
    b6d6:	d1fb      	bne.n	b6d0 <_wdt_init+0x3c>

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    b6d8:	785a      	ldrb	r2, [r3, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    b6da:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= WDT_CONFIG_PER(data);
    b6de:	f042 020b 	orr.w	r2, r2, #11
	((Wdt *)hw)->CONFIG.reg = tmp;
    b6e2:	705a      	strb	r2, [r3, #1]

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
	}

	return ERR_NONE;
}
    b6e4:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    b6e6:	f06f 0010 	mvn.w	r0, #16
    b6ea:	e7fb      	b.n	b6e4 <_wdt_init+0x50>
    b6ec:	0000df45 	.word	0x0000df45
    b6f0:	00016e11 	.word	0x00016e11

0000b6f4 <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    b6f4:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    b6f6:	4288      	cmp	r0, r1
    b6f8:	d301      	bcc.n	b6fe <usb_find_desc+0xa>
		_desc_len_check();
    b6fa:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    b6fc:	bd10      	pop	{r4, pc}
		_desc_len_check();
    b6fe:	7803      	ldrb	r3, [r0, #0]
    b700:	2b01      	cmp	r3, #1
    b702:	d9fa      	bls.n	b6fa <usb_find_desc+0x6>
		if (type == usb_desc_type(desc)) {
    b704:	7844      	ldrb	r4, [r0, #1]
    b706:	4294      	cmp	r4, r2
    b708:	d0f8      	beq.n	b6fc <usb_find_desc+0x8>
    b70a:	4418      	add	r0, r3
    b70c:	e7f3      	b.n	b6f6 <usb_find_desc+0x2>

0000b70e <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    b70e:	4288      	cmp	r0, r1
    b710:	d301      	bcc.n	b716 <usb_find_ep_desc+0x8>
		_desc_len_check();
    b712:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    b714:	4770      	bx	lr
		_desc_len_check();
    b716:	7803      	ldrb	r3, [r0, #0]
    b718:	2b01      	cmp	r3, #1
    b71a:	d9fa      	bls.n	b712 <usb_find_ep_desc+0x4>
	return desc[1];
    b71c:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    b71e:	2a04      	cmp	r2, #4
    b720:	d0f7      	beq.n	b712 <usb_find_ep_desc+0x4>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    b722:	2a05      	cmp	r2, #5
    b724:	d0f6      	beq.n	b714 <usb_find_ep_desc+0x6>
	return (desc + usb_desc_len(desc));
    b726:	4418      	add	r0, r3
    b728:	e7f1      	b.n	b70e <usb_find_ep_desc>
	...

0000b72c <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    b72c:	b538      	push	{r3, r4, r5, lr}
    b72e:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    b730:	4b0c      	ldr	r3, [pc, #48]	; (b764 <usb_find_cfg_desc+0x38>)
    b732:	2202      	movs	r2, #2
{
    b734:	460c      	mov	r4, r1
	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    b736:	4798      	blx	r3
	if (!desc) {
    b738:	b978      	cbnz	r0, b75a <usb_find_cfg_desc+0x2e>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
}
    b73a:	bd38      	pop	{r3, r4, r5, pc}
		_desc_len_check();
    b73c:	7803      	ldrb	r3, [r0, #0]
    b73e:	2b01      	cmp	r3, #1
    b740:	d90d      	bls.n	b75e <usb_find_cfg_desc+0x32>
		if (desc[1] != USB_DT_CONFIG) {
    b742:	7843      	ldrb	r3, [r0, #1]
    b744:	2b02      	cmp	r3, #2
    b746:	d10a      	bne.n	b75e <usb_find_cfg_desc+0x32>
		if (desc[5] == cfg_value) {
    b748:	7943      	ldrb	r3, [r0, #5]
    b74a:	42ab      	cmp	r3, r5
    b74c:	d0f5      	beq.n	b73a <usb_find_cfg_desc+0xe>
	return (ptr[0] + (ptr[1] << 8));
    b74e:	78c2      	ldrb	r2, [r0, #3]
    b750:	7883      	ldrb	r3, [r0, #2]
    b752:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    b756:	fa10 f083 	uxtah	r0, r0, r3
	while (desc < eof) {
    b75a:	42a0      	cmp	r0, r4
    b75c:	d3ee      	bcc.n	b73c <usb_find_cfg_desc+0x10>
		return NULL;
    b75e:	2000      	movs	r0, #0
    b760:	e7eb      	b.n	b73a <usb_find_cfg_desc+0xe>
    b762:	bf00      	nop
    b764:	0000b6f5 	.word	0x0000b6f5

0000b768 <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    b768:	b570      	push	{r4, r5, r6, lr}
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    b76a:	4e09      	ldr	r6, [pc, #36]	; (b790 <usb_find_str_desc+0x28>)
{
    b76c:	4615      	mov	r5, r2
	for (i = 0; desc < eof;) {
    b76e:	2400      	movs	r4, #0
    b770:	4288      	cmp	r0, r1
    b772:	d301      	bcc.n	b778 <usb_find_str_desc+0x10>
				return desc;
			}
			i++;
			desc = usb_desc_next(desc);
		} else {
			return NULL;
    b774:	2000      	movs	r0, #0
		}
	}
	return NULL;
}
    b776:	bd70      	pop	{r4, r5, r6, pc}
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    b778:	2203      	movs	r2, #3
    b77a:	47b0      	blx	r6
		if (desc) {
    b77c:	2800      	cmp	r0, #0
    b77e:	d0fa      	beq.n	b776 <usb_find_str_desc+0xe>
			_desc_len_check();
    b780:	7803      	ldrb	r3, [r0, #0]
    b782:	2b01      	cmp	r3, #1
    b784:	d9f6      	bls.n	b774 <usb_find_str_desc+0xc>
			if (i == str_index) {
    b786:	42ac      	cmp	r4, r5
    b788:	d0f5      	beq.n	b776 <usb_find_str_desc+0xe>
	return (desc + usb_desc_len(desc));
    b78a:	4418      	add	r0, r3
    b78c:	3401      	adds	r4, #1
    b78e:	e7ef      	b.n	b770 <usb_find_str_desc+0x8>
    b790:	0000b6f5 	.word	0x0000b6f5

0000b794 <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    b794:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    b796:	4e07      	ldr	r6, [pc, #28]	; (b7b4 <stdio_io_init+0x20>)
    b798:	4d07      	ldr	r5, [pc, #28]	; (b7b8 <stdio_io_init+0x24>)
    b79a:	6833      	ldr	r3, [r6, #0]
{
    b79c:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
    b79e:	2100      	movs	r1, #0
    b7a0:	6898      	ldr	r0, [r3, #8]
    b7a2:	47a8      	blx	r5
	setbuf(stdin, NULL);
    b7a4:	6833      	ldr	r3, [r6, #0]
    b7a6:	2100      	movs	r1, #0
    b7a8:	6858      	ldr	r0, [r3, #4]
    b7aa:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    b7ac:	4b03      	ldr	r3, [pc, #12]	; (b7bc <stdio_io_init+0x28>)
    b7ae:	601c      	str	r4, [r3, #0]
}
    b7b0:	bd70      	pop	{r4, r5, r6, pc}
    b7b2:	bf00      	nop
    b7b4:	2000054c 	.word	0x2000054c
    b7b8:	000144fd 	.word	0x000144fd
    b7bc:	20001170 	.word	0x20001170

0000b7c0 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    b7c0:	4a04      	ldr	r2, [pc, #16]	; (b7d4 <stdio_io_read+0x14>)
{
    b7c2:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    b7c4:	6810      	ldr	r0, [r2, #0]
    b7c6:	b118      	cbz	r0, b7d0 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
    b7c8:	b28a      	uxth	r2, r1
    b7ca:	4619      	mov	r1, r3
    b7cc:	4b02      	ldr	r3, [pc, #8]	; (b7d8 <stdio_io_read+0x18>)
    b7ce:	4718      	bx	r3
}
    b7d0:	4770      	bx	lr
    b7d2:	bf00      	nop
    b7d4:	20001170 	.word	0x20001170
    b7d8:	0000b11d 	.word	0x0000b11d

0000b7dc <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    b7dc:	4a04      	ldr	r2, [pc, #16]	; (b7f0 <stdio_io_write+0x14>)
{
    b7de:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    b7e0:	6810      	ldr	r0, [r2, #0]
    b7e2:	b118      	cbz	r0, b7ec <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
    b7e4:	b28a      	uxth	r2, r1
    b7e6:	4619      	mov	r1, r3
    b7e8:	4b02      	ldr	r3, [pc, #8]	; (b7f4 <stdio_io_write+0x18>)
    b7ea:	4718      	bx	r3
}
    b7ec:	4770      	bx	lr
    b7ee:	bf00      	nop
    b7f0:	20001170 	.word	0x20001170
    b7f4:	0000b0ed 	.word	0x0000b0ed

0000b7f8 <_spi_m_dma_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_dma_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    b7f8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    b7fa:	4604      	mov	r4, r0
    b7fc:	3800      	subs	r0, #0
{
    b7fe:	460d      	mov	r5, r1
    b800:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    b802:	bf18      	it	ne
    b804:	2001      	movne	r0, #1
    b806:	4907      	ldr	r1, [pc, #28]	; (b824 <_spi_m_dma_io_write+0x2c>)
    b808:	4e07      	ldr	r6, [pc, #28]	; (b828 <_spi_m_dma_io_write+0x30>)
    b80a:	2298      	movs	r2, #152	; 0x98
    b80c:	47b0      	blx	r6

	struct spi_m_dma_descriptor *spi = CONTAINER_OF(io, struct spi_m_dma_descriptor, io);
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    b80e:	f1a4 001c 	sub.w	r0, r4, #28
    b812:	4c06      	ldr	r4, [pc, #24]	; (b82c <_spi_m_dma_io_write+0x34>)
    b814:	9b01      	ldr	r3, [sp, #4]
    b816:	2200      	movs	r2, #0
    b818:	4629      	mov	r1, r5
    b81a:	46a4      	mov	ip, r4
}
    b81c:	b002      	add	sp, #8
    b81e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    b822:	4760      	bx	ip
    b824:	00016e26 	.word	0x00016e26
    b828:	0000df45 	.word	0x0000df45
    b82c:	000117fd 	.word	0x000117fd

0000b830 <_spi_m_dma_io_read>:
{
    b830:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    b832:	4604      	mov	r4, r0
    b834:	3800      	subs	r0, #0
{
    b836:	460d      	mov	r5, r1
    b838:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    b83a:	bf18      	it	ne
    b83c:	2001      	movne	r0, #1
    b83e:	4907      	ldr	r1, [pc, #28]	; (b85c <_spi_m_dma_io_read+0x2c>)
    b840:	4e07      	ldr	r6, [pc, #28]	; (b860 <_spi_m_dma_io_read+0x30>)
    b842:	2281      	movs	r2, #129	; 0x81
    b844:	47b0      	blx	r6
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    b846:	f1a4 001c 	sub.w	r0, r4, #28
    b84a:	4c06      	ldr	r4, [pc, #24]	; (b864 <_spi_m_dma_io_read+0x34>)
    b84c:	9b01      	ldr	r3, [sp, #4]
    b84e:	462a      	mov	r2, r5
    b850:	2100      	movs	r1, #0
    b852:	46a4      	mov	ip, r4
}
    b854:	b002      	add	sp, #8
    b856:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    b85a:	4760      	bx	ip
    b85c:	00016e26 	.word	0x00016e26
    b860:	0000df45 	.word	0x0000df45
    b864:	000117fd 	.word	0x000117fd

0000b868 <spi_m_dma_init>:
{
    b868:	b538      	push	{r3, r4, r5, lr}
    b86a:	460d      	mov	r5, r1
	ASSERT(spi && hw);
    b86c:	4604      	mov	r4, r0
    b86e:	b110      	cbz	r0, b876 <spi_m_dma_init+0xe>
    b870:	1e08      	subs	r0, r1, #0
    b872:	bf18      	it	ne
    b874:	2001      	movne	r0, #1
    b876:	4908      	ldr	r1, [pc, #32]	; (b898 <spi_m_dma_init+0x30>)
    b878:	4b08      	ldr	r3, [pc, #32]	; (b89c <spi_m_dma_init+0x34>)
    b87a:	223b      	movs	r2, #59	; 0x3b
    b87c:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    b87e:	4620      	mov	r0, r4
	rc            = _spi_m_dma_init(&spi->dev, hw);
    b880:	4b07      	ldr	r3, [pc, #28]	; (b8a0 <spi_m_dma_init+0x38>)
	spi->dev.prvt = (void *)hw;
    b882:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_dma_init(&spi->dev, hw);
    b886:	4629      	mov	r1, r5
    b888:	4798      	blx	r3
	if (rc) {
    b88a:	b918      	cbnz	r0, b894 <spi_m_dma_init+0x2c>
	spi->io.read  = _spi_m_dma_io_read;
    b88c:	4b05      	ldr	r3, [pc, #20]	; (b8a4 <spi_m_dma_init+0x3c>)
    b88e:	6263      	str	r3, [r4, #36]	; 0x24
	spi->io.write = _spi_m_dma_io_write;
    b890:	4b05      	ldr	r3, [pc, #20]	; (b8a8 <spi_m_dma_init+0x40>)
    b892:	6223      	str	r3, [r4, #32]
}
    b894:	bd38      	pop	{r3, r4, r5, pc}
    b896:	bf00      	nop
    b898:	00016e26 	.word	0x00016e26
    b89c:	0000df45 	.word	0x0000df45
    b8a0:	00011675 	.word	0x00011675
    b8a4:	0000b831 	.word	0x0000b831
    b8a8:	0000b7f9 	.word	0x0000b7f9

0000b8ac <spi_m_dma_enable>:
{
    b8ac:	b510      	push	{r4, lr}
	ASSERT(spi);
    b8ae:	4604      	mov	r4, r0
    b8b0:	3800      	subs	r0, #0
    b8b2:	4b05      	ldr	r3, [pc, #20]	; (b8c8 <spi_m_dma_enable+0x1c>)
    b8b4:	4905      	ldr	r1, [pc, #20]	; (b8cc <spi_m_dma_enable+0x20>)
    b8b6:	bf18      	it	ne
    b8b8:	2001      	movne	r0, #1
    b8ba:	2251      	movs	r2, #81	; 0x51
    b8bc:	4798      	blx	r3
	_spi_m_dma_enable(&spi->dev);
    b8be:	1d20      	adds	r0, r4, #4
    b8c0:	4b03      	ldr	r3, [pc, #12]	; (b8d0 <spi_m_dma_enable+0x24>)
}
    b8c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_dma_enable(&spi->dev);
    b8c6:	4718      	bx	r3
    b8c8:	0000df45 	.word	0x0000df45
    b8cc:	00016e26 	.word	0x00016e26
    b8d0:	00011739 	.word	0x00011739

0000b8d4 <spi_m_dma_register_callback>:
	return _spi_m_dma_transfer(&spi->dev, txbuf, rxbuf, length);
}

void spi_m_dma_register_callback(struct spi_m_dma_descriptor *spi, const enum spi_m_dma_cb_type type,
                                 spi_m_dma_cb_t func)
{
    b8d4:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    b8d6:	4604      	mov	r4, r0
    b8d8:	3800      	subs	r0, #0
{
    b8da:	460d      	mov	r5, r1
    b8dc:	4616      	mov	r6, r2
	ASSERT(spi);
    b8de:	4907      	ldr	r1, [pc, #28]	; (b8fc <spi_m_dma_register_callback+0x28>)
    b8e0:	4b07      	ldr	r3, [pc, #28]	; (b900 <spi_m_dma_register_callback+0x2c>)
    b8e2:	f04f 02a8 	mov.w	r2, #168	; 0xa8
    b8e6:	bf18      	it	ne
    b8e8:	2001      	movne	r0, #1
    b8ea:	4798      	blx	r3
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    b8ec:	4632      	mov	r2, r6
    b8ee:	4629      	mov	r1, r5
    b8f0:	1d20      	adds	r0, r4, #4
    b8f2:	4b04      	ldr	r3, [pc, #16]	; (b904 <spi_m_dma_register_callback+0x30>)
}
    b8f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    b8f8:	4718      	bx	r3
    b8fa:	bf00      	nop
    b8fc:	00016e26 	.word	0x00016e26
    b900:	0000df45 	.word	0x0000df45
    b904:	00011769 	.word	0x00011769

0000b908 <spi_m_dma_get_io_descriptor>:

int32_t spi_m_dma_get_io_descriptor(struct spi_m_dma_descriptor *const spi, struct io_descriptor **io)
{
    b908:	b538      	push	{r3, r4, r5, lr}
    b90a:	460d      	mov	r5, r1
	ASSERT(spi && io);
    b90c:	4604      	mov	r4, r0
    b90e:	b110      	cbz	r0, b916 <spi_m_dma_get_io_descriptor+0xe>
    b910:	1e08      	subs	r0, r1, #0
    b912:	bf18      	it	ne
    b914:	2001      	movne	r0, #1
    b916:	4904      	ldr	r1, [pc, #16]	; (b928 <spi_m_dma_get_io_descriptor+0x20>)
    b918:	4b04      	ldr	r3, [pc, #16]	; (b92c <spi_m_dma_get_io_descriptor+0x24>)
    b91a:	22ae      	movs	r2, #174	; 0xae
	*io = &spi->io;
    b91c:	3420      	adds	r4, #32
	ASSERT(spi && io);
    b91e:	4798      	blx	r3
	*io = &spi->io;
    b920:	602c      	str	r4, [r5, #0]

	return 0;
}
    b922:	2000      	movs	r0, #0
    b924:	bd38      	pop	{r3, r4, r5, pc}
    b926:	bf00      	nop
    b928:	00016e26 	.word	0x00016e26
    b92c:	0000df45 	.word	0x0000df45

0000b930 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    b930:	3801      	subs	r0, #1
    b932:	2802      	cmp	r0, #2
{
    b934:	b508      	push	{r3, lr}
    b936:	460b      	mov	r3, r1
    b938:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    b93a:	d805      	bhi.n	b948 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    b93c:	4618      	mov	r0, r3
    b93e:	4b04      	ldr	r3, [pc, #16]	; (b950 <_write+0x20>)
    b940:	4798      	blx	r3
	if (n < 0) {
    b942:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    b946:	bd08      	pop	{r3, pc}
		return -1;
    b948:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    b94c:	e7fb      	b.n	b946 <_write+0x16>
    b94e:	bf00      	nop
    b950:	0000b7dd 	.word	0x0000b7dd

0000b954 <_event_system_init>:

/**
 * \brief Initialize event system
 */
int32_t _event_system_init(void)
{
    b954:	b510      	push	{r4, lr}
    b956:	4a13      	ldr	r2, [pc, #76]	; (b9a4 <_event_system_init+0x50>)
}

static inline void hri_evsys_write_USER_reg(const void *const hw, uint8_t index, hri_evsys_user_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->USER[index].reg = data;
    b958:	4913      	ldr	r1, [pc, #76]	; (b9a8 <_event_system_init+0x54>)
    b95a:	2300      	movs	r3, #0
    b95c:	f103 0048 	add.w	r0, r3, #72	; 0x48
    b960:	3301      	adds	r3, #1
	uint8_t i;
	/* configure user multiplexers */
	for (i = 0; i < EVSYS_USERS; i++) {
		hri_evsys_write_USER_reg(EVSYS, i, user_mux_confs[i]);
    b962:	f812 4b01 	ldrb.w	r4, [r2], #1
    b966:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	for (i = 0; i < EVSYS_USERS; i++) {
    b96a:	2b43      	cmp	r3, #67	; 0x43
    b96c:	d1f6      	bne.n	b95c <_event_system_init+0x8>
    b96e:	480f      	ldr	r0, [pc, #60]	; (b9ac <_event_system_init+0x58>)
    b970:	2100      	movs	r1, #0
    b972:	f100 0440 	add.w	r4, r0, #64	; 0x40
	}

	/* configure channels */
	for (i = 0; i < EVSYS_CHANNELS; i++) {
		hri_evsys_write_CHANNEL_reg(EVSYS, i, channel_confs[i]);
    b976:	00ca      	lsls	r2, r1, #3
    b978:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    b97c:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    b980:	f830 3b02 	ldrh.w	r3, [r0], #2

static inline void hri_evsys_write_CHANNEL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_channel_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->Channel[submodule_index].CHANNEL.reg = data;
    b984:	6213      	str	r3, [r2, #32]
		hri_evsys_write_CHINTEN_reg(EVSYS, i, interrupt_cfg[i]);
    b986:	f854 3b04 	ldr.w	r3, [r4], #4
    b98a:	b2db      	uxtb	r3, r3
	((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg = data;
    b98c:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
	((Evsys *)hw)->Channel[submodule_index].CHINTENCLR.reg = ~data;
    b990:	3101      	adds	r1, #1
    b992:	43db      	mvns	r3, r3
    b994:	b2db      	uxtb	r3, r3
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    b996:	2920      	cmp	r1, #32
    b998:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    b99c:	d1eb      	bne.n	b976 <_event_system_init+0x22>
	}

	return ERR_NONE;
}
    b99e:	2000      	movs	r0, #0
    b9a0:	bd10      	pop	{r4, pc}
    b9a2:	bf00      	nop
    b9a4:	00016e44 	.word	0x00016e44
    b9a8:	4100e000 	.word	0x4100e000
    b9ac:	00016e88 	.word	0x00016e88

0000b9b0 <_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    b9b0:	0943      	lsrs	r3, r0, #5
    b9b2:	2201      	movs	r2, #1
    b9b4:	f000 001f 	and.w	r0, r0, #31
    b9b8:	fa02 f000 	lsl.w	r0, r2, r0
    b9bc:	3340      	adds	r3, #64	; 0x40
    b9be:	4a02      	ldr	r2, [pc, #8]	; (b9c8 <_irq_set+0x18>)
    b9c0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
}
    b9c4:	4770      	bx	lr
    b9c6:	bf00      	nop
    b9c8:	e000e100 	.word	0xe000e100

0000b9cc <_get_cycles_for_ms>:
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    b9cc:	4b01      	ldr	r3, [pc, #4]	; (b9d4 <_get_cycles_for_ms+0x8>)
    b9ce:	4358      	muls	r0, r3
    b9d0:	4770      	bx	lr
    b9d2:	bf00      	nop
    b9d4:	0001d4c0 	.word	0x0001d4c0

0000b9d8 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    b9d8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    b9dc:	4615      	mov	r5, r2
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    b9de:	780a      	ldrb	r2, [r1, #0]
    b9e0:	f3c2 1341 	ubfx	r3, r2, #5, #2
    b9e4:	2b01      	cmp	r3, #1
{
    b9e6:	4606      	mov	r6, r0
    b9e8:	460c      	mov	r4, r1
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    b9ea:	d155      	bne.n	ba98 <cdcdf_acm_req+0xc0>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    b9ec:	4b2d      	ldr	r3, [pc, #180]	; (baa4 <cdcdf_acm_req+0xcc>)
    b9ee:	8889      	ldrh	r1, [r1, #4]
    b9f0:	7818      	ldrb	r0, [r3, #0]
    b9f2:	4288      	cmp	r0, r1
    b9f4:	4698      	mov	r8, r3
    b9f6:	d002      	beq.n	b9fe <cdcdf_acm_req+0x26>
    b9f8:	785b      	ldrb	r3, [r3, #1]
    b9fa:	428b      	cmp	r3, r1
    b9fc:	d14c      	bne.n	ba98 <cdcdf_acm_req+0xc0>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    b9fe:	0613      	lsls	r3, r2, #24
    ba00:	88e7      	ldrh	r7, [r4, #6]
    ba02:	d50f      	bpl.n	ba24 <cdcdf_acm_req+0x4c>
	if (USB_DATA_STAGE == stage) {
    ba04:	2d01      	cmp	r5, #1
    ba06:	d033      	beq.n	ba70 <cdcdf_acm_req+0x98>
	switch (req->bRequest) {
    ba08:	7863      	ldrb	r3, [r4, #1]
    ba0a:	2b21      	cmp	r3, #33	; 0x21
    ba0c:	d112      	bne.n	ba34 <cdcdf_acm_req+0x5c>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    ba0e:	2f07      	cmp	r7, #7
    ba10:	d145      	bne.n	ba9e <cdcdf_acm_req+0xc6>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    ba12:	4925      	ldr	r1, [pc, #148]	; (baa8 <cdcdf_acm_req+0xd0>)
    ba14:	2300      	movs	r3, #0
    ba16:	463a      	mov	r2, r7
			return usbdc_xfer(ep, ctrl_buf, len, false);
    ba18:	4c24      	ldr	r4, [pc, #144]	; (baac <cdcdf_acm_req+0xd4>)
    ba1a:	4630      	mov	r0, r6
    ba1c:	47a0      	blx	r4
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    ba1e:	b002      	add	sp, #8
    ba20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    ba24:	4b22      	ldr	r3, [pc, #136]	; (bab0 <cdcdf_acm_req+0xd8>)
    ba26:	4798      	blx	r3
	switch (req->bRequest) {
    ba28:	7863      	ldrb	r3, [r4, #1]
    ba2a:	2b20      	cmp	r3, #32
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    ba2c:	4601      	mov	r1, r0
	switch (req->bRequest) {
    ba2e:	d004      	beq.n	ba3a <cdcdf_acm_req+0x62>
    ba30:	2b22      	cmp	r3, #34	; 0x22
    ba32:	d024      	beq.n	ba7e <cdcdf_acm_req+0xa6>
		return ERR_INVALID_ARG;
    ba34:	f06f 000c 	mvn.w	r0, #12
    ba38:	e7f1      	b.n	ba1e <cdcdf_acm_req+0x46>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    ba3a:	2f07      	cmp	r7, #7
    ba3c:	d12f      	bne.n	ba9e <cdcdf_acm_req+0xc6>
		if (USB_SETUP_STAGE == stage) {
    ba3e:	b915      	cbnz	r5, ba46 <cdcdf_acm_req+0x6e>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    ba40:	462b      	mov	r3, r5
    ba42:	463a      	mov	r2, r7
    ba44:	e7e8      	b.n	ba18 <cdcdf_acm_req+0x40>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    ba46:	6800      	ldr	r0, [r0, #0]
    ba48:	9000      	str	r0, [sp, #0]
    ba4a:	798b      	ldrb	r3, [r1, #6]
    ba4c:	888a      	ldrh	r2, [r1, #4]
    ba4e:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    ba52:	f8d8 3010 	ldr.w	r3, [r8, #16]
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    ba56:	f8ad 2004 	strh.w	r2, [sp, #4]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    ba5a:	b95b      	cbnz	r3, ba74 <cdcdf_acm_req+0x9c>
				usbd_cdc_line_coding = line_coding_tmp;
    ba5c:	4b12      	ldr	r3, [pc, #72]	; (baa8 <cdcdf_acm_req+0xd0>)
    ba5e:	9800      	ldr	r0, [sp, #0]
    ba60:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    ba64:	f89d 2006 	ldrb.w	r2, [sp, #6]
    ba68:	f8c8 0006 	str.w	r0, [r8, #6]
    ba6c:	8099      	strh	r1, [r3, #4]
    ba6e:	719a      	strb	r2, [r3, #6]
		return ERR_NONE;
    ba70:	2000      	movs	r0, #0
    ba72:	e7d4      	b.n	ba1e <cdcdf_acm_req+0x46>
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    ba74:	4668      	mov	r0, sp
    ba76:	4798      	blx	r3
    ba78:	2800      	cmp	r0, #0
    ba7a:	d1ef      	bne.n	ba5c <cdcdf_acm_req+0x84>
    ba7c:	e7f8      	b.n	ba70 <cdcdf_acm_req+0x98>
		usbdc_xfer(0, NULL, 0, 0);
    ba7e:	2300      	movs	r3, #0
    ba80:	461a      	mov	r2, r3
    ba82:	4619      	mov	r1, r3
    ba84:	4618      	mov	r0, r3
    ba86:	4d09      	ldr	r5, [pc, #36]	; (baac <cdcdf_acm_req+0xd4>)
    ba88:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    ba8a:	f8d8 3014 	ldr.w	r3, [r8, #20]
    ba8e:	2b00      	cmp	r3, #0
    ba90:	d0ee      	beq.n	ba70 <cdcdf_acm_req+0x98>
			cdcdf_acm_notify_state(req->wValue);
    ba92:	8860      	ldrh	r0, [r4, #2]
    ba94:	4798      	blx	r3
    ba96:	e7eb      	b.n	ba70 <cdcdf_acm_req+0x98>
		return ERR_NOT_FOUND;
    ba98:	f06f 0009 	mvn.w	r0, #9
    ba9c:	e7bf      	b.n	ba1e <cdcdf_acm_req+0x46>
			return ERR_INVALID_DATA;
    ba9e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    baa2:	e7bc      	b.n	ba1e <cdcdf_acm_req+0x46>
    baa4:	20001174 	.word	0x20001174
    baa8:	2000117a 	.word	0x2000117a
    baac:	00012f99 	.word	0x00012f99
    bab0:	000133c5 	.word	0x000133c5

0000bab4 <cdcdf_acm_ctrl>:
	switch (ctrl) {
    bab4:	2901      	cmp	r1, #1
{
    bab6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    baba:	4615      	mov	r5, r2
	switch (ctrl) {
    babc:	d04f      	beq.n	bb5e <cdcdf_acm_ctrl+0xaa>
    babe:	2902      	cmp	r1, #2
    bac0:	d076      	beq.n	bbb0 <cdcdf_acm_ctrl+0xfc>
    bac2:	2900      	cmp	r1, #0
    bac4:	d177      	bne.n	bbb6 <cdcdf_acm_ctrl+0x102>
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    bac6:	6887      	ldr	r7, [r0, #8]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bac8:	f8df 8114 	ldr.w	r8, [pc, #276]	; bbe0 <cdcdf_acm_ctrl+0x12c>
	ifc = desc->sod;
    bacc:	6810      	ldr	r0, [r2, #0]
	for (i = 0; i < 2; i++) {
    bace:	1e7e      	subs	r6, r7, #1
		if (NULL == ifc) {
    bad0:	b928      	cbnz	r0, bade <cdcdf_acm_ctrl+0x2a>
			return ERR_NOT_FOUND;
    bad2:	f06f 0009 	mvn.w	r0, #9
}
    bad6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bada:	464e      	mov	r6, r9
    badc:	e7f8      	b.n	bad0 <cdcdf_acm_ctrl+0x1c>
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bade:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    bae0:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bae2:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bae6:	2b02      	cmp	r3, #2
    bae8:	d1f3      	bne.n	bad2 <cdcdf_acm_ctrl+0x1e>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    baea:	7873      	ldrb	r3, [r6, #1]
    baec:	429a      	cmp	r2, r3
    baee:	d065      	beq.n	bbbc <cdcdf_acm_ctrl+0x108>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    baf0:	2bff      	cmp	r3, #255	; 0xff
    baf2:	d166      	bne.n	bbc2 <cdcdf_acm_ctrl+0x10e>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    baf4:	7072      	strb	r2, [r6, #1]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    baf6:	6869      	ldr	r1, [r5, #4]
    baf8:	f8df a0e8 	ldr.w	sl, [pc, #232]	; bbe4 <cdcdf_acm_ctrl+0x130>
    bafc:	2205      	movs	r2, #5
    bafe:	47c0      	blx	r8
    bb00:	f106 0901 	add.w	r9, r6, #1
    bb04:	4604      	mov	r4, r0
		while (NULL != ep) {
    bb06:	b964      	cbnz	r4, bb22 <cdcdf_acm_ctrl+0x6e>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    bb08:	682b      	ldr	r3, [r5, #0]
    bb0a:	6869      	ldr	r1, [r5, #4]
    bb0c:	7818      	ldrb	r0, [r3, #0]
    bb0e:	2204      	movs	r2, #4
    bb10:	4418      	add	r0, r3
    bb12:	47c0      	blx	r8
	for (i = 0; i < 2; i++) {
    bb14:	42be      	cmp	r6, r7
    bb16:	d1e0      	bne.n	bada <cdcdf_acm_ctrl+0x26>
	_cdcdf_acm_funcd.enabled = true;
    bb18:	4b2d      	ldr	r3, [pc, #180]	; (bbd0 <cdcdf_acm_ctrl+0x11c>)
    bb1a:	2201      	movs	r2, #1
    bb1c:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    bb1e:	4620      	mov	r0, r4
    bb20:	e7d9      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
	return (ptr[0] + (ptr[1] << 8));
    bb22:	7961      	ldrb	r1, [r4, #5]
    bb24:	7922      	ldrb	r2, [r4, #4]
			ep_desc.bEndpointAddress = ep[2];
    bb26:	f894 b002 	ldrb.w	fp, [r4, #2]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    bb2a:	4b2a      	ldr	r3, [pc, #168]	; (bbd4 <cdcdf_acm_ctrl+0x120>)
    bb2c:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    bb30:	b292      	uxth	r2, r2
    bb32:	78e1      	ldrb	r1, [r4, #3]
    bb34:	4658      	mov	r0, fp
    bb36:	4798      	blx	r3
    bb38:	2800      	cmp	r0, #0
    bb3a:	d145      	bne.n	bbc8 <cdcdf_acm_ctrl+0x114>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    bb3c:	f01b 0f80 	tst.w	fp, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    bb40:	bf14      	ite	ne
    bb42:	f889 b002 	strbne.w	fp, [r9, #2]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    bb46:	f887 b004 	strbeq.w	fp, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    bb4a:	4658      	mov	r0, fp
    bb4c:	47d0      	blx	sl
			desc->sod = ep;
    bb4e:	602c      	str	r4, [r5, #0]
	return (desc + usb_desc_len(desc));
    bb50:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    bb52:	6869      	ldr	r1, [r5, #4]
    bb54:	4b20      	ldr	r3, [pc, #128]	; (bbd8 <cdcdf_acm_ctrl+0x124>)
    bb56:	4420      	add	r0, r4
    bb58:	4798      	blx	r3
    bb5a:	4604      	mov	r4, r0
    bb5c:	e7d3      	b.n	bb06 <cdcdf_acm_ctrl+0x52>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    bb5e:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    bb60:	b12a      	cbz	r2, bb6e <cdcdf_acm_ctrl+0xba>
		ifc_desc.bInterfaceClass = desc->sod[5];
    bb62:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    bb64:	795b      	ldrb	r3, [r3, #5]
    bb66:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bb6a:	2b02      	cmp	r3, #2
    bb6c:	d1b1      	bne.n	bad2 <cdcdf_acm_ctrl+0x1e>
		if (func_data->func_iface[i] == 0xFF) {
    bb6e:	7823      	ldrb	r3, [r4, #0]
    bb70:	2bff      	cmp	r3, #255	; 0xff
    bb72:	d007      	beq.n	bb84 <cdcdf_acm_ctrl+0xd0>
			if (func_data->func_ep_in[i] != 0xFF) {
    bb74:	78a0      	ldrb	r0, [r4, #2]
			func_data->func_iface[i] = 0xFF;
    bb76:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    bb78:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    bb7a:	7025      	strb	r5, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    bb7c:	d002      	beq.n	bb84 <cdcdf_acm_ctrl+0xd0>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    bb7e:	4b17      	ldr	r3, [pc, #92]	; (bbdc <cdcdf_acm_ctrl+0x128>)
    bb80:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    bb82:	70a5      	strb	r5, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    bb84:	7863      	ldrb	r3, [r4, #1]
    bb86:	2bff      	cmp	r3, #255	; 0xff
    bb88:	d007      	beq.n	bb9a <cdcdf_acm_ctrl+0xe6>
			if (func_data->func_ep_in[i] != 0xFF) {
    bb8a:	78e0      	ldrb	r0, [r4, #3]
			func_data->func_iface[i] = 0xFF;
    bb8c:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    bb8e:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    bb90:	7065      	strb	r5, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    bb92:	d002      	beq.n	bb9a <cdcdf_acm_ctrl+0xe6>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    bb94:	4b11      	ldr	r3, [pc, #68]	; (bbdc <cdcdf_acm_ctrl+0x128>)
    bb96:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    bb98:	70e5      	strb	r5, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    bb9a:	7920      	ldrb	r0, [r4, #4]
    bb9c:	28ff      	cmp	r0, #255	; 0xff
    bb9e:	d003      	beq.n	bba8 <cdcdf_acm_ctrl+0xf4>
		usb_d_ep_deinit(func_data->func_ep_out);
    bba0:	4b0e      	ldr	r3, [pc, #56]	; (bbdc <cdcdf_acm_ctrl+0x128>)
    bba2:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    bba4:	23ff      	movs	r3, #255	; 0xff
    bba6:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    bba8:	4b09      	ldr	r3, [pc, #36]	; (bbd0 <cdcdf_acm_ctrl+0x11c>)
    bbaa:	2000      	movs	r0, #0
    bbac:	7158      	strb	r0, [r3, #5]
	return ERR_NONE;
    bbae:	e792      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
		return ERR_UNSUPPORTED_OP;
    bbb0:	f06f 001a 	mvn.w	r0, #26
    bbb4:	e78f      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
	switch (ctrl) {
    bbb6:	f06f 000c 	mvn.w	r0, #12
    bbba:	e78c      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
				return ERR_ALREADY_INITIALIZED;
    bbbc:	f06f 0011 	mvn.w	r0, #17
    bbc0:	e789      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
				return ERR_NO_RESOURCE;
    bbc2:	f06f 001b 	mvn.w	r0, #27
    bbc6:	e786      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
				return ERR_NOT_INITIALIZED;
    bbc8:	f06f 0013 	mvn.w	r0, #19
    bbcc:	e783      	b.n	bad6 <cdcdf_acm_ctrl+0x22>
    bbce:	bf00      	nop
    bbd0:	20001174 	.word	0x20001174
    bbd4:	0000f429 	.word	0x0000f429
    bbd8:	0000b70f 	.word	0x0000b70f
    bbdc:	0000f48d 	.word	0x0000f48d
    bbe0:	0000b6f5 	.word	0x0000b6f5
    bbe4:	0000f4b9 	.word	0x0000f4b9

0000bbe8 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    bbe8:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    bbea:	4b0a      	ldr	r3, [pc, #40]	; (bc14 <cdcdf_acm_init+0x2c>)
    bbec:	4798      	blx	r3
    bbee:	2801      	cmp	r0, #1
    bbf0:	d80c      	bhi.n	bc0c <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    bbf2:	4809      	ldr	r0, [pc, #36]	; (bc18 <cdcdf_acm_init+0x30>)
    bbf4:	4b09      	ldr	r3, [pc, #36]	; (bc1c <cdcdf_acm_init+0x34>)
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    bbf6:	e9c0 3007 	strd	r3, r0, [r0, #28]

	usbdc_register_function(&_cdcdf_acm);
    bbfa:	4b09      	ldr	r3, [pc, #36]	; (bc20 <cdcdf_acm_init+0x38>)
    bbfc:	3018      	adds	r0, #24
    bbfe:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    bc00:	2001      	movs	r0, #1
    bc02:	4908      	ldr	r1, [pc, #32]	; (bc24 <cdcdf_acm_init+0x3c>)
    bc04:	4b08      	ldr	r3, [pc, #32]	; (bc28 <cdcdf_acm_init+0x40>)
    bc06:	4798      	blx	r3
	return ERR_NONE;
    bc08:	2000      	movs	r0, #0
}
    bc0a:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    bc0c:	f06f 0010 	mvn.w	r0, #16
    bc10:	e7fb      	b.n	bc0a <cdcdf_acm_init+0x22>
    bc12:	bf00      	nop
    bc14:	000133d1 	.word	0x000133d1
    bc18:	20001174 	.word	0x20001174
    bc1c:	0000bab5 	.word	0x0000bab5
    bc20:	00013379 	.word	0x00013379
    bc24:	20000354 	.word	0x20000354
    bc28:	000132f1 	.word	0x000132f1

0000bc2c <cdcdf_acm_read>:

/**
 * \brief USB CDC ACM Function Read Data
 */
int32_t cdcdf_acm_read(uint8_t *buf, uint32_t size)
{
    bc2c:	b410      	push	{r4}
/**
 * \brief Check whether CDC ACM Function is enabled
 */
bool cdcdf_acm_is_enabled(void)
{
	return _cdcdf_acm_funcd.enabled;
    bc2e:	4c08      	ldr	r4, [pc, #32]	; (bc50 <cdcdf_acm_read+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    bc30:	7963      	ldrb	r3, [r4, #5]
{
    bc32:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    bc34:	b13b      	cbz	r3, bc46 <cdcdf_acm_read+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    bc36:	4601      	mov	r1, r0
    bc38:	7920      	ldrb	r0, [r4, #4]
    bc3a:	4c06      	ldr	r4, [pc, #24]	; (bc54 <cdcdf_acm_read+0x28>)
    bc3c:	2300      	movs	r3, #0
    bc3e:	46a4      	mov	ip, r4
}
    bc40:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    bc44:	4760      	bx	ip
}
    bc46:	f06f 0010 	mvn.w	r0, #16
    bc4a:	f85d 4b04 	ldr.w	r4, [sp], #4
    bc4e:	4770      	bx	lr
    bc50:	20001174 	.word	0x20001174
    bc54:	00012f99 	.word	0x00012f99

0000bc58 <cdcdf_acm_write>:
{
    bc58:	b410      	push	{r4}
	return _cdcdf_acm_funcd.enabled;
    bc5a:	4c08      	ldr	r4, [pc, #32]	; (bc7c <cdcdf_acm_write+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    bc5c:	7963      	ldrb	r3, [r4, #5]
{
    bc5e:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    bc60:	b13b      	cbz	r3, bc72 <cdcdf_acm_write+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    bc62:	4601      	mov	r1, r0
    bc64:	78e0      	ldrb	r0, [r4, #3]
    bc66:	4c06      	ldr	r4, [pc, #24]	; (bc80 <cdcdf_acm_write+0x28>)
    bc68:	2301      	movs	r3, #1
    bc6a:	46a4      	mov	ip, r4
}
    bc6c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    bc70:	4760      	bx	ip
}
    bc72:	f06f 0010 	mvn.w	r0, #16
    bc76:	f85d 4b04 	ldr.w	r4, [sp], #4
    bc7a:	4770      	bx	lr
    bc7c:	20001174 	.word	0x20001174
    bc80:	00012f99 	.word	0x00012f99

0000bc84 <cdcdf_acm_register_callback>:
{
    bc84:	b508      	push	{r3, lr}
    bc86:	460a      	mov	r2, r1
    bc88:	2803      	cmp	r0, #3
    bc8a:	d814      	bhi.n	bcb6 <cdcdf_acm_register_callback+0x32>
    bc8c:	e8df f000 	tbb	[pc, r0]
    bc90:	100d0902 	.word	0x100d0902
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    bc94:	4b09      	ldr	r3, [pc, #36]	; (bcbc <cdcdf_acm_register_callback+0x38>)
    bc96:	7918      	ldrb	r0, [r3, #4]
    bc98:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    bc9a:	4b09      	ldr	r3, [pc, #36]	; (bcc0 <cdcdf_acm_register_callback+0x3c>)
    bc9c:	4798      	blx	r3
	return ERR_NONE;
    bc9e:	2000      	movs	r0, #0
}
    bca0:	bd08      	pop	{r3, pc}
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    bca2:	4b06      	ldr	r3, [pc, #24]	; (bcbc <cdcdf_acm_register_callback+0x38>)
    bca4:	2102      	movs	r1, #2
    bca6:	78d8      	ldrb	r0, [r3, #3]
    bca8:	e7f7      	b.n	bc9a <cdcdf_acm_register_callback+0x16>
		cdcdf_acm_set_line_coding = (cdcdf_acm_set_line_coding_t)func;
    bcaa:	4b04      	ldr	r3, [pc, #16]	; (bcbc <cdcdf_acm_register_callback+0x38>)
    bcac:	6119      	str	r1, [r3, #16]
		break;
    bcae:	e7f6      	b.n	bc9e <cdcdf_acm_register_callback+0x1a>
		cdcdf_acm_notify_state = (cdcdf_acm_notify_state_t)func;
    bcb0:	4b02      	ldr	r3, [pc, #8]	; (bcbc <cdcdf_acm_register_callback+0x38>)
    bcb2:	6159      	str	r1, [r3, #20]
    bcb4:	e7f3      	b.n	bc9e <cdcdf_acm_register_callback+0x1a>
	return ERR_NONE;
    bcb6:	f06f 000c 	mvn.w	r0, #12
    bcba:	e7f1      	b.n	bca0 <cdcdf_acm_register_callback+0x1c>
    bcbc:	20001174 	.word	0x20001174
    bcc0:	0000f6a1 	.word	0x0000f6a1

0000bcc4 <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    bcc4:	4b04      	ldr	r3, [pc, #16]	; (bcd8 <_sbrk+0x14>)
    bcc6:	6819      	ldr	r1, [r3, #0]
{
    bcc8:	4602      	mov	r2, r0
	if (heap == NULL) {
    bcca:	b909      	cbnz	r1, bcd0 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
    bccc:	4903      	ldr	r1, [pc, #12]	; (bcdc <_sbrk+0x18>)
    bcce:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
    bcd0:	6818      	ldr	r0, [r3, #0]

	heap += incr;
    bcd2:	4402      	add	r2, r0
    bcd4:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
}
    bcd6:	4770      	bx	lr
    bcd8:	20001198 	.word	0x20001198
    bcdc:	200259f8 	.word	0x200259f8

0000bce0 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    bce0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bce4:	4770      	bx	lr

0000bce6 <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    bce6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    bcea:	604b      	str	r3, [r1, #4]

	return 0;
}
    bcec:	2000      	movs	r0, #0
    bcee:	4770      	bx	lr

0000bcf0 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    bcf0:	2001      	movs	r0, #1
    bcf2:	4770      	bx	lr

0000bcf4 <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    bcf4:	2000      	movs	r0, #0
    bcf6:	4770      	bx	lr

0000bcf8 <_qspi_dma_rx_complete>:
 *  \brief Callback for RX
 *  \param[in, out] dev Pointer to the DMA resource.
 */
static void _qspi_dma_rx_complete(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;
    bcf8:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_qspi_write_CTRLA_reg(const void *const hw, hri_qspi_ctrla_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLA.reg = data;
    bcfa:	4903      	ldr	r1, [pc, #12]	; (bd08 <_qspi_dma_rx_complete+0x10>)

	_qspi_end_transfer(dev->prvt);
    bcfc:	681a      	ldr	r2, [r3, #0]

	if (dev->cb.xfer_done) {
    bcfe:	685b      	ldr	r3, [r3, #4]
    bd00:	6011      	str	r1, [r2, #0]
    bd02:	b103      	cbz	r3, bd06 <_qspi_dma_rx_complete+0xe>
		dev->cb.xfer_done(resource);
    bd04:	4718      	bx	r3
	}
}
    bd06:	4770      	bx	lr
    bd08:	01000002 	.word	0x01000002

0000bd0c <_qspi_dma_tx_complete>:
    bd0c:	4b00      	ldr	r3, [pc, #0]	; (bd10 <_qspi_dma_tx_complete+0x4>)
    bd0e:	4718      	bx	r3
    bd10:	0000bcf9 	.word	0x0000bcf9

0000bd14 <_qspi_dma_error_occured>:
 */
static void _qspi_dma_error_occured(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;

	if (dev->cb.error) {
    bd14:	6883      	ldr	r3, [r0, #8]
    bd16:	689b      	ldr	r3, [r3, #8]
    bd18:	b103      	cbz	r3, bd1c <_qspi_dma_error_occured+0x8>
		dev->cb.error(resource);
    bd1a:	4718      	bx	r3
	}
}
    bd1c:	4770      	bx	lr
	...

0000bd20 <_qspi_dma_init>:

int32_t _qspi_dma_init(struct _qspi_dma_dev *dev, void *const hw)
{
    bd20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    bd22:	460d      	mov	r5, r1
	ASSERT(dev && hw);
    bd24:	4604      	mov	r4, r0
    bd26:	b110      	cbz	r0, bd2e <_qspi_dma_init+0xe>
    bd28:	1e08      	subs	r0, r1, #0
    bd2a:	bf18      	it	ne
    bd2c:	2001      	movne	r0, #1
	dev->prvt = hw;
    bd2e:	4626      	mov	r6, r4
	ASSERT(dev && hw);
    bd30:	22cb      	movs	r2, #203	; 0xcb
    bd32:	490f      	ldr	r1, [pc, #60]	; (bd70 <_qspi_dma_init+0x50>)
    bd34:	4b0f      	ldr	r3, [pc, #60]	; (bd74 <_qspi_dma_init+0x54>)
	hri_qspi_write_BAUD_reg(hw,
	                        CONF_QSPI_CPOL << QSPI_BAUD_CPOL_Pos | CONF_QSPI_CPHA << QSPI_BAUD_CPHA_Pos
	                            | QSPI_BAUD_BAUD(CONF_QSPI_BAUD_RATE) | QSPI_BAUD_DLYBS(CONF_QSPI_DLYBS));

	/* Initialize DMA rx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    bd36:	4f10      	ldr	r7, [pc, #64]	; (bd78 <_qspi_dma_init+0x58>)
	ASSERT(dev && hw);
    bd38:	4798      	blx	r3
    bd3a:	2301      	movs	r3, #1
	dev->prvt = hw;
    bd3c:	f846 5b0c 	str.w	r5, [r6], #12
    bd40:	602b      	str	r3, [r5, #0]
}

static inline void hri_qspi_write_CTRLB_reg(const void *const hw, hri_qspi_ctrlb_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLB.reg = data;
    bd42:	4b0e      	ldr	r3, [pc, #56]	; (bd7c <_qspi_dma_init+0x5c>)
    bd44:	606b      	str	r3, [r5, #4]
}

static inline void hri_qspi_write_BAUD_reg(const void *const hw, hri_qspi_baud_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->BAUD.reg = data;
    bd46:	4b0e      	ldr	r3, [pc, #56]	; (bd80 <_qspi_dma_init+0x60>)
    bd48:	60ab      	str	r3, [r5, #8]
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    bd4a:	211f      	movs	r1, #31
    bd4c:	4630      	mov	r0, r6
    bd4e:	47b8      	blx	r7
	dev->resource->back                 = dev;
    bd50:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    bd52:	4a0c      	ldr	r2, [pc, #48]	; (bd84 <_qspi_dma_init+0x64>)
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    bd54:	4d0c      	ldr	r5, [pc, #48]	; (bd88 <_qspi_dma_init+0x68>)
	dev->resource->back                 = dev;
    bd56:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    bd58:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    bd5a:	605d      	str	r5, [r3, #4]
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_TX_CHANNEL);
    bd5c:	211e      	movs	r1, #30
    bd5e:	4630      	mov	r0, r6
    bd60:	47b8      	blx	r7
	dev->resource->back                 = dev;
    bd62:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_tx_complete;
    bd64:	4a09      	ldr	r2, [pc, #36]	; (bd8c <_qspi_dma_init+0x6c>)
	dev->resource->back                 = dev;
    bd66:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    bd68:	e9c3 2500 	strd	r2, r5, [r3]

	return ERR_NONE;
}
    bd6c:	2000      	movs	r0, #0
    bd6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    bd70:	00016f48 	.word	0x00016f48
    bd74:	0000df45 	.word	0x0000df45
    bd78:	0000e189 	.word	0x0000e189
    bd7c:	06000011 	.word	0x06000011
    bd80:	00243b00 	.word	0x00243b00
    bd84:	0000bcf9 	.word	0x0000bcf9
    bd88:	0000bd15 	.word	0x0000bd15
    bd8c:	0000bd0d 	.word	0x0000bd0d

0000bd90 <_flash_program>:
 * \param[in]  buffer        Pointer to buffer where the data to
 *                           write is stored
 * \param[in] size           The size of data to write to a page
 */
static void _flash_program(void *const hw, const uint32_t dst_addr, const uint8_t *buffer, const uint16_t size)
{
    bd90:	b570      	push	{r4, r5, r6, lr}
	uint32_t *ptr_read    = (uint32_t *)buffer;
	uint32_t  nvm_address = dst_addr / 4;
    bd92:	088d      	lsrs	r5, r1, #2
	return ((Nvmctrl *)hw)->PARAM.reg;
}

static inline bool hri_nvmctrl_get_STATUS_READY_bit(const void *const hw)
{
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bd94:	8a44      	ldrh	r4, [r0, #18]
	uint16_t  i;

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bd96:	07e6      	lsls	r6, r4, #31
    bd98:	d5fc      	bpl.n	bd94 <_flash_program+0x4>
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bd9a:	f24a 5415 	movw	r4, #42261	; 0xa515
    bd9e:	8084      	strh	r4, [r0, #4]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bda0:	8a44      	ldrh	r4, [r0, #18]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_PBC | NVMCTRL_CTRLB_CMDEX_KEY);

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bda2:	07e4      	lsls	r4, r4, #31
    bda4:	d5fc      	bpl.n	bda0 <_flash_program+0x10>
    bda6:	00ad      	lsls	r5, r5, #2
    bda8:	2400      	movs	r4, #0
		/* Wait until this module isn't busy */
	}

	/* Writes to the page buffer must be 32 bits, perform manual copy
	 * to ensure alignment */
	for (i = 0; i < size; i += 4) {
    bdaa:	b2a6      	uxth	r6, r4
    bdac:	429e      	cmp	r6, r3
    bdae:	d307      	bcc.n	bdc0 <_flash_program+0x30>
    bdb0:	8a43      	ldrh	r3, [r0, #18]
		NVM_MEMORY[nvm_address++] = *ptr_read;
		ptr_read++;
	}

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bdb2:	07db      	lsls	r3, r3, #31
    bdb4:	d5fc      	bpl.n	bdb0 <_flash_program+0x20>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bdb6:	f24a 5303 	movw	r3, #42243	; 0xa503
	((Nvmctrl *)hw)->ADDR.reg = data;
    bdba:	6141      	str	r1, [r0, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bdbc:	8083      	strh	r3, [r0, #4]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_ADDR_reg(hw, dst_addr);
	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_WP | NVMCTRL_CTRLB_CMDEX_KEY);
}
    bdbe:	bd70      	pop	{r4, r5, r6, pc}
		NVM_MEMORY[nvm_address++] = *ptr_read;
    bdc0:	5916      	ldr	r6, [r2, r4]
    bdc2:	5166      	str	r6, [r4, r5]
	for (i = 0; i < size; i += 4) {
    bdc4:	3404      	adds	r4, #4
    bdc6:	e7f0      	b.n	bdaa <_flash_program+0x1a>

0000bdc8 <_flash_init>:
{
    bdc8:	b538      	push	{r3, r4, r5, lr}
    bdca:	460d      	mov	r5, r1
	ASSERT(device && (hw == NVMCTRL));
    bdcc:	4604      	mov	r4, r0
    bdce:	b118      	cbz	r0, bdd8 <_flash_init+0x10>
    bdd0:	4814      	ldr	r0, [pc, #80]	; (be24 <_flash_init+0x5c>)
    bdd2:	1a0b      	subs	r3, r1, r0
    bdd4:	4258      	negs	r0, r3
    bdd6:	4158      	adcs	r0, r3
    bdd8:	4913      	ldr	r1, [pc, #76]	; (be28 <_flash_init+0x60>)
    bdda:	4b14      	ldr	r3, [pc, #80]	; (be2c <_flash_init+0x64>)
    bddc:	224b      	movs	r2, #75	; 0x4b
    bdde:	4798      	blx	r3
	return ((Nvmctrl *)hw)->CTRLA.reg;
    bde0:	882b      	ldrh	r3, [r5, #0]
	device->hw = hw;
    bde2:	6125      	str	r5, [r4, #16]
	hri_nvmctrl_write_CTRLA_reg(hw, ctrla);
    bde4:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    bde8:	049b      	lsls	r3, r3, #18
    bdea:	0c9b      	lsrs	r3, r3, #18
	((Nvmctrl *)hw)->CTRLA.reg = data;
    bdec:	802b      	strh	r3, [r5, #0]
	_nvm_dev = device;
    bdee:	4b10      	ldr	r3, [pc, #64]	; (be30 <_flash_init+0x68>)
    bdf0:	601c      	str	r4, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    bdf2:	4b10      	ldr	r3, [pc, #64]	; (be34 <_flash_init+0x6c>)
    bdf4:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    bdf8:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
    bdfc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    be00:	f3bf 8f6f 	isb	sy
    be04:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    be08:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    be0c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    be10:	f3bf 8f6f 	isb	sy
}
    be14:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    be16:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    be1a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    be1e:	6019      	str	r1, [r3, #0]
    be20:	601a      	str	r2, [r3, #0]
    be22:	bd38      	pop	{r3, r4, r5, pc}
    be24:	41004000 	.word	0x41004000
    be28:	00016f5f 	.word	0x00016f5f
    be2c:	0000df45 	.word	0x0000df45
    be30:	2000119c 	.word	0x2000119c
    be34:	e000e100 	.word	0xe000e100

0000be38 <_flash_get_page_size>:
}
    be38:	f44f 7000 	mov.w	r0, #512	; 0x200
    be3c:	4770      	bx	lr

0000be3e <_flash_get_total_pages>:
	return (uint32_t)hri_nvmctrl_read_PARAM_NVMP_bf(device->hw);
    be3e:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->PARAM.reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;
    be40:	6898      	ldr	r0, [r3, #8]
}
    be42:	b280      	uxth	r0, r0
    be44:	4770      	bx	lr

0000be46 <_flash_read>:
{
    be46:	b510      	push	{r4, lr}
	while (!hri_nvmctrl_get_STATUS_READY_bit(device->hw)) {
    be48:	6904      	ldr	r4, [r0, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    be4a:	8a60      	ldrh	r0, [r4, #18]
    be4c:	07c0      	lsls	r0, r0, #31
    be4e:	d5fc      	bpl.n	be4a <_flash_read+0x4>
	for (i = 0; i < length; i++) {
    be50:	2000      	movs	r0, #0
    be52:	e002      	b.n	be5a <_flash_read+0x14>
		buffer[i] = nvm_addr[src_addr + i];
    be54:	5c44      	ldrb	r4, [r0, r1]
    be56:	5414      	strb	r4, [r2, r0]
	for (i = 0; i < length; i++) {
    be58:	3001      	adds	r0, #1
    be5a:	4298      	cmp	r0, r3
    be5c:	d1fa      	bne.n	be54 <_flash_read+0xe>
}
    be5e:	bd10      	pop	{r4, pc}

0000be60 <_flash_write>:
{
    be60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    be64:	f5ad 5d00 	sub.w	sp, sp, #8192	; 0x2000
    be68:	b083      	sub	sp, #12
    be6a:	4606      	mov	r6, r0
    be6c:	460c      	mov	r4, r1
    be6e:	4617      	mov	r7, r2
    be70:	9301      	str	r3, [sp, #4]
		block_start_addr = wr_start_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    be72:	f424 59ff 	bic.w	r9, r4, #8160	; 0x1fe0
    be76:	f029 091f 	bic.w	r9, r9, #31
		block_end_addr   = block_start_addr + NVMCTRL_BLOCK_SIZE - 1;
    be7a:	f509 5aff 	add.w	sl, r9, #8160	; 0x1fe0
    be7e:	f10a 0a1f 	add.w	sl, sl, #31
    be82:	f04f 0800 	mov.w	r8, #0
			_flash_read(device, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    be86:	aa02      	add	r2, sp, #8
    be88:	4442      	add	r2, r8
    be8a:	eb09 0108 	add.w	r1, r9, r8
    be8e:	4d24      	ldr	r5, [pc, #144]	; (bf20 <_flash_write+0xc0>)
    be90:	f44f 7300 	mov.w	r3, #512	; 0x200
    be94:	4630      	mov	r0, r6
    be96:	f508 7800 	add.w	r8, r8, #512	; 0x200
    be9a:	47a8      	blx	r5
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    be9c:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    bea0:	d1f1      	bne.n	be86 <_flash_write+0x26>
		j = (wr_start_addr - block_start_addr) / NVMCTRL_PAGE_SIZE;
    bea2:	eba4 0309 	sub.w	r3, r4, r9
    bea6:	0a5a      	lsrs	r2, r3, #9
		k = wr_start_addr - block_start_addr - j * NVMCTRL_PAGE_SIZE;
    bea8:	4639      	mov	r1, r7
    beaa:	f3c3 0308 	ubfx	r3, r3, #0, #9
		while ((wr_start_addr <= block_end_addr) && (length > 0)) {
    beae:	4554      	cmp	r4, sl
    beb0:	460f      	mov	r7, r1
    beb2:	d801      	bhi.n	beb8 <_flash_write+0x58>
    beb4:	9801      	ldr	r0, [sp, #4]
    beb6:	bb18      	cbnz	r0, bf00 <_flash_write+0xa0>
		_flash_erase_block(device->hw, block_start_addr);
    beb8:	6933      	ldr	r3, [r6, #16]
    beba:	8a5a      	ldrh	r2, [r3, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bebc:	07d2      	lsls	r2, r2, #31
    bebe:	d5fc      	bpl.n	beba <_flash_write+0x5a>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bec0:	f24a 5201 	movw	r2, #42241	; 0xa501
			_flash_program(device->hw, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    bec4:	f8df b05c 	ldr.w	fp, [pc, #92]	; bf24 <_flash_write+0xc4>
	((Nvmctrl *)hw)->ADDR.reg = data;
    bec8:	f8c3 9014 	str.w	r9, [r3, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    becc:	f04f 0800 	mov.w	r8, #0
    bed0:	809a      	strh	r2, [r3, #4]
    bed2:	aa02      	add	r2, sp, #8
    bed4:	4442      	add	r2, r8
    bed6:	eb09 0108 	add.w	r1, r9, r8
    beda:	6930      	ldr	r0, [r6, #16]
    bedc:	f44f 7300 	mov.w	r3, #512	; 0x200
    bee0:	f508 7800 	add.w	r8, r8, #512	; 0x200
    bee4:	47d8      	blx	fp
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    bee6:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    beea:	d1f2      	bne.n	bed2 <_flash_write+0x72>
	} while (block_end_addr < (wr_start_addr + length - 1));
    beec:	9b01      	ldr	r3, [sp, #4]
    beee:	4423      	add	r3, r4
    bef0:	3b01      	subs	r3, #1
    bef2:	4553      	cmp	r3, sl
    bef4:	d8bd      	bhi.n	be72 <_flash_write+0x12>
}
    bef6:	f50d 5d00 	add.w	sp, sp, #8192	; 0x2000
    befa:	b003      	add	sp, #12
    befc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tmp_buffer[j][k] = *buffer;
    bf00:	a802      	add	r0, sp, #8
    bf02:	eb00 2042 	add.w	r0, r0, r2, lsl #9
    bf06:	783f      	ldrb	r7, [r7, #0]
    bf08:	54c7      	strb	r7, [r0, r3]
			k                = (k + 1) % NVMCTRL_PAGE_SIZE;
    bf0a:	3301      	adds	r3, #1
    bf0c:	f3c3 0308 	ubfx	r3, r3, #0, #9
			if (0 == k) {
    bf10:	3101      	adds	r1, #1
    bf12:	b903      	cbnz	r3, bf16 <_flash_write+0xb6>
				j++;
    bf14:	3201      	adds	r2, #1
			length--;
    bf16:	9801      	ldr	r0, [sp, #4]
    bf18:	3801      	subs	r0, #1
			wr_start_addr++;
    bf1a:	3401      	adds	r4, #1
			length--;
    bf1c:	9001      	str	r0, [sp, #4]
    bf1e:	e7c6      	b.n	beae <_flash_write+0x4e>
    bf20:	0000be47 	.word	0x0000be47
    bf24:	0000bd91 	.word	0x0000bd91

0000bf28 <_flash_erase>:
{
    bf28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    bf2c:	f421 54ff 	bic.w	r4, r1, #8160	; 0x1fe0
{
    bf30:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
    bf34:	460e      	mov	r6, r1
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    bf36:	4b25      	ldr	r3, [pc, #148]	; (bfcc <_flash_erase+0xa4>)
{
    bf38:	4607      	mov	r7, r0
    bf3a:	4615      	mov	r5, r2
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    bf3c:	f024 041f 	bic.w	r4, r4, #31
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    bf40:	f44f 7200 	mov.w	r2, #512	; 0x200
    bf44:	21ff      	movs	r1, #255	; 0xff
    bf46:	4668      	mov	r0, sp
    bf48:	4798      	blx	r3
	if (dst_addr != block_start_addr) {
    bf4a:	42a6      	cmp	r6, r4
    bf4c:	d11e      	bne.n	bf8c <_flash_erase+0x64>
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    bf4e:	4622      	mov	r2, r4
    bf50:	462b      	mov	r3, r5
    bf52:	f24a 5001 	movw	r0, #42241	; 0xa501
	while (page_nums >= NVMCTRL_BLOCK_PAGES) {
    bf56:	2b0f      	cmp	r3, #15
    bf58:	d82e      	bhi.n	bfb8 <_flash_erase+0x90>
    bf5a:	0929      	lsrs	r1, r5, #4
    bf5c:	f06f 020f 	mvn.w	r2, #15
    bf60:	fb02 5501 	mla	r5, r2, r1, r5
    bf64:	eb04 3441 	add.w	r4, r4, r1, lsl #13
	if (page_nums != 0) {
    bf68:	b165      	cbz	r5, bf84 <_flash_erase+0x5c>
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    bf6a:	4e19      	ldr	r6, [pc, #100]	; (bfd0 <_flash_erase+0xa8>)
    bf6c:	eb04 2545 	add.w	r5, r4, r5, lsl #9
    bf70:	4621      	mov	r1, r4
    bf72:	f44f 7300 	mov.w	r3, #512	; 0x200
    bf76:	466a      	mov	r2, sp
    bf78:	4638      	mov	r0, r7
			block_start_addr += NVMCTRL_PAGE_SIZE;
    bf7a:	f504 7400 	add.w	r4, r4, #512	; 0x200
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    bf7e:	47b0      	blx	r6
		for (i = 0; i < page_nums; i++) {
    bf80:	42a5      	cmp	r5, r4
    bf82:	d1f5      	bne.n	bf70 <_flash_erase+0x48>
}
    bf84:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
    bf88:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    bf8c:	f504 5800 	add.w	r8, r4, #8192	; 0x2000
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    bf90:	f506 59f0 	add.w	r9, r6, #7680	; 0x1e00
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    bf94:	4634      	mov	r4, r6
			_flash_write(device, dst_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    bf96:	4e0e      	ldr	r6, [pc, #56]	; (bfd0 <_flash_erase+0xa8>)
    bf98:	f44f 7300 	mov.w	r3, #512	; 0x200
    bf9c:	466a      	mov	r2, sp
    bf9e:	4621      	mov	r1, r4
    bfa0:	4638      	mov	r0, r7
    bfa2:	47b0      	blx	r6
			if (--page_nums == 0) {
    bfa4:	3d01      	subs	r5, #1
    bfa6:	d0ed      	beq.n	bf84 <_flash_erase+0x5c>
			dst_addr += NVMCTRL_PAGE_SIZE;
    bfa8:	f504 7400 	add.w	r4, r4, #512	; 0x200
			if (dst_addr == block_start_addr) {
    bfac:	45a0      	cmp	r8, r4
    bfae:	d0ce      	beq.n	bf4e <_flash_erase+0x26>
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    bfb0:	45a1      	cmp	r9, r4
    bfb2:	d1f1      	bne.n	bf98 <_flash_erase+0x70>
    bfb4:	4644      	mov	r4, r8
    bfb6:	e7ca      	b.n	bf4e <_flash_erase+0x26>
		_flash_erase_block(device->hw, block_start_addr);
    bfb8:	6939      	ldr	r1, [r7, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    bfba:	8a4e      	ldrh	r6, [r1, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    bfbc:	07f6      	lsls	r6, r6, #31
    bfbe:	d5fc      	bpl.n	bfba <_flash_erase+0x92>
	((Nvmctrl *)hw)->ADDR.reg = data;
    bfc0:	614a      	str	r2, [r1, #20]
		page_nums -= NVMCTRL_BLOCK_PAGES;
    bfc2:	3b10      	subs	r3, #16
	((Nvmctrl *)hw)->CTRLB.reg = data;
    bfc4:	8088      	strh	r0, [r1, #4]
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    bfc6:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		page_nums -= NVMCTRL_BLOCK_PAGES;
    bfca:	e7c4      	b.n	bf56 <_flash_erase+0x2e>
    bfcc:	00014175 	.word	0x00014175
    bfd0:	0000be61 	.word	0x0000be61

0000bfd4 <_flash_is_locked>:
	return !(hri_nvmctrl_get_RUNLOCK_reg(device->hw, 1 << region_id));
    bfd4:	6903      	ldr	r3, [r0, #16]
    bfd6:	f3c1 31cf 	ubfx	r1, r1, #15, #16
	tmp = ((Nvmctrl *)hw)->RUNLOCK.reg;
    bfda:	699a      	ldr	r2, [r3, #24]
    bfdc:	2301      	movs	r3, #1
    bfde:	fa03 f101 	lsl.w	r1, r3, r1
    bfe2:	4211      	tst	r1, r2
}
    bfe4:	bf0c      	ite	eq
    bfe6:	4618      	moveq	r0, r3
    bfe8:	2000      	movne	r0, #0
    bfea:	4770      	bx	lr

0000bfec <NVMCTRL_0_Handler>:
/**
 * \internal NVM 0 interrupt handler
 */
void NVMCTRL_0_Handler(void)
{
	_nvm_interrupt_handler(_nvm_dev);
    bfec:	4b09      	ldr	r3, [pc, #36]	; (c014 <NVMCTRL_0_Handler+0x28>)
    bfee:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    bff0:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_DONE) >> NVMCTRL_INTFLAG_DONE_Pos;
    bff2:	8a1a      	ldrh	r2, [r3, #16]
	if (hri_nvmctrl_get_INTFLAG_DONE_bit(hw)) {
    bff4:	07d2      	lsls	r2, r2, #31
    bff6:	d504      	bpl.n	c002 <NVMCTRL_0_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_DONE;
    bff8:	2201      	movs	r2, #1
    bffa:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.ready_cb) {
    bffc:	6803      	ldr	r3, [r0, #0]
		if (NULL != device->flash_cb.error_cb) {
    bffe:	b143      	cbz	r3, c012 <NVMCTRL_0_Handler+0x26>
			device->flash_cb.error_cb(device);
    c000:	4718      	bx	r3
	return ((Nvmctrl *)hw)->INTFLAG.reg;
    c002:	8a1a      	ldrh	r2, [r3, #16]
    c004:	b292      	uxth	r2, r2
	} else if (hri_nvmctrl_read_INTFLAG_reg(hw) && ~NVMCTRL_INTFLAG_ERR) {
    c006:	b122      	cbz	r2, c012 <NVMCTRL_0_Handler+0x26>
	((Nvmctrl *)hw)->INTFLAG.reg = mask;
    c008:	f240 225e 	movw	r2, #606	; 0x25e
    c00c:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.error_cb) {
    c00e:	6843      	ldr	r3, [r0, #4]
    c010:	e7f5      	b.n	bffe <NVMCTRL_0_Handler+0x12>
}
    c012:	4770      	bx	lr
    c014:	2000119c 	.word	0x2000119c

0000c018 <NVMCTRL_1_Handler>:
    c018:	4b00      	ldr	r3, [pc, #0]	; (c01c <NVMCTRL_1_Handler+0x4>)
    c01a:	4718      	bx	r3
    c01c:	0000bfed 	.word	0x0000bfed

0000c020 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    c020:	b510      	push	{r4, lr}
    c022:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    c024:	4b04      	ldr	r3, [pc, #16]	; (c038 <prvIsQueueEmpty+0x18>)
    c026:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    c028:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    c02a:	4b04      	ldr	r3, [pc, #16]	; (c03c <prvIsQueueEmpty+0x1c>)
    c02c:	4798      	blx	r3

	return xReturn;
}
    c02e:	fab4 f084 	clz	r0, r4
    c032:	0940      	lsrs	r0, r0, #5
    c034:	bd10      	pop	{r4, pc}
    c036:	bf00      	nop
    c038:	0000b315 	.word	0x0000b315
    c03c:	0000b359 	.word	0x0000b359

0000c040 <prvCopyDataToQueue>:
{
    c040:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c042:	4615      	mov	r5, r2
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c044:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c046:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
    c048:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c04a:	b952      	cbnz	r2, c062 <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    c04c:	6807      	ldr	r7, [r0, #0]
    c04e:	bb3f      	cbnz	r7, c0a0 <prvCopyDataToQueue+0x60>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c050:	6840      	ldr	r0, [r0, #4]
    c052:	4b15      	ldr	r3, [pc, #84]	; (c0a8 <prvCopyDataToQueue+0x68>)
    c054:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    c056:	6067      	str	r7, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c058:	4605      	mov	r5, r0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    c05a:	3601      	adds	r6, #1
    c05c:	63a6      	str	r6, [r4, #56]	; 0x38
}
    c05e:	4628      	mov	r0, r5
    c060:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    c062:	4b12      	ldr	r3, [pc, #72]	; (c0ac <prvCopyDataToQueue+0x6c>)
    c064:	b95d      	cbnz	r5, c07e <prvCopyDataToQueue+0x3e>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    c066:	6880      	ldr	r0, [r0, #8]
    c068:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c06a:	68a3      	ldr	r3, [r4, #8]
    c06c:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c06e:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c070:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c072:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c074:	4293      	cmp	r3, r2
    c076:	d3f0      	bcc.n	c05a <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c078:	6823      	ldr	r3, [r4, #0]
    c07a:	60a3      	str	r3, [r4, #8]
    c07c:	e7ed      	b.n	c05a <prvCopyDataToQueue+0x1a>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    c07e:	68c0      	ldr	r0, [r0, #12]
    c080:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c082:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c084:	68e3      	ldr	r3, [r4, #12]
    c086:	4251      	negs	r1, r2
    c088:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
    c08a:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c08c:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
    c08e:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    c090:	bf3e      	ittt	cc
    c092:	6863      	ldrcc	r3, [r4, #4]
    c094:	185b      	addcc	r3, r3, r1
    c096:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    c098:	2d02      	cmp	r5, #2
    c09a:	d101      	bne.n	c0a0 <prvCopyDataToQueue+0x60>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c09c:	b116      	cbz	r6, c0a4 <prvCopyDataToQueue+0x64>
				--uxMessagesWaiting;
    c09e:	3e01      	subs	r6, #1
	BaseType_t  xReturn = pdFALSE;
    c0a0:	2500      	movs	r5, #0
    c0a2:	e7da      	b.n	c05a <prvCopyDataToQueue+0x1a>
    c0a4:	4635      	mov	r5, r6
    c0a6:	e7d8      	b.n	c05a <prvCopyDataToQueue+0x1a>
    c0a8:	000129a9 	.word	0x000129a9
    c0ac:	00014041 	.word	0x00014041

0000c0b0 <prvCopyDataFromQueue>:
{
    c0b0:	4603      	mov	r3, r0
    c0b2:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c0b4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    c0b6:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c0b8:	b16a      	cbz	r2, c0d6 <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c0ba:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c0bc:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c0be:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c0c0:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c0c2:	bf28      	it	cs
    c0c4:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c0c6:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c0c8:	bf28      	it	cs
    c0ca:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
    c0cc:	68d9      	ldr	r1, [r3, #12]
}
    c0ce:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
    c0d2:	4b02      	ldr	r3, [pc, #8]	; (c0dc <prvCopyDataFromQueue+0x2c>)
    c0d4:	4718      	bx	r3
}
    c0d6:	f85d 4b04 	ldr.w	r4, [sp], #4
    c0da:	4770      	bx	lr
    c0dc:	00014041 	.word	0x00014041

0000c0e0 <prvNotifyQueueSetContainer.part.0>:
    c0e0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c0e4:	f383 8811 	msr	BASEPRI, r3
    c0e8:	f3bf 8f6f 	isb	sy
    c0ec:	f3bf 8f4f 	dsb	sy
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    c0f0:	e7fe      	b.n	c0f0 <prvNotifyQueueSetContainer.part.0+0x10>
	...

0000c0f4 <prvNotifyQueueSetContainer>:
{
    c0f4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    c0f6:	6c84      	ldr	r4, [r0, #72]	; 0x48
{
    c0f8:	9001      	str	r0, [sp, #4]
    c0fa:	460a      	mov	r2, r1
	configASSERT(pxQueueSetContainer);
    c0fc:	b90c      	cbnz	r4, c102 <prvNotifyQueueSetContainer+0xe>
    c0fe:	4b17      	ldr	r3, [pc, #92]	; (c15c <prvNotifyQueueSetContainer+0x68>)
    c100:	4798      	blx	r3
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    c102:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c104:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c106:	4299      	cmp	r1, r3
    c108:	d308      	bcc.n	c11c <prvNotifyQueueSetContainer+0x28>
    c10a:	f04f 0380 	mov.w	r3, #128	; 0x80
    c10e:	f383 8811 	msr	BASEPRI, r3
    c112:	f3bf 8f6f 	isb	sy
    c116:	f3bf 8f4f 	dsb	sy
    c11a:	e7fe      	b.n	c11a <prvNotifyQueueSetContainer+0x26>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    c11c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c11e:	428b      	cmp	r3, r1
    c120:	d91a      	bls.n	c158 <prvNotifyQueueSetContainer+0x64>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c122:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c126:	4b0e      	ldr	r3, [pc, #56]	; (c160 <prvNotifyQueueSetContainer+0x6c>)
    c128:	a901      	add	r1, sp, #4
    c12a:	4620      	mov	r0, r4
    c12c:	4798      	blx	r3
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c12e:	b26d      	sxtb	r5, r5

		if (cTxLock == queueUNLOCKED) {
    c130:	1c6b      	adds	r3, r5, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c132:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
    c134:	d10b      	bne.n	c14e <prvNotifyQueueSetContainer+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    c136:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c138:	b133      	cbz	r3, c148 <prvNotifyQueueSetContainer+0x54>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    c13a:	4b0a      	ldr	r3, [pc, #40]	; (c164 <prvNotifyQueueSetContainer+0x70>)
    c13c:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c140:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
    c142:	2800      	cmp	r0, #0
    c144:	bf18      	it	ne
    c146:	2601      	movne	r6, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    c148:	4630      	mov	r0, r6
    c14a:	b002      	add	sp, #8
    c14c:	bd70      	pop	{r4, r5, r6, pc}
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    c14e:	3501      	adds	r5, #1
    c150:	b26d      	sxtb	r5, r5
    c152:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c156:	e7f7      	b.n	c148 <prvNotifyQueueSetContainer+0x54>
	BaseType_t xReturn             = pdFALSE;
    c158:	2600      	movs	r6, #0
	return xReturn;
    c15a:	e7f5      	b.n	c148 <prvNotifyQueueSetContainer+0x54>
    c15c:	0000c0e1 	.word	0x0000c0e1
    c160:	0000c041 	.word	0x0000c041
    c164:	00012861 	.word	0x00012861

0000c168 <prvUnlockQueue>:
{
    c168:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c16c:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    c16e:	4f1f      	ldr	r7, [pc, #124]	; (c1ec <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c170:	4e1f      	ldr	r6, [pc, #124]	; (c1f0 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
    c172:	f8df 8084 	ldr.w	r8, [pc, #132]	; c1f8 <prvUnlockQueue+0x90>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c176:	f8df 9084 	ldr.w	r9, [pc, #132]	; c1fc <prvUnlockQueue+0x94>
	taskENTER_CRITICAL();
    c17a:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
    c17c:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c180:	b26d      	sxtb	r5, r5
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    c182:	2d00      	cmp	r5, #0
    c184:	dc17      	bgt.n	c1b6 <prvUnlockQueue+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
    c186:	23ff      	movs	r3, #255	; 0xff
    c188:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c18c:	4e19      	ldr	r6, [pc, #100]	; (c1f4 <prvUnlockQueue+0x8c>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c18e:	f8df 8060 	ldr.w	r8, [pc, #96]	; c1f0 <prvUnlockQueue+0x88>
					vTaskMissedYield();
    c192:	f8df 9064 	ldr.w	r9, [pc, #100]	; c1f8 <prvUnlockQueue+0x90>
	taskEXIT_CRITICAL();
    c196:	47b0      	blx	r6
	taskENTER_CRITICAL();
    c198:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
    c19a:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c19e:	f104 0710 	add.w	r7, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
    c1a2:	b26d      	sxtb	r5, r5
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    c1a4:	2d00      	cmp	r5, #0
    c1a6:	dc17      	bgt.n	c1d8 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
    c1a8:	23ff      	movs	r3, #255	; 0xff
    c1aa:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c1ae:	4633      	mov	r3, r6
}
    c1b0:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	taskEXIT_CRITICAL();
    c1b4:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
    c1b6:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c1b8:	b13b      	cbz	r3, c1ca <prvUnlockQueue+0x62>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c1ba:	2100      	movs	r1, #0
    c1bc:	4620      	mov	r0, r4
    c1be:	47c8      	blx	r9
    c1c0:	b100      	cbz	r0, c1c4 <prvUnlockQueue+0x5c>
						vTaskMissedYield();
    c1c2:	47c0      	blx	r8
			--cTxLock;
    c1c4:	3d01      	subs	r5, #1
    c1c6:	b26d      	sxtb	r5, r5
    c1c8:	e7db      	b.n	c182 <prvUnlockQueue+0x1a>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c1ca:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c1cc:	2b00      	cmp	r3, #0
    c1ce:	d0da      	beq.n	c186 <prvUnlockQueue+0x1e>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c1d0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c1d4:	47b0      	blx	r6
    c1d6:	e7f3      	b.n	c1c0 <prvUnlockQueue+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c1d8:	6923      	ldr	r3, [r4, #16]
    c1da:	2b00      	cmp	r3, #0
    c1dc:	d0e4      	beq.n	c1a8 <prvUnlockQueue+0x40>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c1de:	4638      	mov	r0, r7
    c1e0:	47c0      	blx	r8
    c1e2:	b100      	cbz	r0, c1e6 <prvUnlockQueue+0x7e>
					vTaskMissedYield();
    c1e4:	47c8      	blx	r9
				--cRxLock;
    c1e6:	3d01      	subs	r5, #1
    c1e8:	b26d      	sxtb	r5, r5
    c1ea:	e7db      	b.n	c1a4 <prvUnlockQueue+0x3c>
    c1ec:	0000b315 	.word	0x0000b315
    c1f0:	00012861 	.word	0x00012861
    c1f4:	0000b359 	.word	0x0000b359
    c1f8:	00012979 	.word	0x00012979
    c1fc:	0000c0f5 	.word	0x0000c0f5

0000c200 <xQueueGenericReset>:
{
    c200:	b538      	push	{r3, r4, r5, lr}
    c202:	460d      	mov	r5, r1
	configASSERT(pxQueue);
    c204:	4604      	mov	r4, r0
    c206:	b908      	cbnz	r0, c20c <xQueueGenericReset+0xc>
    c208:	4b18      	ldr	r3, [pc, #96]	; (c26c <xQueueGenericReset+0x6c>)
    c20a:	4798      	blx	r3
	taskENTER_CRITICAL();
    c20c:	4b18      	ldr	r3, [pc, #96]	; (c270 <xQueueGenericReset+0x70>)
    c20e:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c210:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    c214:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    c216:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c218:	434b      	muls	r3, r1
    c21a:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c21c:	1a5b      	subs	r3, r3, r1
    c21e:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c220:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c222:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c224:	2000      	movs	r0, #0
		pxQueue->cRxLock           = queueUNLOCKED;
    c226:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c228:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock           = queueUNLOCKED;
    c22a:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
    c22e:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
    c232:	b995      	cbnz	r5, c25a <xQueueGenericReset+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c234:	6923      	ldr	r3, [r4, #16]
    c236:	b163      	cbz	r3, c252 <xQueueGenericReset+0x52>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c238:	4b0e      	ldr	r3, [pc, #56]	; (c274 <xQueueGenericReset+0x74>)
    c23a:	f104 0010 	add.w	r0, r4, #16
    c23e:	4798      	blx	r3
    c240:	b138      	cbz	r0, c252 <xQueueGenericReset+0x52>
					queueYIELD_IF_USING_PREEMPTION();
    c242:	4b0d      	ldr	r3, [pc, #52]	; (c278 <xQueueGenericReset+0x78>)
    c244:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c248:	601a      	str	r2, [r3, #0]
    c24a:	f3bf 8f4f 	dsb	sy
    c24e:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
    c252:	4b0a      	ldr	r3, [pc, #40]	; (c27c <xQueueGenericReset+0x7c>)
    c254:	4798      	blx	r3
}
    c256:	2001      	movs	r0, #1
    c258:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    c25a:	f104 0010 	add.w	r0, r4, #16
    c25e:	4d08      	ldr	r5, [pc, #32]	; (c280 <xQueueGenericReset+0x80>)
    c260:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    c262:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c266:	47a8      	blx	r5
    c268:	e7f3      	b.n	c252 <xQueueGenericReset+0x52>
    c26a:	bf00      	nop
    c26c:	0000c0e1 	.word	0x0000c0e1
    c270:	0000b315 	.word	0x0000b315
    c274:	00012861 	.word	0x00012861
    c278:	e000ed04 	.word	0xe000ed04
    c27c:	0000b359 	.word	0x0000b359
    c280:	0000b14d 	.word	0x0000b14d

0000c284 <xQueueGenericCreate>:
{
    c284:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c286:	460d      	mov	r5, r1
    c288:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    c28a:	4606      	mov	r6, r0
    c28c:	b940      	cbnz	r0, c2a0 <xQueueGenericCreate+0x1c>
    c28e:	f04f 0380 	mov.w	r3, #128	; 0x80
    c292:	f383 8811 	msr	BASEPRI, r3
    c296:	f3bf 8f6f 	isb	sy
    c29a:	f3bf 8f4f 	dsb	sy
    c29e:	e7fe      	b.n	c29e <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = (size_t)(
    c2a0:	4348      	muls	r0, r1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    c2a2:	4b0b      	ldr	r3, [pc, #44]	; (c2d0 <xQueueGenericCreate+0x4c>)
    c2a4:	3054      	adds	r0, #84	; 0x54
    c2a6:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    c2a8:	4604      	mov	r4, r0
    c2aa:	b168      	cbz	r0, c2c8 <xQueueGenericCreate+0x44>
	if (uxItemSize == (UBaseType_t)0) {
    c2ac:	b175      	cbz	r5, c2cc <xQueueGenericCreate+0x48>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    c2ae:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    c2b2:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
    c2b4:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    c2b8:	4b06      	ldr	r3, [pc, #24]	; (c2d4 <xQueueGenericCreate+0x50>)
    c2ba:	2101      	movs	r1, #1
    c2bc:	4620      	mov	r0, r4
    c2be:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
    c2c0:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
    c2c2:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    c2c6:	64a3      	str	r3, [r4, #72]	; 0x48
}
    c2c8:	4620      	mov	r0, r4
    c2ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c2cc:	4603      	mov	r3, r0
    c2ce:	e7f0      	b.n	c2b2 <xQueueGenericCreate+0x2e>
    c2d0:	0000b1d1 	.word	0x0000b1d1
    c2d4:	0000c201 	.word	0x0000c201

0000c2d8 <xQueueGenericSend>:
{
    c2d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c2dc:	b085      	sub	sp, #20
    c2de:	460e      	mov	r6, r1
    c2e0:	9201      	str	r2, [sp, #4]
    c2e2:	461c      	mov	r4, r3
	configASSERT(pxQueue);
    c2e4:	4683      	mov	fp, r0
    c2e6:	b940      	cbnz	r0, c2fa <xQueueGenericSend+0x22>
    c2e8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c2ec:	f383 8811 	msr	BASEPRI, r3
    c2f0:	f3bf 8f6f 	isb	sy
    c2f4:	f3bf 8f4f 	dsb	sy
    c2f8:	e7fe      	b.n	c2f8 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c2fa:	b951      	cbnz	r1, c312 <xQueueGenericSend+0x3a>
    c2fc:	6c02      	ldr	r2, [r0, #64]	; 0x40
    c2fe:	b142      	cbz	r2, c312 <xQueueGenericSend+0x3a>
    c300:	f04f 0380 	mov.w	r3, #128	; 0x80
    c304:	f383 8811 	msr	BASEPRI, r3
    c308:	f3bf 8f6f 	isb	sy
    c30c:	f3bf 8f4f 	dsb	sy
    c310:	e7fe      	b.n	c310 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c312:	2c02      	cmp	r4, #2
    c314:	d10c      	bne.n	c330 <xQueueGenericSend+0x58>
    c316:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c31a:	2a01      	cmp	r2, #1
    c31c:	d008      	beq.n	c330 <xQueueGenericSend+0x58>
    c31e:	f04f 0380 	mov.w	r3, #128	; 0x80
    c322:	f383 8811 	msr	BASEPRI, r3
    c326:	f3bf 8f6f 	isb	sy
    c32a:	f3bf 8f4f 	dsb	sy
    c32e:	e7fe      	b.n	c32e <xQueueGenericSend+0x56>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c330:	4a47      	ldr	r2, [pc, #284]	; (c450 <xQueueGenericSend+0x178>)
    c332:	4790      	blx	r2
    c334:	4680      	mov	r8, r0
    c336:	b950      	cbnz	r0, c34e <xQueueGenericSend+0x76>
    c338:	9a01      	ldr	r2, [sp, #4]
    c33a:	b152      	cbz	r2, c352 <xQueueGenericSend+0x7a>
    c33c:	f04f 0380 	mov.w	r3, #128	; 0x80
    c340:	f383 8811 	msr	BASEPRI, r3
    c344:	f3bf 8f6f 	isb	sy
    c348:	f3bf 8f4f 	dsb	sy
    c34c:	e7fe      	b.n	c34c <xQueueGenericSend+0x74>
    c34e:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
    c352:	f8df 9128 	ldr.w	r9, [pc, #296]	; c47c <xQueueGenericSend+0x1a4>
    c356:	46ca      	mov	sl, r9
    c358:	e042      	b.n	c3e0 <xQueueGenericSend+0x108>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c35a:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    c35e:	2a00      	cmp	r2, #0
    c360:	d055      	beq.n	c40e <xQueueGenericSend+0x136>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c362:	4b3c      	ldr	r3, [pc, #240]	; (c454 <xQueueGenericSend+0x17c>)
    c364:	f10b 0024 	add.w	r0, fp, #36	; 0x24
    c368:	4798      	blx	r3
    c36a:	e050      	b.n	c40e <xQueueGenericSend+0x136>
				if (xTicksToWait == (TickType_t)0) {
    c36c:	9f01      	ldr	r7, [sp, #4]
    c36e:	b917      	cbnz	r7, c376 <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
    c370:	47a8      	blx	r5
			return errQUEUE_FULL;
    c372:	2000      	movs	r0, #0
    c374:	e056      	b.n	c424 <xQueueGenericSend+0x14c>
				} else if (xEntryTimeSet == pdFALSE) {
    c376:	f1b8 0f00 	cmp.w	r8, #0
    c37a:	d102      	bne.n	c382 <xQueueGenericSend+0xaa>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c37c:	4a36      	ldr	r2, [pc, #216]	; (c458 <xQueueGenericSend+0x180>)
    c37e:	a802      	add	r0, sp, #8
    c380:	4790      	blx	r2
		taskEXIT_CRITICAL();
    c382:	47a8      	blx	r5
		vTaskSuspendAll();
    c384:	4a35      	ldr	r2, [pc, #212]	; (c45c <xQueueGenericSend+0x184>)
    c386:	f8df 80f8 	ldr.w	r8, [pc, #248]	; c480 <xQueueGenericSend+0x1a8>
    c38a:	4f35      	ldr	r7, [pc, #212]	; (c460 <xQueueGenericSend+0x188>)
    c38c:	4790      	blx	r2
		prvLockQueue(pxQueue);
    c38e:	47d0      	blx	sl
    c390:	f89b 2044 	ldrb.w	r2, [fp, #68]	; 0x44
    c394:	2aff      	cmp	r2, #255	; 0xff
    c396:	bf04      	itt	eq
    c398:	2200      	moveq	r2, #0
    c39a:	f88b 2044 	strbeq.w	r2, [fp, #68]	; 0x44
    c39e:	f89b 2045 	ldrb.w	r2, [fp, #69]	; 0x45
    c3a2:	2aff      	cmp	r2, #255	; 0xff
    c3a4:	bf04      	itt	eq
    c3a6:	2200      	moveq	r2, #0
    c3a8:	f88b 2045 	strbeq.w	r2, [fp, #69]	; 0x45
    c3ac:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c3ae:	4a2d      	ldr	r2, [pc, #180]	; (c464 <xQueueGenericSend+0x18c>)
    c3b0:	a901      	add	r1, sp, #4
    c3b2:	a802      	add	r0, sp, #8
    c3b4:	4790      	blx	r2
    c3b6:	2800      	cmp	r0, #0
    c3b8:	d145      	bne.n	c446 <xQueueGenericSend+0x16e>
	taskENTER_CRITICAL();
    c3ba:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    c3bc:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c3c0:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c3c4:	4291      	cmp	r1, r2
    c3c6:	d130      	bne.n	c42a <xQueueGenericSend+0x152>
	taskEXIT_CRITICAL();
    c3c8:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    c3ca:	9901      	ldr	r1, [sp, #4]
    c3cc:	4a26      	ldr	r2, [pc, #152]	; (c468 <xQueueGenericSend+0x190>)
    c3ce:	f10b 0010 	add.w	r0, fp, #16
    c3d2:	4790      	blx	r2
				prvUnlockQueue(pxQueue);
    c3d4:	4658      	mov	r0, fp
    c3d6:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
    c3d8:	47b8      	blx	r7
    c3da:	b358      	cbz	r0, c434 <xQueueGenericSend+0x15c>
    c3dc:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
    c3e0:	47c8      	blx	r9
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c3e2:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c3e6:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c3ea:	4d20      	ldr	r5, [pc, #128]	; (c46c <xQueueGenericSend+0x194>)
    c3ec:	4291      	cmp	r1, r2
    c3ee:	d301      	bcc.n	c3f4 <xQueueGenericSend+0x11c>
    c3f0:	2c02      	cmp	r4, #2
    c3f2:	d1bb      	bne.n	c36c <xQueueGenericSend+0x94>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c3f4:	4622      	mov	r2, r4
    c3f6:	4631      	mov	r1, r6
    c3f8:	4658      	mov	r0, fp
    c3fa:	4e1d      	ldr	r6, [pc, #116]	; (c470 <xQueueGenericSend+0x198>)
    c3fc:	47b0      	blx	r6
					if (pxQueue->pxQueueSetContainer != NULL) {
    c3fe:	f8db 2048 	ldr.w	r2, [fp, #72]	; 0x48
    c402:	2a00      	cmp	r2, #0
    c404:	d0a9      	beq.n	c35a <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c406:	4b1b      	ldr	r3, [pc, #108]	; (c474 <xQueueGenericSend+0x19c>)
    c408:	4621      	mov	r1, r4
    c40a:	4658      	mov	r0, fp
    c40c:	4798      	blx	r3
						} else if (xYieldRequired != pdFALSE) {
    c40e:	b138      	cbz	r0, c420 <xQueueGenericSend+0x148>
							queueYIELD_IF_USING_PREEMPTION();
    c410:	4b19      	ldr	r3, [pc, #100]	; (c478 <xQueueGenericSend+0x1a0>)
    c412:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c416:	601a      	str	r2, [r3, #0]
    c418:	f3bf 8f4f 	dsb	sy
    c41c:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c420:	47a8      	blx	r5
				return pdPASS;
    c422:	2001      	movs	r0, #1
}
    c424:	b005      	add	sp, #20
    c426:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    c42a:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
    c42c:	4658      	mov	r0, fp
    c42e:	47c0      	blx	r8
				(void)xTaskResumeAll();
    c430:	47b8      	blx	r7
    c432:	e7d3      	b.n	c3dc <xQueueGenericSend+0x104>
					portYIELD_WITHIN_API();
    c434:	4b10      	ldr	r3, [pc, #64]	; (c478 <xQueueGenericSend+0x1a0>)
    c436:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c43a:	601a      	str	r2, [r3, #0]
    c43c:	f3bf 8f4f 	dsb	sy
    c440:	f3bf 8f6f 	isb	sy
    c444:	e7ca      	b.n	c3dc <xQueueGenericSend+0x104>
			prvUnlockQueue(pxQueue);
    c446:	4658      	mov	r0, fp
    c448:	47c0      	blx	r8
			(void)xTaskResumeAll();
    c44a:	47b8      	blx	r7
    c44c:	e791      	b.n	c372 <xQueueGenericSend+0x9a>
    c44e:	bf00      	nop
    c450:	00012989 	.word	0x00012989
    c454:	00012861 	.word	0x00012861
    c458:	000128e1 	.word	0x000128e1
    c45c:	00012505 	.word	0x00012505
    c460:	00012629 	.word	0x00012629
    c464:	000128f5 	.word	0x000128f5
    c468:	000127dd 	.word	0x000127dd
    c46c:	0000b359 	.word	0x0000b359
    c470:	0000c041 	.word	0x0000c041
    c474:	0000c0f5 	.word	0x0000c0f5
    c478:	e000ed04 	.word	0xe000ed04
    c47c:	0000b315 	.word	0x0000b315
    c480:	0000c169 	.word	0x0000c169

0000c484 <xQueueGenericSendFromISR>:
{
    c484:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c488:	4689      	mov	r9, r1
    c48a:	4690      	mov	r8, r2
    c48c:	461f      	mov	r7, r3
	configASSERT(pxQueue);
    c48e:	4604      	mov	r4, r0
    c490:	b940      	cbnz	r0, c4a4 <xQueueGenericSendFromISR+0x20>
    c492:	f04f 0380 	mov.w	r3, #128	; 0x80
    c496:	f383 8811 	msr	BASEPRI, r3
    c49a:	f3bf 8f6f 	isb	sy
    c49e:	f3bf 8f4f 	dsb	sy
    c4a2:	e7fe      	b.n	c4a2 <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c4a4:	b951      	cbnz	r1, c4bc <xQueueGenericSendFromISR+0x38>
    c4a6:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c4a8:	b143      	cbz	r3, c4bc <xQueueGenericSendFromISR+0x38>
    c4aa:	f04f 0380 	mov.w	r3, #128	; 0x80
    c4ae:	f383 8811 	msr	BASEPRI, r3
    c4b2:	f3bf 8f6f 	isb	sy
    c4b6:	f3bf 8f4f 	dsb	sy
    c4ba:	e7fe      	b.n	c4ba <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c4bc:	2f02      	cmp	r7, #2
    c4be:	d10b      	bne.n	c4d8 <xQueueGenericSendFromISR+0x54>
    c4c0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c4c2:	2b01      	cmp	r3, #1
    c4c4:	d008      	beq.n	c4d8 <xQueueGenericSendFromISR+0x54>
    c4c6:	f04f 0380 	mov.w	r3, #128	; 0x80
    c4ca:	f383 8811 	msr	BASEPRI, r3
    c4ce:	f3bf 8f6f 	isb	sy
    c4d2:	f3bf 8f4f 	dsb	sy
    c4d6:	e7fe      	b.n	c4d6 <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    c4d8:	4b1e      	ldr	r3, [pc, #120]	; (c554 <xQueueGenericSendFromISR+0xd0>)
    c4da:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    c4dc:	f3ef 8611 	mrs	r6, BASEPRI
    c4e0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c4e4:	f383 8811 	msr	BASEPRI, r3
    c4e8:	f3bf 8f6f 	isb	sy
    c4ec:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c4f0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c4f2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c4f4:	429a      	cmp	r2, r3
    c4f6:	d301      	bcc.n	c4fc <xQueueGenericSendFromISR+0x78>
    c4f8:	2f02      	cmp	r7, #2
    c4fa:	d129      	bne.n	c550 <xQueueGenericSendFromISR+0xcc>
			const int8_t cTxLock = pxQueue->cTxLock;
    c4fc:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c500:	4b15      	ldr	r3, [pc, #84]	; (c558 <xQueueGenericSendFromISR+0xd4>)
			const int8_t cTxLock = pxQueue->cTxLock;
    c502:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c504:	463a      	mov	r2, r7
    c506:	4649      	mov	r1, r9
    c508:	4620      	mov	r0, r4
    c50a:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    c50c:	1c6b      	adds	r3, r5, #1
    c50e:	d11a      	bne.n	c546 <xQueueGenericSendFromISR+0xc2>
					if (pxQueue->pxQueueSetContainer != NULL) {
    c510:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c512:	b183      	cbz	r3, c536 <xQueueGenericSendFromISR+0xb2>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c514:	4b11      	ldr	r3, [pc, #68]	; (c55c <xQueueGenericSendFromISR+0xd8>)
    c516:	4639      	mov	r1, r7
    c518:	4620      	mov	r0, r4
    c51a:	4798      	blx	r3
    c51c:	b908      	cbnz	r0, c522 <xQueueGenericSendFromISR+0x9e>
			xReturn = pdPASS;
    c51e:	2001      	movs	r0, #1
    c520:	e005      	b.n	c52e <xQueueGenericSendFromISR+0xaa>
							if (pxHigherPriorityTaskWoken != NULL) {
    c522:	f1b8 0f00 	cmp.w	r8, #0
    c526:	d0fa      	beq.n	c51e <xQueueGenericSendFromISR+0x9a>
								*pxHigherPriorityTaskWoken = pdTRUE;
    c528:	2001      	movs	r0, #1
    c52a:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    c52e:	f386 8811 	msr	BASEPRI, r6
}
    c532:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c536:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c538:	2b00      	cmp	r3, #0
    c53a:	d0f0      	beq.n	c51e <xQueueGenericSendFromISR+0x9a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c53c:	4b08      	ldr	r3, [pc, #32]	; (c560 <xQueueGenericSendFromISR+0xdc>)
    c53e:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c542:	4798      	blx	r3
    c544:	e7ea      	b.n	c51c <xQueueGenericSendFromISR+0x98>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    c546:	3501      	adds	r5, #1
    c548:	b26d      	sxtb	r5, r5
    c54a:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c54e:	e7e6      	b.n	c51e <xQueueGenericSendFromISR+0x9a>
			xReturn = errQUEUE_FULL;
    c550:	2000      	movs	r0, #0
    c552:	e7ec      	b.n	c52e <xQueueGenericSendFromISR+0xaa>
    c554:	0000b551 	.word	0x0000b551
    c558:	0000c041 	.word	0x0000c041
    c55c:	0000c0f5 	.word	0x0000c0f5
    c560:	00012861 	.word	0x00012861

0000c564 <xQueueReceive>:
{
    c564:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c568:	b085      	sub	sp, #20
    c56a:	460f      	mov	r7, r1
    c56c:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    c56e:	4604      	mov	r4, r0
    c570:	b940      	cbnz	r0, c584 <xQueueReceive+0x20>
	__asm volatile("	mov %0, %1												\n"
    c572:	f04f 0380 	mov.w	r3, #128	; 0x80
    c576:	f383 8811 	msr	BASEPRI, r3
    c57a:	f3bf 8f6f 	isb	sy
    c57e:	f3bf 8f4f 	dsb	sy
    c582:	e7fe      	b.n	c582 <xQueueReceive+0x1e>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    c584:	b951      	cbnz	r1, c59c <xQueueReceive+0x38>
    c586:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c588:	b143      	cbz	r3, c59c <xQueueReceive+0x38>
    c58a:	f04f 0380 	mov.w	r3, #128	; 0x80
    c58e:	f383 8811 	msr	BASEPRI, r3
    c592:	f3bf 8f6f 	isb	sy
    c596:	f3bf 8f4f 	dsb	sy
    c59a:	e7fe      	b.n	c59a <xQueueReceive+0x36>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c59c:	4b3e      	ldr	r3, [pc, #248]	; (c698 <xQueueReceive+0x134>)
    c59e:	4798      	blx	r3
    c5a0:	4606      	mov	r6, r0
    c5a2:	b950      	cbnz	r0, c5ba <xQueueReceive+0x56>
    c5a4:	9b01      	ldr	r3, [sp, #4]
    c5a6:	b14b      	cbz	r3, c5bc <xQueueReceive+0x58>
    c5a8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5ac:	f383 8811 	msr	BASEPRI, r3
    c5b0:	f3bf 8f6f 	isb	sy
    c5b4:	f3bf 8f4f 	dsb	sy
    c5b8:	e7fe      	b.n	c5b8 <xQueueReceive+0x54>
    c5ba:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    c5bc:	f8df 9100 	ldr.w	r9, [pc, #256]	; c6c0 <xQueueReceive+0x15c>
					portYIELD_WITHIN_API();
    c5c0:	f8df b0f8 	ldr.w	fp, [pc, #248]	; c6bc <xQueueReceive+0x158>
    c5c4:	46ca      	mov	sl, r9
    c5c6:	e03b      	b.n	c640 <xQueueReceive+0xdc>
				if (xTicksToWait == (TickType_t)0) {
    c5c8:	9d01      	ldr	r5, [sp, #4]
    c5ca:	b915      	cbnz	r5, c5d2 <xQueueReceive+0x6e>
					taskEXIT_CRITICAL();
    c5cc:	47c0      	blx	r8
				return errQUEUE_EMPTY;
    c5ce:	2000      	movs	r0, #0
    c5d0:	e053      	b.n	c67a <xQueueReceive+0x116>
				} else if (xEntryTimeSet == pdFALSE) {
    c5d2:	b916      	cbnz	r6, c5da <xQueueReceive+0x76>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c5d4:	4b31      	ldr	r3, [pc, #196]	; (c69c <xQueueReceive+0x138>)
    c5d6:	a802      	add	r0, sp, #8
    c5d8:	4798      	blx	r3
		taskEXIT_CRITICAL();
    c5da:	47c0      	blx	r8
		vTaskSuspendAll();
    c5dc:	4b30      	ldr	r3, [pc, #192]	; (c6a0 <xQueueReceive+0x13c>)
    c5de:	4e31      	ldr	r6, [pc, #196]	; (c6a4 <xQueueReceive+0x140>)
    c5e0:	4d31      	ldr	r5, [pc, #196]	; (c6a8 <xQueueReceive+0x144>)
    c5e2:	4798      	blx	r3
		prvLockQueue(pxQueue);
    c5e4:	47d0      	blx	sl
    c5e6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c5ea:	2bff      	cmp	r3, #255	; 0xff
    c5ec:	bf04      	itt	eq
    c5ee:	2300      	moveq	r3, #0
    c5f0:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    c5f4:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c5f8:	2bff      	cmp	r3, #255	; 0xff
    c5fa:	bf04      	itt	eq
    c5fc:	2300      	moveq	r3, #0
    c5fe:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    c602:	47c0      	blx	r8
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c604:	4b29      	ldr	r3, [pc, #164]	; (c6ac <xQueueReceive+0x148>)
    c606:	f8df 80bc 	ldr.w	r8, [pc, #188]	; c6c4 <xQueueReceive+0x160>
    c60a:	a901      	add	r1, sp, #4
    c60c:	a802      	add	r0, sp, #8
    c60e:	4798      	blx	r3
    c610:	2800      	cmp	r0, #0
    c612:	d139      	bne.n	c688 <xQueueReceive+0x124>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    c614:	4620      	mov	r0, r4
    c616:	47c0      	blx	r8
    c618:	2800      	cmp	r0, #0
    c61a:	d031      	beq.n	c680 <xQueueReceive+0x11c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    c61c:	9901      	ldr	r1, [sp, #4]
    c61e:	4b24      	ldr	r3, [pc, #144]	; (c6b0 <xQueueReceive+0x14c>)
    c620:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c624:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    c626:	4620      	mov	r0, r4
    c628:	47b0      	blx	r6
				if (xTaskResumeAll() == pdFALSE) {
    c62a:	47a8      	blx	r5
    c62c:	b938      	cbnz	r0, c63e <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
    c62e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    c632:	f8cb 3000 	str.w	r3, [fp]
    c636:	f3bf 8f4f 	dsb	sy
    c63a:	f3bf 8f6f 	isb	sy
    c63e:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    c640:	47c8      	blx	r9
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c642:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c644:	f8df 8080 	ldr.w	r8, [pc, #128]	; c6c8 <xQueueReceive+0x164>
    c648:	2d00      	cmp	r5, #0
    c64a:	d0bd      	beq.n	c5c8 <xQueueReceive+0x64>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    c64c:	4b19      	ldr	r3, [pc, #100]	; (c6b4 <xQueueReceive+0x150>)
    c64e:	4639      	mov	r1, r7
    c650:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    c652:	3d01      	subs	r5, #1
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    c654:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    c656:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c658:	6923      	ldr	r3, [r4, #16]
    c65a:	b163      	cbz	r3, c676 <xQueueReceive+0x112>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c65c:	4b16      	ldr	r3, [pc, #88]	; (c6b8 <xQueueReceive+0x154>)
    c65e:	f104 0010 	add.w	r0, r4, #16
    c662:	4798      	blx	r3
    c664:	b138      	cbz	r0, c676 <xQueueReceive+0x112>
						queueYIELD_IF_USING_PREEMPTION();
    c666:	4b15      	ldr	r3, [pc, #84]	; (c6bc <xQueueReceive+0x158>)
    c668:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c66c:	601a      	str	r2, [r3, #0]
    c66e:	f3bf 8f4f 	dsb	sy
    c672:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c676:	47c0      	blx	r8
				return pdPASS;
    c678:	2001      	movs	r0, #1
}
    c67a:	b005      	add	sp, #20
    c67c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				prvUnlockQueue(pxQueue);
    c680:	4620      	mov	r0, r4
    c682:	47b0      	blx	r6
				(void)xTaskResumeAll();
    c684:	47a8      	blx	r5
    c686:	e7da      	b.n	c63e <xQueueReceive+0xda>
			prvUnlockQueue(pxQueue);
    c688:	4620      	mov	r0, r4
    c68a:	47b0      	blx	r6
			(void)xTaskResumeAll();
    c68c:	47a8      	blx	r5
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    c68e:	4620      	mov	r0, r4
    c690:	47c0      	blx	r8
    c692:	2800      	cmp	r0, #0
    c694:	d0d3      	beq.n	c63e <xQueueReceive+0xda>
    c696:	e79a      	b.n	c5ce <xQueueReceive+0x6a>
    c698:	00012989 	.word	0x00012989
    c69c:	000128e1 	.word	0x000128e1
    c6a0:	00012505 	.word	0x00012505
    c6a4:	0000c169 	.word	0x0000c169
    c6a8:	00012629 	.word	0x00012629
    c6ac:	000128f5 	.word	0x000128f5
    c6b0:	000127dd 	.word	0x000127dd
    c6b4:	0000c0b1 	.word	0x0000c0b1
    c6b8:	00012861 	.word	0x00012861
    c6bc:	e000ed04 	.word	0xe000ed04
    c6c0:	0000b315 	.word	0x0000b315
    c6c4:	0000c021 	.word	0x0000c021
    c6c8:	0000b359 	.word	0x0000b359

0000c6cc <vQueueWaitForMessageRestricted>:
{
    c6cc:	b570      	push	{r4, r5, r6, lr}
    c6ce:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
    c6d0:	4b10      	ldr	r3, [pc, #64]	; (c714 <vQueueWaitForMessageRestricted+0x48>)
{
    c6d2:	460d      	mov	r5, r1
    c6d4:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    c6d6:	4798      	blx	r3
    c6d8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    c6dc:	2bff      	cmp	r3, #255	; 0xff
    c6de:	bf04      	itt	eq
    c6e0:	2300      	moveq	r3, #0
    c6e2:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    c6e6:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    c6ea:	2bff      	cmp	r3, #255	; 0xff
    c6ec:	bf04      	itt	eq
    c6ee:	2300      	moveq	r3, #0
    c6f0:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    c6f4:	4b08      	ldr	r3, [pc, #32]	; (c718 <vQueueWaitForMessageRestricted+0x4c>)
    c6f6:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    c6f8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    c6fa:	b92b      	cbnz	r3, c708 <vQueueWaitForMessageRestricted+0x3c>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    c6fc:	4b07      	ldr	r3, [pc, #28]	; (c71c <vQueueWaitForMessageRestricted+0x50>)
    c6fe:	4632      	mov	r2, r6
    c700:	4629      	mov	r1, r5
    c702:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c706:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
    c708:	4620      	mov	r0, r4
    c70a:	4b05      	ldr	r3, [pc, #20]	; (c720 <vQueueWaitForMessageRestricted+0x54>)
}
    c70c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
    c710:	4718      	bx	r3
    c712:	bf00      	nop
    c714:	0000b315 	.word	0x0000b315
    c718:	0000b359 	.word	0x0000b359
    c71c:	00012819 	.word	0x00012819
    c720:	0000c169 	.word	0x0000c169

0000c724 <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    c724:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CRITICAL_SECTION_ENTER();
    c726:	4b0e      	ldr	r3, [pc, #56]	; (c760 <gpio_get_pin_level+0x3c>)
    c728:	4605      	mov	r5, r0
    c72a:	a801      	add	r0, sp, #4
    c72c:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    c72e:	4a0d      	ldr	r2, [pc, #52]	; (c764 <gpio_get_pin_level+0x40>)
    c730:	096b      	lsrs	r3, r5, #5
    c732:	01d9      	lsls	r1, r3, #7
    c734:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    c738:	5851      	ldr	r1, [r2, r1]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    c73a:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    c73c:	691c      	ldr	r4, [r3, #16]
	CRITICAL_SECTION_LEAVE();
    c73e:	4b0a      	ldr	r3, [pc, #40]	; (c768 <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    c740:	4054      	eors	r4, r2
    c742:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    c744:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    c746:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    c748:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    c74c:	4798      	blx	r3
    c74e:	2001      	movs	r0, #1
    c750:	fa00 f505 	lsl.w	r5, r0, r5
    c754:	4225      	tst	r5, r4
}
    c756:	bf08      	it	eq
    c758:	2000      	moveq	r0, #0
    c75a:	b003      	add	sp, #12
    c75c:	bd30      	pop	{r4, r5, pc}
    c75e:	bf00      	nop
    c760:	00011a11 	.word	0x00011a11
    c764:	41008000 	.word	0x41008000
    c768:	00011a1f 	.word	0x00011a1f

0000c76c <hiddf_demo_sof_event>:
#endif /* CONF_USB_COMPOSITE_CDC_ECHO_DEMO */

#if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO
static uint32_t pin_btn1, pin_btn2, pin_btn3;
static void     hiddf_demo_sof_event(void)
{
    c76c:	b570      	push	{r4, r5, r6, lr}
        {HID_CAPS_LOCK, false, HID_KB_KEY_UP},
    };
	uint8_t b_btn_state;
#endif

	if (interval++ > 10) {
    c76e:	4a15      	ldr	r2, [pc, #84]	; (c7c4 <hiddf_demo_sof_event+0x58>)
    c770:	7913      	ldrb	r3, [r2, #4]
    c772:	2b0a      	cmp	r3, #10
    c774:	4614      	mov	r4, r2
    c776:	d802      	bhi.n	c77e <hiddf_demo_sof_event+0x12>
    c778:	3301      	adds	r3, #1
    c77a:	7113      	strb	r3, [r2, #4]
#endif
	}
	(void)pin_btn1;
	(void)pin_btn2;
	(void)pin_btn3;
}
    c77c:	bd70      	pop	{r4, r5, r6, pc}
		interval = 0;
    c77e:	2300      	movs	r3, #0
		if (!gpio_get_pin_level(pin_btn1)) {
    c780:	7a10      	ldrb	r0, [r2, #8]
    c782:	4d11      	ldr	r5, [pc, #68]	; (c7c8 <hiddf_demo_sof_event+0x5c>)
		interval = 0;
    c784:	7113      	strb	r3, [r2, #4]
		if (!gpio_get_pin_level(pin_btn1)) {
    c786:	47a8      	blx	r5
    c788:	b920      	cbnz	r0, c794 <hiddf_demo_sof_event+0x28>
			hiddf_mouse_move(-5, HID_MOUSE_X_AXIS_MV);
    c78a:	4b10      	ldr	r3, [pc, #64]	; (c7cc <hiddf_demo_sof_event+0x60>)
    c78c:	2101      	movs	r1, #1
    c78e:	f06f 0004 	mvn.w	r0, #4
    c792:	4798      	blx	r3
		if (!gpio_get_pin_level(pin_btn3)) {
    c794:	7b20      	ldrb	r0, [r4, #12]
    c796:	47a8      	blx	r5
    c798:	b918      	cbnz	r0, c7a2 <hiddf_demo_sof_event+0x36>
			hiddf_mouse_move(5, HID_MOUSE_X_AXIS_MV);
    c79a:	4b0c      	ldr	r3, [pc, #48]	; (c7cc <hiddf_demo_sof_event+0x60>)
    c79c:	2101      	movs	r1, #1
    c79e:	2005      	movs	r0, #5
    c7a0:	4798      	blx	r3
		if (b_btn_last_state != (b_btn_state = !gpio_get_pin_level(pin_btn2))) {
    c7a2:	7c20      	ldrb	r0, [r4, #16]
    c7a4:	47a8      	blx	r5
    c7a6:	7d22      	ldrb	r2, [r4, #20]
    c7a8:	f080 0001 	eor.w	r0, r0, #1
    c7ac:	b2c3      	uxtb	r3, r0
    c7ae:	429a      	cmp	r2, r3
    c7b0:	d0e4      	beq.n	c77c <hiddf_demo_sof_event+0x10>
			b_btn_last_state = b_btn_state;
    c7b2:	4807      	ldr	r0, [pc, #28]	; (c7d0 <hiddf_demo_sof_event+0x64>)
    c7b4:	7523      	strb	r3, [r4, #20]
			if (1 == b_btn_last_state) {
    c7b6:	7083      	strb	r3, [r0, #2]
}
    c7b8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			hiddf_keyboard_keys_state_change(key_array, 1);
    c7bc:	4b05      	ldr	r3, [pc, #20]	; (c7d4 <hiddf_demo_sof_event+0x68>)
    c7be:	2101      	movs	r1, #1
    c7c0:	4718      	bx	r3
    c7c2:	bf00      	nop
    c7c4:	200011a0 	.word	0x200011a0
    c7c8:	0000c725 	.word	0x0000c725
    c7cc:	0000defd 	.word	0x0000defd
    c7d0:	2000035c 	.word	0x2000035c
    c7d4:	0000e989 	.word	0x0000e989

0000c7d8 <composite_device_init>:
	usbdc_register_handler(USBDC_HDL_SOF, &hiddf_demo_sof_event_h);
}
#endif /* #if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO */

void composite_device_init(void)
{
    c7d8:	b510      	push	{r4, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    c7da:	4b05      	ldr	r3, [pc, #20]	; (c7f0 <composite_device_init+0x18>)
    c7dc:	4805      	ldr	r0, [pc, #20]	; (c7f4 <composite_device_init+0x1c>)
    c7de:	4798      	blx	r3

	/* usbdc_register_funcion inside */
#if CONF_USB_COMPOSITE_CDC_ACM_EN
	cdcdf_acm_init();
    c7e0:	4b05      	ldr	r3, [pc, #20]	; (c7f8 <composite_device_init+0x20>)
    c7e2:	4798      	blx	r3
#endif
#if CONF_USB_COMPOSITE_HID_MOUSE_EN
	hiddf_mouse_init();
    c7e4:	4b05      	ldr	r3, [pc, #20]	; (c7fc <composite_device_init+0x24>)
    c7e6:	4798      	blx	r3
	hiddf_keyboard_init();
#endif
#if CONF_USB_COMPOSITE_MSC_EN
	mscdf_init(CONF_USB_MSC_MAX_LUN);
#endif
}
    c7e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hiddf_keyboard_init();
    c7ec:	4b04      	ldr	r3, [pc, #16]	; (c800 <composite_device_init+0x28>)
    c7ee:	4718      	bx	r3
    c7f0:	0001331d 	.word	0x0001331d
    c7f4:	200011b5 	.word	0x200011b5
    c7f8:	0000bbe9 	.word	0x0000bbe9
    c7fc:	0000deb9 	.word	0x0000deb9
    c800:	0000e945 	.word	0x0000e945

0000c804 <composite_device_start>:

void composite_device_start(void)
{
    c804:	b510      	push	{r4, lr}
	usbdc_start(multi_desc);
    c806:	4b03      	ldr	r3, [pc, #12]	; (c814 <composite_device_start+0x10>)
    c808:	4803      	ldr	r0, [pc, #12]	; (c818 <composite_device_start+0x14>)
    c80a:	4798      	blx	r3
	usbdc_attach();
}
    c80c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	usbdc_attach();
    c810:	4b02      	ldr	r3, [pc, #8]	; (c81c <composite_device_start+0x18>)
    c812:	4718      	bx	r3
    c814:	00013389 	.word	0x00013389
    c818:	20000368 	.word	0x20000368
    c81c:	000133bd 	.word	0x000133bd

0000c820 <usb_init>:
}

void usb_init(void)
{

	composite_device_init();
    c820:	4b00      	ldr	r3, [pc, #0]	; (c824 <usb_init+0x4>)
    c822:	4718      	bx	r3
    c824:	0000c7d9 	.word	0x0000c7d9

0000c828 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    c828:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    c82a:	6805      	ldr	r5, [r0, #0]

	if (!head) {
    c82c:	b91d      	cbnz	r5, c836 <timer_add_timer_task+0xe>
		list_insert_as_head(list, new_task);
    c82e:	4b0f      	ldr	r3, [pc, #60]	; (c86c <timer_add_timer_task+0x44>)
	if (it == head) {
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
	}
}
    c830:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		list_insert_after(prev, new_task);
    c834:	4718      	bx	r3
		if (time_left >= new_task->interval)
    c836:	f8d1 c008 	ldr.w	ip, [r1, #8]
    c83a:	462c      	mov	r4, r5
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    c83c:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c83e:	f1c2 0e01 	rsb	lr, r2, #1
		if (it->time_label <= time) {
    c842:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
    c846:	4293      	cmp	r3, r2
			time_left = it->interval - (time - it->time_label);
    c848:	bf95      	itete	ls
    c84a:	19db      	addls	r3, r3, r7
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c84c:	4473      	addhi	r3, lr
			time_left = it->interval - (time - it->time_label);
    c84e:	1a9b      	subls	r3, r3, r2
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    c850:	19db      	addhi	r3, r3, r7
		if (time_left >= new_task->interval)
    c852:	459c      	cmp	ip, r3
    c854:	d907      	bls.n	c866 <timer_add_timer_task+0x3e>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    c856:	6823      	ldr	r3, [r4, #0]
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    c858:	4626      	mov	r6, r4
    c85a:	b913      	cbnz	r3, c862 <timer_add_timer_task+0x3a>
		list_insert_after(prev, new_task);
    c85c:	4b04      	ldr	r3, [pc, #16]	; (c870 <timer_add_timer_task+0x48>)
    c85e:	4630      	mov	r0, r6
    c860:	e7e6      	b.n	c830 <timer_add_timer_task+0x8>
    c862:	461c      	mov	r4, r3
    c864:	e7ed      	b.n	c842 <timer_add_timer_task+0x1a>
	if (it == head) {
    c866:	42a5      	cmp	r5, r4
    c868:	d0e1      	beq.n	c82e <timer_add_timer_task+0x6>
    c86a:	e7f7      	b.n	c85c <timer_add_timer_task+0x34>
    c86c:	0000f6fd 	.word	0x0000f6fd
    c870:	0000f729 	.word	0x0000f729

0000c874 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    c874:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    c878:	e9d0 6504 	ldrd	r6, r5, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c87c:	7e03      	ldrb	r3, [r0, #24]
	uint32_t                 time  = ++timer->time;
    c87e:	3601      	adds	r6, #1
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c880:	07da      	lsls	r2, r3, #31
{
    c882:	4604      	mov	r4, r0
	uint32_t                 time  = ++timer->time;
    c884:	6106      	str	r6, [r0, #16]
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    c886:	d41f      	bmi.n	c8c8 <timer_process_counted+0x54>
    c888:	7e03      	ldrb	r3, [r0, #24]
    c88a:	079b      	lsls	r3, r3, #30
    c88c:	d41c      	bmi.n	c8c8 <timer_process_counted+0x54>
	}

	while (it && ((time - it->time_label) >= it->interval)) {
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    c88e:	f8df 8044 	ldr.w	r8, [pc, #68]	; c8d4 <timer_process_counted+0x60>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    c892:	f8df 9044 	ldr.w	r9, [pc, #68]	; c8d8 <timer_process_counted+0x64>
		list_remove_head(&timer->tasks);
    c896:	f100 0714 	add.w	r7, r0, #20
	while (it && ((time - it->time_label) >= it->interval)) {
    c89a:	b1cd      	cbz	r5, c8d0 <timer_process_counted+0x5c>
    c89c:	686b      	ldr	r3, [r5, #4]
    c89e:	68aa      	ldr	r2, [r5, #8]
    c8a0:	1af3      	subs	r3, r6, r3
    c8a2:	4293      	cmp	r3, r2
    c8a4:	d314      	bcc.n	c8d0 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
    c8a6:	4638      	mov	r0, r7
    c8a8:	47c0      	blx	r8
		if (TIMER_TASK_REPEAT == tmp->mode) {
    c8aa:	7c2b      	ldrb	r3, [r5, #16]
    c8ac:	2b01      	cmp	r3, #1
    c8ae:	d104      	bne.n	c8ba <timer_process_counted+0x46>
			tmp->time_label = time;
    c8b0:	606e      	str	r6, [r5, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    c8b2:	4632      	mov	r2, r6
    c8b4:	4629      	mov	r1, r5
    c8b6:	4638      	mov	r0, r7
    c8b8:	47c8      	blx	r9
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);
    c8ba:	f8d4 a014 	ldr.w	sl, [r4, #20]

		tmp->cb(tmp);
    c8be:	68eb      	ldr	r3, [r5, #12]
    c8c0:	4628      	mov	r0, r5
    c8c2:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    c8c4:	4655      	mov	r5, sl
    c8c6:	e7e8      	b.n	c89a <timer_process_counted+0x26>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    c8c8:	7e23      	ldrb	r3, [r4, #24]
    c8ca:	f043 0302 	orr.w	r3, r3, #2
    c8ce:	7623      	strb	r3, [r4, #24]
	}
}
    c8d0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c8d4:	0000f771 	.word	0x0000f771
    c8d8:	0000c829 	.word	0x0000c829

0000c8dc <timer_init>:
{
    c8dc:	b570      	push	{r4, r5, r6, lr}
    c8de:	460d      	mov	r5, r1
    c8e0:	4616      	mov	r6, r2
	ASSERT(descr && hw && func);
    c8e2:	4604      	mov	r4, r0
    c8e4:	b118      	cbz	r0, c8ee <timer_init+0x12>
    c8e6:	b189      	cbz	r1, c90c <timer_init+0x30>
    c8e8:	1e10      	subs	r0, r2, #0
    c8ea:	bf18      	it	ne
    c8ec:	2001      	movne	r0, #1
    c8ee:	223b      	movs	r2, #59	; 0x3b
    c8f0:	4907      	ldr	r1, [pc, #28]	; (c910 <timer_init+0x34>)
    c8f2:	4b08      	ldr	r3, [pc, #32]	; (c914 <timer_init+0x38>)
    c8f4:	4798      	blx	r3
	descr->func = func;
    c8f6:	4620      	mov	r0, r4
	descr->func->init(&descr->device, hw);
    c8f8:	6833      	ldr	r3, [r6, #0]
	descr->func = func;
    c8fa:	f840 6b04 	str.w	r6, [r0], #4
	descr->func->init(&descr->device, hw);
    c8fe:	4629      	mov	r1, r5
    c900:	4798      	blx	r3
	descr->device.timer_cb.period_expired = timer_process_counted;
    c902:	4b05      	ldr	r3, [pc, #20]	; (c918 <timer_init+0x3c>)
    c904:	6063      	str	r3, [r4, #4]
	descr->time                           = 0;
    c906:	2000      	movs	r0, #0
    c908:	6160      	str	r0, [r4, #20]
}
    c90a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw && func);
    c90c:	4608      	mov	r0, r1
    c90e:	e7ee      	b.n	c8ee <timer_init+0x12>
    c910:	00016f7c 	.word	0x00016f7c
    c914:	0000df45 	.word	0x0000df45
    c918:	0000c875 	.word	0x0000c875

0000c91c <timer_start>:
{
    c91c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr && descr->func);
    c91e:	4605      	mov	r5, r0
    c920:	b118      	cbz	r0, c92a <timer_start+0xe>
    c922:	6800      	ldr	r0, [r0, #0]
    c924:	3800      	subs	r0, #0
    c926:	bf18      	it	ne
    c928:	2001      	movne	r0, #1
	if (descr->func->is_timer_started(&descr->device)) {
    c92a:	462e      	mov	r6, r5
	ASSERT(descr && descr->func);
    c92c:	4909      	ldr	r1, [pc, #36]	; (c954 <timer_start+0x38>)
    c92e:	4b0a      	ldr	r3, [pc, #40]	; (c958 <timer_start+0x3c>)
    c930:	2254      	movs	r2, #84	; 0x54
    c932:	4798      	blx	r3
	if (descr->func->is_timer_started(&descr->device)) {
    c934:	f856 3b04 	ldr.w	r3, [r6], #4
    c938:	699b      	ldr	r3, [r3, #24]
    c93a:	4630      	mov	r0, r6
    c93c:	4798      	blx	r3
    c93e:	4604      	mov	r4, r0
    c940:	b928      	cbnz	r0, c94e <timer_start+0x32>
	descr->func->start_timer(&descr->device);
    c942:	682b      	ldr	r3, [r5, #0]
    c944:	4630      	mov	r0, r6
    c946:	689b      	ldr	r3, [r3, #8]
    c948:	4798      	blx	r3
	return ERR_NONE;
    c94a:	4620      	mov	r0, r4
}
    c94c:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
    c94e:	f06f 0010 	mvn.w	r0, #16
    c952:	e7fb      	b.n	c94c <timer_start+0x30>
    c954:	00016f7c 	.word	0x00016f7c
    c958:	0000df45 	.word	0x0000df45

0000c95c <timer_add_task>:
{
    c95c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    c960:	460d      	mov	r5, r1
	ASSERT(descr && task && descr->func);
    c962:	4604      	mov	r4, r0
    c964:	b120      	cbz	r0, c970 <timer_add_task+0x14>
    c966:	b309      	cbz	r1, c9ac <timer_add_task+0x50>
    c968:	6800      	ldr	r0, [r0, #0]
    c96a:	3800      	subs	r0, #0
    c96c:	bf18      	it	ne
    c96e:	2001      	movne	r0, #1
    c970:	4920      	ldr	r1, [pc, #128]	; (c9f4 <timer_add_task+0x98>)
    c972:	f8df 8094 	ldr.w	r8, [pc, #148]	; ca08 <timer_add_task+0xac>
    c976:	227b      	movs	r2, #123	; 0x7b
    c978:	47c0      	blx	r8
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    c97a:	7f23      	ldrb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    c97c:	f104 0718 	add.w	r7, r4, #24
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    c980:	f043 0301 	orr.w	r3, r3, #1
    c984:	7723      	strb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    c986:	4629      	mov	r1, r5
    c988:	4b1b      	ldr	r3, [pc, #108]	; (c9f8 <timer_add_task+0x9c>)
    c98a:	4638      	mov	r0, r7
    c98c:	4798      	blx	r3
    c98e:	4606      	mov	r6, r0
    c990:	b170      	cbz	r0, c9b0 <timer_add_task+0x54>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    c992:	7f23      	ldrb	r3, [r4, #28]
		ASSERT(false);
    c994:	4917      	ldr	r1, [pc, #92]	; (c9f4 <timer_add_task+0x98>)
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    c996:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
		ASSERT(false);
    c99a:	2000      	movs	r0, #0
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    c99c:	7723      	strb	r3, [r4, #28]
		ASSERT(false);
    c99e:	2280      	movs	r2, #128	; 0x80
    c9a0:	47c0      	blx	r8
		return ERR_ALREADY_INITIALIZED;
    c9a2:	f06f 0011 	mvn.w	r0, #17
}
    c9a6:	b002      	add	sp, #8
    c9a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(descr && task && descr->func);
    c9ac:	4608      	mov	r0, r1
    c9ae:	e7df      	b.n	c970 <timer_add_task+0x14>
	task->time_label = descr->time;
    c9b0:	6962      	ldr	r2, [r4, #20]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    c9b2:	4b12      	ldr	r3, [pc, #72]	; (c9fc <timer_add_task+0xa0>)
	task->time_label = descr->time;
    c9b4:	606a      	str	r2, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    c9b6:	4629      	mov	r1, r5
    c9b8:	4638      	mov	r0, r7
    c9ba:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    c9bc:	7f23      	ldrb	r3, [r4, #28]
    c9be:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    c9c2:	7723      	strb	r3, [r4, #28]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    c9c4:	7f23      	ldrb	r3, [r4, #28]
    c9c6:	f013 0302 	ands.w	r3, r3, #2
    c9ca:	d010      	beq.n	c9ee <timer_add_task+0x92>
		CRITICAL_SECTION_ENTER()
    c9cc:	4b0c      	ldr	r3, [pc, #48]	; (ca00 <timer_add_task+0xa4>)
    c9ce:	a801      	add	r0, sp, #4
    c9d0:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    c9d2:	7f23      	ldrb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    c9d4:	4620      	mov	r0, r4
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    c9d6:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    c9da:	7723      	strb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    c9dc:	f850 3b04 	ldr.w	r3, [r0], #4
    c9e0:	69db      	ldr	r3, [r3, #28]
    c9e2:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    c9e4:	a801      	add	r0, sp, #4
    c9e6:	4b07      	ldr	r3, [pc, #28]	; (ca04 <timer_add_task+0xa8>)
    c9e8:	4798      	blx	r3
	return ERR_NONE;
    c9ea:	4630      	mov	r0, r6
    c9ec:	e7db      	b.n	c9a6 <timer_add_task+0x4a>
    c9ee:	4618      	mov	r0, r3
    c9f0:	e7d9      	b.n	c9a6 <timer_add_task+0x4a>
    c9f2:	bf00      	nop
    c9f4:	00016f7c 	.word	0x00016f7c
    c9f8:	0000f6ed 	.word	0x0000f6ed
    c9fc:	0000c829 	.word	0x0000c829
    ca00:	00011a11 	.word	0x00011a11
    ca04:	00011a1f 	.word	0x00011a1f
    ca08:	0000df45 	.word	0x0000df45

0000ca0c <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    ca0c:	2000      	movs	r0, #0
    ca0e:	4770      	bx	lr

0000ca10 <_usb_d_dev_wait_dfll_rdy>:
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    ca10:	4b07      	ldr	r3, [pc, #28]	; (ca30 <_usb_d_dev_wait_dfll_rdy+0x20>)
    ca12:	f893 2020 	ldrb.w	r2, [r3, #32]
/**
 * \brief Wait DFLL clock to be ready
 */
static inline void _usb_d_dev_wait_dfll_rdy(void)
{
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    ca16:	07d1      	lsls	r1, r2, #31
    ca18:	d506      	bpl.n	ca28 <_usb_d_dev_wait_dfll_rdy+0x18>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    ca1a:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    ca1c:	f402 6210 	and.w	r2, r2, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    ca20:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    ca24:	d1f9      	bne.n	ca1a <_usb_d_dev_wait_dfll_rdy+0xa>
    ca26:	4770      	bx	lr
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    ca28:	691a      	ldr	r2, [r3, #16]
		       != (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
			;
	} else {
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    ca2a:	05d2      	lsls	r2, r2, #23
    ca2c:	d5fc      	bpl.n	ca28 <_usb_d_dev_wait_dfll_rdy+0x18>
			;
	}
}
    ca2e:	4770      	bx	lr
    ca30:	40001000 	.word	0x40001000

0000ca34 <_usb_d_dev_ept>:
 * \param[in] epn Endpoint number.
 * \param[in] dir Endpoint direction.
 */
static inline struct _usb_d_dev_ep *_usb_d_dev_ept(uint8_t epn, bool dir)
{
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    ca34:	b110      	cbz	r0, ca3c <_usb_d_dev_ept+0x8>
    ca36:	b109      	cbz	r1, ca3c <_usb_d_dev_ept+0x8>
    ca38:	3005      	adds	r0, #5
    ca3a:	b2c0      	uxtb	r0, r0
	return &dev_inst.ep[ep_index];
    ca3c:	2314      	movs	r3, #20
    ca3e:	fb00 3003 	mla	r0, r0, r3, r3
}
    ca42:	4b01      	ldr	r3, [pc, #4]	; (ca48 <_usb_d_dev_ept+0x14>)
    ca44:	4418      	add	r0, r3
    ca46:	4770      	bx	lr
    ca48:	200011f8 	.word	0x200011f8

0000ca4c <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    ca4c:	b430      	push	{r4, r5}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    ca4e:	7cc1      	ldrb	r1, [r0, #19]
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    ca50:	7c85      	ldrb	r5, [r0, #18]

	if (!is_ctrl) {
    ca52:	f001 0307 	and.w	r3, r1, #7
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    ca56:	f005 020f 	and.w	r2, r5, #15
	if (!is_ctrl) {
    ca5a:	2b01      	cmp	r3, #1
    ca5c:	ea4f 1442 	mov.w	r4, r2, lsl #5
    ca60:	f102 0308 	add.w	r3, r2, #8
    ca64:	d00a      	beq.n	ca7c <_usb_d_dev_handle_setup+0x30>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ca66:	015a      	lsls	r2, r3, #5
    ca68:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    ca6c:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ca70:	2110      	movs	r1, #16
    ca72:	71d1      	strb	r1, [r2, #7]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    ca74:	bc30      	pop	{r4, r5}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    ca76:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    ca7a:	4770      	bx	lr
	if (_usb_d_dev_ep_is_busy(ept)) {
    ca7c:	f011 0f40 	tst.w	r1, #64	; 0x40
    ca80:	d00b      	beq.n	ca9a <_usb_d_dev_handle_setup+0x4e>
		ept->flags.bits.is_busy = 0;
    ca82:	0152      	lsls	r2, r2, #5
    ca84:	f36f 1186 	bfc	r1, #6, #1
    ca88:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    ca8c:	74c1      	strb	r1, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    ca8e:	2180      	movs	r1, #128	; 0x80
    ca90:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    ca94:	2140      	movs	r1, #64	; 0x40
    ca96:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105
	ept->flags.bits.is_stalled = 0;
    ca9a:	7cc2      	ldrb	r2, [r0, #19]
    ca9c:	f36f 02c3 	bfc	r2, #3, #1
    caa0:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    caa2:	4a0a      	ldr	r2, [pc, #40]	; (cacc <_usb_d_dev_handle_setup+0x80>)
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    caa4:	015b      	lsls	r3, r3, #5
    caa6:	1911      	adds	r1, r2, r4
    caa8:	2000      	movs	r0, #0
    caaa:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    caae:	f881 023a 	strb.w	r0, [r1, #570]	; 0x23a
    cab2:	f881 024a 	strb.w	r0, [r1, #586]	; 0x24a
    cab6:	216f      	movs	r1, #111	; 0x6f
    cab8:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    caba:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	dev_inst.ep_callbacks.setup(ept->ep);
    cabe:	4628      	mov	r0, r5
    cac0:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    cac4:	bc30      	pop	{r4, r5}
	dev_inst.ep_callbacks.setup(ept->ep);
    cac6:	6893      	ldr	r3, [r2, #8]
    cac8:	4718      	bx	r3
    caca:	bf00      	nop
    cacc:	200011f8 	.word	0x200011f8

0000cad0 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    cad0:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cad2:	7c84      	ldrb	r4, [r0, #18]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cad4:	6882      	ldr	r2, [r0, #8]
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    cad6:	2320      	movs	r3, #32
    cad8:	fa03 f101 	lsl.w	r1, r3, r1
    cadc:	f004 030f 	and.w	r3, r4, #15
    cae0:	015b      	lsls	r3, r3, #5
    cae2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    cae6:	b2c9      	uxtb	r1, r1
    cae8:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    caec:	4b03      	ldr	r3, [pc, #12]	; (cafc <_usb_d_dev_handle_stall+0x2c>)
    caee:	4620      	mov	r0, r4
    caf0:	691b      	ldr	r3, [r3, #16]
}
    caf2:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    caf6:	2101      	movs	r1, #1
    caf8:	4718      	bx	r3
    cafa:	bf00      	nop
    cafc:	200011f8 	.word	0x200011f8

0000cb00 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    cb00:	b410      	push	{r4}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cb02:	7c84      	ldrb	r4, [r0, #18]
    cb04:	2cff      	cmp	r4, #255	; 0xff
    cb06:	d00c      	beq.n	cb22 <_usb_d_dev_trans_done+0x22>
    cb08:	7cc3      	ldrb	r3, [r0, #19]
    cb0a:	065a      	lsls	r2, r3, #25
    cb0c:	d509      	bpl.n	cb22 <_usb_d_dev_trans_done+0x22>
		return;
	}
	ept->flags.bits.is_busy = 0;
    cb0e:	f36f 1386 	bfc	r3, #6, #1
    cb12:	74c3      	strb	r3, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cb14:	4b04      	ldr	r3, [pc, #16]	; (cb28 <_usb_d_dev_trans_done+0x28>)
    cb16:	6882      	ldr	r2, [r0, #8]
    cb18:	691b      	ldr	r3, [r3, #16]
    cb1a:	4620      	mov	r0, r4
}
    cb1c:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cb20:	4718      	bx	r3
}
    cb22:	f85d 4b04 	ldr.w	r4, [sp], #4
    cb26:	4770      	bx	lr
    cb28:	200011f8 	.word	0x200011f8

0000cb2c <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    cb2c:	b477      	push	{r0, r1, r2, r4, r5, r6}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cb2e:	7c83      	ldrb	r3, [r0, #18]
{
    cb30:	460d      	mov	r5, r1
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cb32:	2bff      	cmp	r3, #255	; 0xff
{
    cb34:	4611      	mov	r1, r2
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    cb36:	f644 2225 	movw	r2, #18981	; 0x4a25
    cb3a:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cb3e:	d020      	beq.n	cb82 <_usb_d_dev_trans_stop+0x56>
    cb40:	7cc2      	ldrb	r2, [r0, #19]
    cb42:	0652      	lsls	r2, r2, #25
    cb44:	d51d      	bpl.n	cb82 <_usb_d_dev_trans_stop+0x56>
		return;
	}
	/* Stop transfer */
	if (dir) {
    cb46:	f003 030f 	and.w	r3, r3, #15
    cb4a:	f103 0408 	add.w	r4, r3, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cb4e:	0162      	lsls	r2, r4, #5
    cb50:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cb54:	b195      	cbz	r5, cb7c <_usb_d_dev_trans_stop+0x50>
    cb56:	2680      	movs	r6, #128	; 0x80
    cb58:	7116      	strb	r6, [r2, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    cb5a:	aa02      	add	r2, sp, #8
    cb5c:	4415      	add	r5, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cb5e:	0164      	lsls	r4, r4, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cb60:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cb62:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cb66:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cb6a:	f815 2c04 	ldrb.w	r2, [r5, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cb6e:	71e2      	strb	r2, [r4, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cb70:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    cb74:	4b04      	ldr	r3, [pc, #16]	; (cb88 <_usb_d_dev_trans_stop+0x5c>)
}
    cb76:	b003      	add	sp, #12
    cb78:	bc70      	pop	{r4, r5, r6}
	_usb_d_dev_trans_done(ept, code);
    cb7a:	4718      	bx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    cb7c:	2640      	movs	r6, #64	; 0x40
    cb7e:	7156      	strb	r6, [r2, #5]
}
    cb80:	e7eb      	b.n	cb5a <_usb_d_dev_trans_stop+0x2e>
}
    cb82:	b003      	add	sp, #12
    cb84:	bc70      	pop	{r4, r5, r6}
    cb86:	4770      	bx	lr
    cb88:	0000cb01 	.word	0x0000cb01

0000cb8c <_usb_d_dev_handle_trfail>:
{
    cb8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    cb8e:	7c83      	ldrb	r3, [r0, #18]
    cb90:	f003 0c0f 	and.w	ip, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    cb94:	f640 0204 	movw	r2, #2052	; 0x804
    cb98:	4663      	mov	r3, ip
    cb9a:	f8ad 2004 	strh.w	r2, [sp, #4]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    cb9e:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    cba0:	f10c 0308 	add.w	r3, ip, #8
    cba4:	460c      	mov	r4, r1

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    cba6:	0159      	lsls	r1, r3, #5
    cba8:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    cbac:	780f      	ldrb	r7, [r1, #0]
    cbae:	b334      	cbz	r4, cbfe <_usb_d_dev_handle_trfail+0x72>
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    cbb0:	f3c7 1702 	ubfx	r7, r7, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    cbb4:	4e2c      	ldr	r6, [pc, #176]	; (cc68 <_usb_d_dev_handle_trfail+0xdc>)
    cbb6:	eb02 1204 	add.w	r2, r2, r4, lsl #4
    cbba:	4416      	add	r6, r2
    cbbc:	aa02      	add	r2, sp, #8
    cbbe:	4422      	add	r2, r4
    cbc0:	7ab5      	ldrb	r5, [r6, #10]
    cbc2:	f812 ec04 	ldrb.w	lr, [r2, #-4]
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    cbc6:	2f02      	cmp	r7, #2
	st.reg = bank[bank_n].STATUS_BK.reg;
    cbc8:	b2ed      	uxtb	r5, r5
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    cbca:	ea4f 124c 	mov.w	r2, ip, lsl #5
    cbce:	d119      	bne.n	cc04 <_usb_d_dev_handle_trfail+0x78>
    cbd0:	07e9      	lsls	r1, r5, #31
    cbd2:	d517      	bpl.n	cc04 <_usb_d_dev_handle_trfail+0x78>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    cbd4:	7ab1      	ldrb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cbd6:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cbd8:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cbdc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cbe0:	f36f 0100 	bfc	r1, #0, #1
    cbe4:	72b1      	strb	r1, [r6, #10]
    cbe6:	f883 e007 	strb.w	lr, [r3, #7]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    cbea:	f004 0101 	and.w	r1, r4, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cbee:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    cbf2:	2204      	movs	r2, #4
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cbf4:	4b1d      	ldr	r3, [pc, #116]	; (cc6c <_usb_d_dev_handle_trfail+0xe0>)
}
    cbf6:	b003      	add	sp, #12
    cbf8:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cbfc:	4718      	bx	r3
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    cbfe:	f007 0707 	and.w	r7, r7, #7
	return tmp;
    cc02:	e7d7      	b.n	cbb4 <_usb_d_dev_handle_trfail+0x28>
	} else if (st.bit.ERRORFLOW) {
    cc04:	f015 0502 	ands.w	r5, r5, #2
    cc08:	d01b      	beq.n	cc42 <_usb_d_dev_handle_trfail+0xb6>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    cc0a:	7ab1      	ldrb	r1, [r6, #10]
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cc0c:	7cc5      	ldrb	r5, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc0e:	015b      	lsls	r3, r3, #5
    cc10:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    cc14:	f36f 0141 	bfc	r1, #1, #1
    cc18:	72b1      	strb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc1a:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc1e:	f883 e007 	strb.w	lr, [r3, #7]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    cc22:	f005 0307 	and.w	r3, r5, #7
    cc26:	2b01      	cmp	r3, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc28:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    cc2c:	d119      	bne.n	cc62 <_usb_d_dev_handle_trfail+0xd6>
    cc2e:	066b      	lsls	r3, r5, #25
    cc30:	d517      	bpl.n	cc62 <_usb_d_dev_handle_trfail+0xd6>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    cc32:	7cc3      	ldrb	r3, [r0, #19]
    cc34:	ebb4 1fd3 	cmp.w	r4, r3, lsr #7
    cc38:	ea4f 11d3 	mov.w	r1, r3, lsr #7
    cc3c:	d011      	beq.n	cc62 <_usb_d_dev_handle_trfail+0xd6>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    cc3e:	2200      	movs	r2, #0
    cc40:	e7d8      	b.n	cbf4 <_usb_d_dev_handle_trfail+0x68>
	bank->STATUS_BK.reg     = 0;
    cc42:	490b      	ldr	r1, [pc, #44]	; (cc70 <_usb_d_dev_handle_trfail+0xe4>)
    cc44:	eb04 044c 	add.w	r4, r4, ip, lsl #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc48:	015b      	lsls	r3, r3, #5
    cc4a:	eb01 1404 	add.w	r4, r1, r4, lsl #4
    cc4e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc52:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cc56:	f884 523a 	strb.w	r5, [r4, #570]	; 0x23a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cc5a:	f883 e007 	strb.w	lr, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cc5e:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
}
    cc62:	b003      	add	sp, #12
    cc64:	bdf0      	pop	{r4, r5, r6, r7, pc}
    cc66:	bf00      	nop
    cc68:	20001428 	.word	0x20001428
    cc6c:	0000cb2d 	.word	0x0000cb2d
    cc70:	200011f8 	.word	0x200011f8

0000cc74 <_usb_d_dev_reset_epts>:
{
    cc74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    cc78:	4c0a      	ldr	r4, [pc, #40]	; (cca4 <_usb_d_dev_reset_epts+0x30>)
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    cc7a:	4f0b      	ldr	r7, [pc, #44]	; (cca8 <_usb_d_dev_reset_epts+0x34>)
{
    cc7c:	2501      	movs	r5, #1
		dev_inst.ep[i].ep       = 0xFF;
    cc7e:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    cc80:	2103      	movs	r1, #3
    cc82:	4620      	mov	r0, r4
    cc84:	3501      	adds	r5, #1
    cc86:	47b8      	blx	r7
		dev_inst.ep[i].flags.u8 = 0;
    cc88:	2100      	movs	r1, #0
	for (i = 0; i < USB_D_N_EP; i++) {
    cc8a:	2d1c      	cmp	r5, #28
		dev_inst.ep[i].ep       = 0xFF;
    cc8c:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    cc8e:	74e1      	strb	r1, [r4, #19]
	for (i = 0; i < USB_D_N_EP; i++) {
    cc90:	f104 0414 	add.w	r4, r4, #20
    cc94:	d1f4      	bne.n	cc80 <_usb_d_dev_reset_epts+0xc>
}
    cc96:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    cc9a:	4804      	ldr	r0, [pc, #16]	; (ccac <_usb_d_dev_reset_epts+0x38>)
    cc9c:	4b04      	ldr	r3, [pc, #16]	; (ccb0 <_usb_d_dev_reset_epts+0x3c>)
    cc9e:	22c0      	movs	r2, #192	; 0xc0
    cca0:	4718      	bx	r3
    cca2:	bf00      	nop
    cca4:	2000120c 	.word	0x2000120c
    cca8:	0000cb01 	.word	0x0000cb01
    ccac:	20001428 	.word	0x20001428
    ccb0:	00014175 	.word	0x00014175

0000ccb4 <_usb_d_dev_in_next>:
{
    ccb4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ccb8:	4604      	mov	r4, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    ccba:	7c80      	ldrb	r0, [r0, #18]
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    ccbc:	4688      	mov	r8, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    ccbe:	f000 070f 	and.w	r7, r0, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    ccc2:	2900      	cmp	r1, #0
    ccc4:	d05b      	beq.n	cd7e <_usb_d_dev_in_next+0xca>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    ccc6:	4b4d      	ldr	r3, [pc, #308]	; (cdfc <_usb_d_dev_in_next+0x148>)
    ccc8:	eb03 1347 	add.w	r3, r3, r7, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    cccc:	695e      	ldr	r6, [r3, #20]
    ccce:	f3c6 060d 	ubfx	r6, r6, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    ccd2:	8a22      	ldrh	r2, [r4, #16]
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    ccd4:	f894 e013 	ldrb.w	lr, [r4, #19]
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    ccd8:	f240 33ff 	movw	r3, #1023	; 0x3ff
    ccdc:	429a      	cmp	r2, r3
    ccde:	bf1a      	itte	ne
    cce0:	f102 3cff 	addne.w	ip, r2, #4294967295	; 0xffffffff
    cce4:	fa0f fc8c 	sxthne.w	ip, ip
    cce8:	4694      	moveq	ip, r2
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    ccea:	f00e 0907 	and.w	r9, lr, #7
	if (isr) {
    ccee:	f1b8 0f00 	cmp.w	r8, #0
    ccf2:	d005      	beq.n	cd00 <_usb_d_dev_in_next+0x4c>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ccf4:	017b      	lsls	r3, r7, #5
    ccf6:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    ccfa:	2102      	movs	r1, #2
    ccfc:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	ept->trans_count += trans_count;
    cd00:	68a1      	ldr	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    cd02:	6863      	ldr	r3, [r4, #4]
	ept->trans_count += trans_count;
    cd04:	4431      	add	r1, r6
	if (ept->trans_count < ept->trans_size) {
    cd06:	4299      	cmp	r1, r3
	ept->trans_count += trans_count;
    cd08:	60a1      	str	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    cd0a:	ea4f 1547 	mov.w	r5, r7, lsl #5
    cd0e:	d242      	bcs.n	cd96 <_usb_d_dev_in_next+0xe2>
		trans_next = ept->trans_size - ept->trans_count;
    cd10:	1a5b      	subs	r3, r3, r1
    cd12:	b29e      	uxth	r6, r3
		if (ept->flags.bits.use_cache) {
    cd14:	6823      	ldr	r3, [r4, #0]
    cd16:	f8df a0f0 	ldr.w	sl, [pc, #240]	; ce08 <_usb_d_dev_in_next+0x154>
    cd1a:	f01e 0f20 	tst.w	lr, #32
    cd1e:	4419      	add	r1, r3
    cd20:	d02f      	beq.n	cd82 <_usb_d_dev_in_next+0xce>
			if (trans_next > ept->size) {
    cd22:	4296      	cmp	r6, r2
    cd24:	bf28      	it	cs
    cd26:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    cd28:	4b35      	ldr	r3, [pc, #212]	; (ce00 <_usb_d_dev_in_next+0x14c>)
    cd2a:	68e0      	ldr	r0, [r4, #12]
    cd2c:	4632      	mov	r2, r6
    cd2e:	4798      	blx	r3
	bank->ADDR.reg          = addr;
    cd30:	eb0a 0305 	add.w	r3, sl, r5
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    cd34:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    cd36:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    cd3a:	eb0a 0205 	add.w	r2, sl, r5
    cd3e:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    cd42:	f366 030d 	bfi	r3, r6, #0, #14
    cd46:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    cd4a:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    cd4e:	f36f 339b 	bfc	r3, #14, #14
    cd52:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	if (!isr) {
    cd56:	f1b8 0f00 	cmp.w	r8, #0
    cd5a:	d108      	bne.n	cd6e <_usb_d_dev_in_next+0xba>
			inten = USB_D_BANK1_INT_FLAGS;
    cd5c:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    cd60:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    cd64:	bf0c      	ite	eq
    cd66:	234e      	moveq	r3, #78	; 0x4e
    cd68:	234a      	movne	r3, #74	; 0x4a
    cd6a:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    cd6e:	017b      	lsls	r3, r7, #5
    cd70:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cd74:	2280      	movs	r2, #128	; 0x80
    cd76:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
}
    cd7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    cd7e:	460e      	mov	r6, r1
    cd80:	e7a7      	b.n	ccd2 <_usb_d_dev_in_next+0x1e>
	bank->ADDR.reg          = addr;
    cd82:	eb0a 0305 	add.w	r3, sl, r5
    cd86:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    cd8a:	bf28      	it	cs
    cd8c:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
    cd90:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
}
    cd94:	e7d1      	b.n	cd3a <_usb_d_dev_in_next+0x86>
	} else if (ept->flags.bits.need_zlp) {
    cd96:	f01e 0f10 	tst.w	lr, #16
    cd9a:	d00e      	beq.n	cdba <_usb_d_dev_in_next+0x106>
		ept->flags.bits.need_zlp = 0;
    cd9c:	7ce3      	ldrb	r3, [r4, #19]
    cd9e:	f36f 1304 	bfc	r3, #4, #1
    cda2:	74e3      	strb	r3, [r4, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    cda4:	4b17      	ldr	r3, [pc, #92]	; (ce04 <_usb_d_dev_in_next+0x150>)
    cda6:	442b      	add	r3, r5
    cda8:	685a      	ldr	r2, [r3, #4]
    cdaa:	f36f 020d 	bfc	r2, #0, #14
    cdae:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    cdb0:	685a      	ldr	r2, [r3, #4]
    cdb2:	f36f 329b 	bfc	r2, #14, #14
    cdb6:	605a      	str	r2, [r3, #4]
		goto _in_tx_exec;
    cdb8:	e7cd      	b.n	cd56 <_usb_d_dev_in_next+0xa2>
	if (is_ctrl) {
    cdba:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cdbe:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
	if (last_pkt == ept->size) {
    cdc2:	ea0c 0c06 	and.w	ip, ip, r6
    cdc6:	bf0c      	ite	eq
    cdc8:	234b      	moveq	r3, #75	; 0x4b
    cdca:	234a      	movne	r3, #74	; 0x4a
    cdcc:	4562      	cmp	r2, ip
    cdce:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
    cdd2:	d10c      	bne.n	cdee <_usb_d_dev_in_next+0x13a>
		ept->flags.bits.is_busy = 0;
    cdd4:	7ce3      	ldrb	r3, [r4, #19]
    cdd6:	f36f 1386 	bfc	r3, #6, #1
    cdda:	74e3      	strb	r3, [r4, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    cddc:	4b0a      	ldr	r3, [pc, #40]	; (ce08 <_usb_d_dev_in_next+0x154>)
    cdde:	68db      	ldr	r3, [r3, #12]
    cde0:	4798      	blx	r3
    cde2:	2800      	cmp	r0, #0
    cde4:	d1c9      	bne.n	cd7a <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    cde6:	7ce3      	ldrb	r3, [r4, #19]
    cde8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    cdec:	74e3      	strb	r3, [r4, #19]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cdee:	4620      	mov	r0, r4
    cdf0:	4b06      	ldr	r3, [pc, #24]	; (ce0c <_usb_d_dev_in_next+0x158>)
}
    cdf2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cdf6:	2100      	movs	r1, #0
    cdf8:	4718      	bx	r3
    cdfa:	bf00      	nop
    cdfc:	20001428 	.word	0x20001428
    ce00:	00014041 	.word	0x00014041
    ce04:	20001438 	.word	0x20001438
    ce08:	200011f8 	.word	0x200011f8
    ce0c:	0000cb01 	.word	0x0000cb01

0000ce10 <_usb_d_dev_out_next>:
{
    ce10:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    ce14:	7c86      	ldrb	r6, [r0, #18]
    ce16:	f006 060f 	and.w	r6, r6, #15
{
    ce1a:	4604      	mov	r4, r0
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    ce1c:	460f      	mov	r7, r1
    ce1e:	0175      	lsls	r5, r6, #5
    ce20:	2900      	cmp	r1, #0
    ce22:	d060      	beq.n	cee6 <_usb_d_dev_out_next+0xd6>
    ce24:	4b5d      	ldr	r3, [pc, #372]	; (cf9c <_usb_d_dev_out_next+0x18c>)
    ce26:	442b      	add	r3, r5
    ce28:	685a      	ldr	r2, [r3, #4]
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    ce2a:	685b      	ldr	r3, [r3, #4]
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    ce2c:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    ce30:	f3c3 090d 	ubfx	r9, r3, #0, #14
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    ce34:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    ce38:	7ce2      	ldrb	r2, [r4, #19]
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    ce3a:	f240 33ff 	movw	r3, #1023	; 0x3ff
    ce3e:	4598      	cmp	r8, r3
    ce40:	bf1c      	itt	ne
    ce42:	f108 38ff 	addne.w	r8, r8, #4294967295	; 0xffffffff
    ce46:	fa1f f888 	uxthne.w	r8, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    ce4a:	f002 0307 	and.w	r3, r2, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    ce4e:	ea09 0b08 	and.w	fp, r9, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    ce52:	9301      	str	r3, [sp, #4]
	if (isr) {
    ce54:	b12f      	cbz	r7, ce62 <_usb_d_dev_out_next+0x52>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    ce56:	0173      	lsls	r3, r6, #5
    ce58:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    ce5c:	2101      	movs	r1, #1
    ce5e:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    ce62:	0690      	lsls	r0, r2, #26
    ce64:	d50c      	bpl.n	ce80 <_usb_d_dev_out_next+0x70>
    ce66:	6862      	ldr	r2, [r4, #4]
    ce68:	b152      	cbz	r2, ce80 <_usb_d_dev_out_next+0x70>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    ce6a:	68a0      	ldr	r0, [r4, #8]
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    ce6c:	6823      	ldr	r3, [r4, #0]
    ce6e:	68e1      	ldr	r1, [r4, #12]
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    ce70:	1a12      	subs	r2, r2, r0
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    ce72:	b292      	uxth	r2, r2
    ce74:	455a      	cmp	r2, fp
    ce76:	4418      	add	r0, r3
    ce78:	bf28      	it	cs
    ce7a:	465a      	movcs	r2, fp
    ce7c:	4b48      	ldr	r3, [pc, #288]	; (cfa0 <_usb_d_dev_out_next+0x190>)
    ce7e:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    ce80:	6863      	ldr	r3, [r4, #4]
    ce82:	2b00      	cmp	r3, #0
    ce84:	d132      	bne.n	ceec <_usb_d_dev_out_next+0xdc>
    ce86:	7ce2      	ldrb	r2, [r4, #19]
    ce88:	06d1      	lsls	r1, r2, #27
    ce8a:	d52f      	bpl.n	ceec <_usb_d_dev_out_next+0xdc>
	bank->ADDR.reg          = addr;
    ce8c:	4845      	ldr	r0, [pc, #276]	; (cfa4 <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    ce8e:	68e1      	ldr	r1, [r4, #12]
		ept->flags.bits.need_zlp  = 0;
    ce90:	f022 0230 	bic.w	r2, r2, #48	; 0x30
	bank->ADDR.reg          = addr;
    ce94:	4428      	add	r0, r5
		ept->flags.bits.need_zlp  = 0;
    ce96:	f042 0220 	orr.w	r2, r2, #32
    ce9a:	74e2      	strb	r2, [r4, #19]
	bank->ADDR.reg          = addr;
    ce9c:	f500 720c 	add.w	r2, r0, #560	; 0x230
    cea0:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    cea4:	6851      	ldr	r1, [r2, #4]
    cea6:	8a20      	ldrh	r0, [r4, #16]
    cea8:	f360 319b 	bfi	r1, r0, #14, #14
    ceac:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    ceae:	6851      	ldr	r1, [r2, #4]
    ceb0:	f363 010d 	bfi	r1, r3, #0, #14
    ceb4:	6051      	str	r1, [r2, #4]
	if (!isr) {
    ceb6:	b96f      	cbnz	r7, ced4 <_usb_d_dev_out_next+0xc4>
		if (is_ctrl) {
    ceb8:	9b01      	ldr	r3, [sp, #4]
    ceba:	2b01      	cmp	r3, #1
	bank->STATUS_BK.reg     = 0;
    cebc:	bf04      	itt	eq
    cebe:	4b39      	ldreq	r3, [pc, #228]	; (cfa4 <_usb_d_dev_out_next+0x194>)
    cec0:	195b      	addeq	r3, r3, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    cec2:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    cec6:	bf0a      	itet	eq
    cec8:	f883 724a 	strbeq.w	r7, [r3, #586]	; 0x24a
			inten = USB_D_BANK0_INT_FLAGS;
    cecc:	2325      	movne	r3, #37	; 0x25
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    cece:	232d      	moveq	r3, #45	; 0x2d
    ced0:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    ced4:	0176      	lsls	r6, r6, #5
    ced6:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
    ceda:	2340      	movs	r3, #64	; 0x40
    cedc:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
}
    cee0:	b003      	add	sp, #12
    cee2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    cee6:	468a      	mov	sl, r1
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    cee8:	4689      	mov	r9, r1
    ceea:	e7a3      	b.n	ce34 <_usb_d_dev_out_next+0x24>
	} else if (isr && last_pkt < ept->size) {
    ceec:	68a1      	ldr	r1, [r4, #8]
    ceee:	b1ef      	cbz	r7, cf2c <_usb_d_dev_out_next+0x11c>
    cef0:	8a22      	ldrh	r2, [r4, #16]
    cef2:	455a      	cmp	r2, fp
    cef4:	d91a      	bls.n	cf2c <_usb_d_dev_out_next+0x11c>
		ept->flags.bits.need_zlp = 0;
    cef6:	7ce3      	ldrb	r3, [r4, #19]
		ept->trans_count += last_trans;
    cef8:	4449      	add	r1, r9
		ept->flags.bits.need_zlp = 0;
    cefa:	f36f 1304 	bfc	r3, #4, #1
    cefe:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    cf00:	60a1      	str	r1, [r4, #8]
	if (is_ctrl) {
    cf02:	9b01      	ldr	r3, [sp, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cf04:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    cf08:	2b01      	cmp	r3, #1
    cf0a:	bf0c      	ite	eq
    cf0c:	232d      	moveq	r3, #45	; 0x2d
    cf0e:	2325      	movne	r3, #37	; 0x25
    cf10:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
	if (0 == epn) {
    cf14:	b91e      	cbnz	r6, cf1e <_usb_d_dev_out_next+0x10e>
	bank->ADDR.reg          = addr;
    cf16:	4b23      	ldr	r3, [pc, #140]	; (cfa4 <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    cf18:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    cf1a:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cf1e:	4b22      	ldr	r3, [pc, #136]	; (cfa8 <_usb_d_dev_out_next+0x198>)
    cf20:	2100      	movs	r1, #0
    cf22:	4620      	mov	r0, r4
}
    cf24:	b003      	add	sp, #12
    cf26:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    cf2a:	4718      	bx	r3
		ept->trans_count += trans_size;
    cf2c:	4451      	add	r1, sl
		if (ept->trans_count < ept->trans_size) {
    cf2e:	428b      	cmp	r3, r1
		ept->trans_count += trans_size;
    cf30:	60a1      	str	r1, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    cf32:	d9e6      	bls.n	cf02 <_usb_d_dev_out_next+0xf2>
			if (ept->flags.bits.use_cache) {
    cf34:	7ce0      	ldrb	r0, [r4, #19]
    cf36:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    cf3a:	4a1a      	ldr	r2, [pc, #104]	; (cfa4 <_usb_d_dev_out_next+0x194>)
			trans_next = ept->trans_size - ept->trans_count;
    cf3c:	1a5b      	subs	r3, r3, r1
			if (ept->flags.bits.use_cache) {
    cf3e:	f010 0f20 	tst.w	r0, #32
			trans_next = ept->trans_size - ept->trans_count;
    cf42:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    cf44:	d014      	beq.n	cf70 <_usb_d_dev_out_next+0x160>
	bank->ADDR.reg          = addr;
    cf46:	1951      	adds	r1, r2, r5
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    cf48:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    cf4a:	f8c1 0230 	str.w	r0, [r1, #560]	; 0x230
    cf4e:	4563      	cmp	r3, ip
    cf50:	bf28      	it	cs
    cf52:	4663      	movcs	r3, ip
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    cf54:	442a      	add	r2, r5
    cf56:	f8d2 1234 	ldr.w	r1, [r2, #564]	; 0x234
    cf5a:	f363 319b 	bfi	r1, r3, #14, #14
    cf5e:	f8c2 1234 	str.w	r1, [r2, #564]	; 0x234
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    cf62:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
    cf66:	f36f 030d 	bfc	r3, #0, #14
    cf6a:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
			goto _out_rx_exec;
    cf6e:	e7a2      	b.n	ceb6 <_usb_d_dev_out_next+0xa6>
				if (trans_next > ept->size) {
    cf70:	4563      	cmp	r3, ip
    cf72:	d90a      	bls.n	cf8a <_usb_d_dev_out_next+0x17a>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    cf74:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    cf78:	d80c      	bhi.n	cf94 <_usb_d_dev_out_next+0x184>
						trans_next -= trans_next & size_mask;
    cf7a:	ea23 0308 	bic.w	r3, r3, r8
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    cf7e:	6820      	ldr	r0, [r4, #0]
    cf80:	4401      	add	r1, r0
	bank->ADDR.reg          = addr;
    cf82:	1950      	adds	r0, r2, r5
    cf84:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
}
    cf88:	e7e4      	b.n	cf54 <_usb_d_dev_out_next+0x144>
				} else if (trans_next < ept->size) {
    cf8a:	d2f8      	bcs.n	cf7e <_usb_d_dev_out_next+0x16e>
					ept->flags.bits.use_cache = 1;
    cf8c:	f040 0020 	orr.w	r0, r0, #32
    cf90:	74e0      	strb	r0, [r4, #19]
    cf92:	e7f4      	b.n	cf7e <_usb_d_dev_out_next+0x16e>
						trans_next = USB_D_DEV_TRANS_MAX;
    cf94:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    cf98:	e7f1      	b.n	cf7e <_usb_d_dev_out_next+0x16e>
    cf9a:	bf00      	nop
    cf9c:	20001428 	.word	0x20001428
    cfa0:	00014041 	.word	0x00014041
    cfa4:	200011f8 	.word	0x200011f8
    cfa8:	0000cb01 	.word	0x0000cb01

0000cfac <_usb_d_dev_handler>:
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    cfac:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
{
    cfb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    cfb4:	8c1f      	ldrh	r7, [r3, #32]
    cfb6:	4d69      	ldr	r5, [pc, #420]	; (d15c <_usb_d_dev_handler+0x1b0>)
    cfb8:	b2bf      	uxth	r7, r7
	if (0 == epint) {
    cfba:	2f00      	cmp	r7, #0
    cfbc:	d163      	bne.n	d086 <_usb_d_dev_handler+0xda>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    cfbe:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    cfc0:	8b1a      	ldrh	r2, [r3, #24]
    cfc2:	b292      	uxth	r2, r2
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    cfc4:	400a      	ands	r2, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    cfc6:	f012 0004 	ands.w	r0, r2, #4
    cfca:	d005      	beq.n	cfd8 <_usb_d_dev_handler+0x2c>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    cfcc:	2204      	movs	r2, #4
    cfce:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    cfd0:	682b      	ldr	r3, [r5, #0]
}
    cfd2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.sof();
    cfd6:	4718      	bx	r3
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    cfd8:	f412 7100 	ands.w	r1, r2, #512	; 0x200
    cfdc:	d01f      	beq.n	d01e <_usb_d_dev_handler+0x72>
    cfde:	f240 2201 	movw	r2, #513	; 0x201
    cfe2:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    cfe4:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    cfe6:	2270      	movs	r2, #112	; 0x70
    cfe8:	831a      	strh	r2, [r3, #24]
    cfea:	4603      	mov	r3, r0
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    cfec:	eb05 1243 	add.w	r2, r5, r3, lsl #5
    cff0:	f502 700e 	add.w	r0, r2, #568	; 0x238
    cff4:	f8b2 2238 	ldrh.w	r2, [r2, #568]	; 0x238
    cff8:	f002 020f 	and.w	r2, r2, #15
    cffc:	2a03      	cmp	r2, #3
    cffe:	d109      	bne.n	d014 <_usb_d_dev_handler+0x68>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d000:	8801      	ldrh	r1, [r0, #0]
			bank->EXTREG.reg = 0;
    d002:	2300      	movs	r3, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d004:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    d008:	8003      	strh	r3, [r0, #0]
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    d00a:	686b      	ldr	r3, [r5, #4]
    d00c:	2003      	movs	r0, #3
}
    d00e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d012:	4718      	bx	r3
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    d014:	3301      	adds	r3, #1
    d016:	2b05      	cmp	r3, #5
    d018:	d1e8      	bne.n	cfec <_usb_d_dev_handler+0x40>
	uint32_t lpm_variable = 0;
    d01a:	2100      	movs	r1, #0
    d01c:	e7f5      	b.n	d00a <_usb_d_dev_handler+0x5e>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    d01e:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    d022:	d004      	beq.n	d02e <_usb_d_dev_handler+0x82>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d024:	2280      	movs	r2, #128	; 0x80
    d026:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    d028:	2005      	movs	r0, #5
    d02a:	686b      	ldr	r3, [r5, #4]
    d02c:	e7ef      	b.n	d00e <_usb_d_dev_handler+0x62>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    d02e:	f012 0470 	ands.w	r4, r2, #112	; 0x70
    d032:	d00b      	beq.n	d04c <_usb_d_dev_handler+0xa0>
    d034:	2270      	movs	r2, #112	; 0x70
    d036:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d038:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d03a:	f240 2201 	movw	r2, #513	; 0x201
    d03e:	831a      	strh	r2, [r3, #24]
		_usb_d_dev_wait_dfll_rdy();
    d040:	4b47      	ldr	r3, [pc, #284]	; (d160 <_usb_d_dev_handler+0x1b4>)
    d042:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    d044:	686b      	ldr	r3, [r5, #4]
    d046:	4601      	mov	r1, r0
    d048:	2002      	movs	r0, #2
    d04a:	e7e0      	b.n	d00e <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    d04c:	f012 0108 	ands.w	r1, r2, #8
    d050:	d00e      	beq.n	d070 <_usb_d_dev_handler+0xc4>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d052:	2208      	movs	r2, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d054:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d058:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d05a:	2270      	movs	r2, #112	; 0x70
    d05c:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d05e:	f240 2201 	movw	r2, #513	; 0x201
    d062:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    d064:	4b3f      	ldr	r3, [pc, #252]	; (d164 <_usb_d_dev_handler+0x1b8>)
    d066:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    d068:	686b      	ldr	r3, [r5, #4]
    d06a:	4621      	mov	r1, r4
    d06c:	2001      	movs	r0, #1
    d06e:	e7ce      	b.n	d00e <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    d070:	07d0      	lsls	r0, r2, #31
    d072:	d508      	bpl.n	d086 <_usb_d_dev_handler+0xda>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d074:	f240 2201 	movw	r2, #513	; 0x201
    d078:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d07a:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d07c:	2270      	movs	r2, #112	; 0x70
    d07e:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d080:	2004      	movs	r0, #4
    d082:	686b      	ldr	r3, [r5, #4]
    d084:	e7c3      	b.n	d00e <_usb_d_dev_handler+0x62>
    d086:	4c35      	ldr	r4, [pc, #212]	; (d15c <_usb_d_dev_handler+0x1b0>)
			_usb_d_dev_handle_setup(ept);
    d088:	f8df 90e4 	ldr.w	r9, [pc, #228]	; d170 <_usb_d_dev_handler+0x1c4>
			_usb_d_dev_handle_trfail(ept, 1);
    d08c:	f8df 80e4 	ldr.w	r8, [pc, #228]	; d174 <_usb_d_dev_handler+0x1c8>
		_usb_d_dev_out_next(ept, true);
    d090:	f8df a0e4 	ldr.w	sl, [pc, #228]	; d178 <_usb_d_dev_handler+0x1cc>
	uint32_t lpm_variable = 0;
    d094:	2600      	movs	r6, #0
		if (ept->ep == 0xFF) {
    d096:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
    d09a:	2aff      	cmp	r2, #255	; 0xff
    d09c:	f104 0414 	add.w	r4, r4, #20
    d0a0:	d029      	beq.n	d0f6 <_usb_d_dev_handler+0x14a>
	if (!(epint & (1u << epn))) {
    d0a2:	f002 020f 	and.w	r2, r2, #15
    d0a6:	2101      	movs	r1, #1
    d0a8:	fa01 f302 	lsl.w	r3, r1, r2
    d0ac:	423b      	tst	r3, r7
    d0ae:	d022      	beq.n	d0f6 <_usb_d_dev_handler+0x14a>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d0b0:	0153      	lsls	r3, r2, #5
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d0b2:	0152      	lsls	r2, r2, #5
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d0b4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d0b8:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d0bc:	f893 0107 	ldrb.w	r0, [r3, #263]	; 0x107
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d0c0:	f892 3109 	ldrb.w	r3, [r2, #265]	; 0x109
	if (flags) {
    d0c4:	4003      	ands	r3, r0
    d0c6:	d016      	beq.n	d0f6 <_usb_d_dev_handler+0x14a>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    d0c8:	2214      	movs	r2, #20
    d0ca:	fb02 5206 	mla	r2, r2, r6, r5
    d0ce:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
    d0d2:	f002 0047 	and.w	r0, r2, #71	; 0x47
    d0d6:	4288      	cmp	r0, r1
    d0d8:	d112      	bne.n	d100 <_usb_d_dev_handler+0x154>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d0da:	06da      	lsls	r2, r3, #27
    d0dc:	d502      	bpl.n	d0e4 <_usb_d_dev_handler+0x138>
			_usb_d_dev_handle_setup(ept);
    d0de:	4620      	mov	r0, r4
    d0e0:	47c8      	blx	r9
    d0e2:	e008      	b.n	d0f6 <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d0e4:	f013 0140 	ands.w	r1, r3, #64	; 0x40
    d0e8:	d003      	beq.n	d0f2 <_usb_d_dev_handler+0x146>
		_usb_d_dev_handle_stall(ept, 1);
    d0ea:	4601      	mov	r1, r0
		_usb_d_dev_handle_stall(ept, 0);
    d0ec:	4b1e      	ldr	r3, [pc, #120]	; (d168 <_usb_d_dev_handler+0x1bc>)
    d0ee:	4620      	mov	r0, r4
    d0f0:	e013      	b.n	d11a <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d0f2:	069b      	lsls	r3, r3, #26
    d0f4:	d4fa      	bmi.n	d0ec <_usb_d_dev_handler+0x140>
	for (i = 0; i < USB_D_N_EP; i++) {
    d0f6:	3601      	adds	r6, #1
    d0f8:	2e1b      	cmp	r6, #27
    d0fa:	d1cc      	bne.n	d096 <_usb_d_dev_handler+0xea>
}
    d0fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (_usb_d_dev_ep_is_in(ept)) {
    d100:	0610      	lsls	r0, r2, #24
    d102:	d514      	bpl.n	d12e <_usb_d_dev_handler+0x182>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d104:	0658      	lsls	r0, r3, #25
    d106:	d4f1      	bmi.n	d0ec <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d108:	0718      	lsls	r0, r3, #28
    d10a:	d502      	bpl.n	d112 <_usb_d_dev_handler+0x166>
			_usb_d_dev_handle_trfail(ept, 1);
    d10c:	4620      	mov	r0, r4
    d10e:	47c0      	blx	r8
    d110:	e7f1      	b.n	d0f6 <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    d112:	0798      	lsls	r0, r3, #30
    d114:	d503      	bpl.n	d11e <_usb_d_dev_handler+0x172>
		_usb_d_dev_in_next(ept, true);
    d116:	4b15      	ldr	r3, [pc, #84]	; (d16c <_usb_d_dev_handler+0x1c0>)
    d118:	4620      	mov	r0, r4
		_usb_d_dev_handle_stall(ept, 0);
    d11a:	4798      	blx	r3
    d11c:	e7eb      	b.n	d0f6 <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d11e:	f002 0207 	and.w	r2, r2, #7
    d122:	2a01      	cmp	r2, #1
    d124:	d1e7      	bne.n	d0f6 <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d126:	075a      	lsls	r2, r3, #29
    d128:	d515      	bpl.n	d156 <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 0);
    d12a:	2100      	movs	r1, #0
    d12c:	e7ee      	b.n	d10c <_usb_d_dev_handler+0x160>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d12e:	f013 0020 	ands.w	r0, r3, #32
    d132:	d001      	beq.n	d138 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    d134:	2100      	movs	r1, #0
    d136:	e7d9      	b.n	d0ec <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d138:	0758      	lsls	r0, r3, #29
    d13a:	d4f6      	bmi.n	d12a <_usb_d_dev_handler+0x17e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    d13c:	07d8      	lsls	r0, r3, #31
    d13e:	d502      	bpl.n	d146 <_usb_d_dev_handler+0x19a>
		_usb_d_dev_out_next(ept, true);
    d140:	4620      	mov	r0, r4
    d142:	47d0      	blx	sl
    d144:	e7d7      	b.n	d0f6 <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d146:	f002 0207 	and.w	r2, r2, #7
    d14a:	2a01      	cmp	r2, #1
    d14c:	d1d3      	bne.n	d0f6 <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d14e:	071a      	lsls	r2, r3, #28
    d150:	d501      	bpl.n	d156 <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 1);
    d152:	2101      	movs	r1, #1
    d154:	e7da      	b.n	d10c <_usb_d_dev_handler+0x160>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d156:	06db      	lsls	r3, r3, #27
    d158:	d5cd      	bpl.n	d0f6 <_usb_d_dev_handler+0x14a>
    d15a:	e7c0      	b.n	d0de <_usb_d_dev_handler+0x132>
    d15c:	200011f8 	.word	0x200011f8
    d160:	0000ca11 	.word	0x0000ca11
    d164:	0000cc75 	.word	0x0000cc75
    d168:	0000cad1 	.word	0x0000cad1
    d16c:	0000ccb5 	.word	0x0000ccb5
    d170:	0000ca4d 	.word	0x0000ca4d
    d174:	0000cb8d 	.word	0x0000cb8d
    d178:	0000ce11 	.word	0x0000ce11

0000d17c <_usbd_ep_pcksize_size>:
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    d17c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    d180:	d80f      	bhi.n	d1a2 <_usbd_ep_pcksize_size+0x26>
    d182:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    d186:	d80e      	bhi.n	d1a6 <_usbd_ep_pcksize_size+0x2a>
    d188:	2880      	cmp	r0, #128	; 0x80
    d18a:	d80e      	bhi.n	d1aa <_usbd_ep_pcksize_size+0x2e>
    d18c:	2840      	cmp	r0, #64	; 0x40
    d18e:	d80e      	bhi.n	d1ae <_usbd_ep_pcksize_size+0x32>
    d190:	2820      	cmp	r0, #32
    d192:	d80e      	bhi.n	d1b2 <_usbd_ep_pcksize_size+0x36>
    d194:	2810      	cmp	r0, #16
    d196:	d80e      	bhi.n	d1b6 <_usbd_ep_pcksize_size+0x3a>
    d198:	2808      	cmp	r0, #8
    d19a:	bf94      	ite	ls
    d19c:	2000      	movls	r0, #0
    d19e:	2001      	movhi	r0, #1
    d1a0:	4770      	bx	lr
    d1a2:	2007      	movs	r0, #7
    d1a4:	4770      	bx	lr
    d1a6:	2006      	movs	r0, #6
    d1a8:	4770      	bx	lr
    d1aa:	2005      	movs	r0, #5
    d1ac:	4770      	bx	lr
    d1ae:	2004      	movs	r0, #4
    d1b0:	4770      	bx	lr
    d1b2:	2003      	movs	r0, #3
    d1b4:	4770      	bx	lr
    d1b6:	2002      	movs	r0, #2
}
    d1b8:	4770      	bx	lr
	...

0000d1bc <_usb_d_dev_init>:
{
    d1bc:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    d1be:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d1c2:	789a      	ldrb	r2, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    d1c4:	07d0      	lsls	r0, r2, #31
    d1c6:	d41a      	bmi.n	d1fe <_usb_d_dev_init+0x42>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d1c8:	789a      	ldrb	r2, [r3, #2]
    d1ca:	0791      	lsls	r1, r2, #30
    d1cc:	d1fc      	bne.n	d1c8 <_usb_d_dev_init+0xc>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    d1ce:	781a      	ldrb	r2, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    d1d0:	0792      	lsls	r2, r2, #30
    d1d2:	d50d      	bpl.n	d1f0 <_usb_d_dev_init+0x34>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    d1d4:	781a      	ldrb	r2, [r3, #0]
    d1d6:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    d1da:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d1dc:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d1e0:	7893      	ldrb	r3, [r2, #2]
    d1e2:	0798      	lsls	r0, r3, #30
    d1e4:	d1fc      	bne.n	d1e0 <_usb_d_dev_init+0x24>
    d1e6:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d1ea:	7893      	ldrb	r3, [r2, #2]
    d1ec:	0799      	lsls	r1, r3, #30
    d1ee:	d4fc      	bmi.n	d1ea <_usb_d_dev_init+0x2e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d1f0:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d1f4:	2201      	movs	r2, #1
    d1f6:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d1f8:	789a      	ldrb	r2, [r3, #2]
    d1fa:	0792      	lsls	r2, r2, #30
    d1fc:	d1fc      	bne.n	d1f8 <_usb_d_dev_init+0x3c>
    d1fe:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d202:	7893      	ldrb	r3, [r2, #2]
    d204:	07db      	lsls	r3, r3, #31
    d206:	d4fc      	bmi.n	d202 <_usb_d_dev_init+0x46>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    d208:	4a1e      	ldr	r2, [pc, #120]	; (d284 <_usb_d_dev_init+0xc8>)
    d20a:	4b1f      	ldr	r3, [pc, #124]	; (d288 <_usb_d_dev_init+0xcc>)
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    d20c:	e9c3 2200 	strd	r2, r2, [r3]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    d210:	e9c3 2202 	strd	r2, r2, [r3, #8]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    d214:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    d216:	4b1d      	ldr	r3, [pc, #116]	; (d28c <_usb_d_dev_init+0xd0>)
    d218:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    d21a:	4b1d      	ldr	r3, [pc, #116]	; (d290 <_usb_d_dev_init+0xd4>)
    d21c:	681a      	ldr	r2, [r3, #0]
	uint32_t pad_transp
    d21e:	f3c2 1344 	ubfx	r3, r2, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    d222:	f3c2 2182 	ubfx	r1, r2, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    d226:	f012 021f 	ands.w	r2, r2, #31
    d22a:	d025      	beq.n	d278 <_usb_d_dev_init+0xbc>
		pad_transn = 9;
    d22c:	2a1f      	cmp	r2, #31
    d22e:	bf08      	it	eq
    d230:	2209      	moveq	r2, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    d232:	b31b      	cbz	r3, d27c <_usb_d_dev_init+0xc0>
		pad_transp = 25;
    d234:	2b1f      	cmp	r3, #31
    d236:	bf08      	it	eq
    d238:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    d23a:	b309      	cbz	r1, d280 <_usb_d_dev_init+0xc4>
		pad_trim = 6;
    d23c:	2907      	cmp	r1, #7
    d23e:	bf08      	it	eq
    d240:	2106      	moveq	r1, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    d242:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    d246:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    d24a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d24e:	b29b      	uxth	r3, r3
    d250:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    d252:	78d3      	ldrb	r3, [r2, #3]
    d254:	f043 0303 	orr.w	r3, r3, #3
    d258:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    d25a:	78d3      	ldrb	r3, [r2, #3]
    d25c:	f043 030c 	orr.w	r3, r3, #12
    d260:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d262:	2304      	movs	r3, #4
    d264:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d266:	7890      	ldrb	r0, [r2, #2]
    d268:	f010 0003 	ands.w	r0, r0, #3
    d26c:	d1fb      	bne.n	d266 <_usb_d_dev_init+0xaa>
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    d26e:	4b09      	ldr	r3, [pc, #36]	; (d294 <_usb_d_dev_init+0xd8>)
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    d270:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    d272:	2301      	movs	r3, #1
    d274:	8113      	strh	r3, [r2, #8]
}
    d276:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    d278:	2209      	movs	r2, #9
    d27a:	e7da      	b.n	d232 <_usb_d_dev_init+0x76>
		pad_transp = 25;
    d27c:	2319      	movs	r3, #25
    d27e:	e7dc      	b.n	d23a <_usb_d_dev_init+0x7e>
		pad_trim = 6;
    d280:	2106      	movs	r1, #6
    d282:	e7de      	b.n	d242 <_usb_d_dev_init+0x86>
    d284:	0000ca0d 	.word	0x0000ca0d
    d288:	200011f8 	.word	0x200011f8
    d28c:	0000cc75 	.word	0x0000cc75
    d290:	00800084 	.word	0x00800084
    d294:	20001428 	.word	0x20001428

0000d298 <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    d298:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d29c:	789a      	ldrb	r2, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    d29e:	0792      	lsls	r2, r2, #30
    d2a0:	d122      	bne.n	d2e8 <_usb_d_dev_enable+0x50>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d2a2:	789a      	ldrb	r2, [r3, #2]
    d2a4:	0790      	lsls	r0, r2, #30
    d2a6:	d1fc      	bne.n	d2a2 <_usb_d_dev_enable+0xa>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    d2a8:	7819      	ldrb	r1, [r3, #0]
    d2aa:	b2ca      	uxtb	r2, r1
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    d2ac:	0789      	lsls	r1, r1, #30
    d2ae:	d407      	bmi.n	d2c0 <_usb_d_dev_enable+0x28>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    d2b0:	f042 0202 	orr.w	r2, r2, #2
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d2b4:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d2b6:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d2ba:	7893      	ldrb	r3, [r2, #2]
    d2bc:	079b      	lsls	r3, r3, #30
    d2be:	d1fc      	bne.n	d2ba <_usb_d_dev_enable+0x22>
    d2c0:	4b0b      	ldr	r3, [pc, #44]	; (d2f0 <_usb_d_dev_enable+0x58>)
    d2c2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    d2c6:	609a      	str	r2, [r3, #8]
    d2c8:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    d2cc:	609a      	str	r2, [r3, #8]
    d2ce:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    d2d2:	609a      	str	r2, [r3, #8]
    d2d4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    d2d8:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d2da:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d2de:	f240 228d 	movw	r2, #653	; 0x28d
    d2e2:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    d2e4:	2000      	movs	r0, #0
    d2e6:	4770      	bx	lr
		return -USB_ERR_DENIED;
    d2e8:	f06f 0010 	mvn.w	r0, #16
}
    d2ec:	4770      	bx	lr
    d2ee:	bf00      	nop
    d2f0:	e000e100 	.word	0xe000e100

0000d2f4 <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    d2f4:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d2f8:	8913      	ldrh	r3, [r2, #8]
    d2fa:	f023 0301 	bic.w	r3, r3, #1
    d2fe:	041b      	lsls	r3, r3, #16
    d300:	0c1b      	lsrs	r3, r3, #16
    d302:	8113      	strh	r3, [r2, #8]
}
    d304:	4770      	bx	lr

0000d306 <_usb_d_dev_set_address>:
	((Usb *)hw)->DEVICE.DADD.reg = data;
    d306:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    d30a:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    d30e:	7298      	strb	r0, [r3, #10]
}
    d310:	4770      	bx	lr

0000d312 <_usb_d_dev_get_frame_n>:
	return (((Usb *)hw)->DEVICE.FNUM.reg & USB_DEVICE_FNUM_FNUM_Msk) >> USB_DEVICE_FNUM_FNUM_Pos;
    d312:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d316:	8a18      	ldrh	r0, [r3, #16]
}
    d318:	f3c0 00ca 	ubfx	r0, r0, #3, #11
    d31c:	4770      	bx	lr
	...

0000d320 <_usb_d_dev_ep_init>:
{
    d320:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d324:	f000 040f 	and.w	r4, r0, #15
{
    d328:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d32a:	f8df 90b0 	ldr.w	r9, [pc, #176]	; d3dc <_usb_d_dev_ep_init+0xbc>
    d32e:	09c1      	lsrs	r1, r0, #7
{
    d330:	4607      	mov	r7, r0
    d332:	fa4f f880 	sxtb.w	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d336:	4620      	mov	r0, r4
    d338:	47c8      	blx	r9
	if (epn > CONF_USB_D_MAX_EP_N) {
    d33a:	2c05      	cmp	r4, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d33c:	4606      	mov	r6, r0
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    d33e:	f005 0503 	and.w	r5, r5, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d342:	d83f      	bhi.n	d3c4 <_usb_d_dev_ep_init+0xa4>
	if (ept->ep != 0xFF) {
    d344:	7c83      	ldrb	r3, [r0, #18]
    d346:	2bff      	cmp	r3, #255	; 0xff
    d348:	d13f      	bne.n	d3ca <_usb_d_dev_ep_init+0xaa>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    d34a:	b985      	cbnz	r5, d36e <_usb_d_dev_ep_init+0x4e>
		struct _usb_d_dev_ep *ept_in = _usb_d_dev_ept(epn, !dir);
    d34c:	ea6f 0108 	mvn.w	r1, r8
    d350:	0fc9      	lsrs	r1, r1, #31
    d352:	4620      	mov	r0, r4
    d354:	47c8      	blx	r9
		if (ept_in->ep != 0xFF) {
    d356:	7c83      	ldrb	r3, [r0, #18]
    d358:	2bff      	cmp	r3, #255	; 0xff
    d35a:	d136      	bne.n	d3ca <_usb_d_dev_ep_init+0xaa>
		if (pcfg->cache == NULL) {
    d35c:	230c      	movs	r3, #12
    d35e:	491e      	ldr	r1, [pc, #120]	; (d3d8 <_usb_d_dev_ep_init+0xb8>)
    d360:	4363      	muls	r3, r4
    d362:	58cb      	ldr	r3, [r1, r3]
    d364:	2b00      	cmp	r3, #0
    d366:	d133      	bne.n	d3d0 <_usb_d_dev_ep_init+0xb0>
			return -USB_ERR_FUNC;
    d368:	f06f 0012 	mvn.w	r0, #18
    d36c:	e018      	b.n	d3a0 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d36e:	f1b8 0f00 	cmp.w	r8, #0
    d372:	da17      	bge.n	d3a4 <_usb_d_dev_ep_init+0x84>
    d374:	4918      	ldr	r1, [pc, #96]	; (d3d8 <_usb_d_dev_ep_init+0xb8>)
    d376:	230c      	movs	r3, #12
    d378:	fb03 1304 	mla	r3, r3, r4, r1
    d37c:	6859      	ldr	r1, [r3, #4]
    d37e:	b9e9      	cbnz	r1, d3bc <_usb_d_dev_ep_init+0x9c>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d380:	4915      	ldr	r1, [pc, #84]	; (d3d8 <_usb_d_dev_ep_init+0xb8>)
	ept->size     = max_pkt_siz;
    d382:	8232      	strh	r2, [r6, #16]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d384:	230c      	movs	r3, #12
    d386:	435c      	muls	r4, r3
    d388:	190b      	adds	r3, r1, r4
    d38a:	5909      	ldr	r1, [r1, r4]
    d38c:	685b      	ldr	r3, [r3, #4]
	ept->ep       = ep;
    d38e:	74b7      	strb	r7, [r6, #18]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d390:	ea13 0328 	ands.w	r3, r3, r8, asr #32
    d394:	bf38      	it	cc
    d396:	460b      	movcc	r3, r1
	ept->flags.u8 = (ep_type + 1);
    d398:	3501      	adds	r5, #1
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d39a:	60f3      	str	r3, [r6, #12]
	ept->flags.u8 = (ep_type + 1);
    d39c:	74f5      	strb	r5, [r6, #19]
	return USB_OK;
    d39e:	2000      	movs	r0, #0
}
    d3a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d3a4:	230c      	movs	r3, #12
    d3a6:	490c      	ldr	r1, [pc, #48]	; (d3d8 <_usb_d_dev_ep_init+0xb8>)
    d3a8:	4363      	muls	r3, r4
    d3aa:	58cb      	ldr	r3, [r1, r3]
    d3ac:	2b00      	cmp	r3, #0
    d3ae:	d0e7      	beq.n	d380 <_usb_d_dev_ep_init+0x60>
    d3b0:	4909      	ldr	r1, [pc, #36]	; (d3d8 <_usb_d_dev_ep_init+0xb8>)
    d3b2:	230c      	movs	r3, #12
    d3b4:	fb03 1304 	mla	r3, r3, r4, r1
    d3b8:	891b      	ldrh	r3, [r3, #8]
    d3ba:	e000      	b.n	d3be <_usb_d_dev_ep_init+0x9e>
    d3bc:	895b      	ldrh	r3, [r3, #10]
    d3be:	429a      	cmp	r2, r3
    d3c0:	ddde      	ble.n	d380 <_usb_d_dev_ep_init+0x60>
    d3c2:	e7d1      	b.n	d368 <_usb_d_dev_ep_init+0x48>
		return -USB_ERR_PARAM;
    d3c4:	f06f 0011 	mvn.w	r0, #17
    d3c8:	e7ea      	b.n	d3a0 <_usb_d_dev_ep_init+0x80>
		return -USB_ERR_REDO;
    d3ca:	f06f 0013 	mvn.w	r0, #19
    d3ce:	e7e7      	b.n	d3a0 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d3d0:	f1b8 0f00 	cmp.w	r8, #0
    d3d4:	daec      	bge.n	d3b0 <_usb_d_dev_ep_init+0x90>
    d3d6:	e7cd      	b.n	d374 <_usb_d_dev_ep_init+0x54>
    d3d8:	00016f94 	.word	0x00016f94
    d3dc:	0000ca35 	.word	0x0000ca35

0000d3e0 <_usb_d_dev_ep_deinit>:
{
    d3e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d3e2:	f000 050f 	and.w	r5, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d3e6:	2d05      	cmp	r5, #5
{
    d3e8:	4604      	mov	r4, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d3ea:	d818      	bhi.n	d41e <_usb_d_dev_ep_deinit+0x3e>
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d3ec:	4b17      	ldr	r3, [pc, #92]	; (d44c <_usb_d_dev_ep_deinit+0x6c>)
	bool                  dir = USB_EP_GET_DIR(ep);
    d3ee:	09c1      	lsrs	r1, r0, #7
    d3f0:	b247      	sxtb	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d3f2:	4628      	mov	r0, r5
    d3f4:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d3f6:	7c83      	ldrb	r3, [r0, #18]
    d3f8:	2bff      	cmp	r3, #255	; 0xff
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d3fa:	4606      	mov	r6, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d3fc:	d00f      	beq.n	d41e <_usb_d_dev_ep_deinit+0x3e>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    d3fe:	4b14      	ldr	r3, [pc, #80]	; (d450 <_usb_d_dev_ep_deinit+0x70>)
    d400:	2203      	movs	r2, #3
    d402:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d404:	7cf3      	ldrb	r3, [r6, #19]
    d406:	f003 0307 	and.w	r3, r3, #7
    d40a:	2b01      	cmp	r3, #1
    d40c:	d108      	bne.n	d420 <_usb_d_dev_ep_deinit+0x40>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    d40e:	0164      	lsls	r4, r4, #5
    d410:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d414:	2300      	movs	r3, #0
    d416:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	ept->ep       = 0xFF;
    d41a:	23ff      	movs	r3, #255	; 0xff
    d41c:	8273      	strh	r3, [r6, #18]
}
    d41e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (USB_EP_GET_DIR(ep)) {
    d420:	2f00      	cmp	r7, #0
    d422:	da09      	bge.n	d438 <_usb_d_dev_ep_deinit+0x58>
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    d424:	016b      	lsls	r3, r5, #5
    d426:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d42a:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    d42e:	f002 028f 	and.w	r2, r2, #143	; 0x8f
    d432:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    d436:	e7f0      	b.n	d41a <_usb_d_dev_ep_deinit+0x3a>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    d438:	0164      	lsls	r4, r4, #5
    d43a:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d43e:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
    d442:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    d446:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
    d44a:	e7e6      	b.n	d41a <_usb_d_dev_ep_deinit+0x3a>
    d44c:	0000ca35 	.word	0x0000ca35
    d450:	0000cb2d 	.word	0x0000cb2d

0000d454 <_usb_d_dev_ep_enable>:
{
    d454:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    d458:	f000 050f 	and.w	r5, r0, #15
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d45c:	09c1      	lsrs	r1, r0, #7
    d45e:	4b55      	ldr	r3, [pc, #340]	; (d5b4 <_usb_d_dev_ep_enable+0x160>)
    d460:	fa4f f980 	sxtb.w	r9, r0
    d464:	4628      	mov	r0, r5
    d466:	4798      	blx	r3
    d468:	ea4f 1c45 	mov.w	ip, r5, lsl #5
    d46c:	f10c 4682 	add.w	r6, ip, #1090519040	; 0x41000000
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d470:	2d05      	cmp	r5, #5
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d472:	f896 1100 	ldrb.w	r1, [r6, #256]	; 0x100
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d476:	4607      	mov	r7, r0
    d478:	b2c8      	uxtb	r0, r1
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d47a:	f200 8094 	bhi.w	d5a6 <_usb_d_dev_ep_enable+0x152>
    d47e:	7cba      	ldrb	r2, [r7, #18]
    d480:	2aff      	cmp	r2, #255	; 0xff
    d482:	f000 8090 	beq.w	d5a6 <_usb_d_dev_ep_enable+0x152>
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d486:	7cf9      	ldrb	r1, [r7, #19]
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d488:	4c4b      	ldr	r4, [pc, #300]	; (d5b8 <_usb_d_dev_ep_enable+0x164>)
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d48a:	f001 0307 	and.w	r3, r1, #7
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d48e:	f504 780c 	add.w	r8, r4, #560	; 0x230
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d492:	2b01      	cmp	r3, #1
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d494:	44e0      	add	r8, ip
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d496:	d147      	bne.n	d528 <_usb_d_dev_ep_enable+0xd4>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    d498:	f010 0377 	ands.w	r3, r0, #119	; 0x77
    d49c:	f040 8086 	bne.w	d5ac <_usb_d_dev_ep_enable+0x158>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d4a0:	f8b7 9010 	ldrh.w	r9, [r7, #16]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d4a4:	2111      	movs	r1, #17
    d4a6:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d4aa:	4648      	mov	r0, r9
    d4ac:	4943      	ldr	r1, [pc, #268]	; (d5bc <_usb_d_dev_ep_enable+0x168>)
    d4ae:	4788      	blx	r1
    d4b0:	0700      	lsls	r0, r0, #28
    d4b2:	f000 41e0 	and.w	r1, r0, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d4b6:	4842      	ldr	r0, [pc, #264]	; (d5c0 <_usb_d_dev_ep_enable+0x16c>)
    d4b8:	ea00 3089 	and.w	r0, r0, r9, lsl #14
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d4bc:	f3c9 090d 	ubfx	r9, r9, #0, #14
	bank->STATUS_BK.reg     = 0;
    d4c0:	eb04 1545 	add.w	r5, r4, r5, lsl #5
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d4c4:	4308      	orrs	r0, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d4c6:	f002 020f 	and.w	r2, r2, #15
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d4ca:	ea49 0101 	orr.w	r1, r9, r1
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d4ce:	f8c8 0004 	str.w	r0, [r8, #4]
	bank->ADDR.reg          = addr;
    d4d2:	eb04 1442 	add.w	r4, r4, r2, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d4d6:	f8c8 1014 	str.w	r1, [r8, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d4da:	f04f 0c40 	mov.w	ip, #64	; 0x40
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d4de:	2180      	movs	r1, #128	; 0x80
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d4e0:	f886 c105 	strb.w	ip, [r6, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d4e4:	f886 1104 	strb.w	r1, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d4e8:	f885 323a 	strb.w	r3, [r5, #570]	; 0x23a
    d4ec:	f885 324a 	strb.w	r3, [r5, #586]	; 0x24a
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d4f0:	68fd      	ldr	r5, [r7, #12]
	bank->ADDR.reg          = addr;
    d4f2:	f8c4 5230 	str.w	r5, [r4, #560]	; 0x230
    d4f6:	f504 710c 	add.w	r1, r4, #560	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d4fa:	f8d4 4234 	ldr.w	r4, [r4, #564]	; 0x234
    d4fe:	f369 349b 	bfi	r4, r9, #14, #14
    d502:	604c      	str	r4, [r1, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d504:	684c      	ldr	r4, [r1, #4]
	bank->ADDR.reg          = addr;
    d506:	0150      	lsls	r0, r2, #5
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d508:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    d50c:	f363 040d 	bfi	r4, r3, #0, #14
    d510:	604c      	str	r4, [r1, #4]
    d512:	21b0      	movs	r1, #176	; 0xb0
    d514:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d518:	2110      	movs	r1, #16
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d51a:	f882 c105 	strb.w	ip, [r2, #261]	; 0x105
	return USB_OK;
    d51e:	4618      	mov	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d520:	f882 1109 	strb.w	r1, [r2, #265]	; 0x109
}
    d524:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (dir) {
    d528:	f1b9 0f00 	cmp.w	r9, #0
    d52c:	da1e      	bge.n	d56c <_usb_d_dev_ep_enable+0x118>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    d52e:	f010 0270 	ands.w	r2, r0, #112	; 0x70
    d532:	d13b      	bne.n	d5ac <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    d534:	f3c1 0102 	ubfx	r1, r1, #0, #3
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d538:	8a3b      	ldrh	r3, [r7, #16]
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    d53a:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
    d53e:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d540:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d544:	4618      	mov	r0, r3
    d546:	491d      	ldr	r1, [pc, #116]	; (d5bc <_usb_d_dev_ep_enable+0x168>)
    d548:	4788      	blx	r1
    d54a:	0700      	lsls	r0, r0, #28
    d54c:	f3c3 030d 	ubfx	r3, r3, #0, #14
    d550:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
	bank->STATUS_BK.reg     = 0;
    d554:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d558:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d55a:	2380      	movs	r3, #128	; 0x80
    d55c:	f8c8 0014 	str.w	r0, [r8, #20]
    d560:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d564:	f884 224a 	strb.w	r2, [r4, #586]	; 0x24a
	return USB_OK;
    d568:	4610      	mov	r0, r2
}
    d56a:	e7db      	b.n	d524 <_usb_d_dev_ep_enable+0xd0>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    d56c:	f010 0207 	ands.w	r2, r0, #7
    d570:	d11c      	bne.n	d5ac <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    d572:	f001 0107 	and.w	r1, r1, #7
    d576:	4301      	orrs	r1, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d578:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d57c:	8a39      	ldrh	r1, [r7, #16]
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d57e:	4b0f      	ldr	r3, [pc, #60]	; (d5bc <_usb_d_dev_ep_enable+0x168>)
    d580:	4608      	mov	r0, r1
    d582:	4798      	blx	r3
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d584:	4b0e      	ldr	r3, [pc, #56]	; (d5c0 <_usb_d_dev_ep_enable+0x16c>)
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d586:	0700      	lsls	r0, r0, #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d588:	ea03 3381 	and.w	r3, r3, r1, lsl #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d58c:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    d590:	4303      	orrs	r3, r0
	bank->STATUS_BK.reg     = 0;
    d592:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d596:	f8c8 3004 	str.w	r3, [r8, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d59a:	2340      	movs	r3, #64	; 0x40
    d59c:	f886 3105 	strb.w	r3, [r6, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    d5a0:	f884 223a 	strb.w	r2, [r4, #570]	; 0x23a
    d5a4:	e7e0      	b.n	d568 <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    d5a6:	f06f 0011 	mvn.w	r0, #17
    d5aa:	e7bb      	b.n	d524 <_usb_d_dev_ep_enable+0xd0>
			return -USB_ERR_REDO;
    d5ac:	f06f 0013 	mvn.w	r0, #19
    d5b0:	e7b8      	b.n	d524 <_usb_d_dev_ep_enable+0xd0>
    d5b2:	bf00      	nop
    d5b4:	0000ca35 	.word	0x0000ca35
    d5b8:	200011f8 	.word	0x200011f8
    d5bc:	0000d17d 	.word	0x0000d17d
    d5c0:	0fffc000 	.word	0x0fffc000

0000d5c4 <_usb_d_dev_ep_stall>:
{
    d5c4:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d5c6:	f000 020f 	and.w	r2, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    d5ca:	09c4      	lsrs	r4, r0, #7
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d5cc:	4b2f      	ldr	r3, [pc, #188]	; (d68c <_usb_d_dev_ep_stall+0xc8>)
{
    d5ce:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d5d0:	4610      	mov	r0, r2
    d5d2:	4621      	mov	r1, r4
    d5d4:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d5d6:	2a05      	cmp	r2, #5
    d5d8:	d855      	bhi.n	d686 <_usb_d_dev_ep_stall+0xc2>
	if (USB_EP_STALL_SET == ctrl) {
    d5da:	7c83      	ldrb	r3, [r0, #18]
    d5dc:	2210      	movs	r2, #16
    d5de:	2d01      	cmp	r5, #1
    d5e0:	f003 030f 	and.w	r3, r3, #15
    d5e4:	fa02 f204 	lsl.w	r2, r2, r4
    d5e8:	d113      	bne.n	d612 <_usb_d_dev_ep_stall+0x4e>
    d5ea:	0159      	lsls	r1, r3, #5
    d5ec:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d5f0:	b2d2      	uxtb	r2, r2
    d5f2:	f881 2105 	strb.w	r2, [r1, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d5f6:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    d5f8:	2120      	movs	r1, #32
    d5fa:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d5fe:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    d600:	b2c9      	uxtb	r1, r1
    d602:	f883 1109 	strb.w	r1, [r3, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    d606:	7cc3      	ldrb	r3, [r0, #19]
    d608:	f043 0308 	orr.w	r3, r3, #8
    d60c:	74c3      	strb	r3, [r0, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    d60e:	2000      	movs	r0, #0
}
    d610:	bd38      	pop	{r3, r4, r5, pc}
	} else if (USB_EP_STALL_CLR == ctrl) {
    d612:	bb6d      	cbnz	r5, d670 <_usb_d_dev_ep_stall+0xac>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    d614:	015d      	lsls	r5, r3, #5
    d616:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d61a:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
	if (!is_stalled) {
    d61e:	4211      	tst	r1, r2
    d620:	d0f5      	beq.n	d60e <_usb_d_dev_ep_stall+0x4a>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d622:	b2d2      	uxtb	r2, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d624:	f885 2104 	strb.w	r2, [r5, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d628:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    d62a:	2220      	movs	r2, #32
    d62c:	40a2      	lsls	r2, r4
    d62e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    d632:	b2d1      	uxtb	r1, r2
    d634:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    d638:	f895 3107 	ldrb.w	r3, [r5, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    d63c:	4213      	tst	r3, r2
    d63e:	d006      	beq.n	d64e <_usb_d_dev_ep_stall+0x8a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d640:	f885 1107 	strb.w	r1, [r5, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    d644:	2101      	movs	r1, #1
    d646:	40a1      	lsls	r1, r4
    d648:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d64a:	f885 1104 	strb.w	r1, [r5, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d64e:	7cc2      	ldrb	r2, [r0, #19]
    d650:	f002 0307 	and.w	r3, r2, #7
    d654:	2b01      	cmp	r3, #1
    d656:	d108      	bne.n	d66a <_usb_d_dev_ep_stall+0xa6>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    d658:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    d65c:	f013 0330 	ands.w	r3, r3, #48	; 0x30
    d660:	d1d5      	bne.n	d60e <_usb_d_dev_ep_stall+0x4a>
			ept->flags.bits.is_stalled = 0;
    d662:	f363 02c3 	bfi	r2, r3, #3, #1
		ept->flags.bits.is_stalled = 0;
    d666:	74c2      	strb	r2, [r0, #19]
    d668:	e7d1      	b.n	d60e <_usb_d_dev_ep_stall+0x4a>
    d66a:	f36f 02c3 	bfc	r2, #3, #1
    d66e:	e7fa      	b.n	d666 <_usb_d_dev_ep_stall+0xa2>
    d670:	015b      	lsls	r3, r3, #5
    d672:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d676:	f503 7380 	add.w	r3, r3, #256	; 0x100
    d67a:	799b      	ldrb	r3, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    d67c:	4213      	tst	r3, r2
    d67e:	bf14      	ite	ne
    d680:	2001      	movne	r0, #1
    d682:	2000      	moveq	r0, #0
    d684:	e7c4      	b.n	d610 <_usb_d_dev_ep_stall+0x4c>
		return -USB_ERR_PARAM;
    d686:	f06f 0011 	mvn.w	r0, #17
    d68a:	e7c1      	b.n	d610 <_usb_d_dev_ep_stall+0x4c>
    d68c:	0000ca35 	.word	0x0000ca35

0000d690 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    d690:	b570      	push	{r4, r5, r6, lr}
	uint8_t            epn   = USB_EP_GET_N(ep);
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    d692:	4b13      	ldr	r3, [pc, #76]	; (d6e0 <_usb_d_dev_ep_read_req+0x50>)
	uint8_t            epn   = USB_EP_GET_N(ep);
    d694:	f000 060f 	and.w	r6, r0, #15
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    d698:	0172      	lsls	r2, r6, #5
    d69a:	eb03 1046 	add.w	r0, r3, r6, lsl #5
	uint32_t           addr  = bank[0].ADDR.reg;
    d69e:	589d      	ldr	r5, [r3, r2]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    d6a0:	6844      	ldr	r4, [r0, #4]

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    d6a2:	2e05      	cmp	r6, #5
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    d6a4:	f3c4 040d 	ubfx	r4, r4, #0, #14
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    d6a8:	d814      	bhi.n	d6d4 <_usb_d_dev_ep_read_req+0x44>
    d6aa:	b199      	cbz	r1, d6d4 <_usb_d_dev_ep_read_req+0x44>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d6ac:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d6b0:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    d6b4:	2b11      	cmp	r3, #17
    d6b6:	d110      	bne.n	d6da <_usb_d_dev_ep_read_req+0x4a>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    d6b8:	f892 3107 	ldrb.w	r3, [r2, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    d6bc:	f013 0010 	ands.w	r0, r3, #16
    d6c0:	d007      	beq.n	d6d2 <_usb_d_dev_ep_read_req+0x42>
		return ERR_NONE;
	}
	memcpy(req_buf, (void *)addr, 8);
    d6c2:	682b      	ldr	r3, [r5, #0]
    d6c4:	600b      	str	r3, [r1, #0]
    d6c6:	686b      	ldr	r3, [r5, #4]
    d6c8:	604b      	str	r3, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d6ca:	2310      	movs	r3, #16
    d6cc:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	_usbd_ep_ack_setup(epn);

	return bytes;
    d6d0:	4620      	mov	r0, r4
}
    d6d2:	bd70      	pop	{r4, r5, r6, pc}
		return -USB_ERR_PARAM;
    d6d4:	f06f 0011 	mvn.w	r0, #17
    d6d8:	e7fb      	b.n	d6d2 <_usb_d_dev_ep_read_req+0x42>
		return -USB_ERR_FUNC;
    d6da:	f06f 0012 	mvn.w	r0, #18
    d6de:	e7f8      	b.n	d6d2 <_usb_d_dev_ep_read_req+0x42>
    d6e0:	20001428 	.word	0x20001428

0000d6e4 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    d6e4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    d6e8:	f890 9008 	ldrb.w	r9, [r0, #8]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d6ec:	4b39      	ldr	r3, [pc, #228]	; (d7d4 <_usb_d_dev_ep_trans+0xf0>)
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    d6ee:	f009 050f 	and.w	r5, r9, #15
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    d6f2:	fa4f f789 	sxtb.w	r7, r9
    d6f6:	ea4f 19d9 	mov.w	r9, r9, lsr #7
{
    d6fa:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d6fc:	4649      	mov	r1, r9
    d6fe:	4628      	mov	r0, r5
    d700:	4798      	blx	r3

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d702:	8a02      	ldrh	r2, [r0, #16]
	bool     size_n_aligned = (trans->size & size_mask);
    d704:	f8d8 1004 	ldr.w	r1, [r8, #4]
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d708:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d70c:	429a      	cmp	r2, r3
    d70e:	bf1a      	itte	ne
    d710:	f102 33ff 	addne.w	r3, r2, #4294967295	; 0xffffffff
    d714:	b29b      	uxthne	r3, r3
    d716:	4613      	moveq	r3, r2

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    d718:	2d05      	cmp	r5, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d71a:	4604      	mov	r4, r0
	bool     size_n_aligned = (trans->size & size_mask);
    d71c:	ea03 0601 	and.w	r6, r3, r1
	if (epn > CONF_USB_D_MAX_EP_N) {
    d720:	d828      	bhi.n	d774 <_usb_d_dev_ep_trans+0x90>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    d722:	f8d8 5000 	ldr.w	r5, [r8]
    d726:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
    d72a:	d30a      	bcc.n	d742 <_usb_d_dev_ep_trans+0x5e>
    d72c:	4b2a      	ldr	r3, [pc, #168]	; (d7d8 <_usb_d_dev_ep_trans+0xf4>)
    d72e:	1948      	adds	r0, r1, r5
    d730:	4298      	cmp	r0, r3
    d732:	d206      	bcs.n	d742 <_usb_d_dev_ep_trans+0x5e>
    d734:	f015 0503 	ands.w	r5, r5, #3
    d738:	d103      	bne.n	d742 <_usb_d_dev_ep_trans+0x5e>
	    || (!dir && (trans->size < ept->size))) {
    d73a:	2f00      	cmp	r7, #0
    d73c:	db05      	blt.n	d74a <_usb_d_dev_ep_trans+0x66>
    d73e:	4291      	cmp	r1, r2
    d740:	d214      	bcs.n	d76c <_usb_d_dev_ep_trans+0x88>
		if (!ept->cache) {
    d742:	68e3      	ldr	r3, [r4, #12]
    d744:	2b00      	cmp	r3, #0
    d746:	d03f      	beq.n	d7c8 <_usb_d_dev_ep_trans+0xe4>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    d748:	2501      	movs	r5, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    d74a:	7ce3      	ldrb	r3, [r4, #19]
    d74c:	071b      	lsls	r3, r3, #28
    d74e:	d43e      	bmi.n	d7ce <_usb_d_dev_ep_trans+0xea>
		return USB_HALTED;
	}

	/* Try to start transactions. */

	atomic_enter_critical(&flags);
    d750:	4b22      	ldr	r3, [pc, #136]	; (d7dc <_usb_d_dev_ep_trans+0xf8>)
    d752:	a801      	add	r0, sp, #4
    d754:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    d756:	7ce3      	ldrb	r3, [r4, #19]
    d758:	4a21      	ldr	r2, [pc, #132]	; (d7e0 <_usb_d_dev_ep_trans+0xfc>)
    d75a:	f013 0a40 	ands.w	sl, r3, #64	; 0x40
    d75e:	d00e      	beq.n	d77e <_usb_d_dev_ep_trans+0x9a>
		atomic_leave_critical(&flags);
    d760:	a801      	add	r0, sp, #4
    d762:	4790      	blx	r2
		return USB_BUSY;
    d764:	2001      	movs	r0, #1
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    d766:	b002      	add	sp, #8
    d768:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!dir && size_n_aligned) {
    d76c:	b12e      	cbz	r6, d77a <_usb_d_dev_ep_trans+0x96>
		if (!ept->cache) {
    d76e:	68e3      	ldr	r3, [r4, #12]
    d770:	2b00      	cmp	r3, #0
    d772:	d1ea      	bne.n	d74a <_usb_d_dev_ep_trans+0x66>
		return -USB_ERR_PARAM;
    d774:	f06f 0011 	mvn.w	r0, #17
    d778:	e7f5      	b.n	d766 <_usb_d_dev_ep_trans+0x82>
	bool use_cache = false;
    d77a:	4635      	mov	r5, r6
    d77c:	e7e5      	b.n	d74a <_usb_d_dev_ep_trans+0x66>
	ept->flags.bits.is_busy = 1;
    d77e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d782:	74e3      	strb	r3, [r4, #19]
	atomic_leave_critical(&flags);
    d784:	a801      	add	r0, sp, #4
    d786:	4790      	blx	r2
	ept->trans_buf   = trans->buf;
    d788:	f8d8 3000 	ldr.w	r3, [r8]
    d78c:	6023      	str	r3, [r4, #0]
	ept->trans_size  = trans->size;
    d78e:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ept->trans_count = 0;
    d792:	e9c4 3a01 	strd	r3, sl, [r4, #4]
	ept->flags.bits.dir       = dir;
    d796:	7ce3      	ldrb	r3, [r4, #19]
    d798:	f369 13c7 	bfi	r3, r9, #7, #1
	ept->flags.bits.use_cache = use_cache;
    d79c:	f365 1345 	bfi	r3, r5, #5, #1
    d7a0:	74e3      	strb	r3, [r4, #19]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d7a2:	f898 3009 	ldrb.w	r3, [r8, #9]
    d7a6:	b113      	cbz	r3, d7ae <_usb_d_dev_ep_trans+0xca>
    d7a8:	fab6 f386 	clz	r3, r6
    d7ac:	095b      	lsrs	r3, r3, #5
    d7ae:	7ce2      	ldrb	r2, [r4, #19]
	if (dir) {
    d7b0:	2f00      	cmp	r7, #0
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d7b2:	f363 1204 	bfi	r2, r3, #4, #1
		_usb_d_dev_in_next(ept, false);
    d7b6:	4620      	mov	r0, r4
    d7b8:	bfb4      	ite	lt
    d7ba:	4b0a      	ldrlt	r3, [pc, #40]	; (d7e4 <_usb_d_dev_ep_trans+0x100>)
		_usb_d_dev_out_next(ept, false);
    d7bc:	4b0a      	ldrge	r3, [pc, #40]	; (d7e8 <_usb_d_dev_ep_trans+0x104>)
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    d7be:	74e2      	strb	r2, [r4, #19]
		_usb_d_dev_in_next(ept, false);
    d7c0:	2100      	movs	r1, #0
		_usb_d_dev_out_next(ept, false);
    d7c2:	4798      	blx	r3
	return ERR_NONE;
    d7c4:	2000      	movs	r0, #0
    d7c6:	e7ce      	b.n	d766 <_usb_d_dev_ep_trans+0x82>
			return -USB_ERR_FUNC;
    d7c8:	f06f 0012 	mvn.w	r0, #18
    d7cc:	e7cb      	b.n	d766 <_usb_d_dev_ep_trans+0x82>
		return USB_HALTED;
    d7ce:	2002      	movs	r0, #2
    d7d0:	e7c9      	b.n	d766 <_usb_d_dev_ep_trans+0x82>
    d7d2:	bf00      	nop
    d7d4:	0000ca35 	.word	0x0000ca35
    d7d8:	20042000 	.word	0x20042000
    d7dc:	00011a11 	.word	0x00011a11
    d7e0:	00011a1f 	.word	0x00011a1f
    d7e4:	0000ccb5 	.word	0x0000ccb5
    d7e8:	0000ce11 	.word	0x0000ce11

0000d7ec <_usb_d_dev_ep_get_status>:
	}
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_ABORT);
}

int32_t _usb_d_dev_ep_get_status(const uint8_t ep, struct usb_d_trans_status *stat)
{
    d7ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d7ee:	f000 040f 	and.w	r4, r0, #15
{
    d7f2:	460a      	mov	r2, r1
	bool                  dir = USB_EP_GET_DIR(ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d7f4:	4b19      	ldr	r3, [pc, #100]	; (d85c <_usb_d_dev_ep_get_status+0x70>)
    d7f6:	09c1      	lsrs	r1, r0, #7
{
    d7f8:	4607      	mov	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d7fa:	4620      	mov	r0, r4
    d7fc:	4798      	blx	r3
	bool                  busy, stall;

	if (epn > CONF_USB_D_MAX_EP_N) {
    d7fe:	2c05      	cmp	r4, #5
    d800:	d82a      	bhi.n	d858 <_usb_d_dev_ep_get_status+0x6c>
		return USB_ERR_PARAM;
	}
	busy  = ept->flags.bits.is_busy;
    d802:	7cc5      	ldrb	r5, [r0, #19]
    d804:	f3c5 1180 	ubfx	r1, r5, #6, #1
	stall = ept->flags.bits.is_stalled;
    d808:	f3c5 06c0 	ubfx	r6, r5, #3, #1
	if (stat) {
    d80c:	b1fa      	cbz	r2, d84e <_usb_d_dev_ep_get_status+0x62>
		stat->stall = stall;
    d80e:	7a53      	ldrb	r3, [r2, #9]
		stat->busy  = busy;
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d810:	0164      	lsls	r4, r4, #5
		stat->stall = stall;
    d812:	f366 1304 	bfi	r3, r6, #4, #1
		stat->busy  = busy;
    d816:	f361 0382 	bfi	r3, r1, #2, #1
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d81a:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
		stat->busy  = busy;
    d81e:	7253      	strb	r3, [r2, #9]
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    d820:	f894 3107 	ldrb.w	r3, [r4, #263]	; 0x107
    d824:	f3c3 1400 	ubfx	r4, r3, #4, #1
		stat->dir   = ept->flags.bits.dir;
		stat->size  = ept->trans_size;
    d828:	6843      	ldr	r3, [r0, #4]
    d82a:	6013      	str	r3, [r2, #0]
		stat->count = ept->trans_count;
    d82c:	6883      	ldr	r3, [r0, #8]
		stat->ep    = ep;
    d82e:	7217      	strb	r7, [r2, #8]
		stat->count = ept->trans_count;
    d830:	6053      	str	r3, [r2, #4]
		stat->xtype = ept->flags.bits.eptype - 1;
    d832:	7cc3      	ldrb	r3, [r0, #19]
    d834:	7a50      	ldrb	r0, [r2, #9]
    d836:	3303      	adds	r3, #3
    d838:	f003 0303 	and.w	r3, r3, #3
		stat->dir   = ept->flags.bits.dir;
    d83c:	09ed      	lsrs	r5, r5, #7
		stat->xtype = ept->flags.bits.eptype - 1;
    d83e:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
    d842:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
    d846:	f020 002b 	bic.w	r0, r0, #43	; 0x2b
    d84a:	4303      	orrs	r3, r0
    d84c:	7253      	strb	r3, [r2, #9]
		return USB_ERR_PARAM;
    d84e:	2e00      	cmp	r6, #0
    d850:	bf0c      	ite	eq
    d852:	4608      	moveq	r0, r1
    d854:	2002      	movne	r0, #2
	}
	if (busy) {
		return USB_BUSY;
	}
	return USB_OK;
}
    d856:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return USB_ERR_PARAM;
    d858:	2012      	movs	r0, #18
    d85a:	e7fc      	b.n	d856 <_usb_d_dev_ep_get_status+0x6a>
    d85c:	0000ca35 	.word	0x0000ca35

0000d860 <_usb_d_dev_register_callback>:

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    d860:	4b06      	ldr	r3, [pc, #24]	; (d87c <_usb_d_dev_register_callback+0x1c>)
    d862:	2900      	cmp	r1, #0
    d864:	bf08      	it	eq
    d866:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    d868:	2801      	cmp	r0, #1
    d86a:	d102      	bne.n	d872 <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    d86c:	4b04      	ldr	r3, [pc, #16]	; (d880 <_usb_d_dev_register_callback+0x20>)
    d86e:	6059      	str	r1, [r3, #4]
    d870:	4770      	bx	lr
	} else if (type == USB_D_CB_SOF) {
    d872:	b908      	cbnz	r0, d878 <_usb_d_dev_register_callback+0x18>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    d874:	4b02      	ldr	r3, [pc, #8]	; (d880 <_usb_d_dev_register_callback+0x20>)
    d876:	6019      	str	r1, [r3, #0]
	}
}
    d878:	4770      	bx	lr
    d87a:	bf00      	nop
    d87c:	0000ca0d 	.word	0x0000ca0d
    d880:	200011f8 	.word	0x200011f8

0000d884 <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    d884:	4b08      	ldr	r3, [pc, #32]	; (d8a8 <_usb_d_dev_register_ep_callback+0x24>)
    d886:	2900      	cmp	r1, #0
    d888:	bf08      	it	eq
    d88a:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    d88c:	b910      	cbnz	r0, d894 <_usb_d_dev_register_ep_callback+0x10>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    d88e:	4b07      	ldr	r3, [pc, #28]	; (d8ac <_usb_d_dev_register_ep_callback+0x28>)
    d890:	6099      	str	r1, [r3, #8]
    d892:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    d894:	2801      	cmp	r0, #1
    d896:	d102      	bne.n	d89e <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    d898:	4b04      	ldr	r3, [pc, #16]	; (d8ac <_usb_d_dev_register_ep_callback+0x28>)
    d89a:	60d9      	str	r1, [r3, #12]
    d89c:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    d89e:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    d8a0:	bf04      	itt	eq
    d8a2:	4b02      	ldreq	r3, [pc, #8]	; (d8ac <_usb_d_dev_register_ep_callback+0x28>)
    d8a4:	6119      	streq	r1, [r3, #16]
	}
}
    d8a6:	4770      	bx	lr
    d8a8:	0000ca0d 	.word	0x0000ca0d
    d8ac:	200011f8 	.word	0x200011f8

0000d8b0 <USB_0_Handler>:
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{

	_usb_d_dev_handler();
    d8b0:	4b00      	ldr	r3, [pc, #0]	; (d8b4 <USB_0_Handler+0x4>)
    d8b2:	4718      	bx	r3
    d8b4:	0000cfad 	.word	0x0000cfad

0000d8b8 <USB_1_Handler>:
    d8b8:	4b00      	ldr	r3, [pc, #0]	; (d8bc <USB_1_Handler+0x4>)
    d8ba:	4718      	bx	r3
    d8bc:	0000cfad 	.word	0x0000cfad

0000d8c0 <USB_2_Handler>:
    d8c0:	4b00      	ldr	r3, [pc, #0]	; (d8c4 <USB_2_Handler+0x4>)
    d8c2:	4718      	bx	r3
    d8c4:	0000cfad 	.word	0x0000cfad

0000d8c8 <USB_3_Handler>:
    d8c8:	4b00      	ldr	r3, [pc, #0]	; (d8cc <USB_3_Handler+0x4>)
    d8ca:	4718      	bx	r3
    d8cc:	0000cfad 	.word	0x0000cfad

0000d8d0 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    d8d0:	b508      	push	{r3, lr}
    d8d2:	4603      	mov	r3, r0
    d8d4:	4608      	mov	r0, r1
    d8d6:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
    d8d8:	b923      	cbnz	r3, d8e4 <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    d8da:	4b04      	ldr	r3, [pc, #16]	; (d8ec <_read+0x1c>)
    d8dc:	4798      	blx	r3
	if (n < 0) {
    d8de:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    d8e2:	bd08      	pop	{r3, pc}
		return -1;
    d8e4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    d8e8:	e7fb      	b.n	d8e2 <_read+0x12>
    d8ea:	bf00      	nop
    d8ec:	0000b7c1 	.word	0x0000b7c1

0000d8f0 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    d8f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    d8f4:	4c0c      	ldr	r4, [pc, #48]	; (d928 <prvCheckForValidListAndQueue+0x38>)
	taskENTER_CRITICAL();
    d8f6:	4b0d      	ldr	r3, [pc, #52]	; (d92c <prvCheckForValidListAndQueue+0x3c>)
    d8f8:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    d8fa:	6825      	ldr	r5, [r4, #0]
    d8fc:	b985      	cbnz	r5, d920 <prvCheckForValidListAndQueue+0x30>
			vListInitialise(&xActiveTimerList1);
    d8fe:	1d27      	adds	r7, r4, #4
    d900:	f8df 8034 	ldr.w	r8, [pc, #52]	; d938 <prvCheckForValidListAndQueue+0x48>
    d904:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    d906:	f104 0618 	add.w	r6, r4, #24
			vListInitialise(&xActiveTimerList1);
    d90a:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    d90c:	4630      	mov	r0, r6
    d90e:	47c0      	blx	r8
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    d910:	4b07      	ldr	r3, [pc, #28]	; (d930 <prvCheckForValidListAndQueue+0x40>)
    d912:	462a      	mov	r2, r5
    d914:	210c      	movs	r1, #12
    d916:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    d918:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    d91c:	4798      	blx	r3
    d91e:	6020      	str	r0, [r4, #0]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    d920:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    d924:	4b03      	ldr	r3, [pc, #12]	; (d934 <prvCheckForValidListAndQueue+0x44>)
    d926:	4718      	bx	r3
    d928:	200015b8 	.word	0x200015b8
    d92c:	0000b315 	.word	0x0000b315
    d930:	0000c285 	.word	0x0000c285
    d934:	0000b359 	.word	0x0000b359
    d938:	0000b14d 	.word	0x0000b14d

0000d93c <prvInsertTimerInActiveList>:
	if (xNextExpiryTime <= xTimeNow) {
    d93c:	4291      	cmp	r1, r2
{
    d93e:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    d940:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    d942:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    d944:	d80a      	bhi.n	d95c <prvInsertTimerInActiveList+0x20>
		if (((TickType_t)(xTimeNow - xCommandTime))
    d946:	1ad2      	subs	r2, r2, r3
    d948:	6983      	ldr	r3, [r0, #24]
    d94a:	429a      	cmp	r2, r3
    d94c:	d20e      	bcs.n	d96c <prvInsertTimerInActiveList+0x30>
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    d94e:	4b08      	ldr	r3, [pc, #32]	; (d970 <prvInsertTimerInActiveList+0x34>)
    d950:	1d01      	adds	r1, r0, #4
    d952:	6b18      	ldr	r0, [r3, #48]	; 0x30
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    d954:	4b07      	ldr	r3, [pc, #28]	; (d974 <prvInsertTimerInActiveList+0x38>)
    d956:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    d958:	2000      	movs	r0, #0
}
    d95a:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    d95c:	429a      	cmp	r2, r3
    d95e:	d201      	bcs.n	d964 <prvInsertTimerInActiveList+0x28>
    d960:	4299      	cmp	r1, r3
    d962:	d203      	bcs.n	d96c <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    d964:	4b02      	ldr	r3, [pc, #8]	; (d970 <prvInsertTimerInActiveList+0x34>)
    d966:	1d01      	adds	r1, r0, #4
    d968:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    d96a:	e7f3      	b.n	d954 <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    d96c:	2001      	movs	r0, #1
	return xProcessTimerNow;
    d96e:	e7f4      	b.n	d95a <prvInsertTimerInActiveList+0x1e>
    d970:	200015b8 	.word	0x200015b8
    d974:	0000b181 	.word	0x0000b181

0000d978 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    d978:	4b0e      	ldr	r3, [pc, #56]	; (d9b4 <xTimerCreateTimerTask+0x3c>)
{
    d97a:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    d97c:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    d97e:	4b0e      	ldr	r3, [pc, #56]	; (d9b8 <xTimerCreateTimerTask+0x40>)
    d980:	681a      	ldr	r2, [r3, #0]
    d982:	b942      	cbnz	r2, d996 <xTimerCreateTimerTask+0x1e>
    d984:	f04f 0380 	mov.w	r3, #128	; 0x80
    d988:	f383 8811 	msr	BASEPRI, r3
    d98c:	f3bf 8f6f 	isb	sy
    d990:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
    d994:	e7fe      	b.n	d994 <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(prvTimerTask,
    d996:	3334      	adds	r3, #52	; 0x34
    d998:	9301      	str	r3, [sp, #4]
    d99a:	2302      	movs	r3, #2
    d99c:	9300      	str	r3, [sp, #0]
    d99e:	4907      	ldr	r1, [pc, #28]	; (d9bc <xTimerCreateTimerTask+0x44>)
    d9a0:	4807      	ldr	r0, [pc, #28]	; (d9c0 <xTimerCreateTimerTask+0x48>)
    d9a2:	4c08      	ldr	r4, [pc, #32]	; (d9c4 <xTimerCreateTimerTask+0x4c>)
    d9a4:	2300      	movs	r3, #0
    d9a6:	2240      	movs	r2, #64	; 0x40
    d9a8:	47a0      	blx	r4
	configASSERT(xReturn);
    d9aa:	2800      	cmp	r0, #0
    d9ac:	d0ea      	beq.n	d984 <xTimerCreateTimerTask+0xc>
}
    d9ae:	b002      	add	sp, #8
    d9b0:	bd10      	pop	{r4, pc}
    d9b2:	bf00      	nop
    d9b4:	0000d8f1 	.word	0x0000d8f1
    d9b8:	200015b8 	.word	0x200015b8
    d9bc:	00016fdc 	.word	0x00016fdc
    d9c0:	0000daa9 	.word	0x0000daa9
    d9c4:	000122d5 	.word	0x000122d5

0000d9c8 <xTimerGenericCommand>:
{
    d9c8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    d9ca:	4616      	mov	r6, r2
	configASSERT(xTimer);
    d9cc:	4604      	mov	r4, r0
{
    d9ce:	461a      	mov	r2, r3
	configASSERT(xTimer);
    d9d0:	b940      	cbnz	r0, d9e4 <xTimerGenericCommand+0x1c>
    d9d2:	f04f 0380 	mov.w	r3, #128	; 0x80
    d9d6:	f383 8811 	msr	BASEPRI, r3
    d9da:	f3bf 8f6f 	isb	sy
    d9de:	f3bf 8f4f 	dsb	sy
    d9e2:	e7fe      	b.n	d9e2 <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    d9e4:	4d0d      	ldr	r5, [pc, #52]	; (da1c <xTimerGenericCommand+0x54>)
    d9e6:	6828      	ldr	r0, [r5, #0]
    d9e8:	b188      	cbz	r0, da0e <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    d9ea:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    d9ec:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    d9f0:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    d9f2:	dc0e      	bgt.n	da12 <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    d9f4:	4b0a      	ldr	r3, [pc, #40]	; (da20 <xTimerGenericCommand+0x58>)
    d9f6:	4c0b      	ldr	r4, [pc, #44]	; (da24 <xTimerGenericCommand+0x5c>)
    d9f8:	4798      	blx	r3
    d9fa:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    d9fc:	f04f 0300 	mov.w	r3, #0
    da00:	bf08      	it	eq
    da02:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    da04:	6828      	ldr	r0, [r5, #0]
    da06:	bf18      	it	ne
    da08:	461a      	movne	r2, r3
    da0a:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    da0c:	47a0      	blx	r4
}
    da0e:	b004      	add	sp, #16
    da10:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    da12:	4c05      	ldr	r4, [pc, #20]	; (da28 <xTimerGenericCommand+0x60>)
    da14:	2300      	movs	r3, #0
    da16:	a901      	add	r1, sp, #4
    da18:	e7f8      	b.n	da0c <xTimerGenericCommand+0x44>
    da1a:	bf00      	nop
    da1c:	200015b8 	.word	0x200015b8
    da20:	00012989 	.word	0x00012989
    da24:	0000c2d9 	.word	0x0000c2d9
    da28:	0000c485 	.word	0x0000c485

0000da2c <prvSwitchTimerLists>:
{
    da2c:	b5f0      	push	{r4, r5, r6, r7, lr}
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    da2e:	4d1a      	ldr	r5, [pc, #104]	; (da98 <prvSwitchTimerLists+0x6c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    da30:	4f1a      	ldr	r7, [pc, #104]	; (da9c <prvSwitchTimerLists+0x70>)
{
    da32:	b085      	sub	sp, #20
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    da34:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    da36:	681a      	ldr	r2, [r3, #0]
    da38:	b922      	cbnz	r2, da44 <prvSwitchTimerLists+0x18>
	pxCurrentTimerList  = pxOverflowTimerList;
    da3a:	6b2a      	ldr	r2, [r5, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
    da3c:	e9c5 230b 	strd	r2, r3, [r5, #44]	; 0x2c
}
    da40:	b005      	add	sp, #20
    da42:	bdf0      	pop	{r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    da44:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    da46:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    da48:	681e      	ldr	r6, [r3, #0]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    da4a:	1d21      	adds	r1, r4, #4
    da4c:	4608      	mov	r0, r1
    da4e:	9103      	str	r1, [sp, #12]
    da50:	47b8      	blx	r7
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    da52:	6a63      	ldr	r3, [r4, #36]	; 0x24
    da54:	4620      	mov	r0, r4
    da56:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    da58:	69e3      	ldr	r3, [r4, #28]
    da5a:	9903      	ldr	r1, [sp, #12]
    da5c:	2b01      	cmp	r3, #1
    da5e:	d1e9      	bne.n	da34 <prvSwitchTimerLists+0x8>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    da60:	69a3      	ldr	r3, [r4, #24]
    da62:	4433      	add	r3, r6
			if (xReloadTime > xNextExpireTime) {
    da64:	429e      	cmp	r6, r3
    da66:	d205      	bcs.n	da74 <prvSwitchTimerLists+0x48>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    da68:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    da6a:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    da6c:	4b0c      	ldr	r3, [pc, #48]	; (daa0 <prvSwitchTimerLists+0x74>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    da6e:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    da70:	4798      	blx	r3
    da72:	e7df      	b.n	da34 <prvSwitchTimerLists+0x8>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    da74:	2300      	movs	r3, #0
    da76:	4620      	mov	r0, r4
    da78:	9300      	str	r3, [sp, #0]
    da7a:	4c0a      	ldr	r4, [pc, #40]	; (daa4 <prvSwitchTimerLists+0x78>)
    da7c:	4632      	mov	r2, r6
    da7e:	4619      	mov	r1, r3
    da80:	47a0      	blx	r4
				configASSERT(xResult);
    da82:	2800      	cmp	r0, #0
    da84:	d1d6      	bne.n	da34 <prvSwitchTimerLists+0x8>
    da86:	f04f 0380 	mov.w	r3, #128	; 0x80
    da8a:	f383 8811 	msr	BASEPRI, r3
    da8e:	f3bf 8f6f 	isb	sy
    da92:	f3bf 8f4f 	dsb	sy
    da96:	e7fe      	b.n	da96 <prvSwitchTimerLists+0x6a>
    da98:	200015b8 	.word	0x200015b8
    da9c:	0000b1af 	.word	0x0000b1af
    daa0:	0000b181 	.word	0x0000b181
    daa4:	0000d9c9 	.word	0x0000d9c9

0000daa8 <prvTimerTask>:
{
    daa8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    daac:	f8df 81c8 	ldr.w	r8, [pc, #456]	; dc78 <prvTimerTask+0x1d0>
{
    dab0:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    dab2:	4c68      	ldr	r4, [pc, #416]	; (dc54 <prvTimerTask+0x1ac>)
    dab4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    dab6:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    daba:	4627      	mov	r7, r4
    dabc:	f1bb 0f00 	cmp.w	fp, #0
    dac0:	d044      	beq.n	db4c <prvTimerTask+0xa4>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    dac2:	68db      	ldr	r3, [r3, #12]
    dac4:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
    dac8:	4b63      	ldr	r3, [pc, #396]	; (dc58 <prvTimerTask+0x1b0>)
	xTimeNow = xTaskGetTickCount();
    daca:	4e64      	ldr	r6, [pc, #400]	; (dc5c <prvTimerTask+0x1b4>)
    dacc:	f8df a1ac 	ldr.w	sl, [pc, #428]	; dc7c <prvTimerTask+0x1d4>
	vTaskSuspendAll();
    dad0:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    dad2:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dad4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    dad6:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dad8:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dada:	d239      	bcs.n	db50 <prvTimerTask+0xa8>
		prvSwitchTimerLists();
    dadc:	4b60      	ldr	r3, [pc, #384]	; (dc60 <prvTimerTask+0x1b8>)
    dade:	4798      	blx	r3
	xLastTime = xTimeNow;
    dae0:	63a5      	str	r5, [r4, #56]	; 0x38
			(void)xTaskResumeAll();
    dae2:	47d0      	blx	sl
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dae4:	f8df 9198 	ldr.w	r9, [pc, #408]	; dc80 <prvTimerTask+0x1d8>
		prvSwitchTimerLists();
    dae8:	f8df a174 	ldr.w	sl, [pc, #372]	; dc60 <prvTimerTask+0x1b8>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    daec:	6838      	ldr	r0, [r7, #0]
    daee:	2200      	movs	r2, #0
    daf0:	a903      	add	r1, sp, #12
    daf2:	47c8      	blx	r9
    daf4:	2800      	cmp	r0, #0
    daf6:	d0dc      	beq.n	dab2 <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    daf8:	9b03      	ldr	r3, [sp, #12]
    dafa:	2b00      	cmp	r3, #0
    dafc:	dbf6      	blt.n	daec <prvTimerTask+0x44>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    dafe:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    db00:	6963      	ldr	r3, [r4, #20]
    db02:	b10b      	cbz	r3, db08 <prvTimerTask+0x60>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    db04:	1d20      	adds	r0, r4, #4
    db06:	47c0      	blx	r8
	xTimeNow = xTaskGetTickCount();
    db08:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    db0a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    db0c:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    db0e:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    db10:	d200      	bcs.n	db14 <prvTimerTask+0x6c>
		prvSwitchTimerLists();
    db12:	47d0      	blx	sl
	xLastTime = xTimeNow;
    db14:	9b03      	ldr	r3, [sp, #12]
    db16:	63bd      	str	r5, [r7, #56]	; 0x38
			switch (xMessage.xMessageID) {
    db18:	2b09      	cmp	r3, #9
    db1a:	d8e7      	bhi.n	daec <prvTimerTask+0x44>
    db1c:	a201      	add	r2, pc, #4	; (adr r2, db24 <prvTimerTask+0x7c>)
    db1e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    db22:	bf00      	nop
    db24:	0000dbd9 	.word	0x0000dbd9
    db28:	0000dbd9 	.word	0x0000dbd9
    db2c:	0000dbd9 	.word	0x0000dbd9
    db30:	0000daed 	.word	0x0000daed
    db34:	0000dc25 	.word	0x0000dc25
    db38:	0000dc4b 	.word	0x0000dc4b
    db3c:	0000dbd9 	.word	0x0000dbd9
    db40:	0000dbd9 	.word	0x0000dbd9
    db44:	0000daed 	.word	0x0000daed
    db48:	0000dc25 	.word	0x0000dc25
		xNextExpireTime = (TickType_t)0U;
    db4c:	46d9      	mov	r9, fp
    db4e:	e7bb      	b.n	dac8 <prvTimerTask+0x20>
	xLastTime = xTimeNow;
    db50:	63a0      	str	r0, [r4, #56]	; 0x38
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    db52:	f1bb 0f00 	cmp.w	fp, #0
    db56:	d027      	beq.n	dba8 <prvTimerTask+0x100>
    db58:	4581      	cmp	r9, r0
    db5a:	d83b      	bhi.n	dbd4 <prvTimerTask+0x12c>
				(void)xTaskResumeAll();
    db5c:	47d0      	blx	sl
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    db5e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    db60:	68db      	ldr	r3, [r3, #12]
    db62:	68dc      	ldr	r4, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    db64:	1d20      	adds	r0, r4, #4
    db66:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    db68:	69e3      	ldr	r3, [r4, #28]
    db6a:	2b01      	cmp	r3, #1
    db6c:	d118      	bne.n	dba0 <prvTimerTask+0xf8>
		if (prvInsertTimerInActiveList(
    db6e:	69a1      	ldr	r1, [r4, #24]
    db70:	462a      	mov	r2, r5
    db72:	464b      	mov	r3, r9
    db74:	4d3b      	ldr	r5, [pc, #236]	; (dc64 <prvTimerTask+0x1bc>)
    db76:	4449      	add	r1, r9
    db78:	4620      	mov	r0, r4
    db7a:	47a8      	blx	r5
    db7c:	b180      	cbz	r0, dba0 <prvTimerTask+0xf8>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    db7e:	2300      	movs	r3, #0
    db80:	4d39      	ldr	r5, [pc, #228]	; (dc68 <prvTimerTask+0x1c0>)
    db82:	9300      	str	r3, [sp, #0]
    db84:	464a      	mov	r2, r9
    db86:	4619      	mov	r1, r3
    db88:	4620      	mov	r0, r4
    db8a:	47a8      	blx	r5
			configASSERT(xResult);
    db8c:	b940      	cbnz	r0, dba0 <prvTimerTask+0xf8>
    db8e:	f04f 0380 	mov.w	r3, #128	; 0x80
    db92:	f383 8811 	msr	BASEPRI, r3
    db96:	f3bf 8f6f 	isb	sy
    db9a:	f3bf 8f4f 	dsb	sy
    db9e:	e7fe      	b.n	db9e <prvTimerTask+0xf6>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    dba0:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dba2:	4620      	mov	r0, r4
    dba4:	4798      	blx	r3
}
    dba6:	e79d      	b.n	dae4 <prvTimerTask+0x3c>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    dba8:	6b23      	ldr	r3, [r4, #48]	; 0x30
    dbaa:	681a      	ldr	r2, [r3, #0]
    dbac:	fab2 f282 	clz	r2, r2
    dbb0:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    dbb2:	6820      	ldr	r0, [r4, #0]
    dbb4:	4b2d      	ldr	r3, [pc, #180]	; (dc6c <prvTimerTask+0x1c4>)
    dbb6:	eba9 0105 	sub.w	r1, r9, r5
    dbba:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    dbbc:	47d0      	blx	sl
    dbbe:	2800      	cmp	r0, #0
    dbc0:	d190      	bne.n	dae4 <prvTimerTask+0x3c>
					portYIELD_WITHIN_API();
    dbc2:	4b2b      	ldr	r3, [pc, #172]	; (dc70 <prvTimerTask+0x1c8>)
    dbc4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    dbc8:	601a      	str	r2, [r3, #0]
    dbca:	f3bf 8f4f 	dsb	sy
    dbce:	f3bf 8f6f 	isb	sy
    dbd2:	e787      	b.n	dae4 <prvTimerTask+0x3c>
    dbd4:	2200      	movs	r2, #0
    dbd6:	e7ec      	b.n	dbb2 <prvTimerTask+0x10a>
				if (prvInsertTimerInActiveList(pxTimer,
    dbd8:	69a1      	ldr	r1, [r4, #24]
    dbda:	9b04      	ldr	r3, [sp, #16]
    dbdc:	462a      	mov	r2, r5
    dbde:	4419      	add	r1, r3
    dbe0:	4d20      	ldr	r5, [pc, #128]	; (dc64 <prvTimerTask+0x1bc>)
    dbe2:	4620      	mov	r0, r4
    dbe4:	47a8      	blx	r5
    dbe6:	2800      	cmp	r0, #0
    dbe8:	f43f af7e 	beq.w	dae8 <prvTimerTask+0x40>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    dbec:	6a63      	ldr	r3, [r4, #36]	; 0x24
    dbee:	4620      	mov	r0, r4
    dbf0:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    dbf2:	69e3      	ldr	r3, [r4, #28]
    dbf4:	2b01      	cmp	r3, #1
    dbf6:	f47f af77 	bne.w	dae8 <prvTimerTask+0x40>
						xResult = xTimerGenericCommand(pxTimer,
    dbfa:	69a2      	ldr	r2, [r4, #24]
    dbfc:	9904      	ldr	r1, [sp, #16]
    dbfe:	2300      	movs	r3, #0
    dc00:	440a      	add	r2, r1
    dc02:	4620      	mov	r0, r4
    dc04:	9300      	str	r3, [sp, #0]
    dc06:	4c18      	ldr	r4, [pc, #96]	; (dc68 <prvTimerTask+0x1c0>)
    dc08:	4619      	mov	r1, r3
    dc0a:	47a0      	blx	r4
						configASSERT(xResult);
    dc0c:	2800      	cmp	r0, #0
    dc0e:	f47f af6b 	bne.w	dae8 <prvTimerTask+0x40>
    dc12:	f04f 0380 	mov.w	r3, #128	; 0x80
    dc16:	f383 8811 	msr	BASEPRI, r3
    dc1a:	f3bf 8f6f 	isb	sy
    dc1e:	f3bf 8f4f 	dsb	sy
    dc22:	e7fe      	b.n	dc22 <prvTimerTask+0x17a>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    dc24:	9904      	ldr	r1, [sp, #16]
    dc26:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    dc28:	b941      	cbnz	r1, dc3c <prvTimerTask+0x194>
    dc2a:	f04f 0380 	mov.w	r3, #128	; 0x80
    dc2e:	f383 8811 	msr	BASEPRI, r3
    dc32:	f3bf 8f6f 	isb	sy
    dc36:	f3bf 8f4f 	dsb	sy
    dc3a:	e7fe      	b.n	dc3a <prvTimerTask+0x192>
				(void)prvInsertTimerInActiveList(
    dc3c:	462b      	mov	r3, r5
    dc3e:	462a      	mov	r2, r5
    dc40:	4429      	add	r1, r5
    dc42:	4620      	mov	r0, r4
    dc44:	4c07      	ldr	r4, [pc, #28]	; (dc64 <prvTimerTask+0x1bc>)
    dc46:	47a0      	blx	r4
				break;
    dc48:	e74e      	b.n	dae8 <prvTimerTask+0x40>
				vPortFree(pxTimer);
    dc4a:	4b0a      	ldr	r3, [pc, #40]	; (dc74 <prvTimerTask+0x1cc>)
    dc4c:	4620      	mov	r0, r4
    dc4e:	4798      	blx	r3
			break;
    dc50:	e74a      	b.n	dae8 <prvTimerTask+0x40>
    dc52:	bf00      	nop
    dc54:	200015b8 	.word	0x200015b8
    dc58:	00012505 	.word	0x00012505
    dc5c:	00012519 	.word	0x00012519
    dc60:	0000da2d 	.word	0x0000da2d
    dc64:	0000d93d 	.word	0x0000d93d
    dc68:	0000d9c9 	.word	0x0000d9c9
    dc6c:	0000c6cd 	.word	0x0000c6cd
    dc70:	e000ed04 	.word	0xe000ed04
    dc74:	0000b225 	.word	0x0000b225
    dc78:	0000b1af 	.word	0x0000b1af
    dc7c:	00012629 	.word	0x00012629
    dc80:	0000c565 	.word	0x0000c565

0000dc84 <delay_init>:
/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
	_delay_init(hardware = hw);
    dc84:	4b01      	ldr	r3, [pc, #4]	; (dc8c <delay_init+0x8>)
    dc86:	6018      	str	r0, [r3, #0]
    dc88:	4b01      	ldr	r3, [pc, #4]	; (dc90 <delay_init+0xc>)
    dc8a:	4718      	bx	r3
    dc8c:	200015f4 	.word	0x200015f4
    dc90:	000137a9 	.word	0x000137a9

0000dc94 <delay_ms>:
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dc94:	4b05      	ldr	r3, [pc, #20]	; (dcac <delay_ms+0x18>)
{
    dc96:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dc98:	681c      	ldr	r4, [r3, #0]
    dc9a:	4b05      	ldr	r3, [pc, #20]	; (dcb0 <delay_ms+0x1c>)
    dc9c:	4798      	blx	r3
    dc9e:	4b05      	ldr	r3, [pc, #20]	; (dcb4 <delay_ms+0x20>)
    dca0:	4601      	mov	r1, r0
    dca2:	4620      	mov	r0, r4
}
    dca4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    dca8:	4718      	bx	r3
    dcaa:	bf00      	nop
    dcac:	200015f4 	.word	0x200015f4
    dcb0:	0000b9cd 	.word	0x0000b9cd
    dcb4:	000137bd 	.word	0x000137bd

0000dcb8 <_init_chip>:
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    dcb8:	4a0e      	ldr	r2, [pc, #56]	; (dcf4 <_init_chip+0x3c>)
    dcba:	8813      	ldrh	r3, [r2, #0]
    dcbc:	b29b      	uxth	r3, r3
    dcbe:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    dcc2:	b510      	push	{r4, lr}
    dcc4:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    dcc6:	4b0c      	ldr	r3, [pc, #48]	; (dcf8 <_init_chip+0x40>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    dcc8:	4c0c      	ldr	r4, [pc, #48]	; (dcfc <_init_chip+0x44>)
	_osc32kctrl_init_sources();
    dcca:	4798      	blx	r3
	_oscctrl_init_sources();
    dccc:	4b0c      	ldr	r3, [pc, #48]	; (dd00 <_init_chip+0x48>)
    dcce:	4798      	blx	r3
	_mclk_init();
    dcd0:	4b0c      	ldr	r3, [pc, #48]	; (dd04 <_init_chip+0x4c>)
    dcd2:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    dcd4:	2004      	movs	r0, #4
    dcd6:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    dcd8:	4b0b      	ldr	r3, [pc, #44]	; (dd08 <_init_chip+0x50>)
    dcda:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    dcdc:	f640 70fb 	movw	r0, #4091	; 0xffb
    dce0:	47a0      	blx	r4
}

static inline void hri_mclk_set_AHBMASK_DMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    dce2:	4a0a      	ldr	r2, [pc, #40]	; (dd0c <_init_chip+0x54>)
    dce4:	6913      	ldr	r3, [r2, #16]
    dce6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    dcea:	6113      	str	r3, [r2, #16]
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    dcec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_dma_init();
    dcf0:	4b07      	ldr	r3, [pc, #28]	; (dd10 <_init_chip+0x58>)
    dcf2:	4718      	bx	r3
    dcf4:	41004000 	.word	0x41004000
    dcf8:	0000f77d 	.word	0x0000f77d
    dcfc:	0000eb7d 	.word	0x0000eb7d
    dd00:	0000e525 	.word	0x0000e525
    dd04:	0000eb5d 	.word	0x0000eb5d
    dd08:	0000e529 	.word	0x0000e529
    dd0c:	40000800 	.word	0x40000800
    dd10:	0000df99 	.word	0x0000df99

0000dd14 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    dd14:	4a0b      	ldr	r2, [pc, #44]	; (dd44 <RAMECC_Handler+0x30>)
    dd16:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    dd18:	b082      	sub	sp, #8
    dd1a:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    dd1c:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    dd1e:	9b01      	ldr	r3, [sp, #4]
    dd20:	0799      	lsls	r1, r3, #30
    dd22:	d505      	bpl.n	dd30 <RAMECC_Handler+0x1c>
    dd24:	4b08      	ldr	r3, [pc, #32]	; (dd48 <RAMECC_Handler+0x34>)
    dd26:	681b      	ldr	r3, [r3, #0]
    dd28:	b113      	cbz	r3, dd30 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    dd2a:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    dd2c:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    dd2e:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    dd30:	9b01      	ldr	r3, [sp, #4]
    dd32:	07db      	lsls	r3, r3, #31
    dd34:	d504      	bpl.n	dd40 <RAMECC_Handler+0x2c>
    dd36:	4b04      	ldr	r3, [pc, #16]	; (dd48 <RAMECC_Handler+0x34>)
    dd38:	685b      	ldr	r3, [r3, #4]
    dd3a:	b10b      	cbz	r3, dd40 <RAMECC_Handler+0x2c>
    dd3c:	4a01      	ldr	r2, [pc, #4]	; (dd44 <RAMECC_Handler+0x30>)
    dd3e:	e7f4      	b.n	dd2a <RAMECC_Handler+0x16>
}
    dd40:	b002      	add	sp, #8
    dd42:	4770      	bx	lr
    dd44:	41020000 	.word	0x41020000
    dd48:	20015274 	.word	0x20015274

0000dd4c <hid_mouse_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    dd4c:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    dd4e:	780a      	ldrb	r2, [r1, #0]
    dd50:	2a81      	cmp	r2, #129	; 0x81
    dd52:	d11c      	bne.n	dd8e <hid_mouse_req+0x42>
    dd54:	784b      	ldrb	r3, [r1, #1]
    dd56:	2b06      	cmp	r3, #6
    dd58:	d131      	bne.n	ddbe <hid_mouse_req+0x72>
    dd5a:	4a1a      	ldr	r2, [pc, #104]	; (ddc4 <hid_mouse_req+0x78>)
    dd5c:	888c      	ldrh	r4, [r1, #4]
    dd5e:	7a13      	ldrb	r3, [r2, #8]
    dd60:	429c      	cmp	r4, r3
    dd62:	d12c      	bne.n	ddbe <hid_mouse_req+0x72>
	switch (req->wValue >> 8) {
    dd64:	884b      	ldrh	r3, [r1, #2]
    dd66:	0a1b      	lsrs	r3, r3, #8
    dd68:	2b21      	cmp	r3, #33	; 0x21
    dd6a:	d005      	beq.n	dd78 <hid_mouse_req+0x2c>
    dd6c:	2b22      	cmp	r3, #34	; 0x22
    dd6e:	d00a      	beq.n	dd86 <hid_mouse_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
			switch (req->bRequest) {
    dd70:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    dd74:	bc30      	pop	{r4, r5}
    dd76:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
    dd78:	6811      	ldr	r1, [r2, #0]
    dd7a:	780a      	ldrb	r2, [r1, #0]
    dd7c:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    dd7e:	4c12      	ldr	r4, [pc, #72]	; (ddc8 <hid_mouse_req+0x7c>)
    dd80:	46a4      	mov	ip, r4
}
    dd82:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    dd84:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
    dd86:	4911      	ldr	r1, [pc, #68]	; (ddcc <hid_mouse_req+0x80>)
    dd88:	2300      	movs	r3, #0
    dd8a:	2234      	movs	r2, #52	; 0x34
    dd8c:	e7f7      	b.n	dd7e <hid_mouse_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    dd8e:	f3c2 1241 	ubfx	r2, r2, #5, #2
    dd92:	2a01      	cmp	r2, #1
    dd94:	d113      	bne.n	ddbe <hid_mouse_req+0x72>
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
    dd96:	4c0b      	ldr	r4, [pc, #44]	; (ddc4 <hid_mouse_req+0x78>)
    dd98:	888d      	ldrh	r5, [r1, #4]
    dd9a:	7a23      	ldrb	r3, [r4, #8]
    dd9c:	429d      	cmp	r5, r3
    dd9e:	d10e      	bne.n	ddbe <hid_mouse_req+0x72>
			switch (req->bRequest) {
    dda0:	784b      	ldrb	r3, [r1, #1]
    dda2:	2b03      	cmp	r3, #3
    dda4:	d007      	beq.n	ddb6 <hid_mouse_req+0x6a>
    dda6:	2b0b      	cmp	r3, #11
    dda8:	d1e2      	bne.n	dd70 <hid_mouse_req+0x24>
				_hiddf_mouse_funcd.protocol = req->wValue;
    ddaa:	884b      	ldrh	r3, [r1, #2]
    ddac:	72a3      	strb	r3, [r4, #10]
				return usbdc_xfer(ep, NULL, 0, 0);
    ddae:	2300      	movs	r3, #0
    ddb0:	461a      	mov	r2, r3
    ddb2:	4619      	mov	r1, r3
    ddb4:	e7e3      	b.n	dd7e <hid_mouse_req+0x32>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
    ddb6:	2300      	movs	r3, #0
    ddb8:	f104 010a 	add.w	r1, r4, #10
    ddbc:	e7df      	b.n	dd7e <hid_mouse_req+0x32>
			return ERR_NOT_FOUND;
    ddbe:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    ddc2:	e7d7      	b.n	dd74 <hid_mouse_req+0x28>
    ddc4:	200015f8 	.word	0x200015f8
    ddc8:	00012f99 	.word	0x00012f99
    ddcc:	00016fe4 	.word	0x00016fe4

0000ddd0 <hid_mouse_ctrl>:
	switch (ctrl) {
    ddd0:	2901      	cmp	r1, #1
{
    ddd2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ddd4:	4614      	mov	r4, r2
	switch (ctrl) {
    ddd6:	d03b      	beq.n	de50 <hid_mouse_ctrl+0x80>
    ddd8:	2902      	cmp	r1, #2
    ddda:	d04f      	beq.n	de7c <hid_mouse_ctrl+0xac>
    dddc:	2900      	cmp	r1, #0
    ddde:	d150      	bne.n	de82 <hid_mouse_ctrl+0xb2>
	ifc = desc->sod;
    dde0:	6813      	ldr	r3, [r2, #0]
		return hid_mouse_enable(drv, (struct usbd_descriptors *)param);
    dde2:	6886      	ldr	r6, [r0, #8]
	if (NULL == ifc) {
    dde4:	b91b      	cbnz	r3, ddee <hid_mouse_ctrl+0x1e>
		return ERR_NOT_FOUND;
    dde6:	f06f 0409 	mvn.w	r4, #9
}
    ddea:	4620      	mov	r0, r4
    ddec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    ddee:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    ddf0:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    ddf2:	2903      	cmp	r1, #3
    ddf4:	d1f7      	bne.n	dde6 <hid_mouse_ctrl+0x16>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    ddf6:	7a31      	ldrb	r1, [r6, #8]
    ddf8:	428a      	cmp	r2, r1
    ddfa:	d045      	beq.n	de88 <hid_mouse_ctrl+0xb8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    ddfc:	29ff      	cmp	r1, #255	; 0xff
    ddfe:	d146      	bne.n	de8e <hid_mouse_ctrl+0xbe>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    de00:	7232      	strb	r2, [r6, #8]
    de02:	7818      	ldrb	r0, [r3, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    de04:	6861      	ldr	r1, [r4, #4]
    de06:	4f26      	ldr	r7, [pc, #152]	; (dea0 <hid_mouse_ctrl+0xd0>)
    de08:	2221      	movs	r2, #33	; 0x21
    de0a:	4418      	add	r0, r3
    de0c:	4b25      	ldr	r3, [pc, #148]	; (dea4 <hid_mouse_ctrl+0xd4>)
    de0e:	4798      	blx	r3
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    de10:	6823      	ldr	r3, [r4, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    de12:	6038      	str	r0, [r7, #0]
    de14:	7818      	ldrb	r0, [r3, #0]
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    de16:	6861      	ldr	r1, [r4, #4]
    de18:	4418      	add	r0, r3
    de1a:	4b23      	ldr	r3, [pc, #140]	; (dea8 <hid_mouse_ctrl+0xd8>)
    de1c:	4798      	blx	r3
	desc->sod = ep;
    de1e:	6020      	str	r0, [r4, #0]
	if (NULL != ep) {
    de20:	2800      	cmp	r0, #0
    de22:	d0e0      	beq.n	dde6 <hid_mouse_ctrl+0x16>
	return (ptr[0] + (ptr[1] << 8));
    de24:	7943      	ldrb	r3, [r0, #5]
    de26:	7902      	ldrb	r2, [r0, #4]
		ep_desc.bEndpointAddress = ep[2];
    de28:	7885      	ldrb	r5, [r0, #2]
		if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    de2a:	78c1      	ldrb	r1, [r0, #3]
    de2c:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    de30:	b292      	uxth	r2, r2
    de32:	4b1e      	ldr	r3, [pc, #120]	; (deac <hid_mouse_ctrl+0xdc>)
    de34:	4628      	mov	r0, r5
    de36:	4798      	blx	r3
    de38:	4604      	mov	r4, r0
    de3a:	bb58      	cbnz	r0, de94 <hid_mouse_ctrl+0xc4>
		if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    de3c:	062b      	lsls	r3, r5, #24
    de3e:	d52c      	bpl.n	de9a <hid_mouse_ctrl+0xca>
			usb_d_ep_enable(func_data->func_ep_in);
    de40:	4b1b      	ldr	r3, [pc, #108]	; (deb0 <hid_mouse_ctrl+0xe0>)
			func_data->func_ep_in = ep_desc.bEndpointAddress;
    de42:	7275      	strb	r5, [r6, #9]
			usb_d_ep_enable(func_data->func_ep_in);
    de44:	4628      	mov	r0, r5
    de46:	4798      	blx	r3
	_hiddf_mouse_funcd.protocol = 1;
    de48:	f240 1301 	movw	r3, #257	; 0x101
    de4c:	817b      	strh	r3, [r7, #10]
	return ERR_NONE;
    de4e:	e7cc      	b.n	ddea <hid_mouse_ctrl+0x1a>
		return hid_mouse_disable(drv, (struct usbd_descriptors *)param);
    de50:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    de52:	b11a      	cbz	r2, de5c <hid_mouse_ctrl+0x8c>
		ifc_desc.bInterfaceClass = desc->sod[5];
    de54:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    de56:	795b      	ldrb	r3, [r3, #5]
    de58:	2b03      	cmp	r3, #3
    de5a:	d1c4      	bne.n	dde6 <hid_mouse_ctrl+0x16>
	if (func_data->func_iface != 0xFF) {
    de5c:	7a2b      	ldrb	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    de5e:	7a68      	ldrb	r0, [r5, #9]
	if (func_data->func_iface != 0xFF) {
    de60:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    de62:	bf1c      	itt	ne
    de64:	23ff      	movne	r3, #255	; 0xff
    de66:	722b      	strbne	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    de68:	28ff      	cmp	r0, #255	; 0xff
    de6a:	d003      	beq.n	de74 <hid_mouse_ctrl+0xa4>
		usb_d_ep_deinit(func_data->func_ep_in);
    de6c:	4b11      	ldr	r3, [pc, #68]	; (deb4 <hid_mouse_ctrl+0xe4>)
    de6e:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    de70:	23ff      	movs	r3, #255	; 0xff
    de72:	726b      	strb	r3, [r5, #9]
	_hiddf_mouse_funcd.enabled = false;
    de74:	4b0a      	ldr	r3, [pc, #40]	; (dea0 <hid_mouse_ctrl+0xd0>)
    de76:	2400      	movs	r4, #0
    de78:	72dc      	strb	r4, [r3, #11]
	return ERR_NONE;
    de7a:	e7b6      	b.n	ddea <hid_mouse_ctrl+0x1a>
		return ERR_UNSUPPORTED_OP;
    de7c:	f06f 041a 	mvn.w	r4, #26
    de80:	e7b3      	b.n	ddea <hid_mouse_ctrl+0x1a>
	switch (ctrl) {
    de82:	f06f 040c 	mvn.w	r4, #12
    de86:	e7b0      	b.n	ddea <hid_mouse_ctrl+0x1a>
			return ERR_ALREADY_INITIALIZED;
    de88:	f06f 0411 	mvn.w	r4, #17
    de8c:	e7ad      	b.n	ddea <hid_mouse_ctrl+0x1a>
			return ERR_NO_RESOURCE;
    de8e:	f06f 041b 	mvn.w	r4, #27
    de92:	e7aa      	b.n	ddea <hid_mouse_ctrl+0x1a>
			return ERR_NOT_INITIALIZED;
    de94:	f06f 0413 	mvn.w	r4, #19
    de98:	e7a7      	b.n	ddea <hid_mouse_ctrl+0x1a>
			return ERR_INVALID_DATA;
    de9a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    de9e:	e7a4      	b.n	ddea <hid_mouse_ctrl+0x1a>
    dea0:	200015f8 	.word	0x200015f8
    dea4:	0000b6f5 	.word	0x0000b6f5
    dea8:	0000b70f 	.word	0x0000b70f
    deac:	0000f429 	.word	0x0000f429
    deb0:	0000f4b9 	.word	0x0000f4b9
    deb4:	0000f48d 	.word	0x0000f48d

0000deb8 <hiddf_mouse_init>:

/**
 * \brief Initialize the USB HID Mouse Function Driver
 */
int32_t hiddf_mouse_init(void)
{
    deb8:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    deba:	4b0a      	ldr	r3, [pc, #40]	; (dee4 <hiddf_mouse_init+0x2c>)
    debc:	4798      	blx	r3
    debe:	2801      	cmp	r0, #1
    dec0:	d80c      	bhi.n	dedc <hiddf_mouse_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_mouse.ctrl      = hid_mouse_ctrl;
    dec2:	4809      	ldr	r0, [pc, #36]	; (dee8 <hiddf_mouse_init+0x30>)
    dec4:	4b09      	ldr	r3, [pc, #36]	; (deec <hiddf_mouse_init+0x34>)
	_hiddf_mouse.func_data = &_hiddf_mouse_funcd;
    dec6:	e9c0 3004 	strd	r3, r0, [r0, #16]

	usbdc_register_function(&_hiddf_mouse);
    deca:	4b09      	ldr	r3, [pc, #36]	; (def0 <hiddf_mouse_init+0x38>)
    decc:	300c      	adds	r0, #12
    dece:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_mouse_req_h);
    ded0:	2001      	movs	r0, #1
    ded2:	4908      	ldr	r1, [pc, #32]	; (def4 <hiddf_mouse_init+0x3c>)
    ded4:	4b08      	ldr	r3, [pc, #32]	; (def8 <hiddf_mouse_init+0x40>)
    ded6:	4798      	blx	r3
	return ERR_NONE;
    ded8:	2000      	movs	r0, #0
}
    deda:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    dedc:	f06f 0010 	mvn.w	r0, #16
    dee0:	e7fb      	b.n	deda <hiddf_mouse_init+0x22>
    dee2:	bf00      	nop
    dee4:	000133d1 	.word	0x000133d1
    dee8:	200015f8 	.word	0x200015f8
    deec:	0000ddd1 	.word	0x0000ddd1
    def0:	00013379 	.word	0x00013379
    def4:	200004fc 	.word	0x200004fc
    def8:	000132f1 	.word	0x000132f1

0000defc <hiddf_mouse_move>:
 * \param pos     Signed value to move
 * \param type    HID mouse class pointer move type
 * \return Operation status.
 */
int32_t hiddf_mouse_move(int8_t pos, enum hiddf_mouse_move_type type)
{
    defc:	b410      	push	{r4}

	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    defe:	4c0e      	ldr	r4, [pc, #56]	; (df38 <hiddf_mouse_move+0x3c>)
    df00:	2300      	movs	r3, #0

	if (type == HID_MOUSE_X_AXIS_MV) {
    df02:	2901      	cmp	r1, #1
	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    df04:	6063      	str	r3, [r4, #4]
	if (type == HID_MOUSE_X_AXIS_MV) {
    df06:	d109      	bne.n	df1c <hiddf_mouse_move+0x20>
		_hiddf_mouse_funcd.mouse_report.bytes.x_axis_var = pos;
    df08:	7160      	strb	r0, [r4, #5]
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
	} else {
		return ERR_INVALID_ARG;
	}

	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    df0a:	7a60      	ldrb	r0, [r4, #9]
    df0c:	4c0b      	ldr	r4, [pc, #44]	; (df3c <hiddf_mouse_move+0x40>)
    df0e:	490c      	ldr	r1, [pc, #48]	; (df40 <hiddf_mouse_move+0x44>)
    df10:	46a4      	mov	ip, r4
    df12:	2300      	movs	r3, #0
}
    df14:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    df18:	2204      	movs	r2, #4
    df1a:	4760      	bx	ip
	} else if (type == HID_MOUSE_Y_AXIS_MV) {
    df1c:	2902      	cmp	r1, #2
    df1e:	d101      	bne.n	df24 <hiddf_mouse_move+0x28>
		_hiddf_mouse_funcd.mouse_report.bytes.y_axis_var = pos;
    df20:	71a0      	strb	r0, [r4, #6]
    df22:	e7f2      	b.n	df0a <hiddf_mouse_move+0xe>
	} else if (type == HID_MOUSE_SCROLL_MV) {
    df24:	2903      	cmp	r1, #3
    df26:	d101      	bne.n	df2c <hiddf_mouse_move+0x30>
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
    df28:	71e0      	strb	r0, [r4, #7]
    df2a:	e7ee      	b.n	df0a <hiddf_mouse_move+0xe>
}
    df2c:	f06f 000c 	mvn.w	r0, #12
    df30:	f85d 4b04 	ldr.w	r4, [sp], #4
    df34:	4770      	bx	lr
    df36:	bf00      	nop
    df38:	200015f8 	.word	0x200015f8
    df3c:	00012f99 	.word	0x00012f99
    df40:	200015fc 	.word	0x200015fc

0000df44 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    df44:	b900      	cbnz	r0, df48 <assert+0x4>
		__asm("BKPT #0");
    df46:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    df48:	4770      	bx	lr
	...

0000df4c <_dmac_handler>:
	tmp = ((Dmac *)hw)->INTPEND.reg;
    df4c:	4b10      	ldr	r3, [pc, #64]	; (df90 <_dmac_handler+0x44>)
    df4e:	8c1a      	ldrh	r2, [r3, #32]
}
/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    df50:	b430      	push	{r4, r5}
	tmp = ((Dmac *)hw)->INTPEND.reg;
    df52:	8c1d      	ldrh	r5, [r3, #32]
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
	struct _dma_resource *tmp_resource = &_resources[channel];
    df54:	4c0f      	ldr	r4, [pc, #60]	; (df94 <_dmac_handler+0x48>)
	tmp &= mask;
    df56:	f002 021f 	and.w	r2, r2, #31
    df5a:	210c      	movs	r1, #12
    df5c:	4351      	muls	r1, r2

	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    df5e:	05ed      	lsls	r5, r5, #23
	struct _dma_resource *tmp_resource = &_resources[channel];
    df60:	eb04 0001 	add.w	r0, r4, r1
	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    df64:	d507      	bpl.n	df76 <_dmac_handler+0x2a>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    df66:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    df6a:	2201      	movs	r2, #1
    df6c:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
		tmp_resource->dma_cb.error(tmp_resource);
    df70:	6843      	ldr	r3, [r0, #4]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		tmp_resource->dma_cb.transfer_done(tmp_resource);
	}
}
    df72:	bc30      	pop	{r4, r5}
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    df74:	4718      	bx	r3
	tmp = ((Dmac *)hw)->INTPEND.reg;
    df76:	8c1d      	ldrh	r5, [r3, #32]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
    df78:	05ad      	lsls	r5, r5, #22
    df7a:	d506      	bpl.n	df8a <_dmac_handler+0x3e>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    df7c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    df80:	2202      	movs	r2, #2
    df82:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    df86:	5863      	ldr	r3, [r4, r1]
    df88:	e7f3      	b.n	df72 <_dmac_handler+0x26>
}
    df8a:	bc30      	pop	{r4, r5}
    df8c:	4770      	bx	lr
    df8e:	bf00      	nop
    df90:	4100a000 	.word	0x4100a000
    df94:	20001610 	.word	0x20001610

0000df98 <_dma_init>:
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    df98:	4b3d      	ldr	r3, [pc, #244]	; (e090 <_dma_init+0xf8>)
    df9a:	881a      	ldrh	r2, [r3, #0]
    df9c:	f022 0202 	bic.w	r2, r2, #2
    dfa0:	0412      	lsls	r2, r2, #16
    dfa2:	0c12      	lsrs	r2, r2, #16
{
    dfa4:	b570      	push	{r4, r5, r6, lr}
    dfa6:	801a      	strh	r2, [r3, #0]
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    dfa8:	885a      	ldrh	r2, [r3, #2]
    dfaa:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    dfae:	0412      	lsls	r2, r2, #16
    dfb0:	0c12      	lsrs	r2, r2, #16
    dfb2:	805a      	strh	r2, [r3, #2]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    dfb4:	881a      	ldrh	r2, [r3, #0]
    dfb6:	b292      	uxth	r2, r2
    dfb8:	f042 0201 	orr.w	r2, r2, #1
    dfbc:	801a      	strh	r2, [r3, #0]
	tmp = ((Dmac *)hw)->CTRL.reg;
    dfbe:	881a      	ldrh	r2, [r3, #0]
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    dfc0:	f012 0201 	ands.w	r2, r2, #1
    dfc4:	d1fb      	bne.n	dfbe <_dma_init+0x26>
	((Dmac *)hw)->CTRL.reg = data;
    dfc6:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    dfca:	8019      	strh	r1, [r3, #0]
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    dfcc:	7b59      	ldrb	r1, [r3, #13]
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    dfce:	4831      	ldr	r0, [pc, #196]	; (e094 <_dma_init+0xfc>)
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    dfd0:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << DMAC_DBGCTRL_DBGRUN_Pos;
    dfd4:	f041 0101 	orr.w	r1, r1, #1
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    dfd8:	7359      	strb	r1, [r3, #13]
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    dfda:	492f      	ldr	r1, [pc, #188]	; (e098 <_dma_init+0x100>)
	((Dmac *)hw)->PRICTRL0.reg = data;
    dfdc:	615a      	str	r2, [r3, #20]
	((Dmac *)hw)->BASEADDR.reg = data;
    dfde:	6358      	str	r0, [r3, #52]	; 0x34
	((Dmac *)hw)->WRBADDR.reg = data;
    dfe0:	6399      	str	r1, [r3, #56]	; 0x38
    dfe2:	4613      	mov	r3, r2
    dfe4:	492d      	ldr	r1, [pc, #180]	; (e09c <_dma_init+0x104>)
    dfe6:	4602      	mov	r2, r0
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    dfe8:	461d      	mov	r5, r3
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    dfea:	011c      	lsls	r4, r3, #4
    dfec:	f104 4082 	add.w	r0, r4, #1090519040	; 0x41000000
    dff0:	f500 4020 	add.w	r0, r0, #40960	; 0xa000
    dff4:	680e      	ldr	r6, [r1, #0]

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    dff6:	6406      	str	r6, [r0, #64]	; 0x40
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    dff8:	790e      	ldrb	r6, [r1, #4]

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    dffa:	f880 6045 	strb.w	r6, [r0, #69]	; 0x45
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    dffe:	794e      	ldrb	r6, [r1, #5]

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    e000:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    e004:	3301      	adds	r3, #1
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    e006:	1910      	adds	r0, r2, r4
    e008:	88ce      	ldrh	r6, [r1, #6]
    e00a:	5316      	strh	r6, [r2, r4]
	for (i = 0; i < DMAC_CH_NUM; i++) {
    e00c:	2b20      	cmp	r3, #32
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e00e:	60c5      	str	r5, [r0, #12]
    e010:	f101 0108 	add.w	r1, r1, #8
    e014:	d1e9      	bne.n	dfea <_dma_init+0x52>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e016:	4b22      	ldr	r3, [pc, #136]	; (e0a0 <_dma_init+0x108>)
    e018:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    e01c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    e020:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e024:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e028:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e02c:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e02e:	2201      	movs	r2, #1
    e030:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e034:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e038:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e03c:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e040:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e042:	2202      	movs	r2, #2
    e044:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e048:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e04c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e050:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e054:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e056:	2204      	movs	r2, #4
    e058:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e05c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e060:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e064:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e068:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e06a:	2208      	movs	r2, #8
    e06c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e070:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e074:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e078:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e07c:	605a      	str	r2, [r3, #4]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    e07e:	4a04      	ldr	r2, [pc, #16]	; (e090 <_dma_init+0xf8>)
    e080:	8813      	ldrh	r3, [r2, #0]
    e082:	b29b      	uxth	r3, r3
    e084:	f043 0302 	orr.w	r3, r3, #2
    e088:	8013      	strh	r3, [r2, #0]
}
    e08a:	2000      	movs	r0, #0
    e08c:	bd70      	pop	{r4, r5, r6, pc}
    e08e:	bf00      	nop
    e090:	4100a000 	.word	0x4100a000
    e094:	20015290 	.word	0x20015290
    e098:	20015490 	.word	0x20015490
    e09c:	00017018 	.word	0x00017018
    e0a0:	e000e100 	.word	0xe000e100

0000e0a4 <_dma_set_irq_state>:
	if (DMA_TRANSFER_COMPLETE_CB == type) {
    e0a4:	b939      	cbnz	r1, e0b6 <_dma_set_irq_state+0x12>
	if (value == 0x0) {
    e0a6:	4b08      	ldr	r3, [pc, #32]	; (e0c8 <_dma_set_irq_state+0x24>)
    e0a8:	0100      	lsls	r0, r0, #4
    e0aa:	2102      	movs	r1, #2
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e0ac:	4418      	add	r0, r3
	if (value == 0x0) {
    e0ae:	b93a      	cbnz	r2, e0c0 <_dma_set_irq_state+0x1c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e0b0:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
    e0b4:	4770      	bx	lr
	} else if (DMA_TRANSFER_ERROR_CB == type) {
    e0b6:	2901      	cmp	r1, #1
    e0b8:	d104      	bne.n	e0c4 <_dma_set_irq_state+0x20>
	if (value == 0x0) {
    e0ba:	4b03      	ldr	r3, [pc, #12]	; (e0c8 <_dma_set_irq_state+0x24>)
    e0bc:	0100      	lsls	r0, r0, #4
    e0be:	e7f5      	b.n	e0ac <_dma_set_irq_state+0x8>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
    e0c0:	f880 104d 	strb.w	r1, [r0, #77]	; 0x4d
}
    e0c4:	4770      	bx	lr
    e0c6:	bf00      	nop
    e0c8:	4100a000 	.word	0x4100a000

0000e0cc <_dma_set_destination_address>:
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e0cc:	4b02      	ldr	r3, [pc, #8]	; (e0d8 <_dma_set_destination_address+0xc>)
    e0ce:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e0d2:	6081      	str	r1, [r0, #8]
}
    e0d4:	2000      	movs	r0, #0
    e0d6:	4770      	bx	lr
    e0d8:	20015290 	.word	0x20015290

0000e0dc <_dma_set_source_address>:
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e0dc:	4b02      	ldr	r3, [pc, #8]	; (e0e8 <_dma_set_source_address+0xc>)
    e0de:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e0e2:	6041      	str	r1, [r0, #4]
}
    e0e4:	2000      	movs	r0, #0
    e0e6:	4770      	bx	lr
    e0e8:	20015290 	.word	0x20015290

0000e0ec <_dma_srcinc_enable>:
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e0ec:	4a05      	ldr	r2, [pc, #20]	; (e104 <_dma_srcinc_enable+0x18>)
    e0ee:	0100      	lsls	r0, r0, #4
    e0f0:	5a13      	ldrh	r3, [r2, r0]
    e0f2:	b29b      	uxth	r3, r3
	tmp &= ~DMAC_BTCTRL_SRCINC;
    e0f4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
	tmp |= value << DMAC_BTCTRL_SRCINC_Pos;
    e0f8:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
    e0fc:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->BTCTRL.reg = tmp;
    e0fe:	5211      	strh	r1, [r2, r0]
}
    e100:	2000      	movs	r0, #0
    e102:	4770      	bx	lr
    e104:	20015290 	.word	0x20015290

0000e108 <_dma_set_data_amount>:
	return ((DmacDescriptor *)hw)->DSTADDR.reg;
    e108:	4b0f      	ldr	r3, [pc, #60]	; (e148 <_dma_set_data_amount+0x40>)
{
    e10a:	b570      	push	{r4, r5, r6, lr}
    e10c:	0104      	lsls	r4, r0, #4
    e10e:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e112:	6886      	ldr	r6, [r0, #8]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e114:	5b1a      	ldrh	r2, [r3, r4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e116:	5b1d      	ldrh	r5, [r3, r4]
	tmp = (tmp & DMAC_BTCTRL_BEATSIZE_Msk) >> DMAC_BTCTRL_BEATSIZE_Pos;
    e118:	f3c2 2201 	ubfx	r2, r2, #8, #2
	if (hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(&_descriptor_section[channel])) {
    e11c:	052d      	lsls	r5, r5, #20
		hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e11e:	bf42      	ittt	mi
    e120:	fa01 f502 	lslmi.w	r5, r1, r2
    e124:	19ad      	addmi	r5, r5, r6
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e126:	6085      	strmi	r5, [r0, #8]
	return ((DmacDescriptor *)hw)->SRCADDR.reg;
    e128:	1918      	adds	r0, r3, r4
    e12a:	6845      	ldr	r5, [r0, #4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e12c:	5b1e      	ldrh	r6, [r3, r4]
	if (hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(&_descriptor_section[channel])) {
    e12e:	0576      	lsls	r6, r6, #21
		hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e130:	bf48      	it	mi
    e132:	fa01 f202 	lslmi.w	r2, r1, r2
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e136:	4423      	add	r3, r4
    e138:	bf48      	it	mi
    e13a:	1952      	addmi	r2, r2, r5
	hri_dmacdescriptor_write_BTCNT_reg(&_descriptor_section[channel], amount);
    e13c:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e13e:	bf48      	it	mi
    e140:	6042      	strmi	r2, [r0, #4]
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e142:	8059      	strh	r1, [r3, #2]
}
    e144:	2000      	movs	r0, #0
    e146:	bd70      	pop	{r4, r5, r6, pc}
    e148:	20015290 	.word	0x20015290

0000e14c <_dma_enable_transaction>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_VALID;
    e14c:	0102      	lsls	r2, r0, #4
{
    e14e:	b510      	push	{r4, lr}
    e150:	4c0b      	ldr	r4, [pc, #44]	; (e180 <_dma_enable_transaction+0x34>)
    e152:	5aa3      	ldrh	r3, [r4, r2]
    e154:	b29b      	uxth	r3, r3
    e156:	f043 0301 	orr.w	r3, r3, #1
    e15a:	52a3      	strh	r3, [r4, r2]
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    e15c:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    e160:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    e164:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    e166:	f042 0202 	orr.w	r2, r2, #2
    e16a:	641a      	str	r2, [r3, #64]	; 0x40
	if (software_trigger) {
    e16c:	b131      	cbz	r1, e17c <_dma_enable_transaction+0x30>
	((Dmac *)hw)->SWTRIGCTRL.reg |= mask;
    e16e:	4a05      	ldr	r2, [pc, #20]	; (e184 <_dma_enable_transaction+0x38>)
		hri_dmac_set_SWTRIGCTRL_reg(DMAC, 1 << channel);
    e170:	2301      	movs	r3, #1
    e172:	6911      	ldr	r1, [r2, #16]
    e174:	fa03 f000 	lsl.w	r0, r3, r0
    e178:	4308      	orrs	r0, r1
    e17a:	6110      	str	r0, [r2, #16]
}
    e17c:	2000      	movs	r0, #0
    e17e:	bd10      	pop	{r4, pc}
    e180:	20015290 	.word	0x20015290
    e184:	4100a000 	.word	0x4100a000

0000e188 <_dma_get_channel_resource>:
	*resource = &_resources[channel];
    e188:	4b03      	ldr	r3, [pc, #12]	; (e198 <_dma_get_channel_resource+0x10>)
    e18a:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    e18e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    e192:	6001      	str	r1, [r0, #0]
}
    e194:	2000      	movs	r0, #0
    e196:	4770      	bx	lr
    e198:	20001610 	.word	0x20001610

0000e19c <DMAC_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void DMAC_0_Handler(void)
{
	_dmac_handler();
    e19c:	4b00      	ldr	r3, [pc, #0]	; (e1a0 <DMAC_0_Handler+0x4>)
    e19e:	4718      	bx	r3
    e1a0:	0000df4d 	.word	0x0000df4d

0000e1a4 <DMAC_1_Handler>:
    e1a4:	4b00      	ldr	r3, [pc, #0]	; (e1a8 <DMAC_1_Handler+0x4>)
    e1a6:	4718      	bx	r3
    e1a8:	0000df4d 	.word	0x0000df4d

0000e1ac <DMAC_2_Handler>:
    e1ac:	4b00      	ldr	r3, [pc, #0]	; (e1b0 <DMAC_2_Handler+0x4>)
    e1ae:	4718      	bx	r3
    e1b0:	0000df4d 	.word	0x0000df4d

0000e1b4 <DMAC_3_Handler>:
    e1b4:	4b00      	ldr	r3, [pc, #0]	; (e1b8 <DMAC_3_Handler+0x4>)
    e1b6:	4718      	bx	r3
    e1b8:	0000df4d 	.word	0x0000df4d

0000e1bc <DMAC_4_Handler>:
    e1bc:	4b00      	ldr	r3, [pc, #0]	; (e1c0 <DMAC_4_Handler+0x4>)
    e1be:	4718      	bx	r3
    e1c0:	0000df4d 	.word	0x0000df4d

0000e1c4 <adc_async_window_threshold_reached>:

static void adc_async_window_threshold_reached(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.monitor) {
    e1c4:	6983      	ldr	r3, [r0, #24]
    e1c6:	b103      	cbz	r3, e1ca <adc_async_window_threshold_reached+0x6>
		descr->adc_async_cb.monitor(descr, channel);
    e1c8:	4718      	bx	r3
	}
}
    e1ca:	4770      	bx	lr

0000e1cc <adc_async_error_occured>:

static void adc_async_error_occured(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.error) {
    e1cc:	69c3      	ldr	r3, [r0, #28]
    e1ce:	b103      	cbz	r3, e1d2 <adc_async_error_occured+0x6>
		descr->adc_async_cb.error(descr, channel);
    e1d0:	4718      	bx	r3
	}
}
    e1d2:	4770      	bx	lr

0000e1d4 <adc_async_channel_conversion_done>:
{
    e1d4:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t                              index    = descr->channel_map[channel];
    e1d8:	6a03      	ldr	r3, [r0, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e1da:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
    e1de:	5c5c      	ldrb	r4, [r3, r1]
	ringbuffer_put(&descr_ch->convert, data);
    e1e0:	f8df a054 	ldr.w	sl, [pc, #84]	; e238 <adc_async_channel_conversion_done+0x64>
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e1e4:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e1e8:	ea4f 09c4 	mov.w	r9, r4, lsl #3
    e1ec:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
	ringbuffer_put(&descr_ch->convert, data);
    e1f0:	f104 0b04 	add.w	fp, r4, #4
{
    e1f4:	4605      	mov	r5, r0
    e1f6:	460e      	mov	r6, r1
	ringbuffer_put(&descr_ch->convert, data);
    e1f8:	4658      	mov	r0, fp
    e1fa:	b2d1      	uxtb	r1, r2
{
    e1fc:	4617      	mov	r7, r2
	ringbuffer_put(&descr_ch->convert, data);
    e1fe:	47d0      	blx	sl
	if (1 < _adc_async_get_data_size(&descr->device)) {
    e200:	4b0c      	ldr	r3, [pc, #48]	; (e234 <adc_async_channel_conversion_done+0x60>)
    e202:	4628      	mov	r0, r5
    e204:	4798      	blx	r3
    e206:	2801      	cmp	r0, #1
    e208:	d905      	bls.n	e216 <adc_async_channel_conversion_done+0x42>
		ringbuffer_put(&descr_ch->convert, data >> 8);
    e20a:	0a39      	lsrs	r1, r7, #8
    e20c:	4658      	mov	r0, fp
    e20e:	47d0      	blx	sl
		++descr_ch->bytes_in_buffer;
    e210:	8aa3      	ldrh	r3, [r4, #20]
    e212:	3301      	adds	r3, #1
    e214:	82a3      	strh	r3, [r4, #20]
	++descr_ch->bytes_in_buffer;
    e216:	8aa3      	ldrh	r3, [r4, #20]
    e218:	3301      	adds	r3, #1
    e21a:	82a3      	strh	r3, [r4, #20]
	if (descr_ch->adc_async_ch_cb.convert_done) {
    e21c:	f858 3009 	ldr.w	r3, [r8, r9]
    e220:	b12b      	cbz	r3, e22e <adc_async_channel_conversion_done+0x5a>
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e222:	4631      	mov	r1, r6
    e224:	4628      	mov	r0, r5
}
    e226:	b001      	add	sp, #4
    e228:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e22c:	4718      	bx	r3
}
    e22e:	b001      	add	sp, #4
    e230:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e234:	00012d19 	.word	0x00012d19
    e238:	000119a9 	.word	0x000119a9

0000e23c <adc_async_init>:
{
    e23c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e240:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    e244:	f89d 8020 	ldrb.w	r8, [sp, #32]
    e248:	460e      	mov	r6, r1
    e24a:	4615      	mov	r5, r2
    e24c:	461f      	mov	r7, r3
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e24e:	4604      	mov	r4, r0
    e250:	b150      	cbz	r0, e268 <adc_async_init+0x2c>
    e252:	2900      	cmp	r1, #0
    e254:	d032      	beq.n	e2bc <adc_async_init+0x80>
    e256:	2a00      	cmp	r2, #0
    e258:	d032      	beq.n	e2c0 <adc_async_init+0x84>
    e25a:	f1b8 0f00 	cmp.w	r8, #0
    e25e:	d031      	beq.n	e2c4 <adc_async_init+0x88>
    e260:	f1b9 0000 	subs.w	r0, r9, #0
    e264:	bf18      	it	ne
    e266:	2001      	movne	r0, #1
    e268:	4917      	ldr	r1, [pc, #92]	; (e2c8 <adc_async_init+0x8c>)
    e26a:	f8df a070 	ldr.w	sl, [pc, #112]	; e2dc <adc_async_init+0xa0>
    e26e:	223f      	movs	r2, #63	; 0x3f
    e270:	47d0      	blx	sl
	ASSERT(channel_amount <= (channel_max + 1));
    e272:	1c78      	adds	r0, r7, #1
    e274:	4580      	cmp	r8, r0
    e276:	4914      	ldr	r1, [pc, #80]	; (e2c8 <adc_async_init+0x8c>)
    e278:	f04f 0240 	mov.w	r2, #64	; 0x40
    e27c:	bfcc      	ite	gt
    e27e:	2000      	movgt	r0, #0
    e280:	2001      	movle	r0, #1
    e282:	47d0      	blx	sl
	device = &descr->device;
    e284:	2300      	movs	r3, #0
		channel_map[i] = 0xFF;
    e286:	21ff      	movs	r1, #255	; 0xff
    e288:	b2da      	uxtb	r2, r3
    e28a:	3301      	adds	r3, #1
    e28c:	54a9      	strb	r1, [r5, r2]
	for (uint8_t i = 0; i <= channel_max; i++) {
    e28e:	b2da      	uxtb	r2, r3
    e290:	4297      	cmp	r7, r2
    e292:	d2f9      	bcs.n	e288 <adc_async_init+0x4c>
	init_status           = _adc_async_init(device, hw);
    e294:	4b0d      	ldr	r3, [pc, #52]	; (e2cc <adc_async_init+0x90>)
	descr->channel_map    = channel_map;
    e296:	6225      	str	r5, [r4, #32]
	descr->channel_max    = channel_max;
    e298:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	descr->channel_amount = channel_amount;
    e29c:	f884 8025 	strb.w	r8, [r4, #37]	; 0x25
	descr->descr_ch       = descr_ch;
    e2a0:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	init_status           = _adc_async_init(device, hw);
    e2a4:	4631      	mov	r1, r6
    e2a6:	4620      	mov	r0, r4
    e2a8:	4798      	blx	r3
	if (init_status) {
    e2aa:	b928      	cbnz	r0, e2b8 <adc_async_init+0x7c>
	device->adc_async_ch_cb.convert_done = adc_async_channel_conversion_done;
    e2ac:	4b08      	ldr	r3, [pc, #32]	; (e2d0 <adc_async_init+0x94>)
    e2ae:	60a3      	str	r3, [r4, #8]
	device->adc_async_cb.window_cb       = adc_async_window_threshold_reached;
    e2b0:	4b08      	ldr	r3, [pc, #32]	; (e2d4 <adc_async_init+0x98>)
    e2b2:	6023      	str	r3, [r4, #0]
	device->adc_async_cb.error_cb        = adc_async_error_occured;
    e2b4:	4b08      	ldr	r3, [pc, #32]	; (e2d8 <adc_async_init+0x9c>)
    e2b6:	6063      	str	r3, [r4, #4]
}
    e2b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e2bc:	4608      	mov	r0, r1
    e2be:	e7d3      	b.n	e268 <adc_async_init+0x2c>
    e2c0:	4610      	mov	r0, r2
    e2c2:	e7d1      	b.n	e268 <adc_async_init+0x2c>
    e2c4:	4640      	mov	r0, r8
    e2c6:	e7cf      	b.n	e268 <adc_async_init+0x2c>
    e2c8:	00017118 	.word	0x00017118
    e2cc:	00012c41 	.word	0x00012c41
    e2d0:	0000e1d5 	.word	0x0000e1d5
    e2d4:	0000e1c5 	.word	0x0000e1c5
    e2d8:	0000e1cd 	.word	0x0000e1cd
    e2dc:	0000df45 	.word	0x0000df45

0000e2e0 <adc_async_register_channel_buffer>:
{
    e2e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e2e4:	460e      	mov	r6, r1
    e2e6:	4617      	mov	r7, r2
    e2e8:	4698      	mov	r8, r3
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e2ea:	4604      	mov	r4, r0
    e2ec:	b118      	cbz	r0, e2f6 <adc_async_register_channel_buffer+0x16>
    e2ee:	b1c2      	cbz	r2, e322 <adc_async_register_channel_buffer+0x42>
    e2f0:	1e18      	subs	r0, r3, #0
    e2f2:	bf18      	it	ne
    e2f4:	2001      	movne	r0, #1
    e2f6:	4921      	ldr	r1, [pc, #132]	; (e37c <adc_async_register_channel_buffer+0x9c>)
    e2f8:	4d21      	ldr	r5, [pc, #132]	; (e380 <adc_async_register_channel_buffer+0xa0>)
    e2fa:	2266      	movs	r2, #102	; 0x66
    e2fc:	47a8      	blx	r5
	ASSERT(descr->channel_max >= channel);
    e2fe:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e302:	491e      	ldr	r1, [pc, #120]	; (e37c <adc_async_register_channel_buffer+0x9c>)
    e304:	42b0      	cmp	r0, r6
    e306:	f04f 0267 	mov.w	r2, #103	; 0x67
    e30a:	bf34      	ite	cc
    e30c:	2000      	movcc	r0, #0
    e30e:	2001      	movcs	r0, #1
    e310:	47a8      	blx	r5
	if (descr->channel_map[channel] != 0xFF) {
    e312:	6a23      	ldr	r3, [r4, #32]
    e314:	5d9a      	ldrb	r2, [r3, r6]
    e316:	2aff      	cmp	r2, #255	; 0xff
    e318:	d005      	beq.n	e326 <adc_async_register_channel_buffer+0x46>
		return ERR_INVALID_ARG;
    e31a:	f06f 000c 	mvn.w	r0, #12
}
    e31e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e322:	4610      	mov	r0, r2
    e324:	e7e7      	b.n	e2f6 <adc_async_register_channel_buffer+0x16>
	for (i = 0; i <= descr->channel_max; i++) {
    e326:	2200      	movs	r2, #0
    e328:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	uint8_t i, index = 0;
    e32c:	4615      	mov	r5, r2
		if (descr->channel_map[i] != 0xFF) {
    e32e:	b2d1      	uxtb	r1, r2
    e330:	3201      	adds	r2, #1
    e332:	5c59      	ldrb	r1, [r3, r1]
    e334:	29ff      	cmp	r1, #255	; 0xff
			index++;
    e336:	bf18      	it	ne
    e338:	3501      	addne	r5, #1
	for (i = 0; i <= descr->channel_max; i++) {
    e33a:	b2d1      	uxtb	r1, r2
			index++;
    e33c:	bf18      	it	ne
    e33e:	b2ed      	uxtbne	r5, r5
	for (i = 0; i <= descr->channel_max; i++) {
    e340:	4288      	cmp	r0, r1
    e342:	d2f4      	bcs.n	e32e <adc_async_register_channel_buffer+0x4e>
	if (index > descr->channel_amount) {
    e344:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e348:	42ab      	cmp	r3, r5
    e34a:	d313      	bcc.n	e374 <adc_async_register_channel_buffer+0x94>
	if (ERR_NONE != ringbuffer_init(&descr->descr_ch[index].convert, convert_buffer, convert_buffer_length)) {
    e34c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e34e:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    e352:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    e356:	ea4f 09c3 	mov.w	r9, r3, lsl #3
    e35a:	4642      	mov	r2, r8
    e35c:	4b09      	ldr	r3, [pc, #36]	; (e384 <adc_async_register_channel_buffer+0xa4>)
    e35e:	4639      	mov	r1, r7
    e360:	3004      	adds	r0, #4
    e362:	4798      	blx	r3
    e364:	2800      	cmp	r0, #0
    e366:	d1d8      	bne.n	e31a <adc_async_register_channel_buffer+0x3a>
	descr->channel_map[channel]            = index;
    e368:	6a23      	ldr	r3, [r4, #32]
    e36a:	559d      	strb	r5, [r3, r6]
	descr->descr_ch[index].bytes_in_buffer = 0;
    e36c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e36e:	444b      	add	r3, r9
    e370:	8298      	strh	r0, [r3, #20]
	return ERR_NONE;
    e372:	e7d4      	b.n	e31e <adc_async_register_channel_buffer+0x3e>
		return ERR_NO_RESOURCE;
    e374:	f06f 001b 	mvn.w	r0, #27
    e378:	e7d1      	b.n	e31e <adc_async_register_channel_buffer+0x3e>
    e37a:	bf00      	nop
    e37c:	00017118 	.word	0x00017118
    e380:	0000df45 	.word	0x0000df45
    e384:	0001192d 	.word	0x0001192d

0000e388 <adc_async_enable_channel>:
{
    e388:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    e38a:	4604      	mov	r4, r0
    e38c:	3800      	subs	r0, #0
{
    e38e:	460d      	mov	r5, r1
	ASSERT(descr);
    e390:	bf18      	it	ne
    e392:	2001      	movne	r0, #1
    e394:	4e09      	ldr	r6, [pc, #36]	; (e3bc <adc_async_enable_channel+0x34>)
    e396:	490a      	ldr	r1, [pc, #40]	; (e3c0 <adc_async_enable_channel+0x38>)
    e398:	2283      	movs	r2, #131	; 0x83
    e39a:	47b0      	blx	r6
	ASSERT(descr->channel_max >= channel);
    e39c:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e3a0:	4907      	ldr	r1, [pc, #28]	; (e3c0 <adc_async_enable_channel+0x38>)
    e3a2:	42a8      	cmp	r0, r5
    e3a4:	bf34      	ite	cc
    e3a6:	2000      	movcc	r0, #0
    e3a8:	2001      	movcs	r0, #1
    e3aa:	2284      	movs	r2, #132	; 0x84
    e3ac:	47b0      	blx	r6
	_adc_async_enable_channel(&descr->device, channel);
    e3ae:	4620      	mov	r0, r4
    e3b0:	4b04      	ldr	r3, [pc, #16]	; (e3c4 <adc_async_enable_channel+0x3c>)
    e3b2:	4629      	mov	r1, r5
    e3b4:	4798      	blx	r3
}
    e3b6:	2000      	movs	r0, #0
    e3b8:	bd70      	pop	{r4, r5, r6, pc}
    e3ba:	bf00      	nop
    e3bc:	0000df45 	.word	0x0000df45
    e3c0:	00017118 	.word	0x00017118
    e3c4:	00012d0d 	.word	0x00012d0d

0000e3c8 <adc_async_register_callback>:
{
    e3c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(descr);
    e3cc:	4604      	mov	r4, r0
    e3ce:	3800      	subs	r0, #0
    e3d0:	bf18      	it	ne
    e3d2:	2001      	movne	r0, #1
    e3d4:	f8df 8064 	ldr.w	r8, [pc, #100]	; e43c <adc_async_register_callback+0x74>
{
    e3d8:	460f      	mov	r7, r1
    e3da:	4615      	mov	r5, r2
	ASSERT(descr);
    e3dc:	4915      	ldr	r1, [pc, #84]	; (e434 <adc_async_register_callback+0x6c>)
    e3de:	229c      	movs	r2, #156	; 0x9c
{
    e3e0:	461e      	mov	r6, r3
	ASSERT(descr);
    e3e2:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e3e4:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e3e8:	4912      	ldr	r1, [pc, #72]	; (e434 <adc_async_register_callback+0x6c>)
    e3ea:	42b8      	cmp	r0, r7
    e3ec:	bf34      	ite	cc
    e3ee:	2000      	movcc	r0, #0
    e3f0:	2001      	movcs	r0, #1
    e3f2:	229d      	movs	r2, #157	; 0x9d
    e3f4:	47c0      	blx	r8
	switch (type) {
    e3f6:	2d01      	cmp	r5, #1
    e3f8:	d014      	beq.n	e424 <adc_async_register_callback+0x5c>
    e3fa:	2d02      	cmp	r5, #2
    e3fc:	d014      	beq.n	e428 <adc_async_register_callback+0x60>
    e3fe:	b9ad      	cbnz	r5, e42c <adc_async_register_callback+0x64>
	uint8_t index = descr->channel_map[channel];
    e400:	6a23      	ldr	r3, [r4, #32]
		descr->descr_ch[index].adc_async_ch_cb.convert_done = cb;
    e402:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e404:	5ddb      	ldrb	r3, [r3, r7]
    e406:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e40a:	f842 6033 	str.w	r6, [r2, r3, lsl #3]
	_adc_async_set_irq_state(&descr->device, channel, (enum _adc_async_callback_type)type, cb != NULL);
    e40e:	1e33      	subs	r3, r6, #0
    e410:	4620      	mov	r0, r4
    e412:	bf18      	it	ne
    e414:	2301      	movne	r3, #1
    e416:	4c08      	ldr	r4, [pc, #32]	; (e438 <adc_async_register_callback+0x70>)
    e418:	462a      	mov	r2, r5
    e41a:	4639      	mov	r1, r7
    e41c:	47a0      	blx	r4
	return ERR_NONE;
    e41e:	2000      	movs	r0, #0
}
    e420:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		descr->adc_async_cb.monitor = cb;
    e424:	61a6      	str	r6, [r4, #24]
		break;
    e426:	e7f2      	b.n	e40e <adc_async_register_callback+0x46>
		descr->adc_async_cb.error = cb;
    e428:	61e6      	str	r6, [r4, #28]
		break;
    e42a:	e7f0      	b.n	e40e <adc_async_register_callback+0x46>
	switch (type) {
    e42c:	f06f 000c 	mvn.w	r0, #12
    e430:	e7f6      	b.n	e420 <adc_async_register_callback+0x58>
    e432:	bf00      	nop
    e434:	00017118 	.word	0x00017118
    e438:	00012d45 	.word	0x00012d45
    e43c:	0000df45 	.word	0x0000df45

0000e440 <adc_async_read_channel>:
{
    e440:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    e444:	460e      	mov	r6, r1
    e446:	4617      	mov	r7, r2
    e448:	461d      	mov	r5, r3
	ASSERT(descr && buffer && length);
    e44a:	4604      	mov	r4, r0
    e44c:	b120      	cbz	r0, e458 <adc_async_read_channel+0x18>
    e44e:	2a00      	cmp	r2, #0
    e450:	d03f      	beq.n	e4d2 <adc_async_read_channel+0x92>
    e452:	1e18      	subs	r0, r3, #0
    e454:	bf18      	it	ne
    e456:	2001      	movne	r0, #1
    e458:	f8df 8098 	ldr.w	r8, [pc, #152]	; e4f4 <adc_async_read_channel+0xb4>
    e45c:	4920      	ldr	r1, [pc, #128]	; (e4e0 <adc_async_read_channel+0xa0>)
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e45e:	f8df a098 	ldr.w	sl, [pc, #152]	; e4f8 <adc_async_read_channel+0xb8>
	ASSERT(descr && buffer && length);
    e462:	22bc      	movs	r2, #188	; 0xbc
    e464:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e466:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e46a:	491d      	ldr	r1, [pc, #116]	; (e4e0 <adc_async_read_channel+0xa0>)
    e46c:	42b0      	cmp	r0, r6
    e46e:	bf34      	ite	cc
    e470:	2000      	movcc	r0, #0
    e472:	2001      	movcs	r0, #1
    e474:	22bd      	movs	r2, #189	; 0xbd
    e476:	47c0      	blx	r8
	data_size = _adc_async_get_data_size(&descr->device);
    e478:	4b1a      	ldr	r3, [pc, #104]	; (e4e4 <adc_async_read_channel+0xa4>)
    e47a:	4620      	mov	r0, r4
    e47c:	4798      	blx	r3
	ASSERT(!(length % data_size));
    e47e:	fbb5 f3f0 	udiv	r3, r5, r0
    e482:	fb03 5010 	mls	r0, r3, r0, r5
    e486:	fab0 f080 	clz	r0, r0
    e48a:	4915      	ldr	r1, [pc, #84]	; (e4e0 <adc_async_read_channel+0xa0>)
    e48c:	22bf      	movs	r2, #191	; 0xbf
    e48e:	0940      	lsrs	r0, r0, #5
    e490:	47c0      	blx	r8
	index                                         = descr->channel_map[channel];
    e492:	6a23      	ldr	r3, [r4, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e494:	5d9e      	ldrb	r6, [r3, r6]
    e496:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e498:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    e49c:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
	CRITICAL_SECTION_ENTER()
    e4a0:	a801      	add	r0, sp, #4
    e4a2:	4b11      	ldr	r3, [pc, #68]	; (e4e8 <adc_async_read_channel+0xa8>)
	num = ringbuffer_num(&descr_ch->convert);
    e4a4:	f106 0904 	add.w	r9, r6, #4
	CRITICAL_SECTION_ENTER()
    e4a8:	4798      	blx	r3
	num = ringbuffer_num(&descr_ch->convert);
    e4aa:	4b10      	ldr	r3, [pc, #64]	; (e4ec <adc_async_read_channel+0xac>)
    e4ac:	4648      	mov	r0, r9
    e4ae:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    e4b0:	4b0f      	ldr	r3, [pc, #60]	; (e4f0 <adc_async_read_channel+0xb0>)
	num = ringbuffer_num(&descr_ch->convert);
    e4b2:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
    e4b4:	a801      	add	r0, sp, #4
    e4b6:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    e4b8:	2400      	movs	r4, #0
    e4ba:	45a0      	cmp	r8, r4
    e4bc:	b2a2      	uxth	r2, r4
    e4be:	d001      	beq.n	e4c4 <adc_async_read_channel+0x84>
    e4c0:	42a5      	cmp	r5, r4
    e4c2:	d108      	bne.n	e4d6 <adc_async_read_channel+0x96>
	descr_ch->bytes_in_buffer -= was_read;
    e4c4:	8ab3      	ldrh	r3, [r6, #20]
}
    e4c6:	4620      	mov	r0, r4
	descr_ch->bytes_in_buffer -= was_read;
    e4c8:	1a9b      	subs	r3, r3, r2
    e4ca:	82b3      	strh	r3, [r6, #20]
}
    e4cc:	b002      	add	sp, #8
    e4ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && buffer && length);
    e4d2:	4610      	mov	r0, r2
    e4d4:	e7c0      	b.n	e458 <adc_async_read_channel+0x18>
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e4d6:	1939      	adds	r1, r7, r4
    e4d8:	4648      	mov	r0, r9
    e4da:	47d0      	blx	sl
    e4dc:	3401      	adds	r4, #1
    e4de:	e7ec      	b.n	e4ba <adc_async_read_channel+0x7a>
    e4e0:	00017118 	.word	0x00017118
    e4e4:	00012d19 	.word	0x00012d19
    e4e8:	00011a11 	.word	0x00011a11
    e4ec:	000119ed 	.word	0x000119ed
    e4f0:	00011a1f 	.word	0x00011a1f
    e4f4:	0000df45 	.word	0x0000df45
    e4f8:	00011969 	.word	0x00011969

0000e4fc <adc_async_start_conversion>:
{
    e4fc:	b510      	push	{r4, lr}
	ASSERT(descr);
    e4fe:	4604      	mov	r4, r0
    e500:	3800      	subs	r0, #0
    e502:	bf18      	it	ne
    e504:	2001      	movne	r0, #1
    e506:	4904      	ldr	r1, [pc, #16]	; (e518 <adc_async_start_conversion+0x1c>)
    e508:	4b04      	ldr	r3, [pc, #16]	; (e51c <adc_async_start_conversion+0x20>)
    e50a:	22d6      	movs	r2, #214	; 0xd6
    e50c:	4798      	blx	r3
	_adc_async_convert(&descr->device);
    e50e:	4620      	mov	r0, r4
    e510:	4b03      	ldr	r3, [pc, #12]	; (e520 <adc_async_start_conversion+0x24>)
    e512:	4798      	blx	r3
}
    e514:	2000      	movs	r0, #0
    e516:	bd10      	pop	{r4, pc}
    e518:	00017118 	.word	0x00017118
    e51c:	0000df45 	.word	0x0000df45
    e520:	00012d2d 	.word	0x00012d2d

0000e524 <_oscctrl_init_sources>:
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    e524:	4770      	bx	lr
	...

0000e528 <_oscctrl_init_referenced_generators>:

static inline void hri_gclk_write_GENCTRL_SRC_bf(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	uint32_t tmp;
	GCLK_CRITICAL_SECTION_ENTER();
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    e528:	4b3b      	ldr	r3, [pc, #236]	; (e618 <_oscctrl_init_referenced_generators+0xf0>)
    e52a:	6a1a      	ldr	r2, [r3, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    e52c:	f022 020f 	bic.w	r2, r2, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    e530:	f042 0204 	orr.w	r2, r2, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    e534:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    e536:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    e53a:	6859      	ldr	r1, [r3, #4]
    e53c:	4211      	tst	r1, r2
    e53e:	d1fc      	bne.n	e53a <_oscctrl_init_referenced_generators+0x12>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    e540:	685a      	ldr	r2, [r3, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    e542:	0750      	lsls	r0, r2, #29
    e544:	f3c2 0180 	ubfx	r1, r2, #2, #1
    e548:	d4fa      	bmi.n	e540 <_oscctrl_init_referenced_generators+0x18>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e54a:	4b34      	ldr	r3, [pc, #208]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    e54c:	4a34      	ldr	r2, [pc, #208]	; (e620 <_oscctrl_init_referenced_generators+0xf8>)
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e54e:	7719      	strb	r1, [r3, #28]
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    e550:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e552:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    e556:	f3c2 1100 	ubfx	r1, r2, #4, #1
    e55a:	06d2      	lsls	r2, r2, #27
    e55c:	d4f9      	bmi.n	e552 <_oscctrl_init_referenced_generators+0x2a>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    e55e:	f883 1020 	strb.w	r1, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e562:	4b2e      	ldr	r3, [pc, #184]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
    e564:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    e568:	0750      	lsls	r0, r2, #29
    e56a:	d4fb      	bmi.n	e564 <_oscctrl_init_referenced_generators+0x3c>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    e56c:	2202      	movs	r2, #2
    e56e:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e570:	4b2a      	ldr	r3, [pc, #168]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
    e572:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    e576:	0791      	lsls	r1, r2, #30
    e578:	d4fb      	bmi.n	e572 <_oscctrl_init_referenced_generators+0x4a>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    e57a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    e57c:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e57e:	4b27      	ldr	r3, [pc, #156]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
    e580:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    e584:	0712      	lsls	r2, r2, #28
    e586:	d4fb      	bmi.n	e580 <_oscctrl_init_referenced_generators+0x58>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    e588:	2288      	movs	r2, #136	; 0x88
    e58a:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    e58e:	4a23      	ldr	r2, [pc, #140]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
    e590:	4613      	mov	r3, r2
    e592:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    e596:	0748      	lsls	r0, r1, #29
    e598:	d4fb      	bmi.n	e592 <_oscctrl_init_referenced_generators+0x6a>
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    e59a:	491f      	ldr	r1, [pc, #124]	; (e618 <_oscctrl_init_referenced_generators+0xf0>)
    e59c:	2042      	movs	r0, #66	; 0x42
    e59e:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    e5a2:	2127      	movs	r1, #39	; 0x27
    e5a4:	6491      	str	r1, [r2, #72]	; 0x48
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    e5a6:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    e5a8:	f012 0f06 	tst.w	r2, #6
    e5ac:	d1fb      	bne.n	e5a6 <_oscctrl_init_referenced_generators+0x7e>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    e5ae:	f44f 6200 	mov.w	r2, #2048	; 0x800
    e5b2:	64da      	str	r2, [r3, #76]	; 0x4c
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    e5b4:	2202      	movs	r2, #2
    e5b6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    e5ba:	4b18      	ldr	r3, [pc, #96]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
    e5bc:	461a      	mov	r2, r3
    e5be:	6d19      	ldr	r1, [r3, #80]	; 0x50
    e5c0:	0789      	lsls	r1, r1, #30
    e5c2:	d4fc      	bmi.n	e5be <_oscctrl_init_referenced_generators+0x96>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    e5c4:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    e5c8:	07db      	lsls	r3, r3, #31
    e5ca:	d521      	bpl.n	e610 <_oscctrl_init_referenced_generators+0xe8>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    e5cc:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    e5ce:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    e5d2:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    e5d6:	d1f9      	bne.n	e5cc <_oscctrl_init_referenced_generators+0xa4>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    e5d8:	4b10      	ldr	r3, [pc, #64]	; (e61c <_oscctrl_init_referenced_generators+0xf4>)
    e5da:	6d5a      	ldr	r2, [r3, #84]	; 0x54
#endif
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 1) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 1)))
    e5dc:	07d1      	lsls	r1, r2, #31
    e5de:	d402      	bmi.n	e5e6 <_oscctrl_init_referenced_generators+0xbe>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    e5e0:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    e5e2:	0792      	lsls	r2, r2, #30
    e5e4:	d5f9      	bpl.n	e5da <_oscctrl_init_referenced_generators+0xb2>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    e5e6:	4a0c      	ldr	r2, [pc, #48]	; (e618 <_oscctrl_init_referenced_generators+0xf0>)
    e5e8:	4611      	mov	r1, r2
    e5ea:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    e5ec:	2b00      	cmp	r3, #0
    e5ee:	d1fc      	bne.n	e5ea <_oscctrl_init_referenced_generators+0xc2>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    e5f0:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    e5f2:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    e5f6:	f043 0308 	orr.w	r3, r3, #8
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    e5fa:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    e5fc:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    e600:	684a      	ldr	r2, [r1, #4]
    e602:	421a      	tst	r2, r3
    e604:	d1fc      	bne.n	e600 <_oscctrl_init_referenced_generators+0xd8>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    e606:	4a04      	ldr	r2, [pc, #16]	; (e618 <_oscctrl_init_referenced_generators+0xf0>)
    e608:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    e60a:	075b      	lsls	r3, r3, #29
    e60c:	d4fc      	bmi.n	e608 <_oscctrl_init_referenced_generators+0xe0>
		;
#endif
	(void)hw;
}
    e60e:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    e610:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    e612:	05d8      	lsls	r0, r3, #23
    e614:	d5fc      	bpl.n	e610 <_oscctrl_init_referenced_generators+0xe8>
    e616:	e7df      	b.n	e5d8 <_oscctrl_init_referenced_generators+0xb0>
    e618:	40001c00 	.word	0x40001c00
    e61c:	40001000 	.word	0x40001000
    e620:	04010000 	.word	0x04010000

0000e624 <_rand_sync_read_data>:

/**
 * \brief Read data bits
 */
static uint32_t _rand_sync_read_data(const struct _rand_sync_dev *dev, const uint8_t n_bits)
{
    e624:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    e628:	f890 8004 	ldrb.w	r8, [r0, #4]
    e62c:	f8df 9034 	ldr.w	r9, [pc, #52]	; e664 <_rand_sync_read_data+0x40>
{
    e630:	4605      	mov	r5, r0
    e632:	460f      	mov	r7, r1
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    e634:	f1b8 0f00 	cmp.w	r8, #0
    e638:	d00f      	beq.n	e65a <_rand_sync_read_data+0x36>
	if (r_bits < n_bits) {
    e63a:	4588      	cmp	r8, r1
    e63c:	d20d      	bcs.n	e65a <_rand_sync_read_data+0x36>
		uint8_t  i;
		uint32_t d = 0;
    e63e:	2600      	movs	r6, #0
		/* Join read bits */
		for (i = 0; i < n_bits; i += r_bits) {
    e640:	4634      	mov	r4, r6
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    e642:	4628      	mov	r0, r5
    e644:	47c8      	blx	r9
    e646:	40a0      	lsls	r0, r4
		for (i = 0; i < n_bits; i += r_bits) {
    e648:	4444      	add	r4, r8
    e64a:	b2e4      	uxtb	r4, r4
    e64c:	42a7      	cmp	r7, r4
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    e64e:	ea46 0600 	orr.w	r6, r6, r0
		for (i = 0; i < n_bits; i += r_bits) {
    e652:	d8f6      	bhi.n	e642 <_rand_sync_read_data+0x1e>
		}
		return d;
	} else {
		return _rand_sync_read_one(dev);
	}
}
    e654:	4630      	mov	r0, r6
    e656:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return _rand_sync_read_one(dev);
    e65a:	4628      	mov	r0, r5
    e65c:	464b      	mov	r3, r9
}
    e65e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return _rand_sync_read_one(dev);
    e662:	4718      	bx	r3
    e664:	0000e769 	.word	0x0000e769

0000e668 <rand_sync_init>:
{
    e668:	b570      	push	{r4, r5, r6, lr}
	ASSERT(desc);
    e66a:	4604      	mov	r4, r0
    e66c:	3800      	subs	r0, #0
{
    e66e:	460d      	mov	r5, r1
	ASSERT(desc);
    e670:	4b05      	ldr	r3, [pc, #20]	; (e688 <rand_sync_init+0x20>)
    e672:	4906      	ldr	r1, [pc, #24]	; (e68c <rand_sync_init+0x24>)
    e674:	bf18      	it	ne
    e676:	2001      	movne	r0, #1
    e678:	2229      	movs	r2, #41	; 0x29
    e67a:	4798      	blx	r3
	return _rand_sync_init(&desc->dev, hw);
    e67c:	4629      	mov	r1, r5
    e67e:	4620      	mov	r0, r4
    e680:	4b03      	ldr	r3, [pc, #12]	; (e690 <rand_sync_init+0x28>)
}
    e682:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _rand_sync_init(&desc->dev, hw);
    e686:	4718      	bx	r3
    e688:	0000df45 	.word	0x0000df45
    e68c:	00017133 	.word	0x00017133
    e690:	0000e6e9 	.word	0x0000e6e9

0000e694 <rand_sync_enable>:
{
    e694:	b510      	push	{r4, lr}
	ASSERT(desc);
    e696:	4604      	mov	r4, r0
    e698:	3800      	subs	r0, #0
    e69a:	4b05      	ldr	r3, [pc, #20]	; (e6b0 <rand_sync_enable+0x1c>)
    e69c:	4905      	ldr	r1, [pc, #20]	; (e6b4 <rand_sync_enable+0x20>)
    e69e:	bf18      	it	ne
    e6a0:	2001      	movne	r0, #1
    e6a2:	2236      	movs	r2, #54	; 0x36
    e6a4:	4798      	blx	r3
	return _rand_sync_enable(&desc->dev);
    e6a6:	4620      	mov	r0, r4
    e6a8:	4b03      	ldr	r3, [pc, #12]	; (e6b8 <rand_sync_enable+0x24>)
}
    e6aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _rand_sync_enable(&desc->dev);
    e6ae:	4718      	bx	r3
    e6b0:	0000df45 	.word	0x0000df45
    e6b4:	00017133 	.word	0x00017133
    e6b8:	0000e731 	.word	0x0000e731

0000e6bc <rand_sync_read8>:

uint8_t rand_sync_read8(const struct rand_sync_desc *const desc)
{
    e6bc:	b510      	push	{r4, lr}
	ASSERT(desc);
    e6be:	4604      	mov	r4, r0
    e6c0:	3800      	subs	r0, #0
    e6c2:	bf18      	it	ne
    e6c4:	2001      	movne	r0, #1
    e6c6:	225b      	movs	r2, #91	; 0x5b
    e6c8:	4904      	ldr	r1, [pc, #16]	; (e6dc <rand_sync_read8+0x20>)
    e6ca:	4b05      	ldr	r3, [pc, #20]	; (e6e0 <rand_sync_read8+0x24>)
    e6cc:	4798      	blx	r3
	return (uint8_t)_rand_sync_read_data(&desc->dev, 8);
    e6ce:	4b05      	ldr	r3, [pc, #20]	; (e6e4 <rand_sync_read8+0x28>)
    e6d0:	2108      	movs	r1, #8
    e6d2:	4620      	mov	r0, r4
    e6d4:	4798      	blx	r3
}
    e6d6:	b2c0      	uxtb	r0, r0
    e6d8:	bd10      	pop	{r4, pc}
    e6da:	bf00      	nop
    e6dc:	00017133 	.word	0x00017133
    e6e0:	0000df45 	.word	0x0000df45
    e6e4:	0000e625 	.word	0x0000e625

0000e6e8 <_rand_sync_init>:
	}
	return ERR_NONE;
}

int32_t _rand_sync_init(struct _rand_sync_dev *const dev, void *const hw)
{
    e6e8:	b538      	push	{r3, r4, r5, lr}
    e6ea:	460c      	mov	r4, r1
	int32_t rc;

	ASSERT(dev && hw);
    e6ec:	4605      	mov	r5, r0
    e6ee:	b110      	cbz	r0, e6f6 <_rand_sync_init+0xe>
    e6f0:	1e08      	subs	r0, r1, #0
    e6f2:	bf18      	it	ne
    e6f4:	2001      	movne	r0, #1
    e6f6:	4b0c      	ldr	r3, [pc, #48]	; (e728 <_rand_sync_init+0x40>)
    e6f8:	490c      	ldr	r1, [pc, #48]	; (e72c <_rand_sync_init+0x44>)
    e6fa:	223d      	movs	r2, #61	; 0x3d
    e6fc:	4798      	blx	r3
}

static inline hri_trng_ctrla_reg_t hri_trng_get_CTRLA_reg(const void *const hw, hri_trng_ctrla_reg_t mask)
{
	uint8_t tmp;
	tmp = ((Trng *)hw)->CTRLA.reg;
    e6fe:	7823      	ldrb	r3, [r4, #0]
	if (hri_trng_get_CTRLA_reg(hw, TRNG_CTRLA_ENABLE)) {
    e700:	f013 0302 	ands.w	r3, r3, #2
    e704:	d10c      	bne.n	e720 <_rand_sync_init+0x38>
	((Trng *)hw)->CTRLA.reg &= ~TRNG_CTRLA_RUNSTDBY;
    e706:	7822      	ldrb	r2, [r4, #0]
    e708:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
    e70c:	7022      	strb	r2, [r4, #0]
}

static inline void hri_trng_clear_EVCTRL_DATARDYEO_bit(const void *const hw)
{
	TRNG_CRITICAL_SECTION_ENTER();
	((Trng *)hw)->EVCTRL.reg &= ~TRNG_EVCTRL_DATARDYEO;
    e70e:	7922      	ldrb	r2, [r4, #4]
    e710:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    e714:	7122      	strb	r2, [r4, #4]

	rc = _trng_init(hw);
	if (rc == ERR_NONE) {
		dev->prvt   = hw;
		dev->n_bits = 32;
    e716:	2220      	movs	r2, #32
		dev->prvt   = hw;
    e718:	602c      	str	r4, [r5, #0]
		dev->n_bits = 32;
    e71a:	712a      	strb	r2, [r5, #4]
	return ERR_NONE;
    e71c:	4618      	mov	r0, r3
	}
	return rc;
}
    e71e:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
    e720:	f06f 0010 	mvn.w	r0, #16
	return rc;
    e724:	e7fb      	b.n	e71e <_rand_sync_init+0x36>
    e726:	bf00      	nop
    e728:	0000df45 	.word	0x0000df45
    e72c:	0001714e 	.word	0x0001714e

0000e730 <_rand_sync_enable>:
{
	_rand_sync_disable(dev);
}

int32_t _rand_sync_enable(struct _rand_sync_dev *const dev)
{
    e730:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    e732:	4604      	mov	r4, r0
    e734:	3800      	subs	r0, #0
    e736:	bf18      	it	ne
    e738:	2001      	movne	r0, #1
    e73a:	4d09      	ldr	r5, [pc, #36]	; (e760 <_rand_sync_enable+0x30>)
    e73c:	4909      	ldr	r1, [pc, #36]	; (e764 <_rand_sync_enable+0x34>)
    e73e:	224e      	movs	r2, #78	; 0x4e
    e740:	47a8      	blx	r5
	ASSERT(dev->prvt);
    e742:	6820      	ldr	r0, [r4, #0]
    e744:	4907      	ldr	r1, [pc, #28]	; (e764 <_rand_sync_enable+0x34>)
    e746:	3800      	subs	r0, #0
    e748:	bf18      	it	ne
    e74a:	2001      	movne	r0, #1
    e74c:	224f      	movs	r2, #79	; 0x4f
    e74e:	47a8      	blx	r5

	hri_trng_set_CTRLA_ENABLE_bit(dev->prvt);
    e750:	6822      	ldr	r2, [r4, #0]
	((Trng *)hw)->CTRLA.reg |= TRNG_CTRLA_ENABLE;
    e752:	7813      	ldrb	r3, [r2, #0]
    e754:	f043 0302 	orr.w	r3, r3, #2
    e758:	7013      	strb	r3, [r2, #0]
	return ERR_NONE;
}
    e75a:	2000      	movs	r0, #0
    e75c:	bd38      	pop	{r3, r4, r5, pc}
    e75e:	bf00      	nop
    e760:	0000df45 	.word	0x0000df45
    e764:	0001714e 	.word	0x0001714e

0000e768 <_rand_sync_read_one>:
	(void)seed;
	return ERR_UNSUPPORTED_OP;
}

uint32_t _rand_sync_read_one(const struct _rand_sync_dev *const dev)
{
    e768:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    e76a:	4604      	mov	r4, r0
    e76c:	3800      	subs	r0, #0
    e76e:	4d0d      	ldr	r5, [pc, #52]	; (e7a4 <_rand_sync_read_one+0x3c>)
    e770:	490d      	ldr	r1, [pc, #52]	; (e7a8 <_rand_sync_read_one+0x40>)
    e772:	bf18      	it	ne
    e774:	2001      	movne	r0, #1
    e776:	2266      	movs	r2, #102	; 0x66
    e778:	47a8      	blx	r5
	ASSERT(dev->prvt);
    e77a:	6820      	ldr	r0, [r4, #0]
    e77c:	490a      	ldr	r1, [pc, #40]	; (e7a8 <_rand_sync_read_one+0x40>)
    e77e:	3800      	subs	r0, #0
    e780:	bf18      	it	ne
    e782:	2001      	movne	r0, #1
    e784:	2267      	movs	r2, #103	; 0x67
    e786:	47a8      	blx	r5
	ASSERT(hri_trng_get_CTRLA_reg(dev->prvt, TRNG_CTRLA_ENABLE));
    e788:	6823      	ldr	r3, [r4, #0]
    e78a:	4907      	ldr	r1, [pc, #28]	; (e7a8 <_rand_sync_read_one+0x40>)
	tmp = ((Trng *)hw)->CTRLA.reg;
    e78c:	7818      	ldrb	r0, [r3, #0]
    e78e:	2268      	movs	r2, #104	; 0x68
    e790:	f3c0 0040 	ubfx	r0, r0, #1, #1
    e794:	47a8      	blx	r5

	while (!hri_trng_get_INTFLAG_reg(dev->prvt, TRNG_INTFLAG_DATARDY)) {
    e796:	6823      	ldr	r3, [r4, #0]
	tmp = ((Trng *)hw)->INTFLAG.reg;
    e798:	7a9a      	ldrb	r2, [r3, #10]
    e79a:	07d2      	lsls	r2, r2, #31
    e79c:	d5fc      	bpl.n	e798 <_rand_sync_read_one+0x30>
	return ((Trng *)hw)->DATA.reg;
    e79e:	6a18      	ldr	r0, [r3, #32]
		/* Wait until data ready. */
	}
	return hri_trng_read_DATA_reg(dev->prvt);
}
    e7a0:	bd38      	pop	{r3, r4, r5, pc}
    e7a2:	bf00      	nop
    e7a4:	0000df45 	.word	0x0000df45
    e7a8:	0001714e 	.word	0x0001714e

0000e7ac <hid_keyboard_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    e7ac:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    e7ae:	780a      	ldrb	r2, [r1, #0]
    e7b0:	2a81      	cmp	r2, #129	; 0x81
    e7b2:	d11c      	bne.n	e7ee <hid_keyboard_req+0x42>
    e7b4:	784b      	ldrb	r3, [r1, #1]
    e7b6:	2b06      	cmp	r3, #6
    e7b8:	d131      	bne.n	e81e <hid_keyboard_req+0x72>
    e7ba:	4a1a      	ldr	r2, [pc, #104]	; (e824 <hid_keyboard_req+0x78>)
    e7bc:	888c      	ldrh	r4, [r1, #4]
    e7be:	7b13      	ldrb	r3, [r2, #12]
    e7c0:	429c      	cmp	r4, r3
    e7c2:	d12c      	bne.n	e81e <hid_keyboard_req+0x72>
	switch (req->wValue >> 8) {
    e7c4:	884b      	ldrh	r3, [r1, #2]
    e7c6:	0a1b      	lsrs	r3, r3, #8
    e7c8:	2b21      	cmp	r3, #33	; 0x21
    e7ca:	d005      	beq.n	e7d8 <hid_keyboard_req+0x2c>
    e7cc:	2b22      	cmp	r3, #34	; 0x22
    e7ce:	d00a      	beq.n	e7e6 <hid_keyboard_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
			switch (req->bRequest) {
    e7d0:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    e7d4:	bc30      	pop	{r4, r5}
    e7d6:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
    e7d8:	6811      	ldr	r1, [r2, #0]
    e7da:	780a      	ldrb	r2, [r1, #0]
    e7dc:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    e7de:	4c12      	ldr	r4, [pc, #72]	; (e828 <hid_keyboard_req+0x7c>)
    e7e0:	46a4      	mov	ip, r4
}
    e7e2:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    e7e4:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
    e7e6:	4911      	ldr	r1, [pc, #68]	; (e82c <hid_keyboard_req+0x80>)
    e7e8:	2300      	movs	r3, #0
    e7ea:	223b      	movs	r2, #59	; 0x3b
    e7ec:	e7f7      	b.n	e7de <hid_keyboard_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    e7ee:	f3c2 1241 	ubfx	r2, r2, #5, #2
    e7f2:	2a01      	cmp	r2, #1
    e7f4:	d113      	bne.n	e81e <hid_keyboard_req+0x72>
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
    e7f6:	4c0b      	ldr	r4, [pc, #44]	; (e824 <hid_keyboard_req+0x78>)
    e7f8:	888d      	ldrh	r5, [r1, #4]
    e7fa:	7b23      	ldrb	r3, [r4, #12]
    e7fc:	429d      	cmp	r5, r3
    e7fe:	d10e      	bne.n	e81e <hid_keyboard_req+0x72>
			switch (req->bRequest) {
    e800:	784b      	ldrb	r3, [r1, #1]
    e802:	2b03      	cmp	r3, #3
    e804:	d007      	beq.n	e816 <hid_keyboard_req+0x6a>
    e806:	2b0b      	cmp	r3, #11
    e808:	d1e2      	bne.n	e7d0 <hid_keyboard_req+0x24>
				_hiddf_keyboard_funcd.protocol = req->wValue;
    e80a:	884b      	ldrh	r3, [r1, #2]
    e80c:	73e3      	strb	r3, [r4, #15]
				return usbdc_xfer(ep, NULL, 0, 0);
    e80e:	2300      	movs	r3, #0
    e810:	461a      	mov	r2, r3
    e812:	4619      	mov	r1, r3
    e814:	e7e3      	b.n	e7de <hid_keyboard_req+0x32>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
    e816:	2300      	movs	r3, #0
    e818:	f104 010f 	add.w	r1, r4, #15
    e81c:	e7df      	b.n	e7de <hid_keyboard_req+0x32>
			return ERR_NOT_FOUND;
    e81e:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    e822:	e7d7      	b.n	e7d4 <hid_keyboard_req+0x28>
    e824:	20001790 	.word	0x20001790
    e828:	00012f99 	.word	0x00012f99
    e82c:	00017165 	.word	0x00017165

0000e830 <hid_keyboard_ctrl>:
	switch (ctrl) {
    e830:	2901      	cmp	r1, #1
{
    e832:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e836:	4615      	mov	r5, r2
	switch (ctrl) {
    e838:	d04b      	beq.n	e8d2 <hid_keyboard_ctrl+0xa2>
    e83a:	2902      	cmp	r1, #2
    e83c:	d066      	beq.n	e90c <hid_keyboard_ctrl+0xdc>
    e83e:	2900      	cmp	r1, #0
    e840:	d167      	bne.n	e912 <hid_keyboard_ctrl+0xe2>
	ifc = desc->sod;
    e842:	6813      	ldr	r3, [r2, #0]
		return hid_keyboard_enable(drv, (struct usbd_descriptors *)param);
    e844:	f8d0 8008 	ldr.w	r8, [r0, #8]
	if (NULL == ifc) {
    e848:	b923      	cbnz	r3, e854 <hid_keyboard_ctrl+0x24>
		return ERR_NOT_FOUND;
    e84a:	f06f 0409 	mvn.w	r4, #9
}
    e84e:	4620      	mov	r0, r4
    e850:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e854:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    e856:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e858:	2903      	cmp	r1, #3
    e85a:	d1f6      	bne.n	e84a <hid_keyboard_ctrl+0x1a>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    e85c:	f898 100c 	ldrb.w	r1, [r8, #12]
    e860:	428a      	cmp	r2, r1
    e862:	d059      	beq.n	e918 <hid_keyboard_ctrl+0xe8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    e864:	29ff      	cmp	r1, #255	; 0xff
    e866:	d15a      	bne.n	e91e <hid_keyboard_ctrl+0xee>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    e868:	f888 200c 	strb.w	r2, [r8, #12]
	return (desc + usb_desc_len(desc));
    e86c:	7818      	ldrb	r0, [r3, #0]
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e86e:	6869      	ldr	r1, [r5, #4]
    e870:	4e2e      	ldr	r6, [pc, #184]	; (e92c <hid_keyboard_ctrl+0xfc>)
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e872:	f8df b0c8 	ldr.w	fp, [pc, #200]	; e93c <hid_keyboard_ctrl+0x10c>
    e876:	f8df 90c8 	ldr.w	r9, [pc, #200]	; e940 <hid_keyboard_ctrl+0x110>
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e87a:	4418      	add	r0, r3
    e87c:	2221      	movs	r2, #33	; 0x21
    e87e:	4b2c      	ldr	r3, [pc, #176]	; (e930 <hid_keyboard_ctrl+0x100>)
    e880:	4798      	blx	r3
    e882:	2702      	movs	r7, #2
    e884:	6030      	str	r0, [r6, #0]
		ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e886:	682b      	ldr	r3, [r5, #0]
    e888:	6869      	ldr	r1, [r5, #4]
    e88a:	7818      	ldrb	r0, [r3, #0]
    e88c:	4418      	add	r0, r3
    e88e:	4b29      	ldr	r3, [pc, #164]	; (e934 <hid_keyboard_ctrl+0x104>)
    e890:	4798      	blx	r3
		desc->sod = ep;
    e892:	6028      	str	r0, [r5, #0]
		if (NULL != ep) {
    e894:	2800      	cmp	r0, #0
    e896:	d0d8      	beq.n	e84a <hid_keyboard_ctrl+0x1a>
	return (ptr[0] + (ptr[1] << 8));
    e898:	7941      	ldrb	r1, [r0, #5]
    e89a:	7902      	ldrb	r2, [r0, #4]
			ep_desc.bEndpointAddress = ep[2];
    e89c:	f890 a002 	ldrb.w	sl, [r0, #2]
    e8a0:	eb02 2201 	add.w	r2, r2, r1, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e8a4:	b292      	uxth	r2, r2
    e8a6:	78c1      	ldrb	r1, [r0, #3]
    e8a8:	4650      	mov	r0, sl
    e8aa:	47d8      	blx	fp
    e8ac:	4604      	mov	r4, r0
    e8ae:	2800      	cmp	r0, #0
    e8b0:	d138      	bne.n	e924 <hid_keyboard_ctrl+0xf4>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    e8b2:	f01a 0f80 	tst.w	sl, #128	; 0x80
				func_data->func_ep_in = ep_desc.bEndpointAddress;
    e8b6:	bf14      	ite	ne
    e8b8:	f888 a00d 	strbne.w	sl, [r8, #13]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    e8bc:	f888 a00e 	strbeq.w	sl, [r8, #14]
				usb_d_ep_enable(func_data->func_ep_out);
    e8c0:	4650      	mov	r0, sl
    e8c2:	47c8      	blx	r9
	for (i = 0; i < 2; i++) {
    e8c4:	2f01      	cmp	r7, #1
    e8c6:	d102      	bne.n	e8ce <hid_keyboard_ctrl+0x9e>
	_hiddf_keyboard_funcd.protocol = 1;
    e8c8:	73f7      	strb	r7, [r6, #15]
	_hiddf_keyboard_funcd.enabled  = true;
    e8ca:	7437      	strb	r7, [r6, #16]
	return ERR_NONE;
    e8cc:	e7bf      	b.n	e84e <hid_keyboard_ctrl+0x1e>
    e8ce:	2701      	movs	r7, #1
    e8d0:	e7d9      	b.n	e886 <hid_keyboard_ctrl+0x56>
		return hid_keyboard_disable(drv, (struct usbd_descriptors *)param);
    e8d2:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    e8d4:	b11a      	cbz	r2, e8de <hid_keyboard_ctrl+0xae>
		ifc_desc.bInterfaceClass = desc->sod[5];
    e8d6:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    e8d8:	795b      	ldrb	r3, [r3, #5]
    e8da:	2b03      	cmp	r3, #3
    e8dc:	d1b5      	bne.n	e84a <hid_keyboard_ctrl+0x1a>
	if (func_data->func_iface != 0xFF) {
    e8de:	7b23      	ldrb	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    e8e0:	7b60      	ldrb	r0, [r4, #13]
	if (func_data->func_iface != 0xFF) {
    e8e2:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    e8e4:	bf1c      	itt	ne
    e8e6:	23ff      	movne	r3, #255	; 0xff
    e8e8:	7323      	strbne	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    e8ea:	28ff      	cmp	r0, #255	; 0xff
    e8ec:	d003      	beq.n	e8f6 <hid_keyboard_ctrl+0xc6>
		usb_d_ep_deinit(func_data->func_ep_in);
    e8ee:	4b12      	ldr	r3, [pc, #72]	; (e938 <hid_keyboard_ctrl+0x108>)
    e8f0:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    e8f2:	23ff      	movs	r3, #255	; 0xff
    e8f4:	7363      	strb	r3, [r4, #13]
	if (func_data->func_ep_out != 0xFF) {
    e8f6:	7ba0      	ldrb	r0, [r4, #14]
    e8f8:	28ff      	cmp	r0, #255	; 0xff
    e8fa:	d003      	beq.n	e904 <hid_keyboard_ctrl+0xd4>
		usb_d_ep_deinit(func_data->func_ep_out);
    e8fc:	4b0e      	ldr	r3, [pc, #56]	; (e938 <hid_keyboard_ctrl+0x108>)
    e8fe:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    e900:	23ff      	movs	r3, #255	; 0xff
    e902:	73a3      	strb	r3, [r4, #14]
	_hiddf_keyboard_funcd.enabled = false;
    e904:	4b09      	ldr	r3, [pc, #36]	; (e92c <hid_keyboard_ctrl+0xfc>)
    e906:	2400      	movs	r4, #0
    e908:	741c      	strb	r4, [r3, #16]
	return ERR_NONE;
    e90a:	e7a0      	b.n	e84e <hid_keyboard_ctrl+0x1e>
		return ERR_UNSUPPORTED_OP;
    e90c:	f06f 041a 	mvn.w	r4, #26
    e910:	e79d      	b.n	e84e <hid_keyboard_ctrl+0x1e>
	switch (ctrl) {
    e912:	f06f 040c 	mvn.w	r4, #12
    e916:	e79a      	b.n	e84e <hid_keyboard_ctrl+0x1e>
			return ERR_ALREADY_INITIALIZED;
    e918:	f06f 0411 	mvn.w	r4, #17
    e91c:	e797      	b.n	e84e <hid_keyboard_ctrl+0x1e>
			return ERR_NO_RESOURCE;
    e91e:	f06f 041b 	mvn.w	r4, #27
    e922:	e794      	b.n	e84e <hid_keyboard_ctrl+0x1e>
				return ERR_NOT_INITIALIZED;
    e924:	f06f 0413 	mvn.w	r4, #19
    e928:	e791      	b.n	e84e <hid_keyboard_ctrl+0x1e>
    e92a:	bf00      	nop
    e92c:	20001790 	.word	0x20001790
    e930:	0000b6f5 	.word	0x0000b6f5
    e934:	0000b70f 	.word	0x0000b70f
    e938:	0000f48d 	.word	0x0000f48d
    e93c:	0000f429 	.word	0x0000f429
    e940:	0000f4b9 	.word	0x0000f4b9

0000e944 <hiddf_keyboard_init>:

/**
 * \brief Initialize the USB HID Keyboard Function Driver
 */
int32_t hiddf_keyboard_init(void)
{
    e944:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    e946:	4b0a      	ldr	r3, [pc, #40]	; (e970 <hiddf_keyboard_init+0x2c>)
    e948:	4798      	blx	r3
    e94a:	2801      	cmp	r0, #1
    e94c:	d80c      	bhi.n	e968 <hiddf_keyboard_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_keyboard.ctrl      = hid_keyboard_ctrl;
    e94e:	4809      	ldr	r0, [pc, #36]	; (e974 <hiddf_keyboard_init+0x30>)
    e950:	4b09      	ldr	r3, [pc, #36]	; (e978 <hiddf_keyboard_init+0x34>)
	_hiddf_keyboard.func_data = &_hiddf_keyboard_funcd;
    e952:	e9c0 3006 	strd	r3, r0, [r0, #24]

	usbdc_register_function(&_hiddf_keyboard);
    e956:	4b09      	ldr	r3, [pc, #36]	; (e97c <hiddf_keyboard_init+0x38>)
    e958:	3014      	adds	r0, #20
    e95a:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_keyboard_req_h);
    e95c:	2001      	movs	r0, #1
    e95e:	4908      	ldr	r1, [pc, #32]	; (e980 <hiddf_keyboard_init+0x3c>)
    e960:	4b08      	ldr	r3, [pc, #32]	; (e984 <hiddf_keyboard_init+0x40>)
    e962:	4798      	blx	r3
	return ERR_NONE;
    e964:	2000      	movs	r0, #0
}
    e966:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    e968:	f06f 0010 	mvn.w	r0, #16
    e96c:	e7fb      	b.n	e966 <hiddf_keyboard_init+0x22>
    e96e:	bf00      	nop
    e970:	000133d1 	.word	0x000133d1
    e974:	20001790 	.word	0x20001790
    e978:	0000e831 	.word	0x0000e831
    e97c:	00013379 	.word	0x00013379
    e980:	20000504 	.word	0x20000504
    e984:	000132f1 	.word	0x000132f1

0000e988 <hiddf_keyboard_keys_state_change>:
 * \param keys_desc[]  keys_descriptor array for state changing
 * \param keys_count   total keys amount for state changing
 * \return Operation status.
 */
int32_t hiddf_keyboard_keys_state_change(struct hiddf_kb_key_descriptors keys_desc[], uint8_t keys_count)
{
    e988:	b470      	push	{r4, r5, r6}
	return _hiddf_keyboard_funcd.enabled;
    e98a:	4c20      	ldr	r4, [pc, #128]	; (ea0c <hiddf_keyboard_keys_state_change+0x84>)
	uint8_t i, j;
	uint8_t modifier_keys, regular_keys;

	if (!hiddf_keyboard_is_enabled()) {
    e98c:	7c23      	ldrb	r3, [r4, #16]
    e98e:	2b00      	cmp	r3, #0
    e990:	d037      	beq.n	ea02 <hiddf_keyboard_keys_state_change+0x7a>
		return ERR_DENIED;
	}

	memset(_hiddf_keyboard_funcd.kb_report, 0x00, 8);
    e992:	2300      	movs	r3, #0
    e994:	e9c4 3301 	strd	r3, r3, [r4, #4]
	modifier_keys = 0;
    e998:	461a      	mov	r2, r3

	for (i = 0; i < keys_count; i++) {
		if (true == keys_desc[i].b_modifier) {
    e99a:	1c46      	adds	r6, r0, #1
	for (i = 0; i < keys_count; i++) {
    e99c:	b2dd      	uxtb	r5, r3
    e99e:	42a9      	cmp	r1, r5
    e9a0:	d814      	bhi.n	e9cc <hiddf_keyboard_keys_state_change+0x44>
			modifier_keys++;
		}
	}

	regular_keys = keys_count - modifier_keys;
    e9a2:	1a8a      	subs	r2, r1, r2

	if (regular_keys > 6) {
    e9a4:	b2d2      	uxtb	r2, r2
    e9a6:	2a06      	cmp	r2, #6
    e9a8:	d818      	bhi.n	e9dc <hiddf_keyboard_keys_state_change+0x54>
    e9aa:	2500      	movs	r5, #0
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
	} else {
		i = 2;
    e9ac:	2302      	movs	r3, #2
		for (j = 0; j < keys_count; j++) {
    e9ae:	b2ea      	uxtb	r2, r5
    e9b0:	4291      	cmp	r1, r2
    e9b2:	d919      	bls.n	e9e8 <hiddf_keyboard_keys_state_change+0x60>
			if (HID_KB_KEY_DOWN == keys_desc[j].state) {
    e9b4:	7882      	ldrb	r2, [r0, #2]
    e9b6:	2a01      	cmp	r2, #1
    e9b8:	d105      	bne.n	e9c6 <hiddf_keyboard_keys_state_change+0x3e>
				if (true == keys_desc[j].b_modifier) {
    e9ba:	7846      	ldrb	r6, [r0, #1]
    e9bc:	7802      	ldrb	r2, [r0, #0]
    e9be:	b1de      	cbz	r6, e9f8 <hiddf_keyboard_keys_state_change+0x70>
					_hiddf_keyboard_funcd.kb_report[0] |= keys_desc[j].key_id;
    e9c0:	7926      	ldrb	r6, [r4, #4]
    e9c2:	4332      	orrs	r2, r6
    e9c4:	7122      	strb	r2, [r4, #4]
		for (j = 0; j < keys_count; j++) {
    e9c6:	3501      	adds	r5, #1
    e9c8:	3003      	adds	r0, #3
    e9ca:	e7f0      	b.n	e9ae <hiddf_keyboard_keys_state_change+0x26>
		if (true == keys_desc[i].b_modifier) {
    e9cc:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    e9d0:	5d75      	ldrb	r5, [r6, r5]
    e9d2:	b10d      	cbz	r5, e9d8 <hiddf_keyboard_keys_state_change+0x50>
			modifier_keys++;
    e9d4:	3201      	adds	r2, #1
    e9d6:	b2d2      	uxtb	r2, r2
	for (i = 0; i < keys_count; i++) {
    e9d8:	3301      	adds	r3, #1
    e9da:	e7df      	b.n	e99c <hiddf_keyboard_keys_state_change+0x14>
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
    e9dc:	4a0c      	ldr	r2, [pc, #48]	; (ea10 <hiddf_keyboard_keys_state_change+0x88>)
    e9de:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    e9e2:	f8c4 3006 	str.w	r3, [r4, #6]
    e9e6:	8093      	strh	r3, [r2, #4]
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
				}
			}
		}
	}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    e9e8:	7b60      	ldrb	r0, [r4, #13]
    e9ea:	4c0a      	ldr	r4, [pc, #40]	; (ea14 <hiddf_keyboard_keys_state_change+0x8c>)
    e9ec:	490a      	ldr	r1, [pc, #40]	; (ea18 <hiddf_keyboard_keys_state_change+0x90>)
    e9ee:	46a4      	mov	ip, r4
    e9f0:	2300      	movs	r3, #0
}
    e9f2:	bc70      	pop	{r4, r5, r6}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    e9f4:	2208      	movs	r2, #8
    e9f6:	4760      	bx	ip
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
    e9f8:	1c5e      	adds	r6, r3, #1
    e9fa:	4423      	add	r3, r4
    e9fc:	711a      	strb	r2, [r3, #4]
    e9fe:	b2f3      	uxtb	r3, r6
    ea00:	e7e1      	b.n	e9c6 <hiddf_keyboard_keys_state_change+0x3e>
}
    ea02:	f06f 0010 	mvn.w	r0, #16
    ea06:	bc70      	pop	{r4, r5, r6}
    ea08:	4770      	bx	lr
    ea0a:	bf00      	nop
    ea0c:	20001790 	.word	0x20001790
    ea10:	20001796 	.word	0x20001796
    ea14:	00012f99 	.word	0x00012f99
    ea18:	20001794 	.word	0x20001794

0000ea1c <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    ea1c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ea20:	460e      	mov	r6, r1
    ea22:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    ea24:	4604      	mov	r4, r0
    ea26:	b118      	cbz	r0, ea30 <usart_sync_write+0x14>
    ea28:	b329      	cbz	r1, ea76 <usart_sync_write+0x5a>
    ea2a:	1e10      	subs	r0, r2, #0
    ea2c:	bf18      	it	ne
    ea2e:	2001      	movne	r0, #1
    ea30:	4912      	ldr	r1, [pc, #72]	; (ea7c <usart_sync_write+0x60>)
    ea32:	4b13      	ldr	r3, [pc, #76]	; (ea80 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
    ea34:	4f13      	ldr	r7, [pc, #76]	; (ea84 <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
    ea36:	22f1      	movs	r2, #241	; 0xf1
    ea38:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    ea3a:	3408      	adds	r4, #8
    ea3c:	46b9      	mov	r9, r7
    ea3e:	4620      	mov	r0, r4
    ea40:	47b8      	blx	r7
    ea42:	2800      	cmp	r0, #0
    ea44:	d0fb      	beq.n	ea3e <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    ea46:	f8df 8044 	ldr.w	r8, [pc, #68]	; ea8c <usart_sync_write+0x70>
	uint32_t                      offset = 0;
    ea4a:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
    ea4c:	5df1      	ldrb	r1, [r6, r7]
    ea4e:	4620      	mov	r0, r4
    ea50:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
    ea52:	4620      	mov	r0, r4
    ea54:	47c8      	blx	r9
    ea56:	2800      	cmp	r0, #0
    ea58:	d0fb      	beq.n	ea52 <usart_sync_write+0x36>
			;
	} while (++offset < length);
    ea5a:	3701      	adds	r7, #1
    ea5c:	42bd      	cmp	r5, r7
    ea5e:	d8f5      	bhi.n	ea4c <usart_sync_write+0x30>
    ea60:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
    ea62:	4e09      	ldr	r6, [pc, #36]	; (ea88 <usart_sync_write+0x6c>)
    ea64:	bf08      	it	eq
    ea66:	2501      	moveq	r5, #1
    ea68:	4620      	mov	r0, r4
    ea6a:	47b0      	blx	r6
    ea6c:	2800      	cmp	r0, #0
    ea6e:	d0fb      	beq.n	ea68 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
    ea70:	4628      	mov	r0, r5
    ea72:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    ea76:	4608      	mov	r0, r1
    ea78:	e7da      	b.n	ea30 <usart_sync_write+0x14>
    ea7a:	bf00      	nop
    ea7c:	000171a0 	.word	0x000171a0
    ea80:	0000df45 	.word	0x0000df45
    ea84:	00010f71 	.word	0x00010f71
    ea88:	00010f7b 	.word	0x00010f7b
    ea8c:	00010f5d 	.word	0x00010f5d

0000ea90 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    ea90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ea94:	460e      	mov	r6, r1
    ea96:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    ea98:	4604      	mov	r4, r0
    ea9a:	b118      	cbz	r0, eaa4 <usart_sync_read+0x14>
    ea9c:	b1e9      	cbz	r1, eada <usart_sync_read+0x4a>
    ea9e:	1e10      	subs	r0, r2, #0
    eaa0:	bf18      	it	ne
    eaa2:	2001      	movne	r0, #1
    eaa4:	490e      	ldr	r1, [pc, #56]	; (eae0 <usart_sync_read+0x50>)
    eaa6:	4b0f      	ldr	r3, [pc, #60]	; (eae4 <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    eaa8:	f8df 903c 	ldr.w	r9, [pc, #60]	; eae8 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    eaac:	f8df 803c 	ldr.w	r8, [pc, #60]	; eaec <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
    eab0:	f44f 7286 	mov.w	r2, #268	; 0x10c
    eab4:	4798      	blx	r3
	uint32_t                      offset = 0;
    eab6:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
    eab8:	3408      	adds	r4, #8
    eaba:	4620      	mov	r0, r4
    eabc:	47c8      	blx	r9
    eabe:	2800      	cmp	r0, #0
    eac0:	d0fb      	beq.n	eaba <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    eac2:	4620      	mov	r0, r4
    eac4:	47c0      	blx	r8
    eac6:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
    eac8:	3701      	adds	r7, #1
    eaca:	42bd      	cmp	r5, r7
    eacc:	d8f5      	bhi.n	eaba <usart_sync_read+0x2a>

	return (int32_t)offset;
    eace:	2d00      	cmp	r5, #0
}
    ead0:	bf14      	ite	ne
    ead2:	4628      	movne	r0, r5
    ead4:	2001      	moveq	r0, #1
    ead6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    eada:	4608      	mov	r0, r1
    eadc:	e7e2      	b.n	eaa4 <usart_sync_read+0x14>
    eade:	bf00      	nop
    eae0:	000171a0 	.word	0x000171a0
    eae4:	0000df45 	.word	0x0000df45
    eae8:	00010f85 	.word	0x00010f85
    eaec:	00010f69 	.word	0x00010f69

0000eaf0 <usart_sync_init>:
{
    eaf0:	b538      	push	{r3, r4, r5, lr}
    eaf2:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    eaf4:	4604      	mov	r4, r0
    eaf6:	b110      	cbz	r0, eafe <usart_sync_init+0xe>
    eaf8:	1e08      	subs	r0, r1, #0
    eafa:	bf18      	it	ne
    eafc:	2001      	movne	r0, #1
    eafe:	4907      	ldr	r1, [pc, #28]	; (eb1c <usart_sync_init+0x2c>)
    eb00:	4b07      	ldr	r3, [pc, #28]	; (eb20 <usart_sync_init+0x30>)
    eb02:	2234      	movs	r2, #52	; 0x34
    eb04:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    eb06:	4b07      	ldr	r3, [pc, #28]	; (eb24 <usart_sync_init+0x34>)
    eb08:	4629      	mov	r1, r5
    eb0a:	f104 0008 	add.w	r0, r4, #8
    eb0e:	4798      	blx	r3
	if (init_status) {
    eb10:	b918      	cbnz	r0, eb1a <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
    eb12:	4b05      	ldr	r3, [pc, #20]	; (eb28 <usart_sync_init+0x38>)
    eb14:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    eb16:	4b05      	ldr	r3, [pc, #20]	; (eb2c <usart_sync_init+0x3c>)
    eb18:	6023      	str	r3, [r4, #0]
}
    eb1a:	bd38      	pop	{r3, r4, r5, pc}
    eb1c:	000171a0 	.word	0x000171a0
    eb20:	0000df45 	.word	0x0000df45
    eb24:	00010e79 	.word	0x00010e79
    eb28:	0000ea91 	.word	0x0000ea91
    eb2c:	0000ea1d 	.word	0x0000ea1d

0000eb30 <usart_sync_enable>:
{
    eb30:	b510      	push	{r4, lr}
	ASSERT(descr);
    eb32:	4604      	mov	r4, r0
    eb34:	3800      	subs	r0, #0
    eb36:	bf18      	it	ne
    eb38:	2001      	movne	r0, #1
    eb3a:	4905      	ldr	r1, [pc, #20]	; (eb50 <usart_sync_enable+0x20>)
    eb3c:	4b05      	ldr	r3, [pc, #20]	; (eb54 <usart_sync_enable+0x24>)
    eb3e:	2253      	movs	r2, #83	; 0x53
    eb40:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    eb42:	f104 0008 	add.w	r0, r4, #8
    eb46:	4b04      	ldr	r3, [pc, #16]	; (eb58 <usart_sync_enable+0x28>)
    eb48:	4798      	blx	r3
}
    eb4a:	2000      	movs	r0, #0
    eb4c:	bd10      	pop	{r4, pc}
    eb4e:	bf00      	nop
    eb50:	000171a0 	.word	0x000171a0
    eb54:	0000df45 	.word	0x0000df45
    eb58:	00010f1d 	.word	0x00010f1d

0000eb5c <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    eb5c:	4b01      	ldr	r3, [pc, #4]	; (eb64 <_mclk_init+0x8>)
    eb5e:	2201      	movs	r2, #1
    eb60:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    eb62:	4770      	bx	lr
    eb64:	40000800 	.word	0x40000800

0000eb68 <hri_gclk_wait_for_sync.constprop.0>:
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    eb68:	4903      	ldr	r1, [pc, #12]	; (eb78 <hri_gclk_wait_for_sync.constprop.0+0x10>)
    eb6a:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    eb6e:	684a      	ldr	r2, [r1, #4]
    eb70:	421a      	tst	r2, r3
    eb72:	d1fc      	bne.n	eb6e <hri_gclk_wait_for_sync.constprop.0+0x6>
}
    eb74:	4770      	bx	lr
    eb76:	bf00      	nop
    eb78:	40001c00 	.word	0x40001c00

0000eb7c <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    eb7c:	b510      	push	{r4, lr}

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    eb7e:	07c4      	lsls	r4, r0, #31
    eb80:	d504      	bpl.n	eb8c <_gclk_init_generators_by_fref+0x10>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    eb82:	4b0e      	ldr	r3, [pc, #56]	; (ebbc <_gclk_init_generators_by_fref+0x40>)
    eb84:	4a0e      	ldr	r2, [pc, #56]	; (ebc0 <_gclk_init_generators_by_fref+0x44>)
    eb86:	621a      	str	r2, [r3, #32]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    eb88:	4b0e      	ldr	r3, [pc, #56]	; (ebc4 <_gclk_init_generators_by_fref+0x48>)
    eb8a:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    eb8c:	0781      	lsls	r1, r0, #30
    eb8e:	d504      	bpl.n	eb9a <_gclk_init_generators_by_fref+0x1e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    eb90:	4b0a      	ldr	r3, [pc, #40]	; (ebbc <_gclk_init_generators_by_fref+0x40>)
    eb92:	4a0d      	ldr	r2, [pc, #52]	; (ebc8 <_gclk_init_generators_by_fref+0x4c>)
    eb94:	625a      	str	r2, [r3, #36]	; 0x24
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    eb96:	4b0b      	ldr	r3, [pc, #44]	; (ebc4 <_gclk_init_generators_by_fref+0x48>)
    eb98:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    eb9a:	0742      	lsls	r2, r0, #29
    eb9c:	d504      	bpl.n	eba8 <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    eb9e:	4b07      	ldr	r3, [pc, #28]	; (ebbc <_gclk_init_generators_by_fref+0x40>)
    eba0:	4a0a      	ldr	r2, [pc, #40]	; (ebcc <_gclk_init_generators_by_fref+0x50>)
    eba2:	629a      	str	r2, [r3, #40]	; 0x28
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    eba4:	4b07      	ldr	r3, [pc, #28]	; (ebc4 <_gclk_init_generators_by_fref+0x48>)
    eba6:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    eba8:	0703      	lsls	r3, r0, #28
    ebaa:	d506      	bpl.n	ebba <_gclk_init_generators_by_fref+0x3e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    ebac:	4b03      	ldr	r3, [pc, #12]	; (ebbc <_gclk_init_generators_by_fref+0x40>)
    ebae:	4a08      	ldr	r2, [pc, #32]	; (ebd0 <_gclk_init_generators_by_fref+0x54>)
    ebb0:	62da      	str	r2, [r3, #44]	; 0x2c
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    ebb2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    ebb6:	4b03      	ldr	r3, [pc, #12]	; (ebc4 <_gclk_init_generators_by_fref+0x48>)
    ebb8:	4718      	bx	r3
    ebba:	bd10      	pop	{r4, pc}
    ebbc:	40001c00 	.word	0x40001c00
    ebc0:	00010108 	.word	0x00010108
    ebc4:	0000eb69 	.word	0x0000eb69
    ebc8:	00010106 	.word	0x00010106
    ebcc:	00100106 	.word	0x00100106
    ebd0:	00010104 	.word	0x00010104

0000ebd4 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    ebd4:	b510      	push	{r4, lr}

	usart_sync_enable(&GRID_AUX);
    ebd6:	4c04      	ldr	r4, [pc, #16]	; (ebe8 <stdio_redirect_init+0x14>)
    ebd8:	4b04      	ldr	r3, [pc, #16]	; (ebec <stdio_redirect_init+0x18>)
    ebda:	4620      	mov	r0, r4
    ebdc:	4798      	blx	r3
	stdio_io_init(&GRID_AUX.io);
    ebde:	4620      	mov	r0, r4
    ebe0:	4b03      	ldr	r3, [pc, #12]	; (ebf0 <stdio_redirect_init+0x1c>)
}
    ebe2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&GRID_AUX.io);
    ebe6:	4718      	bx	r3
    ebe8:	20015790 	.word	0x20015790
    ebec:	0000eb31 	.word	0x0000eb31
    ebf0:	0000b795 	.word	0x0000b795

0000ebf4 <flash_ready>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    ebf4:	6943      	ldr	r3, [r0, #20]
    ebf6:	b103      	cbz	r3, ebfa <flash_ready+0x6>
		descr->callbacks.cb_ready(descr);
    ebf8:	4718      	bx	r3
	}
}
    ebfa:	4770      	bx	lr

0000ebfc <flash_error>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    ebfc:	6983      	ldr	r3, [r0, #24]
    ebfe:	b103      	cbz	r3, ec02 <flash_error+0x6>
		descr->callbacks.cb_error(descr);
    ec00:	4718      	bx	r3
	}
}
    ec02:	4770      	bx	lr

0000ec04 <flash_is_address_aligned>:
{
    ec04:	b538      	push	{r3, r4, r5, lr}
	ASSERT(flash);
    ec06:	4604      	mov	r4, r0
    ec08:	3800      	subs	r0, #0
    ec0a:	bf18      	it	ne
    ec0c:	2001      	movne	r0, #1
{
    ec0e:	460d      	mov	r5, r1
	ASSERT(flash);
    ec10:	f240 1217 	movw	r2, #279	; 0x117
    ec14:	4906      	ldr	r1, [pc, #24]	; (ec30 <flash_is_address_aligned+0x2c>)
    ec16:	4b07      	ldr	r3, [pc, #28]	; (ec34 <flash_is_address_aligned+0x30>)
    ec18:	4798      	blx	r3
	uint32_t page_size = _flash_get_page_size(&flash->dev);
    ec1a:	4b07      	ldr	r3, [pc, #28]	; (ec38 <flash_is_address_aligned+0x34>)
    ec1c:	4620      	mov	r0, r4
    ec1e:	4798      	blx	r3
	if (flash_addr & (page_size - 1)) {
    ec20:	3801      	subs	r0, #1
    ec22:	4228      	tst	r0, r5
}
    ec24:	bf14      	ite	ne
    ec26:	f06f 000d 	mvnne.w	r0, #13
    ec2a:	2000      	moveq	r0, #0
    ec2c:	bd38      	pop	{r3, r4, r5, pc}
    ec2e:	bf00      	nop
    ec30:	000171bc 	.word	0x000171bc
    ec34:	0000df45 	.word	0x0000df45
    ec38:	0000be39 	.word	0x0000be39

0000ec3c <flash_init>:
{
    ec3c:	b538      	push	{r3, r4, r5, lr}
    ec3e:	460d      	mov	r5, r1
	ASSERT(flash && hw);
    ec40:	4604      	mov	r4, r0
    ec42:	b110      	cbz	r0, ec4a <flash_init+0xe>
    ec44:	1e08      	subs	r0, r1, #0
    ec46:	bf18      	it	ne
    ec48:	2001      	movne	r0, #1
    ec4a:	4907      	ldr	r1, [pc, #28]	; (ec68 <flash_init+0x2c>)
    ec4c:	4b07      	ldr	r3, [pc, #28]	; (ec6c <flash_init+0x30>)
    ec4e:	2238      	movs	r2, #56	; 0x38
    ec50:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    ec52:	4b07      	ldr	r3, [pc, #28]	; (ec70 <flash_init+0x34>)
    ec54:	4629      	mov	r1, r5
    ec56:	4620      	mov	r0, r4
    ec58:	4798      	blx	r3
	if (rc) {
    ec5a:	b918      	cbnz	r0, ec64 <flash_init+0x28>
	flash->dev.flash_cb.ready_cb = flash_ready;
    ec5c:	4b05      	ldr	r3, [pc, #20]	; (ec74 <flash_init+0x38>)
    ec5e:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    ec60:	4b05      	ldr	r3, [pc, #20]	; (ec78 <flash_init+0x3c>)
    ec62:	6063      	str	r3, [r4, #4]
}
    ec64:	bd38      	pop	{r3, r4, r5, pc}
    ec66:	bf00      	nop
    ec68:	000171bc 	.word	0x000171bc
    ec6c:	0000df45 	.word	0x0000df45
    ec70:	0000bdc9 	.word	0x0000bdc9
    ec74:	0000ebf5 	.word	0x0000ebf5
    ec78:	0000ebfd 	.word	0x0000ebfd

0000ec7c <flash_read>:
{
    ec7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ec80:	460d      	mov	r5, r1
    ec82:	4616      	mov	r6, r2
    ec84:	461f      	mov	r7, r3
	ASSERT(flash && buffer && length);
    ec86:	4604      	mov	r4, r0
    ec88:	b118      	cbz	r0, ec92 <flash_read+0x16>
    ec8a:	b1ea      	cbz	r2, ecc8 <flash_read+0x4c>
    ec8c:	1e18      	subs	r0, r3, #0
    ec8e:	bf18      	it	ne
    ec90:	2001      	movne	r0, #1
    ec92:	4910      	ldr	r1, [pc, #64]	; (ecd4 <flash_read+0x58>)
    ec94:	4b10      	ldr	r3, [pc, #64]	; (ecd8 <flash_read+0x5c>)
    ec96:	2256      	movs	r2, #86	; 0x56
    ec98:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ec9a:	4b10      	ldr	r3, [pc, #64]	; (ecdc <flash_read+0x60>)
    ec9c:	4620      	mov	r0, r4
    ec9e:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    eca0:	4b0f      	ldr	r3, [pc, #60]	; (ece0 <flash_read+0x64>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    eca2:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    eca4:	4620      	mov	r0, r4
    eca6:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    eca8:	fb00 f008 	mul.w	r0, r0, r8
    ecac:	42a8      	cmp	r0, r5
    ecae:	d30d      	bcc.n	eccc <flash_read+0x50>
    ecb0:	197b      	adds	r3, r7, r5
    ecb2:	4298      	cmp	r0, r3
    ecb4:	d30a      	bcc.n	eccc <flash_read+0x50>
	_flash_read(&flash->dev, src_addr, buffer, length);
    ecb6:	4620      	mov	r0, r4
    ecb8:	463b      	mov	r3, r7
    ecba:	4c0a      	ldr	r4, [pc, #40]	; (ece4 <flash_read+0x68>)
    ecbc:	4632      	mov	r2, r6
    ecbe:	4629      	mov	r1, r5
    ecc0:	47a0      	blx	r4
	return ERR_NONE;
    ecc2:	2000      	movs	r0, #0
}
    ecc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    ecc8:	4610      	mov	r0, r2
    ecca:	e7e2      	b.n	ec92 <flash_read+0x16>
		return ERR_BAD_ADDRESS;
    eccc:	f06f 000d 	mvn.w	r0, #13
    ecd0:	e7f8      	b.n	ecc4 <flash_read+0x48>
    ecd2:	bf00      	nop
    ecd4:	000171bc 	.word	0x000171bc
    ecd8:	0000df45 	.word	0x0000df45
    ecdc:	0000be39 	.word	0x0000be39
    ece0:	0000be3f 	.word	0x0000be3f
    ece4:	0000be47 	.word	0x0000be47

0000ece8 <flash_write>:
{
    ece8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    ecec:	460e      	mov	r6, r1
    ecee:	4617      	mov	r7, r2
    ecf0:	4698      	mov	r8, r3
	ASSERT(flash && buffer && length);
    ecf2:	4605      	mov	r5, r0
    ecf4:	b118      	cbz	r0, ecfe <flash_write+0x16>
    ecf6:	b31a      	cbz	r2, ed40 <flash_write+0x58>
    ecf8:	1e18      	subs	r0, r3, #0
    ecfa:	bf18      	it	ne
    ecfc:	2001      	movne	r0, #1
    ecfe:	4914      	ldr	r1, [pc, #80]	; (ed50 <flash_write+0x68>)
    ed00:	4b14      	ldr	r3, [pc, #80]	; (ed54 <flash_write+0x6c>)
    ed02:	226a      	movs	r2, #106	; 0x6a
    ed04:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ed06:	4b14      	ldr	r3, [pc, #80]	; (ed58 <flash_write+0x70>)
    ed08:	4628      	mov	r0, r5
    ed0a:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed0c:	4b13      	ldr	r3, [pc, #76]	; (ed5c <flash_write+0x74>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ed0e:	4604      	mov	r4, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed10:	4628      	mov	r0, r5
    ed12:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    ed14:	4360      	muls	r0, r4
    ed16:	42b0      	cmp	r0, r6
    ed18:	d314      	bcc.n	ed44 <flash_write+0x5c>
    ed1a:	eb08 0306 	add.w	r3, r8, r6
    ed1e:	4298      	cmp	r0, r3
    ed20:	d310      	bcc.n	ed44 <flash_write+0x5c>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    ed22:	4b0f      	ldr	r3, [pc, #60]	; (ed60 <flash_write+0x78>)
    ed24:	4631      	mov	r1, r6
    ed26:	4628      	mov	r0, r5
    ed28:	4798      	blx	r3
    ed2a:	4604      	mov	r4, r0
    ed2c:	b968      	cbnz	r0, ed4a <flash_write+0x62>
	_flash_write(&flash->dev, dst_addr, buffer, length);
    ed2e:	4628      	mov	r0, r5
    ed30:	4643      	mov	r3, r8
    ed32:	4d0c      	ldr	r5, [pc, #48]	; (ed64 <flash_write+0x7c>)
    ed34:	463a      	mov	r2, r7
    ed36:	4631      	mov	r1, r6
    ed38:	47a8      	blx	r5
	return ERR_NONE;
    ed3a:	4620      	mov	r0, r4
}
    ed3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    ed40:	4610      	mov	r0, r2
    ed42:	e7dc      	b.n	ecfe <flash_write+0x16>
		return ERR_BAD_ADDRESS;
    ed44:	f06f 000d 	mvn.w	r0, #13
    ed48:	e7f8      	b.n	ed3c <flash_write+0x54>
		return ERR_DENIED;
    ed4a:	f06f 0010 	mvn.w	r0, #16
    ed4e:	e7f5      	b.n	ed3c <flash_write+0x54>
    ed50:	000171bc 	.word	0x000171bc
    ed54:	0000df45 	.word	0x0000df45
    ed58:	0000be39 	.word	0x0000be39
    ed5c:	0000be3f 	.word	0x0000be3f
    ed60:	0000bfd5 	.word	0x0000bfd5
    ed64:	0000be61 	.word	0x0000be61

0000ed68 <flash_erase>:
{
    ed68:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ed6c:	4688      	mov	r8, r1
    ed6e:	4617      	mov	r7, r2
	ASSERT(flash && page_nums);
    ed70:	4604      	mov	r4, r0
    ed72:	b110      	cbz	r0, ed7a <flash_erase+0x12>
    ed74:	1e10      	subs	r0, r2, #0
    ed76:	bf18      	it	ne
    ed78:	2001      	movne	r0, #1
    ed7a:	4912      	ldr	r1, [pc, #72]	; (edc4 <flash_erase+0x5c>)
    ed7c:	4b12      	ldr	r3, [pc, #72]	; (edc8 <flash_erase+0x60>)
    ed7e:	229a      	movs	r2, #154	; 0x9a
    ed80:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ed82:	4b12      	ldr	r3, [pc, #72]	; (edcc <flash_erase+0x64>)
    ed84:	4620      	mov	r0, r4
    ed86:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed88:	4b11      	ldr	r3, [pc, #68]	; (edd0 <flash_erase+0x68>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    ed8a:	4605      	mov	r5, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed8c:	4620      	mov	r0, r4
    ed8e:	4798      	blx	r3
	rc = flash_is_address_aligned(flash, dst_addr);
    ed90:	4b10      	ldr	r3, [pc, #64]	; (edd4 <flash_erase+0x6c>)
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    ed92:	4681      	mov	r9, r0
	rc = flash_is_address_aligned(flash, dst_addr);
    ed94:	4641      	mov	r1, r8
    ed96:	4620      	mov	r0, r4
    ed98:	4798      	blx	r3
	if (rc) {
    ed9a:	4606      	mov	r6, r0
    ed9c:	b958      	cbnz	r0, edb6 <flash_erase+0x4e>
	if ((page_nums > total_pages) || (dst_addr / page_size + page_nums > total_pages)) {
    ed9e:	454f      	cmp	r7, r9
    eda0:	d80c      	bhi.n	edbc <flash_erase+0x54>
    eda2:	fbb8 f5f5 	udiv	r5, r8, r5
    eda6:	443d      	add	r5, r7
    eda8:	454d      	cmp	r5, r9
    edaa:	d807      	bhi.n	edbc <flash_erase+0x54>
	_flash_erase(&flash->dev, dst_addr, page_nums);
    edac:	4b0a      	ldr	r3, [pc, #40]	; (edd8 <flash_erase+0x70>)
    edae:	463a      	mov	r2, r7
    edb0:	4641      	mov	r1, r8
    edb2:	4620      	mov	r0, r4
    edb4:	4798      	blx	r3
}
    edb6:	4630      	mov	r0, r6
    edb8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ERR_INVALID_ARG;
    edbc:	f06f 060c 	mvn.w	r6, #12
    edc0:	e7f9      	b.n	edb6 <flash_erase+0x4e>
    edc2:	bf00      	nop
    edc4:	000171bc 	.word	0x000171bc
    edc8:	0000df45 	.word	0x0000df45
    edcc:	0000be39 	.word	0x0000be39
    edd0:	0000be3f 	.word	0x0000be3f
    edd4:	0000ec05 	.word	0x0000ec05
    edd8:	0000bf29 	.word	0x0000bf29

0000eddc <_spi_m_async_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_async_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    eddc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(io);
    edde:	4604      	mov	r4, r0
    ede0:	3800      	subs	r0, #0
    ede2:	bf18      	it	ne
    ede4:	2001      	movne	r0, #1
{
    ede6:	460f      	mov	r7, r1
    ede8:	4616      	mov	r6, r2
	ASSERT(io);
    edea:	4909      	ldr	r1, [pc, #36]	; (ee10 <_spi_m_async_io_write+0x34>)
    edec:	4b09      	ldr	r3, [pc, #36]	; (ee14 <_spi_m_async_io_write+0x38>)
    edee:	f240 1227 	movw	r2, #295	; 0x127
    edf2:	4798      	blx	r3
	struct spi_m_async_descriptor *spi = CONTAINER_OF(io, struct spi_m_async_descriptor, io);

	spi->xfer.rxbuf = NULL;
    edf4:	2500      	movs	r5, #0
	spi->xfer.txbuf = (uint8_t *)buf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    edf6:	2310      	movs	r3, #16
    edf8:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = (uint8_t *)buf;
    edfa:	e9c4 7505 	strd	r7, r5, [r4, #20]
	spi->xfercnt    = 0;
    edfe:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_tx(&spi->dev, true);
    ee02:	4b05      	ldr	r3, [pc, #20]	; (ee18 <_spi_m_async_io_write+0x3c>)
    ee04:	2101      	movs	r1, #1
    ee06:	f1a4 0020 	sub.w	r0, r4, #32
    ee0a:	4798      	blx	r3

	return ERR_NONE;
}
    ee0c:	4628      	mov	r0, r5
    ee0e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ee10:	000171d3 	.word	0x000171d3
    ee14:	0000df45 	.word	0x0000df45
    ee18:	00011525 	.word	0x00011525

0000ee1c <_spi_m_async_io_read>:
{
    ee1c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(io);
    ee1e:	4604      	mov	r4, r0
    ee20:	3800      	subs	r0, #0
    ee22:	bf18      	it	ne
    ee24:	2001      	movne	r0, #1
{
    ee26:	460d      	mov	r5, r1
    ee28:	4616      	mov	r6, r2
	ASSERT(io);
    ee2a:	490c      	ldr	r1, [pc, #48]	; (ee5c <_spi_m_async_io_read+0x40>)
    ee2c:	4b0c      	ldr	r3, [pc, #48]	; (ee60 <_spi_m_async_io_read+0x44>)
    ee2e:	f240 1205 	movw	r2, #261	; 0x105
    ee32:	4798      	blx	r3
	spi->xfer.rxbuf = buf;
    ee34:	61a5      	str	r5, [r4, #24]
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ee36:	2310      	movs	r3, #16
	spi->xfer.txbuf = NULL;
    ee38:	2500      	movs	r5, #0
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    ee3a:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = NULL;
    ee3c:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
    ee3e:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_rx(&spi->dev, true);
    ee42:	3c20      	subs	r4, #32
    ee44:	4b07      	ldr	r3, [pc, #28]	; (ee64 <_spi_m_async_io_read+0x48>)
    ee46:	2101      	movs	r1, #1
    ee48:	4620      	mov	r0, r4
    ee4a:	4798      	blx	r3
	_spi_m_async_write_one(&spi->dev, SPI_DUMMY_CHAR);
    ee4c:	4b06      	ldr	r3, [pc, #24]	; (ee68 <_spi_m_async_io_read+0x4c>)
    ee4e:	f240 11ff 	movw	r1, #511	; 0x1ff
    ee52:	4620      	mov	r0, r4
    ee54:	4798      	blx	r3
}
    ee56:	4628      	mov	r0, r5
    ee58:	bd70      	pop	{r4, r5, r6, pc}
    ee5a:	bf00      	nop
    ee5c:	000171d3 	.word	0x000171d3
    ee60:	0000df45 	.word	0x0000df45
    ee64:	00011551 	.word	0x00011551
    ee68:	000115bd 	.word	0x000115bd

0000ee6c <_spi_dev_error>:
{
    ee6c:	b570      	push	{r4, r5, r6, lr}
	_spi_m_async_enable_tx(dev, false);
    ee6e:	4b0c      	ldr	r3, [pc, #48]	; (eea0 <_spi_dev_error+0x34>)
{
    ee70:	4604      	mov	r4, r0
    ee72:	460d      	mov	r5, r1
	_spi_m_async_enable_tx(dev, false);
    ee74:	2100      	movs	r1, #0
    ee76:	4798      	blx	r3
	_spi_m_async_enable_rx(dev, false);
    ee78:	4b0a      	ldr	r3, [pc, #40]	; (eea4 <_spi_dev_error+0x38>)
    ee7a:	2100      	movs	r1, #0
    ee7c:	4620      	mov	r0, r4
    ee7e:	4798      	blx	r3
	_spi_m_async_enable_tx_complete(dev, false);
    ee80:	4b09      	ldr	r3, [pc, #36]	; (eea8 <_spi_dev_error+0x3c>)
    ee82:	2100      	movs	r1, #0
    ee84:	4620      	mov	r0, r4
    ee86:	4798      	blx	r3
	spi->stat = 0;
    ee88:	2300      	movs	r3, #0
    ee8a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	if (spi->callbacks.cb_error) {
    ee8e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    ee90:	b123      	cbz	r3, ee9c <_spi_dev_error+0x30>
		spi->callbacks.cb_error(spi, status);
    ee92:	4629      	mov	r1, r5
    ee94:	1f20      	subs	r0, r4, #4
}
    ee96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		spi->callbacks.cb_error(spi, status);
    ee9a:	4718      	bx	r3
}
    ee9c:	bd70      	pop	{r4, r5, r6, pc}
    ee9e:	bf00      	nop
    eea0:	00011525 	.word	0x00011525
    eea4:	00011551 	.word	0x00011551
    eea8:	00011589 	.word	0x00011589

0000eeac <_spi_dev_complete>:
	if (spi->xfercnt >= spi->xfer.size) {
    eeac:	e9d0 320f 	ldrd	r3, r2, [r0, #60]	; 0x3c
    eeb0:	429a      	cmp	r2, r3
{
    eeb2:	b510      	push	{r4, lr}
    eeb4:	4604      	mov	r4, r0
	if (spi->xfercnt >= spi->xfer.size) {
    eeb6:	d30b      	bcc.n	eed0 <_spi_dev_complete+0x24>
		_spi_m_async_enable_tx_complete(dev, false);
    eeb8:	4b06      	ldr	r3, [pc, #24]	; (eed4 <_spi_dev_complete+0x28>)
    eeba:	2100      	movs	r1, #0
    eebc:	4798      	blx	r3
		spi->stat = 0;
    eebe:	2300      	movs	r3, #0
    eec0:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    eec4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    eec6:	b11b      	cbz	r3, eed0 <_spi_dev_complete+0x24>
			spi->callbacks.cb_xfer(spi);
    eec8:	1f20      	subs	r0, r4, #4
}
    eeca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			spi->callbacks.cb_xfer(spi);
    eece:	4718      	bx	r3
}
    eed0:	bd10      	pop	{r4, pc}
    eed2:	bf00      	nop
    eed4:	00011589 	.word	0x00011589

0000eed8 <_spi_dev_rx>:
{
    eed8:	b570      	push	{r4, r5, r6, lr}
	if (spi->xfer.rxbuf) {
    eeda:	6b85      	ldr	r5, [r0, #56]	; 0x38
    eedc:	4b1c      	ldr	r3, [pc, #112]	; (ef50 <_spi_dev_rx+0x78>)
{
    eede:	4604      	mov	r4, r0
	if (spi->xfer.rxbuf) {
    eee0:	b305      	cbz	r5, ef24 <_spi_dev_rx+0x4c>
		if (!(dev->char_size > 1)) {
    eee2:	7902      	ldrb	r2, [r0, #4]
    eee4:	2a01      	cmp	r2, #1
    eee6:	d816      	bhi.n	ef16 <_spi_dev_rx+0x3e>
			spi->xfer.rxbuf[spi->xfercnt++] = (uint8_t)_spi_m_async_read_one(dev);
    eee8:	4798      	blx	r3
    eeea:	6c23      	ldr	r3, [r4, #64]	; 0x40
    eeec:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    eeee:	1c59      	adds	r1, r3, #1
    eef0:	6421      	str	r1, [r4, #64]	; 0x40
    eef2:	54d0      	strb	r0, [r2, r3]
	if (spi->xfercnt < spi->xfer.size) {
    eef4:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    eef8:	4299      	cmp	r1, r3
    eefa:	d21a      	bcs.n	ef32 <_spi_dev_rx+0x5a>
		if (spi->xfer.txbuf) {
    eefc:	6b62      	ldr	r2, [r4, #52]	; 0x34
    eefe:	4b15      	ldr	r3, [pc, #84]	; (ef54 <_spi_dev_rx+0x7c>)
    ef00:	b1aa      	cbz	r2, ef2e <_spi_dev_rx+0x56>
			if (!(dev->char_size > 1)) {
    ef02:	7920      	ldrb	r0, [r4, #4]
    ef04:	2801      	cmp	r0, #1
				_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt]);
    ef06:	bf94      	ite	ls
    ef08:	5c51      	ldrbls	r1, [r2, r1]
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    ef0a:	f832 1011 	ldrhhi.w	r1, [r2, r1, lsl #1]
    ef0e:	4620      	mov	r0, r4
}
    ef10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    ef14:	4718      	bx	r3
			((uint16_t *)spi->xfer.rxbuf)[spi->xfercnt++] = (uint16_t)_spi_m_async_read_one(dev);
    ef16:	6c06      	ldr	r6, [r0, #64]	; 0x40
    ef18:	1c72      	adds	r2, r6, #1
    ef1a:	6402      	str	r2, [r0, #64]	; 0x40
    ef1c:	4798      	blx	r3
    ef1e:	f825 0016 	strh.w	r0, [r5, r6, lsl #1]
    ef22:	e7e7      	b.n	eef4 <_spi_dev_rx+0x1c>
		_spi_m_async_read_one(dev);
    ef24:	4798      	blx	r3
		spi->xfercnt++;
    ef26:	6c23      	ldr	r3, [r4, #64]	; 0x40
    ef28:	3301      	adds	r3, #1
    ef2a:	6423      	str	r3, [r4, #64]	; 0x40
    ef2c:	e7e2      	b.n	eef4 <_spi_dev_rx+0x1c>
			_spi_m_async_write_one(dev, dev->dummy_byte);
    ef2e:	88e1      	ldrh	r1, [r4, #6]
    ef30:	e7ed      	b.n	ef0e <_spi_dev_rx+0x36>
		_spi_m_async_enable_rx(dev, false);
    ef32:	4b09      	ldr	r3, [pc, #36]	; (ef58 <_spi_dev_rx+0x80>)
    ef34:	2100      	movs	r1, #0
    ef36:	4620      	mov	r0, r4
    ef38:	4798      	blx	r3
		spi->stat = 0;
    ef3a:	2300      	movs	r3, #0
    ef3c:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    ef40:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    ef42:	b11b      	cbz	r3, ef4c <_spi_dev_rx+0x74>
			spi->callbacks.cb_xfer(spi);
    ef44:	1f20      	subs	r0, r4, #4
}
    ef46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			spi->callbacks.cb_xfer(spi);
    ef4a:	4718      	bx	r3
}
    ef4c:	bd70      	pop	{r4, r5, r6, pc}
    ef4e:	bf00      	nop
    ef50:	000115e9 	.word	0x000115e9
    ef54:	000115bd 	.word	0x000115bd
    ef58:	00011551 	.word	0x00011551

0000ef5c <_spi_dev_tx>:
{
    ef5c:	b570      	push	{r4, r5, r6, lr}
    ef5e:	6c03      	ldr	r3, [r0, #64]	; 0x40
	if (!(dev->char_size > 1)) {
    ef60:	7902      	ldrb	r2, [r0, #4]
    ef62:	6b41      	ldr	r1, [r0, #52]	; 0x34
    ef64:	1c5d      	adds	r5, r3, #1
    ef66:	2a01      	cmp	r2, #1
		_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt++]);
    ef68:	6405      	str	r5, [r0, #64]	; 0x40
    ef6a:	bf94      	ite	ls
    ef6c:	5cc9      	ldrbls	r1, [r1, r3]
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    ef6e:	f831 1013 	ldrhhi.w	r1, [r1, r3, lsl #1]
    ef72:	4a09      	ldr	r2, [pc, #36]	; (ef98 <_spi_dev_tx+0x3c>)
{
    ef74:	4604      	mov	r4, r0
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    ef76:	4790      	blx	r2
	if (spi->xfercnt == spi->xfer.size) {
    ef78:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
    ef7c:	429a      	cmp	r2, r3
    ef7e:	d109      	bne.n	ef94 <_spi_dev_tx+0x38>
		_spi_m_async_enable_tx(dev, false);
    ef80:	4b06      	ldr	r3, [pc, #24]	; (ef9c <_spi_dev_tx+0x40>)
    ef82:	2100      	movs	r1, #0
    ef84:	4620      	mov	r0, r4
    ef86:	4798      	blx	r3
		_spi_m_async_enable_tx_complete(dev, true);
    ef88:	4620      	mov	r0, r4
    ef8a:	4b05      	ldr	r3, [pc, #20]	; (efa0 <_spi_dev_tx+0x44>)
}
    ef8c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_enable_tx_complete(dev, true);
    ef90:	2101      	movs	r1, #1
    ef92:	4718      	bx	r3
}
    ef94:	bd70      	pop	{r4, r5, r6, pc}
    ef96:	bf00      	nop
    ef98:	000115bd 	.word	0x000115bd
    ef9c:	00011525 	.word	0x00011525
    efa0:	00011589 	.word	0x00011589

0000efa4 <spi_m_async_init>:
{
    efa4:	b570      	push	{r4, r5, r6, lr}
    efa6:	460e      	mov	r6, r1
	ASSERT(spi && hw);
    efa8:	4604      	mov	r4, r0
    efaa:	b110      	cbz	r0, efb2 <spi_m_async_init+0xe>
    efac:	1e08      	subs	r0, r1, #0
    efae:	bf18      	it	ne
    efb0:	2001      	movne	r0, #1
	spi->dev.prvt = (void *)hw;
    efb2:	4625      	mov	r5, r4
	ASSERT(spi && hw);
    efb4:	4911      	ldr	r1, [pc, #68]	; (effc <spi_m_async_init+0x58>)
    efb6:	4b12      	ldr	r3, [pc, #72]	; (f000 <spi_m_async_init+0x5c>)
    efb8:	22a5      	movs	r2, #165	; 0xa5
    efba:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    efbc:	f845 6f04 	str.w	r6, [r5, #4]!
	rc            = _spi_m_async_init(&spi->dev, hw);
    efc0:	4b10      	ldr	r3, [pc, #64]	; (f004 <spi_m_async_init+0x60>)
    efc2:	4631      	mov	r1, r6
    efc4:	4628      	mov	r0, r5
    efc6:	4798      	blx	r3
	if (rc >= 0) {
    efc8:	2800      	cmp	r0, #0
    efca:	db15      	blt.n	eff8 <spi_m_async_init+0x54>
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (FUNC_PTR)_spi_dev_tx);
    efcc:	4e0e      	ldr	r6, [pc, #56]	; (f008 <spi_m_async_init+0x64>)
    efce:	4a0f      	ldr	r2, [pc, #60]	; (f00c <spi_m_async_init+0x68>)
    efd0:	2100      	movs	r1, #0
    efd2:	4628      	mov	r0, r5
    efd4:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (FUNC_PTR)_spi_dev_rx);
    efd6:	4a0e      	ldr	r2, [pc, #56]	; (f010 <spi_m_async_init+0x6c>)
    efd8:	2101      	movs	r1, #1
    efda:	4628      	mov	r0, r5
    efdc:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (FUNC_PTR)_spi_dev_complete);
    efde:	4a0d      	ldr	r2, [pc, #52]	; (f014 <spi_m_async_init+0x70>)
    efe0:	2102      	movs	r1, #2
    efe2:	4628      	mov	r0, r5
    efe4:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_ERROR, (FUNC_PTR)_spi_dev_error);
    efe6:	4a0c      	ldr	r2, [pc, #48]	; (f018 <spi_m_async_init+0x74>)
    efe8:	2103      	movs	r1, #3
    efea:	4628      	mov	r0, r5
    efec:	47b0      	blx	r6
	spi->io.read  = _spi_m_async_io_read;
    efee:	4b0b      	ldr	r3, [pc, #44]	; (f01c <spi_m_async_init+0x78>)
    eff0:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->io.write = _spi_m_async_io_write;
    eff2:	4b0b      	ldr	r3, [pc, #44]	; (f020 <spi_m_async_init+0x7c>)
    eff4:	6263      	str	r3, [r4, #36]	; 0x24
	return ERR_NONE;
    eff6:	2000      	movs	r0, #0
}
    eff8:	bd70      	pop	{r4, r5, r6, pc}
    effa:	bf00      	nop
    effc:	000171d3 	.word	0x000171d3
    f000:	0000df45 	.word	0x0000df45
    f004:	00011431 	.word	0x00011431
    f008:	00011611 	.word	0x00011611
    f00c:	0000ef5d 	.word	0x0000ef5d
    f010:	0000eed9 	.word	0x0000eed9
    f014:	0000eead 	.word	0x0000eead
    f018:	0000ee6d 	.word	0x0000ee6d
    f01c:	0000ee1d 	.word	0x0000ee1d
    f020:	0000eddd 	.word	0x0000eddd

0000f024 <spi_m_async_enable>:
{
    f024:	b510      	push	{r4, lr}
	ASSERT(spi);
    f026:	4604      	mov	r4, r0
    f028:	3800      	subs	r0, #0
    f02a:	4b05      	ldr	r3, [pc, #20]	; (f040 <spi_m_async_enable+0x1c>)
    f02c:	4905      	ldr	r1, [pc, #20]	; (f044 <spi_m_async_enable+0x20>)
    f02e:	bf18      	it	ne
    f030:	2001      	movne	r0, #1
    f032:	22c1      	movs	r2, #193	; 0xc1
    f034:	4798      	blx	r3
	_spi_m_async_enable(&spi->dev);
    f036:	1d20      	adds	r0, r4, #4
    f038:	4b03      	ldr	r3, [pc, #12]	; (f048 <spi_m_async_enable+0x24>)
}
    f03a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_async_enable(&spi->dev);
    f03e:	4718      	bx	r3
    f040:	0000df45 	.word	0x0000df45
    f044:	000171d3 	.word	0x000171d3
    f048:	00011489 	.word	0x00011489

0000f04c <spi_m_async_set_baudrate>:
{
    f04c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f04e:	4604      	mov	r4, r0
    f050:	3800      	subs	r0, #0
    f052:	4b0a      	ldr	r3, [pc, #40]	; (f07c <spi_m_async_set_baudrate+0x30>)
    f054:	bf18      	it	ne
    f056:	2001      	movne	r0, #1
{
    f058:	460d      	mov	r5, r1
	ASSERT(spi);
    f05a:	22cf      	movs	r2, #207	; 0xcf
    f05c:	4908      	ldr	r1, [pc, #32]	; (f080 <spi_m_async_set_baudrate+0x34>)
    f05e:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f060:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f064:	06db      	lsls	r3, r3, #27
    f066:	d405      	bmi.n	f074 <spi_m_async_set_baudrate+0x28>
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f068:	4629      	mov	r1, r5
    f06a:	1d20      	adds	r0, r4, #4
    f06c:	4b05      	ldr	r3, [pc, #20]	; (f084 <spi_m_async_set_baudrate+0x38>)
}
    f06e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f072:	4718      	bx	r3
}
    f074:	f06f 0003 	mvn.w	r0, #3
    f078:	bd70      	pop	{r4, r5, r6, pc}
    f07a:	bf00      	nop
    f07c:	0000df45 	.word	0x0000df45
    f080:	000171d3 	.word	0x000171d3
    f084:	000114ed 	.word	0x000114ed

0000f088 <spi_m_async_set_mode>:
{
    f088:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f08a:	4604      	mov	r4, r0
    f08c:	3800      	subs	r0, #0
    f08e:	4b0a      	ldr	r3, [pc, #40]	; (f0b8 <spi_m_async_set_mode+0x30>)
    f090:	bf18      	it	ne
    f092:	2001      	movne	r0, #1
{
    f094:	460d      	mov	r5, r1
	ASSERT(spi);
    f096:	22d9      	movs	r2, #217	; 0xd9
    f098:	4908      	ldr	r1, [pc, #32]	; (f0bc <spi_m_async_set_mode+0x34>)
    f09a:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f09c:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f0a0:	06db      	lsls	r3, r3, #27
    f0a2:	d405      	bmi.n	f0b0 <spi_m_async_set_mode+0x28>
	return _spi_m_async_set_mode(&spi->dev, mode);
    f0a4:	4629      	mov	r1, r5
    f0a6:	1d20      	adds	r0, r4, #4
    f0a8:	4b05      	ldr	r3, [pc, #20]	; (f0c0 <spi_m_async_set_mode+0x38>)
}
    f0aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_mode(&spi->dev, mode);
    f0ae:	4718      	bx	r3
}
    f0b0:	f06f 0003 	mvn.w	r0, #3
    f0b4:	bd70      	pop	{r4, r5, r6, pc}
    f0b6:	bf00      	nop
    f0b8:	0000df45 	.word	0x0000df45
    f0bc:	000171d3 	.word	0x000171d3
    f0c0:	000114b9 	.word	0x000114b9

0000f0c4 <spi_m_async_transfer>:

int32_t spi_m_async_transfer(struct spi_m_async_descriptor *spi, uint8_t const *txbuf, uint8_t *const rxbuf,
                             const uint16_t length)
{
    f0c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(spi);
    f0c6:	4604      	mov	r4, r0
    f0c8:	3800      	subs	r0, #0
{
    f0ca:	461e      	mov	r6, r3
	ASSERT(spi);
    f0cc:	bf18      	it	ne
    f0ce:	2001      	movne	r0, #1
    f0d0:	4b11      	ldr	r3, [pc, #68]	; (f118 <spi_m_async_transfer+0x54>)
{
    f0d2:	460d      	mov	r5, r1
    f0d4:	4617      	mov	r7, r2
	ASSERT(spi);
    f0d6:	4911      	ldr	r1, [pc, #68]	; (f11c <spi_m_async_transfer+0x58>)
    f0d8:	f44f 729c 	mov.w	r2, #312	; 0x138
    f0dc:	4798      	blx	r3

	/* Fill transfer descriptor */
	spi->xfer.rxbuf = (uint8_t *)rxbuf;
	spi->xfer.txbuf = (uint8_t *)txbuf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;
    f0de:	2300      	movs	r3, #0
	spi->xfer.size  = length;
    f0e0:	6426      	str	r6, [r4, #64]	; 0x40
	spi->xfercnt    = 0;
    f0e2:	6463      	str	r3, [r4, #68]	; 0x44

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
	_spi_m_async_enable_rx(&spi->dev, true);
    f0e4:	1d26      	adds	r6, r4, #4
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f0e6:	2310      	movs	r3, #16
    f0e8:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	spi->xfer.txbuf = (uint8_t *)txbuf;
    f0ec:	e9c4 570e 	strd	r5, r7, [r4, #56]	; 0x38
	_spi_m_async_enable_rx(&spi->dev, true);
    f0f0:	4b0b      	ldr	r3, [pc, #44]	; (f120 <spi_m_async_transfer+0x5c>)
    f0f2:	2101      	movs	r1, #1
    f0f4:	4630      	mov	r0, r6
    f0f6:	4798      	blx	r3
	if (txbuf) {
    f0f8:	4b0a      	ldr	r3, [pc, #40]	; (f124 <spi_m_async_transfer+0x60>)
    f0fa:	b155      	cbz	r5, f112 <spi_m_async_transfer+0x4e>
		if (!(spi->dev.char_size > 1)) {
    f0fc:	7a21      	ldrb	r1, [r4, #8]
    f0fe:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f100:	2901      	cmp	r1, #1
			_spi_m_async_write_one(&spi->dev, txbuf[spi->xfercnt]);
    f102:	bf94      	ite	ls
    f104:	5ca9      	ldrbls	r1, [r5, r2]
		} else {
			_spi_m_async_write_one(&spi->dev, ((uint16_t *)txbuf)[spi->xfercnt]);
    f106:	f835 1012 	ldrhhi.w	r1, [r5, r2, lsl #1]
		}
	} else {
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f10a:	4630      	mov	r0, r6
    f10c:	4798      	blx	r3
	}

	return ERR_NONE;
}
    f10e:	2000      	movs	r0, #0
    f110:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f112:	8961      	ldrh	r1, [r4, #10]
    f114:	e7f9      	b.n	f10a <spi_m_async_transfer+0x46>
    f116:	bf00      	nop
    f118:	0000df45 	.word	0x0000df45
    f11c:	000171d3 	.word	0x000171d3
    f120:	00011551 	.word	0x00011551
    f124:	000115bd 	.word	0x000115bd

0000f128 <spi_m_async_register_callback>:
	return ERR_NONE;
}

void spi_m_async_register_callback(struct spi_m_async_descriptor *spi, const enum spi_m_async_cb_type type,
                                   FUNC_PTR func)
{
    f128:	b570      	push	{r4, r5, r6, lr}
    f12a:	460e      	mov	r6, r1
    f12c:	4615      	mov	r5, r2
	ASSERT(spi && (type < SPI_M_ASYNC_CB_N));
    f12e:	4604      	mov	r4, r0
    f130:	b118      	cbz	r0, f13a <spi_m_async_register_callback+0x12>
    f132:	2901      	cmp	r1, #1
    f134:	bf8c      	ite	hi
    f136:	2000      	movhi	r0, #0
    f138:	2001      	movls	r0, #1
    f13a:	4909      	ldr	r1, [pc, #36]	; (f160 <spi_m_async_register_callback+0x38>)
    f13c:	4b09      	ldr	r3, [pc, #36]	; (f164 <spi_m_async_register_callback+0x3c>)
    f13e:	f240 1263 	movw	r2, #355	; 0x163
    f142:	4798      	blx	r3

	if (SPI_M_ASYNC_CB_XFER == type) {
    f144:	b90e      	cbnz	r6, f14a <spi_m_async_register_callback+0x22>
		spi->callbacks.cb_xfer = (spi_m_async_cb_xfer_t)func;
    f146:	6325      	str	r5, [r4, #48]	; 0x30
	} else {
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
	}
}
    f148:	bd70      	pop	{r4, r5, r6, pc}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f14a:	1e2a      	subs	r2, r5, #0
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
    f14c:	6365      	str	r5, [r4, #52]	; 0x34
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f14e:	f104 0004 	add.w	r0, r4, #4
    f152:	4b05      	ldr	r3, [pc, #20]	; (f168 <spi_m_async_register_callback+0x40>)
}
    f154:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f158:	bf18      	it	ne
    f15a:	2201      	movne	r2, #1
    f15c:	2103      	movs	r1, #3
    f15e:	4718      	bx	r3
    f160:	000171d3 	.word	0x000171d3
    f164:	0000df45 	.word	0x0000df45
    f168:	00011641 	.word	0x00011641

0000f16c <spi_m_async_get_io_descriptor>:

int32_t spi_m_async_get_io_descriptor(struct spi_m_async_descriptor *const spi, struct io_descriptor **io)
{
    f16c:	b538      	push	{r3, r4, r5, lr}
    f16e:	460d      	mov	r5, r1
	ASSERT(spi && io);
    f170:	4604      	mov	r4, r0
    f172:	b110      	cbz	r0, f17a <spi_m_async_get_io_descriptor+0xe>
    f174:	1e08      	subs	r0, r1, #0
    f176:	bf18      	it	ne
    f178:	2001      	movne	r0, #1
    f17a:	4904      	ldr	r1, [pc, #16]	; (f18c <spi_m_async_get_io_descriptor+0x20>)
    f17c:	4b04      	ldr	r3, [pc, #16]	; (f190 <spi_m_async_get_io_descriptor+0x24>)
    f17e:	f240 126f 	movw	r2, #367	; 0x16f
	*io = &spi->io;
    f182:	3424      	adds	r4, #36	; 0x24
	ASSERT(spi && io);
    f184:	4798      	blx	r3
	*io = &spi->io;
    f186:	602c      	str	r4, [r5, #0]
	return 0;
}
    f188:	2000      	movs	r0, #0
    f18a:	bd38      	pop	{r3, r4, r5, pc}
    f18c:	000171d3 	.word	0x000171d3
    f190:	0000df45 	.word	0x0000df45

0000f194 <crc_sync_init>:

/**
 * \brief Initialize CRC.
 */
int32_t crc_sync_init(struct crc_sync_descriptor *const descr, void *const hw)
{
    f194:	b570      	push	{r4, r5, r6, lr}
    f196:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    f198:	4604      	mov	r4, r0
    f19a:	b110      	cbz	r0, f1a2 <crc_sync_init+0xe>
    f19c:	1e08      	subs	r0, r1, #0
    f19e:	bf18      	it	ne
    f1a0:	2001      	movne	r0, #1
    f1a2:	4905      	ldr	r1, [pc, #20]	; (f1b8 <crc_sync_init+0x24>)
    f1a4:	4b05      	ldr	r3, [pc, #20]	; (f1bc <crc_sync_init+0x28>)
    f1a6:	222b      	movs	r2, #43	; 0x2b
    f1a8:	4798      	blx	r3

	return _crc_sync_init(&descr->dev, hw);
    f1aa:	4629      	mov	r1, r5
    f1ac:	4620      	mov	r0, r4
    f1ae:	4b04      	ldr	r3, [pc, #16]	; (f1c0 <crc_sync_init+0x2c>)
}
    f1b0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _crc_sync_init(&descr->dev, hw);
    f1b4:	4718      	bx	r3
    f1b6:	bf00      	nop
    f1b8:	000171f0 	.word	0x000171f0
    f1bc:	0000df45 	.word	0x0000df45
    f1c0:	000137f5 	.word	0x000137f5

0000f1c4 <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f1c4:	4a0a      	ldr	r2, [pc, #40]	; (f1f0 <_usb_d_find_ep+0x2c>)
{
    f1c6:	b570      	push	{r4, r5, r6, lr}
    f1c8:	2300      	movs	r3, #0
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f1ca:	f000 050f 	and.w	r5, r0, #15
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    f1ce:	7854      	ldrb	r4, [r2, #1]
    f1d0:	4284      	cmp	r4, r0
    f1d2:	b259      	sxtb	r1, r3
    f1d4:	d00a      	beq.n	f1ec <_usb_d_find_ep+0x28>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    f1d6:	7816      	ldrb	r6, [r2, #0]
    f1d8:	b90e      	cbnz	r6, f1de <_usb_d_find_ep+0x1a>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f1da:	42ac      	cmp	r4, r5
    f1dc:	d006      	beq.n	f1ec <_usb_d_find_ep+0x28>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f1de:	3301      	adds	r3, #1
    f1e0:	2b0d      	cmp	r3, #13
    f1e2:	f102 0220 	add.w	r2, r2, #32
    f1e6:	d1f2      	bne.n	f1ce <_usb_d_find_ep+0xa>
			return i;
		}
	}
	return -1;
    f1e8:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
}
    f1ec:	4608      	mov	r0, r1
    f1ee:	bd70      	pop	{r4, r5, r6, pc}
    f1f0:	200017b0 	.word	0x200017b0

0000f1f4 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    f1f4:	2000      	movs	r0, #0
    f1f6:	4770      	bx	lr

0000f1f8 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    f1f8:	b513      	push	{r0, r1, r4, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f1fa:	4b0a      	ldr	r3, [pc, #40]	; (f224 <usb_d_cb_trans_more+0x2c>)
{
    f1fc:	9101      	str	r1, [sp, #4]
    f1fe:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f200:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    f202:	4b09      	ldr	r3, [pc, #36]	; (f228 <usb_d_cb_trans_more+0x30>)
    f204:	9901      	ldr	r1, [sp, #4]
    f206:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    f20a:	789a      	ldrb	r2, [r3, #2]
    f20c:	2a03      	cmp	r2, #3
    f20e:	d105      	bne.n	f21c <usb_d_cb_trans_more+0x24>
		return ept->callbacks.more(ep, transfered);
    f210:	699b      	ldr	r3, [r3, #24]
    f212:	4620      	mov	r0, r4
	}
	return false;
}
    f214:	b002      	add	sp, #8
    f216:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return ept->callbacks.more(ep, transfered);
    f21a:	4718      	bx	r3
}
    f21c:	2000      	movs	r0, #0
    f21e:	b002      	add	sp, #8
    f220:	bd10      	pop	{r4, pc}
    f222:	bf00      	nop
    f224:	0000f1c5 	.word	0x0000f1c5
    f228:	200017b0 	.word	0x200017b0

0000f22c <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    f22c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f230:	4b37      	ldr	r3, [pc, #220]	; (f310 <_usb_d_cb_trans_done+0xe4>)
    f232:	4c38      	ldr	r4, [pc, #224]	; (f314 <_usb_d_cb_trans_done+0xe8>)
{
    f234:	b085      	sub	sp, #20
    f236:	4680      	mov	r8, r0
    f238:	460f      	mov	r7, r1
    f23a:	4691      	mov	r9, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f23c:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    f23e:	0146      	lsls	r6, r0, #5
    f240:	2f00      	cmp	r7, #0
    f242:	d143      	bne.n	f2cc <_usb_d_cb_trans_done+0xa0>
		ept->xfer.hdr.status = USB_XFER_DONE;
    f244:	19a5      	adds	r5, r4, r6
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f246:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_DONE;
    f248:	70ef      	strb	r7, [r5, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f24a:	2900      	cmp	r1, #0
    f24c:	d135      	bne.n	f2ba <_usb_d_cb_trans_done+0x8e>
	if (state == USB_EP_S_X_DATA) {
    f24e:	2320      	movs	r3, #32
    f250:	220c      	movs	r2, #12
    f252:	fb13 2000 	smlabb	r0, r3, r0, r2
    f256:	78ab      	ldrb	r3, [r5, #2]
    f258:	2b03      	cmp	r3, #3
    f25a:	eb04 0200 	add.w	r2, r4, r0
    f25e:	69eb      	ldr	r3, [r5, #28]
    f260:	7868      	ldrb	r0, [r5, #1]
    f262:	d126      	bne.n	f2b2 <_usb_d_cb_trans_done+0x86>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    f264:	2101      	movs	r1, #1
    f266:	f995 400c 	ldrsb.w	r4, [r5, #12]
    f26a:	4798      	blx	r3
		if (err) {
    f26c:	786b      	ldrb	r3, [r5, #1]
    f26e:	b168      	cbz	r0, f28c <_usb_d_cb_trans_done+0x60>
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f270:	2c00      	cmp	r4, #0
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f272:	f240 2205 	movw	r2, #517	; 0x205
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f276:	bfb4      	ite	lt
    f278:	4618      	movlt	r0, r3
    f27a:	f043 0080 	orrge.w	r0, r3, #128	; 0x80
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f27e:	806a      	strh	r2, [r5, #2]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f280:	4b25      	ldr	r3, [pc, #148]	; (f318 <_usb_d_cb_trans_done+0xec>)
    f282:	2101      	movs	r1, #1
    f284:	4798      	blx	r3
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
}
    f286:	b005      	add	sp, #20
    f288:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct usb_d_transfer trans
    f28c:	2c00      	cmp	r4, #0
    f28e:	bfac      	ite	ge
    f290:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    f294:	f003 030f 	andlt.w	r3, r3, #15
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f298:	2204      	movs	r2, #4
	struct usb_d_transfer trans
    f29a:	f88d 300c 	strb.w	r3, [sp, #12]
    f29e:	2301      	movs	r3, #1
    f2a0:	e9cd 0001 	strd	r0, r0, [sp, #4]
    f2a4:	f88d 300d 	strb.w	r3, [sp, #13]
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f2a8:	70aa      	strb	r2, [r5, #2]
	return _usb_d_dev_ep_trans(&trans);
    f2aa:	4b1c      	ldr	r3, [pc, #112]	; (f31c <_usb_d_cb_trans_done+0xf0>)
    f2ac:	a801      	add	r0, sp, #4
    f2ae:	4798      	blx	r3
    f2b0:	e7e9      	b.n	f286 <_usb_d_cb_trans_done+0x5a>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    f2b2:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f2b4:	2302      	movs	r3, #2
    f2b6:	70ab      	strb	r3, [r5, #2]
    f2b8:	e7e5      	b.n	f286 <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f2ba:	2301      	movs	r3, #1
    f2bc:	70ab      	strb	r3, [r5, #2]
	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    f2be:	4434      	add	r4, r6
    f2c0:	464a      	mov	r2, r9
    f2c2:	69e3      	ldr	r3, [r4, #28]
    f2c4:	78e1      	ldrb	r1, [r4, #3]
    f2c6:	4640      	mov	r0, r8
    f2c8:	4798      	blx	r3
    f2ca:	e7dc      	b.n	f286 <_usb_d_cb_trans_done+0x5a>
	} else if (code == USB_TRANS_STALL) {
    f2cc:	2f01      	cmp	r7, #1
		ept->xfer.hdr.status = USB_XFER_HALT;
    f2ce:	eb04 0306 	add.w	r3, r4, r6
	} else if (code == USB_TRANS_STALL) {
    f2d2:	d10b      	bne.n	f2ec <_usb_d_cb_trans_done+0xc0>
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f2d4:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_HALT;
    f2d6:	2202      	movs	r2, #2
    f2d8:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f2da:	b921      	cbnz	r1, f2e6 <_usb_d_cb_trans_done+0xba>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f2dc:	709a      	strb	r2, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f2de:	4640      	mov	r0, r8
    f2e0:	4b0d      	ldr	r3, [pc, #52]	; (f318 <_usb_d_cb_trans_done+0xec>)
    f2e2:	4798      	blx	r3
    f2e4:	e7eb      	b.n	f2be <_usb_d_cb_trans_done+0x92>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    f2e6:	2205      	movs	r2, #5
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f2e8:	709a      	strb	r2, [r3, #2]
    f2ea:	e7e8      	b.n	f2be <_usb_d_cb_trans_done+0x92>
	} else if (code == USB_TRANS_ABORT) {
    f2ec:	2f02      	cmp	r7, #2
    f2ee:	d107      	bne.n	f300 <_usb_d_cb_trans_done+0xd4>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    f2f0:	2204      	movs	r2, #4
    f2f2:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f2f4:	5da2      	ldrb	r2, [r4, r6]
    f2f6:	b90a      	cbnz	r2, f2fc <_usb_d_cb_trans_done+0xd0>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f2f8:	709f      	strb	r7, [r3, #2]
			return;
    f2fa:	e7c4      	b.n	f286 <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f2fc:	2201      	movs	r2, #1
    f2fe:	e7f3      	b.n	f2e8 <_usb_d_cb_trans_done+0xbc>
	} else if (code == USB_TRANS_RESET) {
    f300:	2f03      	cmp	r7, #3
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    f302:	bf0c      	ite	eq
    f304:	f44f 62a0 	moveq.w	r2, #1280	; 0x500
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    f308:	f240 6206 	movwne	r2, #1542	; 0x606
    f30c:	805a      	strh	r2, [r3, #2]
    f30e:	e7d6      	b.n	f2be <_usb_d_cb_trans_done+0x92>
    f310:	0000f1c5 	.word	0x0000f1c5
    f314:	200017b0 	.word	0x200017b0
    f318:	0000d5c5 	.word	0x0000d5c5
    f31c:	0000d6e5 	.word	0x0000d6e5

0000f320 <usb_d_cb_trans_setup>:
{
    f320:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f324:	4b18      	ldr	r3, [pc, #96]	; (f388 <usb_d_cb_trans_setup+0x68>)
	uint8_t *        req      = ept->xfer.req;
    f326:	4f19      	ldr	r7, [pc, #100]	; (f38c <usb_d_cb_trans_setup+0x6c>)
    f328:	4d19      	ldr	r5, [pc, #100]	; (f390 <usb_d_cb_trans_setup+0x70>)
{
    f32a:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f32c:	4798      	blx	r3
	uint8_t *        req      = ept->xfer.req;
    f32e:	f04f 0820 	mov.w	r8, #32
    f332:	230c      	movs	r3, #12
    f334:	fb18 3800 	smlabb	r8, r8, r0, r3
    f338:	44b8      	add	r8, r7
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f33a:	4b16      	ldr	r3, [pc, #88]	; (f394 <usb_d_cb_trans_setup+0x74>)
	int8_t           ep_index = _usb_d_find_ep(ep);
    f33c:	4606      	mov	r6, r0
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f33e:	4641      	mov	r1, r8
    f340:	4620      	mov	r0, r4
    f342:	4798      	blx	r3
	if (n != 8) {
    f344:	b2c0      	uxtb	r0, r0
    f346:	2808      	cmp	r0, #8
    f348:	f044 0980 	orr.w	r9, r4, #128	; 0x80
    f34c:	d008      	beq.n	f360 <usb_d_cb_trans_setup+0x40>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f34e:	2101      	movs	r1, #1
    f350:	4620      	mov	r0, r4
    f352:	47a8      	blx	r5
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f354:	4648      	mov	r0, r9
    f356:	462b      	mov	r3, r5
    f358:	2101      	movs	r1, #1
}
    f35a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f35e:	4718      	bx	r3
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f360:	eb07 1646 	add.w	r6, r7, r6, lsl #5
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f364:	2100      	movs	r1, #0
    f366:	4620      	mov	r0, r4
    f368:	47a8      	blx	r5
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f36a:	2701      	movs	r7, #1
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    f36c:	2100      	movs	r1, #0
    f36e:	4648      	mov	r0, r9
    f370:	47a8      	blx	r5
	if (!ept->callbacks.req(ep, req)) {
    f372:	6973      	ldr	r3, [r6, #20]
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f374:	70b7      	strb	r7, [r6, #2]
	if (!ept->callbacks.req(ep, req)) {
    f376:	4641      	mov	r1, r8
    f378:	4620      	mov	r0, r4
    f37a:	4798      	blx	r3
    f37c:	b910      	cbnz	r0, f384 <usb_d_cb_trans_setup+0x64>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    f37e:	2305      	movs	r3, #5
    f380:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f382:	e7e4      	b.n	f34e <usb_d_cb_trans_setup+0x2e>
}
    f384:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f388:	0000f1c5 	.word	0x0000f1c5
    f38c:	200017b0 	.word	0x200017b0
    f390:	0000d5c5 	.word	0x0000d5c5
    f394:	0000d691 	.word	0x0000d691

0000f398 <usb_d_init>:

int32_t usb_d_init(void)
{
    f398:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    f39a:	4b11      	ldr	r3, [pc, #68]	; (f3e0 <usb_d_init+0x48>)
    f39c:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    f39e:	2800      	cmp	r0, #0
    f3a0:	db1d      	blt.n	f3de <usb_d_init+0x46>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f3a2:	4b10      	ldr	r3, [pc, #64]	; (f3e4 <usb_d_init+0x4c>)
    f3a4:	4810      	ldr	r0, [pc, #64]	; (f3e8 <usb_d_init+0x50>)
    f3a6:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    f3aa:	2100      	movs	r1, #0
    f3ac:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f3ae:	4b0e      	ldr	r3, [pc, #56]	; (f3e8 <usb_d_init+0x50>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    f3b0:	490e      	ldr	r1, [pc, #56]	; (f3ec <usb_d_init+0x54>)
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f3b2:	2200      	movs	r2, #0
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f3b4:	20ff      	movs	r0, #255	; 0xff
    f3b6:	3201      	adds	r2, #1
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f3b8:	2a0d      	cmp	r2, #13
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    f3ba:	e9c3 1105 	strd	r1, r1, [r3, #20]
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f3be:	7058      	strb	r0, [r3, #1]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    f3c0:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f3c2:	f103 0320 	add.w	r3, r3, #32
    f3c6:	d1f6      	bne.n	f3b6 <usb_d_init+0x1e>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    f3c8:	4c09      	ldr	r4, [pc, #36]	; (f3f0 <usb_d_init+0x58>)
    f3ca:	490a      	ldr	r1, [pc, #40]	; (f3f4 <usb_d_init+0x5c>)
    f3cc:	2000      	movs	r0, #0
    f3ce:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    f3d0:	4909      	ldr	r1, [pc, #36]	; (f3f8 <usb_d_init+0x60>)
    f3d2:	2001      	movs	r0, #1
    f3d4:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    f3d6:	2002      	movs	r0, #2
    f3d8:	4908      	ldr	r1, [pc, #32]	; (f3fc <usb_d_init+0x64>)
    f3da:	47a0      	blx	r4
	return ERR_NONE;
    f3dc:	2000      	movs	r0, #0
}
    f3de:	bd10      	pop	{r4, pc}
    f3e0:	0000d1bd 	.word	0x0000d1bd
    f3e4:	00014175 	.word	0x00014175
    f3e8:	200017b0 	.word	0x200017b0
    f3ec:	0000f1f5 	.word	0x0000f1f5
    f3f0:	0000d885 	.word	0x0000d885
    f3f4:	0000f321 	.word	0x0000f321
    f3f8:	0000f1f9 	.word	0x0000f1f9
    f3fc:	0000f22d 	.word	0x0000f22d

0000f400 <usb_d_register_callback>:
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    f400:	4b00      	ldr	r3, [pc, #0]	; (f404 <usb_d_register_callback+0x4>)
    f402:	4718      	bx	r3
    f404:	0000d861 	.word	0x0000d861

0000f408 <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
	return _usb_d_dev_enable();
    f408:	4b00      	ldr	r3, [pc, #0]	; (f40c <usb_d_enable+0x4>)
    f40a:	4718      	bx	r3
    f40c:	0000d299 	.word	0x0000d299

0000f410 <usb_d_attach>:
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
	_usb_d_dev_attach();
    f410:	4b00      	ldr	r3, [pc, #0]	; (f414 <usb_d_attach+0x4>)
    f412:	4718      	bx	r3
    f414:	0000d2f5 	.word	0x0000d2f5

0000f418 <usb_d_get_frame_num>:
	return _usb_d_dev_get_speed();
}

uint16_t usb_d_get_frame_num(void)
{
	return _usb_d_dev_get_frame_n();
    f418:	4b00      	ldr	r3, [pc, #0]	; (f41c <usb_d_get_frame_num+0x4>)
    f41a:	4718      	bx	r3
    f41c:	0000d313 	.word	0x0000d313

0000f420 <usb_d_set_address>:
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
	_usb_d_dev_set_address(addr);
    f420:	4b00      	ldr	r3, [pc, #0]	; (f424 <usb_d_set_address+0x4>)
    f422:	4718      	bx	r3
    f424:	0000d307 	.word	0x0000d307

0000f428 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    f428:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    f42a:	4c11      	ldr	r4, [pc, #68]	; (f470 <usb_d_ep_init+0x48>)
{
    f42c:	4606      	mov	r6, r0
    f42e:	460d      	mov	r5, r1
    f430:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f432:	47a0      	blx	r4
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    f434:	2800      	cmp	r0, #0
    f436:	da14      	bge.n	f462 <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    f438:	20ff      	movs	r0, #255	; 0xff
    f43a:	47a0      	blx	r4
		if (ep_index < 0) {
    f43c:	1e04      	subs	r4, r0, #0
    f43e:	db13      	blt.n	f468 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    f440:	4b0c      	ldr	r3, [pc, #48]	; (f474 <usb_d_ep_init+0x4c>)
    f442:	463a      	mov	r2, r7
    f444:	4629      	mov	r1, r5
    f446:	4630      	mov	r0, r6
    f448:	4798      	blx	r3
	if (rc < 0) {
    f44a:	2800      	cmp	r0, #0
    f44c:	db08      	blt.n	f460 <usb_d_ep_init+0x38>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    f44e:	4b0a      	ldr	r3, [pc, #40]	; (f478 <usb_d_ep_init+0x50>)
    f450:	0162      	lsls	r2, r4, #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f452:	f005 0503 	and.w	r5, r5, #3
	ept->xfer.hdr.ep   = ep;
    f456:	eb03 1444 	add.w	r4, r3, r4, lsl #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f45a:	549d      	strb	r5, [r3, r2]
	ept->xfer.hdr.ep   = ep;
    f45c:	7066      	strb	r6, [r4, #1]
	return ERR_NONE;
    f45e:	2000      	movs	r0, #0
}
    f460:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    f462:	f06f 0013 	mvn.w	r0, #19
    f466:	e7fb      	b.n	f460 <usb_d_ep_init+0x38>
			return -USB_ERR_ALLOC_FAIL;
    f468:	f06f 0014 	mvn.w	r0, #20
    f46c:	e7f8      	b.n	f460 <usb_d_ep_init+0x38>
    f46e:	bf00      	nop
    f470:	0000f1c5 	.word	0x0000f1c5
    f474:	0000d321 	.word	0x0000d321
    f478:	200017b0 	.word	0x200017b0

0000f47c <usb_d_ep0_init>:
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f47c:	2100      	movs	r1, #0
{
    f47e:	4602      	mov	r2, r0
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f480:	4b01      	ldr	r3, [pc, #4]	; (f488 <usb_d_ep0_init+0xc>)
    f482:	4608      	mov	r0, r1
    f484:	4718      	bx	r3
    f486:	bf00      	nop
    f488:	0000f429 	.word	0x0000f429

0000f48c <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    f48c:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f48e:	4b07      	ldr	r3, [pc, #28]	; (f4ac <usb_d_ep_deinit+0x20>)
{
    f490:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f492:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    f494:	1e04      	subs	r4, r0, #0
    f496:	db07      	blt.n	f4a8 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    f498:	4b05      	ldr	r3, [pc, #20]	; (f4b0 <usb_d_ep_deinit+0x24>)
    f49a:	4628      	mov	r0, r5
    f49c:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    f49e:	4805      	ldr	r0, [pc, #20]	; (f4b4 <usb_d_ep_deinit+0x28>)
    f4a0:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    f4a4:	23ff      	movs	r3, #255	; 0xff
    f4a6:	7043      	strb	r3, [r0, #1]
}
    f4a8:	bd38      	pop	{r3, r4, r5, pc}
    f4aa:	bf00      	nop
    f4ac:	0000f1c5 	.word	0x0000f1c5
    f4b0:	0000d3e1 	.word	0x0000d3e1
    f4b4:	200017b0 	.word	0x200017b0

0000f4b8 <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    f4b8:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f4ba:	4b0c      	ldr	r3, [pc, #48]	; (f4ec <usb_d_ep_enable+0x34>)
{
    f4bc:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f4be:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    f4c0:	1e03      	subs	r3, r0, #0
    f4c2:	db10      	blt.n	f4e6 <usb_d_ep_enable+0x2e>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f4c4:	015b      	lsls	r3, r3, #5
    f4c6:	4c0a      	ldr	r4, [pc, #40]	; (f4f0 <usb_d_ep_enable+0x38>)
    f4c8:	5ce2      	ldrb	r2, [r4, r3]
    f4ca:	441c      	add	r4, r3
    f4cc:	2a00      	cmp	r2, #0
    f4ce:	bf0c      	ite	eq
    f4d0:	2202      	moveq	r2, #2
    f4d2:	2201      	movne	r2, #1
	rc                  = _usb_d_dev_ep_enable(ep);
    f4d4:	4b07      	ldr	r3, [pc, #28]	; (f4f4 <usb_d_ep_enable+0x3c>)
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f4d6:	70a2      	strb	r2, [r4, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    f4d8:	4628      	mov	r0, r5
    f4da:	4798      	blx	r3
	if (rc < 0) {
    f4dc:	2800      	cmp	r0, #0
    f4de:	da01      	bge.n	f4e4 <usb_d_ep_enable+0x2c>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    f4e0:	2300      	movs	r3, #0
    f4e2:	70a3      	strb	r3, [r4, #2]
	}
	return rc;
}
    f4e4:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    f4e6:	f06f 0011 	mvn.w	r0, #17
    f4ea:	e7fb      	b.n	f4e4 <usb_d_ep_enable+0x2c>
    f4ec:	0000f1c5 	.word	0x0000f1c5
    f4f0:	200017b0 	.word	0x200017b0
    f4f4:	0000d455 	.word	0x0000d455

0000f4f8 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    f4f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f4fc:	f890 8008 	ldrb.w	r8, [r0, #8]
    f500:	4b31      	ldr	r3, [pc, #196]	; (f5c8 <usb_d_ep_transfer+0xd0>)
{
    f502:	4605      	mov	r5, r0
    f504:	b087      	sub	sp, #28
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f506:	4640      	mov	r0, r8
    f508:	4798      	blx	r3
	uint32_t              len = xfer->size;
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    f50a:	1e04      	subs	r4, r0, #0
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f50c:	7a6f      	ldrb	r7, [r5, #9]
	uint32_t              len = xfer->size;
    f50e:	686e      	ldr	r6, [r5, #4]
	if (ep_index < 0) {
    f510:	db55      	blt.n	f5be <usb_d_ep_transfer+0xc6>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
	state = ept->xfer.hdr.state;
    f512:	f8df a0c8 	ldr.w	sl, [pc, #200]	; f5dc <usb_d_ep_transfer+0xe4>
	atomic_enter_critical(&flags);
    f516:	4b2d      	ldr	r3, [pc, #180]	; (f5cc <usb_d_ep_transfer+0xd4>)
	state = ept->xfer.hdr.state;
    f518:	ea4f 1b44 	mov.w	fp, r4, lsl #5
    f51c:	eb0a 1444 	add.w	r4, sl, r4, lsl #5
	atomic_enter_critical(&flags);
    f520:	a802      	add	r0, sp, #8
    f522:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    f524:	78a3      	ldrb	r3, [r4, #2]
    f526:	f88d 3007 	strb.w	r3, [sp, #7]
	if (state == USB_EP_S_IDLE) {
    f52a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f52e:	2b01      	cmp	r3, #1
    f530:	fa5f f983 	uxtb.w	r9, r3
    f534:	4b26      	ldr	r3, [pc, #152]	; (f5d0 <usb_d_ep_transfer+0xd8>)
    f536:	d11a      	bne.n	f56e <usb_d_ep_transfer+0x76>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    f538:	2203      	movs	r2, #3
    f53a:	70a2      	strb	r2, [r4, #2]
		atomic_leave_critical(&flags);
    f53c:	a802      	add	r0, sp, #8
    f53e:	4798      	blx	r3
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f540:	f81a 300b 	ldrb.w	r3, [sl, fp]
    f544:	b1fb      	cbz	r3, f586 <usb_d_ep_transfer+0x8e>
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f546:	1e3b      	subs	r3, r7, #0
    f548:	ea4f 12d8 	mov.w	r2, r8, lsr #7
    f54c:	bf18      	it	ne
    f54e:	2301      	movne	r3, #1
	struct usb_d_transfer trans
    f550:	6828      	ldr	r0, [r5, #0]
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    f552:	7a29      	ldrb	r1, [r5, #8]
	struct usb_d_transfer trans
    f554:	e9cd 0603 	strd	r0, r6, [sp, #12]
    f558:	b372      	cbz	r2, f5b8 <usb_d_ep_transfer+0xc0>
    f55a:	f041 0280 	orr.w	r2, r1, #128	; 0x80
    f55e:	f88d 3015 	strb.w	r3, [sp, #21]
	return _usb_d_dev_ep_trans(&trans);
    f562:	a803      	add	r0, sp, #12
    f564:	4b1b      	ldr	r3, [pc, #108]	; (f5d4 <usb_d_ep_transfer+0xdc>)
	struct usb_d_transfer trans
    f566:	f88d 2014 	strb.w	r2, [sp, #20]
	return _usb_d_dev_ep_trans(&trans);
    f56a:	4798      	blx	r3
	return rc;
    f56c:	e008      	b.n	f580 <usb_d_ep_transfer+0x88>
		atomic_leave_critical(&flags);
    f56e:	a802      	add	r0, sp, #8
    f570:	4798      	blx	r3
		switch (state) {
    f572:	f89d 3007 	ldrb.w	r3, [sp, #7]
    f576:	2b06      	cmp	r3, #6
    f578:	b2da      	uxtb	r2, r3
    f57a:	d823      	bhi.n	f5c4 <usb_d_ep_transfer+0xcc>
    f57c:	4b16      	ldr	r3, [pc, #88]	; (f5d8 <usb_d_ep_transfer+0xe0>)
    f57e:	5698      	ldrsb	r0, [r3, r2]
}
    f580:	b007      	add	sp, #28
    f582:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    f586:	7ce1      	ldrb	r1, [r4, #19]
    f588:	7ca2      	ldrb	r2, [r4, #18]
    f58a:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    f58e:	b292      	uxth	r2, r2
		if (req_len == 0) {
    f590:	b92a      	cbnz	r2, f59e <usb_d_ep_transfer+0xa6>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f592:	2304      	movs	r3, #4
    f594:	70a3      	strb	r3, [r4, #2]
			len                 = 0;
    f596:	4616      	mov	r6, r2
			zlp                 = true;
    f598:	464b      	mov	r3, r9
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    f59a:	461a      	mov	r2, r3
    f59c:	e7d8      	b.n	f550 <usb_d_ep_transfer+0x58>
			if (dir) {
    f59e:	f994 100c 	ldrsb.w	r1, [r4, #12]
    f5a2:	4296      	cmp	r6, r2
    f5a4:	bf28      	it	cs
    f5a6:	4616      	movcs	r6, r2
    f5a8:	2900      	cmp	r1, #0
    f5aa:	daf6      	bge.n	f59a <usb_d_ep_transfer+0xa2>
				zlp = (req_len > len);
    f5ac:	42b2      	cmp	r2, r6
    f5ae:	bf94      	ite	ls
    f5b0:	2300      	movls	r3, #0
    f5b2:	2301      	movhi	r3, #1
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    f5b4:	464a      	mov	r2, r9
    f5b6:	e7cb      	b.n	f550 <usb_d_ep_transfer+0x58>
	struct usb_d_transfer trans
    f5b8:	f001 020f 	and.w	r2, r1, #15
    f5bc:	e7cf      	b.n	f55e <usb_d_ep_transfer+0x66>
		return -USB_ERR_PARAM;
    f5be:	f06f 0011 	mvn.w	r0, #17
    f5c2:	e7dd      	b.n	f580 <usb_d_ep_transfer+0x88>
		switch (state) {
    f5c4:	2001      	movs	r0, #1
    f5c6:	e7db      	b.n	f580 <usb_d_ep_transfer+0x88>
    f5c8:	0000f1c5 	.word	0x0000f1c5
    f5cc:	00011a11 	.word	0x00011a11
    f5d0:	00011a1f 	.word	0x00011a1f
    f5d4:	0000d6e5 	.word	0x0000d6e5
    f5d8:	0001720a 	.word	0x0001720a
    f5dc:	200017b0 	.word	0x200017b0

0000f5e0 <usb_d_ep_get_status>:
	ept->xfer.hdr.state  = USB_EP_S_IDLE;
	ept->xfer.hdr.status = USB_XFER_ABORT;
}

int32_t usb_d_ep_get_status(const uint8_t ep, struct usb_d_ep_status *stat)
{
    f5e0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int8_t                    ep_index = _usb_d_find_ep(ep);
    f5e2:	4b12      	ldr	r3, [pc, #72]	; (f62c <usb_d_ep_get_status+0x4c>)
	struct usb_d_ep *         ept      = &usb_d_inst.ep[ep_index];
	struct usb_d_trans_status tmp;
	uint8_t                   state = ept->xfer.hdr.state;
    f5e4:	4d12      	ldr	r5, [pc, #72]	; (f630 <usb_d_ep_get_status+0x50>)
{
    f5e6:	b085      	sub	sp, #20
    f5e8:	4606      	mov	r6, r0
    f5ea:	460c      	mov	r4, r1
	int8_t                    ep_index = _usb_d_find_ep(ep);
    f5ec:	4798      	blx	r3
	uint8_t                   state = ept->xfer.hdr.state;
    f5ee:	eb05 1540 	add.w	r5, r5, r0, lsl #5
	if (ep_index < 0) {
    f5f2:	2800      	cmp	r0, #0
	uint8_t                   state = ept->xfer.hdr.state;
    f5f4:	78af      	ldrb	r7, [r5, #2]
	if (ep_index < 0) {
    f5f6:	db14      	blt.n	f622 <usb_d_ep_get_status+0x42>
		return -USB_ERR_PARAM;
	}
	if (stat) {
    f5f8:	b15c      	cbz	r4, f612 <usb_d_ep_get_status+0x32>
		/* Check transaction status if transferring data. */
		_usb_d_dev_ep_get_status(ep, &tmp);
    f5fa:	4b0e      	ldr	r3, [pc, #56]	; (f634 <usb_d_ep_get_status+0x54>)
    f5fc:	a901      	add	r1, sp, #4
    f5fe:	4630      	mov	r0, r6
    f600:	4798      	blx	r3
		stat->ep    = ep;
    f602:	7026      	strb	r6, [r4, #0]
		stat->state = state;
    f604:	70e7      	strb	r7, [r4, #3]
		stat->code  = ept->xfer.hdr.status;
    f606:	78eb      	ldrb	r3, [r5, #3]
    f608:	7063      	strb	r3, [r4, #1]
		stat->count = tmp.count;
    f60a:	9b02      	ldr	r3, [sp, #8]
    f60c:	6063      	str	r3, [r4, #4]
		stat->size  = tmp.size;
    f60e:	9b01      	ldr	r3, [sp, #4]
    f610:	60a3      	str	r3, [r4, #8]
	}
	switch (state) {
    f612:	2f06      	cmp	r7, #6
    f614:	d808      	bhi.n	f628 <usb_d_ep_get_status+0x48>
    f616:	4b08      	ldr	r3, [pc, #32]	; (f638 <usb_d_ep_get_status+0x58>)
    f618:	443b      	add	r3, r7
    f61a:	f993 0007 	ldrsb.w	r0, [r3, #7]
		return -USB_ERR_FUNC;
	default:
		/* Busy */
		return USB_BUSY;
	}
}
    f61e:	b005      	add	sp, #20
    f620:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -USB_ERR_PARAM;
    f622:	f06f 0011 	mvn.w	r0, #17
    f626:	e7fa      	b.n	f61e <usb_d_ep_get_status+0x3e>
    f628:	2001      	movs	r0, #1
    f62a:	e7f8      	b.n	f61e <usb_d_ep_get_status+0x3e>
    f62c:	0000f1c5 	.word	0x0000f1c5
    f630:	200017b0 	.word	0x200017b0
    f634:	0000d7ed 	.word	0x0000d7ed
    f638:	0001720a 	.word	0x0001720a

0000f63c <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    f63c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f640:	4605      	mov	r5, r0
	if (ctrl == USB_EP_HALT_CLR) {
    f642:	460c      	mov	r4, r1
    f644:	b9d9      	cbnz	r1, f67e <usb_d_ep_halt+0x42>
	int8_t           ep_index = _usb_d_find_ep(ep);
    f646:	4b13      	ldr	r3, [pc, #76]	; (f694 <usb_d_ep_halt+0x58>)
    f648:	4798      	blx	r3
	if (ep_index < 0) {
    f64a:	1e06      	subs	r6, r0, #0
    f64c:	db1e      	blt.n	f68c <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    f64e:	4f12      	ldr	r7, [pc, #72]	; (f698 <usb_d_ep_halt+0x5c>)
    f650:	2102      	movs	r1, #2
    f652:	4628      	mov	r0, r5
    f654:	47b8      	blx	r7
    f656:	b180      	cbz	r0, f67a <usb_d_ep_halt+0x3e>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f658:	4621      	mov	r1, r4
    f65a:	4628      	mov	r0, r5
    f65c:	47b8      	blx	r7
		if (rc < 0) {
    f65e:	2800      	cmp	r0, #0
    f660:	db0b      	blt.n	f67a <usb_d_ep_halt+0x3e>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    f662:	480e      	ldr	r0, [pc, #56]	; (f69c <usb_d_ep_halt+0x60>)
    f664:	eb00 1046 	add.w	r0, r0, r6, lsl #5
    f668:	f240 3301 	movw	r3, #769	; 0x301
    f66c:	8043      	strh	r3, [r0, #2]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    f66e:	4622      	mov	r2, r4
    f670:	69c3      	ldr	r3, [r0, #28]
    f672:	2103      	movs	r1, #3
    f674:	4628      	mov	r0, r5
    f676:	4798      	blx	r3
	return ERR_NONE;
    f678:	4620      	mov	r0, r4
	} else if (ctrl == USB_EP_HALT_SET) {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
	}
}
    f67a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ctrl == USB_EP_HALT_SET) {
    f67e:	2901      	cmp	r1, #1
}
    f680:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f684:	4b04      	ldr	r3, [pc, #16]	; (f698 <usb_d_ep_halt+0x5c>)
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    f686:	bf18      	it	ne
    f688:	2102      	movne	r1, #2
    f68a:	4718      	bx	r3
		return -USB_ERR_PARAM;
    f68c:	f06f 0011 	mvn.w	r0, #17
    f690:	e7f3      	b.n	f67a <usb_d_ep_halt+0x3e>
    f692:	bf00      	nop
    f694:	0000f1c5 	.word	0x0000f1c5
    f698:	0000d5c5 	.word	0x0000d5c5
    f69c:	200017b0 	.word	0x200017b0

0000f6a0 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    f6a0:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f6a2:	4b0f      	ldr	r3, [pc, #60]	; (f6e0 <usb_d_ep_register_callback+0x40>)
{
    f6a4:	4614      	mov	r4, r2
    f6a6:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    f6a8:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    f6aa:	4b0e      	ldr	r3, [pc, #56]	; (f6e4 <usb_d_ep_register_callback+0x44>)
    f6ac:	2c00      	cmp	r4, #0
    f6ae:	bf08      	it	eq
    f6b0:	461c      	moveq	r4, r3
	if (ep_index < 0) {
    f6b2:	2800      	cmp	r0, #0
    f6b4:	db08      	blt.n	f6c8 <usb_d_ep_register_callback+0x28>
		return;
	}
	switch (type) {
    f6b6:	2d01      	cmp	r5, #1
    f6b8:	d007      	beq.n	f6ca <usb_d_ep_register_callback+0x2a>
    f6ba:	2d02      	cmp	r5, #2
    f6bc:	d00a      	beq.n	f6d4 <usb_d_ep_register_callback+0x34>
    f6be:	b91d      	cbnz	r5, f6c8 <usb_d_ep_register_callback+0x28>
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    f6c0:	4b09      	ldr	r3, [pc, #36]	; (f6e8 <usb_d_ep_register_callback+0x48>)
    f6c2:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f6c6:	6144      	str	r4, [r0, #20]
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
    f6c8:	bd38      	pop	{r3, r4, r5, pc}
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    f6ca:	4b07      	ldr	r3, [pc, #28]	; (f6e8 <usb_d_ep_register_callback+0x48>)
    f6cc:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f6d0:	6184      	str	r4, [r0, #24]
		break;
    f6d2:	e7f9      	b.n	f6c8 <usb_d_ep_register_callback+0x28>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    f6d4:	4b04      	ldr	r3, [pc, #16]	; (f6e8 <usb_d_ep_register_callback+0x48>)
    f6d6:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    f6da:	61c4      	str	r4, [r0, #28]
		break;
    f6dc:	e7f4      	b.n	f6c8 <usb_d_ep_register_callback+0x28>
    f6de:	bf00      	nop
    f6e0:	0000f1c5 	.word	0x0000f1c5
    f6e4:	0000f1f5 	.word	0x0000f1f5
    f6e8:	200017b0 	.word	0x200017b0

0000f6ec <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    f6ec:	6800      	ldr	r0, [r0, #0]
    f6ee:	b900      	cbnz	r0, f6f2 <is_list_element+0x6>
    f6f0:	4770      	bx	lr
		if (it == element) {
    f6f2:	4288      	cmp	r0, r1
    f6f4:	d1fa      	bne.n	f6ec <is_list_element>
			return true;
    f6f6:	2001      	movs	r0, #1
		}
	}

	return false;
}
    f6f8:	4770      	bx	lr
	...

0000f6fc <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    f6fc:	b538      	push	{r3, r4, r5, lr}
	ASSERT(!is_list_element(list, element));
    f6fe:	4b07      	ldr	r3, [pc, #28]	; (f71c <list_insert_as_head+0x20>)
{
    f700:	460d      	mov	r5, r1
    f702:	4604      	mov	r4, r0
	ASSERT(!is_list_element(list, element));
    f704:	4798      	blx	r3
    f706:	f080 0001 	eor.w	r0, r0, #1
    f70a:	4b05      	ldr	r3, [pc, #20]	; (f720 <list_insert_as_head+0x24>)
    f70c:	4905      	ldr	r1, [pc, #20]	; (f724 <list_insert_as_head+0x28>)
    f70e:	2239      	movs	r2, #57	; 0x39
    f710:	b2c0      	uxtb	r0, r0
    f712:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    f714:	6823      	ldr	r3, [r4, #0]
    f716:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    f718:	6025      	str	r5, [r4, #0]
}
    f71a:	bd38      	pop	{r3, r4, r5, pc}
    f71c:	0000f6ed 	.word	0x0000f6ed
    f720:	0000df45 	.word	0x0000df45
    f724:	00017218 	.word	0x00017218

0000f728 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    f728:	6803      	ldr	r3, [r0, #0]
    f72a:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    f72c:	6001      	str	r1, [r0, #0]
}
    f72e:	4770      	bx	lr

0000f730 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    f730:	b570      	push	{r4, r5, r6, lr}
	struct list_element *it = list->head;

	ASSERT(!is_list_element(list, element));
    f732:	4b0c      	ldr	r3, [pc, #48]	; (f764 <list_insert_at_end+0x34>)
	struct list_element *it = list->head;
    f734:	6805      	ldr	r5, [r0, #0]
{
    f736:	4606      	mov	r6, r0
    f738:	460c      	mov	r4, r1
	ASSERT(!is_list_element(list, element));
    f73a:	4798      	blx	r3
    f73c:	f080 0001 	eor.w	r0, r0, #1
    f740:	4b09      	ldr	r3, [pc, #36]	; (f768 <list_insert_at_end+0x38>)
    f742:	490a      	ldr	r1, [pc, #40]	; (f76c <list_insert_at_end+0x3c>)
    f744:	224f      	movs	r2, #79	; 0x4f
    f746:	b2c0      	uxtb	r0, r0
    f748:	4798      	blx	r3

	if (!list->head) {
    f74a:	6833      	ldr	r3, [r6, #0]
    f74c:	b913      	cbnz	r3, f754 <list_insert_at_end+0x24>
		list->head                             = (struct list_element *)element;
    f74e:	6034      	str	r4, [r6, #0]
		((struct list_element *)element)->next = NULL;
    f750:	6023      	str	r3, [r4, #0]
	while (it->next) {
		it = it->next;
	}
	it->next                               = (struct list_element *)element;
	((struct list_element *)element)->next = NULL;
}
    f752:	bd70      	pop	{r4, r5, r6, pc}
	while (it->next) {
    f754:	462b      	mov	r3, r5
    f756:	682d      	ldr	r5, [r5, #0]
    f758:	2d00      	cmp	r5, #0
    f75a:	d1fb      	bne.n	f754 <list_insert_at_end+0x24>
	it->next                               = (struct list_element *)element;
    f75c:	601c      	str	r4, [r3, #0]
	((struct list_element *)element)->next = NULL;
    f75e:	6025      	str	r5, [r4, #0]
    f760:	e7f7      	b.n	f752 <list_insert_at_end+0x22>
    f762:	bf00      	nop
    f764:	0000f6ed 	.word	0x0000f6ed
    f768:	0000df45 	.word	0x0000df45
    f76c:	00017218 	.word	0x00017218

0000f770 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    f770:	6803      	ldr	r3, [r0, #0]
    f772:	b10b      	cbz	r3, f778 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    f774:	681a      	ldr	r2, [r3, #0]
    f776:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    f778:	4618      	mov	r0, r3
    f77a:	4770      	bx	lr

0000f77c <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    f77c:	4b03      	ldr	r3, [pc, #12]	; (f78c <_osc32kctrl_init_sources+0x10>)
    f77e:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    f780:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    f784:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    f786:	2201      	movs	r2, #1
    f788:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    f78a:	4770      	bx	lr
    f78c:	40001400 	.word	0x40001400

0000f790 <hri_rtcmode0_wait_for_sync>:
typedef uint8_t  hri_rtcalarm_mask_reg_t;
typedef uint8_t  hri_rtcmode2_mask_reg_t;

static inline void hri_rtcmode0_wait_for_sync(const void *const hw, hri_rtcmode0_syncbusy_reg_t reg)
{
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    f790:	6903      	ldr	r3, [r0, #16]
    f792:	420b      	tst	r3, r1
    f794:	d1fc      	bne.n	f790 <hri_rtcmode0_wait_for_sync>
	};
}
    f796:	4770      	bx	lr

0000f798 <_rtc_timer_set_period>:
/**
 * \brief Set timer period
 */
void _rtc_timer_set_period(struct _timer_device *const dev, const uint32_t clock_cycles)
{
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, clock_cycles);
    f798:	68c0      	ldr	r0, [r0, #12]

static inline void hri_rtcmode0_write_COMP_reg(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f79a:	4b02      	ldr	r3, [pc, #8]	; (f7a4 <_rtc_timer_set_period+0xc>)
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    f79c:	6201      	str	r1, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f79e:	2160      	movs	r1, #96	; 0x60
    f7a0:	4718      	bx	r3
    f7a2:	bf00      	nop
    f7a4:	0000f791 	.word	0x0000f791

0000f7a8 <_rtc_timer_get_period>:

/**
 * \brief Retrieve timer period
 */
uint32_t _rtc_timer_get_period(const struct _timer_device *const dev)
{
    f7a8:	b508      	push	{r3, lr}
	return hri_rtcmode0_read_COMP_reg(dev->hw, 0);
    f7aa:	68c0      	ldr	r0, [r0, #12]
	RTC_CRITICAL_SECTION_LEAVE();
}

static inline hri_rtcmode0_comp_reg_t hri_rtcmode0_read_COMP_reg(const void *const hw, uint8_t index)
{
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f7ac:	4b02      	ldr	r3, [pc, #8]	; (f7b8 <_rtc_timer_get_period+0x10>)
    f7ae:	2160      	movs	r1, #96	; 0x60
    f7b0:	4798      	blx	r3
	return ((Rtc *)hw)->MODE0.COMP[index].reg;
    f7b2:	6a00      	ldr	r0, [r0, #32]
}
    f7b4:	bd08      	pop	{r3, pc}
    f7b6:	bf00      	nop
    f7b8:	0000f791 	.word	0x0000f791

0000f7bc <_rtc_timer_is_started>:

/**
 * \brief Check if timer is running
 */
bool _rtc_timer_is_started(const struct _timer_device *const dev)
{
    f7bc:	b508      	push	{r3, lr}
	return hri_rtcmode0_get_CTRLA_ENABLE_bit(dev->hw);
    f7be:	68c0      	ldr	r0, [r0, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f7c0:	4b03      	ldr	r3, [pc, #12]	; (f7d0 <_rtc_timer_is_started+0x14>)
    f7c2:	f248 0103 	movw	r1, #32771	; 0x8003
    f7c6:	4798      	blx	r3
	tmp = ((Rtc *)hw)->MODE0.CTRLA.reg;
    f7c8:	8800      	ldrh	r0, [r0, #0]
}
    f7ca:	f3c0 0040 	ubfx	r0, r0, #1, #1
    f7ce:	bd08      	pop	{r3, pc}
    f7d0:	0000f791 	.word	0x0000f791

0000f7d4 <_rtc_timer_set_irq>:
 * \brief Set timer IRQ
 */
void _rtc_timer_set_irq(struct _timer_device *const dev)
{
	(void)dev;
}
    f7d4:	4770      	bx	lr
	...

0000f7d8 <_rtc_timer_stop>:
{
    f7d8:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f7da:	4604      	mov	r4, r0
    f7dc:	b118      	cbz	r0, f7e6 <_rtc_timer_stop+0xe>
    f7de:	68c0      	ldr	r0, [r0, #12]
    f7e0:	3800      	subs	r0, #0
    f7e2:	bf18      	it	ne
    f7e4:	2001      	movne	r0, #1
    f7e6:	4908      	ldr	r1, [pc, #32]	; (f808 <_rtc_timer_stop+0x30>)
    f7e8:	4b08      	ldr	r3, [pc, #32]	; (f80c <_rtc_timer_stop+0x34>)
    f7ea:	226b      	movs	r2, #107	; 0x6b
    f7ec:	4798      	blx	r3
	hri_rtcmode0_clear_CTRLA_ENABLE_bit(dev->hw);
    f7ee:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg &= ~RTC_MODE0_CTRLA_ENABLE;
    f7f0:	8803      	ldrh	r3, [r0, #0]
    f7f2:	f023 0302 	bic.w	r3, r3, #2
    f7f6:	041b      	lsls	r3, r3, #16
    f7f8:	0c1b      	lsrs	r3, r3, #16
    f7fa:	8003      	strh	r3, [r0, #0]
}
    f7fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f800:	4b03      	ldr	r3, [pc, #12]	; (f810 <_rtc_timer_stop+0x38>)
    f802:	f248 0103 	movw	r1, #32771	; 0x8003
    f806:	4718      	bx	r3
    f808:	00017236 	.word	0x00017236
    f80c:	0000df45 	.word	0x0000df45
    f810:	0000f791 	.word	0x0000f791

0000f814 <_rtc_timer_start>:
{
    f814:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f816:	4604      	mov	r4, r0
    f818:	b118      	cbz	r0, f822 <_rtc_timer_start+0xe>
    f81a:	68c0      	ldr	r0, [r0, #12]
    f81c:	3800      	subs	r0, #0
    f81e:	bf18      	it	ne
    f820:	2001      	movne	r0, #1
    f822:	490e      	ldr	r1, [pc, #56]	; (f85c <_rtc_timer_start+0x48>)
    f824:	4b0e      	ldr	r3, [pc, #56]	; (f860 <_rtc_timer_start+0x4c>)
    f826:	225e      	movs	r2, #94	; 0x5e
    f828:	4798      	blx	r3
    f82a:	4b0e      	ldr	r3, [pc, #56]	; (f864 <_rtc_timer_start+0x50>)
	hri_rtcmode0_write_COUNT_reg(dev->hw, 0);
    f82c:	68e0      	ldr	r0, [r4, #12]
    f82e:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f832:	601a      	str	r2, [r3, #0]
	((Rtc *)hw)->MODE0.COUNT.reg = data;
    f834:	2300      	movs	r3, #0
    f836:	6183      	str	r3, [r0, #24]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COUNT);
    f838:	4a0b      	ldr	r2, [pc, #44]	; (f868 <_rtc_timer_start+0x54>)
    f83a:	2108      	movs	r1, #8
    f83c:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_COUNT);
    f83e:	68e0      	ldr	r0, [r4, #12]
    f840:	2108      	movs	r1, #8
    f842:	4790      	blx	r2
	hri_rtcmode0_set_CTRLA_ENABLE_bit(dev->hw);
    f844:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
    f846:	8803      	ldrh	r3, [r0, #0]
    f848:	b29b      	uxth	r3, r3
    f84a:	f043 0302 	orr.w	r3, r3, #2
}
    f84e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f852:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f854:	f248 0103 	movw	r1, #32771	; 0x8003
    f858:	4710      	bx	r2
    f85a:	bf00      	nop
    f85c:	00017236 	.word	0x00017236
    f860:	0000df45 	.word	0x0000df45
    f864:	e000e100 	.word	0xe000e100
    f868:	0000f791 	.word	0x0000f791

0000f86c <_rtc_timer_deinit>:
{
    f86c:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    f86e:	4604      	mov	r4, r0
    f870:	b118      	cbz	r0, f87a <_rtc_timer_deinit+0xe>
    f872:	68c0      	ldr	r0, [r0, #12]
    f874:	3800      	subs	r0, #0
    f876:	bf18      	it	ne
    f878:	2001      	movne	r0, #1
    f87a:	490b      	ldr	r1, [pc, #44]	; (f8a8 <_rtc_timer_deinit+0x3c>)
    f87c:	4b0b      	ldr	r3, [pc, #44]	; (f8ac <_rtc_timer_deinit+0x40>)
    f87e:	2252      	movs	r2, #82	; 0x52
    f880:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    f882:	4b0b      	ldr	r3, [pc, #44]	; (f8b0 <_rtc_timer_deinit+0x44>)
    f884:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f888:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    f88c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    f890:	f3bf 8f6f 	isb	sy
	hri_rtcmode0_write_CTRLA_reg(dev->hw, RTC_MODE0_CTRLA_SWRST);
    f894:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f896:	2301      	movs	r3, #1
    f898:	8003      	strh	r3, [r0, #0]
}
    f89a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f89e:	4b05      	ldr	r3, [pc, #20]	; (f8b4 <_rtc_timer_deinit+0x48>)
    f8a0:	f248 0103 	movw	r1, #32771	; 0x8003
    f8a4:	4718      	bx	r3
    f8a6:	bf00      	nop
    f8a8:	00017236 	.word	0x00017236
    f8ac:	0000df45 	.word	0x0000df45
    f8b0:	e000e100 	.word	0xe000e100
    f8b4:	0000f791 	.word	0x0000f791

0000f8b8 <_rtc_timer_init>:
{
    f8b8:	b570      	push	{r4, r5, r6, lr}
	ASSERT(dev);
    f8ba:	4604      	mov	r4, r0
{
    f8bc:	460d      	mov	r5, r1
	ASSERT(dev);
    f8be:	3800      	subs	r0, #0
    f8c0:	bf18      	it	ne
    f8c2:	2001      	movne	r0, #1
    f8c4:	4b10      	ldr	r3, [pc, #64]	; (f908 <_rtc_timer_init+0x50>)
    f8c6:	4911      	ldr	r1, [pc, #68]	; (f90c <_rtc_timer_init+0x54>)
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f8c8:	2601      	movs	r6, #1
    f8ca:	2230      	movs	r2, #48	; 0x30
    f8cc:	4798      	blx	r3
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f8ce:	4a10      	ldr	r2, [pc, #64]	; (f910 <_rtc_timer_init+0x58>)
	dev->hw = hw;
    f8d0:	60e5      	str	r5, [r4, #12]
    f8d2:	4628      	mov	r0, r5
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f8d4:	802e      	strh	r6, [r5, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f8d6:	f248 0103 	movw	r1, #32771	; 0x8003
    f8da:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
    f8dc:	68e0      	ldr	r0, [r4, #12]
    f8de:	4631      	mov	r1, r6
    f8e0:	4790      	blx	r2
	    dev->hw, RTC_MODE0_CTRLA_PRESCALER(CONF_RTC_PRESCALER) | RTC_MODE0_CTRLA_COUNTSYNC | RTC_MODE0_CTRLA_MATCHCLR);
    f8e2:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    f8e4:	f248 0380 	movw	r3, #32896	; 0x8080
    f8e8:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    f8ea:	f248 0103 	movw	r1, #32771	; 0x8003
    f8ee:	4790      	blx	r2
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, CONF_RTC_COMP_VAL);
    f8f0:	68e0      	ldr	r0, [r4, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f8f2:	2160      	movs	r1, #96	; 0x60
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    f8f4:	6206      	str	r6, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    f8f6:	4790      	blx	r2
	hri_rtcmode0_set_INTEN_CMP0_bit(dev->hw);
    f8f8:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
    f8fa:	f44f 7280 	mov.w	r2, #256	; 0x100
    f8fe:	815a      	strh	r2, [r3, #10]
	_rtc_dev = dev;
    f900:	4b04      	ldr	r3, [pc, #16]	; (f914 <_rtc_timer_init+0x5c>)
}
    f902:	2000      	movs	r0, #0
	_rtc_dev = dev;
    f904:	601c      	str	r4, [r3, #0]
}
    f906:	bd70      	pop	{r4, r5, r6, pc}
    f908:	0000df45 	.word	0x0000df45
    f90c:	00017236 	.word	0x00017236
    f910:	0000f791 	.word	0x0000f791
    f914:	20001950 	.word	0x20001950

0000f918 <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return &_rtc_timer_functions;
}
    f918:	4800      	ldr	r0, [pc, #0]	; (f91c <_rtc_get_timer+0x4>)
    f91a:	4770      	bx	lr
    f91c:	2000050c 	.word	0x2000050c

0000f920 <RTC_Handler>:
/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
	_rtc_timer_interrupt_handler(_rtc_dev);
    f920:	4b07      	ldr	r3, [pc, #28]	; (f940 <RTC_Handler+0x20>)
{
    f922:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
    f924:	681c      	ldr	r4, [r3, #0]
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
    f926:	68e3      	ldr	r3, [r4, #12]
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    f928:	899b      	ldrh	r3, [r3, #12]
	if (flag & RTC_MODE0_INTFLAG_CMP0) {
    f92a:	05db      	lsls	r3, r3, #23
    f92c:	d507      	bpl.n	f93e <RTC_Handler+0x1e>
		if (dev->timer_cb.period_expired) {
    f92e:	6823      	ldr	r3, [r4, #0]
    f930:	b10b      	cbz	r3, f936 <RTC_Handler+0x16>
			dev->timer_cb.period_expired(dev);
    f932:	4620      	mov	r0, r4
    f934:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    f936:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    f938:	f44f 7280 	mov.w	r2, #256	; 0x100
    f93c:	819a      	strh	r2, [r3, #12]
}
    f93e:	bd10      	pop	{r4, pc}
    f940:	20001950 	.word	0x20001950

0000f944 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    f944:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    f946:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    f948:	b2c5      	uxtb	r5, r0
    f94a:	4b18      	ldr	r3, [pc, #96]	; (f9ac <_gpio_set_pin_function+0x68>)
    f94c:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    f950:	ea4f 1050 	mov.w	r0, r0, lsr #5
    f954:	ea4f 10c0 	mov.w	r0, r0, lsl #7
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    f958:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    f95a:	d107      	bne.n	f96c <_gpio_set_pin_function+0x28>
    f95c:	4423      	add	r3, r4
    f95e:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    f962:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    f966:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    f96a:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    f96c:	1918      	adds	r0, r3, r4
    f96e:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    f972:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    f976:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    f97a:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    f97e:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    f982:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    f986:	f015 0f01 	tst.w	r5, #1
    f98a:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    f98c:	bf19      	ittee	ne
    f98e:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    f992:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    f996:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    f99a:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    f99e:	bf14      	ite	ne
    f9a0:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    f9a2:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    f9a4:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    f9a8:	e7df      	b.n	f96a <_gpio_set_pin_function+0x26>
    f9aa:	bf00      	nop
    f9ac:	41008000 	.word	0x41008000

0000f9b0 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    f9b0:	f000 031f 	and.w	r3, r0, #31
{
    f9b4:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    f9b6:	2501      	movs	r5, #1
    f9b8:	409d      	lsls	r5, r3
	switch (direction) {
    f9ba:	0940      	lsrs	r0, r0, #5
    f9bc:	4b0f      	ldr	r3, [pc, #60]	; (f9fc <gpio_set_pin_direction+0x4c>)
    f9be:	01c0      	lsls	r0, r0, #7
    f9c0:	2901      	cmp	r1, #1
    f9c2:	b2ac      	uxth	r4, r5
    f9c4:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    f9c8:	4403      	add	r3, r0
    f9ca:	d008      	beq.n	f9de <gpio_set_pin_direction+0x2e>
    f9cc:	2902      	cmp	r1, #2
    f9ce:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    f9d2:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    f9d6:	d00e      	beq.n	f9f6 <gpio_set_pin_direction+0x46>
    f9d8:	605d      	str	r5, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    f9da:	629c      	str	r4, [r3, #40]	; 0x28
    f9dc:	e009      	b.n	f9f2 <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    f9de:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    f9e2:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
    f9e6:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    f9ea:	605d      	str	r5, [r3, #4]
    f9ec:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    f9f0:	629c      	str	r4, [r3, #40]	; 0x28
    f9f2:	629a      	str	r2, [r3, #40]	; 0x28
}
    f9f4:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    f9f6:	609d      	str	r5, [r3, #8]
    f9f8:	e7ef      	b.n	f9da <gpio_set_pin_direction+0x2a>
    f9fa:	bf00      	nop
    f9fc:	41008000 	.word	0x41008000

0000fa00 <gpio_set_pin_pull_mode>:
	switch (pull_mode) {
    fa00:	0942      	lsrs	r2, r0, #5
    fa02:	2901      	cmp	r1, #1
    fa04:	4b0d      	ldr	r3, [pc, #52]	; (fa3c <gpio_set_pin_pull_mode+0x3c>)
    fa06:	f000 001f 	and.w	r0, r0, #31
    fa0a:	ea4f 12c2 	mov.w	r2, r2, lsl #7
    fa0e:	d008      	beq.n	fa22 <gpio_set_pin_pull_mode+0x22>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    fa10:	4413      	add	r3, r2
    fa12:	4418      	add	r0, r3
    fa14:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    fa18:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    fa1c:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
}
    fa20:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fa22:	4413      	add	r3, r2
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    fa24:	4081      	lsls	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    fa26:	4418      	add	r0, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fa28:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    fa2a:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
    fa2e:	f042 0204 	orr.w	r2, r2, #4
    fa32:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    fa36:	6199      	str	r1, [r3, #24]
}
    fa38:	4770      	bx	lr
    fa3a:	bf00      	nop
    fa3c:	41008000 	.word	0x41008000

0000fa40 <ADC_0_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
    fa40:	4a14      	ldr	r2, [pc, #80]	; (fa94 <ADC_0_init+0x54>)
 */
void ADC_0_init(void)
{
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fa42:	4915      	ldr	r1, [pc, #84]	; (fa98 <ADC_0_init+0x58>)
    fa44:	6a13      	ldr	r3, [r2, #32]
{
    fa46:	b5f0      	push	{r4, r5, r6, r7, lr}
    fa48:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fa4c:	6213      	str	r3, [r2, #32]
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    fa4e:	4b13      	ldr	r3, [pc, #76]	; (fa9c <ADC_0_init+0x5c>)
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fa50:	4e13      	ldr	r6, [pc, #76]	; (faa0 <ADC_0_init+0x60>)
    fa52:	4d14      	ldr	r5, [pc, #80]	; (faa4 <ADC_0_init+0x64>)
    fa54:	4f14      	ldr	r7, [pc, #80]	; (faa8 <ADC_0_init+0x68>)
{
    fa56:	b085      	sub	sp, #20
    fa58:	2241      	movs	r2, #65	; 0x41
    fa5a:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    fa5e:	4b13      	ldr	r3, [pc, #76]	; (faac <ADC_0_init+0x6c>)
    fa60:	9301      	str	r3, [sp, #4]
    fa62:	2400      	movs	r4, #0
    fa64:	2301      	movs	r3, #1
    fa66:	9300      	str	r3, [sp, #0]
    fa68:	4632      	mov	r2, r6
    fa6a:	4623      	mov	r3, r4
    fa6c:	9402      	str	r4, [sp, #8]
    fa6e:	4628      	mov	r0, r5
    fa70:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_0, 0, ADC_0_buffer, ADC_0_BUFFER_SIZE);
    fa72:	1c72      	adds	r2, r6, #1
    fa74:	4621      	mov	r1, r4
    fa76:	2310      	movs	r3, #16
    fa78:	4628      	mov	r0, r5
    fa7a:	4d0d      	ldr	r5, [pc, #52]	; (fab0 <ADC_0_init+0x70>)
    fa7c:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PA07, GPIO_DIRECTION_OFF);
    fa7e:	4621      	mov	r1, r4
    fa80:	4b0c      	ldr	r3, [pc, #48]	; (fab4 <ADC_0_init+0x74>)
    fa82:	2007      	movs	r0, #7
    fa84:	4798      	blx	r3
	_gpio_set_pin_function(pin, function);
    fa86:	490c      	ldr	r1, [pc, #48]	; (fab8 <ADC_0_init+0x78>)
    fa88:	4b0c      	ldr	r3, [pc, #48]	; (fabc <ADC_0_init+0x7c>)
    fa8a:	2007      	movs	r0, #7

	gpio_set_pin_function(PA07, PINMUX_PA07B_ADC0_AIN7);
}
    fa8c:	b005      	add	sp, #20
    fa8e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fa92:	4718      	bx	r3
    fa94:	40000800 	.word	0x40000800
    fa98:	43001c00 	.word	0x43001c00
    fa9c:	40001c00 	.word	0x40001c00
    faa0:	20001954 	.word	0x20001954
    faa4:	200157a4 	.word	0x200157a4
    faa8:	0000e23d 	.word	0x0000e23d
    faac:	200158a0 	.word	0x200158a0
    fab0:	0000e2e1 	.word	0x0000e2e1
    fab4:	0000f9b1 	.word	0x0000f9b1
    fab8:	00070001 	.word	0x00070001
    fabc:	0000f945 	.word	0x0000f945

0000fac0 <ADC_1_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
    fac0:	4a15      	ldr	r2, [pc, #84]	; (fb18 <ADC_1_init+0x58>)
 */
void ADC_1_init(void)
{
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fac2:	4916      	ldr	r1, [pc, #88]	; (fb1c <ADC_1_init+0x5c>)
    fac4:	6a13      	ldr	r3, [r2, #32]
{
    fac6:	b5f0      	push	{r4, r5, r6, r7, lr}
    fac8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    facc:	6213      	str	r3, [r2, #32]
    face:	4b14      	ldr	r3, [pc, #80]	; (fb20 <ADC_1_init+0x60>)
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fad0:	4e14      	ldr	r6, [pc, #80]	; (fb24 <ADC_1_init+0x64>)
    fad2:	4d15      	ldr	r5, [pc, #84]	; (fb28 <ADC_1_init+0x68>)
    fad4:	4f15      	ldr	r7, [pc, #84]	; (fb2c <ADC_1_init+0x6c>)
{
    fad6:	b085      	sub	sp, #20
    fad8:	2241      	movs	r2, #65	; 0x41
    fada:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    fade:	4b14      	ldr	r3, [pc, #80]	; (fb30 <ADC_1_init+0x70>)
    fae0:	9301      	str	r3, [sp, #4]
    fae2:	2400      	movs	r4, #0
    fae4:	2301      	movs	r3, #1
    fae6:	9300      	str	r3, [sp, #0]
    fae8:	f106 0211 	add.w	r2, r6, #17
    faec:	4623      	mov	r3, r4
    faee:	9402      	str	r4, [sp, #8]
    faf0:	4628      	mov	r0, r5
    faf2:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_1, 0, ADC_1_buffer, ADC_1_BUFFER_SIZE);
    faf4:	f106 0212 	add.w	r2, r6, #18
    faf8:	4621      	mov	r1, r4
    fafa:	2310      	movs	r3, #16
    fafc:	4628      	mov	r0, r5
    fafe:	4d0d      	ldr	r5, [pc, #52]	; (fb34 <ADC_1_init+0x74>)
    fb00:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PC02, GPIO_DIRECTION_OFF);
    fb02:	4621      	mov	r1, r4
    fb04:	4b0c      	ldr	r3, [pc, #48]	; (fb38 <ADC_1_init+0x78>)
    fb06:	2042      	movs	r0, #66	; 0x42
    fb08:	4798      	blx	r3
    fb0a:	490c      	ldr	r1, [pc, #48]	; (fb3c <ADC_1_init+0x7c>)
    fb0c:	4b0c      	ldr	r3, [pc, #48]	; (fb40 <ADC_1_init+0x80>)
    fb0e:	2042      	movs	r0, #66	; 0x42

	gpio_set_pin_function(PC02, PINMUX_PC02B_ADC1_AIN4);
}
    fb10:	b005      	add	sp, #20
    fb12:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fb16:	4718      	bx	r3
    fb18:	40000800 	.word	0x40000800
    fb1c:	43002000 	.word	0x43002000
    fb20:	40001c00 	.word	0x40001c00
    fb24:	20001954 	.word	0x20001954
    fb28:	20015978 	.word	0x20015978
    fb2c:	0000e23d 	.word	0x0000e23d
    fb30:	20015738 	.word	0x20015738
    fb34:	0000e2e1 	.word	0x0000e2e1
    fb38:	0000f9b1 	.word	0x0000f9b1
    fb3c:	00420001 	.word	0x00420001
    fb40:	0000f945 	.word	0x0000f945

0000fb44 <CRC_0_init>:
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_DSU;
    fb44:	4a04      	ldr	r2, [pc, #16]	; (fb58 <CRC_0_init+0x14>)
 * Enables CRC peripheral, clocks and initializes CRC driver
 */
void CRC_0_init(void)
{
	hri_mclk_set_APBBMASK_DSU_bit(MCLK);
	crc_sync_init(&CRC_0, DSU);
    fb46:	4905      	ldr	r1, [pc, #20]	; (fb5c <CRC_0_init+0x18>)
    fb48:	6993      	ldr	r3, [r2, #24]
    fb4a:	4805      	ldr	r0, [pc, #20]	; (fb60 <CRC_0_init+0x1c>)
    fb4c:	f043 0302 	orr.w	r3, r3, #2
    fb50:	6193      	str	r3, [r2, #24]
    fb52:	4b04      	ldr	r3, [pc, #16]	; (fb64 <CRC_0_init+0x20>)
    fb54:	4718      	bx	r3
    fb56:	bf00      	nop
    fb58:	40000800 	.word	0x40000800
    fb5c:	41002000 	.word	0x41002000
    fb60:	20015734 	.word	0x20015734
    fb64:	0000f195 	.word	0x0000f195

0000fb68 <EVENT_SYSTEM_0_init>:
    fb68:	4b08      	ldr	r3, [pc, #32]	; (fb8c <EVENT_SYSTEM_0_init+0x24>)
    fb6a:	2240      	movs	r2, #64	; 0x40
    fb6c:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    fb70:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    fb74:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    fb78:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_EVSYS;
    fb7c:	4a04      	ldr	r2, [pc, #16]	; (fb90 <EVENT_SYSTEM_0_init+0x28>)
    fb7e:	6993      	ldr	r3, [r2, #24]
    fb80:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    fb84:	6193      	str	r3, [r2, #24]
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_2, CONF_GCLK_EVSYS_CHANNEL_2_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_3, CONF_GCLK_EVSYS_CHANNEL_3_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_EVSYS_bit(MCLK);

	event_system_init();
    fb86:	4b03      	ldr	r3, [pc, #12]	; (fb94 <EVENT_SYSTEM_0_init+0x2c>)
    fb88:	4718      	bx	r3
    fb8a:	bf00      	nop
    fb8c:	40001c00 	.word	0x40001c00
    fb90:	40000800 	.word	0x40000800
    fb94:	00012a35 	.word	0x00012a35

0000fb98 <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
    fb98:	4a02      	ldr	r2, [pc, #8]	; (fba4 <FLASH_0_CLOCK_init+0xc>)
    fb9a:	6913      	ldr	r3, [r2, #16]
    fb9c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    fba0:	6113      	str	r3, [r2, #16]

void FLASH_0_CLOCK_init(void)
{

	hri_mclk_set_AHBMASK_NVMCTRL_bit(MCLK);
}
    fba2:	4770      	bx	lr
    fba4:	40000800 	.word	0x40000800

0000fba8 <FLASH_0_init>:

void FLASH_0_init(void)
{
    fba8:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
    fbaa:	4b04      	ldr	r3, [pc, #16]	; (fbbc <FLASH_0_init+0x14>)
    fbac:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
}
    fbae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	flash_init(&FLASH_0, NVMCTRL);
    fbb2:	4903      	ldr	r1, [pc, #12]	; (fbc0 <FLASH_0_init+0x18>)
    fbb4:	4803      	ldr	r0, [pc, #12]	; (fbc4 <FLASH_0_init+0x1c>)
    fbb6:	4b04      	ldr	r3, [pc, #16]	; (fbc8 <FLASH_0_init+0x20>)
    fbb8:	4718      	bx	r3
    fbba:	bf00      	nop
    fbbc:	0000fb99 	.word	0x0000fb99
    fbc0:	41004000 	.word	0x41004000
    fbc4:	20015718 	.word	0x20015718
    fbc8:	0000ec3d 	.word	0x0000ec3d

0000fbcc <QSPI_INSTANCE_PORT_init>:

void QSPI_INSTANCE_PORT_init(void)
{
    fbcc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	// Set pin direction to input
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
    fbd0:	2101      	movs	r1, #1
    fbd2:	4e24      	ldr	r6, [pc, #144]	; (fc64 <QSPI_INSTANCE_PORT_init+0x98>)

	gpio_set_pin_pull_mode(PB11,
    fbd4:	4d24      	ldr	r5, [pc, #144]	; (fc68 <QSPI_INSTANCE_PORT_init+0x9c>)
    fbd6:	4c25      	ldr	r4, [pc, #148]	; (fc6c <QSPI_INSTANCE_PORT_init+0xa0>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    fbd8:	4f25      	ldr	r7, [pc, #148]	; (fc70 <QSPI_INSTANCE_PORT_init+0xa4>)
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
    fbda:	202b      	movs	r0, #43	; 0x2b
    fbdc:	47b0      	blx	r6
	gpio_set_pin_pull_mode(PB11,
    fbde:	2100      	movs	r1, #0
    fbe0:	202b      	movs	r0, #43	; 0x2b
    fbe2:	47a8      	blx	r5
    fbe4:	4923      	ldr	r1, [pc, #140]	; (fc74 <QSPI_INSTANCE_PORT_init+0xa8>)
    fbe6:	202b      	movs	r0, #43	; 0x2b
    fbe8:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB11, PINMUX_PB11H_QSPI_CS);

	gpio_set_pin_direction(PA08,
    fbea:	2102      	movs	r1, #2
    fbec:	2008      	movs	r0, #8
    fbee:	47b0      	blx	r6
    fbf0:	f44f 7380 	mov.w	r3, #256	; 0x100
    fbf4:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA08,
    fbf6:	2100      	movs	r1, #0
    fbf8:	2008      	movs	r0, #8
    fbfa:	47a8      	blx	r5
    fbfc:	491e      	ldr	r1, [pc, #120]	; (fc78 <QSPI_INSTANCE_PORT_init+0xac>)
    fbfe:	2008      	movs	r0, #8
    fc00:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA08H_QSPI_DATA0);

	gpio_set_pin_direction(PA09,
    fc02:	2102      	movs	r1, #2
    fc04:	2009      	movs	r0, #9
    fc06:	47b0      	blx	r6
    fc08:	f44f 7300 	mov.w	r3, #512	; 0x200
    fc0c:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA09,
    fc0e:	2100      	movs	r1, #0
    fc10:	2009      	movs	r0, #9
    fc12:	47a8      	blx	r5
    fc14:	4919      	ldr	r1, [pc, #100]	; (fc7c <QSPI_INSTANCE_PORT_init+0xb0>)
    fc16:	2009      	movs	r0, #9
    fc18:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA09H_QSPI_DATA1);

	gpio_set_pin_direction(PA10,
    fc1a:	2102      	movs	r1, #2
    fc1c:	200a      	movs	r0, #10
    fc1e:	47b0      	blx	r6
    fc20:	f44f 6380 	mov.w	r3, #1024	; 0x400
    fc24:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA10,
    fc26:	2100      	movs	r1, #0
    fc28:	200a      	movs	r0, #10
    fc2a:	47a8      	blx	r5
    fc2c:	4914      	ldr	r1, [pc, #80]	; (fc80 <QSPI_INSTANCE_PORT_init+0xb4>)
    fc2e:	200a      	movs	r0, #10
    fc30:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA10H_QSPI_DATA2);

	gpio_set_pin_direction(PA11,
    fc32:	2102      	movs	r1, #2
    fc34:	200b      	movs	r0, #11
    fc36:	47b0      	blx	r6
    fc38:	f44f 6300 	mov.w	r3, #2048	; 0x800
    fc3c:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA11,
    fc3e:	2100      	movs	r1, #0
    fc40:	200b      	movs	r0, #11
    fc42:	47a8      	blx	r5
    fc44:	490f      	ldr	r1, [pc, #60]	; (fc84 <QSPI_INSTANCE_PORT_init+0xb8>)
    fc46:	200b      	movs	r0, #11
    fc48:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA11H_QSPI_DATA3);

	// Set pin direction to input
	gpio_set_pin_direction(PB10, GPIO_DIRECTION_IN);
    fc4a:	2101      	movs	r1, #1
    fc4c:	202a      	movs	r0, #42	; 0x2a
    fc4e:	47b0      	blx	r6

	gpio_set_pin_pull_mode(PB10,
    fc50:	2100      	movs	r1, #0
    fc52:	202a      	movs	r0, #42	; 0x2a
    fc54:	47a8      	blx	r5
    fc56:	4623      	mov	r3, r4
    fc58:	490b      	ldr	r1, [pc, #44]	; (fc88 <QSPI_INSTANCE_PORT_init+0xbc>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB10, PINMUX_PB10H_QSPI_SCK);
}
    fc5a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    fc5e:	202a      	movs	r0, #42	; 0x2a
    fc60:	4718      	bx	r3
    fc62:	bf00      	nop
    fc64:	0000f9b1 	.word	0x0000f9b1
    fc68:	0000fa01 	.word	0x0000fa01
    fc6c:	0000f945 	.word	0x0000f945
    fc70:	41008000 	.word	0x41008000
    fc74:	002b0007 	.word	0x002b0007
    fc78:	00080007 	.word	0x00080007
    fc7c:	00090007 	.word	0x00090007
    fc80:	000a0007 	.word	0x000a0007
    fc84:	000b0007 	.word	0x000b0007
    fc88:	002a0007 	.word	0x002a0007

0000fc8c <QSPI_INSTANCE_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI;
    fc8c:	4b06      	ldr	r3, [pc, #24]	; (fca8 <QSPI_INSTANCE_CLOCK_init+0x1c>)
    fc8e:	691a      	ldr	r2, [r3, #16]
    fc90:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    fc94:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI_2X;
    fc96:	691a      	ldr	r2, [r3, #16]
    fc98:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
    fc9c:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_QSPI;
    fc9e:	69da      	ldr	r2, [r3, #28]
    fca0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    fca4:	61da      	str	r2, [r3, #28]
void QSPI_INSTANCE_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_QSPI_bit(MCLK);
	hri_mclk_set_AHBMASK_QSPI_2X_bit(MCLK);
	hri_mclk_set_APBCMASK_QSPI_bit(MCLK);
}
    fca6:	4770      	bx	lr
    fca8:	40000800 	.word	0x40000800

0000fcac <QSPI_INSTANCE_init>:

void QSPI_INSTANCE_init(void)
{
    fcac:	b510      	push	{r4, lr}
	QSPI_INSTANCE_CLOCK_init();
    fcae:	4b05      	ldr	r3, [pc, #20]	; (fcc4 <QSPI_INSTANCE_init+0x18>)
    fcb0:	4798      	blx	r3
	qspi_dma_init(&QSPI_INSTANCE, QSPI);
    fcb2:	4b05      	ldr	r3, [pc, #20]	; (fcc8 <QSPI_INSTANCE_init+0x1c>)
    fcb4:	4905      	ldr	r1, [pc, #20]	; (fccc <QSPI_INSTANCE_init+0x20>)
    fcb6:	4806      	ldr	r0, [pc, #24]	; (fcd0 <QSPI_INSTANCE_init+0x24>)
    fcb8:	4798      	blx	r3
	QSPI_INSTANCE_PORT_init();
}
    fcba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	QSPI_INSTANCE_PORT_init();
    fcbe:	4b05      	ldr	r3, [pc, #20]	; (fcd4 <QSPI_INSTANCE_init+0x28>)
    fcc0:	4718      	bx	r3
    fcc2:	bf00      	nop
    fcc4:	0000fc8d 	.word	0x0000fc8d
    fcc8:	000121e1 	.word	0x000121e1
    fccc:	42003400 	.word	0x42003400
    fcd0:	200159e4 	.word	0x200159e4
    fcd4:	0000fbcd 	.word	0x0000fbcd

0000fcd8 <USART_EAST_CLOCK_init>:
    fcd8:	4b06      	ldr	r3, [pc, #24]	; (fcf4 <USART_EAST_CLOCK_init+0x1c>)
    fcda:	2241      	movs	r2, #65	; 0x41
    fcdc:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    fce0:	2242      	movs	r2, #66	; 0x42
    fce2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
    fce6:	4a04      	ldr	r2, [pc, #16]	; (fcf8 <USART_EAST_CLOCK_init+0x20>)
    fce8:	6953      	ldr	r3, [r2, #20]
    fcea:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
    fcee:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}
    fcf0:	4770      	bx	lr
    fcf2:	bf00      	nop
    fcf4:	40001c00 	.word	0x40001c00
    fcf8:	40000800 	.word	0x40000800

0000fcfc <USART_EAST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_EAST_PORT_init()
{
    fcfc:	b510      	push	{r4, lr}
    fcfe:	4c05      	ldr	r4, [pc, #20]	; (fd14 <USART_EAST_PORT_init+0x18>)
    fd00:	4905      	ldr	r1, [pc, #20]	; (fd18 <USART_EAST_PORT_init+0x1c>)
    fd02:	2051      	movs	r0, #81	; 0x51
    fd04:	47a0      	blx	r4
    fd06:	4623      	mov	r3, r4
    fd08:	4904      	ldr	r1, [pc, #16]	; (fd1c <USART_EAST_PORT_init+0x20>)

	gpio_set_pin_function(PC17, PINMUX_PC17D_SERCOM0_PAD0);

	gpio_set_pin_function(PC16, PINMUX_PC16D_SERCOM0_PAD1);
}
    fd0a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fd0e:	2050      	movs	r0, #80	; 0x50
    fd10:	4718      	bx	r3
    fd12:	bf00      	nop
    fd14:	0000f945 	.word	0x0000f945
    fd18:	00510003 	.word	0x00510003
    fd1c:	00500003 	.word	0x00500003

0000fd20 <USART_EAST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_EAST_init(void)
{
    fd20:	b513      	push	{r0, r1, r4, lr}
	USART_EAST_CLOCK_init();
    fd22:	4b07      	ldr	r3, [pc, #28]	; (fd40 <USART_EAST_init+0x20>)
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
    fd24:	4c07      	ldr	r4, [pc, #28]	; (fd44 <USART_EAST_init+0x24>)
	USART_EAST_CLOCK_init();
    fd26:	4798      	blx	r3
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
    fd28:	2300      	movs	r3, #0
    fd2a:	9300      	str	r3, [sp, #0]
    fd2c:	4a06      	ldr	r2, [pc, #24]	; (fd48 <USART_EAST_init+0x28>)
    fd2e:	4907      	ldr	r1, [pc, #28]	; (fd4c <USART_EAST_init+0x2c>)
    fd30:	4807      	ldr	r0, [pc, #28]	; (fd50 <USART_EAST_init+0x30>)
    fd32:	2310      	movs	r3, #16
    fd34:	47a0      	blx	r4
	USART_EAST_PORT_init();
    fd36:	4b07      	ldr	r3, [pc, #28]	; (fd54 <USART_EAST_init+0x34>)
}
    fd38:	b002      	add	sp, #8
    fd3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_EAST_PORT_init();
    fd3e:	4718      	bx	r3
    fd40:	0000fcd9 	.word	0x0000fcd9
    fd44:	00010635 	.word	0x00010635
    fd48:	20001976 	.word	0x20001976
    fd4c:	40003000 	.word	0x40003000
    fd50:	200157d0 	.word	0x200157d0
    fd54:	0000fcfd 	.word	0x0000fcfd

0000fd58 <USART_NORTH_CLOCK_init>:
    fd58:	4b06      	ldr	r3, [pc, #24]	; (fd74 <USART_NORTH_CLOCK_init+0x1c>)
    fd5a:	2241      	movs	r2, #65	; 0x41
    fd5c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    fd60:	2242      	movs	r2, #66	; 0x42
    fd62:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
    fd66:	4a04      	ldr	r2, [pc, #16]	; (fd78 <USART_NORTH_CLOCK_init+0x20>)
    fd68:	6953      	ldr	r3, [r2, #20]
    fd6a:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    fd6e:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}
    fd70:	4770      	bx	lr
    fd72:	bf00      	nop
    fd74:	40001c00 	.word	0x40001c00
    fd78:	40000800 	.word	0x40000800

0000fd7c <USART_NORTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_NORTH_PORT_init()
{
    fd7c:	b510      	push	{r4, lr}
    fd7e:	4c05      	ldr	r4, [pc, #20]	; (fd94 <USART_NORTH_PORT_init+0x18>)
    fd80:	4905      	ldr	r1, [pc, #20]	; (fd98 <USART_NORTH_PORT_init+0x1c>)
    fd82:	205b      	movs	r0, #91	; 0x5b
    fd84:	47a0      	blx	r4
    fd86:	4623      	mov	r3, r4
    fd88:	4904      	ldr	r1, [pc, #16]	; (fd9c <USART_NORTH_PORT_init+0x20>)

	gpio_set_pin_function(PC27, PINMUX_PC27C_SERCOM1_PAD0);

	gpio_set_pin_function(PC28, PINMUX_PC28C_SERCOM1_PAD1);
}
    fd8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fd8e:	205c      	movs	r0, #92	; 0x5c
    fd90:	4718      	bx	r3
    fd92:	bf00      	nop
    fd94:	0000f945 	.word	0x0000f945
    fd98:	005b0002 	.word	0x005b0002
    fd9c:	005c0002 	.word	0x005c0002

0000fda0 <USART_NORTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_NORTH_init(void)
{
    fda0:	b513      	push	{r0, r1, r4, lr}
	USART_NORTH_CLOCK_init();
    fda2:	4b07      	ldr	r3, [pc, #28]	; (fdc0 <USART_NORTH_init+0x20>)
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
    fda4:	4c07      	ldr	r4, [pc, #28]	; (fdc4 <USART_NORTH_init+0x24>)
	USART_NORTH_CLOCK_init();
    fda6:	4798      	blx	r3
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
    fda8:	2300      	movs	r3, #0
    fdaa:	9300      	str	r3, [sp, #0]
    fdac:	4a06      	ldr	r2, [pc, #24]	; (fdc8 <USART_NORTH_init+0x28>)
    fdae:	4907      	ldr	r1, [pc, #28]	; (fdcc <USART_NORTH_init+0x2c>)
    fdb0:	4807      	ldr	r0, [pc, #28]	; (fdd0 <USART_NORTH_init+0x30>)
    fdb2:	2310      	movs	r3, #16
    fdb4:	47a0      	blx	r4
	USART_NORTH_PORT_init();
    fdb6:	4b07      	ldr	r3, [pc, #28]	; (fdd4 <USART_NORTH_init+0x34>)
}
    fdb8:	b002      	add	sp, #8
    fdba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_NORTH_PORT_init();
    fdbe:	4718      	bx	r3
    fdc0:	0000fd59 	.word	0x0000fd59
    fdc4:	00010635 	.word	0x00010635
    fdc8:	20001986 	.word	0x20001986
    fdcc:	40003400 	.word	0x40003400
    fdd0:	20015824 	.word	0x20015824
    fdd4:	0000fd7d 	.word	0x0000fd7d

0000fdd8 <GRID_AUX_PORT_init>:

void GRID_AUX_PORT_init(void)
{
    fdd8:	b510      	push	{r4, lr}
    fdda:	4c05      	ldr	r4, [pc, #20]	; (fdf0 <GRID_AUX_PORT_init+0x18>)
    fddc:	4905      	ldr	r1, [pc, #20]	; (fdf4 <GRID_AUX_PORT_init+0x1c>)
    fdde:	2039      	movs	r0, #57	; 0x39
    fde0:	47a0      	blx	r4
    fde2:	4623      	mov	r3, r4
    fde4:	4904      	ldr	r1, [pc, #16]	; (fdf8 <GRID_AUX_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
    fde6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fdea:	2038      	movs	r0, #56	; 0x38
    fdec:	4718      	bx	r3
    fdee:	bf00      	nop
    fdf0:	0000f945 	.word	0x0000f945
    fdf4:	00390003 	.word	0x00390003
    fdf8:	00380003 	.word	0x00380003

0000fdfc <GRID_AUX_CLOCK_init>:
    fdfc:	4b06      	ldr	r3, [pc, #24]	; (fe18 <GRID_AUX_CLOCK_init+0x1c>)
    fdfe:	2241      	movs	r2, #65	; 0x41
    fe00:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    fe04:	2242      	movs	r2, #66	; 0x42
    fe06:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
    fe0a:	4a04      	ldr	r2, [pc, #16]	; (fe1c <GRID_AUX_CLOCK_init+0x20>)
    fe0c:	6993      	ldr	r3, [r2, #24]
    fe0e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    fe12:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
    fe14:	4770      	bx	lr
    fe16:	bf00      	nop
    fe18:	40001c00 	.word	0x40001c00
    fe1c:	40000800 	.word	0x40000800

0000fe20 <GRID_AUX_init>:

void GRID_AUX_init(void)
{
    fe20:	b510      	push	{r4, lr}
	GRID_AUX_CLOCK_init();
    fe22:	4b05      	ldr	r3, [pc, #20]	; (fe38 <GRID_AUX_init+0x18>)
    fe24:	4798      	blx	r3
	usart_sync_init(&GRID_AUX, SERCOM2, (void *)NULL);
    fe26:	4b05      	ldr	r3, [pc, #20]	; (fe3c <GRID_AUX_init+0x1c>)
    fe28:	4905      	ldr	r1, [pc, #20]	; (fe40 <GRID_AUX_init+0x20>)
    fe2a:	4806      	ldr	r0, [pc, #24]	; (fe44 <GRID_AUX_init+0x24>)
    fe2c:	2200      	movs	r2, #0
    fe2e:	4798      	blx	r3
	GRID_AUX_PORT_init();
}
    fe30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_AUX_PORT_init();
    fe34:	4b04      	ldr	r3, [pc, #16]	; (fe48 <GRID_AUX_init+0x28>)
    fe36:	4718      	bx	r3
    fe38:	0000fdfd 	.word	0x0000fdfd
    fe3c:	0000eaf1 	.word	0x0000eaf1
    fe40:	41012000 	.word	0x41012000
    fe44:	20015790 	.word	0x20015790
    fe48:	0000fdd9 	.word	0x0000fdd9

0000fe4c <UI_SPI_PORT_init>:

void UI_SPI_PORT_init(void)
{
    fe4c:	b570      	push	{r4, r5, r6, lr}
    fe4e:	4e12      	ldr	r6, [pc, #72]	; (fe98 <UI_SPI_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB20, GPIO_DIRECTION_OUT);
    fe50:	4d12      	ldr	r5, [pc, #72]	; (fe9c <UI_SPI_PORT_init+0x50>)
    fe52:	4c13      	ldr	r4, [pc, #76]	; (fea0 <UI_SPI_PORT_init+0x54>)
    fe54:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    fe58:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
    fe5c:	2102      	movs	r1, #2
    fe5e:	2034      	movs	r0, #52	; 0x34
    fe60:	47a8      	blx	r5
    fe62:	4910      	ldr	r1, [pc, #64]	; (fea4 <UI_SPI_PORT_init+0x58>)
    fe64:	2034      	movs	r0, #52	; 0x34
    fe66:	47a0      	blx	r4
    fe68:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
    fe6c:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB21, GPIO_DIRECTION_OUT);
    fe70:	2102      	movs	r1, #2
    fe72:	2035      	movs	r0, #53	; 0x35
    fe74:	47a8      	blx	r5
    fe76:	490c      	ldr	r1, [pc, #48]	; (fea8 <UI_SPI_PORT_init+0x5c>)
    fe78:	2035      	movs	r0, #53	; 0x35
    fe7a:	47a0      	blx	r4

	gpio_set_pin_function(PB21, PINMUX_PB21C_SERCOM3_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA20, GPIO_DIRECTION_IN);
    fe7c:	2101      	movs	r1, #1
    fe7e:	2014      	movs	r0, #20
    fe80:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA20,
    fe82:	4b0a      	ldr	r3, [pc, #40]	; (feac <UI_SPI_PORT_init+0x60>)
    fe84:	2100      	movs	r1, #0
    fe86:	2014      	movs	r0, #20
    fe88:	4798      	blx	r3
    fe8a:	4623      	mov	r3, r4
    fe8c:	4908      	ldr	r1, [pc, #32]	; (feb0 <UI_SPI_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA20, PINMUX_PA20D_SERCOM3_PAD2);
}
    fe8e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    fe92:	2014      	movs	r0, #20
    fe94:	4718      	bx	r3
    fe96:	bf00      	nop
    fe98:	41008000 	.word	0x41008000
    fe9c:	0000f9b1 	.word	0x0000f9b1
    fea0:	0000f945 	.word	0x0000f945
    fea4:	00340002 	.word	0x00340002
    fea8:	00350002 	.word	0x00350002
    feac:	0000fa01 	.word	0x0000fa01
    feb0:	00140003 	.word	0x00140003

0000feb4 <UI_SPI_CLOCK_init>:
    feb4:	4b06      	ldr	r3, [pc, #24]	; (fed0 <UI_SPI_CLOCK_init+0x1c>)
    feb6:	2241      	movs	r2, #65	; 0x41
    feb8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    febc:	2243      	movs	r2, #67	; 0x43
    febe:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
    fec2:	4a04      	ldr	r2, [pc, #16]	; (fed4 <UI_SPI_CLOCK_init+0x20>)
    fec4:	6993      	ldr	r3, [r2, #24]
    fec6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
    feca:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}
    fecc:	4770      	bx	lr
    fece:	bf00      	nop
    fed0:	40001c00 	.word	0x40001c00
    fed4:	40000800 	.word	0x40000800

0000fed8 <UI_SPI_init>:

void UI_SPI_init(void)
{
    fed8:	b510      	push	{r4, lr}
	UI_SPI_CLOCK_init();
    feda:	4b05      	ldr	r3, [pc, #20]	; (fef0 <UI_SPI_init+0x18>)
    fedc:	4798      	blx	r3
	spi_m_async_init(&UI_SPI, SERCOM3);
    fede:	4b05      	ldr	r3, [pc, #20]	; (fef4 <UI_SPI_init+0x1c>)
    fee0:	4905      	ldr	r1, [pc, #20]	; (fef8 <UI_SPI_init+0x20>)
    fee2:	4806      	ldr	r0, [pc, #24]	; (fefc <UI_SPI_init+0x24>)
    fee4:	4798      	blx	r3
	UI_SPI_PORT_init();
}
    fee6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UI_SPI_PORT_init();
    feea:	4b05      	ldr	r3, [pc, #20]	; (ff00 <UI_SPI_init+0x28>)
    feec:	4718      	bx	r3
    feee:	bf00      	nop
    fef0:	0000feb5 	.word	0x0000feb5
    fef4:	0000efa5 	.word	0x0000efa5
    fef8:	41014000 	.word	0x41014000
    fefc:	20015690 	.word	0x20015690
    ff00:	0000fe4d 	.word	0x0000fe4d

0000ff04 <USART_WEST_CLOCK_init>:
    ff04:	4b06      	ldr	r3, [pc, #24]	; (ff20 <USART_WEST_CLOCK_init+0x1c>)
    ff06:	2241      	movs	r2, #65	; 0x41
    ff08:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    ff0c:	2242      	movs	r2, #66	; 0x42
    ff0e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM4;
    ff12:	4a04      	ldr	r2, [pc, #16]	; (ff24 <USART_WEST_CLOCK_init+0x20>)
    ff14:	6a13      	ldr	r3, [r2, #32]
    ff16:	f043 0301 	orr.w	r3, r3, #1
    ff1a:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM4_bit(MCLK);
}
    ff1c:	4770      	bx	lr
    ff1e:	bf00      	nop
    ff20:	40001c00 	.word	0x40001c00
    ff24:	40000800 	.word	0x40000800

0000ff28 <USART_WEST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_WEST_PORT_init()
{
    ff28:	b510      	push	{r4, lr}
    ff2a:	4c05      	ldr	r4, [pc, #20]	; (ff40 <USART_WEST_PORT_init+0x18>)
    ff2c:	4905      	ldr	r1, [pc, #20]	; (ff44 <USART_WEST_PORT_init+0x1c>)
    ff2e:	2028      	movs	r0, #40	; 0x28
    ff30:	47a0      	blx	r4
    ff32:	4623      	mov	r3, r4
    ff34:	4904      	ldr	r1, [pc, #16]	; (ff48 <USART_WEST_PORT_init+0x20>)

	gpio_set_pin_function(PB08, PINMUX_PB08D_SERCOM4_PAD0);

	gpio_set_pin_function(PB09, PINMUX_PB09D_SERCOM4_PAD1);
}
    ff36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ff3a:	2029      	movs	r0, #41	; 0x29
    ff3c:	4718      	bx	r3
    ff3e:	bf00      	nop
    ff40:	0000f945 	.word	0x0000f945
    ff44:	00280003 	.word	0x00280003
    ff48:	00290003 	.word	0x00290003

0000ff4c <USART_WEST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_WEST_init(void)
{
    ff4c:	b513      	push	{r0, r1, r4, lr}
	USART_WEST_CLOCK_init();
    ff4e:	4b08      	ldr	r3, [pc, #32]	; (ff70 <USART_WEST_init+0x24>)
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
    ff50:	4c08      	ldr	r4, [pc, #32]	; (ff74 <USART_WEST_init+0x28>)
	USART_WEST_CLOCK_init();
    ff52:	4798      	blx	r3
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
    ff54:	2300      	movs	r3, #0
    ff56:	9300      	str	r3, [sp, #0]
    ff58:	4a07      	ldr	r2, [pc, #28]	; (ff78 <USART_WEST_init+0x2c>)
    ff5a:	4808      	ldr	r0, [pc, #32]	; (ff7c <USART_WEST_init+0x30>)
    ff5c:	2310      	movs	r3, #16
    ff5e:	f04f 4186 	mov.w	r1, #1124073472	; 0x43000000
    ff62:	47a0      	blx	r4
	USART_WEST_PORT_init();
    ff64:	4b06      	ldr	r3, [pc, #24]	; (ff80 <USART_WEST_init+0x34>)
}
    ff66:	b002      	add	sp, #8
    ff68:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_WEST_PORT_init();
    ff6c:	4718      	bx	r3
    ff6e:	bf00      	nop
    ff70:	0000ff05 	.word	0x0000ff05
    ff74:	00010635 	.word	0x00010635
    ff78:	20001996 	.word	0x20001996
    ff7c:	200158d8 	.word	0x200158d8
    ff80:	0000ff29 	.word	0x0000ff29

0000ff84 <SYS_I2C_PORT_init>:

void SYS_I2C_PORT_init(void)
{
    ff84:	b570      	push	{r4, r5, r6, lr}

	gpio_set_pin_pull_mode(PA23,
    ff86:	2100      	movs	r1, #0
    ff88:	4d07      	ldr	r5, [pc, #28]	; (ffa8 <SYS_I2C_PORT_init+0x24>)
    ff8a:	4c08      	ldr	r4, [pc, #32]	; (ffac <SYS_I2C_PORT_init+0x28>)
    ff8c:	2017      	movs	r0, #23
    ff8e:	47a8      	blx	r5
    ff90:	4907      	ldr	r1, [pc, #28]	; (ffb0 <SYS_I2C_PORT_init+0x2c>)
    ff92:	2017      	movs	r0, #23
    ff94:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA23, PINMUX_PA23D_SERCOM5_PAD0);

	gpio_set_pin_pull_mode(PA22,
    ff96:	2100      	movs	r1, #0
    ff98:	2016      	movs	r0, #22
    ff9a:	47a8      	blx	r5
    ff9c:	4623      	mov	r3, r4
    ff9e:	4905      	ldr	r1, [pc, #20]	; (ffb4 <SYS_I2C_PORT_init+0x30>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA22, PINMUX_PA22D_SERCOM5_PAD1);
}
    ffa0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ffa4:	2016      	movs	r0, #22
    ffa6:	4718      	bx	r3
    ffa8:	0000fa01 	.word	0x0000fa01
    ffac:	0000f945 	.word	0x0000f945
    ffb0:	00170003 	.word	0x00170003
    ffb4:	00160003 	.word	0x00160003

0000ffb8 <SYS_I2C_CLOCK_init>:
    ffb8:	4b06      	ldr	r3, [pc, #24]	; (ffd4 <SYS_I2C_CLOCK_init+0x1c>)
    ffba:	2241      	movs	r2, #65	; 0x41
    ffbc:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    ffc0:	2242      	movs	r2, #66	; 0x42
    ffc2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM5;
    ffc6:	4a04      	ldr	r2, [pc, #16]	; (ffd8 <SYS_I2C_CLOCK_init+0x20>)
    ffc8:	6a13      	ldr	r3, [r2, #32]
    ffca:	f043 0302 	orr.w	r3, r3, #2
    ffce:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_SLOW, CONF_GCLK_SERCOM5_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM5_bit(MCLK);
}
    ffd0:	4770      	bx	lr
    ffd2:	bf00      	nop
    ffd4:	40001c00 	.word	0x40001c00
    ffd8:	40000800 	.word	0x40000800

0000ffdc <SYS_I2C_init>:

void SYS_I2C_init(void)
{
    ffdc:	b510      	push	{r4, lr}
	SYS_I2C_CLOCK_init();
    ffde:	4b05      	ldr	r3, [pc, #20]	; (fff4 <SYS_I2C_init+0x18>)
    ffe0:	4798      	blx	r3
	i2c_m_async_init(&SYS_I2C, SERCOM5);
    ffe2:	4b05      	ldr	r3, [pc, #20]	; (fff8 <SYS_I2C_init+0x1c>)
    ffe4:	4905      	ldr	r1, [pc, #20]	; (fffc <SYS_I2C_init+0x20>)
    ffe6:	4806      	ldr	r0, [pc, #24]	; (10000 <STACK_SIZE>)
    ffe8:	4798      	blx	r3
	SYS_I2C_PORT_init();
}
    ffea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SYS_I2C_PORT_init();
    ffee:	4b05      	ldr	r3, [pc, #20]	; (10004 <STACK_SIZE+0x4>)
    fff0:	4718      	bx	r3
    fff2:	bf00      	nop
    fff4:	0000ffb9 	.word	0x0000ffb9
    fff8:	0000b629 	.word	0x0000b629
    fffc:	43000400 	.word	0x43000400
   10000:	20015750 	.word	0x20015750
   10004:	0000ff85 	.word	0x0000ff85

00010008 <USART_SOUTH_CLOCK_init>:
   10008:	4b06      	ldr	r3, [pc, #24]	; (10024 <USART_SOUTH_CLOCK_init+0x1c>)
   1000a:	2241      	movs	r2, #65	; 0x41
   1000c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   10010:	2242      	movs	r2, #66	; 0x42
   10012:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM6;
   10016:	4a04      	ldr	r2, [pc, #16]	; (10028 <USART_SOUTH_CLOCK_init+0x20>)
   10018:	6a13      	ldr	r3, [r2, #32]
   1001a:	f043 0304 	orr.w	r3, r3, #4
   1001e:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_CORE, CONF_GCLK_SERCOM6_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_SLOW, CONF_GCLK_SERCOM6_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM6_bit(MCLK);
}
   10020:	4770      	bx	lr
   10022:	bf00      	nop
   10024:	40001c00 	.word	0x40001c00
   10028:	40000800 	.word	0x40000800

0001002c <USART_SOUTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_SOUTH_PORT_init()
{
   1002c:	b510      	push	{r4, lr}
   1002e:	4c05      	ldr	r4, [pc, #20]	; (10044 <USART_SOUTH_PORT_init+0x18>)
   10030:	4905      	ldr	r1, [pc, #20]	; (10048 <USART_SOUTH_PORT_init+0x1c>)
   10032:	204d      	movs	r0, #77	; 0x4d
   10034:	47a0      	blx	r4
   10036:	4623      	mov	r3, r4
   10038:	4904      	ldr	r1, [pc, #16]	; (1004c <USART_SOUTH_PORT_init+0x20>)

	gpio_set_pin_function(PC13, PINMUX_PC13D_SERCOM6_PAD0);

	gpio_set_pin_function(PC12, PINMUX_PC12D_SERCOM6_PAD1);
}
   1003a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1003e:	204c      	movs	r0, #76	; 0x4c
   10040:	4718      	bx	r3
   10042:	bf00      	nop
   10044:	0000f945 	.word	0x0000f945
   10048:	004d0003 	.word	0x004d0003
   1004c:	004c0003 	.word	0x004c0003

00010050 <USART_SOUTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_SOUTH_init(void)
{
   10050:	b513      	push	{r0, r1, r4, lr}
	USART_SOUTH_CLOCK_init();
   10052:	4b07      	ldr	r3, [pc, #28]	; (10070 <USART_SOUTH_init+0x20>)
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   10054:	4c07      	ldr	r4, [pc, #28]	; (10074 <USART_SOUTH_init+0x24>)
	USART_SOUTH_CLOCK_init();
   10056:	4798      	blx	r3
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   10058:	2300      	movs	r3, #0
   1005a:	9300      	str	r3, [sp, #0]
   1005c:	4a06      	ldr	r2, [pc, #24]	; (10078 <USART_SOUTH_init+0x28>)
   1005e:	4907      	ldr	r1, [pc, #28]	; (1007c <USART_SOUTH_init+0x2c>)
   10060:	4807      	ldr	r0, [pc, #28]	; (10080 <USART_SOUTH_init+0x30>)
   10062:	2310      	movs	r3, #16
   10064:	47a0      	blx	r4
	USART_SOUTH_PORT_init();
   10066:	4b07      	ldr	r3, [pc, #28]	; (10084 <USART_SOUTH_init+0x34>)
}
   10068:	b002      	add	sp, #8
   1006a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_SOUTH_PORT_init();
   1006e:	4718      	bx	r3
   10070:	00010009 	.word	0x00010009
   10074:	00010635 	.word	0x00010635
   10078:	200019a6 	.word	0x200019a6
   1007c:	43000800 	.word	0x43000800
   10080:	20015928 	.word	0x20015928
   10084:	0001002d 	.word	0x0001002d

00010088 <GRID_LED_PORT_init>:

void GRID_LED_PORT_init(void)
{
   10088:	b570      	push	{r4, r5, r6, lr}
   1008a:	4e12      	ldr	r6, [pc, #72]	; (100d4 <GRID_LED_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB30, GPIO_DIRECTION_OUT);
   1008c:	4d12      	ldr	r5, [pc, #72]	; (100d8 <GRID_LED_PORT_init+0x50>)
   1008e:	4c13      	ldr	r4, [pc, #76]	; (100dc <GRID_LED_PORT_init+0x54>)
   10090:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   10094:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   10098:	2102      	movs	r1, #2
   1009a:	203e      	movs	r0, #62	; 0x3e
   1009c:	47a8      	blx	r5
   1009e:	4910      	ldr	r1, [pc, #64]	; (100e0 <GRID_LED_PORT_init+0x58>)
   100a0:	203e      	movs	r0, #62	; 0x3e
   100a2:	47a0      	blx	r4
   100a4:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   100a8:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB31, GPIO_DIRECTION_OUT);
   100ac:	2102      	movs	r1, #2
   100ae:	203f      	movs	r0, #63	; 0x3f
   100b0:	47a8      	blx	r5
   100b2:	490c      	ldr	r1, [pc, #48]	; (100e4 <GRID_LED_PORT_init+0x5c>)
   100b4:	203f      	movs	r0, #63	; 0x3f
   100b6:	47a0      	blx	r4

	gpio_set_pin_function(PB31, PINMUX_PB31C_SERCOM7_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA30, GPIO_DIRECTION_IN);
   100b8:	2101      	movs	r1, #1
   100ba:	201e      	movs	r0, #30
   100bc:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA30,
   100be:	4b0a      	ldr	r3, [pc, #40]	; (100e8 <GRID_LED_PORT_init+0x60>)
   100c0:	2100      	movs	r1, #0
   100c2:	201e      	movs	r0, #30
   100c4:	4798      	blx	r3
   100c6:	4623      	mov	r3, r4
   100c8:	4908      	ldr	r1, [pc, #32]	; (100ec <GRID_LED_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA30, PINMUX_PA30C_SERCOM7_PAD2);
}
   100ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   100ce:	201e      	movs	r0, #30
   100d0:	4718      	bx	r3
   100d2:	bf00      	nop
   100d4:	41008000 	.word	0x41008000
   100d8:	0000f9b1 	.word	0x0000f9b1
   100dc:	0000f945 	.word	0x0000f945
   100e0:	003e0002 	.word	0x003e0002
   100e4:	003f0002 	.word	0x003f0002
   100e8:	0000fa01 	.word	0x0000fa01
   100ec:	001e0002 	.word	0x001e0002

000100f0 <GRID_LED_CLOCK_init>:
   100f0:	4b06      	ldr	r3, [pc, #24]	; (1010c <GRID_LED_CLOCK_init+0x1c>)
   100f2:	2241      	movs	r2, #65	; 0x41
   100f4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   100f8:	2242      	movs	r2, #66	; 0x42
   100fa:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
   100fe:	4a04      	ldr	r2, [pc, #16]	; (10110 <GRID_LED_CLOCK_init+0x20>)
   10100:	6a13      	ldr	r3, [r2, #32]
   10102:	f043 0308 	orr.w	r3, r3, #8
   10106:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}
   10108:	4770      	bx	lr
   1010a:	bf00      	nop
   1010c:	40001c00 	.word	0x40001c00
   10110:	40000800 	.word	0x40000800

00010114 <GRID_LED_init>:

void GRID_LED_init(void)
{
   10114:	b510      	push	{r4, lr}
	GRID_LED_CLOCK_init();
   10116:	4b05      	ldr	r3, [pc, #20]	; (1012c <GRID_LED_init+0x18>)
   10118:	4798      	blx	r3
	spi_m_dma_init(&GRID_LED, SERCOM7);
   1011a:	4b05      	ldr	r3, [pc, #20]	; (10130 <GRID_LED_init+0x1c>)
   1011c:	4905      	ldr	r1, [pc, #20]	; (10134 <GRID_LED_init+0x20>)
   1011e:	4806      	ldr	r0, [pc, #24]	; (10138 <GRID_LED_init+0x24>)
   10120:	4798      	blx	r3
	GRID_LED_PORT_init();
}
   10122:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_LED_PORT_init();
   10126:	4b05      	ldr	r3, [pc, #20]	; (1013c <GRID_LED_init+0x28>)
   10128:	4718      	bx	r3
   1012a:	bf00      	nop
   1012c:	000100f1 	.word	0x000100f1
   10130:	0000b869 	.word	0x0000b869
   10134:	43000c00 	.word	0x43000c00
   10138:	20015874 	.word	0x20015874
   1013c:	00010089 	.word	0x00010089

00010140 <delay_driver_init>:

void delay_driver_init(void)
{
	delay_init(SysTick);
   10140:	4801      	ldr	r0, [pc, #4]	; (10148 <delay_driver_init+0x8>)
   10142:	4b02      	ldr	r3, [pc, #8]	; (1014c <delay_driver_init+0xc>)
   10144:	4718      	bx	r3
   10146:	bf00      	nop
   10148:	e000e010 	.word	0xe000e010
   1014c:	0000dc85 	.word	0x0000dc85

00010150 <RAND_0_CLOCK_init>:
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TRNG;
   10150:	4a02      	ldr	r2, [pc, #8]	; (1015c <RAND_0_CLOCK_init+0xc>)
   10152:	69d3      	ldr	r3, [r2, #28]
   10154:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   10158:	61d3      	str	r3, [r2, #28]
}

void RAND_0_CLOCK_init(void)
{
	hri_mclk_set_APBCMASK_TRNG_bit(MCLK);
}
   1015a:	4770      	bx	lr
   1015c:	40000800 	.word	0x40000800

00010160 <RAND_0_init>:

void RAND_0_init(void)
{
   10160:	b510      	push	{r4, lr}
	RAND_0_CLOCK_init();
   10162:	4b04      	ldr	r3, [pc, #16]	; (10174 <RAND_0_init+0x14>)
   10164:	4798      	blx	r3
	rand_sync_init(&RAND_0, TRNG);
}
   10166:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rand_sync_init(&RAND_0, TRNG);
   1016a:	4903      	ldr	r1, [pc, #12]	; (10178 <RAND_0_init+0x18>)
   1016c:	4803      	ldr	r0, [pc, #12]	; (1017c <RAND_0_init+0x1c>)
   1016e:	4b04      	ldr	r3, [pc, #16]	; (10180 <RAND_0_init+0x20>)
   10170:	4718      	bx	r3
   10172:	bf00      	nop
   10174:	00010151 	.word	0x00010151
   10178:	42002800 	.word	0x42002800
   1017c:	2001579c 	.word	0x2001579c
   10180:	0000e669 	.word	0x0000e669

00010184 <USB_DEVICE_INSTANCE_PORT_init>:

void USB_DEVICE_INSTANCE_PORT_init(void)
{
   10184:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	gpio_set_pin_direction(PA24,
   10188:	2102      	movs	r1, #2
   1018a:	4f0f      	ldr	r7, [pc, #60]	; (101c8 <USB_DEVICE_INSTANCE_PORT_init+0x44>)
   1018c:	4e0f      	ldr	r6, [pc, #60]	; (101cc <USB_DEVICE_INSTANCE_PORT_init+0x48>)
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA24,
   1018e:	4d10      	ldr	r5, [pc, #64]	; (101d0 <USB_DEVICE_INSTANCE_PORT_init+0x4c>)
   10190:	4c10      	ldr	r4, [pc, #64]	; (101d4 <USB_DEVICE_INSTANCE_PORT_init+0x50>)
	gpio_set_pin_direction(PA24,
   10192:	2018      	movs	r0, #24
   10194:	47b8      	blx	r7
   10196:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   1019a:	6173      	str	r3, [r6, #20]
	gpio_set_pin_pull_mode(PA24,
   1019c:	2100      	movs	r1, #0
   1019e:	2018      	movs	r0, #24
   101a0:	47a8      	blx	r5
   101a2:	490d      	ldr	r1, [pc, #52]	; (101d8 <USB_DEVICE_INSTANCE_PORT_init+0x54>)
   101a4:	2018      	movs	r0, #24
   101a6:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA24H_USB_DM);

	gpio_set_pin_direction(PA25,
   101a8:	2102      	movs	r1, #2
   101aa:	2019      	movs	r0, #25
   101ac:	47b8      	blx	r7
   101ae:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   101b2:	6173      	str	r3, [r6, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA25,
   101b4:	2100      	movs	r1, #0
   101b6:	2019      	movs	r0, #25
   101b8:	47a8      	blx	r5
   101ba:	4623      	mov	r3, r4
   101bc:	4907      	ldr	r1, [pc, #28]	; (101dc <USB_DEVICE_INSTANCE_PORT_init+0x58>)
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA25H_USB_DP);
}
   101be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   101c2:	2019      	movs	r0, #25
   101c4:	4718      	bx	r3
   101c6:	bf00      	nop
   101c8:	0000f9b1 	.word	0x0000f9b1
   101cc:	41008000 	.word	0x41008000
   101d0:	0000fa01 	.word	0x0000fa01
   101d4:	0000f945 	.word	0x0000f945
   101d8:	00180007 	.word	0x00180007
   101dc:	00190007 	.word	0x00190007

000101e0 <USB_DEVICE_INSTANCE_CLOCK_init>:
   101e0:	4b07      	ldr	r3, [pc, #28]	; (10200 <USB_DEVICE_INSTANCE_CLOCK_init+0x20>)
   101e2:	2241      	movs	r2, #65	; 0x41
   101e4:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
   101e8:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
   101ec:	691a      	ldr	r2, [r3, #16]
   101ee:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   101f2:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
   101f4:	699a      	ldr	r2, [r3, #24]
   101f6:	f042 0201 	orr.w	r2, r2, #1
   101fa:	619a      	str	r2, [r3, #24]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, USB_GCLK_ID, CONF_GCLK_USB_SRC | GCLK_PCHCTRL_CHEN);
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}
   101fc:	4770      	bx	lr
   101fe:	bf00      	nop
   10200:	40001c00 	.word	0x40001c00

00010204 <USB_DEVICE_INSTANCE_init>:

void USB_DEVICE_INSTANCE_init(void)
{
   10204:	b510      	push	{r4, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
   10206:	4b04      	ldr	r3, [pc, #16]	; (10218 <USB_DEVICE_INSTANCE_init+0x14>)
   10208:	4798      	blx	r3
	usb_d_init();
   1020a:	4b04      	ldr	r3, [pc, #16]	; (1021c <USB_DEVICE_INSTANCE_init+0x18>)
   1020c:	4798      	blx	r3
	USB_DEVICE_INSTANCE_PORT_init();
}
   1020e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_DEVICE_INSTANCE_PORT_init();
   10212:	4b03      	ldr	r3, [pc, #12]	; (10220 <USB_DEVICE_INSTANCE_init+0x1c>)
   10214:	4718      	bx	r3
   10216:	bf00      	nop
   10218:	000101e1 	.word	0x000101e1
   1021c:	0000f399 	.word	0x0000f399
   10220:	00010185 	.word	0x00010185

00010224 <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
   10224:	4a02      	ldr	r2, [pc, #8]	; (10230 <WDT_0_CLOCK_init+0xc>)
   10226:	6953      	ldr	r3, [r2, #20]
   10228:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   1022c:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
   1022e:	4770      	bx	lr
   10230:	40000800 	.word	0x40000800

00010234 <WDT_0_init>:

void WDT_0_init(void)
{
   10234:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
   10236:	4b07      	ldr	r3, [pc, #28]	; (10254 <WDT_0_init+0x20>)
   10238:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
   1023a:	4b07      	ldr	r3, [pc, #28]	; (10258 <WDT_0_init+0x24>)
   1023c:	4907      	ldr	r1, [pc, #28]	; (1025c <WDT_0_init+0x28>)
   1023e:	2001      	movs	r0, #1
   10240:	2248      	movs	r2, #72	; 0x48
   10242:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
   10244:	4806      	ldr	r0, [pc, #24]	; (10260 <WDT_0_init+0x2c>)
   10246:	4b07      	ldr	r3, [pc, #28]	; (10264 <WDT_0_init+0x30>)
   10248:	6003      	str	r3, [r0, #0]
	wdt_init(&WDT_0, WDT);
}
   1024a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	return _wdt_init(&wdt->dev);
   1024e:	4b06      	ldr	r3, [pc, #24]	; (10268 <WDT_0_init+0x34>)
   10250:	4718      	bx	r3
   10252:	bf00      	nop
   10254:	00010225 	.word	0x00010225
   10258:	0000df45 	.word	0x0000df45
   1025c:	0001724b 	.word	0x0001724b
   10260:	20015820 	.word	0x20015820
   10264:	40002000 	.word	0x40002000
   10268:	0000b695 	.word	0x0000b695

0001026c <system_init>:

void system_init(void)
{
   1026c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
   10270:	4b7c      	ldr	r3, [pc, #496]	; (10464 <system_init+0x1f8>)
   10272:	4c7d      	ldr	r4, [pc, #500]	; (10468 <system_init+0x1fc>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   10274:	4d7d      	ldr	r5, [pc, #500]	; (1046c <system_init+0x200>)
	// GPIO on PA21

	// Set pin direction to input
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);

	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   10276:	4e7e      	ldr	r6, [pc, #504]	; (10470 <system_init+0x204>)
   10278:	4798      	blx	r3
   1027a:	2320      	movs	r3, #32
   1027c:	6163      	str	r3, [r4, #20]
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   1027e:	2102      	movs	r1, #2
   10280:	2005      	movs	r0, #5
   10282:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10284:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
   10288:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1028c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);
   10290:	2101      	movs	r1, #1
   10292:	2015      	movs	r0, #21
   10294:	47a8      	blx	r5
	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   10296:	2100      	movs	r1, #0
   10298:	2015      	movs	r0, #21
   1029a:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1029c:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
   102a0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   102a4:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
	gpio_set_pin_function(PIN_UI_SPI_CS0, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB07

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_2, GPIO_DIRECTION_IN);
   102a8:	2101      	movs	r1, #1
   102aa:	2027      	movs	r0, #39	; 0x27
   102ac:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_2,
   102ae:	2100      	movs	r1, #0
   102b0:	2027      	movs	r0, #39	; 0x27
   102b2:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   102b4:	f894 30c7 	ldrb.w	r3, [r4, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
   102b8:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   102bc:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   102c0:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   102c4:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_SHIFT, GPIO_DIRECTION_OUT);
   102c8:	2102      	movs	r1, #2
   102ca:	202d      	movs	r0, #45	; 0x2d
   102cc:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   102ce:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   102d2:	f44f 4780 	mov.w	r7, #16384	; 0x4000
	tmp &= ~PORT_PINCFG_PMUXEN;
   102d6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   102da:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
   102de:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   102e0:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
   102e4:	202e      	movs	r0, #46	; 0x2e
   102e6:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   102e8:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
   102ec:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   102f0:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	gpio_set_pin_function(HWCFG_CLOCK, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB15

	// Set pin direction to input
	gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
   102f4:	2101      	movs	r1, #1
   102f6:	202f      	movs	r0, #47	; 0x2f
   102f8:	47a8      	blx	r5

	gpio_set_pin_pull_mode(HWCFG_DATA,
   102fa:	2100      	movs	r1, #0
   102fc:	202f      	movs	r0, #47	; 0x2f
   102fe:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10300:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
   10304:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10308:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
	gpio_set_pin_function(HWCFG_DATA, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC11

	// Set pin direction to input
	gpio_set_pin_direction(MAP_MODE, GPIO_DIRECTION_IN);
   1030c:	2101      	movs	r1, #1
   1030e:	204b      	movs	r0, #75	; 0x4b
   10310:	47a8      	blx	r5

	gpio_set_pin_pull_mode(MAP_MODE,
   10312:	2101      	movs	r1, #1
   10314:	204b      	movs	r0, #75	; 0x4b
   10316:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10318:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
   1031c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10320:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(UI_PWR_EN, GPIO_DIRECTION_OUT);
   10324:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10326:	f8c4 7114 	str.w	r7, [r4, #276]	; 0x114
   1032a:	204e      	movs	r0, #78	; 0x4e
   1032c:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1032e:	f894 314e 	ldrb.w	r3, [r4, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
   10332:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10336:	f884 314e 	strb.w	r3, [r4, #334]	; 0x14e
	gpio_set_pin_function(UI_PWR_EN, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC18

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_1, GPIO_DIRECTION_IN);
   1033a:	2101      	movs	r1, #1
   1033c:	2052      	movs	r0, #82	; 0x52
   1033e:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_1,
   10340:	2100      	movs	r1, #0
   10342:	2052      	movs	r0, #82	; 0x52
   10344:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10346:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   1034a:	4e4a      	ldr	r6, [pc, #296]	; (10474 <system_init+0x208>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   1034c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10350:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10354:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   10358:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_A, GPIO_DIRECTION_OUT);
   1035c:	2102      	movs	r1, #2
   1035e:	2053      	movs	r0, #83	; 0x53
   10360:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10362:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
   10366:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1036a:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1036e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   10372:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_B, GPIO_DIRECTION_OUT);
   10376:	2102      	movs	r1, #2
   10378:	2054      	movs	r0, #84	; 0x54
   1037a:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1037c:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
   10380:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10384:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10388:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_C, GPIO_DIRECTION_OUT);
   1038c:	2102      	movs	r1, #2
   1038e:	2055      	movs	r0, #85	; 0x55
   10390:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
   10394:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10396:	f894 3155 	ldrb.w	r3, [r4, #341]	; 0x155
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   1039a:	4d37      	ldr	r5, [pc, #220]	; (10478 <system_init+0x20c>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   1039c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103a0:	f884 3155 	strb.w	r3, [r4, #341]	; 0x155

	gpio_set_pin_function(MUX_C, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
   103a4:	4b35      	ldr	r3, [pc, #212]	; (1047c <system_init+0x210>)
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_RTC;
   103a6:	4c36      	ldr	r4, [pc, #216]	; (10480 <system_init+0x214>)
   103a8:	4798      	blx	r3
	ADC_1_init();
   103aa:	4b36      	ldr	r3, [pc, #216]	; (10484 <system_init+0x218>)
   103ac:	4798      	blx	r3

	CRC_0_init();
   103ae:	4b36      	ldr	r3, [pc, #216]	; (10488 <system_init+0x21c>)
   103b0:	4798      	blx	r3

	EVENT_SYSTEM_0_init();
   103b2:	4b36      	ldr	r3, [pc, #216]	; (1048c <system_init+0x220>)
   103b4:	4798      	blx	r3

	FLASH_0_init();
   103b6:	4b36      	ldr	r3, [pc, #216]	; (10490 <system_init+0x224>)
   103b8:	4798      	blx	r3

	QSPI_INSTANCE_init();
   103ba:	4b36      	ldr	r3, [pc, #216]	; (10494 <system_init+0x228>)
   103bc:	4798      	blx	r3
   103be:	6963      	ldr	r3, [r4, #20]
   103c0:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   103c4:	6163      	str	r3, [r4, #20]
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   103c6:	4b34      	ldr	r3, [pc, #208]	; (10498 <system_init+0x22c>)
   103c8:	4798      	blx	r3
   103ca:	4934      	ldr	r1, [pc, #208]	; (1049c <system_init+0x230>)
   103cc:	4602      	mov	r2, r0
   103ce:	4834      	ldr	r0, [pc, #208]	; (104a0 <system_init+0x234>)
   103d0:	47a8      	blx	r5

	RTC_Scheduler_init();
	USART_EAST_init();
   103d2:	4b34      	ldr	r3, [pc, #208]	; (104a4 <system_init+0x238>)
   103d4:	4798      	blx	r3
	USART_NORTH_init();
   103d6:	4b34      	ldr	r3, [pc, #208]	; (104a8 <system_init+0x23c>)
   103d8:	4798      	blx	r3

	GRID_AUX_init();
   103da:	4b34      	ldr	r3, [pc, #208]	; (104ac <system_init+0x240>)
   103dc:	4798      	blx	r3

	UI_SPI_init();
   103de:	4b34      	ldr	r3, [pc, #208]	; (104b0 <system_init+0x244>)
   103e0:	4798      	blx	r3
	USART_WEST_init();
   103e2:	4b34      	ldr	r3, [pc, #208]	; (104b4 <system_init+0x248>)
   103e4:	4798      	blx	r3

	SYS_I2C_init();
   103e6:	4b34      	ldr	r3, [pc, #208]	; (104b8 <system_init+0x24c>)
   103e8:	4798      	blx	r3
	USART_SOUTH_init();
   103ea:	4b34      	ldr	r3, [pc, #208]	; (104bc <system_init+0x250>)
   103ec:	4798      	blx	r3

	GRID_LED_init();
   103ee:	4b34      	ldr	r3, [pc, #208]	; (104c0 <system_init+0x254>)
   103f0:	4798      	blx	r3

	delay_driver_init();
   103f2:	4b34      	ldr	r3, [pc, #208]	; (104c4 <system_init+0x258>)
   103f4:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
   103f6:	6963      	ldr	r3, [r4, #20]
   103f8:	433b      	orrs	r3, r7
   103fa:	4f33      	ldr	r7, [pc, #204]	; (104c8 <system_init+0x25c>)
   103fc:	6163      	str	r3, [r4, #20]
   103fe:	f04f 0840 	mov.w	r8, #64	; 0x40
   10402:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   10406:	47b0      	blx	r6
   10408:	4930      	ldr	r1, [pc, #192]	; (104cc <system_init+0x260>)
   1040a:	4602      	mov	r2, r0
   1040c:	4830      	ldr	r0, [pc, #192]	; (104d0 <system_init+0x264>)
   1040e:	47a8      	blx	r5
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
   10410:	6963      	ldr	r3, [r4, #20]
   10412:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   10416:	6163      	str	r3, [r4, #20]
   10418:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_1, TC1, _tc_get_timer());
   1041c:	47b0      	blx	r6
   1041e:	492d      	ldr	r1, [pc, #180]	; (104d4 <system_init+0x268>)
   10420:	4602      	mov	r2, r0
   10422:	482d      	ldr	r0, [pc, #180]	; (104d8 <system_init+0x26c>)
   10424:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC2;
   10426:	69a3      	ldr	r3, [r4, #24]
   10428:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   1042c:	61a3      	str	r3, [r4, #24]
   1042e:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_2, TC2, _tc_get_timer());
   10432:	47b0      	blx	r6
   10434:	4929      	ldr	r1, [pc, #164]	; (104dc <system_init+0x270>)
   10436:	4602      	mov	r2, r0
   10438:	4829      	ldr	r0, [pc, #164]	; (104e0 <system_init+0x274>)
   1043a:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC3;
   1043c:	69a3      	ldr	r3, [r4, #24]
   1043e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   10442:	61a3      	str	r3, [r4, #24]
   10444:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_3, TC3, _tc_get_timer());
   10448:	47b0      	blx	r6
   1044a:	4926      	ldr	r1, [pc, #152]	; (104e4 <system_init+0x278>)
   1044c:	4602      	mov	r2, r0
   1044e:	4826      	ldr	r0, [pc, #152]	; (104e8 <system_init+0x27c>)
   10450:	47a8      	blx	r5

	TIMER_0_init();
	TIMER_1_init();
	TIMER_2_init();
	TIMER_3_init();
	RAND_0_init();
   10452:	4b26      	ldr	r3, [pc, #152]	; (104ec <system_init+0x280>)
   10454:	4798      	blx	r3

	USB_DEVICE_INSTANCE_init();
   10456:	4b26      	ldr	r3, [pc, #152]	; (104f0 <system_init+0x284>)
   10458:	4798      	blx	r3

	WDT_0_init();
}
   1045a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WDT_0_init();
   1045e:	4b25      	ldr	r3, [pc, #148]	; (104f4 <system_init+0x288>)
   10460:	4718      	bx	r3
   10462:	bf00      	nop
   10464:	0000dcb9 	.word	0x0000dcb9
   10468:	41008000 	.word	0x41008000
   1046c:	0000f9b1 	.word	0x0000f9b1
   10470:	0000fa01 	.word	0x0000fa01
   10474:	00013761 	.word	0x00013761
   10478:	0000c8dd 	.word	0x0000c8dd
   1047c:	0000fa41 	.word	0x0000fa41
   10480:	40000800 	.word	0x40000800
   10484:	0000fac1 	.word	0x0000fac1
   10488:	0000fb45 	.word	0x0000fb45
   1048c:	0000fb69 	.word	0x0000fb69
   10490:	0000fba9 	.word	0x0000fba9
   10494:	0000fcad 	.word	0x0000fcad
   10498:	0000f919 	.word	0x0000f919
   1049c:	40002400 	.word	0x40002400
   104a0:	200156d8 	.word	0x200156d8
   104a4:	0000fd21 	.word	0x0000fd21
   104a8:	0000fda1 	.word	0x0000fda1
   104ac:	0000fe21 	.word	0x0000fe21
   104b0:	0000fed9 	.word	0x0000fed9
   104b4:	0000ff4d 	.word	0x0000ff4d
   104b8:	0000ffdd 	.word	0x0000ffdd
   104bc:	00010051 	.word	0x00010051
   104c0:	00010115 	.word	0x00010115
   104c4:	00010141 	.word	0x00010141
   104c8:	40001c00 	.word	0x40001c00
   104cc:	40003800 	.word	0x40003800
   104d0:	200159c4 	.word	0x200159c4
   104d4:	40003c00 	.word	0x40003c00
   104d8:	200158b8 	.word	0x200158b8
   104dc:	4101a000 	.word	0x4101a000
   104e0:	200156f8 	.word	0x200156f8
   104e4:	4101c000 	.word	0x4101c000
   104e8:	200159a4 	.word	0x200159a4
   104ec:	00010161 	.word	0x00010161
   104f0:	00010205 	.word	0x00010205
   104f4:	00010235 	.word	0x00010235

000104f8 <usart_transmission_complete>:
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   104f8:	2300      	movs	r3, #0
   104fa:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
   104fc:	69c3      	ldr	r3, [r0, #28]
   104fe:	b10b      	cbz	r3, 10504 <usart_transmission_complete+0xc>
		descr->usart_cb.tx_done(descr);
   10500:	3808      	subs	r0, #8
   10502:	4718      	bx	r3
	}
}
   10504:	4770      	bx	lr

00010506 <usart_error>:
 */
static void usart_error(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   10506:	2300      	movs	r3, #0
   10508:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
   1050a:	6a43      	ldr	r3, [r0, #36]	; 0x24
   1050c:	b10b      	cbz	r3, 10512 <usart_error+0xc>
		descr->usart_cb.error(descr);
   1050e:	3808      	subs	r0, #8
   10510:	4718      	bx	r3
	}
}
   10512:	4770      	bx	lr

00010514 <usart_fill_rx_buffer>:
{
   10514:	b570      	push	{r4, r5, r6, lr}
   10516:	4604      	mov	r4, r0
	ringbuffer_put(&descr->rx, data);
   10518:	4b05      	ldr	r3, [pc, #20]	; (10530 <usart_fill_rx_buffer+0x1c>)
   1051a:	f1a0 0508 	sub.w	r5, r0, #8
   1051e:	302c      	adds	r0, #44	; 0x2c
   10520:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
   10522:	6a23      	ldr	r3, [r4, #32]
   10524:	b11b      	cbz	r3, 1052e <usart_fill_rx_buffer+0x1a>
		descr->usart_cb.rx_done(descr);
   10526:	4628      	mov	r0, r5
}
   10528:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		descr->usart_cb.rx_done(descr);
   1052c:	4718      	bx	r3
}
   1052e:	bd70      	pop	{r4, r5, r6, pc}
   10530:	000119a9 	.word	0x000119a9

00010534 <usart_async_write>:
{
   10534:	b570      	push	{r4, r5, r6, lr}
   10536:	460e      	mov	r6, r1
   10538:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
   1053a:	4604      	mov	r4, r0
   1053c:	b118      	cbz	r0, 10546 <usart_async_write+0x12>
   1053e:	b1d9      	cbz	r1, 10578 <usart_async_write+0x44>
   10540:	1e10      	subs	r0, r2, #0
   10542:	bf18      	it	ne
   10544:	2001      	movne	r0, #1
   10546:	4b0f      	ldr	r3, [pc, #60]	; (10584 <usart_async_write+0x50>)
   10548:	490f      	ldr	r1, [pc, #60]	; (10588 <usart_async_write+0x54>)
   1054a:	f240 123b 	movw	r2, #315	; 0x13b
   1054e:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
   10550:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
   10554:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
   10558:	429a      	cmp	r2, r3
   1055a:	d10f      	bne.n	1057c <usart_async_write+0x48>
	descr->tx_por           = 0;
   1055c:	2300      	movs	r3, #0
   1055e:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
   10562:	2301      	movs	r3, #1
   10564:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
   10566:	f104 0008 	add.w	r0, r4, #8
   1056a:	4b08      	ldr	r3, [pc, #32]	; (1058c <usart_async_write+0x58>)
	descr->tx_buffer        = (uint8_t *)buf;
   1056c:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
   1056e:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	_usart_async_enable_byte_sent_irq(&descr->device);
   10572:	4798      	blx	r3
	return (int32_t)length;
   10574:	4628      	mov	r0, r5
}
   10576:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
   10578:	4608      	mov	r0, r1
   1057a:	e7e4      	b.n	10546 <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
   1057c:	f06f 001b 	mvn.w	r0, #27
   10580:	e7f9      	b.n	10576 <usart_async_write+0x42>
   10582:	bf00      	nop
   10584:	0000df45 	.word	0x0000df45
   10588:	00017264 	.word	0x00017264
   1058c:	00010f8f 	.word	0x00010f8f

00010590 <usart_process_byte_sent>:
	if (descr->tx_por != descr->tx_buffer_length) {
   10590:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   10592:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
   10596:	429a      	cmp	r2, r3
{
   10598:	b510      	push	{r4, lr}
   1059a:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
   1059c:	d00a      	beq.n	105b4 <usart_process_byte_sent+0x24>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
   1059e:	6c02      	ldr	r2, [r0, #64]	; 0x40
   105a0:	1c59      	adds	r1, r3, #1
   105a2:	8781      	strh	r1, [r0, #60]	; 0x3c
   105a4:	5cd1      	ldrb	r1, [r2, r3]
   105a6:	4b04      	ldr	r3, [pc, #16]	; (105b8 <usart_process_byte_sent+0x28>)
   105a8:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
   105aa:	4b04      	ldr	r3, [pc, #16]	; (105bc <usart_process_byte_sent+0x2c>)
   105ac:	4620      	mov	r0, r4
}
   105ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_usart_async_enable_tx_done_irq(&descr->device);
   105b2:	4718      	bx	r3
   105b4:	4b02      	ldr	r3, [pc, #8]	; (105c0 <usart_process_byte_sent+0x30>)
   105b6:	e7fa      	b.n	105ae <usart_process_byte_sent+0x1e>
   105b8:	00010f63 	.word	0x00010f63
   105bc:	00010f8f 	.word	0x00010f8f
   105c0:	00010f97 	.word	0x00010f97

000105c4 <usart_async_read>:
{
   105c4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   105c8:	460e      	mov	r6, r1
   105ca:	4617      	mov	r7, r2
	ASSERT(descr && buf && length);
   105cc:	4604      	mov	r4, r0
   105ce:	b118      	cbz	r0, 105d8 <usart_async_read+0x14>
   105d0:	b1e9      	cbz	r1, 1060e <usart_async_read+0x4a>
   105d2:	1e10      	subs	r0, r2, #0
   105d4:	bf18      	it	ne
   105d6:	2001      	movne	r0, #1
   105d8:	4910      	ldr	r1, [pc, #64]	; (1061c <usart_async_read+0x58>)
   105da:	4b11      	ldr	r3, [pc, #68]	; (10620 <usart_async_read+0x5c>)
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   105dc:	f8df 9050 	ldr.w	r9, [pc, #80]	; 10630 <usart_async_read+0x6c>
	ASSERT(descr && buf && length);
   105e0:	f44f 72ac 	mov.w	r2, #344	; 0x158
   105e4:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   105e6:	3434      	adds	r4, #52	; 0x34
	CRITICAL_SECTION_ENTER()
   105e8:	4b0e      	ldr	r3, [pc, #56]	; (10624 <usart_async_read+0x60>)
   105ea:	a801      	add	r0, sp, #4
   105ec:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   105ee:	4b0e      	ldr	r3, [pc, #56]	; (10628 <usart_async_read+0x64>)
   105f0:	4620      	mov	r0, r4
   105f2:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
   105f4:	4b0d      	ldr	r3, [pc, #52]	; (1062c <usart_async_read+0x68>)
	num = ringbuffer_num(&descr->rx);
   105f6:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
   105f8:	a801      	add	r0, sp, #4
   105fa:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
   105fc:	2500      	movs	r5, #0
   105fe:	45a8      	cmp	r8, r5
   10600:	d001      	beq.n	10606 <usart_async_read+0x42>
   10602:	42bd      	cmp	r5, r7
   10604:	d105      	bne.n	10612 <usart_async_read+0x4e>
}
   10606:	4628      	mov	r0, r5
   10608:	b003      	add	sp, #12
   1060a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && buf && length);
   1060e:	4608      	mov	r0, r1
   10610:	e7e2      	b.n	105d8 <usart_async_read+0x14>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   10612:	1971      	adds	r1, r6, r5
   10614:	4620      	mov	r0, r4
   10616:	47c8      	blx	r9
   10618:	3501      	adds	r5, #1
   1061a:	e7f0      	b.n	105fe <usart_async_read+0x3a>
   1061c:	00017264 	.word	0x00017264
   10620:	0000df45 	.word	0x0000df45
   10624:	00011a11 	.word	0x00011a11
   10628:	000119ed 	.word	0x000119ed
   1062c:	00011a1f 	.word	0x00011a1f
   10630:	00011969 	.word	0x00011969

00010634 <usart_async_init>:
{
   10634:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10636:	460d      	mov	r5, r1
   10638:	4616      	mov	r6, r2
   1063a:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   1063c:	4604      	mov	r4, r0
   1063e:	b120      	cbz	r0, 1064a <usart_async_init+0x16>
   10640:	b309      	cbz	r1, 10686 <usart_async_init+0x52>
   10642:	b312      	cbz	r2, 1068a <usart_async_init+0x56>
   10644:	1e18      	subs	r0, r3, #0
   10646:	bf18      	it	ne
   10648:	2001      	movne	r0, #1
   1064a:	4912      	ldr	r1, [pc, #72]	; (10694 <usart_async_init+0x60>)
   1064c:	4b12      	ldr	r3, [pc, #72]	; (10698 <usart_async_init+0x64>)
   1064e:	223a      	movs	r2, #58	; 0x3a
   10650:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
   10652:	4b12      	ldr	r3, [pc, #72]	; (1069c <usart_async_init+0x68>)
   10654:	463a      	mov	r2, r7
   10656:	4631      	mov	r1, r6
   10658:	f104 0034 	add.w	r0, r4, #52	; 0x34
   1065c:	4798      	blx	r3
   1065e:	b9b0      	cbnz	r0, 1068e <usart_async_init+0x5a>
	init_status = _usart_async_init(&descr->device, hw);
   10660:	4b0f      	ldr	r3, [pc, #60]	; (106a0 <usart_async_init+0x6c>)
   10662:	4629      	mov	r1, r5
   10664:	f104 0008 	add.w	r0, r4, #8
   10668:	4798      	blx	r3
	if (init_status) {
   1066a:	b958      	cbnz	r0, 10684 <usart_async_init+0x50>
	descr->io.read  = usart_async_read;
   1066c:	4b0d      	ldr	r3, [pc, #52]	; (106a4 <usart_async_init+0x70>)
   1066e:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
   10670:	4b0d      	ldr	r3, [pc, #52]	; (106a8 <usart_async_init+0x74>)
   10672:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
   10674:	4b0d      	ldr	r3, [pc, #52]	; (106ac <usart_async_init+0x78>)
   10676:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
   10678:	4b0d      	ldr	r3, [pc, #52]	; (106b0 <usart_async_init+0x7c>)
   1067a:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
   1067c:	4b0d      	ldr	r3, [pc, #52]	; (106b4 <usart_async_init+0x80>)
   1067e:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
   10680:	4b0d      	ldr	r3, [pc, #52]	; (106b8 <usart_async_init+0x84>)
   10682:	6163      	str	r3, [r4, #20]
}
   10684:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   10686:	4608      	mov	r0, r1
   10688:	e7df      	b.n	1064a <usart_async_init+0x16>
   1068a:	4610      	mov	r0, r2
   1068c:	e7dd      	b.n	1064a <usart_async_init+0x16>
		return ERR_INVALID_ARG;
   1068e:	f06f 000c 	mvn.w	r0, #12
   10692:	e7f7      	b.n	10684 <usart_async_init+0x50>
   10694:	00017264 	.word	0x00017264
   10698:	0000df45 	.word	0x0000df45
   1069c:	0001192d 	.word	0x0001192d
   106a0:	00010ea5 	.word	0x00010ea5
   106a4:	000105c5 	.word	0x000105c5
   106a8:	00010535 	.word	0x00010535
   106ac:	00010591 	.word	0x00010591
   106b0:	00010515 	.word	0x00010515
   106b4:	000104f9 	.word	0x000104f9
   106b8:	00010507 	.word	0x00010507

000106bc <usart_async_enable>:
{
   106bc:	b510      	push	{r4, lr}
	ASSERT(descr);
   106be:	4604      	mov	r4, r0
   106c0:	3800      	subs	r0, #0
   106c2:	bf18      	it	ne
   106c4:	2001      	movne	r0, #1
   106c6:	4905      	ldr	r1, [pc, #20]	; (106dc <usart_async_enable+0x20>)
   106c8:	4b05      	ldr	r3, [pc, #20]	; (106e0 <usart_async_enable+0x24>)
   106ca:	2261      	movs	r2, #97	; 0x61
   106cc:	4798      	blx	r3
	_usart_async_enable(&descr->device);
   106ce:	f104 0008 	add.w	r0, r4, #8
   106d2:	4b04      	ldr	r3, [pc, #16]	; (106e4 <usart_async_enable+0x28>)
   106d4:	4798      	blx	r3
}
   106d6:	2000      	movs	r0, #0
   106d8:	bd10      	pop	{r4, pc}
   106da:	bf00      	nop
   106dc:	00017264 	.word	0x00017264
   106e0:	0000df45 	.word	0x0000df45
   106e4:	00010f31 	.word	0x00010f31

000106e8 <usart_async_disable>:
{
   106e8:	b510      	push	{r4, lr}
	ASSERT(descr);
   106ea:	4604      	mov	r4, r0
   106ec:	3800      	subs	r0, #0
   106ee:	bf18      	it	ne
   106f0:	2001      	movne	r0, #1
   106f2:	4905      	ldr	r1, [pc, #20]	; (10708 <usart_async_disable+0x20>)
   106f4:	4b05      	ldr	r3, [pc, #20]	; (1070c <usart_async_disable+0x24>)
   106f6:	226c      	movs	r2, #108	; 0x6c
   106f8:	4798      	blx	r3
	_usart_async_disable(&descr->device);
   106fa:	f104 0008 	add.w	r0, r4, #8
   106fe:	4b04      	ldr	r3, [pc, #16]	; (10710 <usart_async_disable+0x28>)
   10700:	4798      	blx	r3
}
   10702:	2000      	movs	r0, #0
   10704:	bd10      	pop	{r4, pc}
   10706:	bf00      	nop
   10708:	00017264 	.word	0x00017264
   1070c:	0000df45 	.word	0x0000df45
   10710:	00010f45 	.word	0x00010f45

00010714 <usart_async_get_io_descriptor>:
{
   10714:	b538      	push	{r3, r4, r5, lr}
   10716:	460d      	mov	r5, r1
	ASSERT(descr && io);
   10718:	4604      	mov	r4, r0
   1071a:	b110      	cbz	r0, 10722 <usart_async_get_io_descriptor+0xe>
   1071c:	1e08      	subs	r0, r1, #0
   1071e:	bf18      	it	ne
   10720:	2001      	movne	r0, #1
   10722:	4903      	ldr	r1, [pc, #12]	; (10730 <usart_async_get_io_descriptor+0x1c>)
   10724:	4b03      	ldr	r3, [pc, #12]	; (10734 <usart_async_get_io_descriptor+0x20>)
   10726:	2277      	movs	r2, #119	; 0x77
   10728:	4798      	blx	r3
	*io = &descr->io;
   1072a:	602c      	str	r4, [r5, #0]
}
   1072c:	2000      	movs	r0, #0
   1072e:	bd38      	pop	{r3, r4, r5, pc}
   10730:	00017264 	.word	0x00017264
   10734:	0000df45 	.word	0x0000df45

00010738 <usart_async_register_callback>:
{
   10738:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
   1073a:	4605      	mov	r5, r0
   1073c:	3800      	subs	r0, #0
{
   1073e:	460c      	mov	r4, r1
	ASSERT(descr);
   10740:	bf18      	it	ne
   10742:	2001      	movne	r0, #1
   10744:	4911      	ldr	r1, [pc, #68]	; (1078c <usart_async_register_callback+0x54>)
   10746:	4b12      	ldr	r3, [pc, #72]	; (10790 <usart_async_register_callback+0x58>)
{
   10748:	4616      	mov	r6, r2
	ASSERT(descr);
   1074a:	2283      	movs	r2, #131	; 0x83
   1074c:	4798      	blx	r3
	switch (type) {
   1074e:	2c01      	cmp	r4, #1
   10750:	d00d      	beq.n	1076e <usart_async_register_callback+0x36>
   10752:	2c02      	cmp	r4, #2
   10754:	d011      	beq.n	1077a <usart_async_register_callback+0x42>
   10756:	b9b4      	cbnz	r4, 10786 <usart_async_register_callback+0x4e>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   10758:	1e32      	subs	r2, r6, #0
		descr->usart_cb.rx_done = cb;
   1075a:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   1075c:	bf18      	it	ne
   1075e:	2201      	movne	r2, #1
   10760:	2101      	movs	r1, #1
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   10762:	f105 0008 	add.w	r0, r5, #8
   10766:	4b0b      	ldr	r3, [pc, #44]	; (10794 <usart_async_register_callback+0x5c>)
   10768:	4798      	blx	r3
	return ERR_NONE;
   1076a:	2000      	movs	r0, #0
}
   1076c:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   1076e:	1e32      	subs	r2, r6, #0
		descr->usart_cb.tx_done = cb;
   10770:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   10772:	bf18      	it	ne
   10774:	2201      	movne	r2, #1
   10776:	2102      	movs	r1, #2
   10778:	e7f3      	b.n	10762 <usart_async_register_callback+0x2a>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   1077a:	1e32      	subs	r2, r6, #0
		descr->usart_cb.error = cb;
   1077c:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   1077e:	bf18      	it	ne
   10780:	2201      	movne	r2, #1
   10782:	2103      	movs	r1, #3
   10784:	e7ed      	b.n	10762 <usart_async_register_callback+0x2a>
	switch (type) {
   10786:	f06f 000c 	mvn.w	r0, #12
   1078a:	e7ef      	b.n	1076c <usart_async_register_callback+0x34>
   1078c:	00017264 	.word	0x00017264
   10790:	0000df45 	.word	0x0000df45
   10794:	00010fa1 	.word	0x00010fa1

00010798 <usart_async_set_parity>:
{
   10798:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr);
   1079a:	4604      	mov	r4, r0
   1079c:	3800      	subs	r0, #0
   1079e:	bf18      	it	ne
   107a0:	2001      	movne	r0, #1
{
   107a2:	460d      	mov	r5, r1
	ASSERT(descr);
   107a4:	22cb      	movs	r2, #203	; 0xcb
   107a6:	4905      	ldr	r1, [pc, #20]	; (107bc <usart_async_set_parity+0x24>)
   107a8:	4b05      	ldr	r3, [pc, #20]	; (107c0 <usart_async_set_parity+0x28>)
   107aa:	4798      	blx	r3
	_usart_async_set_parity(&descr->device, parity);
   107ac:	f104 0008 	add.w	r0, r4, #8
   107b0:	4b04      	ldr	r3, [pc, #16]	; (107c4 <usart_async_set_parity+0x2c>)
   107b2:	4629      	mov	r1, r5
   107b4:	4798      	blx	r3
}
   107b6:	2000      	movs	r0, #0
   107b8:	bd38      	pop	{r3, r4, r5, pc}
   107ba:	bf00      	nop
   107bc:	00017264 	.word	0x00017264
   107c0:	0000df45 	.word	0x0000df45
   107c4:	00010f51 	.word	0x00010f51

000107c8 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
   107c8:	69c3      	ldr	r3, [r0, #28]
   107ca:	420b      	tst	r3, r1
   107cc:	d1fc      	bne.n	107c8 <hri_sercomi2cm_wait_for_sync>
	};
}
   107ce:	4770      	bx	lr

000107d0 <hri_sercomspi_wait_for_sync>:
	return ((Sercom *)hw)->I2CS.SYNCBUSY.reg & reg;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
   107d0:	69c3      	ldr	r3, [r0, #28]
   107d2:	420b      	tst	r3, r1
   107d4:	d1fc      	bne.n	107d0 <hri_sercomspi_wait_for_sync>
	};
}
   107d6:	4770      	bx	lr

000107d8 <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
   107d8:	69c3      	ldr	r3, [r0, #28]
   107da:	420b      	tst	r3, r1
   107dc:	d1fc      	bne.n	107d8 <hri_sercomusart_wait_for_sync>
	};
}
   107de:	4770      	bx	lr

000107e0 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   107e0:	6802      	ldr	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   107e2:	4b03      	ldr	r3, [pc, #12]	; (107f0 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   107e4:	f022 0202 	bic.w	r2, r2, #2
   107e8:	6002      	str	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   107ea:	2103      	movs	r1, #3
   107ec:	4718      	bx	r3
   107ee:	bf00      	nop
   107f0:	000107c9 	.word	0x000107c9

000107f4 <hri_sercomspi_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomspi_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   107f4:	6802      	ldr	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   107f6:	4b03      	ldr	r3, [pc, #12]	; (10804 <hri_sercomspi_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   107f8:	f022 0202 	bic.w	r2, r2, #2
   107fc:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   107fe:	2103      	movs	r1, #3
   10800:	4718      	bx	r3
   10802:	bf00      	nop
   10804:	000107d1 	.word	0x000107d1

00010808 <hri_sercomusart_get_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomusart_get_CTRLA_ENABLE_bit(const void *const hw)
{
   10808:	b508      	push	{r3, lr}
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1080a:	2103      	movs	r1, #3
   1080c:	4b02      	ldr	r3, [pc, #8]	; (10818 <hri_sercomusart_get_CTRLA_ENABLE_bit+0x10>)
   1080e:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10810:	6800      	ldr	r0, [r0, #0]
	tmp = (tmp & SERCOM_USART_CTRLA_ENABLE) >> SERCOM_USART_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}
   10812:	f3c0 0040 	ubfx	r0, r0, #1, #1
   10816:	bd08      	pop	{r3, pc}
   10818:	000107d9 	.word	0x000107d9

0001081c <hri_sercomusart_write_CTRLA_ENABLE_bit>:

static inline void hri_sercomusart_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   1081c:	6803      	ldr	r3, [r0, #0]
	tmp &= ~SERCOM_USART_CTRLA_ENABLE;
   1081e:	f023 0302 	bic.w	r3, r3, #2
	tmp |= value << SERCOM_USART_CTRLA_ENABLE_Pos;
   10822:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
	((Sercom *)hw)->USART.CTRLA.reg = tmp;
   10826:	6001      	str	r1, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10828:	4b01      	ldr	r3, [pc, #4]	; (10830 <hri_sercomusart_write_CTRLA_ENABLE_bit+0x14>)
   1082a:	2103      	movs	r1, #3
   1082c:	4718      	bx	r3
   1082e:	bf00      	nop
   10830:	000107d9 	.word	0x000107d9

00010834 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   10834:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10836:	4b03      	ldr	r3, [pc, #12]	; (10844 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   10838:	f022 0202 	bic.w	r2, r2, #2
   1083c:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1083e:	2103      	movs	r1, #3
   10840:	4718      	bx	r3
   10842:	bf00      	nop
   10844:	000107d9 	.word	0x000107d9

00010848 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
   10848:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   1084a:	4d0c      	ldr	r5, [pc, #48]	; (1087c <_sercom_get_hardware_index+0x34>)
{
   1084c:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   1084e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   10850:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10852:	466c      	mov	r4, sp
   10854:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   10856:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1085a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   1085e:	466a      	mov	r2, sp
   10860:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
   10862:	f852 1b04 	ldr.w	r1, [r2], #4
   10866:	42b1      	cmp	r1, r6
   10868:	d102      	bne.n	10870 <_sercom_get_hardware_index+0x28>
			return i;
   1086a:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
   1086c:	b008      	add	sp, #32
   1086e:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   10870:	3301      	adds	r3, #1
   10872:	2b08      	cmp	r3, #8
   10874:	d1f5      	bne.n	10862 <_sercom_get_hardware_index+0x1a>
	return 0;
   10876:	2000      	movs	r0, #0
   10878:	e7f8      	b.n	1086c <_sercom_get_hardware_index+0x24>
   1087a:	bf00      	nop
   1087c:	0001729c 	.word	0x0001729c

00010880 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
   10880:	b510      	push	{r4, lr}
	void *hw = device->hw;
   10882:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   10884:	7e22      	ldrb	r2, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   10886:	07d1      	lsls	r1, r2, #31
{
   10888:	4603      	mov	r3, r0
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   1088a:	d508      	bpl.n	1089e <_sercom_usart_interrupt_handler+0x1e>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
   1088c:	7da2      	ldrb	r2, [r4, #22]
   1088e:	07d2      	lsls	r2, r2, #31
   10890:	d505      	bpl.n	1089e <_sercom_usart_interrupt_handler+0x1e>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   10892:	2201      	movs	r2, #1
   10894:	7522      	strb	r2, [r4, #20]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
   10896:	6803      	ldr	r3, [r0, #0]
		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
		status = hri_sercomusart_read_STATUS_reg(hw);
		hri_sercomusart_clear_STATUS_reg(hw, status);
	}
}
   10898:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_byte_sent(device);
   1089c:	4718      	bx	r3
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   1089e:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
   108a0:	0790      	lsls	r0, r2, #30
   108a2:	d509      	bpl.n	108b8 <_sercom_usart_interrupt_handler+0x38>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
   108a4:	7da2      	ldrb	r2, [r4, #22]
   108a6:	0791      	lsls	r1, r2, #30
   108a8:	d506      	bpl.n	108b8 <_sercom_usart_interrupt_handler+0x38>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
   108aa:	2202      	movs	r2, #2
   108ac:	7522      	strb	r2, [r4, #20]
		device->usart_cb.tx_done_cb(device);
   108ae:	4618      	mov	r0, r3
}
   108b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_done_cb(device);
   108b4:	689a      	ldr	r2, [r3, #8]
   108b6:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   108b8:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
   108ba:	0752      	lsls	r2, r2, #29
   108bc:	d50d      	bpl.n	108da <_sercom_usart_interrupt_handler+0x5a>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
   108be:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
   108c0:	f002 0237 	and.w	r2, r2, #55	; 0x37
   108c4:	b112      	cbz	r2, 108cc <_sercom_usart_interrupt_handler+0x4c>
	((Sercom *)hw)->USART.STATUS.reg = mask;
   108c6:	23ff      	movs	r3, #255	; 0xff
   108c8:	8363      	strh	r3, [r4, #26]
}
   108ca:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
   108cc:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   108ce:	685a      	ldr	r2, [r3, #4]
}
   108d0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   108d4:	b2c9      	uxtb	r1, r1
   108d6:	4618      	mov	r0, r3
   108d8:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
   108da:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
   108dc:	09d2      	lsrs	r2, r2, #7
   108de:	d0f4      	beq.n	108ca <_sercom_usart_interrupt_handler+0x4a>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
   108e0:	2280      	movs	r2, #128	; 0x80
   108e2:	7622      	strb	r2, [r4, #24]
		device->usart_cb.error_cb(device);
   108e4:	4618      	mov	r0, r3
   108e6:	68da      	ldr	r2, [r3, #12]
   108e8:	4790      	blx	r2
	return ((Sercom *)hw)->USART.STATUS.reg;
   108ea:	8b63      	ldrh	r3, [r4, #26]
   108ec:	b29b      	uxth	r3, r3
   108ee:	e7eb      	b.n	108c8 <_sercom_usart_interrupt_handler+0x48>

000108f0 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM0) {
   108f0:	4b11      	ldr	r3, [pc, #68]	; (10938 <_sercom_init_irq_param+0x48>)
   108f2:	4298      	cmp	r0, r3
   108f4:	d105      	bne.n	10902 <_sercom_init_irq_param+0x12>
		_sercom0_dev = (struct _usart_async_device *)dev;
   108f6:	4b11      	ldr	r3, [pc, #68]	; (1093c <_sercom_init_irq_param+0x4c>)
   108f8:	6019      	str	r1, [r3, #0]

	if (hw == SERCOM5) {
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
	}

	if (hw == SERCOM6) {
   108fa:	4b11      	ldr	r3, [pc, #68]	; (10940 <_sercom_init_irq_param+0x50>)
   108fc:	4298      	cmp	r0, r3
   108fe:	d018      	beq.n	10932 <_sercom_init_irq_param+0x42>
   10900:	4770      	bx	lr
	if (hw == SERCOM1) {
   10902:	4b10      	ldr	r3, [pc, #64]	; (10944 <_sercom_init_irq_param+0x54>)
   10904:	4298      	cmp	r0, r3
   10906:	d00b      	beq.n	10920 <_sercom_init_irq_param+0x30>
	if (hw == SERCOM3) {
   10908:	4b0f      	ldr	r3, [pc, #60]	; (10948 <_sercom_init_irq_param+0x58>)
   1090a:	4298      	cmp	r0, r3
   1090c:	d00b      	beq.n	10926 <_sercom_init_irq_param+0x36>
	if (hw == SERCOM4) {
   1090e:	f1b0 4f86 	cmp.w	r0, #1124073472	; 0x43000000
   10912:	d00b      	beq.n	1092c <_sercom_init_irq_param+0x3c>
	if (hw == SERCOM5) {
   10914:	4b0d      	ldr	r3, [pc, #52]	; (1094c <_sercom_init_irq_param+0x5c>)
   10916:	4298      	cmp	r0, r3
   10918:	d1ef      	bne.n	108fa <_sercom_init_irq_param+0xa>
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
   1091a:	4b08      	ldr	r3, [pc, #32]	; (1093c <_sercom_init_irq_param+0x4c>)
   1091c:	6119      	str	r1, [r3, #16]
	if (hw == SERCOM6) {
   1091e:	4770      	bx	lr
		_sercom1_dev = (struct _usart_async_device *)dev;
   10920:	4b06      	ldr	r3, [pc, #24]	; (1093c <_sercom_init_irq_param+0x4c>)
   10922:	6059      	str	r1, [r3, #4]
	if (hw == SERCOM5) {
   10924:	e7e9      	b.n	108fa <_sercom_init_irq_param+0xa>
		_sercom3_dev = (struct _spi_async_dev *)dev;
   10926:	4b05      	ldr	r3, [pc, #20]	; (1093c <_sercom_init_irq_param+0x4c>)
   10928:	6099      	str	r1, [r3, #8]
	if (hw == SERCOM6) {
   1092a:	4770      	bx	lr
		_sercom4_dev = (struct _usart_async_device *)dev;
   1092c:	4b03      	ldr	r3, [pc, #12]	; (1093c <_sercom_init_irq_param+0x4c>)
   1092e:	60d9      	str	r1, [r3, #12]
	if (hw == SERCOM6) {
   10930:	4770      	bx	lr
		_sercom6_dev = (struct _usart_async_device *)dev;
   10932:	4b02      	ldr	r3, [pc, #8]	; (1093c <_sercom_init_irq_param+0x4c>)
   10934:	6159      	str	r1, [r3, #20]
	}
}
   10936:	4770      	bx	lr
   10938:	40003000 	.word	0x40003000
   1093c:	200019b8 	.word	0x200019b8
   10940:	43000800 	.word	0x43000800
   10944:	40003400 	.word	0x40003400
   10948:	41014000 	.word	0x41014000
   1094c:	43000400 	.word	0x43000400

00010950 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
   10950:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
   10952:	4b03      	ldr	r3, [pc, #12]	; (10960 <_sercom_get_irq_num+0x10>)
   10954:	4798      	blx	r3
   10956:	0080      	lsls	r0, r0, #2
   10958:	302e      	adds	r0, #46	; 0x2e
}
   1095a:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   1095e:	bd08      	pop	{r3, pc}
   10960:	00010849 	.word	0x00010849

00010964 <_spi_sync_enable>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10964:	69c2      	ldr	r2, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10966:	f012 0201 	ands.w	r2, r2, #1
{
   1096a:	b508      	push	{r3, lr}
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   1096c:	d108      	bne.n	10980 <_spi_sync_enable+0x1c>
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   1096e:	6803      	ldr	r3, [r0, #0]
   10970:	f043 0302 	orr.w	r3, r3, #2
   10974:	6003      	str	r3, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10976:	2103      	movs	r1, #3
   10978:	4b03      	ldr	r3, [pc, #12]	; (10988 <_spi_sync_enable+0x24>)
   1097a:	4798      	blx	r3
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
   1097c:	4610      	mov	r0, r2
}
   1097e:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
   10980:	f06f 0003 	mvn.w	r0, #3
   10984:	e7fb      	b.n	1097e <_spi_sync_enable+0x1a>
   10986:	bf00      	nop
   10988:	000107d1 	.word	0x000107d1

0001098c <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
   1098c:	b508      	push	{r3, lr}
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
   1098e:	4b08      	ldr	r3, [pc, #32]	; (109b0 <_spi_get_regs+0x24>)
   10990:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
		if (sercomspi_regs[i].n == n) {
   10992:	2803      	cmp	r0, #3
   10994:	d007      	beq.n	109a6 <_spi_get_regs+0x1a>
   10996:	2807      	cmp	r0, #7
   10998:	d107      	bne.n	109aa <_spi_get_regs+0x1e>
   1099a:	2301      	movs	r3, #1
			return &sercomspi_regs[i];
   1099c:	4805      	ldr	r0, [pc, #20]	; (109b4 <_spi_get_regs+0x28>)
   1099e:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   109a2:	4418      	add	r0, r3
		}
	}

	return NULL;
}
   109a4:	bd08      	pop	{r3, pc}
		if (sercomspi_regs[i].n == n) {
   109a6:	2300      	movs	r3, #0
   109a8:	e7f8      	b.n	1099c <_spi_get_regs+0x10>
	return NULL;
   109aa:	2000      	movs	r0, #0
   109ac:	e7fa      	b.n	109a4 <_spi_get_regs+0x18>
   109ae:	bf00      	nop
   109b0:	00010849 	.word	0x00010849
   109b4:	000172bc 	.word	0x000172bc

000109b8 <_spi_dma_tx_complete>:
 */
static void _spi_dma_tx_complete(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.tx) {
   109b8:	6883      	ldr	r3, [r0, #8]
   109ba:	685b      	ldr	r3, [r3, #4]
   109bc:	b103      	cbz	r3, 109c0 <_spi_dma_tx_complete+0x8>
		dev->callbacks.tx(resource);
   109be:	4718      	bx	r3
	}
}
   109c0:	4770      	bx	lr

000109c2 <_spi_dma_error_occured>:
 */
static void _spi_dma_error_occured(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.error) {
   109c2:	6883      	ldr	r3, [r0, #8]
   109c4:	68db      	ldr	r3, [r3, #12]
   109c6:	b103      	cbz	r3, 109ca <_spi_dma_error_occured+0x8>
		dev->callbacks.error(resource);
   109c8:	4718      	bx	r3
	}
}
   109ca:	4770      	bx	lr

000109cc <__NVIC_EnableIRQ>:
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   109cc:	0942      	lsrs	r2, r0, #5
   109ce:	2301      	movs	r3, #1
   109d0:	f000 001f 	and.w	r0, r0, #31
   109d4:	fa03 f000 	lsl.w	r0, r3, r0
   109d8:	4b01      	ldr	r3, [pc, #4]	; (109e0 <__NVIC_EnableIRQ+0x14>)
   109da:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
   109de:	4770      	bx	lr
   109e0:	e000e100 	.word	0xe000e100

000109e4 <_spi_async_enable>:
{
   109e4:	b538      	push	{r3, r4, r5, lr}
   109e6:	4604      	mov	r4, r0
	_spi_sync_enable(hw);
   109e8:	4b07      	ldr	r3, [pc, #28]	; (10a08 <_spi_async_enable+0x24>)
		NVIC_EnableIRQ((IRQn_Type)irq++);
   109ea:	4d08      	ldr	r5, [pc, #32]	; (10a0c <_spi_async_enable+0x28>)
	_spi_sync_enable(hw);
   109ec:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   109ee:	4620      	mov	r0, r4
   109f0:	4b07      	ldr	r3, [pc, #28]	; (10a10 <_spi_async_enable+0x2c>)
   109f2:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   109f4:	2100      	movs	r1, #0
	uint8_t irq = _sercom_get_irq_num(hw);
   109f6:	4604      	mov	r4, r0
		NVIC_EnableIRQ((IRQn_Type)irq++);
   109f8:	1860      	adds	r0, r4, r1
   109fa:	b2c0      	uxtb	r0, r0
   109fc:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   109fe:	3101      	adds	r1, #1
   10a00:	2904      	cmp	r1, #4
   10a02:	d1f9      	bne.n	109f8 <_spi_async_enable+0x14>
}
   10a04:	2000      	movs	r0, #0
   10a06:	bd38      	pop	{r3, r4, r5, pc}
   10a08:	00010965 	.word	0x00010965
   10a0c:	000109cd 	.word	0x000109cd
   10a10:	00010951 	.word	0x00010951

00010a14 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10a14:	0943      	lsrs	r3, r0, #5
   10a16:	2201      	movs	r2, #1
   10a18:	f000 001f 	and.w	r0, r0, #31
   10a1c:	fa02 f000 	lsl.w	r0, r2, r0
   10a20:	3320      	adds	r3, #32
   10a22:	4a04      	ldr	r2, [pc, #16]	; (10a34 <__NVIC_DisableIRQ+0x20>)
   10a24:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   10a28:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   10a2c:	f3bf 8f6f 	isb	sy
}
   10a30:	4770      	bx	lr
   10a32:	bf00      	nop
   10a34:	e000e100 	.word	0xe000e100

00010a38 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10a38:	0943      	lsrs	r3, r0, #5
   10a3a:	2201      	movs	r2, #1
   10a3c:	f000 001f 	and.w	r0, r0, #31
   10a40:	fa02 f000 	lsl.w	r0, r2, r0
   10a44:	3360      	adds	r3, #96	; 0x60
   10a46:	4a02      	ldr	r2, [pc, #8]	; (10a50 <__NVIC_ClearPendingIRQ+0x18>)
   10a48:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   10a4c:	4770      	bx	lr
   10a4e:	bf00      	nop
   10a50:	e000e100 	.word	0xe000e100

00010a54 <_get_i2cm_index>:
{
   10a54:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10a56:	4b07      	ldr	r3, [pc, #28]	; (10a74 <_get_i2cm_index+0x20>)
   10a58:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
   10a5a:	2805      	cmp	r0, #5
   10a5c:	d008      	beq.n	10a70 <_get_i2cm_index+0x1c>
	ASSERT(false);
   10a5e:	2000      	movs	r0, #0
   10a60:	4905      	ldr	r1, [pc, #20]	; (10a78 <_get_i2cm_index+0x24>)
   10a62:	4b06      	ldr	r3, [pc, #24]	; (10a7c <_get_i2cm_index+0x28>)
   10a64:	f240 32ed 	movw	r2, #1005	; 0x3ed
   10a68:	4798      	blx	r3
   10a6a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   10a6e:	bd08      	pop	{r3, pc}
			return i;
   10a70:	2000      	movs	r0, #0
   10a72:	e7fc      	b.n	10a6e <_get_i2cm_index+0x1a>
   10a74:	00010849 	.word	0x00010849
   10a78:	00017281 	.word	0x00017281
   10a7c:	0000df45 	.word	0x0000df45

00010a80 <_sercom_i2c_send_stop>:
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10a80:	6842      	ldr	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10a82:	4b03      	ldr	r3, [pc, #12]	; (10a90 <_sercom_i2c_send_stop+0x10>)
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10a84:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
   10a88:	6042      	str	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10a8a:	2104      	movs	r1, #4
   10a8c:	4718      	bx	r3
   10a8e:	bf00      	nop
   10a90:	000107c9 	.word	0x000107c9

00010a94 <_sercom_i2c_sync_analyse_flags>:
{
   10a94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10a98:	460e      	mov	r6, r1
   10a9a:	4614      	mov	r4, r2
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10a9c:	2104      	movs	r1, #4
   10a9e:	4a56      	ldr	r2, [pc, #344]	; (10bf8 <_sercom_i2c_sync_analyse_flags+0x164>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10aa0:	f8d0 8000 	ldr.w	r8, [r0]
   10aa4:	4605      	mov	r5, r0
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10aa6:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.STATUS.reg;
   10aa8:	8b43      	ldrh	r3, [r0, #26]
	if (flags & MB_FLAG) {
   10aaa:	f016 0f01 	tst.w	r6, #1
   10aae:	b29b      	uxth	r3, r3
   10ab0:	4617      	mov	r7, r2
   10ab2:	d064      	beq.n	10b7e <_sercom_i2c_sync_analyse_flags+0xea>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
   10ab4:	079f      	lsls	r7, r3, #30
   10ab6:	d516      	bpl.n	10ae6 <_sercom_i2c_sync_analyse_flags+0x52>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
   10ab8:	2201      	movs	r2, #1
   10aba:	7602      	strb	r2, [r0, #24]
			msg->flags |= I2C_M_FAIL;
   10abc:	8862      	ldrh	r2, [r4, #2]
   10abe:	b292      	uxth	r2, r2
   10ac0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   10ac4:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
   10ac6:	8862      	ldrh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10ac8:	f003 0601 	and.w	r6, r3, #1
			msg->flags &= ~I2C_M_BUSY;
   10acc:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   10ad0:	0412      	lsls	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10ad2:	f1c6 26ff 	rsb	r6, r6, #4278255360	; 0xff00ff00
			msg->flags &= ~I2C_M_BUSY;
   10ad6:	0c12      	lsrs	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10ad8:	f506 067f 	add.w	r6, r6, #16711680	; 0xff0000
			msg->flags &= ~I2C_M_BUSY;
   10adc:	8062      	strh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10ade:	36fc      	adds	r6, #252	; 0xfc
}
   10ae0:	4630      	mov	r0, r6
   10ae2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
   10ae6:	f013 0604 	ands.w	r6, r3, #4
   10aea:	d015      	beq.n	10b18 <_sercom_i2c_sync_analyse_flags+0x84>
				if (msg->len > 0) {
   10aec:	6863      	ldr	r3, [r4, #4]
   10aee:	2b00      	cmp	r3, #0
					msg->flags |= I2C_M_FAIL;
   10af0:	bfc1      	itttt	gt
   10af2:	8863      	ldrhgt	r3, [r4, #2]
   10af4:	b29b      	uxthgt	r3, r3
   10af6:	f443 5380 	orrgt.w	r3, r3, #4096	; 0x1000
   10afa:	8063      	strhgt	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
   10afc:	8863      	ldrh	r3, [r4, #2]
   10afe:	041e      	lsls	r6, r3, #16
   10b00:	d501      	bpl.n	10b06 <_sercom_i2c_sync_analyse_flags+0x72>
					_sercom_i2c_send_stop(hw);
   10b02:	4b3e      	ldr	r3, [pc, #248]	; (10bfc <_sercom_i2c_sync_analyse_flags+0x168>)
   10b04:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10b06:	8863      	ldrh	r3, [r4, #2]
   10b08:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10b0c:	041b      	lsls	r3, r3, #16
   10b0e:	0c1b      	lsrs	r3, r3, #16
   10b10:	8063      	strh	r3, [r4, #2]
			return I2C_NACK;
   10b12:	f06f 0601 	mvn.w	r6, #1
   10b16:	e7e3      	b.n	10ae0 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->flags & I2C_M_TEN) {
   10b18:	8863      	ldrh	r3, [r4, #2]
   10b1a:	f413 6780 	ands.w	r7, r3, #1024	; 0x400
   10b1e:	d015      	beq.n	10b4c <_sercom_i2c_sync_analyse_flags+0xb8>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
   10b20:	8823      	ldrh	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b22:	2104      	movs	r1, #4
   10b24:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   10b26:	f003 0706 	and.w	r7, r3, #6
   10b2a:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   10b2c:	6a43      	ldr	r3, [r0, #36]	; 0x24
   10b2e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   10b32:	433b      	orrs	r3, r7
				hri_sercomi2cm_write_ADDR_reg(hw,
   10b34:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   10b38:	6243      	str	r3, [r0, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b3a:	2104      	movs	r1, #4
   10b3c:	4790      	blx	r2
				msg->flags &= ~I2C_M_TEN;
   10b3e:	8863      	ldrh	r3, [r4, #2]
   10b40:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
				msg->flags &= ~I2C_M_BUSY;
   10b44:	041b      	lsls	r3, r3, #16
   10b46:	0c1b      	lsrs	r3, r3, #16
   10b48:	8063      	strh	r3, [r4, #2]
   10b4a:	e7c9      	b.n	10ae0 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->len == 0) {
   10b4c:	6866      	ldr	r6, [r4, #4]
   10b4e:	b94e      	cbnz	r6, 10b64 <_sercom_i2c_sync_analyse_flags+0xd0>
				if (msg->flags & I2C_M_STOP) {
   10b50:	8863      	ldrh	r3, [r4, #2]
   10b52:	0418      	lsls	r0, r3, #16
   10b54:	d502      	bpl.n	10b5c <_sercom_i2c_sync_analyse_flags+0xc8>
					_sercom_i2c_send_stop(hw);
   10b56:	4b29      	ldr	r3, [pc, #164]	; (10bfc <_sercom_i2c_sync_analyse_flags+0x168>)
   10b58:	4628      	mov	r0, r5
   10b5a:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10b5c:	8863      	ldrh	r3, [r4, #2]
   10b5e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10b62:	e7ef      	b.n	10b44 <_sercom_i2c_sync_analyse_flags+0xb0>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
   10b64:	68a3      	ldr	r3, [r4, #8]
   10b66:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
   10b68:	6283      	str	r3, [r0, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10b6a:	2104      	movs	r1, #4
   10b6c:	4790      	blx	r2
				msg->buffer++;
   10b6e:	68a3      	ldr	r3, [r4, #8]
   10b70:	3301      	adds	r3, #1
   10b72:	60a3      	str	r3, [r4, #8]
				msg->len--;
   10b74:	6863      	ldr	r3, [r4, #4]
   10b76:	3b01      	subs	r3, #1
   10b78:	6063      	str	r3, [r4, #4]
	return I2C_OK;
   10b7a:	2600      	movs	r6, #0
}
   10b7c:	e7b0      	b.n	10ae0 <_sercom_i2c_sync_analyse_flags+0x4c>
	} else if (flags & SB_FLAG) {
   10b7e:	f016 0602 	ands.w	r6, r6, #2
   10b82:	d0ad      	beq.n	10ae0 <_sercom_i2c_sync_analyse_flags+0x4c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
   10b84:	6862      	ldr	r2, [r4, #4]
   10b86:	2a00      	cmp	r2, #0
   10b88:	d032      	beq.n	10bf0 <_sercom_i2c_sync_analyse_flags+0x15c>
   10b8a:	0759      	lsls	r1, r3, #29
   10b8c:	d430      	bmi.n	10bf0 <_sercom_i2c_sync_analyse_flags+0x15c>
			msg->len--;
   10b8e:	3a01      	subs	r2, #1
   10b90:	f3c8 61c0 	ubfx	r1, r8, #27, #1
   10b94:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   10b96:	b99a      	cbnz	r2, 10bc0 <_sercom_i2c_sync_analyse_flags+0x12c>
   10b98:	b1a9      	cbz	r1, 10bc6 <_sercom_i2c_sync_analyse_flags+0x132>
				if (msg->flags & I2C_M_STOP) {
   10b9a:	8863      	ldrh	r3, [r4, #2]
   10b9c:	041b      	lsls	r3, r3, #16
   10b9e:	d508      	bpl.n	10bb2 <_sercom_i2c_sync_analyse_flags+0x11e>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
   10ba0:	686b      	ldr	r3, [r5, #4]
   10ba2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10ba6:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10ba8:	2104      	movs	r1, #4
   10baa:	4628      	mov	r0, r5
   10bac:	47b8      	blx	r7
					_sercom_i2c_send_stop(hw);
   10bae:	4b13      	ldr	r3, [pc, #76]	; (10bfc <_sercom_i2c_sync_analyse_flags+0x168>)
   10bb0:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10bb2:	8863      	ldrh	r3, [r4, #2]
   10bb4:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10bb8:	041b      	lsls	r3, r3, #16
   10bba:	0c1b      	lsrs	r3, r3, #16
   10bbc:	8063      	strh	r3, [r4, #2]
   10bbe:	e00c      	b.n	10bda <_sercom_i2c_sync_analyse_flags+0x146>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   10bc0:	2a01      	cmp	r2, #1
   10bc2:	d10a      	bne.n	10bda <_sercom_i2c_sync_analyse_flags+0x146>
   10bc4:	b149      	cbz	r1, 10bda <_sercom_i2c_sync_analyse_flags+0x146>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   10bc6:	686b      	ldr	r3, [r5, #4]
   10bc8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   10bcc:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10bce:	2104      	movs	r1, #4
   10bd0:	4628      	mov	r0, r5
   10bd2:	47b8      	blx	r7
			if (msg->len == 0) {
   10bd4:	6863      	ldr	r3, [r4, #4]
   10bd6:	2b00      	cmp	r3, #0
   10bd8:	d0df      	beq.n	10b9a <_sercom_i2c_sync_analyse_flags+0x106>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10bda:	2104      	movs	r1, #4
   10bdc:	4628      	mov	r0, r5
   10bde:	47b8      	blx	r7
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
   10be0:	68a3      	ldr	r3, [r4, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
   10be2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   10be4:	1c59      	adds	r1, r3, #1
   10be6:	60a1      	str	r1, [r4, #8]
   10be8:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   10bea:	2302      	movs	r3, #2
   10bec:	762b      	strb	r3, [r5, #24]
   10bee:	e7c4      	b.n	10b7a <_sercom_i2c_sync_analyse_flags+0xe6>
   10bf0:	2302      	movs	r3, #2
   10bf2:	762b      	strb	r3, [r5, #24]
   10bf4:	e78d      	b.n	10b12 <_sercom_i2c_sync_analyse_flags+0x7e>
   10bf6:	bf00      	nop
   10bf8:	000107c9 	.word	0x000107c9
   10bfc:	00010a81 	.word	0x00010a81

00010c00 <_usart_set_parity>:
{
   10c00:	b573      	push	{r0, r1, r4, r5, r6, lr}
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10c02:	4b16      	ldr	r3, [pc, #88]	; (10c5c <_usart_set_parity+0x5c>)
{
   10c04:	4604      	mov	r4, r0
   10c06:	460d      	mov	r5, r1
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10c08:	4798      	blx	r3
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10c0a:	4b15      	ldr	r3, [pc, #84]	; (10c60 <_usart_set_parity+0x60>)
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   10c0c:	4606      	mov	r6, r0
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10c0e:	4620      	mov	r0, r4
   10c10:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
   10c12:	4b14      	ldr	r3, [pc, #80]	; (10c64 <_usart_set_parity+0x64>)
   10c14:	a801      	add	r0, sp, #4
   10c16:	4798      	blx	r3
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   10c18:	4a13      	ldr	r2, [pc, #76]	; (10c68 <_usart_set_parity+0x68>)
   10c1a:	4620      	mov	r0, r4
   10c1c:	2102      	movs	r1, #2
   10c1e:	4790      	blx	r2
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_FORM(mask);
   10c20:	6823      	ldr	r3, [r4, #0]
	if (USART_PARITY_NONE != parity) {
   10c22:	2d02      	cmp	r5, #2
   10c24:	bf14      	ite	ne
   10c26:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_FORM(mask);
   10c2a:	f023 7380 	biceq.w	r3, r3, #16777216	; 0x1000000
   10c2e:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10c30:	211f      	movs	r1, #31
   10c32:	4790      	blx	r2
	tmp = ((Sercom *)hw)->USART.CTRLB.reg;
   10c34:	6863      	ldr	r3, [r4, #4]
	hri_sercomusart_write_CTRLB_PMODE_bit(hw, parity);
   10c36:	3d00      	subs	r5, #0
   10c38:	bf18      	it	ne
   10c3a:	2501      	movne	r5, #1
	tmp &= ~SERCOM_USART_CTRLB_PMODE;
   10c3c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
	tmp |= value << SERCOM_USART_CTRLB_PMODE_Pos;
   10c40:	ea43 3545 	orr.w	r5, r3, r5, lsl #13
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10c44:	211f      	movs	r1, #31
	((Sercom *)hw)->USART.CTRLB.reg = tmp;
   10c46:	6065      	str	r5, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10c48:	4790      	blx	r2
	CRITICAL_SECTION_LEAVE()
   10c4a:	a801      	add	r0, sp, #4
   10c4c:	4b07      	ldr	r3, [pc, #28]	; (10c6c <_usart_set_parity+0x6c>)
   10c4e:	4798      	blx	r3
	hri_sercomusart_write_CTRLA_ENABLE_bit(hw, enabled);
   10c50:	4b07      	ldr	r3, [pc, #28]	; (10c70 <_usart_set_parity+0x70>)
   10c52:	4631      	mov	r1, r6
   10c54:	4620      	mov	r0, r4
   10c56:	4798      	blx	r3
}
   10c58:	b002      	add	sp, #8
   10c5a:	bd70      	pop	{r4, r5, r6, pc}
   10c5c:	00010809 	.word	0x00010809
   10c60:	00010835 	.word	0x00010835
   10c64:	00011a11 	.word	0x00011a11
   10c68:	000107d9 	.word	0x000107d9
   10c6c:	00011a1f 	.word	0x00011a1f
   10c70:	0001081d 	.word	0x0001081d

00010c74 <_spi_set_mode>:
{
   10c74:	b570      	push	{r4, r5, r6, lr}
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10c76:	69c4      	ldr	r4, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   10c78:	f014 0403 	ands.w	r4, r4, #3
{
   10c7c:	460a      	mov	r2, r1
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   10c7e:	d10e      	bne.n	10c9e <_spi_set_mode+0x2a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10c80:	4e08      	ldr	r6, [pc, #32]	; (10ca4 <_spi_set_mode+0x30>)
   10c82:	2103      	movs	r1, #3
   10c84:	47b0      	blx	r6
	return ((Sercom *)hw)->SPI.CTRLA.reg;
   10c86:	6803      	ldr	r3, [r0, #0]
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   10c88:	0712      	lsls	r2, r2, #28
	ctrla &= ~(SERCOM_SPI_CTRLA_CPOL | SERCOM_SPI_CTRLA_CPHA);
   10c8a:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   10c8e:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
   10c92:	431a      	orrs	r2, r3
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   10c94:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10c96:	2103      	movs	r1, #3
   10c98:	47b0      	blx	r6
	return ERR_NONE;
   10c9a:	4620      	mov	r0, r4
}
   10c9c:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
   10c9e:	f06f 0003 	mvn.w	r0, #3
   10ca2:	e7fb      	b.n	10c9c <_spi_set_mode+0x28>
   10ca4:	000107d1 	.word	0x000107d1

00010ca8 <_spi_load_regs_master>:
{
   10ca8:	b538      	push	{r3, r4, r5, lr}
   10caa:	460d      	mov	r5, r1
	ASSERT(hw && regs);
   10cac:	4604      	mov	r4, r0
   10cae:	b110      	cbz	r0, 10cb6 <_spi_load_regs_master+0xe>
   10cb0:	1e08      	subs	r0, r1, #0
   10cb2:	bf18      	it	ne
   10cb4:	2001      	movne	r0, #1
   10cb6:	490f      	ldr	r1, [pc, #60]	; (10cf4 <_spi_load_regs_master+0x4c>)
   10cb8:	4b0f      	ldr	r3, [pc, #60]	; (10cf8 <_spi_load_regs_master+0x50>)
   10cba:	f640 127a 	movw	r2, #2426	; 0x97a
   10cbe:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   10cc0:	682b      	ldr	r3, [r5, #0]
   10cc2:	4a0e      	ldr	r2, [pc, #56]	; (10cfc <_spi_load_regs_master+0x54>)
	hri_sercomspi_write_CTRLA_reg(
   10cc4:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   10cc8:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   10ccc:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10cce:	2103      	movs	r1, #3
   10cd0:	4620      	mov	r0, r4
   10cd2:	4790      	blx	r2
	    (regs->ctrlb
   10cd4:	686b      	ldr	r3, [r5, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
   10cd6:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
   10cda:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
   10cde:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   10ce2:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   10ce4:	2117      	movs	r1, #23
   10ce6:	4790      	blx	r2
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
   10ce8:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
   10cea:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   10cec:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   10cee:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
   10cf2:	bd38      	pop	{r3, r4, r5, pc}
   10cf4:	00017281 	.word	0x00017281
   10cf8:	0000df45 	.word	0x0000df45
   10cfc:	000107d1 	.word	0x000107d1

00010d00 <_i2c_m_sync_init_impl>:
{
   10d00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   10d04:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
   10d06:	4b23      	ldr	r3, [pc, #140]	; (10d94 <_i2c_m_sync_init_impl+0x94>)
   10d08:	f8df 9094 	ldr.w	r9, [pc, #148]	; 10da0 <_i2c_m_sync_init_impl+0xa0>
   10d0c:	4d22      	ldr	r5, [pc, #136]	; (10d98 <_i2c_m_sync_init_impl+0x98>)
{
   10d0e:	4607      	mov	r7, r0
	uint8_t i = _get_i2cm_index(hw);
   10d10:	4608      	mov	r0, r1
   10d12:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
   10d14:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
   10d16:	f013 0f01 	tst.w	r3, #1
   10d1a:	fa5f f880 	uxtb.w	r8, r0
   10d1e:	d115      	bne.n	10d4c <_i2c_m_sync_init_impl+0x4c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   10d20:	2318      	movs	r3, #24
   10d22:	fb03 9308 	mla	r3, r3, r8, r9
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10d26:	2103      	movs	r1, #3
   10d28:	4620      	mov	r0, r4
   10d2a:	6c9e      	ldr	r6, [r3, #72]	; 0x48
   10d2c:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10d2e:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   10d30:	079b      	lsls	r3, r3, #30
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   10d32:	f006 061c 	and.w	r6, r6, #28
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   10d36:	d503      	bpl.n	10d40 <_i2c_m_sync_init_impl+0x40>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
   10d38:	4b18      	ldr	r3, [pc, #96]	; (10d9c <_i2c_m_sync_init_impl+0x9c>)
   10d3a:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
   10d3c:	2102      	movs	r1, #2
   10d3e:	47a8      	blx	r5
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
   10d40:	f046 0601 	orr.w	r6, r6, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   10d44:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10d46:	2103      	movs	r1, #3
   10d48:	4620      	mov	r0, r4
   10d4a:	47a8      	blx	r5
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
   10d4c:	4620      	mov	r0, r4
   10d4e:	2101      	movs	r1, #1
   10d50:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
   10d52:	2218      	movs	r2, #24
   10d54:	fb02 9208 	mla	r2, r2, r8, r9
   10d58:	2103      	movs	r1, #3
   10d5a:	6c96      	ldr	r6, [r2, #72]	; 0x48
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   10d5c:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10d5e:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
   10d60:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
   10d62:	6063      	str	r3, [r4, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10d64:	2104      	movs	r1, #4
   10d66:	47a8      	blx	r5
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
   10d68:	6d13      	ldr	r3, [r2, #80]	; 0x50
	((Sercom *)hw)->I2CM.BAUD.reg = data;
   10d6a:	60e3      	str	r3, [r4, #12]
	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
   10d6c:	f3c6 6301 	ubfx	r3, r6, #24, #2
   10d70:	81bb      	strh	r3, [r7, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
   10d72:	6a63      	ldr	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
   10d74:	f3c6 6640 	ubfx	r6, r6, #25, #1
	tmp &= ~SERCOM_I2CM_ADDR_HS;
   10d78:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
   10d7c:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
   10d80:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10d82:	2104      	movs	r1, #4
   10d84:	47a8      	blx	r5
	service->trise = _i2cms[i].trise;
   10d86:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
   10d8a:	81fb      	strh	r3, [r7, #14]
}
   10d8c:	2000      	movs	r0, #0
   10d8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   10d92:	bf00      	nop
   10d94:	00010a55 	.word	0x00010a55
   10d98:	000107c9 	.word	0x000107c9
   10d9c:	000107e1 	.word	0x000107e1
   10da0:	0001729c 	.word	0x0001729c

00010da4 <_usart_init>:
{
   10da4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10da8:	4b2d      	ldr	r3, [pc, #180]	; (10e60 <_usart_init+0xbc>)
{
   10daa:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10dac:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
   10dae:	4605      	mov	r5, r0
   10db0:	b170      	cbz	r0, 10dd0 <_usart_init+0x2c>
   10db2:	2801      	cmp	r0, #1
   10db4:	d00c      	beq.n	10dd0 <_usart_init+0x2c>
   10db6:	2802      	cmp	r0, #2
   10db8:	d00a      	beq.n	10dd0 <_usart_init+0x2c>
   10dba:	2804      	cmp	r0, #4
   10dbc:	d04b      	beq.n	10e56 <_usart_init+0xb2>
   10dbe:	2806      	cmp	r0, #6
   10dc0:	d04b      	beq.n	10e5a <_usart_init+0xb6>
	ASSERT(false);
   10dc2:	4928      	ldr	r1, [pc, #160]	; (10e64 <_usart_init+0xc0>)
   10dc4:	4b28      	ldr	r3, [pc, #160]	; (10e68 <_usart_init+0xc4>)
   10dc6:	f240 2276 	movw	r2, #630	; 0x276
   10dca:	2000      	movs	r0, #0
   10dcc:	4798      	blx	r3
	return 0;
   10dce:	2500      	movs	r5, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
   10dd0:	69e3      	ldr	r3, [r4, #28]
   10dd2:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 10e74 <_usart_init+0xd0>
   10dd6:	4e25      	ldr	r6, [pc, #148]	; (10e6c <_usart_init+0xc8>)
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
   10dd8:	f013 0f01 	tst.w	r3, #1
   10ddc:	d115      	bne.n	10e0a <_usart_init+0x66>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   10dde:	2318      	movs	r3, #24
   10de0:	fb03 8305 	mla	r3, r3, r5, r8
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10de4:	2103      	movs	r1, #3
   10de6:	4620      	mov	r0, r4
   10de8:	6e1f      	ldr	r7, [r3, #96]	; 0x60
   10dea:	47b0      	blx	r6
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10dec:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   10dee:	079b      	lsls	r3, r3, #30
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   10df0:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   10df4:	d503      	bpl.n	10dfe <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   10df6:	4b1e      	ldr	r3, [pc, #120]	; (10e70 <_usart_init+0xcc>)
   10df8:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   10dfa:	2102      	movs	r1, #2
   10dfc:	47b0      	blx	r6
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
   10dfe:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
   10e02:	6027      	str	r7, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10e04:	2103      	movs	r1, #3
   10e06:	4620      	mov	r0, r4
   10e08:	47b0      	blx	r6
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
   10e0a:	2101      	movs	r1, #1
   10e0c:	4620      	mov	r0, r4
   10e0e:	47b0      	blx	r6
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
   10e10:	2018      	movs	r0, #24
   10e12:	fb00 8505 	mla	r5, r0, r5, r8
   10e16:	2103      	movs	r1, #3
   10e18:	6e2a      	ldr	r2, [r5, #96]	; 0x60
	((Sercom *)hw)->USART.CTRLA.reg = data;
   10e1a:	6022      	str	r2, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10e1c:	4620      	mov	r0, r4
   10e1e:	47b0      	blx	r6
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
   10e20:	6e6b      	ldr	r3, [r5, #100]	; 0x64
	((Sercom *)hw)->USART.CTRLB.reg = data;
   10e22:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   10e24:	211f      	movs	r1, #31
   10e26:	47b0      	blx	r6
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
   10e28:	6eab      	ldr	r3, [r5, #104]	; 0x68
	((Sercom *)hw)->USART.CTRLC.reg = data;
   10e2a:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
   10e2c:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
   10e30:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
   10e34:	d008      	beq.n	10e48 <_usart_init+0xa4>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
   10e36:	89a2      	ldrh	r2, [r4, #12]
   10e38:	f363 020c 	bfi	r2, r3, #0, #13
   10e3c:	81a2      	strh	r2, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
   10e3e:	89a3      	ldrh	r3, [r4, #12]
   10e40:	f895 206e 	ldrb.w	r2, [r5, #110]	; 0x6e
   10e44:	f362 334f 	bfi	r3, r2, #13, #3
	((Sercom *)hw)->USART.RXPL.reg = data;
   10e48:	2000      	movs	r0, #0
	((Sercom *)hw)->USART.BAUD.reg = data;
   10e4a:	81a3      	strh	r3, [r4, #12]
	((Sercom *)hw)->USART.RXPL.reg = data;
   10e4c:	73a0      	strb	r0, [r4, #14]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
   10e4e:	f884 0030 	strb.w	r0, [r4, #48]	; 0x30
}
   10e52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
   10e56:	2503      	movs	r5, #3
   10e58:	e7ba      	b.n	10dd0 <_usart_init+0x2c>
   10e5a:	2504      	movs	r5, #4
   10e5c:	e7b8      	b.n	10dd0 <_usart_init+0x2c>
   10e5e:	bf00      	nop
   10e60:	00010849 	.word	0x00010849
   10e64:	00017281 	.word	0x00017281
   10e68:	0000df45 	.word	0x0000df45
   10e6c:	000107d9 	.word	0x000107d9
   10e70:	00010835 	.word	0x00010835
   10e74:	0001729c 	.word	0x0001729c

00010e78 <_usart_sync_init>:
{
   10e78:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   10e7a:	4605      	mov	r5, r0
   10e7c:	3800      	subs	r0, #0
{
   10e7e:	460c      	mov	r4, r1
	ASSERT(device);
   10e80:	4b05      	ldr	r3, [pc, #20]	; (10e98 <_usart_sync_init+0x20>)
   10e82:	4906      	ldr	r1, [pc, #24]	; (10e9c <_usart_sync_init+0x24>)
   10e84:	bf18      	it	ne
   10e86:	2001      	movne	r0, #1
   10e88:	22c8      	movs	r2, #200	; 0xc8
   10e8a:	4798      	blx	r3
	device->hw = hw;
   10e8c:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
   10e8e:	4620      	mov	r0, r4
   10e90:	4b03      	ldr	r3, [pc, #12]	; (10ea0 <_usart_sync_init+0x28>)
}
   10e92:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
   10e96:	4718      	bx	r3
   10e98:	0000df45 	.word	0x0000df45
   10e9c:	00017281 	.word	0x00017281
   10ea0:	00010da5 	.word	0x00010da5

00010ea4 <_usart_async_init>:
{
   10ea4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(device);
   10ea8:	4606      	mov	r6, r0
   10eaa:	3800      	subs	r0, #0
   10eac:	bf18      	it	ne
   10eae:	2001      	movne	r0, #1
   10eb0:	4b12      	ldr	r3, [pc, #72]	; (10efc <_usart_async_init+0x58>)
{
   10eb2:	460c      	mov	r4, r1
	ASSERT(device);
   10eb4:	22d6      	movs	r2, #214	; 0xd6
   10eb6:	4912      	ldr	r1, [pc, #72]	; (10f00 <_usart_async_init+0x5c>)
   10eb8:	4798      	blx	r3
	init_status = _usart_init(hw);
   10eba:	4b12      	ldr	r3, [pc, #72]	; (10f04 <_usart_async_init+0x60>)
   10ebc:	4620      	mov	r0, r4
   10ebe:	4798      	blx	r3
	if (init_status) {
   10ec0:	4605      	mov	r5, r0
   10ec2:	b9b8      	cbnz	r0, 10ef4 <_usart_async_init+0x50>
	_sercom_init_irq_param(hw, (void *)device);
   10ec4:	4631      	mov	r1, r6
	device->hw = hw;
   10ec6:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
   10ec8:	4620      	mov	r0, r4
   10eca:	4b0f      	ldr	r3, [pc, #60]	; (10f08 <_usart_async_init+0x64>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   10ecc:	f8df 8048 	ldr.w	r8, [pc, #72]	; 10f18 <_usart_async_init+0x74>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   10ed0:	4f0e      	ldr	r7, [pc, #56]	; (10f0c <_usart_async_init+0x68>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   10ed2:	4e0f      	ldr	r6, [pc, #60]	; (10f10 <_usart_async_init+0x6c>)
	_sercom_init_irq_param(hw, (void *)device);
   10ed4:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   10ed6:	4b0f      	ldr	r3, [pc, #60]	; (10f14 <_usart_async_init+0x70>)
   10ed8:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   10eda:	4629      	mov	r1, r5
	uint8_t irq = _sercom_get_irq_num(hw);
   10edc:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   10ede:	1863      	adds	r3, r4, r1
   10ee0:	b2d8      	uxtb	r0, r3
   10ee2:	9001      	str	r0, [sp, #4]
   10ee4:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   10ee6:	9801      	ldr	r0, [sp, #4]
   10ee8:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   10eea:	9801      	ldr	r0, [sp, #4]
   10eec:	47b0      	blx	r6
	for (uint32_t i = 0; i < 4; i++) {
   10eee:	3101      	adds	r1, #1
   10ef0:	2904      	cmp	r1, #4
   10ef2:	d1f4      	bne.n	10ede <_usart_async_init+0x3a>
}
   10ef4:	4628      	mov	r0, r5
   10ef6:	b002      	add	sp, #8
   10ef8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   10efc:	0000df45 	.word	0x0000df45
   10f00:	00017281 	.word	0x00017281
   10f04:	00010da5 	.word	0x00010da5
   10f08:	000108f1 	.word	0x000108f1
   10f0c:	00010a39 	.word	0x00010a39
   10f10:	000109cd 	.word	0x000109cd
   10f14:	00010951 	.word	0x00010951
   10f18:	00010a15 	.word	0x00010a15

00010f1c <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   10f1c:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   10f1e:	6803      	ldr	r3, [r0, #0]
   10f20:	f043 0302 	orr.w	r3, r3, #2
   10f24:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10f26:	2103      	movs	r1, #3
   10f28:	4b00      	ldr	r3, [pc, #0]	; (10f2c <_usart_sync_enable+0x10>)
   10f2a:	4718      	bx	r3
   10f2c:	000107d9 	.word	0x000107d9

00010f30 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   10f30:	6980      	ldr	r0, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   10f32:	6803      	ldr	r3, [r0, #0]
   10f34:	f043 0302 	orr.w	r3, r3, #2
   10f38:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10f3a:	2103      	movs	r1, #3
   10f3c:	4b00      	ldr	r3, [pc, #0]	; (10f40 <_usart_async_enable+0x10>)
   10f3e:	4718      	bx	r3
   10f40:	000107d9 	.word	0x000107d9

00010f44 <_usart_async_disable>:
	hri_sercomusart_clear_CTRLA_ENABLE_bit(device->hw);
   10f44:	6980      	ldr	r0, [r0, #24]
   10f46:	4b01      	ldr	r3, [pc, #4]	; (10f4c <_usart_async_disable+0x8>)
   10f48:	4718      	bx	r3
   10f4a:	bf00      	nop
   10f4c:	00010835 	.word	0x00010835

00010f50 <_usart_async_set_parity>:
	_usart_set_parity(device->hw, parity);
   10f50:	6980      	ldr	r0, [r0, #24]
   10f52:	4b01      	ldr	r3, [pc, #4]	; (10f58 <_usart_async_set_parity+0x8>)
   10f54:	4718      	bx	r3
   10f56:	bf00      	nop
   10f58:	00010c01 	.word	0x00010c01

00010f5c <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   10f5c:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
   10f5e:	6299      	str	r1, [r3, #40]	; 0x28
}
   10f60:	4770      	bx	lr

00010f62 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   10f62:	6983      	ldr	r3, [r0, #24]
   10f64:	6299      	str	r1, [r3, #40]	; 0x28
}
   10f66:	4770      	bx	lr

00010f68 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
   10f68:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
   10f6a:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   10f6c:	b2c0      	uxtb	r0, r0
   10f6e:	4770      	bx	lr

00010f70 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
   10f70:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   10f72:	7e18      	ldrb	r0, [r3, #24]
}
   10f74:	f000 0001 	and.w	r0, r0, #1
   10f78:	4770      	bx	lr

00010f7a <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
   10f7a:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   10f7c:	7e18      	ldrb	r0, [r3, #24]
}
   10f7e:	f3c0 0040 	ubfx	r0, r0, #1, #1
   10f82:	4770      	bx	lr

00010f84 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
   10f84:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   10f86:	7e18      	ldrb	r0, [r3, #24]
}
   10f88:	f3c0 0080 	ubfx	r0, r0, #2, #1
   10f8c:	4770      	bx	lr

00010f8e <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
   10f8e:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   10f90:	2201      	movs	r2, #1
   10f92:	759a      	strb	r2, [r3, #22]
}
   10f94:	4770      	bx	lr

00010f96 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
   10f96:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
   10f98:	2202      	movs	r2, #2
   10f9a:	759a      	strb	r2, [r3, #22]
}
   10f9c:	4770      	bx	lr
	...

00010fa0 <_usart_async_set_irq_state>:
{
   10fa0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   10fa2:	4604      	mov	r4, r0
   10fa4:	3800      	subs	r0, #0
{
   10fa6:	460e      	mov	r6, r1
	ASSERT(device);
   10fa8:	bf18      	it	ne
   10faa:	2001      	movne	r0, #1
   10fac:	490f      	ldr	r1, [pc, #60]	; (10fec <_usart_async_set_irq_state+0x4c>)
   10fae:	4b10      	ldr	r3, [pc, #64]	; (10ff0 <_usart_async_set_irq_state+0x50>)
{
   10fb0:	4615      	mov	r5, r2
	ASSERT(device);
   10fb2:	f240 2236 	movw	r2, #566	; 0x236
   10fb6:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
   10fb8:	f016 0ffd 	tst.w	r6, #253	; 0xfd
   10fbc:	d109      	bne.n	10fd2 <_usart_async_set_irq_state+0x32>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
   10fbe:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   10fc0:	2101      	movs	r1, #1
   10fc2:	2202      	movs	r2, #2
   10fc4:	b915      	cbnz	r5, 10fcc <_usart_async_set_irq_state+0x2c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   10fc6:	7519      	strb	r1, [r3, #20]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
   10fc8:	751a      	strb	r2, [r3, #20]
}
   10fca:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   10fcc:	7599      	strb	r1, [r3, #22]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
   10fce:	759a      	strb	r2, [r3, #22]
   10fd0:	e7fb      	b.n	10fca <_usart_async_set_irq_state+0x2a>
	} else if (USART_ASYNC_RX_DONE == type) {
   10fd2:	2e01      	cmp	r6, #1
   10fd4:	d104      	bne.n	10fe0 <_usart_async_set_irq_state+0x40>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
   10fd6:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   10fd8:	2204      	movs	r2, #4
	if (value == 0x0) {
   10fda:	2d00      	cmp	r5, #0
   10fdc:	d1f7      	bne.n	10fce <_usart_async_set_irq_state+0x2e>
   10fde:	e7f3      	b.n	10fc8 <_usart_async_set_irq_state+0x28>
	} else if (USART_ASYNC_ERROR == type) {
   10fe0:	2e03      	cmp	r6, #3
   10fe2:	d1f2      	bne.n	10fca <_usart_async_set_irq_state+0x2a>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
   10fe4:	69a3      	ldr	r3, [r4, #24]
   10fe6:	2280      	movs	r2, #128	; 0x80
   10fe8:	e7f7      	b.n	10fda <_usart_async_set_irq_state+0x3a>
   10fea:	bf00      	nop
   10fec:	00017281 	.word	0x00017281
   10ff0:	0000df45 	.word	0x0000df45

00010ff4 <_i2c_m_async_init>:
{
   10ff4:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   10ff8:	4605      	mov	r5, r0
   10ffa:	3800      	subs	r0, #0
{
   10ffc:	460c      	mov	r4, r1
	ASSERT(i2c_dev);
   10ffe:	bf18      	it	ne
   11000:	2001      	movne	r0, #1
   11002:	4913      	ldr	r1, [pc, #76]	; (11050 <_i2c_m_async_init+0x5c>)
   11004:	4b13      	ldr	r3, [pc, #76]	; (11054 <_i2c_m_async_init+0x60>)
   11006:	f240 42d3 	movw	r2, #1235	; 0x4d3
   1100a:	4798      	blx	r3
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   1100c:	4b12      	ldr	r3, [pc, #72]	; (11058 <_i2c_m_async_init+0x64>)
	i2c_dev->hw = hw;
   1100e:	612c      	str	r4, [r5, #16]
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11010:	4621      	mov	r1, r4
   11012:	4628      	mov	r0, r5
   11014:	4798      	blx	r3
	if (init_status) {
   11016:	4606      	mov	r6, r0
   11018:	b9b0      	cbnz	r0, 11048 <_i2c_m_async_init+0x54>
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   1101a:	4629      	mov	r1, r5
   1101c:	4620      	mov	r0, r4
   1101e:	4b0f      	ldr	r3, [pc, #60]	; (1105c <_i2c_m_async_init+0x68>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11020:	f8df 8048 	ldr.w	r8, [pc, #72]	; 1106c <_i2c_m_async_init+0x78>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11024:	4f0e      	ldr	r7, [pc, #56]	; (11060 <_i2c_m_async_init+0x6c>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   11026:	4d0f      	ldr	r5, [pc, #60]	; (11064 <_i2c_m_async_init+0x70>)
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11028:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   1102a:	4b0f      	ldr	r3, [pc, #60]	; (11068 <_i2c_m_async_init+0x74>)
   1102c:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   1102e:	4631      	mov	r1, r6
	uint8_t irq = _sercom_get_irq_num(hw);
   11030:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11032:	1863      	adds	r3, r4, r1
   11034:	b2d8      	uxtb	r0, r3
   11036:	9001      	str	r0, [sp, #4]
   11038:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1103a:	9801      	ldr	r0, [sp, #4]
   1103c:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   1103e:	9801      	ldr	r0, [sp, #4]
   11040:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   11042:	3101      	adds	r1, #1
   11044:	2904      	cmp	r1, #4
   11046:	d1f4      	bne.n	11032 <_i2c_m_async_init+0x3e>
}
   11048:	4630      	mov	r0, r6
   1104a:	b002      	add	sp, #8
   1104c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11050:	00017281 	.word	0x00017281
   11054:	0000df45 	.word	0x0000df45
   11058:	00010d01 	.word	0x00010d01
   1105c:	000108f1 	.word	0x000108f1
   11060:	00010a39 	.word	0x00010a39
   11064:	000109cd 	.word	0x000109cd
   11068:	00010951 	.word	0x00010951
   1106c:	00010a15 	.word	0x00010a15

00011070 <_i2c_m_async_transfer>:
{
   11070:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   11074:	4604      	mov	r4, r0
   11076:	3800      	subs	r0, #0
   11078:	4e3c      	ldr	r6, [pc, #240]	; (1116c <_i2c_m_async_transfer+0xfc>)
{
   1107a:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
   1107c:	bf18      	it	ne
   1107e:	2001      	movne	r0, #1
   11080:	493b      	ldr	r1, [pc, #236]	; (11170 <_i2c_m_async_transfer+0x100>)
   11082:	f240 5229 	movw	r2, #1321	; 0x529
   11086:	47b0      	blx	r6
	ASSERT(i2c_dev->hw);
   11088:	6920      	ldr	r0, [r4, #16]
   1108a:	4939      	ldr	r1, [pc, #228]	; (11170 <_i2c_m_async_transfer+0x100>)
   1108c:	3800      	subs	r0, #0
   1108e:	f240 522a 	movw	r2, #1322	; 0x52a
   11092:	bf18      	it	ne
   11094:	2001      	movne	r0, #1
   11096:	47b0      	blx	r6
	ASSERT(msg);
   11098:	1e28      	subs	r0, r5, #0
   1109a:	bf18      	it	ne
   1109c:	2001      	movne	r0, #1
   1109e:	4934      	ldr	r1, [pc, #208]	; (11170 <_i2c_m_async_transfer+0x100>)
   110a0:	f240 522b 	movw	r2, #1323	; 0x52b
   110a4:	47b0      	blx	r6
	if (msg->len == 0) {
   110a6:	6868      	ldr	r0, [r5, #4]
   110a8:	2800      	cmp	r0, #0
   110aa:	d048      	beq.n	1113e <_i2c_m_async_transfer+0xce>
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
   110ac:	8863      	ldrh	r3, [r4, #2]
   110ae:	05da      	lsls	r2, r3, #23
   110b0:	d458      	bmi.n	11164 <_i2c_m_async_transfer+0xf4>
	msg->flags |= I2C_M_BUSY;
   110b2:	886b      	ldrh	r3, [r5, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   110b4:	4f2f      	ldr	r7, [pc, #188]	; (11174 <_i2c_m_async_transfer+0x104>)
   110b6:	b29b      	uxth	r3, r3
   110b8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   110bc:	806b      	strh	r3, [r5, #2]
	i2c_dev->service.msg = *msg;
   110be:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   110c2:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(i2c_dev->hw);
   110c6:	6920      	ldr	r0, [r4, #16]
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
   110c8:	6843      	ldr	r3, [r0, #4]
   110ca:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   110ce:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   110d0:	2104      	movs	r1, #4
   110d2:	47b8      	blx	r7
	void *             hw    = i2c_dev->hw;
   110d4:	6925      	ldr	r5, [r4, #16]
	ASSERT(i2c_dev);
   110d6:	4926      	ldr	r1, [pc, #152]	; (11170 <_i2c_m_async_transfer+0x100>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   110d8:	f8d5 8000 	ldr.w	r8, [r5]
   110dc:	f240 5201 	movw	r2, #1281	; 0x501
   110e0:	2001      	movs	r0, #1
   110e2:	47b0      	blx	r6
	if (msg->len == 1 && sclsm) {
   110e4:	6863      	ldr	r3, [r4, #4]
   110e6:	2b01      	cmp	r3, #1
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   110e8:	686b      	ldr	r3, [r5, #4]
   110ea:	d12a      	bne.n	11142 <_i2c_m_async_transfer+0xd2>
   110ec:	f018 6f00 	tst.w	r8, #134217728	; 0x8000000
   110f0:	d027      	beq.n	11142 <_i2c_m_async_transfer+0xd2>
   110f2:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   110f6:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   110f8:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   110fa:	2104      	movs	r1, #4
   110fc:	47b8      	blx	r7
	if (msg->addr & I2C_M_TEN) {
   110fe:	8820      	ldrh	r0, [r4, #0]
   11100:	f410 6680 	ands.w	r6, r0, #1024	; 0x400
   11104:	ea4f 0240 	mov.w	r2, r0, lsl #1
   11108:	d01e      	beq.n	11148 <_i2c_m_async_transfer+0xd8>
		if (msg->flags & I2C_M_RD) {
   1110a:	8863      	ldrh	r3, [r4, #2]
   1110c:	07db      	lsls	r3, r3, #31
			msg->flags |= I2C_M_TEN;
   1110e:	bf41      	itttt	mi
   11110:	8863      	ldrhmi	r3, [r4, #2]
   11112:	b29b      	uxthmi	r3, r3
   11114:	f443 6380 	orrmi.w	r3, r3, #1024	; 0x400
   11118:	8063      	strhmi	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1111a:	2104      	movs	r1, #4
   1111c:	4628      	mov	r0, r5
   1111e:	47b8      	blx	r7
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11120:	6a6b      	ldr	r3, [r5, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   11122:	f022 0201 	bic.w	r2, r2, #1
   11126:	0552      	lsls	r2, r2, #21
   11128:	0d52      	lsrs	r2, r2, #21
   1112a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   1112e:	431a      	orrs	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
   11130:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11134:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   11136:	626a      	str	r2, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11138:	2104      	movs	r1, #4
   1113a:	47b8      	blx	r7
	return ERR_NONE;
   1113c:	2000      	movs	r0, #0
}
   1113e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   11142:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
   11146:	e7d6      	b.n	110f6 <_i2c_m_async_transfer+0x86>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11148:	2104      	movs	r1, #4
   1114a:	4628      	mov	r0, r5
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
   1114c:	8864      	ldrh	r4, [r4, #2]
   1114e:	47b8      	blx	r7
   11150:	b2a4      	uxth	r4, r4
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11152:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   11154:	b2d2      	uxtb	r2, r2
   11156:	f004 0401 	and.w	r4, r4, #1
   1115a:	4322      	orrs	r2, r4
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   1115c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
   11160:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   11162:	e7e7      	b.n	11134 <_i2c_m_async_transfer+0xc4>
		return ERR_BUSY;
   11164:	f06f 0003 	mvn.w	r0, #3
   11168:	e7e9      	b.n	1113e <_i2c_m_async_transfer+0xce>
   1116a:	bf00      	nop
   1116c:	0000df45 	.word	0x0000df45
   11170:	00017281 	.word	0x00017281
   11174:	000107c9 	.word	0x000107c9

00011178 <_i2c_m_async_register_callback>:
	switch (type) {
   11178:	2901      	cmp	r1, #1
   1117a:	d005      	beq.n	11188 <_i2c_m_async_register_callback+0x10>
   1117c:	2902      	cmp	r1, #2
   1117e:	d005      	beq.n	1118c <_i2c_m_async_register_callback+0x14>
   11180:	b901      	cbnz	r1, 11184 <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.error = (_i2c_error_cb_t)func;
   11182:	6142      	str	r2, [r0, #20]
}
   11184:	2000      	movs	r0, #0
   11186:	4770      	bx	lr
		i2c_dev->cb.tx_complete = (_i2c_complete_cb_t)func;
   11188:	6182      	str	r2, [r0, #24]
		break;
   1118a:	e7fb      	b.n	11184 <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.rx_complete = (_i2c_complete_cb_t)func;
   1118c:	61c2      	str	r2, [r0, #28]
		break;
   1118e:	e7f9      	b.n	11184 <_i2c_m_async_register_callback+0xc>

00011190 <SERCOM0_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom0_dev);
   11190:	4b01      	ldr	r3, [pc, #4]	; (11198 <SERCOM0_0_Handler+0x8>)
   11192:	6818      	ldr	r0, [r3, #0]
   11194:	4b01      	ldr	r3, [pc, #4]	; (1119c <SERCOM0_0_Handler+0xc>)
   11196:	4718      	bx	r3
   11198:	200019b8 	.word	0x200019b8
   1119c:	00010881 	.word	0x00010881

000111a0 <SERCOM0_1_Handler>:
   111a0:	4b00      	ldr	r3, [pc, #0]	; (111a4 <SERCOM0_1_Handler+0x4>)
   111a2:	4718      	bx	r3
   111a4:	00011191 	.word	0x00011191

000111a8 <SERCOM0_2_Handler>:
   111a8:	4b00      	ldr	r3, [pc, #0]	; (111ac <SERCOM0_2_Handler+0x4>)
   111aa:	4718      	bx	r3
   111ac:	00011191 	.word	0x00011191

000111b0 <SERCOM0_3_Handler>:
   111b0:	4b00      	ldr	r3, [pc, #0]	; (111b4 <SERCOM0_3_Handler+0x4>)
   111b2:	4718      	bx	r3
   111b4:	00011191 	.word	0x00011191

000111b8 <SERCOM1_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom1_dev);
   111b8:	4b01      	ldr	r3, [pc, #4]	; (111c0 <SERCOM1_0_Handler+0x8>)
   111ba:	6858      	ldr	r0, [r3, #4]
   111bc:	4b01      	ldr	r3, [pc, #4]	; (111c4 <SERCOM1_0_Handler+0xc>)
   111be:	4718      	bx	r3
   111c0:	200019b8 	.word	0x200019b8
   111c4:	00010881 	.word	0x00010881

000111c8 <SERCOM1_1_Handler>:
   111c8:	4b00      	ldr	r3, [pc, #0]	; (111cc <SERCOM1_1_Handler+0x4>)
   111ca:	4718      	bx	r3
   111cc:	000111b9 	.word	0x000111b9

000111d0 <SERCOM1_2_Handler>:
   111d0:	4b00      	ldr	r3, [pc, #0]	; (111d4 <SERCOM1_2_Handler+0x4>)
   111d2:	4718      	bx	r3
   111d4:	000111b9 	.word	0x000111b9

000111d8 <SERCOM1_3_Handler>:
   111d8:	4b00      	ldr	r3, [pc, #0]	; (111dc <SERCOM1_3_Handler+0x4>)
   111da:	4718      	bx	r3
   111dc:	000111b9 	.word	0x000111b9

000111e0 <SERCOM3_0_Handler>:
	_spi_handler(_sercom3_dev);
   111e0:	4b0f      	ldr	r3, [pc, #60]	; (11220 <SERCOM3_0_Handler+0x40>)
   111e2:	6898      	ldr	r0, [r3, #8]
	void *                      hw = dev->prvt;
   111e4:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
   111e6:	7e13      	ldrb	r3, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
   111e8:	7d91      	ldrb	r1, [r2, #22]
	st &= hri_sercomspi_read_INTEN_reg(hw);
   111ea:	400b      	ands	r3, r1
	if (st & SERCOM_SPI_INTFLAG_DRE) {
   111ec:	07d9      	lsls	r1, r3, #31
   111ee:	d501      	bpl.n	111f4 <SERCOM3_0_Handler+0x14>
		dev->callbacks.tx(dev);
   111f0:	6883      	ldr	r3, [r0, #8]
		dev->callbacks.rx(dev);
   111f2:	4718      	bx	r3
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
   111f4:	0759      	lsls	r1, r3, #29
   111f6:	d501      	bpl.n	111fc <SERCOM3_0_Handler+0x1c>
		dev->callbacks.rx(dev);
   111f8:	68c3      	ldr	r3, [r0, #12]
   111fa:	e7fa      	b.n	111f2 <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
   111fc:	0799      	lsls	r1, r3, #30
   111fe:	d503      	bpl.n	11208 <SERCOM3_0_Handler+0x28>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11200:	2302      	movs	r3, #2
   11202:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
   11204:	6903      	ldr	r3, [r0, #16]
   11206:	e7f4      	b.n	111f2 <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
   11208:	061b      	lsls	r3, r3, #24
   1120a:	d507      	bpl.n	1121c <SERCOM3_0_Handler+0x3c>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
   1120c:	2304      	movs	r3, #4
   1120e:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11210:	2380      	movs	r3, #128	; 0x80
   11212:	7613      	strb	r3, [r2, #24]
		dev->callbacks.err(dev, ERR_OVERFLOW);
   11214:	f06f 0112 	mvn.w	r1, #18
   11218:	6943      	ldr	r3, [r0, #20]
   1121a:	4718      	bx	r3
}
   1121c:	4770      	bx	lr
   1121e:	bf00      	nop
   11220:	200019b8 	.word	0x200019b8

00011224 <SERCOM3_1_Handler>:
   11224:	4b00      	ldr	r3, [pc, #0]	; (11228 <SERCOM3_1_Handler+0x4>)
   11226:	4718      	bx	r3
   11228:	000111e1 	.word	0x000111e1

0001122c <SERCOM3_2_Handler>:
   1122c:	4b00      	ldr	r3, [pc, #0]	; (11230 <SERCOM3_2_Handler+0x4>)
   1122e:	4718      	bx	r3
   11230:	000111e1 	.word	0x000111e1

00011234 <SERCOM3_3_Handler>:
   11234:	4b00      	ldr	r3, [pc, #0]	; (11238 <SERCOM3_3_Handler+0x4>)
   11236:	4718      	bx	r3
   11238:	000111e1 	.word	0x000111e1

0001123c <SERCOM4_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom4_dev);
   1123c:	4b01      	ldr	r3, [pc, #4]	; (11244 <SERCOM4_0_Handler+0x8>)
   1123e:	68d8      	ldr	r0, [r3, #12]
   11240:	4b01      	ldr	r3, [pc, #4]	; (11248 <SERCOM4_0_Handler+0xc>)
   11242:	4718      	bx	r3
   11244:	200019b8 	.word	0x200019b8
   11248:	00010881 	.word	0x00010881

0001124c <SERCOM4_1_Handler>:
   1124c:	4b00      	ldr	r3, [pc, #0]	; (11250 <SERCOM4_1_Handler+0x4>)
   1124e:	4718      	bx	r3
   11250:	0001123d 	.word	0x0001123d

00011254 <SERCOM4_2_Handler>:
   11254:	4b00      	ldr	r3, [pc, #0]	; (11258 <SERCOM4_2_Handler+0x4>)
   11256:	4718      	bx	r3
   11258:	0001123d 	.word	0x0001123d

0001125c <SERCOM4_3_Handler>:
   1125c:	4b00      	ldr	r3, [pc, #0]	; (11260 <SERCOM4_3_Handler+0x4>)
   1125e:	4718      	bx	r3
   11260:	0001123d 	.word	0x0001123d

00011264 <SERCOM5_0_Handler>:
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   11264:	4b1f      	ldr	r3, [pc, #124]	; (112e4 <SERCOM5_0_Handler+0x80>)
	ASSERT(i2c_dev);
   11266:	4920      	ldr	r1, [pc, #128]	; (112e8 <SERCOM5_0_Handler+0x84>)
{
   11268:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   1126c:	691c      	ldr	r4, [r3, #16]
	ASSERT(i2c_dev);
   1126e:	4f1f      	ldr	r7, [pc, #124]	; (112ec <SERCOM5_0_Handler+0x88>)
	void *   hw    = i2c_dev->hw;
   11270:	6926      	ldr	r6, [r4, #16]
	ASSERT(i2c_dev);
   11272:	f240 425f 	movw	r2, #1119	; 0x45f
   11276:	2001      	movs	r0, #1
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
   11278:	7e35      	ldrb	r5, [r6, #24]
   1127a:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
   1127c:	6920      	ldr	r0, [r4, #16]
   1127e:	491a      	ldr	r1, [pc, #104]	; (112e8 <SERCOM5_0_Handler+0x84>)
   11280:	3800      	subs	r0, #0
   11282:	bf18      	it	ne
   11284:	2001      	movne	r0, #1
   11286:	b2ed      	uxtb	r5, r5
   11288:	f44f 628c 	mov.w	r2, #1120	; 0x460
   1128c:	47b8      	blx	r7
	while (!(flags & ERROR_FLAG)) {
   1128e:	0629      	lsls	r1, r5, #24
   11290:	d415      	bmi.n	112be <SERCOM5_0_Handler+0x5a>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
   11292:	4629      	mov	r1, r5
   11294:	4b16      	ldr	r3, [pc, #88]	; (112f0 <SERCOM5_0_Handler+0x8c>)
   11296:	4622      	mov	r2, r4
   11298:	4630      	mov	r0, r6
   1129a:	4798      	blx	r3
		if (ret != 0) {
   1129c:	4601      	mov	r1, r0
   1129e:	b978      	cbnz	r0, 112c0 <SERCOM5_0_Handler+0x5c>
		if ((flags & MB_FLAG) && i2c_dev->cb.tx_complete) {
   112a0:	07ea      	lsls	r2, r5, #31
   112a2:	d505      	bpl.n	112b0 <SERCOM5_0_Handler+0x4c>
   112a4:	69a3      	ldr	r3, [r4, #24]
   112a6:	b11b      	cbz	r3, 112b0 <SERCOM5_0_Handler+0x4c>
			i2c_dev->cb.rx_complete(i2c_dev);
   112a8:	4620      	mov	r0, r4
}
   112aa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			i2c_dev->cb.rx_complete(i2c_dev);
   112ae:	4718      	bx	r3
		} else if ((flags & SB_FLAG) && i2c_dev->cb.rx_complete) {
   112b0:	07ab      	lsls	r3, r5, #30
   112b2:	d502      	bpl.n	112ba <SERCOM5_0_Handler+0x56>
   112b4:	69e3      	ldr	r3, [r4, #28]
   112b6:	2b00      	cmp	r3, #0
   112b8:	d1f6      	bne.n	112a8 <SERCOM5_0_Handler+0x44>
}
   112ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int32_t  ret   = I2C_OK;
   112be:	2100      	movs	r1, #0
	i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
   112c0:	8863      	ldrh	r3, [r4, #2]
   112c2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   112c6:	041b      	lsls	r3, r3, #16
   112c8:	0c1b      	lsrs	r3, r3, #16
   112ca:	8063      	strh	r3, [r4, #2]
	if (i2c_dev->cb.error) {
   112cc:	6963      	ldr	r3, [r4, #20]
   112ce:	2b00      	cmp	r3, #0
   112d0:	d0f3      	beq.n	112ba <SERCOM5_0_Handler+0x56>
		if (ret != I2C_OK) {
   112d2:	b121      	cbz	r1, 112de <SERCOM5_0_Handler+0x7a>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   112d4:	4620      	mov	r0, r4
   112d6:	4798      	blx	r3
	((Sercom *)hw)->I2CM.INTFLAG.reg = mask;
   112d8:	2380      	movs	r3, #128	; 0x80
   112da:	7633      	strb	r3, [r6, #24]
}
   112dc:	e7ed      	b.n	112ba <SERCOM5_0_Handler+0x56>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   112de:	f06f 0104 	mvn.w	r1, #4
   112e2:	e7f7      	b.n	112d4 <SERCOM5_0_Handler+0x70>
   112e4:	200019b8 	.word	0x200019b8
   112e8:	00017281 	.word	0x00017281
   112ec:	0000df45 	.word	0x0000df45
   112f0:	00010a95 	.word	0x00010a95

000112f4 <SERCOM5_1_Handler>:
   112f4:	4b00      	ldr	r3, [pc, #0]	; (112f8 <SERCOM5_1_Handler+0x4>)
   112f6:	4718      	bx	r3
   112f8:	00011265 	.word	0x00011265

000112fc <SERCOM5_2_Handler>:
   112fc:	4b00      	ldr	r3, [pc, #0]	; (11300 <SERCOM5_2_Handler+0x4>)
   112fe:	4718      	bx	r3
   11300:	00011265 	.word	0x00011265

00011304 <SERCOM5_3_Handler>:
   11304:	4b00      	ldr	r3, [pc, #0]	; (11308 <SERCOM5_3_Handler+0x4>)
   11306:	4718      	bx	r3
   11308:	00011265 	.word	0x00011265

0001130c <SERCOM6_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom6_dev);
   1130c:	4b01      	ldr	r3, [pc, #4]	; (11314 <SERCOM6_0_Handler+0x8>)
   1130e:	6958      	ldr	r0, [r3, #20]
   11310:	4b01      	ldr	r3, [pc, #4]	; (11318 <SERCOM6_0_Handler+0xc>)
   11312:	4718      	bx	r3
   11314:	200019b8 	.word	0x200019b8
   11318:	00010881 	.word	0x00010881

0001131c <SERCOM6_1_Handler>:
   1131c:	4b00      	ldr	r3, [pc, #0]	; (11320 <SERCOM6_1_Handler+0x4>)
   1131e:	4718      	bx	r3
   11320:	0001130d 	.word	0x0001130d

00011324 <SERCOM6_2_Handler>:
   11324:	4b00      	ldr	r3, [pc, #0]	; (11328 <SERCOM6_2_Handler+0x4>)
   11326:	4718      	bx	r3
   11328:	0001130d 	.word	0x0001130d

0001132c <SERCOM6_3_Handler>:
   1132c:	4b00      	ldr	r3, [pc, #0]	; (11330 <SERCOM6_3_Handler+0x4>)
   1132e:	4718      	bx	r3
   11330:	0001130d 	.word	0x0001130d

00011334 <_spi_m_sync_init>:
{
   11334:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11338:	4b37      	ldr	r3, [pc, #220]	; (11418 <_spi_m_sync_init+0xe4>)
{
   1133a:	4606      	mov	r6, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   1133c:	4608      	mov	r0, r1
{
   1133e:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11340:	4798      	blx	r3
   11342:	4605      	mov	r5, r0
	ASSERT(dev && hw);
   11344:	2e00      	cmp	r6, #0
   11346:	d05d      	beq.n	11404 <_spi_m_sync_init+0xd0>
   11348:	1e20      	subs	r0, r4, #0
   1134a:	bf18      	it	ne
   1134c:	2001      	movne	r0, #1
   1134e:	4f33      	ldr	r7, [pc, #204]	; (1141c <_spi_m_sync_init+0xe8>)
   11350:	4933      	ldr	r1, [pc, #204]	; (11420 <_spi_m_sync_init+0xec>)
   11352:	f640 2278 	movw	r2, #2680	; 0xa78
   11356:	47b8      	blx	r7
	if (regs == NULL) {
   11358:	46b9      	mov	r9, r7
   1135a:	2d00      	cmp	r5, #0
   1135c:	d058      	beq.n	11410 <_spi_m_sync_init+0xdc>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   1135e:	69e3      	ldr	r3, [r4, #28]
   11360:	4f30      	ldr	r7, [pc, #192]	; (11424 <_spi_m_sync_init+0xf0>)
	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   11362:	f013 0f01 	tst.w	r3, #1
   11366:	d113      	bne.n	11390 <_spi_m_sync_init+0x5c>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11368:	2103      	movs	r1, #3
   1136a:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   1136c:	f8d5 8000 	ldr.w	r8, [r5]
   11370:	47b8      	blx	r7
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   11372:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11374:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11376:	f008 081c 	and.w	r8, r8, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   1137a:	d503      	bpl.n	11384 <_spi_m_sync_init+0x50>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   1137c:	4b2a      	ldr	r3, [pc, #168]	; (11428 <_spi_m_sync_init+0xf4>)
   1137e:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   11380:	2102      	movs	r1, #2
   11382:	47b8      	blx	r7
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   11384:	f048 0301 	orr.w	r3, r8, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11388:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1138a:	2103      	movs	r1, #3
   1138c:	4620      	mov	r0, r4
   1138e:	47b8      	blx	r7
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   11390:	2101      	movs	r1, #1
   11392:	4620      	mov	r0, r4
   11394:	47b8      	blx	r7
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   11396:	682b      	ldr	r3, [r5, #0]
	dev->prvt = hw;
   11398:	6034      	str	r4, [r6, #0]
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   1139a:	f003 031c 	and.w	r3, r3, #28
   1139e:	2b08      	cmp	r3, #8
   113a0:	d132      	bne.n	11408 <_spi_m_sync_init+0xd4>
	ASSERT(hw && regs);
   113a2:	f640 128e 	movw	r2, #2446	; 0x98e
   113a6:	491e      	ldr	r1, [pc, #120]	; (11420 <_spi_m_sync_init+0xec>)
   113a8:	2001      	movs	r0, #1
   113aa:	47c8      	blx	r9
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   113ac:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
   113ae:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   113b2:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   113b6:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   113b8:	2103      	movs	r1, #3
   113ba:	4620      	mov	r0, r4
   113bc:	47b8      	blx	r7
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
   113be:	686b      	ldr	r3, [r5, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
   113c0:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
   113c4:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
   113c8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   113cc:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   113d0:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   113d2:	2117      	movs	r1, #23
   113d4:	47b8      	blx	r7
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
   113d6:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
   113d8:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   113da:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   113dc:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   113e0:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
   113e2:	2b00      	cmp	r3, #0
   113e4:	d1fc      	bne.n	113e0 <_spi_m_sync_init+0xac>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
   113e6:	686b      	ldr	r3, [r5, #4]
   113e8:	f013 0f07 	tst.w	r3, #7
   113ec:	bf0c      	ite	eq
   113ee:	2301      	moveq	r3, #1
   113f0:	2302      	movne	r3, #2
   113f2:	7133      	strb	r3, [r6, #4]
	dev->dummy_byte = regs->dummy_byte;
   113f4:	7bab      	ldrb	r3, [r5, #14]
   113f6:	7bea      	ldrb	r2, [r5, #15]
   113f8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   113fc:	80f3      	strh	r3, [r6, #6]
	return ERR_NONE;
   113fe:	2000      	movs	r0, #0
}
   11400:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(dev && hw);
   11404:	4630      	mov	r0, r6
   11406:	e7a2      	b.n	1134e <_spi_m_sync_init+0x1a>
		_spi_load_regs_master(hw, regs);
   11408:	4b08      	ldr	r3, [pc, #32]	; (1142c <_spi_m_sync_init+0xf8>)
   1140a:	4629      	mov	r1, r5
   1140c:	4798      	blx	r3
   1140e:	e7ea      	b.n	113e6 <_spi_m_sync_init+0xb2>
		return ERR_INVALID_ARG;
   11410:	f06f 000c 	mvn.w	r0, #12
   11414:	e7f4      	b.n	11400 <_spi_m_sync_init+0xcc>
   11416:	bf00      	nop
   11418:	0001098d 	.word	0x0001098d
   1141c:	0000df45 	.word	0x0000df45
   11420:	00017281 	.word	0x00017281
   11424:	000107d1 	.word	0x000107d1
   11428:	000107f5 	.word	0x000107f5
   1142c:	00010ca9 	.word	0x00010ca9

00011430 <_spi_m_async_init>:
{
   11430:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11432:	4b10      	ldr	r3, [pc, #64]	; (11474 <_spi_m_async_init+0x44>)
{
   11434:	4605      	mov	r5, r0
   11436:	460e      	mov	r6, r1
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11438:	4798      	blx	r3
	if (rc < 0) {
   1143a:	2800      	cmp	r0, #0
   1143c:	db17      	blt.n	1146e <_spi_m_async_init+0x3e>
	_sercom_init_irq_param(hw, (void *)dev);
   1143e:	4629      	mov	r1, r5
	spid->callbacks.complete = NULL;
   11440:	2400      	movs	r4, #0
	_sercom_init_irq_param(hw, (void *)dev);
   11442:	4630      	mov	r0, r6
   11444:	4b0c      	ldr	r3, [pc, #48]	; (11478 <_spi_m_async_init+0x48>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11446:	4e0d      	ldr	r6, [pc, #52]	; (1147c <_spi_m_async_init+0x4c>)
	_sercom_init_irq_param(hw, (void *)dev);
   11448:	4798      	blx	r3
	spid->callbacks.rx       = NULL;
   1144a:	e9c5 4403 	strd	r4, r4, [r5, #12]
	spid->callbacks.tx       = NULL;
   1144e:	60ac      	str	r4, [r5, #8]
	uint8_t irq              = _sercom_get_irq_num(hw);
   11450:	4b0b      	ldr	r3, [pc, #44]	; (11480 <_spi_m_async_init+0x50>)
   11452:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11454:	4621      	mov	r1, r4
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11456:	4c0b      	ldr	r4, [pc, #44]	; (11484 <_spi_m_async_init+0x54>)
	uint8_t irq              = _sercom_get_irq_num(hw);
   11458:	4605      	mov	r5, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   1145a:	186b      	adds	r3, r5, r1
   1145c:	b2d8      	uxtb	r0, r3
   1145e:	9001      	str	r0, [sp, #4]
   11460:	47b0      	blx	r6
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11462:	9801      	ldr	r0, [sp, #4]
   11464:	47a0      	blx	r4
	for (uint32_t i = 0; i < 4; i++) {
   11466:	3101      	adds	r1, #1
   11468:	2904      	cmp	r1, #4
   1146a:	d1f6      	bne.n	1145a <_spi_m_async_init+0x2a>
   1146c:	2000      	movs	r0, #0
}
   1146e:	b002      	add	sp, #8
   11470:	bd70      	pop	{r4, r5, r6, pc}
   11472:	bf00      	nop
   11474:	00011335 	.word	0x00011335
   11478:	000108f1 	.word	0x000108f1
   1147c:	00010a15 	.word	0x00010a15
   11480:	00010951 	.word	0x00010951
   11484:	00010a39 	.word	0x00010a39

00011488 <_spi_m_async_enable>:
{
   11488:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   1148a:	4604      	mov	r4, r0
   1148c:	b118      	cbz	r0, 11496 <_spi_m_async_enable+0xe>
   1148e:	6800      	ldr	r0, [r0, #0]
   11490:	3800      	subs	r0, #0
   11492:	bf18      	it	ne
   11494:	2001      	movne	r0, #1
   11496:	4b05      	ldr	r3, [pc, #20]	; (114ac <_spi_m_async_enable+0x24>)
   11498:	4905      	ldr	r1, [pc, #20]	; (114b0 <_spi_m_async_enable+0x28>)
   1149a:	f640 22e5 	movw	r2, #2789	; 0xae5
   1149e:	4798      	blx	r3
	return _spi_async_enable(dev->prvt);
   114a0:	6820      	ldr	r0, [r4, #0]
   114a2:	4b04      	ldr	r3, [pc, #16]	; (114b4 <_spi_m_async_enable+0x2c>)
}
   114a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_async_enable(dev->prvt);
   114a8:	4718      	bx	r3
   114aa:	bf00      	nop
   114ac:	0000df45 	.word	0x0000df45
   114b0:	00017281 	.word	0x00017281
   114b4:	000109e5 	.word	0x000109e5

000114b8 <_spi_m_async_set_mode>:
{
   114b8:	b570      	push	{r4, r5, r6, lr}
   114ba:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   114bc:	4604      	mov	r4, r0
   114be:	b118      	cbz	r0, 114c8 <_spi_m_async_set_mode+0x10>
   114c0:	6800      	ldr	r0, [r0, #0]
   114c2:	3800      	subs	r0, #0
   114c4:	bf18      	it	ne
   114c6:	2001      	movne	r0, #1
   114c8:	4905      	ldr	r1, [pc, #20]	; (114e0 <_spi_m_async_set_mode+0x28>)
   114ca:	4b06      	ldr	r3, [pc, #24]	; (114e4 <_spi_m_async_set_mode+0x2c>)
   114cc:	f640 3216 	movw	r2, #2838	; 0xb16
   114d0:	4798      	blx	r3
	return _spi_set_mode(dev->prvt, mode);
   114d2:	6820      	ldr	r0, [r4, #0]
   114d4:	4b04      	ldr	r3, [pc, #16]	; (114e8 <_spi_m_async_set_mode+0x30>)
   114d6:	4629      	mov	r1, r5
}
   114d8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_set_mode(dev->prvt, mode);
   114dc:	4718      	bx	r3
   114de:	bf00      	nop
   114e0:	00017281 	.word	0x00017281
   114e4:	0000df45 	.word	0x0000df45
   114e8:	00010c75 	.word	0x00010c75

000114ec <_spi_m_async_set_baudrate>:
{
   114ec:	b538      	push	{r3, r4, r5, lr}
   114ee:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   114f0:	4604      	mov	r4, r0
   114f2:	b118      	cbz	r0, 114fc <_spi_m_async_set_baudrate+0x10>
   114f4:	6800      	ldr	r0, [r0, #0]
   114f6:	3800      	subs	r0, #0
   114f8:	bf18      	it	ne
   114fa:	2001      	movne	r0, #1
   114fc:	4907      	ldr	r1, [pc, #28]	; (1151c <_spi_m_async_set_baudrate+0x30>)
   114fe:	4b08      	ldr	r3, [pc, #32]	; (11520 <_spi_m_async_set_baudrate+0x34>)
   11500:	f640 3245 	movw	r2, #2885	; 0xb45
   11504:	4798      	blx	r3
	return _spi_set_baudrate(dev->prvt, baud_val);
   11506:	6823      	ldr	r3, [r4, #0]
   11508:	69d8      	ldr	r0, [r3, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   1150a:	f010 0001 	ands.w	r0, r0, #1
	hri_sercomspi_write_BAUD_reg(hw, baud_val);
   1150e:	bf06      	itte	eq
   11510:	b2ed      	uxtbeq	r5, r5
	((Sercom *)hw)->SPI.BAUD.reg = data;
   11512:	731d      	strbeq	r5, [r3, #12]
		return ERR_BUSY;
   11514:	f06f 0003 	mvnne.w	r0, #3
}
   11518:	bd38      	pop	{r3, r4, r5, pc}
   1151a:	bf00      	nop
   1151c:	00017281 	.word	0x00017281
   11520:	0000df45 	.word	0x0000df45

00011524 <_spi_m_async_enable_tx>:
{
   11524:	b538      	push	{r3, r4, r5, lr}
	void *hw = dev->prvt;
   11526:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev && hw);
   11528:	4b07      	ldr	r3, [pc, #28]	; (11548 <_spi_m_async_enable_tx+0x24>)
   1152a:	1e20      	subs	r0, r4, #0
{
   1152c:	460d      	mov	r5, r1
	ASSERT(dev && hw);
   1152e:	f640 4208 	movw	r2, #3080	; 0xc08
   11532:	4906      	ldr	r1, [pc, #24]	; (1154c <_spi_m_async_enable_tx+0x28>)
   11534:	bf18      	it	ne
   11536:	2001      	movne	r0, #1
   11538:	4798      	blx	r3
	if (state) {
   1153a:	2301      	movs	r3, #1
   1153c:	b115      	cbz	r5, 11544 <_spi_m_async_enable_tx+0x20>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
   1153e:	75a3      	strb	r3, [r4, #22]
}
   11540:	2000      	movs	r0, #0
   11542:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
   11544:	7523      	strb	r3, [r4, #20]
}
   11546:	e7fb      	b.n	11540 <_spi_m_async_enable_tx+0x1c>
   11548:	0000df45 	.word	0x0000df45
   1154c:	00017281 	.word	0x00017281

00011550 <_spi_m_async_enable_rx>:
{
   11550:	b570      	push	{r4, r5, r6, lr}
	void *hw = dev->prvt;
   11552:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev);
   11554:	4e0a      	ldr	r6, [pc, #40]	; (11580 <_spi_m_async_enable_rx+0x30>)
   11556:	f640 421c 	movw	r2, #3100	; 0xc1c
   1155a:	2001      	movs	r0, #1
{
   1155c:	460d      	mov	r5, r1
	ASSERT(dev);
   1155e:	4909      	ldr	r1, [pc, #36]	; (11584 <_spi_m_async_enable_rx+0x34>)
   11560:	47b0      	blx	r6
	ASSERT(hw);
   11562:	1e20      	subs	r0, r4, #0
   11564:	4907      	ldr	r1, [pc, #28]	; (11584 <_spi_m_async_enable_rx+0x34>)
   11566:	f640 421d 	movw	r2, #3101	; 0xc1d
   1156a:	bf18      	it	ne
   1156c:	2001      	movne	r0, #1
   1156e:	47b0      	blx	r6
	if (state) {
   11570:	2304      	movs	r3, #4
   11572:	b115      	cbz	r5, 1157a <_spi_m_async_enable_rx+0x2a>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
   11574:	75a3      	strb	r3, [r4, #22]
}
   11576:	2000      	movs	r0, #0
   11578:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
   1157a:	7523      	strb	r3, [r4, #20]
}
   1157c:	e7fb      	b.n	11576 <_spi_m_async_enable_rx+0x26>
   1157e:	bf00      	nop
   11580:	0000df45 	.word	0x0000df45
   11584:	00017281 	.word	0x00017281

00011588 <_spi_m_async_enable_tx_complete>:
{
   11588:	b538      	push	{r3, r4, r5, lr}
   1158a:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   1158c:	4604      	mov	r4, r0
   1158e:	b118      	cbz	r0, 11598 <_spi_m_async_enable_tx_complete+0x10>
   11590:	6800      	ldr	r0, [r0, #0]
   11592:	3800      	subs	r0, #0
   11594:	bf18      	it	ne
   11596:	2001      	movne	r0, #1
   11598:	4b06      	ldr	r3, [pc, #24]	; (115b4 <_spi_m_async_enable_tx_complete+0x2c>)
   1159a:	4907      	ldr	r1, [pc, #28]	; (115b8 <_spi_m_async_enable_tx_complete+0x30>)
   1159c:	f640 422f 	movw	r2, #3119	; 0xc2f
   115a0:	4798      	blx	r3
	if (state) {
   115a2:	6823      	ldr	r3, [r4, #0]
   115a4:	2202      	movs	r2, #2
   115a6:	b115      	cbz	r5, 115ae <_spi_m_async_enable_tx_complete+0x26>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
   115a8:	759a      	strb	r2, [r3, #22]
}
   115aa:	2000      	movs	r0, #0
   115ac:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
   115ae:	751a      	strb	r2, [r3, #20]
}
   115b0:	e7fb      	b.n	115aa <_spi_m_async_enable_tx_complete+0x22>
   115b2:	bf00      	nop
   115b4:	0000df45 	.word	0x0000df45
   115b8:	00017281 	.word	0x00017281

000115bc <_spi_m_async_write_one>:
{
   115bc:	b538      	push	{r3, r4, r5, lr}
   115be:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   115c0:	4604      	mov	r4, r0
   115c2:	b118      	cbz	r0, 115cc <_spi_m_async_write_one+0x10>
   115c4:	6800      	ldr	r0, [r0, #0]
   115c6:	3800      	subs	r0, #0
   115c8:	bf18      	it	ne
   115ca:	2001      	movne	r0, #1
   115cc:	4904      	ldr	r1, [pc, #16]	; (115e0 <_spi_m_async_write_one+0x24>)
   115ce:	4b05      	ldr	r3, [pc, #20]	; (115e4 <_spi_m_async_write_one+0x28>)
   115d0:	f640 4241 	movw	r2, #3137	; 0xc41
   115d4:	4798      	blx	r3
	hri_sercomspi_write_DATA_reg(dev->prvt, data);
   115d6:	6823      	ldr	r3, [r4, #0]
}
   115d8:	2000      	movs	r0, #0
	((Sercom *)hw)->SPI.DATA.reg = data;
   115da:	629d      	str	r5, [r3, #40]	; 0x28
   115dc:	bd38      	pop	{r3, r4, r5, pc}
   115de:	bf00      	nop
   115e0:	00017281 	.word	0x00017281
   115e4:	0000df45 	.word	0x0000df45

000115e8 <_spi_m_async_read_one>:
{
   115e8:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   115ea:	4604      	mov	r4, r0
   115ec:	b118      	cbz	r0, 115f6 <_spi_m_async_read_one+0xe>
   115ee:	6800      	ldr	r0, [r0, #0]
   115f0:	3800      	subs	r0, #0
   115f2:	bf18      	it	ne
   115f4:	2001      	movne	r0, #1
   115f6:	4904      	ldr	r1, [pc, #16]	; (11608 <_spi_m_async_read_one+0x20>)
   115f8:	4b04      	ldr	r3, [pc, #16]	; (1160c <_spi_m_async_read_one+0x24>)
   115fa:	f640 425c 	movw	r2, #3164	; 0xc5c
   115fe:	4798      	blx	r3
	return hri_sercomspi_read_DATA_reg(dev->prvt);
   11600:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
   11602:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   11604:	b280      	uxth	r0, r0
   11606:	bd10      	pop	{r4, pc}
   11608:	00017281 	.word	0x00017281
   1160c:	0000df45 	.word	0x0000df45

00011610 <_spi_m_async_register_callback>:
{
   11610:	b570      	push	{r4, r5, r6, lr}
   11612:	460d      	mov	r5, r1
   11614:	4616      	mov	r6, r2
	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
   11616:	4604      	mov	r4, r0
   11618:	b118      	cbz	r0, 11622 <_spi_m_async_register_callback+0x12>
   1161a:	2903      	cmp	r1, #3
   1161c:	bf8c      	ite	hi
   1161e:	2000      	movhi	r0, #0
   11620:	2001      	movls	r0, #1
   11622:	4905      	ldr	r1, [pc, #20]	; (11638 <_spi_m_async_register_callback+0x28>)
   11624:	4b05      	ldr	r3, [pc, #20]	; (1163c <_spi_m_async_register_callback+0x2c>)
   11626:	f640 4275 	movw	r2, #3189	; 0xc75
   1162a:	4798      	blx	r3
	p_ls[cb_type] = (func_t)func;
   1162c:	eb04 0185 	add.w	r1, r4, r5, lsl #2
}
   11630:	2000      	movs	r0, #0
	p_ls[cb_type] = (func_t)func;
   11632:	608e      	str	r6, [r1, #8]
}
   11634:	bd70      	pop	{r4, r5, r6, pc}
   11636:	bf00      	nop
   11638:	00017281 	.word	0x00017281
   1163c:	0000df45 	.word	0x0000df45

00011640 <_spi_m_async_set_irq_state>:
{
   11640:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   11642:	4604      	mov	r4, r0
   11644:	3800      	subs	r0, #0
{
   11646:	460e      	mov	r6, r1
	ASSERT(device);
   11648:	bf18      	it	ne
   1164a:	2001      	movne	r0, #1
   1164c:	4907      	ldr	r1, [pc, #28]	; (1166c <_spi_m_async_set_irq_state+0x2c>)
   1164e:	4b08      	ldr	r3, [pc, #32]	; (11670 <_spi_m_async_set_irq_state+0x30>)
{
   11650:	4615      	mov	r5, r2
	ASSERT(device);
   11652:	f640 42b6 	movw	r2, #3254	; 0xcb6
   11656:	4798      	blx	r3
	if (SPI_DEV_CB_ERROR == type) {
   11658:	2e03      	cmp	r6, #3
   1165a:	d103      	bne.n	11664 <_spi_m_async_set_irq_state+0x24>
		hri_sercomspi_write_INTEN_ERROR_bit(device->prvt, state);
   1165c:	6823      	ldr	r3, [r4, #0]
	if (value == 0x0) {
   1165e:	2280      	movs	r2, #128	; 0x80
   11660:	b90d      	cbnz	r5, 11666 <_spi_m_async_set_irq_state+0x26>
		((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_ERROR;
   11662:	751a      	strb	r2, [r3, #20]
}
   11664:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_ERROR;
   11666:	759a      	strb	r2, [r3, #22]
   11668:	e7fc      	b.n	11664 <_spi_m_async_set_irq_state+0x24>
   1166a:	bf00      	nop
   1166c:	00017281 	.word	0x00017281
   11670:	0000df45 	.word	0x0000df45

00011674 <_spi_m_dma_init>:

int32_t _spi_m_dma_init(struct _spi_m_dma_dev *dev, void *const hw)
{
   11674:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11678:	4b25      	ldr	r3, [pc, #148]	; (11710 <_spi_m_dma_init+0x9c>)
{
   1167a:	4605      	mov	r5, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   1167c:	4608      	mov	r0, r1
{
   1167e:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11680:	4798      	blx	r3
   11682:	4606      	mov	r6, r0

	ASSERT(dev && hw);
   11684:	2d00      	cmp	r5, #0
   11686:	d03e      	beq.n	11706 <_spi_m_dma_init+0x92>
   11688:	1e20      	subs	r0, r4, #0
   1168a:	bf18      	it	ne
   1168c:	2001      	movne	r0, #1
   1168e:	4921      	ldr	r1, [pc, #132]	; (11714 <_spi_m_dma_init+0xa0>)
   11690:	4b21      	ldr	r3, [pc, #132]	; (11718 <_spi_m_dma_init+0xa4>)
   11692:	f640 52e3 	movw	r2, #3555	; 0xde3
   11696:	4798      	blx	r3

	if (regs == NULL) {
   11698:	2e00      	cmp	r6, #0
   1169a:	d036      	beq.n	1170a <_spi_m_dma_init+0x96>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   1169c:	69e3      	ldr	r3, [r4, #28]
   1169e:	f8df 8094 	ldr.w	r8, [pc, #148]	; 11734 <_spi_m_dma_init+0xc0>
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   116a2:	f013 0f01 	tst.w	r3, #1
   116a6:	d112      	bne.n	116ce <_spi_m_dma_init+0x5a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   116a8:	2103      	movs	r1, #3
   116aa:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   116ac:	6837      	ldr	r7, [r6, #0]
   116ae:	47c0      	blx	r8
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   116b0:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   116b2:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   116b4:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   116b8:	d503      	bpl.n	116c2 <_spi_m_dma_init+0x4e>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   116ba:	4b18      	ldr	r3, [pc, #96]	; (1171c <_spi_m_dma_init+0xa8>)
   116bc:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   116be:	2102      	movs	r1, #2
   116c0:	47c0      	blx	r8
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   116c2:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   116c6:	6027      	str	r7, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   116c8:	2103      	movs	r1, #3
   116ca:	4620      	mov	r0, r4
   116cc:	47c0      	blx	r8
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
   116ce:	462f      	mov	r7, r5
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   116d0:	4620      	mov	r0, r4
   116d2:	2101      	movs	r1, #1
   116d4:	47c0      	blx	r8

	_spi_load_regs_master(hw, regs);
   116d6:	4631      	mov	r1, r6
	dev->prvt = hw;
   116d8:	f847 4b18 	str.w	r4, [r7], #24
	_spi_load_regs_master(hw, regs);
   116dc:	4b10      	ldr	r3, [pc, #64]	; (11720 <_spi_m_dma_init+0xac>)
   116de:	4798      	blx	r3
	uint8_t index = _sercom_get_hardware_index(hw);
   116e0:	4b10      	ldr	r3, [pc, #64]	; (11724 <_spi_m_dma_init+0xb0>)
   116e2:	4620      	mov	r0, r4
   116e4:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   116e6:	2807      	cmp	r0, #7
		dev->resource->back                 = dev;
		dev->resource->dma_cb.transfer_done = _spi_dma_rx_complete;
		dev->resource->dma_cb.error         = _spi_dma_error_occured;
	}
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, _spi_get_tx_dma_channel(hw));
   116e8:	4b0f      	ldr	r3, [pc, #60]	; (11728 <_spi_m_dma_init+0xb4>)
   116ea:	bf0c      	ite	eq
   116ec:	2108      	moveq	r1, #8
   116ee:	2100      	movne	r1, #0
   116f0:	4638      	mov	r0, r7
   116f2:	4798      	blx	r3
	dev->resource->back                 = dev;
   116f4:	69ab      	ldr	r3, [r5, #24]
	dev->resource->dma_cb.transfer_done = _spi_dma_tx_complete;
   116f6:	4a0d      	ldr	r2, [pc, #52]	; (1172c <_spi_m_dma_init+0xb8>)
   116f8:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   116fa:	4a0d      	ldr	r2, [pc, #52]	; (11730 <_spi_m_dma_init+0xbc>)
	dev->resource->back                 = dev;
   116fc:	609d      	str	r5, [r3, #8]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   116fe:	605a      	str	r2, [r3, #4]

	return ERR_NONE;
   11700:	2000      	movs	r0, #0
}
   11702:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(dev && hw);
   11706:	4628      	mov	r0, r5
   11708:	e7c1      	b.n	1168e <_spi_m_dma_init+0x1a>
		return ERR_INVALID_ARG;
   1170a:	f06f 000c 	mvn.w	r0, #12
   1170e:	e7f8      	b.n	11702 <_spi_m_dma_init+0x8e>
   11710:	0001098d 	.word	0x0001098d
   11714:	00017281 	.word	0x00017281
   11718:	0000df45 	.word	0x0000df45
   1171c:	000107f5 	.word	0x000107f5
   11720:	00010ca9 	.word	0x00010ca9
   11724:	00010849 	.word	0x00010849
   11728:	0000e189 	.word	0x0000e189
   1172c:	000109b9 	.word	0x000109b9
   11730:	000109c3 	.word	0x000109c3
   11734:	000107d1 	.word	0x000107d1

00011738 <_spi_m_dma_enable>:
{
	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_dma_enable(struct _spi_m_dma_dev *dev)
{
   11738:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   1173a:	4604      	mov	r4, r0
   1173c:	b118      	cbz	r0, 11746 <_spi_m_dma_enable+0xe>
   1173e:	6800      	ldr	r0, [r0, #0]
   11740:	3800      	subs	r0, #0
   11742:	bf18      	it	ne
   11744:	2001      	movne	r0, #1
   11746:	4b05      	ldr	r3, [pc, #20]	; (1175c <_spi_m_dma_enable+0x24>)
   11748:	4905      	ldr	r1, [pc, #20]	; (11760 <_spi_m_dma_enable+0x28>)
   1174a:	f640 620e 	movw	r2, #3598	; 0xe0e
   1174e:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
   11750:	6820      	ldr	r0, [r4, #0]
   11752:	4b04      	ldr	r3, [pc, #16]	; (11764 <_spi_m_dma_enable+0x2c>)
}
   11754:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_sync_enable(dev->prvt);
   11758:	4718      	bx	r3
   1175a:	bf00      	nop
   1175c:	0000df45 	.word	0x0000df45
   11760:	00017281 	.word	0x00017281
   11764:	00010965 	.word	0x00010965

00011768 <_spi_m_dma_register_callback>:
	return size;
}

void _spi_m_dma_register_callback(struct _spi_m_dma_dev *dev, enum _spi_dma_dev_cb_type type, _spi_dma_cb_t func)
{
	switch (type) {
   11768:	2901      	cmp	r1, #1
{
   1176a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1176c:	4605      	mov	r5, r0
   1176e:	460e      	mov	r6, r1
   11770:	4614      	mov	r4, r2
	switch (type) {
   11772:	d014      	beq.n	1179e <_spi_m_dma_register_callback+0x36>
   11774:	2902      	cmp	r1, #2
   11776:	d020      	beq.n	117ba <_spi_m_dma_register_callback+0x52>
   11778:	2900      	cmp	r1, #0
   1177a:	d138      	bne.n	117ee <_spi_m_dma_register_callback+0x86>
	case SPI_DEV_CB_DMA_TX:
		dev->callbacks.tx = func;
   1177c:	6042      	str	r2, [r0, #4]
	uint8_t index = _sercom_get_hardware_index(hw);
   1177e:	4b1d      	ldr	r3, [pc, #116]	; (117f4 <_spi_m_dma_register_callback+0x8c>)
   11780:	6800      	ldr	r0, [r0, #0]
   11782:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11784:	2807      	cmp	r0, #7
   11786:	bf08      	it	eq
   11788:	2608      	moveq	r6, #8
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   1178a:	1e22      	subs	r2, r4, #0
   1178c:	bf18      	it	ne
   1178e:	2201      	movne	r2, #1
   11790:	2100      	movs	r1, #0
   11792:	4630      	mov	r0, r6
		break;
	case SPI_DEV_CB_DMA_RX:
		dev->callbacks.rx = func;
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   11794:	4b18      	ldr	r3, [pc, #96]	; (117f8 <_spi_m_dma_register_callback+0x90>)
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
		break;
	case SPI_DEV_CB_DMA_N:
		break;
	}
}
   11796:	b002      	add	sp, #8
   11798:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   1179c:	4718      	bx	r3
		dev->callbacks.rx = func;
   1179e:	6082      	str	r2, [r0, #8]
	uint8_t index = _sercom_get_hardware_index(hw);
   117a0:	4b14      	ldr	r3, [pc, #80]	; (117f4 <_spi_m_dma_register_callback+0x8c>)
   117a2:	6800      	ldr	r0, [r0, #0]
   117a4:	4798      	blx	r3
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   117a6:	1e22      	subs	r2, r4, #0
   117a8:	bf18      	it	ne
   117aa:	2201      	movne	r2, #1
   117ac:	2807      	cmp	r0, #7
   117ae:	f04f 0100 	mov.w	r1, #0
   117b2:	bf8c      	ite	hi
   117b4:	2000      	movhi	r0, #0
   117b6:	2001      	movls	r0, #1
   117b8:	e7ec      	b.n	11794 <_spi_m_dma_register_callback+0x2c>
		dev->callbacks.error = func;
   117ba:	60c2      	str	r2, [r0, #12]
	uint8_t index = _sercom_get_hardware_index(hw);
   117bc:	4e0d      	ldr	r6, [pc, #52]	; (117f4 <_spi_m_dma_register_callback+0x8c>)
   117be:	6800      	ldr	r0, [r0, #0]
   117c0:	47b0      	blx	r6
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   117c2:	1e22      	subs	r2, r4, #0
   117c4:	bf18      	it	ne
   117c6:	2201      	movne	r2, #1
   117c8:	2807      	cmp	r0, #7
   117ca:	bf8c      	ite	hi
   117cc:	2000      	movhi	r0, #0
   117ce:	2001      	movls	r0, #1
   117d0:	2101      	movs	r1, #1
   117d2:	4c09      	ldr	r4, [pc, #36]	; (117f8 <_spi_m_dma_register_callback+0x90>)
   117d4:	9201      	str	r2, [sp, #4]
   117d6:	47a0      	blx	r4
	uint8_t index = _sercom_get_hardware_index(hw);
   117d8:	6828      	ldr	r0, [r5, #0]
   117da:	47b0      	blx	r6
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   117dc:	2807      	cmp	r0, #7
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   117de:	9a01      	ldr	r2, [sp, #4]
   117e0:	f04f 0101 	mov.w	r1, #1
   117e4:	bf0c      	ite	eq
   117e6:	2008      	moveq	r0, #8
   117e8:	2000      	movne	r0, #0
   117ea:	4623      	mov	r3, r4
   117ec:	e7d3      	b.n	11796 <_spi_m_dma_register_callback+0x2e>
}
   117ee:	b002      	add	sp, #8
   117f0:	bd70      	pop	{r4, r5, r6, pc}
   117f2:	bf00      	nop
   117f4:	00010849 	.word	0x00010849
   117f8:	0000e0a5 	.word	0x0000e0a5

000117fc <_spi_m_dma_transfer>:

int32_t _spi_m_dma_transfer(struct _spi_m_dma_dev *dev, uint8_t const *txbuf, uint8_t *const rxbuf,
                            const uint16_t length)
{
   117fc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   11800:	f8d0 8000 	ldr.w	r8, [r0]
	uint8_t index = _sercom_get_hardware_index(hw);
   11804:	f8df 911c 	ldr.w	r9, [pc, #284]	; 11924 <_spi_m_dma_transfer+0x128>
{
   11808:	4605      	mov	r5, r0
   1180a:	461f      	mov	r7, r3
	uint8_t index = _sercom_get_hardware_index(hw);
   1180c:	4640      	mov	r0, r8
   1180e:	4b3d      	ldr	r3, [pc, #244]	; (11904 <_spi_m_dma_transfer+0x108>)
{
   11810:	460e      	mov	r6, r1
   11812:	4692      	mov	sl, r2
	uint8_t index = _sercom_get_hardware_index(hw);
   11814:	4798      	blx	r3
	switch (index) {
   11816:	2807      	cmp	r0, #7
   11818:	4b3b      	ldr	r3, [pc, #236]	; (11908 <_spi_m_dma_transfer+0x10c>)
   1181a:	d86a      	bhi.n	118f2 <_spi_m_dma_transfer+0xf6>
	switch (index) {
   1181c:	d06c      	beq.n	118f8 <_spi_m_dma_transfer+0xfc>
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   1181e:	f04f 0b01 	mov.w	fp, #1
	uint8_t                          rx_ch = _spi_get_rx_dma_channel(dev->prvt);
	uint8_t                          tx_ch = _spi_get_tx_dma_channel(dev->prvt);

	if (rxbuf) {
   11822:	f1ba 0f00 	cmp.w	sl, #0
   11826:	d114      	bne.n	11852 <_spi_m_dma_transfer+0x56>
   11828:	4654      	mov	r4, sl
	ASSERT(dev && dev->prvt);
   1182a:	f1b8 0000 	subs.w	r0, r8, #0
   1182e:	bf18      	it	ne
   11830:	2001      	movne	r0, #1
   11832:	4936      	ldr	r1, [pc, #216]	; (1190c <_spi_m_dma_transfer+0x110>)
   11834:	f640 523d 	movw	r2, #3389	; 0xd3d
   11838:	4798      	blx	r3
	return _spi_sync_rx_disable(dev->prvt);
   1183a:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   1183c:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   1183e:	075b      	lsls	r3, r3, #29
   11840:	d42b      	bmi.n	1189a <_spi_m_dma_transfer+0x9e>
	((Sercom *)hw)->SPI.CTRLB.reg &= ~SERCOM_SPI_CTRLB_RXEN;
   11842:	6843      	ldr	r3, [r0, #4]
   11844:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   11848:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   1184a:	2117      	movs	r1, #23
   1184c:	4b30      	ldr	r3, [pc, #192]	; (11910 <_spi_m_dma_transfer+0x114>)
   1184e:	4798      	blx	r3
}
   11850:	e023      	b.n	1189a <_spi_m_dma_transfer+0x9e>
	if (rxbuf) {
   11852:	2400      	movs	r4, #0
	ASSERT(dev && dev->prvt);
   11854:	f1b8 0000 	subs.w	r0, r8, #0
   11858:	bf18      	it	ne
   1185a:	2001      	movne	r0, #1
   1185c:	f640 5236 	movw	r2, #3382	; 0xd36
   11860:	492a      	ldr	r1, [pc, #168]	; (1190c <_spi_m_dma_transfer+0x110>)
   11862:	4798      	blx	r3
	return _spi_sync_rx_enable(dev->prvt);
   11864:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11866:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   11868:	075a      	lsls	r2, r3, #29
   1186a:	d406      	bmi.n	1187a <_spi_m_dma_transfer+0x7e>
	((Sercom *)hw)->SPI.CTRLB.reg |= SERCOM_SPI_CTRLB_RXEN;
   1186c:	6843      	ldr	r3, [r0, #4]
   1186e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11872:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11874:	2117      	movs	r1, #23
   11876:	4b26      	ldr	r3, [pc, #152]	; (11910 <_spi_m_dma_transfer+0x114>)
   11878:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   1187a:	6829      	ldr	r1, [r5, #0]
		/* Enable spi rx */
		_spi_m_dma_rx_enable(dev);
		_dma_set_source_address(rx_ch, (void *)_spi_m_get_source_for_dma(dev->prvt));
   1187c:	4b25      	ldr	r3, [pc, #148]	; (11914 <_spi_m_dma_transfer+0x118>)
   1187e:	3128      	adds	r1, #40	; 0x28
   11880:	4658      	mov	r0, fp
   11882:	4798      	blx	r3
		_dma_set_destination_address(rx_ch, rxbuf);
   11884:	4651      	mov	r1, sl
   11886:	4658      	mov	r0, fp
   11888:	47c8      	blx	r9
		_dma_set_data_amount(rx_ch, length);
   1188a:	4b23      	ldr	r3, [pc, #140]	; (11918 <_spi_m_dma_transfer+0x11c>)
   1188c:	4639      	mov	r1, r7
   1188e:	4658      	mov	r0, fp
   11890:	4798      	blx	r3
		_dma_enable_transaction(rx_ch, false);
   11892:	4b22      	ldr	r3, [pc, #136]	; (1191c <_spi_m_dma_transfer+0x120>)
   11894:	2100      	movs	r1, #0
   11896:	4658      	mov	r0, fp
   11898:	4798      	blx	r3
	} else {
		/* Disable spi rx */
		_spi_m_dma_rx_disable(dev);
	}

	if (txbuf) {
   1189a:	f8df a07c 	ldr.w	sl, [pc, #124]	; 11918 <_spi_m_dma_transfer+0x11c>
   1189e:	f8df b088 	ldr.w	fp, [pc, #136]	; 11928 <_spi_m_dma_transfer+0x12c>
   118a2:	b1c6      	cbz	r6, 118d6 <_spi_m_dma_transfer+0xda>
		/* Enable spi tx */
		_dma_set_source_address(tx_ch, txbuf);
   118a4:	4b1b      	ldr	r3, [pc, #108]	; (11914 <_spi_m_dma_transfer+0x118>)
   118a6:	4631      	mov	r1, r6
   118a8:	4620      	mov	r0, r4
   118aa:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   118ac:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   118ae:	4620      	mov	r0, r4
   118b0:	3128      	adds	r1, #40	; 0x28
   118b2:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, true);
   118b4:	2101      	movs	r1, #1
		_dma_set_data_amount(tx_ch, length);
	} else {
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
		_dma_srcinc_enable(tx_ch, false);
   118b6:	4620      	mov	r0, r4
   118b8:	47d8      	blx	fp
		_dma_set_data_amount(tx_ch, length);
   118ba:	4639      	mov	r1, r7
   118bc:	4620      	mov	r0, r4
   118be:	47d0      	blx	sl
	}
	_dma_enable_transaction(tx_ch, false);
   118c0:	4b16      	ldr	r3, [pc, #88]	; (1191c <_spi_m_dma_transfer+0x120>)
   118c2:	2100      	movs	r1, #0
   118c4:	4620      	mov	r0, r4
   118c6:	4798      	blx	r3

	return ERR_NONE;
}
   118c8:	2000      	movs	r0, #0
   118ca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   118ce:	f04f 0b01 	mov.w	fp, #1
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   118d2:	2408      	movs	r4, #8
   118d4:	e7be      	b.n	11854 <_spi_m_dma_transfer+0x58>
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   118d6:	4b12      	ldr	r3, [pc, #72]	; (11920 <_spi_m_dma_transfer+0x124>)
   118d8:	4640      	mov	r0, r8
   118da:	4798      	blx	r3
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
   118dc:	4b0d      	ldr	r3, [pc, #52]	; (11914 <_spi_m_dma_transfer+0x118>)
   118de:	f100 010e 	add.w	r1, r0, #14
   118e2:	4620      	mov	r0, r4
   118e4:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   118e6:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   118e8:	4620      	mov	r0, r4
   118ea:	3128      	adds	r1, #40	; 0x28
   118ec:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, false);
   118ee:	4631      	mov	r1, r6
   118f0:	e7e1      	b.n	118b6 <_spi_m_dma_transfer+0xba>
		return CONF_SERCOM_0_SPI_M_DMA_TX_CHANNEL;
   118f2:	f04f 0b00 	mov.w	fp, #0
   118f6:	e794      	b.n	11822 <_spi_m_dma_transfer+0x26>
	if (rxbuf) {
   118f8:	f1ba 0f00 	cmp.w	sl, #0
   118fc:	d1e7      	bne.n	118ce <_spi_m_dma_transfer+0xd2>
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   118fe:	2408      	movs	r4, #8
   11900:	e793      	b.n	1182a <_spi_m_dma_transfer+0x2e>
   11902:	bf00      	nop
   11904:	00010849 	.word	0x00010849
   11908:	0000df45 	.word	0x0000df45
   1190c:	00017281 	.word	0x00017281
   11910:	000107d1 	.word	0x000107d1
   11914:	0000e0dd 	.word	0x0000e0dd
   11918:	0000e109 	.word	0x0000e109
   1191c:	0000e14d 	.word	0x0000e14d
   11920:	0001098d 	.word	0x0001098d
   11924:	0000e0cd 	.word	0x0000e0cd
   11928:	0000e0ed 	.word	0x0000e0ed

0001192c <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
   1192c:	b570      	push	{r4, r5, r6, lr}
   1192e:	460e      	mov	r6, r1
   11930:	4614      	mov	r4, r2
	ASSERT(rb && buf && size);
   11932:	4605      	mov	r5, r0
   11934:	b118      	cbz	r0, 1193e <ringbuffer_init+0x12>
   11936:	b189      	cbz	r1, 1195c <ringbuffer_init+0x30>
   11938:	1e10      	subs	r0, r2, #0
   1193a:	bf18      	it	ne
   1193c:	2001      	movne	r0, #1
   1193e:	4908      	ldr	r1, [pc, #32]	; (11960 <ringbuffer_init+0x34>)
   11940:	4b08      	ldr	r3, [pc, #32]	; (11964 <ringbuffer_init+0x38>)
   11942:	2228      	movs	r2, #40	; 0x28
   11944:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
   11946:	1e63      	subs	r3, r4, #1
   11948:	ea13 0004 	ands.w	r0, r3, r4
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
	rb->read_index  = 0;
   1194c:	bf03      	ittte	eq
   1194e:	e9c5 3001 	strdeq	r3, r0, [r5, #4]
	rb->write_index = rb->read_index;
   11952:	60e8      	streq	r0, [r5, #12]
	rb->buf         = (uint8_t *)buf;
   11954:	602e      	streq	r6, [r5, #0]
		return ERR_INVALID_ARG;
   11956:	f06f 000c 	mvnne.w	r0, #12

	return ERR_NONE;
}
   1195a:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
   1195c:	4608      	mov	r0, r1
   1195e:	e7ee      	b.n	1193e <ringbuffer_init+0x12>
   11960:	00017370 	.word	0x00017370
   11964:	0000df45 	.word	0x0000df45

00011968 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
   11968:	b538      	push	{r3, r4, r5, lr}
   1196a:	460d      	mov	r5, r1
	ASSERT(rb && data);
   1196c:	4604      	mov	r4, r0
   1196e:	b110      	cbz	r0, 11976 <ringbuffer_get+0xe>
   11970:	1e08      	subs	r0, r1, #0
   11972:	bf18      	it	ne
   11974:	2001      	movne	r0, #1
   11976:	4b0a      	ldr	r3, [pc, #40]	; (119a0 <ringbuffer_get+0x38>)
   11978:	490a      	ldr	r1, [pc, #40]	; (119a4 <ringbuffer_get+0x3c>)
   1197a:	2240      	movs	r2, #64	; 0x40
   1197c:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
   1197e:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   11982:	429a      	cmp	r2, r3
   11984:	d009      	beq.n	1199a <ringbuffer_get+0x32>
		*data = rb->buf[rb->read_index & rb->size];
   11986:	6862      	ldr	r2, [r4, #4]
   11988:	4013      	ands	r3, r2
   1198a:	6822      	ldr	r2, [r4, #0]
   1198c:	5cd3      	ldrb	r3, [r2, r3]
   1198e:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
   11990:	68a3      	ldr	r3, [r4, #8]
   11992:	3301      	adds	r3, #1
   11994:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
   11996:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
   11998:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NOT_FOUND;
   1199a:	f06f 0009 	mvn.w	r0, #9
   1199e:	e7fb      	b.n	11998 <ringbuffer_get+0x30>
   119a0:	0000df45 	.word	0x0000df45
   119a4:	00017370 	.word	0x00017370

000119a8 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
   119a8:	b538      	push	{r3, r4, r5, lr}
	ASSERT(rb);
   119aa:	4604      	mov	r4, r0
   119ac:	3800      	subs	r0, #0
   119ae:	bf18      	it	ne
   119b0:	2001      	movne	r0, #1
{
   119b2:	460d      	mov	r5, r1
	ASSERT(rb);
   119b4:	4b0b      	ldr	r3, [pc, #44]	; (119e4 <ringbuffer_put+0x3c>)
   119b6:	490c      	ldr	r1, [pc, #48]	; (119e8 <ringbuffer_put+0x40>)
   119b8:	2251      	movs	r2, #81	; 0x51
   119ba:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
   119bc:	68e3      	ldr	r3, [r4, #12]
   119be:	6862      	ldr	r2, [r4, #4]
   119c0:	4013      	ands	r3, r2
   119c2:	6822      	ldr	r2, [r4, #0]
   119c4:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
   119c6:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   119ca:	68e3      	ldr	r3, [r4, #12]
   119cc:	1a59      	subs	r1, r3, r1
   119ce:	4291      	cmp	r1, r2
		rb->read_index = rb->write_index - rb->size;
   119d0:	bf88      	it	hi
   119d2:	1a9a      	subhi	r2, r3, r2
	}

	rb->write_index++;
   119d4:	f103 0301 	add.w	r3, r3, #1
		rb->read_index = rb->write_index - rb->size;
   119d8:	bf88      	it	hi
   119da:	60a2      	strhi	r2, [r4, #8]
	rb->write_index++;
   119dc:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
   119de:	2000      	movs	r0, #0
   119e0:	bd38      	pop	{r3, r4, r5, pc}
   119e2:	bf00      	nop
   119e4:	0000df45 	.word	0x0000df45
   119e8:	00017370 	.word	0x00017370

000119ec <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
   119ec:	b510      	push	{r4, lr}
	ASSERT(rb);
   119ee:	4604      	mov	r4, r0
   119f0:	3800      	subs	r0, #0
   119f2:	bf18      	it	ne
   119f4:	2001      	movne	r0, #1
   119f6:	4904      	ldr	r1, [pc, #16]	; (11a08 <ringbuffer_num+0x1c>)
   119f8:	4b04      	ldr	r3, [pc, #16]	; (11a0c <ringbuffer_num+0x20>)
   119fa:	2267      	movs	r2, #103	; 0x67
   119fc:	4798      	blx	r3

	return rb->write_index - rb->read_index;
   119fe:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
}
   11a02:	1ac0      	subs	r0, r0, r3
   11a04:	bd10      	pop	{r4, pc}
   11a06:	bf00      	nop
   11a08:	00017370 	.word	0x00017370
   11a0c:	0000df45 	.word	0x0000df45

00011a10 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   11a10:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
   11a14:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   11a16:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   11a18:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
   11a1c:	4770      	bx	lr

00011a1e <atomic_leave_critical>:
   11a1e:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
   11a22:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   11a24:	f383 8810 	msr	PRIMASK, r3
}
   11a28:	4770      	bx	lr
	...

00011a2c <RTC_Scheduler_ping_cb>:
static struct timer_task RTC_Scheduler_heartbeat;

void RTC_Scheduler_ping_cb(const struct timer_task *const timer_task)
{

	pingflag++;
   11a2c:	4a0d      	ldr	r2, [pc, #52]	; (11a64 <RTC_Scheduler_ping_cb+0x38>)
   11a2e:	7813      	ldrb	r3, [r2, #0]
   11a30:	3301      	adds	r3, #1
   11a32:	b2db      	uxtb	r3, r3
   11a34:	7013      	strb	r3, [r2, #0]
	
	switch (pingflag%4)
   11a36:	7813      	ldrb	r3, [r2, #0]
   11a38:	f003 0303 	and.w	r3, r3, #3
   11a3c:	2b02      	cmp	r3, #2
   11a3e:	f642 7248 	movw	r2, #12104	; 0x2f48
   11a42:	d00a      	beq.n	11a5a <RTC_Scheduler_ping_cb+0x2e>
   11a44:	2b03      	cmp	r3, #3
   11a46:	d00a      	beq.n	11a5e <RTC_Scheduler_ping_cb+0x32>
   11a48:	2b01      	cmp	r3, #1
   11a4a:	d003      	beq.n	11a54 <RTC_Scheduler_ping_cb+0x28>
	{
		case 0:
			GRID_PORT_N.ping_flag = 1;
   11a4c:	4b06      	ldr	r3, [pc, #24]	; (11a68 <RTC_Scheduler_ping_cb+0x3c>)
			break;
		case 2:
			GRID_PORT_S.ping_flag = 1;
			break;
		case 3:
			GRID_PORT_W.ping_flag = 1;
   11a4e:	2101      	movs	r1, #1
   11a50:	5499      	strb	r1, [r3, r2]
			break;
	}
	
}
   11a52:	4770      	bx	lr
			GRID_PORT_E.ping_flag = 1;
   11a54:	4905      	ldr	r1, [pc, #20]	; (11a6c <RTC_Scheduler_ping_cb+0x40>)
   11a56:	548b      	strb	r3, [r1, r2]
			break;
   11a58:	4770      	bx	lr
			GRID_PORT_S.ping_flag = 1;
   11a5a:	4b05      	ldr	r3, [pc, #20]	; (11a70 <RTC_Scheduler_ping_cb+0x44>)
   11a5c:	e7f7      	b.n	11a4e <RTC_Scheduler_ping_cb+0x22>
			GRID_PORT_W.ping_flag = 1;
   11a5e:	4b05      	ldr	r3, [pc, #20]	; (11a74 <RTC_Scheduler_ping_cb+0x48>)
   11a60:	e7f5      	b.n	11a4e <RTC_Scheduler_ping_cb+0x22>
   11a62:	bf00      	nop
   11a64:	200019d0 	.word	0x200019d0
   11a68:	20001b6c 	.word	0x20001b6c
   11a6c:	2001228c 	.word	0x2001228c
   11a70:	2000c2f0 	.word	0x2000c2f0
   11a74:	20008cf0 	.word	0x20008cf0

00011a78 <RTC_Scheduler_heartbeat_cb>:
	}

}

void RTC_Scheduler_heartbeat_cb(const struct timer_task *const timer_task)
{
   11a78:	b410      	push	{r4}
	
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11a7a:	4c04      	ldr	r4, [pc, #16]	; (11a8c <RTC_Scheduler_heartbeat_cb+0x14>)
   11a7c:	4804      	ldr	r0, [pc, #16]	; (11a90 <RTC_Scheduler_heartbeat_cb+0x18>)
   11a7e:	2200      	movs	r2, #0
   11a80:	46a4      	mov	ip, r4
   11a82:	230c      	movs	r3, #12

}
   11a84:	f85d 4b04 	ldr.w	r4, [sp], #4
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11a88:	4611      	mov	r1, r2
   11a8a:	4760      	bx	ip
   11a8c:	0000a191 	.word	0x0000a191
   11a90:	200151dc 	.word	0x200151dc

00011a94 <example_task>:
{
   11a94:	b507      	push	{r0, r1, r2, lr}
		CRITICAL_SECTION_ENTER()
   11a96:	4e08      	ldr	r6, [pc, #32]	; (11ab8 <example_task+0x24>)
		printf("ExampleTask ????... %d \r\n", globaltest);
   11a98:	4d08      	ldr	r5, [pc, #32]	; (11abc <example_task+0x28>)
   11a9a:	4c09      	ldr	r4, [pc, #36]	; (11ac0 <example_task+0x2c>)
		CRITICAL_SECTION_ENTER()
   11a9c:	a801      	add	r0, sp, #4
   11a9e:	47b0      	blx	r6
		printf("ExampleTask ????... %d \r\n", globaltest);
   11aa0:	6869      	ldr	r1, [r5, #4]
   11aa2:	4b08      	ldr	r3, [pc, #32]	; (11ac4 <example_task+0x30>)
   11aa4:	4620      	mov	r0, r4
   11aa6:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
   11aa8:	a801      	add	r0, sp, #4
   11aaa:	4b07      	ldr	r3, [pc, #28]	; (11ac8 <example_task+0x34>)
   11aac:	4798      	blx	r3
		vTaskDelay(500/portTICK_PERIOD_MS);
   11aae:	4b07      	ldr	r3, [pc, #28]	; (11acc <example_task+0x38>)
   11ab0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   11ab4:	4798      	blx	r3
	while (1) {
   11ab6:	e7f1      	b.n	11a9c <example_task+0x8>
   11ab8:	00011a11 	.word	0x00011a11
   11abc:	200019d0 	.word	0x200019d0
   11ac0:	00017394 	.word	0x00017394
   11ac4:	000143b9 	.word	0x000143b9
   11ac8:	00011a1f 	.word	0x00011a1f
   11acc:	00012719 	.word	0x00012719

00011ad0 <usb_task_inner>:
static void usb_task_inner(){
   11ad0:	b570      	push	{r4, r5, r6, lr}
	grid_keyboard_tx_pop();
   11ad2:	4b2c      	ldr	r3, [pc, #176]	; (11b84 <usb_task_inner+0xb4>)
static void usb_task_inner(){
   11ad4:	b08a      	sub	sp, #40	; 0x28
	grid_keyboard_tx_pop();
   11ad6:	4798      	blx	r3
	grid_midi_tx_pop();        
   11ad8:	4b2b      	ldr	r3, [pc, #172]	; (11b88 <usb_task_inner+0xb8>)
   11ada:	4798      	blx	r3
	audiodf_midi_read(midi_rx_buffer,16);
   11adc:	4b2b      	ldr	r3, [pc, #172]	; (11b8c <usb_task_inner+0xbc>)
   11ade:	482c      	ldr	r0, [pc, #176]	; (11b90 <usb_task_inner+0xc0>)
   11ae0:	2110      	movs	r1, #16
   11ae2:	4798      	blx	r3
		if (midi_rx_buffer[i]){
   11ae4:	492b      	ldr	r1, [pc, #172]	; (11b94 <usb_task_inner+0xc4>)
	audiodf_midi_read(midi_rx_buffer,16);
   11ae6:	2200      	movs	r2, #0
	uint8_t found = 0;
   11ae8:	4613      	mov	r3, r2
   11aea:	460d      	mov	r5, r1
		if (midi_rx_buffer[i]){
   11aec:	1888      	adds	r0, r1, r2
   11aee:	7a00      	ldrb	r0, [r0, #8]
   11af0:	b108      	cbz	r0, 11af6 <usb_task_inner+0x26>
			found++;
   11af2:	3301      	adds	r3, #1
   11af4:	b2db      	uxtb	r3, r3
	for (uint8_t i=0; i<16; i++){
   11af6:	3201      	adds	r2, #1
   11af8:	2a10      	cmp	r2, #16
   11afa:	d1f7      	bne.n	11aec <usb_task_inner+0x1c>
	if (found){
   11afc:	b313      	cbz	r3, 11b44 <usb_task_inner+0x74>
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11afe:	7a29      	ldrb	r1, [r5, #8]
   11b00:	7a6a      	ldrb	r2, [r5, #9]
   11b02:	7aab      	ldrb	r3, [r5, #10]
   11b04:	7ae8      	ldrb	r0, [r5, #11]
   11b06:	4c24      	ldr	r4, [pc, #144]	; (11b98 <usb_task_inner+0xc8>)
   11b08:	9000      	str	r0, [sp, #0]
   11b0a:	4824      	ldr	r0, [pc, #144]	; (11b9c <usb_task_inner+0xcc>)
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11b0c:	4e24      	ldr	r6, [pc, #144]	; (11ba0 <usb_task_inner+0xd0>)
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11b0e:	47a0      	blx	r4
		uint8_t message[30] = {0};
   11b10:	2400      	movs	r4, #0
   11b12:	4b24      	ldr	r3, [pc, #144]	; (11ba4 <usb_task_inner+0xd4>)
   11b14:	9402      	str	r4, [sp, #8]
   11b16:	221a      	movs	r2, #26
   11b18:	4621      	mov	r1, r4
   11b1a:	a803      	add	r0, sp, #12
   11b1c:	4798      	blx	r3
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11b1e:	7a2a      	ldrb	r2, [r5, #8]
   11b20:	7a6b      	ldrb	r3, [r5, #9]
   11b22:	7aa9      	ldrb	r1, [r5, #10]
   11b24:	7ae8      	ldrb	r0, [r5, #11]
   11b26:	e9cd 1000 	strd	r1, r0, [sp]
   11b2a:	491c      	ldr	r1, [pc, #112]	; (11b9c <usb_task_inner+0xcc>)
   11b2c:	a802      	add	r0, sp, #8
   11b2e:	47b0      	blx	r6
		grid_debug_print_text(message);
   11b30:	4b1d      	ldr	r3, [pc, #116]	; (11ba8 <usb_task_inner+0xd8>)
   11b32:	a802      	add	r0, sp, #8
   11b34:	4798      	blx	r3
   11b36:	4621      	mov	r1, r4
			midi_rx_buffer[i] = 0;
   11b38:	4622      	mov	r2, r4
   11b3a:	186b      	adds	r3, r5, r1
   11b3c:	3101      	adds	r1, #1
		for (uint8_t i=0; i<16; i++){
   11b3e:	2910      	cmp	r1, #16
			midi_rx_buffer[i] = 0;
   11b40:	721a      	strb	r2, [r3, #8]
		for (uint8_t i=0; i<16; i++){
   11b42:	d1fa      	bne.n	11b3a <usb_task_inner+0x6a>
	cdcdf_acm_read(GRID_PORT_H.rx_double_buffer, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);			
   11b44:	4b19      	ldr	r3, [pc, #100]	; (11bac <usb_task_inner+0xdc>)
   11b46:	481a      	ldr	r0, [pc, #104]	; (11bb0 <usb_task_inner+0xe0>)
   11b48:	f44f 7100 	mov.w	r1, #512	; 0x200
   11b4c:	4798      	blx	r3
	uint16_t usblength = strlen(GRID_PORT_H.rx_double_buffer);
   11b4e:	4818      	ldr	r0, [pc, #96]	; (11bb0 <usb_task_inner+0xe0>)
   11b50:	4b18      	ldr	r3, [pc, #96]	; (11bb4 <usb_task_inner+0xe4>)
   11b52:	4798      	blx	r3
	if (usblength){	
   11b54:	4606      	mov	r6, r0
   11b56:	b190      	cbz	r0, 11b7e <usb_task_inner+0xae>
		GRID_PORT_H.rx_double_buffer_status = 1;			
   11b58:	4d17      	ldr	r5, [pc, #92]	; (11bb8 <usb_task_inner+0xe8>)
   11b5a:	2301      	movs	r3, #1
   11b5c:	622b      	str	r3, [r5, #32]
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   11b5e:	2400      	movs	r4, #0
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   11b60:	1ec3      	subs	r3, r0, #3
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   11b62:	62ac      	str	r4, [r5, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_H);
   11b64:	4628      	mov	r0, r5
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   11b66:	626b      	str	r3, [r5, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_H);
   11b68:	4b14      	ldr	r3, [pc, #80]	; (11bbc <usb_task_inner+0xec>)
   11b6a:	4798      	blx	r3
		for(uint32_t i=0; i<usblength; i++){
   11b6c:	4623      	mov	r3, r4
			GRID_PORT_H.rx_double_buffer[i] = 0;
   11b6e:	f241 32b4 	movw	r2, #5044	; 0x13b4
   11b72:	4620      	mov	r0, r4
   11b74:	18e9      	adds	r1, r5, r3
		for(uint32_t i=0; i<usblength; i++){
   11b76:	3301      	adds	r3, #1
   11b78:	429e      	cmp	r6, r3
			GRID_PORT_H.rx_double_buffer[i] = 0;
   11b7a:	5488      	strb	r0, [r1, r2]
		for(uint32_t i=0; i<usblength; i++){
   11b7c:	d1fa      	bne.n	11b74 <usb_task_inner+0xa4>
}
   11b7e:	b00a      	add	sp, #40	; 0x28
   11b80:	bd70      	pop	{r4, r5, r6, pc}
   11b82:	bf00      	nop
   11b84:	0000b069 	.word	0x0000b069
   11b88:	0000af49 	.word	0x0000af49
   11b8c:	00004565 	.word	0x00004565
   11b90:	200019d8 	.word	0x200019d8
   11b94:	200019d0 	.word	0x200019d0
   11b98:	000143b9 	.word	0x000143b9
   11b9c:	000173ae 	.word	0x000173ae
   11ba0:	000147d1 	.word	0x000147d1
   11ba4:	00014175 	.word	0x00014175
   11ba8:	00009279 	.word	0x00009279
   11bac:	0000bc2d 	.word	0x0000bc2d
   11bb0:	200105f4 	.word	0x200105f4
   11bb4:	00014c81 	.word	0x00014c81
   11bb8:	2000f240 	.word	0x2000f240
   11bbc:	00004d89 	.word	0x00004d89

00011bc0 <receive_task_inner>:
static void receive_task_inner(){
   11bc0:	b510      	push	{r4, lr}
	grid_port_receive_task(&GRID_PORT_N);
   11bc2:	4806      	ldr	r0, [pc, #24]	; (11bdc <receive_task_inner+0x1c>)
   11bc4:	4c06      	ldr	r4, [pc, #24]	; (11be0 <receive_task_inner+0x20>)
   11bc6:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_E);
   11bc8:	4806      	ldr	r0, [pc, #24]	; (11be4 <receive_task_inner+0x24>)
   11bca:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_S);
   11bcc:	4806      	ldr	r0, [pc, #24]	; (11be8 <receive_task_inner+0x28>)
   11bce:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_W);							
   11bd0:	4623      	mov	r3, r4
   11bd2:	4806      	ldr	r0, [pc, #24]	; (11bec <receive_task_inner+0x2c>)
}
   11bd4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_receive_task(&GRID_PORT_W);							
   11bd8:	4718      	bx	r3
   11bda:	bf00      	nop
   11bdc:	20001b6c 	.word	0x20001b6c
   11be0:	00004d89 	.word	0x00004d89
   11be4:	2001228c 	.word	0x2001228c
   11be8:	2000c2f0 	.word	0x2000c2f0
   11bec:	20008cf0 	.word	0x20008cf0

00011bf0 <nvm_task_inner>:
static void nvm_task_inner(){
   11bf0:	b510      	push	{r4, lr}
	if (GRID_PORT_U.rx_double_buffer_status == 0){
   11bf2:	4c1a      	ldr	r4, [pc, #104]	; (11c5c <nvm_task_inner+0x6c>)
   11bf4:	6a23      	ldr	r3, [r4, #32]
   11bf6:	b943      	cbnz	r3, 11c0a <nvm_task_inner+0x1a>
		if (grid_nvm_ui_bulk_read_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11bf8:	4919      	ldr	r1, [pc, #100]	; (11c60 <nvm_task_inner+0x70>)
   11bfa:	481a      	ldr	r0, [pc, #104]	; (11c64 <nvm_task_inner+0x74>)
   11bfc:	4b1a      	ldr	r3, [pc, #104]	; (11c68 <nvm_task_inner+0x78>)
   11bfe:	4798      	blx	r3
   11c00:	b118      	cbz	r0, 11c0a <nvm_task_inner+0x1a>
			grid_nvm_ui_bulk_read_next(&grid_nvm_state, &grid_ui_state);
   11c02:	4917      	ldr	r1, [pc, #92]	; (11c60 <nvm_task_inner+0x70>)
   11c04:	4817      	ldr	r0, [pc, #92]	; (11c64 <nvm_task_inner+0x74>)
   11c06:	4b19      	ldr	r3, [pc, #100]	; (11c6c <nvm_task_inner+0x7c>)
   11c08:	4798      	blx	r3
	if (grid_nvm_ui_bulk_clear_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11c0a:	4915      	ldr	r1, [pc, #84]	; (11c60 <nvm_task_inner+0x70>)
   11c0c:	4815      	ldr	r0, [pc, #84]	; (11c64 <nvm_task_inner+0x74>)
   11c0e:	4b18      	ldr	r3, [pc, #96]	; (11c70 <nvm_task_inner+0x80>)
   11c10:	4798      	blx	r3
   11c12:	b118      	cbz	r0, 11c1c <nvm_task_inner+0x2c>
		grid_nvm_ui_bulk_clear_next(&grid_nvm_state, &grid_ui_state);
   11c14:	4912      	ldr	r1, [pc, #72]	; (11c60 <nvm_task_inner+0x70>)
   11c16:	4813      	ldr	r0, [pc, #76]	; (11c64 <nvm_task_inner+0x74>)
   11c18:	4b16      	ldr	r3, [pc, #88]	; (11c74 <nvm_task_inner+0x84>)
   11c1a:	4798      	blx	r3
	if (grid_nvm_ui_bulk_store_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   11c1c:	4910      	ldr	r1, [pc, #64]	; (11c60 <nvm_task_inner+0x70>)
   11c1e:	4811      	ldr	r0, [pc, #68]	; (11c64 <nvm_task_inner+0x74>)
   11c20:	4b15      	ldr	r3, [pc, #84]	; (11c78 <nvm_task_inner+0x88>)
   11c22:	4798      	blx	r3
   11c24:	b118      	cbz	r0, 11c2e <nvm_task_inner+0x3e>
		grid_nvm_ui_bulk_store_next(&grid_nvm_state, &grid_ui_state);
   11c26:	490e      	ldr	r1, [pc, #56]	; (11c60 <nvm_task_inner+0x70>)
   11c28:	480e      	ldr	r0, [pc, #56]	; (11c64 <nvm_task_inner+0x74>)
   11c2a:	4b14      	ldr	r3, [pc, #80]	; (11c7c <nvm_task_inner+0x8c>)
   11c2c:	4798      	blx	r3
	uint32_t nvmlength = GRID_PORT_U.rx_double_buffer_status;
   11c2e:	6a23      	ldr	r3, [r4, #32]
	if (nvmlength){
   11c30:	b143      	cbz	r3, 11c44 <nvm_task_inner+0x54>
		GRID_PORT_U.rx_double_buffer_status = 1;
   11c32:	2201      	movs	r2, #1
   11c34:	6222      	str	r2, [r4, #32]
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   11c36:	3b01      	subs	r3, #1
		GRID_PORT_U.rx_double_buffer_read_start_index = 0;
   11c38:	2200      	movs	r2, #0
   11c3a:	62a2      	str	r2, [r4, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_U);	
   11c3c:	4807      	ldr	r0, [pc, #28]	; (11c5c <nvm_task_inner+0x6c>)
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   11c3e:	6263      	str	r3, [r4, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_U);	
   11c40:	4b0f      	ldr	r3, [pc, #60]	; (11c80 <nvm_task_inner+0x90>)
   11c42:	4798      	blx	r3
static void nvm_task_inner(){
   11c44:	2300      	movs	r3, #0
		GRID_PORT_U.rx_double_buffer[i] = 0;
   11c46:	f241 32b4 	movw	r2, #5044	; 0x13b4
   11c4a:	4618      	mov	r0, r3
   11c4c:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   11c4e:	3301      	adds	r3, #1
   11c50:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
		GRID_PORT_U.rx_double_buffer[i] = 0;
   11c54:	5488      	strb	r0, [r1, r2]
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   11c56:	d1f9      	bne.n	11c4c <nvm_task_inner+0x5c>
}
   11c58:	bd10      	pop	{r4, pc}
   11c5a:	bf00      	nop
   11c5c:	20004acc 	.word	0x20004acc
   11c60:	20007a18 	.word	0x20007a18
   11c64:	20008438 	.word	0x20008438
   11c68:	0000882f 	.word	0x0000882f
   11c6c:	00008835 	.word	0x00008835
   11c70:	00008b07 	.word	0x00008b07
   11c74:	00008b0d 	.word	0x00008b0d
   11c78:	00008943 	.word	0x00008943
   11c7c:	00008949 	.word	0x00008949
   11c80:	00004d89 	.word	0x00004d89

00011c84 <inbound_task_inner>:
static void inbound_task_inner(){
   11c84:	b510      	push	{r4, lr}
	grid_port_process_inbound(&GRID_PORT_U, 1); // Loopback
   11c86:	2101      	movs	r1, #1
   11c88:	4c0a      	ldr	r4, [pc, #40]	; (11cb4 <inbound_task_inner+0x30>)
   11c8a:	480b      	ldr	r0, [pc, #44]	; (11cb8 <inbound_task_inner+0x34>)
   11c8c:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_N, 0);		
   11c8e:	2100      	movs	r1, #0
   11c90:	480a      	ldr	r0, [pc, #40]	; (11cbc <inbound_task_inner+0x38>)
   11c92:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_E, 0);		
   11c94:	2100      	movs	r1, #0
   11c96:	480a      	ldr	r0, [pc, #40]	; (11cc0 <inbound_task_inner+0x3c>)
   11c98:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_S, 0);
   11c9a:	2100      	movs	r1, #0
   11c9c:	4809      	ldr	r0, [pc, #36]	; (11cc4 <inbound_task_inner+0x40>)
   11c9e:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_W, 0);
   11ca0:	2100      	movs	r1, #0
   11ca2:	4809      	ldr	r0, [pc, #36]	; (11cc8 <inbound_task_inner+0x44>)
   11ca4:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   11ca6:	4623      	mov	r3, r4
   11ca8:	4808      	ldr	r0, [pc, #32]	; (11ccc <inbound_task_inner+0x48>)
}
   11caa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   11cae:	2100      	movs	r1, #0
   11cb0:	4718      	bx	r3
   11cb2:	bf00      	nop
   11cb4:	00005209 	.word	0x00005209
   11cb8:	20004acc 	.word	0x20004acc
   11cbc:	20001b6c 	.word	0x20001b6c
   11cc0:	2001228c 	.word	0x2001228c
   11cc4:	2000c2f0 	.word	0x2000c2f0
   11cc8:	20008cf0 	.word	0x20008cf0
   11ccc:	2000f240 	.word	0x2000f240

00011cd0 <outbound_task_inner>:
static void outbound_task_inner(){
   11cd0:	b510      	push	{r4, lr}
	grid_port_process_outbound_usart(&GRID_PORT_N);
   11cd2:	4808      	ldr	r0, [pc, #32]	; (11cf4 <outbound_task_inner+0x24>)
   11cd4:	4c08      	ldr	r4, [pc, #32]	; (11cf8 <outbound_task_inner+0x28>)
   11cd6:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_E);
   11cd8:	4808      	ldr	r0, [pc, #32]	; (11cfc <outbound_task_inner+0x2c>)
   11cda:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_S);
   11cdc:	4808      	ldr	r0, [pc, #32]	; (11d00 <outbound_task_inner+0x30>)
   11cde:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_W);
   11ce0:	4808      	ldr	r0, [pc, #32]	; (11d04 <outbound_task_inner+0x34>)
   11ce2:	47a0      	blx	r4
	grid_port_process_outbound_usb(&GRID_PORT_H);
   11ce4:	4b08      	ldr	r3, [pc, #32]	; (11d08 <outbound_task_inner+0x38>)
   11ce6:	4809      	ldr	r0, [pc, #36]	; (11d0c <outbound_task_inner+0x3c>)
   11ce8:	4798      	blx	r3
}
   11cea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_outbound_ui(&GRID_PORT_U);
   11cee:	4808      	ldr	r0, [pc, #32]	; (11d10 <outbound_task_inner+0x40>)
   11cf0:	4b08      	ldr	r3, [pc, #32]	; (11d14 <outbound_task_inner+0x44>)
   11cf2:	4718      	bx	r3
   11cf4:	20001b6c 	.word	0x20001b6c
   11cf8:	00006315 	.word	0x00006315
   11cfc:	2001228c 	.word	0x2001228c
   11d00:	2000c2f0 	.word	0x2000c2f0
   11d04:	20008cf0 	.word	0x20008cf0
   11d08:	000053cd 	.word	0x000053cd
   11d0c:	2000f240 	.word	0x2000f240
   11d10:	20004acc 	.word	0x20004acc
   11d14:	000056c1 	.word	0x000056c1

00011d18 <led_task_inner>:
static void led_task_inner(){
   11d18:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (grid_sys_state.alert_state){
   11d1c:	4c45      	ldr	r4, [pc, #276]	; (11e34 <led_task_inner+0x11c>)
static void led_task_inner(){
   11d1e:	ed2d 8b02 	vpush	{d8}
	if (grid_sys_state.alert_state){
   11d22:	8963      	ldrh	r3, [r4, #10]
   11d24:	b29b      	uxth	r3, r3
static void led_task_inner(){
   11d26:	b083      	sub	sp, #12
	if (grid_sys_state.alert_state){
   11d28:	b98b      	cbnz	r3, 11d4e <led_task_inner+0x36>
	grid_task_enter_task(&grid_task_state, GRID_TASK_LED);
   11d2a:	2106      	movs	r1, #6
   11d2c:	4b42      	ldr	r3, [pc, #264]	; (11e38 <led_task_inner+0x120>)
   11d2e:	4843      	ldr	r0, [pc, #268]	; (11e3c <led_task_inner+0x124>)
   11d30:	4798      	blx	r3
	grid_led_tick(&grid_led_state);
   11d32:	4843      	ldr	r0, [pc, #268]	; (11e40 <led_task_inner+0x128>)
   11d34:	4b43      	ldr	r3, [pc, #268]	; (11e44 <led_task_inner+0x12c>)
   11d36:	4798      	blx	r3
	grid_led_lowlevel_render_all(&grid_led_state);	
   11d38:	4841      	ldr	r0, [pc, #260]	; (11e40 <led_task_inner+0x128>)
   11d3a:	4b43      	ldr	r3, [pc, #268]	; (11e48 <led_task_inner+0x130>)
   11d3c:	4798      	blx	r3
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   11d3e:	4840      	ldr	r0, [pc, #256]	; (11e40 <led_task_inner+0x128>)
   11d40:	4b42      	ldr	r3, [pc, #264]	; (11e4c <led_task_inner+0x134>)
}
   11d42:	b003      	add	sp, #12
   11d44:	ecbd 8b02 	vpop	{d8}
   11d48:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   11d4c:	4718      	bx	r3
		grid_sys_state.alert_state--;
   11d4e:	8963      	ldrh	r3, [r4, #10]
   11d50:	3b01      	subs	r3, #1
   11d52:	b29b      	uxth	r3, r3
   11d54:	8163      	strh	r3, [r4, #10]
		if (grid_sys_alert_read_color_changed_flag(&grid_sys_state)){
   11d56:	4620      	mov	r0, r4
   11d58:	4b3d      	ldr	r3, [pc, #244]	; (11e50 <led_task_inner+0x138>)
   11d5a:	4798      	blx	r3
   11d5c:	b988      	cbnz	r0, 11d82 <led_task_inner+0x6a>
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11d5e:	4835      	ldr	r0, [pc, #212]	; (11e34 <led_task_inner+0x11c>)
   11d60:	4b3c      	ldr	r3, [pc, #240]	; (11e54 <led_task_inner+0x13c>)
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   11d62:	4e37      	ldr	r6, [pc, #220]	; (11e40 <led_task_inner+0x128>)
   11d64:	4f3c      	ldr	r7, [pc, #240]	; (11e58 <led_task_inner+0x140>)
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11d66:	4798      	blx	r3
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11d68:	2400      	movs	r4, #0
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   11d6a:	4605      	mov	r5, r0
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11d6c:	4b34      	ldr	r3, [pc, #208]	; (11e40 <led_task_inner+0x128>)
   11d6e:	785b      	ldrb	r3, [r3, #1]
   11d70:	b2e1      	uxtb	r1, r4
   11d72:	428b      	cmp	r3, r1
   11d74:	d9d9      	bls.n	11d2a <led_task_inner+0x12>
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   11d76:	462b      	mov	r3, r5
   11d78:	2200      	movs	r2, #0
   11d7a:	4630      	mov	r0, r6
   11d7c:	47b8      	blx	r7
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   11d7e:	3401      	adds	r4, #1
   11d80:	e7f4      	b.n	11d6c <led_task_inner+0x54>
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   11d82:	4b36      	ldr	r3, [pc, #216]	; (11e5c <led_task_inner+0x144>)
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11d84:	4e2e      	ldr	r6, [pc, #184]	; (11e40 <led_task_inner+0x128>)
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   11d86:	4620      	mov	r0, r4
   11d88:	4798      	blx	r3
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   11d8a:	4b35      	ldr	r3, [pc, #212]	; (11e60 <led_task_inner+0x148>)
   11d8c:	4620      	mov	r0, r4
   11d8e:	4798      	blx	r3
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11d90:	4b34      	ldr	r3, [pc, #208]	; (11e64 <led_task_inner+0x14c>)
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   11d92:	ee08 0a10 	vmov	s16, r0
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11d96:	4620      	mov	r0, r4
   11d98:	4798      	blx	r3
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11d9a:	4b33      	ldr	r3, [pc, #204]	; (11e68 <led_task_inner+0x150>)
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   11d9c:	4682      	mov	sl, r0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11d9e:	4620      	mov	r0, r4
   11da0:	4798      	blx	r3
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11da2:	f04f 0900 	mov.w	r9, #0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   11da6:	4683      	mov	fp, r0
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11da8:	4b30      	ldr	r3, [pc, #192]	; (11e6c <led_task_inner+0x154>)
   11daa:	4630      	mov	r0, r6
   11dac:	4798      	blx	r3
   11dae:	fa5f f589 	uxtb.w	r5, r9
   11db2:	42a8      	cmp	r0, r5
   11db4:	f109 0901 	add.w	r9, r9, #1
   11db8:	d9d1      	bls.n	11d5e <led_task_inner+0x46>
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   11dba:	2400      	movs	r4, #0
   11dbc:	4622      	mov	r2, r4
   11dbe:	e9cd 4400 	strd	r4, r4, [sp]
   11dc2:	4623      	mov	r3, r4
   11dc4:	4629      	mov	r1, r5
   11dc6:	4630      	mov	r0, r6
   11dc8:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 11e80 <led_task_inner+0x168>
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   11dcc:	4f28      	ldr	r7, [pc, #160]	; (11e70 <led_task_inner+0x158>)
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   11dce:	47c0      	blx	r8
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   11dd0:	ee18 0a10 	vmov	r0, s16
   11dd4:	4b27      	ldr	r3, [pc, #156]	; (11e74 <led_task_inner+0x15c>)
   11dd6:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 11e84 <led_task_inner+0x16c>
   11dda:	4798      	blx	r3
   11ddc:	4b26      	ldr	r3, [pc, #152]	; (11e78 <led_task_inner+0x160>)
   11dde:	2200      	movs	r2, #0
   11de0:	47b8      	blx	r7
   11de2:	47c0      	blx	r8
   11de4:	4b23      	ldr	r3, [pc, #140]	; (11e74 <led_task_inner+0x15c>)
   11de6:	b2c2      	uxtb	r2, r0
   11de8:	4658      	mov	r0, fp
   11dea:	ee08 2a90 	vmov	s17, r2
   11dee:	4798      	blx	r3
   11df0:	2200      	movs	r2, #0
   11df2:	4b21      	ldr	r3, [pc, #132]	; (11e78 <led_task_inner+0x160>)
   11df4:	47b8      	blx	r7
   11df6:	47c0      	blx	r8
   11df8:	b2c0      	uxtb	r0, r0
   11dfa:	9001      	str	r0, [sp, #4]
   11dfc:	4b1d      	ldr	r3, [pc, #116]	; (11e74 <led_task_inner+0x15c>)
   11dfe:	4650      	mov	r0, sl
   11e00:	4798      	blx	r3
   11e02:	4b1d      	ldr	r3, [pc, #116]	; (11e78 <led_task_inner+0x160>)
   11e04:	2200      	movs	r2, #0
   11e06:	47b8      	blx	r7
   11e08:	47c0      	blx	r8
   11e0a:	b2c0      	uxtb	r0, r0
   11e0c:	ee18 3a90 	vmov	r3, s17
   11e10:	9000      	str	r0, [sp, #0]
   11e12:	4622      	mov	r2, r4
   11e14:	4629      	mov	r1, r5
   11e16:	4630      	mov	r0, r6
   11e18:	f8df 806c 	ldr.w	r8, [pc, #108]	; 11e88 <led_task_inner+0x170>
   11e1c:	47c0      	blx	r8
				grid_led_set_max(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*1   , color_g*1   , color_b*1);
   11e1e:	4622      	mov	r2, r4
   11e20:	e9cd ab00 	strd	sl, fp, [sp]
   11e24:	ee18 3a10 	vmov	r3, s16
   11e28:	4c14      	ldr	r4, [pc, #80]	; (11e7c <led_task_inner+0x164>)
   11e2a:	4629      	mov	r1, r5
   11e2c:	4630      	mov	r0, r6
   11e2e:	47a0      	blx	r4
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   11e30:	e7ba      	b.n	11da8 <led_task_inner+0x90>
   11e32:	bf00      	nop
   11e34:	20007a24 	.word	0x20007a24
   11e38:	00008d7b 	.word	0x00008d7b
   11e3c:	20008ccc 	.word	0x20008ccc
   11e40:	20015254 	.word	0x20015254
   11e44:	00006c89 	.word	0x00006c89
   11e48:	00007079 	.word	0x00007079
   11e4c:	00007099 	.word	0x00007099
   11e50:	000097c5 	.word	0x000097c5
   11e54:	000097cf 	.word	0x000097cf
   11e58:	00006d91 	.word	0x00006d91
   11e5c:	000097c9 	.word	0x000097c9
   11e60:	0000982d 	.word	0x0000982d
   11e64:	00009831 	.word	0x00009831
   11e68:	00009835 	.word	0x00009835
   11e6c:	00006c85 	.word	0x00006c85
   11e70:	00013b75 	.word	0x00013b75
   11e74:	00013aa1 	.word	0x00013aa1
   11e78:	3fe00000 	.word	0x3fe00000
   11e7c:	00006d01 	.word	0x00006d01
   11e80:	00006cc1 	.word	0x00006cc1
   11e84:	00013f99 	.word	0x00013f99
   11e88:	00006ce1 	.word	0x00006ce1

00011e8c <led_task>:
{
   11e8c:	b508      	push	{r3, lr}
		globaltest++;
   11e8e:	4c05      	ldr	r4, [pc, #20]	; (11ea4 <led_task+0x18>)
		led_task_inner();
   11e90:	4e05      	ldr	r6, [pc, #20]	; (11ea8 <led_task+0x1c>)
		vTaskDelay(10/portTICK_PERIOD_MS);
   11e92:	4d06      	ldr	r5, [pc, #24]	; (11eac <led_task+0x20>)
		globaltest++;
   11e94:	6863      	ldr	r3, [r4, #4]
   11e96:	3301      	adds	r3, #1
   11e98:	6063      	str	r3, [r4, #4]
		led_task_inner();
   11e9a:	47b0      	blx	r6
		vTaskDelay(10/portTICK_PERIOD_MS);
   11e9c:	200a      	movs	r0, #10
   11e9e:	47a8      	blx	r5
	while (1) {
   11ea0:	e7f8      	b.n	11e94 <led_task+0x8>
   11ea2:	bf00      	nop
   11ea4:	200019d0 	.word	0x200019d0
   11ea8:	00011d19 	.word	0x00011d19
   11eac:	00012719 	.word	0x00012719

00011eb0 <RTC_Scheduler_realtime_cb>:
{
   11eb0:	b537      	push	{r0, r1, r2, r4, r5, lr}
	grid_sys_rtc_tick_time(&grid_sys_state);	
   11eb2:	4d16      	ldr	r5, [pc, #88]	; (11f0c <RTC_Scheduler_realtime_cb+0x5c>)
   11eb4:	4b16      	ldr	r3, [pc, #88]	; (11f10 <RTC_Scheduler_realtime_cb+0x60>)
   11eb6:	4628      	mov	r0, r5
   11eb8:	4798      	blx	r3
	grid_task_timer_tick(&grid_task_state);
   11eba:	4816      	ldr	r0, [pc, #88]	; (11f14 <RTC_Scheduler_realtime_cb+0x64>)
   11ebc:	4b16      	ldr	r3, [pc, #88]	; (11f18 <RTC_Scheduler_realtime_cb+0x68>)
   11ebe:	4798      	blx	r3
	CRITICAL_SECTION_ENTER();
   11ec0:	4b16      	ldr	r3, [pc, #88]	; (11f1c <RTC_Scheduler_realtime_cb+0x6c>)
   11ec2:	a801      	add	r0, sp, #4
   11ec4:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
   11ec6:	4a16      	ldr	r2, [pc, #88]	; (11f20 <RTC_Scheduler_realtime_cb+0x70>)
   11ec8:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
	return ((Port *)hw)->Group[submodule_index].IN.reg;
   11ecc:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
   11ed0:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
   11ed4:	405c      	eors	r4, r3
   11ed6:	400c      	ands	r4, r1
   11ed8:	405c      	eors	r4, r3
	CRITICAL_SECTION_LEAVE();
   11eda:	a801      	add	r0, sp, #4
   11edc:	4b11      	ldr	r3, [pc, #68]	; (11f24 <RTC_Scheduler_realtime_cb+0x74>)
   11ede:	4798      	blx	r3
	if (mapmode_value != grid_sys_state.mapmodestate){
   11ee0:	7c2a      	ldrb	r2, [r5, #16]
	uint8_t mapmode_value = !gpio_get_pin_level(MAP_MODE);
   11ee2:	f484 6300 	eor.w	r3, r4, #2048	; 0x800
   11ee6:	f3c3 23c0 	ubfx	r3, r3, #11, #1
	if (mapmode_value != grid_sys_state.mapmodestate){
   11eea:	429a      	cmp	r2, r3
   11eec:	d009      	beq.n	11f02 <RTC_Scheduler_realtime_cb+0x52>
		grid_sys_state.mapmodestate = mapmode_value;
   11eee:	742b      	strb	r3, [r5, #16]
		if (grid_sys_state.mapmodestate == 0){ // RELEASE
   11ef0:	7c2b      	ldrb	r3, [r5, #16]
   11ef2:	4c0d      	ldr	r4, [pc, #52]	; (11f28 <RTC_Scheduler_realtime_cb+0x78>)
   11ef4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   11ef8:	b92b      	cbnz	r3, 11f06 <RTC_Scheduler_realtime_cb+0x56>
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_RELEASE);
   11efa:	2308      	movs	r3, #8
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   11efc:	480b      	ldr	r0, [pc, #44]	; (11f2c <RTC_Scheduler_realtime_cb+0x7c>)
   11efe:	4611      	mov	r1, r2
   11f00:	47a0      	blx	r4
}
   11f02:	b003      	add	sp, #12
   11f04:	bd30      	pop	{r4, r5, pc}
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   11f06:	2307      	movs	r3, #7
   11f08:	2200      	movs	r2, #0
   11f0a:	e7f7      	b.n	11efc <RTC_Scheduler_realtime_cb+0x4c>
   11f0c:	20007a24 	.word	0x20007a24
   11f10:	000097b3 	.word	0x000097b3
   11f14:	20008ccc 	.word	0x20008ccc
   11f18:	00008d83 	.word	0x00008d83
   11f1c:	00011a11 	.word	0x00011a11
   11f20:	41008000 	.word	0x41008000
   11f24:	00011a1f 	.word	0x00011a1f
   11f28:	0000a191 	.word	0x0000a191
   11f2c:	200151dc 	.word	0x200151dc

00011f30 <init_timer>:


void init_timer(void)
{
   11f30:	b570      	push	{r4, r5, r6, lr}
	
		
	//RTC_Scheduler_ping.interval = RTC1SEC/20; //50ms
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   11f32:	4c14      	ldr	r4, [pc, #80]	; (11f84 <init_timer+0x54>)
	
	RTC_Scheduler_realtime.interval = 1;
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;

	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   11f34:	4d14      	ldr	r5, [pc, #80]	; (11f88 <init_timer+0x58>)
   11f36:	4e15      	ldr	r6, [pc, #84]	; (11f8c <init_timer+0x5c>)
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   11f38:	f44f 63c8 	mov.w	r3, #1600	; 0x640
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   11f3c:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   11f40:	6223      	str	r3, [r4, #32]
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   11f42:	6362      	str	r2, [r4, #52]	; 0x34
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   11f44:	4b12      	ldr	r3, [pc, #72]	; (11f90 <init_timer+0x60>)
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   11f46:	4a13      	ldr	r2, [pc, #76]	; (11f94 <init_timer+0x64>)
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   11f48:	6263      	str	r3, [r4, #36]	; 0x24
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   11f4a:	63a2      	str	r2, [r4, #56]	; 0x38
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   11f4c:	2301      	movs	r3, #1
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   11f4e:	4a12      	ldr	r2, [pc, #72]	; (11f98 <init_timer+0x68>)
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   11f50:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   11f54:	f104 0118 	add.w	r1, r4, #24
   11f58:	4628      	mov	r0, r5
	RTC_Scheduler_heartbeat.mode     = TIMER_TASK_REPEAT;
   11f5a:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	RTC_Scheduler_realtime.interval = 1;
   11f5e:	64a3      	str	r3, [r4, #72]	; 0x48
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;
   11f60:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   11f64:	64e2      	str	r2, [r4, #76]	; 0x4c
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   11f66:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_heartbeat);
   11f68:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   11f6c:	4628      	mov	r0, r5
   11f6e:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_realtime);
   11f70:	f104 0140 	add.w	r1, r4, #64	; 0x40
   11f74:	4628      	mov	r0, r5
   11f76:	47b0      	blx	r6
	
	timer_start(&RTC_Scheduler);
   11f78:	4628      	mov	r0, r5
   11f7a:	4b08      	ldr	r3, [pc, #32]	; (11f9c <init_timer+0x6c>)
	
}
   11f7c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	timer_start(&RTC_Scheduler);
   11f80:	4718      	bx	r3
   11f82:	bf00      	nop
   11f84:	200019d0 	.word	0x200019d0
   11f88:	200156d8 	.word	0x200156d8
   11f8c:	0000c95d 	.word	0x0000c95d
   11f90:	00011a2d 	.word	0x00011a2d
   11f94:	00011a79 	.word	0x00011a79
   11f98:	00011eb1 	.word	0x00011eb1
   11f9c:	0000c91d 	.word	0x0000c91d

00011fa0 <main>:

//====================== USB TEST =====================//

int main(void)
{
   11fa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	


	atmel_start_init();	
   11fa4:	4b59      	ldr	r3, [pc, #356]	; (1210c <main+0x16c>)
    
            
            
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   11fa6:	4c5a      	ldr	r4, [pc, #360]	; (12110 <main+0x170>)
	// 	while (1) {
	// 		;
	// 	}
	// }

	if (xTaskCreate(example_task, "Example", TASK_EXAMPLE_STACK_SIZE/4, NULL, TASK_EXAMPLE_STACK_PRIORITY, &xCreatedExampleTask)
   11fa8:	4d5a      	ldr	r5, [pc, #360]	; (12114 <main+0x174>)
   11faa:	4e5b      	ldr	r6, [pc, #364]	; (12118 <main+0x178>)
{
   11fac:	b085      	sub	sp, #20
	atmel_start_init();	
   11fae:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   11fb0:	495a      	ldr	r1, [pc, #360]	; (1211c <main+0x17c>)
   11fb2:	485b      	ldr	r0, [pc, #364]	; (12120 <main+0x180>)
   11fb4:	47a0      	blx	r4
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "D51 Init");
   11fb6:	495b      	ldr	r1, [pc, #364]	; (12124 <main+0x184>)
   11fb8:	4859      	ldr	r0, [pc, #356]	; (12120 <main+0x180>)
   11fba:	47a0      	blx	r4
	grid_d51_init(); // Check User Row
   11fbc:	4b5a      	ldr	r3, [pc, #360]	; (12128 <main+0x188>)
   11fbe:	4798      	blx	r3
	audiodf_midi_init();
   11fc0:	4b5a      	ldr	r3, [pc, #360]	; (1212c <main+0x18c>)
   11fc2:	4798      	blx	r3
	composite_device_start();
   11fc4:	4b5a      	ldr	r3, [pc, #360]	; (12130 <main+0x190>)
   11fc6:	4798      	blx	r3
	grid_usb_serial_init();
   11fc8:	4b5a      	ldr	r3, [pc, #360]	; (12134 <main+0x194>)
   11fca:	4798      	blx	r3
	grid_usb_midi_init();
   11fcc:	4b5a      	ldr	r3, [pc, #360]	; (12138 <main+0x198>)
   11fce:	4798      	blx	r3
	grid_keyboard_init(&grid_keyboard_state);
   11fd0:	4b5a      	ldr	r3, [pc, #360]	; (1213c <main+0x19c>)
   11fd2:	485b      	ldr	r0, [pc, #364]	; (12140 <main+0x1a0>)
   11fd4:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Initialized");
   11fd6:	495b      	ldr	r1, [pc, #364]	; (12144 <main+0x1a4>)
   11fd8:	4851      	ldr	r0, [pc, #324]	; (12120 <main+0x180>)
   11fda:	47a0      	blx	r4
	rand_sync_enable(&RAND_0);	
   11fdc:	4b5a      	ldr	r3, [pc, #360]	; (12148 <main+0x1a8>)
   11fde:	485b      	ldr	r0, [pc, #364]	; (1214c <main+0x1ac>)
   11fe0:	4798      	blx	r3
	grid_expr_init(&grid_expr_state);
   11fe2:	485b      	ldr	r0, [pc, #364]	; (12150 <main+0x1b0>)
   11fe4:	4b5b      	ldr	r3, [pc, #364]	; (12154 <main+0x1b4>)
   11fe6:	4798      	blx	r3
	grid_module_common_init();
   11fe8:	4b5b      	ldr	r3, [pc, #364]	; (12158 <main+0x1b8>)
   11fea:	4798      	blx	r3
    grid_ui_reinit(&grid_ui_state);
   11fec:	4b5b      	ldr	r3, [pc, #364]	; (1215c <main+0x1bc>)
   11fee:	485c      	ldr	r0, [pc, #368]	; (12160 <main+0x1c0>)
   11ff0:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Grid Module Initialized");
   11ff2:	495c      	ldr	r1, [pc, #368]	; (12164 <main+0x1c4>)
   11ff4:	484a      	ldr	r0, [pc, #296]	; (12120 <main+0x180>)
   11ff6:	47a0      	blx	r4
	init_timer();
   11ff8:	4b5b      	ldr	r3, [pc, #364]	; (12168 <main+0x1c8>)
   11ffa:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Entering Main Loop");
   11ffc:	495b      	ldr	r1, [pc, #364]	; (1216c <main+0x1cc>)
   11ffe:	4848      	ldr	r0, [pc, #288]	; (12120 <main+0x180>)
   12000:	47a0      	blx	r4
	grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
   12002:	495b      	ldr	r1, [pc, #364]	; (12170 <main+0x1d0>)
   12004:	485b      	ldr	r0, [pc, #364]	; (12174 <main+0x1d4>)
   12006:	4b5c      	ldr	r3, [pc, #368]	; (12178 <main+0x1d8>)
   12008:	4798      	blx	r3
	grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);	
   1200a:	4959      	ldr	r1, [pc, #356]	; (12170 <main+0x1d0>)
   1200c:	4854      	ldr	r0, [pc, #336]	; (12160 <main+0x1c0>)
   1200e:	4b5b      	ldr	r3, [pc, #364]	; (1217c <main+0x1dc>)
   12010:	4798      	blx	r3
	if (xTaskCreate(example_task, "Example", TASK_EXAMPLE_STACK_SIZE/4, NULL, TASK_EXAMPLE_STACK_PRIORITY, &xCreatedExampleTask)
   12012:	2302      	movs	r3, #2
   12014:	9300      	str	r3, [sp, #0]
   12016:	495a      	ldr	r1, [pc, #360]	; (12180 <main+0x1e0>)
   12018:	485a      	ldr	r0, [pc, #360]	; (12184 <main+0x1e4>)
   1201a:	9501      	str	r5, [sp, #4]
   1201c:	2300      	movs	r3, #0
   1201e:	2220      	movs	r2, #32
   12020:	47b0      	blx	r6
   12022:	2801      	cmp	r0, #1
   12024:	9403      	str	r4, [sp, #12]
   12026:	d000      	beq.n	1202a <main+0x8a>
	    != pdPASS) {
		while (1) {
   12028:	e7fe      	b.n	12028 <main+0x88>
	// 		;
	// 	}
	// }


	if (xTaskCreate(led_task, "Led Task", ((2*512)/sizeof(portSTACK_TYPE)), NULL, tskIDLE_PRIORITY +1, &xCreatedLedTask)
   1202a:	3504      	adds	r5, #4
   1202c:	e9cd 0500 	strd	r0, r5, [sp]
   12030:	4955      	ldr	r1, [pc, #340]	; (12188 <main+0x1e8>)
   12032:	4856      	ldr	r0, [pc, #344]	; (1218c <main+0x1ec>)
   12034:	2300      	movs	r3, #0
   12036:	f44f 7280 	mov.w	r2, #256	; 0x100
   1203a:	47b0      	blx	r6
   1203c:	2801      	cmp	r0, #1
   1203e:	d000      	beq.n	12042 <main+0xa2>
	    != pdPASS) {
		while (1) {
   12040:	e7fe      	b.n	12040 <main+0xa0>
   12042:	4d53      	ldr	r5, [pc, #332]	; (12190 <main+0x1f0>)
   12044:	f8df a188 	ldr.w	sl, [pc, #392]	; 121d0 <main+0x230>
	uint32_t loopcounter = 0;
   12048:	2400      	movs	r4, #0
	
		
		if (usb_init_flag == 0){
			
			
			if (usb_d_get_frame_num() == 0){
   1204a:	4b52      	ldr	r3, [pc, #328]	; (12194 <main+0x1f4>)
   1204c:	f8df 9184 	ldr.w	r9, [pc, #388]	; 121d4 <main+0x234>
   12050:	f8df 8184 	ldr.w	r8, [pc, #388]	; 121d8 <main+0x238>
   12054:	4f50      	ldr	r7, [pc, #320]	; (12198 <main+0x1f8>)
   12056:	4e51      	ldr	r6, [pc, #324]	; (1219c <main+0x1fc>)
   12058:	4798      	blx	r3
   1205a:	2800      	cmp	r0, #0
   1205c:	d031      	beq.n	120c2 <main+0x122>
				
			}
			else{			
			
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN	
   1205e:	2400      	movs	r4, #0
   12060:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   12064:	22ff      	movs	r2, #255	; 0xff
   12066:	e9cd 4300 	strd	r4, r3, [sp]
   1206a:	4621      	mov	r1, r4
   1206c:	4623      	mov	r3, r4
   1206e:	4841      	ldr	r0, [pc, #260]	; (12174 <main+0x1d4>)
   12070:	f8df b168 	ldr.w	fp, [pc, #360]	; 121dc <main+0x23c>
   12074:	47d8      	blx	fp
				
				GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Connected");
   12076:	494a      	ldr	r1, [pc, #296]	; (121a0 <main+0x200>)
   12078:	9b03      	ldr	r3, [sp, #12]
   1207a:	4829      	ldr	r0, [pc, #164]	; (12120 <main+0x180>)
   1207c:	4798      	blx	r3
				
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   1207e:	4b49      	ldr	r3, [pc, #292]	; (121a4 <main+0x204>)
   12080:	483c      	ldr	r0, [pc, #240]	; (12174 <main+0x1d4>)
   12082:	4798      	blx	r3
   12084:	4b48      	ldr	r3, [pc, #288]	; (121a8 <main+0x208>)
   12086:	4601      	mov	r1, r0
   12088:	483a      	ldr	r0, [pc, #232]	; (12174 <main+0x1d4>)
   1208a:	4798      	blx	r3
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   1208c:	4622      	mov	r2, r4
   1208e:	4621      	mov	r1, r4
   12090:	4846      	ldr	r0, [pc, #280]	; (121ac <main+0x20c>)
   12092:	4c47      	ldr	r4, [pc, #284]	; (121b0 <main+0x210>)
   12094:	2309      	movs	r3, #9
   12096:	47a0      	blx	r4
				
				usb_init_flag = 1;
				
				

				printf("Forever! \r\n");
   12098:	4b46      	ldr	r3, [pc, #280]	; (121b4 <main+0x214>)
   1209a:	4847      	ldr	r0, [pc, #284]	; (121b8 <main+0x218>)
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   1209c:	4c47      	ldr	r4, [pc, #284]	; (121bc <main+0x21c>)
				printf("Forever! \r\n");
   1209e:	4798      	blx	r3
				delay_ms(2);
   120a0:	2002      	movs	r0, #2
   120a2:	47a8      	blx	r5


				vTaskStartScheduler();
   120a4:	4b46      	ldr	r3, [pc, #280]	; (121c0 <main+0x220>)
   120a6:	4798      	blx	r3

				while(1){
				
		
					
					usb_task_inner();
   120a8:	47d0      	blx	sl
					nvm_task_inner();
   120aa:	47c8      	blx	r9

					receive_task_inner();
   120ac:	47c0      	blx	r8
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   120ae:	4620      	mov	r0, r4
   120b0:	47b8      	blx	r7

					ui_task_inner();

					inbound_task_inner();
   120b2:	47b0      	blx	r6

					outbound_task_inner();
   120b4:	4b43      	ldr	r3, [pc, #268]	; (121c4 <main+0x224>)
   120b6:	4798      	blx	r3

					led_task_inner();
   120b8:	4b43      	ldr	r3, [pc, #268]	; (121c8 <main+0x228>)
   120ba:	4798      	blx	r3

					delay_ms(1);
   120bc:	2001      	movs	r0, #1
   120be:	47a8      	blx	r5
				while(1){
   120c0:	e7f2      	b.n	120a8 <main+0x108>
		
		
		
		// Request neighbor bank settings if we don't have it initialized
		
 		if (grid_sys_get_bank_valid(&grid_sys_state) == 0 && loopcounter%80 == 0){
   120c2:	f8df b0b0 	ldr.w	fp, [pc, #176]	; 12174 <main+0x1d4>
   120c6:	4b41      	ldr	r3, [pc, #260]	; (121cc <main+0x22c>)
   120c8:	4658      	mov	r0, fp
   120ca:	4798      	blx	r3
   120cc:	b980      	cbnz	r0, 120f0 <main+0x150>
   120ce:	2250      	movs	r2, #80	; 0x50
   120d0:	fbb4 f3f2 	udiv	r3, r4, r2
   120d4:	fb02 4313 	mls	r3, r2, r3, r4
   120d8:	b953      	cbnz	r3, 120f0 <main+0x150>
 								
			if (grid_sys_state.bank_init_flag == 0)	{
   120da:	f89b 3027 	ldrb.w	r3, [fp, #39]	; 0x27
   120de:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   120e2:	b92b      	cbnz	r3, 120f0 <main+0x150>
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_REQUEST);
   120e4:	4831      	ldr	r0, [pc, #196]	; (121ac <main+0x20c>)
   120e6:	f8df b0c8 	ldr.w	fp, [pc, #200]	; 121b0 <main+0x210>
   120ea:	230a      	movs	r3, #10
   120ec:	4611      	mov	r1, r2
   120ee:	47d8      	blx	fp
	

		
		
		
		usb_task_inner();
   120f0:	47d0      	blx	sl
		


		nvm_task_inner();
   120f2:	47c8      	blx	r9
		
					


		receive_task_inner();
   120f4:	47c0      	blx	r8
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   120f6:	4831      	ldr	r0, [pc, #196]	; (121bc <main+0x21c>)
   120f8:	47b8      	blx	r7
		
		
		
		
		
		inbound_task_inner();
   120fa:	47b0      	blx	r6

		outbound_task_inner();
   120fc:	4b31      	ldr	r3, [pc, #196]	; (121c4 <main+0x224>)
   120fe:	4798      	blx	r3

		led_task_inner();
   12100:	4b31      	ldr	r3, [pc, #196]	; (121c8 <main+0x228>)
   12102:	4798      	blx	r3

		delay_ms(1);
   12104:	2001      	movs	r0, #1
		loopcounter++;
   12106:	3401      	adds	r4, #1
		delay_ms(1);
   12108:	47a8      	blx	r5
		if (usb_init_flag == 0){
   1210a:	e79e      	b.n	1204a <main+0xaa>
   1210c:	00012e11 	.word	0x00012e11
   12110:	000143b9 	.word	0x000143b9
   12114:	20001a24 	.word	0x20001a24
   12118:	000122d5 	.word	0x000122d5
   1211c:	000173c9 	.word	0x000173c9
   12120:	000167e3 	.word	0x000167e3
   12124:	000173db 	.word	0x000173db
   12128:	00006381 	.word	0x00006381
   1212c:	000044dd 	.word	0x000044dd
   12130:	0000c805 	.word	0x0000c805
   12134:	0000ace1 	.word	0x0000ace1
   12138:	0000aed9 	.word	0x0000aed9
   1213c:	0000afc5 	.word	0x0000afc5
   12140:	20008c80 	.word	0x20008c80
   12144:	000173e4 	.word	0x000173e4
   12148:	0000e695 	.word	0x0000e695
   1214c:	2001579c 	.word	0x2001579c
   12150:	2000bc3c 	.word	0x2000bc3c
   12154:	000063f1 	.word	0x000063f1
   12158:	000070c9 	.word	0x000070c9
   1215c:	0000a0c9 	.word	0x0000a0c9
   12160:	20007a18 	.word	0x20007a18
   12164:	00017401 	.word	0x00017401
   12168:	00011f31 	.word	0x00011f31
   1216c:	00017419 	.word	0x00017419
   12170:	20008438 	.word	0x20008438
   12174:	20007a24 	.word	0x20007a24
   12178:	000090e5 	.word	0x000090e5
   1217c:	00009af5 	.word	0x00009af5
   12180:	0001742c 	.word	0x0001742c
   12184:	00011a95 	.word	0x00011a95
   12188:	00017434 	.word	0x00017434
   1218c:	00011e8d 	.word	0x00011e8d
   12190:	0000dc95 	.word	0x0000dc95
   12194:	0000f419 	.word	0x0000f419
   12198:	0000a7a5 	.word	0x0000a7a5
   1219c:	00011c85 	.word	0x00011c85
   121a0:	0001743d 	.word	0x0001743d
   121a4:	00009749 	.word	0x00009749
   121a8:	00009763 	.word	0x00009763
   121ac:	200151dc 	.word	0x200151dc
   121b0:	0000a191 	.word	0x0000a191
   121b4:	000144c9 	.word	0x000144c9
   121b8:	00017458 	.word	0x00017458
   121bc:	20004acc 	.word	0x20004acc
   121c0:	00012481 	.word	0x00012481
   121c4:	00011cd1 	.word	0x00011cd1
   121c8:	00011d19 	.word	0x00011d19
   121cc:	0000970b 	.word	0x0000970b
   121d0:	00011ad1 	.word	0x00011ad1
   121d4:	00011bf1 	.word	0x00011bf1
   121d8:	00011bc1 	.word	0x00011bc1
   121dc:	00009813 	.word	0x00009813

000121e0 <qspi_dma_init>:
 * \brief Driver version
 */
#define QSPI_DMA_DRIVER_VERSION 0x00000001u

int32_t qspi_dma_init(struct qspi_dma_descriptor *qspi, void *const hw)
{
   121e0:	b570      	push	{r4, r5, r6, lr}
   121e2:	460d      	mov	r5, r1
	ASSERT(qspi && hw);
   121e4:	4604      	mov	r4, r0
   121e6:	b110      	cbz	r0, 121ee <qspi_dma_init+0xe>
   121e8:	1e08      	subs	r0, r1, #0
   121ea:	bf18      	it	ne
   121ec:	2001      	movne	r0, #1
   121ee:	4905      	ldr	r1, [pc, #20]	; (12204 <qspi_dma_init+0x24>)
   121f0:	4b05      	ldr	r3, [pc, #20]	; (12208 <qspi_dma_init+0x28>)
   121f2:	2231      	movs	r2, #49	; 0x31
   121f4:	4798      	blx	r3

	return _qspi_dma_init(&qspi->dev, hw);
   121f6:	4629      	mov	r1, r5
   121f8:	4620      	mov	r0, r4
   121fa:	4b04      	ldr	r3, [pc, #16]	; (1220c <qspi_dma_init+0x2c>)
}
   121fc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _qspi_dma_init(&qspi->dev, hw);
   12200:	4718      	bx	r3
   12202:	bf00      	nop
   12204:	00017463 	.word	0x00017463
   12208:	0000df45 	.word	0x0000df45
   1220c:	0000bd21 	.word	0x0000bd21

00012210 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12210:	4906      	ldr	r1, [pc, #24]	; (1222c <prvIdleTask+0x1c>)
				taskYIELD();
   12212:	4b07      	ldr	r3, [pc, #28]	; (12230 <prvIdleTask+0x20>)
   12214:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12218:	6808      	ldr	r0, [r1, #0]
   1221a:	2801      	cmp	r0, #1
   1221c:	d9fc      	bls.n	12218 <prvIdleTask+0x8>
				taskYIELD();
   1221e:	601a      	str	r2, [r3, #0]
   12220:	f3bf 8f4f 	dsb	sy
   12224:	f3bf 8f6f 	isb	sy
   12228:	e7f6      	b.n	12218 <prvIdleTask+0x8>
   1222a:	bf00      	nop
   1222c:	20001a30 	.word	0x20001a30
   12230:	e000ed04 	.word	0xe000ed04

00012234 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   12234:	4b07      	ldr	r3, [pc, #28]	; (12254 <prvResetNextTaskUnblockTime+0x20>)
   12236:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
   1223a:	6812      	ldr	r2, [r2, #0]
   1223c:	b922      	cbnz	r2, 12248 <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   1223e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   12242:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	}
}
   12246:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   12248:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
   1224c:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   1224e:	68d2      	ldr	r2, [r2, #12]
   12250:	6852      	ldr	r2, [r2, #4]
   12252:	e7f6      	b.n	12242 <prvResetNextTaskUnblockTime+0xe>
   12254:	20001a30 	.word	0x20001a30

00012258 <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
   12258:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
   1225c:	4f19      	ldr	r7, [pc, #100]	; (122c4 <prvAddCurrentTaskToDelayedList+0x6c>)
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   1225e:	4b1a      	ldr	r3, [pc, #104]	; (122c8 <prvAddCurrentTaskToDelayedList+0x70>)
	const TickType_t xConstTickCount = xTickCount;
   12260:	f8d7 6094 	ldr.w	r6, [r7, #148]	; 0x94
{
   12264:	4605      	mov	r5, r0
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12266:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
   1226a:	3004      	adds	r0, #4
{
   1226c:	4688      	mov	r8, r1
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   1226e:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
   12270:	1c6b      	adds	r3, r5, #1
   12272:	463c      	mov	r4, r7
   12274:	d10b      	bne.n	1228e <prvAddCurrentTaskToDelayedList+0x36>
   12276:	f1b8 0f00 	cmp.w	r8, #0
   1227a:	d008      	beq.n	1228e <prvAddCurrentTaskToDelayedList+0x36>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
   1227c:	f8d7 1098 	ldr.w	r1, [r7, #152]	; 0x98
   12280:	4b12      	ldr	r3, [pc, #72]	; (122cc <prvAddCurrentTaskToDelayedList+0x74>)
   12282:	3104      	adds	r1, #4
   12284:	f107 0064 	add.w	r0, r7, #100	; 0x64

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
   12288:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   1228c:	4718      	bx	r3
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
   1228e:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   12292:	1975      	adds	r5, r6, r5
   12294:	605d      	str	r5, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
   12296:	4b0e      	ldr	r3, [pc, #56]	; (122d0 <prvAddCurrentTaskToDelayedList+0x78>)
   12298:	d305      	bcc.n	122a6 <prvAddCurrentTaskToDelayedList+0x4e>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   1229a:	f8d4 009c 	ldr.w	r0, [r4, #156]	; 0x9c
   1229e:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
   122a2:	3104      	adds	r1, #4
   122a4:	e7f0      	b.n	12288 <prvAddCurrentTaskToDelayedList+0x30>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   122a6:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
   122aa:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
   122ae:	3104      	adds	r1, #4
   122b0:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
   122b2:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   122b6:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
   122b8:	bf88      	it	hi
   122ba:	f8c4 5090 	strhi.w	r5, [r4, #144]	; 0x90
}
   122be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   122c2:	bf00      	nop
   122c4:	20001a30 	.word	0x20001a30
   122c8:	0000b1af 	.word	0x0000b1af
   122cc:	0000b169 	.word	0x0000b169
   122d0:	0000b181 	.word	0x0000b181

000122d4 <xTaskCreate>:
{
   122d4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pxStack = (StackType_t *)pvPortMalloc(
   122d8:	0094      	lsls	r4, r2, #2
   122da:	4d5e      	ldr	r5, [pc, #376]	; (12454 <xTaskCreate+0x180>)
{
   122dc:	4607      	mov	r7, r0
		pxStack = (StackType_t *)pvPortMalloc(
   122de:	4620      	mov	r0, r4
{
   122e0:	460e      	mov	r6, r1
   122e2:	4698      	mov	r8, r3
		pxStack = (StackType_t *)pvPortMalloc(
   122e4:	47a8      	blx	r5
		if (pxStack != NULL) {
   122e6:	4681      	mov	r9, r0
   122e8:	2800      	cmp	r0, #0
   122ea:	f000 80a2 	beq.w	12432 <xTaskCreate+0x15e>
			pxNewTCB = (TCB_t *)pvPortMalloc(
   122ee:	2054      	movs	r0, #84	; 0x54
   122f0:	47a8      	blx	r5
			if (pxNewTCB != NULL) {
   122f2:	4605      	mov	r5, r0
   122f4:	2800      	cmp	r0, #0
   122f6:	f000 8099 	beq.w	1242c <xTaskCreate+0x158>
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   122fa:	4b57      	ldr	r3, [pc, #348]	; (12458 <xTaskCreate+0x184>)
				pxNewTCB->pxStack = pxStack;
   122fc:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   12300:	4622      	mov	r2, r4
   12302:	21a5      	movs	r1, #165	; 0xa5
   12304:	4648      	mov	r0, r9
   12306:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12308:	f8d5 b030 	ldr.w	fp, [r5, #48]	; 0x30
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   1230c:	1e73      	subs	r3, r6, #1
   1230e:	f105 0234 	add.w	r2, r5, #52	; 0x34
   12312:	3607      	adds	r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
   12314:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   12318:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
   1231c:	7819      	ldrb	r1, [r3, #0]
   1231e:	b109      	cbz	r1, 12324 <xTaskCreate+0x50>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12320:	42b3      	cmp	r3, r6
   12322:	d1f7      	bne.n	12314 <xTaskCreate+0x40>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12324:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12326:	4a4d      	ldr	r2, [pc, #308]	; (1245c <xTaskCreate+0x188>)
   12328:	2e04      	cmp	r6, #4
   1232a:	bf28      	it	cs
   1232c:	2604      	movcs	r6, #4
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   1232e:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12332:	f105 0904 	add.w	r9, r5, #4
		pxNewTCB->uxMutexesHeld  = 0;
   12336:	e9c5 6a11 	strd	r6, sl, [r5, #68]	; 0x44
	pxNewTCB->uxPriority = uxPriority;
   1233a:	62ee      	str	r6, [r5, #44]	; 0x2c
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   1233c:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   1233e:	f885 a03b 	strb.w	sl, [r5, #59]	; 0x3b
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12342:	3c04      	subs	r4, #4
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12344:	4790      	blx	r2
	listSET_LIST_ITEM_VALUE(
   12346:	f1c6 0605 	rsb	r6, r6, #5
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   1234a:	4a44      	ldr	r2, [pc, #272]	; (1245c <xTaskCreate+0x188>)
   1234c:	f105 0018 	add.w	r0, r5, #24
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12350:	445c      	add	r4, fp
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   12352:	4790      	blx	r2
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12354:	4b42      	ldr	r3, [pc, #264]	; (12460 <xTaskCreate+0x18c>)
		pxNewTCB->ulNotifiedValue = 0;
   12356:	f8c5 a04c 	str.w	sl, [r5, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
   1235a:	612d      	str	r5, [r5, #16]
	listSET_LIST_ITEM_VALUE(
   1235c:	61ae      	str	r6, [r5, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
   1235e:	626d      	str	r5, [r5, #36]	; 0x24
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
   12360:	f885 a050 	strb.w	sl, [r5, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12364:	4642      	mov	r2, r8
   12366:	4639      	mov	r1, r7
   12368:	f024 0007 	bic.w	r0, r4, #7
   1236c:	4798      	blx	r3
	if ((void *)pxCreatedTask != NULL) {
   1236e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12370:	6028      	str	r0, [r5, #0]
	if ((void *)pxCreatedTask != NULL) {
   12372:	b103      	cbz	r3, 12376 <xTaskCreate+0xa2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
   12374:	601d      	str	r5, [r3, #0]
		uxCurrentNumberOfTasks++;
   12376:	4c3b      	ldr	r4, [pc, #236]	; (12464 <xTaskCreate+0x190>)
	taskENTER_CRITICAL();
   12378:	4b3b      	ldr	r3, [pc, #236]	; (12468 <xTaskCreate+0x194>)
   1237a:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   1237c:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
   12380:	3301      	adds	r3, #1
   12382:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
		if (pxCurrentTCB == NULL) {
   12386:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   1238a:	2b00      	cmp	r3, #0
   1238c:	d155      	bne.n	1243a <xTaskCreate+0x166>
			pxCurrentTCB = pxNewTCB;
   1238e:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
   12392:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
   12396:	2b01      	cmp	r3, #1
   12398:	d120      	bne.n	123dc <xTaskCreate+0x108>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   1239a:	4e34      	ldr	r6, [pc, #208]	; (1246c <xTaskCreate+0x198>)
   1239c:	4620      	mov	r0, r4
   1239e:	47b0      	blx	r6
   123a0:	f104 0014 	add.w	r0, r4, #20
   123a4:	47b0      	blx	r6
   123a6:	f104 0028 	add.w	r0, r4, #40	; 0x28
   123aa:	47b0      	blx	r6
   123ac:	f104 003c 	add.w	r0, r4, #60	; 0x3c
   123b0:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList1);
   123b2:	f104 08a4 	add.w	r8, r4, #164	; 0xa4
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   123b6:	f104 0050 	add.w	r0, r4, #80	; 0x50
   123ba:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
   123bc:	f104 07b8 	add.w	r7, r4, #184	; 0xb8
	vListInitialise(&xDelayedTaskList1);
   123c0:	4640      	mov	r0, r8
   123c2:	47b0      	blx	r6
	vListInitialise(&xDelayedTaskList2);
   123c4:	4638      	mov	r0, r7
   123c6:	47b0      	blx	r6
	vListInitialise(&xPendingReadyList);
   123c8:	f104 0078 	add.w	r0, r4, #120	; 0x78
   123cc:	47b0      	blx	r6
		vListInitialise(&xSuspendedTaskList);
   123ce:	f104 0064 	add.w	r0, r4, #100	; 0x64
   123d2:	47b0      	blx	r6
	pxDelayedTaskList         = &xDelayedTaskList1;
   123d4:	f8c4 808c 	str.w	r8, [r4, #140]	; 0x8c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   123d8:	f8c4 709c 	str.w	r7, [r4, #156]	; 0x9c
		uxTaskNumber++;
   123dc:	f8d4 30d0 	ldr.w	r3, [r4, #208]	; 0xd0
		prvAddTaskToReadyList(pxNewTCB);
   123e0:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
		uxTaskNumber++;
   123e4:	3301      	adds	r3, #1
   123e6:	f8c4 30d0 	str.w	r3, [r4, #208]	; 0xd0
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   123ea:	63eb      	str	r3, [r5, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
   123ec:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   123ee:	2014      	movs	r0, #20
   123f0:	4293      	cmp	r3, r2
   123f2:	bf88      	it	hi
   123f4:	f8c4 30d4 	strhi.w	r3, [r4, #212]	; 0xd4
   123f8:	fb00 4003 	mla	r0, r0, r3, r4
   123fc:	4649      	mov	r1, r9
   123fe:	4b1c      	ldr	r3, [pc, #112]	; (12470 <xTaskCreate+0x19c>)
   12400:	4798      	blx	r3
	taskEXIT_CRITICAL();
   12402:	4b1c      	ldr	r3, [pc, #112]	; (12474 <xTaskCreate+0x1a0>)
   12404:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
   12406:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
   1240a:	b16b      	cbz	r3, 12428 <xTaskCreate+0x154>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
   1240c:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   12410:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12412:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   12414:	429a      	cmp	r2, r3
   12416:	d207      	bcs.n	12428 <xTaskCreate+0x154>
			taskYIELD_IF_USING_PREEMPTION();
   12418:	4b17      	ldr	r3, [pc, #92]	; (12478 <xTaskCreate+0x1a4>)
   1241a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   1241e:	601a      	str	r2, [r3, #0]
   12420:	f3bf 8f4f 	dsb	sy
   12424:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
   12428:	2001      	movs	r0, #1
	return xReturn;
   1242a:	e004      	b.n	12436 <xTaskCreate+0x162>
				vPortFree(pxStack);
   1242c:	4b13      	ldr	r3, [pc, #76]	; (1247c <xTaskCreate+0x1a8>)
   1242e:	4648      	mov	r0, r9
   12430:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   12432:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   12436:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (xSchedulerRunning == pdFALSE) {
   1243a:	f8d4 30cc 	ldr.w	r3, [r4, #204]	; 0xcc
   1243e:	2b00      	cmp	r3, #0
   12440:	d1cc      	bne.n	123dc <xTaskCreate+0x108>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
   12442:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   12446:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12448:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
   1244a:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
   1244c:	bf98      	it	ls
   1244e:	f8c4 5098 	strls.w	r5, [r4, #152]	; 0x98
   12452:	e7c3      	b.n	123dc <xTaskCreate+0x108>
   12454:	0000b1d1 	.word	0x0000b1d1
   12458:	00014175 	.word	0x00014175
   1245c:	0000b163 	.word	0x0000b163
   12460:	0000b2b9 	.word	0x0000b2b9
   12464:	20001a30 	.word	0x20001a30
   12468:	0000b315 	.word	0x0000b315
   1246c:	0000b14d 	.word	0x0000b14d
   12470:	0000b169 	.word	0x0000b169
   12474:	0000b359 	.word	0x0000b359
   12478:	e000ed04 	.word	0xe000ed04
   1247c:	0000b225 	.word	0x0000b225

00012480 <vTaskStartScheduler>:
{
   12480:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(prvIdleTask,
   12482:	4c1a      	ldr	r4, [pc, #104]	; (124ec <vTaskStartScheduler+0x6c>)
   12484:	491a      	ldr	r1, [pc, #104]	; (124f0 <vTaskStartScheduler+0x70>)
   12486:	481b      	ldr	r0, [pc, #108]	; (124f4 <vTaskStartScheduler+0x74>)
   12488:	4e1b      	ldr	r6, [pc, #108]	; (124f8 <vTaskStartScheduler+0x78>)
   1248a:	f104 03dc 	add.w	r3, r4, #220	; 0xdc
   1248e:	2500      	movs	r5, #0
   12490:	9301      	str	r3, [sp, #4]
   12492:	9500      	str	r5, [sp, #0]
   12494:	462b      	mov	r3, r5
   12496:	2240      	movs	r2, #64	; 0x40
   12498:	47b0      	blx	r6
		if (xReturn == pdPASS) {
   1249a:	2801      	cmp	r0, #1
   1249c:	d118      	bne.n	124d0 <vTaskStartScheduler+0x50>
			xReturn = xTimerCreateTimerTask();
   1249e:	4b17      	ldr	r3, [pc, #92]	; (124fc <vTaskStartScheduler+0x7c>)
   124a0:	4798      	blx	r3
	if (xReturn == pdPASS) {
   124a2:	2801      	cmp	r0, #1
   124a4:	d114      	bne.n	124d0 <vTaskStartScheduler+0x50>
   124a6:	f04f 0380 	mov.w	r3, #128	; 0x80
   124aa:	f383 8811 	msr	BASEPRI, r3
   124ae:	f3bf 8f6f 	isb	sy
   124b2:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   124b6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   124ba:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
		if (xPortStartScheduler() != pdFALSE) {
   124be:	4b10      	ldr	r3, [pc, #64]	; (12500 <vTaskStartScheduler+0x80>)
		xSchedulerRunning    = pdTRUE;
   124c0:	f8c4 00cc 	str.w	r0, [r4, #204]	; 0xcc
		xTickCount           = (TickType_t)0U;
   124c4:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
}
   124c8:	b002      	add	sp, #8
   124ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (xPortStartScheduler() != pdFALSE) {
   124ce:	4718      	bx	r3
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
   124d0:	3001      	adds	r0, #1
   124d2:	d108      	bne.n	124e6 <vTaskStartScheduler+0x66>
   124d4:	f04f 0380 	mov.w	r3, #128	; 0x80
   124d8:	f383 8811 	msr	BASEPRI, r3
   124dc:	f3bf 8f6f 	isb	sy
   124e0:	f3bf 8f4f 	dsb	sy
   124e4:	e7fe      	b.n	124e4 <vTaskStartScheduler+0x64>
}
   124e6:	b002      	add	sp, #8
   124e8:	bd70      	pop	{r4, r5, r6, pc}
   124ea:	bf00      	nop
   124ec:	20001a30 	.word	0x20001a30
   124f0:	0001747d 	.word	0x0001747d
   124f4:	00012211 	.word	0x00012211
   124f8:	000122d5 	.word	0x000122d5
   124fc:	0000d979 	.word	0x0000d979
   12500:	0000b43d 	.word	0x0000b43d

00012504 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   12504:	4a03      	ldr	r2, [pc, #12]	; (12514 <vTaskSuspendAll+0x10>)
   12506:	f8d2 30d8 	ldr.w	r3, [r2, #216]	; 0xd8
   1250a:	3301      	adds	r3, #1
   1250c:	f8c2 30d8 	str.w	r3, [r2, #216]	; 0xd8
}
   12510:	4770      	bx	lr
   12512:	bf00      	nop
   12514:	20001a30 	.word	0x20001a30

00012518 <xTaskGetTickCount>:
		xTicks = xTickCount;
   12518:	4b01      	ldr	r3, [pc, #4]	; (12520 <xTaskGetTickCount+0x8>)
   1251a:	f8d3 0094 	ldr.w	r0, [r3, #148]	; 0x94
}
   1251e:	4770      	bx	lr
   12520:	20001a30 	.word	0x20001a30

00012524 <xTaskIncrementTick>:
{
   12524:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12528:	4b3b      	ldr	r3, [pc, #236]	; (12618 <xTaskIncrementTick+0xf4>)
   1252a:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
   1252e:	461c      	mov	r4, r3
   12530:	2a00      	cmp	r2, #0
   12532:	d16a      	bne.n	1260a <xTaskIncrementTick+0xe6>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
   12534:	f8d3 7094 	ldr.w	r7, [r3, #148]	; 0x94
   12538:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   1253a:	f8c3 7094 	str.w	r7, [r3, #148]	; 0x94
		if (xConstTickCount
   1253e:	b9df      	cbnz	r7, 12578 <xTaskIncrementTick+0x54>
			taskSWITCH_DELAYED_LISTS();
   12540:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
   12544:	681b      	ldr	r3, [r3, #0]
   12546:	b143      	cbz	r3, 1255a <xTaskIncrementTick+0x36>
   12548:	f04f 0380 	mov.w	r3, #128	; 0x80
   1254c:	f383 8811 	msr	BASEPRI, r3
   12550:	f3bf 8f6f 	isb	sy
   12554:	f3bf 8f4f 	dsb	sy
   12558:	e7fe      	b.n	12558 <xTaskIncrementTick+0x34>
   1255a:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   1255e:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
   12562:	f8c4 208c 	str.w	r2, [r4, #140]	; 0x8c
   12566:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
   1256a:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
   1256e:	3301      	adds	r3, #1
   12570:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
   12574:	4b29      	ldr	r3, [pc, #164]	; (1261c <xTaskIncrementTick+0xf8>)
   12576:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12578:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
   1257c:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
   1257e:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12582:	d910      	bls.n	125a6 <xTaskIncrementTick+0x82>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
   12584:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   12588:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1258a:	2314      	movs	r3, #20
   1258c:	4353      	muls	r3, r2
   1258e:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
   12590:	2b02      	cmp	r3, #2
   12592:	bf28      	it	cs
   12594:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
   12596:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
			xSwitchRequired = pdTRUE;
   1259a:	2b00      	cmp	r3, #0
}
   1259c:	bf0c      	ite	eq
   1259e:	4628      	moveq	r0, r5
   125a0:	2001      	movne	r0, #1
   125a2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
   125a6:	f8df 8078 	ldr.w	r8, [pc, #120]	; 12620 <xTaskIncrementTick+0xfc>
					prvAddTaskToReadyList(pxTCB);
   125aa:	f8df 9078 	ldr.w	r9, [pc, #120]	; 12624 <xTaskIncrementTick+0x100>
   125ae:	f04f 0a14 	mov.w	sl, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   125b2:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   125b6:	681b      	ldr	r3, [r3, #0]
   125b8:	b923      	cbnz	r3, 125c4 <xTaskIncrementTick+0xa0>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   125ba:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
						xNextTaskUnblockTime = xItemValue;
   125be:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
						break;
   125c2:	e7df      	b.n	12584 <xTaskIncrementTick+0x60>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   125c4:	f8d4 308c 	ldr.w	r3, [r4, #140]	; 0x8c
   125c8:	68db      	ldr	r3, [r3, #12]
   125ca:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
   125cc:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
   125ce:	429f      	cmp	r7, r3
   125d0:	d3f5      	bcc.n	125be <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
   125d2:	f106 0b04 	add.w	fp, r6, #4
   125d6:	4658      	mov	r0, fp
   125d8:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
   125da:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   125dc:	b113      	cbz	r3, 125e4 <xTaskIncrementTick+0xc0>
						(void)uxListRemove(&(pxTCB->xEventListItem));
   125de:	f106 0018 	add.w	r0, r6, #24
   125e2:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
   125e4:	6af0      	ldr	r0, [r6, #44]	; 0x2c
   125e6:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
   125ea:	4298      	cmp	r0, r3
   125ec:	bf88      	it	hi
   125ee:	f8c4 00d4 	strhi.w	r0, [r4, #212]	; 0xd4
   125f2:	4659      	mov	r1, fp
   125f4:	fb0a 4000 	mla	r0, sl, r0, r4
   125f8:	47c8      	blx	r9
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   125fa:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   125fe:	6af2      	ldr	r2, [r6, #44]	; 0x2c
   12600:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   12602:	429a      	cmp	r2, r3
   12604:	bf28      	it	cs
   12606:	2501      	movcs	r5, #1
   12608:	e7d3      	b.n	125b2 <xTaskIncrementTick+0x8e>
		++uxPendedTicks;
   1260a:	f8d3 30e4 	ldr.w	r3, [r3, #228]	; 0xe4
   1260e:	3301      	adds	r3, #1
   12610:	f8c4 30e4 	str.w	r3, [r4, #228]	; 0xe4
	BaseType_t xSwitchRequired = pdFALSE;
   12614:	2500      	movs	r5, #0
   12616:	e7be      	b.n	12596 <xTaskIncrementTick+0x72>
   12618:	20001a30 	.word	0x20001a30
   1261c:	00012235 	.word	0x00012235
   12620:	0000b1af 	.word	0x0000b1af
   12624:	0000b169 	.word	0x0000b169

00012628 <xTaskResumeAll>:
{
   12628:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
   1262c:	4c32      	ldr	r4, [pc, #200]	; (126f8 <xTaskResumeAll+0xd0>)
   1262e:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   12632:	b943      	cbnz	r3, 12646 <xTaskResumeAll+0x1e>
   12634:	f04f 0380 	mov.w	r3, #128	; 0x80
   12638:	f383 8811 	msr	BASEPRI, r3
   1263c:	f3bf 8f6f 	isb	sy
   12640:	f3bf 8f4f 	dsb	sy
   12644:	e7fe      	b.n	12644 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
   12646:	4b2d      	ldr	r3, [pc, #180]	; (126fc <xTaskResumeAll+0xd4>)
   12648:	4798      	blx	r3
		--uxSchedulerSuspended;
   1264a:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1264e:	3b01      	subs	r3, #1
   12650:	f8c4 30d8 	str.w	r3, [r4, #216]	; 0xd8
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12654:	f8d4 50d8 	ldr.w	r5, [r4, #216]	; 0xd8
   12658:	b135      	cbz	r5, 12668 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
   1265a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1265c:	4b28      	ldr	r3, [pc, #160]	; (12700 <xTaskResumeAll+0xd8>)
   1265e:	4798      	blx	r3
}
   12660:	4620      	mov	r0, r4
   12662:	b002      	add	sp, #8
   12664:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
   12668:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
   1266c:	2b00      	cmp	r3, #0
   1266e:	d0f4      	beq.n	1265a <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12670:	4e24      	ldr	r6, [pc, #144]	; (12704 <xTaskResumeAll+0xdc>)
					prvAddTaskToReadyList(pxTCB);
   12672:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 12714 <xTaskResumeAll+0xec>
   12676:	2714      	movs	r7, #20
   12678:	e01d      	b.n	126b6 <xTaskResumeAll+0x8e>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
   1267a:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
   1267e:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12680:	f105 0018 	add.w	r0, r5, #24
   12684:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12686:	1d29      	adds	r1, r5, #4
   12688:	4608      	mov	r0, r1
   1268a:	9101      	str	r1, [sp, #4]
   1268c:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
   1268e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   12690:	f8d4 30d4 	ldr.w	r3, [r4, #212]	; 0xd4
   12694:	9901      	ldr	r1, [sp, #4]
   12696:	4298      	cmp	r0, r3
   12698:	bf88      	it	hi
   1269a:	f8c4 00d4 	strhi.w	r0, [r4, #212]	; 0xd4
   1269e:	fb07 4000 	mla	r0, r7, r0, r4
   126a2:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   126a4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   126a8:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   126aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   126ac:	429a      	cmp	r2, r3
   126ae:	d302      	bcc.n	126b6 <xTaskResumeAll+0x8e>
						xYieldPending = pdTRUE;
   126b0:	2301      	movs	r3, #1
   126b2:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
   126b6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
   126b8:	2b00      	cmp	r3, #0
   126ba:	d1de      	bne.n	1267a <xTaskResumeAll+0x52>
				if (pxTCB != NULL) {
   126bc:	b10d      	cbz	r5, 126c2 <xTaskResumeAll+0x9a>
					prvResetNextTaskUnblockTime();
   126be:	4b12      	ldr	r3, [pc, #72]	; (12708 <xTaskResumeAll+0xe0>)
   126c0:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   126c2:	f8d4 50e4 	ldr.w	r5, [r4, #228]	; 0xe4
					if (uxPendedCounts > (UBaseType_t)0U) {
   126c6:	b14d      	cbz	r5, 126dc <xTaskResumeAll+0xb4>
							if (xTaskIncrementTick() != pdFALSE) {
   126c8:	4e10      	ldr	r6, [pc, #64]	; (1270c <xTaskResumeAll+0xe4>)
								xYieldPending = pdTRUE;
   126ca:	2701      	movs	r7, #1
							if (xTaskIncrementTick() != pdFALSE) {
   126cc:	47b0      	blx	r6
   126ce:	b108      	cbz	r0, 126d4 <xTaskResumeAll+0xac>
								xYieldPending = pdTRUE;
   126d0:	f8c4 70e8 	str.w	r7, [r4, #232]	; 0xe8
						} while (uxPendedCounts > (UBaseType_t)0U);
   126d4:	3d01      	subs	r5, #1
   126d6:	d1f9      	bne.n	126cc <xTaskResumeAll+0xa4>
						uxPendedTicks = 0;
   126d8:	f8c4 50e4 	str.w	r5, [r4, #228]	; 0xe4
				if (xYieldPending != pdFALSE) {
   126dc:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
   126e0:	2b00      	cmp	r3, #0
   126e2:	d0ba      	beq.n	1265a <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
   126e4:	4b0a      	ldr	r3, [pc, #40]	; (12710 <xTaskResumeAll+0xe8>)
   126e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   126ea:	601a      	str	r2, [r3, #0]
   126ec:	f3bf 8f4f 	dsb	sy
   126f0:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   126f4:	2401      	movs	r4, #1
   126f6:	e7b1      	b.n	1265c <xTaskResumeAll+0x34>
   126f8:	20001a30 	.word	0x20001a30
   126fc:	0000b315 	.word	0x0000b315
   12700:	0000b359 	.word	0x0000b359
   12704:	0000b1af 	.word	0x0000b1af
   12708:	00012235 	.word	0x00012235
   1270c:	00012525 	.word	0x00012525
   12710:	e000ed04 	.word	0xe000ed04
   12714:	0000b169 	.word	0x0000b169

00012718 <vTaskDelay>:
{
   12718:	b508      	push	{r3, lr}
	if (xTicksToDelay > (TickType_t)0U) {
   1271a:	b940      	cbnz	r0, 1272e <vTaskDelay+0x16>
		portYIELD_WITHIN_API();
   1271c:	4b0f      	ldr	r3, [pc, #60]	; (1275c <vTaskDelay+0x44>)
   1271e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12722:	601a      	str	r2, [r3, #0]
   12724:	f3bf 8f4f 	dsb	sy
   12728:	f3bf 8f6f 	isb	sy
}
   1272c:	bd08      	pop	{r3, pc}
		configASSERT(uxSchedulerSuspended == 0);
   1272e:	4b0c      	ldr	r3, [pc, #48]	; (12760 <vTaskDelay+0x48>)
   12730:	f8d3 10d8 	ldr.w	r1, [r3, #216]	; 0xd8
   12734:	b141      	cbz	r1, 12748 <vTaskDelay+0x30>
   12736:	f04f 0380 	mov.w	r3, #128	; 0x80
   1273a:	f383 8811 	msr	BASEPRI, r3
   1273e:	f3bf 8f6f 	isb	sy
   12742:	f3bf 8f4f 	dsb	sy
   12746:	e7fe      	b.n	12746 <vTaskDelay+0x2e>
		vTaskSuspendAll();
   12748:	4b06      	ldr	r3, [pc, #24]	; (12764 <vTaskDelay+0x4c>)
   1274a:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
   1274c:	4b06      	ldr	r3, [pc, #24]	; (12768 <vTaskDelay+0x50>)
   1274e:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
   12750:	4b06      	ldr	r3, [pc, #24]	; (1276c <vTaskDelay+0x54>)
   12752:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
   12754:	2800      	cmp	r0, #0
   12756:	d0e1      	beq.n	1271c <vTaskDelay+0x4>
   12758:	e7e8      	b.n	1272c <vTaskDelay+0x14>
   1275a:	bf00      	nop
   1275c:	e000ed04 	.word	0xe000ed04
   12760:	20001a30 	.word	0x20001a30
   12764:	00012505 	.word	0x00012505
   12768:	00012259 	.word	0x00012259
   1276c:	00012629 	.word	0x00012629

00012770 <vTaskSwitchContext>:
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
   12770:	4a19      	ldr	r2, [pc, #100]	; (127d8 <vTaskSwitchContext+0x68>)
   12772:	f8d2 10d8 	ldr.w	r1, [r2, #216]	; 0xd8
{
   12776:	b530      	push	{r4, r5, lr}
   12778:	4613      	mov	r3, r2
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
   1277a:	b119      	cbz	r1, 12784 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
   1277c:	2301      	movs	r3, #1
   1277e:	f8c2 30e8 	str.w	r3, [r2, #232]	; 0xe8
}
   12782:	bd30      	pop	{r4, r5, pc}
		xYieldPending = pdFALSE;
   12784:	f8c2 10e8 	str.w	r1, [r2, #232]	; 0xe8
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12788:	f8d2 10d4 	ldr.w	r1, [r2, #212]	; 0xd4
   1278c:	2514      	movs	r5, #20
   1278e:	fb05 f201 	mul.w	r2, r5, r1
   12792:	1898      	adds	r0, r3, r2
   12794:	589c      	ldr	r4, [r3, r2]
   12796:	b194      	cbz	r4, 127be <vTaskSwitchContext+0x4e>
   12798:	6844      	ldr	r4, [r0, #4]
   1279a:	3208      	adds	r2, #8
   1279c:	6864      	ldr	r4, [r4, #4]
   1279e:	6044      	str	r4, [r0, #4]
   127a0:	441a      	add	r2, r3
   127a2:	4294      	cmp	r4, r2
   127a4:	bf04      	itt	eq
   127a6:	6862      	ldreq	r2, [r4, #4]
   127a8:	6042      	streq	r2, [r0, #4]
   127aa:	2214      	movs	r2, #20
   127ac:	fb02 3201 	mla	r2, r2, r1, r3
   127b0:	6852      	ldr	r2, [r2, #4]
   127b2:	68d2      	ldr	r2, [r2, #12]
   127b4:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
   127b8:	f8c3 10d4 	str.w	r1, [r3, #212]	; 0xd4
}
   127bc:	e7e1      	b.n	12782 <vTaskSwitchContext+0x12>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   127be:	b941      	cbnz	r1, 127d2 <vTaskSwitchContext+0x62>
   127c0:	f04f 0380 	mov.w	r3, #128	; 0x80
   127c4:	f383 8811 	msr	BASEPRI, r3
   127c8:	f3bf 8f6f 	isb	sy
   127cc:	f3bf 8f4f 	dsb	sy
   127d0:	e7fe      	b.n	127d0 <vTaskSwitchContext+0x60>
   127d2:	3901      	subs	r1, #1
   127d4:	e7db      	b.n	1278e <vTaskSwitchContext+0x1e>
   127d6:	bf00      	nop
   127d8:	20001a30 	.word	0x20001a30

000127dc <vTaskPlaceOnEventList>:
{
   127dc:	b510      	push	{r4, lr}
   127de:	460c      	mov	r4, r1
	configASSERT(pxEventList);
   127e0:	b940      	cbnz	r0, 127f4 <vTaskPlaceOnEventList+0x18>
   127e2:	f04f 0380 	mov.w	r3, #128	; 0x80
   127e6:	f383 8811 	msr	BASEPRI, r3
   127ea:	f3bf 8f6f 	isb	sy
   127ee:	f3bf 8f4f 	dsb	sy
   127f2:	e7fe      	b.n	127f2 <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
   127f4:	4b05      	ldr	r3, [pc, #20]	; (1280c <vTaskPlaceOnEventList+0x30>)
   127f6:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
   127fa:	4b05      	ldr	r3, [pc, #20]	; (12810 <vTaskPlaceOnEventList+0x34>)
   127fc:	3118      	adds	r1, #24
   127fe:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12800:	4620      	mov	r0, r4
   12802:	4b04      	ldr	r3, [pc, #16]	; (12814 <vTaskPlaceOnEventList+0x38>)
}
   12804:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12808:	2101      	movs	r1, #1
   1280a:	4718      	bx	r3
   1280c:	20001a30 	.word	0x20001a30
   12810:	0000b181 	.word	0x0000b181
   12814:	00012259 	.word	0x00012259

00012818 <vTaskPlaceOnEventListRestricted>:
{
   12818:	b570      	push	{r4, r5, r6, lr}
   1281a:	460d      	mov	r5, r1
   1281c:	4614      	mov	r4, r2
	configASSERT(pxEventList);
   1281e:	b940      	cbnz	r0, 12832 <vTaskPlaceOnEventListRestricted+0x1a>
   12820:	f04f 0380 	mov.w	r3, #128	; 0x80
   12824:	f383 8811 	msr	BASEPRI, r3
   12828:	f3bf 8f6f 	isb	sy
   1282c:	f3bf 8f4f 	dsb	sy
   12830:	e7fe      	b.n	12830 <vTaskPlaceOnEventListRestricted+0x18>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
   12832:	4b08      	ldr	r3, [pc, #32]	; (12854 <vTaskPlaceOnEventListRestricted+0x3c>)
   12834:	f8d3 1098 	ldr.w	r1, [r3, #152]	; 0x98
   12838:	4b07      	ldr	r3, [pc, #28]	; (12858 <vTaskPlaceOnEventListRestricted+0x40>)
   1283a:	3118      	adds	r1, #24
   1283c:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
   1283e:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12840:	4621      	mov	r1, r4
   12842:	bf08      	it	eq
   12844:	4628      	moveq	r0, r5
   12846:	4b05      	ldr	r3, [pc, #20]	; (1285c <vTaskPlaceOnEventListRestricted+0x44>)
}
   12848:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   1284c:	bf18      	it	ne
   1284e:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   12852:	4718      	bx	r3
   12854:	20001a30 	.word	0x20001a30
   12858:	0000b169 	.word	0x0000b169
   1285c:	00012259 	.word	0x00012259

00012860 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12860:	68c3      	ldr	r3, [r0, #12]
{
   12862:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12864:	68df      	ldr	r7, [r3, #12]
	configASSERT(pxUnblockedTCB);
   12866:	b947      	cbnz	r7, 1287a <xTaskRemoveFromEventList+0x1a>
   12868:	f04f 0380 	mov.w	r3, #128	; 0x80
   1286c:	f383 8811 	msr	BASEPRI, r3
   12870:	f3bf 8f6f 	isb	sy
   12874:	f3bf 8f4f 	dsb	sy
   12878:	e7fe      	b.n	12878 <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   1287a:	f107 0118 	add.w	r1, r7, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   1287e:	4c15      	ldr	r4, [pc, #84]	; (128d4 <xTaskRemoveFromEventList+0x74>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12880:	4e15      	ldr	r6, [pc, #84]	; (128d8 <xTaskRemoveFromEventList+0x78>)
   12882:	9101      	str	r1, [sp, #4]
   12884:	4608      	mov	r0, r1
   12886:	47b0      	blx	r6
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12888:	f8d4 30d8 	ldr.w	r3, [r4, #216]	; 0xd8
   1288c:	4d13      	ldr	r5, [pc, #76]	; (128dc <xTaskRemoveFromEventList+0x7c>)
   1288e:	9901      	ldr	r1, [sp, #4]
   12890:	b9e3      	cbnz	r3, 128cc <xTaskRemoveFromEventList+0x6c>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
   12892:	1d39      	adds	r1, r7, #4
   12894:	4608      	mov	r0, r1
   12896:	9101      	str	r1, [sp, #4]
   12898:	47b0      	blx	r6
		prvAddTaskToReadyList(pxUnblockedTCB);
   1289a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   1289c:	f8d4 20d4 	ldr.w	r2, [r4, #212]	; 0xd4
   128a0:	9901      	ldr	r1, [sp, #4]
   128a2:	4293      	cmp	r3, r2
   128a4:	f04f 0014 	mov.w	r0, #20
   128a8:	bf88      	it	hi
   128aa:	f8c4 30d4 	strhi.w	r3, [r4, #212]	; 0xd4
   128ae:	fb00 4003 	mla	r0, r0, r3, r4
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   128b2:	47a8      	blx	r5
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
   128b4:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
   128b8:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   128ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   128bc:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   128be:	bf8a      	itet	hi
   128c0:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
   128c2:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
   128c4:	f8c4 00e8 	strhi.w	r0, [r4, #232]	; 0xe8
}
   128c8:	b003      	add	sp, #12
   128ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   128cc:	f104 0078 	add.w	r0, r4, #120	; 0x78
   128d0:	e7ef      	b.n	128b2 <xTaskRemoveFromEventList+0x52>
   128d2:	bf00      	nop
   128d4:	20001a30 	.word	0x20001a30
   128d8:	0000b1af 	.word	0x0000b1af
   128dc:	0000b169 	.word	0x0000b169

000128e0 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   128e0:	4b03      	ldr	r3, [pc, #12]	; (128f0 <vTaskInternalSetTimeOutState+0x10>)
   128e2:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
	pxTimeOut->xTimeOnEntering = xTickCount;
   128e6:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   128ea:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   128ec:	6043      	str	r3, [r0, #4]
}
   128ee:	4770      	bx	lr
   128f0:	20001a30 	.word	0x20001a30

000128f4 <xTaskCheckForTimeOut>:
{
   128f4:	b570      	push	{r4, r5, r6, lr}
   128f6:	460c      	mov	r4, r1
	configASSERT(pxTimeOut);
   128f8:	4605      	mov	r5, r0
   128fa:	b940      	cbnz	r0, 1290e <xTaskCheckForTimeOut+0x1a>
   128fc:	f04f 0380 	mov.w	r3, #128	; 0x80
   12900:	f383 8811 	msr	BASEPRI, r3
   12904:	f3bf 8f6f 	isb	sy
   12908:	f3bf 8f4f 	dsb	sy
   1290c:	e7fe      	b.n	1290c <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
   1290e:	b941      	cbnz	r1, 12922 <xTaskCheckForTimeOut+0x2e>
   12910:	f04f 0380 	mov.w	r3, #128	; 0x80
   12914:	f383 8811 	msr	BASEPRI, r3
   12918:	f3bf 8f6f 	isb	sy
   1291c:	f3bf 8f4f 	dsb	sy
   12920:	e7fe      	b.n	12920 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
   12922:	4b11      	ldr	r3, [pc, #68]	; (12968 <xTaskCheckForTimeOut+0x74>)
   12924:	4798      	blx	r3
		    if (*pxTicksToWait == portMAX_DELAY) {
   12926:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
   12928:	4810      	ldr	r0, [pc, #64]	; (1296c <xTaskCheckForTimeOut+0x78>)
		    if (*pxTicksToWait == portMAX_DELAY) {
   1292a:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
   1292c:	f8d0 1094 	ldr.w	r1, [r0, #148]	; 0x94
		    if (*pxTicksToWait == portMAX_DELAY) {
   12930:	d010      	beq.n	12954 <xTaskCheckForTimeOut+0x60>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   12932:	f8d0 00e0 	ldr.w	r0, [r0, #224]	; 0xe0
   12936:	682e      	ldr	r6, [r5, #0]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12938:	686a      	ldr	r2, [r5, #4]
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   1293a:	4286      	cmp	r6, r0
   1293c:	d001      	beq.n	12942 <xTaskCheckForTimeOut+0x4e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
   1293e:	428a      	cmp	r2, r1
   12940:	d90f      	bls.n	12962 <xTaskCheckForTimeOut+0x6e>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   12942:	1a88      	subs	r0, r1, r2
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
   12944:	4283      	cmp	r3, r0
   12946:	d90a      	bls.n	1295e <xTaskCheckForTimeOut+0x6a>
			*pxTicksToWait -= xElapsedTime;
   12948:	1a5b      	subs	r3, r3, r1
   1294a:	4413      	add	r3, r2
   1294c:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
   1294e:	4628      	mov	r0, r5
   12950:	4b07      	ldr	r3, [pc, #28]	; (12970 <xTaskCheckForTimeOut+0x7c>)
   12952:	4798      	blx	r3
			xReturn = pdFALSE;
   12954:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   12956:	4b07      	ldr	r3, [pc, #28]	; (12974 <xTaskCheckForTimeOut+0x80>)
   12958:	4798      	blx	r3
}
   1295a:	4620      	mov	r0, r4
   1295c:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
   1295e:	2300      	movs	r3, #0
   12960:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
   12962:	2401      	movs	r4, #1
   12964:	e7f7      	b.n	12956 <xTaskCheckForTimeOut+0x62>
   12966:	bf00      	nop
   12968:	0000b315 	.word	0x0000b315
   1296c:	20001a30 	.word	0x20001a30
   12970:	000128e1 	.word	0x000128e1
   12974:	0000b359 	.word	0x0000b359

00012978 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   12978:	4b02      	ldr	r3, [pc, #8]	; (12984 <vTaskMissedYield+0xc>)
   1297a:	2201      	movs	r2, #1
   1297c:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
}
   12980:	4770      	bx	lr
   12982:	bf00      	nop
   12984:	20001a30 	.word	0x20001a30

00012988 <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
   12988:	4b06      	ldr	r3, [pc, #24]	; (129a4 <xTaskGetSchedulerState+0x1c>)
   1298a:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
   1298e:	b132      	cbz	r2, 1299e <xTaskGetSchedulerState+0x16>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12990:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
   12994:	2b00      	cmp	r3, #0
			xReturn = taskSCHEDULER_SUSPENDED;
   12996:	bf0c      	ite	eq
   12998:	2002      	moveq	r0, #2
   1299a:	2000      	movne	r0, #0
   1299c:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
   1299e:	2001      	movs	r0, #1
}
   129a0:	4770      	bx	lr
   129a2:	bf00      	nop
   129a4:	20001a30 	.word	0x20001a30

000129a8 <xTaskPriorityDisinherit>:
{
   129a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (pxMutexHolder != NULL) {
   129aa:	b910      	cbnz	r0, 129b2 <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
   129ac:	2000      	movs	r0, #0
}
   129ae:	b003      	add	sp, #12
   129b0:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
   129b2:	4d1d      	ldr	r5, [pc, #116]	; (12a28 <xTaskPriorityDisinherit+0x80>)
   129b4:	f8d5 4098 	ldr.w	r4, [r5, #152]	; 0x98
   129b8:	4284      	cmp	r4, r0
   129ba:	d008      	beq.n	129ce <xTaskPriorityDisinherit+0x26>
   129bc:	f04f 0380 	mov.w	r3, #128	; 0x80
   129c0:	f383 8811 	msr	BASEPRI, r3
   129c4:	f3bf 8f6f 	isb	sy
   129c8:	f3bf 8f4f 	dsb	sy
   129cc:	e7fe      	b.n	129cc <xTaskPriorityDisinherit+0x24>
		configASSERT(pxTCB->uxMutexesHeld);
   129ce:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   129d0:	b943      	cbnz	r3, 129e4 <xTaskPriorityDisinherit+0x3c>
   129d2:	f04f 0380 	mov.w	r3, #128	; 0x80
   129d6:	f383 8811 	msr	BASEPRI, r3
   129da:	f3bf 8f6f 	isb	sy
   129de:	f3bf 8f4f 	dsb	sy
   129e2:	e7fe      	b.n	129e2 <xTaskPriorityDisinherit+0x3a>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   129e4:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   129e6:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
   129e8:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   129ea:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
   129ec:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   129ee:	d0dd      	beq.n	129ac <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
   129f0:	2b00      	cmp	r3, #0
   129f2:	d1db      	bne.n	129ac <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
   129f4:	1d21      	adds	r1, r4, #4
   129f6:	4b0d      	ldr	r3, [pc, #52]	; (12a2c <xTaskPriorityDisinherit+0x84>)
   129f8:	9101      	str	r1, [sp, #4]
   129fa:	4608      	mov	r0, r1
   129fc:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   129fe:	6c63      	ldr	r3, [r4, #68]	; 0x44
   12a00:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
   12a02:	f1c3 0205 	rsb	r2, r3, #5
   12a06:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
   12a08:	f8d5 20d4 	ldr.w	r2, [r5, #212]	; 0xd4
   12a0c:	9901      	ldr	r1, [sp, #4]
   12a0e:	4293      	cmp	r3, r2
   12a10:	f04f 0014 	mov.w	r0, #20
   12a14:	fb00 5003 	mla	r0, r0, r3, r5
   12a18:	bf88      	it	hi
   12a1a:	f8c5 30d4 	strhi.w	r3, [r5, #212]	; 0xd4
   12a1e:	4b04      	ldr	r3, [pc, #16]	; (12a30 <xTaskPriorityDisinherit+0x88>)
   12a20:	4798      	blx	r3
				xReturn = pdTRUE;
   12a22:	2001      	movs	r0, #1
	return xReturn;
   12a24:	e7c3      	b.n	129ae <xTaskPriorityDisinherit+0x6>
   12a26:	bf00      	nop
   12a28:	20001a30 	.word	0x20001a30
   12a2c:	0000b1af 	.word	0x0000b1af
   12a30:	0000b169 	.word	0x0000b169

00012a34 <event_system_init>:
/**
 * \brief Initialize event system.
 */
int32_t event_system_init(void)
{
	return _event_system_init();
   12a34:	4b00      	ldr	r3, [pc, #0]	; (12a38 <event_system_init+0x4>)
   12a36:	4718      	bx	r3
   12a38:	0000b955 	.word	0x0000b955

00012a3c <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
   12a3c:	6b03      	ldr	r3, [r0, #48]	; 0x30
   12a3e:	420b      	tst	r3, r1
   12a40:	d1fc      	bne.n	12a3c <hri_adc_wait_for_sync>
	};
}
   12a42:	4770      	bx	lr

00012a44 <hri_adc_set_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
   12a44:	8803      	ldrh	r3, [r0, #0]
   12a46:	b29b      	uxth	r3, r3
   12a48:	f043 0302 	orr.w	r3, r3, #2
   12a4c:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12a4e:	2103      	movs	r1, #3
   12a50:	4b00      	ldr	r3, [pc, #0]	; (12a54 <hri_adc_set_CTRLA_ENABLE_bit+0x10>)
   12a52:	4718      	bx	r3
   12a54:	00012a3d 	.word	0x00012a3d

00012a58 <hri_adc_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
   12a58:	8803      	ldrh	r3, [r0, #0]
   12a5a:	f023 0302 	bic.w	r3, r3, #2
   12a5e:	041b      	lsls	r3, r3, #16
   12a60:	0c1b      	lsrs	r3, r3, #16
   12a62:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12a64:	2103      	movs	r1, #3
   12a66:	4b01      	ldr	r3, [pc, #4]	; (12a6c <hri_adc_clear_CTRLA_ENABLE_bit+0x14>)
   12a68:	4718      	bx	r3
   12a6a:	bf00      	nop
   12a6c:	00012a3d 	.word	0x00012a3d

00012a70 <_adc_interrupt_handler>:
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _adc_interrupt_handler(struct _adc_async_device *device)
{
	void *const hw      = device->hw;
   12a70:	6942      	ldr	r2, [r0, #20]
	return ((Adc *)hw)->INTFLAG.reg;
   12a72:	f892 102e 	ldrb.w	r1, [r2, #46]	; 0x2e
	return ((Adc *)hw)->INTENSET.reg;
   12a76:	f892 302d 	ldrb.w	r3, [r2, #45]	; 0x2d
	uint8_t     intflag = hri_adc_read_INTFLAG_reg(hw);
	intflag &= hri_adc_read_INTEN_reg(hw);
   12a7a:	400b      	ands	r3, r1
{
   12a7c:	b430      	push	{r4, r5}
	if (intflag & ADC_INTFLAG_RESRDY) {
   12a7e:	f013 0501 	ands.w	r5, r3, #1
   12a82:	d009      	beq.n	12a98 <_adc_interrupt_handler+0x28>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_RESRDY;
   12a84:	2301      	movs	r3, #1
   12a86:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
	return ((Adc *)hw)->RESULT.reg;
   12a8a:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
		hri_adc_clear_interrupt_RESRDY_bit(hw);
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   12a8e:	6883      	ldr	r3, [r0, #8]
		device->adc_async_cb.error_cb(device, 0);
	} else if (intflag & ADC_INTFLAG_WINMON) {
		hri_adc_clear_interrupt_WINMON_bit(hw);
		device->adc_async_cb.window_cb(device, 0);
	}
}
   12a90:	bc30      	pop	{r4, r5}
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   12a92:	b292      	uxth	r2, r2
   12a94:	2100      	movs	r1, #0
   12a96:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_OVERRUN) {
   12a98:	f013 0102 	ands.w	r1, r3, #2
   12a9c:	d006      	beq.n	12aac <_adc_interrupt_handler+0x3c>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
   12a9e:	2302      	movs	r3, #2
   12aa0:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.error_cb(device, 0);
   12aa4:	6843      	ldr	r3, [r0, #4]
   12aa6:	4629      	mov	r1, r5
}
   12aa8:	bc30      	pop	{r4, r5}
		device->adc_async_cb.window_cb(device, 0);
   12aaa:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_WINMON) {
   12aac:	075b      	lsls	r3, r3, #29
   12aae:	d504      	bpl.n	12aba <_adc_interrupt_handler+0x4a>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
   12ab0:	2304      	movs	r3, #4
   12ab2:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.window_cb(device, 0);
   12ab6:	6803      	ldr	r3, [r0, #0]
   12ab8:	e7f6      	b.n	12aa8 <_adc_interrupt_handler+0x38>
}
   12aba:	bc30      	pop	{r4, r5}
   12abc:	4770      	bx	lr
	...

00012ac0 <_adc_get_regs>:
{
   12ac0:	b508      	push	{r3, lr}
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12ac2:	f100 433d 	add.w	r3, r0, #3170893824	; 0xbd000000
   12ac6:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
		if (_adcs[i].number == n) {
   12aca:	f413 3f7f 	tst.w	r3, #261120	; 0x3fc00
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12ace:	f3c3 2087 	ubfx	r0, r3, #10, #8
		if (_adcs[i].number == n) {
   12ad2:	d007      	beq.n	12ae4 <_adc_get_regs+0x24>
   12ad4:	2801      	cmp	r0, #1
   12ad6:	d005      	beq.n	12ae4 <_adc_get_regs+0x24>
	ASSERT(false);
   12ad8:	2000      	movs	r0, #0
   12ada:	4903      	ldr	r1, [pc, #12]	; (12ae8 <_adc_get_regs+0x28>)
   12adc:	4b03      	ldr	r3, [pc, #12]	; (12aec <_adc_get_regs+0x2c>)
   12ade:	228c      	movs	r2, #140	; 0x8c
   12ae0:	4798      	blx	r3
	return 0;
   12ae2:	2000      	movs	r0, #0
}
   12ae4:	bd08      	pop	{r3, pc}
   12ae6:	bf00      	nop
   12ae8:	00017491 	.word	0x00017491
   12aec:	0000df45 	.word	0x0000df45

00012af0 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12af0:	0943      	lsrs	r3, r0, #5
   12af2:	2201      	movs	r2, #1
   12af4:	f000 001f 	and.w	r0, r0, #31
   12af8:	fa02 f000 	lsl.w	r0, r2, r0
   12afc:	3360      	adds	r3, #96	; 0x60
   12afe:	4a02      	ldr	r2, [pc, #8]	; (12b08 <__NVIC_ClearPendingIRQ+0x18>)
   12b00:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   12b04:	4770      	bx	lr
   12b06:	bf00      	nop
   12b08:	e000e100 	.word	0xe000e100

00012b0c <_adc_get_irq_num.isra.0>:
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   12b0c:	f100 403d 	add.w	r0, r0, #3170893824	; 0xbd000000
   12b10:	f5a0 50e0 	sub.w	r0, r0, #7168	; 0x1c00
   12b14:	0a80      	lsrs	r0, r0, #10
	return ADC0_0_IRQn + (_adc_get_hardware_index(device->hw) << 1);
   12b16:	0040      	lsls	r0, r0, #1
   12b18:	3076      	adds	r0, #118	; 0x76
}
   12b1a:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   12b1e:	4770      	bx	lr

00012b20 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12b20:	0943      	lsrs	r3, r0, #5
   12b22:	2201      	movs	r2, #1
   12b24:	f000 001f 	and.w	r0, r0, #31
   12b28:	fa02 f000 	lsl.w	r0, r2, r0
   12b2c:	3320      	adds	r3, #32
   12b2e:	4a04      	ldr	r2, [pc, #16]	; (12b40 <__NVIC_DisableIRQ+0x20>)
   12b30:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   12b34:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   12b38:	f3bf 8f6f 	isb	sy
}
   12b3c:	4770      	bx	lr
   12b3e:	bf00      	nop
   12b40:	e000e100 	.word	0xe000e100

00012b44 <_adc_init>:
{
   12b44:	b538      	push	{r3, r4, r5, lr}
	if (hw == ADC0) {
   12b46:	4b39      	ldr	r3, [pc, #228]	; (12c2c <_adc_init+0xe8>)
   12b48:	4298      	cmp	r0, r3
{
   12b4a:	460c      	mov	r4, r1
	if (hw == ADC0) {
   12b4c:	d15c      	bne.n	12c08 <_adc_init+0xc4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   12b4e:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   12b52:	681b      	ldr	r3, [r3, #0]
   12b54:	00da      	lsls	r2, r3, #3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   12b56:	0919      	lsrs	r1, r3, #4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   12b58:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   12b5c:	f001 0170 	and.w	r1, r1, #112	; 0x70
   12b60:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
   12b62:	f3c3 0382 	ubfx	r3, r3, #2, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12b66:	431a      	orrs	r2, r3
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
   12b68:	6b03      	ldr	r3, [r0, #48]	; 0x30
   12b6a:	4d31      	ldr	r5, [pc, #196]	; (12c30 <_adc_init+0xec>)
	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
   12b6c:	f013 0f01 	tst.w	r3, #1
   12b70:	d10c      	bne.n	12b8c <_adc_init+0x48>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12b72:	2103      	movs	r1, #3
   12b74:	47a8      	blx	r5
	tmp = ((Adc *)hw)->CTRLA.reg;
   12b76:	8803      	ldrh	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
   12b78:	079b      	lsls	r3, r3, #30
   12b7a:	d503      	bpl.n	12b84 <_adc_init+0x40>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
   12b7c:	4b2d      	ldr	r3, [pc, #180]	; (12c34 <_adc_init+0xf0>)
   12b7e:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
   12b80:	2102      	movs	r1, #2
   12b82:	47a8      	blx	r5
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
   12b84:	2301      	movs	r3, #1
   12b86:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12b88:	2103      	movs	r1, #3
   12b8a:	47a8      	blx	r5
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
   12b8c:	2101      	movs	r1, #1
   12b8e:	47a8      	blx	r5
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
   12b90:	4929      	ldr	r1, [pc, #164]	; (12c38 <_adc_init+0xf4>)
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
   12b92:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
   12b96:	2316      	movs	r3, #22
   12b98:	fb03 1404 	mla	r4, r3, r4, r1
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12b9c:	f640 71ff 	movw	r1, #4095	; 0xfff
   12ba0:	88a3      	ldrh	r3, [r4, #4]
	((Adc *)hw)->CTRLB.reg = data;
   12ba2:	80c3      	strh	r3, [r0, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12ba4:	47a8      	blx	r5
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
   12ba6:	79a3      	ldrb	r3, [r4, #6]
	((Adc *)hw)->REFCTRL.reg = data;
   12ba8:	7203      	strb	r3, [r0, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12baa:	f640 71ff 	movw	r1, #4095	; 0xfff
   12bae:	47a8      	blx	r5
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
   12bb0:	79e3      	ldrb	r3, [r4, #7]
	((Adc *)hw)->EVCTRL.reg = data;
   12bb2:	7083      	strb	r3, [r0, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
   12bb4:	8923      	ldrh	r3, [r4, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
   12bb6:	8083      	strh	r3, [r0, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12bb8:	f640 71ff 	movw	r1, #4095	; 0xfff
   12bbc:	47a8      	blx	r5
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
   12bbe:	7aa3      	ldrb	r3, [r4, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
   12bc0:	7283      	strb	r3, [r0, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12bc2:	f640 71ff 	movw	r1, #4095	; 0xfff
   12bc6:	47a8      	blx	r5
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
   12bc8:	7ae3      	ldrb	r3, [r4, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
   12bca:	72c3      	strb	r3, [r0, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12bcc:	f640 71ff 	movw	r1, #4095	; 0xfff
   12bd0:	47a8      	blx	r5
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
   12bd2:	89a3      	ldrh	r3, [r4, #12]
	((Adc *)hw)->WINLT.reg = data;
   12bd4:	8183      	strh	r3, [r0, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
   12bd6:	2180      	movs	r1, #128	; 0x80
   12bd8:	47a8      	blx	r5
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
   12bda:	89e3      	ldrh	r3, [r4, #14]
	((Adc *)hw)->WINUT.reg = data;
   12bdc:	81c3      	strh	r3, [r0, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
   12bde:	f44f 7180 	mov.w	r1, #256	; 0x100
   12be2:	47a8      	blx	r5
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
   12be4:	8a23      	ldrh	r3, [r4, #16]
	((Adc *)hw)->GAINCORR.reg = data;
   12be6:	8203      	strh	r3, [r0, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
   12be8:	f44f 7100 	mov.w	r1, #512	; 0x200
   12bec:	47a8      	blx	r5
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
   12bee:	8a63      	ldrh	r3, [r4, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
   12bf0:	8243      	strh	r3, [r0, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
   12bf2:	f44f 6180 	mov.w	r1, #1024	; 0x400
   12bf6:	47a8      	blx	r5
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
   12bf8:	7d23      	ldrb	r3, [r4, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
   12bfa:	70c3      	strb	r3, [r0, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
   12bfc:	8863      	ldrh	r3, [r4, #2]
	((Adc *)hw)->CTRLA.reg = data;
   12bfe:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   12c00:	2103      	movs	r1, #3
   12c02:	47a8      	blx	r5
}
   12c04:	2000      	movs	r0, #0
   12c06:	bd38      	pop	{r3, r4, r5, pc}
	} else if (hw == ADC1) {
   12c08:	4b0c      	ldr	r3, [pc, #48]	; (12c3c <_adc_init+0xf8>)
   12c0a:	4298      	cmp	r0, r3
   12c0c:	d10c      	bne.n	12c28 <_adc_init+0xe4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12c0e:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   12c12:	681b      	ldr	r3, [r3, #0]
   12c14:	0ada      	lsrs	r2, r3, #11
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   12c16:	0c99      	lsrs	r1, r3, #18
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   12c18:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   12c1c:	f001 0170 	and.w	r1, r1, #112	; 0x70
   12c20:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
   12c22:	f3c3 4302 	ubfx	r3, r3, #16, #3
   12c26:	e79e      	b.n	12b66 <_adc_init+0x22>
	uint16_t calib_reg = 0;
   12c28:	2200      	movs	r2, #0
   12c2a:	e79d      	b.n	12b68 <_adc_init+0x24>
   12c2c:	43001c00 	.word	0x43001c00
   12c30:	00012a3d 	.word	0x00012a3d
   12c34:	00012a59 	.word	0x00012a59
   12c38:	000174a6 	.word	0x000174a6
   12c3c:	43002000 	.word	0x43002000

00012c40 <_adc_async_init>:
{
   12c40:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ASSERT(device);
   12c44:	4604      	mov	r4, r0
   12c46:	3800      	subs	r0, #0
   12c48:	bf18      	it	ne
   12c4a:	2001      	movne	r0, #1
{
   12c4c:	460d      	mov	r5, r1
	ASSERT(device);
   12c4e:	22f1      	movs	r2, #241	; 0xf1
   12c50:	4923      	ldr	r1, [pc, #140]	; (12ce0 <_adc_async_init+0xa0>)
   12c52:	4b24      	ldr	r3, [pc, #144]	; (12ce4 <_adc_async_init+0xa4>)
   12c54:	4798      	blx	r3
	init_status = _adc_init(hw, _adc_get_regs((uint32_t)hw));
   12c56:	4b24      	ldr	r3, [pc, #144]	; (12ce8 <_adc_async_init+0xa8>)
   12c58:	4628      	mov	r0, r5
   12c5a:	4798      	blx	r3
   12c5c:	4b23      	ldr	r3, [pc, #140]	; (12cec <_adc_async_init+0xac>)
   12c5e:	4601      	mov	r1, r0
   12c60:	4628      	mov	r0, r5
   12c62:	4798      	blx	r3
	if (init_status) {
   12c64:	4606      	mov	r6, r0
   12c66:	2800      	cmp	r0, #0
   12c68:	d130      	bne.n	12ccc <_adc_async_init+0x8c>
	if (hw == ADC0) {
   12c6a:	4b21      	ldr	r3, [pc, #132]	; (12cf0 <_adc_async_init+0xb0>)
	device->hw = hw;
   12c6c:	6165      	str	r5, [r4, #20]
	if (hw == ADC0) {
   12c6e:	429d      	cmp	r5, r3
   12c70:	d12f      	bne.n	12cd2 <_adc_async_init+0x92>
		_adc0_dev = dev;
   12c72:	4b20      	ldr	r3, [pc, #128]	; (12cf4 <_adc_async_init+0xb4>)
   12c74:	601c      	str	r4, [r3, #0]
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   12c76:	4920      	ldr	r1, [pc, #128]	; (12cf8 <_adc_async_init+0xb8>)
   12c78:	f8df 9088 	ldr.w	r9, [pc, #136]	; 12d04 <_adc_async_init+0xc4>
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   12c7c:	f8df 8088 	ldr.w	r8, [pc, #136]	; 12d08 <_adc_async_init+0xc8>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   12c80:	4f1e      	ldr	r7, [pc, #120]	; (12cfc <_adc_async_init+0xbc>)
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   12c82:	4628      	mov	r0, r5
   12c84:	4788      	blx	r1
   12c86:	b200      	sxth	r0, r0
   12c88:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   12c8a:	6960      	ldr	r0, [r4, #20]
   12c8c:	4788      	blx	r1
   12c8e:	b200      	sxth	r0, r0
   12c90:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 0);
   12c92:	6960      	ldr	r0, [r4, #20]
   12c94:	4788      	blx	r1
   12c96:	2501      	movs	r5, #1
   12c98:	0942      	lsrs	r2, r0, #5
   12c9a:	f000 031f 	and.w	r3, r0, #31
   12c9e:	fa05 f303 	lsl.w	r3, r5, r3
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 1);
   12ca2:	4428      	add	r0, r5
   12ca4:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
   12ca8:	b200      	sxth	r0, r0
   12caa:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 1);
   12cac:	6960      	ldr	r0, [r4, #20]
   12cae:	4788      	blx	r1
   12cb0:	4428      	add	r0, r5
   12cb2:	b200      	sxth	r0, r0
   12cb4:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 1);
   12cb6:	6960      	ldr	r0, [r4, #20]
   12cb8:	4788      	blx	r1
   12cba:	1943      	adds	r3, r0, r5
   12cbc:	f3c3 124a 	ubfx	r2, r3, #5, #11
   12cc0:	f003 031f 	and.w	r3, r3, #31
   12cc4:	fa05 f303 	lsl.w	r3, r5, r3
   12cc8:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
}
   12ccc:	4630      	mov	r0, r6
   12cce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (hw == ADC1) {
   12cd2:	4b0b      	ldr	r3, [pc, #44]	; (12d00 <_adc_async_init+0xc0>)
   12cd4:	429d      	cmp	r5, r3
		_adc1_dev = dev;
   12cd6:	bf04      	itt	eq
   12cd8:	4b06      	ldreq	r3, [pc, #24]	; (12cf4 <_adc_async_init+0xb4>)
   12cda:	605c      	streq	r4, [r3, #4]
   12cdc:	e7cb      	b.n	12c76 <_adc_async_init+0x36>
   12cde:	bf00      	nop
   12ce0:	00017491 	.word	0x00017491
   12ce4:	0000df45 	.word	0x0000df45
   12ce8:	00012ac1 	.word	0x00012ac1
   12cec:	00012b45 	.word	0x00012b45
   12cf0:	43001c00 	.word	0x43001c00
   12cf4:	20001b1c 	.word	0x20001b1c
   12cf8:	00012b0d 	.word	0x00012b0d
   12cfc:	e000e100 	.word	0xe000e100
   12d00:	43002000 	.word	0x43002000
   12d04:	00012b21 	.word	0x00012b21
   12d08:	00012af1 	.word	0x00012af1

00012d0c <_adc_async_enable_channel>:
	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
   12d0c:	6940      	ldr	r0, [r0, #20]
   12d0e:	4b01      	ldr	r3, [pc, #4]	; (12d14 <_adc_async_enable_channel+0x8>)
   12d10:	4718      	bx	r3
   12d12:	bf00      	nop
   12d14:	00012a45 	.word	0x00012a45

00012d18 <_adc_async_get_data_size>:
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
   12d18:	6943      	ldr	r3, [r0, #20]
	tmp = ((Adc *)hw)->CTRLB.reg;
   12d1a:	88db      	ldrh	r3, [r3, #6]
   12d1c:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   12d20:	2b03      	cmp	r3, #3
}
   12d22:	bf0c      	ite	eq
   12d24:	2001      	moveq	r0, #1
   12d26:	2002      	movne	r0, #2
   12d28:	4770      	bx	lr
	...

00012d2c <_adc_async_convert>:
	hri_adc_set_SWTRIG_START_bit(device->hw);
   12d2c:	6940      	ldr	r0, [r0, #20]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
   12d2e:	7d03      	ldrb	r3, [r0, #20]
   12d30:	f043 0302 	orr.w	r3, r3, #2
   12d34:	7503      	strb	r3, [r0, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   12d36:	f640 71ff 	movw	r1, #4095	; 0xfff
   12d3a:	4b01      	ldr	r3, [pc, #4]	; (12d40 <_adc_async_convert+0x14>)
   12d3c:	4718      	bx	r3
   12d3e:	bf00      	nop
   12d40:	00012a3d 	.word	0x00012a3d

00012d44 <_adc_async_set_irq_state>:
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   12d44:	2a01      	cmp	r2, #1
	void *const hw = device->hw;
   12d46:	6941      	ldr	r1, [r0, #20]
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   12d48:	d104      	bne.n	12d54 <_adc_async_set_irq_state+0x10>
	if (value == 0x0) {
   12d4a:	2204      	movs	r2, #4
	if (value == 0x0) {
   12d4c:	b93b      	cbnz	r3, 12d5e <_adc_async_set_irq_state+0x1a>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_RESRDY;
   12d4e:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
   12d52:	4770      	bx	lr
	} else if (ADC_ASYNC_DEVICE_ERROR_CB == type) {
   12d54:	2a02      	cmp	r2, #2
   12d56:	d0f9      	beq.n	12d4c <_adc_async_set_irq_state+0x8>
	} else if (ADC_ASYNC_DEVICE_CONVERT_CB == type) {
   12d58:	b91a      	cbnz	r2, 12d62 <_adc_async_set_irq_state+0x1e>
	if (value == 0x0) {
   12d5a:	2201      	movs	r2, #1
   12d5c:	e7f6      	b.n	12d4c <_adc_async_set_irq_state+0x8>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_RESRDY;
   12d5e:	f881 202d 	strb.w	r2, [r1, #45]	; 0x2d
}
   12d62:	4770      	bx	lr

00012d64 <ADC0_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC0_0_Handler(void)
{
	_adc_interrupt_handler(_adc0_dev);
   12d64:	4b01      	ldr	r3, [pc, #4]	; (12d6c <ADC0_0_Handler+0x8>)
   12d66:	6818      	ldr	r0, [r3, #0]
   12d68:	4b01      	ldr	r3, [pc, #4]	; (12d70 <ADC0_0_Handler+0xc>)
   12d6a:	4718      	bx	r3
   12d6c:	20001b1c 	.word	0x20001b1c
   12d70:	00012a71 	.word	0x00012a71

00012d74 <ADC0_1_Handler>:
   12d74:	4b00      	ldr	r3, [pc, #0]	; (12d78 <ADC0_1_Handler+0x4>)
   12d76:	4718      	bx	r3
   12d78:	00012d65 	.word	0x00012d65

00012d7c <ADC1_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC1_0_Handler(void)
{
	_adc_interrupt_handler(_adc1_dev);
   12d7c:	4b01      	ldr	r3, [pc, #4]	; (12d84 <ADC1_0_Handler+0x8>)
   12d7e:	6858      	ldr	r0, [r3, #4]
   12d80:	4b01      	ldr	r3, [pc, #4]	; (12d88 <ADC1_0_Handler+0xc>)
   12d82:	4718      	bx	r3
   12d84:	20001b1c 	.word	0x20001b1c
   12d88:	00012a71 	.word	0x00012a71

00012d8c <ADC1_1_Handler>:
   12d8c:	4b00      	ldr	r3, [pc, #0]	; (12d90 <ADC1_1_Handler+0x4>)
   12d8e:	4718      	bx	r3
   12d90:	00012d7d 	.word	0x00012d7d

00012d94 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
   12d94:	e7fe      	b.n	12d94 <Dummy_Handler>
	...

00012d98 <Reset_Handler>:
{
   12d98:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
   12d9a:	4a14      	ldr	r2, [pc, #80]	; (12dec <Reset_Handler+0x54>)
   12d9c:	4b14      	ldr	r3, [pc, #80]	; (12df0 <Reset_Handler+0x58>)
   12d9e:	429a      	cmp	r2, r3
   12da0:	d002      	beq.n	12da8 <Reset_Handler+0x10>
		for (; pDest < &_erelocate;) {
   12da2:	4914      	ldr	r1, [pc, #80]	; (12df4 <Reset_Handler+0x5c>)
   12da4:	428b      	cmp	r3, r1
   12da6:	d318      	bcc.n	12dda <Reset_Handler+0x42>
	pSrc  = &_etext;
   12da8:	4b13      	ldr	r3, [pc, #76]	; (12df8 <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
   12daa:	4a14      	ldr	r2, [pc, #80]	; (12dfc <Reset_Handler+0x64>)
		*pDest++ = 0;
   12dac:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
   12dae:	4293      	cmp	r3, r2
   12db0:	d318      	bcc.n	12de4 <Reset_Handler+0x4c>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
   12db2:	4a13      	ldr	r2, [pc, #76]	; (12e00 <Reset_Handler+0x68>)
   12db4:	4b13      	ldr	r3, [pc, #76]	; (12e04 <Reset_Handler+0x6c>)
   12db6:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   12dba:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
   12dbc:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   12dc0:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   12dc4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   12dc8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   12dcc:	f3bf 8f6f 	isb	sy
	__libc_init_array();
   12dd0:	4b0d      	ldr	r3, [pc, #52]	; (12e08 <Reset_Handler+0x70>)
   12dd2:	4798      	blx	r3
	main();
   12dd4:	4b0d      	ldr	r3, [pc, #52]	; (12e0c <Reset_Handler+0x74>)
   12dd6:	4798      	blx	r3
	while (1)
   12dd8:	e7fe      	b.n	12dd8 <Reset_Handler+0x40>
			*pDest++ = *pSrc++;
   12dda:	f852 0b04 	ldr.w	r0, [r2], #4
   12dde:	f843 0b04 	str.w	r0, [r3], #4
   12de2:	e7df      	b.n	12da4 <Reset_Handler+0xc>
		*pDest++ = 0;
   12de4:	f843 1b04 	str.w	r1, [r3], #4
   12de8:	e7e1      	b.n	12dae <Reset_Handler+0x16>
   12dea:	bf00      	nop
   12dec:	0001762c 	.word	0x0001762c
   12df0:	20000000 	.word	0x20000000
   12df4:	200005b0 	.word	0x200005b0
   12df8:	200005b0 	.word	0x200005b0
   12dfc:	200159f8 	.word	0x200159f8
   12e00:	00004000 	.word	0x00004000
   12e04:	e000ed00 	.word	0xe000ed00
   12e08:	00013fd9 	.word	0x00013fd9
   12e0c:	00011fa1 	.word	0x00011fa1

00012e10 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
   12e10:	b510      	push	{r4, lr}
	system_init();
   12e12:	4b04      	ldr	r3, [pc, #16]	; (12e24 <atmel_start_init+0x14>)
   12e14:	4798      	blx	r3
	usb_init();
   12e16:	4b04      	ldr	r3, [pc, #16]	; (12e28 <atmel_start_init+0x18>)
   12e18:	4798      	blx	r3
	stdio_redirect_init();
}
   12e1a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
   12e1e:	4b03      	ldr	r3, [pc, #12]	; (12e2c <atmel_start_init+0x1c>)
   12e20:	4718      	bx	r3
   12e22:	bf00      	nop
   12e24:	0001026d 	.word	0x0001026d
   12e28:	0000c821 	.word	0x0000c821
   12e2c:	0000ebd5 	.word	0x0000ebd5

00012e30 <usbdc_unconfig>:
/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   12e30:	4b05      	ldr	r3, [pc, #20]	; (12e48 <usbdc_unconfig+0x18>)
{
   12e32:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   12e34:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
   12e36:	b904      	cbnz	r4, 12e3a <usbdc_unconfig+0xa>
		func->ctrl(func, USBDF_DISABLE, NULL);
		func = func->next;
	}
}
   12e38:	bd10      	pop	{r4, pc}
		func->ctrl(func, USBDF_DISABLE, NULL);
   12e3a:	6863      	ldr	r3, [r4, #4]
   12e3c:	4620      	mov	r0, r4
   12e3e:	2200      	movs	r2, #0
   12e40:	2101      	movs	r1, #1
   12e42:	4798      	blx	r3
		func = func->next;
   12e44:	6824      	ldr	r4, [r4, #0]
   12e46:	e7f6      	b.n	12e36 <usbdc_unconfig+0x6>
   12e48:	20001b24 	.word	0x20001b24

00012e4c <usbdc_change_notify>:
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   12e4c:	4b06      	ldr	r3, [pc, #24]	; (12e68 <usbdc_change_notify+0x1c>)
{
   12e4e:	b570      	push	{r4, r5, r6, lr}
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   12e50:	68dc      	ldr	r4, [r3, #12]
{
   12e52:	4605      	mov	r5, r0
   12e54:	460e      	mov	r6, r1

	while (cg != NULL) {
   12e56:	b904      	cbnz	r4, 12e5a <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
	}
}
   12e58:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
   12e5a:	6863      	ldr	r3, [r4, #4]
   12e5c:	b113      	cbz	r3, 12e64 <usbdc_change_notify+0x18>
			cg->cb(change, value);
   12e5e:	4631      	mov	r1, r6
   12e60:	4628      	mov	r0, r5
   12e62:	4798      	blx	r3
		cg = cg->next;
   12e64:	6824      	ldr	r4, [r4, #0]
   12e66:	e7f6      	b.n	12e56 <usbdc_change_notify+0xa>
   12e68:	20001b24 	.word	0x20001b24

00012e6c <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
   12e6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
   12e6e:	4b0c      	ldr	r3, [pc, #48]	; (12ea0 <usbdc_request_handler+0x34>)
   12e70:	689c      	ldr	r4, [r3, #8]
{
   12e72:	4605      	mov	r5, r0
   12e74:	460e      	mov	r6, r1
   12e76:	4617      	mov	r7, r2
	int32_t                   rc;

	while (h != NULL) {
   12e78:	b90c      	cbnz	r4, 12e7e <usbdc_request_handler+0x12>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
   12e7a:	4620      	mov	r0, r4
}
   12e7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (NULL != h->cb) {
   12e7e:	6863      	ldr	r3, [r4, #4]
   12e80:	b90b      	cbnz	r3, 12e86 <usbdc_request_handler+0x1a>
		h = h->next;
   12e82:	6824      	ldr	r4, [r4, #0]
   12e84:	e7f8      	b.n	12e78 <usbdc_request_handler+0xc>
			rc = h->cb(ep, req, stage);
   12e86:	463a      	mov	r2, r7
   12e88:	4631      	mov	r1, r6
   12e8a:	4628      	mov	r0, r5
   12e8c:	4798      	blx	r3
			if (0 == rc) {
   12e8e:	b120      	cbz	r0, 12e9a <usbdc_request_handler+0x2e>
			} else if (ERR_NOT_FOUND != rc) {
   12e90:	300a      	adds	r0, #10
   12e92:	d0f6      	beq.n	12e82 <usbdc_request_handler+0x16>
				return -1;
   12e94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   12e98:	e7f0      	b.n	12e7c <usbdc_request_handler+0x10>
				return true;
   12e9a:	2001      	movs	r0, #1
   12e9c:	e7ee      	b.n	12e7c <usbdc_request_handler+0x10>
   12e9e:	bf00      	nop
   12ea0:	20001b24 	.word	0x20001b24

00012ea4 <usbd_sof_cb>:
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   12ea4:	4b04      	ldr	r3, [pc, #16]	; (12eb8 <usbd_sof_cb+0x14>)

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
   12ea6:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   12ea8:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
   12eaa:	b904      	cbnz	r4, 12eae <usbd_sof_cb+0xa>
	usbdc_sof_notify();
}
   12eac:	bd10      	pop	{r4, pc}
		if (NULL != sof->cb) {
   12eae:	6863      	ldr	r3, [r4, #4]
   12eb0:	b103      	cbz	r3, 12eb4 <usbd_sof_cb+0x10>
			sof->cb();
   12eb2:	4798      	blx	r3
		sof = sof->next;
   12eb4:	6824      	ldr	r4, [r4, #0]
   12eb6:	e7f8      	b.n	12eaa <usbd_sof_cb+0x6>
   12eb8:	20001b24 	.word	0x20001b24

00012ebc <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
   12ebc:	b510      	push	{r4, lr}
   12ebe:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
   12ec0:	460a      	mov	r2, r1
   12ec2:	b119      	cbz	r1, 12ecc <usbdc_cb_ctl_done+0x10>
   12ec4:	2901      	cmp	r1, #1
   12ec6:	d021      	beq.n	12f0c <usbdc_cb_ctl_done+0x50>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
   12ec8:	2000      	movs	r0, #0
   12eca:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
   12ecc:	7823      	ldrb	r3, [r4, #0]
   12ece:	2b00      	cmp	r3, #0
   12ed0:	d1fa      	bne.n	12ec8 <usbdc_cb_ctl_done+0xc>
	switch (req->bRequest) {
   12ed2:	7863      	ldrb	r3, [r4, #1]
   12ed4:	2b05      	cmp	r3, #5
   12ed6:	d00d      	beq.n	12ef4 <usbdc_cb_ctl_done+0x38>
   12ed8:	2b09      	cmp	r3, #9
   12eda:	d1f5      	bne.n	12ec8 <usbdc_cb_ctl_done+0xc>
		usbdc.cfg_value = req->wValue;
   12edc:	8862      	ldrh	r2, [r4, #2]
   12ede:	4b0e      	ldr	r3, [pc, #56]	; (12f18 <usbdc_cb_ctl_done+0x5c>)
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   12ee0:	2a00      	cmp	r2, #0
		usbdc.cfg_value = req->wValue;
   12ee2:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   12ee4:	bf14      	ite	ne
   12ee6:	2104      	movne	r1, #4
   12ee8:	2103      	moveq	r1, #3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   12eea:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
   12eec:	2001      	movs	r0, #1
   12eee:	4b0b      	ldr	r3, [pc, #44]	; (12f1c <usbdc_cb_ctl_done+0x60>)
   12ef0:	4798      	blx	r3
		break;
   12ef2:	e7e9      	b.n	12ec8 <usbdc_cb_ctl_done+0xc>
		usbdc_set_address(req->wValue);
   12ef4:	8860      	ldrh	r0, [r4, #2]
	usb_d_set_address(addr);
   12ef6:	4b0a      	ldr	r3, [pc, #40]	; (12f20 <usbdc_cb_ctl_done+0x64>)
   12ef8:	b2c0      	uxtb	r0, r0
   12efa:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   12efc:	8863      	ldrh	r3, [r4, #2]
   12efe:	2b00      	cmp	r3, #0
   12f00:	bf18      	it	ne
   12f02:	2103      	movne	r1, #3
   12f04:	4b04      	ldr	r3, [pc, #16]	; (12f18 <usbdc_cb_ctl_done+0x5c>)
   12f06:	bf08      	it	eq
   12f08:	2102      	moveq	r1, #2
   12f0a:	e7ee      	b.n	12eea <usbdc_cb_ctl_done+0x2e>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
   12f0c:	4b05      	ldr	r3, [pc, #20]	; (12f24 <usbdc_cb_ctl_done+0x68>)
   12f0e:	4621      	mov	r1, r4
   12f10:	2000      	movs	r0, #0
   12f12:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
   12f14:	e7d8      	b.n	12ec8 <usbdc_cb_ctl_done+0xc>
   12f16:	bf00      	nop
   12f18:	20001b24 	.word	0x20001b24
   12f1c:	00012e4d 	.word	0x00012e4d
   12f20:	0000f421 	.word	0x0000f421
   12f24:	00012e6d 	.word	0x00012e6d

00012f28 <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
   12f28:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();

	usbdc.state       = USBD_S_DEFAULT;
   12f2a:	4d0d      	ldr	r5, [pc, #52]	; (12f60 <usbdc_reset+0x38>)
	usbdc_unconfig();
   12f2c:	4b0d      	ldr	r3, [pc, #52]	; (12f64 <usbdc_reset+0x3c>)
	usbdc.cfg_value   = 0;
	usbdc.ifc_alt_map = 0;
   12f2e:	2400      	movs	r4, #0
	usbdc.state       = USBD_S_DEFAULT;
   12f30:	2602      	movs	r6, #2
	usbdc_unconfig();
   12f32:	4798      	blx	r3
	usbdc.state       = USBD_S_DEFAULT;
   12f34:	836e      	strh	r6, [r5, #26]

	// Setup EP0
	usb_d_ep_deinit(0);
   12f36:	4620      	mov	r0, r4
   12f38:	4b0b      	ldr	r3, [pc, #44]	; (12f68 <usbdc_reset+0x40>)
	usbdc.ifc_alt_map = 0;
   12f3a:	776c      	strb	r4, [r5, #29]
	usb_d_ep_deinit(0);
   12f3c:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
   12f3e:	4b0b      	ldr	r3, [pc, #44]	; (12f6c <usbdc_reset+0x44>)
   12f40:	7f28      	ldrb	r0, [r5, #28]
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   12f42:	4d0b      	ldr	r5, [pc, #44]	; (12f70 <usbdc_reset+0x48>)
	usb_d_ep0_init(usbdc.ctrl_size);
   12f44:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   12f46:	4621      	mov	r1, r4
   12f48:	4620      	mov	r0, r4
   12f4a:	4a0a      	ldr	r2, [pc, #40]	; (12f74 <usbdc_reset+0x4c>)
   12f4c:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
   12f4e:	4620      	mov	r0, r4
   12f50:	4631      	mov	r1, r6
   12f52:	4a09      	ldr	r2, [pc, #36]	; (12f78 <usbdc_reset+0x50>)
   12f54:	47a8      	blx	r5
	usb_d_ep_enable(0);
   12f56:	4620      	mov	r0, r4
   12f58:	4b08      	ldr	r3, [pc, #32]	; (12f7c <usbdc_reset+0x54>)
}
   12f5a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_d_ep_enable(0);
   12f5e:	4718      	bx	r3
   12f60:	20001b24 	.word	0x20001b24
   12f64:	00012e31 	.word	0x00012e31
   12f68:	0000f48d 	.word	0x0000f48d
   12f6c:	0000f47d 	.word	0x0000f47d
   12f70:	0000f6a1 	.word	0x0000f6a1
   12f74:	00012fb9 	.word	0x00012fb9
   12f78:	00012ebd 	.word	0x00012ebd
   12f7c:	0000f4b9 	.word	0x0000f4b9

00012f80 <usbd_event_cb>:
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
	(void)param;

	switch (ev) {
   12f80:	b110      	cbz	r0, 12f88 <usbd_event_cb+0x8>
   12f82:	2801      	cmp	r0, #1
   12f84:	d002      	beq.n	12f8c <usbd_event_cb+0xc>
   12f86:	4770      	bx	lr
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
   12f88:	4b01      	ldr	r3, [pc, #4]	; (12f90 <usbd_event_cb+0x10>)
   12f8a:	4718      	bx	r3
		break;

	case USB_EV_RESET:
		usbdc_reset();
   12f8c:	4b01      	ldr	r3, [pc, #4]	; (12f94 <usbd_event_cb+0x14>)
   12f8e:	4718      	bx	r3
   12f90:	00012e4d 	.word	0x00012e4d
   12f94:	00012f29 	.word	0x00012f29

00012f98 <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
   12f98:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   12f9a:	f88d 000c 	strb.w	r0, [sp, #12]
   12f9e:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
   12fa2:	a801      	add	r0, sp, #4
   12fa4:	4b03      	ldr	r3, [pc, #12]	; (12fb4 <usbdc_xfer+0x1c>)
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   12fa6:	e9cd 1201 	strd	r1, r2, [sp, #4]
	return usb_d_ep_transfer(&xfer);
   12faa:	4798      	blx	r3
}
   12fac:	b005      	add	sp, #20
   12fae:	f85d fb04 	ldr.w	pc, [sp], #4
   12fb2:	bf00      	nop
   12fb4:	0000f4f9 	.word	0x0000f4f9

00012fb8 <usbdc_cb_ctl_req>:
{
   12fb8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   12fbc:	4ba6      	ldr	r3, [pc, #664]	; (13258 <usbdc_cb_ctl_req+0x2a0>)
   12fbe:	2200      	movs	r2, #0
{
   12fc0:	4605      	mov	r5, r0
   12fc2:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   12fc4:	4798      	blx	r3
   12fc6:	1c43      	adds	r3, r0, #1
   12fc8:	d008      	beq.n	12fdc <usbdc_cb_ctl_req+0x24>
   12fca:	2801      	cmp	r0, #1
   12fcc:	d034      	beq.n	13038 <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
   12fce:	7823      	ldrb	r3, [r4, #0]
   12fd0:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
   12fd4:	d004      	beq.n	12fe0 <usbdc_cb_ctl_req+0x28>
   12fd6:	2a80      	cmp	r2, #128	; 0x80
   12fd8:	f000 80ca 	beq.w	13170 <usbdc_cb_ctl_req+0x1b8>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   12fdc:	2000      	movs	r0, #0
   12fde:	e02b      	b.n	13038 <usbdc_cb_ctl_req+0x80>
	switch (req->bRequest) {
   12fe0:	7862      	ldrb	r2, [r4, #1]
   12fe2:	3a01      	subs	r2, #1
   12fe4:	2a0a      	cmp	r2, #10
   12fe6:	d8f9      	bhi.n	12fdc <usbdc_cb_ctl_req+0x24>
   12fe8:	a101      	add	r1, pc, #4	; (adr r1, 12ff0 <usbdc_cb_ctl_req+0x38>)
   12fea:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   12fee:	bf00      	nop
   12ff0:	000130a3 	.word	0x000130a3
   12ff4:	00012fdd 	.word	0x00012fdd
   12ff8:	000130c9 	.word	0x000130c9
   12ffc:	00012fdd 	.word	0x00012fdd
   13000:	00013027 	.word	0x00013027
   13004:	00012fdd 	.word	0x00012fdd
   13008:	00012fdd 	.word	0x00012fdd
   1300c:	00012fdd 	.word	0x00012fdd
   13010:	0001301d 	.word	0x0001301d
   13014:	00012fdd 	.word	0x00012fdd
   13018:	000130e3 	.word	0x000130e3
		if (!usbdc_set_config(req->wValue)) {
   1301c:	8862      	ldrh	r2, [r4, #2]
   1301e:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
   13020:	b96a      	cbnz	r2, 1303e <usbdc_cb_ctl_req+0x86>
		usbdc_unconfig();
   13022:	4b8e      	ldr	r3, [pc, #568]	; (1325c <usbdc_cb_ctl_req+0x2a4>)
   13024:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
   13026:	2200      	movs	r2, #0
   13028:	2301      	movs	r3, #1
   1302a:	4611      	mov	r1, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   1302c:	4c8c      	ldr	r4, [pc, #560]	; (13260 <usbdc_cb_ctl_req+0x2a8>)
   1302e:	4628      	mov	r0, r5
   13030:	47a0      	blx	r4
   13032:	fab0 f080 	clz	r0, r0
   13036:	0940      	lsrs	r0, r0, #5
}
   13038:	b004      	add	sp, #16
   1303a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
   1303e:	4c89      	ldr	r4, [pc, #548]	; (13264 <usbdc_cb_ctl_req+0x2ac>)
   13040:	6823      	ldr	r3, [r4, #0]
   13042:	e9d3 0100 	ldrd	r0, r1, [r3]
   13046:	4b88      	ldr	r3, [pc, #544]	; (13268 <usbdc_cb_ctl_req+0x2b0>)
   13048:	4798      	blx	r3
	if (NULL == cfg_desc) {
   1304a:	2800      	cmp	r0, #0
   1304c:	d0c6      	beq.n	12fdc <usbdc_cb_ctl_req+0x24>
   1304e:	78c2      	ldrb	r2, [r0, #3]
   13050:	7883      	ldrb	r3, [r0, #2]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13052:	4f86      	ldr	r7, [pc, #536]	; (1326c <usbdc_cb_ctl_req+0x2b4>)
   13054:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
   13058:	fa10 f183 	uxtah	r1, r0, r3
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   1305c:	2204      	movs	r2, #4
	desc.eod  = cfg_desc + total_len;
   1305e:	9103      	str	r1, [sp, #12]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13060:	47b8      	blx	r7
	uint8_t                 last_iface = 0xFF;
   13062:	23ff      	movs	r3, #255	; 0xff
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13064:	9002      	str	r0, [sp, #8]
	while (NULL != desc.sod) {
   13066:	9a02      	ldr	r2, [sp, #8]
   13068:	2a00      	cmp	r2, #0
   1306a:	d0dc      	beq.n	13026 <usbdc_cb_ctl_req+0x6e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
   1306c:	f892 8002 	ldrb.w	r8, [r2, #2]
   13070:	4598      	cmp	r8, r3
   13072:	d014      	beq.n	1309e <usbdc_cb_ctl_req+0xe6>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
   13074:	6926      	ldr	r6, [r4, #16]
			while (NULL != func) {
   13076:	b94e      	cbnz	r6, 1308c <usbdc_cb_ctl_req+0xd4>
		desc.sod = usb_desc_next(desc.sod);
   13078:	9802      	ldr	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   1307a:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   1307c:	7803      	ldrb	r3, [r0, #0]
   1307e:	2204      	movs	r2, #4
   13080:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   13082:	9002      	str	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13084:	47b8      	blx	r7
   13086:	4643      	mov	r3, r8
   13088:	9002      	str	r0, [sp, #8]
   1308a:	e7ec      	b.n	13066 <usbdc_cb_ctl_req+0xae>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
   1308c:	6873      	ldr	r3, [r6, #4]
   1308e:	aa02      	add	r2, sp, #8
   13090:	2100      	movs	r1, #0
   13092:	4630      	mov	r0, r6
   13094:	4798      	blx	r3
   13096:	2800      	cmp	r0, #0
   13098:	d0ee      	beq.n	13078 <usbdc_cb_ctl_req+0xc0>
					func = func->next;
   1309a:	6836      	ldr	r6, [r6, #0]
   1309c:	e7eb      	b.n	13076 <usbdc_cb_ctl_req+0xbe>
   1309e:	4698      	mov	r8, r3
   130a0:	e7ea      	b.n	13078 <usbdc_cb_ctl_req+0xc0>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   130a2:	2b02      	cmp	r3, #2
   130a4:	d19a      	bne.n	12fdc <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   130a6:	88e2      	ldrh	r2, [r4, #6]
   130a8:	2a00      	cmp	r2, #0
   130aa:	d197      	bne.n	12fdc <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
   130ac:	88a0      	ldrh	r0, [r4, #4]
   130ae:	4b70      	ldr	r3, [pc, #448]	; (13270 <usbdc_cb_ctl_req+0x2b8>)
   130b0:	9201      	str	r2, [sp, #4]
   130b2:	4611      	mov	r1, r2
   130b4:	b2c0      	uxtb	r0, r0
   130b6:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   130b8:	9a01      	ldr	r2, [sp, #4]
   130ba:	2301      	movs	r3, #1
		usbdc_xfer(ep, NULL, 0, true);
   130bc:	4611      	mov	r1, r2
   130be:	4628      	mov	r0, r5
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   130c0:	4c67      	ldr	r4, [pc, #412]	; (13260 <usbdc_cb_ctl_req+0x2a8>)
   130c2:	47a0      	blx	r4
			return true;
   130c4:	2001      	movs	r0, #1
   130c6:	e7b7      	b.n	13038 <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   130c8:	2b02      	cmp	r3, #2
   130ca:	d187      	bne.n	12fdc <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   130cc:	88e6      	ldrh	r6, [r4, #6]
   130ce:	2e00      	cmp	r6, #0
   130d0:	d184      	bne.n	12fdc <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
   130d2:	88a0      	ldrh	r0, [r4, #4]
   130d4:	4b66      	ldr	r3, [pc, #408]	; (13270 <usbdc_cb_ctl_req+0x2b8>)
   130d6:	2101      	movs	r1, #1
   130d8:	b2c0      	uxtb	r0, r0
   130da:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   130dc:	2301      	movs	r3, #1
   130de:	4632      	mov	r2, r6
   130e0:	e7ec      	b.n	130bc <usbdc_cb_ctl_req+0x104>
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   130e2:	4d60      	ldr	r5, [pc, #384]	; (13264 <usbdc_cb_ctl_req+0x2ac>)
		return usbdc_set_interface(req->wValue, req->wIndex);
   130e4:	8866      	ldrh	r6, [r4, #2]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   130e6:	682b      	ldr	r3, [r5, #0]
   130e8:	7eea      	ldrb	r2, [r5, #27]
		return usbdc_set_interface(req->wValue, req->wIndex);
   130ea:	88a7      	ldrh	r7, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   130ec:	e9d3 0100 	ldrd	r0, r1, [r3]
   130f0:	4b5d      	ldr	r3, [pc, #372]	; (13268 <usbdc_cb_ctl_req+0x2b0>)
   130f2:	4798      	blx	r3
	if (NULL == ifc) {
   130f4:	2800      	cmp	r0, #0
   130f6:	f43f af71 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
	desc.sod = ifc;
   130fa:	9002      	str	r0, [sp, #8]
	return (ptr[0] + (ptr[1] << 8));
   130fc:	78c2      	ldrb	r2, [r0, #3]
   130fe:	7883      	ldrb	r3, [r0, #2]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   13100:	4c5a      	ldr	r4, [pc, #360]	; (1326c <usbdc_cb_ctl_req+0x2b4>)
   13102:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
   13106:	fa10 f183 	uxtah	r1, r0, r3
   1310a:	9103      	str	r1, [sp, #12]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   1310c:	2204      	movs	r2, #4
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   1310e:	47a0      	blx	r4
		if (NULL == ifc) {
   13110:	2800      	cmp	r0, #0
   13112:	f43f af63 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
   13116:	7883      	ldrb	r3, [r0, #2]
   13118:	42bb      	cmp	r3, r7
   1311a:	d110      	bne.n	1313e <usbdc_cb_ctl_req+0x186>
   1311c:	78c3      	ldrb	r3, [r0, #3]
   1311e:	42b3      	cmp	r3, r6
   13120:	d10d      	bne.n	1313e <usbdc_cb_ctl_req+0x186>
	func     = (struct usbdf_driver *)usbdc.func_list.head;
   13122:	692c      	ldr	r4, [r5, #16]
	desc.sod = ifc;
   13124:	9002      	str	r0, [sp, #8]
	while (NULL != func) {
   13126:	2c00      	cmp	r4, #0
   13128:	f43f af58 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
   1312c:	2101      	movs	r1, #1
   1312e:	6863      	ldr	r3, [r4, #4]
   13130:	aa02      	add	r2, sp, #8
   13132:	4620      	mov	r0, r4
   13134:	4798      	blx	r3
   13136:	4601      	mov	r1, r0
   13138:	b140      	cbz	r0, 1314c <usbdc_cb_ctl_req+0x194>
			func = func->next;
   1313a:	6824      	ldr	r4, [r4, #0]
   1313c:	e7f3      	b.n	13126 <usbdc_cb_ctl_req+0x16e>
		desc.sod = usb_desc_next(desc.sod);
   1313e:	9802      	ldr	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13140:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   13142:	7803      	ldrb	r3, [r0, #0]
   13144:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   13146:	9002      	str	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13148:	2204      	movs	r2, #4
   1314a:	e7e0      	b.n	1310e <usbdc_cb_ctl_req+0x156>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
   1314c:	6863      	ldr	r3, [r4, #4]
   1314e:	aa02      	add	r2, sp, #8
   13150:	4620      	mov	r0, r4
   13152:	4798      	blx	r3
   13154:	2800      	cmp	r0, #0
   13156:	f47f af41 	bne.w	12fdc <usbdc_cb_ctl_req+0x24>
			if (alt_set) {
   1315a:	b126      	cbz	r6, 13166 <usbdc_cb_ctl_req+0x1ae>
				usbdc.ifc_alt_map |= 1 << ifc_id;
   1315c:	2301      	movs	r3, #1
   1315e:	40bb      	lsls	r3, r7
   13160:	7f6f      	ldrb	r7, [r5, #29]
   13162:	431f      	orrs	r7, r3
   13164:	776f      	strb	r7, [r5, #29]
			usbdc_xfer(0, NULL, 0, 0);
   13166:	2300      	movs	r3, #0
   13168:	461a      	mov	r2, r3
   1316a:	4619      	mov	r1, r3
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   1316c:	4618      	mov	r0, r3
   1316e:	e7a7      	b.n	130c0 <usbdc_cb_ctl_req+0x108>
	switch (req->bRequest) {
   13170:	7862      	ldrb	r2, [r4, #1]
   13172:	2a0a      	cmp	r2, #10
   13174:	f63f af32 	bhi.w	12fdc <usbdc_cb_ctl_req+0x24>
   13178:	a101      	add	r1, pc, #4	; (adr r1, 13180 <usbdc_cb_ctl_req+0x1c8>)
   1317a:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   1317e:	bf00      	nop
   13180:	00013279 	.word	0x00013279
   13184:	00012fdd 	.word	0x00012fdd
   13188:	00012fdd 	.word	0x00012fdd
   1318c:	00012fdd 	.word	0x00012fdd
   13190:	00012fdd 	.word	0x00012fdd
   13194:	00012fdd 	.word	0x00012fdd
   13198:	000131ad 	.word	0x000131ad
   1319c:	00012fdd 	.word	0x00012fdd
   131a0:	00013249 	.word	0x00013249
   131a4:	00012fdd 	.word	0x00012fdd
   131a8:	000132a7 	.word	0x000132a7
	uint8_t type = (uint8_t)(req->wValue >> 8);
   131ac:	8863      	ldrh	r3, [r4, #2]
   131ae:	0a19      	lsrs	r1, r3, #8
	switch (type) {
   131b0:	2902      	cmp	r1, #2
	uint8_t type = (uint8_t)(req->wValue >> 8);
   131b2:	460a      	mov	r2, r1
	switch (type) {
   131b4:	d016      	beq.n	131e4 <usbdc_cb_ctl_req+0x22c>
   131b6:	2903      	cmp	r1, #3
   131b8:	d031      	beq.n	1321e <usbdc_cb_ctl_req+0x266>
   131ba:	2901      	cmp	r1, #1
   131bc:	f47f af0e 	bne.w	12fdc <usbdc_cb_ctl_req+0x24>
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   131c0:	4b28      	ldr	r3, [pc, #160]	; (13264 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   131c2:	88e4      	ldrh	r4, [r4, #6]
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   131c4:	681b      	ldr	r3, [r3, #0]
   131c6:	e9d3 0100 	ldrd	r0, r1, [r3]
   131ca:	4b28      	ldr	r3, [pc, #160]	; (1326c <usbdc_cb_ctl_req+0x2b4>)
   131cc:	4798      	blx	r3
	if (!dev_desc) {
   131ce:	4601      	mov	r1, r0
   131d0:	2800      	cmp	r0, #0
   131d2:	f43f af03 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
   131d6:	2c12      	cmp	r4, #18
   131d8:	4622      	mov	r2, r4
   131da:	f04f 0300 	mov.w	r3, #0
   131de:	bf28      	it	cs
   131e0:	2212      	movcs	r2, #18
   131e2:	e723      	b.n	1302c <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   131e4:	4a1f      	ldr	r2, [pc, #124]	; (13264 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   131e6:	88e4      	ldrh	r4, [r4, #6]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   131e8:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   131ea:	7f16      	ldrb	r6, [r2, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   131ec:	1c5a      	adds	r2, r3, #1
   131ee:	e9d0 0100 	ldrd	r0, r1, [r0]
   131f2:	4b1d      	ldr	r3, [pc, #116]	; (13268 <usbdc_cb_ctl_req+0x2b0>)
   131f4:	b2d2      	uxtb	r2, r2
   131f6:	4798      	blx	r3
	if (NULL == cfg_desc) {
   131f8:	4601      	mov	r1, r0
   131fa:	2800      	cmp	r0, #0
   131fc:	f43f aeee 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
	return (ptr[0] + (ptr[1] << 8));
   13200:	78c3      	ldrb	r3, [r0, #3]
   13202:	7882      	ldrb	r2, [r0, #2]
   13204:	eb02 2203 	add.w	r2, r2, r3, lsl #8
   13208:	b292      	uxth	r2, r2
	if (length <= total_len) {
   1320a:	4294      	cmp	r4, r2
   1320c:	d91a      	bls.n	13244 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1320e:	3e01      	subs	r6, #1
   13210:	4226      	tst	r6, r4
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13212:	bf0c      	ite	eq
   13214:	2301      	moveq	r3, #1
   13216:	2300      	movne	r3, #0
   13218:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   1321a:	4622      	mov	r2, r4
   1321c:	e706      	b.n	1302c <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1321e:	4a11      	ldr	r2, [pc, #68]	; (13264 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13220:	88e4      	ldrh	r4, [r4, #6]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   13222:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13224:	7f16      	ldrb	r6, [r2, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   13226:	e9d0 0100 	ldrd	r0, r1, [r0]
   1322a:	b2da      	uxtb	r2, r3
   1322c:	4b11      	ldr	r3, [pc, #68]	; (13274 <usbdc_cb_ctl_req+0x2bc>)
   1322e:	4798      	blx	r3
	if (NULL == str_desc) {
   13230:	4601      	mov	r1, r0
   13232:	2800      	cmp	r0, #0
   13234:	f43f aed2 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
	if (length <= str_desc[0]) {
   13238:	7802      	ldrb	r2, [r0, #0]
   1323a:	4294      	cmp	r4, r2
   1323c:	d902      	bls.n	13244 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1323e:	1e73      	subs	r3, r6, #1
   13240:	4223      	tst	r3, r4
   13242:	e7e6      	b.n	13212 <usbdc_cb_ctl_req+0x25a>
		need_zlp = false;
   13244:	2300      	movs	r3, #0
   13246:	e7e8      	b.n	1321a <usbdc_cb_ctl_req+0x262>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
   13248:	4906      	ldr	r1, [pc, #24]	; (13264 <usbdc_cb_ctl_req+0x2ac>)
   1324a:	694b      	ldr	r3, [r1, #20]
   1324c:	7eca      	ldrb	r2, [r1, #27]
   1324e:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
   13250:	2300      	movs	r3, #0
   13252:	2201      	movs	r2, #1
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13254:	6949      	ldr	r1, [r1, #20]
   13256:	e732      	b.n	130be <usbdc_cb_ctl_req+0x106>
   13258:	00012e6d 	.word	0x00012e6d
   1325c:	00012e31 	.word	0x00012e31
   13260:	00012f99 	.word	0x00012f99
   13264:	20001b24 	.word	0x20001b24
   13268:	0000b72d 	.word	0x0000b72d
   1326c:	0000b6f5 	.word	0x0000b6f5
   13270:	0000f63d 	.word	0x0000f63d
   13274:	0000b769 	.word	0x0000b769
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13278:	f003 011f 	and.w	r1, r3, #31
   1327c:	f013 031e 	ands.w	r3, r3, #30
   13280:	d00b      	beq.n	1329a <usbdc_cb_ctl_req+0x2e2>
   13282:	2902      	cmp	r1, #2
   13284:	f47f aeaa 	bne.w	12fdc <usbdc_cb_ctl_req+0x24>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
   13288:	88a0      	ldrh	r0, [r4, #4]
   1328a:	4b17      	ldr	r3, [pc, #92]	; (132e8 <usbdc_cb_ctl_req+0x330>)
   1328c:	b2c0      	uxtb	r0, r0
   1328e:	4798      	blx	r3
		if (st < 0) {
   13290:	1e03      	subs	r3, r0, #0
   13292:	f6ff aea3 	blt.w	12fdc <usbdc_cb_ctl_req+0x24>
		st = st & 0x1;
   13296:	f003 0301 	and.w	r3, r3, #1
	memcpy(usbdc.ctrl_buf, &st, 2);
   1329a:	4914      	ldr	r1, [pc, #80]	; (132ec <usbdc_cb_ctl_req+0x334>)
   1329c:	694a      	ldr	r2, [r1, #20]
   1329e:	8013      	strh	r3, [r2, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   132a0:	2300      	movs	r3, #0
   132a2:	2202      	movs	r2, #2
   132a4:	e7d6      	b.n	13254 <usbdc_cb_ctl_req+0x29c>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
   132a6:	4911      	ldr	r1, [pc, #68]	; (132ec <usbdc_cb_ctl_req+0x334>)
   132a8:	88a2      	ldrh	r2, [r4, #4]
   132aa:	7f4b      	ldrb	r3, [r1, #29]
   132ac:	4113      	asrs	r3, r2
   132ae:	f013 0301 	ands.w	r3, r3, #1
   132b2:	460e      	mov	r6, r1
   132b4:	d00c      	beq.n	132d0 <usbdc_cb_ctl_req+0x318>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   132b6:	690d      	ldr	r5, [r1, #16]
	while (NULL != func) {
   132b8:	2d00      	cmp	r5, #0
   132ba:	f43f ae8f 	beq.w	12fdc <usbdc_cb_ctl_req+0x24>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
   132be:	686b      	ldr	r3, [r5, #4]
   132c0:	4622      	mov	r2, r4
   132c2:	2102      	movs	r1, #2
   132c4:	4628      	mov	r0, r5
   132c6:	4798      	blx	r3
   132c8:	2800      	cmp	r0, #0
   132ca:	da06      	bge.n	132da <usbdc_cb_ctl_req+0x322>
			func = func->next;
   132cc:	682d      	ldr	r5, [r5, #0]
   132ce:	e7f3      	b.n	132b8 <usbdc_cb_ctl_req+0x300>
		usbdc.ctrl_buf[0] = 0;
   132d0:	694a      	ldr	r2, [r1, #20]
   132d2:	7013      	strb	r3, [r2, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   132d4:	6949      	ldr	r1, [r1, #20]
   132d6:	2201      	movs	r2, #1
   132d8:	e748      	b.n	1316c <usbdc_cb_ctl_req+0x1b4>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
   132da:	6973      	ldr	r3, [r6, #20]
   132dc:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   132de:	6971      	ldr	r1, [r6, #20]
   132e0:	2300      	movs	r3, #0
   132e2:	2201      	movs	r2, #1
   132e4:	e742      	b.n	1316c <usbdc_cb_ctl_req+0x1b4>
   132e6:	bf00      	nop
   132e8:	0000f63d 	.word	0x0000f63d
   132ec:	20001b24 	.word	0x20001b24

000132f0 <usbdc_register_handler>:
/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
	switch (type) {
   132f0:	2801      	cmp	r0, #1
   132f2:	d005      	beq.n	13300 <usbdc_register_handler+0x10>
   132f4:	2802      	cmp	r0, #2
   132f6:	d005      	beq.n	13304 <usbdc_register_handler+0x14>
   132f8:	b930      	cbnz	r0, 13308 <usbdc_register_handler+0x18>
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
   132fa:	4804      	ldr	r0, [pc, #16]	; (1330c <usbdc_register_handler+0x1c>)
		break;
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
		break;
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   132fc:	4b04      	ldr	r3, [pc, #16]	; (13310 <usbdc_register_handler+0x20>)
   132fe:	4718      	bx	r3
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
   13300:	4804      	ldr	r0, [pc, #16]	; (13314 <usbdc_register_handler+0x24>)
   13302:	e7fb      	b.n	132fc <usbdc_register_handler+0xc>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   13304:	4804      	ldr	r0, [pc, #16]	; (13318 <usbdc_register_handler+0x28>)
   13306:	e7f9      	b.n	132fc <usbdc_register_handler+0xc>
		break;
	default:
		break;
	}
}
   13308:	4770      	bx	lr
   1330a:	bf00      	nop
   1330c:	20001b28 	.word	0x20001b28
   13310:	0000f731 	.word	0x0000f731
   13314:	20001b2c 	.word	0x20001b2c
   13318:	20001b30 	.word	0x20001b30

0001331c <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
   1331c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
   1331e:	4604      	mov	r4, r0
   13320:	3800      	subs	r0, #0
   13322:	bf18      	it	ne
   13324:	2001      	movne	r0, #1
   13326:	490c      	ldr	r1, [pc, #48]	; (13358 <usbdc_init+0x3c>)
   13328:	4b0c      	ldr	r3, [pc, #48]	; (1335c <usbdc_init+0x40>)
   1332a:	f240 3255 	movw	r2, #853	; 0x355
   1332e:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
   13330:	4b0b      	ldr	r3, [pc, #44]	; (13360 <usbdc_init+0x44>)
   13332:	4798      	blx	r3
	if (rc < 0) {
   13334:	2800      	cmp	r0, #0
   13336:	db0e      	blt.n	13356 <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
   13338:	4b0a      	ldr	r3, [pc, #40]	; (13364 <usbdc_init+0x48>)
   1333a:	4d0b      	ldr	r5, [pc, #44]	; (13368 <usbdc_init+0x4c>)
   1333c:	2220      	movs	r2, #32
   1333e:	4618      	mov	r0, r3
   13340:	2100      	movs	r1, #0
   13342:	47a8      	blx	r5
	usbdc.ctrl_buf = ctrl_buf;
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   13344:	4909      	ldr	r1, [pc, #36]	; (1336c <usbdc_init+0x50>)
	usbdc.ctrl_buf = ctrl_buf;
   13346:	6144      	str	r4, [r0, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   13348:	4c09      	ldr	r4, [pc, #36]	; (13370 <usbdc_init+0x54>)
   1334a:	2000      	movs	r0, #0
   1334c:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
   1334e:	2001      	movs	r0, #1
   13350:	4908      	ldr	r1, [pc, #32]	; (13374 <usbdc_init+0x58>)
   13352:	47a0      	blx	r4

	return 0;
   13354:	2000      	movs	r0, #0
}
   13356:	bd38      	pop	{r3, r4, r5, pc}
   13358:	000174d2 	.word	0x000174d2
   1335c:	0000df45 	.word	0x0000df45
   13360:	0000f399 	.word	0x0000f399
   13364:	20001b24 	.word	0x20001b24
   13368:	00014175 	.word	0x00014175
   1336c:	00012ea5 	.word	0x00012ea5
   13370:	0000f401 	.word	0x0000f401
   13374:	00012f81 	.word	0x00012f81

00013378 <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
   13378:	4601      	mov	r1, r0
	list_insert_at_end(&usbdc.func_list, func);
   1337a:	4b01      	ldr	r3, [pc, #4]	; (13380 <usbdc_register_function+0x8>)
   1337c:	4801      	ldr	r0, [pc, #4]	; (13384 <usbdc_register_function+0xc>)
   1337e:	4718      	bx	r3
   13380:	0000f731 	.word	0x0000f731
   13384:	20001b34 	.word	0x20001b34

00013388 <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
   13388:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
   1338a:	4b0a      	ldr	r3, [pc, #40]	; (133b4 <usbdc_start+0x2c>)
   1338c:	7e9c      	ldrb	r4, [r3, #26]
   1338e:	b954      	cbnz	r4, 133a6 <usbdc_start+0x1e>
		return ERR_BUSY;
	}

	if (desces) {
   13390:	b160      	cbz	r0, 133ac <usbdc_start+0x24>
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
   13392:	6802      	ldr	r2, [r0, #0]
		usbdc.desces.ls_fs = desces;
   13394:	6018      	str	r0, [r3, #0]
	usbdc.ctrl_size = desces->sod[7];
   13396:	79d2      	ldrb	r2, [r2, #7]
   13398:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
   1339a:	2201      	movs	r2, #1
   1339c:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
   1339e:	4b06      	ldr	r3, [pc, #24]	; (133b8 <usbdc_start+0x30>)
   133a0:	4798      	blx	r3
	return ERR_NONE;
   133a2:	4620      	mov	r0, r4
}
   133a4:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
   133a6:	f06f 0003 	mvn.w	r0, #3
   133aa:	e7fb      	b.n	133a4 <usbdc_start+0x1c>
		return ERR_BAD_DATA;
   133ac:	f06f 0008 	mvn.w	r0, #8
   133b0:	e7f8      	b.n	133a4 <usbdc_start+0x1c>
   133b2:	bf00      	nop
   133b4:	20001b24 	.word	0x20001b24
   133b8:	0000f409 	.word	0x0000f409

000133bc <usbdc_attach>:
/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
	usb_d_attach();
   133bc:	4b00      	ldr	r3, [pc, #0]	; (133c0 <usbdc_attach+0x4>)
   133be:	4718      	bx	r3
   133c0:	0000f411 	.word	0x0000f411

000133c4 <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
   133c4:	4b01      	ldr	r3, [pc, #4]	; (133cc <usbdc_get_ctrl_buffer+0x8>)
   133c6:	6958      	ldr	r0, [r3, #20]
   133c8:	4770      	bx	lr
   133ca:	bf00      	nop
   133cc:	20001b24 	.word	0x20001b24

000133d0 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
   133d0:	4b03      	ldr	r3, [pc, #12]	; (133e0 <usbdc_get_state+0x10>)
   133d2:	7e98      	ldrb	r0, [r3, #26]
   133d4:	f010 0f10 	tst.w	r0, #16
		return USBD_S_SUSPEND;
	}
	return usbdc.state;
}
   133d8:	bf18      	it	ne
   133da:	2010      	movne	r0, #16
   133dc:	4770      	bx	lr
   133de:	bf00      	nop
   133e0:	20001b24 	.word	0x20001b24

000133e4 <hri_tc_wait_for_sync>:
typedef uint8_t  hri_tccount8_per_reg_t;
typedef uint8_t  hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
   133e4:	6903      	ldr	r3, [r0, #16]
   133e6:	420b      	tst	r3, r1
   133e8:	d1fc      	bne.n	133e4 <hri_tc_wait_for_sync>
	};
}
   133ea:	4770      	bx	lr

000133ec <_tc_timer_start>:
/**
 * \brief Start hardware timer
 */
void _tc_timer_start(struct _timer_device *const device)
{
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
   133ec:	68c0      	ldr	r0, [r0, #12]
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
   133ee:	6803      	ldr	r3, [r0, #0]
   133f0:	f043 0302 	orr.w	r3, r3, #2
   133f4:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   133f6:	2103      	movs	r1, #3
   133f8:	4b00      	ldr	r3, [pc, #0]	; (133fc <_tc_timer_start+0x10>)
   133fa:	4718      	bx	r3
   133fc:	000133e5 	.word	0x000133e5

00013400 <_tc_timer_get_period>:
/**
 * \brief Retrieve timer period
 */
uint32_t _tc_timer_get_period(const struct _timer_device *const device)
{
	void *const hw = device->hw;
   13400:	68c0      	ldr	r0, [r0, #12]
{
   13402:	b508      	push	{r3, lr}
}

static inline hri_tc_ctrla_reg_t hri_tc_read_CTRLA_MODE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13404:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13406:	f3c3 0381 	ubfx	r3, r3, #2, #2

	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1340a:	2b02      	cmp	r3, #2
   1340c:	d104      	bne.n	13418 <_tc_timer_get_period+0x18>
	TC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tccount32_cc_reg_t hri_tccount32_read_CC_reg(const void *const hw, uint8_t index)
{
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1340e:	4b0e      	ldr	r3, [pc, #56]	; (13448 <_tc_timer_get_period+0x48>)
   13410:	21c0      	movs	r1, #192	; 0xc0
   13412:	4798      	blx	r3
	return ((Tc *)hw)->COUNT32.CC[index].reg;
   13414:	69c0      	ldr	r0, [r0, #28]
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
		return hri_tccount8_read_PER_reg(hw);
	}

	return 0;
}
   13416:	bd08      	pop	{r3, pc}
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13418:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1341a:	f013 0f0c 	tst.w	r3, #12
   1341e:	d105      	bne.n	1342c <_tc_timer_get_period+0x2c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13420:	4b09      	ldr	r3, [pc, #36]	; (13448 <_tc_timer_get_period+0x48>)
   13422:	21c0      	movs	r1, #192	; 0xc0
   13424:	4798      	blx	r3
	return ((Tc *)hw)->COUNT16.CC[index].reg;
   13426:	8b80      	ldrh	r0, [r0, #28]
   13428:	b280      	uxth	r0, r0
		return hri_tccount16_read_CC_reg(hw, 0);
   1342a:	e7f4      	b.n	13416 <_tc_timer_get_period+0x16>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1342c:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   1342e:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13432:	2b01      	cmp	r3, #1
   13434:	d105      	bne.n	13442 <_tc_timer_get_period+0x42>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13436:	4b04      	ldr	r3, [pc, #16]	; (13448 <_tc_timer_get_period+0x48>)
   13438:	2120      	movs	r1, #32
   1343a:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.PER.reg;
   1343c:	7ec0      	ldrb	r0, [r0, #27]
   1343e:	b2c0      	uxtb	r0, r0
		return hri_tccount8_read_PER_reg(hw);
   13440:	e7e9      	b.n	13416 <_tc_timer_get_period+0x16>
	return 0;
   13442:	2000      	movs	r0, #0
   13444:	e7e7      	b.n	13416 <_tc_timer_get_period+0x16>
   13446:	bf00      	nop
   13448:	000133e5 	.word	0x000133e5

0001344c <_tc_timer_is_started>:
/**
 * \brief Check if timer is running
 */
bool _tc_timer_is_started(const struct _timer_device *const device)
{
   1344c:	b508      	push	{r3, lr}
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
   1344e:	68c0      	ldr	r0, [r0, #12]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13450:	4b03      	ldr	r3, [pc, #12]	; (13460 <_tc_timer_is_started+0x14>)
   13452:	2103      	movs	r1, #3
   13454:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13456:	6800      	ldr	r0, [r0, #0]
}
   13458:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1345c:	bd08      	pop	{r3, pc}
   1345e:	bf00      	nop
   13460:	000133e5 	.word	0x000133e5

00013464 <tc_interrupt_handler>:
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
	void *const hw = device->hw;
   13464:	68c2      	ldr	r2, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
   13466:	7a91      	ldrb	r1, [r2, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
   13468:	07c9      	lsls	r1, r1, #31
   1346a:	d503      	bpl.n	13474 <tc_interrupt_handler+0x10>
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
   1346c:	2101      	movs	r1, #1
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
   1346e:	6803      	ldr	r3, [r0, #0]
   13470:	7291      	strb	r1, [r2, #10]
   13472:	4718      	bx	r3
	}
}
   13474:	4770      	bx	lr
	...

00013478 <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
   13478:	b570      	push	{r4, r5, r6, lr}
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   1347a:	4d15      	ldr	r5, [pc, #84]	; (134d0 <get_tc_index+0x58>)
{
   1347c:	4606      	mov	r6, r0
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   1347e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   13480:	b088      	sub	sp, #32
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13482:	466c      	mov	r4, sp
   13484:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13486:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1348a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   1348e:	466a      	mov	r2, sp
   13490:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
   13492:	f852 1b04 	ldr.w	r1, [r2], #4
   13496:	42b1      	cmp	r1, r6
   13498:	d104      	bne.n	134a4 <get_tc_index+0x2c>
			return i;
   1349a:	b2d8      	uxtb	r0, r3
		if (_tcs[i].number == index) {
   1349c:	b93b      	cbnz	r3, 134ae <get_tc_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   1349e:	4618      	mov	r0, r3
			return i;
   134a0:	b240      	sxtb	r0, r0
   134a2:	e012      	b.n	134ca <get_tc_index+0x52>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   134a4:	3301      	adds	r3, #1
   134a6:	2b08      	cmp	r3, #8
   134a8:	d1f3      	bne.n	13492 <get_tc_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   134aa:	2000      	movs	r0, #0
   134ac:	e7f8      	b.n	134a0 <get_tc_index+0x28>
		if (_tcs[i].number == index) {
   134ae:	2801      	cmp	r0, #1
   134b0:	d0f6      	beq.n	134a0 <get_tc_index+0x28>
   134b2:	2802      	cmp	r0, #2
   134b4:	d0f4      	beq.n	134a0 <get_tc_index+0x28>
   134b6:	2803      	cmp	r0, #3
   134b8:	d0f2      	beq.n	134a0 <get_tc_index+0x28>
	ASSERT(false);
   134ba:	2000      	movs	r0, #0
   134bc:	4905      	ldr	r1, [pc, #20]	; (134d4 <get_tc_index+0x5c>)
   134be:	4b06      	ldr	r3, [pc, #24]	; (134d8 <get_tc_index+0x60>)
   134c0:	f240 1267 	movw	r2, #359	; 0x167
   134c4:	4798      	blx	r3
	return -1;
   134c6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   134ca:	b008      	add	sp, #32
   134cc:	bd70      	pop	{r4, r5, r6, pc}
   134ce:	bf00      	nop
   134d0:	000174fc 	.word	0x000174fc
   134d4:	000174e8 	.word	0x000174e8
   134d8:	0000df45 	.word	0x0000df45

000134dc <_tc_timer_set_irq>:
{
   134dc:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
   134de:	4b0a      	ldr	r3, [pc, #40]	; (13508 <_tc_timer_set_irq+0x2c>)
   134e0:	68c0      	ldr	r0, [r0, #12]
   134e2:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   134e4:	4b09      	ldr	r3, [pc, #36]	; (1350c <_tc_timer_set_irq+0x30>)
   134e6:	490a      	ldr	r1, [pc, #40]	; (13510 <_tc_timer_set_irq+0x34>)
	int8_t      i  = get_tc_index(hw);
   134e8:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
   134ea:	f44f 7291 	mov.w	r2, #290	; 0x122
   134ee:	2001      	movs	r0, #1
   134f0:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
   134f2:	4808      	ldr	r0, [pc, #32]	; (13514 <_tc_timer_set_irq+0x38>)
   134f4:	2314      	movs	r3, #20
   134f6:	fb03 0404 	mla	r4, r3, r4, r0
   134fa:	4b07      	ldr	r3, [pc, #28]	; (13518 <_tc_timer_set_irq+0x3c>)
   134fc:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
}
   13500:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_irq_set(_tcs[i].irq);
   13504:	4718      	bx	r3
   13506:	bf00      	nop
   13508:	00013479 	.word	0x00013479
   1350c:	0000df45 	.word	0x0000df45
   13510:	000174e8 	.word	0x000174e8
   13514:	000174fc 	.word	0x000174fc
   13518:	0000b9b1 	.word	0x0000b9b1

0001351c <_tc_timer_stop>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
   1351c:	68c0      	ldr	r0, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   1351e:	6803      	ldr	r3, [r0, #0]
   13520:	f023 0302 	bic.w	r3, r3, #2
   13524:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13526:	2103      	movs	r1, #3
   13528:	4b00      	ldr	r3, [pc, #0]	; (1352c <_tc_timer_stop+0x10>)
   1352a:	4718      	bx	r3
   1352c:	000133e5 	.word	0x000133e5

00013530 <_tc_timer_deinit>:
{
   13530:	b570      	push	{r4, r5, r6, lr}
	void *const hw = device->hw;
   13532:	68c4      	ldr	r4, [r0, #12]
	int8_t      i  = get_tc_index(hw);
   13534:	4b17      	ldr	r3, [pc, #92]	; (13594 <_tc_timer_deinit+0x64>)
   13536:	4620      	mov	r0, r4
   13538:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   1353a:	4b17      	ldr	r3, [pc, #92]	; (13598 <_tc_timer_deinit+0x68>)
   1353c:	4917      	ldr	r1, [pc, #92]	; (1359c <_tc_timer_deinit+0x6c>)
	int8_t      i  = get_tc_index(hw);
   1353e:	4605      	mov	r5, r0
	ASSERT(ARRAY_SIZE(_tcs));
   13540:	22cd      	movs	r2, #205	; 0xcd
   13542:	2001      	movs	r0, #1
   13544:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
   13546:	4816      	ldr	r0, [pc, #88]	; (135a0 <_tc_timer_deinit+0x70>)
   13548:	2314      	movs	r3, #20
   1354a:	fb03 0505 	mla	r5, r3, r5, r0
   1354e:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13552:	2b00      	cmp	r3, #0
   13554:	db0d      	blt.n	13572 <_tc_timer_deinit+0x42>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13556:	095a      	lsrs	r2, r3, #5
   13558:	2101      	movs	r1, #1
   1355a:	f003 031f 	and.w	r3, r3, #31
   1355e:	fa01 f303 	lsl.w	r3, r1, r3
   13562:	3220      	adds	r2, #32
   13564:	490f      	ldr	r1, [pc, #60]	; (135a4 <_tc_timer_deinit+0x74>)
   13566:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1356a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1356e:	f3bf 8f6f 	isb	sy
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13572:	6823      	ldr	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13574:	4a0c      	ldr	r2, [pc, #48]	; (135a8 <_tc_timer_deinit+0x78>)
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13576:	f023 0302 	bic.w	r3, r3, #2
   1357a:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   1357c:	2103      	movs	r1, #3
   1357e:	4620      	mov	r0, r4
   13580:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_SWRST;
   13582:	6823      	ldr	r3, [r4, #0]
   13584:	f043 0301 	orr.w	r3, r3, #1
   13588:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   1358a:	2101      	movs	r1, #1
}
   1358c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   13590:	4710      	bx	r2
   13592:	bf00      	nop
   13594:	00013479 	.word	0x00013479
   13598:	0000df45 	.word	0x0000df45
   1359c:	000174e8 	.word	0x000174e8
   135a0:	000174fc 	.word	0x000174fc
   135a4:	e000e100 	.word	0xe000e100
   135a8:	000133e5 	.word	0x000133e5

000135ac <_tc_timer_init>:
{
   135ac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int8_t i = get_tc_index(hw);
   135b0:	4b51      	ldr	r3, [pc, #324]	; (136f8 <_tc_timer_init+0x14c>)
{
   135b2:	4607      	mov	r7, r0
	int8_t i = get_tc_index(hw);
   135b4:	4608      	mov	r0, r1
{
   135b6:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
   135b8:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   135ba:	4b50      	ldr	r3, [pc, #320]	; (136fc <_tc_timer_init+0x150>)
   135bc:	4950      	ldr	r1, [pc, #320]	; (13700 <_tc_timer_init+0x154>)
	device->hw = hw;
   135be:	60fc      	str	r4, [r7, #12]
	ASSERT(ARRAY_SIZE(_tcs));
   135c0:	22a0      	movs	r2, #160	; 0xa0
	int8_t i = get_tc_index(hw);
   135c2:	4606      	mov	r6, r0
	ASSERT(ARRAY_SIZE(_tcs));
   135c4:	2001      	movs	r0, #1
   135c6:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
   135c8:	6923      	ldr	r3, [r4, #16]
   135ca:	4a4e      	ldr	r2, [pc, #312]	; (13704 <_tc_timer_init+0x158>)
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
   135cc:	f013 0f01 	tst.w	r3, #1
   135d0:	d112      	bne.n	135f8 <_tc_timer_init+0x4c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   135d2:	2103      	movs	r1, #3
   135d4:	4620      	mov	r0, r4
   135d6:	4790      	blx	r2
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   135d8:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
   135da:	079b      	lsls	r3, r3, #30
   135dc:	d507      	bpl.n	135ee <_tc_timer_init+0x42>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   135de:	6823      	ldr	r3, [r4, #0]
   135e0:	f023 0302 	bic.w	r3, r3, #2
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   135e4:	2103      	movs	r1, #3
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   135e6:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   135e8:	4790      	blx	r2
			hri_tc_wait_for_sync(hw, TC_SYNCBUSY_ENABLE);
   135ea:	2102      	movs	r1, #2
   135ec:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   135ee:	2301      	movs	r3, #1
   135f0:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   135f2:	2103      	movs	r1, #3
   135f4:	4620      	mov	r0, r4
   135f6:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   135f8:	f8df 9124 	ldr.w	r9, [pc, #292]	; 13720 <_tc_timer_init+0x174>
   135fc:	2514      	movs	r5, #20
   135fe:	fb05 9506 	mla	r5, r5, r6, r9
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   13602:	2101      	movs	r1, #1
   13604:	4620      	mov	r0, r4
   13606:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   13608:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   1360c:	f8c4 8000 	str.w	r8, [r4]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13610:	2103      	movs	r1, #3
   13612:	4790      	blx	r2
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
   13614:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
   13618:	73e3      	strb	r3, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
   1361a:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
   1361c:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
   1361e:	2301      	movs	r3, #1
   13620:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
   13622:	f008 030c 	and.w	r3, r8, #12
   13626:	2b08      	cmp	r3, #8
   13628:	d13b      	bne.n	136a2 <_tc_timer_init+0xf6>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
   1362a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   1362c:	61e3      	str	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1362e:	21c0      	movs	r1, #192	; 0xc0
   13630:	4790      	blx	r2
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
   13632:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13634:	6223      	str	r3, [r4, #32]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13636:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13638:	4620      	mov	r0, r4
   1363a:	4790      	blx	r2
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
   1363c:	2301      	movs	r3, #1
   1363e:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
   13640:	4b31      	ldr	r3, [pc, #196]	; (13708 <_tc_timer_init+0x15c>)
   13642:	429c      	cmp	r4, r3
   13644:	d146      	bne.n	136d4 <_tc_timer_init+0x128>
		_tc0_dev = (struct _timer_device *)dev;
   13646:	4b31      	ldr	r3, [pc, #196]	; (1370c <_tc_timer_init+0x160>)
   13648:	601f      	str	r7, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
   1364a:	2314      	movs	r3, #20
   1364c:	fb03 9306 	mla	r3, r3, r6, r9
   13650:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13654:	2b00      	cmp	r3, #0
   13656:	db0d      	blt.n	13674 <_tc_timer_init+0xc8>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13658:	095a      	lsrs	r2, r3, #5
   1365a:	2101      	movs	r1, #1
   1365c:	f003 031f 	and.w	r3, r3, #31
   13660:	fa01 f303 	lsl.w	r3, r1, r3
   13664:	3220      	adds	r2, #32
   13666:	492a      	ldr	r1, [pc, #168]	; (13710 <_tc_timer_init+0x164>)
   13668:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1366c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13670:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
   13674:	2014      	movs	r0, #20
   13676:	fb00 9606 	mla	r6, r0, r6, r9
   1367a:	f9b6 3022 	ldrsh.w	r3, [r6, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   1367e:	2b00      	cmp	r3, #0
   13680:	db0c      	blt.n	1369c <_tc_timer_init+0xf0>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13682:	f003 011f 	and.w	r1, r3, #31
   13686:	095b      	lsrs	r3, r3, #5
   13688:	009b      	lsls	r3, r3, #2
   1368a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   1368e:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   13692:	2201      	movs	r2, #1
   13694:	408a      	lsls	r2, r1
   13696:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1369a:	601a      	str	r2, [r3, #0]
}
   1369c:	2000      	movs	r0, #0
   1369e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
   136a2:	b933      	cbnz	r3, 136b2 <_tc_timer_init+0x106>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
   136a4:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   136a6:	83a3      	strh	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   136a8:	21c0      	movs	r1, #192	; 0xc0
   136aa:	4790      	blx	r2
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
   136ac:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   136ae:	83e3      	strh	r3, [r4, #30]
   136b0:	e7c1      	b.n	13636 <_tc_timer_init+0x8a>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
   136b2:	2b04      	cmp	r3, #4
   136b4:	d1c2      	bne.n	1363c <_tc_timer_init+0x90>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
   136b6:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   136ba:	7723      	strb	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   136bc:	21c0      	movs	r1, #192	; 0xc0
   136be:	4790      	blx	r2
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
   136c0:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   136c4:	7763      	strb	r3, [r4, #29]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   136c6:	21c0      	movs	r1, #192	; 0xc0
   136c8:	4790      	blx	r2
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
   136ca:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
   136ce:	76e3      	strb	r3, [r4, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   136d0:	2120      	movs	r1, #32
   136d2:	e7b1      	b.n	13638 <_tc_timer_init+0x8c>
	if (hw == TC1) {
   136d4:	4b0f      	ldr	r3, [pc, #60]	; (13714 <_tc_timer_init+0x168>)
   136d6:	429c      	cmp	r4, r3
   136d8:	d008      	beq.n	136ec <_tc_timer_init+0x140>
	if (hw == TC2) {
   136da:	4b0f      	ldr	r3, [pc, #60]	; (13718 <_tc_timer_init+0x16c>)
   136dc:	429c      	cmp	r4, r3
   136de:	d008      	beq.n	136f2 <_tc_timer_init+0x146>
	if (hw == TC3) {
   136e0:	4b0e      	ldr	r3, [pc, #56]	; (1371c <_tc_timer_init+0x170>)
   136e2:	429c      	cmp	r4, r3
   136e4:	d1b1      	bne.n	1364a <_tc_timer_init+0x9e>
		_tc3_dev = (struct _timer_device *)dev;
   136e6:	4b09      	ldr	r3, [pc, #36]	; (1370c <_tc_timer_init+0x160>)
   136e8:	60df      	str	r7, [r3, #12]
   136ea:	e7ae      	b.n	1364a <_tc_timer_init+0x9e>
		_tc1_dev = (struct _timer_device *)dev;
   136ec:	4b07      	ldr	r3, [pc, #28]	; (1370c <_tc_timer_init+0x160>)
   136ee:	605f      	str	r7, [r3, #4]
	if (hw == TC3) {
   136f0:	e7ab      	b.n	1364a <_tc_timer_init+0x9e>
		_tc2_dev = (struct _timer_device *)dev;
   136f2:	4b06      	ldr	r3, [pc, #24]	; (1370c <_tc_timer_init+0x160>)
   136f4:	609f      	str	r7, [r3, #8]
	if (hw == TC3) {
   136f6:	e7a8      	b.n	1364a <_tc_timer_init+0x9e>
   136f8:	00013479 	.word	0x00013479
   136fc:	0000df45 	.word	0x0000df45
   13700:	000174e8 	.word	0x000174e8
   13704:	000133e5 	.word	0x000133e5
   13708:	40003800 	.word	0x40003800
   1370c:	20001b44 	.word	0x20001b44
   13710:	e000e100 	.word	0xe000e100
   13714:	40003c00 	.word	0x40003c00
   13718:	4101a000 	.word	0x4101a000
   1371c:	4101c000 	.word	0x4101c000
   13720:	000174fc 	.word	0x000174fc

00013724 <_tc_timer_set_period>:
	void *const hw = device->hw;
   13724:	68c0      	ldr	r0, [r0, #12]
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13726:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13728:	f3c3 0381 	ubfx	r3, r3, #2, #2
	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1372c:	2b02      	cmp	r3, #2
   1372e:	d103      	bne.n	13738 <_tc_timer_set_period+0x14>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13730:	61c1      	str	r1, [r0, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13732:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13734:	4b09      	ldr	r3, [pc, #36]	; (1375c <_tc_timer_set_period+0x38>)
   13736:	4718      	bx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13738:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1373a:	f013 0f0c 	tst.w	r3, #12
   1373e:	d102      	bne.n	13746 <_tc_timer_set_period+0x22>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)clock_cycles);
   13740:	b289      	uxth	r1, r1
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   13742:	8381      	strh	r1, [r0, #28]
   13744:	e7f5      	b.n	13732 <_tc_timer_set_period+0xe>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13746:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13748:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1374c:	2b01      	cmp	r3, #1
   1374e:	d103      	bne.n	13758 <_tc_timer_set_period+0x34>
		hri_tccount8_write_PER_reg(hw, clock_cycles);
   13750:	b2c9      	uxtb	r1, r1
	((Tc *)hw)->COUNT8.PER.reg = data;
   13752:	76c1      	strb	r1, [r0, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13754:	2120      	movs	r1, #32
   13756:	e7ed      	b.n	13734 <_tc_timer_set_period+0x10>
}
   13758:	4770      	bx	lr
   1375a:	bf00      	nop
   1375c:	000133e5 	.word	0x000133e5

00013760 <_tc_get_timer>:
}
   13760:	4800      	ldr	r0, [pc, #0]	; (13764 <_tc_get_timer+0x4>)
   13762:	4770      	bx	lr
   13764:	2000052c 	.word	0x2000052c

00013768 <TC0_Handler>:
	tc_interrupt_handler(_tc0_dev);
   13768:	4b01      	ldr	r3, [pc, #4]	; (13770 <TC0_Handler+0x8>)
   1376a:	6818      	ldr	r0, [r3, #0]
   1376c:	4b01      	ldr	r3, [pc, #4]	; (13774 <TC0_Handler+0xc>)
   1376e:	4718      	bx	r3
   13770:	20001b44 	.word	0x20001b44
   13774:	00013465 	.word	0x00013465

00013778 <TC1_Handler>:
	tc_interrupt_handler(_tc1_dev);
   13778:	4b01      	ldr	r3, [pc, #4]	; (13780 <TC1_Handler+0x8>)
   1377a:	6858      	ldr	r0, [r3, #4]
   1377c:	4b01      	ldr	r3, [pc, #4]	; (13784 <TC1_Handler+0xc>)
   1377e:	4718      	bx	r3
   13780:	20001b44 	.word	0x20001b44
   13784:	00013465 	.word	0x00013465

00013788 <TC2_Handler>:
	tc_interrupt_handler(_tc2_dev);
   13788:	4b01      	ldr	r3, [pc, #4]	; (13790 <TC2_Handler+0x8>)
   1378a:	6898      	ldr	r0, [r3, #8]
   1378c:	4b01      	ldr	r3, [pc, #4]	; (13794 <TC2_Handler+0xc>)
   1378e:	4718      	bx	r3
   13790:	20001b44 	.word	0x20001b44
   13794:	00013465 	.word	0x00013465

00013798 <TC3_Handler>:
	tc_interrupt_handler(_tc3_dev);
   13798:	4b01      	ldr	r3, [pc, #4]	; (137a0 <TC3_Handler+0x8>)
   1379a:	68d8      	ldr	r0, [r3, #12]
   1379c:	4b01      	ldr	r3, [pc, #4]	; (137a4 <TC3_Handler+0xc>)
   1379e:	4718      	bx	r3
   137a0:	20001b44 	.word	0x20001b44
   137a4:	00013465 	.word	0x00013465

000137a8 <_delay_init>:
   137a8:	4b03      	ldr	r3, [pc, #12]	; (137b8 <_delay_init+0x10>)
   137aa:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   137ae:	605a      	str	r2, [r3, #4]
   137b0:	2205      	movs	r2, #5
   137b2:	601a      	str	r2, [r3, #0]
   137b4:	4770      	bx	lr
   137b6:	bf00      	nop
   137b8:	e000e010 	.word	0xe000e010

000137bc <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
   137bc:	0e0b      	lsrs	r3, r1, #24
   137be:	4a0c      	ldr	r2, [pc, #48]	; (137f0 <_delay_cycles+0x34>)
{
   137c0:	b530      	push	{r4, r5, lr}
	uint8_t  n   = cycles >> 24;
   137c2:	4618      	mov	r0, r3
	uint32_t buf = cycles;

	while (n--) {
		SysTick->LOAD = 0xFFFFFF;
   137c4:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
	while (n--) {
   137c8:	3801      	subs	r0, #1
   137ca:	b2c0      	uxtb	r0, r0
   137cc:	28ff      	cmp	r0, #255	; 0xff
   137ce:	d108      	bne.n	137e2 <_delay_cycles+0x26>
   137d0:	eba3 6303 	sub.w	r3, r3, r3, lsl #24
   137d4:	4419      	add	r1, r3
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			;
		buf -= 0xFFFFFF;
	}

	SysTick->LOAD = buf;
   137d6:	6051      	str	r1, [r2, #4]
	SysTick->VAL  = buf;
   137d8:	6091      	str	r1, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   137da:	6813      	ldr	r3, [r2, #0]
   137dc:	03db      	lsls	r3, r3, #15
   137de:	d5fc      	bpl.n	137da <_delay_cycles+0x1e>
		;
}
   137e0:	bd30      	pop	{r4, r5, pc}
		SysTick->LOAD = 0xFFFFFF;
   137e2:	6054      	str	r4, [r2, #4]
		SysTick->VAL  = 0xFFFFFF;
   137e4:	6094      	str	r4, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   137e6:	6815      	ldr	r5, [r2, #0]
   137e8:	03ed      	lsls	r5, r5, #15
   137ea:	d5fc      	bpl.n	137e6 <_delay_cycles+0x2a>
   137ec:	e7ec      	b.n	137c8 <_delay_cycles+0xc>
   137ee:	bf00      	nop
   137f0:	e000e010 	.word	0xe000e010

000137f4 <_crc_sync_init>:
/**
 * \brief Initialize CRC.
 */
int32_t _crc_sync_init(struct _crc_sync_device *const device, void *const hw)
{
	device->hw = hw;
   137f4:	6001      	str	r1, [r0, #0]

	return ERR_NONE;
}
   137f6:	2000      	movs	r0, #0
   137f8:	4770      	bx	lr
	...

000137fc <__aeabi_drsub>:
   137fc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   13800:	e002      	b.n	13808 <__adddf3>
   13802:	bf00      	nop

00013804 <__aeabi_dsub>:
   13804:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00013808 <__adddf3>:
   13808:	b530      	push	{r4, r5, lr}
   1380a:	ea4f 0441 	mov.w	r4, r1, lsl #1
   1380e:	ea4f 0543 	mov.w	r5, r3, lsl #1
   13812:	ea94 0f05 	teq	r4, r5
   13816:	bf08      	it	eq
   13818:	ea90 0f02 	teqeq	r0, r2
   1381c:	bf1f      	itttt	ne
   1381e:	ea54 0c00 	orrsne.w	ip, r4, r0
   13822:	ea55 0c02 	orrsne.w	ip, r5, r2
   13826:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   1382a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   1382e:	f000 80e2 	beq.w	139f6 <__adddf3+0x1ee>
   13832:	ea4f 5454 	mov.w	r4, r4, lsr #21
   13836:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   1383a:	bfb8      	it	lt
   1383c:	426d      	neglt	r5, r5
   1383e:	dd0c      	ble.n	1385a <__adddf3+0x52>
   13840:	442c      	add	r4, r5
   13842:	ea80 0202 	eor.w	r2, r0, r2
   13846:	ea81 0303 	eor.w	r3, r1, r3
   1384a:	ea82 0000 	eor.w	r0, r2, r0
   1384e:	ea83 0101 	eor.w	r1, r3, r1
   13852:	ea80 0202 	eor.w	r2, r0, r2
   13856:	ea81 0303 	eor.w	r3, r1, r3
   1385a:	2d36      	cmp	r5, #54	; 0x36
   1385c:	bf88      	it	hi
   1385e:	bd30      	pophi	{r4, r5, pc}
   13860:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   13864:	ea4f 3101 	mov.w	r1, r1, lsl #12
   13868:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   1386c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   13870:	d002      	beq.n	13878 <__adddf3+0x70>
   13872:	4240      	negs	r0, r0
   13874:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13878:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   1387c:	ea4f 3303 	mov.w	r3, r3, lsl #12
   13880:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   13884:	d002      	beq.n	1388c <__adddf3+0x84>
   13886:	4252      	negs	r2, r2
   13888:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   1388c:	ea94 0f05 	teq	r4, r5
   13890:	f000 80a7 	beq.w	139e2 <__adddf3+0x1da>
   13894:	f1a4 0401 	sub.w	r4, r4, #1
   13898:	f1d5 0e20 	rsbs	lr, r5, #32
   1389c:	db0d      	blt.n	138ba <__adddf3+0xb2>
   1389e:	fa02 fc0e 	lsl.w	ip, r2, lr
   138a2:	fa22 f205 	lsr.w	r2, r2, r5
   138a6:	1880      	adds	r0, r0, r2
   138a8:	f141 0100 	adc.w	r1, r1, #0
   138ac:	fa03 f20e 	lsl.w	r2, r3, lr
   138b0:	1880      	adds	r0, r0, r2
   138b2:	fa43 f305 	asr.w	r3, r3, r5
   138b6:	4159      	adcs	r1, r3
   138b8:	e00e      	b.n	138d8 <__adddf3+0xd0>
   138ba:	f1a5 0520 	sub.w	r5, r5, #32
   138be:	f10e 0e20 	add.w	lr, lr, #32
   138c2:	2a01      	cmp	r2, #1
   138c4:	fa03 fc0e 	lsl.w	ip, r3, lr
   138c8:	bf28      	it	cs
   138ca:	f04c 0c02 	orrcs.w	ip, ip, #2
   138ce:	fa43 f305 	asr.w	r3, r3, r5
   138d2:	18c0      	adds	r0, r0, r3
   138d4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   138d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   138dc:	d507      	bpl.n	138ee <__adddf3+0xe6>
   138de:	f04f 0e00 	mov.w	lr, #0
   138e2:	f1dc 0c00 	rsbs	ip, ip, #0
   138e6:	eb7e 0000 	sbcs.w	r0, lr, r0
   138ea:	eb6e 0101 	sbc.w	r1, lr, r1
   138ee:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   138f2:	d31b      	bcc.n	1392c <__adddf3+0x124>
   138f4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   138f8:	d30c      	bcc.n	13914 <__adddf3+0x10c>
   138fa:	0849      	lsrs	r1, r1, #1
   138fc:	ea5f 0030 	movs.w	r0, r0, rrx
   13900:	ea4f 0c3c 	mov.w	ip, ip, rrx
   13904:	f104 0401 	add.w	r4, r4, #1
   13908:	ea4f 5244 	mov.w	r2, r4, lsl #21
   1390c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   13910:	f080 809a 	bcs.w	13a48 <__adddf3+0x240>
   13914:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   13918:	bf08      	it	eq
   1391a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1391e:	f150 0000 	adcs.w	r0, r0, #0
   13922:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13926:	ea41 0105 	orr.w	r1, r1, r5
   1392a:	bd30      	pop	{r4, r5, pc}
   1392c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   13930:	4140      	adcs	r0, r0
   13932:	eb41 0101 	adc.w	r1, r1, r1
   13936:	3c01      	subs	r4, #1
   13938:	bf28      	it	cs
   1393a:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   1393e:	d2e9      	bcs.n	13914 <__adddf3+0x10c>
   13940:	f091 0f00 	teq	r1, #0
   13944:	bf04      	itt	eq
   13946:	4601      	moveq	r1, r0
   13948:	2000      	moveq	r0, #0
   1394a:	fab1 f381 	clz	r3, r1
   1394e:	bf08      	it	eq
   13950:	3320      	addeq	r3, #32
   13952:	f1a3 030b 	sub.w	r3, r3, #11
   13956:	f1b3 0220 	subs.w	r2, r3, #32
   1395a:	da0c      	bge.n	13976 <__adddf3+0x16e>
   1395c:	320c      	adds	r2, #12
   1395e:	dd08      	ble.n	13972 <__adddf3+0x16a>
   13960:	f102 0c14 	add.w	ip, r2, #20
   13964:	f1c2 020c 	rsb	r2, r2, #12
   13968:	fa01 f00c 	lsl.w	r0, r1, ip
   1396c:	fa21 f102 	lsr.w	r1, r1, r2
   13970:	e00c      	b.n	1398c <__adddf3+0x184>
   13972:	f102 0214 	add.w	r2, r2, #20
   13976:	bfd8      	it	le
   13978:	f1c2 0c20 	rsble	ip, r2, #32
   1397c:	fa01 f102 	lsl.w	r1, r1, r2
   13980:	fa20 fc0c 	lsr.w	ip, r0, ip
   13984:	bfdc      	itt	le
   13986:	ea41 010c 	orrle.w	r1, r1, ip
   1398a:	4090      	lslle	r0, r2
   1398c:	1ae4      	subs	r4, r4, r3
   1398e:	bfa2      	ittt	ge
   13990:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   13994:	4329      	orrge	r1, r5
   13996:	bd30      	popge	{r4, r5, pc}
   13998:	ea6f 0404 	mvn.w	r4, r4
   1399c:	3c1f      	subs	r4, #31
   1399e:	da1c      	bge.n	139da <__adddf3+0x1d2>
   139a0:	340c      	adds	r4, #12
   139a2:	dc0e      	bgt.n	139c2 <__adddf3+0x1ba>
   139a4:	f104 0414 	add.w	r4, r4, #20
   139a8:	f1c4 0220 	rsb	r2, r4, #32
   139ac:	fa20 f004 	lsr.w	r0, r0, r4
   139b0:	fa01 f302 	lsl.w	r3, r1, r2
   139b4:	ea40 0003 	orr.w	r0, r0, r3
   139b8:	fa21 f304 	lsr.w	r3, r1, r4
   139bc:	ea45 0103 	orr.w	r1, r5, r3
   139c0:	bd30      	pop	{r4, r5, pc}
   139c2:	f1c4 040c 	rsb	r4, r4, #12
   139c6:	f1c4 0220 	rsb	r2, r4, #32
   139ca:	fa20 f002 	lsr.w	r0, r0, r2
   139ce:	fa01 f304 	lsl.w	r3, r1, r4
   139d2:	ea40 0003 	orr.w	r0, r0, r3
   139d6:	4629      	mov	r1, r5
   139d8:	bd30      	pop	{r4, r5, pc}
   139da:	fa21 f004 	lsr.w	r0, r1, r4
   139de:	4629      	mov	r1, r5
   139e0:	bd30      	pop	{r4, r5, pc}
   139e2:	f094 0f00 	teq	r4, #0
   139e6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   139ea:	bf06      	itte	eq
   139ec:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   139f0:	3401      	addeq	r4, #1
   139f2:	3d01      	subne	r5, #1
   139f4:	e74e      	b.n	13894 <__adddf3+0x8c>
   139f6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   139fa:	bf18      	it	ne
   139fc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   13a00:	d029      	beq.n	13a56 <__adddf3+0x24e>
   13a02:	ea94 0f05 	teq	r4, r5
   13a06:	bf08      	it	eq
   13a08:	ea90 0f02 	teqeq	r0, r2
   13a0c:	d005      	beq.n	13a1a <__adddf3+0x212>
   13a0e:	ea54 0c00 	orrs.w	ip, r4, r0
   13a12:	bf04      	itt	eq
   13a14:	4619      	moveq	r1, r3
   13a16:	4610      	moveq	r0, r2
   13a18:	bd30      	pop	{r4, r5, pc}
   13a1a:	ea91 0f03 	teq	r1, r3
   13a1e:	bf1e      	ittt	ne
   13a20:	2100      	movne	r1, #0
   13a22:	2000      	movne	r0, #0
   13a24:	bd30      	popne	{r4, r5, pc}
   13a26:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   13a2a:	d105      	bne.n	13a38 <__adddf3+0x230>
   13a2c:	0040      	lsls	r0, r0, #1
   13a2e:	4149      	adcs	r1, r1
   13a30:	bf28      	it	cs
   13a32:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   13a36:	bd30      	pop	{r4, r5, pc}
   13a38:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   13a3c:	bf3c      	itt	cc
   13a3e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   13a42:	bd30      	popcc	{r4, r5, pc}
   13a44:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13a48:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   13a4c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   13a50:	f04f 0000 	mov.w	r0, #0
   13a54:	bd30      	pop	{r4, r5, pc}
   13a56:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   13a5a:	bf1a      	itte	ne
   13a5c:	4619      	movne	r1, r3
   13a5e:	4610      	movne	r0, r2
   13a60:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   13a64:	bf1c      	itt	ne
   13a66:	460b      	movne	r3, r1
   13a68:	4602      	movne	r2, r0
   13a6a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   13a6e:	bf06      	itte	eq
   13a70:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   13a74:	ea91 0f03 	teqeq	r1, r3
   13a78:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   13a7c:	bd30      	pop	{r4, r5, pc}
   13a7e:	bf00      	nop

00013a80 <__aeabi_ui2d>:
   13a80:	f090 0f00 	teq	r0, #0
   13a84:	bf04      	itt	eq
   13a86:	2100      	moveq	r1, #0
   13a88:	4770      	bxeq	lr
   13a8a:	b530      	push	{r4, r5, lr}
   13a8c:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13a90:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13a94:	f04f 0500 	mov.w	r5, #0
   13a98:	f04f 0100 	mov.w	r1, #0
   13a9c:	e750      	b.n	13940 <__adddf3+0x138>
   13a9e:	bf00      	nop

00013aa0 <__aeabi_i2d>:
   13aa0:	f090 0f00 	teq	r0, #0
   13aa4:	bf04      	itt	eq
   13aa6:	2100      	moveq	r1, #0
   13aa8:	4770      	bxeq	lr
   13aaa:	b530      	push	{r4, r5, lr}
   13aac:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13ab0:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13ab4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   13ab8:	bf48      	it	mi
   13aba:	4240      	negmi	r0, r0
   13abc:	f04f 0100 	mov.w	r1, #0
   13ac0:	e73e      	b.n	13940 <__adddf3+0x138>
   13ac2:	bf00      	nop

00013ac4 <__aeabi_f2d>:
   13ac4:	0042      	lsls	r2, r0, #1
   13ac6:	ea4f 01e2 	mov.w	r1, r2, asr #3
   13aca:	ea4f 0131 	mov.w	r1, r1, rrx
   13ace:	ea4f 7002 	mov.w	r0, r2, lsl #28
   13ad2:	bf1f      	itttt	ne
   13ad4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   13ad8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   13adc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   13ae0:	4770      	bxne	lr
   13ae2:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   13ae6:	bf08      	it	eq
   13ae8:	4770      	bxeq	lr
   13aea:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   13aee:	bf04      	itt	eq
   13af0:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   13af4:	4770      	bxeq	lr
   13af6:	b530      	push	{r4, r5, lr}
   13af8:	f44f 7460 	mov.w	r4, #896	; 0x380
   13afc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   13b00:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   13b04:	e71c      	b.n	13940 <__adddf3+0x138>
   13b06:	bf00      	nop

00013b08 <__aeabi_ul2d>:
   13b08:	ea50 0201 	orrs.w	r2, r0, r1
   13b0c:	bf08      	it	eq
   13b0e:	4770      	bxeq	lr
   13b10:	b530      	push	{r4, r5, lr}
   13b12:	f04f 0500 	mov.w	r5, #0
   13b16:	e00a      	b.n	13b2e <__aeabi_l2d+0x16>

00013b18 <__aeabi_l2d>:
   13b18:	ea50 0201 	orrs.w	r2, r0, r1
   13b1c:	bf08      	it	eq
   13b1e:	4770      	bxeq	lr
   13b20:	b530      	push	{r4, r5, lr}
   13b22:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   13b26:	d502      	bpl.n	13b2e <__aeabi_l2d+0x16>
   13b28:	4240      	negs	r0, r0
   13b2a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13b2e:	f44f 6480 	mov.w	r4, #1024	; 0x400
   13b32:	f104 0432 	add.w	r4, r4, #50	; 0x32
   13b36:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   13b3a:	f43f aed8 	beq.w	138ee <__adddf3+0xe6>
   13b3e:	f04f 0203 	mov.w	r2, #3
   13b42:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   13b46:	bf18      	it	ne
   13b48:	3203      	addne	r2, #3
   13b4a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   13b4e:	bf18      	it	ne
   13b50:	3203      	addne	r2, #3
   13b52:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   13b56:	f1c2 0320 	rsb	r3, r2, #32
   13b5a:	fa00 fc03 	lsl.w	ip, r0, r3
   13b5e:	fa20 f002 	lsr.w	r0, r0, r2
   13b62:	fa01 fe03 	lsl.w	lr, r1, r3
   13b66:	ea40 000e 	orr.w	r0, r0, lr
   13b6a:	fa21 f102 	lsr.w	r1, r1, r2
   13b6e:	4414      	add	r4, r2
   13b70:	e6bd      	b.n	138ee <__adddf3+0xe6>
   13b72:	bf00      	nop

00013b74 <__aeabi_dmul>:
   13b74:	b570      	push	{r4, r5, r6, lr}
   13b76:	f04f 0cff 	mov.w	ip, #255	; 0xff
   13b7a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   13b7e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   13b82:	bf1d      	ittte	ne
   13b84:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   13b88:	ea94 0f0c 	teqne	r4, ip
   13b8c:	ea95 0f0c 	teqne	r5, ip
   13b90:	f000 f8de 	bleq	13d50 <__aeabi_dmul+0x1dc>
   13b94:	442c      	add	r4, r5
   13b96:	ea81 0603 	eor.w	r6, r1, r3
   13b9a:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   13b9e:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   13ba2:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   13ba6:	bf18      	it	ne
   13ba8:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   13bac:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13bb0:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   13bb4:	d038      	beq.n	13c28 <__aeabi_dmul+0xb4>
   13bb6:	fba0 ce02 	umull	ip, lr, r0, r2
   13bba:	f04f 0500 	mov.w	r5, #0
   13bbe:	fbe1 e502 	umlal	lr, r5, r1, r2
   13bc2:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   13bc6:	fbe0 e503 	umlal	lr, r5, r0, r3
   13bca:	f04f 0600 	mov.w	r6, #0
   13bce:	fbe1 5603 	umlal	r5, r6, r1, r3
   13bd2:	f09c 0f00 	teq	ip, #0
   13bd6:	bf18      	it	ne
   13bd8:	f04e 0e01 	orrne.w	lr, lr, #1
   13bdc:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   13be0:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   13be4:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   13be8:	d204      	bcs.n	13bf4 <__aeabi_dmul+0x80>
   13bea:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   13bee:	416d      	adcs	r5, r5
   13bf0:	eb46 0606 	adc.w	r6, r6, r6
   13bf4:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   13bf8:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   13bfc:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   13c00:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   13c04:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   13c08:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   13c0c:	bf88      	it	hi
   13c0e:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   13c12:	d81e      	bhi.n	13c52 <__aeabi_dmul+0xde>
   13c14:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   13c18:	bf08      	it	eq
   13c1a:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   13c1e:	f150 0000 	adcs.w	r0, r0, #0
   13c22:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13c26:	bd70      	pop	{r4, r5, r6, pc}
   13c28:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   13c2c:	ea46 0101 	orr.w	r1, r6, r1
   13c30:	ea40 0002 	orr.w	r0, r0, r2
   13c34:	ea81 0103 	eor.w	r1, r1, r3
   13c38:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   13c3c:	bfc2      	ittt	gt
   13c3e:	ebd4 050c 	rsbsgt	r5, r4, ip
   13c42:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   13c46:	bd70      	popgt	{r4, r5, r6, pc}
   13c48:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13c4c:	f04f 0e00 	mov.w	lr, #0
   13c50:	3c01      	subs	r4, #1
   13c52:	f300 80ab 	bgt.w	13dac <__aeabi_dmul+0x238>
   13c56:	f114 0f36 	cmn.w	r4, #54	; 0x36
   13c5a:	bfde      	ittt	le
   13c5c:	2000      	movle	r0, #0
   13c5e:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   13c62:	bd70      	pople	{r4, r5, r6, pc}
   13c64:	f1c4 0400 	rsb	r4, r4, #0
   13c68:	3c20      	subs	r4, #32
   13c6a:	da35      	bge.n	13cd8 <__aeabi_dmul+0x164>
   13c6c:	340c      	adds	r4, #12
   13c6e:	dc1b      	bgt.n	13ca8 <__aeabi_dmul+0x134>
   13c70:	f104 0414 	add.w	r4, r4, #20
   13c74:	f1c4 0520 	rsb	r5, r4, #32
   13c78:	fa00 f305 	lsl.w	r3, r0, r5
   13c7c:	fa20 f004 	lsr.w	r0, r0, r4
   13c80:	fa01 f205 	lsl.w	r2, r1, r5
   13c84:	ea40 0002 	orr.w	r0, r0, r2
   13c88:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   13c8c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   13c90:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   13c94:	fa21 f604 	lsr.w	r6, r1, r4
   13c98:	eb42 0106 	adc.w	r1, r2, r6
   13c9c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13ca0:	bf08      	it	eq
   13ca2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13ca6:	bd70      	pop	{r4, r5, r6, pc}
   13ca8:	f1c4 040c 	rsb	r4, r4, #12
   13cac:	f1c4 0520 	rsb	r5, r4, #32
   13cb0:	fa00 f304 	lsl.w	r3, r0, r4
   13cb4:	fa20 f005 	lsr.w	r0, r0, r5
   13cb8:	fa01 f204 	lsl.w	r2, r1, r4
   13cbc:	ea40 0002 	orr.w	r0, r0, r2
   13cc0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13cc4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   13cc8:	f141 0100 	adc.w	r1, r1, #0
   13ccc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13cd0:	bf08      	it	eq
   13cd2:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13cd6:	bd70      	pop	{r4, r5, r6, pc}
   13cd8:	f1c4 0520 	rsb	r5, r4, #32
   13cdc:	fa00 f205 	lsl.w	r2, r0, r5
   13ce0:	ea4e 0e02 	orr.w	lr, lr, r2
   13ce4:	fa20 f304 	lsr.w	r3, r0, r4
   13ce8:	fa01 f205 	lsl.w	r2, r1, r5
   13cec:	ea43 0302 	orr.w	r3, r3, r2
   13cf0:	fa21 f004 	lsr.w	r0, r1, r4
   13cf4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13cf8:	fa21 f204 	lsr.w	r2, r1, r4
   13cfc:	ea20 0002 	bic.w	r0, r0, r2
   13d00:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   13d04:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   13d08:	bf08      	it	eq
   13d0a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   13d0e:	bd70      	pop	{r4, r5, r6, pc}
   13d10:	f094 0f00 	teq	r4, #0
   13d14:	d10f      	bne.n	13d36 <__aeabi_dmul+0x1c2>
   13d16:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   13d1a:	0040      	lsls	r0, r0, #1
   13d1c:	eb41 0101 	adc.w	r1, r1, r1
   13d20:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   13d24:	bf08      	it	eq
   13d26:	3c01      	subeq	r4, #1
   13d28:	d0f7      	beq.n	13d1a <__aeabi_dmul+0x1a6>
   13d2a:	ea41 0106 	orr.w	r1, r1, r6
   13d2e:	f095 0f00 	teq	r5, #0
   13d32:	bf18      	it	ne
   13d34:	4770      	bxne	lr
   13d36:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   13d3a:	0052      	lsls	r2, r2, #1
   13d3c:	eb43 0303 	adc.w	r3, r3, r3
   13d40:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   13d44:	bf08      	it	eq
   13d46:	3d01      	subeq	r5, #1
   13d48:	d0f7      	beq.n	13d3a <__aeabi_dmul+0x1c6>
   13d4a:	ea43 0306 	orr.w	r3, r3, r6
   13d4e:	4770      	bx	lr
   13d50:	ea94 0f0c 	teq	r4, ip
   13d54:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   13d58:	bf18      	it	ne
   13d5a:	ea95 0f0c 	teqne	r5, ip
   13d5e:	d00c      	beq.n	13d7a <__aeabi_dmul+0x206>
   13d60:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   13d64:	bf18      	it	ne
   13d66:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   13d6a:	d1d1      	bne.n	13d10 <__aeabi_dmul+0x19c>
   13d6c:	ea81 0103 	eor.w	r1, r1, r3
   13d70:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13d74:	f04f 0000 	mov.w	r0, #0
   13d78:	bd70      	pop	{r4, r5, r6, pc}
   13d7a:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   13d7e:	bf06      	itte	eq
   13d80:	4610      	moveq	r0, r2
   13d82:	4619      	moveq	r1, r3
   13d84:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   13d88:	d019      	beq.n	13dbe <__aeabi_dmul+0x24a>
   13d8a:	ea94 0f0c 	teq	r4, ip
   13d8e:	d102      	bne.n	13d96 <__aeabi_dmul+0x222>
   13d90:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   13d94:	d113      	bne.n	13dbe <__aeabi_dmul+0x24a>
   13d96:	ea95 0f0c 	teq	r5, ip
   13d9a:	d105      	bne.n	13da8 <__aeabi_dmul+0x234>
   13d9c:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   13da0:	bf1c      	itt	ne
   13da2:	4610      	movne	r0, r2
   13da4:	4619      	movne	r1, r3
   13da6:	d10a      	bne.n	13dbe <__aeabi_dmul+0x24a>
   13da8:	ea81 0103 	eor.w	r1, r1, r3
   13dac:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   13db0:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   13db4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   13db8:	f04f 0000 	mov.w	r0, #0
   13dbc:	bd70      	pop	{r4, r5, r6, pc}
   13dbe:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   13dc2:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   13dc6:	bd70      	pop	{r4, r5, r6, pc}

00013dc8 <__aeabi_ddiv>:
   13dc8:	b570      	push	{r4, r5, r6, lr}
   13dca:	f04f 0cff 	mov.w	ip, #255	; 0xff
   13dce:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   13dd2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   13dd6:	bf1d      	ittte	ne
   13dd8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   13ddc:	ea94 0f0c 	teqne	r4, ip
   13de0:	ea95 0f0c 	teqne	r5, ip
   13de4:	f000 f8a7 	bleq	13f36 <__aeabi_ddiv+0x16e>
   13de8:	eba4 0405 	sub.w	r4, r4, r5
   13dec:	ea81 0e03 	eor.w	lr, r1, r3
   13df0:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   13df4:	ea4f 3101 	mov.w	r1, r1, lsl #12
   13df8:	f000 8088 	beq.w	13f0c <__aeabi_ddiv+0x144>
   13dfc:	ea4f 3303 	mov.w	r3, r3, lsl #12
   13e00:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   13e04:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   13e08:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   13e0c:	ea4f 2202 	mov.w	r2, r2, lsl #8
   13e10:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   13e14:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   13e18:	ea4f 2600 	mov.w	r6, r0, lsl #8
   13e1c:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   13e20:	429d      	cmp	r5, r3
   13e22:	bf08      	it	eq
   13e24:	4296      	cmpeq	r6, r2
   13e26:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   13e2a:	f504 7440 	add.w	r4, r4, #768	; 0x300
   13e2e:	d202      	bcs.n	13e36 <__aeabi_ddiv+0x6e>
   13e30:	085b      	lsrs	r3, r3, #1
   13e32:	ea4f 0232 	mov.w	r2, r2, rrx
   13e36:	1ab6      	subs	r6, r6, r2
   13e38:	eb65 0503 	sbc.w	r5, r5, r3
   13e3c:	085b      	lsrs	r3, r3, #1
   13e3e:	ea4f 0232 	mov.w	r2, r2, rrx
   13e42:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   13e46:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   13e4a:	ebb6 0e02 	subs.w	lr, r6, r2
   13e4e:	eb75 0e03 	sbcs.w	lr, r5, r3
   13e52:	bf22      	ittt	cs
   13e54:	1ab6      	subcs	r6, r6, r2
   13e56:	4675      	movcs	r5, lr
   13e58:	ea40 000c 	orrcs.w	r0, r0, ip
   13e5c:	085b      	lsrs	r3, r3, #1
   13e5e:	ea4f 0232 	mov.w	r2, r2, rrx
   13e62:	ebb6 0e02 	subs.w	lr, r6, r2
   13e66:	eb75 0e03 	sbcs.w	lr, r5, r3
   13e6a:	bf22      	ittt	cs
   13e6c:	1ab6      	subcs	r6, r6, r2
   13e6e:	4675      	movcs	r5, lr
   13e70:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   13e74:	085b      	lsrs	r3, r3, #1
   13e76:	ea4f 0232 	mov.w	r2, r2, rrx
   13e7a:	ebb6 0e02 	subs.w	lr, r6, r2
   13e7e:	eb75 0e03 	sbcs.w	lr, r5, r3
   13e82:	bf22      	ittt	cs
   13e84:	1ab6      	subcs	r6, r6, r2
   13e86:	4675      	movcs	r5, lr
   13e88:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   13e8c:	085b      	lsrs	r3, r3, #1
   13e8e:	ea4f 0232 	mov.w	r2, r2, rrx
   13e92:	ebb6 0e02 	subs.w	lr, r6, r2
   13e96:	eb75 0e03 	sbcs.w	lr, r5, r3
   13e9a:	bf22      	ittt	cs
   13e9c:	1ab6      	subcs	r6, r6, r2
   13e9e:	4675      	movcs	r5, lr
   13ea0:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   13ea4:	ea55 0e06 	orrs.w	lr, r5, r6
   13ea8:	d018      	beq.n	13edc <__aeabi_ddiv+0x114>
   13eaa:	ea4f 1505 	mov.w	r5, r5, lsl #4
   13eae:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   13eb2:	ea4f 1606 	mov.w	r6, r6, lsl #4
   13eb6:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   13eba:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   13ebe:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   13ec2:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   13ec6:	d1c0      	bne.n	13e4a <__aeabi_ddiv+0x82>
   13ec8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   13ecc:	d10b      	bne.n	13ee6 <__aeabi_ddiv+0x11e>
   13ece:	ea41 0100 	orr.w	r1, r1, r0
   13ed2:	f04f 0000 	mov.w	r0, #0
   13ed6:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   13eda:	e7b6      	b.n	13e4a <__aeabi_ddiv+0x82>
   13edc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   13ee0:	bf04      	itt	eq
   13ee2:	4301      	orreq	r1, r0
   13ee4:	2000      	moveq	r0, #0
   13ee6:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   13eea:	bf88      	it	hi
   13eec:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   13ef0:	f63f aeaf 	bhi.w	13c52 <__aeabi_dmul+0xde>
   13ef4:	ebb5 0c03 	subs.w	ip, r5, r3
   13ef8:	bf04      	itt	eq
   13efa:	ebb6 0c02 	subseq.w	ip, r6, r2
   13efe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   13f02:	f150 0000 	adcs.w	r0, r0, #0
   13f06:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   13f0a:	bd70      	pop	{r4, r5, r6, pc}
   13f0c:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   13f10:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   13f14:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   13f18:	bfc2      	ittt	gt
   13f1a:	ebd4 050c 	rsbsgt	r5, r4, ip
   13f1e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   13f22:	bd70      	popgt	{r4, r5, r6, pc}
   13f24:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   13f28:	f04f 0e00 	mov.w	lr, #0
   13f2c:	3c01      	subs	r4, #1
   13f2e:	e690      	b.n	13c52 <__aeabi_dmul+0xde>
   13f30:	ea45 0e06 	orr.w	lr, r5, r6
   13f34:	e68d      	b.n	13c52 <__aeabi_dmul+0xde>
   13f36:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   13f3a:	ea94 0f0c 	teq	r4, ip
   13f3e:	bf08      	it	eq
   13f40:	ea95 0f0c 	teqeq	r5, ip
   13f44:	f43f af3b 	beq.w	13dbe <__aeabi_dmul+0x24a>
   13f48:	ea94 0f0c 	teq	r4, ip
   13f4c:	d10a      	bne.n	13f64 <__aeabi_ddiv+0x19c>
   13f4e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   13f52:	f47f af34 	bne.w	13dbe <__aeabi_dmul+0x24a>
   13f56:	ea95 0f0c 	teq	r5, ip
   13f5a:	f47f af25 	bne.w	13da8 <__aeabi_dmul+0x234>
   13f5e:	4610      	mov	r0, r2
   13f60:	4619      	mov	r1, r3
   13f62:	e72c      	b.n	13dbe <__aeabi_dmul+0x24a>
   13f64:	ea95 0f0c 	teq	r5, ip
   13f68:	d106      	bne.n	13f78 <__aeabi_ddiv+0x1b0>
   13f6a:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   13f6e:	f43f aefd 	beq.w	13d6c <__aeabi_dmul+0x1f8>
   13f72:	4610      	mov	r0, r2
   13f74:	4619      	mov	r1, r3
   13f76:	e722      	b.n	13dbe <__aeabi_dmul+0x24a>
   13f78:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   13f7c:	bf18      	it	ne
   13f7e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   13f82:	f47f aec5 	bne.w	13d10 <__aeabi_dmul+0x19c>
   13f86:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   13f8a:	f47f af0d 	bne.w	13da8 <__aeabi_dmul+0x234>
   13f8e:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   13f92:	f47f aeeb 	bne.w	13d6c <__aeabi_dmul+0x1f8>
   13f96:	e712      	b.n	13dbe <__aeabi_dmul+0x24a>

00013f98 <__aeabi_d2uiz>:
   13f98:	004a      	lsls	r2, r1, #1
   13f9a:	d211      	bcs.n	13fc0 <__aeabi_d2uiz+0x28>
   13f9c:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   13fa0:	d211      	bcs.n	13fc6 <__aeabi_d2uiz+0x2e>
   13fa2:	d50d      	bpl.n	13fc0 <__aeabi_d2uiz+0x28>
   13fa4:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   13fa8:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   13fac:	d40e      	bmi.n	13fcc <__aeabi_d2uiz+0x34>
   13fae:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   13fb2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   13fb6:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   13fba:	fa23 f002 	lsr.w	r0, r3, r2
   13fbe:	4770      	bx	lr
   13fc0:	f04f 0000 	mov.w	r0, #0
   13fc4:	4770      	bx	lr
   13fc6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   13fca:	d102      	bne.n	13fd2 <__aeabi_d2uiz+0x3a>
   13fcc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13fd0:	4770      	bx	lr
   13fd2:	f04f 0000 	mov.w	r0, #0
   13fd6:	4770      	bx	lr

00013fd8 <__libc_init_array>:
   13fd8:	b570      	push	{r4, r5, r6, lr}
   13fda:	4e0d      	ldr	r6, [pc, #52]	; (14010 <__libc_init_array+0x38>)
   13fdc:	4d0d      	ldr	r5, [pc, #52]	; (14014 <__libc_init_array+0x3c>)
   13fde:	1b76      	subs	r6, r6, r5
   13fe0:	10b6      	asrs	r6, r6, #2
   13fe2:	d006      	beq.n	13ff2 <__libc_init_array+0x1a>
   13fe4:	2400      	movs	r4, #0
   13fe6:	3401      	adds	r4, #1
   13fe8:	f855 3b04 	ldr.w	r3, [r5], #4
   13fec:	4798      	blx	r3
   13fee:	42a6      	cmp	r6, r4
   13ff0:	d1f9      	bne.n	13fe6 <__libc_init_array+0xe>
   13ff2:	4e09      	ldr	r6, [pc, #36]	; (14018 <__libc_init_array+0x40>)
   13ff4:	4d09      	ldr	r5, [pc, #36]	; (1401c <__libc_init_array+0x44>)
   13ff6:	1b76      	subs	r6, r6, r5
   13ff8:	f003 fb08 	bl	1760c <_init>
   13ffc:	10b6      	asrs	r6, r6, #2
   13ffe:	d006      	beq.n	1400e <__libc_init_array+0x36>
   14000:	2400      	movs	r4, #0
   14002:	3401      	adds	r4, #1
   14004:	f855 3b04 	ldr.w	r3, [r5], #4
   14008:	4798      	blx	r3
   1400a:	42a6      	cmp	r6, r4
   1400c:	d1f9      	bne.n	14002 <__libc_init_array+0x2a>
   1400e:	bd70      	pop	{r4, r5, r6, pc}
   14010:	00017618 	.word	0x00017618
   14014:	00017618 	.word	0x00017618
   14018:	0001761c 	.word	0x0001761c
   1401c:	00017618 	.word	0x00017618

00014020 <malloc>:
   14020:	4b02      	ldr	r3, [pc, #8]	; (1402c <malloc+0xc>)
   14022:	4601      	mov	r1, r0
   14024:	6818      	ldr	r0, [r3, #0]
   14026:	f000 b94b 	b.w	142c0 <_malloc_r>
   1402a:	bf00      	nop
   1402c:	2000054c 	.word	0x2000054c

00014030 <free>:
   14030:	4b02      	ldr	r3, [pc, #8]	; (1403c <free+0xc>)
   14032:	4601      	mov	r1, r0
   14034:	6818      	ldr	r0, [r3, #0]
   14036:	f000 b8ed 	b.w	14214 <_free_r>
   1403a:	bf00      	nop
   1403c:	2000054c 	.word	0x2000054c

00014040 <memcpy>:
   14040:	4684      	mov	ip, r0
   14042:	ea41 0300 	orr.w	r3, r1, r0
   14046:	f013 0303 	ands.w	r3, r3, #3
   1404a:	d16d      	bne.n	14128 <memcpy+0xe8>
   1404c:	3a40      	subs	r2, #64	; 0x40
   1404e:	d341      	bcc.n	140d4 <memcpy+0x94>
   14050:	f851 3b04 	ldr.w	r3, [r1], #4
   14054:	f840 3b04 	str.w	r3, [r0], #4
   14058:	f851 3b04 	ldr.w	r3, [r1], #4
   1405c:	f840 3b04 	str.w	r3, [r0], #4
   14060:	f851 3b04 	ldr.w	r3, [r1], #4
   14064:	f840 3b04 	str.w	r3, [r0], #4
   14068:	f851 3b04 	ldr.w	r3, [r1], #4
   1406c:	f840 3b04 	str.w	r3, [r0], #4
   14070:	f851 3b04 	ldr.w	r3, [r1], #4
   14074:	f840 3b04 	str.w	r3, [r0], #4
   14078:	f851 3b04 	ldr.w	r3, [r1], #4
   1407c:	f840 3b04 	str.w	r3, [r0], #4
   14080:	f851 3b04 	ldr.w	r3, [r1], #4
   14084:	f840 3b04 	str.w	r3, [r0], #4
   14088:	f851 3b04 	ldr.w	r3, [r1], #4
   1408c:	f840 3b04 	str.w	r3, [r0], #4
   14090:	f851 3b04 	ldr.w	r3, [r1], #4
   14094:	f840 3b04 	str.w	r3, [r0], #4
   14098:	f851 3b04 	ldr.w	r3, [r1], #4
   1409c:	f840 3b04 	str.w	r3, [r0], #4
   140a0:	f851 3b04 	ldr.w	r3, [r1], #4
   140a4:	f840 3b04 	str.w	r3, [r0], #4
   140a8:	f851 3b04 	ldr.w	r3, [r1], #4
   140ac:	f840 3b04 	str.w	r3, [r0], #4
   140b0:	f851 3b04 	ldr.w	r3, [r1], #4
   140b4:	f840 3b04 	str.w	r3, [r0], #4
   140b8:	f851 3b04 	ldr.w	r3, [r1], #4
   140bc:	f840 3b04 	str.w	r3, [r0], #4
   140c0:	f851 3b04 	ldr.w	r3, [r1], #4
   140c4:	f840 3b04 	str.w	r3, [r0], #4
   140c8:	f851 3b04 	ldr.w	r3, [r1], #4
   140cc:	f840 3b04 	str.w	r3, [r0], #4
   140d0:	3a40      	subs	r2, #64	; 0x40
   140d2:	d2bd      	bcs.n	14050 <memcpy+0x10>
   140d4:	3230      	adds	r2, #48	; 0x30
   140d6:	d311      	bcc.n	140fc <memcpy+0xbc>
   140d8:	f851 3b04 	ldr.w	r3, [r1], #4
   140dc:	f840 3b04 	str.w	r3, [r0], #4
   140e0:	f851 3b04 	ldr.w	r3, [r1], #4
   140e4:	f840 3b04 	str.w	r3, [r0], #4
   140e8:	f851 3b04 	ldr.w	r3, [r1], #4
   140ec:	f840 3b04 	str.w	r3, [r0], #4
   140f0:	f851 3b04 	ldr.w	r3, [r1], #4
   140f4:	f840 3b04 	str.w	r3, [r0], #4
   140f8:	3a10      	subs	r2, #16
   140fa:	d2ed      	bcs.n	140d8 <memcpy+0x98>
   140fc:	320c      	adds	r2, #12
   140fe:	d305      	bcc.n	1410c <memcpy+0xcc>
   14100:	f851 3b04 	ldr.w	r3, [r1], #4
   14104:	f840 3b04 	str.w	r3, [r0], #4
   14108:	3a04      	subs	r2, #4
   1410a:	d2f9      	bcs.n	14100 <memcpy+0xc0>
   1410c:	3204      	adds	r2, #4
   1410e:	d008      	beq.n	14122 <memcpy+0xe2>
   14110:	07d2      	lsls	r2, r2, #31
   14112:	bf1c      	itt	ne
   14114:	f811 3b01 	ldrbne.w	r3, [r1], #1
   14118:	f800 3b01 	strbne.w	r3, [r0], #1
   1411c:	d301      	bcc.n	14122 <memcpy+0xe2>
   1411e:	880b      	ldrh	r3, [r1, #0]
   14120:	8003      	strh	r3, [r0, #0]
   14122:	4660      	mov	r0, ip
   14124:	4770      	bx	lr
   14126:	bf00      	nop
   14128:	2a08      	cmp	r2, #8
   1412a:	d313      	bcc.n	14154 <memcpy+0x114>
   1412c:	078b      	lsls	r3, r1, #30
   1412e:	d08d      	beq.n	1404c <memcpy+0xc>
   14130:	f010 0303 	ands.w	r3, r0, #3
   14134:	d08a      	beq.n	1404c <memcpy+0xc>
   14136:	f1c3 0304 	rsb	r3, r3, #4
   1413a:	1ad2      	subs	r2, r2, r3
   1413c:	07db      	lsls	r3, r3, #31
   1413e:	bf1c      	itt	ne
   14140:	f811 3b01 	ldrbne.w	r3, [r1], #1
   14144:	f800 3b01 	strbne.w	r3, [r0], #1
   14148:	d380      	bcc.n	1404c <memcpy+0xc>
   1414a:	f831 3b02 	ldrh.w	r3, [r1], #2
   1414e:	f820 3b02 	strh.w	r3, [r0], #2
   14152:	e77b      	b.n	1404c <memcpy+0xc>
   14154:	3a04      	subs	r2, #4
   14156:	d3d9      	bcc.n	1410c <memcpy+0xcc>
   14158:	3a01      	subs	r2, #1
   1415a:	f811 3b01 	ldrb.w	r3, [r1], #1
   1415e:	f800 3b01 	strb.w	r3, [r0], #1
   14162:	d2f9      	bcs.n	14158 <memcpy+0x118>
   14164:	780b      	ldrb	r3, [r1, #0]
   14166:	7003      	strb	r3, [r0, #0]
   14168:	784b      	ldrb	r3, [r1, #1]
   1416a:	7043      	strb	r3, [r0, #1]
   1416c:	788b      	ldrb	r3, [r1, #2]
   1416e:	7083      	strb	r3, [r0, #2]
   14170:	4660      	mov	r0, ip
   14172:	4770      	bx	lr

00014174 <memset>:
   14174:	b4f0      	push	{r4, r5, r6, r7}
   14176:	0786      	lsls	r6, r0, #30
   14178:	d046      	beq.n	14208 <memset+0x94>
   1417a:	1e54      	subs	r4, r2, #1
   1417c:	2a00      	cmp	r2, #0
   1417e:	d03c      	beq.n	141fa <memset+0x86>
   14180:	b2ca      	uxtb	r2, r1
   14182:	4603      	mov	r3, r0
   14184:	e002      	b.n	1418c <memset+0x18>
   14186:	f114 34ff 	adds.w	r4, r4, #4294967295	; 0xffffffff
   1418a:	d336      	bcc.n	141fa <memset+0x86>
   1418c:	f803 2b01 	strb.w	r2, [r3], #1
   14190:	079d      	lsls	r5, r3, #30
   14192:	d1f8      	bne.n	14186 <memset+0x12>
   14194:	2c03      	cmp	r4, #3
   14196:	d929      	bls.n	141ec <memset+0x78>
   14198:	b2cd      	uxtb	r5, r1
   1419a:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   1419e:	2c0f      	cmp	r4, #15
   141a0:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   141a4:	d933      	bls.n	1420e <memset+0x9a>
   141a6:	f1a4 0610 	sub.w	r6, r4, #16
   141aa:	0936      	lsrs	r6, r6, #4
   141ac:	f103 0720 	add.w	r7, r3, #32
   141b0:	eb07 1706 	add.w	r7, r7, r6, lsl #4
   141b4:	f103 0210 	add.w	r2, r3, #16
   141b8:	e942 5504 	strd	r5, r5, [r2, #-16]
   141bc:	e942 5502 	strd	r5, r5, [r2, #-8]
   141c0:	3210      	adds	r2, #16
   141c2:	42ba      	cmp	r2, r7
   141c4:	d1f8      	bne.n	141b8 <memset+0x44>
   141c6:	1c72      	adds	r2, r6, #1
   141c8:	f014 0f0c 	tst.w	r4, #12
   141cc:	eb03 1202 	add.w	r2, r3, r2, lsl #4
   141d0:	f004 060f 	and.w	r6, r4, #15
   141d4:	d013      	beq.n	141fe <memset+0x8a>
   141d6:	1f33      	subs	r3, r6, #4
   141d8:	f023 0303 	bic.w	r3, r3, #3
   141dc:	3304      	adds	r3, #4
   141de:	4413      	add	r3, r2
   141e0:	f842 5b04 	str.w	r5, [r2], #4
   141e4:	4293      	cmp	r3, r2
   141e6:	d1fb      	bne.n	141e0 <memset+0x6c>
   141e8:	f006 0403 	and.w	r4, r6, #3
   141ec:	b12c      	cbz	r4, 141fa <memset+0x86>
   141ee:	b2c9      	uxtb	r1, r1
   141f0:	441c      	add	r4, r3
   141f2:	f803 1b01 	strb.w	r1, [r3], #1
   141f6:	429c      	cmp	r4, r3
   141f8:	d1fb      	bne.n	141f2 <memset+0x7e>
   141fa:	bcf0      	pop	{r4, r5, r6, r7}
   141fc:	4770      	bx	lr
   141fe:	4634      	mov	r4, r6
   14200:	4613      	mov	r3, r2
   14202:	2c00      	cmp	r4, #0
   14204:	d1f3      	bne.n	141ee <memset+0x7a>
   14206:	e7f8      	b.n	141fa <memset+0x86>
   14208:	4614      	mov	r4, r2
   1420a:	4603      	mov	r3, r0
   1420c:	e7c2      	b.n	14194 <memset+0x20>
   1420e:	461a      	mov	r2, r3
   14210:	4626      	mov	r6, r4
   14212:	e7e0      	b.n	141d6 <memset+0x62>

00014214 <_free_r>:
   14214:	2900      	cmp	r1, #0
   14216:	d03c      	beq.n	14292 <_free_r+0x7e>
   14218:	b538      	push	{r3, r4, r5, lr}
   1421a:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1421e:	1f0c      	subs	r4, r1, #4
   14220:	2b00      	cmp	r3, #0
   14222:	bfb8      	it	lt
   14224:	18e4      	addlt	r4, r4, r3
   14226:	4605      	mov	r5, r0
   14228:	f001 f920 	bl	1546c <__malloc_lock>
   1422c:	4b23      	ldr	r3, [pc, #140]	; (142bc <_free_r+0xa8>)
   1422e:	681a      	ldr	r2, [r3, #0]
   14230:	b12a      	cbz	r2, 1423e <_free_r+0x2a>
   14232:	42a2      	cmp	r2, r4
   14234:	d90d      	bls.n	14252 <_free_r+0x3e>
   14236:	6821      	ldr	r1, [r4, #0]
   14238:	1860      	adds	r0, r4, r1
   1423a:	4282      	cmp	r2, r0
   1423c:	d023      	beq.n	14286 <_free_r+0x72>
   1423e:	6062      	str	r2, [r4, #4]
   14240:	4628      	mov	r0, r5
   14242:	601c      	str	r4, [r3, #0]
   14244:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14248:	f001 b912 	b.w	15470 <__malloc_unlock>
   1424c:	42a3      	cmp	r3, r4
   1424e:	d803      	bhi.n	14258 <_free_r+0x44>
   14250:	461a      	mov	r2, r3
   14252:	6853      	ldr	r3, [r2, #4]
   14254:	2b00      	cmp	r3, #0
   14256:	d1f9      	bne.n	1424c <_free_r+0x38>
   14258:	6811      	ldr	r1, [r2, #0]
   1425a:	1850      	adds	r0, r2, r1
   1425c:	42a0      	cmp	r0, r4
   1425e:	d019      	beq.n	14294 <_free_r+0x80>
   14260:	d824      	bhi.n	142ac <_free_r+0x98>
   14262:	6821      	ldr	r1, [r4, #0]
   14264:	1860      	adds	r0, r4, r1
   14266:	4283      	cmp	r3, r0
   14268:	d006      	beq.n	14278 <_free_r+0x64>
   1426a:	6063      	str	r3, [r4, #4]
   1426c:	6054      	str	r4, [r2, #4]
   1426e:	4628      	mov	r0, r5
   14270:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14274:	f001 b8fc 	b.w	15470 <__malloc_unlock>
   14278:	e9d3 0300 	ldrd	r0, r3, [r3]
   1427c:	4401      	add	r1, r0
   1427e:	6063      	str	r3, [r4, #4]
   14280:	6021      	str	r1, [r4, #0]
   14282:	6054      	str	r4, [r2, #4]
   14284:	e7f3      	b.n	1426e <_free_r+0x5a>
   14286:	e9d2 0200 	ldrd	r0, r2, [r2]
   1428a:	4401      	add	r1, r0
   1428c:	6062      	str	r2, [r4, #4]
   1428e:	6021      	str	r1, [r4, #0]
   14290:	e7d6      	b.n	14240 <_free_r+0x2c>
   14292:	4770      	bx	lr
   14294:	6820      	ldr	r0, [r4, #0]
   14296:	4401      	add	r1, r0
   14298:	1850      	adds	r0, r2, r1
   1429a:	4283      	cmp	r3, r0
   1429c:	6011      	str	r1, [r2, #0]
   1429e:	d1e6      	bne.n	1426e <_free_r+0x5a>
   142a0:	e9d3 0300 	ldrd	r0, r3, [r3]
   142a4:	4401      	add	r1, r0
   142a6:	6053      	str	r3, [r2, #4]
   142a8:	6011      	str	r1, [r2, #0]
   142aa:	e7e0      	b.n	1426e <_free_r+0x5a>
   142ac:	230c      	movs	r3, #12
   142ae:	602b      	str	r3, [r5, #0]
   142b0:	4628      	mov	r0, r5
   142b2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   142b6:	f001 b8db 	b.w	15470 <__malloc_unlock>
   142ba:	bf00      	nop
   142bc:	20001b54 	.word	0x20001b54

000142c0 <_malloc_r>:
   142c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   142c2:	1ccd      	adds	r5, r1, #3
   142c4:	f025 0503 	bic.w	r5, r5, #3
   142c8:	3508      	adds	r5, #8
   142ca:	2d0c      	cmp	r5, #12
   142cc:	bf38      	it	cc
   142ce:	250c      	movcc	r5, #12
   142d0:	2d00      	cmp	r5, #0
   142d2:	4606      	mov	r6, r0
   142d4:	db33      	blt.n	1433e <_malloc_r+0x7e>
   142d6:	42a9      	cmp	r1, r5
   142d8:	d831      	bhi.n	1433e <_malloc_r+0x7e>
   142da:	4f2a      	ldr	r7, [pc, #168]	; (14384 <_malloc_r+0xc4>)
   142dc:	f001 f8c6 	bl	1546c <__malloc_lock>
   142e0:	683a      	ldr	r2, [r7, #0]
   142e2:	b152      	cbz	r2, 142fa <_malloc_r+0x3a>
   142e4:	6813      	ldr	r3, [r2, #0]
   142e6:	1b5b      	subs	r3, r3, r5
   142e8:	d404      	bmi.n	142f4 <_malloc_r+0x34>
   142ea:	e03f      	b.n	1436c <_malloc_r+0xac>
   142ec:	6823      	ldr	r3, [r4, #0]
   142ee:	1b5b      	subs	r3, r3, r5
   142f0:	d529      	bpl.n	14346 <_malloc_r+0x86>
   142f2:	4622      	mov	r2, r4
   142f4:	6854      	ldr	r4, [r2, #4]
   142f6:	2c00      	cmp	r4, #0
   142f8:	d1f8      	bne.n	142ec <_malloc_r+0x2c>
   142fa:	6879      	ldr	r1, [r7, #4]
   142fc:	2900      	cmp	r1, #0
   142fe:	d03b      	beq.n	14378 <_malloc_r+0xb8>
   14300:	4629      	mov	r1, r5
   14302:	4630      	mov	r0, r6
   14304:	f000 f8e8 	bl	144d8 <_sbrk_r>
   14308:	1c43      	adds	r3, r0, #1
   1430a:	d028      	beq.n	1435e <_malloc_r+0x9e>
   1430c:	1cc4      	adds	r4, r0, #3
   1430e:	f024 0403 	bic.w	r4, r4, #3
   14312:	42a0      	cmp	r0, r4
   14314:	d005      	beq.n	14322 <_malloc_r+0x62>
   14316:	1a21      	subs	r1, r4, r0
   14318:	4630      	mov	r0, r6
   1431a:	f000 f8dd 	bl	144d8 <_sbrk_r>
   1431e:	3001      	adds	r0, #1
   14320:	d01d      	beq.n	1435e <_malloc_r+0x9e>
   14322:	6025      	str	r5, [r4, #0]
   14324:	4630      	mov	r0, r6
   14326:	f001 f8a3 	bl	15470 <__malloc_unlock>
   1432a:	f104 000b 	add.w	r0, r4, #11
   1432e:	f020 0007 	bic.w	r0, r0, #7
   14332:	1d23      	adds	r3, r4, #4
   14334:	1ac2      	subs	r2, r0, r3
   14336:	d001      	beq.n	1433c <_malloc_r+0x7c>
   14338:	1a1b      	subs	r3, r3, r0
   1433a:	50a3      	str	r3, [r4, r2]
   1433c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1433e:	220c      	movs	r2, #12
   14340:	6032      	str	r2, [r6, #0]
   14342:	2000      	movs	r0, #0
   14344:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14346:	2b0b      	cmp	r3, #11
   14348:	d805      	bhi.n	14356 <_malloc_r+0x96>
   1434a:	42a2      	cmp	r2, r4
   1434c:	6863      	ldr	r3, [r4, #4]
   1434e:	d011      	beq.n	14374 <_malloc_r+0xb4>
   14350:	6053      	str	r3, [r2, #4]
   14352:	e7e7      	b.n	14324 <_malloc_r+0x64>
   14354:	4614      	mov	r4, r2
   14356:	6023      	str	r3, [r4, #0]
   14358:	441c      	add	r4, r3
   1435a:	6025      	str	r5, [r4, #0]
   1435c:	e7e2      	b.n	14324 <_malloc_r+0x64>
   1435e:	230c      	movs	r3, #12
   14360:	4630      	mov	r0, r6
   14362:	6033      	str	r3, [r6, #0]
   14364:	f001 f884 	bl	15470 <__malloc_unlock>
   14368:	2000      	movs	r0, #0
   1436a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   1436c:	2b0b      	cmp	r3, #11
   1436e:	d8f1      	bhi.n	14354 <_malloc_r+0x94>
   14370:	6853      	ldr	r3, [r2, #4]
   14372:	4614      	mov	r4, r2
   14374:	603b      	str	r3, [r7, #0]
   14376:	e7d5      	b.n	14324 <_malloc_r+0x64>
   14378:	4630      	mov	r0, r6
   1437a:	f000 f8ad 	bl	144d8 <_sbrk_r>
   1437e:	6078      	str	r0, [r7, #4]
   14380:	e7be      	b.n	14300 <_malloc_r+0x40>
   14382:	bf00      	nop
   14384:	20001b54 	.word	0x20001b54

00014388 <_iprintf_r>:
   14388:	b40e      	push	{r1, r2, r3}
   1438a:	b510      	push	{r4, lr}
   1438c:	4604      	mov	r4, r0
   1438e:	b083      	sub	sp, #12
   14390:	b108      	cbz	r0, 14396 <_iprintf_r+0xe>
   14392:	6983      	ldr	r3, [r0, #24]
   14394:	b163      	cbz	r3, 143b0 <_iprintf_r+0x28>
   14396:	a806      	add	r0, sp, #24
   14398:	4603      	mov	r3, r0
   1439a:	9001      	str	r0, [sp, #4]
   1439c:	9a05      	ldr	r2, [sp, #20]
   1439e:	68a1      	ldr	r1, [r4, #8]
   143a0:	4620      	mov	r0, r4
   143a2:	f001 fabf 	bl	15924 <_vfiprintf_r>
   143a6:	b003      	add	sp, #12
   143a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   143ac:	b003      	add	sp, #12
   143ae:	4770      	bx	lr
   143b0:	f000 ff74 	bl	1529c <__sinit>
   143b4:	e7ef      	b.n	14396 <_iprintf_r+0xe>
   143b6:	bf00      	nop

000143b8 <iprintf>:
   143b8:	b40f      	push	{r0, r1, r2, r3}
   143ba:	b510      	push	{r4, lr}
   143bc:	4b0b      	ldr	r3, [pc, #44]	; (143ec <iprintf+0x34>)
   143be:	681c      	ldr	r4, [r3, #0]
   143c0:	b082      	sub	sp, #8
   143c2:	b10c      	cbz	r4, 143c8 <iprintf+0x10>
   143c4:	69a3      	ldr	r3, [r4, #24]
   143c6:	b163      	cbz	r3, 143e2 <iprintf+0x2a>
   143c8:	a805      	add	r0, sp, #20
   143ca:	4603      	mov	r3, r0
   143cc:	9001      	str	r0, [sp, #4]
   143ce:	9a04      	ldr	r2, [sp, #16]
   143d0:	68a1      	ldr	r1, [r4, #8]
   143d2:	4620      	mov	r0, r4
   143d4:	f001 faa6 	bl	15924 <_vfiprintf_r>
   143d8:	b002      	add	sp, #8
   143da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   143de:	b004      	add	sp, #16
   143e0:	4770      	bx	lr
   143e2:	4620      	mov	r0, r4
   143e4:	f000 ff5a 	bl	1529c <__sinit>
   143e8:	e7ee      	b.n	143c8 <iprintf+0x10>
   143ea:	bf00      	nop
   143ec:	2000054c 	.word	0x2000054c

000143f0 <_puts_r>:
   143f0:	6983      	ldr	r3, [r0, #24]
   143f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   143f6:	4680      	mov	r8, r0
   143f8:	460e      	mov	r6, r1
   143fa:	b333      	cbz	r3, 1444a <_puts_r+0x5a>
   143fc:	6884      	ldr	r4, [r0, #8]
   143fe:	4b2f      	ldr	r3, [pc, #188]	; (144bc <_puts_r+0xcc>)
   14400:	429c      	cmp	r4, r3
   14402:	d030      	beq.n	14466 <_puts_r+0x76>
   14404:	4b2e      	ldr	r3, [pc, #184]	; (144c0 <_puts_r+0xd0>)
   14406:	429c      	cmp	r4, r3
   14408:	d039      	beq.n	1447e <_puts_r+0x8e>
   1440a:	4b2e      	ldr	r3, [pc, #184]	; (144c4 <_puts_r+0xd4>)
   1440c:	429c      	cmp	r4, r3
   1440e:	bf08      	it	eq
   14410:	f8d8 400c 	ldreq.w	r4, [r8, #12]
   14414:	89a3      	ldrh	r3, [r4, #12]
   14416:	071b      	lsls	r3, r3, #28
   14418:	d52a      	bpl.n	14470 <_puts_r+0x80>
   1441a:	6923      	ldr	r3, [r4, #16]
   1441c:	b343      	cbz	r3, 14470 <_puts_r+0x80>
   1441e:	3e01      	subs	r6, #1
   14420:	68a3      	ldr	r3, [r4, #8]
   14422:	f816 5f01 	ldrb.w	r5, [r6, #1]!
   14426:	3b01      	subs	r3, #1
   14428:	60a3      	str	r3, [r4, #8]
   1442a:	b39d      	cbz	r5, 14494 <_puts_r+0xa4>
   1442c:	2b00      	cmp	r3, #0
   1442e:	da07      	bge.n	14440 <_puts_r+0x50>
   14430:	69a7      	ldr	r7, [r4, #24]
   14432:	429f      	cmp	r7, r3
   14434:	4622      	mov	r2, r4
   14436:	4629      	mov	r1, r5
   14438:	4640      	mov	r0, r8
   1443a:	dc23      	bgt.n	14484 <_puts_r+0x94>
   1443c:	2d0a      	cmp	r5, #10
   1443e:	d021      	beq.n	14484 <_puts_r+0x94>
   14440:	6823      	ldr	r3, [r4, #0]
   14442:	1c5a      	adds	r2, r3, #1
   14444:	6022      	str	r2, [r4, #0]
   14446:	701d      	strb	r5, [r3, #0]
   14448:	e7ea      	b.n	14420 <_puts_r+0x30>
   1444a:	f000 ff27 	bl	1529c <__sinit>
   1444e:	f8d8 3018 	ldr.w	r3, [r8, #24]
   14452:	f8d8 4008 	ldr.w	r4, [r8, #8]
   14456:	2b00      	cmp	r3, #0
   14458:	d1d1      	bne.n	143fe <_puts_r+0xe>
   1445a:	4640      	mov	r0, r8
   1445c:	f000 ff1e 	bl	1529c <__sinit>
   14460:	4b16      	ldr	r3, [pc, #88]	; (144bc <_puts_r+0xcc>)
   14462:	429c      	cmp	r4, r3
   14464:	d1ce      	bne.n	14404 <_puts_r+0x14>
   14466:	f8d8 4004 	ldr.w	r4, [r8, #4]
   1446a:	89a3      	ldrh	r3, [r4, #12]
   1446c:	071b      	lsls	r3, r3, #28
   1446e:	d4d4      	bmi.n	1441a <_puts_r+0x2a>
   14470:	4621      	mov	r1, r4
   14472:	4640      	mov	r0, r8
   14474:	f000 fcd2 	bl	14e1c <__swsetup_r>
   14478:	2800      	cmp	r0, #0
   1447a:	d0d0      	beq.n	1441e <_puts_r+0x2e>
   1447c:	e006      	b.n	1448c <_puts_r+0x9c>
   1447e:	f8d8 4008 	ldr.w	r4, [r8, #8]
   14482:	e7c7      	b.n	14414 <_puts_r+0x24>
   14484:	f000 fc6a 	bl	14d5c <__swbuf_r>
   14488:	3001      	adds	r0, #1
   1448a:	d1c9      	bne.n	14420 <_puts_r+0x30>
   1448c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14490:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14494:	2b00      	cmp	r3, #0
   14496:	da09      	bge.n	144ac <_puts_r+0xbc>
   14498:	4622      	mov	r2, r4
   1449a:	4640      	mov	r0, r8
   1449c:	210a      	movs	r1, #10
   1449e:	f000 fc5d 	bl	14d5c <__swbuf_r>
   144a2:	3001      	adds	r0, #1
   144a4:	d0f2      	beq.n	1448c <_puts_r+0x9c>
   144a6:	200a      	movs	r0, #10
   144a8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   144ac:	6823      	ldr	r3, [r4, #0]
   144ae:	220a      	movs	r2, #10
   144b0:	1c59      	adds	r1, r3, #1
   144b2:	6021      	str	r1, [r4, #0]
   144b4:	701a      	strb	r2, [r3, #0]
   144b6:	4610      	mov	r0, r2
   144b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   144bc:	000175b0 	.word	0x000175b0
   144c0:	00017590 	.word	0x00017590
   144c4:	00017570 	.word	0x00017570

000144c8 <puts>:
   144c8:	4b02      	ldr	r3, [pc, #8]	; (144d4 <puts+0xc>)
   144ca:	4601      	mov	r1, r0
   144cc:	6818      	ldr	r0, [r3, #0]
   144ce:	f7ff bf8f 	b.w	143f0 <_puts_r>
   144d2:	bf00      	nop
   144d4:	2000054c 	.word	0x2000054c

000144d8 <_sbrk_r>:
   144d8:	b538      	push	{r3, r4, r5, lr}
   144da:	4c07      	ldr	r4, [pc, #28]	; (144f8 <_sbrk_r+0x20>)
   144dc:	2300      	movs	r3, #0
   144de:	4605      	mov	r5, r0
   144e0:	4608      	mov	r0, r1
   144e2:	6023      	str	r3, [r4, #0]
   144e4:	f7f7 fbee 	bl	bcc4 <_sbrk>
   144e8:	1c43      	adds	r3, r0, #1
   144ea:	d000      	beq.n	144ee <_sbrk_r+0x16>
   144ec:	bd38      	pop	{r3, r4, r5, pc}
   144ee:	6823      	ldr	r3, [r4, #0]
   144f0:	2b00      	cmp	r3, #0
   144f2:	d0fb      	beq.n	144ec <_sbrk_r+0x14>
   144f4:	602b      	str	r3, [r5, #0]
   144f6:	bd38      	pop	{r3, r4, r5, pc}
   144f8:	200159f4 	.word	0x200159f4

000144fc <setbuf>:
   144fc:	2900      	cmp	r1, #0
   144fe:	bf0c      	ite	eq
   14500:	2202      	moveq	r2, #2
   14502:	2200      	movne	r2, #0
   14504:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14508:	f000 b800 	b.w	1450c <setvbuf>

0001450c <setvbuf>:
   1450c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   14510:	4c58      	ldr	r4, [pc, #352]	; (14674 <setvbuf+0x168>)
   14512:	6825      	ldr	r5, [r4, #0]
   14514:	b083      	sub	sp, #12
   14516:	4604      	mov	r4, r0
   14518:	460f      	mov	r7, r1
   1451a:	4690      	mov	r8, r2
   1451c:	461e      	mov	r6, r3
   1451e:	b115      	cbz	r5, 14526 <setvbuf+0x1a>
   14520:	69ab      	ldr	r3, [r5, #24]
   14522:	2b00      	cmp	r3, #0
   14524:	d062      	beq.n	145ec <setvbuf+0xe0>
   14526:	4b54      	ldr	r3, [pc, #336]	; (14678 <setvbuf+0x16c>)
   14528:	429c      	cmp	r4, r3
   1452a:	d065      	beq.n	145f8 <setvbuf+0xec>
   1452c:	4b53      	ldr	r3, [pc, #332]	; (1467c <setvbuf+0x170>)
   1452e:	429c      	cmp	r4, r3
   14530:	d064      	beq.n	145fc <setvbuf+0xf0>
   14532:	4b53      	ldr	r3, [pc, #332]	; (14680 <setvbuf+0x174>)
   14534:	429c      	cmp	r4, r3
   14536:	bf08      	it	eq
   14538:	68ec      	ldreq	r4, [r5, #12]
   1453a:	f1b8 0f02 	cmp.w	r8, #2
   1453e:	d006      	beq.n	1454e <setvbuf+0x42>
   14540:	f1b8 0f01 	cmp.w	r8, #1
   14544:	f200 8093 	bhi.w	1466e <setvbuf+0x162>
   14548:	2e00      	cmp	r6, #0
   1454a:	f2c0 8090 	blt.w	1466e <setvbuf+0x162>
   1454e:	4621      	mov	r1, r4
   14550:	4628      	mov	r0, r5
   14552:	f000 fd79 	bl	15048 <_fflush_r>
   14556:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14558:	b141      	cbz	r1, 1456c <setvbuf+0x60>
   1455a:	f104 0344 	add.w	r3, r4, #68	; 0x44
   1455e:	4299      	cmp	r1, r3
   14560:	d002      	beq.n	14568 <setvbuf+0x5c>
   14562:	4628      	mov	r0, r5
   14564:	f7ff fe56 	bl	14214 <_free_r>
   14568:	2300      	movs	r3, #0
   1456a:	6363      	str	r3, [r4, #52]	; 0x34
   1456c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14570:	2200      	movs	r2, #0
   14572:	61a2      	str	r2, [r4, #24]
   14574:	6062      	str	r2, [r4, #4]
   14576:	061a      	lsls	r2, r3, #24
   14578:	d44f      	bmi.n	1461a <setvbuf+0x10e>
   1457a:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
   1457e:	f023 0303 	bic.w	r3, r3, #3
   14582:	f1b8 0f02 	cmp.w	r8, #2
   14586:	81a3      	strh	r3, [r4, #12]
   14588:	d04e      	beq.n	14628 <setvbuf+0x11c>
   1458a:	ab01      	add	r3, sp, #4
   1458c:	466a      	mov	r2, sp
   1458e:	4621      	mov	r1, r4
   14590:	4628      	mov	r0, r5
   14592:	f000 fef3 	bl	1537c <__swhatbuf_r>
   14596:	89a3      	ldrh	r3, [r4, #12]
   14598:	4318      	orrs	r0, r3
   1459a:	81a0      	strh	r0, [r4, #12]
   1459c:	2e00      	cmp	r6, #0
   1459e:	d12f      	bne.n	14600 <setvbuf+0xf4>
   145a0:	9e00      	ldr	r6, [sp, #0]
   145a2:	4630      	mov	r0, r6
   145a4:	f7ff fd3c 	bl	14020 <malloc>
   145a8:	4607      	mov	r7, r0
   145aa:	2800      	cmp	r0, #0
   145ac:	d04f      	beq.n	1464e <setvbuf+0x142>
   145ae:	89a3      	ldrh	r3, [r4, #12]
   145b0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   145b4:	81a3      	strh	r3, [r4, #12]
   145b6:	69ab      	ldr	r3, [r5, #24]
   145b8:	b33b      	cbz	r3, 1460a <setvbuf+0xfe>
   145ba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   145be:	6027      	str	r7, [r4, #0]
   145c0:	f1b8 0f01 	cmp.w	r8, #1
   145c4:	bf04      	itt	eq
   145c6:	f043 0301 	orreq.w	r3, r3, #1
   145ca:	81a3      	strheq	r3, [r4, #12]
   145cc:	b29b      	uxth	r3, r3
   145ce:	f013 0008 	ands.w	r0, r3, #8
   145d2:	e9c4 7604 	strd	r7, r6, [r4, #16]
   145d6:	d01c      	beq.n	14612 <setvbuf+0x106>
   145d8:	f013 0001 	ands.w	r0, r3, #1
   145dc:	d033      	beq.n	14646 <setvbuf+0x13a>
   145de:	2000      	movs	r0, #0
   145e0:	4276      	negs	r6, r6
   145e2:	61a6      	str	r6, [r4, #24]
   145e4:	60a0      	str	r0, [r4, #8]
   145e6:	b003      	add	sp, #12
   145e8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   145ec:	4628      	mov	r0, r5
   145ee:	f000 fe55 	bl	1529c <__sinit>
   145f2:	4b21      	ldr	r3, [pc, #132]	; (14678 <setvbuf+0x16c>)
   145f4:	429c      	cmp	r4, r3
   145f6:	d199      	bne.n	1452c <setvbuf+0x20>
   145f8:	686c      	ldr	r4, [r5, #4]
   145fa:	e79e      	b.n	1453a <setvbuf+0x2e>
   145fc:	68ac      	ldr	r4, [r5, #8]
   145fe:	e79c      	b.n	1453a <setvbuf+0x2e>
   14600:	2f00      	cmp	r7, #0
   14602:	d0ce      	beq.n	145a2 <setvbuf+0x96>
   14604:	69ab      	ldr	r3, [r5, #24]
   14606:	2b00      	cmp	r3, #0
   14608:	d1d7      	bne.n	145ba <setvbuf+0xae>
   1460a:	4628      	mov	r0, r5
   1460c:	f000 fe46 	bl	1529c <__sinit>
   14610:	e7d3      	b.n	145ba <setvbuf+0xae>
   14612:	60a0      	str	r0, [r4, #8]
   14614:	b003      	add	sp, #12
   14616:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1461a:	6921      	ldr	r1, [r4, #16]
   1461c:	4628      	mov	r0, r5
   1461e:	f7ff fdf9 	bl	14214 <_free_r>
   14622:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14626:	e7a8      	b.n	1457a <setvbuf+0x6e>
   14628:	2000      	movs	r0, #0
   1462a:	f104 0247 	add.w	r2, r4, #71	; 0x47
   1462e:	f043 0302 	orr.w	r3, r3, #2
   14632:	2500      	movs	r5, #0
   14634:	2101      	movs	r1, #1
   14636:	81a3      	strh	r3, [r4, #12]
   14638:	60a5      	str	r5, [r4, #8]
   1463a:	6022      	str	r2, [r4, #0]
   1463c:	e9c4 2104 	strd	r2, r1, [r4, #16]
   14640:	b003      	add	sp, #12
   14642:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14646:	60a6      	str	r6, [r4, #8]
   14648:	b003      	add	sp, #12
   1464a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   1464e:	f8dd 9000 	ldr.w	r9, [sp]
   14652:	45b1      	cmp	r9, r6
   14654:	d006      	beq.n	14664 <setvbuf+0x158>
   14656:	4648      	mov	r0, r9
   14658:	f7ff fce2 	bl	14020 <malloc>
   1465c:	4607      	mov	r7, r0
   1465e:	b108      	cbz	r0, 14664 <setvbuf+0x158>
   14660:	464e      	mov	r6, r9
   14662:	e7a4      	b.n	145ae <setvbuf+0xa2>
   14664:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14668:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1466c:	e7dd      	b.n	1462a <setvbuf+0x11e>
   1466e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14672:	e7cf      	b.n	14614 <setvbuf+0x108>
   14674:	2000054c 	.word	0x2000054c
   14678:	000175b0 	.word	0x000175b0
   1467c:	00017590 	.word	0x00017590
   14680:	00017570 	.word	0x00017570

00014684 <_sniprintf_r>:
   14684:	b408      	push	{r3}
   14686:	b530      	push	{r4, r5, lr}
   14688:	2a00      	cmp	r2, #0
   1468a:	b09c      	sub	sp, #112	; 0x70
   1468c:	4604      	mov	r4, r0
   1468e:	db35      	blt.n	146fc <_sniprintf_r+0x78>
   14690:	f44f 7302 	mov.w	r3, #520	; 0x208
   14694:	9102      	str	r1, [sp, #8]
   14696:	9106      	str	r1, [sp, #24]
   14698:	f8ad 3014 	strh.w	r3, [sp, #20]
   1469c:	a920      	add	r1, sp, #128	; 0x80
   1469e:	d018      	beq.n	146d2 <_sniprintf_r+0x4e>
   146a0:	3a01      	subs	r2, #1
   146a2:	460b      	mov	r3, r1
   146a4:	9204      	str	r2, [sp, #16]
   146a6:	9207      	str	r2, [sp, #28]
   146a8:	9101      	str	r1, [sp, #4]
   146aa:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   146ac:	f64f 75ff 	movw	r5, #65535	; 0xffff
   146b0:	a902      	add	r1, sp, #8
   146b2:	f8ad 5016 	strh.w	r5, [sp, #22]
   146b6:	f000 ffb9 	bl	1562c <_svfiprintf_r>
   146ba:	1c42      	adds	r2, r0, #1
   146bc:	da01      	bge.n	146c2 <_sniprintf_r+0x3e>
   146be:	238b      	movs	r3, #139	; 0x8b
   146c0:	6023      	str	r3, [r4, #0]
   146c2:	9b02      	ldr	r3, [sp, #8]
   146c4:	2200      	movs	r2, #0
   146c6:	701a      	strb	r2, [r3, #0]
   146c8:	b01c      	add	sp, #112	; 0x70
   146ca:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   146ce:	b001      	add	sp, #4
   146d0:	4770      	bx	lr
   146d2:	460b      	mov	r3, r1
   146d4:	9204      	str	r2, [sp, #16]
   146d6:	9207      	str	r2, [sp, #28]
   146d8:	9101      	str	r1, [sp, #4]
   146da:	f64f 75ff 	movw	r5, #65535	; 0xffff
   146de:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
   146e0:	f8ad 5016 	strh.w	r5, [sp, #22]
   146e4:	a902      	add	r1, sp, #8
   146e6:	f000 ffa1 	bl	1562c <_svfiprintf_r>
   146ea:	1c43      	adds	r3, r0, #1
   146ec:	da01      	bge.n	146f2 <_sniprintf_r+0x6e>
   146ee:	238b      	movs	r3, #139	; 0x8b
   146f0:	6023      	str	r3, [r4, #0]
   146f2:	b01c      	add	sp, #112	; 0x70
   146f4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   146f8:	b001      	add	sp, #4
   146fa:	4770      	bx	lr
   146fc:	228b      	movs	r2, #139	; 0x8b
   146fe:	6002      	str	r2, [r0, #0]
   14700:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14704:	e7f5      	b.n	146f2 <_sniprintf_r+0x6e>
   14706:	bf00      	nop

00014708 <sniprintf>:
   14708:	b40c      	push	{r2, r3}
   1470a:	b530      	push	{r4, r5, lr}
   1470c:	4b20      	ldr	r3, [pc, #128]	; (14790 <sniprintf+0x88>)
   1470e:	2900      	cmp	r1, #0
   14710:	b09d      	sub	sp, #116	; 0x74
   14712:	681c      	ldr	r4, [r3, #0]
   14714:	db37      	blt.n	14786 <sniprintf+0x7e>
   14716:	f44f 7302 	mov.w	r3, #520	; 0x208
   1471a:	9002      	str	r0, [sp, #8]
   1471c:	9006      	str	r0, [sp, #24]
   1471e:	f8ad 3014 	strh.w	r3, [sp, #20]
   14722:	a821      	add	r0, sp, #132	; 0x84
   14724:	d019      	beq.n	1475a <sniprintf+0x52>
   14726:	3901      	subs	r1, #1
   14728:	4603      	mov	r3, r0
   1472a:	9a20      	ldr	r2, [sp, #128]	; 0x80
   1472c:	9104      	str	r1, [sp, #16]
   1472e:	9107      	str	r1, [sp, #28]
   14730:	9001      	str	r0, [sp, #4]
   14732:	f64f 75ff 	movw	r5, #65535	; 0xffff
   14736:	a902      	add	r1, sp, #8
   14738:	4620      	mov	r0, r4
   1473a:	f8ad 5016 	strh.w	r5, [sp, #22]
   1473e:	f000 ff75 	bl	1562c <_svfiprintf_r>
   14742:	1c42      	adds	r2, r0, #1
   14744:	da01      	bge.n	1474a <sniprintf+0x42>
   14746:	238b      	movs	r3, #139	; 0x8b
   14748:	6023      	str	r3, [r4, #0]
   1474a:	9b02      	ldr	r3, [sp, #8]
   1474c:	2200      	movs	r2, #0
   1474e:	701a      	strb	r2, [r3, #0]
   14750:	b01d      	add	sp, #116	; 0x74
   14752:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14756:	b002      	add	sp, #8
   14758:	4770      	bx	lr
   1475a:	4603      	mov	r3, r0
   1475c:	9104      	str	r1, [sp, #16]
   1475e:	9107      	str	r1, [sp, #28]
   14760:	9001      	str	r0, [sp, #4]
   14762:	f64f 75ff 	movw	r5, #65535	; 0xffff
   14766:	9a20      	ldr	r2, [sp, #128]	; 0x80
   14768:	f8ad 5016 	strh.w	r5, [sp, #22]
   1476c:	a902      	add	r1, sp, #8
   1476e:	4620      	mov	r0, r4
   14770:	f000 ff5c 	bl	1562c <_svfiprintf_r>
   14774:	1c43      	adds	r3, r0, #1
   14776:	da01      	bge.n	1477c <sniprintf+0x74>
   14778:	238b      	movs	r3, #139	; 0x8b
   1477a:	6023      	str	r3, [r4, #0]
   1477c:	b01d      	add	sp, #116	; 0x74
   1477e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14782:	b002      	add	sp, #8
   14784:	4770      	bx	lr
   14786:	238b      	movs	r3, #139	; 0x8b
   14788:	6023      	str	r3, [r4, #0]
   1478a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   1478e:	e7f5      	b.n	1477c <sniprintf+0x74>
   14790:	2000054c 	.word	0x2000054c

00014794 <_siprintf_r>:
   14794:	b40c      	push	{r2, r3}
   14796:	b570      	push	{r4, r5, r6, lr}
   14798:	b09c      	sub	sp, #112	; 0x70
   1479a:	ac20      	add	r4, sp, #128	; 0x80
   1479c:	4e0b      	ldr	r6, [pc, #44]	; (147cc <_siprintf_r+0x38>)
   1479e:	f854 2b04 	ldr.w	r2, [r4], #4
   147a2:	9102      	str	r1, [sp, #8]
   147a4:	4623      	mov	r3, r4
   147a6:	9106      	str	r1, [sp, #24]
   147a8:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
   147ac:	a902      	add	r1, sp, #8
   147ae:	9401      	str	r4, [sp, #4]
   147b0:	9507      	str	r5, [sp, #28]
   147b2:	e9cd 5604 	strd	r5, r6, [sp, #16]
   147b6:	f000 ff39 	bl	1562c <_svfiprintf_r>
   147ba:	9b02      	ldr	r3, [sp, #8]
   147bc:	2200      	movs	r2, #0
   147be:	701a      	strb	r2, [r3, #0]
   147c0:	b01c      	add	sp, #112	; 0x70
   147c2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   147c6:	b002      	add	sp, #8
   147c8:	4770      	bx	lr
   147ca:	bf00      	nop
   147cc:	ffff0208 	.word	0xffff0208

000147d0 <siprintf>:
   147d0:	b40e      	push	{r1, r2, r3}
   147d2:	b530      	push	{r4, r5, lr}
   147d4:	b09c      	sub	sp, #112	; 0x70
   147d6:	ab1f      	add	r3, sp, #124	; 0x7c
   147d8:	4c0c      	ldr	r4, [pc, #48]	; (1480c <siprintf+0x3c>)
   147da:	4d0d      	ldr	r5, [pc, #52]	; (14810 <siprintf+0x40>)
   147dc:	f853 2b04 	ldr.w	r2, [r3], #4
   147e0:	9301      	str	r3, [sp, #4]
   147e2:	4601      	mov	r1, r0
   147e4:	9102      	str	r1, [sp, #8]
   147e6:	9106      	str	r1, [sp, #24]
   147e8:	6820      	ldr	r0, [r4, #0]
   147ea:	a902      	add	r1, sp, #8
   147ec:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
   147f0:	9407      	str	r4, [sp, #28]
   147f2:	e9cd 4504 	strd	r4, r5, [sp, #16]
   147f6:	f000 ff19 	bl	1562c <_svfiprintf_r>
   147fa:	9b02      	ldr	r3, [sp, #8]
   147fc:	2200      	movs	r2, #0
   147fe:	701a      	strb	r2, [r3, #0]
   14800:	b01c      	add	sp, #112	; 0x70
   14802:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14806:	b003      	add	sp, #12
   14808:	4770      	bx	lr
   1480a:	bf00      	nop
   1480c:	2000054c 	.word	0x2000054c
   14810:	ffff0208 	.word	0xffff0208

00014814 <strchr>:
   14814:	b2c9      	uxtb	r1, r1
   14816:	f000 0303 	and.w	r3, r0, #3
   1481a:	2900      	cmp	r1, #0
   1481c:	d035      	beq.n	1488a <strchr+0x76>
   1481e:	b17b      	cbz	r3, 14840 <strchr+0x2c>
   14820:	7803      	ldrb	r3, [r0, #0]
   14822:	2b00      	cmp	r3, #0
   14824:	d057      	beq.n	148d6 <strchr+0xc2>
   14826:	4299      	cmp	r1, r3
   14828:	d052      	beq.n	148d0 <strchr+0xbc>
   1482a:	1c43      	adds	r3, r0, #1
   1482c:	e005      	b.n	1483a <strchr+0x26>
   1482e:	f813 2b01 	ldrb.w	r2, [r3], #1
   14832:	2a00      	cmp	r2, #0
   14834:	d04d      	beq.n	148d2 <strchr+0xbe>
   14836:	428a      	cmp	r2, r1
   14838:	d04a      	beq.n	148d0 <strchr+0xbc>
   1483a:	079a      	lsls	r2, r3, #30
   1483c:	4618      	mov	r0, r3
   1483e:	d1f6      	bne.n	1482e <strchr+0x1a>
   14840:	b470      	push	{r4, r5, r6}
   14842:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
   14846:	6804      	ldr	r4, [r0, #0]
   14848:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
   1484c:	e001      	b.n	14852 <strchr+0x3e>
   1484e:	f850 4f04 	ldr.w	r4, [r0, #4]!
   14852:	ea86 0504 	eor.w	r5, r6, r4
   14856:	f1a5 3201 	sub.w	r2, r5, #16843009	; 0x1010101
   1485a:	f1a4 3301 	sub.w	r3, r4, #16843009	; 0x1010101
   1485e:	ea22 0205 	bic.w	r2, r2, r5
   14862:	ea23 0304 	bic.w	r3, r3, r4
   14866:	4313      	orrs	r3, r2
   14868:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   1486c:	d0ef      	beq.n	1484e <strchr+0x3a>
   1486e:	7803      	ldrb	r3, [r0, #0]
   14870:	b143      	cbz	r3, 14884 <strchr+0x70>
   14872:	4299      	cmp	r1, r3
   14874:	d102      	bne.n	1487c <strchr+0x68>
   14876:	e006      	b.n	14886 <strchr+0x72>
   14878:	428b      	cmp	r3, r1
   1487a:	d004      	beq.n	14886 <strchr+0x72>
   1487c:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   14880:	2b00      	cmp	r3, #0
   14882:	d1f9      	bne.n	14878 <strchr+0x64>
   14884:	4618      	mov	r0, r3
   14886:	bc70      	pop	{r4, r5, r6}
   14888:	4770      	bx	lr
   1488a:	b14b      	cbz	r3, 148a0 <strchr+0x8c>
   1488c:	7803      	ldrb	r3, [r0, #0]
   1488e:	b1fb      	cbz	r3, 148d0 <strchr+0xbc>
   14890:	1c43      	adds	r3, r0, #1
   14892:	e002      	b.n	1489a <strchr+0x86>
   14894:	7802      	ldrb	r2, [r0, #0]
   14896:	3301      	adds	r3, #1
   14898:	b1d2      	cbz	r2, 148d0 <strchr+0xbc>
   1489a:	0799      	lsls	r1, r3, #30
   1489c:	4618      	mov	r0, r3
   1489e:	d1f9      	bne.n	14894 <strchr+0x80>
   148a0:	6802      	ldr	r2, [r0, #0]
   148a2:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
   148a6:	ea23 0302 	bic.w	r3, r3, r2
   148aa:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   148ae:	d108      	bne.n	148c2 <strchr+0xae>
   148b0:	f850 2f04 	ldr.w	r2, [r0, #4]!
   148b4:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
   148b8:	ea23 0302 	bic.w	r3, r3, r2
   148bc:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
   148c0:	d0f6      	beq.n	148b0 <strchr+0x9c>
   148c2:	7803      	ldrb	r3, [r0, #0]
   148c4:	b123      	cbz	r3, 148d0 <strchr+0xbc>
   148c6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   148ca:	2b00      	cmp	r3, #0
   148cc:	d1fb      	bne.n	148c6 <strchr+0xb2>
   148ce:	4770      	bx	lr
   148d0:	4770      	bx	lr
   148d2:	4610      	mov	r0, r2
   148d4:	4770      	bx	lr
   148d6:	4618      	mov	r0, r3
   148d8:	4770      	bx	lr
   148da:	bf00      	nop
   148dc:	0000      	movs	r0, r0
   148de:	0000      	movs	r0, r0
   148e0:	eba2 0003 	sub.w	r0, r2, r3
   148e4:	4770      	bx	lr
   148e6:	bf00      	nop

000148e8 <strcmp>:
   148e8:	7802      	ldrb	r2, [r0, #0]
   148ea:	780b      	ldrb	r3, [r1, #0]
   148ec:	2a01      	cmp	r2, #1
   148ee:	bf28      	it	cs
   148f0:	429a      	cmpcs	r2, r3
   148f2:	d1f5      	bne.n	148e0 <strchr+0xcc>
   148f4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
   148f8:	ea40 0401 	orr.w	r4, r0, r1
   148fc:	e9cd 6702 	strd	r6, r7, [sp, #8]
   14900:	f06f 0c00 	mvn.w	ip, #0
   14904:	ea4f 7244 	mov.w	r2, r4, lsl #29
   14908:	b312      	cbz	r2, 14950 <strcmp+0x68>
   1490a:	ea80 0401 	eor.w	r4, r0, r1
   1490e:	f014 0f07 	tst.w	r4, #7
   14912:	d16a      	bne.n	149ea <strcmp+0x102>
   14914:	f000 0407 	and.w	r4, r0, #7
   14918:	f020 0007 	bic.w	r0, r0, #7
   1491c:	f004 0503 	and.w	r5, r4, #3
   14920:	f021 0107 	bic.w	r1, r1, #7
   14924:	ea4f 05c5 	mov.w	r5, r5, lsl #3
   14928:	e8f0 2304 	ldrd	r2, r3, [r0], #16
   1492c:	f014 0f04 	tst.w	r4, #4
   14930:	e8f1 6704 	ldrd	r6, r7, [r1], #16
   14934:	fa0c f405 	lsl.w	r4, ip, r5
   14938:	ea62 0204 	orn	r2, r2, r4
   1493c:	ea66 0604 	orn	r6, r6, r4
   14940:	d00a      	beq.n	14958 <strcmp+0x70>
   14942:	ea63 0304 	orn	r3, r3, r4
   14946:	4662      	mov	r2, ip
   14948:	ea67 0704 	orn	r7, r7, r4
   1494c:	4666      	mov	r6, ip
   1494e:	e003      	b.n	14958 <strcmp+0x70>
   14950:	e8f0 2304 	ldrd	r2, r3, [r0], #16
   14954:	e8f1 6704 	ldrd	r6, r7, [r1], #16
   14958:	fa82 f54c 	uadd8	r5, r2, ip
   1495c:	ea82 0406 	eor.w	r4, r2, r6
   14960:	faa4 f48c 	sel	r4, r4, ip
   14964:	bb6c      	cbnz	r4, 149c2 <strcmp+0xda>
   14966:	fa83 f54c 	uadd8	r5, r3, ip
   1496a:	ea83 0507 	eor.w	r5, r3, r7
   1496e:	faa5 f58c 	sel	r5, r5, ip
   14972:	b995      	cbnz	r5, 1499a <strcmp+0xb2>
   14974:	e950 2302 	ldrd	r2, r3, [r0, #-8]
   14978:	e951 6702 	ldrd	r6, r7, [r1, #-8]
   1497c:	fa82 f54c 	uadd8	r5, r2, ip
   14980:	ea82 0406 	eor.w	r4, r2, r6
   14984:	faa4 f48c 	sel	r4, r4, ip
   14988:	fa83 f54c 	uadd8	r5, r3, ip
   1498c:	ea83 0507 	eor.w	r5, r3, r7
   14990:	faa5 f58c 	sel	r5, r5, ip
   14994:	4325      	orrs	r5, r4
   14996:	d0db      	beq.n	14950 <strcmp+0x68>
   14998:	b99c      	cbnz	r4, 149c2 <strcmp+0xda>
   1499a:	ba2d      	rev	r5, r5
   1499c:	fab5 f485 	clz	r4, r5
   149a0:	f024 0407 	bic.w	r4, r4, #7
   149a4:	fa27 f104 	lsr.w	r1, r7, r4
   149a8:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   149ac:	fa23 f304 	lsr.w	r3, r3, r4
   149b0:	f003 00ff 	and.w	r0, r3, #255	; 0xff
   149b4:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   149b8:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   149bc:	eba0 0001 	sub.w	r0, r0, r1
   149c0:	4770      	bx	lr
   149c2:	ba24      	rev	r4, r4
   149c4:	fab4 f484 	clz	r4, r4
   149c8:	f024 0407 	bic.w	r4, r4, #7
   149cc:	fa26 f104 	lsr.w	r1, r6, r4
   149d0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
   149d4:	fa22 f204 	lsr.w	r2, r2, r4
   149d8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
   149dc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   149e0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   149e4:	eba0 0001 	sub.w	r0, r0, r1
   149e8:	4770      	bx	lr
   149ea:	f014 0f03 	tst.w	r4, #3
   149ee:	d13c      	bne.n	14a6a <strcmp+0x182>
   149f0:	f010 0403 	ands.w	r4, r0, #3
   149f4:	d128      	bne.n	14a48 <strcmp+0x160>
   149f6:	f850 2b08 	ldr.w	r2, [r0], #8
   149fa:	f851 3b08 	ldr.w	r3, [r1], #8
   149fe:	fa82 f54c 	uadd8	r5, r2, ip
   14a02:	ea82 0503 	eor.w	r5, r2, r3
   14a06:	faa5 f58c 	sel	r5, r5, ip
   14a0a:	b95d      	cbnz	r5, 14a24 <strcmp+0x13c>
   14a0c:	f850 2c04 	ldr.w	r2, [r0, #-4]
   14a10:	f851 3c04 	ldr.w	r3, [r1, #-4]
   14a14:	fa82 f54c 	uadd8	r5, r2, ip
   14a18:	ea82 0503 	eor.w	r5, r2, r3
   14a1c:	faa5 f58c 	sel	r5, r5, ip
   14a20:	2d00      	cmp	r5, #0
   14a22:	d0e8      	beq.n	149f6 <strcmp+0x10e>
   14a24:	ba2d      	rev	r5, r5
   14a26:	fab5 f485 	clz	r4, r5
   14a2a:	f024 0407 	bic.w	r4, r4, #7
   14a2e:	fa23 f104 	lsr.w	r1, r3, r4
   14a32:	fa22 f204 	lsr.w	r2, r2, r4
   14a36:	f002 00ff 	and.w	r0, r2, #255	; 0xff
   14a3a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   14a3e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14a42:	eba0 0001 	sub.w	r0, r0, r1
   14a46:	4770      	bx	lr
   14a48:	ea4f 04c4 	mov.w	r4, r4, lsl #3
   14a4c:	f020 0003 	bic.w	r0, r0, #3
   14a50:	f850 2b08 	ldr.w	r2, [r0], #8
   14a54:	f021 0103 	bic.w	r1, r1, #3
   14a58:	f851 3b08 	ldr.w	r3, [r1], #8
   14a5c:	fa0c f404 	lsl.w	r4, ip, r4
   14a60:	ea62 0204 	orn	r2, r2, r4
   14a64:	ea63 0304 	orn	r3, r3, r4
   14a68:	e7c9      	b.n	149fe <strcmp+0x116>
   14a6a:	f010 0403 	ands.w	r4, r0, #3
   14a6e:	d01a      	beq.n	14aa6 <strcmp+0x1be>
   14a70:	eba1 0104 	sub.w	r1, r1, r4
   14a74:	f020 0003 	bic.w	r0, r0, #3
   14a78:	07e4      	lsls	r4, r4, #31
   14a7a:	f850 2b04 	ldr.w	r2, [r0], #4
   14a7e:	d006      	beq.n	14a8e <strcmp+0x1a6>
   14a80:	d20f      	bcs.n	14aa2 <strcmp+0x1ba>
   14a82:	788b      	ldrb	r3, [r1, #2]
   14a84:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
   14a88:	1ae4      	subs	r4, r4, r3
   14a8a:	d106      	bne.n	14a9a <strcmp+0x1b2>
   14a8c:	b12b      	cbz	r3, 14a9a <strcmp+0x1b2>
   14a8e:	78cb      	ldrb	r3, [r1, #3]
   14a90:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
   14a94:	1ae4      	subs	r4, r4, r3
   14a96:	d100      	bne.n	14a9a <strcmp+0x1b2>
   14a98:	b91b      	cbnz	r3, 14aa2 <strcmp+0x1ba>
   14a9a:	4620      	mov	r0, r4
   14a9c:	f85d 4b10 	ldr.w	r4, [sp], #16
   14aa0:	4770      	bx	lr
   14aa2:	f101 0104 	add.w	r1, r1, #4
   14aa6:	f850 2b04 	ldr.w	r2, [r0], #4
   14aaa:	07cc      	lsls	r4, r1, #31
   14aac:	f021 0103 	bic.w	r1, r1, #3
   14ab0:	f851 3b04 	ldr.w	r3, [r1], #4
   14ab4:	d848      	bhi.n	14b48 <strcmp+0x260>
   14ab6:	d224      	bcs.n	14b02 <strcmp+0x21a>
   14ab8:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
   14abc:	fa82 f54c 	uadd8	r5, r2, ip
   14ac0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
   14ac4:	faa5 f58c 	sel	r5, r5, ip
   14ac8:	d10a      	bne.n	14ae0 <strcmp+0x1f8>
   14aca:	b965      	cbnz	r5, 14ae6 <strcmp+0x1fe>
   14acc:	f851 3b04 	ldr.w	r3, [r1], #4
   14ad0:	ea84 0402 	eor.w	r4, r4, r2
   14ad4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
   14ad8:	d10e      	bne.n	14af8 <strcmp+0x210>
   14ada:	f850 2b04 	ldr.w	r2, [r0], #4
   14ade:	e7eb      	b.n	14ab8 <strcmp+0x1d0>
   14ae0:	ea4f 2313 	mov.w	r3, r3, lsr #8
   14ae4:	e055      	b.n	14b92 <strcmp+0x2aa>
   14ae6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
   14aea:	d14d      	bne.n	14b88 <strcmp+0x2a0>
   14aec:	7808      	ldrb	r0, [r1, #0]
   14aee:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14af2:	f1c0 0000 	rsb	r0, r0, #0
   14af6:	4770      	bx	lr
   14af8:	ea4f 6212 	mov.w	r2, r2, lsr #24
   14afc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
   14b00:	e047      	b.n	14b92 <strcmp+0x2aa>
   14b02:	ea02 441c 	and.w	r4, r2, ip, lsr #16
   14b06:	fa82 f54c 	uadd8	r5, r2, ip
   14b0a:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
   14b0e:	faa5 f58c 	sel	r5, r5, ip
   14b12:	d10a      	bne.n	14b2a <strcmp+0x242>
   14b14:	b965      	cbnz	r5, 14b30 <strcmp+0x248>
   14b16:	f851 3b04 	ldr.w	r3, [r1], #4
   14b1a:	ea84 0402 	eor.w	r4, r4, r2
   14b1e:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
   14b22:	d10c      	bne.n	14b3e <strcmp+0x256>
   14b24:	f850 2b04 	ldr.w	r2, [r0], #4
   14b28:	e7eb      	b.n	14b02 <strcmp+0x21a>
   14b2a:	ea4f 4313 	mov.w	r3, r3, lsr #16
   14b2e:	e030      	b.n	14b92 <strcmp+0x2aa>
   14b30:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
   14b34:	d128      	bne.n	14b88 <strcmp+0x2a0>
   14b36:	880b      	ldrh	r3, [r1, #0]
   14b38:	ea4f 4212 	mov.w	r2, r2, lsr #16
   14b3c:	e029      	b.n	14b92 <strcmp+0x2aa>
   14b3e:	ea4f 4212 	mov.w	r2, r2, lsr #16
   14b42:	ea03 431c 	and.w	r3, r3, ip, lsr #16
   14b46:	e024      	b.n	14b92 <strcmp+0x2aa>
   14b48:	f002 04ff 	and.w	r4, r2, #255	; 0xff
   14b4c:	fa82 f54c 	uadd8	r5, r2, ip
   14b50:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
   14b54:	faa5 f58c 	sel	r5, r5, ip
   14b58:	d10a      	bne.n	14b70 <strcmp+0x288>
   14b5a:	b965      	cbnz	r5, 14b76 <strcmp+0x28e>
   14b5c:	f851 3b04 	ldr.w	r3, [r1], #4
   14b60:	ea84 0402 	eor.w	r4, r4, r2
   14b64:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
   14b68:	d109      	bne.n	14b7e <strcmp+0x296>
   14b6a:	f850 2b04 	ldr.w	r2, [r0], #4
   14b6e:	e7eb      	b.n	14b48 <strcmp+0x260>
   14b70:	ea4f 6313 	mov.w	r3, r3, lsr #24
   14b74:	e00d      	b.n	14b92 <strcmp+0x2aa>
   14b76:	f015 0fff 	tst.w	r5, #255	; 0xff
   14b7a:	d105      	bne.n	14b88 <strcmp+0x2a0>
   14b7c:	680b      	ldr	r3, [r1, #0]
   14b7e:	ea4f 2212 	mov.w	r2, r2, lsr #8
   14b82:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
   14b86:	e004      	b.n	14b92 <strcmp+0x2aa>
   14b88:	f04f 0000 	mov.w	r0, #0
   14b8c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14b90:	4770      	bx	lr
   14b92:	ba12      	rev	r2, r2
   14b94:	ba1b      	rev	r3, r3
   14b96:	fa82 f44c 	uadd8	r4, r2, ip
   14b9a:	ea82 0403 	eor.w	r4, r2, r3
   14b9e:	faa4 f58c 	sel	r5, r4, ip
   14ba2:	fab5 f485 	clz	r4, r5
   14ba6:	fa02 f204 	lsl.w	r2, r2, r4
   14baa:	fa03 f304 	lsl.w	r3, r3, r4
   14bae:	ea4f 6012 	mov.w	r0, r2, lsr #24
   14bb2:	e8fd 4504 	ldrd	r4, r5, [sp], #16
   14bb6:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
   14bba:	4770      	bx	lr

00014bbc <strcpy>:
   14bbc:	ea80 0201 	eor.w	r2, r0, r1
   14bc0:	4684      	mov	ip, r0
   14bc2:	f012 0f03 	tst.w	r2, #3
   14bc6:	d14f      	bne.n	14c68 <strcpy+0xac>
   14bc8:	f011 0f03 	tst.w	r1, #3
   14bcc:	d132      	bne.n	14c34 <strcpy+0x78>
   14bce:	f84d 4d04 	str.w	r4, [sp, #-4]!
   14bd2:	f011 0f04 	tst.w	r1, #4
   14bd6:	f851 3b04 	ldr.w	r3, [r1], #4
   14bda:	d00b      	beq.n	14bf4 <strcpy+0x38>
   14bdc:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   14be0:	439a      	bics	r2, r3
   14be2:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   14be6:	bf04      	itt	eq
   14be8:	f84c 3b04 	streq.w	r3, [ip], #4
   14bec:	f851 3b04 	ldreq.w	r3, [r1], #4
   14bf0:	d116      	bne.n	14c20 <strcpy+0x64>
   14bf2:	bf00      	nop
   14bf4:	f851 4b04 	ldr.w	r4, [r1], #4
   14bf8:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   14bfc:	439a      	bics	r2, r3
   14bfe:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   14c02:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   14c06:	d10b      	bne.n	14c20 <strcpy+0x64>
   14c08:	f84c 3b04 	str.w	r3, [ip], #4
   14c0c:	43a2      	bics	r2, r4
   14c0e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   14c12:	bf04      	itt	eq
   14c14:	f851 3b04 	ldreq.w	r3, [r1], #4
   14c18:	f84c 4b04 	streq.w	r4, [ip], #4
   14c1c:	d0ea      	beq.n	14bf4 <strcpy+0x38>
   14c1e:	4623      	mov	r3, r4
   14c20:	f80c 3b01 	strb.w	r3, [ip], #1
   14c24:	f013 0fff 	tst.w	r3, #255	; 0xff
   14c28:	ea4f 2333 	mov.w	r3, r3, ror #8
   14c2c:	d1f8      	bne.n	14c20 <strcpy+0x64>
   14c2e:	f85d 4b04 	ldr.w	r4, [sp], #4
   14c32:	4770      	bx	lr
   14c34:	f011 0f01 	tst.w	r1, #1
   14c38:	d006      	beq.n	14c48 <strcpy+0x8c>
   14c3a:	f811 2b01 	ldrb.w	r2, [r1], #1
   14c3e:	f80c 2b01 	strb.w	r2, [ip], #1
   14c42:	2a00      	cmp	r2, #0
   14c44:	bf08      	it	eq
   14c46:	4770      	bxeq	lr
   14c48:	f011 0f02 	tst.w	r1, #2
   14c4c:	d0bf      	beq.n	14bce <strcpy+0x12>
   14c4e:	f831 2b02 	ldrh.w	r2, [r1], #2
   14c52:	f012 0fff 	tst.w	r2, #255	; 0xff
   14c56:	bf16      	itet	ne
   14c58:	f82c 2b02 	strhne.w	r2, [ip], #2
   14c5c:	f88c 2000 	strbeq.w	r2, [ip]
   14c60:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   14c64:	d1b3      	bne.n	14bce <strcpy+0x12>
   14c66:	4770      	bx	lr
   14c68:	f811 2b01 	ldrb.w	r2, [r1], #1
   14c6c:	f80c 2b01 	strb.w	r2, [ip], #1
   14c70:	2a00      	cmp	r2, #0
   14c72:	d1f9      	bne.n	14c68 <strcpy+0xac>
   14c74:	4770      	bx	lr
   14c76:	bf00      	nop
	...

00014c80 <strlen>:
   14c80:	f890 f000 	pld	[r0]
   14c84:	e96d 4502 	strd	r4, r5, [sp, #-8]!
   14c88:	f020 0107 	bic.w	r1, r0, #7
   14c8c:	f06f 0c00 	mvn.w	ip, #0
   14c90:	f010 0407 	ands.w	r4, r0, #7
   14c94:	f891 f020 	pld	[r1, #32]
   14c98:	f040 8049 	bne.w	14d2e <strlen+0xae>
   14c9c:	f04f 0400 	mov.w	r4, #0
   14ca0:	f06f 0007 	mvn.w	r0, #7
   14ca4:	e9d1 2300 	ldrd	r2, r3, [r1]
   14ca8:	f891 f040 	pld	[r1, #64]	; 0x40
   14cac:	f100 0008 	add.w	r0, r0, #8
   14cb0:	fa82 f24c 	uadd8	r2, r2, ip
   14cb4:	faa4 f28c 	sel	r2, r4, ip
   14cb8:	fa83 f34c 	uadd8	r3, r3, ip
   14cbc:	faa2 f38c 	sel	r3, r2, ip
   14cc0:	bb4b      	cbnz	r3, 14d16 <strlen+0x96>
   14cc2:	e9d1 2302 	ldrd	r2, r3, [r1, #8]
   14cc6:	fa82 f24c 	uadd8	r2, r2, ip
   14cca:	f100 0008 	add.w	r0, r0, #8
   14cce:	faa4 f28c 	sel	r2, r4, ip
   14cd2:	fa83 f34c 	uadd8	r3, r3, ip
   14cd6:	faa2 f38c 	sel	r3, r2, ip
   14cda:	b9e3      	cbnz	r3, 14d16 <strlen+0x96>
   14cdc:	e9d1 2304 	ldrd	r2, r3, [r1, #16]
   14ce0:	fa82 f24c 	uadd8	r2, r2, ip
   14ce4:	f100 0008 	add.w	r0, r0, #8
   14ce8:	faa4 f28c 	sel	r2, r4, ip
   14cec:	fa83 f34c 	uadd8	r3, r3, ip
   14cf0:	faa2 f38c 	sel	r3, r2, ip
   14cf4:	b97b      	cbnz	r3, 14d16 <strlen+0x96>
   14cf6:	e9d1 2306 	ldrd	r2, r3, [r1, #24]
   14cfa:	f101 0120 	add.w	r1, r1, #32
   14cfe:	fa82 f24c 	uadd8	r2, r2, ip
   14d02:	f100 0008 	add.w	r0, r0, #8
   14d06:	faa4 f28c 	sel	r2, r4, ip
   14d0a:	fa83 f34c 	uadd8	r3, r3, ip
   14d0e:	faa2 f38c 	sel	r3, r2, ip
   14d12:	2b00      	cmp	r3, #0
   14d14:	d0c6      	beq.n	14ca4 <strlen+0x24>
   14d16:	2a00      	cmp	r2, #0
   14d18:	bf04      	itt	eq
   14d1a:	3004      	addeq	r0, #4
   14d1c:	461a      	moveq	r2, r3
   14d1e:	ba12      	rev	r2, r2
   14d20:	fab2 f282 	clz	r2, r2
   14d24:	e8fd 4502 	ldrd	r4, r5, [sp], #8
   14d28:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
   14d2c:	4770      	bx	lr
   14d2e:	e9d1 2300 	ldrd	r2, r3, [r1]
   14d32:	f004 0503 	and.w	r5, r4, #3
   14d36:	f1c4 0000 	rsb	r0, r4, #0
   14d3a:	ea4f 05c5 	mov.w	r5, r5, lsl #3
   14d3e:	f014 0f04 	tst.w	r4, #4
   14d42:	f891 f040 	pld	[r1, #64]	; 0x40
   14d46:	fa0c f505 	lsl.w	r5, ip, r5
   14d4a:	ea62 0205 	orn	r2, r2, r5
   14d4e:	bf1c      	itt	ne
   14d50:	ea63 0305 	ornne	r3, r3, r5
   14d54:	4662      	movne	r2, ip
   14d56:	f04f 0400 	mov.w	r4, #0
   14d5a:	e7a9      	b.n	14cb0 <strlen+0x30>

00014d5c <__swbuf_r>:
   14d5c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14d5e:	460d      	mov	r5, r1
   14d60:	4614      	mov	r4, r2
   14d62:	4606      	mov	r6, r0
   14d64:	b108      	cbz	r0, 14d6a <__swbuf_r+0xe>
   14d66:	6983      	ldr	r3, [r0, #24]
   14d68:	b343      	cbz	r3, 14dbc <__swbuf_r+0x60>
   14d6a:	4b25      	ldr	r3, [pc, #148]	; (14e00 <__swbuf_r+0xa4>)
   14d6c:	429c      	cmp	r4, r3
   14d6e:	d02a      	beq.n	14dc6 <__swbuf_r+0x6a>
   14d70:	4b24      	ldr	r3, [pc, #144]	; (14e04 <__swbuf_r+0xa8>)
   14d72:	429c      	cmp	r4, r3
   14d74:	d029      	beq.n	14dca <__swbuf_r+0x6e>
   14d76:	4b24      	ldr	r3, [pc, #144]	; (14e08 <__swbuf_r+0xac>)
   14d78:	429c      	cmp	r4, r3
   14d7a:	bf08      	it	eq
   14d7c:	68f4      	ldreq	r4, [r6, #12]
   14d7e:	89a3      	ldrh	r3, [r4, #12]
   14d80:	69a2      	ldr	r2, [r4, #24]
   14d82:	60a2      	str	r2, [r4, #8]
   14d84:	071a      	lsls	r2, r3, #28
   14d86:	d522      	bpl.n	14dce <__swbuf_r+0x72>
   14d88:	6923      	ldr	r3, [r4, #16]
   14d8a:	b303      	cbz	r3, 14dce <__swbuf_r+0x72>
   14d8c:	6822      	ldr	r2, [r4, #0]
   14d8e:	6961      	ldr	r1, [r4, #20]
   14d90:	1ad3      	subs	r3, r2, r3
   14d92:	b2ed      	uxtb	r5, r5
   14d94:	4299      	cmp	r1, r3
   14d96:	462f      	mov	r7, r5
   14d98:	dd29      	ble.n	14dee <__swbuf_r+0x92>
   14d9a:	3301      	adds	r3, #1
   14d9c:	68a1      	ldr	r1, [r4, #8]
   14d9e:	1c50      	adds	r0, r2, #1
   14da0:	3901      	subs	r1, #1
   14da2:	60a1      	str	r1, [r4, #8]
   14da4:	6020      	str	r0, [r4, #0]
   14da6:	7015      	strb	r5, [r2, #0]
   14da8:	6962      	ldr	r2, [r4, #20]
   14daa:	429a      	cmp	r2, r3
   14dac:	d016      	beq.n	14ddc <__swbuf_r+0x80>
   14dae:	89a3      	ldrh	r3, [r4, #12]
   14db0:	07db      	lsls	r3, r3, #31
   14db2:	d501      	bpl.n	14db8 <__swbuf_r+0x5c>
   14db4:	2d0a      	cmp	r5, #10
   14db6:	d011      	beq.n	14ddc <__swbuf_r+0x80>
   14db8:	4638      	mov	r0, r7
   14dba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14dbc:	f000 fa6e 	bl	1529c <__sinit>
   14dc0:	4b0f      	ldr	r3, [pc, #60]	; (14e00 <__swbuf_r+0xa4>)
   14dc2:	429c      	cmp	r4, r3
   14dc4:	d1d4      	bne.n	14d70 <__swbuf_r+0x14>
   14dc6:	6874      	ldr	r4, [r6, #4]
   14dc8:	e7d9      	b.n	14d7e <__swbuf_r+0x22>
   14dca:	68b4      	ldr	r4, [r6, #8]
   14dcc:	e7d7      	b.n	14d7e <__swbuf_r+0x22>
   14dce:	4621      	mov	r1, r4
   14dd0:	4630      	mov	r0, r6
   14dd2:	f000 f823 	bl	14e1c <__swsetup_r>
   14dd6:	b938      	cbnz	r0, 14de8 <__swbuf_r+0x8c>
   14dd8:	6923      	ldr	r3, [r4, #16]
   14dda:	e7d7      	b.n	14d8c <__swbuf_r+0x30>
   14ddc:	4621      	mov	r1, r4
   14dde:	4630      	mov	r0, r6
   14de0:	f000 f932 	bl	15048 <_fflush_r>
   14de4:	2800      	cmp	r0, #0
   14de6:	d0e7      	beq.n	14db8 <__swbuf_r+0x5c>
   14de8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   14dec:	e7e4      	b.n	14db8 <__swbuf_r+0x5c>
   14dee:	4621      	mov	r1, r4
   14df0:	4630      	mov	r0, r6
   14df2:	f000 f929 	bl	15048 <_fflush_r>
   14df6:	2800      	cmp	r0, #0
   14df8:	d1f6      	bne.n	14de8 <__swbuf_r+0x8c>
   14dfa:	6822      	ldr	r2, [r4, #0]
   14dfc:	2301      	movs	r3, #1
   14dfe:	e7cd      	b.n	14d9c <__swbuf_r+0x40>
   14e00:	000175b0 	.word	0x000175b0
   14e04:	00017590 	.word	0x00017590
   14e08:	00017570 	.word	0x00017570

00014e0c <__swbuf>:
   14e0c:	4b02      	ldr	r3, [pc, #8]	; (14e18 <__swbuf+0xc>)
   14e0e:	460a      	mov	r2, r1
   14e10:	4601      	mov	r1, r0
   14e12:	6818      	ldr	r0, [r3, #0]
   14e14:	f7ff bfa2 	b.w	14d5c <__swbuf_r>
   14e18:	2000054c 	.word	0x2000054c

00014e1c <__swsetup_r>:
   14e1c:	4b3b      	ldr	r3, [pc, #236]	; (14f0c <__swsetup_r+0xf0>)
   14e1e:	b570      	push	{r4, r5, r6, lr}
   14e20:	681d      	ldr	r5, [r3, #0]
   14e22:	4606      	mov	r6, r0
   14e24:	460c      	mov	r4, r1
   14e26:	b10d      	cbz	r5, 14e2c <__swsetup_r+0x10>
   14e28:	69ab      	ldr	r3, [r5, #24]
   14e2a:	b1db      	cbz	r3, 14e64 <__swsetup_r+0x48>
   14e2c:	4b38      	ldr	r3, [pc, #224]	; (14f10 <__swsetup_r+0xf4>)
   14e2e:	429c      	cmp	r4, r3
   14e30:	d01e      	beq.n	14e70 <__swsetup_r+0x54>
   14e32:	4b38      	ldr	r3, [pc, #224]	; (14f14 <__swsetup_r+0xf8>)
   14e34:	429c      	cmp	r4, r3
   14e36:	d04a      	beq.n	14ece <__swsetup_r+0xb2>
   14e38:	4b37      	ldr	r3, [pc, #220]	; (14f18 <__swsetup_r+0xfc>)
   14e3a:	429c      	cmp	r4, r3
   14e3c:	bf08      	it	eq
   14e3e:	68ec      	ldreq	r4, [r5, #12]
   14e40:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14e44:	b293      	uxth	r3, r2
   14e46:	0719      	lsls	r1, r3, #28
   14e48:	d518      	bpl.n	14e7c <__swsetup_r+0x60>
   14e4a:	6920      	ldr	r0, [r4, #16]
   14e4c:	b308      	cbz	r0, 14e92 <__swsetup_r+0x76>
   14e4e:	f013 0201 	ands.w	r2, r3, #1
   14e52:	d02c      	beq.n	14eae <__swsetup_r+0x92>
   14e54:	6963      	ldr	r3, [r4, #20]
   14e56:	2200      	movs	r2, #0
   14e58:	425b      	negs	r3, r3
   14e5a:	61a3      	str	r3, [r4, #24]
   14e5c:	60a2      	str	r2, [r4, #8]
   14e5e:	b360      	cbz	r0, 14eba <__swsetup_r+0x9e>
   14e60:	2000      	movs	r0, #0
   14e62:	bd70      	pop	{r4, r5, r6, pc}
   14e64:	4628      	mov	r0, r5
   14e66:	f000 fa19 	bl	1529c <__sinit>
   14e6a:	4b29      	ldr	r3, [pc, #164]	; (14f10 <__swsetup_r+0xf4>)
   14e6c:	429c      	cmp	r4, r3
   14e6e:	d1e0      	bne.n	14e32 <__swsetup_r+0x16>
   14e70:	686c      	ldr	r4, [r5, #4]
   14e72:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14e76:	b293      	uxth	r3, r2
   14e78:	0719      	lsls	r1, r3, #28
   14e7a:	d4e6      	bmi.n	14e4a <__swsetup_r+0x2e>
   14e7c:	06dd      	lsls	r5, r3, #27
   14e7e:	d53c      	bpl.n	14efa <__swsetup_r+0xde>
   14e80:	0758      	lsls	r0, r3, #29
   14e82:	d426      	bmi.n	14ed2 <__swsetup_r+0xb6>
   14e84:	6920      	ldr	r0, [r4, #16]
   14e86:	f042 0308 	orr.w	r3, r2, #8
   14e8a:	81a3      	strh	r3, [r4, #12]
   14e8c:	b29b      	uxth	r3, r3
   14e8e:	2800      	cmp	r0, #0
   14e90:	d1dd      	bne.n	14e4e <__swsetup_r+0x32>
   14e92:	f403 7220 	and.w	r2, r3, #640	; 0x280
   14e96:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
   14e9a:	d0d8      	beq.n	14e4e <__swsetup_r+0x32>
   14e9c:	4630      	mov	r0, r6
   14e9e:	4621      	mov	r1, r4
   14ea0:	f000 fa9a 	bl	153d8 <__smakebuf_r>
   14ea4:	89a3      	ldrh	r3, [r4, #12]
   14ea6:	6920      	ldr	r0, [r4, #16]
   14ea8:	f013 0201 	ands.w	r2, r3, #1
   14eac:	d1d2      	bne.n	14e54 <__swsetup_r+0x38>
   14eae:	0799      	lsls	r1, r3, #30
   14eb0:	bf58      	it	pl
   14eb2:	6962      	ldrpl	r2, [r4, #20]
   14eb4:	60a2      	str	r2, [r4, #8]
   14eb6:	2800      	cmp	r0, #0
   14eb8:	d1d2      	bne.n	14e60 <__swsetup_r+0x44>
   14eba:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14ebe:	061a      	lsls	r2, r3, #24
   14ec0:	d5cf      	bpl.n	14e62 <__swsetup_r+0x46>
   14ec2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14ec6:	81a3      	strh	r3, [r4, #12]
   14ec8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14ecc:	bd70      	pop	{r4, r5, r6, pc}
   14ece:	68ac      	ldr	r4, [r5, #8]
   14ed0:	e7b6      	b.n	14e40 <__swsetup_r+0x24>
   14ed2:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14ed4:	b151      	cbz	r1, 14eec <__swsetup_r+0xd0>
   14ed6:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14eda:	4299      	cmp	r1, r3
   14edc:	d004      	beq.n	14ee8 <__swsetup_r+0xcc>
   14ede:	4630      	mov	r0, r6
   14ee0:	f7ff f998 	bl	14214 <_free_r>
   14ee4:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14ee8:	2300      	movs	r3, #0
   14eea:	6363      	str	r3, [r4, #52]	; 0x34
   14eec:	2300      	movs	r3, #0
   14eee:	6920      	ldr	r0, [r4, #16]
   14ef0:	6063      	str	r3, [r4, #4]
   14ef2:	f022 0224 	bic.w	r2, r2, #36	; 0x24
   14ef6:	6020      	str	r0, [r4, #0]
   14ef8:	e7c5      	b.n	14e86 <__swsetup_r+0x6a>
   14efa:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   14efe:	2309      	movs	r3, #9
   14f00:	6033      	str	r3, [r6, #0]
   14f02:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14f06:	81a2      	strh	r2, [r4, #12]
   14f08:	bd70      	pop	{r4, r5, r6, pc}
   14f0a:	bf00      	nop
   14f0c:	2000054c 	.word	0x2000054c
   14f10:	000175b0 	.word	0x000175b0
   14f14:	00017590 	.word	0x00017590
   14f18:	00017570 	.word	0x00017570

00014f1c <__sflush_r>:
   14f1c:	898b      	ldrh	r3, [r1, #12]
   14f1e:	071a      	lsls	r2, r3, #28
   14f20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14f24:	460c      	mov	r4, r1
   14f26:	4680      	mov	r8, r0
   14f28:	d441      	bmi.n	14fae <__sflush_r+0x92>
   14f2a:	684a      	ldr	r2, [r1, #4]
   14f2c:	2a00      	cmp	r2, #0
   14f2e:	dd59      	ble.n	14fe4 <__sflush_r+0xc8>
   14f30:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   14f32:	2e00      	cmp	r6, #0
   14f34:	d053      	beq.n	14fde <__sflush_r+0xc2>
   14f36:	2200      	movs	r2, #0
   14f38:	f8d8 5000 	ldr.w	r5, [r8]
   14f3c:	6a21      	ldr	r1, [r4, #32]
   14f3e:	f8c8 2000 	str.w	r2, [r8]
   14f42:	f413 5280 	ands.w	r2, r3, #4096	; 0x1000
   14f46:	d151      	bne.n	14fec <__sflush_r+0xd0>
   14f48:	2301      	movs	r3, #1
   14f4a:	4640      	mov	r0, r8
   14f4c:	47b0      	blx	r6
   14f4e:	1c43      	adds	r3, r0, #1
   14f50:	d05f      	beq.n	15012 <__sflush_r+0xf6>
   14f52:	89a3      	ldrh	r3, [r4, #12]
   14f54:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   14f56:	6a21      	ldr	r1, [r4, #32]
   14f58:	075f      	lsls	r7, r3, #29
   14f5a:	d505      	bpl.n	14f68 <__sflush_r+0x4c>
   14f5c:	6862      	ldr	r2, [r4, #4]
   14f5e:	6b63      	ldr	r3, [r4, #52]	; 0x34
   14f60:	1a80      	subs	r0, r0, r2
   14f62:	b10b      	cbz	r3, 14f68 <__sflush_r+0x4c>
   14f64:	6c23      	ldr	r3, [r4, #64]	; 0x40
   14f66:	1ac0      	subs	r0, r0, r3
   14f68:	4602      	mov	r2, r0
   14f6a:	2300      	movs	r3, #0
   14f6c:	4640      	mov	r0, r8
   14f6e:	47b0      	blx	r6
   14f70:	1c46      	adds	r6, r0, #1
   14f72:	d145      	bne.n	15000 <__sflush_r+0xe4>
   14f74:	f8d8 3000 	ldr.w	r3, [r8]
   14f78:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14f7c:	2b00      	cmp	r3, #0
   14f7e:	d055      	beq.n	1502c <__sflush_r+0x110>
   14f80:	2b1d      	cmp	r3, #29
   14f82:	d001      	beq.n	14f88 <__sflush_r+0x6c>
   14f84:	2b16      	cmp	r3, #22
   14f86:	d15a      	bne.n	1503e <__sflush_r+0x122>
   14f88:	6923      	ldr	r3, [r4, #16]
   14f8a:	2200      	movs	r2, #0
   14f8c:	e9c4 3200 	strd	r3, r2, [r4]
   14f90:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14f92:	f8c8 5000 	str.w	r5, [r8]
   14f96:	b311      	cbz	r1, 14fde <__sflush_r+0xc2>
   14f98:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14f9c:	4299      	cmp	r1, r3
   14f9e:	d002      	beq.n	14fa6 <__sflush_r+0x8a>
   14fa0:	4640      	mov	r0, r8
   14fa2:	f7ff f937 	bl	14214 <_free_r>
   14fa6:	2000      	movs	r0, #0
   14fa8:	6360      	str	r0, [r4, #52]	; 0x34
   14faa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14fae:	690e      	ldr	r6, [r1, #16]
   14fb0:	b1ae      	cbz	r6, 14fde <__sflush_r+0xc2>
   14fb2:	680d      	ldr	r5, [r1, #0]
   14fb4:	600e      	str	r6, [r1, #0]
   14fb6:	0799      	lsls	r1, r3, #30
   14fb8:	bf0c      	ite	eq
   14fba:	6963      	ldreq	r3, [r4, #20]
   14fbc:	2300      	movne	r3, #0
   14fbe:	1bad      	subs	r5, r5, r6
   14fc0:	60a3      	str	r3, [r4, #8]
   14fc2:	e00a      	b.n	14fda <__sflush_r+0xbe>
   14fc4:	462b      	mov	r3, r5
   14fc6:	4632      	mov	r2, r6
   14fc8:	6aa7      	ldr	r7, [r4, #40]	; 0x28
   14fca:	6a21      	ldr	r1, [r4, #32]
   14fcc:	4640      	mov	r0, r8
   14fce:	47b8      	blx	r7
   14fd0:	2800      	cmp	r0, #0
   14fd2:	eba5 0500 	sub.w	r5, r5, r0
   14fd6:	4406      	add	r6, r0
   14fd8:	dd0a      	ble.n	14ff0 <__sflush_r+0xd4>
   14fda:	2d00      	cmp	r5, #0
   14fdc:	dcf2      	bgt.n	14fc4 <__sflush_r+0xa8>
   14fde:	2000      	movs	r0, #0
   14fe0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14fe4:	6c0a      	ldr	r2, [r1, #64]	; 0x40
   14fe6:	2a00      	cmp	r2, #0
   14fe8:	dca2      	bgt.n	14f30 <__sflush_r+0x14>
   14fea:	e7f8      	b.n	14fde <__sflush_r+0xc2>
   14fec:	6d60      	ldr	r0, [r4, #84]	; 0x54
   14fee:	e7b3      	b.n	14f58 <__sflush_r+0x3c>
   14ff0:	89a3      	ldrh	r3, [r4, #12]
   14ff2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14ff6:	81a3      	strh	r3, [r4, #12]
   14ff8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14ffc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15000:	6922      	ldr	r2, [r4, #16]
   15002:	89a3      	ldrh	r3, [r4, #12]
   15004:	6022      	str	r2, [r4, #0]
   15006:	2200      	movs	r2, #0
   15008:	6062      	str	r2, [r4, #4]
   1500a:	04da      	lsls	r2, r3, #19
   1500c:	d5c0      	bpl.n	14f90 <__sflush_r+0x74>
   1500e:	6560      	str	r0, [r4, #84]	; 0x54
   15010:	e7be      	b.n	14f90 <__sflush_r+0x74>
   15012:	f8d8 3000 	ldr.w	r3, [r8]
   15016:	2b00      	cmp	r3, #0
   15018:	d09b      	beq.n	14f52 <__sflush_r+0x36>
   1501a:	2b1d      	cmp	r3, #29
   1501c:	d00c      	beq.n	15038 <__sflush_r+0x11c>
   1501e:	2b16      	cmp	r3, #22
   15020:	d00a      	beq.n	15038 <__sflush_r+0x11c>
   15022:	89a3      	ldrh	r3, [r4, #12]
   15024:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   15028:	81a3      	strh	r3, [r4, #12]
   1502a:	e7d9      	b.n	14fe0 <__sflush_r+0xc4>
   1502c:	6921      	ldr	r1, [r4, #16]
   1502e:	e9c4 1300 	strd	r1, r3, [r4]
   15032:	04d3      	lsls	r3, r2, #19
   15034:	d5ac      	bpl.n	14f90 <__sflush_r+0x74>
   15036:	e7ea      	b.n	1500e <__sflush_r+0xf2>
   15038:	f8c8 5000 	str.w	r5, [r8]
   1503c:	e7cf      	b.n	14fde <__sflush_r+0xc2>
   1503e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   15042:	81a2      	strh	r2, [r4, #12]
   15044:	e7cc      	b.n	14fe0 <__sflush_r+0xc4>
   15046:	bf00      	nop

00015048 <_fflush_r>:
   15048:	690b      	ldr	r3, [r1, #16]
   1504a:	b323      	cbz	r3, 15096 <_fflush_r+0x4e>
   1504c:	b510      	push	{r4, lr}
   1504e:	4604      	mov	r4, r0
   15050:	b082      	sub	sp, #8
   15052:	b108      	cbz	r0, 15058 <_fflush_r+0x10>
   15054:	6983      	ldr	r3, [r0, #24]
   15056:	b1bb      	cbz	r3, 15088 <_fflush_r+0x40>
   15058:	4b10      	ldr	r3, [pc, #64]	; (1509c <_fflush_r+0x54>)
   1505a:	4299      	cmp	r1, r3
   1505c:	d012      	beq.n	15084 <_fflush_r+0x3c>
   1505e:	4b10      	ldr	r3, [pc, #64]	; (150a0 <_fflush_r+0x58>)
   15060:	4299      	cmp	r1, r3
   15062:	d016      	beq.n	15092 <_fflush_r+0x4a>
   15064:	4b0f      	ldr	r3, [pc, #60]	; (150a4 <_fflush_r+0x5c>)
   15066:	4299      	cmp	r1, r3
   15068:	bf08      	it	eq
   1506a:	68e1      	ldreq	r1, [r4, #12]
   1506c:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
   15070:	b12b      	cbz	r3, 1507e <_fflush_r+0x36>
   15072:	4620      	mov	r0, r4
   15074:	b002      	add	sp, #8
   15076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1507a:	f7ff bf4f 	b.w	14f1c <__sflush_r>
   1507e:	2000      	movs	r0, #0
   15080:	b002      	add	sp, #8
   15082:	bd10      	pop	{r4, pc}
   15084:	6861      	ldr	r1, [r4, #4]
   15086:	e7f1      	b.n	1506c <_fflush_r+0x24>
   15088:	9101      	str	r1, [sp, #4]
   1508a:	f000 f907 	bl	1529c <__sinit>
   1508e:	9901      	ldr	r1, [sp, #4]
   15090:	e7e2      	b.n	15058 <_fflush_r+0x10>
   15092:	68a1      	ldr	r1, [r4, #8]
   15094:	e7ea      	b.n	1506c <_fflush_r+0x24>
   15096:	2000      	movs	r0, #0
   15098:	4770      	bx	lr
   1509a:	bf00      	nop
   1509c:	000175b0 	.word	0x000175b0
   150a0:	00017590 	.word	0x00017590
   150a4:	00017570 	.word	0x00017570

000150a8 <fflush>:
   150a8:	b120      	cbz	r0, 150b4 <fflush+0xc>
   150aa:	4b05      	ldr	r3, [pc, #20]	; (150c0 <fflush+0x18>)
   150ac:	4601      	mov	r1, r0
   150ae:	6818      	ldr	r0, [r3, #0]
   150b0:	f7ff bfca 	b.w	15048 <_fflush_r>
   150b4:	4b03      	ldr	r3, [pc, #12]	; (150c4 <fflush+0x1c>)
   150b6:	4904      	ldr	r1, [pc, #16]	; (150c8 <fflush+0x20>)
   150b8:	6818      	ldr	r0, [r3, #0]
   150ba:	f000 b935 	b.w	15328 <_fwalk_reent>
   150be:	bf00      	nop
   150c0:	2000054c 	.word	0x2000054c
   150c4:	0001756c 	.word	0x0001756c
   150c8:	00015049 	.word	0x00015049

000150cc <__fp_lock>:
   150cc:	2000      	movs	r0, #0
   150ce:	4770      	bx	lr

000150d0 <_cleanup_r>:
   150d0:	4901      	ldr	r1, [pc, #4]	; (150d8 <_cleanup_r+0x8>)
   150d2:	f000 b929 	b.w	15328 <_fwalk_reent>
   150d6:	bf00      	nop
   150d8:	00015049 	.word	0x00015049

000150dc <__fp_unlock>:
   150dc:	2000      	movs	r0, #0
   150de:	4770      	bx	lr

000150e0 <__sfmoreglue>:
   150e0:	b570      	push	{r4, r5, r6, lr}
   150e2:	1e4a      	subs	r2, r1, #1
   150e4:	2568      	movs	r5, #104	; 0x68
   150e6:	fb05 f502 	mul.w	r5, r5, r2
   150ea:	460e      	mov	r6, r1
   150ec:	f105 0174 	add.w	r1, r5, #116	; 0x74
   150f0:	f7ff f8e6 	bl	142c0 <_malloc_r>
   150f4:	4604      	mov	r4, r0
   150f6:	b140      	cbz	r0, 1510a <__sfmoreglue+0x2a>
   150f8:	2100      	movs	r1, #0
   150fa:	300c      	adds	r0, #12
   150fc:	6066      	str	r6, [r4, #4]
   150fe:	f105 0268 	add.w	r2, r5, #104	; 0x68
   15102:	6021      	str	r1, [r4, #0]
   15104:	60a0      	str	r0, [r4, #8]
   15106:	f7ff f835 	bl	14174 <memset>
   1510a:	4620      	mov	r0, r4
   1510c:	bd70      	pop	{r4, r5, r6, pc}
   1510e:	bf00      	nop

00015110 <__sfp>:
   15110:	4b1e      	ldr	r3, [pc, #120]	; (1518c <__sfp+0x7c>)
   15112:	b570      	push	{r4, r5, r6, lr}
   15114:	681d      	ldr	r5, [r3, #0]
   15116:	69ab      	ldr	r3, [r5, #24]
   15118:	4606      	mov	r6, r0
   1511a:	b343      	cbz	r3, 1516e <__sfp+0x5e>
   1511c:	3548      	adds	r5, #72	; 0x48
   1511e:	e9d5 3401 	ldrd	r3, r4, [r5, #4]
   15122:	3b01      	subs	r3, #1
   15124:	d505      	bpl.n	15132 <__sfp+0x22>
   15126:	e01e      	b.n	15166 <__sfp+0x56>
   15128:	3b01      	subs	r3, #1
   1512a:	1c5a      	adds	r2, r3, #1
   1512c:	f104 0468 	add.w	r4, r4, #104	; 0x68
   15130:	d019      	beq.n	15166 <__sfp+0x56>
   15132:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   15136:	2a00      	cmp	r2, #0
   15138:	d1f6      	bne.n	15128 <__sfp+0x18>
   1513a:	2500      	movs	r5, #0
   1513c:	4b14      	ldr	r3, [pc, #80]	; (15190 <__sfp+0x80>)
   1513e:	6665      	str	r5, [r4, #100]	; 0x64
   15140:	e9c4 5500 	strd	r5, r5, [r4]
   15144:	60a5      	str	r5, [r4, #8]
   15146:	e9c4 5504 	strd	r5, r5, [r4, #16]
   1514a:	61a5      	str	r5, [r4, #24]
   1514c:	4629      	mov	r1, r5
   1514e:	60e3      	str	r3, [r4, #12]
   15150:	2208      	movs	r2, #8
   15152:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   15156:	f7ff f80d 	bl	14174 <memset>
   1515a:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   1515e:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   15162:	4620      	mov	r0, r4
   15164:	bd70      	pop	{r4, r5, r6, pc}
   15166:	682c      	ldr	r4, [r5, #0]
   15168:	b12c      	cbz	r4, 15176 <__sfp+0x66>
   1516a:	4625      	mov	r5, r4
   1516c:	e7d7      	b.n	1511e <__sfp+0xe>
   1516e:	4628      	mov	r0, r5
   15170:	f000 f810 	bl	15194 <__sinit.part.0>
   15174:	e7d2      	b.n	1511c <__sfp+0xc>
   15176:	2104      	movs	r1, #4
   15178:	4630      	mov	r0, r6
   1517a:	f7ff ffb1 	bl	150e0 <__sfmoreglue>
   1517e:	4604      	mov	r4, r0
   15180:	6028      	str	r0, [r5, #0]
   15182:	2800      	cmp	r0, #0
   15184:	d1f1      	bne.n	1516a <__sfp+0x5a>
   15186:	230c      	movs	r3, #12
   15188:	6033      	str	r3, [r6, #0]
   1518a:	e7ea      	b.n	15162 <__sfp+0x52>
   1518c:	0001756c 	.word	0x0001756c
   15190:	ffff0001 	.word	0xffff0001

00015194 <__sinit.part.0>:
   15194:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15198:	4b33      	ldr	r3, [pc, #204]	; (15268 <__sinit.part.0+0xd4>)
   1519a:	4934      	ldr	r1, [pc, #208]	; (1526c <__sinit.part.0+0xd8>)
   1519c:	681a      	ldr	r2, [r3, #0]
   1519e:	6281      	str	r1, [r0, #40]	; 0x28
   151a0:	4290      	cmp	r0, r2
   151a2:	f04f 0300 	mov.w	r3, #0
   151a6:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
   151aa:	6503      	str	r3, [r0, #80]	; 0x50
   151ac:	bf04      	itt	eq
   151ae:	2301      	moveq	r3, #1
   151b0:	6183      	streq	r3, [r0, #24]
   151b2:	4605      	mov	r5, r0
   151b4:	f7ff ffac 	bl	15110 <__sfp>
   151b8:	6068      	str	r0, [r5, #4]
   151ba:	4628      	mov	r0, r5
   151bc:	f7ff ffa8 	bl	15110 <__sfp>
   151c0:	60a8      	str	r0, [r5, #8]
   151c2:	4628      	mov	r0, r5
   151c4:	f7ff ffa4 	bl	15110 <__sfp>
   151c8:	686e      	ldr	r6, [r5, #4]
   151ca:	60e8      	str	r0, [r5, #12]
   151cc:	2400      	movs	r4, #0
   151ce:	2304      	movs	r3, #4
   151d0:	60f3      	str	r3, [r6, #12]
   151d2:	6674      	str	r4, [r6, #100]	; 0x64
   151d4:	e9c6 4400 	strd	r4, r4, [r6]
   151d8:	60b4      	str	r4, [r6, #8]
   151da:	e9c6 4404 	strd	r4, r4, [r6, #16]
   151de:	61b4      	str	r4, [r6, #24]
   151e0:	4621      	mov	r1, r4
   151e2:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   151e6:	2208      	movs	r2, #8
   151e8:	f7fe ffc4 	bl	14174 <memset>
   151ec:	f8df b088 	ldr.w	fp, [pc, #136]	; 15278 <__sinit.part.0+0xe4>
   151f0:	68af      	ldr	r7, [r5, #8]
   151f2:	f8df a088 	ldr.w	sl, [pc, #136]	; 1527c <__sinit.part.0+0xe8>
   151f6:	f8df 9088 	ldr.w	r9, [pc, #136]	; 15280 <__sinit.part.0+0xec>
   151fa:	f8df 8088 	ldr.w	r8, [pc, #136]	; 15284 <__sinit.part.0+0xf0>
   151fe:	4b1c      	ldr	r3, [pc, #112]	; (15270 <__sinit.part.0+0xdc>)
   15200:	f8c6 8030 	str.w	r8, [r6, #48]	; 0x30
   15204:	e9c6 6b08 	strd	r6, fp, [r6, #32]
   15208:	e9c6 a90a 	strd	sl, r9, [r6, #40]	; 0x28
   1520c:	4621      	mov	r1, r4
   1520e:	60fb      	str	r3, [r7, #12]
   15210:	2208      	movs	r2, #8
   15212:	667c      	str	r4, [r7, #100]	; 0x64
   15214:	e9c7 4400 	strd	r4, r4, [r7]
   15218:	60bc      	str	r4, [r7, #8]
   1521a:	e9c7 4404 	strd	r4, r4, [r7, #16]
   1521e:	61bc      	str	r4, [r7, #24]
   15220:	f107 005c 	add.w	r0, r7, #92	; 0x5c
   15224:	f7fe ffa6 	bl	14174 <memset>
   15228:	68ee      	ldr	r6, [r5, #12]
   1522a:	4b12      	ldr	r3, [pc, #72]	; (15274 <__sinit.part.0+0xe0>)
   1522c:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30
   15230:	e9c7 7b08 	strd	r7, fp, [r7, #32]
   15234:	e9c7 a90a 	strd	sl, r9, [r7, #40]	; 0x28
   15238:	4621      	mov	r1, r4
   1523a:	60f3      	str	r3, [r6, #12]
   1523c:	6674      	str	r4, [r6, #100]	; 0x64
   1523e:	e9c6 4400 	strd	r4, r4, [r6]
   15242:	60b4      	str	r4, [r6, #8]
   15244:	e9c6 4404 	strd	r4, r4, [r6, #16]
   15248:	61b4      	str	r4, [r6, #24]
   1524a:	f106 005c 	add.w	r0, r6, #92	; 0x5c
   1524e:	2208      	movs	r2, #8
   15250:	f7fe ff90 	bl	14174 <memset>
   15254:	2301      	movs	r3, #1
   15256:	e9c6 6b08 	strd	r6, fp, [r6, #32]
   1525a:	e9c6 a90a 	strd	sl, r9, [r6, #40]	; 0x28
   1525e:	f8c6 8030 	str.w	r8, [r6, #48]	; 0x30
   15262:	61ab      	str	r3, [r5, #24]
   15264:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15268:	0001756c 	.word	0x0001756c
   1526c:	000150d1 	.word	0x000150d1
   15270:	00010009 	.word	0x00010009
   15274:	00020012 	.word	0x00020012
   15278:	00015fc5 	.word	0x00015fc5
   1527c:	00015fed 	.word	0x00015fed
   15280:	0001602d 	.word	0x0001602d
   15284:	0001604d 	.word	0x0001604d

00015288 <_cleanup>:
   15288:	4b02      	ldr	r3, [pc, #8]	; (15294 <_cleanup+0xc>)
   1528a:	4903      	ldr	r1, [pc, #12]	; (15298 <_cleanup+0x10>)
   1528c:	6818      	ldr	r0, [r3, #0]
   1528e:	f000 b84b 	b.w	15328 <_fwalk_reent>
   15292:	bf00      	nop
   15294:	0001756c 	.word	0x0001756c
   15298:	00015049 	.word	0x00015049

0001529c <__sinit>:
   1529c:	6983      	ldr	r3, [r0, #24]
   1529e:	b903      	cbnz	r3, 152a2 <__sinit+0x6>
   152a0:	e778      	b.n	15194 <__sinit.part.0>
   152a2:	4770      	bx	lr

000152a4 <__sfp_lock_acquire>:
   152a4:	4770      	bx	lr
   152a6:	bf00      	nop

000152a8 <__sfp_lock_release>:
   152a8:	4770      	bx	lr
   152aa:	bf00      	nop

000152ac <__sinit_lock_acquire>:
   152ac:	4770      	bx	lr
   152ae:	bf00      	nop

000152b0 <__sinit_lock_release>:
   152b0:	4770      	bx	lr
   152b2:	bf00      	nop

000152b4 <__fp_lock_all>:
   152b4:	4b02      	ldr	r3, [pc, #8]	; (152c0 <__fp_lock_all+0xc>)
   152b6:	4903      	ldr	r1, [pc, #12]	; (152c4 <__fp_lock_all+0x10>)
   152b8:	6818      	ldr	r0, [r3, #0]
   152ba:	f000 b80f 	b.w	152dc <_fwalk>
   152be:	bf00      	nop
   152c0:	2000054c 	.word	0x2000054c
   152c4:	000150cd 	.word	0x000150cd

000152c8 <__fp_unlock_all>:
   152c8:	4b02      	ldr	r3, [pc, #8]	; (152d4 <__fp_unlock_all+0xc>)
   152ca:	4903      	ldr	r1, [pc, #12]	; (152d8 <__fp_unlock_all+0x10>)
   152cc:	6818      	ldr	r0, [r3, #0]
   152ce:	f000 b805 	b.w	152dc <_fwalk>
   152d2:	bf00      	nop
   152d4:	2000054c 	.word	0x2000054c
   152d8:	000150dd 	.word	0x000150dd

000152dc <_fwalk>:
   152dc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   152e0:	f110 0748 	adds.w	r7, r0, #72	; 0x48
   152e4:	d01b      	beq.n	1531e <_fwalk+0x42>
   152e6:	4688      	mov	r8, r1
   152e8:	2600      	movs	r6, #0
   152ea:	e9d7 5401 	ldrd	r5, r4, [r7, #4]
   152ee:	3d01      	subs	r5, #1
   152f0:	d40f      	bmi.n	15312 <_fwalk+0x36>
   152f2:	89a3      	ldrh	r3, [r4, #12]
   152f4:	2b01      	cmp	r3, #1
   152f6:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   152fa:	d906      	bls.n	1530a <_fwalk+0x2e>
   152fc:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
   15300:	3301      	adds	r3, #1
   15302:	4620      	mov	r0, r4
   15304:	d001      	beq.n	1530a <_fwalk+0x2e>
   15306:	47c0      	blx	r8
   15308:	4306      	orrs	r6, r0
   1530a:	1c6b      	adds	r3, r5, #1
   1530c:	f104 0468 	add.w	r4, r4, #104	; 0x68
   15310:	d1ef      	bne.n	152f2 <_fwalk+0x16>
   15312:	683f      	ldr	r7, [r7, #0]
   15314:	2f00      	cmp	r7, #0
   15316:	d1e8      	bne.n	152ea <_fwalk+0xe>
   15318:	4630      	mov	r0, r6
   1531a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   1531e:	463e      	mov	r6, r7
   15320:	4630      	mov	r0, r6
   15322:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15326:	bf00      	nop

00015328 <_fwalk_reent>:
   15328:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1532c:	f110 0748 	adds.w	r7, r0, #72	; 0x48
   15330:	d01f      	beq.n	15372 <_fwalk_reent+0x4a>
   15332:	4688      	mov	r8, r1
   15334:	4606      	mov	r6, r0
   15336:	f04f 0900 	mov.w	r9, #0
   1533a:	e9d7 5401 	ldrd	r5, r4, [r7, #4]
   1533e:	3d01      	subs	r5, #1
   15340:	d411      	bmi.n	15366 <_fwalk_reent+0x3e>
   15342:	89a3      	ldrh	r3, [r4, #12]
   15344:	2b01      	cmp	r3, #1
   15346:	f105 35ff 	add.w	r5, r5, #4294967295	; 0xffffffff
   1534a:	d908      	bls.n	1535e <_fwalk_reent+0x36>
   1534c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
   15350:	3301      	adds	r3, #1
   15352:	4621      	mov	r1, r4
   15354:	4630      	mov	r0, r6
   15356:	d002      	beq.n	1535e <_fwalk_reent+0x36>
   15358:	47c0      	blx	r8
   1535a:	ea49 0900 	orr.w	r9, r9, r0
   1535e:	1c6b      	adds	r3, r5, #1
   15360:	f104 0468 	add.w	r4, r4, #104	; 0x68
   15364:	d1ed      	bne.n	15342 <_fwalk_reent+0x1a>
   15366:	683f      	ldr	r7, [r7, #0]
   15368:	2f00      	cmp	r7, #0
   1536a:	d1e6      	bne.n	1533a <_fwalk_reent+0x12>
   1536c:	4648      	mov	r0, r9
   1536e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   15372:	46b9      	mov	r9, r7
   15374:	4648      	mov	r0, r9
   15376:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1537a:	bf00      	nop

0001537c <__swhatbuf_r>:
   1537c:	b570      	push	{r4, r5, r6, lr}
   1537e:	460c      	mov	r4, r1
   15380:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15384:	2900      	cmp	r1, #0
   15386:	b096      	sub	sp, #88	; 0x58
   15388:	4616      	mov	r6, r2
   1538a:	461d      	mov	r5, r3
   1538c:	db13      	blt.n	153b6 <__swhatbuf_r+0x3a>
   1538e:	466a      	mov	r2, sp
   15390:	f000 fe88 	bl	160a4 <_fstat_r>
   15394:	2800      	cmp	r0, #0
   15396:	db0e      	blt.n	153b6 <__swhatbuf_r+0x3a>
   15398:	9a01      	ldr	r2, [sp, #4]
   1539a:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   1539e:	f5a2 5200 	sub.w	r2, r2, #8192	; 0x2000
   153a2:	fab2 f282 	clz	r2, r2
   153a6:	0952      	lsrs	r2, r2, #5
   153a8:	f44f 6380 	mov.w	r3, #1024	; 0x400
   153ac:	2000      	movs	r0, #0
   153ae:	602a      	str	r2, [r5, #0]
   153b0:	6033      	str	r3, [r6, #0]
   153b2:	b016      	add	sp, #88	; 0x58
   153b4:	bd70      	pop	{r4, r5, r6, pc}
   153b6:	89a3      	ldrh	r3, [r4, #12]
   153b8:	2200      	movs	r2, #0
   153ba:	061b      	lsls	r3, r3, #24
   153bc:	602a      	str	r2, [r5, #0]
   153be:	d504      	bpl.n	153ca <__swhatbuf_r+0x4e>
   153c0:	2340      	movs	r3, #64	; 0x40
   153c2:	2000      	movs	r0, #0
   153c4:	6033      	str	r3, [r6, #0]
   153c6:	b016      	add	sp, #88	; 0x58
   153c8:	bd70      	pop	{r4, r5, r6, pc}
   153ca:	f44f 6380 	mov.w	r3, #1024	; 0x400
   153ce:	2000      	movs	r0, #0
   153d0:	6033      	str	r3, [r6, #0]
   153d2:	b016      	add	sp, #88	; 0x58
   153d4:	bd70      	pop	{r4, r5, r6, pc}
   153d6:	bf00      	nop

000153d8 <__smakebuf_r>:
   153d8:	898a      	ldrh	r2, [r1, #12]
   153da:	0792      	lsls	r2, r2, #30
   153dc:	460b      	mov	r3, r1
   153de:	d506      	bpl.n	153ee <__smakebuf_r+0x16>
   153e0:	f101 0247 	add.w	r2, r1, #71	; 0x47
   153e4:	2101      	movs	r1, #1
   153e6:	601a      	str	r2, [r3, #0]
   153e8:	e9c3 2104 	strd	r2, r1, [r3, #16]
   153ec:	4770      	bx	lr
   153ee:	b570      	push	{r4, r5, r6, lr}
   153f0:	b082      	sub	sp, #8
   153f2:	ab01      	add	r3, sp, #4
   153f4:	466a      	mov	r2, sp
   153f6:	460c      	mov	r4, r1
   153f8:	4606      	mov	r6, r0
   153fa:	f7ff ffbf 	bl	1537c <__swhatbuf_r>
   153fe:	9900      	ldr	r1, [sp, #0]
   15400:	4605      	mov	r5, r0
   15402:	4630      	mov	r0, r6
   15404:	f7fe ff5c 	bl	142c0 <_malloc_r>
   15408:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1540c:	b170      	cbz	r0, 1542c <__smakebuf_r+0x54>
   1540e:	4916      	ldr	r1, [pc, #88]	; (15468 <__smakebuf_r+0x90>)
   15410:	62b1      	str	r1, [r6, #40]	; 0x28
   15412:	9a01      	ldr	r2, [sp, #4]
   15414:	9900      	ldr	r1, [sp, #0]
   15416:	6020      	str	r0, [r4, #0]
   15418:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1541c:	81a3      	strh	r3, [r4, #12]
   1541e:	e9c4 0104 	strd	r0, r1, [r4, #16]
   15422:	b98a      	cbnz	r2, 15448 <__smakebuf_r+0x70>
   15424:	432b      	orrs	r3, r5
   15426:	81a3      	strh	r3, [r4, #12]
   15428:	b002      	add	sp, #8
   1542a:	bd70      	pop	{r4, r5, r6, pc}
   1542c:	059a      	lsls	r2, r3, #22
   1542e:	d4fb      	bmi.n	15428 <__smakebuf_r+0x50>
   15430:	f023 0303 	bic.w	r3, r3, #3
   15434:	f104 0247 	add.w	r2, r4, #71	; 0x47
   15438:	f043 0302 	orr.w	r3, r3, #2
   1543c:	2101      	movs	r1, #1
   1543e:	81a3      	strh	r3, [r4, #12]
   15440:	6022      	str	r2, [r4, #0]
   15442:	e9c4 2104 	strd	r2, r1, [r4, #16]
   15446:	e7ef      	b.n	15428 <__smakebuf_r+0x50>
   15448:	4630      	mov	r0, r6
   1544a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   1544e:	f000 ffc1 	bl	163d4 <_isatty_r>
   15452:	b910      	cbnz	r0, 1545a <__smakebuf_r+0x82>
   15454:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15458:	e7e4      	b.n	15424 <__smakebuf_r+0x4c>
   1545a:	89a3      	ldrh	r3, [r4, #12]
   1545c:	f023 0303 	bic.w	r3, r3, #3
   15460:	f043 0301 	orr.w	r3, r3, #1
   15464:	b21b      	sxth	r3, r3
   15466:	e7dd      	b.n	15424 <__smakebuf_r+0x4c>
   15468:	000150d1 	.word	0x000150d1

0001546c <__malloc_lock>:
   1546c:	4770      	bx	lr
   1546e:	bf00      	nop

00015470 <__malloc_unlock>:
   15470:	4770      	bx	lr
   15472:	bf00      	nop

00015474 <__ssputs_r>:
   15474:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15478:	688e      	ldr	r6, [r1, #8]
   1547a:	461d      	mov	r5, r3
   1547c:	42ae      	cmp	r6, r5
   1547e:	460c      	mov	r4, r1
   15480:	680b      	ldr	r3, [r1, #0]
   15482:	4617      	mov	r7, r2
   15484:	d836      	bhi.n	154f4 <__ssputs_r+0x80>
   15486:	4680      	mov	r8, r0
   15488:	8988      	ldrh	r0, [r1, #12]
   1548a:	f410 6f90 	tst.w	r0, #1152	; 0x480
   1548e:	d10e      	bne.n	154ae <__ssputs_r+0x3a>
   15490:	4635      	mov	r5, r6
   15492:	4618      	mov	r0, r3
   15494:	462a      	mov	r2, r5
   15496:	4639      	mov	r1, r7
   15498:	f001 f81a 	bl	164d0 <memmove>
   1549c:	68a2      	ldr	r2, [r4, #8]
   1549e:	6823      	ldr	r3, [r4, #0]
   154a0:	1b96      	subs	r6, r2, r6
   154a2:	442b      	add	r3, r5
   154a4:	60a6      	str	r6, [r4, #8]
   154a6:	6023      	str	r3, [r4, #0]
   154a8:	2000      	movs	r0, #0
   154aa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   154ae:	e9d1 1604 	ldrd	r1, r6, [r1, #16]
   154b2:	eb06 0646 	add.w	r6, r6, r6, lsl #1
   154b6:	eba3 0901 	sub.w	r9, r3, r1
   154ba:	eb06 76d6 	add.w	r6, r6, r6, lsr #31
   154be:	1c6b      	adds	r3, r5, #1
   154c0:	1076      	asrs	r6, r6, #1
   154c2:	444b      	add	r3, r9
   154c4:	42b3      	cmp	r3, r6
   154c6:	4632      	mov	r2, r6
   154c8:	bf84      	itt	hi
   154ca:	461e      	movhi	r6, r3
   154cc:	4632      	movhi	r2, r6
   154ce:	0543      	lsls	r3, r0, #21
   154d0:	d512      	bpl.n	154f8 <__ssputs_r+0x84>
   154d2:	4611      	mov	r1, r2
   154d4:	4640      	mov	r0, r8
   154d6:	f7fe fef3 	bl	142c0 <_malloc_r>
   154da:	4682      	mov	sl, r0
   154dc:	b300      	cbz	r0, 15520 <__ssputs_r+0xac>
   154de:	464a      	mov	r2, r9
   154e0:	6921      	ldr	r1, [r4, #16]
   154e2:	f7fe fdad 	bl	14040 <memcpy>
   154e6:	89a3      	ldrh	r3, [r4, #12]
   154e8:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   154ec:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   154f0:	81a3      	strh	r3, [r4, #12]
   154f2:	e006      	b.n	15502 <__ssputs_r+0x8e>
   154f4:	462e      	mov	r6, r5
   154f6:	e7cc      	b.n	15492 <__ssputs_r+0x1e>
   154f8:	4640      	mov	r0, r8
   154fa:	f001 f851 	bl	165a0 <_realloc_r>
   154fe:	4682      	mov	sl, r0
   15500:	b150      	cbz	r0, 15518 <__ssputs_r+0xa4>
   15502:	eba6 0209 	sub.w	r2, r6, r9
   15506:	eb0a 0309 	add.w	r3, sl, r9
   1550a:	6166      	str	r6, [r4, #20]
   1550c:	f8c4 a010 	str.w	sl, [r4, #16]
   15510:	6023      	str	r3, [r4, #0]
   15512:	60a2      	str	r2, [r4, #8]
   15514:	462e      	mov	r6, r5
   15516:	e7bc      	b.n	15492 <__ssputs_r+0x1e>
   15518:	6921      	ldr	r1, [r4, #16]
   1551a:	4640      	mov	r0, r8
   1551c:	f7fe fe7a 	bl	14214 <_free_r>
   15520:	230c      	movs	r3, #12
   15522:	f8c8 3000 	str.w	r3, [r8]
   15526:	89a3      	ldrh	r3, [r4, #12]
   15528:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1552c:	81a3      	strh	r3, [r4, #12]
   1552e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15532:	e7ba      	b.n	154aa <__ssputs_r+0x36>

00015534 <__ssprint_r>:
   15534:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15538:	6893      	ldr	r3, [r2, #8]
   1553a:	b083      	sub	sp, #12
   1553c:	4690      	mov	r8, r2
   1553e:	2b00      	cmp	r3, #0
   15540:	d06d      	beq.n	1561e <__ssprint_r+0xea>
   15542:	6817      	ldr	r7, [r2, #0]
   15544:	688d      	ldr	r5, [r1, #8]
   15546:	4682      	mov	sl, r0
   15548:	460c      	mov	r4, r1
   1554a:	6808      	ldr	r0, [r1, #0]
   1554c:	3708      	adds	r7, #8
   1554e:	e043      	b.n	155d8 <__ssprint_r+0xa4>
   15550:	89a3      	ldrh	r3, [r4, #12]
   15552:	f413 6f90 	tst.w	r3, #1152	; 0x480
   15556:	d02e      	beq.n	155b6 <__ssprint_r+0x82>
   15558:	e9d4 1504 	ldrd	r1, r5, [r4, #16]
   1555c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   15560:	eba0 0b01 	sub.w	fp, r0, r1
   15564:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   15568:	eb0b 0006 	add.w	r0, fp, r6
   1556c:	106d      	asrs	r5, r5, #1
   1556e:	3001      	adds	r0, #1
   15570:	42a8      	cmp	r0, r5
   15572:	462a      	mov	r2, r5
   15574:	bf84      	itt	hi
   15576:	4605      	movhi	r5, r0
   15578:	462a      	movhi	r2, r5
   1557a:	055b      	lsls	r3, r3, #21
   1557c:	d536      	bpl.n	155ec <__ssprint_r+0xb8>
   1557e:	4611      	mov	r1, r2
   15580:	4650      	mov	r0, sl
   15582:	f7fe fe9d 	bl	142c0 <_malloc_r>
   15586:	2800      	cmp	r0, #0
   15588:	d03a      	beq.n	15600 <__ssprint_r+0xcc>
   1558a:	465a      	mov	r2, fp
   1558c:	6921      	ldr	r1, [r4, #16]
   1558e:	9001      	str	r0, [sp, #4]
   15590:	f7fe fd56 	bl	14040 <memcpy>
   15594:	89a2      	ldrh	r2, [r4, #12]
   15596:	9b01      	ldr	r3, [sp, #4]
   15598:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   1559c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   155a0:	81a2      	strh	r2, [r4, #12]
   155a2:	eba5 020b 	sub.w	r2, r5, fp
   155a6:	eb03 000b 	add.w	r0, r3, fp
   155aa:	6165      	str	r5, [r4, #20]
   155ac:	6123      	str	r3, [r4, #16]
   155ae:	6020      	str	r0, [r4, #0]
   155b0:	60a2      	str	r2, [r4, #8]
   155b2:	4635      	mov	r5, r6
   155b4:	46b3      	mov	fp, r6
   155b6:	465a      	mov	r2, fp
   155b8:	4649      	mov	r1, r9
   155ba:	f000 ff89 	bl	164d0 <memmove>
   155be:	f8d8 3008 	ldr.w	r3, [r8, #8]
   155c2:	68a2      	ldr	r2, [r4, #8]
   155c4:	6820      	ldr	r0, [r4, #0]
   155c6:	1b55      	subs	r5, r2, r5
   155c8:	4458      	add	r0, fp
   155ca:	1b9e      	subs	r6, r3, r6
   155cc:	60a5      	str	r5, [r4, #8]
   155ce:	6020      	str	r0, [r4, #0]
   155d0:	f8c8 6008 	str.w	r6, [r8, #8]
   155d4:	b31e      	cbz	r6, 1561e <__ssprint_r+0xea>
   155d6:	3708      	adds	r7, #8
   155d8:	e957 9602 	ldrd	r9, r6, [r7, #-8]
   155dc:	46ab      	mov	fp, r5
   155de:	2e00      	cmp	r6, #0
   155e0:	d0f9      	beq.n	155d6 <__ssprint_r+0xa2>
   155e2:	42ae      	cmp	r6, r5
   155e4:	d2b4      	bcs.n	15550 <__ssprint_r+0x1c>
   155e6:	4635      	mov	r5, r6
   155e8:	46b3      	mov	fp, r6
   155ea:	e7e4      	b.n	155b6 <__ssprint_r+0x82>
   155ec:	4650      	mov	r0, sl
   155ee:	f000 ffd7 	bl	165a0 <_realloc_r>
   155f2:	4603      	mov	r3, r0
   155f4:	2800      	cmp	r0, #0
   155f6:	d1d4      	bne.n	155a2 <__ssprint_r+0x6e>
   155f8:	6921      	ldr	r1, [r4, #16]
   155fa:	4650      	mov	r0, sl
   155fc:	f7fe fe0a 	bl	14214 <_free_r>
   15600:	230c      	movs	r3, #12
   15602:	f8ca 3000 	str.w	r3, [sl]
   15606:	89a3      	ldrh	r3, [r4, #12]
   15608:	2200      	movs	r2, #0
   1560a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   1560e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15612:	81a3      	strh	r3, [r4, #12]
   15614:	e9c8 2201 	strd	r2, r2, [r8, #4]
   15618:	b003      	add	sp, #12
   1561a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1561e:	2000      	movs	r0, #0
   15620:	f8c8 0004 	str.w	r0, [r8, #4]
   15624:	b003      	add	sp, #12
   15626:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1562a:	bf00      	nop

0001562c <_svfiprintf_r>:
   1562c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15630:	4690      	mov	r8, r2
   15632:	898a      	ldrh	r2, [r1, #12]
   15634:	b09f      	sub	sp, #124	; 0x7c
   15636:	0614      	lsls	r4, r2, #24
   15638:	468b      	mov	fp, r1
   1563a:	9002      	str	r0, [sp, #8]
   1563c:	d503      	bpl.n	15646 <_svfiprintf_r+0x1a>
   1563e:	690a      	ldr	r2, [r1, #16]
   15640:	2a00      	cmp	r2, #0
   15642:	f000 810b 	beq.w	1585c <_svfiprintf_r+0x230>
   15646:	9305      	str	r3, [sp, #20]
   15648:	2330      	movs	r3, #48	; 0x30
   1564a:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
   1564e:	f898 3000 	ldrb.w	r3, [r8]
   15652:	4e8e      	ldr	r6, [pc, #568]	; (1588c <_svfiprintf_r+0x260>)
   15654:	2100      	movs	r1, #0
   15656:	2220      	movs	r2, #32
   15658:	910b      	str	r1, [sp, #44]	; 0x2c
   1565a:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   1565e:	2701      	movs	r7, #1
   15660:	2b00      	cmp	r3, #0
   15662:	f000 8084 	beq.w	1576e <_svfiprintf_r+0x142>
   15666:	2b25      	cmp	r3, #37	; 0x25
   15668:	f000 80f6 	beq.w	15858 <_svfiprintf_r+0x22c>
   1566c:	4645      	mov	r5, r8
   1566e:	e003      	b.n	15678 <_svfiprintf_r+0x4c>
   15670:	2b25      	cmp	r3, #37	; 0x25
   15672:	f000 8086 	beq.w	15782 <_svfiprintf_r+0x156>
   15676:	4625      	mov	r5, r4
   15678:	786b      	ldrb	r3, [r5, #1]
   1567a:	1c6c      	adds	r4, r5, #1
   1567c:	2b00      	cmp	r3, #0
   1567e:	d1f7      	bne.n	15670 <_svfiprintf_r+0x44>
   15680:	ebb4 0a08 	subs.w	sl, r4, r8
   15684:	d073      	beq.n	1576e <_svfiprintf_r+0x142>
   15686:	4642      	mov	r2, r8
   15688:	4653      	mov	r3, sl
   1568a:	4659      	mov	r1, fp
   1568c:	9802      	ldr	r0, [sp, #8]
   1568e:	f7ff fef1 	bl	15474 <__ssputs_r>
   15692:	3001      	adds	r0, #1
   15694:	d06b      	beq.n	1576e <_svfiprintf_r+0x142>
   15696:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15698:	786a      	ldrb	r2, [r5, #1]
   1569a:	4453      	add	r3, sl
   1569c:	930b      	str	r3, [sp, #44]	; 0x2c
   1569e:	2a00      	cmp	r2, #0
   156a0:	d065      	beq.n	1576e <_svfiprintf_r+0x142>
   156a2:	2300      	movs	r3, #0
   156a4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   156a8:	3401      	adds	r4, #1
   156aa:	9306      	str	r3, [sp, #24]
   156ac:	e9cd 3308 	strd	r3, r3, [sp, #32]
   156b0:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
   156b4:	931c      	str	r3, [sp, #112]	; 0x70
   156b6:	9207      	str	r2, [sp, #28]
   156b8:	e005      	b.n	156c6 <_svfiprintf_r+0x9a>
   156ba:	9a06      	ldr	r2, [sp, #24]
   156bc:	fa07 f303 	lsl.w	r3, r7, r3
   156c0:	4313      	orrs	r3, r2
   156c2:	462c      	mov	r4, r5
   156c4:	9306      	str	r3, [sp, #24]
   156c6:	4625      	mov	r5, r4
   156c8:	2205      	movs	r2, #5
   156ca:	f815 1b01 	ldrb.w	r1, [r5], #1
   156ce:	4630      	mov	r0, r6
   156d0:	f000 feae 	bl	16430 <memchr>
   156d4:	46aa      	mov	sl, r5
   156d6:	1b83      	subs	r3, r0, r6
   156d8:	2800      	cmp	r0, #0
   156da:	d1ee      	bne.n	156ba <_svfiprintf_r+0x8e>
   156dc:	9b06      	ldr	r3, [sp, #24]
   156de:	06d9      	lsls	r1, r3, #27
   156e0:	bf44      	itt	mi
   156e2:	2220      	movmi	r2, #32
   156e4:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   156e8:	7821      	ldrb	r1, [r4, #0]
   156ea:	071a      	lsls	r2, r3, #28
   156ec:	bf44      	itt	mi
   156ee:	222b      	movmi	r2, #43	; 0x2b
   156f0:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   156f4:	292a      	cmp	r1, #42	; 0x2a
   156f6:	d148      	bne.n	1578a <_svfiprintf_r+0x15e>
   156f8:	9a05      	ldr	r2, [sp, #20]
   156fa:	6811      	ldr	r1, [r2, #0]
   156fc:	3204      	adds	r2, #4
   156fe:	2900      	cmp	r1, #0
   15700:	9205      	str	r2, [sp, #20]
   15702:	db7e      	blt.n	15802 <_svfiprintf_r+0x1d6>
   15704:	9109      	str	r1, [sp, #36]	; 0x24
   15706:	7861      	ldrb	r1, [r4, #1]
   15708:	1ca5      	adds	r5, r4, #2
   1570a:	292e      	cmp	r1, #46	; 0x2e
   1570c:	d056      	beq.n	157bc <_svfiprintf_r+0x190>
   1570e:	4c60      	ldr	r4, [pc, #384]	; (15890 <_svfiprintf_r+0x264>)
   15710:	2203      	movs	r2, #3
   15712:	4620      	mov	r0, r4
   15714:	f000 fe8c 	bl	16430 <memchr>
   15718:	2800      	cmp	r0, #0
   1571a:	d068      	beq.n	157ee <_svfiprintf_r+0x1c2>
   1571c:	1b00      	subs	r0, r0, r4
   1571e:	9b06      	ldr	r3, [sp, #24]
   15720:	2440      	movs	r4, #64	; 0x40
   15722:	fa04 f000 	lsl.w	r0, r4, r0
   15726:	4303      	orrs	r3, r0
   15728:	9306      	str	r3, [sp, #24]
   1572a:	f105 0801 	add.w	r8, r5, #1
   1572e:	7829      	ldrb	r1, [r5, #0]
   15730:	4858      	ldr	r0, [pc, #352]	; (15894 <_svfiprintf_r+0x268>)
   15732:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   15736:	2206      	movs	r2, #6
   15738:	f000 fe7a 	bl	16430 <memchr>
   1573c:	2800      	cmp	r0, #0
   1573e:	d066      	beq.n	1580e <_svfiprintf_r+0x1e2>
   15740:	4b55      	ldr	r3, [pc, #340]	; (15898 <_svfiprintf_r+0x26c>)
   15742:	2b00      	cmp	r3, #0
   15744:	d056      	beq.n	157f4 <_svfiprintf_r+0x1c8>
   15746:	ab05      	add	r3, sp, #20
   15748:	9300      	str	r3, [sp, #0]
   1574a:	465a      	mov	r2, fp
   1574c:	4b53      	ldr	r3, [pc, #332]	; (1589c <_svfiprintf_r+0x270>)
   1574e:	9802      	ldr	r0, [sp, #8]
   15750:	a906      	add	r1, sp, #24
   15752:	f3af 8000 	nop.w
   15756:	4681      	mov	r9, r0
   15758:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   1575c:	d007      	beq.n	1576e <_svfiprintf_r+0x142>
   1575e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15760:	444b      	add	r3, r9
   15762:	930b      	str	r3, [sp, #44]	; 0x2c
   15764:	f898 3000 	ldrb.w	r3, [r8]
   15768:	2b00      	cmp	r3, #0
   1576a:	f47f af7c 	bne.w	15666 <_svfiprintf_r+0x3a>
   1576e:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15772:	065b      	lsls	r3, r3, #25
   15774:	bf54      	ite	pl
   15776:	980b      	ldrpl	r0, [sp, #44]	; 0x2c
   15778:	f04f 30ff 	movmi.w	r0, #4294967295	; 0xffffffff
   1577c:	b01f      	add	sp, #124	; 0x7c
   1577e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15782:	ebb4 0a08 	subs.w	sl, r4, r8
   15786:	d08c      	beq.n	156a2 <_svfiprintf_r+0x76>
   15788:	e77d      	b.n	15686 <_svfiprintf_r+0x5a>
   1578a:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   1578e:	2a09      	cmp	r2, #9
   15790:	bf88      	it	hi
   15792:	46a2      	movhi	sl, r4
   15794:	d8b9      	bhi.n	1570a <_svfiprintf_r+0xde>
   15796:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15798:	e001      	b.n	1579e <_svfiprintf_r+0x172>
   1579a:	462c      	mov	r4, r5
   1579c:	3501      	adds	r5, #1
   1579e:	7829      	ldrb	r1, [r5, #0]
   157a0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   157a4:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   157a8:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   157ac:	2a09      	cmp	r2, #9
   157ae:	46aa      	mov	sl, r5
   157b0:	d9f3      	bls.n	1579a <_svfiprintf_r+0x16e>
   157b2:	292e      	cmp	r1, #46	; 0x2e
   157b4:	f104 0502 	add.w	r5, r4, #2
   157b8:	9309      	str	r3, [sp, #36]	; 0x24
   157ba:	d1a8      	bne.n	1570e <_svfiprintf_r+0xe2>
   157bc:	f89a 1001 	ldrb.w	r1, [sl, #1]
   157c0:	292a      	cmp	r1, #42	; 0x2a
   157c2:	d12e      	bne.n	15822 <_svfiprintf_r+0x1f6>
   157c4:	9b05      	ldr	r3, [sp, #20]
   157c6:	f89a 1002 	ldrb.w	r1, [sl, #2]
   157ca:	681a      	ldr	r2, [r3, #0]
   157cc:	9207      	str	r2, [sp, #28]
   157ce:	3304      	adds	r3, #4
   157d0:	2a00      	cmp	r2, #0
   157d2:	9305      	str	r3, [sp, #20]
   157d4:	f10a 0503 	add.w	r5, sl, #3
   157d8:	f10a 0302 	add.w	r3, sl, #2
   157dc:	db37      	blt.n	1584e <_svfiprintf_r+0x222>
   157de:	4c2c      	ldr	r4, [pc, #176]	; (15890 <_svfiprintf_r+0x264>)
   157e0:	2203      	movs	r2, #3
   157e2:	4620      	mov	r0, r4
   157e4:	469a      	mov	sl, r3
   157e6:	f000 fe23 	bl	16430 <memchr>
   157ea:	2800      	cmp	r0, #0
   157ec:	d196      	bne.n	1571c <_svfiprintf_r+0xf0>
   157ee:	46a8      	mov	r8, r5
   157f0:	4655      	mov	r5, sl
   157f2:	e79c      	b.n	1572e <_svfiprintf_r+0x102>
   157f4:	9b05      	ldr	r3, [sp, #20]
   157f6:	3307      	adds	r3, #7
   157f8:	f023 0307 	bic.w	r3, r3, #7
   157fc:	3308      	adds	r3, #8
   157fe:	9305      	str	r3, [sp, #20]
   15800:	e7ad      	b.n	1575e <_svfiprintf_r+0x132>
   15802:	4249      	negs	r1, r1
   15804:	f043 0302 	orr.w	r3, r3, #2
   15808:	9109      	str	r1, [sp, #36]	; 0x24
   1580a:	9306      	str	r3, [sp, #24]
   1580c:	e77b      	b.n	15706 <_svfiprintf_r+0xda>
   1580e:	ab05      	add	r3, sp, #20
   15810:	9300      	str	r3, [sp, #0]
   15812:	465a      	mov	r2, fp
   15814:	4b21      	ldr	r3, [pc, #132]	; (1589c <_svfiprintf_r+0x270>)
   15816:	9802      	ldr	r0, [sp, #8]
   15818:	a906      	add	r1, sp, #24
   1581a:	f000 fa87 	bl	15d2c <_printf_i>
   1581e:	4681      	mov	r9, r0
   15820:	e79a      	b.n	15758 <_svfiprintf_r+0x12c>
   15822:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15826:	2300      	movs	r3, #0
   15828:	2a09      	cmp	r2, #9
   1582a:	9307      	str	r3, [sp, #28]
   1582c:	d901      	bls.n	15832 <_svfiprintf_r+0x206>
   1582e:	e023      	b.n	15878 <_svfiprintf_r+0x24c>
   15830:	4655      	mov	r5, sl
   15832:	7869      	ldrb	r1, [r5, #1]
   15834:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15838:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   1583c:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15840:	2a09      	cmp	r2, #9
   15842:	f105 0a01 	add.w	sl, r5, #1
   15846:	d9f3      	bls.n	15830 <_svfiprintf_r+0x204>
   15848:	3502      	adds	r5, #2
   1584a:	9307      	str	r3, [sp, #28]
   1584c:	e75f      	b.n	1570e <_svfiprintf_r+0xe2>
   1584e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15852:	469a      	mov	sl, r3
   15854:	9207      	str	r2, [sp, #28]
   15856:	e75a      	b.n	1570e <_svfiprintf_r+0xe2>
   15858:	4644      	mov	r4, r8
   1585a:	e722      	b.n	156a2 <_svfiprintf_r+0x76>
   1585c:	2140      	movs	r1, #64	; 0x40
   1585e:	9303      	str	r3, [sp, #12]
   15860:	f7fe fd2e 	bl	142c0 <_malloc_r>
   15864:	9b03      	ldr	r3, [sp, #12]
   15866:	f8cb 0000 	str.w	r0, [fp]
   1586a:	f8cb 0010 	str.w	r0, [fp, #16]
   1586e:	b130      	cbz	r0, 1587e <_svfiprintf_r+0x252>
   15870:	2240      	movs	r2, #64	; 0x40
   15872:	f8cb 2014 	str.w	r2, [fp, #20]
   15876:	e6e6      	b.n	15646 <_svfiprintf_r+0x1a>
   15878:	46aa      	mov	sl, r5
   1587a:	3501      	adds	r5, #1
   1587c:	e747      	b.n	1570e <_svfiprintf_r+0xe2>
   1587e:	9a02      	ldr	r2, [sp, #8]
   15880:	230c      	movs	r3, #12
   15882:	6013      	str	r3, [r2, #0]
   15884:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15888:	e778      	b.n	1577c <_svfiprintf_r+0x150>
   1588a:	bf00      	nop
   1588c:	000175d0 	.word	0x000175d0
   15890:	000175d8 	.word	0x000175d8
   15894:	000175dc 	.word	0x000175dc
   15898:	00000000 	.word	0x00000000
   1589c:	00015475 	.word	0x00015475

000158a0 <__sfputc_r>:
   158a0:	6893      	ldr	r3, [r2, #8]
   158a2:	3b01      	subs	r3, #1
   158a4:	2b00      	cmp	r3, #0
   158a6:	6093      	str	r3, [r2, #8]
   158a8:	da0f      	bge.n	158ca <__sfputc_r+0x2a>
   158aa:	b410      	push	{r4}
   158ac:	6994      	ldr	r4, [r2, #24]
   158ae:	42a3      	cmp	r3, r4
   158b0:	db08      	blt.n	158c4 <__sfputc_r+0x24>
   158b2:	290a      	cmp	r1, #10
   158b4:	d006      	beq.n	158c4 <__sfputc_r+0x24>
   158b6:	6813      	ldr	r3, [r2, #0]
   158b8:	1c58      	adds	r0, r3, #1
   158ba:	6010      	str	r0, [r2, #0]
   158bc:	7019      	strb	r1, [r3, #0]
   158be:	4608      	mov	r0, r1
   158c0:	bc10      	pop	{r4}
   158c2:	4770      	bx	lr
   158c4:	bc10      	pop	{r4}
   158c6:	f7ff ba49 	b.w	14d5c <__swbuf_r>
   158ca:	6813      	ldr	r3, [r2, #0]
   158cc:	1c58      	adds	r0, r3, #1
   158ce:	6010      	str	r0, [r2, #0]
   158d0:	7019      	strb	r1, [r3, #0]
   158d2:	4608      	mov	r0, r1
   158d4:	4770      	bx	lr
   158d6:	bf00      	nop

000158d8 <__sfputs_r>:
   158d8:	b19b      	cbz	r3, 15902 <__sfputs_r+0x2a>
   158da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   158dc:	4413      	add	r3, r2
   158de:	460f      	mov	r7, r1
   158e0:	4606      	mov	r6, r0
   158e2:	1e5d      	subs	r5, r3, #1
   158e4:	1e54      	subs	r4, r2, #1
   158e6:	e001      	b.n	158ec <__sfputs_r+0x14>
   158e8:	42ac      	cmp	r4, r5
   158ea:	d008      	beq.n	158fe <__sfputs_r+0x26>
   158ec:	463a      	mov	r2, r7
   158ee:	f814 1f01 	ldrb.w	r1, [r4, #1]!
   158f2:	4630      	mov	r0, r6
   158f4:	f7ff ffd4 	bl	158a0 <__sfputc_r>
   158f8:	1c43      	adds	r3, r0, #1
   158fa:	d1f5      	bne.n	158e8 <__sfputs_r+0x10>
   158fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   158fe:	2000      	movs	r0, #0
   15900:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15902:	2000      	movs	r0, #0
   15904:	4770      	bx	lr
   15906:	bf00      	nop

00015908 <__sprint_r>:
   15908:	6893      	ldr	r3, [r2, #8]
   1590a:	b510      	push	{r4, lr}
   1590c:	4614      	mov	r4, r2
   1590e:	b913      	cbnz	r3, 15916 <__sprint_r+0xe>
   15910:	6053      	str	r3, [r2, #4]
   15912:	4618      	mov	r0, r3
   15914:	bd10      	pop	{r4, pc}
   15916:	f000 fbd9 	bl	160cc <__sfvwrite_r>
   1591a:	2300      	movs	r3, #0
   1591c:	e9c4 3301 	strd	r3, r3, [r4, #4]
   15920:	bd10      	pop	{r4, pc}
   15922:	bf00      	nop

00015924 <_vfiprintf_r>:
   15924:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15928:	b09f      	sub	sp, #124	; 0x7c
   1592a:	468b      	mov	fp, r1
   1592c:	4690      	mov	r8, r2
   1592e:	461c      	mov	r4, r3
   15930:	9003      	str	r0, [sp, #12]
   15932:	b118      	cbz	r0, 1593c <_vfiprintf_r+0x18>
   15934:	6983      	ldr	r3, [r0, #24]
   15936:	2b00      	cmp	r3, #0
   15938:	f000 80b7 	beq.w	15aaa <_vfiprintf_r+0x186>
   1593c:	4ba2      	ldr	r3, [pc, #648]	; (15bc8 <_vfiprintf_r+0x2a4>)
   1593e:	459b      	cmp	fp, r3
   15940:	f000 80b9 	beq.w	15ab6 <_vfiprintf_r+0x192>
   15944:	4ba1      	ldr	r3, [pc, #644]	; (15bcc <_vfiprintf_r+0x2a8>)
   15946:	459b      	cmp	fp, r3
   15948:	f000 80c7 	beq.w	15ada <_vfiprintf_r+0x1b6>
   1594c:	4ba0      	ldr	r3, [pc, #640]	; (15bd0 <_vfiprintf_r+0x2ac>)
   1594e:	459b      	cmp	fp, r3
   15950:	bf04      	itt	eq
   15952:	9b03      	ldreq	r3, [sp, #12]
   15954:	f8d3 b00c 	ldreq.w	fp, [r3, #12]
   15958:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   1595c:	0718      	lsls	r0, r3, #28
   1595e:	f140 80b2 	bpl.w	15ac6 <_vfiprintf_r+0x1a2>
   15962:	f8db 3010 	ldr.w	r3, [fp, #16]
   15966:	2b00      	cmp	r3, #0
   15968:	f000 80ad 	beq.w	15ac6 <_vfiprintf_r+0x1a2>
   1596c:	2330      	movs	r3, #48	; 0x30
   1596e:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
   15972:	f898 3000 	ldrb.w	r3, [r8]
   15976:	9405      	str	r4, [sp, #20]
   15978:	2100      	movs	r1, #0
   1597a:	2220      	movs	r2, #32
   1597c:	910b      	str	r1, [sp, #44]	; 0x2c
   1597e:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
   15982:	4e94      	ldr	r6, [pc, #592]	; (15bd4 <_vfiprintf_r+0x2b0>)
   15984:	2701      	movs	r7, #1
   15986:	2b00      	cmp	r3, #0
   15988:	f000 8087 	beq.w	15a9a <_vfiprintf_r+0x176>
   1598c:	2b25      	cmp	r3, #37	; 0x25
   1598e:	f000 8115 	beq.w	15bbc <_vfiprintf_r+0x298>
   15992:	4645      	mov	r5, r8
   15994:	e003      	b.n	1599e <_vfiprintf_r+0x7a>
   15996:	2b25      	cmp	r3, #37	; 0x25
   15998:	f000 80a3 	beq.w	15ae2 <_vfiprintf_r+0x1be>
   1599c:	4625      	mov	r5, r4
   1599e:	786b      	ldrb	r3, [r5, #1]
   159a0:	1c6c      	adds	r4, r5, #1
   159a2:	2b00      	cmp	r3, #0
   159a4:	d1f7      	bne.n	15996 <_vfiprintf_r+0x72>
   159a6:	ebb4 0a08 	subs.w	sl, r4, r8
   159aa:	d076      	beq.n	15a9a <_vfiprintf_r+0x176>
   159ac:	4642      	mov	r2, r8
   159ae:	4653      	mov	r3, sl
   159b0:	4659      	mov	r1, fp
   159b2:	9803      	ldr	r0, [sp, #12]
   159b4:	f7ff ff90 	bl	158d8 <__sfputs_r>
   159b8:	3001      	adds	r0, #1
   159ba:	d06e      	beq.n	15a9a <_vfiprintf_r+0x176>
   159bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   159be:	786a      	ldrb	r2, [r5, #1]
   159c0:	4453      	add	r3, sl
   159c2:	930b      	str	r3, [sp, #44]	; 0x2c
   159c4:	2a00      	cmp	r2, #0
   159c6:	d068      	beq.n	15a9a <_vfiprintf_r+0x176>
   159c8:	2300      	movs	r3, #0
   159ca:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   159ce:	3401      	adds	r4, #1
   159d0:	9306      	str	r3, [sp, #24]
   159d2:	e9cd 3308 	strd	r3, r3, [sp, #32]
   159d6:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
   159da:	931c      	str	r3, [sp, #112]	; 0x70
   159dc:	9207      	str	r2, [sp, #28]
   159de:	e005      	b.n	159ec <_vfiprintf_r+0xc8>
   159e0:	9a06      	ldr	r2, [sp, #24]
   159e2:	fa07 f303 	lsl.w	r3, r7, r3
   159e6:	4313      	orrs	r3, r2
   159e8:	462c      	mov	r4, r5
   159ea:	9306      	str	r3, [sp, #24]
   159ec:	4625      	mov	r5, r4
   159ee:	2205      	movs	r2, #5
   159f0:	f815 1b01 	ldrb.w	r1, [r5], #1
   159f4:	4630      	mov	r0, r6
   159f6:	f000 fd1b 	bl	16430 <memchr>
   159fa:	46aa      	mov	sl, r5
   159fc:	1b83      	subs	r3, r0, r6
   159fe:	2800      	cmp	r0, #0
   15a00:	d1ee      	bne.n	159e0 <_vfiprintf_r+0xbc>
   15a02:	9b06      	ldr	r3, [sp, #24]
   15a04:	06d9      	lsls	r1, r3, #27
   15a06:	bf44      	itt	mi
   15a08:	2220      	movmi	r2, #32
   15a0a:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   15a0e:	7821      	ldrb	r1, [r4, #0]
   15a10:	071a      	lsls	r2, r3, #28
   15a12:	bf44      	itt	mi
   15a14:	222b      	movmi	r2, #43	; 0x2b
   15a16:	f88d 205b 	strbmi.w	r2, [sp, #91]	; 0x5b
   15a1a:	292a      	cmp	r1, #42	; 0x2a
   15a1c:	d166      	bne.n	15aec <_vfiprintf_r+0x1c8>
   15a1e:	9a05      	ldr	r2, [sp, #20]
   15a20:	6811      	ldr	r1, [r2, #0]
   15a22:	3204      	adds	r2, #4
   15a24:	2900      	cmp	r1, #0
   15a26:	9205      	str	r2, [sp, #20]
   15a28:	f2c0 809d 	blt.w	15b66 <_vfiprintf_r+0x242>
   15a2c:	9109      	str	r1, [sp, #36]	; 0x24
   15a2e:	7861      	ldrb	r1, [r4, #1]
   15a30:	1ca5      	adds	r5, r4, #2
   15a32:	292e      	cmp	r1, #46	; 0x2e
   15a34:	d073      	beq.n	15b1e <_vfiprintf_r+0x1fa>
   15a36:	4c68      	ldr	r4, [pc, #416]	; (15bd8 <_vfiprintf_r+0x2b4>)
   15a38:	2203      	movs	r2, #3
   15a3a:	4620      	mov	r0, r4
   15a3c:	f000 fcf8 	bl	16430 <memchr>
   15a40:	2800      	cmp	r0, #0
   15a42:	f000 8086 	beq.w	15b52 <_vfiprintf_r+0x22e>
   15a46:	1b00      	subs	r0, r0, r4
   15a48:	9b06      	ldr	r3, [sp, #24]
   15a4a:	2440      	movs	r4, #64	; 0x40
   15a4c:	fa04 f000 	lsl.w	r0, r4, r0
   15a50:	4303      	orrs	r3, r0
   15a52:	9306      	str	r3, [sp, #24]
   15a54:	f105 0801 	add.w	r8, r5, #1
   15a58:	7829      	ldrb	r1, [r5, #0]
   15a5a:	4860      	ldr	r0, [pc, #384]	; (15bdc <_vfiprintf_r+0x2b8>)
   15a5c:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
   15a60:	2206      	movs	r2, #6
   15a62:	f000 fce5 	bl	16430 <memchr>
   15a66:	2800      	cmp	r0, #0
   15a68:	f000 8083 	beq.w	15b72 <_vfiprintf_r+0x24e>
   15a6c:	4b5c      	ldr	r3, [pc, #368]	; (15be0 <_vfiprintf_r+0x2bc>)
   15a6e:	2b00      	cmp	r3, #0
   15a70:	d072      	beq.n	15b58 <_vfiprintf_r+0x234>
   15a72:	ab05      	add	r3, sp, #20
   15a74:	9300      	str	r3, [sp, #0]
   15a76:	465a      	mov	r2, fp
   15a78:	4b5a      	ldr	r3, [pc, #360]	; (15be4 <_vfiprintf_r+0x2c0>)
   15a7a:	9803      	ldr	r0, [sp, #12]
   15a7c:	a906      	add	r1, sp, #24
   15a7e:	f3af 8000 	nop.w
   15a82:	4681      	mov	r9, r0
   15a84:	f1b9 3fff 	cmp.w	r9, #4294967295	; 0xffffffff
   15a88:	d007      	beq.n	15a9a <_vfiprintf_r+0x176>
   15a8a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   15a8c:	444b      	add	r3, r9
   15a8e:	930b      	str	r3, [sp, #44]	; 0x2c
   15a90:	f898 3000 	ldrb.w	r3, [r8]
   15a94:	2b00      	cmp	r3, #0
   15a96:	f47f af79 	bne.w	1598c <_vfiprintf_r+0x68>
   15a9a:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15a9e:	065b      	lsls	r3, r3, #25
   15aa0:	d418      	bmi.n	15ad4 <_vfiprintf_r+0x1b0>
   15aa2:	980b      	ldr	r0, [sp, #44]	; 0x2c
   15aa4:	b01f      	add	sp, #124	; 0x7c
   15aa6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15aaa:	f7ff fbf7 	bl	1529c <__sinit>
   15aae:	4b46      	ldr	r3, [pc, #280]	; (15bc8 <_vfiprintf_r+0x2a4>)
   15ab0:	459b      	cmp	fp, r3
   15ab2:	f47f af47 	bne.w	15944 <_vfiprintf_r+0x20>
   15ab6:	9b03      	ldr	r3, [sp, #12]
   15ab8:	f8d3 b004 	ldr.w	fp, [r3, #4]
   15abc:	f8bb 300c 	ldrh.w	r3, [fp, #12]
   15ac0:	0718      	lsls	r0, r3, #28
   15ac2:	f53f af4e 	bmi.w	15962 <_vfiprintf_r+0x3e>
   15ac6:	4659      	mov	r1, fp
   15ac8:	9803      	ldr	r0, [sp, #12]
   15aca:	f7ff f9a7 	bl	14e1c <__swsetup_r>
   15ace:	2800      	cmp	r0, #0
   15ad0:	f43f af4c 	beq.w	1596c <_vfiprintf_r+0x48>
   15ad4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15ad8:	e7e4      	b.n	15aa4 <_vfiprintf_r+0x180>
   15ada:	9b03      	ldr	r3, [sp, #12]
   15adc:	f8d3 b008 	ldr.w	fp, [r3, #8]
   15ae0:	e73a      	b.n	15958 <_vfiprintf_r+0x34>
   15ae2:	ebb4 0a08 	subs.w	sl, r4, r8
   15ae6:	f43f af6f 	beq.w	159c8 <_vfiprintf_r+0xa4>
   15aea:	e75f      	b.n	159ac <_vfiprintf_r+0x88>
   15aec:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15af0:	2a09      	cmp	r2, #9
   15af2:	bf88      	it	hi
   15af4:	46a2      	movhi	sl, r4
   15af6:	d89c      	bhi.n	15a32 <_vfiprintf_r+0x10e>
   15af8:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15afa:	e001      	b.n	15b00 <_vfiprintf_r+0x1dc>
   15afc:	462c      	mov	r4, r5
   15afe:	3501      	adds	r5, #1
   15b00:	7829      	ldrb	r1, [r5, #0]
   15b02:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15b06:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   15b0a:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15b0e:	2a09      	cmp	r2, #9
   15b10:	46aa      	mov	sl, r5
   15b12:	d9f3      	bls.n	15afc <_vfiprintf_r+0x1d8>
   15b14:	292e      	cmp	r1, #46	; 0x2e
   15b16:	f104 0502 	add.w	r5, r4, #2
   15b1a:	9309      	str	r3, [sp, #36]	; 0x24
   15b1c:	d18b      	bne.n	15a36 <_vfiprintf_r+0x112>
   15b1e:	f89a 1001 	ldrb.w	r1, [sl, #1]
   15b22:	292a      	cmp	r1, #42	; 0x2a
   15b24:	d12f      	bne.n	15b86 <_vfiprintf_r+0x262>
   15b26:	9b05      	ldr	r3, [sp, #20]
   15b28:	f89a 1002 	ldrb.w	r1, [sl, #2]
   15b2c:	681a      	ldr	r2, [r3, #0]
   15b2e:	9207      	str	r2, [sp, #28]
   15b30:	3304      	adds	r3, #4
   15b32:	2a00      	cmp	r2, #0
   15b34:	9305      	str	r3, [sp, #20]
   15b36:	f10a 0503 	add.w	r5, sl, #3
   15b3a:	f10a 0302 	add.w	r3, sl, #2
   15b3e:	db38      	blt.n	15bb2 <_vfiprintf_r+0x28e>
   15b40:	4c25      	ldr	r4, [pc, #148]	; (15bd8 <_vfiprintf_r+0x2b4>)
   15b42:	2203      	movs	r2, #3
   15b44:	4620      	mov	r0, r4
   15b46:	469a      	mov	sl, r3
   15b48:	f000 fc72 	bl	16430 <memchr>
   15b4c:	2800      	cmp	r0, #0
   15b4e:	f47f af7a 	bne.w	15a46 <_vfiprintf_r+0x122>
   15b52:	46a8      	mov	r8, r5
   15b54:	4655      	mov	r5, sl
   15b56:	e77f      	b.n	15a58 <_vfiprintf_r+0x134>
   15b58:	9b05      	ldr	r3, [sp, #20]
   15b5a:	3307      	adds	r3, #7
   15b5c:	f023 0307 	bic.w	r3, r3, #7
   15b60:	3308      	adds	r3, #8
   15b62:	9305      	str	r3, [sp, #20]
   15b64:	e791      	b.n	15a8a <_vfiprintf_r+0x166>
   15b66:	4249      	negs	r1, r1
   15b68:	f043 0302 	orr.w	r3, r3, #2
   15b6c:	9109      	str	r1, [sp, #36]	; 0x24
   15b6e:	9306      	str	r3, [sp, #24]
   15b70:	e75d      	b.n	15a2e <_vfiprintf_r+0x10a>
   15b72:	ab05      	add	r3, sp, #20
   15b74:	9300      	str	r3, [sp, #0]
   15b76:	465a      	mov	r2, fp
   15b78:	4b1a      	ldr	r3, [pc, #104]	; (15be4 <_vfiprintf_r+0x2c0>)
   15b7a:	9803      	ldr	r0, [sp, #12]
   15b7c:	a906      	add	r1, sp, #24
   15b7e:	f000 f8d5 	bl	15d2c <_printf_i>
   15b82:	4681      	mov	r9, r0
   15b84:	e77e      	b.n	15a84 <_vfiprintf_r+0x160>
   15b86:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15b8a:	2300      	movs	r3, #0
   15b8c:	2a09      	cmp	r2, #9
   15b8e:	9307      	str	r3, [sp, #28]
   15b90:	d901      	bls.n	15b96 <_vfiprintf_r+0x272>
   15b92:	e015      	b.n	15bc0 <_vfiprintf_r+0x29c>
   15b94:	4655      	mov	r5, sl
   15b96:	7869      	ldrb	r1, [r5, #1]
   15b98:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   15b9c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
   15ba0:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
   15ba4:	2a09      	cmp	r2, #9
   15ba6:	f105 0a01 	add.w	sl, r5, #1
   15baa:	d9f3      	bls.n	15b94 <_vfiprintf_r+0x270>
   15bac:	3502      	adds	r5, #2
   15bae:	9307      	str	r3, [sp, #28]
   15bb0:	e741      	b.n	15a36 <_vfiprintf_r+0x112>
   15bb2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15bb6:	469a      	mov	sl, r3
   15bb8:	9207      	str	r2, [sp, #28]
   15bba:	e73c      	b.n	15a36 <_vfiprintf_r+0x112>
   15bbc:	4644      	mov	r4, r8
   15bbe:	e703      	b.n	159c8 <_vfiprintf_r+0xa4>
   15bc0:	46aa      	mov	sl, r5
   15bc2:	3501      	adds	r5, #1
   15bc4:	e737      	b.n	15a36 <_vfiprintf_r+0x112>
   15bc6:	bf00      	nop
   15bc8:	000175b0 	.word	0x000175b0
   15bcc:	00017590 	.word	0x00017590
   15bd0:	00017570 	.word	0x00017570
   15bd4:	000175d0 	.word	0x000175d0
   15bd8:	000175d8 	.word	0x000175d8
   15bdc:	000175dc 	.word	0x000175dc
   15be0:	00000000 	.word	0x00000000
   15be4:	000158d9 	.word	0x000158d9

00015be8 <vfiprintf>:
   15be8:	b410      	push	{r4}
   15bea:	4c04      	ldr	r4, [pc, #16]	; (15bfc <vfiprintf+0x14>)
   15bec:	4613      	mov	r3, r2
   15bee:	460a      	mov	r2, r1
   15bf0:	4601      	mov	r1, r0
   15bf2:	6820      	ldr	r0, [r4, #0]
   15bf4:	bc10      	pop	{r4}
   15bf6:	f7ff be95 	b.w	15924 <_vfiprintf_r>
   15bfa:	bf00      	nop
   15bfc:	2000054c 	.word	0x2000054c

00015c00 <_printf_common>:
   15c00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15c04:	460c      	mov	r4, r1
   15c06:	4691      	mov	r9, r2
   15c08:	690a      	ldr	r2, [r1, #16]
   15c0a:	6889      	ldr	r1, [r1, #8]
   15c0c:	f8dd 8020 	ldr.w	r8, [sp, #32]
   15c10:	428a      	cmp	r2, r1
   15c12:	bfb8      	it	lt
   15c14:	460a      	movlt	r2, r1
   15c16:	f8c9 2000 	str.w	r2, [r9]
   15c1a:	f894 1043 	ldrb.w	r1, [r4, #67]	; 0x43
   15c1e:	4606      	mov	r6, r0
   15c20:	461f      	mov	r7, r3
   15c22:	b111      	cbz	r1, 15c2a <_printf_common+0x2a>
   15c24:	3201      	adds	r2, #1
   15c26:	f8c9 2000 	str.w	r2, [r9]
   15c2a:	6823      	ldr	r3, [r4, #0]
   15c2c:	0699      	lsls	r1, r3, #26
   15c2e:	d55c      	bpl.n	15cea <_printf_common+0xea>
   15c30:	f8d9 2000 	ldr.w	r2, [r9]
   15c34:	3202      	adds	r2, #2
   15c36:	f8c9 2000 	str.w	r2, [r9]
   15c3a:	6823      	ldr	r3, [r4, #0]
   15c3c:	f013 0f06 	tst.w	r3, #6
   15c40:	4619      	mov	r1, r3
   15c42:	d11d      	bne.n	15c80 <_printf_common+0x80>
   15c44:	68e1      	ldr	r1, [r4, #12]
   15c46:	1a8a      	subs	r2, r1, r2
   15c48:	2a00      	cmp	r2, #0
   15c4a:	bfd8      	it	le
   15c4c:	4619      	movle	r1, r3
   15c4e:	dd17      	ble.n	15c80 <_printf_common+0x80>
   15c50:	f104 0a19 	add.w	sl, r4, #25
   15c54:	2500      	movs	r5, #0
   15c56:	e005      	b.n	15c64 <_printf_common+0x64>
   15c58:	68e3      	ldr	r3, [r4, #12]
   15c5a:	f8d9 2000 	ldr.w	r2, [r9]
   15c5e:	1a9b      	subs	r3, r3, r2
   15c60:	42ab      	cmp	r3, r5
   15c62:	dd0c      	ble.n	15c7e <_printf_common+0x7e>
   15c64:	2301      	movs	r3, #1
   15c66:	4652      	mov	r2, sl
   15c68:	4639      	mov	r1, r7
   15c6a:	4630      	mov	r0, r6
   15c6c:	47c0      	blx	r8
   15c6e:	3001      	adds	r0, #1
   15c70:	f105 0501 	add.w	r5, r5, #1
   15c74:	d1f0      	bne.n	15c58 <_printf_common+0x58>
   15c76:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15c7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15c7e:	6821      	ldr	r1, [r4, #0]
   15c80:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   15c84:	3300      	adds	r3, #0
   15c86:	bf18      	it	ne
   15c88:	2301      	movne	r3, #1
   15c8a:	068a      	lsls	r2, r1, #26
   15c8c:	d50a      	bpl.n	15ca4 <_printf_common+0xa4>
   15c8e:	18e1      	adds	r1, r4, r3
   15c90:	1c5a      	adds	r2, r3, #1
   15c92:	2030      	movs	r0, #48	; 0x30
   15c94:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   15c98:	4422      	add	r2, r4
   15c9a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   15c9e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   15ca2:	3302      	adds	r3, #2
   15ca4:	f104 0243 	add.w	r2, r4, #67	; 0x43
   15ca8:	4639      	mov	r1, r7
   15caa:	4630      	mov	r0, r6
   15cac:	47c0      	blx	r8
   15cae:	3001      	adds	r0, #1
   15cb0:	d0e1      	beq.n	15c76 <_printf_common+0x76>
   15cb2:	6823      	ldr	r3, [r4, #0]
   15cb4:	68a2      	ldr	r2, [r4, #8]
   15cb6:	6921      	ldr	r1, [r4, #16]
   15cb8:	f003 0306 	and.w	r3, r3, #6
   15cbc:	2b04      	cmp	r3, #4
   15cbe:	d01d      	beq.n	15cfc <_printf_common+0xfc>
   15cc0:	428a      	cmp	r2, r1
   15cc2:	dd26      	ble.n	15d12 <_printf_common+0x112>
   15cc4:	f04f 0900 	mov.w	r9, #0
   15cc8:	1a52      	subs	r2, r2, r1
   15cca:	4491      	add	r9, r2
   15ccc:	341a      	adds	r4, #26
   15cce:	2500      	movs	r5, #0
   15cd0:	e001      	b.n	15cd6 <_printf_common+0xd6>
   15cd2:	454d      	cmp	r5, r9
   15cd4:	da1d      	bge.n	15d12 <_printf_common+0x112>
   15cd6:	2301      	movs	r3, #1
   15cd8:	4622      	mov	r2, r4
   15cda:	4639      	mov	r1, r7
   15cdc:	4630      	mov	r0, r6
   15cde:	47c0      	blx	r8
   15ce0:	3001      	adds	r0, #1
   15ce2:	f105 0501 	add.w	r5, r5, #1
   15ce6:	d1f4      	bne.n	15cd2 <_printf_common+0xd2>
   15ce8:	e7c5      	b.n	15c76 <_printf_common+0x76>
   15cea:	f013 0f06 	tst.w	r3, #6
   15cee:	d013      	beq.n	15d18 <_printf_common+0x118>
   15cf0:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
   15cf4:	3300      	adds	r3, #0
   15cf6:	bf18      	it	ne
   15cf8:	2301      	movne	r3, #1
   15cfa:	e7d3      	b.n	15ca4 <_printf_common+0xa4>
   15cfc:	f8d9 0000 	ldr.w	r0, [r9]
   15d00:	68e3      	ldr	r3, [r4, #12]
   15d02:	428a      	cmp	r2, r1
   15d04:	eba3 0300 	sub.w	r3, r3, r0
   15d08:	ea23 79e3 	bic.w	r9, r3, r3, asr #31
   15d0c:	dcdc      	bgt.n	15cc8 <_printf_common+0xc8>
   15d0e:	2b00      	cmp	r3, #0
   15d10:	dcdc      	bgt.n	15ccc <_printf_common+0xcc>
   15d12:	2000      	movs	r0, #0
   15d14:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15d18:	68e1      	ldr	r1, [r4, #12]
   15d1a:	f8d9 2000 	ldr.w	r2, [r9]
   15d1e:	1a8a      	subs	r2, r1, r2
   15d20:	2a00      	cmp	r2, #0
   15d22:	bfd8      	it	le
   15d24:	4619      	movle	r1, r3
   15d26:	dc93      	bgt.n	15c50 <_printf_common+0x50>
   15d28:	e7aa      	b.n	15c80 <_printf_common+0x80>
   15d2a:	bf00      	nop

00015d2c <_printf_i>:
   15d2c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   15d30:	460c      	mov	r4, r1
   15d32:	7e09      	ldrb	r1, [r1, #24]
   15d34:	b085      	sub	sp, #20
   15d36:	296e      	cmp	r1, #110	; 0x6e
   15d38:	4606      	mov	r6, r0
   15d3a:	4617      	mov	r7, r2
   15d3c:	980c      	ldr	r0, [sp, #48]	; 0x30
   15d3e:	4698      	mov	r8, r3
   15d40:	f104 0e43 	add.w	lr, r4, #67	; 0x43
   15d44:	d06d      	beq.n	15e22 <_printf_i+0xf6>
   15d46:	d939      	bls.n	15dbc <_printf_i+0x90>
   15d48:	2973      	cmp	r1, #115	; 0x73
   15d4a:	f000 80f6 	beq.w	15f3a <_printf_i+0x20e>
   15d4e:	d944      	bls.n	15dda <_printf_i+0xae>
   15d50:	2975      	cmp	r1, #117	; 0x75
   15d52:	f000 8104 	beq.w	15f5e <_printf_i+0x232>
   15d56:	2978      	cmp	r1, #120	; 0x78
   15d58:	f040 8111 	bne.w	15f7e <_printf_i+0x252>
   15d5c:	2378      	movs	r3, #120	; 0x78
   15d5e:	6822      	ldr	r2, [r4, #0]
   15d60:	f8df c258 	ldr.w	ip, [pc, #600]	; 15fbc <_printf_i+0x290>
   15d64:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   15d68:	6801      	ldr	r1, [r0, #0]
   15d6a:	0615      	lsls	r5, r2, #24
   15d6c:	f851 3b04 	ldr.w	r3, [r1], #4
   15d70:	6001      	str	r1, [r0, #0]
   15d72:	f140 80a1 	bpl.w	15eb8 <_printf_i+0x18c>
   15d76:	07d1      	lsls	r1, r2, #31
   15d78:	bf44      	itt	mi
   15d7a:	f042 0220 	orrmi.w	r2, r2, #32
   15d7e:	6022      	strmi	r2, [r4, #0]
   15d80:	2b00      	cmp	r3, #0
   15d82:	f000 8093 	beq.w	15eac <_printf_i+0x180>
   15d86:	2210      	movs	r2, #16
   15d88:	2100      	movs	r1, #0
   15d8a:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   15d8e:	6860      	ldr	r0, [r4, #4]
   15d90:	60a0      	str	r0, [r4, #8]
   15d92:	2800      	cmp	r0, #0
   15d94:	f2c0 80c8 	blt.w	15f28 <_printf_i+0x1fc>
   15d98:	6821      	ldr	r1, [r4, #0]
   15d9a:	f021 0104 	bic.w	r1, r1, #4
   15d9e:	6021      	str	r1, [r4, #0]
   15da0:	2b00      	cmp	r3, #0
   15da2:	f040 80a3 	bne.w	15eec <_printf_i+0x1c0>
   15da6:	2800      	cmp	r0, #0
   15da8:	f040 80c0 	bne.w	15f2c <_printf_i+0x200>
   15dac:	4675      	mov	r5, lr
   15dae:	2a08      	cmp	r2, #8
   15db0:	f000 80ac 	beq.w	15f0c <_printf_i+0x1e0>
   15db4:	ebae 0305 	sub.w	r3, lr, r5
   15db8:	6123      	str	r3, [r4, #16]
   15dba:	e041      	b.n	15e40 <_printf_i+0x114>
   15dbc:	2963      	cmp	r1, #99	; 0x63
   15dbe:	f000 80e5 	beq.w	15f8c <_printf_i+0x260>
   15dc2:	d81a      	bhi.n	15dfa <_printf_i+0xce>
   15dc4:	2900      	cmp	r1, #0
   15dc6:	d038      	beq.n	15e3a <_printf_i+0x10e>
   15dc8:	2958      	cmp	r1, #88	; 0x58
   15dca:	f040 80d8 	bne.w	15f7e <_printf_i+0x252>
   15dce:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
   15dd2:	6822      	ldr	r2, [r4, #0]
   15dd4:	f8df c1e8 	ldr.w	ip, [pc, #488]	; 15fc0 <_printf_i+0x294>
   15dd8:	e7c6      	b.n	15d68 <_printf_i+0x3c>
   15dda:	296f      	cmp	r1, #111	; 0x6f
   15ddc:	f000 80bf 	beq.w	15f5e <_printf_i+0x232>
   15de0:	2970      	cmp	r1, #112	; 0x70
   15de2:	f040 80cc 	bne.w	15f7e <_printf_i+0x252>
   15de6:	6822      	ldr	r2, [r4, #0]
   15de8:	f8df c1d0 	ldr.w	ip, [pc, #464]	; 15fbc <_printf_i+0x290>
   15dec:	f042 0220 	orr.w	r2, r2, #32
   15df0:	2378      	movs	r3, #120	; 0x78
   15df2:	6022      	str	r2, [r4, #0]
   15df4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   15df8:	e7b6      	b.n	15d68 <_printf_i+0x3c>
   15dfa:	2964      	cmp	r1, #100	; 0x64
   15dfc:	d002      	beq.n	15e04 <_printf_i+0xd8>
   15dfe:	2969      	cmp	r1, #105	; 0x69
   15e00:	f040 80bd 	bne.w	15f7e <_printf_i+0x252>
   15e04:	6822      	ldr	r2, [r4, #0]
   15e06:	6803      	ldr	r3, [r0, #0]
   15e08:	0611      	lsls	r1, r2, #24
   15e0a:	f103 0504 	add.w	r5, r3, #4
   15e0e:	d557      	bpl.n	15ec0 <_printf_i+0x194>
   15e10:	6819      	ldr	r1, [r3, #0]
   15e12:	6005      	str	r5, [r0, #0]
   15e14:	460b      	mov	r3, r1
   15e16:	2900      	cmp	r1, #0
   15e18:	db59      	blt.n	15ece <_printf_i+0x1a2>
   15e1a:	f8df c1a4 	ldr.w	ip, [pc, #420]	; 15fc0 <_printf_i+0x294>
   15e1e:	220a      	movs	r2, #10
   15e20:	e7b5      	b.n	15d8e <_printf_i+0x62>
   15e22:	6803      	ldr	r3, [r0, #0]
   15e24:	6822      	ldr	r2, [r4, #0]
   15e26:	6961      	ldr	r1, [r4, #20]
   15e28:	1d1d      	adds	r5, r3, #4
   15e2a:	6005      	str	r5, [r0, #0]
   15e2c:	0615      	lsls	r5, r2, #24
   15e2e:	681b      	ldr	r3, [r3, #0]
   15e30:	d402      	bmi.n	15e38 <_printf_i+0x10c>
   15e32:	0650      	lsls	r0, r2, #25
   15e34:	f100 80bd 	bmi.w	15fb2 <_printf_i+0x286>
   15e38:	6019      	str	r1, [r3, #0]
   15e3a:	2300      	movs	r3, #0
   15e3c:	4675      	mov	r5, lr
   15e3e:	6123      	str	r3, [r4, #16]
   15e40:	f8cd 8000 	str.w	r8, [sp]
   15e44:	463b      	mov	r3, r7
   15e46:	aa03      	add	r2, sp, #12
   15e48:	4621      	mov	r1, r4
   15e4a:	4630      	mov	r0, r6
   15e4c:	f7ff fed8 	bl	15c00 <_printf_common>
   15e50:	3001      	adds	r0, #1
   15e52:	d020      	beq.n	15e96 <_printf_i+0x16a>
   15e54:	462a      	mov	r2, r5
   15e56:	6923      	ldr	r3, [r4, #16]
   15e58:	4639      	mov	r1, r7
   15e5a:	4630      	mov	r0, r6
   15e5c:	47c0      	blx	r8
   15e5e:	3001      	adds	r0, #1
   15e60:	d019      	beq.n	15e96 <_printf_i+0x16a>
   15e62:	6822      	ldr	r2, [r4, #0]
   15e64:	9803      	ldr	r0, [sp, #12]
   15e66:	68e3      	ldr	r3, [r4, #12]
   15e68:	0792      	lsls	r2, r2, #30
   15e6a:	d519      	bpl.n	15ea0 <_printf_i+0x174>
   15e6c:	1a1a      	subs	r2, r3, r0
   15e6e:	2a00      	cmp	r2, #0
   15e70:	dd16      	ble.n	15ea0 <_printf_i+0x174>
   15e72:	f104 0919 	add.w	r9, r4, #25
   15e76:	2500      	movs	r5, #0
   15e78:	e004      	b.n	15e84 <_printf_i+0x158>
   15e7a:	68e3      	ldr	r3, [r4, #12]
   15e7c:	9803      	ldr	r0, [sp, #12]
   15e7e:	1a1a      	subs	r2, r3, r0
   15e80:	42aa      	cmp	r2, r5
   15e82:	dd0d      	ble.n	15ea0 <_printf_i+0x174>
   15e84:	2301      	movs	r3, #1
   15e86:	464a      	mov	r2, r9
   15e88:	4639      	mov	r1, r7
   15e8a:	4630      	mov	r0, r6
   15e8c:	47c0      	blx	r8
   15e8e:	3001      	adds	r0, #1
   15e90:	f105 0501 	add.w	r5, r5, #1
   15e94:	d1f1      	bne.n	15e7a <_printf_i+0x14e>
   15e96:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15e9a:	b005      	add	sp, #20
   15e9c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   15ea0:	4298      	cmp	r0, r3
   15ea2:	bfb8      	it	lt
   15ea4:	4618      	movlt	r0, r3
   15ea6:	b005      	add	sp, #20
   15ea8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   15eac:	6822      	ldr	r2, [r4, #0]
   15eae:	f022 0220 	bic.w	r2, r2, #32
   15eb2:	6022      	str	r2, [r4, #0]
   15eb4:	2210      	movs	r2, #16
   15eb6:	e767      	b.n	15d88 <_printf_i+0x5c>
   15eb8:	0650      	lsls	r0, r2, #25
   15eba:	bf48      	it	mi
   15ebc:	b29b      	uxthmi	r3, r3
   15ebe:	e75a      	b.n	15d76 <_printf_i+0x4a>
   15ec0:	0651      	lsls	r1, r2, #25
   15ec2:	d5a5      	bpl.n	15e10 <_printf_i+0xe4>
   15ec4:	f9b3 3000 	ldrsh.w	r3, [r3]
   15ec8:	6005      	str	r5, [r0, #0]
   15eca:	4619      	mov	r1, r3
   15ecc:	e7a3      	b.n	15e16 <_printf_i+0xea>
   15ece:	6861      	ldr	r1, [r4, #4]
   15ed0:	60a1      	str	r1, [r4, #8]
   15ed2:	202d      	movs	r0, #45	; 0x2d
   15ed4:	2900      	cmp	r1, #0
   15ed6:	f1c3 0300 	rsb	r3, r3, #0
   15eda:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
   15ede:	db02      	blt.n	15ee6 <_printf_i+0x1ba>
   15ee0:	f022 0204 	bic.w	r2, r2, #4
   15ee4:	6022      	str	r2, [r4, #0]
   15ee6:	f8df c0d8 	ldr.w	ip, [pc, #216]	; 15fc0 <_printf_i+0x294>
   15eea:	220a      	movs	r2, #10
   15eec:	4675      	mov	r5, lr
   15eee:	e000      	b.n	15ef2 <_printf_i+0x1c6>
   15ef0:	460b      	mov	r3, r1
   15ef2:	fbb3 f1f2 	udiv	r1, r3, r2
   15ef6:	fb02 3011 	mls	r0, r2, r1, r3
   15efa:	4293      	cmp	r3, r2
   15efc:	f81c 0000 	ldrb.w	r0, [ip, r0]
   15f00:	f805 0d01 	strb.w	r0, [r5, #-1]!
   15f04:	d2f4      	bcs.n	15ef0 <_printf_i+0x1c4>
   15f06:	2a08      	cmp	r2, #8
   15f08:	f47f af54 	bne.w	15db4 <_printf_i+0x88>
   15f0c:	6823      	ldr	r3, [r4, #0]
   15f0e:	07db      	lsls	r3, r3, #31
   15f10:	f57f af50 	bpl.w	15db4 <_printf_i+0x88>
   15f14:	6862      	ldr	r2, [r4, #4]
   15f16:	6923      	ldr	r3, [r4, #16]
   15f18:	429a      	cmp	r2, r3
   15f1a:	f73f af4b 	bgt.w	15db4 <_printf_i+0x88>
   15f1e:	2330      	movs	r3, #48	; 0x30
   15f20:	f805 3c01 	strb.w	r3, [r5, #-1]
   15f24:	3d01      	subs	r5, #1
   15f26:	e745      	b.n	15db4 <_printf_i+0x88>
   15f28:	2b00      	cmp	r3, #0
   15f2a:	d1df      	bne.n	15eec <_printf_i+0x1c0>
   15f2c:	f89c 3000 	ldrb.w	r3, [ip]
   15f30:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   15f34:	f104 0542 	add.w	r5, r4, #66	; 0x42
   15f38:	e739      	b.n	15dae <_printf_i+0x82>
   15f3a:	6803      	ldr	r3, [r0, #0]
   15f3c:	6862      	ldr	r2, [r4, #4]
   15f3e:	1d19      	adds	r1, r3, #4
   15f40:	6001      	str	r1, [r0, #0]
   15f42:	681d      	ldr	r5, [r3, #0]
   15f44:	2100      	movs	r1, #0
   15f46:	4628      	mov	r0, r5
   15f48:	f000 fa72 	bl	16430 <memchr>
   15f4c:	2800      	cmp	r0, #0
   15f4e:	d032      	beq.n	15fb6 <_printf_i+0x28a>
   15f50:	1b40      	subs	r0, r0, r5
   15f52:	6060      	str	r0, [r4, #4]
   15f54:	6120      	str	r0, [r4, #16]
   15f56:	2300      	movs	r3, #0
   15f58:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   15f5c:	e770      	b.n	15e40 <_printf_i+0x114>
   15f5e:	6822      	ldr	r2, [r4, #0]
   15f60:	6803      	ldr	r3, [r0, #0]
   15f62:	f012 0f80 	tst.w	r2, #128	; 0x80
   15f66:	f103 0504 	add.w	r5, r3, #4
   15f6a:	d01a      	beq.n	15fa2 <_printf_i+0x276>
   15f6c:	681b      	ldr	r3, [r3, #0]
   15f6e:	6005      	str	r5, [r0, #0]
   15f70:	296f      	cmp	r1, #111	; 0x6f
   15f72:	bf0c      	ite	eq
   15f74:	2208      	moveq	r2, #8
   15f76:	220a      	movne	r2, #10
   15f78:	f8df c044 	ldr.w	ip, [pc, #68]	; 15fc0 <_printf_i+0x294>
   15f7c:	e704      	b.n	15d88 <_printf_i+0x5c>
   15f7e:	2301      	movs	r3, #1
   15f80:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
   15f84:	6123      	str	r3, [r4, #16]
   15f86:	f104 0542 	add.w	r5, r4, #66	; 0x42
   15f8a:	e7e4      	b.n	15f56 <_printf_i+0x22a>
   15f8c:	6803      	ldr	r3, [r0, #0]
   15f8e:	681a      	ldr	r2, [r3, #0]
   15f90:	1d19      	adds	r1, r3, #4
   15f92:	2301      	movs	r3, #1
   15f94:	6001      	str	r1, [r0, #0]
   15f96:	f104 0542 	add.w	r5, r4, #66	; 0x42
   15f9a:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
   15f9e:	6123      	str	r3, [r4, #16]
   15fa0:	e7d9      	b.n	15f56 <_printf_i+0x22a>
   15fa2:	f012 0f40 	tst.w	r2, #64	; 0x40
   15fa6:	bf0d      	iteet	eq
   15fa8:	681b      	ldreq	r3, [r3, #0]
   15faa:	6005      	strne	r5, [r0, #0]
   15fac:	881b      	ldrhne	r3, [r3, #0]
   15fae:	6005      	streq	r5, [r0, #0]
   15fb0:	e7de      	b.n	15f70 <_printf_i+0x244>
   15fb2:	8019      	strh	r1, [r3, #0]
   15fb4:	e741      	b.n	15e3a <_printf_i+0x10e>
   15fb6:	6860      	ldr	r0, [r4, #4]
   15fb8:	e7cc      	b.n	15f54 <_printf_i+0x228>
   15fba:	bf00      	nop
   15fbc:	000175f8 	.word	0x000175f8
   15fc0:	000175e4 	.word	0x000175e4

00015fc4 <__sread>:
   15fc4:	b510      	push	{r4, lr}
   15fc6:	460c      	mov	r4, r1
   15fc8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15fcc:	f000 fb0e 	bl	165ec <_read_r>
   15fd0:	2800      	cmp	r0, #0
   15fd2:	db03      	blt.n	15fdc <__sread+0x18>
   15fd4:	6d63      	ldr	r3, [r4, #84]	; 0x54
   15fd6:	4403      	add	r3, r0
   15fd8:	6563      	str	r3, [r4, #84]	; 0x54
   15fda:	bd10      	pop	{r4, pc}
   15fdc:	89a3      	ldrh	r3, [r4, #12]
   15fde:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   15fe2:	81a3      	strh	r3, [r4, #12]
   15fe4:	bd10      	pop	{r4, pc}
   15fe6:	bf00      	nop

00015fe8 <__seofread>:
   15fe8:	2000      	movs	r0, #0
   15fea:	4770      	bx	lr

00015fec <__swrite>:
   15fec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15ff0:	4616      	mov	r6, r2
   15ff2:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
   15ff6:	461f      	mov	r7, r3
   15ff8:	05d3      	lsls	r3, r2, #23
   15ffa:	460c      	mov	r4, r1
   15ffc:	4605      	mov	r5, r0
   15ffe:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16002:	d409      	bmi.n	16018 <__swrite+0x2c>
   16004:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
   16008:	81a2      	strh	r2, [r4, #12]
   1600a:	463b      	mov	r3, r7
   1600c:	4632      	mov	r2, r6
   1600e:	4628      	mov	r0, r5
   16010:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   16014:	f000 b81e 	b.w	16054 <_write_r>
   16018:	2200      	movs	r2, #0
   1601a:	2302      	movs	r3, #2
   1601c:	f000 f9ec 	bl	163f8 <_lseek_r>
   16020:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   16024:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   16028:	e7ec      	b.n	16004 <__swrite+0x18>
   1602a:	bf00      	nop

0001602c <__sseek>:
   1602c:	b510      	push	{r4, lr}
   1602e:	460c      	mov	r4, r1
   16030:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16034:	f000 f9e0 	bl	163f8 <_lseek_r>
   16038:	89a3      	ldrh	r3, [r4, #12]
   1603a:	1c42      	adds	r2, r0, #1
   1603c:	bf0e      	itee	eq
   1603e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   16042:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   16046:	6560      	strne	r0, [r4, #84]	; 0x54
   16048:	81a3      	strh	r3, [r4, #12]
   1604a:	bd10      	pop	{r4, pc}

0001604c <__sclose>:
   1604c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16050:	f000 b816 	b.w	16080 <_close_r>

00016054 <_write_r>:
   16054:	b570      	push	{r4, r5, r6, lr}
   16056:	460d      	mov	r5, r1
   16058:	4c08      	ldr	r4, [pc, #32]	; (1607c <_write_r+0x28>)
   1605a:	4611      	mov	r1, r2
   1605c:	4606      	mov	r6, r0
   1605e:	461a      	mov	r2, r3
   16060:	4628      	mov	r0, r5
   16062:	2300      	movs	r3, #0
   16064:	6023      	str	r3, [r4, #0]
   16066:	f7f5 fc63 	bl	b930 <_write>
   1606a:	1c43      	adds	r3, r0, #1
   1606c:	d000      	beq.n	16070 <_write_r+0x1c>
   1606e:	bd70      	pop	{r4, r5, r6, pc}
   16070:	6823      	ldr	r3, [r4, #0]
   16072:	2b00      	cmp	r3, #0
   16074:	d0fb      	beq.n	1606e <_write_r+0x1a>
   16076:	6033      	str	r3, [r6, #0]
   16078:	bd70      	pop	{r4, r5, r6, pc}
   1607a:	bf00      	nop
   1607c:	200159f4 	.word	0x200159f4

00016080 <_close_r>:
   16080:	b538      	push	{r3, r4, r5, lr}
   16082:	4c07      	ldr	r4, [pc, #28]	; (160a0 <_close_r+0x20>)
   16084:	2300      	movs	r3, #0
   16086:	4605      	mov	r5, r0
   16088:	4608      	mov	r0, r1
   1608a:	6023      	str	r3, [r4, #0]
   1608c:	f7f5 fe28 	bl	bce0 <_close>
   16090:	1c43      	adds	r3, r0, #1
   16092:	d000      	beq.n	16096 <_close_r+0x16>
   16094:	bd38      	pop	{r3, r4, r5, pc}
   16096:	6823      	ldr	r3, [r4, #0]
   16098:	2b00      	cmp	r3, #0
   1609a:	d0fb      	beq.n	16094 <_close_r+0x14>
   1609c:	602b      	str	r3, [r5, #0]
   1609e:	bd38      	pop	{r3, r4, r5, pc}
   160a0:	200159f4 	.word	0x200159f4

000160a4 <_fstat_r>:
   160a4:	b538      	push	{r3, r4, r5, lr}
   160a6:	460b      	mov	r3, r1
   160a8:	4c07      	ldr	r4, [pc, #28]	; (160c8 <_fstat_r+0x24>)
   160aa:	4605      	mov	r5, r0
   160ac:	4611      	mov	r1, r2
   160ae:	4618      	mov	r0, r3
   160b0:	2300      	movs	r3, #0
   160b2:	6023      	str	r3, [r4, #0]
   160b4:	f7f5 fe17 	bl	bce6 <_fstat>
   160b8:	1c43      	adds	r3, r0, #1
   160ba:	d000      	beq.n	160be <_fstat_r+0x1a>
   160bc:	bd38      	pop	{r3, r4, r5, pc}
   160be:	6823      	ldr	r3, [r4, #0]
   160c0:	2b00      	cmp	r3, #0
   160c2:	d0fb      	beq.n	160bc <_fstat_r+0x18>
   160c4:	602b      	str	r3, [r5, #0]
   160c6:	bd38      	pop	{r3, r4, r5, pc}
   160c8:	200159f4 	.word	0x200159f4

000160cc <__sfvwrite_r>:
   160cc:	6893      	ldr	r3, [r2, #8]
   160ce:	2b00      	cmp	r3, #0
   160d0:	f000 8102 	beq.w	162d8 <__sfvwrite_r+0x20c>
   160d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   160d8:	f9b1 300c 	ldrsh.w	r3, [r1, #12]
   160dc:	b29b      	uxth	r3, r3
   160de:	460c      	mov	r4, r1
   160e0:	0719      	lsls	r1, r3, #28
   160e2:	b083      	sub	sp, #12
   160e4:	4682      	mov	sl, r0
   160e6:	4690      	mov	r8, r2
   160e8:	d535      	bpl.n	16156 <__sfvwrite_r+0x8a>
   160ea:	6922      	ldr	r2, [r4, #16]
   160ec:	b39a      	cbz	r2, 16156 <__sfvwrite_r+0x8a>
   160ee:	f013 0202 	ands.w	r2, r3, #2
   160f2:	f8d8 6000 	ldr.w	r6, [r8]
   160f6:	d03d      	beq.n	16174 <__sfvwrite_r+0xa8>
   160f8:	2700      	movs	r7, #0
   160fa:	f8d4 b028 	ldr.w	fp, [r4, #40]	; 0x28
   160fe:	f8d4 c020 	ldr.w	ip, [r4, #32]
   16102:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 163d0 <__sfvwrite_r+0x304>
   16106:	463d      	mov	r5, r7
   16108:	454d      	cmp	r5, r9
   1610a:	462b      	mov	r3, r5
   1610c:	463a      	mov	r2, r7
   1610e:	bf28      	it	cs
   16110:	464b      	movcs	r3, r9
   16112:	4661      	mov	r1, ip
   16114:	4650      	mov	r0, sl
   16116:	b1d5      	cbz	r5, 1614e <__sfvwrite_r+0x82>
   16118:	47d8      	blx	fp
   1611a:	2800      	cmp	r0, #0
   1611c:	f340 80d2 	ble.w	162c4 <__sfvwrite_r+0x1f8>
   16120:	f8d8 3008 	ldr.w	r3, [r8, #8]
   16124:	1a1b      	subs	r3, r3, r0
   16126:	4407      	add	r7, r0
   16128:	1a2d      	subs	r5, r5, r0
   1612a:	f8c8 3008 	str.w	r3, [r8, #8]
   1612e:	2b00      	cmp	r3, #0
   16130:	f000 80b7 	beq.w	162a2 <__sfvwrite_r+0x1d6>
   16134:	f8d4 c020 	ldr.w	ip, [r4, #32]
   16138:	f8d4 b028 	ldr.w	fp, [r4, #40]	; 0x28
   1613c:	454d      	cmp	r5, r9
   1613e:	462b      	mov	r3, r5
   16140:	463a      	mov	r2, r7
   16142:	bf28      	it	cs
   16144:	464b      	movcs	r3, r9
   16146:	4661      	mov	r1, ip
   16148:	4650      	mov	r0, sl
   1614a:	2d00      	cmp	r5, #0
   1614c:	d1e4      	bne.n	16118 <__sfvwrite_r+0x4c>
   1614e:	e9d6 7500 	ldrd	r7, r5, [r6]
   16152:	3608      	adds	r6, #8
   16154:	e7d8      	b.n	16108 <__sfvwrite_r+0x3c>
   16156:	4621      	mov	r1, r4
   16158:	4650      	mov	r0, sl
   1615a:	f7fe fe5f 	bl	14e1c <__swsetup_r>
   1615e:	2800      	cmp	r0, #0
   16160:	f040 8130 	bne.w	163c4 <__sfvwrite_r+0x2f8>
   16164:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   16168:	f8d8 6000 	ldr.w	r6, [r8]
   1616c:	b29b      	uxth	r3, r3
   1616e:	f013 0202 	ands.w	r2, r3, #2
   16172:	d1c1      	bne.n	160f8 <__sfvwrite_r+0x2c>
   16174:	f013 0901 	ands.w	r9, r3, #1
   16178:	f040 80b0 	bne.w	162dc <__sfvwrite_r+0x210>
   1617c:	68a7      	ldr	r7, [r4, #8]
   1617e:	6820      	ldr	r0, [r4, #0]
   16180:	464d      	mov	r5, r9
   16182:	2d00      	cmp	r5, #0
   16184:	d054      	beq.n	16230 <__sfvwrite_r+0x164>
   16186:	059a      	lsls	r2, r3, #22
   16188:	f140 80bc 	bpl.w	16304 <__sfvwrite_r+0x238>
   1618c:	42af      	cmp	r7, r5
   1618e:	46bb      	mov	fp, r7
   16190:	f200 80e7 	bhi.w	16362 <__sfvwrite_r+0x296>
   16194:	f413 6f90 	tst.w	r3, #1152	; 0x480
   16198:	d02f      	beq.n	161fa <__sfvwrite_r+0x12e>
   1619a:	e9d4 1704 	ldrd	r1, r7, [r4, #16]
   1619e:	eb07 0747 	add.w	r7, r7, r7, lsl #1
   161a2:	eba0 0b01 	sub.w	fp, r0, r1
   161a6:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
   161aa:	1c68      	adds	r0, r5, #1
   161ac:	107f      	asrs	r7, r7, #1
   161ae:	4458      	add	r0, fp
   161b0:	42b8      	cmp	r0, r7
   161b2:	463a      	mov	r2, r7
   161b4:	bf84      	itt	hi
   161b6:	4607      	movhi	r7, r0
   161b8:	463a      	movhi	r2, r7
   161ba:	055b      	lsls	r3, r3, #21
   161bc:	f140 80e9 	bpl.w	16392 <__sfvwrite_r+0x2c6>
   161c0:	4611      	mov	r1, r2
   161c2:	4650      	mov	r0, sl
   161c4:	f7fe f87c 	bl	142c0 <_malloc_r>
   161c8:	2800      	cmp	r0, #0
   161ca:	f000 80f5 	beq.w	163b8 <__sfvwrite_r+0x2ec>
   161ce:	465a      	mov	r2, fp
   161d0:	6921      	ldr	r1, [r4, #16]
   161d2:	9001      	str	r0, [sp, #4]
   161d4:	f7fd ff34 	bl	14040 <memcpy>
   161d8:	89a2      	ldrh	r2, [r4, #12]
   161da:	9b01      	ldr	r3, [sp, #4]
   161dc:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
   161e0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   161e4:	81a2      	strh	r2, [r4, #12]
   161e6:	eba7 020b 	sub.w	r2, r7, fp
   161ea:	eb03 000b 	add.w	r0, r3, fp
   161ee:	6167      	str	r7, [r4, #20]
   161f0:	6123      	str	r3, [r4, #16]
   161f2:	6020      	str	r0, [r4, #0]
   161f4:	60a2      	str	r2, [r4, #8]
   161f6:	462f      	mov	r7, r5
   161f8:	46ab      	mov	fp, r5
   161fa:	465a      	mov	r2, fp
   161fc:	4649      	mov	r1, r9
   161fe:	f000 f967 	bl	164d0 <memmove>
   16202:	68a2      	ldr	r2, [r4, #8]
   16204:	6823      	ldr	r3, [r4, #0]
   16206:	1bd2      	subs	r2, r2, r7
   16208:	445b      	add	r3, fp
   1620a:	462f      	mov	r7, r5
   1620c:	60a2      	str	r2, [r4, #8]
   1620e:	6023      	str	r3, [r4, #0]
   16210:	2500      	movs	r5, #0
   16212:	f8d8 3008 	ldr.w	r3, [r8, #8]
   16216:	1bdb      	subs	r3, r3, r7
   16218:	44b9      	add	r9, r7
   1621a:	f8c8 3008 	str.w	r3, [r8, #8]
   1621e:	2b00      	cmp	r3, #0
   16220:	d03f      	beq.n	162a2 <__sfvwrite_r+0x1d6>
   16222:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   16226:	68a7      	ldr	r7, [r4, #8]
   16228:	6820      	ldr	r0, [r4, #0]
   1622a:	b29b      	uxth	r3, r3
   1622c:	2d00      	cmp	r5, #0
   1622e:	d1aa      	bne.n	16186 <__sfvwrite_r+0xba>
   16230:	e9d6 9500 	ldrd	r9, r5, [r6]
   16234:	3608      	adds	r6, #8
   16236:	e7a4      	b.n	16182 <__sfvwrite_r+0xb6>
   16238:	f10b 0308 	add.w	r3, fp, #8
   1623c:	e953 6702 	ldrd	r6, r7, [r3, #-8]
   16240:	469b      	mov	fp, r3
   16242:	3308      	adds	r3, #8
   16244:	2f00      	cmp	r7, #0
   16246:	d0f9      	beq.n	1623c <__sfvwrite_r+0x170>
   16248:	463a      	mov	r2, r7
   1624a:	210a      	movs	r1, #10
   1624c:	4630      	mov	r0, r6
   1624e:	f000 f8ef 	bl	16430 <memchr>
   16252:	2800      	cmp	r0, #0
   16254:	d053      	beq.n	162fe <__sfvwrite_r+0x232>
   16256:	3001      	adds	r0, #1
   16258:	eba0 0906 	sub.w	r9, r0, r6
   1625c:	464b      	mov	r3, r9
   1625e:	e9d4 1204 	ldrd	r1, r2, [r4, #16]
   16262:	6820      	ldr	r0, [r4, #0]
   16264:	42bb      	cmp	r3, r7
   16266:	bf28      	it	cs
   16268:	463b      	movcs	r3, r7
   1626a:	4288      	cmp	r0, r1
   1626c:	d903      	bls.n	16276 <__sfvwrite_r+0x1aa>
   1626e:	68a5      	ldr	r5, [r4, #8]
   16270:	4415      	add	r5, r2
   16272:	42ab      	cmp	r3, r5
   16274:	dc19      	bgt.n	162aa <__sfvwrite_r+0x1de>
   16276:	429a      	cmp	r2, r3
   16278:	dc7d      	bgt.n	16376 <__sfvwrite_r+0x2aa>
   1627a:	4613      	mov	r3, r2
   1627c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
   1627e:	6a21      	ldr	r1, [r4, #32]
   16280:	4632      	mov	r2, r6
   16282:	4650      	mov	r0, sl
   16284:	47a8      	blx	r5
   16286:	1e05      	subs	r5, r0, #0
   16288:	dd1c      	ble.n	162c4 <__sfvwrite_r+0x1f8>
   1628a:	ebb9 0905 	subs.w	r9, r9, r5
   1628e:	d06b      	beq.n	16368 <__sfvwrite_r+0x29c>
   16290:	2001      	movs	r0, #1
   16292:	f8d8 3008 	ldr.w	r3, [r8, #8]
   16296:	1b5b      	subs	r3, r3, r5
   16298:	442e      	add	r6, r5
   1629a:	1b7f      	subs	r7, r7, r5
   1629c:	f8c8 3008 	str.w	r3, [r8, #8]
   162a0:	bb13      	cbnz	r3, 162e8 <__sfvwrite_r+0x21c>
   162a2:	2000      	movs	r0, #0
   162a4:	b003      	add	sp, #12
   162a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   162aa:	4631      	mov	r1, r6
   162ac:	462a      	mov	r2, r5
   162ae:	f000 f90f 	bl	164d0 <memmove>
   162b2:	6823      	ldr	r3, [r4, #0]
   162b4:	442b      	add	r3, r5
   162b6:	6023      	str	r3, [r4, #0]
   162b8:	4621      	mov	r1, r4
   162ba:	4650      	mov	r0, sl
   162bc:	f7fe fec4 	bl	15048 <_fflush_r>
   162c0:	2800      	cmp	r0, #0
   162c2:	d0e2      	beq.n	1628a <__sfvwrite_r+0x1be>
   162c4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   162c8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   162cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   162d0:	81a3      	strh	r3, [r4, #12]
   162d2:	b003      	add	sp, #12
   162d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   162d8:	2000      	movs	r0, #0
   162da:	4770      	bx	lr
   162dc:	4633      	mov	r3, r6
   162de:	4691      	mov	r9, r2
   162e0:	4610      	mov	r0, r2
   162e2:	4617      	mov	r7, r2
   162e4:	464e      	mov	r6, r9
   162e6:	469b      	mov	fp, r3
   162e8:	2f00      	cmp	r7, #0
   162ea:	d0a5      	beq.n	16238 <__sfvwrite_r+0x16c>
   162ec:	2800      	cmp	r0, #0
   162ee:	d1b5      	bne.n	1625c <__sfvwrite_r+0x190>
   162f0:	463a      	mov	r2, r7
   162f2:	210a      	movs	r1, #10
   162f4:	4630      	mov	r0, r6
   162f6:	f000 f89b 	bl	16430 <memchr>
   162fa:	2800      	cmp	r0, #0
   162fc:	d1ab      	bne.n	16256 <__sfvwrite_r+0x18a>
   162fe:	1c7b      	adds	r3, r7, #1
   16300:	4699      	mov	r9, r3
   16302:	e7ac      	b.n	1625e <__sfvwrite_r+0x192>
   16304:	6923      	ldr	r3, [r4, #16]
   16306:	4283      	cmp	r3, r0
   16308:	d315      	bcc.n	16336 <__sfvwrite_r+0x26a>
   1630a:	6961      	ldr	r1, [r4, #20]
   1630c:	42a9      	cmp	r1, r5
   1630e:	d812      	bhi.n	16336 <__sfvwrite_r+0x26a>
   16310:	4b2e      	ldr	r3, [pc, #184]	; (163cc <__sfvwrite_r+0x300>)
   16312:	6aa7      	ldr	r7, [r4, #40]	; 0x28
   16314:	429d      	cmp	r5, r3
   16316:	bf94      	ite	ls
   16318:	462b      	movls	r3, r5
   1631a:	f06f 4300 	mvnhi.w	r3, #2147483648	; 0x80000000
   1631e:	464a      	mov	r2, r9
   16320:	fb93 f3f1 	sdiv	r3, r3, r1
   16324:	4650      	mov	r0, sl
   16326:	fb01 f303 	mul.w	r3, r1, r3
   1632a:	6a21      	ldr	r1, [r4, #32]
   1632c:	47b8      	blx	r7
   1632e:	1e07      	subs	r7, r0, #0
   16330:	ddc8      	ble.n	162c4 <__sfvwrite_r+0x1f8>
   16332:	1bed      	subs	r5, r5, r7
   16334:	e76d      	b.n	16212 <__sfvwrite_r+0x146>
   16336:	42af      	cmp	r7, r5
   16338:	bf28      	it	cs
   1633a:	462f      	movcs	r7, r5
   1633c:	463a      	mov	r2, r7
   1633e:	4649      	mov	r1, r9
   16340:	f000 f8c6 	bl	164d0 <memmove>
   16344:	68a3      	ldr	r3, [r4, #8]
   16346:	6822      	ldr	r2, [r4, #0]
   16348:	1bdb      	subs	r3, r3, r7
   1634a:	443a      	add	r2, r7
   1634c:	60a3      	str	r3, [r4, #8]
   1634e:	6022      	str	r2, [r4, #0]
   16350:	2b00      	cmp	r3, #0
   16352:	d1ee      	bne.n	16332 <__sfvwrite_r+0x266>
   16354:	4621      	mov	r1, r4
   16356:	4650      	mov	r0, sl
   16358:	f7fe fe76 	bl	15048 <_fflush_r>
   1635c:	2800      	cmp	r0, #0
   1635e:	d0e8      	beq.n	16332 <__sfvwrite_r+0x266>
   16360:	e7b0      	b.n	162c4 <__sfvwrite_r+0x1f8>
   16362:	462f      	mov	r7, r5
   16364:	46ab      	mov	fp, r5
   16366:	e748      	b.n	161fa <__sfvwrite_r+0x12e>
   16368:	4621      	mov	r1, r4
   1636a:	4650      	mov	r0, sl
   1636c:	f7fe fe6c 	bl	15048 <_fflush_r>
   16370:	2800      	cmp	r0, #0
   16372:	d08e      	beq.n	16292 <__sfvwrite_r+0x1c6>
   16374:	e7a6      	b.n	162c4 <__sfvwrite_r+0x1f8>
   16376:	461a      	mov	r2, r3
   16378:	4631      	mov	r1, r6
   1637a:	9301      	str	r3, [sp, #4]
   1637c:	f000 f8a8 	bl	164d0 <memmove>
   16380:	9b01      	ldr	r3, [sp, #4]
   16382:	68a1      	ldr	r1, [r4, #8]
   16384:	6822      	ldr	r2, [r4, #0]
   16386:	1ac9      	subs	r1, r1, r3
   16388:	441a      	add	r2, r3
   1638a:	60a1      	str	r1, [r4, #8]
   1638c:	6022      	str	r2, [r4, #0]
   1638e:	461d      	mov	r5, r3
   16390:	e77b      	b.n	1628a <__sfvwrite_r+0x1be>
   16392:	4650      	mov	r0, sl
   16394:	f000 f904 	bl	165a0 <_realloc_r>
   16398:	4603      	mov	r3, r0
   1639a:	2800      	cmp	r0, #0
   1639c:	f47f af23 	bne.w	161e6 <__sfvwrite_r+0x11a>
   163a0:	6921      	ldr	r1, [r4, #16]
   163a2:	4650      	mov	r0, sl
   163a4:	f7fd ff36 	bl	14214 <_free_r>
   163a8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   163ac:	220c      	movs	r2, #12
   163ae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
   163b2:	f8ca 2000 	str.w	r2, [sl]
   163b6:	e787      	b.n	162c8 <__sfvwrite_r+0x1fc>
   163b8:	230c      	movs	r3, #12
   163ba:	f8ca 3000 	str.w	r3, [sl]
   163be:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   163c2:	e781      	b.n	162c8 <__sfvwrite_r+0x1fc>
   163c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   163c8:	e76c      	b.n	162a4 <__sfvwrite_r+0x1d8>
   163ca:	bf00      	nop
   163cc:	7ffffffe 	.word	0x7ffffffe
   163d0:	7ffffc00 	.word	0x7ffffc00

000163d4 <_isatty_r>:
   163d4:	b538      	push	{r3, r4, r5, lr}
   163d6:	4c07      	ldr	r4, [pc, #28]	; (163f4 <_isatty_r+0x20>)
   163d8:	2300      	movs	r3, #0
   163da:	4605      	mov	r5, r0
   163dc:	4608      	mov	r0, r1
   163de:	6023      	str	r3, [r4, #0]
   163e0:	f7f5 fc86 	bl	bcf0 <_isatty>
   163e4:	1c43      	adds	r3, r0, #1
   163e6:	d000      	beq.n	163ea <_isatty_r+0x16>
   163e8:	bd38      	pop	{r3, r4, r5, pc}
   163ea:	6823      	ldr	r3, [r4, #0]
   163ec:	2b00      	cmp	r3, #0
   163ee:	d0fb      	beq.n	163e8 <_isatty_r+0x14>
   163f0:	602b      	str	r3, [r5, #0]
   163f2:	bd38      	pop	{r3, r4, r5, pc}
   163f4:	200159f4 	.word	0x200159f4

000163f8 <_lseek_r>:
   163f8:	b570      	push	{r4, r5, r6, lr}
   163fa:	460d      	mov	r5, r1
   163fc:	4c08      	ldr	r4, [pc, #32]	; (16420 <_lseek_r+0x28>)
   163fe:	4611      	mov	r1, r2
   16400:	4606      	mov	r6, r0
   16402:	461a      	mov	r2, r3
   16404:	4628      	mov	r0, r5
   16406:	2300      	movs	r3, #0
   16408:	6023      	str	r3, [r4, #0]
   1640a:	f7f5 fc73 	bl	bcf4 <_lseek>
   1640e:	1c43      	adds	r3, r0, #1
   16410:	d000      	beq.n	16414 <_lseek_r+0x1c>
   16412:	bd70      	pop	{r4, r5, r6, pc}
   16414:	6823      	ldr	r3, [r4, #0]
   16416:	2b00      	cmp	r3, #0
   16418:	d0fb      	beq.n	16412 <_lseek_r+0x1a>
   1641a:	6033      	str	r3, [r6, #0]
   1641c:	bd70      	pop	{r4, r5, r6, pc}
   1641e:	bf00      	nop
   16420:	200159f4 	.word	0x200159f4
	...

00016430 <memchr>:
   16430:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   16434:	2a10      	cmp	r2, #16
   16436:	db2b      	blt.n	16490 <memchr+0x60>
   16438:	f010 0f07 	tst.w	r0, #7
   1643c:	d008      	beq.n	16450 <memchr+0x20>
   1643e:	f810 3b01 	ldrb.w	r3, [r0], #1
   16442:	3a01      	subs	r2, #1
   16444:	428b      	cmp	r3, r1
   16446:	d02d      	beq.n	164a4 <memchr+0x74>
   16448:	f010 0f07 	tst.w	r0, #7
   1644c:	b342      	cbz	r2, 164a0 <memchr+0x70>
   1644e:	d1f6      	bne.n	1643e <memchr+0xe>
   16450:	b4f0      	push	{r4, r5, r6, r7}
   16452:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   16456:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   1645a:	f022 0407 	bic.w	r4, r2, #7
   1645e:	f07f 0700 	mvns.w	r7, #0
   16462:	2300      	movs	r3, #0
   16464:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   16468:	3c08      	subs	r4, #8
   1646a:	ea85 0501 	eor.w	r5, r5, r1
   1646e:	ea86 0601 	eor.w	r6, r6, r1
   16472:	fa85 f547 	uadd8	r5, r5, r7
   16476:	faa3 f587 	sel	r5, r3, r7
   1647a:	fa86 f647 	uadd8	r6, r6, r7
   1647e:	faa5 f687 	sel	r6, r5, r7
   16482:	b98e      	cbnz	r6, 164a8 <memchr+0x78>
   16484:	d1ee      	bne.n	16464 <memchr+0x34>
   16486:	bcf0      	pop	{r4, r5, r6, r7}
   16488:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1648c:	f002 0207 	and.w	r2, r2, #7
   16490:	b132      	cbz	r2, 164a0 <memchr+0x70>
   16492:	f810 3b01 	ldrb.w	r3, [r0], #1
   16496:	3a01      	subs	r2, #1
   16498:	ea83 0301 	eor.w	r3, r3, r1
   1649c:	b113      	cbz	r3, 164a4 <memchr+0x74>
   1649e:	d1f8      	bne.n	16492 <memchr+0x62>
   164a0:	2000      	movs	r0, #0
   164a2:	4770      	bx	lr
   164a4:	3801      	subs	r0, #1
   164a6:	4770      	bx	lr
   164a8:	2d00      	cmp	r5, #0
   164aa:	bf06      	itte	eq
   164ac:	4635      	moveq	r5, r6
   164ae:	3803      	subeq	r0, #3
   164b0:	3807      	subne	r0, #7
   164b2:	f015 0f01 	tst.w	r5, #1
   164b6:	d107      	bne.n	164c8 <memchr+0x98>
   164b8:	3001      	adds	r0, #1
   164ba:	f415 7f80 	tst.w	r5, #256	; 0x100
   164be:	bf02      	ittt	eq
   164c0:	3001      	addeq	r0, #1
   164c2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   164c6:	3001      	addeq	r0, #1
   164c8:	bcf0      	pop	{r4, r5, r6, r7}
   164ca:	3801      	subs	r0, #1
   164cc:	4770      	bx	lr
   164ce:	bf00      	nop

000164d0 <memmove>:
   164d0:	4288      	cmp	r0, r1
   164d2:	b4f0      	push	{r4, r5, r6, r7}
   164d4:	d90d      	bls.n	164f2 <memmove+0x22>
   164d6:	188b      	adds	r3, r1, r2
   164d8:	4283      	cmp	r3, r0
   164da:	d90a      	bls.n	164f2 <memmove+0x22>
   164dc:	1884      	adds	r4, r0, r2
   164de:	b132      	cbz	r2, 164ee <memmove+0x1e>
   164e0:	4622      	mov	r2, r4
   164e2:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   164e6:	f802 4d01 	strb.w	r4, [r2, #-1]!
   164ea:	4299      	cmp	r1, r3
   164ec:	d1f9      	bne.n	164e2 <memmove+0x12>
   164ee:	bcf0      	pop	{r4, r5, r6, r7}
   164f0:	4770      	bx	lr
   164f2:	2a0f      	cmp	r2, #15
   164f4:	d80e      	bhi.n	16514 <memmove+0x44>
   164f6:	4603      	mov	r3, r0
   164f8:	1e54      	subs	r4, r2, #1
   164fa:	2a00      	cmp	r2, #0
   164fc:	d0f7      	beq.n	164ee <memmove+0x1e>
   164fe:	3401      	adds	r4, #1
   16500:	440c      	add	r4, r1
   16502:	3b01      	subs	r3, #1
   16504:	f811 2b01 	ldrb.w	r2, [r1], #1
   16508:	f803 2f01 	strb.w	r2, [r3, #1]!
   1650c:	42a1      	cmp	r1, r4
   1650e:	d1f9      	bne.n	16504 <memmove+0x34>
   16510:	bcf0      	pop	{r4, r5, r6, r7}
   16512:	4770      	bx	lr
   16514:	ea40 0301 	orr.w	r3, r0, r1
   16518:	079b      	lsls	r3, r3, #30
   1651a:	d13b      	bne.n	16594 <memmove+0xc4>
   1651c:	f1a2 0710 	sub.w	r7, r2, #16
   16520:	093f      	lsrs	r7, r7, #4
   16522:	f101 0620 	add.w	r6, r1, #32
   16526:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   1652a:	f101 0310 	add.w	r3, r1, #16
   1652e:	f100 0410 	add.w	r4, r0, #16
   16532:	f853 5c10 	ldr.w	r5, [r3, #-16]
   16536:	f844 5c10 	str.w	r5, [r4, #-16]
   1653a:	f853 5c0c 	ldr.w	r5, [r3, #-12]
   1653e:	f844 5c0c 	str.w	r5, [r4, #-12]
   16542:	f853 5c08 	ldr.w	r5, [r3, #-8]
   16546:	f844 5c08 	str.w	r5, [r4, #-8]
   1654a:	f853 5c04 	ldr.w	r5, [r3, #-4]
   1654e:	f844 5c04 	str.w	r5, [r4, #-4]
   16552:	3310      	adds	r3, #16
   16554:	42b3      	cmp	r3, r6
   16556:	f104 0410 	add.w	r4, r4, #16
   1655a:	d1ea      	bne.n	16532 <memmove+0x62>
   1655c:	1c7b      	adds	r3, r7, #1
   1655e:	011b      	lsls	r3, r3, #4
   16560:	f012 0f0c 	tst.w	r2, #12
   16564:	4419      	add	r1, r3
   16566:	f002 050f 	and.w	r5, r2, #15
   1656a:	4403      	add	r3, r0
   1656c:	d015      	beq.n	1659a <memmove+0xca>
   1656e:	3d04      	subs	r5, #4
   16570:	08ad      	lsrs	r5, r5, #2
   16572:	eb03 0c85 	add.w	ip, r3, r5, lsl #2
   16576:	1f1c      	subs	r4, r3, #4
   16578:	460e      	mov	r6, r1
   1657a:	f856 7b04 	ldr.w	r7, [r6], #4
   1657e:	f844 7f04 	str.w	r7, [r4, #4]!
   16582:	4564      	cmp	r4, ip
   16584:	d1f9      	bne.n	1657a <memmove+0xaa>
   16586:	3501      	adds	r5, #1
   16588:	00ad      	lsls	r5, r5, #2
   1658a:	442b      	add	r3, r5
   1658c:	4429      	add	r1, r5
   1658e:	f002 0203 	and.w	r2, r2, #3
   16592:	e7b1      	b.n	164f8 <memmove+0x28>
   16594:	1e54      	subs	r4, r2, #1
   16596:	4603      	mov	r3, r0
   16598:	e7b1      	b.n	164fe <memmove+0x2e>
   1659a:	462a      	mov	r2, r5
   1659c:	e7ac      	b.n	164f8 <memmove+0x28>
   1659e:	bf00      	nop

000165a0 <_realloc_r>:
   165a0:	b309      	cbz	r1, 165e6 <_realloc_r+0x46>
   165a2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   165a4:	4614      	mov	r4, r2
   165a6:	b1ca      	cbz	r2, 165dc <_realloc_r+0x3c>
   165a8:	4606      	mov	r6, r0
   165aa:	460d      	mov	r5, r1
   165ac:	f000 f834 	bl	16618 <_malloc_usable_size_r>
   165b0:	42a0      	cmp	r0, r4
   165b2:	d302      	bcc.n	165ba <_realloc_r+0x1a>
   165b4:	462f      	mov	r7, r5
   165b6:	4638      	mov	r0, r7
   165b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   165ba:	4621      	mov	r1, r4
   165bc:	4630      	mov	r0, r6
   165be:	f7fd fe7f 	bl	142c0 <_malloc_r>
   165c2:	4607      	mov	r7, r0
   165c4:	2800      	cmp	r0, #0
   165c6:	d0f6      	beq.n	165b6 <_realloc_r+0x16>
   165c8:	4622      	mov	r2, r4
   165ca:	4629      	mov	r1, r5
   165cc:	f7fd fd38 	bl	14040 <memcpy>
   165d0:	4630      	mov	r0, r6
   165d2:	4629      	mov	r1, r5
   165d4:	f7fd fe1e 	bl	14214 <_free_r>
   165d8:	4638      	mov	r0, r7
   165da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   165dc:	4627      	mov	r7, r4
   165de:	f7fd fe19 	bl	14214 <_free_r>
   165e2:	4638      	mov	r0, r7
   165e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   165e6:	4611      	mov	r1, r2
   165e8:	f7fd be6a 	b.w	142c0 <_malloc_r>

000165ec <_read_r>:
   165ec:	b570      	push	{r4, r5, r6, lr}
   165ee:	460d      	mov	r5, r1
   165f0:	4c08      	ldr	r4, [pc, #32]	; (16614 <_read_r+0x28>)
   165f2:	4611      	mov	r1, r2
   165f4:	4606      	mov	r6, r0
   165f6:	461a      	mov	r2, r3
   165f8:	4628      	mov	r0, r5
   165fa:	2300      	movs	r3, #0
   165fc:	6023      	str	r3, [r4, #0]
   165fe:	f7f7 f967 	bl	d8d0 <_read>
   16602:	1c43      	adds	r3, r0, #1
   16604:	d000      	beq.n	16608 <_read_r+0x1c>
   16606:	bd70      	pop	{r4, r5, r6, pc}
   16608:	6823      	ldr	r3, [r4, #0]
   1660a:	2b00      	cmp	r3, #0
   1660c:	d0fb      	beq.n	16606 <_read_r+0x1a>
   1660e:	6033      	str	r3, [r6, #0]
   16610:	bd70      	pop	{r4, r5, r6, pc}
   16612:	bf00      	nop
   16614:	200159f4 	.word	0x200159f4

00016618 <_malloc_usable_size_r>:
   16618:	f851 3c04 	ldr.w	r3, [r1, #-4]
   1661c:	1f18      	subs	r0, r3, #4
   1661e:	2b00      	cmp	r3, #0
   16620:	bfbc      	itt	lt
   16622:	580b      	ldrlt	r3, [r1, r0]
   16624:	18c0      	addlt	r0, r0, r3
   16626:	4770      	bx	lr
   16628:	6d617246 	.word	0x6d617246
   1662c:	74532065 	.word	0x74532065
   16630:	20747261 	.word	0x20747261
   16634:	7366664f 	.word	0x7366664f
   16638:	7b007465 	.word	0x7b007465
   1663c:	70797422 	.word	0x70797422
   16640:	223a2265 	.word	0x223a2265
   16644:	4e524157 	.word	0x4e524157
   16648:	22474e49 	.word	0x22474e49
   1664c:	6422202c 	.word	0x6422202c
   16650:	22617461 	.word	0x22617461
   16654:	225b203a 	.word	0x225b203a
   16658:	5d227325 	.word	0x5d227325
   1665c:	000a0d7d 	.word	0x000a0d7d
   16660:	6e6e6f43 	.word	0x6e6e6f43
   16664:	00746365 	.word	0x00746365
   16668:	7974227b 	.word	0x7974227b
   1666c:	3a226570 	.word	0x3a226570
   16670:	41572220 	.word	0x41572220
   16674:	4e494e52 	.word	0x4e494e52
   16678:	202c2247 	.word	0x202c2247
   1667c:	74616422 	.word	0x74616422
   16680:	203a2261 	.word	0x203a2261
   16684:	6e55225b 	.word	0x6e55225b
   16688:	776f6e6b 	.word	0x776f6e6b
   1668c:	73654d20 	.word	0x73654d20
   16690:	65676173 	.word	0x65676173
   16694:	70795420 	.word	0x70795420
   16698:	7d5d2265 	.word	0x7d5d2265
   1669c:	227b000d 	.word	0x227b000d
   166a0:	65707974 	.word	0x65707974
   166a4:	22203a22 	.word	0x22203a22
   166a8:	4e524157 	.word	0x4e524157
   166ac:	22474e49 	.word	0x22474e49
   166b0:	6422202c 	.word	0x6422202c
   166b4:	22617461 	.word	0x22617461
   166b8:	225b203a 	.word	0x225b203a
   166bc:	61766e49 	.word	0x61766e49
   166c0:	2064696c 	.word	0x2064696c
   166c4:	63656843 	.word	0x63656843
   166c8:	6d75736b 	.word	0x6d75736b
   166cc:	0d7d5d22 	.word	0x0d7d5d22
   166d0:	6d695400 	.word	0x6d695400
   166d4:	74756f65 	.word	0x74756f65
   166d8:	73694420 	.word	0x73694420
   166dc:	6e6e6f63 	.word	0x6e6e6f63
   166e0:	20746365 	.word	0x20746365
   166e4:	65522026 	.word	0x65522026
   166e8:	20746573 	.word	0x20746573
   166ec:	65636552 	.word	0x65636552
   166f0:	72657669 	.word	0x72657669
   166f4:	6d695400 	.word	0x6d695400
   166f8:	74756f65 	.word	0x74756f65
   166fc:	52202620 	.word	0x52202620
   16700:	74657365 	.word	0x74657365
   16704:	63655220 	.word	0x63655220
   16708:	65766965 	.word	0x65766965
   1670c:	63250072 	.word	0x63250072
   16710:	63256325 	.word	0x63256325
   16714:	30256325 	.word	0x30256325
   16718:	30257832 	.word	0x30257832
   1671c:	30257832 	.word	0x30257832
   16720:	63257832 	.word	0x63257832
   16724:	000a3030 	.word	0x000a3030
   16728:	30256325 	.word	0x30256325
   1672c:	2e5f7833 	.word	0x2e5f7833
   16730:	2e2e2e2e 	.word	0x2e2e2e2e
   16734:	2e2e2e2e 	.word	0x2e2e2e2e
   16738:	2e2e2e2e 	.word	0x2e2e2e2e
   1673c:	2e2e2e2e 	.word	0x2e2e2e2e
   16740:	2e2e2e2e 	.word	0x2e2e2e2e
   16744:	2e2e2e2e 	.word	0x2e2e2e2e
   16748:	2e2e2e2e 	.word	0x2e2e2e2e
   1674c:	252e2e2e 	.word	0x252e2e2e
   16750:	63250063 	.word	0x63250063
   16754:	78333025 	.word	0x78333025
   16758:	2e2e2e5f 	.word	0x2e2e2e5f
   1675c:	2e2e2e2e 	.word	0x2e2e2e2e
   16760:	0063252e 	.word	0x0063252e
   16764:	30256325 	.word	0x30256325
   16768:	2e5f7833 	.word	0x2e5f7833
   1676c:	0063252e 	.word	0x0063252e
   16770:	30256325 	.word	0x30256325
   16774:	2e5f7833 	.word	0x2e5f7833
   16778:	2e2e2e2e 	.word	0x2e2e2e2e
   1677c:	0063252e 	.word	0x0063252e
   16780:	7974227b 	.word	0x7974227b
   16784:	3a226570 	.word	0x3a226570
   16788:	43574822 	.word	0x43574822
   1678c:	2c224746 	.word	0x2c224746
   16790:	61642220 	.word	0x61642220
   16794:	3a226174 	.word	0x3a226174
   16798:	64252220 	.word	0x64252220
   1679c:	0a0d7d22 	.word	0x0a0d7d22
   167a0:	204f4e00 	.word	0x204f4e00
   167a4:	52455355 	.word	0x52455355
   167a8:	574f5220 	.word	0x574f5220
   167ac:	45484320 	.word	0x45484320
   167b0:	00214b43 	.word	0x00214b43
   167b4:	55206f4e 	.word	0x55206f4e
   167b8:	2074696e 	.word	0x2074696e
   167bc:	74736554 	.word	0x74736554
   167c0:	206f4e00 	.word	0x206f4e00
   167c4:	64726148 	.word	0x64726148
   167c8:	65726177 	.word	0x65726177
   167cc:	73655420 	.word	0x73655420
   167d0:	65520074 	.word	0x65520074
   167d4:	6e696461 	.word	0x6e696461
   167d8:	73552067 	.word	0x73552067
   167dc:	52207265 	.word	0x52207265
   167e0:	7b00776f 	.word	0x7b00776f
   167e4:	70797422 	.word	0x70797422
   167e8:	223a2265 	.word	0x223a2265
   167ec:	22474f4c 	.word	0x22474f4c
   167f0:	6422202c 	.word	0x6422202c
   167f4:	22617461 	.word	0x22617461
   167f8:	225b203a 	.word	0x225b203a
   167fc:	5d227325 	.word	0x5d227325
   16800:	000a0d7d 	.word	0x000a0d7d
   16804:	69726556 	.word	0x69726556
   16808:	6e697966 	.word	0x6e697966
   1680c:	73552067 	.word	0x73552067
   16810:	52207265 	.word	0x52207265
   16814:	5500776f 	.word	0x5500776f
   16818:	74616470 	.word	0x74616470
   1681c:	20676e69 	.word	0x20676e69
   16820:	72657355 	.word	0x72657355
   16824:	776f5220 	.word	0x776f5220
   16828:	73795300 	.word	0x73795300
   1682c:	206d6574 	.word	0x206d6574
   16830:	65736552 	.word	0x65736552
   16834:	6e550074 	.word	0x6e550074
   16838:	6e616863 	.word	0x6e616863
   1683c:	20646567 	.word	0x20646567
   16840:	72657355 	.word	0x72657355
   16844:	776f5220 	.word	0x776f5220
   16848:	00          	.byte	0x00
   16849:	45          	.byte	0x45
   1684a:	5252      	.short	0x5252
   1684c:	6920524f 	.word	0x6920524f
   16850:	7865206e 	.word	0x7865206e
   16854:	6c5f7270 	.word	0x6c5f7270
   16858:	6c657665 	.word	0x6c657665
   1685c:	2928335f 	.word	0x2928335f
   16860:	73626100 	.word	0x73626100
   16864:	78697300 	.word	0x78697300
   16868:	64646100 	.word	0x64646100
   1686c:	69727000 	.word	0x69727000
   16870:	6900746e 	.word	0x6900746e
   16874:	75460066 	.word	0x75460066
   16878:	6974636e 	.word	0x6974636e
   1687c:	22206e6f 	.word	0x22206e6f
   16880:	20227325 	.word	0x20227325
   16884:	20746f6e 	.word	0x20746f6e
   16888:	6e756f66 	.word	0x6e756f66
   1688c:	000a2164 	.word	0x000a2164
   16890:	29642528 	.word	0x29642528
   16894:	32302500 	.word	0x32302500
   16898:	0078      	.short	0x0078
   1689a:	3002      	.short	0x3002
   1689c:	7b653035 	.word	0x7b653035
   168a0:	305a2870 	.word	0x305a2870
   168a4:	30307d29 	.word	0x30307d29
   168a8:	30306330 	.word	0x30306330
   168ac:	30020003 	.word	0x30020003
   168b0:	7b653035 	.word	0x7b653035
   168b4:	305a2870 	.word	0x305a2870
   168b8:	30307d29 	.word	0x30307d29
   168bc:	707b3830 	.word	0x707b3830
   168c0:	29345a28 	.word	0x29345a28
   168c4:	3002037d 	.word	0x3002037d
   168c8:	7b653033 	.word	0x7b653033
   168cc:	355a2870 	.word	0x355a2870
   168d0:	00037d29 	.word	0x00037d29
   168d4:	30353002 	.word	0x30353002
   168d8:	28707b65 	.word	0x28707b65
   168dc:	7d29305a 	.word	0x7d29305a
   168e0:	39303030 	.word	0x39303030
   168e4:	5a28707b 	.word	0x5a28707b
   168e8:	037d2934 	.word	0x037d2934
   168ec:	35300200 	.word	0x35300200
   168f0:	707b6530 	.word	0x707b6530
   168f4:	29305a28 	.word	0x29305a28
   168f8:	3030307d 	.word	0x3030307d
   168fc:	28707b61 	.word	0x28707b61
   16900:	7d29345a 	.word	0x7d29345a
   16904:	33300203 	.word	0x33300203
   16908:	707b6530 	.word	0x707b6530
   1690c:	29305a28 	.word	0x29305a28
   16910:	0200037d 	.word	0x0200037d
   16914:	65303530 	.word	0x65303530
   16918:	5a28707b 	.word	0x5a28707b
   1691c:	307d2930 	.word	0x307d2930
   16920:	7b623030 	.word	0x7b623030
   16924:	345a2870 	.word	0x345a2870
   16928:	02037d29 	.word	0x02037d29
   1692c:	66303330 	.word	0x66303330
   16930:	5a28707b 	.word	0x5a28707b
   16934:	037d2930 	.word	0x037d2930
   16938:	20495500 	.word	0x20495500
   1693c:	65776f50 	.word	0x65776f50
   16940:	6e452072 	.word	0x6e452072
   16944:	656c6261 	.word	0x656c6261
   16948:	696e4900 	.word	0x696e4900
   1694c:	6f4d2074 	.word	0x6f4d2074
   16950:	656c7564 	.word	0x656c7564
   16954:	4f50203a 	.word	0x4f50203a
   16958:	49003631 	.word	0x49003631
   1695c:	2074696e 	.word	0x2074696e
   16960:	75646f4d 	.word	0x75646f4d
   16964:	203a656c 	.word	0x203a656c
   16968:	36315542 	.word	0x36315542
   1696c:	696e4900 	.word	0x696e4900
   16970:	6f4d2074 	.word	0x6f4d2074
   16974:	656c7564 	.word	0x656c7564
   16978:	4250203a 	.word	0x4250203a
   1697c:	49003446 	.word	0x49003446
   16980:	2074696e 	.word	0x2074696e
   16984:	75646f4d 	.word	0x75646f4d
   16988:	203a656c 	.word	0x203a656c
   1698c:	36314e45 	.word	0x36314e45
   16990:	696e4900 	.word	0x696e4900
   16994:	6f4d2074 	.word	0x6f4d2074
   16998:	656c7564 	.word	0x656c7564
   1699c:	6e55203a 	.word	0x6e55203a
   169a0:	776f6e6b 	.word	0x776f6e6b
   169a4:	6f4d206e 	.word	0x6f4d206e
   169a8:	656c7564 	.word	0x656c7564
   169ac:	43574800 	.word	0x43574800
   169b0:	4d204746 	.word	0x4d204746
   169b4:	616d7369 	.word	0x616d7369
   169b8:	00686374 	.word	0x00686374
   169bc:	0f0e0d0c 	.word	0x0f0e0d0c
   169c0:	0b0a0908 	.word	0x0b0a0908
   169c4:	07060504 	.word	0x07060504
   169c8:	03020100 	.word	0x03020100
   169cc:	0f0e0d0c 	.word	0x0f0e0d0c
   169d0:	0b0a0908 	.word	0x0b0a0908
   169d4:	07060504 	.word	0x07060504
   169d8:	03020100 	.word	0x03020100
   169dc:	0f0e0d0c 	.word	0x0f0e0d0c
   169e0:	0b0a0908 	.word	0x0b0a0908
   169e4:	07060504 	.word	0x07060504
   169e8:	03020100 	.word	0x03020100
   169ec:	0f0e0d0c 	.word	0x0f0e0d0c
   169f0:	0b0a0908 	.word	0x0b0a0908
   169f4:	07060504 	.word	0x07060504
   169f8:	03020100 	.word	0x03020100
   169fc:	63256325 	.word	0x63256325
   16a00:	2e2e2e2e 	.word	0x2e2e2e2e
   16a04:	2e2e2e2e 	.word	0x2e2e2e2e
   16a08:	2e2e2e2e 	.word	0x2e2e2e2e
   16a0c:	6325      	.short	0x6325
   16a0e:	00          	.byte	0x00
   16a0f:	25          	.byte	0x25
   16a10:	33302563 	.word	0x33302563
   16a14:	63256578 	.word	0x63256578
   16a18:	00          	.byte	0x00
   16a19:	25          	.byte	0x25
   16a1a:	2563      	.short	0x2563
   16a1c:	5f783330 	.word	0x5f783330
   16a20:	2e2e2e2e 	.word	0x2e2e2e2e
   16a24:	25006325 	.word	0x25006325
   16a28:	33302563 	.word	0x33302563
   16a2c:	23006578 	.word	0x23006578
   16a30:	23200020 	.word	0x23200020
   16a34:	38302500 	.word	0x38302500
   16a38:	72670078 	.word	0x72670078
   16a3c:	735f6469 	.word	0x735f6469
   16a40:	3a3a7379 	.word	0x3a3a7379
   16a44:	63656863 	.word	0x63656863
   16a48:	6d75736b 	.word	0x6d75736b
   16a4c:	65684300 	.word	0x65684300
   16a50:	75736b63 	.word	0x75736b63
   16a54:	6552206d 	.word	0x6552206d
   16a58:	432f6461 	.word	0x432f6461
   16a5c:	75636c61 	.word	0x75636c61
   16a60:	6574616c 	.word	0x6574616c
   16a64:	63617000 	.word	0x63617000
   16a68:	7b74656b 	.word	0x7b74656b
   16a6c:	202c6425 	.word	0x202c6425
   16a70:	202c6425 	.word	0x202c6425
   16a74:	202c6425 	.word	0x202c6425
   16a78:	202c6425 	.word	0x202c6425
   16a7c:	202c6425 	.word	0x202c6425
   16a80:	202c6425 	.word	0x202c6425
   16a84:	202c6425 	.word	0x202c6425
   16a88:	207d6425 	.word	0x207d6425
   16a8c:	64616552 	.word	0x64616552
   16a90:	6425203a 	.word	0x6425203a
   16a94:	6143202c 	.word	0x6143202c
   16a98:	6c75636c 	.word	0x6c75636c
   16a9c:	3a657461 	.word	0x3a657461
   16aa0:	00642520 	.word	0x00642520
   16aa4:	63656843 	.word	0x63656843
   16aa8:	6d75736b 	.word	0x6d75736b
   16aac:	69725720 	.word	0x69725720
   16ab0:	432f6574 	.word	0x432f6574
   16ab4:	75636c61 	.word	0x75636c61
   16ab8:	6574616c 	.word	0x6574616c
   16abc:	65684300 	.word	0x65684300
   16ac0:	75736b63 	.word	0x75736b63
   16ac4:	764f206d 	.word	0x764f206d
   16ac8:	72777265 	.word	0x72777265
   16acc:	00657469 	.word	0x00657469
   16ad0:	61726150 	.word	0x61726150
   16ad4:	72706170 	.word	0x72706170
   16ad8:	73616b69 	.word	0x73616b69
   16adc:	00          	.byte	0x00
   16add:	25          	.byte	0x25
   16ade:	2563      	.short	0x2563
   16ae0:	5f783330 	.word	0x5f783330
   16ae4:	2e2e2e2e 	.word	0x2e2e2e2e
   16ae8:	02002e2e 	.word	0x02002e2e
   16aec:	65313430 	.word	0x65313430
   16af0:	5428707b 	.word	0x5428707b
   16af4:	307d2930 	.word	0x307d2930
   16af8:	28707b31 	.word	0x28707b31
   16afc:	7d29315a 	.word	0x7d29315a
   16b00:	5a28707b 	.word	0x5a28707b
   16b04:	7b7d2932 	.word	0x7b7d2932
   16b08:	335a2870 	.word	0x335a2870
   16b0c:	00037d29 	.word	0x00037d29
   16b10:	30303002 	.word	0x30303002
   16b14:	39303065 	.word	0x39303065
   16b18:	28707b30 	.word	0x28707b30
   16b1c:	7d293054 	.word	0x7d293054
   16b20:	5428707b 	.word	0x5428707b
   16b24:	037d2932 	.word	0x037d2932
   16b28:	30343002 	.word	0x30343002
   16b2c:	28707b65 	.word	0x28707b65
   16b30:	7d293054 	.word	0x7d293054
   16b34:	707b3130 	.word	0x707b3130
   16b38:	29325428 	.word	0x29325428
   16b3c:	0200037d 	.word	0x0200037d
   16b40:	65303030 	.word	0x65303030
   16b44:	30383030 	.word	0x30383030
   16b48:	5428707b 	.word	0x5428707b
   16b4c:	7b7d2930 	.word	0x7b7d2930
   16b50:	32542870 	.word	0x32542870
   16b54:	02037d29 	.word	0x02037d29
   16b58:	65303430 	.word	0x65303430
   16b5c:	5428707b 	.word	0x5428707b
   16b60:	307d2930 	.word	0x307d2930
   16b64:	28707b31 	.word	0x28707b31
   16b68:	7d293254 	.word	0x7d293254
   16b6c:	30020003 	.word	0x30020003
   16b70:	30653030 	.word	0x30653030
   16b74:	7b306230 	.word	0x7b306230
   16b78:	30542870 	.word	0x30542870
   16b7c:	707b7d29 	.word	0x707b7d29
   16b80:	29325428 	.word	0x29325428
   16b84:	3002037d 	.word	0x3002037d
   16b88:	7b653034 	.word	0x7b653034
   16b8c:	30542870 	.word	0x30542870
   16b90:	31307d29 	.word	0x31307d29
   16b94:	5428707b 	.word	0x5428707b
   16b98:	037d2932 	.word	0x037d2932
   16b9c:	34300200 	.word	0x34300200
   16ba0:	707b6531 	.word	0x707b6531
   16ba4:	29305428 	.word	0x29305428
   16ba8:	7b31307d 	.word	0x7b31307d
   16bac:	315a2870 	.word	0x315a2870
   16bb0:	707b7d29 	.word	0x707b7d29
   16bb4:	29325a28 	.word	0x29325a28
   16bb8:	28707b7d 	.word	0x28707b7d
   16bbc:	7d29335a 	.word	0x7d29335a
   16bc0:	34300203 	.word	0x34300203
   16bc4:	707b6531 	.word	0x707b6531
   16bc8:	29305428 	.word	0x29305428
   16bcc:	7b32307d 	.word	0x7b32307d
   16bd0:	315a2870 	.word	0x315a2870
   16bd4:	707b7d29 	.word	0x707b7d29
   16bd8:	29325a28 	.word	0x29325a28
   16bdc:	28707b7d 	.word	0x28707b7d
   16be0:	7d29335a 	.word	0x7d29335a
   16be4:	30020003 	.word	0x30020003
   16be8:	30653030 	.word	0x30653030
   16bec:	7b306230 	.word	0x7b306230
   16bf0:	30542870 	.word	0x30542870
   16bf4:	707b7d29 	.word	0x707b7d29
   16bf8:	29385428 	.word	0x29385428
   16bfc:	4923037d 	.word	0x4923037d
   16c00:	305a7b46 	.word	0x305a7b46
   16c04:	7d333d3d 	.word	0x7d333d3d
   16c08:	02485423 	.word	0x02485423
   16c0c:	65313430 	.word	0x65313430
   16c10:	5428707b 	.word	0x5428707b
   16c14:	307d2930 	.word	0x307d2930
   16c18:	28707b31 	.word	0x28707b31
   16c1c:	7d293854 	.word	0x7d293854
   16c20:	5a28707b 	.word	0x5a28707b
   16c24:	7b7d2932 	.word	0x7b7d2932
   16c28:	32312870 	.word	0x32312870
   16c2c:	38542d38 	.word	0x38542d38
   16c30:	23037d29 	.word	0x23037d29
   16c34:	45234c45 	.word	0x45234c45
   16c38:	3430024e 	.word	0x3430024e
   16c3c:	707b6530 	.word	0x707b6530
   16c40:	29305428 	.word	0x29305428
   16c44:	7b31307d 	.word	0x7b31307d
   16c48:	38542870 	.word	0x38542870
   16c4c:	00037d29 	.word	0x00037d29
   16c50:	30303002 	.word	0x30303002
   16c54:	62303065 	.word	0x62303065
   16c58:	28707b30 	.word	0x28707b30
   16c5c:	7d293054 	.word	0x7d293054
   16c60:	5428707b 	.word	0x5428707b
   16c64:	037d2938 	.word	0x037d2938
   16c68:	30343002 	.word	0x30343002
   16c6c:	28707b65 	.word	0x28707b65
   16c70:	7d293054 	.word	0x7d293054
   16c74:	707b3130 	.word	0x707b3130
   16c78:	29385428 	.word	0x29385428
   16c7c:	0200037d 	.word	0x0200037d
   16c80:	65303030 	.word	0x65303030
   16c84:	30393030 	.word	0x30393030
   16c88:	5428707b 	.word	0x5428707b
   16c8c:	7b7d2930 	.word	0x7b7d2930
   16c90:	32542870 	.word	0x32542870
   16c94:	02037d29 	.word	0x02037d29
   16c98:	65303430 	.word	0x65303430
   16c9c:	5428707b 	.word	0x5428707b
   16ca0:	307d2930 	.word	0x307d2930
   16ca4:	28707b32 	.word	0x28707b32
   16ca8:	7d293254 	.word	0x7d293254
   16cac:	30020003 	.word	0x30020003
   16cb0:	30653030 	.word	0x30653030
   16cb4:	7b303830 	.word	0x7b303830
   16cb8:	30542870 	.word	0x30542870
   16cbc:	707b7d29 	.word	0x707b7d29
   16cc0:	29325428 	.word	0x29325428
   16cc4:	3002037d 	.word	0x3002037d
   16cc8:	7b653034 	.word	0x7b653034
   16ccc:	30542870 	.word	0x30542870
   16cd0:	32307d29 	.word	0x32307d29
   16cd4:	5428707b 	.word	0x5428707b
   16cd8:	037d2932 	.word	0x037d2932
   16cdc:	67655200 	.word	0x67655200
   16ce0:	65747369 	.word	0x65747369
   16ce4:	63412072 	.word	0x63412072
   16ce8:	6e6f6974 	.word	0x6e6f6974
   16cec:	65764500 	.word	0x65764500
   16cf0:	4e20746e 	.word	0x4e20746e
   16cf4:	4620746f 	.word	0x4620746f
   16cf8:	646e756f 	.word	0x646e756f
   16cfc:	73452000 	.word	0x73452000
   16d00:	65706163 	.word	0x65706163
   16d04:	68432064 	.word	0x68432064
   16d08:	46207261 	.word	0x46207261
   16d0c:	646e756f 	.word	0x646e756f
   16d10:	30020020 	.word	0x30020020
   16d14:	7b653035 	.word	0x7b653035
   16d18:	305a2870 	.word	0x305a2870
   16d1c:	707b7d29 	.word	0x707b7d29
   16d20:	29305428 	.word	0x29305428
   16d24:	3030307d 	.word	0x3030307d
   16d28:	02000330 	.word	0x02000330
   16d2c:	65303530 	.word	0x65303530
   16d30:	5a28707b 	.word	0x5a28707b
   16d34:	7b7d2930 	.word	0x7b7d2930
   16d38:	30542870 	.word	0x30542870
   16d3c:	34307d29 	.word	0x34307d29
   16d40:	5428707b 	.word	0x5428707b
   16d44:	037d2932 	.word	0x037d2932
   16d48:	35300200 	.word	0x35300200
   16d4c:	707b6530 	.word	0x707b6530
   16d50:	29305a28 	.word	0x29305a28
   16d54:	28707b7d 	.word	0x28707b7d
   16d58:	7d293054 	.word	0x7d293054
   16d5c:	707b3530 	.word	0x707b3530
   16d60:	29325428 	.word	0x29325428
   16d64:	0200037d 	.word	0x0200037d
   16d68:	65303530 	.word	0x65303530
   16d6c:	5a28707b 	.word	0x5a28707b
   16d70:	7b7d2930 	.word	0x7b7d2930
   16d74:	30542870 	.word	0x30542870
   16d78:	31307d29 	.word	0x31307d29
   16d7c:	5428707b 	.word	0x5428707b
   16d80:	037d2932 	.word	0x037d2932
   16d84:	35300200 	.word	0x35300200
   16d88:	707b6530 	.word	0x707b6530
   16d8c:	29305a28 	.word	0x29305a28
   16d90:	28707b7d 	.word	0x28707b7d
   16d94:	7d293054 	.word	0x7d293054
   16d98:	707b3130 	.word	0x707b3130
   16d9c:	29355428 	.word	0x29355428
   16da0:	0200037d 	.word	0x0200037d
   16da4:	65303530 	.word	0x65303530
   16da8:	5a28707b 	.word	0x5a28707b
   16dac:	7b7d2930 	.word	0x7b7d2930
   16db0:	30542870 	.word	0x30542870
   16db4:	64307d29 	.word	0x64307d29
   16db8:	5428707b 	.word	0x5428707b
   16dbc:	037d2935 	.word	0x037d2935
   16dc0:	6e795300 	.word	0x6e795300
   16dc4:	20786174 	.word	0x20786174
   16dc8:	6f727245 	.word	0x6f727245
   16dcc:	000d2172 	.word	0x000d2172
   16dd0:	20001b6c 	.word	0x20001b6c
   16dd4:	2001228c 	.word	0x2001228c
   16dd8:	2000c2f0 	.word	0x2000c2f0
   16ddc:	20008cf0 	.word	0x20008cf0
   16de0:	682f2e2e 	.word	0x682f2e2e
   16de4:	732f6c61 	.word	0x732f6c61
   16de8:	682f6372 	.word	0x682f6372
   16dec:	695f6c61 	.word	0x695f6c61
   16df0:	00632e6f 	.word	0x00632e6f
   16df4:	682f2e2e 	.word	0x682f2e2e
   16df8:	732f6c61 	.word	0x732f6c61
   16dfc:	682f6372 	.word	0x682f6372
   16e00:	695f6c61 	.word	0x695f6c61
   16e04:	6d5f6332 	.word	0x6d5f6332
   16e08:	7973615f 	.word	0x7973615f
   16e0c:	632e636e 	.word	0x632e636e
   16e10:	00          	.byte	0x00
   16e11:	2e          	.byte	0x2e
   16e12:	2f2e      	.short	0x2f2e
   16e14:	2f6c7068 	.word	0x2f6c7068
   16e18:	2f746477 	.word	0x2f746477
   16e1c:	5f6c7068 	.word	0x5f6c7068
   16e20:	2e746477 	.word	0x2e746477
   16e24:	0063      	.short	0x0063
   16e26:	2e2e      	.short	0x2e2e
   16e28:	6c61682f 	.word	0x6c61682f
   16e2c:	6372732f 	.word	0x6372732f
   16e30:	6c61682f 	.word	0x6c61682f
   16e34:	6970735f 	.word	0x6970735f
   16e38:	645f6d5f 	.word	0x645f6d5f
   16e3c:	632e616d 	.word	0x632e616d
   16e40:	00000000 	.word	0x00000000

00016e44 <user_mux_confs>:
	...
   16e70:	04030201 04030201 00000000 00000000     ................
	...

00016e88 <channel_confs>:
   16e88:	05230522 05250524 00000000 00000000     ".#.$.%.........
	...

00016ec8 <interrupt_cfg>:
   16ec8:	00000002 00000002 00000002 00000002     ................
	...
   16f48:	682f2e2e 712f6c70 2f697073 5f6c7068     ../hpl/qspi/hpl_
   16f58:	69707371 2e00632e 70682f2e 766e2f6c     qspi.c.../hpl/nv
   16f68:	7274636d 70682f6c 766e5f6c 7274636d     mctrl/hpl_nvmctr
   16f78:	00632e6c 682f2e2e 732f6c61 682f6372     l.c.../hal/src/h
   16f88:	745f6c61 72656d69 0000632e              al_timer.c..

00016f94 <_usb_ep_cfgs>:
   16f94:	20001578 00000000 00000040 00000000     x.. ....@.......
	...
   16fac:	20001570 00000000 00000008 20001530     p.. ........0.. 
   16fbc:	20001528 00080040 00000000 00000000     (.. @...........
	...
   16fd4:	200014e8 00400000 20726d54 00637653     ... ..@.Tmr Svc.

00016fe4 <mouse_report_desc>:
   16fe4:	02090105 010901a1 090500a1 03290119     ..............).
   16ff4:	01250015 03950175 05750281 01810195     ..%.u.....u.....
   17004:	30090105 38093109 7f258115 03950875     ...0.1.8..%.u...
   17014:	c0c00681                                ....

00017018 <_cfgs>:
   17018:	00200600 08068000 00200400 08068000     .. ....... .....
   17028:	00201000 08068000 00200c00 08068000     .. ....... .....
	...
   17048:	00200b00 14000003 00200a00 08000002     .. ....... .....
   17058:	00201300 14000003 00000000 00000000     .. .............
	...
   17108:	00005400 1c000000 00005300 0c000000     .T.......S......
   17118:	682f2e2e 732f6c61 682f6372 615f6c61     ../hal/src/hal_a
   17128:	615f6364 636e7973 2e00632e 61682f2e     dc_async.c.../ha
   17138:	72732f6c 61682f63 61725f6c 735f646e     l/src/hal_rand_s
   17148:	2e636e79 2e2e0063 6c70682f 6e72742f     ync.c.../hpl/trn
   17158:	70682f67 72745f6c 632e676e               g/hpl_trng.c.

00017165 <keyboard_report_desc>:
   17165:	06090105 070501a1 e729e019 01250015     ..........)...%.
   17175:	08950175 01810281 65290019 65250015     u.........)e..%e
   17185:	06950875 08050081 05290119 01250015     u.........)...%.
   17195:	05950175 03950291 2ec00191 61682f2e     u............/ha
   171a5:	72732f6c 61682f63 73755f6c 5f747261     l/src/hal_usart_
   171b5:	636e7973 2e00632e 61682f2e 72732f6c     sync.c.../hal/sr
   171c5:	61682f63 6c665f6c 2e687361 2e2e0063     c/hal_flash.c...
   171d5:	6c61682f 6372732f 6c61682f 6970735f     /hal/src/hal_spi
   171e5:	615f6d5f 636e7973 2e00632e 61682f2e     _m_async.c.../ha
   171f5:	72732f6c 61682f63 72635f6c 79735f63     l/src/hal_crc_sy
   17205:	632e636e                                 nc.c.

0001720a <CSWTCH.37>:
   1720a:	010101ed                                 .......

00017211 <CSWTCH.40>:
   17211:	010100ed 2ef00201 61682f2e 74752f6c     ........./hal/ut
   17221:	2f736c69 2f637273 6c697475 696c5f73     ils/src/utils_li
   17231:	632e7473 2f2e2e00 2f6c7068 2f637472     st.c.../hpl/rtc/
   17241:	5f6c7068 2e637472 2e2e0063 6c61682f     hpl_rtc.c.../hal
   17251:	636e692f 6564756c 6c61682f 7464775f     /include/hal_wdt
   17261:	2e00682e 61682f2e 72732f6c 61682f63     .h.../hal/src/ha
   17271:	73755f6c 5f747261 6e797361 00632e63     l_usart_async.c.
   17281:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
   17291:	65735f6c 6d6f6372 0000632e 00400030     l_sercom.c..0.@.
   172a1:	00400034 00410120 00410140 00430000     4.@. .A.@.A...C.
   172b1:	00430004 00430008                        ..C...C...C

000172bc <sercomspi_regs>:
   172bc:	3020000c 00020000 00000000 01ff0005     .. 0............
   172cc:	20000c03 00000000 00000000 ff000600     ... ............
   172dc:	00000701                                ....

000172e0 <_i2cms>:
   172e0:	00000005 00200014 00000100 0000e6e5     ...... .........
   172f0:	00d70000 02dc6c00                       .....l..

000172f8 <_usarts>:
   172f8:	00000000 40100004 00030000 00700002     .......@......p.
   17308:	0000aaaa 00000000 00000001 40100004     ...............@
   17318:	00030000 00700002 0000aaaa 00000000     ......p.........
   17328:	00000002 40100004 00030000 00700002     .......@......p.
   17338:	00005555 00000000 00000004 40100004     UU.............@
   17348:	00030000 00700002 0000aaaa 00000000     ......p.........
   17358:	00000006 40100004 00030000 00700002     .......@......p.
   17368:	0000aaaa 00000000 682f2e2e 752f6c61     ........../hal/u
   17378:	736c6974 6372732f 6974752f 725f736c     tils/src/utils_r
   17388:	62676e69 65666675 00632e72 6d617845     ingbuffer.c.Exam
   17398:	54656c70 206b7361 3f3f3f3f 202e2e2e     pleTask ????... 
   173a8:	0d206425 494d000a 203a4944 78323025     %d ...MIDI: %02x
   173b8:	32302520 30252078 25207832 0a783230      %02x %02x %02x.
   173c8:	61745300 49207472 6974696e 7a696c61     .Start Initializ
   173d8:	44006465 49203135 0074696e 706d6f43     ed.D51 Init.Comp
   173e8:	7469736f 65442065 65636976 696e4920     osite Device Ini
   173f8:	6c616974 64657a69 69724700 6f4d2064     tialized.Grid Mo
   17408:	656c7564 696e4920 6c616974 64657a69     dule Initialized
   17418:	746e4500 6e697265 614d2067 4c206e69     .Entering Main L
   17428:	00706f6f 6d617845 00656c70 2064654c     oop.Example.Led 
   17438:	6b736154 6d6f4300 69736f70 44206574     Task.Composite D
   17448:	63697665 6f432065 63656e6e 00646574     evice Connected.
   17458:	65726f46 21726576 2e000d20 61682f2e     Forever! ..../ha
   17468:	72732f6c 61682f63 73715f6c 645f6970     l/src/hal_qspi_d
   17478:	632e616d 4c444900 25090045 75250963     ma.c.IDLE..%c.%u
   17488:	09752509 0a0d7525 2f2e2e00 2f6c7068     .%u.%u...../hpl/
   17498:	2f636461 5f6c7068 2e636461               adc/hpl_adc.c.

000174a6 <_adcs>:
   174a6:	01000000 0003000c 00041807 00000000     ................
   174b6:	0014080b 00010000 000c0100 18040003     ................
   174c6:	00000004 080b0000 00000014 752f2e2e     ............../u
   174d6:	642f6273 63697665 73752f65 2e636462     sb/device/usbdc.
   174e6:	2e2e0063 6c70682f 2f63742f 5f6c7068     c.../hpl/tc/hpl_
   174f6:	632e6374 38000000 3c004000 a0004000     tc.c...8.@.<.@..
   17506:	c0004101 14004101 18004200 14004200     .A...A...B...B..
   17516:	18004300                                 .C...C

0001751c <_tcs>:
   1751c:	006b0000 00000308 00000021 00003a98     ..k.....!....:..
   1752c:	00000000 006c0001 00000308 00000021     ......l.....!...
   1753c:	00003a98 00000000 006d0002 00000308     .:........m.....
   1754c:	00000021 00003a98 00000000 006e0003     !....:........n.
   1755c:	00000308 00000021 00003a98 00000000     ....!....:......

0001756c <_global_impure_ptr>:
   1756c:	20000550                                P.. 

00017570 <__sf_fake_stderr>:
	...

00017590 <__sf_fake_stdout>:
	...

000175b0 <__sf_fake_stdin>:
	...
   175d0:	2b302d23 00000020 004c6c68 45676665     #-0+ ...hlL.efgE
   175e0:	00004746 33323130 37363534 42413938     FG..0123456789AB
   175f0:	46454443 00000000 33323130 37363534     CDEF....01234567
   17600:	62613938 66656463 00000000              89abcdef....

0001760c <_init>:
   1760c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1760e:	bf00      	nop
   17610:	bcf8      	pop	{r3, r4, r5, r6, r7}
   17612:	bc08      	pop	{r3}
   17614:	469e      	mov	lr, r3
   17616:	4770      	bx	lr

00017618 <__frame_dummy_init_array_entry>:
   17618:	42cd 0000                                   .B..

0001761c <_fini>:
   1761c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1761e:	bf00      	nop
   17620:	bcf8      	pop	{r3, r4, r5, r6, r7}
   17622:	bc08      	pop	{r3}
   17624:	469e      	mov	lr, r3
   17626:	4770      	bx	lr

00017628 <__do_global_dtors_aux_fini_array_entry>:
   17628:	42a5 0000                                   .B..
