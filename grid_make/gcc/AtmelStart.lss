
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00012f70  00004000  00004000  00004000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000005b0  20000000  00016f70  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  000205b0  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  000205b0  2**0
                  CONTENTS
  4 .bss          0001ca34  200005b0  00017520  000205b0  2**4
                  ALLOC
  5 .stack        00010004  2001cfe4  00033f54  000205b0  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000205b0  2**0
                  CONTENTS, READONLY
  7 .comment      0000004c  00000000  00000000  000205de  2**0
                  CONTENTS, READONLY
  8 .debug_info   000b1d13  00000000  00000000  0002062a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 000111fb  00000000  00000000  000d233d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    00032705  00000000  00000000  000e3538  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00002bf8  00000000  00000000  00115c3d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00008938  00000000  00000000  00118835  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  00050024  00000000  00000000  0012116d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   0005fff1  00000000  00000000  00171191  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    001289e8  00000000  00000000  001d1182  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00008a3c  00000000  00000000  002f9b6c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00004000 <exception_table>:
    4000:	e8 cf 02 20 11 35 01 00 0d 35 01 00 0d 35 01 00     ... .5...5...5..
    4010:	0d 35 01 00 0d 35 01 00 0d 35 01 00 00 00 00 00     .5...5...5......
	...
    402c:	21 b6 00 00 0d 35 01 00 00 00 00 00 b1 b6 00 00     !....5..........
    403c:	15 b7 00 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .....5...5...5..
    404c:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    405c:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    406c:	09 fe 00 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .....5...5...5..
    407c:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    408c:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    409c:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    40ac:	0d 35 01 00 0d 35 01 00 d5 c4 00 00 01 c5 00 00     .5...5..........
    40bc:	85 e6 00 00 8d e6 00 00 95 e6 00 00 9d e6 00 00     ................
    40cc:	a5 e6 00 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .....5...5...5..
    40dc:	0d 35 01 00 0d 35 01 00 0d 35 01 00 00 00 00 00     .5...5...5......
	...
    40f4:	fd e1 00 00 79 16 01 00 89 16 01 00 91 16 01 00     ....y...........
    4104:	99 16 01 00 a1 16 01 00 b1 16 01 00 b9 16 01 00     ................
    4114:	c1 16 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .....5...5...5..
    4124:	0d 35 01 00 c9 16 01 00 0d 17 01 00 15 17 01 00     .5..............
    4134:	1d 17 01 00 25 17 01 00 35 17 01 00 3d 17 01 00     ....%...5...=...
    4144:	45 17 01 00 4d 17 01 00 dd 17 01 00 e5 17 01 00     E...M...........
    4154:	ed 17 01 00 f5 17 01 00 05 18 01 00 0d 18 01 00     ................
    4164:	15 18 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .....5...5...5..
    4174:	0d 35 01 00 00 00 00 00 00 00 00 00 99 dd 00 00     .5..............
    4184:	a1 dd 00 00 a9 dd 00 00 b1 dd 00 00 00 00 00 00     ................
    4194:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    41a4:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    41b4:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    41c4:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    41d4:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    41e4:	0d 35 01 00 0d 35 01 00 e1 3e 01 00 f1 3e 01 00     .5...5...>...>..
    41f4:	01 3f 01 00 11 3f 01 00 0d 35 01 00 0d 35 01 00     .?...?...5...5..
    4204:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    4214:	0d 35 01 00 dd 34 01 00 ed 34 01 00 f5 34 01 00     .5...4...4...4..
    4224:	05 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    4234:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    4244:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..
    4254:	0d 35 01 00 0d 35 01 00 0d 35 01 00 0d 35 01 00     .5...5...5...5..

00004264 <__do_global_dtors_aux>:
    4264:	b510      	push	{r4, lr}
    4266:	4c05      	ldr	r4, [pc, #20]	; (427c <__do_global_dtors_aux+0x18>)
    4268:	7823      	ldrb	r3, [r4, #0]
    426a:	b933      	cbnz	r3, 427a <__do_global_dtors_aux+0x16>
    426c:	4b04      	ldr	r3, [pc, #16]	; (4280 <__do_global_dtors_aux+0x1c>)
    426e:	b113      	cbz	r3, 4276 <__do_global_dtors_aux+0x12>
    4270:	4804      	ldr	r0, [pc, #16]	; (4284 <__do_global_dtors_aux+0x20>)
    4272:	f3af 8000 	nop.w
    4276:	2301      	movs	r3, #1
    4278:	7023      	strb	r3, [r4, #0]
    427a:	bd10      	pop	{r4, pc}
    427c:	200005b0 	.word	0x200005b0
    4280:	00000000 	.word	0x00000000
    4284:	00016f70 	.word	0x00016f70

00004288 <frame_dummy>:
    4288:	b508      	push	{r3, lr}
    428a:	4b03      	ldr	r3, [pc, #12]	; (4298 <frame_dummy+0x10>)
    428c:	b11b      	cbz	r3, 4296 <frame_dummy+0xe>
    428e:	4903      	ldr	r1, [pc, #12]	; (429c <frame_dummy+0x14>)
    4290:	4803      	ldr	r0, [pc, #12]	; (42a0 <frame_dummy+0x18>)
    4292:	f3af 8000 	nop.w
    4296:	bd08      	pop	{r3, pc}
    4298:	00000000 	.word	0x00000000
    429c:	200005b4 	.word	0x200005b4
    42a0:	00016f70 	.word	0x00016f70

000042a4 <audio_midi_req>:
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */

static int32_t audio_midi_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    42a4:	b410      	push	{r4}
		
	//return ERR_NOT_FOUND;	
		
	if ((0x81 == req->bmRequestType) && (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1])) {
    42a6:	780b      	ldrb	r3, [r1, #0]
    42a8:	2b81      	cmp	r3, #129	; 0x81
    42aa:	d110      	bne.n	42ce <audio_midi_req+0x2a>
    42ac:	4b1a      	ldr	r3, [pc, #104]	; (4318 <audio_midi_req+0x74>)
    42ae:	888a      	ldrh	r2, [r1, #4]
    42b0:	7919      	ldrb	r1, [r3, #4]
    42b2:	4291      	cmp	r1, r2
    42b4:	4619      	mov	r1, r3
    42b6:	d002      	beq.n	42be <audio_midi_req+0x1a>
    42b8:	795b      	ldrb	r3, [r3, #5]
    42ba:	4293      	cmp	r3, r2
    42bc:	d128      	bne.n	4310 <audio_midi_req+0x6c>
	return usbdc_xfer(ep, _audiodf_midi_funcd.audio_desc, _audiodf_midi_funcd.audio_desc[0], false);
    42be:	6809      	ldr	r1, [r1, #0]
    42c0:	780a      	ldrb	r2, [r1, #0]
    42c2:	2300      	movs	r3, #0
			switch (req->bRequest) {
				case 0x03: /* Get Protocol */
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
				case 0x0B: /* Set Protocol */
				_audiodf_midi_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
    42c4:	4c15      	ldr	r4, [pc, #84]	; (431c <audio_midi_req+0x78>)
    42c6:	46a4      	mov	ip, r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    42c8:	f85d 4b04 	ldr.w	r4, [sp], #4
				return usbdc_xfer(ep, NULL, 0, 0);
    42cc:	4760      	bx	ip
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    42ce:	f3c3 1341 	ubfx	r3, r3, #5, #2
    42d2:	2b01      	cmp	r3, #1
    42d4:	d11c      	bne.n	4310 <audio_midi_req+0x6c>
		if (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1]) {
    42d6:	4b10      	ldr	r3, [pc, #64]	; (4318 <audio_midi_req+0x74>)
    42d8:	888a      	ldrh	r2, [r1, #4]
    42da:	791c      	ldrb	r4, [r3, #4]
    42dc:	4294      	cmp	r4, r2
    42de:	461c      	mov	r4, r3
    42e0:	d002      	beq.n	42e8 <audio_midi_req+0x44>
    42e2:	795b      	ldrb	r3, [r3, #5]
    42e4:	4293      	cmp	r3, r2
    42e6:	d113      	bne.n	4310 <audio_midi_req+0x6c>
			switch (req->bRequest) {
    42e8:	784b      	ldrb	r3, [r1, #1]
    42ea:	2b03      	cmp	r3, #3
    42ec:	d006      	beq.n	42fc <audio_midi_req+0x58>
    42ee:	2b0b      	cmp	r3, #11
    42f0:	d008      	beq.n	4304 <audio_midi_req+0x60>
    42f2:	f06f 000c 	mvn.w	r0, #12
}
    42f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    42fa:	4770      	bx	lr
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
    42fc:	4908      	ldr	r1, [pc, #32]	; (4320 <audio_midi_req+0x7c>)
    42fe:	2300      	movs	r3, #0
    4300:	2201      	movs	r2, #1
    4302:	e7df      	b.n	42c4 <audio_midi_req+0x20>
				_audiodf_midi_funcd.protocol = req->wValue;
    4304:	884b      	ldrh	r3, [r1, #2]
    4306:	7223      	strb	r3, [r4, #8]
				return usbdc_xfer(ep, NULL, 0, 0);
    4308:	2300      	movs	r3, #0
    430a:	461a      	mov	r2, r3
    430c:	4619      	mov	r1, r3
    430e:	e7d9      	b.n	42c4 <audio_midi_req+0x20>
			return ERR_NOT_FOUND; // Never hit breakpoint here
    4310:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    4314:	e7ef      	b.n	42f6 <audio_midi_req+0x52>
    4316:	bf00      	nop
    4318:	200005cc 	.word	0x200005cc
    431c:	00013711 	.word	0x00013711
    4320:	200005d4 	.word	0x200005d4

00004324 <audio_midi_ctrl>:
	switch (ctrl) {
    4324:	2901      	cmp	r1, #1
{
    4326:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    432a:	460d      	mov	r5, r1
    432c:	4614      	mov	r4, r2
	switch (ctrl) {
    432e:	d070      	beq.n	4412 <audio_midi_ctrl+0xee>
    4330:	2902      	cmp	r1, #2
    4332:	f000 8092 	beq.w	445a <audio_midi_ctrl+0x136>
    4336:	2900      	cmp	r1, #0
    4338:	f040 8092 	bne.w	4460 <audio_midi_ctrl+0x13c>
		return audio_midi_enable(drv, (struct usbd_descriptors *)param);
    433c:	6886      	ldr	r6, [r0, #8]
	ifc = desc->sod;
    433e:	f8df 8148 	ldr.w	r8, [pc, #328]	; 4488 <audio_midi_ctrl+0x164>
    4342:	6810      	ldr	r0, [r2, #0]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    4344:	f8df 9144 	ldr.w	r9, [pc, #324]	; 448c <audio_midi_ctrl+0x168>
    4348:	1d37      	adds	r7, r6, #4
		if (NULL == ifc) {
    434a:	b920      	cbnz	r0, 4356 <audio_midi_ctrl+0x32>
			return ERR_NOT_FOUND;
    434c:	f06f 0009 	mvn.w	r0, #9
}
    4350:	b003      	add	sp, #12
    4352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    4356:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    4358:	7882      	ldrb	r2, [r0, #2]
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    435a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    435e:	2b01      	cmp	r3, #1
    4360:	d1f4      	bne.n	434c <audio_midi_ctrl+0x28>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    4362:	783b      	ldrb	r3, [r7, #0]
    4364:	429a      	cmp	r2, r3
    4366:	d07e      	beq.n	4466 <audio_midi_ctrl+0x142>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    4368:	2bff      	cmp	r3, #255	; 0xff
    436a:	d17f      	bne.n	446c <audio_midi_ctrl+0x148>
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    436c:	2d01      	cmp	r5, #1
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    436e:	f807 2b01 	strb.w	r2, [r7], #1
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    4372:	d009      	beq.n	4388 <audio_midi_ctrl+0x64>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);		
    4374:	6823      	ldr	r3, [r4, #0]
    4376:	6861      	ldr	r1, [r4, #4]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    4378:	7818      	ldrb	r0, [r3, #0]
    437a:	2204      	movs	r2, #4
    437c:	4418      	add	r0, r3
    437e:	47c0      	blx	r8
	for (i=0; i<2; i++){
    4380:	2d01      	cmp	r5, #1
    4382:	d042      	beq.n	440a <audio_midi_ctrl+0xe6>
    4384:	2501      	movs	r5, #1
    4386:	e7e0      	b.n	434a <audio_midi_ctrl+0x26>
			ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    4388:	6861      	ldr	r1, [r4, #4]
    438a:	f8df a104 	ldr.w	sl, [pc, #260]	; 4490 <audio_midi_ctrl+0x16c>
    438e:	2205      	movs	r2, #5
    4390:	47c0      	blx	r8
    4392:	4683      	mov	fp, r0
			while (NULL != ep) {
    4394:	f1bb 0f00 	cmp.w	fp, #0
    4398:	d0ec      	beq.n	4374 <audio_midi_ctrl+0x50>
				ep_desc.bEndpointAddress = ep[2];
    439a:	f89b 2002 	ldrb.w	r2, [fp, #2]
    439e:	f88d 2002 	strb.w	r2, [sp, #2]
				ep_desc.bmAttributes     = ep[3];
    43a2:	f89b 2003 	ldrb.w	r2, [fp, #3]
    43a6:	f88d 2003 	strb.w	r2, [sp, #3]
	return (ptr[0] + (ptr[1] << 8));
    43aa:	f89b 1005 	ldrb.w	r1, [fp, #5]
    43ae:	f89b 2004 	ldrb.w	r2, [fp, #4]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43b2:	4b31      	ldr	r3, [pc, #196]	; (4478 <audio_midi_ctrl+0x154>)
    43b4:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    43b8:	b292      	uxth	r2, r2
				ep_desc.wMaxPacketSize   = usb_get_u16(ep + 4);
    43ba:	f8ad 2004 	strh.w	r2, [sp, #4]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    43be:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    43c2:	b2d2      	uxtb	r2, r2
    43c4:	f889 2004 	strb.w	r2, [r9, #4]
				usb_debug2[0] = i;
    43c8:	2201      	movs	r2, #1
    43ca:	f889 2000 	strb.w	r2, [r9]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43ce:	f89d 0002 	ldrb.w	r0, [sp, #2]
    43d2:	f89d 1003 	ldrb.w	r1, [sp, #3]
    43d6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    43da:	b292      	uxth	r2, r2
    43dc:	4798      	blx	r3
    43de:	2800      	cmp	r0, #0
    43e0:	d147      	bne.n	4472 <audio_midi_ctrl+0x14e>
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    43e2:	f89d 2002 	ldrb.w	r2, [sp, #2]
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    43e6:	f89d 0002 	ldrb.w	r0, [sp, #2]
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    43ea:	0613      	lsls	r3, r2, #24
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    43ec:	b2c0      	uxtb	r0, r0
    43ee:	bf4c      	ite	mi
    43f0:	71b0      	strbmi	r0, [r6, #6]
					func_data->func_ep_out = ep_desc.bEndpointAddress;
    43f2:	71f0      	strbpl	r0, [r6, #7]
					usb_d_ep_enable(func_data->func_ep_out);
    43f4:	47d0      	blx	sl
				desc->sod = ep;
    43f6:	f8c4 b000 	str.w	fp, [r4]
	return (desc + usb_desc_len(desc));
    43fa:	f89b 0000 	ldrb.w	r0, [fp]
				ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    43fe:	6861      	ldr	r1, [r4, #4]
    4400:	4b1e      	ldr	r3, [pc, #120]	; (447c <audio_midi_ctrl+0x158>)
    4402:	4458      	add	r0, fp
    4404:	4798      	blx	r3
    4406:	4683      	mov	fp, r0
    4408:	e7c4      	b.n	4394 <audio_midi_ctrl+0x70>
	_audiodf_midi_funcd.enabled = true;
    440a:	4b1d      	ldr	r3, [pc, #116]	; (4480 <audio_midi_ctrl+0x15c>)
	return ERR_NONE;
    440c:	2000      	movs	r0, #0
	_audiodf_midi_funcd.enabled = true;
    440e:	745d      	strb	r5, [r3, #17]
	return ERR_NONE;
    4410:	e79e      	b.n	4350 <audio_midi_ctrl+0x2c>
		return audio_midi_disable(drv, (struct usbd_descriptors *)param);
    4412:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    4414:	b12a      	cbz	r2, 4422 <audio_midi_ctrl+0xfe>
		ifc_desc.bInterfaceClass = desc->sod[5];
    4416:	6813      	ldr	r3, [r2, #0]
		if ((AUDIO_AC_SUBCLASS != ifc_desc.bInterfaceClass) && (AUDIO_MS_SUBCLASS != ifc_desc.bInterfaceClass)) {
    4418:	795b      	ldrb	r3, [r3, #5]
    441a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    441e:	2b01      	cmp	r3, #1
    4420:	d194      	bne.n	434c <audio_midi_ctrl+0x28>
	if (func_data->func_iface[0] != 0xFF) {
    4422:	792b      	ldrb	r3, [r5, #4]
	if (func_data->func_ep_in != 0xFF) {
    4424:	79a8      	ldrb	r0, [r5, #6]
	if (func_data->func_iface[0] != 0xFF) {
    4426:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[0] = 0xFF;
    4428:	bf1c      	itt	ne
    442a:	23ff      	movne	r3, #255	; 0xff
    442c:	712b      	strbne	r3, [r5, #4]
	if (func_data->func_iface[1] != 0xFF) {
    442e:	796b      	ldrb	r3, [r5, #5]
    4430:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[1] = 0xFF;
    4432:	bf1c      	itt	ne
    4434:	23ff      	movne	r3, #255	; 0xff
    4436:	716b      	strbne	r3, [r5, #5]
	if (func_data->func_ep_in != 0xFF) {
    4438:	28ff      	cmp	r0, #255	; 0xff
    443a:	d003      	beq.n	4444 <audio_midi_ctrl+0x120>
		usb_d_ep_deinit(func_data->func_ep_in);
    443c:	4b11      	ldr	r3, [pc, #68]	; (4484 <audio_midi_ctrl+0x160>)
    443e:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    4440:	23ff      	movs	r3, #255	; 0xff
    4442:	71ab      	strb	r3, [r5, #6]
	if (func_data->func_ep_out != 0xFF) {
    4444:	79e8      	ldrb	r0, [r5, #7]
    4446:	28ff      	cmp	r0, #255	; 0xff
    4448:	d003      	beq.n	4452 <audio_midi_ctrl+0x12e>
		usb_d_ep_deinit(func_data->func_ep_out);
    444a:	4b0e      	ldr	r3, [pc, #56]	; (4484 <audio_midi_ctrl+0x160>)
    444c:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    444e:	23ff      	movs	r3, #255	; 0xff
    4450:	71eb      	strb	r3, [r5, #7]
	_audiodf_midi_funcd.enabled = false;
    4452:	4b0b      	ldr	r3, [pc, #44]	; (4480 <audio_midi_ctrl+0x15c>)
    4454:	2000      	movs	r0, #0
    4456:	7458      	strb	r0, [r3, #17]
	return ERR_NONE;
    4458:	e77a      	b.n	4350 <audio_midi_ctrl+0x2c>
		return ERR_UNSUPPORTED_OP;
    445a:	f06f 001a 	mvn.w	r0, #26
    445e:	e777      	b.n	4350 <audio_midi_ctrl+0x2c>
	switch (ctrl) {
    4460:	f06f 000c 	mvn.w	r0, #12
    4464:	e774      	b.n	4350 <audio_midi_ctrl+0x2c>
				return ERR_ALREADY_INITIALIZED;
    4466:	f06f 0011 	mvn.w	r0, #17
    446a:	e771      	b.n	4350 <audio_midi_ctrl+0x2c>
				return ERR_NO_RESOURCE;
    446c:	f06f 001b 	mvn.w	r0, #27
    4470:	e76e      	b.n	4350 <audio_midi_ctrl+0x2c>
					return ERR_NOT_INITIALIZED;
    4472:	f06f 0013 	mvn.w	r0, #19
    4476:	e76b      	b.n	4350 <audio_midi_ctrl+0x2c>
    4478:	0000f911 	.word	0x0000f911
    447c:	0000bbf7 	.word	0x0000bbf7
    4480:	200005cc 	.word	0x200005cc
    4484:	0000f975 	.word	0x0000f975
    4488:	0000bbdd 	.word	0x0000bbdd
    448c:	20009140 	.word	0x20009140
    4490:	0000f9a1 	.word	0x0000f9a1

00004494 <audiodf_midi_init>:

/**
 * \brief Initialize the USB Audio Midi Function Driver
 */
int32_t audiodf_midi_init(void)
{
    4494:	b508      	push	{r3, lr}
	
	
	if (usbdc_get_state() > USBD_S_POWER) {
    4496:	4b0a      	ldr	r3, [pc, #40]	; (44c0 <audiodf_midi_init+0x2c>)
    4498:	4798      	blx	r3
    449a:	2801      	cmp	r0, #1
    449c:	d80c      	bhi.n	44b8 <audiodf_midi_init+0x24>
		return ERR_DENIED;
	}
	
	_audiodf_midi.ctrl      = audio_midi_ctrl;
    449e:	4809      	ldr	r0, [pc, #36]	; (44c4 <audiodf_midi_init+0x30>)
    44a0:	4b09      	ldr	r3, [pc, #36]	; (44c8 <audiodf_midi_init+0x34>)
	_audiodf_midi.func_data = &_audiodf_midi_funcd;
    44a2:	e9c0 3006 	strd	r3, r0, [r0, #24]
	
	usbdc_register_function(&_audiodf_midi);
    44a6:	4b09      	ldr	r3, [pc, #36]	; (44cc <audiodf_midi_init+0x38>)
    44a8:	3014      	adds	r0, #20
    44aa:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &audio_midi_req_h);
    44ac:	2001      	movs	r0, #1
    44ae:	4908      	ldr	r1, [pc, #32]	; (44d0 <audiodf_midi_init+0x3c>)
    44b0:	4b08      	ldr	r3, [pc, #32]	; (44d4 <audiodf_midi_init+0x40>)
    44b2:	4798      	blx	r3
	return ERR_NONE;
    44b4:	2000      	movs	r0, #0
}
    44b6:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    44b8:	f06f 0010 	mvn.w	r0, #16
    44bc:	e7fb      	b.n	44b6 <audiodf_midi_init+0x22>
    44be:	bf00      	nop
    44c0:	00013b49 	.word	0x00013b49
    44c4:	200005cc 	.word	0x200005cc
    44c8:	00004325 	.word	0x00004325
    44cc:	00013af1 	.word	0x00013af1
    44d0:	20000000 	.word	0x20000000
    44d4:	00013a69 	.word	0x00013a69

000044d8 <audiodf_midi_write>:
}



int32_t audiodf_midi_write(uint8_t byte0, uint8_t byte1, uint8_t byte2, uint8_t byte3)
{
    44d8:	b410      	push	{r4}
		return ERR_DENIED;
	}
	
	// if previous xfer is completed
	
	_audiodf_midi_funcd.midi_report[0] = byte0;
    44da:	4c07      	ldr	r4, [pc, #28]	; (44f8 <audiodf_midi_write+0x20>)
    44dc:	7260      	strb	r0, [r4, #9]
	_audiodf_midi_funcd.midi_report[1] = byte1;
    44de:	72a1      	strb	r1, [r4, #10]
	_audiodf_midi_funcd.midi_report[2] = byte2;
    44e0:	72e2      	strb	r2, [r4, #11]
	_audiodf_midi_funcd.midi_report[3] = byte3;
    44e2:	7323      	strb	r3, [r4, #12]

	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    44e4:	79a0      	ldrb	r0, [r4, #6]
    44e6:	f104 0109 	add.w	r1, r4, #9
    44ea:	4c04      	ldr	r4, [pc, #16]	; (44fc <audiodf_midi_write+0x24>)
    44ec:	2300      	movs	r3, #0
    44ee:	46a4      	mov	ip, r4
    44f0:	2204      	movs	r2, #4
	
}
    44f2:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    44f6:	4760      	bx	ip
    44f8:	200005cc 	.word	0x200005cc
    44fc:	00013711 	.word	0x00013711

00004500 <audiodf_midi_write_status>:

int32_t audiodf_midi_write_status(){
    4500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	
	struct usb_d_ep_status epstat;
	return usb_d_ep_get_status(_audiodf_midi_funcd.func_ep_in, &epstat);
    4502:	4b04      	ldr	r3, [pc, #16]	; (4514 <audiodf_midi_write_status+0x14>)
    4504:	a901      	add	r1, sp, #4
    4506:	7998      	ldrb	r0, [r3, #6]
    4508:	4b03      	ldr	r3, [pc, #12]	; (4518 <audiodf_midi_write_status+0x18>)
    450a:	4798      	blx	r3
	
}
    450c:	b005      	add	sp, #20
    450e:	f85d fb04 	ldr.w	pc, [sp], #4
    4512:	bf00      	nop
    4514:	200005cc 	.word	0x200005cc
    4518:	0000fac9 	.word	0x0000fac9

0000451c <audiodf_midi_read>:



int32_t audiodf_midi_read(uint8_t *buf, uint32_t size)
{
    451c:	b410      	push	{r4}
    451e:	460a      	mov	r2, r1
	if (!audiodf_midi_is_enabled()) {
		return ERR_DENIED;
	}
		
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4520:	4c04      	ldr	r4, [pc, #16]	; (4534 <audiodf_midi_read+0x18>)
    4522:	4601      	mov	r1, r0
    4524:	4804      	ldr	r0, [pc, #16]	; (4538 <audiodf_midi_read+0x1c>)
    4526:	46a4      	mov	ip, r4
    4528:	79c0      	ldrb	r0, [r0, #7]
}
    452a:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    452e:	2300      	movs	r3, #0
    4530:	4760      	bx	ip
    4532:	bf00      	nop
    4534:	00013711 	.word	0x00013711
    4538:	200005cc 	.word	0x200005cc

0000453c <audiodf_midi_register_callback>:


int32_t audiodf_midi_register_callback(enum audiodf_midi_cb_type cb_type, FUNC_PTR func)
{
    453c:	b510      	push	{r4, lr}
    453e:	460a      	mov	r2, r1
	switch (cb_type) {
    4540:	b120      	cbz	r0, 454c <audiodf_midi_register_callback+0x10>
    4542:	2801      	cmp	r0, #1
    4544:	d009      	beq.n	455a <audiodf_midi_register_callback+0x1e>
    4546:	f06f 000c 	mvn.w	r0, #12
		break;
		default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
}
    454a:	bd10      	pop	{r4, pc}
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    454c:	4b05      	ldr	r3, [pc, #20]	; (4564 <audiodf_midi_register_callback+0x28>)
    454e:	79d8      	ldrb	r0, [r3, #7]
    4550:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    4552:	4b05      	ldr	r3, [pc, #20]	; (4568 <audiodf_midi_register_callback+0x2c>)
    4554:	4798      	blx	r3
	return ERR_NONE;
    4556:	2000      	movs	r0, #0
		break;
    4558:	e7f7      	b.n	454a <audiodf_midi_register_callback+0xe>
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    455a:	4b02      	ldr	r3, [pc, #8]	; (4564 <audiodf_midi_register_callback+0x28>)
    455c:	2102      	movs	r1, #2
    455e:	7998      	ldrb	r0, [r3, #6]
    4560:	e7f7      	b.n	4552 <audiodf_midi_register_callback+0x16>
    4562:	bf00      	nop
    4564:	200005cc 	.word	0x200005cc
    4568:	0000fb89 	.word	0x0000fb89

0000456c <grid_ain_channel_init>:

struct AIN_Channel* ain_channel_buffer;



uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    456c:	b570      	push	{r4, r5, r6, lr}
	instance->buffer_depth = buffer_depth;
	
	instance->result_format = result_format;
	instance->result_resolution = result_resolution;
	
	instance->result_average = 0;
    456e:	2500      	movs	r5, #0
	instance->result_format = result_format;
    4570:	7142      	strb	r2, [r0, #5]
	instance->result_resolution = result_resolution;
    4572:	7183      	strb	r3, [r0, #6]
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    4574:	4604      	mov	r4, r0
	
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4576:	4b0a      	ldr	r3, [pc, #40]	; (45a0 <grid_ain_channel_init+0x34>)
	instance->buffer_depth = buffer_depth;
    4578:	7101      	strb	r1, [r0, #4]
	instance->result_average = 0;
    457a:	8145      	strh	r5, [r0, #10]
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    457c:	0048      	lsls	r0, r1, #1
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    457e:	460e      	mov	r6, r1
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4580:	4798      	blx	r3
	
	// Init the whole buffer with zeros
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    4582:	462b      	mov	r3, r5
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4584:	6020      	str	r0, [r4, #0]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    4586:	462a      	mov	r2, r5
    4588:	b2d9      	uxtb	r1, r3
    458a:	428e      	cmp	r6, r1
    458c:	d803      	bhi.n	4596 <grid_ain_channel_init+0x2a>
		instance->buffer[i] = 0;
	}
	
	instance->result_changed = 0;
    458e:	81a2      	strh	r2, [r4, #12]
	instance->result_value = 0;
    4590:	8122      	strh	r2, [r4, #8]
		
	return 0;
}
    4592:	2000      	movs	r0, #0
    4594:	bd70      	pop	{r4, r5, r6, pc}
		instance->buffer[i] = 0;
    4596:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    459a:	3301      	adds	r3, #1
    459c:	e7f4      	b.n	4588 <grid_ain_channel_init+0x1c>
    459e:	bf00      	nop
    45a0:	00014799 	.word	0x00014799

000045a4 <grid_ain_init>:
	}
}


/** Initialize ain buffer for a given number of analog channels */
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    45a8:	4605      	mov	r5, r0
    45aa:	4699      	mov	r9, r3
	
	// ain_channel_result_resolution = resolution
	
	
	// 2D buffer, example: 16 potentiometers, last 32 samples stored for each
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45ac:	0100      	lsls	r0, r0, #4
    45ae:	4b0b      	ldr	r3, [pc, #44]	; (45dc <grid_ain_init+0x38>)
    45b0:	4e0b      	ldr	r6, [pc, #44]	; (45e0 <grid_ain_init+0x3c>)

	for (uint8_t i=0; i<length; i++){
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45b2:	f8df a030 	ldr.w	sl, [pc, #48]	; 45e4 <grid_ain_init+0x40>
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45b6:	460f      	mov	r7, r1
    45b8:	4690      	mov	r8, r2
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45ba:	4798      	blx	r3
	for (uint8_t i=0; i<length; i++){
    45bc:	2400      	movs	r4, #0
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45be:	6030      	str	r0, [r6, #0]
	for (uint8_t i=0; i<length; i++){
    45c0:	42a5      	cmp	r5, r4
    45c2:	d102      	bne.n	45ca <grid_ain_init+0x26>
	}

	return 0;
}
    45c4:	2000      	movs	r0, #0
    45c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45ca:	6830      	ldr	r0, [r6, #0]
    45cc:	464b      	mov	r3, r9
    45ce:	eb00 1004 	add.w	r0, r0, r4, lsl #4
    45d2:	4642      	mov	r2, r8
    45d4:	4639      	mov	r1, r7
    45d6:	47d0      	blx	sl
	for (uint8_t i=0; i<length; i++){
    45d8:	3401      	adds	r4, #1
    45da:	e7f1      	b.n	45c0 <grid_ain_init+0x1c>
    45dc:	00014799 	.word	0x00014799
    45e0:	2000c0a8 	.word	0x2000c0a8
    45e4:	0000456d 	.word	0x0000456d

000045e8 <grid_ain_add_sample>:

uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    45e8:	4b30      	ldr	r3, [pc, #192]	; (46ac <grid_ain_add_sample+0xc4>)
uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
    45ea:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    45ee:	681a      	ldr	r2, [r3, #0]
    45f0:	0104      	lsls	r4, r0, #4
    45f2:	eb02 1300 	add.w	r3, r2, r0, lsl #4
	uint16_t maximum = 0;

	uint8_t minimum_index = 0;
	uint8_t maximum_index = 0;
	
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    45f6:	5914      	ldr	r4, [r2, r4]
    45f8:	f893 e004 	ldrb.w	lr, [r3, #4]
    45fc:	2200      	movs	r2, #0
	uint8_t maximum_index = 0;
    45fe:	4615      	mov	r5, r2
	uint8_t minimum_index = 0;
    4600:	4616      	mov	r6, r2
	uint16_t maximum = 0;
    4602:	4691      	mov	r9, r2
	uint16_t minimum = -1; // -1 trick to get the largest possible number
    4604:	f64f 78ff 	movw	r8, #65535	; 0xffff
	uint32_t sum = 0;
    4608:	4610      	mov	r0, r2
    460a:	fa5f fc82 	uxtb.w	ip, r2
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    460e:	45e6      	cmp	lr, ip
    4610:	d83c      	bhi.n	468c <grid_ain_add_sample+0xa4>
	
	}
	
	uint16_t average = sum/instance->buffer_depth;
	
	if (value>average){		
    4612:	180a      	adds	r2, r1, r0
	uint16_t average = sum/instance->buffer_depth;
    4614:	fbb0 f0fe 	udiv	r0, r0, lr
	if (value>average){		
    4618:	b280      	uxth	r0, r0
    461a:	4288      	cmp	r0, r1
		// Replace minimum in the buffer and recalculate sum
		sum = sum - instance->buffer[minimum_index] + value;
    461c:	bf34      	ite	cc
    461e:	b230      	sxthcc	r0, r6
		instance->buffer[minimum_index] = value;		
	}else{
		// Replace maximum in the buffer and recalculate sum
		sum = sum - instance->buffer[maximum_index] + value;
    4620:	b228      	sxthcs	r0, r5
    4622:	f834 5010 	ldrh.w	r5, [r4, r0, lsl #1]
		instance->buffer[maximum_index] = value;
    4626:	f824 1010 	strh.w	r1, [r4, r0, lsl #1]
		sum = sum - instance->buffer[maximum_index] + value;
    462a:	1b52      	subs	r2, r2, r5
	}
	
	// Recalculate average
	average = sum/instance->buffer_depth;
    462c:	7919      	ldrb	r1, [r3, #4]
    462e:	fbb2 f2f1 	udiv	r2, r2, r1
	
	
	uint8_t downscale_factor = (16-instance->result_resolution);
    4632:	7999      	ldrb	r1, [r3, #6]
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    4634:	795c      	ldrb	r4, [r3, #5]
	
	uint16_t downsampled = average>>downscale_factor;
	uint16_t upscaled    = downsampled<<upscale_factor;
	
	uint8_t criteria_a = instance->result_value != upscaled;
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4636:	895e      	ldrh	r6, [r3, #10]
	
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
	uint8_t criteria_d = upscaled==0;
	
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4638:	f8b3 e008 	ldrh.w	lr, [r3, #8]
	uint8_t downscale_factor = (16-instance->result_resolution);
    463c:	f1c1 0710 	rsb	r7, r1, #16
	uint16_t downsampled = average>>downscale_factor;
    4640:	b295      	uxth	r5, r2
    4642:	b2ff      	uxtb	r7, r7
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    4644:	1a61      	subs	r1, r4, r1
	uint16_t upscaled    = downsampled<<upscale_factor;
    4646:	b2c8      	uxtb	r0, r1
	uint16_t downsampled = average>>downscale_factor;
    4648:	fa45 f107 	asr.w	r1, r5, r7
	uint16_t upscaled    = downsampled<<upscale_factor;
    464c:	b289      	uxth	r1, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    464e:	1b76      	subs	r6, r6, r5
	uint16_t upscaled    = downsampled<<upscale_factor;
    4650:	4081      	lsls	r1, r0
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4652:	2e00      	cmp	r6, #0
	uint16_t upscaled    = downsampled<<upscale_factor;
    4654:	fa1f fc81 	uxth.w	ip, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4658:	bfb8      	it	lt
    465a:	4276      	neglt	r6, r6
    465c:	2501      	movs	r5, #1
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    465e:	45e6      	cmp	lr, ip
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4660:	fa05 f707 	lsl.w	r7, r5, r7
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4664:	d01f      	beq.n	46a6 <grid_ain_add_sample+0xbe>
    4666:	42be      	cmp	r6, r7
    4668:	dc09      	bgt.n	467e <grid_ain_add_sample+0x96>
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
    466a:	fa05 f404 	lsl.w	r4, r5, r4
    466e:	fa05 f000 	lsl.w	r0, r5, r0
    4672:	1a20      	subs	r0, r4, r0
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4674:	4560      	cmp	r0, ip
    4676:	d002      	beq.n	467e <grid_ain_add_sample+0x96>
    4678:	f1bc 0f00 	cmp.w	ip, #0
    467c:	d113      	bne.n	46a6 <grid_ain_add_sample+0xbe>
		
		instance->result_average = average;
		instance->result_value = upscaled;
		instance->result_changed = 1;
    467e:	2001      	movs	r0, #1
	average = sum/instance->buffer_depth;
    4680:	815a      	strh	r2, [r3, #10]
		instance->result_value = upscaled;
    4682:	f8a3 c008 	strh.w	ip, [r3, #8]
		instance->result_changed = 1;
    4686:	8198      	strh	r0, [r3, #12]
		return 1;
	}else{		
		return 0;
	}
	
}
    4688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		uint16_t current = instance->buffer[i];
    468c:	f834 7012 	ldrh.w	r7, [r4, r2, lsl #1]
		if (current > maximum){
    4690:	45b9      	cmp	r9, r7
    4692:	bf3c      	itt	cc
    4694:	4665      	movcc	r5, ip
    4696:	46b9      	movcc	r9, r7
		if (current < minimum){
    4698:	45b8      	cmp	r8, r7
		sum += current;
    469a:	4438      	add	r0, r7
		if (current < minimum){
    469c:	bf84      	itt	hi
    469e:	4666      	movhi	r6, ip
    46a0:	46b8      	movhi	r8, r7
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    46a2:	3201      	adds	r2, #1
    46a4:	e7b1      	b.n	460a <grid_ain_add_sample+0x22>
		return 0;
    46a6:	2000      	movs	r0, #0
    46a8:	e7ee      	b.n	4688 <grid_ain_add_sample+0xa0>
    46aa:	bf00      	nop
    46ac:	2000c0a8 	.word	0x2000c0a8

000046b0 <grid_ain_get_changed>:

uint8_t grid_ain_get_changed(uint8_t channel){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
	return instance->result_changed;
    46b0:	4b02      	ldr	r3, [pc, #8]	; (46bc <grid_ain_get_changed+0xc>)
    46b2:	681b      	ldr	r3, [r3, #0]
    46b4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
}
    46b8:	7b00      	ldrb	r0, [r0, #12]
    46ba:	4770      	bx	lr
    46bc:	2000c0a8 	.word	0x2000c0a8

000046c0 <grid_ain_get_average>:
	
uint16_t grid_ain_get_average(uint8_t channel, uint8_t resolution){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    46c0:	4b08      	ldr	r3, [pc, #32]	; (46e4 <grid_ain_get_average+0x24>)
    46c2:	681a      	ldr	r2, [r3, #0]
	instance->result_changed = 0;
	
	if (resolution>6 && resolution<15){
    46c4:	1fcb      	subs	r3, r1, #7
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    46c6:	eb02 1200 	add.w	r2, r2, r0, lsl #4
	if (resolution>6 && resolution<15){
    46ca:	2b07      	cmp	r3, #7
	instance->result_changed = 0;
    46cc:	f04f 0000 	mov.w	r0, #0
    46d0:	8190      	strh	r0, [r2, #12]
	if (resolution>6 && resolution<15){
    46d2:	d805      	bhi.n	46e0 <grid_ain_get_average+0x20>
		

		
		return (instance->result_value)/(1<<(instance->result_format-resolution));
    46d4:	7950      	ldrb	r0, [r2, #5]
    46d6:	8913      	ldrh	r3, [r2, #8]
    46d8:	1a40      	subs	r0, r0, r1
    46da:	fa43 f000 	asr.w	r0, r3, r0
    46de:	b280      	uxth	r0, r0
		
	}
	else{
		return 0;
	}
}
    46e0:	4770      	bx	lr
    46e2:	bf00      	nop
    46e4:	2000c0a8 	.word	0x2000c0a8

000046e8 <grid_port_reset_receiver>:
#include "grid_buf.h"

// PORTS


void grid_port_reset_receiver(struct grid_port* por){
    46e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	usart_async_disable(por->usart);
    46ea:	4b24      	ldr	r3, [pc, #144]	; (477c <grid_port_reset_receiver+0x94>)
	
	
	por->ping_partner_token = 255;
	por->ping_local_token = 255;
	
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    46ec:	4e24      	ldr	r6, [pc, #144]	; (4780 <grid_port_reset_receiver+0x98>)
void grid_port_reset_receiver(struct grid_port* por){
    46ee:	4604      	mov	r4, r0
	usart_async_disable(por->usart);
    46f0:	6840      	ldr	r0, [r0, #4]
    46f2:	4798      	blx	r3
	por->partner_status = 0;
    46f4:	f642 734b 	movw	r3, #12107	; 0x2f4b
	por->rx_double_buffer_seek_start_index = 0;
    46f8:	2500      	movs	r5, #0
	por->rx_double_buffer_read_start_index = 0;
    46fa:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	por->ping_local_token = 255;
    46fe:	f642 7731 	movw	r7, #12081	; 0x2f31
	por->partner_status = 0;
    4702:	54e5      	strb	r5, [r4, r3]
	por->ping_partner_token = 255;
    4704:	f642 7332 	movw	r3, #12082	; 0x2f32
    4708:	22ff      	movs	r2, #255	; 0xff
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    470a:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
	por->ping_partner_token = 255;
    470e:	54e2      	strb	r2, [r4, r3]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4710:	2102      	movs	r1, #2
	por->ping_local_token = 255;
    4712:	55e2      	strb	r2, [r4, r7]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4714:	303b      	adds	r0, #59	; 0x3b
    4716:	47b0      	blx	r6
	grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4718:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    471c:	5de2      	ldrb	r2, [r4, r7]
    471e:	2102      	movs	r1, #2
    4720:	3039      	adds	r0, #57	; 0x39
    4722:	47b0      	blx	r6
	grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4724:	f642 7347 	movw	r3, #12103	; 0x2f47
    4728:	f504 563c 	add.w	r6, r4, #12032	; 0x2f00
    472c:	3633      	adds	r6, #51	; 0x33
    472e:	5ce1      	ldrb	r1, [r4, r3]
    4730:	4b14      	ldr	r3, [pc, #80]	; (4784 <grid_port_reset_receiver+0x9c>)
    4732:	9101      	str	r1, [sp, #4]
    4734:	4630      	mov	r0, r6
    4736:	4798      	blx	r3
    4738:	9901      	ldr	r1, [sp, #4]
    473a:	4b13      	ldr	r3, [pc, #76]	; (4788 <grid_port_reset_receiver+0xa0>)
    473c:	4602      	mov	r2, r0
    473e:	4630      	mov	r0, r6
    4740:	4798      	blx	r3


	
	por->rx_double_buffer_timeout = 0;
	grid_sys_port_reset_dma(por);
    4742:	4b12      	ldr	r3, [pc, #72]	; (478c <grid_port_reset_receiver+0xa4>)
	por->rx_double_buffer_timeout = 0;
    4744:	61e5      	str	r5, [r4, #28]
	grid_sys_port_reset_dma(por);
    4746:	4620      	mov	r0, r4
    4748:	4798      	blx	r3
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    474a:	f504 539d 	add.w	r3, r4, #5024	; 0x13a0
    474e:	3314      	adds	r3, #20
    4750:	f504 521c 	add.w	r2, r4, #9984	; 0x2700
    4754:	323c      	adds	r2, #60	; 0x3c
    4756:	4619      	mov	r1, r3
		por->rx_double_buffer[i] = 0;
    4758:	f803 5b01 	strb.w	r5, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    475c:	4293      	cmp	r3, r2
    475e:	d1fb      	bne.n	4758 <grid_port_reset_receiver+0x70>
    4760:	f104 032c 	add.w	r3, r4, #44	; 0x2c
	}
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
		por->tx_double_buffer[i] = 0;
    4764:	2200      	movs	r2, #0
    4766:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    476a:	428b      	cmp	r3, r1
    476c:	d1fb      	bne.n	4766 <grid_port_reset_receiver+0x7e>
	}
	
	usart_async_enable(por->usart);
    476e:	6860      	ldr	r0, [r4, #4]
    4770:	4b07      	ldr	r3, [pc, #28]	; (4790 <grid_port_reset_receiver+0xa8>)
	
}
    4772:	b003      	add	sp, #12
    4774:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	usart_async_enable(por->usart);
    4778:	4718      	bx	r3
    477a:	bf00      	nop
    477c:	00010bd1 	.word	0x00010bd1
    4780:	00009c31 	.word	0x00009c31
    4784:	00009d79 	.word	0x00009d79
    4788:	00009dad 	.word	0x00009dad
    478c:	000097bd 	.word	0x000097bd
    4790:	00010ba5 	.word	0x00010ba5

00004794 <grid_buffer_init>:



uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
	
	grid_buffer_error_count = 0;
    4794:	4a0f      	ldr	r2, [pc, #60]	; (47d4 <grid_buffer_init+0x40>)
    4796:	2300      	movs	r3, #0
uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
    4798:	b510      	push	{r4, lr}
    479a:	3002      	adds	r0, #2
	grid_buffer_error_count = 0;
    479c:	7013      	strb	r3, [r2, #0]
	
	buf->buffer_length = length;
	
	buf->read_length   = 0;
    479e:	f8a0 33ee 	strh.w	r3, [r0, #1006]	; 0x3ee
	buf->buffer_length = length;
    47a2:	f820 1c02 	strh.w	r1, [r0, #-2]
	
	buf->read_start    = 0;
    47a6:	f8a0 33e8 	strh.w	r3, [r0, #1000]	; 0x3e8
	buf->read_stop     = 0;
    47aa:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
	buf->read_active   = 0;
    47ae:	f8a0 33ec 	strh.w	r3, [r0, #1004]	; 0x3ec
	
	buf->write_start    = 0;
    47b2:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
	buf->write_stop     = 0;
    47b6:	f8a0 33f2 	strh.w	r3, [r0, #1010]	; 0x3f2
	buf->write_active   = 0;
    47ba:	f8a0 33f4 	strh.w	r3, [r0, #1012]	; 0x3f4
	

	for (uint16_t i=0; i<buf->buffer_length; i++){
		buf->buffer_storage[i] = 0;
    47be:	461c      	mov	r4, r3
	for (uint16_t i=0; i<buf->buffer_length; i++){
    47c0:	b29a      	uxth	r2, r3
    47c2:	4291      	cmp	r1, r2
    47c4:	d801      	bhi.n	47ca <grid_buffer_init+0x36>
	}
	
	return 1;
	
}
    47c6:	2001      	movs	r0, #1
    47c8:	bd10      	pop	{r4, pc}
		buf->buffer_storage[i] = 0;
    47ca:	f800 4b01 	strb.w	r4, [r0], #1
	for (uint16_t i=0; i<buf->buffer_length; i++){
    47ce:	3301      	adds	r3, #1
    47d0:	e7f6      	b.n	47c0 <grid_buffer_init+0x2c>
    47d2:	bf00      	nop
    47d4:	2000c09c 	.word	0x2000c09c

000047d8 <grid_buffer_get_space>:

uint16_t grid_buffer_get_space(struct grid_buffer* buf){
	
	uint16_t space = 0;
		
	if (buf->read_start > buf->write_start){
    47d8:	f8b0 33ea 	ldrh.w	r3, [r0, #1002]	; 0x3ea
    47dc:	f8b0 23f2 	ldrh.w	r2, [r0, #1010]	; 0x3f2
    47e0:	4293      	cmp	r3, r2
		space = buf->read_start - buf->write_start;
	}
	else{
		space = buf->buffer_length - buf->write_start + buf->read_start;
    47e2:	bf9b      	ittet	ls
    47e4:	8800      	ldrhls	r0, [r0, #0]
    47e6:	18c0      	addls	r0, r0, r3
		space = buf->read_start - buf->write_start;
    47e8:	1a98      	subhi	r0, r3, r2
		space = buf->buffer_length - buf->write_start + buf->read_start;
    47ea:	1a80      	subls	r0, r0, r2
    47ec:	b280      	uxth	r0, r0
	}
	
	return space;
}
    47ee:	4770      	bx	lr

000047f0 <grid_buffer_write_init>:





uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    47f0:	b510      	push	{r4, lr}
	
	
	
	uint16_t space = grid_buffer_get_space(buf);
    47f2:	4b0c      	ldr	r3, [pc, #48]	; (4824 <grid_buffer_write_init+0x34>)
uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    47f4:	4604      	mov	r4, r0
	uint16_t space = grid_buffer_get_space(buf);
    47f6:	4798      	blx	r3

	
	if (space>length){
    47f8:	4288      	cmp	r0, r1
    47fa:	d90b      	bls.n	4814 <grid_buffer_write_init+0x24>
		
		buf->write_stop = (buf->write_start+length)%buf->buffer_length;
    47fc:	f8b4 33f2 	ldrh.w	r3, [r4, #1010]	; 0x3f2
    4800:	8820      	ldrh	r0, [r4, #0]
    4802:	440b      	add	r3, r1
    4804:	fbb3 f2f0 	udiv	r2, r3, r0
    4808:	fb00 3312 	mls	r3, r0, r2, r3
    480c:	f8a4 33f4 	strh.w	r3, [r4, #1012]	; 0x3f4
	}
	
	
	
	
}
    4810:	4608      	mov	r0, r1
    4812:	bd10      	pop	{r4, pc}
		grid_buffer_error_count++;
    4814:	4a04      	ldr	r2, [pc, #16]	; (4828 <grid_buffer_write_init+0x38>)
    4816:	7813      	ldrb	r3, [r2, #0]
    4818:	3301      	adds	r3, #1
    481a:	b2db      	uxtb	r3, r3
    481c:	7013      	strb	r3, [r2, #0]
		return 0; // failed
    481e:	2100      	movs	r1, #0
    4820:	e7f6      	b.n	4810 <grid_buffer_write_init+0x20>
    4822:	bf00      	nop
    4824:	000047d9 	.word	0x000047d9
    4828:	2000c09c 	.word	0x2000c09c

0000482c <grid_buffer_write_character>:

uint8_t grid_buffer_write_character(struct grid_buffer* buf, uint8_t character){
	

		
	buf->buffer_storage[buf->write_active] = character;
    482c:	f8b0 33f6 	ldrh.w	r3, [r0, #1014]	; 0x3f6
    4830:	18c2      	adds	r2, r0, r3
		
	buf->write_active++;
    4832:	3301      	adds	r3, #1
	buf->buffer_storage[buf->write_active] = character;
    4834:	7091      	strb	r1, [r2, #2]
	buf->write_active %= buf->buffer_length;
    4836:	8801      	ldrh	r1, [r0, #0]
    4838:	b29b      	uxth	r3, r3
    483a:	fbb3 f2f1 	udiv	r2, r3, r1
    483e:	fb01 3312 	mls	r3, r1, r2, r3
    4842:	f8a0 33f6 	strh.w	r3, [r0, #1014]	; 0x3f6
		
	return 1;
		

}
    4846:	2001      	movs	r0, #1
    4848:	4770      	bx	lr
	...

0000484c <grid_buffer_write_acknowledge>:

uint8_t grid_buffer_write_acknowledge(struct grid_buffer* buf){
	
	if (buf->write_active == buf->write_stop){
    484c:	f8b0 33f4 	ldrh.w	r3, [r0, #1012]	; 0x3f4
    4850:	f8b0 23f6 	ldrh.w	r2, [r0, #1014]	; 0x3f6
    4854:	4293      	cmp	r3, r2
		buf->write_start = buf->write_active;
		return 1;
	}
	else{
		
		grid_buffer_error_count++;
    4856:	bf17      	itett	ne
    4858:	4a05      	ldrne	r2, [pc, #20]	; (4870 <grid_buffer_write_acknowledge+0x24>)
		buf->write_start = buf->write_active;
    485a:	f8a0 33f2 	strheq.w	r3, [r0, #1010]	; 0x3f2
		grid_buffer_error_count++;
    485e:	7813      	ldrbne	r3, [r2, #0]
    4860:	3301      	addne	r3, #1
    4862:	bf17      	itett	ne
    4864:	b2db      	uxtbne	r3, r3
		return 1;
    4866:	2001      	moveq	r0, #1
		grid_buffer_error_count++;
    4868:	7013      	strbne	r3, [r2, #0]
    486a:	2000      	movne	r0, #0
		return 0;
	}
	
	
}
    486c:	4770      	bx	lr
    486e:	bf00      	nop
    4870:	2000c09c 	.word	0x2000c09c

00004874 <grid_port_receive_decode>:
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    4874:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4878:	ed2d 8b02 	vpush	{d8}
	uint8_t buffer[length];
    487c:	1dd3      	adds	r3, r2, #7
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    487e:	b08b      	sub	sp, #44	; 0x2c
    4880:	4690      	mov	r8, r2
	uint8_t buffer[length];
    4882:	08db      	lsrs	r3, r3, #3
    4884:	466a      	mov	r2, sp
    4886:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
	for (uint16_t i = 0; i<length; i++){
    488a:	2200      	movs	r2, #0
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    488c:	af02      	add	r7, sp, #8
	uint8_t buffer[length];
    488e:	469d      	mov	sp, r3
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    4890:	4604      	mov	r4, r0
    4892:	6a83      	ldr	r3, [r0, #40]	; 0x28
	uint8_t buffer[length];
    4894:	f10d 0908 	add.w	r9, sp, #8
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4898:	f241 3088 	movw	r0, #5000	; 0x1388
    489c:	f241 35b4 	movw	r5, #5044	; 0x13b4
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    48a0:	4694      	mov	ip, r2
	for (uint16_t i = 0; i<length; i++){
    48a2:	b291      	uxth	r1, r2
    48a4:	4588      	cmp	r8, r1
    48a6:	f200 80e3 	bhi.w	4a70 <grid_port_receive_decode+0x1fc>
	for (uint16_t i = 0; i<length; i++){
    48aa:	2200      	movs	r2, #0
	message = &buffer[0];
    48ac:	464d      	mov	r5, r9
	for (uint16_t i = 0; i<length; i++){
    48ae:	f241 3088 	movw	r0, #5000	; 0x1388
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    48b2:	f241 3cb4 	movw	ip, #5044	; 0x13b4
    48b6:	4696      	mov	lr, r2
	for (uint16_t i = 0; i<length; i++){
    48b8:	b291      	uxth	r1, r2
    48ba:	4588      	cmp	r8, r1
    48bc:	f200 80e5 	bhi.w	4a8a <grid_port_receive_decode+0x216>
	por->rx_double_buffer_read_start_index = (por->rx_double_buffer_read_start_index + length)%GRID_DOUBLE_BUFFER_RX_SIZE;
    48c0:	4443      	add	r3, r8
    48c2:	fbb3 f2f0 	udiv	r2, r3, r0
    48c6:	fb00 3312 	mls	r3, r0, r2, r3
	por->rx_double_buffer_seek_start_index =  por->rx_double_buffer_read_start_index;
    48ca:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
	por->rx_double_buffer_status = 0;
    48ce:	2300      	movs	r3, #0
    48d0:	6223      	str	r3, [r4, #32]
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    48d2:	f8df a250 	ldr.w	sl, [pc, #592]	; 4b24 <grid_port_receive_decode+0x2b0>
    48d6:	f8df b250 	ldr.w	fp, [pc, #592]	; 4b28 <grid_port_receive_decode+0x2b4>
    48da:	4b88      	ldr	r3, [pc, #544]	; (4afc <grid_port_receive_decode+0x288>)
	for (uint16_t i = 1; i<length; i++){
    48dc:	2601      	movs	r6, #1
    48de:	45b0      	cmp	r8, r6
    48e0:	f200 80dd 	bhi.w	4a9e <grid_port_receive_decode+0x22a>
	if (message[0] == GRID_CONST_SOH && message[length-1] == GRID_CONST_LF){
    48e4:	782b      	ldrb	r3, [r5, #0]
    48e6:	2b01      	cmp	r3, #1
    48e8:	f040 80bc 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
    48ec:	eb05 0308 	add.w	r3, r5, r8
    48f0:	f813 9c01 	ldrb.w	r9, [r3, #-1]
    48f4:	f1b9 0f0a 	cmp.w	r9, #10
    48f8:	f040 80b4 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
		checksum_received = grid_msg_checksum_read(message, length);
    48fc:	4b80      	ldr	r3, [pc, #512]	; (4b00 <grid_port_receive_decode+0x28c>)
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    48fe:	4e81      	ldr	r6, [pc, #516]	; (4b04 <grid_port_receive_decode+0x290>)
		checksum_received = grid_msg_checksum_read(message, length);
    4900:	4641      	mov	r1, r8
    4902:	4628      	mov	r0, r5
    4904:	4798      	blx	r3
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4906:	4641      	mov	r1, r8
		checksum_received = grid_msg_checksum_read(message, length);
    4908:	4682      	mov	sl, r0
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    490a:	4628      	mov	r0, r5
    490c:	47b0      	blx	r6
		if (checksum_calculated == checksum_received && error_flag == 0){
    490e:	4582      	cmp	sl, r0
    4910:	f040 81fc 	bne.w	4d0c <grid_port_receive_decode+0x498>
			if (message[1] == GRID_CONST_BRC){ // Broadcast message
    4914:	786b      	ldrb	r3, [r5, #1]
    4916:	2b0f      	cmp	r3, #15
    4918:	f040 810c 	bne.w	4b34 <grid_port_receive_decode+0x2c0>
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    491c:	f107 061f 	add.w	r6, r7, #31
				uint8_t error=0;
    4920:	f04f 0300 	mov.w	r3, #0
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4924:	f8df b204 	ldr.w	fp, [pc, #516]	; 4b2c <grid_port_receive_decode+0x2b8>
				uint8_t error=0;
    4928:	77fb      	strb	r3, [r7, #31]
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    492a:	2202      	movs	r2, #2
    492c:	4633      	mov	r3, r6
    492e:	2104      	movs	r1, #4
    4930:	4628      	mov	r0, r5
    4932:	47d8      	blx	fp
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4934:	4649      	mov	r1, r9
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4936:	6078      	str	r0, [r7, #4]
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4938:	4633      	mov	r3, r6
    493a:	2202      	movs	r2, #2
    493c:	4628      	mov	r0, r5
    493e:	47d8      	blx	fp
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4940:	4633      	mov	r3, r6
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4942:	6038      	str	r0, [r7, #0]
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4944:	2202      	movs	r2, #2
    4946:	2106      	movs	r1, #6
    4948:	4628      	mov	r0, r5
    494a:	47d8      	blx	fp
    494c:	b2c3      	uxtb	r3, r0
    494e:	617b      	str	r3, [r7, #20]
    4950:	f1a3 0a7f 	sub.w	sl, r3, #127	; 0x7f
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4954:	2202      	movs	r2, #2
    4956:	4633      	mov	r3, r6
    4958:	2108      	movs	r1, #8
    495a:	4628      	mov	r0, r5
    495c:	47d8      	blx	fp
    495e:	b2c3      	uxtb	r3, r0
    4960:	613b      	str	r3, [r7, #16]
    4962:	f1a3 097f 	sub.w	r9, r3, #127	; 0x7f
				uint8_t received_rot = grid_msg_get_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
    4966:	2202      	movs	r2, #2
    4968:	4633      	mov	r3, r6
    496a:	210c      	movs	r1, #12
    496c:	4628      	mov	r0, r5
    496e:	47d8      	blx	fp
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    4970:	f642 7330 	movw	r3, #12080	; 0x2f30
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4974:	fa4f fa8a 	sxtb.w	sl, sl
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    4978:	5ce3      	ldrb	r3, [r4, r3]
    497a:	4418      	add	r0, r3
    497c:	f000 0203 	and.w	r2, r0, #3
    4980:	ee08 2a10 	vmov	s16, r2
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4984:	fa4f f989 	sxtb.w	r9, r9
				if (por->partner_fi == 0){ // 0 deg
    4988:	b143      	cbz	r3, 499c <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 1){ // 90 deg
    498a:	2b01      	cmp	r3, #1
    498c:	f040 8098 	bne.w	4ac0 <grid_port_receive_decode+0x24c>
					rotated_dx  -= received_dy;
    4990:	693b      	ldr	r3, [r7, #16]
    4992:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dy  += received_dx;
    4996:	46d1      	mov	r9, sl
					rotated_dx  -= received_dy;
    4998:	fa4f fa83 	sxtb.w	sl, r3
				uint8_t updated_dx = rotated_dx + GRID_SYS_DEFAULT_POSITION + por->dx;
    499c:	f642 7349 	movw	r3, #12105	; 0x2f49
    49a0:	f897 b000 	ldrb.w	fp, [r7]
    49a4:	5ce3      	ldrb	r3, [r4, r3]
    49a6:	337f      	adds	r3, #127	; 0x7f
    49a8:	449a      	add	sl, r3
    49aa:	fa5f f38a 	uxtb.w	r3, sl
    49ae:	60fb      	str	r3, [r7, #12]
				uint8_t updated_dy = rotated_dy + GRID_SYS_DEFAULT_POSITION + por->dy;
    49b0:	f642 734a 	movw	r3, #12106	; 0x2f4a
    49b4:	f814 a003 	ldrb.w	sl, [r4, r3]
    49b8:	f10a 0a7f 	add.w	sl, sl, #127	; 0x7f
    49bc:	44d1      	add	r9, sl
    49be:	fa5f f389 	uxtb.w	r3, r9
    49c2:	60bb      	str	r3, [r7, #8]
				if (received_dx + GRID_SYS_DEFAULT_POSITION == 0 && received_dy + GRID_SYS_DEFAULT_POSITION == 0)
    49c4:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    49c8:	4313      	orrs	r3, r2
    49ca:	f897 a004 	ldrb.w	sl, [r7, #4]
    49ce:	d020      	beq.n	4a12 <grid_port_receive_decode+0x19e>
					grid_msg_set_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, updated_id, &error);
    49d0:	f8df 915c 	ldr.w	r9, [pc, #348]	; 4b30 <grid_port_receive_decode+0x2bc>
    49d4:	9600      	str	r6, [sp, #0]
    49d6:	4653      	mov	r3, sl
    49d8:	2202      	movs	r2, #2
    49da:	2104      	movs	r1, #4
    49dc:	4628      	mov	r0, r5
    49de:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, updated_dx, &error);
    49e0:	9600      	str	r6, [sp, #0]
    49e2:	68fb      	ldr	r3, [r7, #12]
    49e4:	2202      	movs	r2, #2
    49e6:	2106      	movs	r1, #6
    49e8:	4628      	mov	r0, r5
    49ea:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, updated_dy, &error);
    49ec:	9600      	str	r6, [sp, #0]
    49ee:	68bb      	ldr	r3, [r7, #8]
    49f0:	2202      	movs	r2, #2
    49f2:	2108      	movs	r1, #8
    49f4:	4628      	mov	r0, r5
    49f6:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, updated_age, &error);
    49f8:	465b      	mov	r3, fp
    49fa:	2202      	movs	r2, #2
    49fc:	210a      	movs	r1, #10
    49fe:	9600      	str	r6, [sp, #0]
    4a00:	4628      	mov	r0, r5
    4a02:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, updated_rot, &error);
    4a04:	ee18 3a10 	vmov	r3, s16
    4a08:	9600      	str	r6, [sp, #0]
    4a0a:	2202      	movs	r2, #2
    4a0c:	210c      	movs	r1, #12
    4a0e:	4628      	mov	r0, r5
    4a10:	47c8      	blx	r9
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a12:	68fb      	ldr	r3, [r7, #12]
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a14:	483c      	ldr	r0, [pc, #240]	; (4b08 <grid_port_receive_decode+0x294>)
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a16:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a1a:	68bb      	ldr	r3, [r7, #8]
    4a1c:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a20:	eb0b 2a0a 	add.w	sl, fp, sl, lsl #8
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a24:	4b39      	ldr	r3, [pc, #228]	; (4b0c <grid_port_receive_decode+0x298>)
    4a26:	4651      	mov	r1, sl
    4a28:	4798      	blx	r3
    4a2a:	b9d8      	cbnz	r0, 4a64 <grid_port_receive_decode+0x1f0>
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a2c:	4b35      	ldr	r3, [pc, #212]	; (4b04 <grid_port_receive_decode+0x290>)
    4a2e:	4641      	mov	r1, r8
    4a30:	4628      	mov	r0, r5
    4a32:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a34:	f504 542c 	add.w	r4, r4, #11008	; 0x2b00
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a38:	4b35      	ldr	r3, [pc, #212]	; (4b10 <grid_port_receive_decode+0x29c>)
    4a3a:	4602      	mov	r2, r0
    4a3c:	4641      	mov	r1, r8
    4a3e:	4628      	mov	r0, r5
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a40:	3434      	adds	r4, #52	; 0x34
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a42:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a44:	4b33      	ldr	r3, [pc, #204]	; (4b14 <grid_port_receive_decode+0x2a0>)
    4a46:	4641      	mov	r1, r8
    4a48:	4620      	mov	r0, r4
    4a4a:	4798      	blx	r3
    4a4c:	b150      	cbz	r0, 4a64 <grid_port_receive_decode+0x1f0>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4a4e:	4e32      	ldr	r6, [pc, #200]	; (4b18 <grid_port_receive_decode+0x2a4>)
    4a50:	44a8      	add	r8, r5
						for (uint16_t i=0; i<length; i++){
    4a52:	45a8      	cmp	r8, r5
    4a54:	d14d      	bne.n	4af2 <grid_port_receive_decode+0x27e>
						grid_buffer_write_acknowledge(&por->rx_buffer);
    4a56:	4b31      	ldr	r3, [pc, #196]	; (4b1c <grid_port_receive_decode+0x2a8>)
    4a58:	4620      	mov	r0, r4
    4a5a:	4798      	blx	r3
						grid_msg_push_recent(&grid_sys_state, fingerprint);
    4a5c:	482a      	ldr	r0, [pc, #168]	; (4b08 <grid_port_receive_decode+0x294>)
    4a5e:	4b30      	ldr	r3, [pc, #192]	; (4b20 <grid_port_receive_decode+0x2ac>)
    4a60:	4651      	mov	r1, sl
    4a62:	4798      	blx	r3
}
    4a64:	3724      	adds	r7, #36	; 0x24
    4a66:	46bd      	mov	sp, r7
    4a68:	ecbd 8b02 	vpop	{d8}
    4a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4a70:	18d6      	adds	r6, r2, r3
    4a72:	fbb6 f1f0 	udiv	r1, r6, r0
    4a76:	fb00 6111 	mls	r1, r0, r1, r6
    4a7a:	4421      	add	r1, r4
    4a7c:	5d4e      	ldrb	r6, [r1, r5]
    4a7e:	f809 6002 	strb.w	r6, [r9, r2]
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    4a82:	f801 c005 	strb.w	ip, [r1, r5]
	for (uint16_t i = 0; i<length; i++){
    4a86:	3201      	adds	r2, #1
    4a88:	e70b      	b.n	48a2 <grid_port_receive_decode+0x2e>
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    4a8a:	18d6      	adds	r6, r2, r3
    4a8c:	fbb6 f1f0 	udiv	r1, r6, r0
    4a90:	fb00 6111 	mls	r1, r0, r1, r6
    4a94:	4421      	add	r1, r4
    4a96:	3201      	adds	r2, #1
    4a98:	f801 e00c 	strb.w	lr, [r1, ip]
	for (uint16_t i = 0; i<length; i++){
    4a9c:	e70c      	b.n	48b8 <grid_port_receive_decode+0x44>
		if (buffer[i] == GRID_CONST_SOH){
    4a9e:	f819 2006 	ldrb.w	r2, [r9, r6]
    4aa2:	2a01      	cmp	r2, #1
    4aa4:	d109      	bne.n	4aba <grid_port_receive_decode+0x246>
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4aa6:	4651      	mov	r1, sl
    4aa8:	4658      	mov	r0, fp
    4aaa:	4798      	blx	r3
			length -= i;
    4aac:	eba8 0806 	sub.w	r8, r8, r6
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4ab0:	4b12      	ldr	r3, [pc, #72]	; (4afc <grid_port_receive_decode+0x288>)
			length -= i;
    4ab2:	fa1f f888 	uxth.w	r8, r8
			message = &buffer[i];
    4ab6:	eb09 0506 	add.w	r5, r9, r6
	for (uint16_t i = 1; i<length; i++){
    4aba:	3601      	adds	r6, #1
    4abc:	b2b6      	uxth	r6, r6
    4abe:	e70e      	b.n	48de <grid_port_receive_decode+0x6a>
				else if(por->partner_fi == 2){ // 180 deg
    4ac0:	2b02      	cmp	r3, #2
    4ac2:	d10a      	bne.n	4ada <grid_port_receive_decode+0x266>
					rotated_dx  -= received_dx;
    4ac4:	697b      	ldr	r3, [r7, #20]
    4ac6:	f1c3 0a7f 	rsb	sl, r3, #127	; 0x7f
					rotated_dy  -= received_dy;
    4aca:	693b      	ldr	r3, [r7, #16]
					rotated_dx  -= received_dx;
    4acc:	fa4f fa8a 	sxtb.w	sl, sl
					rotated_dy  -= received_dy;
    4ad0:	f1c3 097f 	rsb	r9, r3, #127	; 0x7f
					rotated_dy  -= received_dx;
    4ad4:	fa4f f989 	sxtb.w	r9, r9
    4ad8:	e760      	b.n	499c <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 3){ // 270 deg
    4ada:	2b03      	cmp	r3, #3
    4adc:	d105      	bne.n	4aea <grid_port_receive_decode+0x276>
					rotated_dy  -= received_dx;
    4ade:	697b      	ldr	r3, [r7, #20]
    4ae0:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dx  += received_dy;
    4ae4:	46ca      	mov	sl, r9
					rotated_dy  -= received_dx;
    4ae6:	4699      	mov	r9, r3
    4ae8:	e7f4      	b.n	4ad4 <grid_port_receive_decode+0x260>
				int8_t rotated_dy = 0;
    4aea:	f04f 0900 	mov.w	r9, #0
				int8_t rotated_dx = 0;
    4aee:	46ca      	mov	sl, r9
    4af0:	e754      	b.n	499c <grid_port_receive_decode+0x128>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4af2:	f815 1b01 	ldrb.w	r1, [r5], #1
    4af6:	4620      	mov	r0, r4
    4af8:	47b0      	blx	r6
						for (uint16_t i=0; i<length; i++){
    4afa:	e7aa      	b.n	4a52 <grid_port_receive_decode+0x1de>
    4afc:	00014925 	.word	0x00014925
    4b00:	00009d91 	.word	0x00009d91
    4b04:	00009d79 	.word	0x00009d79
    4b08:	2000f008 	.word	0x2000f008
    4b0c:	00009de9 	.word	0x00009de9
    4b10:	00009dad 	.word	0x00009dad
    4b14:	000047f1 	.word	0x000047f1
    4b18:	0000482d 	.word	0x0000482d
    4b1c:	0000484d 	.word	0x0000484d
    4b20:	00009e03 	.word	0x00009e03
    4b24:	00015ea4 	.word	0x00015ea4
    4b28:	00015eb7 	.word	0x00015eb7
    4b2c:	00009dbd 	.word	0x00009dbd
    4b30:	00009dd5 	.word	0x00009dd5
			else if (message[1] == GRID_CONST_DCT){ // Direct Message
    4b34:	2b0e      	cmp	r3, #14
    4b36:	f040 80e5 	bne.w	4d04 <grid_port_receive_decode+0x490>
				if (message[2] == GRID_CONST_ACK){
    4b3a:	78ab      	ldrb	r3, [r5, #2]
    4b3c:	2b07      	cmp	r3, #7
    4b3e:	d191      	bne.n	4a64 <grid_port_receive_decode+0x1f0>
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b40:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4d20 <grid_port_receive_decode+0x4ac>
    4b44:	2200      	movs	r2, #0
    4b46:	2102      	movs	r1, #2
    4b48:	f105 0008 	add.w	r0, r5, #8
    4b4c:	47c8      	blx	r9
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b4e:	2200      	movs	r2, #0
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b50:	fa5f fa80 	uxtb.w	sl, r0
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b54:	2102      	movs	r1, #2
    4b56:	1da8      	adds	r0, r5, #6
    4b58:	47c8      	blx	r9
					if (por->partner_status == 0){
    4b5a:	f642 724b 	movw	r2, #12107	; 0x2f4b
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b5e:	fa5f fb80 	uxtb.w	fp, r0
					if (por->partner_status == 0){
    4b62:	5ca2      	ldrb	r2, [r4, r2]
    4b64:	2a00      	cmp	r2, #0
    4b66:	d172      	bne.n	4c4e <grid_port_receive_decode+0x3da>
						if (por->ping_local_token == 255){ // I have no clue
    4b68:	f642 7931 	movw	r9, #12081	; 0x2f31
    4b6c:	f814 2009 	ldrb.w	r2, [r4, r9]
    4b70:	2aff      	cmp	r2, #255	; 0xff
    4b72:	d11b      	bne.n	4bac <grid_port_receive_decode+0x338>
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4b74:	4a66      	ldr	r2, [pc, #408]	; (4d10 <grid_port_receive_decode+0x49c>)
    4b76:	4867      	ldr	r0, [pc, #412]	; (4d14 <grid_port_receive_decode+0x4a0>)
    4b78:	4790      	blx	r2
    4b7a:	f000 027f 	and.w	r2, r0, #127	; 0x7f
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4b7e:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4b82:	f804 2009 	strb.w	r2, [r4, r9]
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4b86:	4b64      	ldr	r3, [pc, #400]	; (4d18 <grid_port_receive_decode+0x4a4>)
    4b88:	2102      	movs	r1, #2
    4b8a:	3039      	adds	r0, #57	; 0x39
    4b8c:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4b8e:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4b92:	f642 7247 	movw	r2, #12103	; 0x2f47
    4b96:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4b9a:	5ca1      	ldrb	r1, [r4, r2]
    4b9c:	6179      	str	r1, [r7, #20]
    4b9e:	4648      	mov	r0, r9
    4ba0:	47b0      	blx	r6
    4ba2:	6979      	ldr	r1, [r7, #20]
    4ba4:	4b5d      	ldr	r3, [pc, #372]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4ba6:	4602      	mov	r2, r0
    4ba8:	4648      	mov	r0, r9
    4baa:	4798      	blx	r3
						if (partner_token_received != por->ping_partner_token){
    4bac:	f642 7232 	movw	r2, #12082	; 0x2f32
    4bb0:	5ca1      	ldrb	r1, [r4, r2]
    4bb2:	4559      	cmp	r1, fp
    4bb4:	d017      	beq.n	4be6 <grid_port_receive_decode+0x372>
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bb6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = partner_token_received;							
    4bba:	f804 b002 	strb.w	fp, [r4, r2]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bbe:	4b56      	ldr	r3, [pc, #344]	; (4d18 <grid_port_receive_decode+0x4a4>)
    4bc0:	465a      	mov	r2, fp
    4bc2:	2102      	movs	r1, #2
    4bc4:	303b      	adds	r0, #59	; 0x3b
    4bc6:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4bc8:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4bcc:	f642 7347 	movw	r3, #12103	; 0x2f47
    4bd0:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4bd4:	5ce1      	ldrb	r1, [r4, r3]
    4bd6:	6179      	str	r1, [r7, #20]
    4bd8:	4648      	mov	r0, r9
    4bda:	47b0      	blx	r6
    4bdc:	6979      	ldr	r1, [r7, #20]
    4bde:	4b4f      	ldr	r3, [pc, #316]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4be0:	4602      	mov	r2, r0
    4be2:	4648      	mov	r0, r9
    4be4:	4798      	blx	r3
						if (por->ping_local_token != local_token_received){
    4be6:	f642 7331 	movw	r3, #12081	; 0x2f31
    4bea:	5ce3      	ldrb	r3, [r4, r3]
    4bec:	4553      	cmp	r3, sl
    4bee:	d129      	bne.n	4c44 <grid_port_receive_decode+0x3d0>
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4bf0:	7a62      	ldrb	r2, [r4, #9]
    4bf2:	78eb      	ldrb	r3, [r5, #3]
    4bf4:	1a9b      	subs	r3, r3, r2
    4bf6:	3306      	adds	r3, #6
    4bf8:	425a      	negs	r2, r3
    4bfa:	f002 0203 	and.w	r2, r2, #3
    4bfe:	f003 0303 	and.w	r3, r3, #3
    4c02:	bf58      	it	pl
    4c04:	4253      	negpl	r3, r2
    4c06:	f642 7230 	movw	r2, #12080	; 0x2f30
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c0a:	f1a8 000a 	sub.w	r0, r8, #10
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c0e:	54a3      	strb	r3, [r4, r2]
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c10:	2102      	movs	r1, #2
    4c12:	4b43      	ldr	r3, [pc, #268]	; (4d20 <grid_port_receive_decode+0x4ac>)
    4c14:	2200      	movs	r2, #0
    4c16:	4428      	add	r0, r5
    4c18:	4798      	blx	r3
    4c1a:	f642 732c 	movw	r3, #12076	; 0x2f2c
							por->partner_status = 1;
    4c1e:	2201      	movs	r2, #1
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c20:	50e0      	str	r0, [r4, r3]
							por->partner_status = 1;
    4c22:	f642 734b 	movw	r3, #12107	; 0x2f4b
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c26:	493f      	ldr	r1, [pc, #252]	; (4d24 <grid_port_receive_decode+0x4b0>)
							por->partner_status = 1;
    4c28:	54e2      	strb	r2, [r4, r3]
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c2a:	483f      	ldr	r0, [pc, #252]	; (4d28 <grid_port_receive_decode+0x4b4>)
    4c2c:	4b3f      	ldr	r3, [pc, #252]	; (4d2c <grid_port_receive_decode+0x4b8>)
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c2e:	4d40      	ldr	r5, [pc, #256]	; (4d30 <grid_port_receive_decode+0x4bc>)
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c30:	4798      	blx	r3
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c32:	2300      	movs	r3, #0
    4c34:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    4c38:	e9cd 3200 	strd	r3, r2, [sp]
    4c3c:	4835      	ldr	r0, [pc, #212]	; (4d14 <grid_port_receive_decode+0x4a0>)
    4c3e:	22ff      	movs	r2, #255	; 0xff
    4c40:	4619      	mov	r1, r3
    4c42:	47a8      	blx	r5
						por->ping_flag = 1;
    4c44:	f642 7348 	movw	r3, #12104	; 0x2f48
    4c48:	2201      	movs	r2, #1
    4c4a:	54e2      	strb	r2, [r4, r3]
    4c4c:	e70a      	b.n	4a64 <grid_port_receive_decode+0x1f0>
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c4e:	7a61      	ldrb	r1, [r4, #9]
    4c50:	78ea      	ldrb	r2, [r5, #3]
    4c52:	1a52      	subs	r2, r2, r1
    4c54:	3206      	adds	r2, #6
    4c56:	4251      	negs	r1, r2
						validator &= local_token_received == por->ping_local_token;
    4c58:	f642 7031 	movw	r0, #12081	; 0x2f31
						validator &= partner_token_received == por->ping_partner_token;
    4c5c:	f642 7c32 	movw	ip, #12082	; 0x2f32
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c60:	f001 0103 	and.w	r1, r1, #3
						validator &= local_token_received == por->ping_local_token;
    4c64:	5c20      	ldrb	r0, [r4, r0]
						validator &= partner_token_received == por->ping_partner_token;
    4c66:	f814 c00c 	ldrb.w	ip, [r4, ip]
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c6a:	f002 0203 	and.w	r2, r2, #3
    4c6e:	bf58      	it	pl
    4c70:	424a      	negpl	r2, r1
    4c72:	f642 7130 	movw	r1, #12080	; 0x2f30
    4c76:	4550      	cmp	r0, sl
    4c78:	bf08      	it	eq
    4c7a:	45dc      	cmpeq	ip, fp
    4c7c:	5c61      	ldrb	r1, [r4, r1]
    4c7e:	bf0c      	ite	eq
    4c80:	f04f 0a01 	moveq.w	sl, #1
    4c84:	f04f 0a00 	movne.w	sl, #0
						validator &= por->partner_hwcfg == grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c88:	f642 732c 	movw	r3, #12076	; 0x2f2c
    4c8c:	f1a8 000a 	sub.w	r0, r8, #10
    4c90:	428a      	cmp	r2, r1
    4c92:	bf14      	ite	ne
    4c94:	f04f 0a00 	movne.w	sl, #0
    4c98:	f00a 0a01 	andeq.w	sl, sl, #1
    4c9c:	4428      	add	r0, r5
    4c9e:	2200      	movs	r2, #0
    4ca0:	2102      	movs	r1, #2
    4ca2:	f854 b003 	ldr.w	fp, [r4, r3]
    4ca6:	47c8      	blx	r9
						if (validator == 1){
    4ca8:	4558      	cmp	r0, fp
    4caa:	d103      	bne.n	4cb4 <grid_port_receive_decode+0x440>
    4cac:	f1ba 0f00 	cmp.w	sl, #0
    4cb0:	f47f aed8 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
							por->partner_status = 0;
    4cb4:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4cb8:	2200      	movs	r2, #0
    4cba:	54e2      	strb	r2, [r4, r3]
							por->ping_local_token = 255;
    4cbc:	f642 7831 	movw	r8, #12081	; 0x2f31
							por->ping_partner_token = 255;
    4cc0:	f642 7332 	movw	r3, #12082	; 0x2f32
    4cc4:	22ff      	movs	r2, #255	; 0xff
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4cc6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = 255;
    4cca:	54e2      	strb	r2, [r4, r3]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4ccc:	4d12      	ldr	r5, [pc, #72]	; (4d18 <grid_port_receive_decode+0x4a4>)
							por->ping_local_token = 255;
    4cce:	f804 2008 	strb.w	r2, [r4, r8]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4cd2:	2102      	movs	r1, #2
    4cd4:	303b      	adds	r0, #59	; 0x3b
    4cd6:	47a8      	blx	r5
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4cd8:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4cdc:	f814 2008 	ldrb.w	r2, [r4, r8]
    4ce0:	2102      	movs	r1, #2
    4ce2:	3039      	adds	r0, #57	; 0x39
    4ce4:	47a8      	blx	r5
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4ce6:	f642 7347 	movw	r3, #12103	; 0x2f47
    4cea:	f504 553c 	add.w	r5, r4, #12032	; 0x2f00
    4cee:	3533      	adds	r5, #51	; 0x33
    4cf0:	5ce1      	ldrb	r1, [r4, r3]
    4cf2:	6179      	str	r1, [r7, #20]
    4cf4:	4628      	mov	r0, r5
    4cf6:	47b0      	blx	r6
    4cf8:	6979      	ldr	r1, [r7, #20]
    4cfa:	4b08      	ldr	r3, [pc, #32]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4cfc:	4602      	mov	r2, r0
    4cfe:	4628      	mov	r0, r5
    4d00:	4798      	blx	r3
    4d02:	e6af      	b.n	4a64 <grid_port_receive_decode+0x1f0>
				printf("{\"type\": \"WARNING\", \"data\": [\"Unknow Message Type\"]}\r\n");
    4d04:	480b      	ldr	r0, [pc, #44]	; (4d34 <grid_port_receive_decode+0x4c0>)
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d06:	4b0c      	ldr	r3, [pc, #48]	; (4d38 <grid_port_receive_decode+0x4c4>)
    4d08:	4798      	blx	r3
	return;
    4d0a:	e6ab      	b.n	4a64 <grid_port_receive_decode+0x1f0>
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d0c:	480b      	ldr	r0, [pc, #44]	; (4d3c <grid_port_receive_decode+0x4c8>)
    4d0e:	e7fa      	b.n	4d06 <grid_port_receive_decode+0x492>
    4d10:	00009b51 	.word	0x00009b51
    4d14:	2000f008 	.word	0x2000f008
    4d18:	00009c31 	.word	0x00009c31
    4d1c:	00009dad 	.word	0x00009dad
    4d20:	00009c09 	.word	0x00009c09
    4d24:	00015edc 	.word	0x00015edc
    4d28:	00015eb7 	.word	0x00015eb7
    4d2c:	00014925 	.word	0x00014925
    4d30:	00009bbb 	.word	0x00009bbb
    4d34:	00015ee4 	.word	0x00015ee4
    4d38:	00014a59 	.word	0x00014a59
    4d3c:	00015f1a 	.word	0x00015f1a

00004d40 <grid_port_receive_task>:
void grid_port_receive_task(struct grid_port* por){
    4d40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (por->usart_error_flag == 1){
    4d42:	7e03      	ldrb	r3, [r0, #24]
    4d44:	2b01      	cmp	r3, #1
void grid_port_receive_task(struct grid_port* por){
    4d46:	4604      	mov	r4, r0
	if (por->usart_error_flag == 1){
    4d48:	d10d      	bne.n	4d66 <grid_port_receive_task+0x26>
		por->usart_error_flag = 0;
    4d4a:	2500      	movs	r5, #0
    4d4c:	7605      	strb	r5, [r0, #24]
		grid_port_reset_receiver(por);
    4d4e:	4b53      	ldr	r3, [pc, #332]	; (4e9c <grid_port_receive_task+0x15c>)
    4d50:	4798      	blx	r3
		grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500); // White triangle
    4d52:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d56:	e9cd 5300 	strd	r5, r3, [sp]
    4d5a:	23ff      	movs	r3, #255	; 0xff
    4d5c:	4850      	ldr	r0, [pc, #320]	; (4ea0 <grid_port_receive_task+0x160>)
    4d5e:	4d51      	ldr	r5, [pc, #324]	; (4ea4 <grid_port_receive_task+0x164>)
    4d60:	461a      	mov	r2, r3
    4d62:	4619      	mov	r1, r3
    4d64:	47a8      	blx	r5
	if	(por->rx_double_buffer_status == 0){
    4d66:	6a25      	ldr	r5, [r4, #32]
    4d68:	bb7d      	cbnz	r5, 4dca <grid_port_receive_task+0x8a>
		if (por->usart!=NULL){ // His is GRID usart port
    4d6a:	6863      	ldr	r3, [r4, #4]
    4d6c:	b1cb      	cbz	r3, 4da2 <grid_port_receive_task+0x62>
			if (por->rx_double_buffer_timeout > 1000){
    4d6e:	69e3      	ldr	r3, [r4, #28]
    4d70:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4d74:	d93e      	bls.n	4df4 <grid_port_receive_task+0xb4>
				if (por->partner_status == 1){
    4d76:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4d7a:	5ce3      	ldrb	r3, [r4, r3]
    4d7c:	2b01      	cmp	r3, #1
    4d7e:	d12c      	bne.n	4dda <grid_port_receive_task+0x9a>
					GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout Disconnect & Reset Receiver");
    4d80:	4949      	ldr	r1, [pc, #292]	; (4ea8 <grid_port_receive_task+0x168>)
    4d82:	4b4a      	ldr	r3, [pc, #296]	; (4eac <grid_port_receive_task+0x16c>)
    4d84:	484a      	ldr	r0, [pc, #296]	; (4eb0 <grid_port_receive_task+0x170>)
    4d86:	4798      	blx	r3
					grid_port_reset_receiver(por);
    4d88:	4b44      	ldr	r3, [pc, #272]	; (4e9c <grid_port_receive_task+0x15c>)
    4d8a:	4620      	mov	r0, r4
    4d8c:	4798      	blx	r3
					grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500);
    4d8e:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d92:	e9cd 5300 	strd	r5, r3, [sp]
    4d96:	23ff      	movs	r3, #255	; 0xff
    4d98:	4841      	ldr	r0, [pc, #260]	; (4ea0 <grid_port_receive_task+0x160>)
    4d9a:	4d42      	ldr	r5, [pc, #264]	; (4ea4 <grid_port_receive_task+0x164>)
    4d9c:	461a      	mov	r2, r3
    4d9e:	4619      	mov	r1, r3
    4da0:	47a8      	blx	r5
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4da2:	f241 3687 	movw	r6, #4999	; 0x1387
void grid_port_receive_task(struct grid_port* por){
    4da6:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4daa:	f241 30b4 	movw	r0, #5044	; 0x13b4
    4dae:	46b4      	mov	ip, r6
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4db0:	f241 3788 	movw	r7, #5000	; 0x1388
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4db4:	f241 3e86 	movw	lr, #4998	; 0x1386
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4db8:	6a62      	ldr	r2, [r4, #36]	; 0x24
    4dba:	18a3      	adds	r3, r4, r2
    4dbc:	5c1b      	ldrb	r3, [r3, r0]
    4dbe:	2b0a      	cmp	r3, #10
    4dc0:	d11b      	bne.n	4dfa <grid_port_receive_task+0xba>
				por->rx_double_buffer_timeout = 0;
    4dc2:	2300      	movs	r3, #0
    4dc4:	2501      	movs	r5, #1
    4dc6:	e9c4 3507 	strd	r3, r5, [r4, #28]
	if (por->rx_double_buffer_read_start_index < por->rx_double_buffer_seek_start_index){
    4dca:	e9d4 2109 	ldrd	r2, r1, [r4, #36]	; 0x24
    4dce:	4291      	cmp	r1, r2
    4dd0:	d359      	bcc.n	4e86 <grid_port_receive_task+0x146>
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4dd2:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
    4dd6:	3209      	adds	r2, #9
    4dd8:	e056      	b.n	4e88 <grid_port_receive_task+0x148>
					if (por->rx_double_buffer_read_start_index == 0 && por->rx_double_buffer_seek_start_index == 0){
    4dda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4ddc:	b913      	cbnz	r3, 4de4 <grid_port_receive_task+0xa4>
    4dde:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4de0:	2b00      	cmp	r3, #0
    4de2:	d0de      	beq.n	4da2 <grid_port_receive_task+0x62>
						GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout & Reset Receiver");
    4de4:	4933      	ldr	r1, [pc, #204]	; (4eb4 <grid_port_receive_task+0x174>)
    4de6:	4b31      	ldr	r3, [pc, #196]	; (4eac <grid_port_receive_task+0x16c>)
    4de8:	4831      	ldr	r0, [pc, #196]	; (4eb0 <grid_port_receive_task+0x170>)
    4dea:	4798      	blx	r3
						grid_port_reset_receiver(por);
    4dec:	4b2b      	ldr	r3, [pc, #172]	; (4e9c <grid_port_receive_task+0x15c>)
    4dee:	4620      	mov	r0, r4
    4df0:	4798      	blx	r3
    4df2:	e7d6      	b.n	4da2 <grid_port_receive_task+0x62>
				por->rx_double_buffer_timeout++;
    4df4:	3301      	adds	r3, #1
    4df6:	61e3      	str	r3, [r4, #28]
    4df8:	e7d3      	b.n	4da2 <grid_port_receive_task+0x62>
			else if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 0){
    4dfa:	b923      	cbnz	r3, 4e06 <grid_port_receive_task+0xc6>
	if (por->rx_double_buffer_status == 0){
    4dfc:	6a23      	ldr	r3, [r4, #32]
    4dfe:	2b00      	cmp	r3, #0
    4e00:	d1e3      	bne.n	4dca <grid_port_receive_task+0x8a>
}
    4e02:	b003      	add	sp, #12
    4e04:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (por->rx_double_buffer_seek_start_index == por->rx_double_buffer_read_start_index-1)
    4e06:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    4e08:	1e6b      	subs	r3, r5, #1
    4e0a:	429a      	cmp	r2, r3
    4e0c:	d10d      	bne.n	4e2a <grid_port_receive_task+0xea>
				grid_port_reset_receiver(por);	
    4e0e:	4b23      	ldr	r3, [pc, #140]	; (4e9c <grid_port_receive_task+0x15c>)
    4e10:	4620      	mov	r0, r4
    4e12:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 255, 0, 0, 2, 200); // RED
    4e14:	2302      	movs	r3, #2
    4e16:	20c8      	movs	r0, #200	; 0xc8
    4e18:	e9cd 3000 	strd	r3, r0, [sp]
    4e1c:	2300      	movs	r3, #0
    4e1e:	461a      	mov	r2, r3
    4e20:	21ff      	movs	r1, #255	; 0xff
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e22:	481f      	ldr	r0, [pc, #124]	; (4ea0 <grid_port_receive_task+0x160>)
    4e24:	4c1f      	ldr	r4, [pc, #124]	; (4ea4 <grid_port_receive_task+0x164>)
    4e26:	47a0      	blx	r4
				return;
    4e28:	e7eb      	b.n	4e02 <grid_port_receive_task+0xc2>
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4e2a:	42b2      	cmp	r2, r6
    4e2c:	d10b      	bne.n	4e46 <grid_port_receive_task+0x106>
    4e2e:	b955      	cbnz	r5, 4e46 <grid_port_receive_task+0x106>
				grid_port_reset_receiver(por);
    4e30:	4b1a      	ldr	r3, [pc, #104]	; (4e9c <grid_port_receive_task+0x15c>)
    4e32:	4620      	mov	r0, r4
    4e34:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 2, 200); // RED
    4e36:	2302      	movs	r3, #2
    4e38:	21c8      	movs	r1, #200	; 0xc8
    4e3a:	e9cd 3100 	strd	r3, r1, [sp]
    4e3e:	22ff      	movs	r2, #255	; 0xff
    4e40:	462b      	mov	r3, r5
    4e42:	4629      	mov	r1, r5
    4e44:	e7ed      	b.n	4e22 <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4e46:	4465      	add	r5, ip
    4e48:	fbb5 f3f7 	udiv	r3, r5, r7
    4e4c:	fb07 5513 	mls	r5, r7, r3, r5
    4e50:	4425      	add	r5, r4
    4e52:	5c2b      	ldrb	r3, [r5, r0]
    4e54:	b153      	cbz	r3, 4e6c <grid_port_receive_task+0x12c>
				grid_port_reset_receiver(por);
    4e56:	4b11      	ldr	r3, [pc, #68]	; (4e9c <grid_port_receive_task+0x15c>)
    4e58:	4620      	mov	r0, r4
    4e5a:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e5c:	2302      	movs	r3, #2
    4e5e:	22c8      	movs	r2, #200	; 0xc8
    4e60:	e9cd 3200 	strd	r3, r2, [sp]
    4e64:	2200      	movs	r2, #0
    4e66:	23ff      	movs	r3, #255	; 0xff
    4e68:	4611      	mov	r1, r2
    4e6a:	e7da      	b.n	4e22 <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4e6c:	4572      	cmp	r2, lr
				por->rx_double_buffer_seek_start_index++;
    4e6e:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
    4e72:	bf98      	it	ls
    4e74:	3201      	addls	r2, #1
    4e76:	b289      	uxth	r1, r1
				por->rx_double_buffer_timeout = 0;
    4e78:	61e3      	str	r3, [r4, #28]
				por->rx_double_buffer_seek_start_index++;
    4e7a:	bf94      	ite	ls
    4e7c:	6262      	strls	r2, [r4, #36]	; 0x24
				por->rx_double_buffer_seek_start_index=0;
    4e7e:	6263      	strhi	r3, [r4, #36]	; 0x24
		for(uint16_t i = 0; i<490; i++){
    4e80:	2900      	cmp	r1, #0
    4e82:	d199      	bne.n	4db8 <grid_port_receive_task+0x78>
    4e84:	e7ba      	b.n	4dfc <grid_port_receive_task+0xbc>
		length = por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e86:	3201      	adds	r2, #1
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e88:	1a52      	subs	r2, r2, r1
	grid_port_receive_decode(por, por->rx_double_buffer_read_start_index, length);
    4e8a:	4b0b      	ldr	r3, [pc, #44]	; (4eb8 <grid_port_receive_task+0x178>)
    4e8c:	b292      	uxth	r2, r2
    4e8e:	b289      	uxth	r1, r1
    4e90:	4620      	mov	r0, r4
    4e92:	4798      	blx	r3
	por->rx_double_buffer_status = 0;
    4e94:	2300      	movs	r3, #0
    4e96:	6223      	str	r3, [r4, #32]
    4e98:	e7b3      	b.n	4e02 <grid_port_receive_task+0xc2>
    4e9a:	bf00      	nop
    4e9c:	000046e9 	.word	0x000046e9
    4ea0:	2000f008 	.word	0x2000f008
    4ea4:	00009bbb 	.word	0x00009bbb
    4ea8:	00015f4d 	.word	0x00015f4d
    4eac:	00014925 	.word	0x00014925
    4eb0:	00015eb7 	.word	0x00015eb7
    4eb4:	00015f71 	.word	0x00015f71
    4eb8:	00004875 	.word	0x00004875

00004ebc <grid_buffer_read_size>:
	return 1;
}

uint16_t grid_buffer_read_size(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4ebc:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4ec0:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4ec4:	428b      	cmp	r3, r1
uint16_t grid_buffer_read_size(struct grid_buffer* buf){
    4ec6:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ec8:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop) {
    4eca:	d000      	beq.n	4ece <grid_buffer_read_size+0x12>
		while(1){
    4ecc:	e7fe      	b.n	4ecc <grid_buffer_read_size+0x10>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4ece:	f8b0 63ea 	ldrh.w	r6, [r0, #1002]	; 0x3ea
    4ed2:	42b3      	cmp	r3, r6
    4ed4:	d000      	beq.n	4ed8 <grid_buffer_read_size+0x1c>
		while(1){
    4ed6:	e7fe      	b.n	4ed6 <grid_buffer_read_size+0x1a>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	if (buf->read_start == buf->write_start) {
    4ed8:	f8b0 73f2 	ldrh.w	r7, [r0, #1010]	; 0x3f2
    4edc:	42be      	cmp	r6, r7
    4ede:	d016      	beq.n	4f0e <grid_buffer_read_size+0x52>
	}
	
	
	
	// Seek message end character
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4ee0:	8805      	ldrh	r5, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4ee2:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4ee4:	b2a3      	uxth	r3, r4
    4ee6:	429d      	cmp	r5, r3
    4ee8:	d800      	bhi.n	4eec <grid_buffer_read_size+0x30>
		}
		
		
	}
	
	while(1){
    4eea:	e7fe      	b.n	4eea <grid_buffer_read_size+0x2e>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4eec:	1930      	adds	r0, r6, r4
    4eee:	fbb0 f1f5 	udiv	r1, r0, r5
    4ef2:	fb05 0111 	mls	r1, r5, r1, r0
		if (index == buf->write_start) return 0;
    4ef6:	b288      	uxth	r0, r1
    4ef8:	4287      	cmp	r7, r0
    4efa:	d008      	beq.n	4f0e <grid_buffer_read_size+0x52>
		if (buf->buffer_storage[index] == '\n'){
    4efc:	4411      	add	r1, r2
    4efe:	3301      	adds	r3, #1
    4f00:	b298      	uxth	r0, r3
    4f02:	788b      	ldrb	r3, [r1, #2]
    4f04:	2b0a      	cmp	r3, #10
    4f06:	f104 0401 	add.w	r4, r4, #1
    4f0a:	d1eb      	bne.n	4ee4 <grid_buffer_read_size+0x28>
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f0e:	2000      	movs	r0, #0
    4f10:	e7fc      	b.n	4f0c <grid_buffer_read_size+0x50>

00004f12 <grid_buffer_read_init>:

uint16_t grid_buffer_read_init(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f12:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4f16:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f1a:	4293      	cmp	r3, r2
uint16_t grid_buffer_read_init(struct grid_buffer* buf){
    4f1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->read_active != buf->read_stop) {
    4f1e:	d000      	beq.n	4f22 <grid_buffer_read_init+0x10>
		while(1){
    4f20:	e7fe      	b.n	4f20 <grid_buffer_read_init+0xe>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f22:	f8b0 53ea 	ldrh.w	r5, [r0, #1002]	; 0x3ea
    4f26:	42ab      	cmp	r3, r5
    4f28:	d000      	beq.n	4f2c <grid_buffer_read_init+0x1a>
		while(1){
    4f2a:	e7fe      	b.n	4f2a <grid_buffer_read_init+0x18>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	if (buf->read_start == buf->write_start) {
    4f2c:	f8b0 63f2 	ldrh.w	r6, [r0, #1010]	; 0x3f2
    4f30:	42b5      	cmp	r5, r6
    4f32:	d020      	beq.n	4f76 <grid_buffer_read_init+0x64>
	}
	
	
	
	// Seek message end character	
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f34:	8801      	ldrh	r1, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f36:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f38:	b2a3      	uxth	r3, r4
    4f3a:	4299      	cmp	r1, r3
    4f3c:	d800      	bhi.n	4f40 <grid_buffer_read_init+0x2e>
		}
		
		
	}
		
	while(1){
    4f3e:	e7fe      	b.n	4f3e <grid_buffer_read_init+0x2c>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f40:	192f      	adds	r7, r5, r4
    4f42:	fbb7 f2f1 	udiv	r2, r7, r1
    4f46:	fb01 7212 	mls	r2, r1, r2, r7
		if (index == buf->write_start) return 0;	
    4f4a:	b297      	uxth	r7, r2
    4f4c:	42be      	cmp	r6, r7
    4f4e:	d012      	beq.n	4f76 <grid_buffer_read_init+0x64>
		if (buf->buffer_storage[index] == '\n'){
    4f50:	1887      	adds	r7, r0, r2
    4f52:	3301      	adds	r3, #1
    4f54:	78bf      	ldrb	r7, [r7, #2]
    4f56:	2f0a      	cmp	r7, #10
    4f58:	b29b      	uxth	r3, r3
    4f5a:	f104 0401 	add.w	r4, r4, #1
    4f5e:	d1eb      	bne.n	4f38 <grid_buffer_read_init+0x26>
			buf->read_stop = (index+1)%buf->buffer_length;
    4f60:	3201      	adds	r2, #1
    4f62:	fbb2 f4f1 	udiv	r4, r2, r1
    4f66:	fb01 2214 	mls	r2, r1, r4, r2
    4f6a:	f8a0 23ec 	strh.w	r2, [r0, #1004]	; 0x3ec
			buf->read_length = i+1;
    4f6e:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f72:	4618      	mov	r0, r3
    4f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f76:	2300      	movs	r3, #0
    4f78:	e7fb      	b.n	4f72 <grid_buffer_read_init+0x60>

00004f7a <grid_buffer_read_character>:

uint8_t grid_buffer_read_character(struct grid_buffer* buf){
	
	// Check if packet is not over
	if (buf->read_active != buf->read_stop){
    4f7a:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f7e:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4f82:	4299      	cmp	r1, r3
uint8_t grid_buffer_read_character(struct grid_buffer* buf){
    4f84:	b510      	push	{r4, lr}
    4f86:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop){
    4f88:	d00b      	beq.n	4fa2 <grid_buffer_read_character+0x28>
		
		uint8_t character = buf->buffer_storage[buf->read_active];
		
		buf->read_active++;
		buf->read_active %= buf->buffer_length;
    4f8a:	8814      	ldrh	r4, [r2, #0]
		uint8_t character = buf->buffer_storage[buf->read_active];
    4f8c:	18c1      	adds	r1, r0, r3
		buf->read_active++;
    4f8e:	3301      	adds	r3, #1
		buf->read_active %= buf->buffer_length;
    4f90:	b29b      	uxth	r3, r3
		uint8_t character = buf->buffer_storage[buf->read_active];
    4f92:	7888      	ldrb	r0, [r1, #2]
		buf->read_active %= buf->buffer_length;
    4f94:	fbb3 f1f4 	udiv	r1, r3, r4
    4f98:	fb04 3311 	mls	r3, r4, r1, r3
    4f9c:	f8a2 33ee 	strh.w	r3, [r2, #1006]	; 0x3ee
			// TRAP: TRANSMISSION WAS OVER ALREADY
		}
	}
	

}
    4fa0:	bd10      	pop	{r4, pc}
		while(1){
    4fa2:	e7fe      	b.n	4fa2 <grid_buffer_read_character+0x28>

00004fa4 <grid_buffer_read_acknowledge>:

// TRANSMISSION WAS ACKNOWLEDGED, PACKET CAN BE DELETED
uint8_t grid_buffer_read_acknowledge(struct grid_buffer* buf){
	
	// Check if packet is really over
	if (buf->read_active == buf->read_stop){
    4fa4:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4fa8:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4fac:	4293      	cmp	r3, r2
    4fae:	d000      	beq.n	4fb2 <grid_buffer_read_acknowledge+0xe>
		buf->read_start = buf->read_stop;
		return 1;
	}else{
		
		while(1){
    4fb0:	e7fe      	b.n	4fb0 <grid_buffer_read_acknowledge+0xc>
		buf->read_start = buf->read_stop;
    4fb2:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	

}
    4fb6:	2001      	movs	r0, #1
    4fb8:	4770      	bx	lr
	...

00004fbc <grid_port_init>:
	buf->read_start  = buf->read_stop;
	
	return 1;
}

void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4fc0:	4604      	mov	r4, r0
	
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fc2:	f500 501c 	add.w	r0, r0, #9984	; 0x2700
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fc6:	b087      	sub	sp, #28
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fc8:	f8df 8148 	ldr.w	r8, [pc, #328]	; 5114 <grid_port_init+0x158>
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fcc:	460d      	mov	r5, r1
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fce:	303c      	adds	r0, #60	; 0x3c
    4fd0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fd4:	4616      	mov	r6, r2
    4fd6:	461f      	mov	r7, r3
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fd8:	47c0      	blx	r8
	grid_buffer_init(&por->rx_buffer, GRID_BUFFER_SIZE);
    4fda:	f504 502c 	add.w	r0, r4, #11008	; 0x2b00
    4fde:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    4fe2:	3034      	adds	r0, #52	; 0x34
    4fe4:	47c0      	blx	r8
	
	
	por->cooldown = 0;
    4fe6:	2000      	movs	r0, #0
	
	por->dma_channel = dma;
    4fe8:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
	por->cooldown = 0;
    4fec:	6020      	str	r0, [r4, #0]
	
	por->tx_double_buffer_status	= 0;
	por->rx_double_buffer_status	= 0;
	
	
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    4fee:	f241 3288 	movw	r2, #5000	; 0x1388
	por->dma_channel = dma;
    4ff2:	72a3      	strb	r3, [r4, #10]
	por->direction = dir;
    4ff4:	7267      	strb	r7, [r4, #9]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    4ff6:	4603      	mov	r3, r0
	por->usart	= usart;
    4ff8:	6065      	str	r5, [r4, #4]
	por->type		= type;
    4ffa:	7226      	strb	r6, [r4, #8]
	por->tx_double_buffer_status	= 0;
    4ffc:	81a0      	strh	r0, [r4, #12]
	por->rx_double_buffer_status	= 0;
    4ffe:	6220      	str	r0, [r4, #32]
		por->tx_double_buffer[i] = 0;		
    5000:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5002:	3301      	adds	r3, #1
    5004:	4293      	cmp	r3, r2
		por->tx_double_buffer[i] = 0;		
    5006:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    500a:	d1f9      	bne.n	5000 <grid_port_init+0x44>
	}
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    500c:	2300      	movs	r3, #0
		por->rx_double_buffer[i] = 0;
    500e:	f241 31b4 	movw	r1, #5044	; 0x13b4
    5012:	461d      	mov	r5, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5014:	f241 3288 	movw	r2, #5000	; 0x1388
		por->rx_double_buffer[i] = 0;
    5018:	18e0      	adds	r0, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    501a:	3301      	adds	r3, #1
    501c:	4293      	cmp	r3, r2
		por->rx_double_buffer[i] = 0;
    501e:	5445      	strb	r5, [r0, r1]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5020:	d1fa      	bne.n	5018 <grid_port_init+0x5c>
	}
	
	por->partner_fi = 0;
	
	por->partner_hwcfg = 0;
    5022:	f642 732c 	movw	r3, #12076	; 0x2f2c
	por->partner_fi = 0;
    5026:	f642 7130 	movw	r1, #12080	; 0x2f30
	por->partner_status = 1;
	
	por->ping_local_token = 255;
    502a:	f642 7031 	movw	r0, #12081	; 0x2f31
	por->partner_fi = 0;
    502e:	5465      	strb	r5, [r4, r1]
	por->partner_hwcfg = 0;
    5030:	50e5      	str	r5, [r4, r3]
	por->partner_status = 1;
    5032:	f642 734b 	movw	r3, #12107	; 0x2f4b
    5036:	2201      	movs	r2, #1
	por->ping_local_token = 255;
    5038:	27ff      	movs	r7, #255	; 0xff
	por->partner_status = 1;
    503a:	54e2      	strb	r2, [r4, r3]
	por->ping_local_token = 255;
    503c:	5427      	strb	r7, [r4, r0]
	por->ping_partner_token = 255;
    503e:	f642 7032 	movw	r0, #12082	; 0x2f32
	
	por->ping_flag = 0;
	
	if (type == GRID_PORT_TYPE_USART){	
    5042:	4296      	cmp	r6, r2
	por->ping_partner_token = 255;
    5044:	5427      	strb	r7, [r4, r0]
	por->ping_flag = 0;
    5046:	f642 7048 	movw	r0, #12104	; 0x2f48
    504a:	5425      	strb	r5, [r4, r0]
	if (type == GRID_PORT_TYPE_USART){	
    504c:	d156      	bne.n	50fc <grid_port_init+0x140>
		
		por->partner_status = 0;
    504e:	54e5      	strb	r5, [r4, r3]
		por->partner_fi = 0;
    5050:	5465      	strb	r5, [r4, r1]
		
		
		sprintf(por->ping_packet, "%c%c%c%c%02x%02x%02x%c00\n", GRID_CONST_SOH, GRID_CONST_DCT, GRID_CONST_BELL, por->direction, grid_sys_get_hwcfg(), 255, 255, GRID_CONST_EOT);
    5052:	4b2b      	ldr	r3, [pc, #172]	; (5100 <grid_port_init+0x144>)
    5054:	f894 9009 	ldrb.w	r9, [r4, #9]
    5058:	4798      	blx	r3
    505a:	f504 583c 	add.w	r8, r4, #12032	; 0x2f00
    505e:	2304      	movs	r3, #4
    5060:	f108 0833 	add.w	r8, r8, #51	; 0x33
    5064:	e9cd 7304 	strd	r7, r3, [sp, #16]
    5068:	fa5f f989 	uxtb.w	r9, r9
    506c:	2307      	movs	r3, #7
    506e:	4632      	mov	r2, r6
    5070:	4924      	ldr	r1, [pc, #144]	; (5104 <grid_port_init+0x148>)
    5072:	f8cd 9004 	str.w	r9, [sp, #4]
    5076:	e9cd 0702 	strd	r0, r7, [sp, #8]
    507a:	f8df 909c 	ldr.w	r9, [pc, #156]	; 5118 <grid_port_init+0x15c>
    507e:	9300      	str	r3, [sp, #0]
    5080:	4640      	mov	r0, r8
    5082:	230e      	movs	r3, #14
    5084:	47c8      	blx	r9
		
		por->ping_packet_length = strlen(por->ping_packet);	
    5086:	4b20      	ldr	r3, [pc, #128]	; (5108 <grid_port_init+0x14c>)
    5088:	4640      	mov	r0, r8
    508a:	4798      	blx	r3
    508c:	f642 7347 	movw	r3, #12103	; 0x2f47
    5090:	b2c0      	uxtb	r0, r0
    5092:	54e0      	strb	r0, [r4, r3]
			
		grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    5094:	4640      	mov	r0, r8
    5096:	f814 9003 	ldrb.w	r9, [r4, r3]
    509a:	5ce1      	ldrb	r1, [r4, r3]
    509c:	4b1b      	ldr	r3, [pc, #108]	; (510c <grid_port_init+0x150>)
    509e:	4798      	blx	r3
    50a0:	fa5f f989 	uxtb.w	r9, r9
    50a4:	4b1a      	ldr	r3, [pc, #104]	; (5110 <grid_port_init+0x154>)
    50a6:	4602      	mov	r2, r0
    50a8:	4649      	mov	r1, r9
    50aa:	4640      	mov	r0, r8
    50ac:	4798      	blx	r3
		

		
		if (por->direction == GRID_CONST_NORTH){
    50ae:	7a63      	ldrb	r3, [r4, #9]
    50b0:	2b11      	cmp	r3, #17
    50b2:	d108      	bne.n	50c6 <grid_port_init+0x10a>
			por->dx = 0;
    50b4:	f642 7349 	movw	r3, #12105	; 0x2f49
    50b8:	54e5      	strb	r5, [r4, r3]
			por->dy = 1;
    50ba:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50be:	54e6      	strb	r6, [r4, r3]
	}
	else{
		por->partner_status = 1; //UI AND USB are considered to be connected by default
	}
	
}
    50c0:	b007      	add	sp, #28
    50c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if (por->direction == GRID_CONST_EAST){
    50c6:	7a63      	ldrb	r3, [r4, #9]
    50c8:	2b12      	cmp	r3, #18
    50ca:	d106      	bne.n	50da <grid_port_init+0x11e>
			por->dx = 1;
    50cc:	f642 7349 	movw	r3, #12105	; 0x2f49
    50d0:	54e6      	strb	r6, [r4, r3]
			por->dy = 0;
    50d2:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50d6:	54e5      	strb	r5, [r4, r3]
    50d8:	e7f2      	b.n	50c0 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_SOUTH){
    50da:	7a63      	ldrb	r3, [r4, #9]
    50dc:	2b13      	cmp	r3, #19
    50de:	d106      	bne.n	50ee <grid_port_init+0x132>
			por->dx = 0;
    50e0:	f642 7349 	movw	r3, #12105	; 0x2f49
    50e4:	54e5      	strb	r5, [r4, r3]
			por->dy = -1;
    50e6:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50ea:	54e7      	strb	r7, [r4, r3]
    50ec:	e7e8      	b.n	50c0 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_WEST){
    50ee:	7a63      	ldrb	r3, [r4, #9]
    50f0:	2b14      	cmp	r3, #20
    50f2:	d1e5      	bne.n	50c0 <grid_port_init+0x104>
			por->dx = -1;
    50f4:	f642 7349 	movw	r3, #12105	; 0x2f49
    50f8:	54e7      	strb	r7, [r4, r3]
    50fa:	e7ea      	b.n	50d2 <grid_port_init+0x116>
		por->partner_status = 1; //UI AND USB are considered to be connected by default
    50fc:	54e2      	strb	r2, [r4, r3]
}
    50fe:	e7df      	b.n	50c0 <grid_port_init+0x104>
    5100:	00009c95 	.word	0x00009c95
    5104:	00015f8a 	.word	0x00015f8a
    5108:	00014d0b 	.word	0x00014d0b
    510c:	00009d79 	.word	0x00009d79
    5110:	00009dad 	.word	0x00009dad
    5114:	00004795 	.word	0x00004795
    5118:	00014c8d 	.word	0x00014c8d

0000511c <grid_port_init_all>:

void grid_port_init_all(void){
    511c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5120:	2600      	movs	r6, #0
    5122:	4d1c      	ldr	r5, [pc, #112]	; (5194 <grid_port_init_all+0x78>)
    5124:	491c      	ldr	r1, [pc, #112]	; (5198 <grid_port_init_all+0x7c>)
    5126:	481d      	ldr	r0, [pc, #116]	; (519c <grid_port_init_all+0x80>)
    5128:	9600      	str	r6, [sp, #0]
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    512a:	2401      	movs	r4, #1
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    512c:	2311      	movs	r3, #17
    512e:	2201      	movs	r2, #1
    5130:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    5132:	f04f 0902 	mov.w	r9, #2
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    5136:	4622      	mov	r2, r4
    5138:	4919      	ldr	r1, [pc, #100]	; (51a0 <grid_port_init_all+0x84>)
    513a:	481a      	ldr	r0, [pc, #104]	; (51a4 <grid_port_init_all+0x88>)
    513c:	9400      	str	r4, [sp, #0]
    513e:	2312      	movs	r3, #18
    5140:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    5142:	2703      	movs	r7, #3
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    5144:	4622      	mov	r2, r4
    5146:	4918      	ldr	r1, [pc, #96]	; (51a8 <grid_port_init_all+0x8c>)
    5148:	4818      	ldr	r0, [pc, #96]	; (51ac <grid_port_init_all+0x90>)
    514a:	f8cd 9000 	str.w	r9, [sp]
    514e:	2313      	movs	r3, #19
    5150:	47a8      	blx	r5
	
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    5152:	f8df 8068 	ldr.w	r8, [pc, #104]	; 51bc <grid_port_init_all+0xa0>
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    5156:	9700      	str	r7, [sp, #0]
    5158:	4622      	mov	r2, r4
    515a:	4915      	ldr	r1, [pc, #84]	; (51b0 <grid_port_init_all+0x94>)
    515c:	4815      	ldr	r0, [pc, #84]	; (51b4 <grid_port_init_all+0x98>)
    515e:	2314      	movs	r3, #20
    5160:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    5162:	f04f 0aff 	mov.w	sl, #255	; 0xff
    5166:	463a      	mov	r2, r7
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    5168:	4f13      	ldr	r7, [pc, #76]	; (51b8 <grid_port_init_all+0x9c>)
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    516a:	f8cd a000 	str.w	sl, [sp]
    516e:	4633      	mov	r3, r6
    5170:	4631      	mov	r1, r6
    5172:	4640      	mov	r0, r8
    5174:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    5176:	4633      	mov	r3, r6
    5178:	f8cd a000 	str.w	sl, [sp]
    517c:	464a      	mov	r2, r9
    517e:	4631      	mov	r1, r6
    5180:	4638      	mov	r0, r7
    5182:	47a8      	blx	r5
	
	GRID_PORT_U.partner_status = 1; // UI IS ALWAYS CONNECTED
    5184:	f642 734b 	movw	r3, #12107	; 0x2f4b
    5188:	f808 4003 	strb.w	r4, [r8, r3]
	GRID_PORT_H.partner_status = 1; // HOST IS ALWAYS CONNECTED (Not really!)
    518c:	54fc      	strb	r4, [r7, r3]
	
	
}
    518e:	b002      	add	sp, #8
    5190:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5194:	00004fbd 	.word	0x00004fbd
    5198:	2001ce04 	.word	0x2001ce04
    519c:	20009150 	.word	0x20009150
    51a0:	2001cdb0 	.word	0x2001cdb0
    51a4:	20019870 	.word	0x20019870
    51a8:	2001cf08 	.word	0x2001cf08
    51ac:	200138d4 	.word	0x200138d4
    51b0:	2001ceb8 	.word	0x2001ceb8
    51b4:	200102d4 	.word	0x200102d4
    51b8:	20016824 	.word	0x20016824
    51bc:	2000c0b0 	.word	0x2000c0b0

000051c0 <grid_port_process_inbound>:


//=============================== PROCESS INBOUND ==============================//


uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51c4:	f500 582c 	add.w	r8, r0, #11008	; 0x2b00
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51c8:	b091      	sub	sp, #68	; 0x44
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51ca:	f108 0834 	add.w	r8, r8, #52	; 0x34
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51ce:	af02      	add	r7, sp, #8
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51d0:	4b5c      	ldr	r3, [pc, #368]	; (5344 <grid_port_process_inbound+0x184>)
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51d2:	6079      	str	r1, [r7, #4]
    51d4:	4606      	mov	r6, r0
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51d6:	4640      	mov	r0, r8
    51d8:	4798      	blx	r3
	
	if (!packet_size){
    51da:	4605      	mov	r5, r0
    51dc:	2800      	cmp	r0, #0
    51de:	f000 80af 	beq.w	5340 <grid_port_process_inbound+0x180>
		uint8_t port_count = 6;
		struct grid_port* port_array_default[port_count];
		struct grid_port* port_array[port_count];
		
		
		port_array_default[0] = &GRID_PORT_N;
    51e2:	4b59      	ldr	r3, [pc, #356]	; (5348 <grid_port_process_inbound+0x188>)
    51e4:	60bb      	str	r3, [r7, #8]
		port_array_default[1] = &GRID_PORT_E;
    51e6:	4b59      	ldr	r3, [pc, #356]	; (534c <grid_port_process_inbound+0x18c>)
    51e8:	60fb      	str	r3, [r7, #12]
		port_array_default[2] = &GRID_PORT_S;
    51ea:	4b59      	ldr	r3, [pc, #356]	; (5350 <grid_port_process_inbound+0x190>)
    51ec:	613b      	str	r3, [r7, #16]
		port_array_default[3] = &GRID_PORT_W;
    51ee:	4b59      	ldr	r3, [pc, #356]	; (5354 <grid_port_process_inbound+0x194>)
    51f0:	617b      	str	r3, [r7, #20]
		
		port_array_default[4] = &GRID_PORT_U;
    51f2:	4b59      	ldr	r3, [pc, #356]	; (5358 <grid_port_process_inbound+0x198>)
    51f4:	61bb      	str	r3, [r7, #24]
		port_array_default[5] = &GRID_PORT_H;
    51f6:	4b59      	ldr	r3, [pc, #356]	; (535c <grid_port_process_inbound+0x19c>)
    51f8:	61fb      	str	r3, [r7, #28]
	}else{
    51fa:	46eb      	mov	fp, sp
		
		uint8_t j=0;
		
		for(uint8_t i=0; i<port_count; i++){
    51fc:	f107 0308 	add.w	r3, r7, #8
		port_array_default[5] = &GRID_PORT_H;
    5200:	f04f 0906 	mov.w	r9, #6
		uint8_t j=0;
    5204:	2400      	movs	r4, #0
			if (port_array_default[i]->partner_status != 0){
    5206:	f642 714b 	movw	r1, #12107	; 0x2f4b
    520a:	f853 2b04 	ldr.w	r2, [r3], #4
    520e:	5c50      	ldrb	r0, [r2, r1]
    5210:	b138      	cbz	r0, 5222 <grid_port_process_inbound+0x62>
				port_array[j] = port_array_default[i];
    5212:	f107 0038 	add.w	r0, r7, #56	; 0x38
    5216:	eb00 0084 	add.w	r0, r0, r4, lsl #2
				j++;
    521a:	3401      	adds	r4, #1
				port_array[j] = port_array_default[i];
    521c:	f840 2c18 	str.w	r2, [r0, #-24]
				j++;
    5220:	b2e4      	uxtb	r4, r4
		for(uint8_t i=0; i<port_count; i++){
    5222:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    5226:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
    522a:	d1ee      	bne.n	520a <grid_port_process_inbound+0x4a>
		
		for (uint8_t i=0; i<port_count; i++)
		{
			if (port_array[i] != por || loopback){
			
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    522c:	4a4c      	ldr	r2, [pc, #304]	; (5360 <grid_port_process_inbound+0x1a0>)
    522e:	4649      	mov	r1, r9
			if (port_array[i] != por || loopback){
    5230:	f107 0a20 	add.w	sl, r7, #32
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5234:	f242 7c3c 	movw	ip, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5238:	b2c8      	uxtb	r0, r1
    523a:	4284      	cmp	r4, r0
    523c:	d805      	bhi.n	524a <grid_port_process_inbound+0x8a>
					return 0;
				}	
			}	
		}
		
		if (packet_size != grid_buffer_read_init(&por->rx_buffer)){
    523e:	4b49      	ldr	r3, [pc, #292]	; (5364 <grid_port_process_inbound+0x1a4>)
    5240:	4640      	mov	r0, r8
    5242:	4798      	blx	r3
    5244:	42a8      	cmp	r0, r5
    5246:	d047      	beq.n	52d8 <grid_port_process_inbound+0x118>
			while(1){			
    5248:	e7fe      	b.n	5248 <grid_port_process_inbound+0x88>
			if (port_array[i] != por || loopback){
    524a:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
    524e:	42b0      	cmp	r0, r6
    5250:	d101      	bne.n	5256 <grid_port_process_inbound+0x96>
    5252:	687b      	ldr	r3, [r7, #4]
    5254:	b1b3      	cbz	r3, 5284 <grid_port_process_inbound+0xc4>
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5256:	4460      	add	r0, ip
    5258:	4790      	blx	r2
    525a:	42a8      	cmp	r0, r5
    525c:	4a40      	ldr	r2, [pc, #256]	; (5360 <grid_port_process_inbound+0x1a0>)
    525e:	f242 7c3c 	movw	ip, #10044	; 0x273c
    5262:	d20f      	bcs.n	5284 <grid_port_process_inbound+0xc4>
					grid_sys_alert_set_alert(&grid_sys_state, 100,100,0,2,200);
    5264:	2302      	movs	r3, #2
    5266:	22c8      	movs	r2, #200	; 0xc8
    5268:	e9cd 3200 	strd	r3, r2, [sp]
    526c:	2264      	movs	r2, #100	; 0x64
    526e:	483e      	ldr	r0, [pc, #248]	; (5368 <grid_port_process_inbound+0x1a8>)
    5270:	4c3e      	ldr	r4, [pc, #248]	; (536c <grid_port_process_inbound+0x1ac>)
    5272:	2300      	movs	r3, #0
    5274:	4611      	mov	r1, r2
    5276:	47a0      	blx	r4
					return 0;
    5278:	46dd      	mov	sp, fp
		}	

		return 1;
	}
		
}
    527a:	4648      	mov	r0, r9
    527c:	373c      	adds	r7, #60	; 0x3c
    527e:	46bd      	mov	sp, r7
    5280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (uint8_t i=0; i<port_count; i++)
    5284:	3101      	adds	r1, #1
    5286:	e7d7      	b.n	5238 <grid_port_process_inbound+0x78>
			if (port_array[i] != por || loopback){
    5288:	f85a 0029 	ldr.w	r0, [sl, r9, lsl #2]
    528c:	42b0      	cmp	r0, r6
    528e:	d101      	bne.n	5294 <grid_port_process_inbound+0xd4>
    5290:	6879      	ldr	r1, [r7, #4]
    5292:	b129      	cbz	r1, 52a0 <grid_port_process_inbound+0xe0>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    5294:	4418      	add	r0, r3
    5296:	4629      	mov	r1, r5
    5298:	4790      	blx	r2
    529a:	4a35      	ldr	r2, [pc, #212]	; (5370 <grid_port_process_inbound+0x1b0>)
    529c:	f242 733c 	movw	r3, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52a0:	f109 0901 	add.w	r9, r9, #1
    52a4:	fa5f f189 	uxtb.w	r1, r9
    52a8:	428c      	cmp	r4, r1
    52aa:	d8ed      	bhi.n	5288 <grid_port_process_inbound+0xc8>
    52ac:	f04f 0a00 	mov.w	sl, #0
		for (uint16_t j=0; j<packet_size; j++)
    52b0:	fa1f f38a 	uxth.w	r3, sl
    52b4:	429d      	cmp	r5, r3
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52b6:	4640      	mov	r0, r8
		for (uint16_t j=0; j<packet_size; j++)
    52b8:	d816      	bhi.n	52e8 <grid_port_process_inbound+0x128>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    52ba:	4b2e      	ldr	r3, [pc, #184]	; (5374 <grid_port_process_inbound+0x1b4>)
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    52bc:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 5380 <grid_port_process_inbound+0x1c0>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    52c0:	4798      	blx	r3
			if (port_array[i] != por || loopback){
    52c2:	f107 0520 	add.w	r5, r7, #32
		for (uint8_t i=0; i<port_count; i++)
    52c6:	2100      	movs	r1, #0
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    52c8:	f242 783c 	movw	r8, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52cc:	b2cb      	uxtb	r3, r1
    52ce:	429c      	cmp	r4, r3
    52d0:	d82c      	bhi.n	532c <grid_port_process_inbound+0x16c>
		return 1;
    52d2:	f04f 0901 	mov.w	r9, #1
    52d6:	e7cf      	b.n	5278 <grid_port_process_inbound+0xb8>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52d8:	4a25      	ldr	r2, [pc, #148]	; (5370 <grid_port_process_inbound+0x1b0>)
    52da:	f04f 0900 	mov.w	r9, #0
			if (port_array[i] != por || loopback){
    52de:	f107 0a20 	add.w	sl, r7, #32
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52e2:	f242 733c 	movw	r3, #10044	; 0x273c
    52e6:	e7dd      	b.n	52a4 <grid_port_process_inbound+0xe4>
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52e8:	4b23      	ldr	r3, [pc, #140]	; (5378 <grid_port_process_inbound+0x1b8>)
    52ea:	4798      	blx	r3
			for (uint8_t i=0; i<port_count; i++){
    52ec:	f04f 0900 	mov.w	r9, #0
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52f0:	4601      	mov	r1, r0
				if (port_array[i] != por || loopback){
    52f2:	f107 0320 	add.w	r3, r7, #32
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    52f6:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    52fa:	fa5f f089 	uxtb.w	r0, r9
    52fe:	4284      	cmp	r4, r0
    5300:	d802      	bhi.n	5308 <grid_port_process_inbound+0x148>
		for (uint16_t j=0; j<packet_size; j++)
    5302:	f10a 0a01 	add.w	sl, sl, #1
    5306:	e7d3      	b.n	52b0 <grid_port_process_inbound+0xf0>
				if (port_array[i] != por || loopback){
    5308:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
    530c:	42b0      	cmp	r0, r6
    530e:	d101      	bne.n	5314 <grid_port_process_inbound+0x154>
    5310:	687a      	ldr	r2, [r7, #4]
    5312:	b142      	cbz	r2, 5326 <grid_port_process_inbound+0x166>
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    5314:	4b19      	ldr	r3, [pc, #100]	; (537c <grid_port_process_inbound+0x1bc>)
    5316:	6039      	str	r1, [r7, #0]
    5318:	4460      	add	r0, ip
    531a:	4798      	blx	r3
    531c:	6839      	ldr	r1, [r7, #0]
    531e:	f107 0320 	add.w	r3, r7, #32
    5322:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    5326:	f109 0901 	add.w	r9, r9, #1
    532a:	e7e6      	b.n	52fa <grid_port_process_inbound+0x13a>
			if (port_array[i] != por || loopback){
    532c:	f855 0021 	ldr.w	r0, [r5, r1, lsl #2]
    5330:	42b0      	cmp	r0, r6
    5332:	d101      	bne.n	5338 <grid_port_process_inbound+0x178>
    5334:	687b      	ldr	r3, [r7, #4]
    5336:	b10b      	cbz	r3, 533c <grid_port_process_inbound+0x17c>
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5338:	4440      	add	r0, r8
    533a:	47c8      	blx	r9
		for (uint8_t i=0; i<port_count; i++)
    533c:	3101      	adds	r1, #1
    533e:	e7c5      	b.n	52cc <grid_port_process_inbound+0x10c>
		return 0;
    5340:	4681      	mov	r9, r0
    5342:	e79a      	b.n	527a <grid_port_process_inbound+0xba>
    5344:	00004ebd 	.word	0x00004ebd
    5348:	20009150 	.word	0x20009150
    534c:	20019870 	.word	0x20019870
    5350:	200138d4 	.word	0x200138d4
    5354:	200102d4 	.word	0x200102d4
    5358:	2000c0b0 	.word	0x2000c0b0
    535c:	20016824 	.word	0x20016824
    5360:	000047d9 	.word	0x000047d9
    5364:	00004f13 	.word	0x00004f13
    5368:	2000f008 	.word	0x2000f008
    536c:	00009bbb 	.word	0x00009bbb
    5370:	000047f1 	.word	0x000047f1
    5374:	00004fa5 	.word	0x00004fa5
    5378:	00004f7b 	.word	0x00004f7b
    537c:	0000482d 	.word	0x0000482d
    5380:	0000484d 	.word	0x0000484d

00005384 <grid_port_process_outbound_usb>:



//=============================== PROCESS OUTBOUND ==============================//

uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    5384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			

	// OLD DEBUG IMPLEMENTATION
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5388:	f500 551c 	add.w	r5, r0, #9984	; 0x2700
    538c:	353c      	adds	r5, #60	; 0x3c
    538e:	4ba7      	ldr	r3, [pc, #668]	; (562c <grid_port_process_outbound_usb+0x2a8>)
uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    5390:	b0ed      	sub	sp, #436	; 0x1b4
    5392:	4680      	mov	r8, r0
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5394:	4628      	mov	r0, r5
    5396:	4798      	blx	r3
	
	if (!length){		
    5398:	4604      	mov	r4, r0
    539a:	b910      	cbnz	r0, 53a2 <grid_port_process_outbound_usb+0x1e>
			
	// Let's send the packet through USB
	cdcdf_acm_write(por->tx_double_buffer, packet_length);

	
}
    539c:	b06d      	add	sp, #436	; 0x1b4
    539e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    53a2:	f108 0b2c 	add.w	fp, r8, #44	; 0x2c
    53a6:	f508 539d 	add.w	r3, r8, #5024	; 0x13a0
    53aa:	3314      	adds	r3, #20
	if (!length){		
    53ac:	465a      	mov	r2, fp
		por->tx_double_buffer[i] = 0;
    53ae:	2100      	movs	r1, #0
    53b0:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    53b4:	429a      	cmp	r2, r3
    53b6:	d1fb      	bne.n	53b0 <grid_port_process_outbound_usb+0x2c>
	grid_msg_init(&message);
    53b8:	4b9d      	ldr	r3, [pc, #628]	; (5630 <grid_port_process_outbound_usb+0x2ac>)
		grid_msg_packet_receive_char(&message, nextchar);
    53ba:	f8df 92b8 	ldr.w	r9, [pc, #696]	; 5674 <grid_port_process_outbound_usb+0x2f0>
	grid_msg_init(&message);
    53be:	a805      	add	r0, sp, #20
    53c0:	4798      	blx	r3
	grid_buffer_read_init(&por->tx_buffer);
    53c2:	4b9c      	ldr	r3, [pc, #624]	; (5634 <grid_port_process_outbound_usb+0x2b0>)
    53c4:	4628      	mov	r0, r5
    53c6:	4798      	blx	r3
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    53c8:	4b9b      	ldr	r3, [pc, #620]	; (5638 <grid_port_process_outbound_usb+0x2b4>)
	for (uint16_t i = 0; i<length; i++){
    53ca:	46da      	mov	sl, fp
    53cc:	2700      	movs	r7, #0
    53ce:	b2ba      	uxth	r2, r7
    53d0:	4294      	cmp	r4, r2
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    53d2:	4628      	mov	r0, r5
	for (uint16_t i = 0; i<length; i++){
    53d4:	d825      	bhi.n	5422 <grid_port_process_outbound_usb+0x9e>
	grid_buffer_read_acknowledge(&por->tx_buffer);
    53d6:	4b99      	ldr	r3, [pc, #612]	; (563c <grid_port_process_outbound_usb+0x2b8>)
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    53d8:	4c99      	ldr	r4, [pc, #612]	; (5640 <grid_port_process_outbound_usb+0x2bc>)
	grid_buffer_read_acknowledge(&por->tx_buffer);
    53da:	4798      	blx	r3
	int8_t dx = grid_msg_header_get_dx(&message) - GRID_SYS_DEFAULT_POSITION;
    53dc:	4b99      	ldr	r3, [pc, #612]	; (5644 <grid_port_process_outbound_usb+0x2c0>)
    53de:	a805      	add	r0, sp, #20
    53e0:	4798      	blx	r3
    53e2:	387f      	subs	r0, #127	; 0x7f
    53e4:	b243      	sxtb	r3, r0
    53e6:	9300      	str	r3, [sp, #0]
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    53e8:	a805      	add	r0, sp, #20
    53ea:	4b97      	ldr	r3, [pc, #604]	; (5648 <grid_port_process_outbound_usb+0x2c4>)
    53ec:	4798      	blx	r3
    53ee:	387f      	subs	r0, #127	; 0x7f
    53f0:	b243      	sxtb	r3, r0
	for (uint16_t i=0; i<message.body_length; i++){
    53f2:	f04f 0a00 	mov.w	sl, #0
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    53f6:	9301      	str	r3, [sp, #4]
	uint8_t current_start		= 0;
    53f8:	4656      	mov	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    53fa:	9a6a      	ldr	r2, [sp, #424]	; 0x1a8
    53fc:	fa1f f38a 	uxth.w	r3, sl
    5400:	429a      	cmp	r2, r3
    5402:	d818      	bhi.n	5436 <grid_port_process_outbound_usb+0xb2>
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5404:	4b91      	ldr	r3, [pc, #580]	; (564c <grid_port_process_outbound_usb+0x2c8>)
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5406:	4e92      	ldr	r6, [pc, #584]	; (5650 <grid_port_process_outbound_usb+0x2cc>)
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5408:	a805      	add	r0, sp, #20
    540a:	4798      	blx	r3
	for (uint32_t i=0; i<packet_length; i++){
    540c:	2400      	movs	r4, #0
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    540e:	4605      	mov	r5, r0
	for (uint32_t i=0; i<packet_length; i++){
    5410:	42ac      	cmp	r4, r5
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5412:	4621      	mov	r1, r4
	for (uint32_t i=0; i<packet_length; i++){
    5414:	f040 8104 	bne.w	5620 <grid_port_process_outbound_usb+0x29c>
	cdcdf_acm_write(por->tx_double_buffer, packet_length);
    5418:	4b8e      	ldr	r3, [pc, #568]	; (5654 <grid_port_process_outbound_usb+0x2d0>)
    541a:	f108 002c 	add.w	r0, r8, #44	; 0x2c
    541e:	4798      	blx	r3
}
    5420:	e7bc      	b.n	539c <grid_port_process_outbound_usb+0x18>
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    5422:	4798      	blx	r3
    5424:	4606      	mov	r6, r0
		grid_msg_packet_receive_char(&message, nextchar);
    5426:	4601      	mov	r1, r0
    5428:	a805      	add	r0, sp, #20
    542a:	47c8      	blx	r9
		por->tx_double_buffer[i] = nextchar;	
    542c:	3701      	adds	r7, #1
    542e:	f80a 6b01 	strb.w	r6, [sl], #1
	for (uint16_t i = 0; i<length; i++){
    5432:	4b81      	ldr	r3, [pc, #516]	; (5638 <grid_port_process_outbound_usb+0x2b4>)
    5434:	e7cb      	b.n	53ce <grid_port_process_outbound_usb+0x4a>
		if (message.body[i] == GRID_CONST_STX){
    5436:	aa05      	add	r2, sp, #20
    5438:	4413      	add	r3, r2
    543a:	7d1b      	ldrb	r3, [r3, #20]
    543c:	2b02      	cmp	r3, #2
    543e:	d104      	bne.n	544a <grid_port_process_outbound_usb+0xc6>
			current_start = i;
    5440:	fa5f f68a 	uxtb.w	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    5444:	f10a 0a01 	add.w	sl, sl, #1
    5448:	e7d7      	b.n	53fa <grid_port_process_outbound_usb+0x76>
		else if (message.body[i] == GRID_CONST_ETX && current_start!=0){
    544a:	2b03      	cmp	r3, #3
    544c:	d1fa      	bne.n	5444 <grid_port_process_outbound_usb+0xc0>
    544e:	b90e      	cbnz	r6, 5454 <grid_port_process_outbound_usb+0xd0>
			current_start = 0;
    5450:	2600      	movs	r6, #0
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5452:	e7f7      	b.n	5444 <grid_port_process_outbound_usb+0xc0>
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5454:	4631      	mov	r1, r6
    5456:	2201      	movs	r2, #1
    5458:	a805      	add	r0, sp, #20
    545a:	47a0      	blx	r4
    545c:	4635      	mov	r5, r6
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    545e:	2301      	movs	r3, #1
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5460:	b2c6      	uxtb	r6, r0
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    5462:	2204      	movs	r2, #4
    5464:	4629      	mov	r1, r5
    5466:	a805      	add	r0, sp, #20
    5468:	47a0      	blx	r4
    546a:	b2c0      	uxtb	r0, r0
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    546c:	2e00      	cmp	r6, #0
    546e:	d13f      	bne.n	54f0 <grid_port_process_outbound_usb+0x16c>
    5470:	280e      	cmp	r0, #14
    5472:	d1ed      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_offset,		GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_length);
    5474:	4629      	mov	r1, r5
    5476:	2302      	movs	r3, #2
    5478:	2205      	movs	r2, #5
    547a:	a805      	add	r0, sp, #20
    547c:	47a0      	blx	r4
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    547e:	4629      	mov	r1, r5
    5480:	2302      	movs	r3, #2
    5482:	2207      	movs	r2, #7
    5484:	a805      	add	r0, sp, #20
    5486:	47a0      	blx	r4
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    5488:	4629      	mov	r1, r5
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    548a:	4681      	mov	r9, r0
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    548c:	2302      	movs	r3, #2
    548e:	2209      	movs	r2, #9
    5490:	a805      	add	r0, sp, #20
    5492:	47a0      	blx	r4
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    5494:	4629      	mov	r1, r5
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    5496:	4607      	mov	r7, r0
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    5498:	2302      	movs	r3, #2
    549a:	220b      	movs	r2, #11
    549c:	a805      	add	r0, sp, #20
    549e:	47a0      	blx	r4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54a0:	9901      	ldr	r1, [sp, #4]
    54a2:	4a6d      	ldr	r2, [pc, #436]	; (5658 <grid_port_process_outbound_usb+0x2d4>)
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54a4:	f88d 000f 	strb.w	r0, [sp, #15]
				uint8_t midi_command = 	(midi_commandchannel&0xF0)>>4;
    54a8:	f3c9 1303 	ubfx	r3, r9, #4, #4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54ac:	7bd2      	ldrb	r2, [r2, #15]
				midievent.byte0 = 0<<4|midi_command;
    54ae:	f88d 300c 	strb.w	r3, [sp, #12]
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54b2:	f1c1 0900 	rsb	r9, r1, #0
    54b6:	f009 0903 	and.w	r9, r9, #3
    54ba:	eb09 0982 	add.w	r9, r9, r2, lsl #2
    54be:	f009 090f 	and.w	r9, r9, #15
				midievent.byte1 = midi_command<<4|midi_channel;
    54c2:	ea49 1903 	orr.w	r9, r9, r3, lsl #4
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    54c6:	b2ff      	uxtb	r7, r7
    54c8:	9b00      	ldr	r3, [sp, #0]
				midievent.byte1 = midi_command<<4|midi_channel;
    54ca:	f88d 900d 	strb.w	r9, [sp, #13]
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    54ce:	37e0      	adds	r7, #224	; 0xe0
    54d0:	2260      	movs	r2, #96	; 0x60
    54d2:	eb07 1703 	add.w	r7, r7, r3, lsl #4
    54d6:	fb97 f3f2 	sdiv	r3, r7, r2
    54da:	fb02 7713 	mls	r7, r2, r3, r7
    54de:	f88d 700e 	strb.w	r7, [sp, #14]
				grid_midi_tx_push(midievent);
    54e2:	9803      	ldr	r0, [sp, #12]
    54e4:	4b5d      	ldr	r3, [pc, #372]	; (565c <grid_port_process_outbound_usb+0x2d8>)
    54e6:	4798      	blx	r3
				grid_midi_tx_pop(midievent);				
    54e8:	9803      	ldr	r0, [sp, #12]
    54ea:	4b5d      	ldr	r3, [pc, #372]	; (5660 <grid_port_process_outbound_usb+0x2dc>)
    54ec:	4798      	blx	r3
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54ee:	e7a9      	b.n	5444 <grid_port_process_outbound_usb+0xc0>
			else if (msg_class == GRID_CLASS_MIDIABSOLUTE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54f0:	2e01      	cmp	r6, #1
    54f2:	d127      	bne.n	5544 <grid_port_process_outbound_usb+0x1c0>
    54f4:	280e      	cmp	r0, #14
    54f6:	d1ab      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    54f8:	4629      	mov	r1, r5
    54fa:	2302      	movs	r3, #2
    54fc:	2205      	movs	r2, #5
    54fe:	a805      	add	r0, sp, #20
    5500:	47a0      	blx	r4
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5502:	4629      	mov	r1, r5
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5504:	4681      	mov	r9, r0
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5506:	2302      	movs	r3, #2
    5508:	2207      	movs	r2, #7
    550a:	a805      	add	r0, sp, #20
    550c:	47a0      	blx	r4
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    550e:	4629      	mov	r1, r5
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5510:	4607      	mov	r7, r0
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5512:	2302      	movs	r3, #2
    5514:	2209      	movs	r2, #9
    5516:	a805      	add	r0, sp, #20
    5518:	47a0      	blx	r4
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    551a:	220b      	movs	r2, #11
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    551c:	4606      	mov	r6, r0
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    551e:	4629      	mov	r1, r5
    5520:	2302      	movs	r3, #2
    5522:	a805      	add	r0, sp, #20
    5524:	47a0      	blx	r4
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5526:	f88d 900c 	strb.w	r9, [sp, #12]
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    552a:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    552e:	f88d 600e 	strb.w	r6, [sp, #14]
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5532:	f88d 000f 	strb.w	r0, [sp, #15]
				grid_midi_tx_push(midievent);
    5536:	9803      	ldr	r0, [sp, #12]
    5538:	4b48      	ldr	r3, [pc, #288]	; (565c <grid_port_process_outbound_usb+0x2d8>)
    553a:	4798      	blx	r3
				grid_midi_tx_pop(midievent);	
    553c:	9803      	ldr	r0, [sp, #12]
    553e:	4b48      	ldr	r3, [pc, #288]	; (5660 <grid_port_process_outbound_usb+0x2dc>)
    5540:	4798      	blx	r3
    5542:	e785      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5544:	2e90      	cmp	r6, #144	; 0x90
    5546:	d11d      	bne.n	5584 <grid_port_process_outbound_usb+0x200>
    5548:	280e      	cmp	r0, #14
    554a:	d181      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    554c:	4629      	mov	r1, r5
    554e:	2302      	movs	r3, #2
    5550:	2205      	movs	r2, #5
    5552:	a805      	add	r0, sp, #20
    5554:	47a0      	blx	r4
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    5556:	4629      	mov	r1, r5
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5558:	4607      	mov	r7, r0
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    555a:	2302      	movs	r3, #2
    555c:	2207      	movs	r2, #7
    555e:	a805      	add	r0, sp, #20
    5560:	47a0      	blx	r4
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5562:	4629      	mov	r1, r5
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    5564:	4606      	mov	r6, r0
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5566:	2302      	movs	r3, #2
    5568:	2209      	movs	r2, #9
    556a:	a805      	add	r0, sp, #20
    556c:	47a0      	blx	r4
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    556e:	4b3d      	ldr	r3, [pc, #244]	; (5664 <grid_port_process_outbound_usb+0x2e0>)
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5570:	f88d 000e 	strb.w	r0, [sp, #14]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    5574:	a903      	add	r1, sp, #12
    5576:	483c      	ldr	r0, [pc, #240]	; (5668 <grid_port_process_outbound_usb+0x2e4>)
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5578:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    557c:	f88d 600c 	strb.w	r6, [sp, #12]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    5580:	4798      	blx	r3
    5582:	e765      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYMACRO_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5584:	2e91      	cmp	r6, #145	; 0x91
    5586:	f47f af63 	bne.w	5450 <grid_port_process_outbound_usb+0xcc>
    558a:	280e      	cmp	r0, #14
    558c:	f47f af60 	bne.w	5450 <grid_port_process_outbound_usb+0xcc>
    5590:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5592:	2302      	movs	r3, #2
    5594:	4632      	mov	r2, r6
    5596:	4629      	mov	r1, r5
    5598:	a805      	add	r0, sp, #20
    559a:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    559c:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    559e:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55a0:	2302      	movs	r3, #2
    55a2:	b2d2      	uxtb	r2, r2
    55a4:	4629      	mov	r1, r5
    55a6:	a805      	add	r0, sp, #20
    55a8:	47a0      	blx	r4
    55aa:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55ac:	28ff      	cmp	r0, #255	; 0xff
    55ae:	d00d      	beq.n	55cc <grid_port_process_outbound_usb+0x248>
                        key.ispressed = 1;
    55b0:	2201      	movs	r2, #1
    55b2:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    55b6:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    55b8:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55ba:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    55be:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    55c2:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    55c4:	e893 0003 	ldmia.w	r3, {r0, r1}
    55c8:	4b28      	ldr	r3, [pc, #160]	; (566c <grid_port_process_outbound_usb+0x2e8>)
    55ca:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    55cc:	3604      	adds	r6, #4
    55ce:	b2f6      	uxtb	r6, r6
    55d0:	2e1d      	cmp	r6, #29
    55d2:	d1de      	bne.n	5592 <grid_port_process_outbound_usb+0x20e>
                delay_ms(5);
    55d4:	4b26      	ldr	r3, [pc, #152]	; (5670 <grid_port_process_outbound_usb+0x2ec>)
    55d6:	2005      	movs	r0, #5
    55d8:	4798      	blx	r3
    55da:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55dc:	2302      	movs	r3, #2
    55de:	4632      	mov	r2, r6
    55e0:	4629      	mov	r1, r5
    55e2:	a805      	add	r0, sp, #20
    55e4:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e6:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55e8:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55ea:	2302      	movs	r3, #2
    55ec:	b2d2      	uxtb	r2, r2
    55ee:	4629      	mov	r1, r5
    55f0:	a805      	add	r0, sp, #20
    55f2:	47a0      	blx	r4
    55f4:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55f6:	28ff      	cmp	r0, #255	; 0xff
    55f8:	d00d      	beq.n	5616 <grid_port_process_outbound_usb+0x292>
                        key.ispressed = 0;
    55fa:	2200      	movs	r2, #0
    55fc:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    5600:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    5602:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5604:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5608:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    560c:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    560e:	e893 0003 	ldmia.w	r3, {r0, r1}
    5612:	4b16      	ldr	r3, [pc, #88]	; (566c <grid_port_process_outbound_usb+0x2e8>)
    5614:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    5616:	3604      	adds	r6, #4
    5618:	b2f6      	uxtb	r6, r6
    561a:	2e1d      	cmp	r6, #29
    561c:	d1de      	bne.n	55dc <grid_port_process_outbound_usb+0x258>
    561e:	e717      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5620:	a805      	add	r0, sp, #20
    5622:	47b0      	blx	r6
	for (uint32_t i=0; i<packet_length; i++){
    5624:	3401      	adds	r4, #1
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5626:	f80b 0b01 	strb.w	r0, [fp], #1
	for (uint32_t i=0; i<packet_length; i++){
    562a:	e6f1      	b.n	5410 <grid_port_process_outbound_usb+0x8c>
    562c:	00004ebd 	.word	0x00004ebd
    5630:	0000896d 	.word	0x0000896d
    5634:	00004f13 	.word	0x00004f13
    5638:	00004f7b 	.word	0x00004f7b
    563c:	00004fa5 	.word	0x00004fa5
    5640:	00008935 	.word	0x00008935
    5644:	00008829 	.word	0x00008829
    5648:	00008869 	.word	0x00008869
    564c:	000088c9 	.word	0x000088c9
    5650:	00008a63 	.word	0x00008a63
    5654:	0000c141 	.word	0x0000c141
    5658:	2000f008 	.word	0x2000f008
    565c:	0000b2c9 	.word	0x0000b2c9
    5660:	0000b2f1 	.word	0x0000b2f1
    5664:	0000b101 	.word	0x0000b101
    5668:	20010264 	.word	0x20010264
    566c:	0000b3d9 	.word	0x0000b3d9
    5670:	0000e17d 	.word	0x0000e17d
    5674:	00008a15 	.word	0x00008a15

00005678 <grid_port_process_outbound_ui>:

uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    5678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    567c:	ed2d 8b02 	vpush	{d8}
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5680:	f500 541c 	add.w	r4, r0, #9984	; 0x2700
    5684:	343c      	adds	r4, #60	; 0x3c
uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    5686:	f5ad 7d7b 	sub.w	sp, sp, #1004	; 0x3ec
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    568a:	4bb5      	ldr	r3, [pc, #724]	; (5960 <grid_port_process_outbound_ui+0x2e8>)
    568c:	4620      	mov	r0, r4
    568e:	4798      	blx	r3
	
	if (!length){
    5690:	2500      	movs	r5, #0
    5692:	9006      	str	r0, [sp, #24]
    5694:	b928      	cbnz	r0, 56a2 <grid_port_process_outbound_ui+0x2a>

		
	}
	
	
}
    5696:	f50d 7d7b 	add.w	sp, sp, #1004	; 0x3ec
    569a:	ecbd 8b02 	vpop	{d8}
    569e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56a2:	4bb0      	ldr	r3, [pc, #704]	; (5964 <grid_port_process_outbound_ui+0x2ec>)
    56a4:	952f      	str	r5, [sp, #188]	; 0xbc
    56a6:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    56aa:	4629      	mov	r1, r5
    56ac:	a830      	add	r0, sp, #192	; 0xc0
    56ae:	4798      	blx	r3
		grid_buffer_read_init(&por->tx_buffer);
    56b0:	4bad      	ldr	r3, [pc, #692]	; (5968 <grid_port_process_outbound_ui+0x2f0>)
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56b2:	4fae      	ldr	r7, [pc, #696]	; (596c <grid_port_process_outbound_ui+0x2f4>)
		grid_buffer_read_init(&por->tx_buffer);
    56b4:	4620      	mov	r0, r4
    56b6:	4798      	blx	r3
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56b8:	ae2f      	add	r6, sp, #188	; 0xbc
		for (uint16_t i = 0; i<length; i++){
    56ba:	9a06      	ldr	r2, [sp, #24]
    56bc:	b2ab      	uxth	r3, r5
    56be:	429a      	cmp	r2, r3
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56c0:	4620      	mov	r0, r4
		for (uint16_t i = 0; i<length; i++){
    56c2:	d839      	bhi.n	5738 <grid_port_process_outbound_ui+0xc0>
		grid_buffer_read_acknowledge(&por->tx_buffer);
    56c4:	4baa      	ldr	r3, [pc, #680]	; (5970 <grid_port_process_outbound_ui+0x2f8>)
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56c6:	4fab      	ldr	r7, [pc, #684]	; (5974 <grid_port_process_outbound_ui+0x2fc>)
		grid_buffer_read_acknowledge(&por->tx_buffer);
    56c8:	4798      	blx	r3
		uint8_t error=0;
    56ca:	2500      	movs	r5, #0
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56cc:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    56d0:	2202      	movs	r2, #2
    56d2:	2106      	movs	r1, #6
    56d4:	4630      	mov	r0, r6
		uint8_t error=0;
    56d6:	f88d 5026 	strb.w	r5, [sp, #38]	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56da:	47b8      	blx	r7
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56dc:	f10d 0326 	add.w	r3, sp, #38	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56e0:	fa5f fb80 	uxtb.w	fp, r0
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56e4:	2202      	movs	r2, #2
    56e6:	2108      	movs	r1, #8
    56e8:	4630      	mov	r0, r6
    56ea:	47b8      	blx	r7
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    56ec:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56f0:	b2c0      	uxtb	r0, r0
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    56f2:	d125      	bne.n	5740 <grid_port_process_outbound_ui+0xc8>
			position_is_me = 1;
    56f4:	f1a0 027f 	sub.w	r2, r0, #127	; 0x7f
    56f8:	f1d2 0b00 	rsbs	fp, r2, #0
    56fc:	eb4b 0b02 	adc.w	fp, fp, r2
		uint8_t position_is_local = 0;
    5700:	462c      	mov	r4, r5
		uint8_t position_is_global = 0;
    5702:	9502      	str	r5, [sp, #8]
		uint8_t error_flag = 0;	
    5704:	2300      	movs	r3, #0
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    5706:	4d9c      	ldr	r5, [pc, #624]	; (5978 <grid_port_process_outbound_ui+0x300>)
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5708:	f8df a298 	ldr.w	sl, [pc, #664]	; 59a4 <grid_port_process_outbound_ui+0x32c>
		uint8_t error_flag = 0;	
    570c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5710:	9303      	str	r3, [sp, #12]
		uint8_t current_start		= 0;
    5712:	4698      	mov	r8, r3
			if (message[i] == GRID_CONST_STX){
    5714:	9b03      	ldr	r3, [sp, #12]
    5716:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
    571a:	f813 1009 	ldrb.w	r1, [r3, r9]
    571e:	2902      	cmp	r1, #2
    5720:	d120      	bne.n	5764 <grid_port_process_outbound_ui+0xec>
				current_start = i;
    5722:	f89d 800c 	ldrb.w	r8, [sp, #12]
		for (uint16_t i=0; i<length; i++){
    5726:	9b03      	ldr	r3, [sp, #12]
    5728:	9a06      	ldr	r2, [sp, #24]
    572a:	3301      	adds	r3, #1
    572c:	9303      	str	r3, [sp, #12]
    572e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    5732:	429a      	cmp	r2, r3
    5734:	d8ee      	bhi.n	5714 <grid_port_process_outbound_ui+0x9c>
    5736:	e7ae      	b.n	5696 <grid_port_process_outbound_ui+0x1e>
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5738:	47b8      	blx	r7
    573a:	5570      	strb	r0, [r6, r5]
		for (uint16_t i = 0; i<length; i++){
    573c:	3501      	adds	r5, #1
    573e:	e7bc      	b.n	56ba <grid_port_process_outbound_ui+0x42>
		else if (dx == GRID_SYS_GLOBAL_POSITION && dy==GRID_SYS_GLOBAL_POSITION){
    5740:	f1bb 0f00 	cmp.w	fp, #0
    5744:	d105      	bne.n	5752 <grid_port_process_outbound_ui+0xda>
		uint8_t position_is_global = 0;
    5746:	fab0 f380 	clz	r3, r0
    574a:	095b      	lsrs	r3, r3, #5
    574c:	9302      	str	r3, [sp, #8]
		uint8_t position_is_local = 0;
    574e:	465c      	mov	r4, fp
    5750:	e7d8      	b.n	5704 <grid_port_process_outbound_ui+0x8c>
		else if (dx == GRID_SYS_LOCAL_POSITION && dy==GRID_SYS_LOCAL_POSITION){
    5752:	ea0b 0000 	and.w	r0, fp, r0
    5756:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    575a:	425c      	negs	r4, r3
    575c:	415c      	adcs	r4, r3
		uint8_t position_is_global = 0;
    575e:	46ab      	mov	fp, r5
		uint8_t position_is_me = 0;
    5760:	9502      	str	r5, [sp, #8]
    5762:	e7cf      	b.n	5704 <grid_port_process_outbound_ui+0x8c>
			else if (message[i] == GRID_CONST_ETX && current_start!=0){
    5764:	2903      	cmp	r1, #3
    5766:	d1de      	bne.n	5726 <grid_port_process_outbound_ui+0xae>
    5768:	f1b8 0f00 	cmp.w	r8, #0
    576c:	d102      	bne.n	5774 <grid_port_process_outbound_ui+0xfc>
				current_start = 0;
    576e:	f04f 0800 	mov.w	r8, #0
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    5772:	e7d8      	b.n	5726 <grid_port_process_outbound_ui+0xae>
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    5774:	f108 0001 	add.w	r0, r8, #1
    5778:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    577c:	4448      	add	r0, r9
    577e:	47a8      	blx	r5
    5780:	b2c6      	uxtb	r6, r0
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    5782:	f108 0004 	add.w	r0, r8, #4
    5786:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    578a:	2101      	movs	r1, #1
    578c:	4448      	add	r0, r9
    578e:	47a8      	blx	r5
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    5790:	2e30      	cmp	r6, #48	; 0x30
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    5792:	b2c7      	uxtb	r7, r0
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    5794:	d126      	bne.n	57e4 <grid_port_process_outbound_ui+0x16c>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    5796:	f108 0005 	add.w	r0, r8, #5
    579a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    579e:	2102      	movs	r1, #2
    57a0:	4448      	add	r0, r9
    57a2:	47a8      	blx	r5
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57a4:	2f0e      	cmp	r7, #14
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57a6:	4606      	mov	r6, r0
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57a8:	d10e      	bne.n	57c8 <grid_port_process_outbound_ui+0x150>
						if (grid_sys_get_bank_valid(&grid_sys_state) == 0){
    57aa:	4874      	ldr	r0, [pc, #464]	; (597c <grid_port_process_outbound_ui+0x304>)
    57ac:	4b74      	ldr	r3, [pc, #464]	; (5980 <grid_port_process_outbound_ui+0x308>)
    57ae:	4798      	blx	r3
    57b0:	4602      	mov	r2, r0
    57b2:	b920      	cbnz	r0, 57be <grid_port_process_outbound_ui+0x146>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
    57b4:	4601      	mov	r1, r0
    57b6:	4f73      	ldr	r7, [pc, #460]	; (5984 <grid_port_process_outbound_ui+0x30c>)
    57b8:	4873      	ldr	r0, [pc, #460]	; (5988 <grid_port_process_outbound_ui+0x310>)
    57ba:	230c      	movs	r3, #12
    57bc:	47b8      	blx	r7
						grid_sys_set_bank(&grid_sys_state, banknumber);
    57be:	486f      	ldr	r0, [pc, #444]	; (597c <grid_port_process_outbound_ui+0x304>)
    57c0:	b2f1      	uxtb	r1, r6
								grid_sys_set_bank(&grid_sys_state, banknumber);
    57c2:	4b72      	ldr	r3, [pc, #456]	; (598c <grid_port_process_outbound_ui+0x314>)
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    57c4:	4798      	blx	r3
    57c6:	e7d2      	b.n	576e <grid_port_process_outbound_ui+0xf6>
					else if (msg_instr == GRID_INSTR_FETCH_code){ //GET BANK
    57c8:	2f0f      	cmp	r7, #15
    57ca:	d1d0      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_valid(&grid_sys_state) != 0){
    57cc:	486b      	ldr	r0, [pc, #428]	; (597c <grid_port_process_outbound_ui+0x304>)
    57ce:	4b6c      	ldr	r3, [pc, #432]	; (5980 <grid_port_process_outbound_ui+0x308>)
    57d0:	4798      	blx	r3
    57d2:	2800      	cmp	r0, #0
    57d4:	d0cb      	beq.n	576e <grid_port_process_outbound_ui+0xf6>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
    57d6:	2200      	movs	r2, #0
    57d8:	486b      	ldr	r0, [pc, #428]	; (5988 <grid_port_process_outbound_ui+0x310>)
    57da:	4e6a      	ldr	r6, [pc, #424]	; (5984 <grid_port_process_outbound_ui+0x30c>)
    57dc:	2309      	movs	r3, #9
    57de:	4611      	mov	r1, r2
    57e0:	47b0      	blx	r6
    57e2:	e7c4      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_BANKENABLED_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    57e4:	2e31      	cmp	r6, #49	; 0x31
    57e6:	d140      	bne.n	586a <grid_port_process_outbound_ui+0x1f2>
    57e8:	2f0e      	cmp	r7, #14
    57ea:	d1c0      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
    57ec:	9b02      	ldr	r3, [sp, #8]
    57ee:	ea4b 0303 	orr.w	r3, fp, r3
    57f2:	4323      	orrs	r3, r4
    57f4:	d0bb      	beq.n	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_BANKNUMBER_offset], GRID_CLASS_BANKENABLED_BANKNUMBER_length, &error_flag);
    57f6:	f108 0005 	add.w	r0, r8, #5
    57fa:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57fe:	2102      	movs	r1, #2
    5800:	4448      	add	r0, r9
    5802:	47a8      	blx	r5
    5804:	b2c6      	uxtb	r6, r0
					uint8_t isenabled  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_ISENABLED_offset], GRID_CLASS_BANKENABLED_ISENABLED_length, &error_flag);
    5806:	f108 0007 	add.w	r0, r8, #7
    580a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    580e:	2102      	movs	r1, #2
    5810:	4448      	add	r0, r9
    5812:	47a8      	blx	r5
    5814:	fa5f f880 	uxtb.w	r8, r0
					if (isenabled == 1){
    5818:	f1b8 0f01 	cmp.w	r8, #1
    581c:	d110      	bne.n	5840 <grid_port_process_outbound_ui+0x1c8>
						grid_sys_bank_enable(&grid_sys_state, banknumber);
    581e:	4f57      	ldr	r7, [pc, #348]	; (597c <grid_port_process_outbound_ui+0x304>)
    5820:	4b5b      	ldr	r3, [pc, #364]	; (5990 <grid_port_process_outbound_ui+0x318>)
    5822:	4631      	mov	r1, r6
    5824:	4638      	mov	r0, r7
    5826:	4798      	blx	r3
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5828:	4b5a      	ldr	r3, [pc, #360]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    582a:	4638      	mov	r0, r7
    582c:	4798      	blx	r3
    582e:	42b0      	cmp	r0, r6
    5830:	d19d      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
							if (grid_sys_state.bank_activebank_valid == 1){
    5832:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5836:	2b01      	cmp	r3, #1
    5838:	d199      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
								grid_sys_set_bank(&grid_sys_state, banknumber);
    583a:	4631      	mov	r1, r6
    583c:	4638      	mov	r0, r7
    583e:	e7c0      	b.n	57c2 <grid_port_process_outbound_ui+0x14a>
					}else if (isenabled == 0){	
    5840:	f1b8 0f00 	cmp.w	r8, #0
    5844:	d193      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5846:	484d      	ldr	r0, [pc, #308]	; (597c <grid_port_process_outbound_ui+0x304>)
    5848:	4b52      	ldr	r3, [pc, #328]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    584a:	4798      	blx	r3
    584c:	42b0      	cmp	r0, r6
    584e:	d107      	bne.n	5860 <grid_port_process_outbound_ui+0x1e8>
							if (grid_sys_state.bank_activebank_valid == 1){
    5850:	484a      	ldr	r0, [pc, #296]	; (597c <grid_port_process_outbound_ui+0x304>)
    5852:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    5856:	2b01      	cmp	r3, #1
    5858:	d102      	bne.n	5860 <grid_port_process_outbound_ui+0x1e8>
								grid_sys_set_bank(&grid_sys_state, 255);
    585a:	4b4c      	ldr	r3, [pc, #304]	; (598c <grid_port_process_outbound_ui+0x314>)
    585c:	21ff      	movs	r1, #255	; 0xff
    585e:	4798      	blx	r3
						grid_sys_bank_disable(&grid_sys_state, banknumber);
    5860:	4b4d      	ldr	r3, [pc, #308]	; (5998 <grid_port_process_outbound_ui+0x320>)
    5862:	4846      	ldr	r0, [pc, #280]	; (597c <grid_port_process_outbound_ui+0x304>)
    5864:	4631      	mov	r1, r6
    5866:	4798      	blx	r3
    5868:	e75d      	b.n	5726 <grid_port_process_outbound_ui+0xae>
				else if (msg_class == GRID_CLASS_BANKCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    586a:	2e32      	cmp	r6, #50	; 0x32
    586c:	d147      	bne.n	58fe <grid_port_process_outbound_ui+0x286>
    586e:	2f0e      	cmp	r7, #14
    5870:	f47f af7d 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5874:	9b02      	ldr	r3, [sp, #8]
    5876:	ea4b 0303 	orr.w	r3, fp, r3
    587a:	4323      	orrs	r3, r4
    587c:	f43f af77 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    5880:	f108 0005 	add.w	r0, r8, #5
    5884:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5888:	2102      	movs	r1, #2
    588a:	4448      	add	r0, r9
    588c:	47a8      	blx	r5
    588e:	b2c3      	uxtb	r3, r0
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    5890:	f108 0007 	add.w	r0, r8, #7
    5894:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5898:	2102      	movs	r1, #2
    589a:	4448      	add	r0, r9
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    589c:	ee08 3a10 	vmov	s16, r3
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58a0:	47a8      	blx	r5
    58a2:	4606      	mov	r6, r0
					uint8_t green	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_GRE_offset], GRID_CLASS_BANKCOLOR_GRE_length, &error_flag);
    58a4:	f108 0009 	add.w	r0, r8, #9
    58a8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58ac:	2102      	movs	r1, #2
    58ae:	4448      	add	r0, r9
    58b0:	47a8      	blx	r5
    58b2:	4607      	mov	r7, r0
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58b4:	f108 000b 	add.w	r0, r8, #11
    58b8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58bc:	2102      	movs	r1, #2
    58be:	4448      	add	r0, r9
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    58c0:	0436      	lsls	r6, r6, #16
    58c2:	023f      	lsls	r7, r7, #8
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58c4:	47a8      	blx	r5
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    58c6:	b2bf      	uxth	r7, r7
    58c8:	f406 067f 	and.w	r6, r6, #16711680	; 0xff0000
    58cc:	433e      	orrs	r6, r7
    58ce:	4f2b      	ldr	r7, [pc, #172]	; (597c <grid_port_process_outbound_ui+0x304>)
    58d0:	4b32      	ldr	r3, [pc, #200]	; (599c <grid_port_process_outbound_ui+0x324>)
    58d2:	fa56 f280 	uxtab	r2, r6, r0
    58d6:	ee18 1a10 	vmov	r1, s16
    58da:	4638      	mov	r0, r7
    58dc:	4798      	blx	r3
					if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    58de:	4b2d      	ldr	r3, [pc, #180]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    58e0:	4638      	mov	r0, r7
    58e2:	4798      	blx	r3
    58e4:	ee18 3a10 	vmov	r3, s16
    58e8:	4298      	cmp	r0, r3
    58ea:	f47f af40 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_state.bank_activebank_valid == 1){
    58ee:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    58f2:	2b01      	cmp	r3, #1
    58f4:	f47f af3b 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
							grid_sys_set_bank(&grid_sys_state, banknumber);
    58f8:	ee18 1a10 	vmov	r1, s16
    58fc:	e79e      	b.n	583c <grid_port_process_outbound_ui+0x1c4>
				else if (msg_class == GRID_CLASS_LEDPHASE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    58fe:	2e40      	cmp	r6, #64	; 0x40
    5900:	d154      	bne.n	59ac <grid_port_process_outbound_ui+0x334>
    5902:	2f0e      	cmp	r7, #14
    5904:	f47f af33 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5908:	ea5b 0304 	orrs.w	r3, fp, r4
    590c:	f43f af2f 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_NUM_offset], GRID_CLASS_LEDPHASE_NUM_length, &error_flag);
    5910:	f108 0005 	add.w	r0, r8, #5
    5914:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5918:	2102      	movs	r1, #2
    591a:	4448      	add	r0, r9
    591c:	47a8      	blx	r5
    591e:	b2c6      	uxtb	r6, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_LAY_offset], GRID_CLASS_LEDPHASE_LAY_length, &error_flag);
    5920:	f108 0007 	add.w	r0, r8, #7
    5924:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5928:	2102      	movs	r1, #2
    592a:	4448      	add	r0, r9
    592c:	47a8      	blx	r5
    592e:	b2c7      	uxtb	r7, r0
					uint16_t led_pha  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_PHA_offset], GRID_CLASS_LEDPHASE_PHA_length, &error_flag);
    5930:	f108 0009 	add.w	r0, r8, #9
    5934:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5938:	2102      	movs	r1, #2
    593a:	4448      	add	r0, r9
    593c:	47a8      	blx	r5
					if (led_pha*2 > 255){
    593e:	b283      	uxth	r3, r0
    5940:	005b      	lsls	r3, r3, #1
    5942:	2bff      	cmp	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    5944:	bfdc      	itt	le
    5946:	0040      	lslle	r0, r0, #1
    5948:	f000 03fe 	andle.w	r3, r0, #254	; 0xfe
    594c:	f8df 8058 	ldr.w	r8, [pc, #88]	; 59a8 <grid_port_process_outbound_ui+0x330>
    5950:	4813      	ldr	r0, [pc, #76]	; (59a0 <grid_port_process_outbound_ui+0x328>)
						grid_led_set_phase(&grid_led_state, led_num, led_lay, 255);
    5952:	bfc8      	it	gt
    5954:	23ff      	movgt	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    5956:	463a      	mov	r2, r7
    5958:	4631      	mov	r1, r6
    595a:	47c0      	blx	r8
    595c:	e707      	b.n	576e <grid_port_process_outbound_ui+0xf6>
    595e:	bf00      	nop
    5960:	00004ebd 	.word	0x00004ebd
    5964:	000147c5 	.word	0x000147c5
    5968:	00004f13 	.word	0x00004f13
    596c:	00004f7b 	.word	0x00004f7b
    5970:	00004fa5 	.word	0x00004fa5
    5974:	00009dbd 	.word	0x00009dbd
    5978:	00009c09 	.word	0x00009c09
    597c:	2000f008 	.word	0x2000f008
    5980:	00009ab3 	.word	0x00009ab3
    5984:	0000a539 	.word	0x0000a539
    5988:	2001c7c0 	.word	0x2001c7c0
    598c:	00009b0b 	.word	0x00009b0b
    5990:	00009a81 	.word	0x00009a81
    5994:	00009aaf 	.word	0x00009aaf
    5998:	00009a8d 	.word	0x00009a8d
    599c:	00009a99 	.word	0x00009a99
    59a0:	2001c838 	.word	0x2001c838
    59a4:	2000effc 	.word	0x2000effc
    59a8:	00007139 	.word	0x00007139
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    59ac:	2e41      	cmp	r6, #65	; 0x41
    59ae:	d13a      	bne.n	5a26 <grid_port_process_outbound_ui+0x3ae>
    59b0:	2f0e      	cmp	r7, #14
    59b2:	f47f aedc 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    59b6:	ea5b 0304 	orrs.w	r3, fp, r4
    59ba:	f43f aed8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_NUM_offset], GRID_CLASS_LEDCOLOR_NUM_length, &error_flag);
    59be:	f108 0005 	add.w	r0, r8, #5
    59c2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59c6:	2102      	movs	r1, #2
    59c8:	4448      	add	r0, r9
    59ca:	47a8      	blx	r5
    59cc:	4607      	mov	r7, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_LAY_offset], GRID_CLASS_LEDCOLOR_LAY_length, &error_flag);
    59ce:	f108 0007 	add.w	r0, r8, #7
    59d2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59d6:	2102      	movs	r1, #2
    59d8:	4448      	add	r0, r9
    59da:	47a8      	blx	r5
    59dc:	9004      	str	r0, [sp, #16]
					uint8_t led_red	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_RED_offset], GRID_CLASS_LEDCOLOR_RED_length, &error_flag);
    59de:	f108 0009 	add.w	r0, r8, #9
    59e2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59e6:	2102      	movs	r1, #2
    59e8:	4448      	add	r0, r9
    59ea:	47a8      	blx	r5
    59ec:	9005      	str	r0, [sp, #20]
					uint8_t led_gre	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_GRE_offset], GRID_CLASS_LEDCOLOR_GRE_length, &error_flag);
    59ee:	f108 000b 	add.w	r0, r8, #11
    59f2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59f6:	2102      	movs	r1, #2
    59f8:	4448      	add	r0, r9
    59fa:	47a8      	blx	r5
    59fc:	4606      	mov	r6, r0
					uint8_t led_blu	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_BLU_offset], GRID_CLASS_LEDCOLOR_BLU_length, &error_flag);
    59fe:	f108 000d 	add.w	r0, r8, #13
    5a02:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a06:	2102      	movs	r1, #2
    5a08:	4448      	add	r0, r9
    5a0a:	47a8      	blx	r5
					grid_led_set_color(&grid_led_state, led_num, led_lay, led_red, led_gre, led_blu);
    5a0c:	9b05      	ldr	r3, [sp, #20]
    5a0e:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5a12:	b2c0      	uxtb	r0, r0
    5a14:	b2f6      	uxtb	r6, r6
    5a16:	9001      	str	r0, [sp, #4]
    5a18:	9600      	str	r6, [sp, #0]
    5a1a:	48a9      	ldr	r0, [pc, #676]	; (5cc0 <grid_port_process_outbound_ui+0x648>)
    5a1c:	4ea9      	ldr	r6, [pc, #676]	; (5cc4 <grid_port_process_outbound_ui+0x64c>)
    5a1e:	b2db      	uxtb	r3, r3
    5a20:	b2f9      	uxtb	r1, r7
    5a22:	47b0      	blx	r6
    5a24:	e6a3      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if(msg_class == GRID_CLASS_SERIALNUMBER_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5a26:	2e11      	cmp	r6, #17
    5a28:	d15d      	bne.n	5ae6 <grid_port_process_outbound_ui+0x46e>
    5a2a:	2f0f      	cmp	r7, #15
    5a2c:	f47f ae9f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5a30:	9b02      	ldr	r3, [sp, #8]
    5a32:	ea5b 0303 	orrs.w	r3, fp, r3
    5a36:	f43f ae9a 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint32_t uniqueid[4] = {0};
    5a3a:	2210      	movs	r2, #16
    5a3c:	2100      	movs	r1, #0
    5a3e:	4fa2      	ldr	r7, [pc, #648]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a40:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 5cf0 <grid_port_process_outbound_ui+0x678>
					uint32_t uniqueid[4] = {0};
    5a44:	a80a      	add	r0, sp, #40	; 0x28
    5a46:	47b8      	blx	r7
					grid_sys_get_id(uniqueid);					
    5a48:	4ba0      	ldr	r3, [pc, #640]	; (5ccc <grid_port_process_outbound_ui+0x654>)
    5a4a:	a80a      	add	r0, sp, #40	; 0x28
    5a4c:	4798      	blx	r3
					grid_msg_init(&response);
    5a4e:	4ba0      	ldr	r3, [pc, #640]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
    5a50:	a893      	add	r0, sp, #588	; 0x24c
    5a52:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a54:	227f      	movs	r2, #127	; 0x7f
    5a56:	2300      	movs	r3, #0
    5a58:	4611      	mov	r1, r2
    5a5a:	a893      	add	r0, sp, #588	; 0x24c
    5a5c:	47c0      	blx	r8
					uint8_t response_payload[50] = {0};
    5a5e:	f04f 0800 	mov.w	r8, #0
    5a62:	222e      	movs	r2, #46	; 0x2e
    5a64:	4641      	mov	r1, r8
    5a66:	a80f      	add	r0, sp, #60	; 0x3c
    5a68:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5a6c:	47b8      	blx	r7
					snprintf(response_payload, 49, GRID_CLASS_SERIALNUMBER_frame);
    5a6e:	2303      	movs	r3, #3
    5a70:	e9cd 6300 	strd	r6, r3, [sp]
    5a74:	4a97      	ldr	r2, [pc, #604]	; (5cd4 <grid_port_process_outbound_ui+0x65c>)
    5a76:	4e98      	ldr	r6, [pc, #608]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
    5a78:	2131      	movs	r1, #49	; 0x31
    5a7a:	2302      	movs	r3, #2
    5a7c:	a80e      	add	r0, sp, #56	; 0x38
    5a7e:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a80:	4b96      	ldr	r3, [pc, #600]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a82:	4e97      	ldr	r6, [pc, #604]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a84:	a80e      	add	r0, sp, #56	; 0x38
    5a86:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a88:	270d      	movs	r7, #13
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a8a:	4602      	mov	r2, r0
    5a8c:	4b95      	ldr	r3, [pc, #596]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5a8e:	a90e      	add	r1, sp, #56	; 0x38
    5a90:	a893      	add	r0, sp, #588	; 0x24c
    5a92:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a94:	2301      	movs	r3, #1
    5a96:	2204      	movs	r2, #4
    5a98:	4641      	mov	r1, r8
    5a9a:	a893      	add	r0, sp, #588	; 0x24c
    5a9c:	9700      	str	r7, [sp, #0]
    5a9e:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD0_offset, GRID_CLASS_SERIALNUMBER_WORD0_length, uniqueid[0]);
    5aa0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5aa2:	9300      	str	r3, [sp, #0]
    5aa4:	2205      	movs	r2, #5
    5aa6:	2308      	movs	r3, #8
    5aa8:	4641      	mov	r1, r8
    5aaa:	a893      	add	r0, sp, #588	; 0x24c
    5aac:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD1_offset, GRID_CLASS_SERIALNUMBER_WORD1_length, uniqueid[1]);
    5aae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5ab0:	9300      	str	r3, [sp, #0]
    5ab2:	463a      	mov	r2, r7
    5ab4:	2308      	movs	r3, #8
    5ab6:	4641      	mov	r1, r8
    5ab8:	a893      	add	r0, sp, #588	; 0x24c
    5aba:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD2_offset, GRID_CLASS_SERIALNUMBER_WORD2_length, uniqueid[2]);
    5abc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5abe:	9300      	str	r3, [sp, #0]
    5ac0:	2215      	movs	r2, #21
    5ac2:	2308      	movs	r3, #8
    5ac4:	4641      	mov	r1, r8
    5ac6:	a893      	add	r0, sp, #588	; 0x24c
    5ac8:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD3_offset, GRID_CLASS_SERIALNUMBER_WORD3_length, uniqueid[3]);
    5aca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5acc:	9300      	str	r3, [sp, #0]
    5ace:	221d      	movs	r2, #29
    5ad0:	2308      	movs	r3, #8
    5ad2:	4641      	mov	r1, r8
    5ad4:	a893      	add	r0, sp, #588	; 0x24c
    5ad6:	47b0      	blx	r6
					grid_msg_packet_close(&response);
    5ad8:	4b83      	ldr	r3, [pc, #524]	; (5ce8 <grid_port_process_outbound_ui+0x670>)
    5ada:	a893      	add	r0, sp, #588	; 0x24c
    5adc:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    5ade:	4b83      	ldr	r3, [pc, #524]	; (5cec <grid_port_process_outbound_ui+0x674>)
    5ae0:	a893      	add	r0, sp, #588	; 0x24c
    5ae2:	4798      	blx	r3
				else if(msg_class == GRID_CLASS_UPTIME_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5ae4:	e61f      	b.n	5726 <grid_port_process_outbound_ui+0xae>
    5ae6:	2e14      	cmp	r6, #20
    5ae8:	d13f      	bne.n	5b6a <grid_port_process_outbound_ui+0x4f2>
    5aea:	2f0f      	cmp	r7, #15
    5aec:	f47f ae3f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5af0:	9b02      	ldr	r3, [sp, #8]
    5af2:	ea5b 0303 	orrs.w	r3, fp, r3
    5af6:	f43f ae3a 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5afa:	4b75      	ldr	r3, [pc, #468]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5afc:	4f7c      	ldr	r7, [pc, #496]	; (5cf0 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5afe:	a893      	add	r0, sp, #588	; 0x24c
    5b00:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b02:	227f      	movs	r2, #127	; 0x7f
					uint8_t response_payload[50] = {0};
    5b04:	f04f 0800 	mov.w	r8, #0
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b08:	4611      	mov	r1, r2
    5b0a:	2300      	movs	r3, #0
    5b0c:	a893      	add	r0, sp, #588	; 0x24c
    5b0e:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b10:	4b6d      	ldr	r3, [pc, #436]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
    5b12:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5b16:	222e      	movs	r2, #46	; 0x2e
    5b18:	4641      	mov	r1, r8
    5b1a:	a80f      	add	r0, sp, #60	; 0x3c
    5b1c:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b1e:	2303      	movs	r3, #3
    5b20:	e9cd 6300 	strd	r6, r3, [sp]
    5b24:	4a73      	ldr	r2, [pc, #460]	; (5cf4 <grid_port_process_outbound_ui+0x67c>)
    5b26:	4e6c      	ldr	r6, [pc, #432]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b28:	4f6d      	ldr	r7, [pc, #436]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b2a:	2131      	movs	r1, #49	; 0x31
    5b2c:	2302      	movs	r3, #2
    5b2e:	a80e      	add	r0, sp, #56	; 0x38
    5b30:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b32:	4b6a      	ldr	r3, [pc, #424]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b34:	4e70      	ldr	r6, [pc, #448]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b36:	a80e      	add	r0, sp, #56	; 0x38
    5b38:	4798      	blx	r3
    5b3a:	4b6a      	ldr	r3, [pc, #424]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5b3c:	4602      	mov	r2, r0
    5b3e:	a90e      	add	r1, sp, #56	; 0x38
    5b40:	a893      	add	r0, sp, #588	; 0x24c
    5b42:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b44:	230d      	movs	r3, #13
    5b46:	9300      	str	r3, [sp, #0]
    5b48:	2204      	movs	r2, #4
    5b4a:	2301      	movs	r3, #1
    5b4c:	4641      	mov	r1, r8
    5b4e:	a893      	add	r0, sp, #588	; 0x24c
    5b50:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b52:	6833      	ldr	r3, [r6, #0]
    5b54:	9300      	str	r3, [sp, #0]
    5b56:	2205      	movs	r2, #5
    5b58:	2308      	movs	r3, #8
    5b5a:	4641      	mov	r1, r8
    5b5c:	a893      	add	r0, sp, #588	; 0x24c
    5b5e:	47b8      	blx	r7
					uint32_t milliseconds = grid_sys_state.uptime/RTC1MS%1000;
    5b60:	6833      	ldr	r3, [r6, #0]
					uint32_t seconds =		grid_sys_state.uptime/RTC1MS/1000%60;
    5b62:	6833      	ldr	r3, [r6, #0]
					uint32_t minutes =		grid_sys_state.uptime/RTC1MS/1000/60%60;
    5b64:	6833      	ldr	r3, [r6, #0]
					uint32_t hours =		grid_sys_state.uptime/RTC1MS/1000/60/60%60;
    5b66:	6833      	ldr	r3, [r6, #0]
    5b68:	e7b6      	b.n	5ad8 <grid_port_process_outbound_ui+0x460>
				else if(msg_class == GRID_CLASS_RESETCAUSE_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5b6a:	2e12      	cmp	r6, #18
    5b6c:	d137      	bne.n	5bde <grid_port_process_outbound_ui+0x566>
    5b6e:	2f0f      	cmp	r7, #15
    5b70:	f47f adfd 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5b74:	9b02      	ldr	r3, [sp, #8]
    5b76:	ea5b 0303 	orrs.w	r3, fp, r3
    5b7a:	f43f adf8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5b7e:	4b54      	ldr	r3, [pc, #336]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b80:	4f5b      	ldr	r7, [pc, #364]	; (5cf0 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5b82:	a893      	add	r0, sp, #588	; 0x24c
    5b84:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b86:	227f      	movs	r2, #127	; 0x7f
    5b88:	4611      	mov	r1, r2
    5b8a:	2300      	movs	r3, #0
    5b8c:	a893      	add	r0, sp, #588	; 0x24c
    5b8e:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b90:	2700      	movs	r7, #0
    5b92:	4b4d      	ldr	r3, [pc, #308]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
    5b94:	970e      	str	r7, [sp, #56]	; 0x38
    5b96:	222e      	movs	r2, #46	; 0x2e
    5b98:	4639      	mov	r1, r7
    5b9a:	a80f      	add	r0, sp, #60	; 0x3c
    5b9c:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_RESETCAUSE_frame);
    5b9e:	2303      	movs	r3, #3
    5ba0:	e9cd 6300 	strd	r6, r3, [sp]
    5ba4:	4a55      	ldr	r2, [pc, #340]	; (5cfc <grid_port_process_outbound_ui+0x684>)
    5ba6:	4e4c      	ldr	r6, [pc, #304]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
    5ba8:	2131      	movs	r1, #49	; 0x31
    5baa:	2302      	movs	r3, #2
    5bac:	a80e      	add	r0, sp, #56	; 0x38
    5bae:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bb0:	4b4a      	ldr	r3, [pc, #296]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bb2:	4e4b      	ldr	r6, [pc, #300]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bb4:	a80e      	add	r0, sp, #56	; 0x38
    5bb6:	4798      	blx	r3
    5bb8:	4b4a      	ldr	r3, [pc, #296]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5bba:	4602      	mov	r2, r0
    5bbc:	a90e      	add	r1, sp, #56	; 0x38
    5bbe:	a893      	add	r0, sp, #588	; 0x24c
    5bc0:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bc2:	230d      	movs	r3, #13
    5bc4:	9300      	str	r3, [sp, #0]
    5bc6:	2204      	movs	r2, #4
    5bc8:	2301      	movs	r3, #1
    5bca:	4639      	mov	r1, r7
    5bcc:	a893      	add	r0, sp, #588	; 0x24c
    5bce:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_RESETCAUSE_CAUSE_offset, GRID_CLASS_RESETCAUSE_CAUSE_length,grid_sys_state.reset_cause);
    5bd0:	4b49      	ldr	r3, [pc, #292]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5bd2:	791b      	ldrb	r3, [r3, #4]
    5bd4:	9300      	str	r3, [sp, #0]
    5bd6:	2205      	movs	r2, #5
    5bd8:	2302      	movs	r3, #2
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5bda:	4639      	mov	r1, r7
    5bdc:	e26e      	b.n	60bc <grid_port_process_outbound_ui+0xa44>
				else if(msg_class == GRID_CLASS_RESET_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me)){
    5bde:	2e13      	cmp	r6, #19
    5be0:	d113      	bne.n	5c0a <grid_port_process_outbound_ui+0x592>
    5be2:	2f0e      	cmp	r7, #14
    5be4:	f47f adc3 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5be8:	f1bb 0f00 	cmp.w	fp, #0
    5bec:	f43f adbf 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5bf0:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5bf4:	4942      	ldr	r1, [pc, #264]	; (5d00 <grid_port_process_outbound_ui+0x688>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5bf6:	4b43      	ldr	r3, [pc, #268]	; (5d04 <grid_port_process_outbound_ui+0x68c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5bf8:	68ca      	ldr	r2, [r1, #12]
    5bfa:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5bfe:	4313      	orrs	r3, r2
    5c00:	60cb      	str	r3, [r1, #12]
    5c02:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    5c06:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    5c08:	e7fd      	b.n	5c06 <grid_port_process_outbound_ui+0x58e>
				else if (msg_class == GRID_CLASS_GLOBALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c0a:	2e61      	cmp	r6, #97	; 0x61
    5c0c:	d10c      	bne.n	5c28 <grid_port_process_outbound_ui+0x5b0>
    5c0e:	2f0e      	cmp	r7, #14
    5c10:	f47f adad 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c14:	9b02      	ldr	r3, [sp, #8]
    5c16:	ea5b 0303 	orrs.w	r3, fp, r3
    5c1a:	f43f ada8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
    5c1e:	493a      	ldr	r1, [pc, #232]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c20:	4835      	ldr	r0, [pc, #212]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c22:	4b3a      	ldr	r3, [pc, #232]	; (5d0c <grid_port_process_outbound_ui+0x694>)
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5c24:	4798      	blx	r3
    5c26:	e5a2      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c28:	2e60      	cmp	r6, #96	; 0x60
    5c2a:	d117      	bne.n	5c5c <grid_port_process_outbound_ui+0x5e4>
    5c2c:	2f0e      	cmp	r7, #14
    5c2e:	f47f ad9e 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c32:	9b02      	ldr	r3, [sp, #8]
    5c34:	ea5b 0303 	orrs.w	r3, fp, r3
    5c38:	f43f ad99 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_store_configuration(&grid_sys_state, &grid_nvm_state);
    5c3c:	4932      	ldr	r1, [pc, #200]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c3e:	482e      	ldr	r0, [pc, #184]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c40:	4b33      	ldr	r3, [pc, #204]	; (5d10 <grid_port_process_outbound_ui+0x698>)
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c42:	4e34      	ldr	r6, [pc, #208]	; (5d14 <grid_port_process_outbound_ui+0x69c>)
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c44:	4798      	blx	r3
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c46:	2700      	movs	r7, #0
    5c48:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5c4c:	e9cd 7300 	strd	r7, r3, [sp]
    5c50:	4829      	ldr	r0, [pc, #164]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c52:	463b      	mov	r3, r7
    5c54:	22ff      	movs	r2, #255	; 0xff
    5c56:	4639      	mov	r1, r7
    5c58:	47b0      	blx	r6
    5c5a:	e588      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c5c:	2e62      	cmp	r6, #98	; 0x62
    5c5e:	d10b      	bne.n	5c78 <grid_port_process_outbound_ui+0x600>
    5c60:	2f0e      	cmp	r7, #14
    5c62:	f47f ad84 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c66:	9b02      	ldr	r3, [sp, #8]
    5c68:	ea5b 0303 	orrs.w	r3, fp, r3
    5c6c:	f43f ad7f 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c70:	4925      	ldr	r1, [pc, #148]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c72:	4b29      	ldr	r3, [pc, #164]	; (5d18 <grid_port_process_outbound_ui+0x6a0>)
    5c74:	4650      	mov	r0, sl
    5c76:	e7e4      	b.n	5c42 <grid_port_process_outbound_ui+0x5ca>
				else if (msg_class == GRID_CLASS_GLOBALRECALL_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c78:	2e63      	cmp	r6, #99	; 0x63
    5c7a:	d112      	bne.n	5ca2 <grid_port_process_outbound_ui+0x62a>
    5c7c:	2f0e      	cmp	r7, #14
    5c7e:	f47f ad76 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c82:	9b02      	ldr	r3, [sp, #8]
    5c84:	ea5b 0303 	orrs.w	r3, fp, r3
    5c88:	f43f ad71 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_GLOBALRECALL_BANKNUMBER_offset], GRID_CLASS_GLOBALRECALL_BANKNUMBER_length	, &error_flag);
    5c8c:	f108 0005 	add.w	r0, r8, #5
    5c90:	2102      	movs	r1, #2
    5c92:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5c96:	4448      	add	r0, r9
    5c98:	47a8      	blx	r5
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    5c9a:	4b20      	ldr	r3, [pc, #128]	; (5d1c <grid_port_process_outbound_ui+0x6a4>)
    5c9c:	b2c1      	uxtb	r1, r0
    5c9e:	4816      	ldr	r0, [pc, #88]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5ca0:	e590      	b.n	57c4 <grid_port_process_outbound_ui+0x14c>
				else if (msg_class == GRID_CLASS_LOCALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5ca2:	2e71      	cmp	r6, #113	; 0x71
    5ca4:	d13e      	bne.n	5d24 <grid_port_process_outbound_ui+0x6ac>
    5ca6:	2f0e      	cmp	r7, #14
    5ca8:	f47f ad61 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5cac:	9b02      	ldr	r3, [sp, #8]
    5cae:	ea5b 0303 	orrs.w	r3, fp, r3
    5cb2:	f43f ad5c 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);						
    5cb6:	4914      	ldr	r1, [pc, #80]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5cb8:	4b19      	ldr	r3, [pc, #100]	; (5d20 <grid_port_process_outbound_ui+0x6a8>)
    5cba:	4650      	mov	r0, sl
    5cbc:	e7b2      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
    5cbe:	bf00      	nop
    5cc0:	2001c838 	.word	0x2001c838
    5cc4:	000070c9 	.word	0x000070c9
    5cc8:	000147c5 	.word	0x000147c5
    5ccc:	00009c69 	.word	0x00009c69
    5cd0:	0000896d 	.word	0x0000896d
    5cd4:	00015fa4 	.word	0x00015fa4
    5cd8:	00014c25 	.word	0x00014c25
    5cdc:	00014d0b 	.word	0x00014d0b
    5ce0:	00008951 	.word	0x00008951
    5ce4:	000088dd 	.word	0x000088dd
    5ce8:	00008a99 	.word	0x00008a99
    5cec:	00008b6d 	.word	0x00008b6d
    5cf0:	000089a1 	.word	0x000089a1
    5cf4:	00015fce 	.word	0x00015fce
    5cf8:	2000f008 	.word	0x2000f008
    5cfc:	00015fe0 	.word	0x00015fe0
    5d00:	e000ed00 	.word	0xe000ed00
    5d04:	05fa0004 	.word	0x05fa0004
    5d08:	2000fa1c 	.word	0x2000fa1c
    5d0c:	0000948d 	.word	0x0000948d
    5d10:	00009139 	.word	0x00009139
    5d14:	00009bbb 	.word	0x00009bbb
    5d18:	00009585 	.word	0x00009585
    5d1c:	00009331 	.word	0x00009331
    5d20:	00009e9d 	.word	0x00009e9d
				else if (msg_class == GRID_CLASS_LOCALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d24:	2e70      	cmp	r6, #112	; 0x70
    5d26:	d10b      	bne.n	5d40 <grid_port_process_outbound_ui+0x6c8>
    5d28:	2f0e      	cmp	r7, #14
    5d2a:	f47f ad20 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5d2e:	9b02      	ldr	r3, [sp, #8]
    5d30:	ea5b 0303 	orrs.w	r3, fp, r3
    5d34:	f43f ad1b 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_store_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d38:	49b4      	ldr	r1, [pc, #720]	; (600c <grid_port_process_outbound_ui+0x994>)
    5d3a:	4bb5      	ldr	r3, [pc, #724]	; (6010 <grid_port_process_outbound_ui+0x998>)
    5d3c:	4650      	mov	r0, sl
    5d3e:	e771      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_LOCALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d40:	2e72      	cmp	r6, #114	; 0x72
    5d42:	d10b      	bne.n	5d5c <grid_port_process_outbound_ui+0x6e4>
    5d44:	2f0e      	cmp	r7, #14
    5d46:	f47f ad12 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5d4a:	9b02      	ldr	r3, [sp, #8]
    5d4c:	ea5b 0303 	orrs.w	r3, fp, r3
    5d50:	f43f ad0d 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d54:	49ad      	ldr	r1, [pc, #692]	; (600c <grid_port_process_outbound_ui+0x994>)
    5d56:	4baf      	ldr	r3, [pc, #700]	; (6014 <grid_port_process_outbound_ui+0x99c>)
    5d58:	4650      	mov	r0, sl
    5d5a:	e763      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5d5c:	2e80      	cmp	r6, #128	; 0x80
    5d5e:	f040 81b0 	bne.w	60c2 <grid_port_process_outbound_ui+0xa4a>
    5d62:	2f0f      	cmp	r7, #15
    5d64:	d122      	bne.n	5dac <grid_port_process_outbound_ui+0x734>
    5d66:	9b02      	ldr	r3, [sp, #8]
    5d68:	ea5b 0303 	orrs.w	r3, fp, r3
    5d6c:	f43f acff 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5d70:	f108 0005 	add.w	r0, r8, #5
    5d74:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d78:	2102      	movs	r1, #2
    5d7a:	4448      	add	r0, r9
    5d7c:	47a8      	blx	r5
    5d7e:	4606      	mov	r6, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5d80:	f108 0007 	add.w	r0, r8, #7
    5d84:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d88:	2102      	movs	r1, #2
    5d8a:	4448      	add	r0, r9
    5d8c:	47a8      	blx	r5
    5d8e:	4607      	mov	r7, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5d90:	f108 0009 	add.w	r0, r8, #9
    5d94:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d98:	2102      	movs	r1, #2
    5d9a:	4448      	add	r0, r9
    5d9c:	47a8      	blx	r5
					grid_ui_recall_event_configuration(&grid_ui_state, banknumber, elementnumber, eventtype);
    5d9e:	b2f1      	uxtb	r1, r6
    5da0:	b2c3      	uxtb	r3, r0
    5da2:	4e9d      	ldr	r6, [pc, #628]	; (6018 <grid_port_process_outbound_ui+0x9a0>)
    5da4:	b2fa      	uxtb	r2, r7
    5da6:	4650      	mov	r0, sl
    5da8:	47b0      	blx	r6
    5daa:	e4e0      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    5dac:	2f0e      	cmp	r7, #14
    5dae:	f47f acde 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5db2:	f1bb 0f00 	cmp.w	fp, #0
    5db6:	f040 80e0 	bne.w	5f7a <grid_port_process_outbound_ui+0x902>
    5dba:	2c00      	cmp	r4, #0
    5dbc:	f000 8150 	beq.w	6060 <grid_port_process_outbound_ui+0x9e8>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5dc0:	ab2f      	add	r3, sp, #188	; 0xbc
    5dc2:	f108 0005 	add.w	r0, r8, #5
    5dc6:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dca:	2102      	movs	r1, #2
    5dcc:	4418      	add	r0, r3
    5dce:	47a8      	blx	r5
    5dd0:	b2c3      	uxtb	r3, r0
    5dd2:	9305      	str	r3, [sp, #20]
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5dd4:	f108 0007 	add.w	r0, r8, #7
    5dd8:	ab2f      	add	r3, sp, #188	; 0xbc
    5dda:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dde:	2102      	movs	r1, #2
    5de0:	4418      	add	r0, r3
    5de2:	47a8      	blx	r5
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5de4:	ab2f      	add	r3, sp, #188	; 0xbc
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5de6:	9007      	str	r0, [sp, #28]
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5de8:	f108 0009 	add.w	r0, r8, #9
    5dec:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5df0:	2102      	movs	r1, #2
    5df2:	4418      	add	r0, r3
    5df4:	47a8      	blx	r5
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5df6:	2700      	movs	r7, #0
    5df8:	4b88      	ldr	r3, [pc, #544]	; (601c <grid_port_process_outbound_ui+0x9a4>)
    5dfa:	970e      	str	r7, [sp, #56]	; 0x38
    5dfc:	227e      	movs	r2, #126	; 0x7e
    5dfe:	4639      	mov	r1, r7
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e00:	fa5f f980 	uxtb.w	r9, r0
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e04:	a80f      	add	r0, sp, #60	; 0x3c
    5e06:	4798      	blx	r3
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e08:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5e0c:	f108 000b 	add.w	r0, r8, #11
    5e10:	eba3 0308 	sub.w	r3, r3, r8
    5e14:	aa2f      	add	r2, sp, #188	; 0xbc
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e16:	ae0e      	add	r6, sp, #56	; 0x38
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e18:	3b0b      	subs	r3, #11
					for(uint32_t j = 0; j<actionstring_length; j++){
    5e1a:	eb02 0800 	add.w	r8, r2, r0
    5e1e:	4639      	mov	r1, r7
    5e20:	4299      	cmp	r1, r3
    5e22:	f0c0 80ed 	bcc.w	6000 <grid_port_process_outbound_ui+0x988>
					grid_ui_event_register_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype, actionstring, actionstring_length);
    5e26:	9905      	ldr	r1, [sp, #20]
    5e28:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e2c:	f89d 801c 	ldrb.w	r8, [sp, #28]
    5e30:	4f7b      	ldr	r7, [pc, #492]	; (6020 <grid_port_process_outbound_ui+0x9a8>)
    5e32:	0109      	lsls	r1, r1, #4
    5e34:	9104      	str	r1, [sp, #16]
    5e36:	9905      	ldr	r1, [sp, #20]
    5e38:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    5e3c:	2664      	movs	r6, #100	; 0x64
    5e3e:	68d0      	ldr	r0, [r2, #12]
    5e40:	fb06 f608 	mul.w	r6, r6, r8
    5e44:	aa0e      	add	r2, sp, #56	; 0x38
    5e46:	4649      	mov	r1, r9
    5e48:	4430      	add	r0, r6
    5e4a:	47b8      	blx	r7
					if (banknumber == grid_sys_state.bank_activebank_number){
    5e4c:	4b75      	ldr	r3, [pc, #468]	; (6024 <grid_port_process_outbound_ui+0x9ac>)
    5e4e:	9a05      	ldr	r2, [sp, #20]
    5e50:	7bdb      	ldrb	r3, [r3, #15]
    5e52:	4293      	cmp	r3, r2
    5e54:	d105      	bne.n	5e62 <grid_port_process_outbound_ui+0x7ea>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    5e56:	9905      	ldr	r1, [sp, #20]
    5e58:	4f73      	ldr	r7, [pc, #460]	; (6028 <grid_port_process_outbound_ui+0x9b0>)
    5e5a:	464b      	mov	r3, r9
    5e5c:	4642      	mov	r2, r8
    5e5e:	4650      	mov	r0, sl
    5e60:	47b8      	blx	r7
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5e62:	f8da 3004 	ldr.w	r3, [sl, #4]
    5e66:	9a04      	ldr	r2, [sp, #16]
    5e68:	4413      	add	r3, r2
    5e6a:	4649      	mov	r1, r9
    5e6c:	68d8      	ldr	r0, [r3, #12]
    5e6e:	4b6f      	ldr	r3, [pc, #444]	; (602c <grid_port_process_outbound_ui+0x9b4>)
    5e70:	4430      	add	r0, r6
    5e72:	4798      	blx	r3
					if (event_index != 255){
    5e74:	28ff      	cmp	r0, #255	; 0xff
    5e76:	d03d      	beq.n	5ef4 <grid_port_process_outbound_ui+0x87c>
						if (position_is_local){
    5e78:	b304      	cbz	r4, 5ebc <grid_port_process_outbound_ui+0x844>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5e7a:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e7e:	9904      	ldr	r1, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5e80:	9f04      	ldr	r7, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5e82:	440a      	add	r2, r1
    5e84:	23bc      	movs	r3, #188	; 0xbc
    5e86:	68d2      	ldr	r2, [r2, #12]
    5e88:	4432      	add	r2, r6
    5e8a:	fb10 f303 	smulbb	r3, r0, r3
    5e8e:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5e90:	441a      	add	r2, r3
    5e92:	2100      	movs	r1, #0
    5e94:	f882 10b8 	strb.w	r1, [r2, #184]	; 0xb8
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5e98:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e9c:	443a      	add	r2, r7
    5e9e:	68d2      	ldr	r2, [r2, #12]
    5ea0:	4432      	add	r2, r6
    5ea2:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5ea4:	441a      	add	r2, r3
    5ea6:	f882 10b6 	strb.w	r1, [r2, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5eaa:	f8da 2004 	ldr.w	r2, [sl, #4]
    5eae:	443a      	add	r2, r7
    5eb0:	68d2      	ldr	r2, [r2, #12]
    5eb2:	4432      	add	r2, r6
    5eb4:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5eb6:	4413      	add	r3, r2
    5eb8:	f883 10b7 	strb.w	r1, [r3, #183]	; 0xb7
						if (position_is_me){
    5ebc:	f1bb 0f00 	cmp.w	fp, #0
    5ec0:	d018      	beq.n	5ef4 <grid_port_process_outbound_ui+0x87c>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    5ec2:	22bc      	movs	r2, #188	; 0xbc
    5ec4:	fb10 f002 	smulbb	r0, r0, r2
    5ec8:	f8da 3004 	ldr.w	r3, [sl, #4]
    5ecc:	9a04      	ldr	r2, [sp, #16]
    5ece:	4413      	add	r3, r2
    5ed0:	2201      	movs	r2, #1
    5ed2:	68db      	ldr	r3, [r3, #12]
    5ed4:	4433      	add	r3, r6
    5ed6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    5ed8:	4403      	add	r3, r0
    5eda:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5ede:	f8da 3004 	ldr.w	r3, [sl, #4]
    5ee2:	9a04      	ldr	r2, [sp, #16]
    5ee4:	441a      	add	r2, r3
    5ee6:	68d3      	ldr	r3, [r2, #12]
    5ee8:	441e      	add	r6, r3
    5eea:	6e33      	ldr	r3, [r6, #96]	; 0x60
    5eec:	4418      	add	r0, r3
    5eee:	2300      	movs	r3, #0
    5ef0:	f880 30b7 	strb.w	r3, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    5ef4:	4b4e      	ldr	r3, [pc, #312]	; (6030 <grid_port_process_outbound_ui+0x9b8>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5ef6:	4e4f      	ldr	r6, [pc, #316]	; (6034 <grid_port_process_outbound_ui+0x9bc>)
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5ef8:	4f4f      	ldr	r7, [pc, #316]	; (6038 <grid_port_process_outbound_ui+0x9c0>)
					grid_msg_init(&response);
    5efa:	a893      	add	r0, sp, #588	; 0x24c
    5efc:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5efe:	227f      	movs	r2, #127	; 0x7f
    5f00:	4611      	mov	r1, r2
    5f02:	2300      	movs	r3, #0
    5f04:	a893      	add	r0, sp, #588	; 0x24c
    5f06:	47b0      	blx	r6
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f08:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    5f0a:	2600      	movs	r6, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f0c:	494b      	ldr	r1, [pc, #300]	; (603c <grid_port_process_outbound_ui+0x9c4>)
    5f0e:	9300      	str	r3, [sp, #0]
    5f10:	2202      	movs	r2, #2
    5f12:	2380      	movs	r3, #128	; 0x80
    5f14:	a80a      	add	r0, sp, #40	; 0x28
					uint8_t response_payload[10] = {0};
    5f16:	e9cd 660a 	strd	r6, r6, [sp, #40]	; 0x28
    5f1a:	f8ad 6030 	strh.w	r6, [sp, #48]	; 0x30
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f1e:	47b8      	blx	r7
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f20:	4b47      	ldr	r3, [pc, #284]	; (6040 <grid_port_process_outbound_ui+0x9c8>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f22:	4f48      	ldr	r7, [pc, #288]	; (6044 <grid_port_process_outbound_ui+0x9cc>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f24:	a80a      	add	r0, sp, #40	; 0x28
    5f26:	4798      	blx	r3
    5f28:	4b47      	ldr	r3, [pc, #284]	; (6048 <grid_port_process_outbound_ui+0x9d0>)
    5f2a:	4602      	mov	r2, r0
    5f2c:	a90a      	add	r1, sp, #40	; 0x28
    5f2e:	a893      	add	r0, sp, #588	; 0x24c
    5f30:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f32:	9b05      	ldr	r3, [sp, #20]
    5f34:	9300      	str	r3, [sp, #0]
    5f36:	2205      	movs	r2, #5
    5f38:	2302      	movs	r3, #2
    5f3a:	4631      	mov	r1, r6
    5f3c:	a893      	add	r0, sp, #588	; 0x24c
    5f3e:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    5f40:	2302      	movs	r3, #2
    5f42:	2207      	movs	r2, #7
    5f44:	4631      	mov	r1, r6
    5f46:	a893      	add	r0, sp, #588	; 0x24c
    5f48:	f8cd 8000 	str.w	r8, [sp]
    5f4c:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    5f4e:	2302      	movs	r3, #2
    5f50:	2209      	movs	r2, #9
    5f52:	4631      	mov	r1, r6
    5f54:	a893      	add	r0, sp, #588	; 0x24c
    5f56:	f8cd 9000 	str.w	r9, [sp]
    5f5a:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5f5c:	230a      	movs	r3, #10
    5f5e:	9300      	str	r3, [sp, #0]
    5f60:	2204      	movs	r2, #4
    5f62:	2301      	movs	r3, #1
    5f64:	4631      	mov	r1, r6
    5f66:	a893      	add	r0, sp, #588	; 0x24c
    5f68:	47b8      	blx	r7
                        grid_msg_packet_close(&response);
    5f6a:	4b38      	ldr	r3, [pc, #224]	; (604c <grid_port_process_outbound_ui+0x9d4>)
    5f6c:	a893      	add	r0, sp, #588	; 0x24c
    5f6e:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5f70:	4b37      	ldr	r3, [pc, #220]	; (6050 <grid_port_process_outbound_ui+0x9d8>)
    5f72:	a893      	add	r0, sp, #588	; 0x24c
    5f74:	4798      	blx	r3
    5f76:	f7ff bbfa 	b.w	576e <grid_port_process_outbound_ui+0xf6>
                    if (!position_is_local){
    5f7a:	2c00      	cmp	r4, #0
    5f7c:	f47f af20 	bne.w	5dc0 <grid_port_process_outbound_ui+0x748>
                        grid_keyboard_state.isenabled = 0;             
    5f80:	4e34      	ldr	r6, [pc, #208]	; (6054 <grid_port_process_outbound_ui+0x9dc>)
                        grid_msg_init(&response);
    5f82:	4b2b      	ldr	r3, [pc, #172]	; (6030 <grid_port_process_outbound_ui+0x9b8>)
                        grid_keyboard_state.isenabled = 0;             
    5f84:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    5f88:	a893      	add	r0, sp, #588	; 0x24c
    5f8a:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f8c:	227f      	movs	r2, #127	; 0x7f
    5f8e:	4623      	mov	r3, r4
    5f90:	4611      	mov	r1, r2
    5f92:	a893      	add	r0, sp, #588	; 0x24c
    5f94:	4f27      	ldr	r7, [pc, #156]	; (6034 <grid_port_process_outbound_ui+0x9bc>)
    5f96:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5f98:	2303      	movs	r3, #3
    5f9a:	492f      	ldr	r1, [pc, #188]	; (6058 <grid_port_process_outbound_ui+0x9e0>)
    5f9c:	9300      	str	r3, [sp, #0]
    5f9e:	2202      	movs	r2, #2
    5fa0:	4f25      	ldr	r7, [pc, #148]	; (6038 <grid_port_process_outbound_ui+0x9c0>)
                        uint8_t response_payload[10] = {0};
    5fa2:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fa6:	2392      	movs	r3, #146	; 0x92
    5fa8:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    5faa:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fae:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5fb0:	4b23      	ldr	r3, [pc, #140]	; (6040 <grid_port_process_outbound_ui+0x9c8>)
    5fb2:	a80e      	add	r0, sp, #56	; 0x38
    5fb4:	4798      	blx	r3
    5fb6:	a90e      	add	r1, sp, #56	; 0x38
    5fb8:	4602      	mov	r2, r0
    5fba:	4b23      	ldr	r3, [pc, #140]	; (6048 <grid_port_process_outbound_ui+0x9d0>)
    5fbc:	a893      	add	r0, sp, #588	; 0x24c
    5fbe:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    5fc0:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    5fc4:	9300      	str	r3, [sp, #0]
    5fc6:	4e1f      	ldr	r6, [pc, #124]	; (6044 <grid_port_process_outbound_ui+0x9cc>)
    5fc8:	4621      	mov	r1, r4
    5fca:	a893      	add	r0, sp, #588	; 0x24c
    5fcc:	2302      	movs	r3, #2
    5fce:	2205      	movs	r2, #5
    5fd0:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5fd2:	230d      	movs	r3, #13
    5fd4:	4621      	mov	r1, r4
    5fd6:	2204      	movs	r2, #4
    5fd8:	9300      	str	r3, [sp, #0]
    5fda:	a893      	add	r0, sp, #588	; 0x24c
    5fdc:	2301      	movs	r3, #1
    5fde:	47b0      	blx	r6
                        grid_msg_packet_close(&response);
    5fe0:	4b1a      	ldr	r3, [pc, #104]	; (604c <grid_port_process_outbound_ui+0x9d4>)
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    5fe2:	4e1e      	ldr	r6, [pc, #120]	; (605c <grid_port_process_outbound_ui+0x9e4>)
                        grid_msg_packet_close(&response);
    5fe4:	a893      	add	r0, sp, #588	; 0x24c
    5fe6:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5fe8:	4b19      	ldr	r3, [pc, #100]	; (6050 <grid_port_process_outbound_ui+0x9d8>)
    5fea:	a893      	add	r0, sp, #588	; 0x24c
    5fec:	4798      	blx	r3
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    5fee:	23fa      	movs	r3, #250	; 0xfa
    5ff0:	e9cd 4300 	strd	r4, r3, [sp]
    5ff4:	2364      	movs	r3, #100	; 0x64
    5ff6:	480b      	ldr	r0, [pc, #44]	; (6024 <grid_port_process_outbound_ui+0x9ac>)
    5ff8:	461a      	mov	r2, r3
    5ffa:	4619      	mov	r1, r3
    5ffc:	47b0      	blx	r6
    5ffe:	e6df      	b.n	5dc0 <grid_port_process_outbound_ui+0x748>
						actionstring[j] = message[current_start+GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset + j];
    6000:	f818 2b01 	ldrb.w	r2, [r8], #1
    6004:	558a      	strb	r2, [r1, r6]
					for(uint32_t j = 0; j<actionstring_length; j++){
    6006:	3101      	adds	r1, #1
    6008:	e70a      	b.n	5e20 <grid_port_process_outbound_ui+0x7a8>
    600a:	bf00      	nop
    600c:	2000fa1c 	.word	0x2000fa1c
    6010:	00009e8d 	.word	0x00009e8d
    6014:	00009ead 	.word	0x00009ead
    6018:	00009ebd 	.word	0x00009ebd
    601c:	000147c5 	.word	0x000147c5
    6020:	0000a2dd 	.word	0x0000a2dd
    6024:	2000f008 	.word	0x2000f008
    6028:	0000a539 	.word	0x0000a539
    602c:	0000a4ed 	.word	0x0000a4ed
    6030:	0000896d 	.word	0x0000896d
    6034:	000089a1 	.word	0x000089a1
    6038:	00014c8d 	.word	0x00014c8d
    603c:	00015fec 	.word	0x00015fec
    6040:	00014d0b 	.word	0x00014d0b
    6044:	00008951 	.word	0x00008951
    6048:	000088dd 	.word	0x000088dd
    604c:	00008a99 	.word	0x00008a99
    6050:	00008b6d 	.word	0x00008b6d
    6054:	20010264 	.word	0x20010264
    6058:	00015fe0 	.word	0x00015fe0
    605c:	00009bbb 	.word	0x00009bbb
                        grid_keyboard_state.isenabled = 0;             
    6060:	4e8b      	ldr	r6, [pc, #556]	; (6290 <grid_port_process_outbound_ui+0xc18>)
                        grid_msg_init(&response);
    6062:	4b8c      	ldr	r3, [pc, #560]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
                        grid_keyboard_state.isenabled = 0;             
    6064:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    6068:	a893      	add	r0, sp, #588	; 0x24c
    606a:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    606c:	227f      	movs	r2, #127	; 0x7f
    606e:	4611      	mov	r1, r2
    6070:	4f89      	ldr	r7, [pc, #548]	; (6298 <grid_port_process_outbound_ui+0xc20>)
    6072:	4623      	mov	r3, r4
    6074:	a893      	add	r0, sp, #588	; 0x24c
    6076:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6078:	2303      	movs	r3, #3
    607a:	4988      	ldr	r1, [pc, #544]	; (629c <grid_port_process_outbound_ui+0xc24>)
    607c:	9300      	str	r3, [sp, #0]
    607e:	2202      	movs	r2, #2
    6080:	2392      	movs	r3, #146	; 0x92
    6082:	4f87      	ldr	r7, [pc, #540]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
                        uint8_t response_payload[10] = {0};
    6084:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6088:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    608a:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    608e:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6090:	4b84      	ldr	r3, [pc, #528]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
    6092:	a80e      	add	r0, sp, #56	; 0x38
    6094:	4798      	blx	r3
    6096:	4b84      	ldr	r3, [pc, #528]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    6098:	4602      	mov	r2, r0
    609a:	a90e      	add	r1, sp, #56	; 0x38
    609c:	a893      	add	r0, sp, #588	; 0x24c
    609e:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    60a0:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    60a4:	9300      	str	r3, [sp, #0]
    60a6:	2205      	movs	r2, #5
    60a8:	2302      	movs	r3, #2
    60aa:	4621      	mov	r1, r4
    60ac:	4e7f      	ldr	r6, [pc, #508]	; (62ac <grid_port_process_outbound_ui+0xc34>)
    60ae:	a893      	add	r0, sp, #588	; 0x24c
    60b0:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    60b2:	230d      	movs	r3, #13
    60b4:	9300      	str	r3, [sp, #0]
    60b6:	2204      	movs	r2, #4
    60b8:	2301      	movs	r3, #1
    60ba:	4621      	mov	r1, r4
    60bc:	a893      	add	r0, sp, #588	; 0x24c
    60be:	47b0      	blx	r6
    60c0:	e753      	b.n	5f6a <grid_port_process_outbound_ui+0x8f2>
                else if (msg_class == GRID_CLASS_HIDKEYSTATUS_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    60c2:	2e92      	cmp	r6, #146	; 0x92
    60c4:	d13e      	bne.n	6144 <grid_port_process_outbound_ui+0xacc>
    60c6:	2f0e      	cmp	r7, #14
    60c8:	f47f ab51 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    60cc:	9b02      	ldr	r3, [sp, #8]
    60ce:	ea5b 0303 	orrs.w	r3, fp, r3
    60d2:	f43f ab4c 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    60d6:	f108 0005 	add.w	r0, r8, #5
    60da:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    60de:	2102      	movs	r1, #2
    60e0:	4448      	add	r0, r9
    60e2:	47a8      	blx	r5
                    grid_keyboard_state.isenabled = isenabled;
    60e4:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 6290 <grid_port_process_outbound_ui+0xc18>
                    grid_msg_init(&response);
    60e8:	4b6a      	ldr	r3, [pc, #424]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    60ea:	f888 0045 	strb.w	r0, [r8, #69]	; 0x45
                    grid_msg_init(&response);
    60ee:	a893      	add	r0, sp, #588	; 0x24c
    60f0:	4798      	blx	r3
                    grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    60f2:	227f      	movs	r2, #127	; 0x7f
    60f4:	4611      	mov	r1, r2
    60f6:	4f68      	ldr	r7, [pc, #416]	; (6298 <grid_port_process_outbound_ui+0xc20>)
    60f8:	2300      	movs	r3, #0
    60fa:	a893      	add	r0, sp, #588	; 0x24c
    60fc:	47b8      	blx	r7
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60fe:	2303      	movs	r3, #3
    6100:	4966      	ldr	r1, [pc, #408]	; (629c <grid_port_process_outbound_ui+0xc24>)
    6102:	9300      	str	r3, [sp, #0]
                    uint8_t response_payload[10] = {0};
    6104:	2700      	movs	r7, #0
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6106:	4633      	mov	r3, r6
    6108:	2202      	movs	r2, #2
    610a:	4e65      	ldr	r6, [pc, #404]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
                    uint8_t response_payload[10] = {0};
    610c:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6110:	a80e      	add	r0, sp, #56	; 0x38
                    uint8_t response_payload[10] = {0};
    6112:	e9cd 770e 	strd	r7, r7, [sp, #56]	; 0x38
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6116:	47b0      	blx	r6
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6118:	4b62      	ldr	r3, [pc, #392]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    611a:	4e64      	ldr	r6, [pc, #400]	; (62ac <grid_port_process_outbound_ui+0xc34>)
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    611c:	a80e      	add	r0, sp, #56	; 0x38
    611e:	4798      	blx	r3
    6120:	4b61      	ldr	r3, [pc, #388]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    6122:	4602      	mov	r2, r0
    6124:	a90e      	add	r1, sp, #56	; 0x38
    6126:	a893      	add	r0, sp, #588	; 0x24c
    6128:	4798      	blx	r3
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    612a:	f898 3045 	ldrb.w	r3, [r8, #69]	; 0x45
    612e:	9300      	str	r3, [sp, #0]
    6130:	2205      	movs	r2, #5
    6132:	2302      	movs	r3, #2
    6134:	4639      	mov	r1, r7
    6136:	a893      	add	r0, sp, #588	; 0x24c
    6138:	47b0      	blx	r6
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    613a:	230a      	movs	r3, #10
    613c:	9300      	str	r3, [sp, #0]
    613e:	2204      	movs	r2, #4
    6140:	2301      	movs	r3, #1
    6142:	e54a      	b.n	5bda <grid_port_process_outbound_ui+0x562>
				else if (msg_class == GRID_CLASS_CONFIGDEFAULT_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    6144:	2e81      	cmp	r6, #129	; 0x81
    6146:	f47f ab12 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    614a:	2f0e      	cmp	r7, #14
    614c:	f47f ab0f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    6150:	ea5b 0304 	orrs.w	r3, fp, r4
    6154:	f43f ab0b 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    6158:	f108 0005 	add.w	r0, r8, #5
    615c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6160:	2102      	movs	r1, #2
    6162:	4448      	add	r0, r9
    6164:	47a8      	blx	r5
    6166:	b2c7      	uxtb	r7, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    6168:	f108 0007 	add.w	r0, r8, #7
    616c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6170:	2102      	movs	r1, #2
    6172:	4448      	add	r0, r9
    6174:	47a8      	blx	r5
    6176:	4606      	mov	r6, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    6178:	f108 0009 	add.w	r0, r8, #9
    617c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6180:	2102      	movs	r1, #2
    6182:	4448      	add	r0, r9
    6184:	47a8      	blx	r5
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6186:	f8da 3004 	ldr.w	r3, [sl, #4]
    618a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
    618e:	b2f2      	uxtb	r2, r6
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    6190:	fa5f f880 	uxtb.w	r8, r0
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6194:	f04f 0964 	mov.w	r9, #100	; 0x64
    6198:	68d8      	ldr	r0, [r3, #12]
    619a:	4b45      	ldr	r3, [pc, #276]	; (62b0 <grid_port_process_outbound_ui+0xc38>)
    619c:	9204      	str	r2, [sp, #16]
    619e:	fb09 f902 	mul.w	r9, r9, r2
    61a2:	4641      	mov	r1, r8
    61a4:	4448      	add	r0, r9
    61a6:	4798      	blx	r3
					if (banknumber == grid_sys_state.bank_activebank_number){
    61a8:	4b42      	ldr	r3, [pc, #264]	; (62b4 <grid_port_process_outbound_ui+0xc3c>)
    61aa:	7bdb      	ldrb	r3, [r3, #15]
    61ac:	42bb      	cmp	r3, r7
    61ae:	d105      	bne.n	61bc <grid_port_process_outbound_ui+0xb44>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    61b0:	9a04      	ldr	r2, [sp, #16]
    61b2:	4e41      	ldr	r6, [pc, #260]	; (62b8 <grid_port_process_outbound_ui+0xc40>)
    61b4:	4643      	mov	r3, r8
    61b6:	4639      	mov	r1, r7
    61b8:	4650      	mov	r0, sl
    61ba:	47b0      	blx	r6
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61bc:	f8da 3004 	ldr.w	r3, [sl, #4]
    61c0:	013a      	lsls	r2, r7, #4
    61c2:	4413      	add	r3, r2
    61c4:	4641      	mov	r1, r8
    61c6:	68d8      	ldr	r0, [r3, #12]
    61c8:	4b3c      	ldr	r3, [pc, #240]	; (62bc <grid_port_process_outbound_ui+0xc44>)
    61ca:	4448      	add	r0, r9
    61cc:	4798      	blx	r3
					if (event_index != 255){
    61ce:	28ff      	cmp	r0, #255	; 0xff
    61d0:	d018      	beq.n	6204 <grid_port_process_outbound_ui+0xb8c>
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    61d2:	f8da 3004 	ldr.w	r3, [sl, #4]
    61d6:	22bc      	movs	r2, #188	; 0xbc
    61d8:	fb10 f002 	smulbb	r0, r0, r2
    61dc:	013a      	lsls	r2, r7, #4
    61de:	4413      	add	r3, r2
    61e0:	2201      	movs	r2, #1
    61e2:	68db      	ldr	r3, [r3, #12]
    61e4:	444b      	add	r3, r9
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    61e6:	0139      	lsls	r1, r7, #4
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    61e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    61ea:	4403      	add	r3, r0
    61ec:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    61f0:	f8da 3004 	ldr.w	r3, [sl, #4]
    61f4:	440b      	add	r3, r1
    61f6:	68db      	ldr	r3, [r3, #12]
    61f8:	4499      	add	r9, r3
    61fa:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
    61fe:	4418      	add	r0, r3
    6200:	f880 20b7 	strb.w	r2, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    6204:	4b23      	ldr	r3, [pc, #140]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6206:	f8df 9090 	ldr.w	r9, [pc, #144]	; 6298 <grid_port_process_outbound_ui+0xc20>
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    620a:	4e25      	ldr	r6, [pc, #148]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
					grid_msg_init(&response);
    620c:	a893      	add	r0, sp, #588	; 0x24c
    620e:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6210:	227f      	movs	r2, #127	; 0x7f
    6212:	4611      	mov	r1, r2
    6214:	2300      	movs	r3, #0
    6216:	a893      	add	r0, sp, #588	; 0x24c
    6218:	47c8      	blx	r9
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    621a:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    621c:	f04f 0900 	mov.w	r9, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6220:	4927      	ldr	r1, [pc, #156]	; (62c0 <grid_port_process_outbound_ui+0xc48>)
    6222:	9300      	str	r3, [sp, #0]
    6224:	2202      	movs	r2, #2
    6226:	2380      	movs	r3, #128	; 0x80
    6228:	a80e      	add	r0, sp, #56	; 0x38
					uint8_t response_payload[10] = {0};
    622a:	e9cd 990e 	strd	r9, r9, [sp, #56]	; 0x38
    622e:	f8ad 9040 	strh.w	r9, [sp, #64]	; 0x40
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6232:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6234:	4b1b      	ldr	r3, [pc, #108]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
    6236:	a80e      	add	r0, sp, #56	; 0x38
    6238:	4798      	blx	r3
    623a:	4b1b      	ldr	r3, [pc, #108]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    623c:	4602      	mov	r2, r0
    623e:	a90e      	add	r1, sp, #56	; 0x38
    6240:	a893      	add	r0, sp, #588	; 0x24c
    6242:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    6244:	9700      	str	r7, [sp, #0]
    6246:	2302      	movs	r3, #2
    6248:	4f18      	ldr	r7, [pc, #96]	; (62ac <grid_port_process_outbound_ui+0xc34>)
    624a:	2205      	movs	r2, #5
    624c:	4649      	mov	r1, r9
    624e:	a893      	add	r0, sp, #588	; 0x24c
    6250:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    6252:	9b04      	ldr	r3, [sp, #16]
    6254:	9300      	str	r3, [sp, #0]
    6256:	2207      	movs	r2, #7
    6258:	2302      	movs	r3, #2
    625a:	4649      	mov	r1, r9
    625c:	a893      	add	r0, sp, #588	; 0x24c
    625e:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    6260:	f8cd 8000 	str.w	r8, [sp]
    6264:	2302      	movs	r3, #2
    6266:	2209      	movs	r2, #9
    6268:	4649      	mov	r1, r9
    626a:	a893      	add	r0, sp, #588	; 0x24c
    626c:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    626e:	230a      	movs	r3, #10
    6270:	2204      	movs	r2, #4
    6272:	4649      	mov	r1, r9
    6274:	9300      	str	r3, [sp, #0]
    6276:	a893      	add	r0, sp, #588	; 0x24c
    6278:	2301      	movs	r3, #1
    627a:	47b8      	blx	r7
					grid_msg_packet_close(&response);
    627c:	4b11      	ldr	r3, [pc, #68]	; (62c4 <grid_port_process_outbound_ui+0xc4c>)
    627e:	a893      	add	r0, sp, #588	; 0x24c
    6280:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    6282:	4b11      	ldr	r3, [pc, #68]	; (62c8 <grid_port_process_outbound_ui+0xc50>)
    6284:	a893      	add	r0, sp, #588	; 0x24c
    6286:	4798      	blx	r3
				current_start = 0;
    6288:	46c8      	mov	r8, r9
    628a:	f7ff ba4c 	b.w	5726 <grid_port_process_outbound_ui+0xae>
    628e:	bf00      	nop
    6290:	20010264 	.word	0x20010264
    6294:	0000896d 	.word	0x0000896d
    6298:	000089a1 	.word	0x000089a1
    629c:	00015fe0 	.word	0x00015fe0
    62a0:	00014c8d 	.word	0x00014c8d
    62a4:	00014d0b 	.word	0x00014d0b
    62a8:	000088dd 	.word	0x000088dd
    62ac:	00008951 	.word	0x00008951
    62b0:	0000a349 	.word	0x0000a349
    62b4:	2000f008 	.word	0x2000f008
    62b8:	0000a539 	.word	0x0000a539
    62bc:	0000a4ed 	.word	0x0000a4ed
    62c0:	00015fec 	.word	0x00015fec
    62c4:	00008a99 	.word	0x00008a99
    62c8:	00008b6d 	.word	0x00008b6d

000062cc <grid_port_process_outbound_usart>:

uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    62cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    62d0:	8987      	ldrh	r7, [r0, #12]
uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    62d2:	4605      	mov	r5, r0
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    62d4:	bb1f      	cbnz	r7, 631e <grid_port_process_outbound_usart+0x52>
		
		uint16_t packet_size = grid_buffer_read_size(&por->tx_buffer);
    62d6:	f500 561c 	add.w	r6, r0, #9984	; 0x2700
    62da:	363c      	adds	r6, #60	; 0x3c
    62dc:	4b11      	ldr	r3, [pc, #68]	; (6324 <grid_port_process_outbound_usart+0x58>)
    62de:	4630      	mov	r0, r6
    62e0:	4798      	blx	r3
		
		if (!packet_size){
    62e2:	4604      	mov	r4, r0
    62e4:	b1a0      	cbz	r0, 6310 <grid_port_process_outbound_usart+0x44>
			// NO PACKET IN RX BUFFER
			return 0;
		}else{
			
			// Let's transfer the packet to local memory
			grid_buffer_read_init(&por->tx_buffer);
    62e6:	4b10      	ldr	r3, [pc, #64]	; (6328 <grid_port_process_outbound_usart+0x5c>)
			
			por->tx_double_buffer_status = packet_size;
			
			for (uint16_t i = 0; i<packet_size; i++){
				
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    62e8:	f8df a048 	ldr.w	sl, [pc, #72]	; 6334 <grid_port_process_outbound_usart+0x68>
			grid_buffer_read_init(&por->tx_buffer);
    62ec:	4630      	mov	r0, r6
    62ee:	f105 082c 	add.w	r8, r5, #44	; 0x2c
    62f2:	4798      	blx	r3
			por->tx_double_buffer_status = packet_size;
    62f4:	46c1      	mov	r9, r8
    62f6:	81ac      	strh	r4, [r5, #12]
			for (uint16_t i = 0; i<packet_size; i++){
    62f8:	b2bb      	uxth	r3, r7
    62fa:	429c      	cmp	r4, r3
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    62fc:	4630      	mov	r0, r6
			for (uint16_t i = 0; i<packet_size; i++){
    62fe:	d809      	bhi.n	6314 <grid_port_process_outbound_usart+0x48>
				por->tx_double_buffer[i] = character;
				
			}
		
			// Let's acknowledge the transaction
			grid_buffer_read_acknowledge(&por->tx_buffer);
    6300:	4b0a      	ldr	r3, [pc, #40]	; (632c <grid_port_process_outbound_usart+0x60>)
    6302:	4798      	blx	r3
			
			// Let's send the packet through USART
			io_write(&por->usart->io, por->tx_double_buffer, por->tx_double_buffer_status);		
    6304:	89aa      	ldrh	r2, [r5, #12]
    6306:	6868      	ldr	r0, [r5, #4]
    6308:	4b09      	ldr	r3, [pc, #36]	; (6330 <grid_port_process_outbound_usart+0x64>)
    630a:	4649      	mov	r1, r9
    630c:	4798      	blx	r3
			
			return 1;
    630e:	2001      	movs	r0, #1
		}
		
	}
	
	return 0;
}
    6310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6314:	47d0      	blx	sl
				por->tx_double_buffer[i] = character;
    6316:	3701      	adds	r7, #1
    6318:	f808 0b01 	strb.w	r0, [r8], #1
			for (uint16_t i = 0; i<packet_size; i++){
    631c:	e7ec      	b.n	62f8 <grid_port_process_outbound_usart+0x2c>
	return 0;
    631e:	2000      	movs	r0, #0
    6320:	e7f6      	b.n	6310 <grid_port_process_outbound_usart+0x44>
    6322:	bf00      	nop
    6324:	00004ebd 	.word	0x00004ebd
    6328:	00004f13 	.word	0x00004f13
    632c:	00004fa5 	.word	0x00004fa5
    6330:	0000b495 	.word	0x0000b495
    6334:	00004f7b 	.word	0x00004f7b

00006338 <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    6338:	b537      	push	{r0, r1, r2, r4, r5, lr}
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    633a:	4b0e      	ldr	r3, [pc, #56]	; (6374 <gpio_get_pin_level+0x3c>)
    633c:	4605      	mov	r5, r0
    633e:	a801      	add	r0, sp, #4
    6340:	4798      	blx	r3
	return tmp;
}

static inline hri_port_dir_reg_t hri_port_read_DIR_reg(const void *const hw, uint8_t submodule_index)
{
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    6342:	4a0d      	ldr	r2, [pc, #52]	; (6378 <gpio_get_pin_level+0x40>)
    6344:	096b      	lsrs	r3, r5, #5
    6346:	01d9      	lsls	r1, r3, #7
    6348:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    634c:	5851      	ldr	r1, [r2, r1]
	return tmp;
}

static inline hri_port_in_reg_t hri_port_read_IN_reg(const void *const hw, uint8_t submodule_index)
{
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    634e:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    6350:	691c      	ldr	r4, [r3, #16]
	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;

	CRITICAL_SECTION_LEAVE();
    6352:	4b0a      	ldr	r3, [pc, #40]	; (637c <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    6354:	4054      	eors	r4, r2
    6356:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    6358:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    635a:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    635c:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    6360:	4798      	blx	r3
    6362:	2001      	movs	r0, #1
    6364:	fa00 f505 	lsl.w	r5, r0, r5
    6368:	4225      	tst	r5, r4
}
    636a:	bf08      	it	eq
    636c:	2000      	moveq	r0, #0
    636e:	b003      	add	sp, #12
    6370:	bd30      	pop	{r4, r5, pc}
    6372:	bf00      	nop
    6374:	00011ef9 	.word	0x00011ef9
    6378:	41008000 	.word	0x41008000
    637c:	00011f07 	.word	0x00011f07

00006380 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6380:	f000 031f 	and.w	r3, r0, #31
{
    6384:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6386:	2501      	movs	r5, #1
    6388:	409d      	lsls	r5, r3
	switch (direction) {
    638a:	0940      	lsrs	r0, r0, #5
    638c:	4b0f      	ldr	r3, [pc, #60]	; (63cc <gpio_set_pin_direction+0x4c>)
    638e:	01c0      	lsls	r0, r0, #7
    6390:	2901      	cmp	r1, #1
    6392:	b2ac      	uxth	r4, r5
    6394:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6398:	4403      	add	r3, r0
    639a:	d008      	beq.n	63ae <gpio_set_pin_direction+0x2e>
    639c:	2902      	cmp	r1, #2
    639e:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    63a2:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    63a6:	d00e      	beq.n	63c6 <gpio_set_pin_direction+0x46>
    63a8:	605d      	str	r5, [r3, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    63aa:	629c      	str	r4, [r3, #40]	; 0x28
    63ac:	e009      	b.n	63c2 <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    63ae:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    63b2:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
    63b6:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    63ba:	605d      	str	r5, [r3, #4]
    63bc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    63c0:	629c      	str	r4, [r3, #40]	; 0x28
    63c2:	629a      	str	r2, [r3, #40]	; 0x28
}
    63c4:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    63c6:	609d      	str	r5, [r3, #8]
    63c8:	e7ef      	b.n	63aa <gpio_set_pin_direction+0x2a>
    63ca:	bf00      	nop
    63cc:	41008000 	.word	0x41008000

000063d0 <gpio_set_pin_pull_mode>:
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
	switch (pull_mode) {
    63d0:	f000 021f 	and.w	r2, r0, #31
    63d4:	2901      	cmp	r1, #1
    63d6:	ea4f 1050 	mov.w	r0, r0, lsr #5
    63da:	4b14      	ldr	r3, [pc, #80]	; (642c <gpio_set_pin_pull_mode+0x5c>)
    63dc:	ea4f 10c0 	mov.w	r0, r0, lsl #7
    63e0:	d00a      	beq.n	63f8 <gpio_set_pin_pull_mode+0x28>
    63e2:	2902      	cmp	r1, #2
    63e4:	d014      	beq.n	6410 <gpio_set_pin_pull_mode+0x40>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    63e6:	4403      	add	r3, r0
    63e8:	4413      	add	r3, r2
    63ea:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
    63ee:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    63f2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
    63f6:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    63f8:	4403      	add	r3, r0
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
		break;

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    63fa:	4091      	lsls	r1, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    63fc:	441a      	add	r2, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    63fe:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    6400:	f892 0040 	ldrb.w	r0, [r2, #64]	; 0x40
    6404:	f040 0004 	orr.w	r0, r0, #4
    6408:	f882 0040 	strb.w	r0, [r2, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    640c:	6199      	str	r1, [r3, #24]
}
    640e:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6410:	4403      	add	r3, r0
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
		hri_port_set_OUT_reg(PORT, port, 1U << pin);
		break;

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    6412:	2101      	movs	r1, #1
    6414:	4091      	lsls	r1, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    6416:	441a      	add	r2, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6418:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    641a:	f892 0040 	ldrb.w	r0, [r2, #64]	; 0x40
    641e:	f040 0004 	orr.w	r0, r0, #4
    6422:	f882 0040 	strb.w	r0, [r2, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    6426:	6159      	str	r1, [r3, #20]
}
    6428:	4770      	bx	lr
    642a:	bf00      	nop
    642c:	41008000 	.word	0x41008000

00006430 <grid_d51_init>:
	
}



void grid_d51_init(){
    6430:	b570      	push	{r4, r5, r6, lr}
	
	uint32_t hwid = grid_sys_get_hwcfg();
    6432:	4b09      	ldr	r3, [pc, #36]	; (6458 <grid_d51_init+0x28>)
	
	#ifdef NDEBUG		
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "USER ROW CHECK!");
	grid_d51_verify_user_row();
	#else
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6434:	4d09      	ldr	r5, [pc, #36]	; (645c <grid_d51_init+0x2c>)
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    6436:	4c0a      	ldr	r4, [pc, #40]	; (6460 <grid_d51_init+0x30>)
	uint32_t hwid = grid_sys_get_hwcfg();
    6438:	4798      	blx	r3
    643a:	4601      	mov	r1, r0
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    643c:	4809      	ldr	r0, [pc, #36]	; (6464 <grid_d51_init+0x34>)
    643e:	47a0      	blx	r4
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    6440:	4909      	ldr	r1, [pc, #36]	; (6468 <grid_d51_init+0x38>)
    6442:	4628      	mov	r0, r5
    6444:	47a0      	blx	r4
	{
	}
	
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Unit Test");
    6446:	4909      	ldr	r1, [pc, #36]	; (646c <grid_d51_init+0x3c>)
    6448:	4628      	mov	r0, r5
    644a:	47a0      	blx	r4
	while (1)
	{
	}
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    644c:	4628      	mov	r0, r5
    644e:	4623      	mov	r3, r4
    6450:	4907      	ldr	r1, [pc, #28]	; (6470 <grid_d51_init+0x40>)
	#endif
		
}
    6452:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Hardware Test");
    6456:	4718      	bx	r3
    6458:	00009c95 	.word	0x00009c95
    645c:	00015eb7 	.word	0x00015eb7
    6460:	00014925 	.word	0x00014925
    6464:	00015ffc 	.word	0x00015ffc
    6468:	0001601d 	.word	0x0001601d
    646c:	00016030 	.word	0x00016030
    6470:	0001603d 	.word	0x0001603d

00006474 <grid_d51_boundary_scan>:
	
}



uint8_t grid_d51_boundary_scan(uint32_t* result_bitmap){
    6474:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}


	result_bitmap[0] = 0;
    6478:	2400      	movs	r4, #0
uint8_t grid_d51_boundary_scan(uint32_t* result_bitmap){
    647a:	b0a7      	sub	sp, #156	; 0x9c
	result_bitmap[1] = 0;
    647c:	e9c0 4400 	strd	r4, r4, [r0]
	result_bitmap[2] = 0;
	result_bitmap[3] = 0;
    6480:	e9c0 4402 	strd	r4, r4, [r0, #8]



	// set bit high if there was an error
	uint32_t error_bitmap[4] = {0};
    6484:	4ba3      	ldr	r3, [pc, #652]	; (6714 <grid_d51_boundary_scan+0x2a0>)
	pins [31] = PIN_GND;				//GND
	pins [32] = GPIO(GPIO_PORTB, 10);
	pins [33] = GPIO(GPIO_PORTB, 11);
	pins [34] = GPIO(GPIO_PORTB, 12);
	pins [35] = GPIO(GPIO_PORTB, 13);
	pins [36] = GPIO(GPIO_PORTB, 14);
    6486:	4da4      	ldr	r5, [pc, #656]	; (6718 <grid_d51_boundary_scan+0x2a4>)
	pins [39] = PIN_VDD;				//VDDIO
	pins [40] = GPIO(GPIO_PORTC, 10);
	pins [41] = GPIO(GPIO_PORTC, 11);
	pins [42] = GPIO(GPIO_PORTC, 12);
	pins [43] = GPIO(GPIO_PORTC, 13);
	pins [44] = GPIO(GPIO_PORTC, 14);
    6488:	4fa4      	ldr	r7, [pc, #656]	; (671c <grid_d51_boundary_scan+0x2a8>)
	pins [87] = GPIO(GPIO_PORTA, 27);
	pins [88] = PIN_RST;				//RESETN
	pins [89] = PIN_CORE;				//VDDCORE
	pins [90] = PIN_GND;				//GND
	pins [91] = PIN_VSW;				//VSW
	pins [92] = PIN_VDD;				//VDDIO
    648a:	f8df 82d4 	ldr.w	r8, [pc, #724]	; 6760 <grid_d51_boundary_scan+0x2ec>
	uint32_t error_bitmap[4] = {0};
    648e:	2210      	movs	r2, #16
    6490:	4621      	mov	r1, r4
uint8_t grid_d51_boundary_scan(uint32_t* result_bitmap){
    6492:	4606      	mov	r6, r0
	uint32_t error_bitmap[4] = {0};
    6494:	a809      	add	r0, sp, #36	; 0x24
    6496:	4798      	blx	r3
	pins [4]  = GPIO(GPIO_PORTC, 1);
    6498:	4ba1      	ldr	r3, [pc, #644]	; (6720 <grid_d51_boundary_scan+0x2ac>)
    649a:	4aa2      	ldr	r2, [pc, #648]	; (6724 <grid_d51_boundary_scan+0x2b0>)
	pins [20] = GPIO(GPIO_PORTA, 7);
    649c:	49a2      	ldr	r1, [pc, #648]	; (6728 <grid_d51_boundary_scan+0x2b4>)
	pins [28] = GPIO(GPIO_PORTA, 10);
    649e:	48a3      	ldr	r0, [pc, #652]	; (672c <grid_d51_boundary_scan+0x2b8>)
	pins [64] = GPIO(GPIO_PORTB, 16);
    64a0:	f8df c2c0 	ldr.w	ip, [pc, #704]	; 6764 <grid_d51_boundary_scan+0x2f0>
	pins [80] = GPIO(GPIO_PORTB, 24);
    64a4:	f8df e2c0 	ldr.w	lr, [pc, #704]	; 6768 <grid_d51_boundary_scan+0x2f4>
	pins [93] = GPIO(GPIO_PORTA, 30);
	pins [94] = GPIO(GPIO_PORTA, 31);
	pins [95] = GPIO(GPIO_PORTB, 30);
	pins [96] = GPIO(GPIO_PORTB, 31);
    64a8:	9401      	str	r4, [sp, #4]
	pins [4]  = GPIO(GPIO_PORTC, 1);
    64aa:	e9cd 230d 	strd	r2, r3, [sp, #52]	; 0x34
	pins [8]  = GPIO(GPIO_PORTA, 3);
    64ae:	4ba0      	ldr	r3, [pc, #640]	; (6730 <grid_d51_boundary_scan+0x2bc>)
    64b0:	930f      	str	r3, [sp, #60]	; 0x3c
	pins [12] = PIN_VDD;				//VDDANA
    64b2:	f103 5328 	add.w	r3, r3, #704643072	; 0x2a000000
    64b6:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    64ba:	f203 23fa 	addw	r3, r3, #762	; 0x2fa
    64be:	9310      	str	r3, [sp, #64]	; 0x40
	pins [20] = GPIO(GPIO_PORTA, 7);
    64c0:	4b9c      	ldr	r3, [pc, #624]	; (6734 <grid_d51_boundary_scan+0x2c0>)
    64c2:	e9cd 1311 	strd	r1, r3, [sp, #68]	; 0x44
	pins [28] = GPIO(GPIO_PORTA, 10);
    64c6:	4b9c      	ldr	r3, [pc, #624]	; (6738 <grid_d51_boundary_scan+0x2c4>)
    64c8:	e9cd 0313 	strd	r0, r3, [sp, #76]	; 0x4c
	pins [36] = GPIO(GPIO_PORTB, 14);
    64cc:	4b9b      	ldr	r3, [pc, #620]	; (673c <grid_d51_boundary_scan+0x2c8>)
    64ce:	e9cd 5315 	strd	r5, r3, [sp, #84]	; 0x54
	pins [44] = GPIO(GPIO_PORTC, 14);
    64d2:	4b9b      	ldr	r3, [pc, #620]	; (6740 <grid_d51_boundary_scan+0x2cc>)
		//pin is real gpio pin
		if (pin_this < SPECIAL_CODES){

			if (!pin_failed){
				// SET TO INPUT, PULLDOWN
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    64d4:	4d9b      	ldr	r5, [pc, #620]	; (6744 <grid_d51_boundary_scan+0x2d0>)
	pins [44] = GPIO(GPIO_PORTC, 14);
    64d6:	e9cd 7317 	strd	r7, r3, [sp, #92]	; 0x5c
	pins [48] = GPIO(GPIO_PORTA, 14);
    64da:	4b9b      	ldr	r3, [pc, #620]	; (6748 <grid_d51_boundary_scan+0x2d4>)
    64dc:	9319      	str	r3, [sp, #100]	; 0x64
	pins [52] = GPIO(GPIO_PORTA, 16);
    64de:	f103 53a8 	add.w	r3, r3, #352321536	; 0x15000000
    64e2:	f503 13a0 	add.w	r3, r3, #1310720	; 0x140000
    64e6:	f203 2302 	addw	r3, r3, #514	; 0x202
    64ea:	931a      	str	r3, [sp, #104]	; 0x68
	pins [56] = GPIO(GPIO_PORTC, 16);
    64ec:	f103 3340 	add.w	r3, r3, #1077952576	; 0x40404040
    64f0:	931b      	str	r3, [sp, #108]	; 0x6c
	pins [64] = GPIO(GPIO_PORTB, 16);
    64f2:	4b96      	ldr	r3, [pc, #600]	; (674c <grid_d51_boundary_scan+0x2d8>)
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);
    64f4:	4f96      	ldr	r7, [pc, #600]	; (6750 <grid_d51_boundary_scan+0x2dc>)
	pins [64] = GPIO(GPIO_PORTB, 16);
    64f6:	e9cd c31c 	strd	ip, r3, [sp, #112]	; 0x70
	pins [68] = GPIO(GPIO_PORTB, 20);
    64fa:	f103 4361 	add.w	r3, r3, #3774873600	; 0xe1000000
    64fe:	f503 0362 	add.w	r3, r3, #14811136	; 0xe20000
    6502:	f203 4304 	addw	r3, r3, #1028	; 0x404
    6506:	931e      	str	r3, [sp, #120]	; 0x78
	pins [72] = GPIO(GPIO_PORTA, 22);
    6508:	f103 6380 	add.w	r3, r3, #67108864	; 0x4000000
    650c:	f503 3378 	add.w	r3, r3, #253952	; 0x3e000
    6510:	f503 73f1 	add.w	r3, r3, #482	; 0x1e2
    6514:	931f      	str	r3, [sp, #124]	; 0x7c
	pins [80] = GPIO(GPIO_PORTB, 24);
    6516:	4b8f      	ldr	r3, [pc, #572]	; (6754 <grid_d51_boundary_scan+0x2e0>)
    6518:	e9cd e320 	strd	lr, r3, [sp, #128]	; 0x80
	pins [84] = GPIO(GPIO_PORTC, 26);
    651c:	f103 4342 	add.w	r3, r3, #3254779904	; 0xc2000000
    6520:	f503 2384 	add.w	r3, r3, #270336	; 0x42000
    6524:	f203 2322 	addw	r3, r3, #546	; 0x222
    6528:	9322      	str	r3, [sp, #136]	; 0x88
	pins [92] = PIN_VDD;				//VDDIO
    652a:	4b8b      	ldr	r3, [pc, #556]	; (6758 <grid_d51_boundary_scan+0x2e4>)
    652c:	e9cd 8323 	strd	r8, r3, [sp, #140]	; 0x8c
	pins [96] = GPIO(GPIO_PORTB, 31);
    6530:	f103 4364 	add.w	r3, r3, #3825205248	; 0xe4000000
    6534:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    6538:	f503 73a1 	add.w	r3, r3, #322	; 0x142
    653c:	9325      	str	r3, [sp, #148]	; 0x94
	for (uint8_t i=0; i<100; i++){
    653e:	ab0d      	add	r3, sp, #52	; 0x34
    6540:	9304      	str	r3, [sp, #16]
    6542:	f89d 3004 	ldrb.w	r3, [sp, #4]
    6546:	9305      	str	r3, [sp, #20]
		uint8_t pin_this = pins[i];
    6548:	9b04      	ldr	r3, [sp, #16]
    654a:	f813 4b01 	ldrb.w	r4, [r3], #1
    654e:	9304      	str	r3, [sp, #16]
		if (pin_this < SPECIAL_CODES){
    6550:	2cef      	cmp	r4, #239	; 0xef
    6552:	d843      	bhi.n	65dc <grid_d51_boundary_scan+0x168>
		uint8_t pin_prev = pins[(i-1+100)%100];
    6554:	9b01      	ldr	r3, [sp, #4]

				// TEST IF pins[i] reads low
				if (gpio_get_pin_level(pin_this) != false){
    6556:	f8df b204 	ldr.w	fp, [pc, #516]	; 675c <grid_d51_boundary_scan+0x2e8>
		uint8_t pin_prev = pins[(i-1+100)%100];
    655a:	2164      	movs	r1, #100	; 0x64
    655c:	3363      	adds	r3, #99	; 0x63
    655e:	fbb3 f2f1 	udiv	r2, r3, r1
    6562:	fb01 3212 	mls	r2, r1, r2, r3
    6566:	ab26      	add	r3, sp, #152	; 0x98
    6568:	441a      	add	r2, r3
		uint8_t pin_next = pins[(i+1)%100];
    656a:	9b01      	ldr	r3, [sp, #4]
		uint8_t pin_prev = pins[(i-1+100)%100];
    656c:	f812 ac64 	ldrb.w	sl, [r2, #-100]
		uint8_t pin_next = pins[(i+1)%100];
    6570:	1c5a      	adds	r2, r3, #1
    6572:	fbb2 f3f1 	udiv	r3, r2, r1
    6576:	fb01 2313 	mls	r3, r1, r3, r2
    657a:	aa26      	add	r2, sp, #152	; 0x98
    657c:	4413      	add	r3, r2
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    657e:	2101      	movs	r1, #1
    6580:	4620      	mov	r0, r4
		uint8_t pin_next = pins[(i+1)%100];
    6582:	f813 9c64 	ldrb.w	r9, [r3, #-100]
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6586:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);
    6588:	2102      	movs	r1, #2
    658a:	4620      	mov	r0, r4
    658c:	47b8      	blx	r7
				if (gpio_get_pin_level(pin_this) != false){
    658e:	4620      	mov	r0, r4
    6590:	47d8      	blx	fp
					pin_failed = true;
				}

				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6592:	2100      	movs	r1, #0
				if (gpio_get_pin_level(pin_this) != false){
    6594:	4680      	mov	r8, r0
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6596:	4620      	mov	r0, r4
    6598:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    659a:	2100      	movs	r1, #0
    659c:	4620      	mov	r0, r4
    659e:	47b8      	blx	r7
			}

			if (!pin_failed){
    65a0:	f1b8 0f00 	cmp.w	r8, #0
    65a4:	d022      	beq.n	65ec <grid_d51_boundary_scan+0x178>
		
			if (pin_failed){
				//Sorry, pin failed

				uint8_t error_array_index = i/25;
				uint8_t error_bit_index = i%25;
    65a6:	9805      	ldr	r0, [sp, #20]
				uint8_t error_array_index = i/25;
    65a8:	9b05      	ldr	r3, [sp, #20]
    65aa:	2219      	movs	r2, #25

				error_count++;
				error_bitmap[error_array_index] |= (1<<error_bit_index);
    65ac:	a926      	add	r1, sp, #152	; 0x98
				uint8_t error_array_index = i/25;
    65ae:	fbb3 f3f2 	udiv	r3, r3, r2
				error_bitmap[error_array_index] |= (1<<error_bit_index);
    65b2:	eb01 0183 	add.w	r1, r1, r3, lsl #2
				uint8_t error_bit_index = i%25;
    65b6:	fb02 0313 	mls	r3, r2, r3, r0
				error_bitmap[error_array_index] |= (1<<error_bit_index);
    65ba:	b2db      	uxtb	r3, r3
    65bc:	2201      	movs	r2, #1
    65be:	fa02 f303 	lsl.w	r3, r2, r3
    65c2:	f851 2c74 	ldr.w	r2, [r1, #-116]
    65c6:	4313      	orrs	r3, r2
    65c8:	f841 3c74 	str.w	r3, [r1, #-116]

				result_bitmap[0] = error_bitmap[0];
    65cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    65ce:	6033      	str	r3, [r6, #0]
				result_bitmap[1] = error_bitmap[1];
    65d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    65d2:	6073      	str	r3, [r6, #4]
				result_bitmap[2] = error_bitmap[2];
    65d4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    65d6:	60b3      	str	r3, [r6, #8]
				result_bitmap[3] = error_bitmap[3];
    65d8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    65da:	60f3      	str	r3, [r6, #12]
	for (uint8_t i=0; i<100; i++){
    65dc:	9b01      	ldr	r3, [sp, #4]
    65de:	3301      	adds	r3, #1
    65e0:	2b64      	cmp	r3, #100	; 0x64
    65e2:	9301      	str	r3, [sp, #4]
    65e4:	d1ad      	bne.n	6542 <grid_d51_boundary_scan+0xce>
		}

	}


    65e6:	b027      	add	sp, #156	; 0x9c
    65e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    65ec:	2101      	movs	r1, #1
    65ee:	4620      	mov	r0, r4
    65f0:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_UP);
    65f2:	2101      	movs	r1, #1
    65f4:	4620      	mov	r0, r4
    65f6:	47b8      	blx	r7
				if (gpio_get_pin_level(pin_this) != true){
    65f8:	4620      	mov	r0, r4
    65fa:	47d8      	blx	fp
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    65fc:	4641      	mov	r1, r8
				if (gpio_get_pin_level(pin_this) != true){
    65fe:	9002      	str	r0, [sp, #8]
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6600:	4620      	mov	r0, r4
    6602:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    6604:	4620      	mov	r0, r4
    6606:	47b8      	blx	r7
			if (!pin_failed){
    6608:	9b02      	ldr	r3, [sp, #8]
    660a:	2b00      	cmp	r3, #0
    660c:	d0cb      	beq.n	65a6 <grid_d51_boundary_scan+0x132>
				if (pin_prev < SPECIAL_CODES){
    660e:	f1ba 0fef 	cmp.w	sl, #239	; 0xef
    6612:	d93f      	bls.n	6694 <grid_d51_boundary_scan+0x220>
				if (pin_next < SPECIAL_CODES){
    6614:	f1b9 0fef 	cmp.w	r9, #239	; 0xef
    6618:	d8e0      	bhi.n	65dc <grid_d51_boundary_scan+0x168>
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    661a:	2101      	movs	r1, #1
    661c:	4620      	mov	r0, r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    661e:	ea4f 1859 	mov.w	r8, r9, lsr #5
    6622:	47a8      	blx	r5
    6624:	ea4f 18c8 	mov.w	r8, r8, lsl #7
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);	
    6628:	2102      	movs	r1, #2
    662a:	4620      	mov	r0, r4
    662c:	47b8      	blx	r7
    662e:	f108 4882 	add.w	r8, r8, #1090519040	; 0x41000000
					gpio_set_pin_direction(pin_next, GPIO_DIRECTION_OUT);
    6632:	2102      	movs	r1, #2
    6634:	4648      	mov	r0, r9
    6636:	47a8      	blx	r5
    6638:	f508 4800 	add.w	r8, r8, #32768	; 0x8000
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    663c:	2101      	movs	r1, #1
    663e:	f009 0b1f 	and.w	fp, r9, #31
    6642:	fa01 fb0b 	lsl.w	fp, r1, fp
					if (gpio_get_pin_level(pin_this) != false){
    6646:	4b45      	ldr	r3, [pc, #276]	; (675c <grid_d51_boundary_scan+0x2e8>)
    6648:	f8c8 b018 	str.w	fp, [r8, #24]
    664c:	4620      	mov	r0, r4
    664e:	4798      	blx	r3
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6650:	2101      	movs	r1, #1
					if (gpio_get_pin_level(pin_this) != false){
    6652:	4682      	mov	sl, r0
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6654:	4620      	mov	r0, r4
    6656:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_UP);	
    6658:	2101      	movs	r1, #1
    665a:	4620      	mov	r0, r4
    665c:	47b8      	blx	r7
					gpio_set_pin_direction(pin_next, GPIO_DIRECTION_OUT);
    665e:	2102      	movs	r1, #2
    6660:	4648      	mov	r0, r9
    6662:	47a8      	blx	r5
					if (gpio_get_pin_level(pin_this) != true){
    6664:	4b3d      	ldr	r3, [pc, #244]	; (675c <grid_d51_boundary_scan+0x2e8>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    6666:	f8c8 b014 	str.w	fp, [r8, #20]
    666a:	4620      	mov	r0, r4
    666c:	4798      	blx	r3
    666e:	9b02      	ldr	r3, [sp, #8]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6670:	2100      	movs	r1, #0
					if (gpio_get_pin_level(pin_this) != true){
    6672:	2800      	cmp	r0, #0
    6674:	bf08      	it	eq
    6676:	469a      	moveq	sl, r3
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6678:	4620      	mov	r0, r4
    667a:	47a8      	blx	r5
					gpio_set_pin_direction(pin_next, GPIO_DIRECTION_OFF);
    667c:	2100      	movs	r1, #0
    667e:	4648      	mov	r0, r9
    6680:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    6682:	2100      	movs	r1, #0
    6684:	4620      	mov	r0, r4
    6686:	47b8      	blx	r7
    6688:	f8c8 b014 	str.w	fp, [r8, #20]
			if (pin_failed){
    668c:	f1ba 0f00 	cmp.w	sl, #0
    6690:	d0a4      	beq.n	65dc <grid_d51_boundary_scan+0x168>
    6692:	e788      	b.n	65a6 <grid_d51_boundary_scan+0x132>
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6694:	2101      	movs	r1, #1
    6696:	4620      	mov	r0, r4
    6698:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);	
    669a:	2102      	movs	r1, #2
    669c:	4620      	mov	r0, r4
    669e:	47b8      	blx	r7
					gpio_set_pin_direction(pin_prev, GPIO_DIRECTION_OUT);
    66a0:	2102      	movs	r1, #2
    66a2:	4650      	mov	r0, sl
    66a4:	47a8      	blx	r5
    66a6:	2101      	movs	r1, #1
    66a8:	f00a 031f 	and.w	r3, sl, #31
    66ac:	fa01 f303 	lsl.w	r3, r1, r3
    66b0:	9303      	str	r3, [sp, #12]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    66b2:	ea4f 135a 	mov.w	r3, sl, lsr #5
    66b6:	01db      	lsls	r3, r3, #7
    66b8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    66bc:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
    66c0:	9a03      	ldr	r2, [sp, #12]
    66c2:	619a      	str	r2, [r3, #24]
					if (gpio_get_pin_level(pin_this) != false){
    66c4:	4620      	mov	r0, r4
    66c6:	9307      	str	r3, [sp, #28]
    66c8:	47d8      	blx	fp
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    66ca:	2101      	movs	r1, #1
					if (gpio_get_pin_level(pin_this) != false){
    66cc:	9006      	str	r0, [sp, #24]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    66ce:	4620      	mov	r0, r4
    66d0:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_UP);	
    66d2:	2101      	movs	r1, #1
    66d4:	4620      	mov	r0, r4
    66d6:	47b8      	blx	r7
					gpio_set_pin_direction(pin_prev, GPIO_DIRECTION_OUT);
    66d8:	2102      	movs	r1, #2
    66da:	4650      	mov	r0, sl
    66dc:	47a8      	blx	r5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    66de:	9b07      	ldr	r3, [sp, #28]
    66e0:	9a03      	ldr	r2, [sp, #12]
    66e2:	615a      	str	r2, [r3, #20]
					if (gpio_get_pin_level(pin_this) != true){
    66e4:	4620      	mov	r0, r4
    66e6:	9307      	str	r3, [sp, #28]
    66e8:	47d8      	blx	fp
    66ea:	9b02      	ldr	r3, [sp, #8]
    66ec:	9a06      	ldr	r2, [sp, #24]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    66ee:	4641      	mov	r1, r8
					if (gpio_get_pin_level(pin_this) != true){
    66f0:	2800      	cmp	r0, #0
    66f2:	bf08      	it	eq
    66f4:	461a      	moveq	r2, r3
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    66f6:	4620      	mov	r0, r4
					if (gpio_get_pin_level(pin_this) != true){
    66f8:	9206      	str	r2, [sp, #24]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    66fa:	47a8      	blx	r5
					gpio_set_pin_direction(pin_prev, GPIO_DIRECTION_OFF);
    66fc:	4650      	mov	r0, sl
    66fe:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    6700:	4620      	mov	r0, r4
    6702:	47b8      	blx	r7
    6704:	9b07      	ldr	r3, [sp, #28]
    6706:	9a03      	ldr	r2, [sp, #12]
    6708:	615a      	str	r2, [r3, #20]
			if (!pin_failed){
    670a:	9a06      	ldr	r2, [sp, #24]
    670c:	2a00      	cmp	r2, #0
    670e:	d081      	beq.n	6614 <grid_d51_boundary_scan+0x1a0>
    6710:	e749      	b.n	65a6 <grid_d51_boundary_scan+0x132>
    6712:	bf00      	nop
    6714:	000147c5 	.word	0x000147c5
    6718:	2d2c2b2a 	.word	0x2d2c2b2a
    671c:	4d4c4b4a 	.word	0x4d4c4b4a
    6720:	02434241 	.word	0x02434241
    6724:	40010023 	.word	0x40010023
    6728:	06050429 	.word	0x06050429
    672c:	0908fdfe 	.word	0x0908fdfe
    6730:	fe252403 	.word	0xfe252403
    6734:	47464507 	.word	0x47464507
    6738:	fefd0b0a 	.word	0xfefd0b0a
    673c:	fdfe2f2e 	.word	0xfdfe2f2e
    6740:	0d0c4f4e 	.word	0x0d0c4f4e
    6744:	00006381 	.word	0x00006381
    6748:	fdfe0f0e 	.word	0xfdfe0f0e
    674c:	33323130 	.word	0x33323130
    6750:	000063d1 	.word	0x000063d1
    6754:	59583938 	.word	0x59583938
    6758:	3e1f1efd 	.word	0x3e1f1efd
    675c:	00006339 	.word	0x00006339
    6760:	f7fef8fc 	.word	0xf7fef8fc
    6764:	fdfe5554 	.word	0xfdfe5554
    6768:	3736fdfe 	.word	0x3736fdfe

0000676c <grid_expr_clear_input>:
}


grid_expr_clear_input(struct grid_expr_model* expr){

    expr->input_string_length = 0;
    676c:	2300      	movs	r3, #0
    676e:	f880 30fe 	strb.w	r3, [r0, #254]	; 0xfe

    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    6772:	1d02      	adds	r2, r0, #4
    6774:	30fe      	adds	r0, #254	; 0xfe

        expr->input_string[i] = 0;
    6776:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    677a:	4282      	cmp	r2, r0
    677c:	d1fb      	bne.n	6776 <grid_expr_clear_input+0xa>

    }

}
    677e:	4770      	bx	lr

00006780 <grid_expr_clear_output>:

grid_expr_clear_output(struct grid_expr_model* expr){


    expr->output_string_length = 0;
    6780:	2300      	movs	r3, #0
    6782:	f880 31fa 	strb.w	r3, [r0, #506]	; 0x1fa

    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    6786:	f100 02ff 	add.w	r2, r0, #255	; 0xff
    678a:	f200 10f9 	addw	r0, r0, #505	; 0x1f9

        expr->output_string[i] = 0;
    678e:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    6792:	4282      	cmp	r2, r0
    6794:	d1fb      	bne.n	678e <grid_expr_clear_output+0xe>

    }

}
    6796:	4770      	bx	lr

00006798 <grid_expr_init>:
void grid_expr_init(struct grid_expr_model* expr){
    6798:	b510      	push	{r4, lr}
    expr->current_event = NULL;
    679a:	2300      	movs	r3, #0
    679c:	6003      	str	r3, [r0, #0]
    grid_expr_clear_input(expr);
    679e:	4b04      	ldr	r3, [pc, #16]	; (67b0 <grid_expr_init+0x18>)
void grid_expr_init(struct grid_expr_model* expr){
    67a0:	4601      	mov	r1, r0
    grid_expr_clear_input(expr);
    67a2:	4798      	blx	r3
}
    67a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_expr_clear_output(expr);
    67a8:	4b02      	ldr	r3, [pc, #8]	; (67b4 <grid_expr_init+0x1c>)
    67aa:	4608      	mov	r0, r1
    67ac:	4718      	bx	r3
    67ae:	bf00      	nop
    67b0:	0000676d 	.word	0x0000676d
    67b4:	00006781 	.word	0x00006781

000067b8 <grid_expr_set_current_event>:



grid_expr_set_current_event(struct grid_expr_model* expr, struct grid_ui_event* eve){

    expr->current_event = eve;
    67b8:	6001      	str	r1, [r0, #0]
}
    67ba:	4770      	bx	lr

000067bc <get>:
}


char get(char** e)
{
    char ret = **e;
    67bc:	6802      	ldr	r2, [r0, #0]
{
    67be:	4603      	mov	r3, r0
    char ret = **e;
    67c0:	f812 0b01 	ldrb.w	r0, [r2], #1
    ++*e;
    67c4:	601a      	str	r2, [r3, #0]
    return ret;
}
    67c6:	4770      	bx	lr

000067c8 <number>:

int number(char** e)
{
    67c8:	b530      	push	{r4, r5, lr}
    char ret = **e;
    67ca:	6801      	ldr	r1, [r0, #0]
    67cc:	f811 3b01 	ldrb.w	r3, [r1], #1
    ++*e;
    67d0:	6001      	str	r1, [r0, #0]
{
    67d2:	4602      	mov	r2, r0
    int result = get(e) - '0';
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    {
        result = 10*result + get(e) - '0'; // HEX para
    67d4:	250a      	movs	r5, #10
    int result = get(e) - '0';
    67d6:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    return **e;
    67da:	6811      	ldr	r1, [r2, #0]
    67dc:	780b      	ldrb	r3, [r1, #0]
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    67de:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
    67e2:	2c09      	cmp	r4, #9
    67e4:	d900      	bls.n	67e8 <number+0x20>
    }
    return result;
}
    67e6:	bd30      	pop	{r4, r5, pc}
    ++*e;
    67e8:	3101      	adds	r1, #1
        result = 10*result + get(e) - '0'; // HEX para
    67ea:	fb05 3300 	mla	r3, r5, r0, r3
    ++*e;
    67ee:	6011      	str	r1, [r2, #0]
        result = 10*result + get(e) - '0'; // HEX para
    67f0:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    67f4:	e7f1      	b.n	67da <number+0x12>
	...

000067f8 <expr_level_0>:
            result -= expr_level_2(e);
    return result;
}

int expr_level_0(char ** e) // equality
{
    67f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_1(e);
    67fa:	4e2a      	ldr	r6, [pc, #168]	; (68a4 <expr_level_0+0xac>)
        else if (peeked == '=' && peeked2 == '='){
            get(e); // burn the second character
            result = (result == expr_level_1(e));
        }
        else if (peeked == '!' && peeked2 == '='){
            get(e); // burn the second character
    67fc:	4f2a      	ldr	r7, [pc, #168]	; (68a8 <expr_level_0+0xb0>)
{
    67fe:	4605      	mov	r5, r0
    int result = expr_level_1(e);
    6800:	47b0      	blx	r6
    6802:	4604      	mov	r4, r0
    return **e;
    6804:	682a      	ldr	r2, [r5, #0]
    6806:	7813      	ldrb	r3, [r2, #0]
    while (     (peek(e) == '>' && peek2(e) != '=') || 
    6808:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
    680c:	293c      	cmp	r1, #60	; 0x3c
    680e:	d004      	beq.n	681a <expr_level_0+0x22>
                (peek(e) == '<' && peek2(e) != '=') || 
    6810:	2b3d      	cmp	r3, #61	; 0x3d
    6812:	d143      	bne.n	689c <expr_level_0+0xa4>
                (peek(e) == '!' && peek2(e) == '=') ||
    6814:	7851      	ldrb	r1, [r2, #1]
    6816:	293d      	cmp	r1, #61	; 0x3d
    6818:	d142      	bne.n	68a0 <expr_level_0+0xa8>
    ++*e;
    681a:	1c51      	adds	r1, r2, #1
    681c:	6029      	str	r1, [r5, #0]
        if ((peeked == '>' && peeked2 != '=')){
    681e:	2b3e      	cmp	r3, #62	; 0x3e
    return **e;
    6820:	7852      	ldrb	r2, [r2, #1]
        if ((peeked == '>' && peeked2 != '=')){
    6822:	d108      	bne.n	6836 <expr_level_0+0x3e>
    6824:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result>expr_level_1(e));
    6826:	4628      	mov	r0, r5
        if ((peeked == '>' && peeked2 != '=')){
    6828:	d028      	beq.n	687c <expr_level_0+0x84>
            result = (result>expr_level_1(e));
    682a:	47b0      	blx	r6
    682c:	42a0      	cmp	r0, r4
    682e:	bfac      	ite	ge
    6830:	2400      	movge	r4, #0
    6832:	2401      	movlt	r4, #1
    6834:	e7e6      	b.n	6804 <expr_level_0+0xc>
        else if (peeked == '<' && peeked2 != '='){
    6836:	2b3c      	cmp	r3, #60	; 0x3c
    6838:	d108      	bne.n	684c <expr_level_0+0x54>
    683a:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result<expr_level_1(e));
    683c:	4628      	mov	r0, r5
        else if (peeked == '<' && peeked2 != '='){
    683e:	d025      	beq.n	688c <expr_level_0+0x94>
            result = (result<expr_level_1(e));
    6840:	47b0      	blx	r6
    6842:	42a0      	cmp	r0, r4
    6844:	bfd4      	ite	le
    6846:	2400      	movle	r4, #0
    6848:	2401      	movgt	r4, #1
    684a:	e7db      	b.n	6804 <expr_level_0+0xc>
        else if (peeked == '=' && peeked2 == '='){
    684c:	2b3d      	cmp	r3, #61	; 0x3d
    684e:	d109      	bne.n	6864 <expr_level_0+0x6c>
    6850:	2a3d      	cmp	r2, #61	; 0x3d
    6852:	d1d7      	bne.n	6804 <expr_level_0+0xc>
            get(e); // burn the second character
    6854:	4628      	mov	r0, r5
    6856:	47b8      	blx	r7
            result = (result == expr_level_1(e));
    6858:	4628      	mov	r0, r5
    685a:	47b0      	blx	r6
    685c:	1b03      	subs	r3, r0, r4
    685e:	425c      	negs	r4, r3
    6860:	415c      	adcs	r4, r3
    6862:	e7cf      	b.n	6804 <expr_level_0+0xc>
        else if (peeked == '!' && peeked2 == '='){
    6864:	2b21      	cmp	r3, #33	; 0x21
    6866:	d1cd      	bne.n	6804 <expr_level_0+0xc>
    6868:	2a3d      	cmp	r2, #61	; 0x3d
    686a:	d1cb      	bne.n	6804 <expr_level_0+0xc>
            get(e); // burn the second character
    686c:	4628      	mov	r0, r5
    686e:	47b8      	blx	r7
            result = (result != expr_level_1(e));
    6870:	4628      	mov	r0, r5
    6872:	47b0      	blx	r6
    6874:	1b04      	subs	r4, r0, r4
    6876:	bf18      	it	ne
    6878:	2401      	movne	r4, #1
    687a:	e7c3      	b.n	6804 <expr_level_0+0xc>
        }
        else if (peeked == '>' && peeked2 == '='){
            get(e); // burn the second character
    687c:	47b8      	blx	r7
            result = (result >= expr_level_1(e));
    687e:	4628      	mov	r0, r5
    6880:	47b0      	blx	r6
    6882:	42a0      	cmp	r0, r4
    6884:	bfcc      	ite	gt
    6886:	2400      	movgt	r4, #0
    6888:	2401      	movle	r4, #1
    688a:	e7bb      	b.n	6804 <expr_level_0+0xc>
        }
        else if (peeked == '<' && peeked2 == '='){
            get(e); // burn the second character
    688c:	47b8      	blx	r7
            result = (result <= expr_level_1(e));
    688e:	4628      	mov	r0, r5
    6890:	47b0      	blx	r6
    6892:	42a0      	cmp	r0, r4
    6894:	bfb4      	ite	lt
    6896:	2400      	movlt	r4, #0
    6898:	2401      	movge	r4, #1
    689a:	e7b3      	b.n	6804 <expr_level_0+0xc>
                (peek(e) == '=' && peek2(e) == '=') ||
    689c:	2b21      	cmp	r3, #33	; 0x21
    689e:	d0b9      	beq.n	6814 <expr_level_0+0x1c>
        }
    }
    return result;
}
    68a0:	4620      	mov	r0, r4
    68a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    68a4:	00006965 	.word	0x00006965
    68a8:	000067bd 	.word	0x000067bd

000068ac <expr_level_3>:
        get(e);
    68ac:	4913      	ldr	r1, [pc, #76]	; (68fc <expr_level_3+0x50>)
{
    68ae:	b570      	push	{r4, r5, r6, lr}
    68b0:	4604      	mov	r4, r0
    68b2:	2501      	movs	r5, #1
    return **e;
    68b4:	6823      	ldr	r3, [r4, #0]
    68b6:	781b      	ldrb	r3, [r3, #0]
    if (peek(e) >= '0' && peek(e) <= '9') // HEX para
    68b8:	2b2f      	cmp	r3, #47	; 0x2f
    68ba:	d908      	bls.n	68ce <expr_level_3+0x22>
    68bc:	2b39      	cmp	r3, #57	; 0x39
    68be:	d818      	bhi.n	68f2 <expr_level_3+0x46>
        return number(e);
    68c0:	4b0f      	ldr	r3, [pc, #60]	; (6900 <expr_level_3+0x54>)
    68c2:	4620      	mov	r0, r4
    68c4:	4798      	blx	r3
    68c6:	4601      	mov	r1, r0
}
    68c8:	fb05 f001 	mul.w	r0, r5, r1
    68cc:	bd70      	pop	{r4, r5, r6, pc}
    else if (peek(e) == '(')
    68ce:	2b28      	cmp	r3, #40	; 0x28
    68d0:	d109      	bne.n	68e6 <expr_level_3+0x3a>
        get(e); // '('
    68d2:	4e0a      	ldr	r6, [pc, #40]	; (68fc <expr_level_3+0x50>)
    68d4:	4620      	mov	r0, r4
    68d6:	47b0      	blx	r6
        int result = expr_level_0(e);
    68d8:	4b0a      	ldr	r3, [pc, #40]	; (6904 <expr_level_3+0x58>)
    68da:	4620      	mov	r0, r4
    68dc:	4798      	blx	r3
    68de:	4601      	mov	r1, r0
        get(e); // ')'
    68e0:	4620      	mov	r0, r4
    68e2:	47b0      	blx	r6
        return result;
    68e4:	e7f0      	b.n	68c8 <expr_level_3+0x1c>
    else if (peek(e) == '-')
    68e6:	2b2d      	cmp	r3, #45	; 0x2d
    68e8:	d103      	bne.n	68f2 <expr_level_3+0x46>
        get(e);
    68ea:	4620      	mov	r0, r4
    68ec:	4788      	blx	r1
        return -expr_level_3(e);
    68ee:	426d      	negs	r5, r5
    68f0:	e7e0      	b.n	68b4 <expr_level_3+0x8>
    printf("ERROR in expr_level_3()\n");
    68f2:	4805      	ldr	r0, [pc, #20]	; (6908 <expr_level_3+0x5c>)
    68f4:	4b05      	ldr	r3, [pc, #20]	; (690c <expr_level_3+0x60>)
    68f6:	4798      	blx	r3
    return 0; // error
    68f8:	2100      	movs	r1, #0
    68fa:	e7e5      	b.n	68c8 <expr_level_3+0x1c>
    68fc:	000067bd 	.word	0x000067bd
    6900:	000067c9 	.word	0x000067c9
    6904:	000067f9 	.word	0x000067f9
    6908:	000160c5 	.word	0x000160c5
    690c:	00014a59 	.word	0x00014a59

00006910 <expr_level_2>:
{
    6910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_3(e);
    6912:	4e13      	ldr	r6, [pc, #76]	; (6960 <expr_level_2+0x50>)
{
    6914:	4605      	mov	r5, r0
    int result = expr_level_3(e);
    6916:	47b0      	blx	r6
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6918:	f240 4721 	movw	r7, #1057	; 0x421
    int result = expr_level_3(e);
    691c:	4604      	mov	r4, r0
    return **e;
    691e:	682a      	ldr	r2, [r5, #0]
    6920:	7811      	ldrb	r1, [r2, #0]
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6922:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
    6926:	b2db      	uxtb	r3, r3
    6928:	2b0a      	cmp	r3, #10
    692a:	d803      	bhi.n	6934 <expr_level_2+0x24>
    692c:	fa27 f303 	lsr.w	r3, r7, r3
    6930:	07db      	lsls	r3, r3, #31
    6932:	d401      	bmi.n	6938 <expr_level_2+0x28>
}
    6934:	4620      	mov	r0, r4
    6936:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ++*e;
    6938:	3201      	adds	r2, #1
        if (peeked == '*'){
    693a:	292a      	cmp	r1, #42	; 0x2a
    ++*e;
    693c:	602a      	str	r2, [r5, #0]
            result *= expr_level_3(e);
    693e:	4628      	mov	r0, r5
        if (peeked == '*'){
    6940:	d102      	bne.n	6948 <expr_level_2+0x38>
            result *= expr_level_3(e);
    6942:	47b0      	blx	r6
    6944:	4344      	muls	r4, r0
    6946:	e7ea      	b.n	691e <expr_level_2+0xe>
        else if (peeked == '%'){
    6948:	2925      	cmp	r1, #37	; 0x25
    694a:	d105      	bne.n	6958 <expr_level_2+0x48>
            result %= expr_level_3(e);
    694c:	47b0      	blx	r6
    694e:	fb94 f3f0 	sdiv	r3, r4, r0
    6952:	fb03 4410 	mls	r4, r3, r0, r4
    6956:	e7e2      	b.n	691e <expr_level_2+0xe>
            result /= expr_level_3(e);
    6958:	47b0      	blx	r6
    695a:	fb94 f4f0 	sdiv	r4, r4, r0
    695e:	e7de      	b.n	691e <expr_level_2+0xe>
    6960:	000068ad 	.word	0x000068ad

00006964 <expr_level_1>:
{
    6964:	b570      	push	{r4, r5, r6, lr}
    int result = expr_level_2(e);
    6966:	4e0b      	ldr	r6, [pc, #44]	; (6994 <expr_level_1+0x30>)
{
    6968:	4605      	mov	r5, r0
    int result = expr_level_2(e);
    696a:	47b0      	blx	r6
    696c:	4604      	mov	r4, r0
    return **e;
    696e:	682b      	ldr	r3, [r5, #0]
    6970:	781a      	ldrb	r2, [r3, #0]
    while (peek(e) == '+' || peek(e) == '-')
    6972:	2a2b      	cmp	r2, #43	; 0x2b
    6974:	d003      	beq.n	697e <expr_level_1+0x1a>
    6976:	2a2d      	cmp	r2, #45	; 0x2d
    6978:	d001      	beq.n	697e <expr_level_1+0x1a>
}
    697a:	4620      	mov	r0, r4
    697c:	bd70      	pop	{r4, r5, r6, pc}
    ++*e;
    697e:	3301      	adds	r3, #1
        if (get(e) == '+')
    6980:	2a2b      	cmp	r2, #43	; 0x2b
    ++*e;
    6982:	602b      	str	r3, [r5, #0]
            result += expr_level_2(e);
    6984:	4628      	mov	r0, r5
        if (get(e) == '+')
    6986:	d102      	bne.n	698e <expr_level_1+0x2a>
            result += expr_level_2(e);
    6988:	47b0      	blx	r6
    698a:	4404      	add	r4, r0
    698c:	e7ef      	b.n	696e <expr_level_1+0xa>
            result -= expr_level_2(e);
    698e:	47b0      	blx	r6
    6990:	1a24      	subs	r4, r4, r0
    6992:	e7ec      	b.n	696e <expr_level_1+0xa>
    6994:	00006911 	.word	0x00006911

00006998 <insertTo>:


    return expression_inner(&str);
}

void insertTo(char* start,int length,char* that){
    6998:	b570      	push	{r4, r5, r6, lr}
    699a:	b09a      	sub	sp, #104	; 0x68
    699c:	4604      	mov	r4, r0
    
    char ending[100] = {0};
    699e:	4b0b      	ldr	r3, [pc, #44]	; (69cc <insertTo+0x34>)
void insertTo(char* start,int length,char* that){
    69a0:	4615      	mov	r5, r2
    69a2:	460e      	mov	r6, r1
    char ending[100] = {0};
    69a4:	2260      	movs	r2, #96	; 0x60
    69a6:	2100      	movs	r1, #0
    69a8:	a802      	add	r0, sp, #8
    69aa:	9101      	str	r1, [sp, #4]
    69ac:	4798      	blx	r3
    
    //printf("insertTo: Hova: %s Milyen hosszú helyre: %d Mit: %s\n", start, length, that);
    
    sprintf(ending,"%s",start+length);
    69ae:	19a1      	adds	r1, r4, r6
    69b0:	a801      	add	r0, sp, #4
    69b2:	4e07      	ldr	r6, [pc, #28]	; (69d0 <insertTo+0x38>)
    69b4:	47b0      	blx	r6
    sprintf(start,"%s",that);
    69b6:	4629      	mov	r1, r5
    69b8:	4620      	mov	r0, r4
    69ba:	47b0      	blx	r6
    sprintf(start+strlen(that),"%s",ending);
    69bc:	4b05      	ldr	r3, [pc, #20]	; (69d4 <insertTo+0x3c>)
    69be:	4628      	mov	r0, r5
    69c0:	4798      	blx	r3
    69c2:	a901      	add	r1, sp, #4
    69c4:	4420      	add	r0, r4
    69c6:	47b0      	blx	r6
}
    69c8:	b01a      	add	sp, #104	; 0x68
    69ca:	bd70      	pop	{r4, r5, r6, pc}
    69cc:	000147c5 	.word	0x000147c5
    69d0:	00014cfb 	.word	0x00014cfb
    69d4:	00014d0b 	.word	0x00014d0b

000069d8 <brack_len>:
        // START: SUKU
    
    int nyitCount = 0;
    int zarCount = 0;
    
    for(int i=0; i<maxLen; i++){
    69d8:	2300      	movs	r3, #0
int brack_len(char* funcDesc,int maxLen){ //pl.: almafa(6*(2+2))*45
    69da:	b530      	push	{r4, r5, lr}
    int nyitCount = 0;
    69dc:	461a      	mov	r2, r3
    int zarCount = 0;
    69de:	461c      	mov	r4, r3
    for(int i=0; i<maxLen; i++){
    69e0:	428b      	cmp	r3, r1
    69e2:	da0c      	bge.n	69fe <brack_len+0x26>
        
        if (funcDesc[i] == '('){
    69e4:	5cc5      	ldrb	r5, [r0, r3]
    69e6:	2d28      	cmp	r5, #40	; 0x28
    69e8:	f103 0301 	add.w	r3, r3, #1
    69ec:	d101      	bne.n	69f2 <brack_len+0x1a>
            
            nyitCount++;
    69ee:	3201      	adds	r2, #1
    69f0:	e7f6      	b.n	69e0 <brack_len+0x8>
        }
        else if (funcDesc[i] == ')'){
    69f2:	2d29      	cmp	r5, #41	; 0x29
    69f4:	d1f4      	bne.n	69e0 <brack_len+0x8>
            zarCount++;
    69f6:	3401      	adds	r4, #1
            
            if (zarCount == nyitCount){
    69f8:	42a2      	cmp	r2, r4
    69fa:	d1f1      	bne.n	69e0 <brack_len+0x8>
                return i+1;
    69fc:	4618      	mov	r0, r3
            }
        }
        
    }
}
    69fe:	bd30      	pop	{r4, r5, pc}

00006a00 <calcSubFnc>:



void calcSubFnc(char* startposition){
    6a00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    uint8_t debug_level = 0; 

    char* fName = startposition;
    char* fNameEnd = strstr(fName,"(");
    6a04:	4b82      	ldr	r3, [pc, #520]	; (6c10 <calcSubFnc+0x210>)
void calcSubFnc(char* startposition){
    6a06:	b0ab      	sub	sp, #172	; 0xac
    char* fNameEnd = strstr(fName,"(");
    6a08:	2128      	movs	r1, #40	; 0x28
void calcSubFnc(char* startposition){
    6a0a:	4680      	mov	r8, r0
    char* fNameEnd = strstr(fName,"(");
    6a0c:	4798      	blx	r3


    if (debug_level) printf("FNC name: ");
    if (debug_level) delay_ms(1);

    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6a0e:	eba0 0208 	sub.w	r2, r0, r8
    char* fNameEnd = strstr(fName,"(");
    6a12:	4681      	mov	r9, r0
    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6a14:	2300      	movs	r3, #0
    6a16:	9200      	str	r2, [sp, #0]
    6a18:	9900      	ldr	r1, [sp, #0]
    6a1a:	b2da      	uxtb	r2, r3
    6a1c:	428a      	cmp	r2, r1
    6a1e:	f103 0301 	add.w	r3, r3, #1
    6a22:	dbf9      	blt.n	6a18 <calcSubFnc+0x18>
    }

    if (debug_level) printf("\r\n");
    if (debug_level) delay_ms(1);
    
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6a24:	4b7b      	ldr	r3, [pc, #492]	; (6c14 <calcSubFnc+0x214>)
    
    if (debug_level) printf("calcSubFnc Maxoffset: %d  ## \r\n", max_offset);
    if (debug_level) delay_ms(5);;
    
    int param_expr_results[10] = {0};
    6a26:	4f7c      	ldr	r7, [pc, #496]	; (6c18 <calcSubFnc+0x218>)
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6a28:	4648      	mov	r0, r9
    6a2a:	4798      	blx	r3
    6a2c:	4b7b      	ldr	r3, [pc, #492]	; (6c1c <calcSubFnc+0x21c>)
    6a2e:	4601      	mov	r1, r0
    6a30:	4648      	mov	r0, r9
    6a32:	4798      	blx	r3
    int param_expr_results[10] = {0};
    6a34:	2228      	movs	r2, #40	; 0x28
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6a36:	1e86      	subs	r6, r0, #2
    int param_expr_results[10] = {0};
    6a38:	2100      	movs	r1, #0
    6a3a:	a807      	add	r0, sp, #28
    6a3c:	47b8      	blx	r7
    char* comma = strstr(start, ",");
    int commaoffset = -1;
    
    
    
    for (int i=0; i<max_offset; i=i){
    6a3e:	2500      	movs	r5, #0
    int param_expr_results_count = 0;
    6a40:	462c      	mov	r4, r5
    for (int i=0; i<max_offset; i=i){
    6a42:	42b5      	cmp	r5, r6
    6a44:	da2a      	bge.n	6a9c <calcSubFnc+0x9c>
    6a46:	eb09 0a05 	add.w	sl, r9, r5
    6a4a:	4652      	mov	r2, sl
    6a4c:	46ab      	mov	fp, r5
        
        int commaoffset = -1;
        
        for(int j=i; j<max_offset; j++){
            
            if (start[j] == ','){
    6a4e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    6a52:	f8cd b004 	str.w	fp, [sp, #4]
    6a56:	292c      	cmp	r1, #44	; 0x2c
    6a58:	f10b 0b01 	add.w	fp, fp, #1
    6a5c:	f000 80cc 	beq.w	6bf8 <calcSubFnc+0x1f8>
        for(int j=i; j<max_offset; j++){
    6a60:	455e      	cmp	r6, fp
    6a62:	dcf4      	bgt.n	6a4e <calcSubFnc+0x4e>
 
        if (commaoffset==-1){
            
           // printf("No more commas! \r\n");
            
            char param_expr[20] = {0};
    6a64:	f04f 0900 	mov.w	r9, #0
    6a68:	4649      	mov	r1, r9
    6a6a:	2210      	movs	r2, #16
    6a6c:	a812      	add	r0, sp, #72	; 0x48
    6a6e:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
            
            for (int j=0; j<(max_offset-i); j++){
    6a72:	1b75      	subs	r5, r6, r5
            char param_expr[20] = {0};
    6a74:	47b8      	blx	r7
            for (int j=0; j<(max_offset-i); j++){
    6a76:	4649      	mov	r1, r9
    6a78:	ab11      	add	r3, sp, #68	; 0x44
    6a7a:	e003      	b.n	6a84 <calcSubFnc+0x84>
                param_expr[j] = start[i+j];
    6a7c:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
    6a80:	545a      	strb	r2, [r3, r1]
            for (int j=0; j<(max_offset-i); j++){
    6a82:	3101      	adds	r1, #1
    6a84:	428d      	cmp	r5, r1
    6a86:	dcf9      	bgt.n	6a7c <calcSubFnc+0x7c>
            }
            
            if (debug_level) printf("Parameter: \"%s\", ", param_expr);
            if (debug_level) delay_ms(2);
            
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6a88:	9304      	str	r3, [sp, #16]
    int result = expr_level_0(e);
    6a8a:	a804      	add	r0, sp, #16
    6a8c:	4b64      	ldr	r3, [pc, #400]	; (6c20 <calcSubFnc+0x220>)
    6a8e:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6a90:	ab2a      	add	r3, sp, #168	; 0xa8
    6a92:	eb03 0384 	add.w	r3, r3, r4, lsl #2
            
            
            if (debug_level) printf("Result: \"%d\" \r\n", param_expr_results[param_expr_results_count]);
            if (debug_level) delay_ms(2);
            
            param_expr_results_count++;
    6a96:	3401      	adds	r4, #1
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6a98:	f843 0c8c 	str.w	r0, [r3, #-140]
    
    
    // START: CALC BUILTIN


    char justName[10] = {0};
    6a9c:	2300      	movs	r3, #0
    6a9e:	aa04      	add	r2, sp, #16
    6aa0:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6aa4:	f8ad 3018 	strh.w	r3, [sp, #24]
    
    for (int i=0; i<9; i++){
    6aa8:	f108 0008 	add.w	r0, r8, #8
    6aac:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    6ab0:	4693      	mov	fp, r2
        
        if (fName[i] == '('){
    6ab2:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    6ab6:	2928      	cmp	r1, #40	; 0x28
    6ab8:	d127      	bne.n	6b0a <calcSubFnc+0x10a>
        }
        
    }

    
    if(strcmp(justName,"abs")==0){
    6aba:	495a      	ldr	r1, [pc, #360]	; (6c24 <calcSubFnc+0x224>)
    6abc:	4d5a      	ldr	r5, [pc, #360]	; (6c28 <calcSubFnc+0x228>)
    6abe:	f8df a19c 	ldr.w	sl, [pc, #412]	; 6c5c <calcSubFnc+0x25c>
    6ac2:	4658      	mov	r0, fp
    6ac4:	47a8      	blx	r5
    6ac6:	f10d 0944 	add.w	r9, sp, #68	; 0x44
    6aca:	b318      	cbz	r0, 6b14 <calcSubFnc+0x114>
        resultOfFnc = abs(param_expr_results[0]);
    }
    else if(strcmp(justName,"six")==0){
    6acc:	4957      	ldr	r1, [pc, #348]	; (6c2c <calcSubFnc+0x22c>)
    6ace:	4658      	mov	r0, fp
    6ad0:	47a8      	blx	r5
    6ad2:	2800      	cmp	r0, #0
    6ad4:	f000 808e 	beq.w	6bf4 <calcSubFnc+0x1f4>
        resultOfFnc = 666666;
    }
    else if(strcmp(justName,"add")==0){
    6ad8:	4955      	ldr	r1, [pc, #340]	; (6c30 <calcSubFnc+0x230>)
    6ada:	4658      	mov	r0, fp
    6adc:	47a8      	blx	r5
    6ade:	2800      	cmp	r0, #0
    6ae0:	d130      	bne.n	6b44 <calcSubFnc+0x144>
        resultOfFnc = param_expr_results[0] + param_expr_results[1];
    6ae2:	e9dd 5307 	ldrd	r5, r3, [sp, #28]
    6ae6:	441d      	add	r5, r3
    6ae8:	e018      	b.n	6b1c <calcSubFnc+0x11c>
                param_expr[j] = start[i+j];
    6aea:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
    6aee:	5488      	strb	r0, [r1, r2]
            for (int j=0; j<commaoffset-i; j++){
    6af0:	3201      	adds	r2, #1
    6af2:	4295      	cmp	r5, r2
    6af4:	dcf9      	bgt.n	6aea <calcSubFnc+0xea>
    int result = expr_level_0(e);
    6af6:	4b4a      	ldr	r3, [pc, #296]	; (6c20 <calcSubFnc+0x220>)
    6af8:	9104      	str	r1, [sp, #16]
    6afa:	a804      	add	r0, sp, #16
    6afc:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6afe:	ab07      	add	r3, sp, #28
    6b00:	465d      	mov	r5, fp
    6b02:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
            param_expr_results_count++;
    6b06:	3401      	adds	r4, #1
    for (int i=0; i<max_offset; i=i){
    6b08:	e79b      	b.n	6a42 <calcSubFnc+0x42>
    for (int i=0; i<9; i++){
    6b0a:	4283      	cmp	r3, r0
            justName[i] = fName[i];
    6b0c:	f802 1b01 	strb.w	r1, [r2], #1
    for (int i=0; i<9; i++){
    6b10:	d1cf      	bne.n	6ab2 <calcSubFnc+0xb2>
    6b12:	e7d2      	b.n	6aba <calcSubFnc+0xba>
        resultOfFnc = abs(param_expr_results[0]);
    6b14:	9d07      	ldr	r5, [sp, #28]
    6b16:	2d00      	cmp	r5, #0
    6b18:	bfb8      	it	lt
    6b1a:	426d      	neglt	r5, r5
    
    //printf("resultOfFnc: %d\n", resultOfFnc);
    

    
    char buff[100] = {0};
    6b1c:	2100      	movs	r1, #0
    6b1e:	2260      	movs	r2, #96	; 0x60
    6b20:	a812      	add	r0, sp, #72	; 0x48
    6b22:	9111      	str	r1, [sp, #68]	; 0x44
    6b24:	47b8      	blx	r7
    
    sprintf(buff,"(%d)",resultOfFnc); //HEX para, sign para
    6b26:	462a      	mov	r2, r5
    6b28:	4942      	ldr	r1, [pc, #264]	; (6c34 <calcSubFnc+0x234>)
    6b2a:	4648      	mov	r0, r9
    6b2c:	47d0      	blx	sl
    
    // hova, milyen hosszan, mit
    insertTo(startposition,(fNameEnd-fName)+max_offset+2,buff);
    6b2e:	9b00      	ldr	r3, [sp, #0]
    6b30:	4433      	add	r3, r6
    6b32:	4619      	mov	r1, r3
    6b34:	464a      	mov	r2, r9
    6b36:	4b40      	ldr	r3, [pc, #256]	; (6c38 <calcSubFnc+0x238>)
    6b38:	3102      	adds	r1, #2
    6b3a:	4640      	mov	r0, r8
    6b3c:	4798      	blx	r3
    
        
    //printf(" @@ debug: %s @@\n", startposition);
}
    6b3e:	b02b      	add	sp, #172	; 0xac
    6b40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    6b44:	493d      	ldr	r1, [pc, #244]	; (6c3c <calcSubFnc+0x23c>)
    6b46:	4658      	mov	r0, fp
    6b48:	47a8      	blx	r5
    6b4a:	b120      	cbz	r0, 6b56 <calcSubFnc+0x156>
    6b4c:	493c      	ldr	r1, [pc, #240]	; (6c40 <calcSubFnc+0x240>)
    6b4e:	4658      	mov	r0, fp
    6b50:	47a8      	blx	r5
    6b52:	2800      	cmp	r0, #0
    6b54:	d13e      	bne.n	6bd4 <calcSubFnc+0x1d4>
        char fmt_str[] = "%02x";
    6b56:	4b3b      	ldr	r3, [pc, #236]	; (6c44 <calcSubFnc+0x244>)
        if (param_expr_results_count>1){
    6b58:	2c01      	cmp	r4, #1
        char fmt_str[] = "%02x";
    6b5a:	6818      	ldr	r0, [r3, #0]
    6b5c:	791b      	ldrb	r3, [r3, #4]
    6b5e:	9002      	str	r0, [sp, #8]
    6b60:	f88d 300c 	strb.w	r3, [sp, #12]
        if (param_expr_results_count>1){
    6b64:	dd0a      	ble.n	6b7c <calcSubFnc+0x17c>
            if (param_expr_results[param_expr_results_count-1]<=8){
    6b66:	ab2a      	add	r3, sp, #168	; 0xa8
    6b68:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    6b6c:	f853 3c90 	ldr.w	r3, [r3, #-144]
    6b70:	2b08      	cmp	r3, #8
                fmt_str[2] = param_expr_results[param_expr_results_count-1]+'0';
    6b72:	bfd4      	ite	le
    6b74:	3330      	addle	r3, #48	; 0x30
                fmt_str[2] = 8+'0';
    6b76:	2338      	movgt	r3, #56	; 0x38
    6b78:	f88d 300a 	strb.w	r3, [sp, #10]
        uint8_t temp_array[20] = {0};
    6b7c:	2100      	movs	r1, #0
    6b7e:	2210      	movs	r2, #16
    6b80:	a812      	add	r0, sp, #72	; 0x48
    6b82:	9111      	str	r1, [sp, #68]	; 0x44
    6b84:	47b8      	blx	r7
        sprintf(temp_array, fmt_str, param_expr_results[0]);
    6b86:	9d07      	ldr	r5, [sp, #28]
    6b88:	a902      	add	r1, sp, #8
    6b8a:	462a      	mov	r2, r5
    6b8c:	4648      	mov	r0, r9
    6b8e:	47d0      	blx	sl
        if (param_expr_results_count>1){
    6b90:	2c01      	cmp	r4, #1
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6b92:	4a2d      	ldr	r2, [pc, #180]	; (6c48 <calcSubFnc+0x248>)
            temp_array_length = param_expr_results[param_expr_results_count-1];
    6b94:	bfc4      	itt	gt
    6b96:	ab2a      	addgt	r3, sp, #168	; 0xa8
    6b98:	eb03 0484 	addgt.w	r4, r3, r4, lsl #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6b9c:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
            temp_array_length = param_expr_results[param_expr_results_count-1];
    6ba0:	bfc8      	it	gt
    6ba2:	f814 1c90 	ldrbgt.w	r1, [r4, #-144]
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6ba6:	b2d8      	uxtb	r0, r3
    6ba8:	f5c3 73fc 	rsb	r3, r3, #504	; 0x1f8
            temp_array_length = 2; // default print length
    6bac:	bfd8      	it	le
    6bae:	2102      	movle	r1, #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6bb0:	3301      	adds	r3, #1
    6bb2:	1a5b      	subs	r3, r3, r1
    6bb4:	4413      	add	r3, r2
        for (uint8_t i=0; i<temp_array_length; i++){
    6bb6:	2400      	movs	r4, #0
    6bb8:	fa5f fc84 	uxtb.w	ip, r4
    6bbc:	458c      	cmp	ip, r1
    6bbe:	d303      	bcc.n	6bc8 <calcSubFnc+0x1c8>
        expr->output_string_length += temp_array_length;
    6bc0:	4401      	add	r1, r0
    6bc2:	f882 11fa 	strb.w	r1, [r2, #506]	; 0x1fa
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    6bc6:	e7a9      	b.n	6b1c <calcSubFnc+0x11c>
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6bc8:	f819 c004 	ldrb.w	ip, [r9, r4]
    6bcc:	f803 cb01 	strb.w	ip, [r3], #1
        for (uint8_t i=0; i<temp_array_length; i++){
    6bd0:	3401      	adds	r4, #1
    6bd2:	e7f1      	b.n	6bb8 <calcSubFnc+0x1b8>
    else if(strcmp(justName,"if")==0){
    6bd4:	491d      	ldr	r1, [pc, #116]	; (6c4c <calcSubFnc+0x24c>)
    6bd6:	4658      	mov	r0, fp
    6bd8:	47a8      	blx	r5
    6bda:	b928      	cbnz	r0, 6be8 <calcSubFnc+0x1e8>
        if (param_expr_results[0]){
    6bdc:	9b07      	ldr	r3, [sp, #28]
    6bde:	b10b      	cbz	r3, 6be4 <calcSubFnc+0x1e4>
            resultOfFnc = param_expr_results[1];
    6be0:	9d08      	ldr	r5, [sp, #32]
    6be2:	e79b      	b.n	6b1c <calcSubFnc+0x11c>
            resultOfFnc = param_expr_results[2];
    6be4:	9d09      	ldr	r5, [sp, #36]	; 0x24
    6be6:	e799      	b.n	6b1c <calcSubFnc+0x11c>
        printf("Function \"%s\" not found!\n", justName);
    6be8:	4819      	ldr	r0, [pc, #100]	; (6c50 <calcSubFnc+0x250>)
    6bea:	4b1a      	ldr	r3, [pc, #104]	; (6c54 <calcSubFnc+0x254>)
    6bec:	4659      	mov	r1, fp
    6bee:	4798      	blx	r3
        resultOfFnc = 0;
    6bf0:	2500      	movs	r5, #0
    6bf2:	e793      	b.n	6b1c <calcSubFnc+0x11c>
        resultOfFnc = 666666;
    6bf4:	4d18      	ldr	r5, [pc, #96]	; (6c58 <calcSubFnc+0x258>)
    6bf6:	e791      	b.n	6b1c <calcSubFnc+0x11c>
            char param_expr[20] = {0};
    6bf8:	2300      	movs	r3, #0
    6bfa:	4619      	mov	r1, r3
    6bfc:	9311      	str	r3, [sp, #68]	; 0x44
    6bfe:	2210      	movs	r2, #16
    6c00:	4b05      	ldr	r3, [pc, #20]	; (6c18 <calcSubFnc+0x218>)
    6c02:	a812      	add	r0, sp, #72	; 0x48
    6c04:	4798      	blx	r3
            for (int j=0; j<commaoffset-i; j++){
    6c06:	9b01      	ldr	r3, [sp, #4]
    6c08:	2200      	movs	r2, #0
    6c0a:	1b5d      	subs	r5, r3, r5
    6c0c:	a911      	add	r1, sp, #68	; 0x44
    6c0e:	e770      	b.n	6af2 <calcSubFnc+0xf2>
    6c10:	00014ccd 	.word	0x00014ccd
    6c14:	00014d0b 	.word	0x00014d0b
    6c18:	000147c5 	.word	0x000147c5
    6c1c:	000069d9 	.word	0x000069d9
    6c20:	000067f9 	.word	0x000067f9
    6c24:	000160dd 	.word	0x000160dd
    6c28:	00014ce7 	.word	0x00014ce7
    6c2c:	000160e1 	.word	0x000160e1
    6c30:	000160e5 	.word	0x000160e5
    6c34:	0001610c 	.word	0x0001610c
    6c38:	00006999 	.word	0x00006999
    6c3c:	000160e9 	.word	0x000160e9
    6c40:	00016d31 	.word	0x00016d31
    6c44:	00016111 	.word	0x00016111
    6c48:	20013220 	.word	0x20013220
    6c4c:	000160ef 	.word	0x000160ef
    6c50:	000160f2 	.word	0x000160f2
    6c54:	00014925 	.word	0x00014925
    6c58:	000a2c2a 	.word	0x000a2c2a
    6c5c:	00014c8d 	.word	0x00014c8d

00006c60 <char_is_valid_name>:


uint8_t char_is_valid_name(uint8_t ch){


    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_')){
    6c60:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    6c64:	2b09      	cmp	r3, #9
    6c66:	d909      	bls.n	6c7c <char_is_valid_name+0x1c>
    6c68:	f020 0320 	bic.w	r3, r0, #32
    6c6c:	3b41      	subs	r3, #65	; 0x41
    6c6e:	2b19      	cmp	r3, #25
    6c70:	d904      	bls.n	6c7c <char_is_valid_name+0x1c>

                    return 1;
    6c72:	f1a0 035f 	sub.w	r3, r0, #95	; 0x5f
    6c76:	4258      	negs	r0, r3
    6c78:	4158      	adcs	r0, r3
    6c7a:	4770      	bx	lr
    6c7c:	2001      	movs	r0, #1
                }
    
    return 0;


}
    6c7e:	4770      	bx	lr

00006c80 <subst_all_variables_starting_from_the_back>:


void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6c80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c84:	ed2d 8b02 	vpush	{d8}
    uint8_t variable_name_valid = 0;
    

    int izgi = 0;
    int var_end_pos = -1;
    char var_name[10] = {0};
    6c88:	2200      	movs	r2, #0
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6c8a:	b0a1      	sub	sp, #132	; 0x84
    char var_name[10] = {0};
    6c8c:	e9cd 2201 	strd	r2, r2, [sp, #4]
    6c90:	f8df a23c 	ldr.w	sl, [pc, #572]	; 6ed0 <subst_all_variables_starting_from_the_back+0x250>
    6c94:	f8ad 200c 	strh.w	r2, [sp, #12]
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6c98:	460d      	mov	r5, r1
    6c9a:	1846      	adds	r6, r0, r1
    int var_end_pos = -1;
    6c9c:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    uint8_t variable_name_found = 0;
    6ca0:	4611      	mov	r1, r2
    uint8_t function_name_found = 0;
    6ca2:	4691      	mov	r9, r2
    
    if (debug_level) printf("Subst Vars\r\n");
    
    // i must be signed int
    for(int i = len; i>=0; i--){
    6ca4:	2d00      	cmp	r5, #0
    6ca6:	da04      	bge.n	6cb2 <subst_all_variables_starting_from_the_back+0x32>
    if (debug_level ==2) printf("i%d %d %d %d\r\n",i, function_name_found, variable_name_found, variable_name_valid);
    if (debug_level ==2) delay_ms(5);
        
    }
    
}
    6ca8:	b021      	add	sp, #132	; 0x84
    6caa:	ecbd 8b02 	vpop	{d8}
    6cae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (function_name_found){
    6cb2:	ee08 6a10 	vmov	s16, r6
    6cb6:	f816 4901 	ldrb.w	r4, [r6], #-1
    6cba:	4620      	mov	r0, r4
    6cbc:	47d0      	blx	sl
    6cbe:	f1b9 0f00 	cmp.w	r9, #0
    6cc2:	d011      	beq.n	6ce8 <subst_all_variables_starting_from_the_back+0x68>
                function_name_found=0;
    6cc4:	f1b0 0900 	subs.w	r9, r0, #0
    6cc8:	bf18      	it	ne
    6cca:	f04f 0901 	movne.w	r9, #1
        if (variable_name_found){
    6cce:	2900      	cmp	r1, #0
    6cd0:	d144      	bne.n	6d5c <subst_all_variables_starting_from_the_back+0xdc>
                for (int j = 0; j<10; j++){
    6cd2:	2300      	movs	r3, #0
    6cd4:	aa01      	add	r2, sp, #4
                var_name[j] = 0;
    6cd6:	4619      	mov	r1, r3
            for (int j = 0; j<10; j++){
    6cd8:	3301      	adds	r3, #1
    6cda:	2b0a      	cmp	r3, #10
                var_name[j] = 0;
    6cdc:	f802 1b01 	strb.w	r1, [r2], #1
            for (int j = 0; j<10; j++){
    6ce0:	d1fa      	bne.n	6cd8 <subst_all_variables_starting_from_the_back+0x58>
            variable_name_valid = 0;
    6ce2:	2200      	movs	r2, #0
            variable_name_found = 0;
    6ce4:	4611      	mov	r1, r2
    6ce6:	e04c      	b.n	6d82 <subst_all_variables_starting_from_the_back+0x102>
        else if (variable_name_found == 0){
    6ce8:	2900      	cmp	r1, #0
    6cea:	d137      	bne.n	6d5c <subst_all_variables_starting_from_the_back+0xdc>
            if  (char_is_valid_name(expr_string[i])){
    6cec:	2800      	cmp	r0, #0
    6cee:	d0f0      	beq.n	6cd2 <subst_all_variables_starting_from_the_back+0x52>
                if (expr_string[i+1] == '('){
    6cf0:	78b3      	ldrb	r3, [r6, #2]
    6cf2:	2b28      	cmp	r3, #40	; 0x28
    6cf4:	f000 80cd 	beq.w	6e92 <subst_all_variables_starting_from_the_back+0x212>
                    if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6cf8:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
                        variable_name_valid = 1; 
    6cfc:	2b09      	cmp	r3, #9
    6cfe:	bf88      	it	hi
    6d00:	2201      	movhi	r2, #1
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6d02:	46ab      	mov	fp, r5
                var_name[var_end_pos-i] = expr_string[i];
    6d04:	ebab 0305 	sub.w	r3, fp, r5
    6d08:	a920      	add	r1, sp, #128	; 0x80
    6d0a:	440b      	add	r3, r1
    6d0c:	f803 4c7c 	strb.w	r4, [r3, #-124]
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6d10:	3c30      	subs	r4, #48	; 0x30
    6d12:	2c09      	cmp	r4, #9
    6d14:	d924      	bls.n	6d60 <subst_all_variables_starting_from_the_back+0xe0>
                if (i==0){
    6d16:	b125      	cbz	r5, 6d22 <subst_all_variables_starting_from_the_back+0xa2>
                    if (!char_is_valid_name(expr_string[i-1])){
    6d18:	7830      	ldrb	r0, [r6, #0]
    6d1a:	47d0      	blx	sl
    6d1c:	2800      	cmp	r0, #0
    6d1e:	f040 80b6 	bne.w	6e8e <subst_all_variables_starting_from_the_back+0x20e>
                    int var_name_len = strlen(var_name);
    6d22:	4b5e      	ldr	r3, [pc, #376]	; (6e9c <subst_all_variables_starting_from_the_back+0x21c>)
    6d24:	a801      	add	r0, sp, #4
    6d26:	4798      	blx	r3
                    char var_name_good[10] = {0};
    6d28:	2300      	movs	r3, #0
    6d2a:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6d2e:	aa01      	add	r2, sp, #4
                    int var_name_len = strlen(var_name);
    6d30:	4680      	mov	r8, r0
                    char var_name_good[10] = {0};
    6d32:	4402      	add	r2, r0
    6d34:	f8ad 3018 	strh.w	r3, [sp, #24]
                    for (int j = 0; j<var_name_len; j++){
    6d38:	a904      	add	r1, sp, #16
                        var_name_good[j+1] = 0;
    6d3a:	4618      	mov	r0, r3
                    for (int j = 0; j<var_name_len; j++){
    6d3c:	4543      	cmp	r3, r8
    6d3e:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
    6d42:	db20      	blt.n	6d86 <subst_all_variables_starting_from_the_back+0x106>
                    if (var_name_len == 2 || var_name_len == 3){
    6d44:	f1a8 0302 	sub.w	r3, r8, #2
    6d48:	2b01      	cmp	r3, #1
    6d4a:	d864      	bhi.n	6e16 <subst_all_variables_starting_from_the_back+0x196>
                        if (var_name_good[0] == 'T'){
    6d4c:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6d50:	2b54      	cmp	r3, #84	; 0x54
    6d52:	d15e      	bne.n	6e12 <subst_all_variables_starting_from_the_back+0x192>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6d54:	2301      	movs	r3, #1
                            uint8_t index = 0;
    6d56:	2200      	movs	r2, #0
                            uint8_t is_template_var = 1;
    6d58:	4618      	mov	r0, r3
    6d5a:	e02d      	b.n	6db8 <subst_all_variables_starting_from_the_back+0x138>
            if (char_is_valid_name(expr_string[i])){
    6d5c:	2800      	cmp	r0, #0
    6d5e:	d1d1      	bne.n	6d04 <subst_all_variables_starting_from_the_back+0x84>
            if (variable_name_valid){
    6d60:	2a00      	cmp	r2, #0
    6d62:	d1d8      	bne.n	6d16 <subst_all_variables_starting_from_the_back+0x96>
    6d64:	2401      	movs	r4, #1
            if (!char_is_valid_name(expr_string[i])){
    6d66:	7870      	ldrb	r0, [r6, #1]
    6d68:	47d0      	blx	sl
    6d6a:	4601      	mov	r1, r0
    6d6c:	2800      	cmp	r0, #0
    6d6e:	f040 8093 	bne.w	6e98 <subst_all_variables_starting_from_the_back+0x218>
    6d72:	aa01      	add	r2, sp, #4
                for (int j = 0; j<10; j++){
    6d74:	4603      	mov	r3, r0
    6d76:	3301      	adds	r3, #1
    6d78:	2b0a      	cmp	r3, #10
                    var_name[j] = 0;
    6d7a:	f802 0b01 	strb.w	r0, [r2], #1
                for (int j = 0; j<10; j++){
    6d7e:	d1fa      	bne.n	6d76 <subst_all_variables_starting_from_the_back+0xf6>
                variable_name_valid = 0;
    6d80:	2200      	movs	r2, #0
    for(int i = len; i>=0; i--){
    6d82:	3d01      	subs	r5, #1
    6d84:	e78e      	b.n	6ca4 <subst_all_variables_starting_from_the_back+0x24>
                        var_name_good[j] = var_name[var_name_len-1-j];
    6d86:	7814      	ldrb	r4, [r2, #0]
    6d88:	700c      	strb	r4, [r1, #0]
                        var_name_good[j+1] = 0;
    6d8a:	3301      	adds	r3, #1
    6d8c:	f801 0f01 	strb.w	r0, [r1, #1]!
                    for (int j = 0; j<var_name_len; j++){
    6d90:	e7d4      	b.n	6d3c <subst_all_variables_starting_from_the_back+0xbc>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6d92:	a920      	add	r1, sp, #128	; 0x80
    6d94:	4419      	add	r1, r3
                            for (uint8_t j = 1; j<var_name_len; j++){
    6d96:	3301      	adds	r3, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6d98:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6d9c:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6da0:	2c09      	cmp	r4, #9
                                    index = index*10;
    6da2:	bf9f      	itttt	ls
    6da4:	eb02 0282 	addls.w	r2, r2, r2, lsl #2
    6da8:	eb01 0242 	addls.w	r2, r1, r2, lsl #1
                                    index += var_name_good[j] - '0'; 
    6dac:	3a30      	subls	r2, #48	; 0x30
    6dae:	f002 02ff 	andls.w	r2, r2, #255	; 0xff
                                    is_template_var = 0;
    6db2:	bf88      	it	hi
    6db4:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6db6:	b2db      	uxtb	r3, r3
    6db8:	4543      	cmp	r3, r8
    6dba:	dbea      	blt.n	6d92 <subst_all_variables_starting_from_the_back+0x112>
                            if (is_template_var){
    6dbc:	b358      	cbz	r0, 6e16 <subst_all_variables_starting_from_the_back+0x196>
                                variable_value = grid_expr_state.current_event->parent->template_parameter_list[index];
    6dbe:	4b38      	ldr	r3, [pc, #224]	; (6ea0 <subst_all_variables_starting_from_the_back+0x220>)
    6dc0:	681b      	ldr	r3, [r3, #0]
    6dc2:	685b      	ldr	r3, [r3, #4]
    6dc4:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    6dc8:	68d4      	ldr	r4, [r2, #12]
                    char buff[100] = {0};
    6dca:	4b36      	ldr	r3, [pc, #216]	; (6ea4 <subst_all_variables_starting_from_the_back+0x224>)
    6dcc:	2700      	movs	r7, #0
    6dce:	2260      	movs	r2, #96	; 0x60
    6dd0:	4639      	mov	r1, r7
    6dd2:	a808      	add	r0, sp, #32
    6dd4:	9707      	str	r7, [sp, #28]
    6dd6:	4798      	blx	r3
                    sprintf(buff,"%d",variable_value); // HEX para
    6dd8:	4933      	ldr	r1, [pc, #204]	; (6ea8 <subst_all_variables_starting_from_the_back+0x228>)
    6dda:	4b34      	ldr	r3, [pc, #208]	; (6eac <subst_all_variables_starting_from_the_back+0x22c>)
    6ddc:	4622      	mov	r2, r4
    6dde:	a807      	add	r0, sp, #28
    6de0:	4798      	blx	r3
                    insertTo(found,var_name_len,buff);
    6de2:	4b33      	ldr	r3, [pc, #204]	; (6eb0 <subst_all_variables_starting_from_the_back+0x230>)
    6de4:	aa07      	add	r2, sp, #28
    6de6:	4641      	mov	r1, r8
    6de8:	ee18 0a10 	vmov	r0, s16
    6dec:	4798      	blx	r3
                    for (int j = 0; j<10; j++){
    6dee:	ab01      	add	r3, sp, #4
                    insertTo(found,var_name_len,buff);
    6df0:	461a      	mov	r2, r3
                        var_name[j] = 0;
    6df2:	4639      	mov	r1, r7
                    for (int j = 0; j<10; j++){
    6df4:	3701      	adds	r7, #1
    6df6:	2f0a      	cmp	r7, #10
                        var_name[j] = 0;
    6df8:	f802 1b01 	strb.w	r1, [r2], #1
                    for (int j = 0; j<10; j++){
    6dfc:	d1fa      	bne.n	6df4 <subst_all_variables_starting_from_the_back+0x174>
                    for (int j = 0; j<10; j++){
    6dfe:	2200      	movs	r2, #0
                        var_name[j] = 0;
    6e00:	4611      	mov	r1, r2
                    for (int j = 0; j<10; j++){
    6e02:	3201      	adds	r2, #1
    6e04:	2a0a      	cmp	r2, #10
                        var_name[j] = 0;
    6e06:	f803 1b01 	strb.w	r1, [r3], #1
                    for (int j = 0; j<10; j++){
    6e0a:	d1fa      	bne.n	6e02 <subst_all_variables_starting_from_the_back+0x182>
                    variable_name_valid = 0;
    6e0c:	2200      	movs	r2, #0
    6e0e:	4614      	mov	r4, r2
    6e10:	e7a9      	b.n	6d66 <subst_all_variables_starting_from_the_back+0xe6>
                        else if (var_name_good[0] == 'Z'){
    6e12:	2b5a      	cmp	r3, #90	; 0x5a
    6e14:	d01e      	beq.n	6e54 <subst_all_variables_starting_from_the_back+0x1d4>
                    int32_t variable_value = 1;
    6e16:	2401      	movs	r4, #1
    6e18:	e7d7      	b.n	6dca <subst_all_variables_starting_from_the_back+0x14a>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6e1a:	a920      	add	r1, sp, #128	; 0x80
    6e1c:	4411      	add	r1, r2
                            for (uint8_t j = 1; j<var_name_len; j++){
    6e1e:	3201      	adds	r2, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6e20:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6e24:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6e28:	2c09      	cmp	r4, #9
                                    index = index*10;
    6e2a:	bf9f      	itttt	ls
    6e2c:	eb03 0383 	addls.w	r3, r3, r3, lsl #2
    6e30:	eb01 0343 	addls.w	r3, r1, r3, lsl #1
                                    index += var_name_good[j] - '0'; 
    6e34:	3b30      	subls	r3, #48	; 0x30
    6e36:	f003 03ff 	andls.w	r3, r3, #255	; 0xff
                                    is_template_var = 0;
    6e3a:	bf88      	it	hi
    6e3c:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6e3e:	b2d2      	uxtb	r2, r2
    6e40:	4542      	cmp	r2, r8
    6e42:	dbea      	blt.n	6e1a <subst_all_variables_starting_from_the_back+0x19a>
                            if (is_template_var){
    6e44:	2800      	cmp	r0, #0
    6e46:	d0e6      	beq.n	6e16 <subst_all_variables_starting_from_the_back+0x196>
                                if (index == 0){
    6e48:	b943      	cbnz	r3, 6e5c <subst_all_variables_starting_from_the_back+0x1dc>
                                    variable_value = grid_sys_get_bank_num(&grid_sys_state);
    6e4a:	481a      	ldr	r0, [pc, #104]	; (6eb4 <subst_all_variables_starting_from_the_back+0x234>)
    6e4c:	4b1a      	ldr	r3, [pc, #104]	; (6eb8 <subst_all_variables_starting_from_the_back+0x238>)
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6e4e:	4798      	blx	r3
    6e50:	4604      	mov	r4, r0
    6e52:	e7ba      	b.n	6dca <subst_all_variables_starting_from_the_back+0x14a>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6e54:	2201      	movs	r2, #1
                            uint8_t index = 0;
    6e56:	2300      	movs	r3, #0
                            uint8_t is_template_var = 1;
    6e58:	4610      	mov	r0, r2
    6e5a:	e7f1      	b.n	6e40 <subst_all_variables_starting_from_the_back+0x1c0>
                                else if (index == 1){
    6e5c:	2b01      	cmp	r3, #1
    6e5e:	d102      	bne.n	6e66 <subst_all_variables_starting_from_the_back+0x1e6>
                                    variable_value = grid_sys_get_bank_red(&grid_sys_state);
    6e60:	4814      	ldr	r0, [pc, #80]	; (6eb4 <subst_all_variables_starting_from_the_back+0x234>)
    6e62:	4b16      	ldr	r3, [pc, #88]	; (6ebc <subst_all_variables_starting_from_the_back+0x23c>)
    6e64:	e7f3      	b.n	6e4e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 2){
    6e66:	2b02      	cmp	r3, #2
    6e68:	d102      	bne.n	6e70 <subst_all_variables_starting_from_the_back+0x1f0>
                                    variable_value = grid_sys_get_bank_gre(&grid_sys_state);
    6e6a:	4812      	ldr	r0, [pc, #72]	; (6eb4 <subst_all_variables_starting_from_the_back+0x234>)
    6e6c:	4b14      	ldr	r3, [pc, #80]	; (6ec0 <subst_all_variables_starting_from_the_back+0x240>)
    6e6e:	e7ee      	b.n	6e4e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 3){
    6e70:	2b03      	cmp	r3, #3
    6e72:	d102      	bne.n	6e7a <subst_all_variables_starting_from_the_back+0x1fa>
                                    variable_value = grid_sys_get_bank_blu(&grid_sys_state);
    6e74:	480f      	ldr	r0, [pc, #60]	; (6eb4 <subst_all_variables_starting_from_the_back+0x234>)
    6e76:	4b13      	ldr	r3, [pc, #76]	; (6ec4 <subst_all_variables_starting_from_the_back+0x244>)
    6e78:	e7e9      	b.n	6e4e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 4){
    6e7a:	2b04      	cmp	r3, #4
    6e7c:	d102      	bne.n	6e84 <subst_all_variables_starting_from_the_back+0x204>
                                    variable_value = grid_sys_get_map_state(&grid_sys_state);
    6e7e:	480d      	ldr	r0, [pc, #52]	; (6eb4 <subst_all_variables_starting_from_the_back+0x234>)
    6e80:	4b11      	ldr	r3, [pc, #68]	; (6ec8 <subst_all_variables_starting_from_the_back+0x248>)
    6e82:	e7e4      	b.n	6e4e <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 5){
    6e84:	2b05      	cmp	r3, #5
    6e86:	d1c6      	bne.n	6e16 <subst_all_variables_starting_from_the_back+0x196>
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6e88:	480a      	ldr	r0, [pc, #40]	; (6eb4 <subst_all_variables_starting_from_the_back+0x234>)
    6e8a:	4b10      	ldr	r3, [pc, #64]	; (6ecc <subst_all_variables_starting_from_the_back+0x24c>)
    6e8c:	e7df      	b.n	6e4e <subst_all_variables_starting_from_the_back+0x1ce>
    6e8e:	2201      	movs	r2, #1
    6e90:	e7bd      	b.n	6e0e <subst_all_variables_starting_from_the_back+0x18e>
                    function_name_found = 1;                    
    6e92:	f04f 0901 	mov.w	r9, #1
    6e96:	e71c      	b.n	6cd2 <subst_all_variables_starting_from_the_back+0x52>
    6e98:	4621      	mov	r1, r4
    6e9a:	e772      	b.n	6d82 <subst_all_variables_starting_from_the_back+0x102>
    6e9c:	00014d0b 	.word	0x00014d0b
    6ea0:	20013220 	.word	0x20013220
    6ea4:	000147c5 	.word	0x000147c5
    6ea8:	0001631d 	.word	0x0001631d
    6eac:	00014c8d 	.word	0x00014c8d
    6eb0:	00006999 	.word	0x00006999
    6eb4:	2000f008 	.word	0x2000f008
    6eb8:	00009aaf 	.word	0x00009aaf
    6ebc:	00009ab9 	.word	0x00009ab9
    6ec0:	00009abf 	.word	0x00009abf
    6ec4:	00009ac5 	.word	0x00009ac5
    6ec8:	00009acb 	.word	0x00009acb
    6ecc:	00009acf 	.word	0x00009acf
    6ed0:	00006c61 	.word	0x00006c61

00006ed4 <subst_all_functions_starting_from_the_back>:



void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6ed4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    if (debug_level) printf("Subst Fncs in %s\r\n", expr_string);
    if (debug_level) delay_ms(5);
    
    uint8_t function_name_found = 0;
    uint8_t function_name_valid = 0;
    6ed8:	2200      	movs	r2, #0

            
        }
        else if (function_name_found){
            
            if (char_is_valid_name(expr_string[i])){
    6eda:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6f44 <subst_all_functions_starting_from_the_back+0x70>
                //printf("izgi=%d, i=%d\n", izgi, i);  
                
            }
            else if (function_name_valid){
                
                calcSubFnc(&expr_string[i+1]);
    6ede:	4f18      	ldr	r7, [pc, #96]	; (6f40 <subst_all_functions_starting_from_the_back+0x6c>)
    6ee0:	1844      	adds	r4, r0, r1
void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6ee2:	4605      	mov	r5, r0
    uint8_t function_name_found = 0;
    6ee4:	4611      	mov	r1, r2
    for(int i= len; i>=0; i--){
    6ee6:	ebb4 0a05 	subs.w	sl, r4, r5
    6eea:	d501      	bpl.n	6ef0 <subst_all_functions_starting_from_the_back+0x1c>

        if (debug_level) printf("i%d %d %d\r\n",i, function_name_found, function_name_valid);
        if (debug_level) delay_ms(1);
    }
    
}
    6eec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (expr_string[i] == '(' && function_name_valid == 0){
    6ef0:	7826      	ldrb	r6, [r4, #0]
    6ef2:	2e28      	cmp	r6, #40	; 0x28
    6ef4:	d100      	bne.n	6ef8 <subst_all_functions_starting_from_the_back+0x24>
    6ef6:	b1e2      	cbz	r2, 6f32 <subst_all_functions_starting_from_the_back+0x5e>
        else if (function_name_found){
    6ef8:	b1c9      	cbz	r1, 6f2e <subst_all_functions_starting_from_the_back+0x5a>
            if (char_is_valid_name(expr_string[i])){
    6efa:	4630      	mov	r0, r6
    6efc:	47c0      	blx	r8
    6efe:	4681      	mov	r9, r0
    6f00:	b158      	cbz	r0, 6f1a <subst_all_functions_starting_from_the_back+0x46>
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6f02:	3e30      	subs	r6, #48	; 0x30
    6f04:	2e09      	cmp	r6, #9
    6f06:	d816      	bhi.n	6f36 <subst_all_functions_starting_from_the_back+0x62>
                if (i==0 && function_name_valid){ // start of expr string special case
    6f08:	f1ba 0f00 	cmp.w	sl, #0
    6f0c:	d10f      	bne.n	6f2e <subst_all_functions_starting_from_the_back+0x5a>
    6f0e:	b172      	cbz	r2, 6f2e <subst_all_functions_starting_from_the_back+0x5a>
                    calcSubFnc(&expr_string[i]);
    6f10:	4620      	mov	r0, r4
    6f12:	47b8      	blx	r7
                    function_name_valid = 0;
    6f14:	2200      	movs	r2, #0
                function_name_found = 0;
    6f16:	4611      	mov	r1, r2
    6f18:	e009      	b.n	6f2e <subst_all_functions_starting_from_the_back+0x5a>
            else if (function_name_valid){
    6f1a:	2a00      	cmp	r2, #0
    6f1c:	d0fb      	beq.n	6f16 <subst_all_functions_starting_from_the_back+0x42>
                calcSubFnc(&expr_string[i+1]);
    6f1e:	1c60      	adds	r0, r4, #1
    6f20:	47b8      	blx	r7
                function_name_found = (expr_string[i] == '(');
    6f22:	7821      	ldrb	r1, [r4, #0]
    6f24:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
    6f28:	4259      	negs	r1, r3
    6f2a:	4159      	adcs	r1, r3
                function_name_valid = 0;
    6f2c:	464a      	mov	r2, r9
    for(int i= len; i>=0; i--){
    6f2e:	3c01      	subs	r4, #1
    6f30:	e7d9      	b.n	6ee6 <subst_all_functions_starting_from_the_back+0x12>
            function_name_found = 1;
    6f32:	2101      	movs	r1, #1
    6f34:	e7fb      	b.n	6f2e <subst_all_functions_starting_from_the_back+0x5a>
                if (i==0 && function_name_valid){ // start of expr string special case
    6f36:	f1ba 0f00 	cmp.w	sl, #0
    6f3a:	d0e9      	beq.n	6f10 <subst_all_functions_starting_from_the_back+0x3c>
                    function_name_valid = 1;
    6f3c:	460a      	mov	r2, r1
    6f3e:	e7f6      	b.n	6f2e <subst_all_functions_starting_from_the_back+0x5a>
    6f40:	00006a01 	.word	0x00006a01
    6f44:	00006c61 	.word	0x00006c61

00006f48 <grid_expr_evaluate>:
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6f48:	b573      	push	{r0, r1, r4, r5, r6, lr}
    grid_expr_clear_input(expr);
    6f4a:	4b12      	ldr	r3, [pc, #72]	; (6f94 <grid_expr_evaluate+0x4c>)
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6f4c:	4604      	mov	r4, r0
    6f4e:	460e      	mov	r6, r1
    6f50:	4611      	mov	r1, r2
    grid_expr_clear_input(expr);
    6f52:	4798      	blx	r3
    grid_expr_clear_output(expr);
    6f54:	4b10      	ldr	r3, [pc, #64]	; (6f98 <grid_expr_evaluate+0x50>)
    6f56:	4620      	mov	r0, r4
    6f58:	4798      	blx	r3
    for (uint32_t i=0; i<input_length; i++){
    6f5a:	1d22      	adds	r2, r4, #4
    6f5c:	2300      	movs	r3, #0
    6f5e:	4615      	mov	r5, r2
    6f60:	4299      	cmp	r1, r3
    6f62:	d811      	bhi.n	6f88 <grid_expr_evaluate+0x40>
    expr->input_string_length = input_length;
    6f64:	f884 10fe 	strb.w	r1, [r4, #254]	; 0xfe
    subst_all_variables_starting_from_the_back(expr->input_string, expr->input_string_length);    
    6f68:	4b0c      	ldr	r3, [pc, #48]	; (6f9c <grid_expr_evaluate+0x54>)
    6f6a:	4628      	mov	r0, r5
    6f6c:	4798      	blx	r3
    subst_all_functions_starting_from_the_back(expr->input_string, expr->input_string_length);
    6f6e:	f894 10fe 	ldrb.w	r1, [r4, #254]	; 0xfe
    6f72:	4b0b      	ldr	r3, [pc, #44]	; (6fa0 <grid_expr_evaluate+0x58>)
    6f74:	4628      	mov	r0, r5
    6f76:	4798      	blx	r3
    int result = expr_level_0(e);
    6f78:	4b0a      	ldr	r3, [pc, #40]	; (6fa4 <grid_expr_evaluate+0x5c>)
    6f7a:	9501      	str	r5, [sp, #4]
    6f7c:	a801      	add	r0, sp, #4
    6f7e:	4798      	blx	r3
    expr->return_value = result;
    6f80:	f8c4 01fc 	str.w	r0, [r4, #508]	; 0x1fc
}
    6f84:	b002      	add	sp, #8
    6f86:	bd70      	pop	{r4, r5, r6, pc}
        expr->input_string[i] = input_str[i];
    6f88:	5cf0      	ldrb	r0, [r6, r3]
    6f8a:	f802 0b01 	strb.w	r0, [r2], #1
    for (uint32_t i=0; i<input_length; i++){
    6f8e:	3301      	adds	r3, #1
    6f90:	e7e6      	b.n	6f60 <grid_expr_evaluate+0x18>
    6f92:	bf00      	nop
    6f94:	0000676d 	.word	0x0000676d
    6f98:	00006781 	.word	0x00006781
    6f9c:	00006c81 	.word	0x00006c81
    6fa0:	00006ed5 	.word	0x00006ed5
    6fa4:	000067f9 	.word	0x000067f9

00006fa8 <grid_led_lowlevel_hardware_transfer_complete_cb>:


void grid_led_lowlevel_hardware_transfer_complete_cb(struct _dma_resource *resource){
	

	grid_led_hardware_transfer_done = 1;
    6fa8:	4b01      	ldr	r3, [pc, #4]	; (6fb0 <grid_led_lowlevel_hardware_transfer_complete_cb+0x8>)
    6faa:	2201      	movs	r2, #1
    6fac:	701a      	strb	r2, [r3, #0]
	
	
}
    6fae:	4770      	bx	lr
    6fb0:	2000914c 	.word	0x2000914c

00006fb4 <grid_led_lowlevel_set_color>:
uint8_t grid_led_lowlevel_set_color(struct grid_led_model* mod, uint32_t led_index, uint16_t led_r, uint16_t led_g, uint16_t led_b){
    6fb4:	b510      	push	{r4, lr}
	if (led_index<mod->led_number){
    6fb6:	7844      	ldrb	r4, [r0, #1]
    6fb8:	428c      	cmp	r4, r1
    6fba:	d91c      	bls.n	6ff6 <grid_led_lowlevel_set_color+0x42>
		mod->led_frame_buffer_usable[led_index*3 + 0] = grid_led_color_code[led_g];
    6fbc:	2bff      	cmp	r3, #255	; 0xff
    6fbe:	f04f 040c 	mov.w	r4, #12
    6fc2:	fb04 f101 	mul.w	r1, r4, r1
    6fc6:	bf28      	it	cs
    6fc8:	23ff      	movcs	r3, #255	; 0xff
    6fca:	4c0c      	ldr	r4, [pc, #48]	; (6ffc <grid_led_lowlevel_set_color+0x48>)
    6fcc:	68c0      	ldr	r0, [r0, #12]
    6fce:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6fd2:	5043      	str	r3, [r0, r1]
		mod->led_frame_buffer_usable[led_index*3 + 1] = grid_led_color_code[led_r];
    6fd4:	2aff      	cmp	r2, #255	; 0xff
    6fd6:	bf28      	it	cs
    6fd8:	22ff      	movcs	r2, #255	; 0xff
    6fda:	4401      	add	r1, r0
    6fdc:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
    6fe0:	604b      	str	r3, [r1, #4]
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6fe2:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6fe6:	2bff      	cmp	r3, #255	; 0xff
    6fe8:	bf28      	it	cs
    6fea:	23ff      	movcs	r3, #255	; 0xff
		return 0;
    6fec:	2000      	movs	r0, #0
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    6fee:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    6ff2:	608b      	str	r3, [r1, #8]
}
    6ff4:	bd10      	pop	{r4, pc}
		return -1;		
    6ff6:	20ff      	movs	r0, #255	; 0xff
    6ff8:	e7fc      	b.n	6ff4 <grid_led_lowlevel_set_color+0x40>
    6ffa:	bf00      	nop
    6ffc:	2000fe60 	.word	0x2000fe60

00007000 <grid_led_hardware_init>:


}


void grid_led_hardware_init(struct grid_led_model* mod){
    7000:	b510      	push	{r4, lr}
	
	spi_m_dma_get_io_descriptor(&GRID_LED, &mod->hardware_io_descriptor);
    7002:	4c06      	ldr	r4, [pc, #24]	; (701c <grid_led_hardware_init+0x1c>)
    7004:	4b06      	ldr	r3, [pc, #24]	; (7020 <grid_led_hardware_init+0x20>)
    7006:	f100 0114 	add.w	r1, r0, #20
    700a:	4620      	mov	r0, r4
    700c:	4798      	blx	r3
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    700e:	4620      	mov	r0, r4
    7010:	4a04      	ldr	r2, [pc, #16]	; (7024 <grid_led_hardware_init+0x24>)
    7012:	4b05      	ldr	r3, [pc, #20]	; (7028 <grid_led_hardware_init+0x28>)
	

		
}
    7014:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    7018:	2100      	movs	r1, #0
    701a:	4718      	bx	r3
    701c:	2001ce54 	.word	0x2001ce54
    7020:	0000bdf1 	.word	0x0000bdf1
    7024:	00006fa9 	.word	0x00006fa9
    7028:	0000bdbd 	.word	0x0000bdbd

0000702c <grid_led_get_led_number>:

uint32_t grid_led_get_led_number(struct grid_led_model* mod){

	return mod->led_number;

}
    702c:	7840      	ldrb	r0, [r0, #1]
    702e:	4770      	bx	lr

00007030 <grid_led_tick>:

/** ================== ANIMATION ==================  */


void grid_led_tick(struct grid_led_model* mod){
    7030:	b5f0      	push	{r4, r5, r6, r7, lr}
	

	/** ATOMI - all phase registers must be updated  */
	for (uint8_t j=0; j<mod->led_number; j++){
    7032:	7846      	ldrb	r6, [r0, #1]
    7034:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    7038:	eb06 0282 	add.w	r2, r6, r2, lsl #2
    703c:	2400      	movs	r4, #0
    703e:	270d      	movs	r7, #13
    7040:	b2e3      	uxtb	r3, r4
    7042:	429e      	cmp	r6, r3
    7044:	d800      	bhi.n	7048 <grid_led_tick+0x18>
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
		}	
	}
	/** END */
	
}
    7046:	bdf0      	pop	{r4, r5, r6, r7, pc}
    7048:	6903      	ldr	r3, [r0, #16]
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    704a:	2103      	movs	r1, #3
    704c:	fb07 3304 	mla	r3, r7, r4, r3
    7050:	7add      	ldrb	r5, [r3, #11]
    7052:	f893 c00c 	ldrb.w	ip, [r3, #12]
    7056:	3901      	subs	r1, #1
    7058:	4465      	add	r5, ip
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    705a:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    705e:	72dd      	strb	r5, [r3, #11]
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    7060:	4413      	add	r3, r2
    7062:	d1f5      	bne.n	7050 <grid_led_tick+0x20>
	for (uint8_t j=0; j<mod->led_number; j++){
    7064:	3401      	adds	r4, #1
    7066:	e7eb      	b.n	7040 <grid_led_tick+0x10>

00007068 <grid_led_set_min>:
	grid_led_set_max(mod, num, layer, r, g, b);

}


void grid_led_set_min(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    7068:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r = r;
    706a:	7844      	ldrb	r4, [r0, #1]
    706c:	6900      	ldr	r0, [r0, #16]
    706e:	fb04 1202 	mla	r2, r4, r2, r1
    7072:	240d      	movs	r4, #13
    7074:	4362      	muls	r2, r4
    7076:	1881      	adds	r1, r0, r2
    7078:	5483      	strb	r3, [r0, r2]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g = g;
    707a:	f89d 3008 	ldrb.w	r3, [sp, #8]
    707e:	704b      	strb	r3, [r1, #1]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b = b;	
    7080:	f89d 300c 	ldrb.w	r3, [sp, #12]
    7084:	708b      	strb	r3, [r1, #2]
}
    7086:	bd10      	pop	{r4, pc}

00007088 <grid_led_set_mid>:

void grid_led_set_mid(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    7088:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.r = r;
    708a:	7844      	ldrb	r4, [r0, #1]
    708c:	fb04 1102 	mla	r1, r4, r2, r1
    7090:	6902      	ldr	r2, [r0, #16]
    7092:	200d      	movs	r0, #13
    7094:	fb00 2201 	mla	r2, r0, r1, r2
    7098:	70d3      	strb	r3, [r2, #3]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.g = g;
    709a:	f89d 3008 	ldrb.w	r3, [sp, #8]
    709e:	7113      	strb	r3, [r2, #4]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.b = b;	
    70a0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    70a4:	7153      	strb	r3, [r2, #5]
}
    70a6:	bd10      	pop	{r4, pc}

000070a8 <grid_led_set_max>:

void grid_led_set_max(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    70a8:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r = r;
    70aa:	7844      	ldrb	r4, [r0, #1]
    70ac:	fb04 1102 	mla	r1, r4, r2, r1
    70b0:	6902      	ldr	r2, [r0, #16]
    70b2:	200d      	movs	r0, #13
    70b4:	fb00 2201 	mla	r2, r0, r1, r2
    70b8:	7193      	strb	r3, [r2, #6]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g = g;
    70ba:	f89d 3008 	ldrb.w	r3, [sp, #8]
    70be:	71d3      	strb	r3, [r2, #7]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b = b;	
    70c0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    70c4:	7213      	strb	r3, [r2, #8]
}
    70c6:	bd10      	pop	{r4, pc}

000070c8 <grid_led_set_color>:
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    70c8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    70cc:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
    70d0:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    70d4:	f8df a058 	ldr.w	sl, [pc, #88]	; 7130 <grid_led_set_color+0x68>
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    70d8:	461c      	mov	r4, r3
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    70da:	2314      	movs	r3, #20
    70dc:	fbb9 fcf3 	udiv	ip, r9, r3
    70e0:	f8cd c004 	str.w	ip, [sp, #4]
    70e4:	fbb8 fcf3 	udiv	ip, r8, r3
    70e8:	fbb4 f3f3 	udiv	r3, r4, r3
    70ec:	f8cd c000 	str.w	ip, [sp]
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    70f0:	4605      	mov	r5, r0
    70f2:	460e      	mov	r6, r1
    70f4:	4617      	mov	r7, r2
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    70f6:	47d0      	blx	sl
	grid_led_set_mid(mod, num, layer, r/2, g/2, b/2);
    70f8:	ea4f 0359 	mov.w	r3, r9, lsr #1
    70fc:	9301      	str	r3, [sp, #4]
    70fe:	ea4f 0358 	mov.w	r3, r8, lsr #1
    7102:	9300      	str	r3, [sp, #0]
    7104:	463a      	mov	r2, r7
    7106:	0863      	lsrs	r3, r4, #1
    7108:	4631      	mov	r1, r6
    710a:	4628      	mov	r0, r5
    710c:	f8df a024 	ldr.w	sl, [pc, #36]	; 7134 <grid_led_set_color+0x6c>
    7110:	47d0      	blx	sl
	grid_led_set_max(mod, num, layer, r, g, b);
    7112:	4623      	mov	r3, r4
    7114:	4c05      	ldr	r4, [pc, #20]	; (712c <grid_led_set_color+0x64>)
    7116:	463a      	mov	r2, r7
    7118:	4631      	mov	r1, r6
    711a:	4628      	mov	r0, r5
    711c:	46a4      	mov	ip, r4
    711e:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
}
    7122:	b002      	add	sp, #8
    7124:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_led_set_max(mod, num, layer, r, g, b);
    7128:	4760      	bx	ip
    712a:	bf00      	nop
    712c:	000070a9 	.word	0x000070a9
    7130:	00007069 	.word	0x00007069
    7134:	00007089 	.word	0x00007089

00007138 <grid_led_set_phase>:

void grid_led_set_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    7138:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].pha = val;
    713a:	7844      	ldrb	r4, [r0, #1]
    713c:	fb04 1102 	mla	r1, r4, r2, r1
    7140:	6902      	ldr	r2, [r0, #16]
    7142:	200d      	movs	r0, #13
    7144:	fb00 2101 	mla	r1, r0, r1, r2
    7148:	72cb      	strb	r3, [r1, #11]
}
    714a:	bd10      	pop	{r4, pc}

0000714c <grid_led_set_frequency>:
uint8_t grid_led_get_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer){
	
	return mod->led_smart_buffer[num+(mod->led_number*layer)].pha;
}

void grid_led_set_frequency(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    714c:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].fre = val;
    714e:	7844      	ldrb	r4, [r0, #1]
    7150:	fb04 1102 	mla	r1, r4, r2, r1
    7154:	6902      	ldr	r2, [r0, #16]
    7156:	200d      	movs	r0, #13
    7158:	fb00 2101 	mla	r1, r0, r1, r2
    715c:	730b      	strb	r3, [r1, #12]
}
    715e:	bd10      	pop	{r4, pc}

00007160 <grid_led_buffer_init>:
void grid_led_buffer_init(struct grid_led_model* mod, uint32_t length){
    7160:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7164:	4604      	mov	r4, r0
	mod->led_number = length;
    7166:	7041      	strb	r1, [r0, #1]
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    7168:	b2cd      	uxtb	r5, r1
    716a:	200c      	movs	r0, #12
    716c:	4368      	muls	r0, r5
    716e:	3090      	adds	r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    7170:	4f4c      	ldr	r7, [pc, #304]	; (72a4 <grid_led_buffer_init+0x144>)
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    7172:	6060      	str	r0, [r4, #4]
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    7174:	47b8      	blx	r7
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    7176:	f100 0390 	add.w	r3, r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    717a:	60a0      	str	r0, [r4, #8]
    717c:	4606      	mov	r6, r0
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    717e:	2027      	movs	r0, #39	; 0x27
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    7180:	60e3      	str	r3, [r4, #12]
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    7182:	4368      	muls	r0, r5
    7184:	47b8      	blx	r7
    7186:	6120      	str	r0, [r4, #16]
	if(mod->led_frame_buffer==NULL || mod->led_smart_buffer==NULL){
    7188:	b106      	cbz	r6, 718c <grid_led_buffer_init+0x2c>
    718a:	b900      	cbnz	r0, 718e <grid_led_buffer_init+0x2e>
		while(1){
    718c:	e7fe      	b.n	718c <grid_led_buffer_init+0x2c>
    718e:	2300      	movs	r3, #0
		mod->led_frame_buffer[i] = LED_CODE_R;
    7190:	4619      	mov	r1, r3
    7192:	68a2      	ldr	r2, [r4, #8]
    7194:	54d1      	strb	r1, [r2, r3]
	for (uint8_t i = 0; i<GRID_LED_RESET_LENGTH; i++){
    7196:	3301      	adds	r3, #1
    7198:	2b90      	cmp	r3, #144	; 0x90
    719a:	d1fa      	bne.n	7192 <grid_led_buffer_init+0x32>
	for (uint32_t i = 0; i<mod->led_number; i++){
    719c:	2500      	movs	r5, #0
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    719e:	4f42      	ldr	r7, [pc, #264]	; (72a8 <grid_led_buffer_init+0x148>)
    71a0:	462e      	mov	r6, r5
	for (uint32_t i = 0; i<mod->led_number; i++){
    71a2:	7863      	ldrb	r3, [r4, #1]
    71a4:	429d      	cmp	r5, r3
    71a6:	d30c      	bcc.n	71c2 <grid_led_buffer_init+0x62>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    71a8:	4d40      	ldr	r5, [pc, #256]	; (72ac <grid_led_buffer_init+0x14c>)
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    71aa:	4e41      	ldr	r6, [pc, #260]	; (72b0 <grid_led_buffer_init+0x150>)
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    71ac:	4f41      	ldr	r7, [pc, #260]	; (72b4 <grid_led_buffer_init+0x154>)
    71ae:	f04f 0b00 	mov.w	fp, #0
	for(uint8_t i = 0; i<mod->led_number; i++){
    71b2:	7863      	ldrb	r3, [r4, #1]
    71b4:	fa5f fa8b 	uxtb.w	sl, fp
    71b8:	4553      	cmp	r3, sl
    71ba:	d80a      	bhi.n	71d2 <grid_led_buffer_init+0x72>
}
    71bc:	b003      	add	sp, #12
    71be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    71c2:	2300      	movs	r3, #0
    71c4:	4629      	mov	r1, r5
    71c6:	9600      	str	r6, [sp, #0]
    71c8:	461a      	mov	r2, r3
    71ca:	4620      	mov	r0, r4
    71cc:	47b8      	blx	r7
	for (uint32_t i = 0; i<mod->led_number; i++){
    71ce:	3501      	adds	r5, #1
    71d0:	e7e7      	b.n	71a2 <grid_led_buffer_init+0x42>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    71d2:	2300      	movs	r3, #0
    71d4:	e9cd 3300 	strd	r3, r3, [sp]
    71d8:	2201      	movs	r2, #1
    71da:	4651      	mov	r1, sl
    71dc:	4620      	mov	r0, r4
    71de:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    71e0:	2300      	movs	r3, #0
    71e2:	227f      	movs	r2, #127	; 0x7f
    71e4:	e9cd 2300 	strd	r2, r3, [sp]
    71e8:	4651      	mov	r1, sl
    71ea:	2201      	movs	r2, #1
    71ec:	4620      	mov	r0, r4
    71ee:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    71f0:	2300      	movs	r3, #0
    71f2:	22ff      	movs	r2, #255	; 0xff
    71f4:	e9cd 2300 	strd	r2, r3, [sp]
    71f8:	4651      	mov	r1, sl
    71fa:	2201      	movs	r2, #1
    71fc:	4620      	mov	r0, r4
    71fe:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    7200:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 72b8 <grid_led_buffer_init+0x158>
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    7204:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 72bc <grid_led_buffer_init+0x15c>
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    7208:	2300      	movs	r3, #0
    720a:	2201      	movs	r2, #1
    720c:	4651      	mov	r1, sl
    720e:	4620      	mov	r0, r4
    7210:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    7212:	2300      	movs	r3, #0
    7214:	2201      	movs	r2, #1
    7216:	4651      	mov	r1, sl
    7218:	4620      	mov	r0, r4
    721a:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x00, 0x00);
    721c:	2300      	movs	r3, #0
    721e:	e9cd 3300 	strd	r3, r3, [sp]
    7222:	2202      	movs	r2, #2
    7224:	4651      	mov	r1, sl
    7226:	4620      	mov	r0, r4
    7228:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x7F, 0x00);
    722a:	2300      	movs	r3, #0
    722c:	227f      	movs	r2, #127	; 0x7f
    722e:	e9cd 2300 	strd	r2, r3, [sp]
    7232:	4651      	mov	r1, sl
    7234:	2202      	movs	r2, #2
    7236:	4620      	mov	r0, r4
    7238:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0xFF, 0x00);
    723a:	2300      	movs	r3, #0
    723c:	22ff      	movs	r2, #255	; 0xff
    723e:	e9cd 2300 	strd	r2, r3, [sp]
    7242:	4651      	mov	r1, sl
    7244:	2202      	movs	r2, #2
    7246:	4620      	mov	r0, r4
    7248:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_B, 0);
    724a:	2300      	movs	r3, #0
    724c:	2202      	movs	r2, #2
    724e:	4651      	mov	r1, sl
    7250:	4620      	mov	r0, r4
    7252:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_B, 0);
    7254:	2300      	movs	r3, #0
    7256:	2202      	movs	r2, #2
    7258:	4651      	mov	r1, sl
    725a:	4620      	mov	r0, r4
    725c:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    725e:	2300      	movs	r3, #0
    7260:	461a      	mov	r2, r3
    7262:	e9cd 3300 	strd	r3, r3, [sp]
    7266:	4651      	mov	r1, sl
    7268:	4620      	mov	r0, r4
    726a:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    726c:	2300      	movs	r3, #0
    726e:	461a      	mov	r2, r3
    7270:	e9cd 3300 	strd	r3, r3, [sp]
    7274:	4651      	mov	r1, sl
    7276:	4620      	mov	r0, r4
    7278:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    727a:	2300      	movs	r3, #0
    727c:	461a      	mov	r2, r3
    727e:	e9cd 3300 	strd	r3, r3, [sp]
    7282:	4651      	mov	r1, sl
    7284:	4620      	mov	r0, r4
    7286:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_ALERT, 0);
    7288:	2300      	movs	r3, #0
    728a:	461a      	mov	r2, r3
    728c:	4651      	mov	r1, sl
    728e:	4620      	mov	r0, r4
    7290:	47c8      	blx	r9
		grid_led_set_phase(mod, i, GRID_LED_LAYER_ALERT, 0);
    7292:	2300      	movs	r3, #0
    7294:	461a      	mov	r2, r3
    7296:	4651      	mov	r1, sl
    7298:	4620      	mov	r0, r4
    729a:	47c0      	blx	r8
	for(uint8_t i = 0; i<mod->led_number; i++){
    729c:	f10b 0b01 	add.w	fp, fp, #1
    72a0:	e787      	b.n	71b2 <grid_led_buffer_init+0x52>
    72a2:	bf00      	nop
    72a4:	00014799 	.word	0x00014799
    72a8:	00006fb5 	.word	0x00006fb5
    72ac:	00007069 	.word	0x00007069
    72b0:	00007089 	.word	0x00007089
    72b4:	000070a9 	.word	0x000070a9
    72b8:	0000714d 	.word	0x0000714d
    72bc:	00007139 	.word	0x00007139

000072c0 <grid_led_lowlevel_init>:
uint8_t grid_led_lowlevel_init(struct grid_led_model* mod, uint8_t num){
    72c0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    72c2:	4e29      	ldr	r6, [pc, #164]	; (7368 <grid_led_lowlevel_init+0xa8>)
	for(uint16_t i=0; i<256; i++){
    72c4:	2300      	movs	r3, #0
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    72c6:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
		temp |= (i/2%2)   ? (LED_CODE_O<<28) : (LED_CODE_Z<<28);
    72ca:	f013 0f02 	tst.w	r3, #2
    72ce:	bf0c      	ite	eq
    72d0:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    72d4:	f04f 4560 	movne.w	r5, #3758096384	; 0xe0000000
		temp |= (i/4%2)   ? (LED_CODE_O<<16) : (LED_CODE_Z<<16);
    72d8:	f013 0f04 	tst.w	r3, #4
    72dc:	bf0c      	ite	eq
    72de:	f44f 2400 	moveq.w	r4, #524288	; 0x80000
    72e2:	f44f 2460 	movne.w	r4, #917504	; 0xe0000
		temp |= (i/8%2)   ? (LED_CODE_O<<20) : (LED_CODE_Z<<20);
    72e6:	f013 0f08 	tst.w	r3, #8
    72ea:	ea45 0504 	orr.w	r5, r5, r4
    72ee:	bf0c      	ite	eq
    72f0:	f44f 0400 	moveq.w	r4, #8388608	; 0x800000
    72f4:	f44f 0460 	movne.w	r4, #14680064	; 0xe00000
		temp |= (i/16%2)  ? (LED_CODE_O<<8)  : (LED_CODE_Z<<8);
    72f8:	f013 0f10 	tst.w	r3, #16
    72fc:	ea45 0504 	orr.w	r5, r5, r4
    7300:	bf0c      	ite	eq
    7302:	f44f 6400 	moveq.w	r4, #2048	; 0x800
    7306:	f44f 6460 	movne.w	r4, #3584	; 0xe00
		temp |= (i/32%2)  ? (LED_CODE_O<<12) : (LED_CODE_Z<<12);
    730a:	f013 0f20 	tst.w	r3, #32
    730e:	bf0c      	ite	eq
    7310:	f44f 4200 	moveq.w	r2, #32768	; 0x8000
    7314:	f44f 4260 	movne.w	r2, #57344	; 0xe000
    7318:	432c      	orrs	r4, r5
		temp |= (i/64%2)  ? (LED_CODE_O<<0)  : (LED_CODE_Z<<0);
    731a:	f013 0f40 	tst.w	r3, #64	; 0x40
    731e:	ea44 0402 	orr.w	r4, r4, r2
    7322:	bf0c      	ite	eq
    7324:	2208      	moveq	r2, #8
    7326:	220e      	movne	r2, #14
    7328:	4314      	orrs	r4, r2
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    732a:	09da      	lsrs	r2, r3, #7
    732c:	bf14      	ite	ne
    732e:	22e0      	movne	r2, #224	; 0xe0
    7330:	2280      	moveq	r2, #128	; 0x80
	for(uint16_t i=0; i<256; i++){
    7332:	3301      	adds	r3, #1
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    7334:	4322      	orrs	r2, r4
	for(uint16_t i=0; i<256; i++){
    7336:	b29b      	uxth	r3, r3
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    7338:	433a      	orrs	r2, r7
	for(uint16_t i=0; i<256; i++){
    733a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		grid_led_color_code[i] = temp;
    733e:	f846 2b04 	str.w	r2, [r6], #4
	for(uint16_t i=0; i<256; i++){
    7342:	d108      	bne.n	7356 <grid_led_lowlevel_init+0x96>
	grid_led_buffer_init(mod, num);		
    7344:	4b09      	ldr	r3, [pc, #36]	; (736c <grid_led_lowlevel_init+0xac>)
    7346:	9001      	str	r0, [sp, #4]
    7348:	4798      	blx	r3
	grid_led_hardware_init(mod);
    734a:	9801      	ldr	r0, [sp, #4]
    734c:	4b08      	ldr	r3, [pc, #32]	; (7370 <grid_led_lowlevel_init+0xb0>)
    734e:	4798      	blx	r3
}
    7350:	2000      	movs	r0, #0
    7352:	b003      	add	sp, #12
    7354:	bdf0      	pop	{r4, r5, r6, r7, pc}
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    7356:	f013 0f01 	tst.w	r3, #1
    735a:	bf14      	ite	ne
    735c:	f04f 6760 	movne.w	r7, #234881024	; 0xe000000
    7360:	f04f 6700 	moveq.w	r7, #134217728	; 0x8000000
    7364:	e7b1      	b.n	72ca <grid_led_lowlevel_init+0xa>
    7366:	bf00      	nop
    7368:	2000fe60 	.word	0x2000fe60
    736c:	00007161 	.word	0x00007161
    7370:	00007001 	.word	0x00007001

00007374 <grid_led_lowlevel_render>:


void grid_led_lowlevel_render(struct grid_led_model* mod, uint32_t num){
    7374:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    7378:	7847      	ldrb	r7, [r0, #1]
		uint8_t layer = i;
				
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
		uint8_t min_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g;
		uint8_t min_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b;
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    737a:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 741c <grid_led_lowlevel_render+0xa8>
    737e:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    7382:	eb07 0783 	add.w	r7, r7, r3, lsl #2
    7386:	6903      	ldr	r3, [r0, #16]
	uint32_t mix_b = 0;
    7388:	2500      	movs	r5, #0
    738a:	240d      	movs	r4, #13
    738c:	fb04 3401 	mla	r4, r4, r1, r3
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
    7390:	2603      	movs	r6, #3
	uint32_t mix_g = 0;
    7392:	462b      	mov	r3, r5
	uint32_t mix_r = 0;
    7394:	462a      	mov	r2, r5
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    7396:	f894 900b 	ldrb.w	r9, [r4, #11]
		uint8_t max_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r;
		uint8_t max_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g;
		uint8_t max_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b;
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
				
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    739a:	f894 b003 	ldrb.w	fp, [r4, #3]
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    739e:	f818 e009 	ldrb.w	lr, [r8, r9]
		uint8_t mid_a = mid_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    73a2:	44c1      	add	r9, r8
    73a4:	3e01      	subs	r6, #1
    73a6:	f899 a100 	ldrb.w	sl, [r9, #256]	; 0x100
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    73aa:	f899 c200 	ldrb.w	ip, [r9, #512]	; 0x200
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    73ae:	f894 9000 	ldrb.w	r9, [r4]
    73b2:	fb1b fb0a 	smulbb	fp, fp, sl
    73b6:	fb09 bb0e 	mla	fp, r9, lr, fp
    73ba:	f894 9006 	ldrb.w	r9, [r4, #6]
    73be:	fb09 b90c 	mla	r9, r9, ip, fp
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    73c2:	f894 b004 	ldrb.w	fp, [r4, #4]
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    73c6:	444a      	add	r2, r9
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    73c8:	f894 9001 	ldrb.w	r9, [r4, #1]
    73cc:	fb1b fb0a 	smulbb	fp, fp, sl
    73d0:	fb09 bb0e 	mla	fp, r9, lr, fp
    73d4:	f894 9007 	ldrb.w	r9, [r4, #7]
    73d8:	fb09 b90c 	mla	r9, r9, ip, fp
    73dc:	444b      	add	r3, r9
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    73de:	f894 9005 	ldrb.w	r9, [r4, #5]
    73e2:	f894 b002 	ldrb.w	fp, [r4, #2]
    73e6:	fb19 f90a 	smulbb	r9, r9, sl
    73ea:	fb0b 9e0e 	mla	lr, fp, lr, r9
    73ee:	f894 9008 	ldrb.w	r9, [r4, #8]
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    73f2:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    73f6:	fb09 ec0c 	mla	ip, r9, ip, lr
    73fa:	4465      	add	r5, ip
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    73fc:	443c      	add	r4, r7
    73fe:	d1ca      	bne.n	7396 <grid_led_lowlevel_render+0x22>

	mix_r = (mix_r)/2/256;
	mix_g = (mix_g)/2/256;
	mix_b = (mix_b)/2/256;
				
	grid_led_lowlevel_set_color(mod, num, mix_r, mix_g, mix_b);
    7400:	f3c5 254f 	ubfx	r5, r5, #9, #16
    7404:	4c04      	ldr	r4, [pc, #16]	; (7418 <grid_led_lowlevel_render+0xa4>)
    7406:	9500      	str	r5, [sp, #0]
    7408:	f3c3 234f 	ubfx	r3, r3, #9, #16
    740c:	f3c2 224f 	ubfx	r2, r2, #9, #16
    7410:	47a0      	blx	r4
	
}
    7412:	b003      	add	sp, #12
    7414:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7418:	00006fb5 	.word	0x00006fb5
    741c:	20000008 	.word	0x20000008

00007420 <grid_led_lowlevel_render_all>:


void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7420:	b570      	push	{r4, r5, r6, lr}
	
	for (uint32_t i=0; i<mod->led_number; i++){
		
		grid_led_lowlevel_render(mod, i);
    7422:	4e06      	ldr	r6, [pc, #24]	; (743c <grid_led_lowlevel_render_all+0x1c>)
void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7424:	4605      	mov	r5, r0
	for (uint32_t i=0; i<mod->led_number; i++){
    7426:	2400      	movs	r4, #0
    7428:	786b      	ldrb	r3, [r5, #1]
    742a:	42a3      	cmp	r3, r4
    742c:	d800      	bhi.n	7430 <grid_led_lowlevel_render_all+0x10>
	}
	
}
    742e:	bd70      	pop	{r4, r5, r6, pc}
		grid_led_lowlevel_render(mod, i);
    7430:	4621      	mov	r1, r4
    7432:	4628      	mov	r0, r5
    7434:	47b0      	blx	r6
	for (uint32_t i=0; i<mod->led_number; i++){
    7436:	3401      	adds	r4, #1
    7438:	e7f6      	b.n	7428 <grid_led_lowlevel_render_all+0x8>
    743a:	bf00      	nop
    743c:	00007375 	.word	0x00007375

00007440 <grid_led_lowlevel_hardware_start_transfer>:
			
	}
	
}

void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    7440:	b510      	push	{r4, lr}
	
	// SEND DATA TO LEDs
	grid_led_hardware_transfer_done = 0;
    7442:	4b07      	ldr	r3, [pc, #28]	; (7460 <grid_led_lowlevel_hardware_start_transfer+0x20>)
void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    7444:	4604      	mov	r4, r0
	grid_led_hardware_transfer_done = 0;
    7446:	2200      	movs	r2, #0
    7448:	701a      	strb	r2, [r3, #0]
	spi_m_dma_enable(&GRID_LED);
    744a:	4806      	ldr	r0, [pc, #24]	; (7464 <grid_led_lowlevel_hardware_start_transfer+0x24>)
    744c:	4b06      	ldr	r3, [pc, #24]	; (7468 <grid_led_lowlevel_hardware_start_transfer+0x28>)
    744e:	4798      	blx	r3
			
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    7450:	88a2      	ldrh	r2, [r4, #4]
    7452:	68a1      	ldr	r1, [r4, #8]
    7454:	6960      	ldr	r0, [r4, #20]
    7456:	4b05      	ldr	r3, [pc, #20]	; (746c <grid_led_lowlevel_hardware_start_transfer+0x2c>)

}
    7458:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    745c:	4718      	bx	r3
    745e:	bf00      	nop
    7460:	2000914c 	.word	0x2000914c
    7464:	2001ce54 	.word	0x2001ce54
    7468:	0000bd95 	.word	0x0000bd95
    746c:	0000b495 	.word	0x0000b495

00007470 <grid_module_common_init>:

	
/* ============================== GRID_MODULE_INIT() ================================ */


void grid_module_common_init(void){
    7470:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	grid_ui_model_init(&grid_core_state, 1);
    7474:	4d70      	ldr	r5, [pc, #448]	; (7638 <grid_module_common_init+0x1c8>)
    7476:	4b71      	ldr	r3, [pc, #452]	; (763c <grid_module_common_init+0x1cc>)
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
	
		
	if (1){	// INIT CORE_STATE->hearbeat	
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7478:	f8df 9240 	ldr.w	r9, [pc, #576]	; 76bc <grid_module_common_init+0x24c>
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
		payload_length = strlen(payload_template);
    747c:	f8df 8240 	ldr.w	r8, [pc, #576]	; 76c0 <grid_module_common_init+0x250>
	
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    7480:	4f6f      	ldr	r7, [pc, #444]	; (7640 <grid_module_common_init+0x1d0>)
		uint8_t error = 0;
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7482:	f8df a240 	ldr.w	sl, [pc, #576]	; 76c4 <grid_module_common_init+0x254>
void grid_module_common_init(void){
    7486:	b0a5      	sub	sp, #148	; 0x94
	grid_ui_model_init(&grid_core_state, 1);
    7488:	4628      	mov	r0, r5
    748a:	2101      	movs	r1, #1
    748c:	4798      	blx	r3
	grid_ui_bank_init(&grid_core_state, 0, 1);
    748e:	4628      	mov	r0, r5
    7490:	4b6c      	ldr	r3, [pc, #432]	; (7644 <grid_module_common_init+0x1d4>)
    7492:	2201      	movs	r2, #1
    7494:	2100      	movs	r1, #0
    7496:	4798      	blx	r3
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    7498:	2200      	movs	r2, #0
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    749a:	2400      	movs	r4, #0
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    749c:	6868      	ldr	r0, [r5, #4]
    749e:	4b6a      	ldr	r3, [pc, #424]	; (7648 <grid_module_common_init+0x1d8>)
    74a0:	4611      	mov	r1, r2
    74a2:	4798      	blx	r3
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    74a4:	227e      	movs	r2, #126	; 0x7e
    74a6:	4621      	mov	r1, r4
    74a8:	a804      	add	r0, sp, #16
    74aa:	9403      	str	r4, [sp, #12]
    74ac:	47c8      	blx	r9
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
    74ae:	4967      	ldr	r1, [pc, #412]	; (764c <grid_module_common_init+0x1dc>)
    74b0:	4b67      	ldr	r3, [pc, #412]	; (7650 <grid_module_common_init+0x1e0>)
    74b2:	a803      	add	r0, sp, #12
    74b4:	4798      	blx	r3
		payload_length = strlen(payload_template);
    74b6:	a803      	add	r0, sp, #12
    74b8:	47c0      	blx	r8
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    74ba:	aa03      	add	r2, sp, #12
    74bc:	1816      	adds	r6, r2, r0
    74be:	2303      	movs	r3, #3
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    74c0:	f10d 0b0b 	add.w	fp, sp, #11
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    74c4:	4963      	ldr	r1, [pc, #396]	; (7654 <grid_module_common_init+0x1e4>)
    74c6:	9300      	str	r3, [sp, #0]
    74c8:	2202      	movs	r2, #2
    74ca:	2310      	movs	r3, #16
    74cc:	4630      	mov	r0, r6
    74ce:	47b8      	blx	r7
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    74d0:	230e      	movs	r3, #14
    74d2:	2201      	movs	r2, #1
    74d4:	2104      	movs	r1, #4
	
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    74d6:	4f60      	ldr	r7, [pc, #384]	; (7658 <grid_module_common_init+0x1e8>)
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    74d8:	f8cd b000 	str.w	fp, [sp]
    74dc:	4630      	mov	r0, r6
		uint8_t error = 0;
    74de:	f88d 400b 	strb.w	r4, [sp, #11]
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    74e2:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    74e4:	47b8      	blx	r7
    74e6:	2202      	movs	r2, #2
    74e8:	4603      	mov	r3, r0
    74ea:	2105      	movs	r1, #5
    74ec:	4630      	mov	r0, r6
    74ee:	f8cd b000 	str.w	fp, [sp]
    74f2:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMAJOR_offset, GRID_CLASS_HEARTBEAT_VMAJOR_length , GRID_PROTOCOL_VERSION_MAJOR, &error);
    74f4:	2301      	movs	r3, #1
    74f6:	2202      	movs	r2, #2
    74f8:	2107      	movs	r1, #7
    74fa:	4630      	mov	r0, r6
    74fc:	f8cd b000 	str.w	fp, [sp]
    7500:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMINOR_offset, GRID_CLASS_HEARTBEAT_VMINOR_length  , GRID_PROTOCOL_VERSION_MINOR, &error);
    7502:	2301      	movs	r3, #1
    7504:	2202      	movs	r2, #2
    7506:	2109      	movs	r1, #9
    7508:	4630      	mov	r0, r6
    750a:	f8cd b000 	str.w	fp, [sp]
    750e:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VPATCH_offset, GRID_CLASS_HEARTBEAT_VPATCH_length  , GRID_PROTOCOL_VERSION_PATCH, &error);
    7510:	2309      	movs	r3, #9
    7512:	2202      	movs	r2, #2
    7514:	210b      	movs	r1, #11
    7516:	4630      	mov	r0, r6
    7518:	f8cd b000 	str.w	fp, [sp]
    751c:	47d0      	blx	sl
	
		payload_length = strlen(payload_template);
    751e:	a803      	add	r0, sp, #12
    7520:	47c0      	blx	r8
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    7522:	686e      	ldr	r6, [r5, #4]
		payload_length = strlen(payload_template);
    7524:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    7526:	aa03      	add	r2, sp, #12
    7528:	68f0      	ldr	r0, [r6, #12]
    752a:	4e4c      	ldr	r6, [pc, #304]	; (765c <grid_module_common_init+0x1ec>)
    752c:	210c      	movs	r1, #12
    752e:	47b0      	blx	r6
		
	}

	if (1){	// INIT CORE_STATE->mapmode press
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7530:	227e      	movs	r2, #126	; 0x7e
    7532:	4621      	mov	r1, r4
    7534:	a804      	add	r0, sp, #16
    7536:	9403      	str	r4, [sp, #12]
    7538:	47c8      	blx	r9
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_PRESS GRID_ACTIONSTRING_MAPMODE_PRESS);
    753a:	4949      	ldr	r1, [pc, #292]	; (7660 <grid_module_common_init+0x1f0>)
    753c:	4b44      	ldr	r3, [pc, #272]	; (7650 <grid_module_common_init+0x1e0>)
    753e:	a803      	add	r0, sp, #12
    7540:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7542:	a803      	add	r0, sp, #12
    7544:	47c0      	blx	r8
    7546:	4603      	mov	r3, r0
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_PRESS, payload_template, payload_length);			
    7548:	6868      	ldr	r0, [r5, #4]
    754a:	aa03      	add	r2, sp, #12
    754c:	68c0      	ldr	r0, [r0, #12]
    754e:	2107      	movs	r1, #7
    7550:	47b0      	blx	r6
		
	}	

	if (1){ // INIT CORE_STATE->mapmode release
			
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7552:	227e      	movs	r2, #126	; 0x7e
    7554:	4621      	mov	r1, r4
    7556:	a804      	add	r0, sp, #16
    7558:	9403      	str	r4, [sp, #12]
    755a:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_RELEASE GRID_ACTIONSTRING_MAPMODE_RELEASE);
    755c:	4941      	ldr	r1, [pc, #260]	; (7664 <grid_module_common_init+0x1f4>)
    755e:	4b3c      	ldr	r3, [pc, #240]	; (7650 <grid_module_common_init+0x1e0>)
    7560:	a803      	add	r0, sp, #12
    7562:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7564:	a803      	add	r0, sp, #12
    7566:	47c0      	blx	r8
    7568:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_RELEASE, payload_template, payload_length);
    756a:	6868      	ldr	r0, [r5, #4]
    756c:	aa03      	add	r2, sp, #12
    756e:	68c0      	ldr	r0, [r0, #12]
    7570:	2108      	movs	r1, #8
    7572:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgresponse
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7574:	227e      	movs	r2, #126	; 0x7e
    7576:	4621      	mov	r1, r4
    7578:	a804      	add	r0, sp, #16
    757a:	9403      	str	r4, [sp, #12]
    757c:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_RESPONES GRID_ACTIONSTRING_CFG_RESPONSE);
    757e:	493a      	ldr	r1, [pc, #232]	; (7668 <grid_module_common_init+0x1f8>)
    7580:	4b33      	ldr	r3, [pc, #204]	; (7650 <grid_module_common_init+0x1e0>)
    7582:	a803      	add	r0, sp, #12
    7584:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7586:	a803      	add	r0, sp, #12
    7588:	47c0      	blx	r8
    758a:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_RESPONSE, payload_template, payload_length);
    758c:	6868      	ldr	r0, [r5, #4]
    758e:	aa03      	add	r2, sp, #12
    7590:	68c0      	ldr	r0, [r0, #12]
    7592:	2109      	movs	r1, #9
    7594:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgrequest
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7596:	227e      	movs	r2, #126	; 0x7e
    7598:	4621      	mov	r1, r4
    759a:	a804      	add	r0, sp, #16
    759c:	9403      	str	r4, [sp, #12]
    759e:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_REQUEST GRID_ACTIONSTRING_CFG_REQUEST);
    75a0:	4932      	ldr	r1, [pc, #200]	; (766c <grid_module_common_init+0x1fc>)
    75a2:	4b2b      	ldr	r3, [pc, #172]	; (7650 <grid_module_common_init+0x1e0>)
    75a4:	a803      	add	r0, sp, #12
    75a6:	4798      	blx	r3
		payload_length = strlen(payload_template);
    75a8:	a803      	add	r0, sp, #12
    75aa:	47c0      	blx	r8
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    75ac:	686c      	ldr	r4, [r5, #4]
		payload_length = strlen(payload_template);
    75ae:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    75b0:	aa03      	add	r2, sp, #12
    75b2:	68e0      	ldr	r0, [r4, #12]
	}	
	
	
	//enable pwr!
	
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    75b4:	4c2e      	ldr	r4, [pc, #184]	; (7670 <grid_module_common_init+0x200>)
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    75b6:	210a      	movs	r1, #10
    75b8:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    75ba:	492e      	ldr	r1, [pc, #184]	; (7674 <grid_module_common_init+0x204>)
    75bc:	482e      	ldr	r0, [pc, #184]	; (7678 <grid_module_common_init+0x208>)
    75be:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    75c0:	4b2e      	ldr	r3, [pc, #184]	; (767c <grid_module_common_init+0x20c>)
    75c2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    75c6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(UI_PWR_EN, true);

	// ADC SETUP	
	
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    75ca:	47b8      	blx	r7
    75cc:	4625      	mov	r5, r4
    75ce:	b970      	cbnz	r0, 75ee <grid_module_common_init+0x17e>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PO16");
    75d0:	492b      	ldr	r1, [pc, #172]	; (7680 <grid_module_common_init+0x210>)
    75d2:	4829      	ldr	r0, [pc, #164]	; (7678 <grid_module_common_init+0x208>)
    75d4:	47a8      	blx	r5
		grid_module_po16_revb_init();
    75d6:	4b2b      	ldr	r3, [pc, #172]	; (7684 <grid_module_common_init+0x214>)
	}
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
		grid_module_bu16_revb_init();
    75d8:	4798      	blx	r3
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
	}


	grid_sys_init(&grid_sys_state);
    75da:	4b2b      	ldr	r3, [pc, #172]	; (7688 <grid_module_common_init+0x218>)
    75dc:	482b      	ldr	r0, [pc, #172]	; (768c <grid_module_common_init+0x21c>)
    75de:	4798      	blx	r3


	grid_nvm_init(&grid_nvm_state, &FLASH_0);
    75e0:	492b      	ldr	r1, [pc, #172]	; (7690 <grid_module_common_init+0x220>)
    75e2:	482c      	ldr	r0, [pc, #176]	; (7694 <grid_module_common_init+0x224>)
    75e4:	4b2c      	ldr	r3, [pc, #176]	; (7698 <grid_module_common_init+0x228>)
    75e6:	4798      	blx	r3
	
		
}
    75e8:	b025      	add	sp, #148	; 0x94
    75ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    75ee:	47b8      	blx	r7
    75f0:	2808      	cmp	r0, #8
    75f2:	d0ed      	beq.n	75d0 <grid_module_common_init+0x160>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    75f4:	47b8      	blx	r7
    75f6:	2880      	cmp	r0, #128	; 0x80
    75f8:	d104      	bne.n	7604 <grid_module_common_init+0x194>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
    75fa:	4928      	ldr	r1, [pc, #160]	; (769c <grid_module_common_init+0x22c>)
    75fc:	481e      	ldr	r0, [pc, #120]	; (7678 <grid_module_common_init+0x208>)
    75fe:	47a8      	blx	r5
		grid_module_bu16_revb_init();
    7600:	4b27      	ldr	r3, [pc, #156]	; (76a0 <grid_module_common_init+0x230>)
    7602:	e7e9      	b.n	75d8 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    7604:	47b8      	blx	r7
    7606:	2888      	cmp	r0, #136	; 0x88
    7608:	d0f7      	beq.n	75fa <grid_module_common_init+0x18a>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_PBF4_RevA){
    760a:	47b8      	blx	r7
    760c:	2840      	cmp	r0, #64	; 0x40
    760e:	d104      	bne.n	761a <grid_module_common_init+0x1aa>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PBF4");					
    7610:	4924      	ldr	r1, [pc, #144]	; (76a4 <grid_module_common_init+0x234>)
    7612:	4819      	ldr	r0, [pc, #100]	; (7678 <grid_module_common_init+0x208>)
    7614:	47a0      	blx	r4
		grid_module_pbf4_reva_init();			
    7616:	4b24      	ldr	r3, [pc, #144]	; (76a8 <grid_module_common_init+0x238>)
    7618:	e7de      	b.n	75d8 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_EN16_RevA){
    761a:	47b8      	blx	r7
    761c:	28c0      	cmp	r0, #192	; 0xc0
    761e:	d104      	bne.n	762a <grid_module_common_init+0x1ba>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: EN16");
    7620:	4922      	ldr	r1, [pc, #136]	; (76ac <grid_module_common_init+0x23c>)
    7622:	4815      	ldr	r0, [pc, #84]	; (7678 <grid_module_common_init+0x208>)
    7624:	47a0      	blx	r4
		grid_module_en16_reva_init();	
    7626:	4b22      	ldr	r3, [pc, #136]	; (76b0 <grid_module_common_init+0x240>)
    7628:	e7d6      	b.n	75d8 <grid_module_common_init+0x168>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
    762a:	4922      	ldr	r1, [pc, #136]	; (76b4 <grid_module_common_init+0x244>)
    762c:	4812      	ldr	r0, [pc, #72]	; (7678 <grid_module_common_init+0x208>)
    762e:	47a0      	blx	r4
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
    7630:	4921      	ldr	r1, [pc, #132]	; (76b8 <grid_module_common_init+0x248>)
    7632:	4811      	ldr	r0, [pc, #68]	; (7678 <grid_module_common_init+0x208>)
    7634:	47a0      	blx	r4
    7636:	e7d0      	b.n	75da <grid_module_common_init+0x16a>
    7638:	2001c7c0 	.word	0x2001c7c0
    763c:	00009e19 	.word	0x00009e19
    7640:	00014c8d 	.word	0x00014c8d
    7644:	00009e4d 	.word	0x00009e4d
    7648:	0000a779 	.word	0x0000a779
    764c:	00016116 	.word	0x00016116
    7650:	00014cfb 	.word	0x00014cfb
    7654:	00015fce 	.word	0x00015fce
    7658:	00009c95 	.word	0x00009c95
    765c:	0000a2dd 	.word	0x0000a2dd
    7660:	0001612a 	.word	0x0001612a
    7664:	00016150 	.word	0x00016150
    7668:	00016169 	.word	0x00016169
    766c:	0001618f 	.word	0x0001618f
    7670:	00014925 	.word	0x00014925
    7674:	000161b5 	.word	0x000161b5
    7678:	0001605f 	.word	0x0001605f
    767c:	41008000 	.word	0x41008000
    7680:	000161c5 	.word	0x000161c5
    7684:	00008749 	.word	0x00008749
    7688:	000099f9 	.word	0x000099f9
    768c:	2000f008 	.word	0x2000f008
    7690:	2001ccf8 	.word	0x2001ccf8
    7694:	2000fa1c 	.word	0x2000fa1c
    7698:	000090a1 	.word	0x000090a1
    769c:	000161d7 	.word	0x000161d7
    76a0:	000079f9 	.word	0x000079f9
    76a4:	000161e9 	.word	0x000161e9
    76a8:	000083ed 	.word	0x000083ed
    76ac:	000161fb 	.word	0x000161fb
    76b0:	00007f11 	.word	0x00007f11
    76b4:	0001620d 	.word	0x0001620d
    76b8:	00016229 	.word	0x00016229
    76bc:	000147c5 	.word	0x000147c5
    76c0:	00014d0b 	.word	0x00014d0b
    76c4:	00009dd5 	.word	0x00009dd5

000076c8 <grid_module_bu16_revb_hardware_start_transfer>:

static uint8_t grid_bu16_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_bu16_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};
	
	
void grid_module_bu16_revb_hardware_start_transfer(void){
    76c8:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    76ca:	4c04      	ldr	r4, [pc, #16]	; (76dc <grid_module_bu16_revb_hardware_start_transfer+0x14>)
    76cc:	4804      	ldr	r0, [pc, #16]	; (76e0 <grid_module_bu16_revb_hardware_start_transfer+0x18>)
    76ce:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    76d0:	4623      	mov	r3, r4
    76d2:	4804      	ldr	r0, [pc, #16]	; (76e4 <grid_module_bu16_revb_hardware_start_transfer+0x1c>)

}
    76d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    76d8:	4718      	bx	r3
    76da:	bf00      	nop
    76dc:	0000e9e5 	.word	0x0000e9e5
    76e0:	2001cd84 	.word	0x2001cd84
    76e4:	2001cf58 	.word	0x2001cf58

000076e8 <grid_module_bu16_revb_hardware_transfer_complete_cb>:

static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    76e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    76ec:	4aa4      	ldr	r2, [pc, #656]	; (7980 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x298>)
    76ee:	7813      	ldrb	r3, [r2, #0]
static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    76f0:	b08b      	sub	sp, #44	; 0x2c
    76f2:	4614      	mov	r4, r2
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    76f4:	b933      	cbnz	r3, 7704 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_bu16_revb_hardware_transfer_complete++;
    76f6:	7813      	ldrb	r3, [r2, #0]
    76f8:	3301      	adds	r3, #1
    76fa:	b2db      	uxtb	r3, r3
    76fc:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_bu16_revb_hardware_transfer_complete = 0;
	grid_module_bu16_revb_hardware_start_transfer();
}
    76fe:	b00b      	add	sp, #44	; 0x2c
    7700:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7704:	4b9f      	ldr	r3, [pc, #636]	; (7984 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x29c>)
    7706:	48a0      	ldr	r0, [pc, #640]	; (7988 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7708:	4d9f      	ldr	r5, [pc, #636]	; (7988 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    770a:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    770c:	7c6a      	ldrb	r2, [r5, #17]
		bank=0;
    770e:	28ff      	cmp	r0, #255	; 0xff
    7710:	bf14      	ite	ne
    7712:	4603      	movne	r3, r0
    7714:	2300      	moveq	r3, #0
	if (bank_changed){
    7716:	b9fa      	cbnz	r2, 7758 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x70>
	uint16_t adcresult_0 = 0;
    7718:	2300      	movs	r3, #0
    771a:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    771e:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    7722:	7863      	ldrb	r3, [r4, #1]
    7724:	4a99      	ldr	r2, [pc, #612]	; (798c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a4>)
    7726:	3308      	adds	r3, #8
    7728:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    772a:	7863      	ldrb	r3, [r4, #1]
    772c:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    772e:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7730:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_bu16_revb_mux++;
    7732:	7863      	ldrb	r3, [r4, #1]
    7734:	3301      	adds	r3, #1
    7736:	b2db      	uxtb	r3, r3
    7738:	7063      	strb	r3, [r4, #1]
	grid_module_bu16_revb_mux%=8;
    773a:	7863      	ldrb	r3, [r4, #1]
    773c:	f003 0307 	and.w	r3, r3, #7
    7740:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_bu16_revb_mux/1%2);
    7742:	7863      	ldrb	r3, [r4, #1]
	if (level) {
    7744:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7748:	b2f6      	uxtb	r6, r6
    774a:	4b91      	ldr	r3, [pc, #580]	; (7990 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    774c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    7750:	d141      	bne.n	77d6 <grid_module_bu16_revb_hardware_transfer_complete_cb+0xee>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7752:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    7756:	e040      	b.n	77da <grid_module_bu16_revb_hardware_transfer_complete_cb+0xf2>
		grid_sys_state.bank_active_changed = 0;
    7758:	f04f 0900 	mov.w	r9, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    775c:	fa0f fa83 	sxth.w	sl, r3
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7760:	f8df 823c 	ldr.w	r8, [pc, #572]	; 79a0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>
		grid_sys_state.bank_active_changed = 0;
    7764:	f885 9011 	strb.w	r9, [r5, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7768:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    776c:	eb04 1703 	add.w	r7, r4, r3, lsl #4
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7770:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7774:	7bea      	ldrb	r2, [r5, #15]
    7776:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    777a:	fa5f f689 	uxtb.w	r6, r9
    777e:	7a5b      	ldrb	r3, [r3, #9]
    7780:	42b3      	cmp	r3, r6
    7782:	d9c9      	bls.n	7718 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x30>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7784:	f8d8 2004 	ldr.w	r2, [r8, #4]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7788:	f8df b220 	ldr.w	fp, [pc, #544]	; 79ac <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c4>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    778c:	4452      	add	r2, sl
    778e:	2364      	movs	r3, #100	; 0x64
    7790:	68d2      	ldr	r2, [r2, #12]
    7792:	4373      	muls	r3, r6
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    7794:	19b9      	adds	r1, r7, r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7796:	441a      	add	r2, r3
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    7798:	7888      	ldrb	r0, [r1, #2]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    779a:	f891 1042 	ldrb.w	r1, [r1, #66]	; 0x42
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    779e:	6190      	str	r0, [r2, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    77a0:	61d1      	str	r1, [r2, #28]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    77a2:	f8d8 2004 	ldr.w	r2, [r8, #4]
    77a6:	7be9      	ldrb	r1, [r5, #15]
    77a8:	eb02 1201 	add.w	r2, r2, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    77ac:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    77ae:	68d2      	ldr	r2, [r2, #12]
    77b0:	4413      	add	r3, r2
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    77b2:	4632      	mov	r2, r6
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    77b4:	60de      	str	r6, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    77b6:	7be9      	ldrb	r1, [r5, #15]
    77b8:	2300      	movs	r3, #0
    77ba:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    77bc:	7be9      	ldrb	r1, [r5, #15]
    77be:	2304      	movs	r3, #4
    77c0:	4632      	mov	r2, r6
    77c2:	4640      	mov	r0, r8
    77c4:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    77c6:	7be9      	ldrb	r1, [r5, #15]
    77c8:	2305      	movs	r3, #5
    77ca:	4632      	mov	r2, r6
    77cc:	4640      	mov	r0, r8
    77ce:	47d8      	blx	fp
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    77d0:	f109 0901 	add.w	r9, r9, #1
    77d4:	e7cc      	b.n	7770 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x88>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    77d6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_bu16_revb_mux/2%2);
    77da:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    77dc:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 79b0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c8>
    77e0:	486c      	ldr	r0, [pc, #432]	; (7994 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2ac>)
    77e2:	f013 0f02 	tst.w	r3, #2
    77e6:	4b6a      	ldr	r3, [pc, #424]	; (7990 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    77e8:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    77ec:	bf14      	ite	ne
    77ee:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    77f2:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_bu16_revb_mux/4%2);
    77f6:	7863      	ldrb	r3, [r4, #1]
    77f8:	f013 0f04 	tst.w	r3, #4
    77fc:	4b64      	ldr	r3, [pc, #400]	; (7990 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    77fe:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7802:	bf14      	ite	ne
    7804:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7808:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    780c:	2100      	movs	r1, #0
    780e:	2302      	movs	r3, #2
    7810:	aa05      	add	r2, sp, #20
    7812:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    7814:	2302      	movs	r3, #2
    7816:	f10d 0216 	add.w	r2, sp, #22
    781a:	485f      	ldr	r0, [pc, #380]	; (7998 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b0>)
    781c:	2100      	movs	r1, #0
    781e:	47c0      	blx	r8
	uint8_t result_value[2] = {0};
    7820:	2300      	movs	r3, #0
    7822:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint8_t result_valid[2] = {0};
    7826:	f8ad 3010 	strh.w	r3, [sp, #16]
	if (adcresult_0>60000){
    782a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	result_index[0] = adc_index_0;
    782e:	f88d 7008 	strb.w	r7, [sp, #8]
	if (adcresult_0>60000){
    7832:	f64e 2260 	movw	r2, #60000	; 0xea60
    7836:	4293      	cmp	r3, r2
	result_index[1] = adc_index_1;
    7838:	f88d 6009 	strb.w	r6, [sp, #9]
	if (adcresult_0>60000){
    783c:	d978      	bls.n	7930 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x248>
		result_valid[0] = 1;
    783e:	2301      	movs	r3, #1
    7840:	f88d 3010 	strb.w	r3, [sp, #16]
	if (adcresult_1>60000){
    7844:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    7848:	f64e 2260 	movw	r2, #60000	; 0xea60
    784c:	4293      	cmp	r3, r2
    784e:	d975      	bls.n	793c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x254>
		result_value[1] = 0;
    7850:	2300      	movs	r3, #0
		result_value[1] = 127;
    7852:	f88d 300d 	strb.w	r3, [sp, #13]
		result_valid[1] = 1;
    7856:	2301      	movs	r3, #1
    7858:	f88d 3011 	strb.w	r3, [sp, #17]
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    785c:	4b4f      	ldr	r3, [pc, #316]	; (799c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b4>)
    785e:	ae06      	add	r6, sp, #24
    7860:	f103 0710 	add.w	r7, r3, #16
    7864:	6818      	ldr	r0, [r3, #0]
    7866:	6859      	ldr	r1, [r3, #4]
    7868:	4632      	mov	r2, r6
    786a:	c203      	stmia	r2!, {r0, r1}
    786c:	3308      	adds	r3, #8
    786e:	42bb      	cmp	r3, r7
    7870:	4616      	mov	r6, r2
    7872:	d1f7      	bne.n	7864 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7874:	484a      	ldr	r0, [pc, #296]	; (79a0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    7876:	2300      	movs	r3, #0
    7878:	f10d 0908 	add.w	r9, sp, #8
    787c:	f10d 0b0c 	add.w	fp, sp, #12
    7880:	9301      	str	r3, [sp, #4]
    7882:	4682      	mov	sl, r0
		uint8_t res_index = result_index[i];
    7884:	f819 6b01 	ldrb.w	r6, [r9], #1
		uint8_t res_value = result_value[i];
    7888:	f81b 8b01 	ldrb.w	r8, [fp], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    788c:	6843      	ldr	r3, [r0, #4]
    788e:	7bea      	ldrb	r2, [r5, #15]
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    7890:	19a1      	adds	r1, r4, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7892:	b2d2      	uxtb	r2, r2
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    7894:	f891 c082 	ldrb.w	ip, [r1, #130]	; 0x82
    7898:	45e0      	cmp	r8, ip
    789a:	d042      	beq.n	7922 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
    789c:	9f01      	ldr	r7, [sp, #4]
		uint8_t res_valid = result_valid[i];
    789e:	a904      	add	r1, sp, #16
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    78a0:	5c79      	ldrb	r1, [r7, r1]
    78a2:	2901      	cmp	r1, #1
    78a4:	d13d      	bne.n	7922 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    78a6:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    78aa:	2164      	movs	r1, #100	; 0x64
    78ac:	68db      	ldr	r3, [r3, #12]
    78ae:	fb16 f101 	smulbb	r1, r6, r1
    78b2:	440b      	add	r3, r1
			if (grid_bu16_helper_template_b_abs[res_index] == 0){ // Button Press Event
    78b4:	f1bc 0f00 	cmp.w	ip, #0
    78b8:	d14d      	bne.n	7956 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x26e>
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    78ba:	699a      	ldr	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    78bc:	f8d3 e01c 	ldr.w	lr, [r3, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    78c0:	2a00      	cmp	r2, #0
    78c2:	bf0c      	ite	eq
    78c4:	227f      	moveq	r2, #127	; 0x7f
    78c6:	2200      	movne	r2, #0
    78c8:	619a      	str	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    78ca:	f1be 0f00 	cmp.w	lr, #0
    78ce:	d13c      	bne.n	794a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x262>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    78d0:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    78d4:	f8c3 c01c 	str.w	ip, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    78d8:	f895 c00f 	ldrb.w	ip, [r5, #15]
    78dc:	9f01      	ldr	r7, [sp, #4]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    78de:	69db      	ldr	r3, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    78e0:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
    78e4:	44bc      	add	ip, r7
    78e6:	f88c 2002 	strb.w	r2, [ip, #2]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    78ea:	7bea      	ldrb	r2, [r5, #15]
    78ec:	eb04 1202 	add.w	r2, r4, r2, lsl #4
    78f0:	443a      	add	r2, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    78f2:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    78f6:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
    78fa:	2300      	movs	r3, #0
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    78fc:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7900:	441a      	add	r2, r3
    7902:	3310      	adds	r3, #16
    7904:	68d2      	ldr	r2, [r2, #12]
    7906:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7908:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    790a:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    790e:	d1f5      	bne.n	78fc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x214>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7910:	7be9      	ldrb	r1, [r5, #15]
    7912:	2304      	movs	r3, #4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7914:	4632      	mov	r2, r6
    7916:	4f23      	ldr	r7, [pc, #140]	; (79a4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2bc>)
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7918:	4426      	add	r6, r4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    791a:	47b8      	blx	r7
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    791c:	4820      	ldr	r0, [pc, #128]	; (79a0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
    791e:	f886 8082 	strb.w	r8, [r6, #130]	; 0x82
	for (uint8_t i=0; i<2; i++)
    7922:	9b01      	ldr	r3, [sp, #4]
    7924:	b173      	cbz	r3, 7944 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x25c>
	grid_module_bu16_revb_hardware_transfer_complete = 0;
    7926:	2300      	movs	r3, #0
    7928:	7023      	strb	r3, [r4, #0]
	grid_module_bu16_revb_hardware_start_transfer();
    792a:	4b1f      	ldr	r3, [pc, #124]	; (79a8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c0>)
    792c:	4798      	blx	r3
    792e:	e6e6      	b.n	76fe <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16>
	else if (adcresult_0<200){
    7930:	2bc7      	cmp	r3, #199	; 0xc7
    7932:	d887      	bhi.n	7844 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x15c>
		result_value[0] = 127;
    7934:	237f      	movs	r3, #127	; 0x7f
    7936:	f88d 300c 	strb.w	r3, [sp, #12]
    793a:	e780      	b.n	783e <grid_module_bu16_revb_hardware_transfer_complete_cb+0x156>
	else if (adcresult_1<200){
    793c:	2bc7      	cmp	r3, #199	; 0xc7
    793e:	d88d      	bhi.n	785c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x174>
		result_value[1] = 127;
    7940:	237f      	movs	r3, #127	; 0x7f
    7942:	e786      	b.n	7852 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16a>
    7944:	2301      	movs	r3, #1
    7946:	9301      	str	r3, [sp, #4]
    7948:	e79c      	b.n	7884 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x19c>
				else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    794a:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    794e:	bf08      	it	eq
    7950:	f04f 0c7f 	moveq.w	ip, #127	; 0x7f
    7954:	e7be      	b.n	78d4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1ec>
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    7956:	aa0a      	add	r2, sp, #40	; 0x28
    7958:	4432      	add	r2, r6
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    795a:	60de      	str	r6, [r3, #12]
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    795c:	f812 2c10 	ldrb.w	r2, [r2, #-16]
    7960:	611a      	str	r2, [r3, #16]
    7962:	2300      	movs	r3, #0
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7964:	469c      	mov	ip, r3
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7966:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    796a:	441a      	add	r2, r3
    796c:	3310      	adds	r3, #16
    796e:	68d2      	ldr	r2, [r2, #12]
    7970:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7972:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7974:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7978:	d1f5      	bne.n	7966 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x27e>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    797a:	7be9      	ldrb	r1, [r5, #15]
    797c:	2305      	movs	r3, #5
    797e:	e7c9      	b.n	7914 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x22c>
    7980:	200005ec 	.word	0x200005ec
    7984:	00009aaf 	.word	0x00009aaf
    7988:	2000f008 	.word	0x2000f008
    798c:	20000308 	.word	0x20000308
    7990:	41008000 	.word	0x41008000
    7994:	2001cd84 	.word	0x2001cd84
    7998:	2001cf58 	.word	0x2001cf58
    799c:	00016238 	.word	0x00016238
    79a0:	2000effc 	.word	0x2000effc
    79a4:	0000a539 	.word	0x0000a539
    79a8:	000076c9 	.word	0x000076c9
    79ac:	0000a88d 	.word	0x0000a88d
    79b0:	0000e929 	.word	0x0000e929

000079b4 <grid_module_bu16_revb_hardware_init>:

void grid_module_bu16_revb_hardware_init(void){
    79b4:	b570      	push	{r4, r5, r6, lr}
	

	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    79b6:	4c0b      	ldr	r4, [pc, #44]	; (79e4 <grid_module_bu16_revb_hardware_init+0x30>)
    79b8:	4e0b      	ldr	r6, [pc, #44]	; (79e8 <grid_module_bu16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    79ba:	4d0c      	ldr	r5, [pc, #48]	; (79ec <grid_module_bu16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    79bc:	4b0c      	ldr	r3, [pc, #48]	; (79f0 <grid_module_bu16_revb_hardware_init+0x3c>)
    79be:	2200      	movs	r2, #0
    79c0:	4611      	mov	r1, r2
    79c2:	4620      	mov	r0, r4
    79c4:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    79c6:	2200      	movs	r2, #0
    79c8:	4b09      	ldr	r3, [pc, #36]	; (79f0 <grid_module_bu16_revb_hardware_init+0x3c>)
    79ca:	4611      	mov	r1, r2
    79cc:	4628      	mov	r0, r5
    79ce:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    79d0:	4620      	mov	r0, r4
    79d2:	4c08      	ldr	r4, [pc, #32]	; (79f4 <grid_module_bu16_revb_hardware_init+0x40>)
    79d4:	2100      	movs	r1, #0
    79d6:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    79d8:	4628      	mov	r0, r5
    79da:	4623      	mov	r3, r4
    79dc:	2100      	movs	r1, #0

}
    79de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    79e2:	4718      	bx	r3
    79e4:	2001cd84 	.word	0x2001cd84
    79e8:	0000e8b1 	.word	0x0000e8b1
    79ec:	2001cf58 	.word	0x2001cf58
    79f0:	000076e9 	.word	0x000076e9
    79f4:	0000e871 	.word	0x0000e871

000079f8 <grid_module_bu16_revb_init>:



void grid_module_bu16_revb_init(){
    79f8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	grid_led_lowlevel_init(&grid_led_state, 16);
    79fc:	4b12      	ldr	r3, [pc, #72]	; (7a48 <grid_module_bu16_revb_init+0x50>)
    79fe:	4813      	ldr	r0, [pc, #76]	; (7a4c <grid_module_bu16_revb_init+0x54>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7a00:	4e13      	ldr	r6, [pc, #76]	; (7a50 <grid_module_bu16_revb_init+0x58>)
    7a02:	4f14      	ldr	r7, [pc, #80]	; (7a54 <grid_module_bu16_revb_init+0x5c>)
		
		for (uint8_t j=0; j<16; j++){

			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    7a04:	f8df 805c 	ldr.w	r8, [pc, #92]	; 7a64 <grid_module_bu16_revb_init+0x6c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7a08:	2110      	movs	r1, #16
    7a0a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    7a0c:	4810      	ldr	r0, [pc, #64]	; (7a50 <grid_module_bu16_revb_init+0x58>)
    7a0e:	4b12      	ldr	r3, [pc, #72]	; (7a58 <grid_module_bu16_revb_init+0x60>)
    7a10:	2104      	movs	r1, #4
    7a12:	4798      	blx	r3
    7a14:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7a16:	2210      	movs	r2, #16
    7a18:	b2e1      	uxtb	r1, r4
    7a1a:	4630      	mov	r0, r6
    7a1c:	47b8      	blx	r7
		for (uint8_t j=0; j<16; j++){
    7a1e:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7a22:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    7a24:	6870      	ldr	r0, [r6, #4]
    7a26:	b2e9      	uxtb	r1, r5
    7a28:	2202      	movs	r2, #2
    7a2a:	4448      	add	r0, r9
    7a2c:	3501      	adds	r5, #1
    7a2e:	47c0      	blx	r8
		for (uint8_t j=0; j<16; j++){
    7a30:	2d10      	cmp	r5, #16
    7a32:	d1f7      	bne.n	7a24 <grid_module_bu16_revb_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    7a34:	3401      	adds	r4, #1
    7a36:	2c04      	cmp	r4, #4
    7a38:	d1ed      	bne.n	7a16 <grid_module_bu16_revb_init+0x1e>

		}		
		
	}
				
	grid_module_bu16_revb_hardware_init();
    7a3a:	4b08      	ldr	r3, [pc, #32]	; (7a5c <grid_module_bu16_revb_init+0x64>)
    7a3c:	4798      	blx	r3
	grid_module_bu16_revb_hardware_start_transfer();

};
    7a3e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_bu16_revb_hardware_start_transfer();
    7a42:	4b07      	ldr	r3, [pc, #28]	; (7a60 <grid_module_bu16_revb_init+0x68>)
    7a44:	4718      	bx	r3
    7a46:	bf00      	nop
    7a48:	000072c1 	.word	0x000072c1
    7a4c:	2001c838 	.word	0x2001c838
    7a50:	2000effc 	.word	0x2000effc
    7a54:	00009e4d 	.word	0x00009e4d
    7a58:	00009e19 	.word	0x00009e19
    7a5c:	000079b5 	.word	0x000079b5
    7a60:	000076c9 	.word	0x000076c9
    7a64:	0000a779 	.word	0x0000a779

00007a68 <grid_module_en16_reva_hardware_start_transfer>:





void grid_module_en16_reva_hardware_start_transfer(void){
    7a68:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7a6a:	4b08      	ldr	r3, [pc, #32]	; (7a8c <grid_module_en16_reva_hardware_start_transfer+0x24>)
	

	gpio_set_pin_level(PIN_UI_SPI_CS0, true);

	spi_m_async_enable(&UI_SPI);
    7a6c:	4808      	ldr	r0, [pc, #32]	; (7a90 <grid_module_en16_reva_hardware_start_transfer+0x28>)

	//io_write(io, UI_SPI_TX_BUFFER, 8);
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7a6e:	4c09      	ldr	r4, [pc, #36]	; (7a94 <grid_module_en16_reva_hardware_start_transfer+0x2c>)
    7a70:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7a74:	619a      	str	r2, [r3, #24]
	spi_m_async_enable(&UI_SPI);
    7a76:	4b08      	ldr	r3, [pc, #32]	; (7a98 <grid_module_en16_reva_hardware_start_transfer+0x30>)
    7a78:	4798      	blx	r3
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7a7a:	4a08      	ldr	r2, [pc, #32]	; (7a9c <grid_module_en16_reva_hardware_start_transfer+0x34>)
    7a7c:	4804      	ldr	r0, [pc, #16]	; (7a90 <grid_module_en16_reva_hardware_start_transfer+0x28>)
    7a7e:	46a4      	mov	ip, r4
    7a80:	2308      	movs	r3, #8

}
    7a82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7a86:	f102 010e 	add.w	r1, r2, #14
    7a8a:	4760      	bx	ip
    7a8c:	41008000 	.word	0x41008000
    7a90:	2001cc70 	.word	0x2001cc70
    7a94:	0000f5ad 	.word	0x0000f5ad
    7a98:	0000f50d 	.word	0x0000f50d
    7a9c:	2000067e 	.word	0x2000067e

00007aa0 <grid_module_en16_reva_hardware_transfer_complete_cb>:

void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    7aa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7aa4:	4ba8      	ldr	r3, [pc, #672]	; (7d48 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2a8>)
	
	// Set the shift registers to continuously load data until new transaction is issued
	gpio_set_pin_level(PIN_UI_SPI_CS0, false);


	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7aa6:	48a9      	ldr	r0, [pc, #676]	; (7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
	if (bank == 255){
		bank=0;
	}


	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7aa8:	4fa8      	ldr	r7, [pc, #672]	; (7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7aaa:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7aae:	615a      	str	r2, [r3, #20]
void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    7ab0:	b089      	sub	sp, #36	; 0x24
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7ab2:	4ba7      	ldr	r3, [pc, #668]	; (7d50 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b0>)
    7ab4:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7ab6:	7c7b      	ldrb	r3, [r7, #17]
		bank=0;
    7ab8:	28ff      	cmp	r0, #255	; 0xff
    7aba:	bf14      	ite	ne
    7abc:	4606      	movne	r6, r0
    7abe:	2600      	moveq	r6, #0
		
	if (bank_changed){
    7ac0:	2b00      	cmp	r3, #0
    7ac2:	f040 815f 	bne.w	7d84 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e4>
		

		uint8_t i = UI_ENCODER_LOOKUP[j];
		

		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7ac6:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 7d80 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e0>
				uint8_t controlnumber = i;
 
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 

				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    7aca:	0133      	lsls	r3, r6, #4
    7acc:	9302      	str	r3, [sp, #8]
    7ace:	eb08 1306 	add.w	r3, r8, r6, lsl #4
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7ad2:	f04f 0b00 	mov.w	fp, #0
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    7ad6:	9303      	str	r3, [sp, #12]
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7ad8:	f3cb 0346 	ubfx	r3, fp, #1, #7
    7adc:	f00b 0201 	and.w	r2, fp, #1
    7ae0:	f818 3003 	ldrb.w	r3, [r8, r3]
    7ae4:	0092      	lsls	r2, r2, #2
    7ae6:	4113      	asrs	r3, r2
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    7ae8:	eb08 020b 	add.w	r2, r8, fp
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7aec:	b2de      	uxtb	r6, r3
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    7aee:	f892 015c 	ldrb.w	r0, [r2, #348]	; 0x15c
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    7af2:	f003 030f 	and.w	r3, r3, #15
		if (old_value != new_value){
    7af6:	4283      	cmp	r3, r0
    7af8:	fa5f f18b 	uxtb.w	r1, fp
    7afc:	f000 8115 	beq.w	7d2a <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7b00:	4894      	ldr	r0, [pc, #592]	; (7d54 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b4>)
            UI_SPI_RX_BUFFER_LAST[j] = new_value;
    7b02:	f882 315c 	strb.w	r3, [r2, #348]	; 0x15c
			UI_SPI_DEBUG = j;
    7b06:	4a94      	ldr	r2, [pc, #592]	; (7d58 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b8>)
		uint8_t i = UI_ENCODER_LOOKUP[j];
    7b08:	f81b 4000 	ldrb.w	r4, [fp, r0]
			UI_SPI_DEBUG = j;
    7b0c:	7011      	strb	r1, [r2, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    7b0e:	4d93      	ldr	r5, [pc, #588]	; (7d5c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2bc>)
			uint8_t button_value = (new_value&0b00000100)?1:0;
    7b10:	f3c3 0280 	ubfx	r2, r3, #2, #1
    7b14:	9201      	str	r2, [sp, #4]
            uint8_t phase_a      = (new_value&0b00000010)?1:0;
    7b16:	f3c3 0240 	ubfx	r2, r3, #1, #1
    7b1a:	9200      	str	r2, [sp, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    7b1c:	eb05 1204 	add.w	r2, r5, r4, lsl #4
    7b20:	9801      	ldr	r0, [sp, #4]
    7b22:	7851      	ldrb	r1, [r2, #1]
    7b24:	4281      	cmp	r1, r0
			uint8_t phase_b      = (new_value&0b00000001)?1:0;
    7b26:	f006 0601 	and.w	r6, r6, #1
			if (button_value != grid_ui_encoder_array[i].button_value){
    7b2a:	ea4f 1704 	mov.w	r7, r4, lsl #4
    7b2e:	d04d      	beq.n	7bcc <grid_module_en16_reva_hardware_transfer_complete_cb+0x12c>
				grid_ui_encoder_array[i].button_changed = 1;
    7b30:	2101      	movs	r1, #1
				grid_ui_encoder_array[i].button_value = new_value>>2;
    7b32:	089b      	lsrs	r3, r3, #2
				grid_ui_encoder_array[i].button_changed = 1;
    7b34:	7091      	strb	r1, [r2, #2]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7b36:	f8df a214 	ldr.w	sl, [pc, #532]	; 7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>
				grid_ui_encoder_array[i].button_value = new_value>>2;
    7b3a:	7053      	strb	r3, [r2, #1]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7b3c:	4a88      	ldr	r2, [pc, #544]	; (7d60 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7b3e:	f8df c230 	ldr.w	ip, [pc, #560]	; 7d70 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7b42:	6852      	ldr	r2, [r2, #4]
    7b44:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7b48:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    7b4c:	2164      	movs	r1, #100	; 0x64
    7b4e:	68d2      	ldr	r2, [r2, #12]
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7b50:	f10d 0910 	add.w	r9, sp, #16
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    7b54:	fb04 2201 	mla	r2, r4, r1, r2
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7b58:	f8dc 1004 	ldr.w	r1, [ip, #4]
    7b5c:	f8dc 0000 	ldr.w	r0, [ip]
    7b60:	46ce      	mov	lr, r9
    7b62:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    7b66:	497f      	ldr	r1, [pc, #508]	; (7d64 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    7b68:	f10c 0c08 	add.w	ip, ip, #8
    7b6c:	458c      	cmp	ip, r1
    7b6e:	46f1      	mov	r9, lr
    7b70:	d1f2      	bne.n	7b58 <grid_module_en16_reva_hardware_transfer_complete_cb+0xb8>
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    7b72:	a908      	add	r1, sp, #32
    7b74:	4421      	add	r1, r4
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7b76:	60d4      	str	r4, [r2, #12]
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    7b78:	2b00      	cmp	r3, #0
    7b7a:	f040 8152 	bne.w	7e22 <grid_module_en16_reva_hardware_transfer_complete_cb+0x382>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7b7e:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7b82:	6111      	str	r1, [r2, #16]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7b84:	6991      	ldr	r1, [r2, #24]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    7b86:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7b8a:	2900      	cmp	r1, #0
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7b8c:	69d1      	ldr	r1, [r2, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    7b8e:	f8c2 c014 	str.w	ip, [r2, #20]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7b92:	bf0c      	ite	eq
    7b94:	4660      	moveq	r0, ip
    7b96:	2000      	movne	r0, #0
    7b98:	6190      	str	r0, [r2, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7b9a:	2900      	cmp	r1, #0
    7b9c:	f040 813d 	bne.w	7e1a <grid_module_en16_reva_hardware_transfer_complete_cb+0x37a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7ba0:	233f      	movs	r3, #63	; 0x3f
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7ba2:	496a      	ldr	r1, [pc, #424]	; (7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7ba4:	61d3      	str	r3, [r2, #28]
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7ba6:	7bcb      	ldrb	r3, [r1, #15]
    7ba8:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    7bac:	4423      	add	r3, r4
    7bae:	7718      	strb	r0, [r3, #28]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7bb0:	7bcb      	ldrb	r3, [r1, #15]
    7bb2:	69d2      	ldr	r2, [r2, #28]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7bb4:	7bc9      	ldrb	r1, [r1, #15]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7bb6:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    7bba:	4423      	add	r3, r4
    7bbc:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7bc0:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7bc2:	4867      	ldr	r0, [pc, #412]	; (7d60 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    7bc4:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 7d74 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>
    7bc8:	4622      	mov	r2, r4
    7bca:	47c8      	blx	r9
            if (a_now == 1 && b_now == 1){ //detent found
    7bcc:	9b00      	ldr	r3, [sp, #0]
    7bce:	2b00      	cmp	r3, #0
    7bd0:	f000 8155 	beq.w	7e7e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3de>
    7bd4:	2e00      	cmp	r6, #0
    7bd6:	f000 8155 	beq.w	7e84 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
			uint8_t b_prev = grid_ui_encoder_array[i].phase_b_previous;
    7bda:	19eb      	adds	r3, r5, r7
                if (b_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7bdc:	7b9a      	ldrb	r2, [r3, #14]
    7bde:	2a00      	cmp	r2, #0
    7be0:	f040 8128 	bne.w	7e34 <grid_module_en16_reva_hardware_transfer_complete_cb+0x394>
    7be4:	7bd9      	ldrb	r1, [r3, #15]
    7be6:	2900      	cmp	r1, #0
    7be8:	f040 814c 	bne.w	7e84 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7bec:	2201      	movs	r2, #1
    7bee:	73da      	strb	r2, [r3, #15]
                    delta = -1;
    7bf0:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			grid_ui_encoder_array[i].phase_a_previous = a_now;
    7bf4:	442f      	add	r7, r5
    7bf6:	9b00      	ldr	r3, [sp, #0]
    7bf8:	737b      	strb	r3, [r7, #13]
			grid_ui_encoder_array[i].phase_b_previous = b_now;
    7bfa:	73be      	strb	r6, [r7, #14]
			if (delta != 0){
    7bfc:	f1b9 0f00 	cmp.w	r9, #0
    7c00:	f000 8093 	beq.w	7d2a <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
				uint32_t elapsed_time = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_ui_encoder_array[i].last_real_time);
    7c04:	68b9      	ldr	r1, [r7, #8]
    7c06:	4851      	ldr	r0, [pc, #324]	; (7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7c08:	4b57      	ldr	r3, [pc, #348]	; (7d68 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c8>)
    7c0a:	4798      	blx	r3
				if (elapsed_ms>25){
    7c0c:	f5b0 7fd0 	cmp.w	r0, #416	; 0x1a0
    7c10:	f080 811b 	bcs.w	7e4a <grid_module_en16_reva_hardware_transfer_complete_cb+0x3aa>
                uint32_t elapsed_ms = elapsed_time/RTC1MS;
    7c14:	0900      	lsrs	r0, r0, #4
    7c16:	2801      	cmp	r0, #1
    7c18:	bf38      	it	cc
    7c1a:	2001      	movcc	r0, #1
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7c1c:	4e4b      	ldr	r6, [pc, #300]	; (7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7c1e:	4b53      	ldr	r3, [pc, #332]	; (7d6c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2cc>)
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7c20:	f240 2771 	movw	r7, #625	; 0x271
    7c24:	fb00 7010 	mls	r0, r0, r0, r7
    7c28:	2796      	movs	r7, #150	; 0x96
    7c2a:	fbb0 f7f7 	udiv	r7, r0, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7c2e:	4630      	mov	r0, r6
    7c30:	4798      	blx	r3
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7c32:	4a4b      	ldr	r2, [pc, #300]	; (7d60 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    7c34:	6852      	ldr	r2, [r2, #4]
    7c36:	7bf1      	ldrb	r1, [r6, #15]
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7c38:	4e4d      	ldr	r6, [pc, #308]	; (7d70 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>)
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7c3a:	eb02 1201 	add.w	r2, r2, r1, lsl #4
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    7c3e:	3701      	adds	r7, #1
    7c40:	b2ff      	uxtb	r7, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7c42:	eb05 1504 	add.w	r5, r5, r4, lsl #4
				delta_high = delta * (velocityfactor * 2 - 1);
    7c46:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    7c4a:	eb0a 0a47 	add.w	sl, sl, r7, lsl #1
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7c4e:	68d2      	ldr	r2, [r2, #12]
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    7c50:	60a8      	str	r0, [r5, #8]
				delta_high = delta * (velocityfactor * 2 - 1);
    7c52:	fb0a fa09 	mul.w	sl, sl, r9
				delta_low =  delta * velocityfactor;			
    7c56:	fb07 f509 	mul.w	r5, r7, r9
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7c5a:	2164      	movs	r1, #100	; 0x64
				delta_low =  delta * velocityfactor;			
    7c5c:	b2ab      	uxth	r3, r5
				delta_high = delta * (velocityfactor * 2 - 1);
    7c5e:	fa1f f78a 	uxth.w	r7, sl
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    7c62:	fb04 2201 	mla	r2, r4, r1, r2
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7c66:	f10d 0e10 	add.w	lr, sp, #16
    7c6a:	6871      	ldr	r1, [r6, #4]
    7c6c:	6830      	ldr	r0, [r6, #0]
    7c6e:	46f4      	mov	ip, lr
    7c70:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    7c74:	493b      	ldr	r1, [pc, #236]	; (7d64 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    7c76:	3608      	adds	r6, #8
    7c78:	428e      	cmp	r6, r1
    7c7a:	46e6      	mov	lr, ip
    7c7c:	d1f5      	bne.n	7c6a <grid_module_en16_reva_hardware_transfer_complete_cb+0x1ca>
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    7c7e:	a908      	add	r1, sp, #32
    7c80:	4421      	add	r1, r4
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7c82:	6214      	str	r4, [r2, #32]
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    7c84:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    7c88:	6251      	str	r1, [r2, #36]	; 0x24
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    7c8a:	9903      	ldr	r1, [sp, #12]
    7c8c:	4421      	add	r1, r4
    7c8e:	f891 c09c 	ldrb.w	ip, [r1, #156]	; 0x9c
				uint8_t new_abs_low_velocity_value = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7c92:	f891 60dc 	ldrb.w	r6, [r1, #220]	; 0xdc
				uint8_t new_abs_high_velocity_value = grid_en16_helper_template_e_abs_high_velocity[bank][i];
    7c96:	f891 011c 	ldrb.w	r0, [r1, #284]	; 0x11c
                
				uint8_t new_rel_no_velocity_value =  template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL];
    7c9a:	f892 1034 	ldrb.w	r1, [r2, #52]	; 0x34
				
				if (delta != 0){
                    
                    
                    // ABSOLUTE NO VELOCITY						
					if (new_abs_no_velocity_value + delta < 0){
    7c9e:	44cc      	add	ip, r9
    7ca0:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
    7ca4:	f000 80d3 	beq.w	7e4e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ae>
						new_abs_no_velocity_value = 0;
					}
					else if (new_abs_no_velocity_value + delta > 127){
    7ca8:	f1bc 0f7f 	cmp.w	ip, #127	; 0x7f
    7cac:	f300 80d2 	bgt.w	7e54 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3b4>
						new_abs_no_velocity_value = 127;
					}
					else{
						new_abs_no_velocity_value += delta;
    7cb0:	fa5f fc8c 	uxtb.w	ip, ip
					}	
                    
                    // ABSOLUTE LOW VELOCITY						
					if (new_abs_low_velocity_value + delta_low < 0){
    7cb4:	1975      	adds	r5, r6, r5
    7cb6:	b2db      	uxtb	r3, r3
    7cb8:	f100 80cf 	bmi.w	7e5a <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ba>
						new_abs_low_velocity_value = 0;
					}
					else if (new_abs_low_velocity_value + delta_low > 127){
    7cbc:	2d7f      	cmp	r5, #127	; 0x7f
    7cbe:	f300 80ce 	bgt.w	7e5e <grid_module_en16_reva_hardware_transfer_complete_cb+0x3be>
						new_abs_low_velocity_value = 127;
					}
					else{
						new_abs_low_velocity_value += delta_low;
    7cc2:	441e      	add	r6, r3
    7cc4:	b2f6      	uxtb	r6, r6
					}	
  					
                    // ABSOLUTE HIGH VELOCITY						
					if (new_abs_high_velocity_value + delta_high < 0){
    7cc6:	eb10 0a0a 	adds.w	sl, r0, sl
    7cca:	b2ff      	uxtb	r7, r7
    7ccc:	f100 80c9 	bmi.w	7e62 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c2>
						new_abs_high_velocity_value = 0;
					}
					else if (new_abs_high_velocity_value + delta_high > 127){
    7cd0:	f1ba 0f7f 	cmp.w	sl, #127	; 0x7f
    7cd4:	f300 80c7 	bgt.w	7e66 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c6>
						new_abs_high_velocity_value = 127;
					}
					else{
						new_abs_high_velocity_value += delta_high;
    7cd8:	4438      	add	r0, r7
    7cda:	b2c0      	uxtb	r0, r0
					}	



                    // RELATIVE NO VELOCITY
					if (new_rel_no_velocity_value == 255){
    7cdc:	29ff      	cmp	r1, #255	; 0xff
    7cde:	f040 80c4 	bne.w	7e6a <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ca>
						if (delta>0){
							new_rel_no_velocity_value = 65;
						}
						else{
							new_rel_no_velocity_value = 63;
    7ce2:	f1b9 0f01 	cmp.w	r9, #1
					}
                    
                    // RELATIVE LOW VELOCITY
					if (new_rel_low_velocity_value == 255){
                        
                        new_rel_low_velocity_value = 64 + delta_low;
    7ce6:	f103 0340 	add.w	r3, r3, #64	; 0x40
							new_rel_no_velocity_value = 63;
    7cea:	bf0c      	ite	eq
    7cec:	2541      	moveq	r5, #65	; 0x41
    7cee:	253f      	movne	r5, #63	; 0x3f
                        new_rel_low_velocity_value = 64 + delta_low;
    7cf0:	b2db      	uxtb	r3, r3
					}
                    
                    // RELATIVE HIGH VELOCITY
					if (new_rel_high_velocity_value == 255){
				
                        new_rel_high_velocity_value = 64 + delta_high;
    7cf2:	3740      	adds	r7, #64	; 0x40
	
                    
                    
					
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = new_rel_no_velocity_value;
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = new_rel_low_velocity_value;
    7cf4:	e9c2 530d 	strd	r5, r3, [r2, #52]	; 0x34
                    
                    
                    
                    
                    
                    if (button_value == 1){
    7cf8:	9b01      	ldr	r3, [sp, #4]
    7cfa:	4914      	ldr	r1, [pc, #80]	; (7d4c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    7cfc:	4d1d      	ldr	r5, [pc, #116]	; (7d74 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>)
						new_rel_high_velocity_value += delta_high;
    7cfe:	b2ff      	uxtb	r7, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = new_rel_high_velocity_value;
    7d00:	63d7      	str	r7, [r2, #60]	; 0x3c
                    if (button_value == 1){
    7d02:	2b00      	cmp	r3, #0
    7d04:	f000 80b8 	beq.w	7e78 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3d8>
                        
                        // ABS is only updated if nonpush rotation event happened
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7d08:	9b02      	ldr	r3, [sp, #8]
                        
                        // ABS high velocity
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
                        
                        
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    7d0a:	7bc9      	ldrb	r1, [r1, #15]
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    7d0c:	4443      	add	r3, r8
    7d0e:	4423      	add	r3, r4
    7d10:	f883 c09c 	strb.w	ip, [r3, #156]	; 0x9c
                        grid_en16_helper_template_e_abs_low_velocity[bank][i] = new_abs_low_velocity_value;
    7d14:	f883 60dc 	strb.w	r6, [r3, #220]	; 0xdc
                        grid_en16_helper_template_e_abs_high_velocity[bank][i] = new_abs_high_velocity_value;
    7d18:	f883 011c 	strb.w	r0, [r3, #284]	; 0x11c
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = new_abs_low_velocity_value;
    7d1c:	e9c2 c60a 	strd	ip, r6, [r2, #40]	; 0x28
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
    7d20:	6310      	str	r0, [r2, #48]	; 0x30
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    7d22:	2301      	movs	r3, #1
                    }
                    else{
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    7d24:	480e      	ldr	r0, [pc, #56]	; (7d60 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    7d26:	4622      	mov	r2, r4
    7d28:	47a8      	blx	r5
	for (uint8_t j=0; j<16; j++){
    7d2a:	f10b 0b01 	add.w	fp, fp, #1
    7d2e:	f1bb 0f10 	cmp.w	fp, #16
    7d32:	f47f aed1 	bne.w	7ad8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x38>

			
	}
		

	grid_module_en16_reva_hardware_transfer_complete = 0;
    7d36:	4b10      	ldr	r3, [pc, #64]	; (7d78 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d8>)
    7d38:	2200      	movs	r2, #0
    7d3a:	701a      	strb	r2, [r3, #0]
	grid_module_en16_reva_hardware_start_transfer();
    7d3c:	4b0f      	ldr	r3, [pc, #60]	; (7d7c <grid_module_en16_reva_hardware_transfer_complete_cb+0x2dc>)
}
    7d3e:	b009      	add	sp, #36	; 0x24
    7d40:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_module_en16_reva_hardware_start_transfer();
    7d44:	4718      	bx	r3
    7d46:	bf00      	nop
    7d48:	41008000 	.word	0x41008000
    7d4c:	2000f008 	.word	0x2000f008
    7d50:	00009aaf 	.word	0x00009aaf
    7d54:	20000318 	.word	0x20000318
    7d58:	2000c09d 	.word	0x2000c09d
    7d5c:	20019770 	.word	0x20019770
    7d60:	2000effc 	.word	0x2000effc
    7d64:	00016258 	.word	0x00016258
    7d68:	00009b55 	.word	0x00009b55
    7d6c:	00009b51 	.word	0x00009b51
    7d70:	00016248 	.word	0x00016248
    7d74:	0000a539 	.word	0x0000a539
    7d78:	2001c854 	.word	0x2001c854
    7d7c:	00007a69 	.word	0x00007a69
    7d80:	2000067e 	.word	0x2000067e
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7d84:	b233      	sxth	r3, r6
		grid_sys_state.bank_active_changed = 0;
    7d86:	2400      	movs	r4, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7d88:	ea4f 1b03 	mov.w	fp, r3, lsl #4
    7d8c:	f8df 8108 	ldr.w	r8, [pc, #264]	; 7e98 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f8>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    7d90:	f8df a108 	ldr.w	sl, [pc, #264]	; 7e9c <grid_module_en16_reva_hardware_transfer_complete_cb+0x3fc>
		grid_sys_state.bank_active_changed = 0;
    7d94:	747c      	strb	r4, [r7, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7d96:	465d      	mov	r5, fp
    7d98:	f8d8 3004 	ldr.w	r3, [r8, #4]
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7d9c:	f8df c100 	ldr.w	ip, [pc, #256]	; 7ea0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x400>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7da0:	445b      	add	r3, fp
    7da2:	2164      	movs	r1, #100	; 0x64
    7da4:	68db      	ldr	r3, [r3, #12]
    7da6:	b2e2      	uxtb	r2, r4
    7da8:	fb01 3304 	mla	r3, r1, r4, r3
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    7dac:	f10d 0e10 	add.w	lr, sp, #16
    7db0:	f8dc 1004 	ldr.w	r1, [ip, #4]
    7db4:	f8dc 0000 	ldr.w	r0, [ip]
    7db8:	46f1      	mov	r9, lr
    7dba:	e8a9 0003 	stmia.w	r9!, {r0, r1}
    7dbe:	4933      	ldr	r1, [pc, #204]	; (7e8c <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ec>)
    7dc0:	f10c 0c08 	add.w	ip, ip, #8
    7dc4:	458c      	cmp	ip, r1
    7dc6:	46ce      	mov	lr, r9
    7dc8:	d1f2      	bne.n	7db0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x310>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7dca:	a904      	add	r1, sp, #16
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7dcc:	60dc      	str	r4, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7dce:	5d09      	ldrb	r1, [r1, r4]
    7dd0:	6119      	str	r1, [r3, #16]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    7dd2:	f815 000a 	ldrb.w	r0, [r5, sl]
    7dd6:	6198      	str	r0, [r3, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    7dd8:	482d      	ldr	r0, [pc, #180]	; (7e90 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f0>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7dda:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 7ea4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x404>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    7dde:	5c28      	ldrb	r0, [r5, r0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7de0:	6259      	str	r1, [r3, #36]	; 0x24
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7de2:	e9c3 0407 	strd	r0, r4, [r3, #28]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    7de6:	492b      	ldr	r1, [pc, #172]	; (7e94 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f4>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7de8:	9200      	str	r2, [sp, #0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    7dea:	5c68      	ldrb	r0, [r5, r1]
    7dec:	6298      	str	r0, [r3, #40]	; 0x28
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7dee:	f101 0040 	add.w	r0, r1, #64	; 0x40
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7df2:	3180      	adds	r1, #128	; 0x80
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    7df4:	5c28      	ldrb	r0, [r5, r0]
    7df6:	62d8      	str	r0, [r3, #44]	; 0x2c
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    7df8:	5c69      	ldrb	r1, [r5, r1]
    7dfa:	6319      	str	r1, [r3, #48]	; 0x30
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7dfc:	4640      	mov	r0, r8
    7dfe:	7bf9      	ldrb	r1, [r7, #15]
    7e00:	2300      	movs	r3, #0
    7e02:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    7e04:	3401      	adds	r4, #1
    7e06:	7bf9      	ldrb	r1, [r7, #15]
    7e08:	9a00      	ldr	r2, [sp, #0]
    7e0a:	2301      	movs	r3, #1
    7e0c:	4640      	mov	r0, r8
    7e0e:	47c8      	blx	r9
		for (uint8_t i = 0; i<16; i++)
    7e10:	2c10      	cmp	r4, #16
    7e12:	f105 0501 	add.w	r5, r5, #1
    7e16:	d1bf      	bne.n	7d98 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2f8>
    7e18:	e655      	b.n	7ac6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x26>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7e1a:	293f      	cmp	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7e1c:	bf08      	it	eq
    7e1e:	4663      	moveq	r3, ip
    7e20:	e6bf      	b.n	7ba2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x102>
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    7e22:	f811 3c10 	ldrb.w	r3, [r1, #-16]
    7e26:	6113      	str	r3, [r2, #16]
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;
    7e28:	2300      	movs	r3, #0
    7e2a:	6153      	str	r3, [r2, #20]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7e2c:	f89a 100f 	ldrb.w	r1, [sl, #15]
    7e30:	2305      	movs	r3, #5
    7e32:	e6c6      	b.n	7bc2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x122>
                if (a_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    7e34:	7b5a      	ldrb	r2, [r3, #13]
    7e36:	bb2a      	cbnz	r2, 7e84 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
    7e38:	7bd9      	ldrb	r1, [r3, #15]
    7e3a:	b921      	cbnz	r1, 7e46 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3a6>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    7e3c:	f04f 0901 	mov.w	r9, #1
    7e40:	f883 900f 	strb.w	r9, [r3, #15]
    7e44:	e6d6      	b.n	7bf4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
			int16_t delta = 0;
    7e46:	4691      	mov	r9, r2
    7e48:	e6d4      	b.n	7bf4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
					elapsed_ms = 25;
    7e4a:	2019      	movs	r0, #25
    7e4c:	e6e6      	b.n	7c1c <grid_module_en16_reva_hardware_transfer_complete_cb+0x17c>
						new_abs_no_velocity_value = 0;
    7e4e:	f04f 0c00 	mov.w	ip, #0
    7e52:	e72f      	b.n	7cb4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_no_velocity_value = 127;
    7e54:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
    7e58:	e72c      	b.n	7cb4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_low_velocity_value = 0;
    7e5a:	2600      	movs	r6, #0
    7e5c:	e733      	b.n	7cc6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_low_velocity_value = 127;
    7e5e:	267f      	movs	r6, #127	; 0x7f
    7e60:	e731      	b.n	7cc6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_high_velocity_value = 0;
    7e62:	2000      	movs	r0, #0
    7e64:	e73a      	b.n	7cdc <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_abs_high_velocity_value = 127;
    7e66:	207f      	movs	r0, #127	; 0x7f
    7e68:	e738      	b.n	7cdc <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_rel_no_velocity_value += delta;
    7e6a:	4489      	add	r9, r1
						new_rel_low_velocity_value += delta_low;
    7e6c:	440b      	add	r3, r1
						new_rel_no_velocity_value += delta;
    7e6e:	fa5f f589 	uxtb.w	r5, r9
						new_rel_low_velocity_value += delta_low;
    7e72:	b2db      	uxtb	r3, r3
						new_rel_high_velocity_value += delta_high;
    7e74:	440f      	add	r7, r1
    7e76:	e73d      	b.n	7cf4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x254>
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    7e78:	7bc9      	ldrb	r1, [r1, #15]
    7e7a:	230d      	movs	r3, #13
    7e7c:	e752      	b.n	7d24 <grid_module_en16_reva_hardware_transfer_complete_cb+0x284>
            if (a_now == 0 && b_now == 0){
    7e7e:	b90e      	cbnz	r6, 7e84 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                grid_ui_encoder_array[i].phase_change_lock = 0;
    7e80:	19eb      	adds	r3, r5, r7
    7e82:	73de      	strb	r6, [r3, #15]
			int16_t delta = 0;
    7e84:	f04f 0900 	mov.w	r9, #0
    7e88:	e6b4      	b.n	7bf4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
    7e8a:	bf00      	nop
    7e8c:	00016258 	.word	0x00016258
    7e90:	200006da 	.word	0x200006da
    7e94:	2000071a 	.word	0x2000071a
    7e98:	2000effc 	.word	0x2000effc
    7e9c:	2000069a 	.word	0x2000069a
    7ea0:	00016248 	.word	0x00016248
    7ea4:	0000a88d 	.word	0x0000a88d

00007ea8 <grid_module_en16_reva_hardware_init>:
    7ea8:	4b0f      	ldr	r3, [pc, #60]	; (7ee8 <grid_module_en16_reva_hardware_init+0x40>)
    7eaa:	f44f 1200 	mov.w	r2, #2097152	; 0x200000

void grid_module_en16_reva_hardware_init(void){
    7eae:	b510      	push	{r4, lr}
    7eb0:	615a      	str	r2, [r3, #20]
	
	
	
	
	
	spi_m_async_set_mode(&UI_SPI, SPI_MODE_3);
    7eb2:	4c0e      	ldr	r4, [pc, #56]	; (7eec <grid_module_en16_reva_hardware_init+0x44>)
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    7eb4:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    7eb6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    7eba:	629a      	str	r2, [r3, #40]	; 0x28
    7ebc:	4a0c      	ldr	r2, [pc, #48]	; (7ef0 <grid_module_en16_reva_hardware_init+0x48>)
    7ebe:	629a      	str	r2, [r3, #40]	; 0x28
    7ec0:	2103      	movs	r1, #3
    7ec2:	4b0c      	ldr	r3, [pc, #48]	; (7ef4 <grid_module_en16_reva_hardware_init+0x4c>)
    7ec4:	4620      	mov	r0, r4
    7ec6:	4798      	blx	r3
	spi_m_async_set_baudrate(&UI_SPI, 1000000); // was 400000 check clock div setting
    7ec8:	490b      	ldr	r1, [pc, #44]	; (7ef8 <grid_module_en16_reva_hardware_init+0x50>)
    7eca:	4b0c      	ldr	r3, [pc, #48]	; (7efc <grid_module_en16_reva_hardware_init+0x54>)
    7ecc:	4620      	mov	r0, r4
    7ece:	4798      	blx	r3
	
	spi_m_async_get_io_descriptor(&UI_SPI, &grid_module_en16_reva_hardware_io);
    7ed0:	490b      	ldr	r1, [pc, #44]	; (7f00 <grid_module_en16_reva_hardware_init+0x58>)
    7ed2:	4b0c      	ldr	r3, [pc, #48]	; (7f04 <grid_module_en16_reva_hardware_init+0x5c>)
    7ed4:	4620      	mov	r0, r4
    7ed6:	4798      	blx	r3


	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7ed8:	4620      	mov	r0, r4
    7eda:	4a0b      	ldr	r2, [pc, #44]	; (7f08 <grid_module_en16_reva_hardware_init+0x60>)
    7edc:	4b0b      	ldr	r3, [pc, #44]	; (7f0c <grid_module_en16_reva_hardware_init+0x64>)


}
    7ede:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    7ee2:	2100      	movs	r1, #0
    7ee4:	4718      	bx	r3
    7ee6:	bf00      	nop
    7ee8:	41008000 	.word	0x41008000
    7eec:	2001cc70 	.word	0x2001cc70
    7ef0:	c0000020 	.word	0xc0000020
    7ef4:	0000f571 	.word	0x0000f571
    7ef8:	000f4240 	.word	0x000f4240
    7efc:	0000f535 	.word	0x0000f535
    7f00:	2000c0a0 	.word	0x2000c0a0
    7f04:	0000f655 	.word	0x0000f655
    7f08:	00007aa1 	.word	0x00007aa1
    7f0c:	0000f611 	.word	0x0000f611

00007f10 <grid_module_en16_reva_init>:

void grid_module_en16_reva_init(){
    7f10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	grid_led_lowlevel_init(&grid_led_state, 16);
    7f14:	4b1d      	ldr	r3, [pc, #116]	; (7f8c <grid_module_en16_reva_init+0x7c>)
    7f16:	481e      	ldr	r0, [pc, #120]	; (7f90 <grid_module_en16_reva_init+0x80>)

	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
	{
		
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7f18:	4e1e      	ldr	r6, [pc, #120]	; (7f94 <grid_module_en16_reva_init+0x84>)
    7f1a:	4f1f      	ldr	r7, [pc, #124]	; (7f98 <grid_module_en16_reva_init+0x88>)
		
		for(uint8_t j=0; j<16; j++){
		
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7f1c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 7fac <grid_module_en16_reva_init+0x9c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7f20:	2110      	movs	r1, #16
    7f22:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);	
    7f24:	481b      	ldr	r0, [pc, #108]	; (7f94 <grid_module_en16_reva_init+0x84>)
    7f26:	4b1d      	ldr	r3, [pc, #116]	; (7f9c <grid_module_en16_reva_init+0x8c>)
    7f28:	2104      	movs	r1, #4
    7f2a:	4798      	blx	r3
    7f2c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7f2e:	2210      	movs	r2, #16
    7f30:	b2e1      	uxtb	r1, r4
    7f32:	4630      	mov	r0, r6
    7f34:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    7f36:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    7f3a:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    7f3c:	6870      	ldr	r0, [r6, #4]
    7f3e:	b2e9      	uxtb	r1, r5
    7f40:	2203      	movs	r2, #3
    7f42:	4448      	add	r0, r9
    7f44:	3501      	adds	r5, #1
    7f46:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    7f48:	2d10      	cmp	r5, #16
    7f4a:	d1f7      	bne.n	7f3c <grid_module_en16_reva_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
    7f4c:	3401      	adds	r4, #1
    7f4e:	2c04      	cmp	r4, #4
    7f50:	d1ed      	bne.n	7f2e <grid_module_en16_reva_init+0x1e>
    7f52:	2200      	movs	r2, #0
    7f54:	4b12      	ldr	r3, [pc, #72]	; (7fa0 <grid_module_en16_reva_init+0x90>)
	// initialize local encoder helper struct
	for (uint8_t j = 0; j<16; j++)
	{
		grid_ui_encoder_array[j].controller_number = j;
		
		grid_ui_encoder_array[j].button_value = 1;
    7f56:	2001      	movs	r0, #1
		grid_ui_encoder_array[j].button_changed = 0; 
    7f58:	4611      	mov	r1, r2
		grid_ui_encoder_array[j].rotation_value = 0;
		grid_ui_encoder_array[j].rotation_changed = 1;
		grid_ui_encoder_array[j].rotation_direction = 0;
		grid_ui_encoder_array[j].last_real_time = -1;
    7f5a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		grid_ui_encoder_array[j].controller_number = j;
    7f5e:	701a      	strb	r2, [r3, #0]
		grid_ui_encoder_array[j].button_value = 1;
    7f60:	3201      	adds	r2, #1
	for (uint8_t j = 0; j<16; j++)
    7f62:	2a10      	cmp	r2, #16
		grid_ui_encoder_array[j].button_value = 1;
    7f64:	7058      	strb	r0, [r3, #1]
		grid_ui_encoder_array[j].button_changed = 0; 
    7f66:	7099      	strb	r1, [r3, #2]
		grid_ui_encoder_array[j].rotation_value = 0;
    7f68:	70d9      	strb	r1, [r3, #3]
		grid_ui_encoder_array[j].rotation_changed = 1;
    7f6a:	7118      	strb	r0, [r3, #4]
		grid_ui_encoder_array[j].rotation_direction = 0;
    7f6c:	7159      	strb	r1, [r3, #5]
		grid_ui_encoder_array[j].last_real_time = -1;
    7f6e:	609c      	str	r4, [r3, #8]
		grid_ui_encoder_array[j].velocity = 0;
    7f70:	7319      	strb	r1, [r3, #12]
		grid_ui_encoder_array[j].phase_a_previous = 1;
    7f72:	7358      	strb	r0, [r3, #13]
		grid_ui_encoder_array[j].phase_b_previous = 1;	
    7f74:	7398      	strb	r0, [r3, #14]
        
        grid_ui_encoder_array[j].phase_change_lock = 0;
    7f76:	73d9      	strb	r1, [r3, #15]
	for (uint8_t j = 0; j<16; j++)
    7f78:	f103 0310 	add.w	r3, r3, #16
    7f7c:	d1ef      	bne.n	7f5e <grid_module_en16_reva_init+0x4e>
		
	}
	
	
	grid_module_en16_reva_hardware_init();
    7f7e:	4b09      	ldr	r3, [pc, #36]	; (7fa4 <grid_module_en16_reva_init+0x94>)
    7f80:	4798      	blx	r3
	
	
	grid_module_en16_reva_hardware_start_transfer();
	
}
    7f82:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_en16_reva_hardware_start_transfer();
    7f86:	4b08      	ldr	r3, [pc, #32]	; (7fa8 <grid_module_en16_reva_init+0x98>)
    7f88:	4718      	bx	r3
    7f8a:	bf00      	nop
    7f8c:	000072c1 	.word	0x000072c1
    7f90:	2001c838 	.word	0x2001c838
    7f94:	2000effc 	.word	0x2000effc
    7f98:	00009e4d 	.word	0x00009e4d
    7f9c:	00009e19 	.word	0x00009e19
    7fa0:	20019770 	.word	0x20019770
    7fa4:	00007ea9 	.word	0x00007ea9
    7fa8:	00007a69 	.word	0x00007a69
    7fac:	0000a779 	.word	0x0000a779

00007fb0 <grid_module_pbf4_reva_hardware_start_transfer>:
static uint8_t grid_pbf4_helper_template_b_abs[16] = {0};
	
static uint8_t grid_pbf4_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_pbf4_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};

void grid_module_pbf4_reva_hardware_start_transfer(void){
    7fb0:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7fb2:	4c04      	ldr	r4, [pc, #16]	; (7fc4 <grid_module_pbf4_reva_hardware_start_transfer+0x14>)
    7fb4:	4804      	ldr	r0, [pc, #16]	; (7fc8 <grid_module_pbf4_reva_hardware_start_transfer+0x18>)
    7fb6:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7fb8:	4623      	mov	r3, r4
    7fba:	4804      	ldr	r0, [pc, #16]	; (7fcc <grid_module_pbf4_reva_hardware_start_transfer+0x1c>)
	
}
    7fbc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7fc0:	4718      	bx	r3
    7fc2:	bf00      	nop
    7fc4:	0000e9e5 	.word	0x0000e9e5
    7fc8:	2001cd84 	.word	0x2001cd84
    7fcc:	2001cf58 	.word	0x2001cf58

00007fd0 <grid_module_pbf4_reva_hardware_transfer_complete_cb>:

void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7fd4:	4aa8      	ldr	r2, [pc, #672]	; (8278 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    7fd6:	7813      	ldrb	r3, [r2, #0]
void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    7fd8:	b08b      	sub	sp, #44	; 0x2c
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    7fda:	b933      	cbnz	r3, 7fea <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a>
		grid_module_pbf4_reva_hardware_transfer_complete++;
    7fdc:	7813      	ldrb	r3, [r2, #0]
    7fde:	3301      	adds	r3, #1
    7fe0:	b2db      	uxtb	r3, r3
    7fe2:	7013      	strb	r3, [r2, #0]
	
	
	
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
	grid_module_pbf4_reva_hardware_start_transfer();
}
    7fe4:	b00b      	add	sp, #44	; 0x2c
    7fe6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    7fea:	4ba4      	ldr	r3, [pc, #656]	; (827c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ac>)
    7fec:	7c5a      	ldrb	r2, [r3, #17]
    7fee:	469a      	mov	sl, r3
    7ff0:	bb02      	cbnz	r2, 8034 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x64>
	uint16_t adcresult_0 = 0;
    7ff2:	2300      	movs	r3, #0
    7ff4:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7ff8:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    7ffc:	4ba0      	ldr	r3, [pc, #640]	; (8280 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b0>)
    7ffe:	49a1      	ldr	r1, [pc, #644]	; (8284 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b4>)
    8000:	781a      	ldrb	r2, [r3, #0]
    8002:	3208      	adds	r2, #8
    8004:	5c8d      	ldrb	r5, [r1, r2]
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    8006:	781a      	ldrb	r2, [r3, #0]
    8008:	b2d2      	uxtb	r2, r2
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    800a:	b2ed      	uxtb	r5, r5
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    800c:	5c8c      	ldrb	r4, [r1, r2]
	grid_module_pbf4_reva_mux++;
    800e:	781a      	ldrb	r2, [r3, #0]
    8010:	3201      	adds	r2, #1
    8012:	b2d2      	uxtb	r2, r2
    8014:	701a      	strb	r2, [r3, #0]
	grid_module_pbf4_reva_mux%=8;
    8016:	781a      	ldrb	r2, [r3, #0]
    8018:	f002 0207 	and.w	r2, r2, #7
    801c:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(MUX_A, grid_module_pbf4_reva_mux/1%2);
    801e:	781a      	ldrb	r2, [r3, #0]
    8020:	f012 0f01 	tst.w	r2, #1
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    8024:	b2e4      	uxtb	r4, r4
    8026:	4a98      	ldr	r2, [pc, #608]	; (8288 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    8028:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    802c:	d133      	bne.n	8096 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xc6>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    802e:	f8c2 1114 	str.w	r1, [r2, #276]	; 0x114
}
    8032:	e032      	b.n	809a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xca>
		grid_sys_state.bank_active_changed = 0;
    8034:	2500      	movs	r5, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8036:	4c95      	ldr	r4, [pc, #596]	; (828c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8038:	4e95      	ldr	r6, [pc, #596]	; (8290 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c0>)
		grid_sys_state.bank_active_changed = 0;
    803a:	745d      	strb	r5, [r3, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    803c:	2764      	movs	r7, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    803e:	6863      	ldr	r3, [r4, #4]
    8040:	f89a 100f 	ldrb.w	r1, [sl, #15]
    8044:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    8048:	b2ea      	uxtb	r2, r5
    804a:	7a5b      	ldrb	r3, [r3, #9]
    804c:	4293      	cmp	r3, r2
    804e:	d9d0      	bls.n	7ff2 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    8050:	6863      	ldr	r3, [r4, #4]
    8052:	f89a 100f 	ldrb.w	r1, [sl, #15]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8056:	9201      	str	r2, [sp, #4]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    8058:	eb03 1301 	add.w	r3, r3, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    805c:	4620      	mov	r0, r4
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    805e:	68db      	ldr	r3, [r3, #12]
    8060:	fb07 3302 	mla	r3, r7, r2, r3
    8064:	3501      	adds	r5, #1
    8066:	60da      	str	r2, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8068:	f89a 100f 	ldrb.w	r1, [sl, #15]
    806c:	2300      	movs	r3, #0
    806e:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    8070:	f89a 100f 	ldrb.w	r1, [sl, #15]
    8074:	9a01      	ldr	r2, [sp, #4]
    8076:	2301      	movs	r3, #1
    8078:	4620      	mov	r0, r4
    807a:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    807c:	f89a 100f 	ldrb.w	r1, [sl, #15]
    8080:	9a01      	ldr	r2, [sp, #4]
    8082:	2304      	movs	r3, #4
    8084:	4620      	mov	r0, r4
    8086:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    8088:	f89a 100f 	ldrb.w	r1, [sl, #15]
    808c:	9a01      	ldr	r2, [sp, #4]
    808e:	2305      	movs	r3, #5
    8090:	4620      	mov	r0, r4
    8092:	47b0      	blx	r6
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8094:	e7d3      	b.n	803e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x6e>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8096:	f8c2 1118 	str.w	r1, [r2, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_pbf4_reva_mux/2%2);
    809a:	781a      	ldrb	r2, [r3, #0]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    809c:	4e7d      	ldr	r6, [pc, #500]	; (8294 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c4>)
    809e:	487e      	ldr	r0, [pc, #504]	; (8298 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c8>)
	uint32_t input_0 = adcresult_0*1.03;
    80a0:	f8df b210 	ldr.w	fp, [pc, #528]	; 82b4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e4>
    80a4:	f8df 9210 	ldr.w	r9, [pc, #528]	; 82b8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e8>
    80a8:	f012 0f02 	tst.w	r2, #2
    80ac:	4a76      	ldr	r2, [pc, #472]	; (8288 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    80ae:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    80b2:	bf14      	ite	ne
    80b4:	f8c2 1118 	strne.w	r1, [r2, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    80b8:	f8c2 1114 	streq.w	r1, [r2, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_pbf4_reva_mux/4%2);
    80bc:	781b      	ldrb	r3, [r3, #0]
    80be:	f013 0f04 	tst.w	r3, #4
    80c2:	4b71      	ldr	r3, [pc, #452]	; (8288 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    80c4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    80c8:	bf14      	ite	ne
    80ca:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    80ce:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    80d2:	2100      	movs	r1, #0
    80d4:	2302      	movs	r3, #2
    80d6:	aa05      	add	r2, sp, #20
    80d8:	47b0      	blx	r6
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    80da:	2302      	movs	r3, #2
    80dc:	f10d 0216 	add.w	r2, sp, #22
    80e0:	2100      	movs	r1, #0
    80e2:	486e      	ldr	r0, [pc, #440]	; (829c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2cc>)
    80e4:	47b0      	blx	r6
	uint32_t input_0 = adcresult_0*1.03;
    80e6:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    80ea:	4e6d      	ldr	r6, [pc, #436]	; (82a0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d0>)
    80ec:	47d8      	blx	fp
    80ee:	a360      	add	r3, pc, #384	; (adr r3, 8270 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    80f0:	e9d3 2300 	ldrd	r2, r3, [r3]
    80f4:	47b0      	blx	r6
    80f6:	47c8      	blx	r9
    80f8:	f64f 77ff 	movw	r7, #65535	; 0xffff
    80fc:	42b8      	cmp	r0, r7
    80fe:	4680      	mov	r8, r0
    8100:	bf28      	it	cs
    8102:	46b8      	movcs	r8, r7
    8104:	9001      	str	r0, [sp, #4]
	adcresult_0 = input_0;
    8106:	f8ad 8014 	strh.w	r8, [sp, #20]
	uint32_t input_1 = adcresult_1*1.03;
    810a:	f8bd 0016 	ldrh.w	r0, [sp, #22]
    810e:	47d8      	blx	fp
    8110:	a357      	add	r3, pc, #348	; (adr r3, 8270 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    8112:	e9d3 2300 	ldrd	r2, r3, [r3]
    8116:	47b0      	blx	r6
    8118:	47c8      	blx	r9
	adcresult_1 = input_1;
    811a:	42b8      	cmp	r0, r7
    811c:	4603      	mov	r3, r0
    811e:	bf28      	it	cs
    8120:	463b      	movcs	r3, r7
    8122:	f8ad 3016 	strh.w	r3, [sp, #22]
	if (adc_index_1 == 8 || adc_index_1 == 9){
    8126:	f1a4 0308 	sub.w	r3, r4, #8
    812a:	2b01      	cmp	r3, #1
    812c:	d972      	bls.n	8214 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
	else if (adc_index_0 > 13){ // BUTTON
    812e:	2d0d      	cmp	r5, #13
    8130:	f8df 9188 	ldr.w	r9, [pc, #392]	; 82bc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ec>
    8134:	f240 80c4 	bls.w	82c0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2f0>
		uint8_t result_value[2] = {0};
    8138:	2300      	movs	r3, #0
		if (adcresult_0>60000){
    813a:	9a01      	ldr	r2, [sp, #4]
		uint8_t result_value[2] = {0};
    813c:	f8ad 300c 	strh.w	r3, [sp, #12]
		uint8_t result_valid[2] = {0};
    8140:	f8ad 3010 	strh.w	r3, [sp, #16]
		if (adcresult_0>60000){
    8144:	f64e 2360 	movw	r3, #60000	; 0xea60
		result_index[0] = adc_index_0-4;
    8148:	3d04      	subs	r5, #4
		result_index[1] = adc_index_1-4;
    814a:	3c04      	subs	r4, #4
		if (adcresult_0>60000){
    814c:	429a      	cmp	r2, r3
		result_index[0] = adc_index_0-4;
    814e:	f88d 5008 	strb.w	r5, [sp, #8]
		result_index[1] = adc_index_1-4;
    8152:	f88d 4009 	strb.w	r4, [sp, #9]
		if (adcresult_0>60000){
    8156:	d963      	bls.n	8220 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x250>
			result_valid[0] = 1;
    8158:	2301      	movs	r3, #1
    815a:	f88d 3010 	strb.w	r3, [sp, #16]
		if (adcresult_1>60000){
    815e:	f64e 2360 	movw	r3, #60000	; 0xea60
    8162:	4298      	cmp	r0, r3
    8164:	d963      	bls.n	822e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x25e>
			result_value[1] = 0;
    8166:	2300      	movs	r3, #0
			result_value[1] = 127;
    8168:	f88d 300d 	strb.w	r3, [sp, #13]
			result_valid[1] = 1;
    816c:	2301      	movs	r3, #1
    816e:	f88d 3011 	strb.w	r3, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8172:	4b4c      	ldr	r3, [pc, #304]	; (82a4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d4>)
    8174:	ac06      	add	r4, sp, #24
    8176:	6818      	ldr	r0, [r3, #0]
    8178:	6859      	ldr	r1, [r3, #4]
    817a:	4622      	mov	r2, r4
    817c:	c203      	stmia	r2!, {r0, r1}
    817e:	3308      	adds	r3, #8
    8180:	454b      	cmp	r3, r9
    8182:	4614      	mov	r4, r2
    8184:	d1f7      	bne.n	8176 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a6>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8186:	f8df b104 	ldr.w	fp, [pc, #260]	; 828c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>
    818a:	ab03      	add	r3, sp, #12
    818c:	f10d 0808 	add.w	r8, sp, #8
    8190:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8192:	2400      	movs	r4, #0
    8194:	46d9      	mov	r9, fp
			uint8_t res_value = result_value[i];
    8196:	9b01      	ldr	r3, [sp, #4]
			uint8_t res_index = result_index[i];
    8198:	f818 7b01 	ldrb.w	r7, [r8], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    819c:	4a42      	ldr	r2, [pc, #264]	; (82a8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
			uint8_t res_value = result_value[i];
    819e:	f813 6b01 	ldrb.w	r6, [r3], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    81a2:	5dd2      	ldrb	r2, [r2, r7]
			uint8_t res_value = result_value[i];
    81a4:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81a6:	f8db 3004 	ldr.w	r3, [fp, #4]
    81aa:	f89a 100f 	ldrb.w	r1, [sl, #15]
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    81ae:	4296      	cmp	r6, r2
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81b0:	b2c9      	uxtb	r1, r1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    81b2:	d02e      	beq.n	8212 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			uint8_t res_valid = result_valid[i];
    81b4:	a804      	add	r0, sp, #16
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    81b6:	5c20      	ldrb	r0, [r4, r0]
    81b8:	2801      	cmp	r0, #1
    81ba:	d12a      	bne.n	8212 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81bc:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    81c0:	2064      	movs	r0, #100	; 0x64
    81c2:	68db      	ldr	r3, [r3, #12]
    81c4:	fb17 f000 	smulbb	r0, r7, r0
    81c8:	4403      	add	r3, r0
				if (grid_pbf4_helper_template_b_abs[res_index] == 0){ // Button Press Event
    81ca:	2a00      	cmp	r2, #0
    81cc:	d13b      	bne.n	8246 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x276>
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    81ce:	6999      	ldr	r1, [r3, #24]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    81d0:	2900      	cmp	r1, #0
    81d2:	bf0c      	ite	eq
    81d4:	217f      	moveq	r1, #127	; 0x7f
    81d6:	2100      	movne	r1, #0
    81d8:	6199      	str	r1, [r3, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    81da:	69d9      	ldr	r1, [r3, #28]
    81dc:	bb69      	cbnz	r1, 823a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x26a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    81de:	213f      	movs	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    81e0:	61d9      	str	r1, [r3, #28]
					grid_pbf4_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    81e2:	f89a 300f 	ldrb.w	r3, [sl, #15]
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    81e6:	f89a 300f 	ldrb.w	r3, [sl, #15]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    81ea:	227f      	movs	r2, #127	; 0x7f
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    81ec:	2300      	movs	r3, #0
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    81ee:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    81f2:	4419      	add	r1, r3
    81f4:	3310      	adds	r3, #16
    81f6:	68c9      	ldr	r1, [r1, #12]
    81f8:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    81fa:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    81fc:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    81fe:	d1f6      	bne.n	81ee <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x21e>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    8200:	f89a 100f 	ldrb.w	r1, [sl, #15]
    8204:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    8206:	4d29      	ldr	r5, [pc, #164]	; (82ac <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2dc>)
    8208:	463a      	mov	r2, r7
    820a:	4658      	mov	r0, fp
    820c:	47a8      	blx	r5
					grid_pbf4_helper_template_b_abs[result_index[i]] = res_value;
    820e:	4b26      	ldr	r3, [pc, #152]	; (82a8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
    8210:	55de      	strb	r6, [r3, r7]
		for (uint8_t i=0; i<2; i++)
    8212:	b184      	cbz	r4, 8236 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x266>
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
    8214:	4a18      	ldr	r2, [pc, #96]	; (8278 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    8216:	2300      	movs	r3, #0
    8218:	7013      	strb	r3, [r2, #0]
	grid_module_pbf4_reva_hardware_start_transfer();
    821a:	4b25      	ldr	r3, [pc, #148]	; (82b0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e0>)
    821c:	4798      	blx	r3
    821e:	e6e1      	b.n	7fe4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x14>
		else if (adcresult_0<200){
    8220:	9b01      	ldr	r3, [sp, #4]
    8222:	2bc7      	cmp	r3, #199	; 0xc7
    8224:	d89b      	bhi.n	815e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x18e>
			result_value[0] = 127;
    8226:	237f      	movs	r3, #127	; 0x7f
    8228:	f88d 300c 	strb.w	r3, [sp, #12]
    822c:	e794      	b.n	8158 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x188>
		else if (adcresult_1<200){
    822e:	28c7      	cmp	r0, #199	; 0xc7
    8230:	d89f      	bhi.n	8172 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a2>
			result_value[1] = 127;
    8232:	237f      	movs	r3, #127	; 0x7f
    8234:	e798      	b.n	8168 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x198>
    8236:	2401      	movs	r4, #1
    8238:	e7ad      	b.n	8196 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1c6>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    823a:	293f      	cmp	r1, #63	; 0x3f
    823c:	d101      	bne.n	8242 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x272>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    823e:	217f      	movs	r1, #127	; 0x7f
    8240:	e7ce      	b.n	81e0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x210>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    8242:	61da      	str	r2, [r3, #28]
    8244:	e7cd      	b.n	81e2 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x212>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    8246:	aa0a      	add	r2, sp, #40	; 0x28
    8248:	19d1      	adds	r1, r2, r7
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    824a:	60df      	str	r7, [r3, #12]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    824c:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    8250:	6119      	str	r1, [r3, #16]
    8252:	2300      	movs	r3, #0
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    8254:	461a      	mov	r2, r3
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8256:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    825a:	4419      	add	r1, r3
    825c:	3310      	adds	r3, #16
    825e:	68c9      	ldr	r1, [r1, #12]
    8260:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8262:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    8264:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8266:	d1f6      	bne.n	8256 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x286>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    8268:	f89a 100f 	ldrb.w	r1, [sl, #15]
    826c:	2305      	movs	r3, #5
    826e:	e7ca      	b.n	8206 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x236>
    8270:	47ae147b 	.word	0x47ae147b
    8274:	3ff07ae1 	.word	0x3ff07ae1
    8278:	2000c0ac 	.word	0x2000c0ac
    827c:	2000f008 	.word	0x2000f008
    8280:	2001c7c8 	.word	0x2001c7c8
    8284:	20000329 	.word	0x20000329
    8288:	41008000 	.word	0x41008000
    828c:	2000effc 	.word	0x2000effc
    8290:	0000a88d 	.word	0x0000a88d
    8294:	0000e929 	.word	0x0000e929
    8298:	2001cd84 	.word	0x2001cd84
    829c:	2001cf58 	.word	0x2001cf58
    82a0:	000142ed 	.word	0x000142ed
    82a4:	00016258 	.word	0x00016258
    82a8:	200007eb 	.word	0x200007eb
    82ac:	0000a539 	.word	0x0000a539
    82b0:	00007fb1 	.word	0x00007fb1
    82b4:	00014219 	.word	0x00014219
    82b8:	00014711 	.word	0x00014711
    82bc:	00016268 	.word	0x00016268
		if (adc_index_1 == 0 || adc_index_1 == 1){
    82c0:	2c01      	cmp	r4, #1
    82c2:	4e33      	ldr	r6, [pc, #204]	; (8390 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c0>)
    82c4:	d85e      	bhi.n	8384 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3b4>
			grid_ain_add_sample(adc_index_0, (1<<16)-1-adcresult_0);
    82c6:	ea88 0107 	eor.w	r1, r8, r7
    82ca:	4628      	mov	r0, r5
    82cc:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, (1<<16)-1-adcresult_1);
    82ce:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    82d2:	1a79      	subs	r1, r7, r1
			grid_ain_add_sample(adc_index_1, adcresult_1);
    82d4:	4620      	mov	r0, r4
    82d6:	47b0      	blx	r6
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    82d8:	4a2e      	ldr	r2, [pc, #184]	; (8394 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c4>)
		result_index[0] = adc_index_0;
    82da:	f88d 5010 	strb.w	r5, [sp, #16]
		result_index[1] = adc_index_1;
    82de:	f88d 4011 	strb.w	r4, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    82e2:	ab06      	add	r3, sp, #24
    82e4:	6810      	ldr	r0, [r2, #0]
    82e6:	6851      	ldr	r1, [r2, #4]
    82e8:	461c      	mov	r4, r3
    82ea:	c403      	stmia	r4!, {r0, r1}
    82ec:	3208      	adds	r2, #8
    82ee:	454a      	cmp	r2, r9
    82f0:	4623      	mov	r3, r4
    82f2:	d1f7      	bne.n	82e4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x314>
		for (uint8_t i=0; i<2; i++)
    82f4:	ab04      	add	r3, sp, #16
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    82f6:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 83a0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>
    82fa:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    82fc:	f04f 0902 	mov.w	r9, #2
			uint8_t res_index = result_index[i];
    8300:	9b01      	ldr	r3, [sp, #4]
    8302:	f813 4b01 	ldrb.w	r4, [r3], #1
    8306:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8308:	f8d8 3004 	ldr.w	r3, [r8, #4]
    830c:	f89a 200f 	ldrb.w	r2, [sl, #15]
    8310:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			if (grid_ain_get_changed(res_index)){
    8314:	4620      	mov	r0, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8316:	68dd      	ldr	r5, [r3, #12]
			if (grid_ain_get_changed(res_index)){
    8318:	4b1f      	ldr	r3, [pc, #124]	; (8398 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c8>)
    831a:	4798      	blx	r3
    831c:	b358      	cbz	r0, 8376 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3a6>
				uint8_t res_value = grid_ain_get_average(res_index, 7);
    831e:	4e1f      	ldr	r6, [pc, #124]	; (839c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3cc>)
    8320:	2107      	movs	r1, #7
    8322:	4620      	mov	r0, r4
    8324:	47b0      	blx	r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8326:	2764      	movs	r7, #100	; 0x64
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    8328:	ab0a      	add	r3, sp, #40	; 0x28
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    832a:	fb14 f707 	smulbb	r7, r4, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    832e:	4423      	add	r3, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8330:	443d      	add	r5, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    8332:	f813 3c10 	ldrb.w	r3, [r3, #-16]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    8336:	60ec      	str	r4, [r5, #12]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    8338:	612b      	str	r3, [r5, #16]
    833a:	2500      	movs	r5, #0
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    833c:	4b18      	ldr	r3, [pc, #96]	; (83a0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>)
    833e:	685a      	ldr	r2, [r3, #4]
    8340:	442a      	add	r2, r5
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8342:	2107      	movs	r1, #7
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8344:	68d2      	ldr	r2, [r2, #12]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8346:	4620      	mov	r0, r4
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8348:	eb02 0b07 	add.w	fp, r2, r7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    834c:	47b0      	blx	r6
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    834e:	2107      	movs	r1, #7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8350:	f8cb 0014 	str.w	r0, [fp, #20]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8354:	4620      	mov	r0, r4
    8356:	47b0      	blx	r6
    8358:	3510      	adds	r5, #16
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    835a:	2300      	movs	r3, #0
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    835c:	2d40      	cmp	r5, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    835e:	f8cb 0018 	str.w	r0, [fp, #24]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    8362:	f8cb 301c 	str.w	r3, [fp, #28]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8366:	d1e9      	bne.n	833c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x36c>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);
    8368:	4622      	mov	r2, r4
    836a:	f89a 100f 	ldrb.w	r1, [sl, #15]
    836e:	4c0d      	ldr	r4, [pc, #52]	; (83a4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d4>)
    8370:	2301      	movs	r3, #1
    8372:	4640      	mov	r0, r8
    8374:	47a0      	blx	r4
		for (uint8_t i=0; i<2; i++)
    8376:	f1b9 0f01 	cmp.w	r9, #1
    837a:	f43f af4b 	beq.w	8214 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
    837e:	f04f 0901 	mov.w	r9, #1
    8382:	e7bd      	b.n	8300 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x330>
			grid_ain_add_sample(adc_index_0, adcresult_0);
    8384:	4641      	mov	r1, r8
    8386:	4628      	mov	r0, r5
    8388:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, adcresult_1);
    838a:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    838e:	e7a1      	b.n	82d4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x304>
    8390:	000045e9 	.word	0x000045e9
    8394:	00016258 	.word	0x00016258
    8398:	000046b1 	.word	0x000046b1
    839c:	000046c1 	.word	0x000046c1
    83a0:	2000effc 	.word	0x2000effc
    83a4:	0000a539 	.word	0x0000a539

000083a8 <grid_module_pbf4_reva_hardware_init>:

void grid_module_pbf4_reva_hardware_init(void){
    83a8:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    83aa:	4c0b      	ldr	r4, [pc, #44]	; (83d8 <grid_module_pbf4_reva_hardware_init+0x30>)
    83ac:	4e0b      	ldr	r6, [pc, #44]	; (83dc <grid_module_pbf4_reva_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    83ae:	4d0c      	ldr	r5, [pc, #48]	; (83e0 <grid_module_pbf4_reva_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    83b0:	4b0c      	ldr	r3, [pc, #48]	; (83e4 <grid_module_pbf4_reva_hardware_init+0x3c>)
    83b2:	2200      	movs	r2, #0
    83b4:	4611      	mov	r1, r2
    83b6:	4620      	mov	r0, r4
    83b8:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    83ba:	2200      	movs	r2, #0
    83bc:	4b09      	ldr	r3, [pc, #36]	; (83e4 <grid_module_pbf4_reva_hardware_init+0x3c>)
    83be:	4611      	mov	r1, r2
    83c0:	4628      	mov	r0, r5
    83c2:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    83c4:	4620      	mov	r0, r4
    83c6:	4c08      	ldr	r4, [pc, #32]	; (83e8 <grid_module_pbf4_reva_hardware_init+0x40>)
    83c8:	2100      	movs	r1, #0
    83ca:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    83cc:	4628      	mov	r0, r5
    83ce:	4623      	mov	r3, r4
    83d0:	2100      	movs	r1, #0

}
    83d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    83d6:	4718      	bx	r3
    83d8:	2001cd84 	.word	0x2001cd84
    83dc:	0000e8b1 	.word	0x0000e8b1
    83e0:	2001cf58 	.word	0x2001cf58
    83e4:	00007fd1 	.word	0x00007fd1
    83e8:	0000e871 	.word	0x0000e871

000083ec <grid_module_pbf4_reva_init>:




void grid_module_pbf4_reva_init(){
    83ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    83f0:	220e      	movs	r2, #14
    83f2:	4c16      	ldr	r4, [pc, #88]	; (844c <grid_module_pbf4_reva_init+0x60>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);

	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 12);
    83f4:	4e16      	ldr	r6, [pc, #88]	; (8450 <grid_module_pbf4_reva_init+0x64>)
    83f6:	f8df 9074 	ldr.w	r9, [pc, #116]	; 846c <grid_module_pbf4_reva_init+0x80>
    83fa:	4f16      	ldr	r7, [pc, #88]	; (8454 <grid_module_pbf4_reva_init+0x68>)
	grid_ain_init(16, 5, 14, 7);
    83fc:	2307      	movs	r3, #7
    83fe:	2105      	movs	r1, #5
    8400:	2010      	movs	r0, #16
    8402:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 12);	
    8404:	4b14      	ldr	r3, [pc, #80]	; (8458 <grid_module_pbf4_reva_init+0x6c>)
    8406:	4815      	ldr	r0, [pc, #84]	; (845c <grid_module_pbf4_reva_init+0x70>)
    8408:	210c      	movs	r1, #12
    840a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    840c:	4810      	ldr	r0, [pc, #64]	; (8450 <grid_module_pbf4_reva_init+0x64>)
    840e:	4b14      	ldr	r3, [pc, #80]	; (8460 <grid_module_pbf4_reva_init+0x74>)
    8410:	2104      	movs	r1, #4
    8412:	4798      	blx	r3
    8414:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 12);
    8416:	220c      	movs	r2, #12
    8418:	b2e1      	uxtb	r1, r4
    841a:	4630      	mov	r0, r6
    841c:	47c8      	blx	r9
		
		for(uint8_t j=0; j<12; j++){
    841e:	ea4f 1804 	mov.w	r8, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 12);
    8422:	2500      	movs	r5, #0
			
				
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8424:	6870      	ldr	r0, [r6, #4]
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
    8426:	2d07      	cmp	r5, #7
    8428:	b2e9      	uxtb	r1, r5
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    842a:	bf94      	ite	ls
    842c:	2201      	movls	r2, #1
			
			}
			else{ // BUTTONS -> MIDI Note On/Off
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    842e:	2202      	movhi	r2, #2
    8430:	4440      	add	r0, r8
    8432:	3501      	adds	r5, #1
    8434:	47b8      	blx	r7
		for(uint8_t j=0; j<12; j++){
    8436:	2d0c      	cmp	r5, #12
    8438:	d1f4      	bne.n	8424 <grid_module_pbf4_reva_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    843a:	3401      	adds	r4, #1
    843c:	2c04      	cmp	r4, #4
    843e:	d1ea      	bne.n	8416 <grid_module_pbf4_reva_init+0x2a>
			}
			
		}	
	}
			
	grid_module_pbf4_reva_hardware_init();
    8440:	4b08      	ldr	r3, [pc, #32]	; (8464 <grid_module_pbf4_reva_init+0x78>)
    8442:	4798      	blx	r3
	grid_module_pbf4_reva_hardware_start_transfer();
	
    8444:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_pbf4_reva_hardware_start_transfer();
    8448:	4b07      	ldr	r3, [pc, #28]	; (8468 <grid_module_pbf4_reva_init+0x7c>)
    844a:	4718      	bx	r3
    844c:	000045a5 	.word	0x000045a5
    8450:	2000effc 	.word	0x2000effc
    8454:	0000a779 	.word	0x0000a779
    8458:	000072c1 	.word	0x000072c1
    845c:	2001c838 	.word	0x2001c838
    8460:	00009e19 	.word	0x00009e19
    8464:	000083a9 	.word	0x000083a9
    8468:	00007fb1 	.word	0x00007fb1
    846c:	00009e4d 	.word	0x00009e4d

00008470 <grid_module_po16_revb_hardware_start_transfer>:

volatile uint8_t grid_module_po16_revb_hardware_transfer_complete = 0;
volatile uint8_t grid_module_po16_revb_mux =0;
volatile uint8_t grid_module_po16_revb_mux_lookup[16] = {0, 1, 4, 5, 8, 9, 12, 13, 2, 3, 6, 7, 10, 11, 14, 15};

void grid_module_po16_revb_hardware_start_transfer(void){
    8470:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    8472:	4c04      	ldr	r4, [pc, #16]	; (8484 <grid_module_po16_revb_hardware_start_transfer+0x14>)
    8474:	4804      	ldr	r0, [pc, #16]	; (8488 <grid_module_po16_revb_hardware_start_transfer+0x18>)
    8476:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    8478:	4623      	mov	r3, r4
    847a:	4804      	ldr	r0, [pc, #16]	; (848c <grid_module_po16_revb_hardware_start_transfer+0x1c>)
	
}
    847c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    8480:	4718      	bx	r3
    8482:	bf00      	nop
    8484:	0000e9e5 	.word	0x0000e9e5
    8488:	2001cd84 	.word	0x2001cd84
    848c:	2001cf58 	.word	0x2001cf58

00008490 <grid_module_po16_revb_hardware_transfer_complete_cb>:

static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    8490:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    8494:	4a88      	ldr	r2, [pc, #544]	; (86b8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x228>)
    8496:	7813      	ldrb	r3, [r2, #0]
static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    8498:	b089      	sub	sp, #36	; 0x24
    849a:	4614      	mov	r4, r2
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    849c:	b933      	cbnz	r3, 84ac <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_po16_revb_hardware_transfer_complete++;
    849e:	7813      	ldrb	r3, [r2, #0]
    84a0:	3301      	adds	r3, #1
    84a2:	b2db      	uxtb	r3, r3
    84a4:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_po16_revb_hardware_transfer_complete = 0;
	grid_module_po16_revb_hardware_start_transfer();
}
    84a6:	b009      	add	sp, #36	; 0x24
    84a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    84ac:	4d83      	ldr	r5, [pc, #524]	; (86bc <grid_module_po16_revb_hardware_transfer_complete_cb+0x22c>)
    84ae:	7c6b      	ldrb	r3, [r5, #17]
    84b0:	b9fb      	cbnz	r3, 84f2 <grid_module_po16_revb_hardware_transfer_complete_cb+0x62>
	uint16_t adcresult_0 = 0;
    84b2:	2300      	movs	r3, #0
    84b4:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint16_t adcresult_1 = 0;
    84b8:	f8ad 300e 	strh.w	r3, [sp, #14]
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    84bc:	7863      	ldrb	r3, [r4, #1]
    84be:	4a80      	ldr	r2, [pc, #512]	; (86c0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x230>)
    84c0:	3308      	adds	r3, #8
    84c2:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    84c4:	7863      	ldrb	r3, [r4, #1]
    84c6:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    84c8:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    84ca:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_po16_revb_mux++;
    84cc:	7863      	ldrb	r3, [r4, #1]
    84ce:	3301      	adds	r3, #1
    84d0:	b2db      	uxtb	r3, r3
    84d2:	7063      	strb	r3, [r4, #1]
	grid_module_po16_revb_mux%=8;
    84d4:	7863      	ldrb	r3, [r4, #1]
    84d6:	f003 0307 	and.w	r3, r3, #7
    84da:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_po16_revb_mux/1%2);
    84dc:	7863      	ldrb	r3, [r4, #1]
    84de:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    84e2:	b2f6      	uxtb	r6, r6
    84e4:	4b77      	ldr	r3, [pc, #476]	; (86c4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    84e6:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    84ea:	d128      	bne.n	853e <grid_module_po16_revb_hardware_transfer_complete_cb+0xae>
    84ec:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    84f0:	e027      	b.n	8542 <grid_module_po16_revb_hardware_transfer_complete_cb+0xb2>
		grid_sys_state.bank_active_changed = 0;
    84f2:	2600      	movs	r6, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    84f4:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 86dc <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    84f8:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 86ec <grid_module_po16_revb_hardware_transfer_complete_cb+0x25c>
		grid_sys_state.bank_active_changed = 0;
    84fc:	746e      	strb	r6, [r5, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    84fe:	f04f 0a64 	mov.w	sl, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8502:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8506:	7bea      	ldrb	r2, [r5, #15]
    8508:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    850c:	b2f7      	uxtb	r7, r6
    850e:	7a5b      	ldrb	r3, [r3, #9]
    8510:	42bb      	cmp	r3, r7
    8512:	d9ce      	bls.n	84b2 <grid_module_po16_revb_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8514:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8518:	7bea      	ldrb	r2, [r5, #15]
    851a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    851e:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8520:	68db      	ldr	r3, [r3, #12]
    8522:	fb0a 3307 	mla	r3, sl, r7, r3
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8526:	463a      	mov	r2, r7
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8528:	60df      	str	r7, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    852a:	7be9      	ldrb	r1, [r5, #15]
    852c:	2300      	movs	r3, #0
    852e:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    8530:	7be9      	ldrb	r1, [r5, #15]
    8532:	2301      	movs	r3, #1
    8534:	463a      	mov	r2, r7
    8536:	4640      	mov	r0, r8
    8538:	47c8      	blx	r9
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    853a:	3601      	adds	r6, #1
    853c:	e7e1      	b.n	8502 <grid_module_po16_revb_hardware_transfer_complete_cb+0x72>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    853e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_po16_revb_mux/2%2);
    8542:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8544:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 86f0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x260>
    8548:	485f      	ldr	r0, [pc, #380]	; (86c8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x238>)
	uint32_t input_0 = adcresult_0*1.03;	
    854a:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 86f4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x264>
    854e:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 86f8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x268>
    8552:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 86fc <grid_module_po16_revb_hardware_transfer_complete_cb+0x26c>
    8556:	f013 0f02 	tst.w	r3, #2
    855a:	4b5a      	ldr	r3, [pc, #360]	; (86c4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    855c:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    8560:	bf14      	ite	ne
    8562:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8566:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_po16_revb_mux/4%2);
    856a:	7863      	ldrb	r3, [r4, #1]
    856c:	f013 0f04 	tst.w	r3, #4
    8570:	4b54      	ldr	r3, [pc, #336]	; (86c4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    8572:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8576:	bf14      	ite	ne
    8578:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    857c:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8580:	2100      	movs	r1, #0
    8582:	2302      	movs	r3, #2
    8584:	aa03      	add	r2, sp, #12
    8586:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    8588:	2302      	movs	r3, #2
    858a:	f10d 020e 	add.w	r2, sp, #14
    858e:	2100      	movs	r1, #0
    8590:	484e      	ldr	r0, [pc, #312]	; (86cc <grid_module_po16_revb_hardware_transfer_complete_cb+0x23c>)
    8592:	47c0      	blx	r8
	uint32_t input_0 = adcresult_0*1.03;	
    8594:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    8598:	47d8      	blx	fp
    859a:	a345      	add	r3, pc, #276	; (adr r3, 86b0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    859c:	e9d3 2300 	ldrd	r2, r3, [r3]
    85a0:	47d0      	blx	sl
    85a2:	47c8      	blx	r9
	adcresult_0 = input_0;
    85a4:	f64f 78ff 	movw	r8, #65535	; 0xffff
    85a8:	4540      	cmp	r0, r8
    85aa:	bf28      	it	cs
    85ac:	4640      	movcs	r0, r8
    85ae:	f8ad 000c 	strh.w	r0, [sp, #12]
	uint32_t input_1 = adcresult_1*1.03;	
    85b2:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    85b6:	47d8      	blx	fp
    85b8:	a33d      	add	r3, pc, #244	; (adr r3, 86b0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    85ba:	e9d3 2300 	ldrd	r2, r3, [r3]
    85be:	47d0      	blx	sl
    85c0:	47c8      	blx	r9
	adcresult_1 = input_1;
    85c2:	4540      	cmp	r0, r8
    85c4:	bf28      	it	cs
    85c6:	4640      	movcs	r0, r8
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    85c8:	4b41      	ldr	r3, [pc, #260]	; (86d0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x240>)
	adcresult_1 = input_1;
    85ca:	f8ad 000e 	strh.w	r0, [sp, #14]
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    85ce:	4798      	blx	r3
    85d0:	2808      	cmp	r0, #8
    85d2:	d109      	bne.n	85e8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x158>
		adcresult_0	= 65535 - adcresult_0;
    85d4:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    85d8:	43db      	mvns	r3, r3
    85da:	f8ad 300c 	strh.w	r3, [sp, #12]
		adcresult_1 = 65535 - adcresult_1;
    85de:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    85e2:	43db      	mvns	r3, r3
    85e4:	f8ad 300e 	strh.w	r3, [sp, #14]
	grid_ain_add_sample(adc_index_0, adcresult_0);
    85e8:	f8bd 100c 	ldrh.w	r1, [sp, #12]
    85ec:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8700 <grid_module_po16_revb_hardware_transfer_complete_cb+0x270>
    85f0:	4638      	mov	r0, r7
    85f2:	47c0      	blx	r8
	grid_ain_add_sample(adc_index_1, adcresult_1);
    85f4:	4630      	mov	r0, r6
    85f6:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    85fa:	47c0      	blx	r8
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    85fc:	4b35      	ldr	r3, [pc, #212]	; (86d4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x244>)
	result_index[0] = adc_index_0;
    85fe:	f88d 7008 	strb.w	r7, [sp, #8]
	result_index[1] = adc_index_1;
    8602:	f88d 6009 	strb.w	r6, [sp, #9]
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8606:	f103 0710 	add.w	r7, r3, #16
    860a:	ae04      	add	r6, sp, #16
    860c:	6818      	ldr	r0, [r3, #0]
    860e:	6859      	ldr	r1, [r3, #4]
    8610:	4632      	mov	r2, r6
    8612:	c203      	stmia	r2!, {r0, r1}
    8614:	3308      	adds	r3, #8
    8616:	42bb      	cmp	r3, r7
    8618:	4616      	mov	r6, r2
    861a:	d1f7      	bne.n	860c <grid_module_po16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    861c:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 86dc <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
    8620:	f10d 0a08 	add.w	sl, sp, #8
	for (uint8_t i=0; i<2; i++)
    8624:	f04f 0900 	mov.w	r9, #0
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8628:	f8d8 3004 	ldr.w	r3, [r8, #4]
    862c:	7bea      	ldrb	r2, [r5, #15]
		uint8_t res_index = result_index[i];
    862e:	f81a 6b01 	ldrb.w	r6, [sl], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8632:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		if (grid_ain_get_changed(res_index)){
    8636:	4630      	mov	r0, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8638:	68df      	ldr	r7, [r3, #12]
		if (grid_ain_get_changed(res_index)){
    863a:	4b27      	ldr	r3, [pc, #156]	; (86d8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x248>)
    863c:	4798      	blx	r3
    863e:	b350      	cbz	r0, 8696 <grid_module_po16_revb_hardware_transfer_complete_cb+0x206>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8640:	2264      	movs	r2, #100	; 0x64
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8642:	a908      	add	r1, sp, #32
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8644:	fb16 f202 	smulbb	r2, r6, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8648:	4431      	add	r1, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    864a:	18bb      	adds	r3, r7, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    864c:	f811 1c10 	ldrb.w	r1, [r1, #-16]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    8650:	60de      	str	r6, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8652:	6119      	str	r1, [r3, #16]
    8654:	2700      	movs	r7, #0
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8656:	4b21      	ldr	r3, [pc, #132]	; (86dc <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>)
    8658:	9201      	str	r2, [sp, #4]
    865a:	685b      	ldr	r3, [r3, #4]
    865c:	443b      	add	r3, r7
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    865e:	2107      	movs	r1, #7
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8660:	68db      	ldr	r3, [r3, #12]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8662:	4630      	mov	r0, r6
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8664:	eb03 0b02 	add.w	fp, r3, r2
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8668:	4b1d      	ldr	r3, [pc, #116]	; (86e0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
    866a:	4798      	blx	r3
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    866c:	4b1c      	ldr	r3, [pc, #112]	; (86e0 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    866e:	f8cb 0014 	str.w	r0, [fp, #20]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8672:	2107      	movs	r1, #7
    8674:	4630      	mov	r0, r6
    8676:	4798      	blx	r3
    8678:	3710      	adds	r7, #16
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    867a:	2300      	movs	r3, #0
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    867c:	2f40      	cmp	r7, #64	; 0x40
    867e:	9a01      	ldr	r2, [sp, #4]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8680:	f8cb 0018 	str.w	r0, [fp, #24]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    8684:	f8cb 301c 	str.w	r3, [fp, #28]
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8688:	d1e5      	bne.n	8656 <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c6>
			grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);		
    868a:	4632      	mov	r2, r6
    868c:	7be9      	ldrb	r1, [r5, #15]
    868e:	4e15      	ldr	r6, [pc, #84]	; (86e4 <grid_module_po16_revb_hardware_transfer_complete_cb+0x254>)
    8690:	2301      	movs	r3, #1
    8692:	4640      	mov	r0, r8
    8694:	47b0      	blx	r6
	for (uint8_t i=0; i<2; i++)
    8696:	f1b9 0f00 	cmp.w	r9, #0
    869a:	d004      	beq.n	86a6 <grid_module_po16_revb_hardware_transfer_complete_cb+0x216>
	grid_module_po16_revb_hardware_transfer_complete = 0;
    869c:	2300      	movs	r3, #0
    869e:	7023      	strb	r3, [r4, #0]
	grid_module_po16_revb_hardware_start_transfer();
    86a0:	4b11      	ldr	r3, [pc, #68]	; (86e8 <grid_module_po16_revb_hardware_transfer_complete_cb+0x258>)
    86a2:	4798      	blx	r3
    86a4:	e6ff      	b.n	84a6 <grid_module_po16_revb_hardware_transfer_complete_cb+0x16>
    86a6:	f04f 0901 	mov.w	r9, #1
    86aa:	e7bd      	b.n	8628 <grid_module_po16_revb_hardware_transfer_complete_cb+0x198>
    86ac:	f3af 8000 	nop.w
    86b0:	47ae147b 	.word	0x47ae147b
    86b4:	3ff07ae1 	.word	0x3ff07ae1
    86b8:	200007fd 	.word	0x200007fd
    86bc:	2000f008 	.word	0x2000f008
    86c0:	20000339 	.word	0x20000339
    86c4:	41008000 	.word	0x41008000
    86c8:	2001cd84 	.word	0x2001cd84
    86cc:	2001cf58 	.word	0x2001cf58
    86d0:	00009c95 	.word	0x00009c95
    86d4:	00016268 	.word	0x00016268
    86d8:	000046b1 	.word	0x000046b1
    86dc:	2000effc 	.word	0x2000effc
    86e0:	000046c1 	.word	0x000046c1
    86e4:	0000a539 	.word	0x0000a539
    86e8:	00008471 	.word	0x00008471
    86ec:	0000a88d 	.word	0x0000a88d
    86f0:	0000e929 	.word	0x0000e929
    86f4:	00014219 	.word	0x00014219
    86f8:	000142ed 	.word	0x000142ed
    86fc:	00014711 	.word	0x00014711
    8700:	000045e9 	.word	0x000045e9

00008704 <grid_module_po16_revb_hardware_init>:

void grid_module_po16_revb_hardware_init(void){
    8704:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8706:	4c0b      	ldr	r4, [pc, #44]	; (8734 <grid_module_po16_revb_hardware_init+0x30>)
    8708:	4e0b      	ldr	r6, [pc, #44]	; (8738 <grid_module_po16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    870a:	4d0c      	ldr	r5, [pc, #48]	; (873c <grid_module_po16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    870c:	4b0c      	ldr	r3, [pc, #48]	; (8740 <grid_module_po16_revb_hardware_init+0x3c>)
    870e:	2200      	movs	r2, #0
    8710:	4611      	mov	r1, r2
    8712:	4620      	mov	r0, r4
    8714:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8716:	2200      	movs	r2, #0
    8718:	4b09      	ldr	r3, [pc, #36]	; (8740 <grid_module_po16_revb_hardware_init+0x3c>)
    871a:	4611      	mov	r1, r2
    871c:	4628      	mov	r0, r5
    871e:	47b0      	blx	r6
		
	adc_async_enable_channel(&ADC_0, 0);
    8720:	4620      	mov	r0, r4
    8722:	4c08      	ldr	r4, [pc, #32]	; (8744 <grid_module_po16_revb_hardware_init+0x40>)
    8724:	2100      	movs	r1, #0
    8726:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8728:	4628      	mov	r0, r5
    872a:	4623      	mov	r3, r4
    872c:	2100      	movs	r1, #0

}
    872e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    8732:	4718      	bx	r3
    8734:	2001cd84 	.word	0x2001cd84
    8738:	0000e8b1 	.word	0x0000e8b1
    873c:	2001cf58 	.word	0x2001cf58
    8740:	00008491 	.word	0x00008491
    8744:	0000e871 	.word	0x0000e871

00008748 <grid_module_po16_revb_init>:




void grid_module_po16_revb_init(){
    8748:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    874c:	220e      	movs	r2, #14
    874e:	4c15      	ldr	r4, [pc, #84]	; (87a4 <grid_module_po16_revb_init+0x5c>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8750:	4e15      	ldr	r6, [pc, #84]	; (87a8 <grid_module_po16_revb_init+0x60>)
    8752:	4f16      	ldr	r7, [pc, #88]	; (87ac <grid_module_po16_revb_init+0x64>)
		
		for(uint8_t j=0; j<16; j++){
			
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8754:	f8df 806c 	ldr.w	r8, [pc, #108]	; 87c4 <grid_module_po16_revb_init+0x7c>
	grid_ain_init(16, 5, 14, 7);
    8758:	2307      	movs	r3, #7
    875a:	2105      	movs	r1, #5
    875c:	2010      	movs	r0, #16
    875e:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 16);
    8760:	4b13      	ldr	r3, [pc, #76]	; (87b0 <grid_module_po16_revb_init+0x68>)
    8762:	4814      	ldr	r0, [pc, #80]	; (87b4 <grid_module_po16_revb_init+0x6c>)
    8764:	2110      	movs	r1, #16
    8766:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    8768:	480f      	ldr	r0, [pc, #60]	; (87a8 <grid_module_po16_revb_init+0x60>)
    876a:	4b13      	ldr	r3, [pc, #76]	; (87b8 <grid_module_po16_revb_init+0x70>)
    876c:	2104      	movs	r1, #4
    876e:	4798      	blx	r3
    8770:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8772:	2210      	movs	r2, #16
    8774:	b2e1      	uxtb	r1, r4
    8776:	4630      	mov	r0, r6
    8778:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    877a:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    877e:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8780:	6870      	ldr	r0, [r6, #4]
    8782:	b2e9      	uxtb	r1, r5
    8784:	2201      	movs	r2, #1
    8786:	4448      	add	r0, r9
    8788:	3501      	adds	r5, #1
    878a:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    878c:	2d10      	cmp	r5, #16
    878e:	d1f7      	bne.n	8780 <grid_module_po16_revb_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
    8790:	3401      	adds	r4, #1
    8792:	2c04      	cmp	r4, #4
    8794:	d1ed      	bne.n	8772 <grid_module_po16_revb_init+0x2a>

		}
	}
	
	grid_module_po16_revb_hardware_init();
    8796:	4b09      	ldr	r3, [pc, #36]	; (87bc <grid_module_po16_revb_init+0x74>)
    8798:	4798      	blx	r3
	grid_module_po16_revb_hardware_start_transfer();
	
    879a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_po16_revb_hardware_start_transfer();
    879e:	4b08      	ldr	r3, [pc, #32]	; (87c0 <grid_module_po16_revb_init+0x78>)
    87a0:	4718      	bx	r3
    87a2:	bf00      	nop
    87a4:	000045a5 	.word	0x000045a5
    87a8:	2000effc 	.word	0x2000effc
    87ac:	00009e4d 	.word	0x00009e4d
    87b0:	000072c1 	.word	0x000072c1
    87b4:	2001c838 	.word	0x2001c838
    87b8:	00009e19 	.word	0x00009e19
    87bc:	00008705 	.word	0x00008705
    87c0:	00008471 	.word	0x00008471
    87c4:	0000a779 	.word	0x0000a779

000087c8 <grid_msg_header_set_len>:

#include "grid_msg.h"


// ======================= GRID MSG LEN ======================//
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    87c8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    87ca:	2200      	movs	r2, #0
    87cc:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    87d0:	f10d 020f 	add.w	r2, sp, #15
    87d4:	9200      	str	r2, [sp, #0]
    87d6:	2202      	movs	r2, #2
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    87d8:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    87da:	4c02      	ldr	r4, [pc, #8]	; (87e4 <grid_msg_header_set_len+0x1c>)
    87dc:	4611      	mov	r1, r2
    87de:	47a0      	blx	r4
	
}
    87e0:	b004      	add	sp, #16
    87e2:	bd10      	pop	{r4, pc}
    87e4:	00009dd5 	.word	0x00009dd5

000087e8 <grid_msg_header_set_id>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, &error);
}

// ======================= GRID MSG ID ======================//
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    87e8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    87ea:	2200      	movs	r2, #0
    87ec:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    87f0:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    87f4:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    87f6:	9200      	str	r2, [sp, #0]
    87f8:	4c02      	ldr	r4, [pc, #8]	; (8804 <grid_msg_header_set_id+0x1c>)
    87fa:	2202      	movs	r2, #2
    87fc:	2104      	movs	r1, #4
    87fe:	47a0      	blx	r4
	
}
    8800:	b004      	add	sp, #16
    8802:	bd10      	pop	{r4, pc}
    8804:	00009dd5 	.word	0x00009dd5

00008808 <grid_msg_header_set_dx>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
}

// ======================= GRID MSG DX ======================//
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8808:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    880a:	2200      	movs	r2, #0
    880c:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8810:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8814:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8816:	9200      	str	r2, [sp, #0]
    8818:	4c02      	ldr	r4, [pc, #8]	; (8824 <grid_msg_header_set_dx+0x1c>)
    881a:	2202      	movs	r2, #2
    881c:	2106      	movs	r1, #6
    881e:	47a0      	blx	r4
	
}
    8820:	b004      	add	sp, #16
    8822:	bd10      	pop	{r4, pc}
    8824:	00009dd5 	.word	0x00009dd5

00008828 <grid_msg_header_get_dx>:


uint8_t grid_msg_header_get_dx(struct grid_msg* msg){
    8828:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    882a:	2300      	movs	r3, #0
    882c:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    8830:	4c04      	ldr	r4, [pc, #16]	; (8844 <grid_msg_header_get_dx+0x1c>)
    8832:	f10d 0307 	add.w	r3, sp, #7
    8836:	2202      	movs	r2, #2
    8838:	2106      	movs	r1, #6
    883a:	47a0      	blx	r4
}
    883c:	b2c0      	uxtb	r0, r0
    883e:	b002      	add	sp, #8
    8840:	bd10      	pop	{r4, pc}
    8842:	bf00      	nop
    8844:	00009dbd 	.word	0x00009dbd

00008848 <grid_msg_header_set_dy>:

// ======================= GRID MSG DY ======================//
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    8848:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    884a:	2200      	movs	r2, #0
    884c:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    8850:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    8854:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    8856:	9200      	str	r2, [sp, #0]
    8858:	4c02      	ldr	r4, [pc, #8]	; (8864 <grid_msg_header_set_dy+0x1c>)
    885a:	2202      	movs	r2, #2
    885c:	2108      	movs	r1, #8
    885e:	47a0      	blx	r4
	
}
    8860:	b004      	add	sp, #16
    8862:	bd10      	pop	{r4, pc}
    8864:	00009dd5 	.word	0x00009dd5

00008868 <grid_msg_header_get_dy>:


uint8_t grid_msg_header_get_dy(struct grid_msg* msg){
    8868:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    886a:	2300      	movs	r3, #0
    886c:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    8870:	4c04      	ldr	r4, [pc, #16]	; (8884 <grid_msg_header_get_dy+0x1c>)
    8872:	f10d 0307 	add.w	r3, sp, #7
    8876:	2202      	movs	r2, #2
    8878:	2108      	movs	r1, #8
    887a:	47a0      	blx	r4
}
    887c:	b2c0      	uxtb	r0, r0
    887e:	b002      	add	sp, #8
    8880:	bd10      	pop	{r4, pc}
    8882:	bf00      	nop
    8884:	00009dbd 	.word	0x00009dbd

00008888 <grid_msg_header_set_rot>:

// ======================= GRID MSG ROT ======================//
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    8888:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    888a:	2200      	movs	r2, #0
    888c:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    8890:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    8894:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    8896:	9200      	str	r2, [sp, #0]
    8898:	4c02      	ldr	r4, [pc, #8]	; (88a4 <grid_msg_header_set_rot+0x1c>)
    889a:	2202      	movs	r2, #2
    889c:	210c      	movs	r1, #12
    889e:	47a0      	blx	r4
	
}
    88a0:	b004      	add	sp, #16
    88a2:	bd10      	pop	{r4, pc}
    88a4:	00009dd5 	.word	0x00009dd5

000088a8 <grid_msg_header_set_age>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
}

// ======================= GRID MSG AGE ======================//
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    88a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    88aa:	2200      	movs	r2, #0
    88ac:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    88b0:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    88b4:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    88b6:	9200      	str	r2, [sp, #0]
    88b8:	4c02      	ldr	r4, [pc, #8]	; (88c4 <grid_msg_header_set_age+0x1c>)
    88ba:	2202      	movs	r2, #2
    88bc:	210a      	movs	r1, #10
    88be:	47a0      	blx	r4
	
}
    88c0:	b004      	add	sp, #16
    88c2:	bd10      	pop	{r4, pc}
    88c4:	00009dd5 	.word	0x00009dd5

000088c8 <grid_msg_packet_get_length>:
}

// ======================= MSG GET PACKET LENGTH ======================//
uint32_t grid_msg_packet_get_length(struct grid_msg* msg){
	
	return (msg->header_length + msg->body_length + msg->footer_length);
    88c8:	e9d0 3264 	ldrd	r3, r2, [r0, #400]	; 0x190
    88cc:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    88d0:	4413      	add	r3, r2
}
    88d2:	4418      	add	r0, r3
    88d4:	4770      	bx	lr

000088d6 <grid_msg_body_get_length>:

// ======================= MSG GET BODY LENGTH ======================//
uint32_t grid_msg_body_get_length(struct grid_msg* msg){
	
	return (msg->body_length);
}
    88d6:	f8d0 0194 	ldr.w	r0, [r0, #404]	; 0x194
    88da:	4770      	bx	lr

000088dc <grid_msg_body_append_text>:
	
	return (msg->footer_length);
}


void	grid_msg_body_append_text(struct grid_msg* msg, uint8_t* str, uint32_t len){
    88dc:	b570      	push	{r4, r5, r6, lr}
    88de:	f8d0 5194 	ldr.w	r5, [r0, #404]	; 0x194

	
	for(uint32_t i=0; i<len; i++){
    88e2:	2300      	movs	r3, #0
    88e4:	4293      	cmp	r3, r2
    88e6:	d103      	bne.n	88f0 <grid_msg_body_append_text+0x14>
		
		msg->body[msg->body_length + i] = str[i];
	}
	
	msg->body_length += len;
    88e8:	442b      	add	r3, r5
    88ea:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    88ee:	bd70      	pop	{r4, r5, r6, pc}
		msg->body[msg->body_length + i] = str[i];
    88f0:	18c4      	adds	r4, r0, r3
    88f2:	442c      	add	r4, r5
    88f4:	5cce      	ldrb	r6, [r1, r3]
    88f6:	7526      	strb	r6, [r4, #20]
	for(uint32_t i=0; i<len; i++){
    88f8:	3301      	adds	r3, #1
    88fa:	e7f3      	b.n	88e4 <grid_msg_body_append_text+0x8>

000088fc <grid_msg_body_append_text_escaped>:

void	grid_msg_body_append_text_escaped(struct grid_msg* msg, uint8_t* str, uint32_t len){
    88fc:	b5f0      	push	{r4, r5, r6, r7, lr}
    88fe:	f8d0 6194 	ldr.w	r6, [r0, #404]	; 0x194
	
	for(uint32_t i=0; i<len; i++){
    8902:	2400      	movs	r4, #0
		
		if (str[i] == GRID_CONST_STX){
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
		}
		else if (str[i] == GRID_CONST_ETX){
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    8904:	2783      	movs	r7, #131	; 0x83
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8906:	f04f 0c82 	mov.w	ip, #130	; 0x82
	for(uint32_t i=0; i<len; i++){
    890a:	4294      	cmp	r4, r2
    890c:	eb04 0306 	add.w	r3, r4, r6
    8910:	d102      	bne.n	8918 <grid_msg_body_append_text_escaped+0x1c>
			msg->body[msg->body_length + i] = str[i];
		}
		
	}
	
	msg->body_length += len;
    8912:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    8916:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (str[i] == GRID_CONST_STX){
    8918:	5d0d      	ldrb	r5, [r1, r4]
    891a:	2d02      	cmp	r5, #2
    891c:	4403      	add	r3, r0
    891e:	d103      	bne.n	8928 <grid_msg_body_append_text_escaped+0x2c>
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8920:	f883 c014 	strb.w	ip, [r3, #20]
	for(uint32_t i=0; i<len; i++){
    8924:	3401      	adds	r4, #1
    8926:	e7f0      	b.n	890a <grid_msg_body_append_text_escaped+0xe>
		else if (str[i] == GRID_CONST_ETX){
    8928:	2d03      	cmp	r5, #3
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    892a:	bf0c      	ite	eq
    892c:	751f      	strbeq	r7, [r3, #20]
			msg->body[msg->body_length + i] = str[i];
    892e:	751d      	strbne	r5, [r3, #20]
    8930:	e7f8      	b.n	8924 <grid_msg_body_append_text_escaped+0x28>
	...

00008934 <grid_msg_text_get_parameter>:


uint32_t grid_msg_text_get_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length){
    8934:	b420      	push	{r5}
	
	uint8_t error;
	
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    8936:	f101 0514 	add.w	r5, r1, #20
    893a:	4415      	add	r5, r2
    893c:	4619      	mov	r1, r3
    893e:	4428      	add	r0, r5
    8940:	4b02      	ldr	r3, [pc, #8]	; (894c <grid_msg_text_get_parameter+0x18>)
	
}
    8942:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    8946:	2200      	movs	r2, #0
    8948:	4718      	bx	r3
    894a:	bf00      	nop
    894c:	00009c09 	.word	0x00009c09

00008950 <grid_msg_text_set_parameter>:

void grid_msg_text_set_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length, uint32_t value){
    8950:	b420      	push	{r5}
	
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    8952:	f101 0514 	add.w	r5, r1, #20
    8956:	4415      	add	r5, r2
    8958:	4619      	mov	r1, r3
    895a:	9a01      	ldr	r2, [sp, #4]
    895c:	4b02      	ldr	r3, [pc, #8]	; (8968 <grid_msg_text_set_parameter+0x18>)
    895e:	4428      	add	r0, r5
	
}
    8960:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    8964:	4718      	bx	r3
    8966:	bf00      	nop
    8968:	00009c31 	.word	0x00009c31

0000896c <grid_msg_init>:


// ======================= GRID MSG INIT ======================//
void	grid_msg_init(struct grid_msg* msg){
	
	msg->header_length = 0;
    896c:	2300      	movs	r3, #0
	msg->body_length = 0;
    896e:	e9c0 3364 	strd	r3, r3, [r0, #400]	; 0x190
	msg->footer_length = 0;
    8972:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
	
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    8976:	1e42      	subs	r2, r0, #1
    8978:	f100 0113 	add.w	r1, r0, #19
	{
		msg->header[i] = 0;
    897c:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    8980:	4291      	cmp	r1, r2
    8982:	d1fb      	bne.n	897c <grid_msg_init+0x10>
    8984:	f100 0214 	add.w	r2, r0, #20
    8988:	f200 118b 	addw	r1, r0, #395	; 0x18b
	}
	
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
	{
		msg->body[i] = 0;
    898c:	2300      	movs	r3, #0
    898e:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
    8992:	428a      	cmp	r2, r1
    8994:	d1fb      	bne.n	898e <grid_msg_init+0x22>
	}
	
	for (uint32_t i=0; i<GRID_MSG_FOOTER_maxlength; i++)
	{
		msg->footer[i] = 0;
    8996:	f880 318b 	strb.w	r3, [r0, #395]	; 0x18b
    899a:	f8c0 318c 	str.w	r3, [r0, #396]	; 0x18c
	}
	
		
}
    899e:	4770      	bx	lr

000089a0 <grid_msg_init_header>:

// ======================= MSG INIT HEADER======================//

void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    89a0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    89a4:	461e      	mov	r6, r3
	
    
    uint8_t age = grid_sys_state.sessionid;
    89a6:	4b13      	ldr	r3, [pc, #76]	; (89f4 <grid_msg_init_header+0x54>)
    
	sprintf(msg->header, GRID_BRC_frame);
    89a8:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8a10 <grid_msg_init_header+0x70>
    uint8_t age = grid_sys_state.sessionid;
    89ac:	795d      	ldrb	r5, [r3, #5]
	sprintf(msg->header, GRID_BRC_frame);
    89ae:	2317      	movs	r3, #23
void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    89b0:	4604      	mov	r4, r0
    89b2:	4688      	mov	r8, r1
    89b4:	4617      	mov	r7, r2
	sprintf(msg->header, GRID_BRC_frame);
    89b6:	4910      	ldr	r1, [pc, #64]	; (89f8 <grid_msg_init_header+0x58>)
    89b8:	9300      	str	r3, [sp, #0]
    89ba:	2201      	movs	r2, #1
    89bc:	230f      	movs	r3, #15
    89be:	47c8      	blx	r9
	msg->header_length = strlen(msg->header);
    89c0:	4b0e      	ldr	r3, [pc, #56]	; (89fc <grid_msg_init_header+0x5c>)
    89c2:	4620      	mov	r0, r4
    89c4:	4798      	blx	r3
	
	grid_msg_header_set_dx(msg, dx);
    89c6:	4641      	mov	r1, r8
	msg->header_length = strlen(msg->header);
    89c8:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	grid_msg_header_set_dx(msg, dx);
    89cc:	4b0c      	ldr	r3, [pc, #48]	; (8a00 <grid_msg_init_header+0x60>)
    89ce:	4620      	mov	r0, r4
    89d0:	4798      	blx	r3
	grid_msg_header_set_dy(msg, dy);
    89d2:	4639      	mov	r1, r7
    89d4:	4620      	mov	r0, r4
    89d6:	4b0b      	ldr	r3, [pc, #44]	; (8a04 <grid_msg_init_header+0x64>)
    89d8:	4798      	blx	r3
	grid_msg_header_set_rot(msg, rot);
    89da:	4631      	mov	r1, r6
    89dc:	4620      	mov	r0, r4
    89de:	4b0a      	ldr	r3, [pc, #40]	; (8a08 <grid_msg_init_header+0x68>)
    89e0:	4798      	blx	r3
    uint8_t age = grid_sys_state.sessionid;
    89e2:	b2ed      	uxtb	r5, r5
	grid_msg_header_set_age(msg, age);
    89e4:	4b09      	ldr	r3, [pc, #36]	; (8a0c <grid_msg_init_header+0x6c>)
    89e6:	4629      	mov	r1, r5
    89e8:	4620      	mov	r0, r4
	
	
}
    89ea:	b003      	add	sp, #12
    89ec:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	grid_msg_header_set_age(msg, age);
    89f0:	4718      	bx	r3
    89f2:	bf00      	nop
    89f4:	2000f008 	.word	0x2000f008
    89f8:	00016278 	.word	0x00016278
    89fc:	00014d0b 	.word	0x00014d0b
    8a00:	00008809 	.word	0x00008809
    8a04:	00008849 	.word	0x00008849
    8a08:	00008889 	.word	0x00008889
    8a0c:	000088a9 	.word	0x000088a9
    8a10:	00014c8d 	.word	0x00014c8d

00008a14 <grid_msg_packet_receive_char>:

// ======================= MSG RECEIVE CHAR ======================//
void	grid_msg_packet_receive_char(struct grid_msg* msg, uint8_t nextchar){
	
	if (msg->body_length == 0){
    8a14:	f8d0 2194 	ldr.w	r2, [r0, #404]	; 0x194
    8a18:	b96a      	cbnz	r2, 8a36 <grid_msg_packet_receive_char+0x22>
		
		if (nextchar != GRID_CONST_EOB){
    8a1a:	2917      	cmp	r1, #23
			msg->header[msg->header_length] = nextchar;
    8a1c:	bf15      	itete	ne
    8a1e:	f8d0 3190 	ldrne.w	r3, [r0, #400]	; 0x190
			msg->header_length++;
		}
		else{
			msg->body[msg->body_length] = nextchar;
    8a22:	7501      	strbeq	r1, [r0, #20]
			msg->header[msg->header_length] = nextchar;
    8a24:	54c1      	strbne	r1, [r0, r3]
			msg->body_length++;
    8a26:	2301      	moveq	r3, #1
			msg->header_length++;
    8a28:	bf1a      	itte	ne
    8a2a:	3301      	addne	r3, #1
    8a2c:	f8c0 3190 	strne.w	r3, [r0, #400]	; 0x190
			msg->body_length++;
    8a30:	f8c0 3194 	streq.w	r3, [r0, #404]	; 0x194
    8a34:	4770      	bx	lr
			
		}
		
	}
	else if(msg->footer_length == 0){
    8a36:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
    8a3a:	b96b      	cbnz	r3, 8a58 <grid_msg_packet_receive_char+0x44>
		
		if (nextchar != GRID_CONST_EOT){
    8a3c:	2904      	cmp	r1, #4
    8a3e:	d005      	beq.n	8a4c <grid_msg_packet_receive_char+0x38>
			msg->body[msg->body_length] = nextchar;
    8a40:	1883      	adds	r3, r0, r2
			msg->body_length++;
    8a42:	3201      	adds	r2, #1
			msg->body[msg->body_length] = nextchar;
    8a44:	7519      	strb	r1, [r3, #20]
			msg->body_length++;
    8a46:	f8c0 2194 	str.w	r2, [r0, #404]	; 0x194
    8a4a:	4770      	bx	lr
		}
		else{
			msg->footer[msg->footer_length] = nextchar;
    8a4c:	f880 118b 	strb.w	r1, [r0, #395]	; 0x18b
			msg->footer_length++;
    8a50:	2301      	movs	r3, #1
		
	}
	else{
		
		msg->footer[msg->footer_length] = nextchar;
		msg->footer_length++;
    8a52:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
		
	}
	
}
    8a56:	4770      	bx	lr
		msg->footer[msg->footer_length] = nextchar;
    8a58:	18c2      	adds	r2, r0, r3
		msg->footer_length++;
    8a5a:	3301      	adds	r3, #1
		msg->footer[msg->footer_length] = nextchar;
    8a5c:	f882 118b 	strb.w	r1, [r2, #395]	; 0x18b
		msg->footer_length++;
    8a60:	e7f7      	b.n	8a52 <grid_msg_packet_receive_char+0x3e>

00008a62 <grid_msg_packet_send_char>:

// ======================= GRID MSG SEND CHAR ======================//

uint8_t	grid_msg_packet_send_char(struct grid_msg* msg, uint32_t charindex){
	
	if (charindex < msg->header_length){
    8a62:	f8d0 2190 	ldr.w	r2, [r0, #400]	; 0x190
    8a66:	428a      	cmp	r2, r1
    8a68:	d901      	bls.n	8a6e <grid_msg_packet_send_char+0xc>
		
		return msg->header[charindex];
    8a6a:	5c40      	ldrb	r0, [r0, r1]
    8a6c:	4770      	bx	lr
	}
	else if (charindex < msg->body_length + msg->header_length){
    8a6e:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
    8a72:	4413      	add	r3, r2
    8a74:	428b      	cmp	r3, r1
    8a76:	d903      	bls.n	8a80 <grid_msg_packet_send_char+0x1e>
	
		return msg->body[charindex - msg->header_length];
    8a78:	1a89      	subs	r1, r1, r2
    8a7a:	4408      	add	r0, r1
    8a7c:	7d00      	ldrb	r0, [r0, #20]
    8a7e:	4770      	bx	lr
	}
	else if (charindex < msg->footer_length + msg->body_length + msg->header_length){
    8a80:	f8d0 2198 	ldr.w	r2, [r0, #408]	; 0x198
    8a84:	441a      	add	r2, r3
    8a86:	428a      	cmp	r2, r1
	
		return msg->footer[charindex - msg->header_length - msg->body_length];
    8a88:	bf83      	ittte	hi
    8a8a:	1ac9      	subhi	r1, r1, r3
    8a8c:	1840      	addhi	r0, r0, r1
    8a8e:	f890 018b 	ldrbhi.w	r0, [r0, #395]	; 0x18b
	}
	else{
		// OVERRUN
		return -1;
    8a92:	20ff      	movls	r0, #255	; 0xff
	}
	
	
}
    8a94:	4770      	bx	lr
	...

00008a98 <grid_msg_packet_close>:



uint8_t	grid_msg_packet_close(struct grid_msg* msg){
    8a98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    8a9a:	4604      	mov	r4, r0
	
	
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    8a9c:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    8aa0:	492b      	ldr	r1, [pc, #172]	; (8b50 <grid_msg_packet_close+0xb8>)
    8aa2:	4d2c      	ldr	r5, [pc, #176]	; (8b54 <grid_msg_packet_close+0xbc>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8aa4:	4e2c      	ldr	r6, [pc, #176]	; (8b58 <grid_msg_packet_close+0xc0>)
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    8aa6:	f200 108b 	addw	r0, r0, #395	; 0x18b
    8aaa:	2204      	movs	r2, #4
    8aac:	4420      	add	r0, r4
    8aae:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8ab0:	f8d4 7198 	ldr.w	r7, [r4, #408]	; 0x198
    8ab4:	f207 108b 	addw	r0, r7, #395	; 0x18b
    8ab8:	4420      	add	r0, r4
    8aba:	47b0      	blx	r6
	
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8abc:	e9d4 3164 	ldrd	r3, r1, [r4, #400]	; 0x190
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8ac0:	4438      	add	r0, r7
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8ac2:	440b      	add	r3, r1
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    8ac4:	4f25      	ldr	r7, [pc, #148]	; (8b5c <grid_msg_packet_close+0xc4>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8ac6:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    8aca:	1819      	adds	r1, r3, r0
    8acc:	b2c9      	uxtb	r1, r1
    8ace:	4b24      	ldr	r3, [pc, #144]	; (8b60 <grid_msg_packet_close+0xc8>)
    8ad0:	4620      	mov	r0, r4
    8ad2:	4798      	blx	r3
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    8ad4:	f897 10ad 	ldrb.w	r1, [r7, #173]	; 0xad
    8ad8:	4b22      	ldr	r3, [pc, #136]	; (8b64 <grid_msg_packet_close+0xcc>)
    8ada:	4620      	mov	r0, r4
    8adc:	4798      	blx	r3
	
	grid_sys_state.next_broadcast_message_id++;
    8ade:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
    8ae2:	3301      	adds	r3, #1
    8ae4:	b2db      	uxtb	r3, r3
    8ae6:	f887 30ad 	strb.w	r3, [r7, #173]	; 0xad
	
	
	uint8_t checksum = 0;
	
	for (uint32_t i=0; i<msg->header_length; i++){
    8aea:	f8d4 3190 	ldr.w	r3, [r4, #400]	; 0x190
    8aee:	4621      	mov	r1, r4
    8af0:	4423      	add	r3, r4
	uint8_t checksum = 0;
    8af2:	2200      	movs	r2, #0
	for (uint32_t i=0; i<msg->header_length; i++){
    8af4:	4299      	cmp	r1, r3
    8af6:	d11f      	bne.n	8b38 <grid_msg_packet_close+0xa0>
    8af8:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
    8afc:	4423      	add	r3, r4
    8afe:	f104 0114 	add.w	r1, r4, #20
    8b02:	3314      	adds	r3, #20
		checksum ^= msg->header[i];
	}
		
	for (uint32_t i=0; i<msg->body_length; i++){
    8b04:	4299      	cmp	r1, r3
    8b06:	d11b      	bne.n	8b40 <grid_msg_packet_close+0xa8>
		checksum ^= msg->body[i];
	}
		
	for (uint32_t i=0; i<msg->footer_length; i++){
    8b08:	f8d4 0198 	ldr.w	r0, [r4, #408]	; 0x198
    8b0c:	1823      	adds	r3, r4, r0
    8b0e:	f204 118b 	addw	r1, r4, #395	; 0x18b
    8b12:	f203 138b 	addw	r3, r3, #395	; 0x18b
    8b16:	4299      	cmp	r1, r3
    8b18:	d116      	bne.n	8b48 <grid_msg_packet_close+0xb0>
		checksum ^= msg->footer[i];
	}
	
	sprintf(&msg->footer[msg->footer_length], "%02x\n", checksum);
    8b1a:	f200 108b 	addw	r0, r0, #395	; 0x18b
    8b1e:	4912      	ldr	r1, [pc, #72]	; (8b68 <grid_msg_packet_close+0xd0>)
    8b20:	4420      	add	r0, r4
    8b22:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    8b24:	f8d4 5198 	ldr.w	r5, [r4, #408]	; 0x198
    8b28:	f205 108b 	addw	r0, r5, #395	; 0x18b
    8b2c:	4420      	add	r0, r4
    8b2e:	47b0      	blx	r6
    8b30:	4428      	add	r0, r5
    8b32:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	
	
}
    8b36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		checksum ^= msg->header[i];
    8b38:	f811 0b01 	ldrb.w	r0, [r1], #1
    8b3c:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->header_length; i++){
    8b3e:	e7d9      	b.n	8af4 <grid_msg_packet_close+0x5c>
		checksum ^= msg->body[i];
    8b40:	f811 0b01 	ldrb.w	r0, [r1], #1
    8b44:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->body_length; i++){
    8b46:	e7dd      	b.n	8b04 <grid_msg_packet_close+0x6c>
		checksum ^= msg->footer[i];
    8b48:	f811 7b01 	ldrb.w	r7, [r1], #1
    8b4c:	407a      	eors	r2, r7
	for (uint32_t i=0; i<msg->footer_length; i++){
    8b4e:	e7e2      	b.n	8b16 <grid_msg_packet_close+0x7e>
    8b50:	00015fcb 	.word	0x00015fcb
    8b54:	00014c8d 	.word	0x00014c8d
    8b58:	00014d0b 	.word	0x00014d0b
    8b5c:	2000f008 	.word	0x2000f008
    8b60:	000087c9 	.word	0x000087c9
    8b64:	000087e9 	.word	0x000087e9
    8b68:	00016c3f 	.word	0x00016c3f

00008b6c <grid_msg_packet_send_everywhere>:

uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    8b6c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	
	uint32_t message_length = grid_msg_packet_get_length(msg);
    8b70:	4b0f      	ldr	r3, [pc, #60]	; (8bb0 <grid_msg_packet_send_everywhere+0x44>)
uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    8b72:	4606      	mov	r6, r0
	uint32_t message_length = grid_msg_packet_get_length(msg);
    8b74:	4798      	blx	r3
	
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    8b76:	4b0f      	ldr	r3, [pc, #60]	; (8bb4 <grid_msg_packet_send_everywhere+0x48>)
	uint32_t message_length = grid_msg_packet_get_length(msg);
    8b78:	4604      	mov	r4, r0
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    8b7a:	b281      	uxth	r1, r0
    8b7c:	480e      	ldr	r0, [pc, #56]	; (8bb8 <grid_msg_packet_send_everywhere+0x4c>)
    8b7e:	4798      	blx	r3
    8b80:	b978      	cbnz	r0, 8ba2 <grid_msg_packet_send_everywhere+0x36>
		
		return 0;
	}
	
	
}
    8b82:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    8b86:	4629      	mov	r1, r5
    8b88:	4630      	mov	r0, r6
    8b8a:	47b8      	blx	r7
    8b8c:	4601      	mov	r1, r0
    8b8e:	4640      	mov	r0, r8
    8b90:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    8b92:	3501      	adds	r5, #1
    8b94:	42a5      	cmp	r5, r4
    8b96:	d1f6      	bne.n	8b86 <grid_msg_packet_send_everywhere+0x1a>
		grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    8b98:	4807      	ldr	r0, [pc, #28]	; (8bb8 <grid_msg_packet_send_everywhere+0x4c>)
    8b9a:	4b08      	ldr	r3, [pc, #32]	; (8bbc <grid_msg_packet_send_everywhere+0x50>)
    8b9c:	4798      	blx	r3
		return 1;
    8b9e:	2001      	movs	r0, #1
    8ba0:	e7ef      	b.n	8b82 <grid_msg_packet_send_everywhere+0x16>
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    8ba2:	4f07      	ldr	r7, [pc, #28]	; (8bc0 <grid_msg_packet_send_everywhere+0x54>)
    8ba4:	f8df 8010 	ldr.w	r8, [pc, #16]	; 8bb8 <grid_msg_packet_send_everywhere+0x4c>
    8ba8:	f8df 9018 	ldr.w	r9, [pc, #24]	; 8bc4 <grid_msg_packet_send_everywhere+0x58>
		for(uint32_t i = 0; i<message_length; i++){
    8bac:	2500      	movs	r5, #0
    8bae:	e7f1      	b.n	8b94 <grid_msg_packet_send_everywhere+0x28>
    8bb0:	000088c9 	.word	0x000088c9
    8bb4:	000047f1 	.word	0x000047f1
    8bb8:	2000ebe4 	.word	0x2000ebe4
    8bbc:	0000484d 	.word	0x0000484d
    8bc0:	00008a63 	.word	0x00008a63
    8bc4:	0000482d 	.word	0x0000482d

00008bc8 <grid_nvm_ui_bulk_read_init>:
}


void grid_nvm_ui_bulk_read_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->read_bulk_page_index = 0;
    8bc8:	2300      	movs	r3, #0
    8bca:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 1;
    8bce:	2301      	movs	r3, #1
    8bd0:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
			
}
    8bd4:	4770      	bx	lr

00008bd6 <grid_nvm_ui_bulk_read_is_in_progress>:

uint8_t grid_nvm_ui_bulk_read_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->read_bulk_status;
	
}
    8bd6:	f890 0428 	ldrb.w	r0, [r0, #1064]	; 0x428
    8bda:	4770      	bx	lr

00008bdc <grid_nvm_ui_bulk_read_next>:

void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8bdc:	b5f0      	push	{r4, r5, r6, r7, lr}
    8bde:	4604      	mov	r4, r0
    8be0:	b0ed      	sub	sp, #436	; 0x1b4
	
	if (nvm->read_bulk_status == 1){
    8be2:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
    8be6:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8be8:	4608      	mov	r0, r1
	if (nvm->read_bulk_status == 1){
    8bea:	d12f      	bne.n	8c4c <grid_nvm_ui_bulk_read_next+0x70>
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8bec:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8bee:	f8d4 2424 	ldr.w	r2, [r4, #1060]	; 0x424
    8bf2:	23a0      	movs	r3, #160	; 0xa0
    8bf4:	fbb2 f3f3 	udiv	r3, r2, r3
    8bf8:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8bfc:	4299      	cmp	r1, r3
    8bfe:	d91c      	bls.n	8c3a <grid_nvm_ui_bulk_read_next+0x5e>
			
			if (element < ui->bank_list[bank].element_list_length){
    8c00:	6845      	ldr	r5, [r0, #4]
    8c02:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8c06:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8c08:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8c0a:	fbb2 f1f7 	udiv	r1, r2, r7
    8c0e:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    8c12:	42b5      	cmp	r5, r6
    8c14:	d911      	bls.n	8c3a <grid_nvm_ui_bulk_read_next+0x5e>
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8c16:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8c1a:	68da      	ldr	r2, [r3, #12]
    8c1c:	2364      	movs	r3, #100	; 0x64
    8c1e:	fb06 2303 	mla	r3, r6, r3, r2
    8c22:	b2ca      	uxtb	r2, r1
    8c24:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8c28:	4295      	cmp	r5, r2
    8c2a:	d906      	bls.n	8c3a <grid_nvm_ui_bulk_read_next+0x5e>
					// Valid memory location
					
					int status = grid_ui_nvm_load_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);
    8c2c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8c2e:	22bc      	movs	r2, #188	; 0xbc
    8c30:	fb02 3201 	mla	r2, r2, r1, r3
    8c34:	4b1f      	ldr	r3, [pc, #124]	; (8cb4 <grid_nvm_ui_bulk_read_next+0xd8>)
    8c36:	4621      	mov	r1, r4
    8c38:	4798      	blx	r3
			}
	
		}
		
		
		if (nvm->read_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8c3a:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
    8c3e:	f240 227e 	movw	r2, #638	; 0x27e
    8c42:	4293      	cmp	r3, r2
    8c44:	d804      	bhi.n	8c50 <grid_nvm_ui_bulk_read_next+0x74>
			
			nvm->read_bulk_page_index++;
    8c46:	3301      	adds	r3, #1
    8c48:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
	}
	
	
	
	
}
    8c4c:	b06d      	add	sp, #436	; 0x1b4
    8c4e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			nvm->read_bulk_page_index = 0;
    8c50:	2500      	movs	r5, #0
    8c52:	f8c4 5424 	str.w	r5, [r4, #1060]	; 0x424
			nvm->read_bulk_status = 0;
    8c56:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
			grid_msg_init(&response);
    8c5a:	a805      	add	r0, sp, #20
    8c5c:	4b16      	ldr	r3, [pc, #88]	; (8cb8 <grid_nvm_ui_bulk_read_next+0xdc>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8c5e:	4c17      	ldr	r4, [pc, #92]	; (8cbc <grid_nvm_ui_bulk_read_next+0xe0>)
			grid_msg_init(&response);
    8c60:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8c62:	227f      	movs	r2, #127	; 0x7f
    8c64:	462b      	mov	r3, r5
    8c66:	4611      	mov	r1, r2
    8c68:	a805      	add	r0, sp, #20
    8c6a:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    8c6c:	2303      	movs	r3, #3
    8c6e:	4914      	ldr	r1, [pc, #80]	; (8cc0 <grid_nvm_ui_bulk_read_next+0xe4>)
    8c70:	9300      	str	r3, [sp, #0]
    8c72:	2202      	movs	r2, #2
    8c74:	4c13      	ldr	r4, [pc, #76]	; (8cc4 <grid_nvm_ui_bulk_read_next+0xe8>)
			uint8_t response_payload[10] = {0};
    8c76:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    8c7a:	2371      	movs	r3, #113	; 0x71
    8c7c:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8c7e:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    8c82:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8c84:	4b10      	ldr	r3, [pc, #64]	; (8cc8 <grid_nvm_ui_bulk_read_next+0xec>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8c86:	4c11      	ldr	r4, [pc, #68]	; (8ccc <grid_nvm_ui_bulk_read_next+0xf0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8c88:	a802      	add	r0, sp, #8
    8c8a:	4798      	blx	r3
    8c8c:	a902      	add	r1, sp, #8
    8c8e:	4602      	mov	r2, r0
    8c90:	4b0f      	ldr	r3, [pc, #60]	; (8cd0 <grid_nvm_ui_bulk_read_next+0xf4>)
    8c92:	a805      	add	r0, sp, #20
    8c94:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8c96:	230a      	movs	r3, #10
    8c98:	9300      	str	r3, [sp, #0]
    8c9a:	2204      	movs	r2, #4
    8c9c:	4629      	mov	r1, r5
    8c9e:	a805      	add	r0, sp, #20
    8ca0:	2301      	movs	r3, #1
    8ca2:	47a0      	blx	r4
			grid_msg_packet_close(&response);
    8ca4:	4b0b      	ldr	r3, [pc, #44]	; (8cd4 <grid_nvm_ui_bulk_read_next+0xf8>)
    8ca6:	a805      	add	r0, sp, #20
    8ca8:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8caa:	4b0b      	ldr	r3, [pc, #44]	; (8cd8 <grid_nvm_ui_bulk_read_next+0xfc>)
    8cac:	a805      	add	r0, sp, #20
    8cae:	4798      	blx	r3
}
    8cb0:	e7cc      	b.n	8c4c <grid_nvm_ui_bulk_read_next+0x70>
    8cb2:	bf00      	nop
    8cb4:	0000a23d 	.word	0x0000a23d
    8cb8:	0000896d 	.word	0x0000896d
    8cbc:	000089a1 	.word	0x000089a1
    8cc0:	0001628b 	.word	0x0001628b
    8cc4:	00014c8d 	.word	0x00014c8d
    8cc8:	00014d0b 	.word	0x00014d0b
    8ccc:	00008951 	.word	0x00008951
    8cd0:	000088dd 	.word	0x000088dd
    8cd4:	00008a99 	.word	0x00008a99
    8cd8:	00008b6d 	.word	0x00008b6d

00008cdc <grid_nvm_ui_bulk_store_init>:


void grid_nvm_ui_bulk_store_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->store_bulk_page_index = 0;
    8cdc:	2300      	movs	r3, #0
    8cde:	f8c0 3434 	str.w	r3, [r0, #1076]	; 0x434
	nvm->store_bulk_status = 1;
    8ce2:	2301      	movs	r3, #1
    8ce4:	f880 3438 	strb.w	r3, [r0, #1080]	; 0x438
	
}
    8ce8:	4770      	bx	lr

00008cea <grid_nvm_ui_bulk_store_is_in_progress>:

uint8_t grid_nvm_ui_bulk_store_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->store_bulk_status;
	
}
    8cea:	f890 0438 	ldrb.w	r0, [r0, #1080]	; 0x438
    8cee:	4770      	bx	lr

00008cf0 <grid_nvm_ui_bulk_store_next>:

// DO THIS!!
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8cf0:	b5f0      	push	{r4, r5, r6, r7, lr}
     
    // START: NEW
    
    
	if (nvm->store_bulk_status == 1){
    8cf2:	f890 3438 	ldrb.w	r3, [r0, #1080]	; 0x438
    8cf6:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8cf8:	b0ed      	sub	sp, #436	; 0x1b4
    8cfa:	4604      	mov	r4, r0
    8cfc:	460d      	mov	r5, r1
	if (nvm->store_bulk_status == 1){
    8cfe:	d168      	bne.n	8dd2 <grid_nvm_ui_bulk_store_next+0xe2>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];

                        if (eve->cfg_changed_flag == 1){


                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    8d00:	4f53      	ldr	r7, [pc, #332]	; (8e50 <grid_nvm_ui_bulk_store_next+0x160>)
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8d02:	26a0      	movs	r6, #160	; 0xa0
            if (bank < ui->bank_list_length){
    8d04:	786a      	ldrb	r2, [r5, #1]
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8d06:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    8d0a:	fbb3 f1f6 	udiv	r1, r3, r6
    8d0e:	f001 0003 	and.w	r0, r1, #3
            if (bank < ui->bank_list_length){
    8d12:	4282      	cmp	r2, r0
    8d14:	d95f      	bls.n	8dd6 <grid_nvm_ui_bulk_store_next+0xe6>
                if (element < ui->bank_list[bank].element_list_length){
    8d16:	6869      	ldr	r1, [r5, #4]
    8d18:	eb01 1100 	add.w	r1, r1, r0, lsl #4
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8d1c:	f04f 0e0a 	mov.w	lr, #10
                if (element < ui->bank_list[bank].element_list_length){
    8d20:	7a48      	ldrb	r0, [r1, #9]
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8d22:	fbb3 f2fe 	udiv	r2, r3, lr
    8d26:	f002 0c0f 	and.w	ip, r2, #15
                if (element < ui->bank_list[bank].element_list_length){
    8d2a:	4560      	cmp	r0, ip
    8d2c:	d953      	bls.n	8dd6 <grid_nvm_ui_bulk_store_next+0xe6>
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8d2e:	68c9      	ldr	r1, [r1, #12]
            uint8_t event   = nvm->store_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8d30:	fb0e 3212 	mls	r2, lr, r2, r3
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8d34:	2364      	movs	r3, #100	; 0x64
    8d36:	fb0c 1303 	mla	r3, ip, r3, r1
    8d3a:	b2d1      	uxtb	r1, r2
    8d3c:	f893 005c 	ldrb.w	r0, [r3, #92]	; 0x5c
    8d40:	4288      	cmp	r0, r1
    8d42:	d948      	bls.n	8dd6 <grid_nvm_ui_bulk_store_next+0xe6>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];
    8d44:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8d46:	21bc      	movs	r1, #188	; 0xbc
    8d48:	fb01 3202 	mla	r2, r1, r2, r3
                        if (eve->cfg_changed_flag == 1){
    8d4c:	f892 30b6 	ldrb.w	r3, [r2, #182]	; 0xb6
    8d50:	2b01      	cmp	r3, #1
    8d52:	d140      	bne.n	8dd6 <grid_nvm_ui_bulk_store_next+0xe6>
                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    8d54:	4621      	mov	r1, r4
    8d56:	4628      	mov	r0, r5
    8d58:	47b8      	blx	r7
    8d5a:	3800      	subs	r0, #0
    8d5c:	bf18      	it	ne
    8d5e:	2001      	movne	r0, #1

            }
            
            

            if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8d60:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    8d64:	f240 227e 	movw	r2, #638	; 0x27e
    8d68:	4293      	cmp	r3, r2
    8d6a:	d804      	bhi.n	8d76 <grid_nvm_ui_bulk_store_next+0x86>



                nvm->store_bulk_page_index++;       
    8d6c:	3301      	adds	r3, #1
    8d6e:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        while (something_was_stored == 0){
    8d72:	2800      	cmp	r0, #0
    8d74:	d0c6      	beq.n	8d04 <grid_nvm_ui_bulk_store_next+0x14>
		

		
		
		
		if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8d76:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    8d7a:	4e36      	ldr	r6, [pc, #216]	; (8e54 <grid_nvm_ui_bulk_store_next+0x164>)
    8d7c:	f240 227e 	movw	r2, #638	; 0x27e
    8d80:	4293      	cmp	r3, r2
    8d82:	d82a      	bhi.n	8dda <grid_nvm_ui_bulk_store_next+0xea>
			
            
            uint8_t intensity = abs(nvm->store_bulk_page_index%100 - 50)/1.5 + 40;
    8d84:	2264      	movs	r2, #100	; 0x64
    8d86:	fbb3 f0f2 	udiv	r0, r3, r2
    8d8a:	fb02 3010 	mls	r0, r2, r0, r3
    8d8e:	3832      	subs	r0, #50	; 0x32
    8d90:	2800      	cmp	r0, #0
    8d92:	bfb8      	it	lt
    8d94:	4240      	neglt	r0, r0
    8d96:	4f30      	ldr	r7, [pc, #192]	; (8e58 <grid_nvm_ui_bulk_store_next+0x168>)
    8d98:	4c30      	ldr	r4, [pc, #192]	; (8e5c <grid_nvm_ui_bulk_store_next+0x16c>)
    8d9a:	4d31      	ldr	r5, [pc, #196]	; (8e60 <grid_nvm_ui_bulk_store_next+0x170>)
    8d9c:	47b8      	blx	r7
    8d9e:	4b31      	ldr	r3, [pc, #196]	; (8e64 <grid_nvm_ui_bulk_store_next+0x174>)
    8da0:	2200      	movs	r2, #0
    8da2:	47a0      	blx	r4
    8da4:	4b30      	ldr	r3, [pc, #192]	; (8e68 <grid_nvm_ui_bulk_store_next+0x178>)
    8da6:	4c31      	ldr	r4, [pc, #196]	; (8e6c <grid_nvm_ui_bulk_store_next+0x17c>)
    8da8:	2200      	movs	r2, #0
    8daa:	47a0      	blx	r4
    8dac:	47a8      	blx	r5
    8dae:	b2c4      	uxtb	r4, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, 0, intensity*0.75, intensity, 1, 1000);
    8db0:	4620      	mov	r0, r4
    8db2:	47b8      	blx	r7
    8db4:	4b2e      	ldr	r3, [pc, #184]	; (8e70 <grid_nvm_ui_bulk_store_next+0x180>)
    8db6:	4f2f      	ldr	r7, [pc, #188]	; (8e74 <grid_nvm_ui_bulk_store_next+0x184>)
    8db8:	2200      	movs	r2, #0
    8dba:	47b8      	blx	r7
    8dbc:	47a8      	blx	r5
    8dbe:	2301      	movs	r3, #1
    8dc0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8dc4:	e9cd 3200 	strd	r3, r2, [sp]
    8dc8:	2100      	movs	r1, #0
    8dca:	b2c2      	uxtb	r2, r0
    8dcc:	4623      	mov	r3, r4
    8dce:	482a      	ldr	r0, [pc, #168]	; (8e78 <grid_nvm_ui_bulk_store_next+0x188>)
    8dd0:	47b0      	blx	r6
	}
	
	
	
	
}
    8dd2:	b06d      	add	sp, #436	; 0x1b4
    8dd4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    8dd6:	2000      	movs	r0, #0
    8dd8:	e7c2      	b.n	8d60 <grid_nvm_ui_bulk_store_next+0x70>
			nvm->store_bulk_page_index = 0;
    8dda:	2500      	movs	r5, #0
    8ddc:	f8c4 5434 	str.w	r5, [r4, #1076]	; 0x434
			nvm->store_bulk_status = 0;
    8de0:	f884 5438 	strb.w	r5, [r4, #1080]	; 0x438
			grid_msg_init(&response);
    8de4:	a805      	add	r0, sp, #20
    8de6:	4b25      	ldr	r3, [pc, #148]	; (8e7c <grid_nvm_ui_bulk_store_next+0x18c>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8de8:	4c25      	ldr	r4, [pc, #148]	; (8e80 <grid_nvm_ui_bulk_store_next+0x190>)
			grid_msg_init(&response);
    8dea:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8dec:	227f      	movs	r2, #127	; 0x7f
    8dee:	462b      	mov	r3, r5
    8df0:	4611      	mov	r1, r2
    8df2:	a805      	add	r0, sp, #20
    8df4:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8df6:	2303      	movs	r3, #3
    8df8:	4922      	ldr	r1, [pc, #136]	; (8e84 <grid_nvm_ui_bulk_store_next+0x194>)
    8dfa:	9300      	str	r3, [sp, #0]
    8dfc:	2202      	movs	r2, #2
    8dfe:	4c22      	ldr	r4, [pc, #136]	; (8e88 <grid_nvm_ui_bulk_store_next+0x198>)
			uint8_t response_payload[10] = {0};
    8e00:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8e04:	2370      	movs	r3, #112	; 0x70
    8e06:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8e08:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    8e0c:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8e0e:	4b1f      	ldr	r3, [pc, #124]	; (8e8c <grid_nvm_ui_bulk_store_next+0x19c>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8e10:	4c1f      	ldr	r4, [pc, #124]	; (8e90 <grid_nvm_ui_bulk_store_next+0x1a0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8e12:	a802      	add	r0, sp, #8
    8e14:	4798      	blx	r3
    8e16:	a902      	add	r1, sp, #8
    8e18:	4602      	mov	r2, r0
    8e1a:	4b1e      	ldr	r3, [pc, #120]	; (8e94 <grid_nvm_ui_bulk_store_next+0x1a4>)
    8e1c:	a805      	add	r0, sp, #20
    8e1e:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8e20:	230a      	movs	r3, #10
    8e22:	9300      	str	r3, [sp, #0]
    8e24:	4629      	mov	r1, r5
    8e26:	a805      	add	r0, sp, #20
    8e28:	2301      	movs	r3, #1
    8e2a:	2204      	movs	r2, #4
    8e2c:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8e2e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8e32:	e9cd 5300 	strd	r5, r3, [sp]
    8e36:	22ff      	movs	r2, #255	; 0xff
    8e38:	462b      	mov	r3, r5
    8e3a:	4629      	mov	r1, r5
    8e3c:	480e      	ldr	r0, [pc, #56]	; (8e78 <grid_nvm_ui_bulk_store_next+0x188>)
    8e3e:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8e40:	4b15      	ldr	r3, [pc, #84]	; (8e98 <grid_nvm_ui_bulk_store_next+0x1a8>)
    8e42:	a805      	add	r0, sp, #20
    8e44:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8e46:	4b15      	ldr	r3, [pc, #84]	; (8e9c <grid_nvm_ui_bulk_store_next+0x1ac>)
    8e48:	a805      	add	r0, sp, #20
    8e4a:	4798      	blx	r3
}
    8e4c:	e7c1      	b.n	8dd2 <grid_nvm_ui_bulk_store_next+0xe2>
    8e4e:	bf00      	nop
    8e50:	0000a0a1 	.word	0x0000a0a1
    8e54:	00009bbb 	.word	0x00009bbb
    8e58:	00014219 	.word	0x00014219
    8e5c:	00014541 	.word	0x00014541
    8e60:	00014711 	.word	0x00014711
    8e64:	3ff80000 	.word	0x3ff80000
    8e68:	40440000 	.word	0x40440000
    8e6c:	00013f81 	.word	0x00013f81
    8e70:	3fe80000 	.word	0x3fe80000
    8e74:	000142ed 	.word	0x000142ed
    8e78:	2000f008 	.word	0x2000f008
    8e7c:	0000896d 	.word	0x0000896d
    8e80:	000089a1 	.word	0x000089a1
    8e84:	0001628b 	.word	0x0001628b
    8e88:	00014c8d 	.word	0x00014c8d
    8e8c:	00014d0b 	.word	0x00014d0b
    8e90:	00008951 	.word	0x00008951
    8e94:	000088dd 	.word	0x000088dd
    8e98:	00008a99 	.word	0x00008a99
    8e9c:	00008b6d 	.word	0x00008b6d

00008ea0 <grid_nvm_ui_bulk_clear_init>:



void grid_nvm_ui_bulk_clear_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->clear_bulk_page_index = 0;
    8ea0:	2300      	movs	r3, #0
    8ea2:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 1;
    8ea6:	2301      	movs	r3, #1
    8ea8:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	
}
    8eac:	4770      	bx	lr

00008eae <grid_nvm_ui_bulk_clear_is_in_progress>:

uint8_t grid_nvm_ui_bulk_clear_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->clear_bulk_status;
	
}
    8eae:	f890 0430 	ldrb.w	r0, [r0, #1072]	; 0x430
    8eb2:	4770      	bx	lr

00008eb4 <grid_nvm_ui_bulk_clear_next>:


void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8eb4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    8eb8:	4604      	mov	r4, r0
    8eba:	b0ec      	sub	sp, #432	; 0x1b0
	
	if (nvm->clear_bulk_status == 1){
    8ebc:	f894 3430 	ldrb.w	r3, [r4, #1072]	; 0x430
    8ec0:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    8ec2:	4608      	mov	r0, r1
	if (nvm->clear_bulk_status == 1){
    8ec4:	d15b      	bne.n	8f7e <grid_nvm_ui_bulk_clear_next+0xca>
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    8ec6:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    8ec8:	f8d4 242c 	ldr.w	r2, [r4, #1068]	; 0x42c
    8ecc:	23a0      	movs	r3, #160	; 0xa0
    8ece:	fbb2 f3f3 	udiv	r3, r2, r3
    8ed2:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    8ed6:	4299      	cmp	r1, r3
    8ed8:	d91c      	bls.n	8f14 <grid_nvm_ui_bulk_clear_next+0x60>
			
			if (element < ui->bank_list[bank].element_list_length){
    8eda:	6845      	ldr	r5, [r0, #4]
    8edc:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8ee0:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    8ee2:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    8ee4:	fbb2 f1f7 	udiv	r1, r2, r7
    8ee8:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    8eec:	42b5      	cmp	r5, r6
    8eee:	d911      	bls.n	8f14 <grid_nvm_ui_bulk_clear_next+0x60>
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    8ef0:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    8ef4:	68da      	ldr	r2, [r3, #12]
    8ef6:	2364      	movs	r3, #100	; 0x64
    8ef8:	fb06 2303 	mla	r3, r6, r3, r2
    8efc:	b2ca      	uxtb	r2, r1
    8efe:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    8f02:	4295      	cmp	r5, r2
    8f04:	d906      	bls.n	8f14 <grid_nvm_ui_bulk_clear_next+0x60>
					// Valid memory location
					
					grid_ui_nvm_clear_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);		
    8f06:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8f08:	22bc      	movs	r2, #188	; 0xbc
    8f0a:	fb02 3201 	mla	r2, r2, r1, r3
    8f0e:	4b3c      	ldr	r3, [pc, #240]	; (9000 <grid_nvm_ui_bulk_clear_next+0x14c>)
    8f10:	4621      	mov	r1, r4
    8f12:	4798      	blx	r3
	
		}
		
		
		
		if (nvm->clear_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    8f14:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8f18:	4e3a      	ldr	r6, [pc, #232]	; (9004 <grid_nvm_ui_bulk_clear_next+0x150>)
    8f1a:	f240 227e 	movw	r2, #638	; 0x27e
    8f1e:	4293      	cmp	r3, r2
    8f20:	d830      	bhi.n	8f84 <grid_nvm_ui_bulk_clear_next+0xd0>
			
            
            uint8_t intensity = abs(nvm->clear_bulk_page_index%100 - 50)/1.5 + 40;
    8f22:	2264      	movs	r2, #100	; 0x64
    8f24:	fbb3 f0f2 	udiv	r0, r3, r2
    8f28:	fb02 3010 	mls	r0, r2, r0, r3
    8f2c:	3832      	subs	r0, #50	; 0x32
    8f2e:	2800      	cmp	r0, #0
    8f30:	bfb8      	it	lt
    8f32:	4240      	neglt	r0, r0
    8f34:	f8df 8118 	ldr.w	r8, [pc, #280]	; 9050 <grid_nvm_ui_bulk_clear_next+0x19c>
    8f38:	4d33      	ldr	r5, [pc, #204]	; (9008 <grid_nvm_ui_bulk_clear_next+0x154>)
    8f3a:	4f34      	ldr	r7, [pc, #208]	; (900c <grid_nvm_ui_bulk_clear_next+0x158>)
    8f3c:	47c0      	blx	r8
    8f3e:	4b34      	ldr	r3, [pc, #208]	; (9010 <grid_nvm_ui_bulk_clear_next+0x15c>)
    8f40:	2200      	movs	r2, #0
    8f42:	47a8      	blx	r5
    8f44:	4b33      	ldr	r3, [pc, #204]	; (9014 <grid_nvm_ui_bulk_clear_next+0x160>)
    8f46:	4d34      	ldr	r5, [pc, #208]	; (9018 <grid_nvm_ui_bulk_clear_next+0x164>)
    8f48:	2200      	movs	r2, #0
    8f4a:	47a8      	blx	r5
    8f4c:	47b8      	blx	r7
    8f4e:	b2c5      	uxtb	r5, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, intensity, intensity*0.75, 0, 1, 1000);
    8f50:	4628      	mov	r0, r5
    8f52:	47c0      	blx	r8
    8f54:	4b31      	ldr	r3, [pc, #196]	; (901c <grid_nvm_ui_bulk_clear_next+0x168>)
    8f56:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 9054 <grid_nvm_ui_bulk_clear_next+0x1a0>
    8f5a:	2200      	movs	r2, #0
    8f5c:	47c0      	blx	r8
    8f5e:	47b8      	blx	r7
    8f60:	2301      	movs	r3, #1
    8f62:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    8f66:	e9cd 3200 	strd	r3, r2, [sp]
    8f6a:	4629      	mov	r1, r5
    8f6c:	2300      	movs	r3, #0
    8f6e:	b2c2      	uxtb	r2, r0
    8f70:	482b      	ldr	r0, [pc, #172]	; (9020 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8f72:	47b0      	blx	r6


            
            nvm->clear_bulk_page_index++;
    8f74:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    8f78:	3301      	adds	r3, #1
    8f7a:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	}
	
	
	
	
}
    8f7e:	b06c      	add	sp, #432	; 0x1b0
    8f80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			nvm->clear_bulk_page_index = 0;
    8f84:	2500      	movs	r5, #0
    8f86:	f8c4 542c 	str.w	r5, [r4, #1068]	; 0x42c
			nvm->clear_bulk_status = 0;
    8f8a:	f884 5430 	strb.w	r5, [r4, #1072]	; 0x430
			grid_msg_init(&response);
    8f8e:	a805      	add	r0, sp, #20
    8f90:	4b24      	ldr	r3, [pc, #144]	; (9024 <grid_nvm_ui_bulk_clear_next+0x170>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f92:	4c25      	ldr	r4, [pc, #148]	; (9028 <grid_nvm_ui_bulk_clear_next+0x174>)
			grid_msg_init(&response);
    8f94:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    8f96:	227f      	movs	r2, #127	; 0x7f
    8f98:	462b      	mov	r3, r5
    8f9a:	4611      	mov	r1, r2
    8f9c:	a805      	add	r0, sp, #20
    8f9e:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8fa0:	2303      	movs	r3, #3
    8fa2:	4922      	ldr	r1, [pc, #136]	; (902c <grid_nvm_ui_bulk_clear_next+0x178>)
    8fa4:	9300      	str	r3, [sp, #0]
    8fa6:	2202      	movs	r2, #2
    8fa8:	4c21      	ldr	r4, [pc, #132]	; (9030 <grid_nvm_ui_bulk_clear_next+0x17c>)
			uint8_t response_payload[10] = {0};
    8faa:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8fae:	2372      	movs	r3, #114	; 0x72
    8fb0:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    8fb2:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    8fb6:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8fb8:	4b1e      	ldr	r3, [pc, #120]	; (9034 <grid_nvm_ui_bulk_clear_next+0x180>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8fba:	4c1f      	ldr	r4, [pc, #124]	; (9038 <grid_nvm_ui_bulk_clear_next+0x184>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    8fbc:	a802      	add	r0, sp, #8
    8fbe:	4798      	blx	r3
    8fc0:	a902      	add	r1, sp, #8
    8fc2:	4602      	mov	r2, r0
    8fc4:	4b1d      	ldr	r3, [pc, #116]	; (903c <grid_nvm_ui_bulk_clear_next+0x188>)
    8fc6:	a805      	add	r0, sp, #20
    8fc8:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    8fca:	230a      	movs	r3, #10
    8fcc:	9300      	str	r3, [sp, #0]
    8fce:	4629      	mov	r1, r5
    8fd0:	a805      	add	r0, sp, #20
    8fd2:	2301      	movs	r3, #1
    8fd4:	2204      	movs	r2, #4
    8fd6:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    8fd8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    8fdc:	22ff      	movs	r2, #255	; 0xff
    8fde:	4629      	mov	r1, r5
    8fe0:	e9cd 5300 	strd	r5, r3, [sp]
    8fe4:	480e      	ldr	r0, [pc, #56]	; (9020 <grid_nvm_ui_bulk_clear_next+0x16c>)
    8fe6:	462b      	mov	r3, r5
    8fe8:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    8fea:	4b15      	ldr	r3, [pc, #84]	; (9040 <grid_nvm_ui_bulk_clear_next+0x18c>)
    8fec:	a805      	add	r0, sp, #20
    8fee:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    8ff0:	4b14      	ldr	r3, [pc, #80]	; (9044 <grid_nvm_ui_bulk_clear_next+0x190>)
    8ff2:	a805      	add	r0, sp, #20
    8ff4:	4798      	blx	r3
            grid_ui_reinit_local(&grid_ui_state);
    8ff6:	4814      	ldr	r0, [pc, #80]	; (9048 <grid_nvm_ui_bulk_clear_next+0x194>)
    8ff8:	4b14      	ldr	r3, [pc, #80]	; (904c <grid_nvm_ui_bulk_clear_next+0x198>)
    8ffa:	4798      	blx	r3
}
    8ffc:	e7bf      	b.n	8f7e <grid_nvm_ui_bulk_clear_next+0xca>
    8ffe:	bf00      	nop
    9000:	0000a2b5 	.word	0x0000a2b5
    9004:	00009bbb 	.word	0x00009bbb
    9008:	00014541 	.word	0x00014541
    900c:	00014711 	.word	0x00014711
    9010:	3ff80000 	.word	0x3ff80000
    9014:	40440000 	.word	0x40440000
    9018:	00013f81 	.word	0x00013f81
    901c:	3fe80000 	.word	0x3fe80000
    9020:	2000f008 	.word	0x2000f008
    9024:	0000896d 	.word	0x0000896d
    9028:	000089a1 	.word	0x000089a1
    902c:	0001628b 	.word	0x0001628b
    9030:	00014c8d 	.word	0x00014c8d
    9034:	00014d0b 	.word	0x00014d0b
    9038:	00008951 	.word	0x00008951
    903c:	000088dd 	.word	0x000088dd
    9040:	00008a99 	.word	0x00008a99
    9044:	00008b6d 	.word	0x00008b6d
    9048:	2000effc 	.word	0x2000effc
    904c:	0000a8c1 	.word	0x0000a8c1
    9050:	00014219 	.word	0x00014219
    9054:	000142ed 	.word	0x000142ed

00009058 <grid_nvm_clear_read_buffer>:



void grid_nvm_clear_read_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9058:	f100 0309 	add.w	r3, r0, #9
    905c:	f200 2209 	addw	r2, r0, #521	; 0x209
		
		mod->read_buffer[i] = 255;
    9060:	21ff      	movs	r1, #255	; 0xff
    9062:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9066:	4293      	cmp	r3, r2
    9068:	d1fb      	bne.n	9062 <grid_nvm_clear_read_buffer+0xa>
		
	}

	mod->read_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    906a:	2302      	movs	r3, #2
    906c:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	mod->read_buffer_length = 0;
    9070:	2300      	movs	r3, #0
    9072:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
	
}
    9076:	4770      	bx	lr

00009078 <grid_nvm_clear_write_buffer>:

void grid_nvm_clear_write_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9078:	f500 7306 	add.w	r3, r0, #536	; 0x218
    907c:	f500 6283 	add.w	r2, r0, #1048	; 0x418
		
		mod->write_buffer[i] = 255;
    9080:	21ff      	movs	r1, #255	; 0xff
    9082:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    9086:	4293      	cmp	r3, r2
    9088:	d1fb      	bne.n	9082 <grid_nvm_clear_write_buffer+0xa>
		
	}
	
	mod->write_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    908a:	2302      	movs	r3, #2
    908c:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	mod->write_buffer_length = 0;
    9090:	2300      	movs	r3, #0
    9092:	f8c0 3418 	str.w	r3, [r0, #1048]	; 0x418
	mod->write_target_address = -1;
    9096:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    909a:	f8c0 3420 	str.w	r3, [r0, #1056]	; 0x420
}
    909e:	4770      	bx	lr

000090a0 <grid_nvm_init>:
void grid_nvm_init(struct grid_nvm_model* nvm, struct flash_descriptor* flash_instance){
    90a0:	b510      	push	{r4, lr}
	nvm->bank_settings_page_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    90a2:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
	nvm->flash = flash_instance;
    90a6:	e9c0 1300 	strd	r1, r3, [r0]
	nvm->status = 1;
    90aa:	2301      	movs	r3, #1
    90ac:	7203      	strb	r3, [r0, #8]
	nvm->read_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    90ae:	2300      	movs	r3, #0
    90b0:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	nvm->write_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    90b4:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	nvm->read_bulk_page_index = 0;
    90b8:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 0;
    90bc:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
	nvm->clear_bulk_page_index = 0;
    90c0:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 0;	
    90c4:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	nvm->write_bulk_page_index = 0;
    90c8:	f8c0 343c 	str.w	r3, [r0, #1084]	; 0x43c
	nvm->write_bulk_status = 0;
    90cc:	f880 3440 	strb.w	r3, [r0, #1088]	; 0x440
	grid_nvm_clear_read_buffer(nvm);
    90d0:	4b02      	ldr	r3, [pc, #8]	; (90dc <grid_nvm_init+0x3c>)
    90d2:	4798      	blx	r3
}
    90d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_nvm_clear_write_buffer(nvm);
    90d8:	4b01      	ldr	r3, [pc, #4]	; (90e0 <grid_nvm_init+0x40>)
    90da:	4718      	bx	r3
    90dc:	00009059 	.word	0x00009059
    90e0:	00009079 	.word	0x00009079

000090e4 <grid_nvm_calculate_event_page_offset>:


uint32_t grid_nvm_calculate_event_page_offset(struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    90e4:	b510      	push	{r4, lr}
	
	
	
	uint8_t bank_number		= eve->parent->parent->index;
    90e6:	684a      	ldr	r2, [r1, #4]
    90e8:	6853      	ldr	r3, [r2, #4]
	uint8_t element_number	= eve->parent->index;
	uint8_t event_number	= eve->index;

	return GRID_NVM_STRATEGY_BANK_size * bank_number + GRID_NVM_STRATEGY_ELEMENT_size * element_number + GRID_NVM_STRATEGY_EVENT_size * event_number;
    90ea:	7a1c      	ldrb	r4, [r3, #8]
    90ec:	7a13      	ldrb	r3, [r2, #8]
    90ee:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    90f2:	20a0      	movs	r0, #160	; 0xa0
    90f4:	005b      	lsls	r3, r3, #1
    90f6:	fb10 3304 	smlabb	r3, r0, r4, r3
    90fa:	7a08      	ldrb	r0, [r1, #8]
	
    90fc:	4418      	add	r0, r3
    90fe:	bd10      	pop	{r4, pc}

00009100 <_gpio_set_pin_pull_mode.constprop.0>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    9100:	01c0      	lsls	r0, r0, #7
    9102:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    9106:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    910a:	2301      	movs	r3, #1
    910c:	408b      	lsls	r3, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    910e:	4401      	add	r1, r0
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    9110:	6043      	str	r3, [r0, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    9112:	f891 2040 	ldrb.w	r2, [r1, #64]	; 0x40
    9116:	f042 0204 	orr.w	r2, r2, #4
    911a:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    911e:	6183      	str	r3, [r0, #24]

	default:
		ASSERT(false);
		break;
	}
}
    9120:	4770      	bx	lr

00009122 <grid_task_enter_task>:
 * Author : SUKU WC
*/

#include "grid_sys.h"

enum grid_task grid_task_enter_task(struct grid_task_model* mod, enum grid_task next_task){
    9122:	4603      	mov	r3, r0
	
	
	enum grid_task previous_task = mod->current_task;
    9124:	7840      	ldrb	r0, [r0, #1]
	mod->current_task = next_task;
    9126:	7059      	strb	r1, [r3, #1]
	return previous_task;
	
}
    9128:	4770      	bx	lr

0000912a <grid_task_timer_tick>:
	
}

void grid_task_timer_tick(struct grid_task_model* mod){
	
	mod->timer[mod->current_task]++;
    912a:	7843      	ldrb	r3, [r0, #1]
    912c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    9130:	6843      	ldr	r3, [r0, #4]
    9132:	3301      	adds	r3, #1
    9134:	6043      	str	r3, [r0, #4]
	
}
    9136:	4770      	bx	lr

00009138 <grid_sys_nvm_store_configuration>:
}




void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9138:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    913c:	f2ad 4dec 	subw	sp, sp, #1260	; 0x4ec

	struct grid_msg message;
	
	grid_msg_init(&message);
    9140:	4b6a      	ldr	r3, [pc, #424]	; (92ec <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9142:	4c6b      	ldr	r4, [pc, #428]	; (92f0 <grid_sys_nvm_store_configuration+0x1b8>)
	for(uint8_t i=0; i<4; i++){
		
		// BANK ENABLED	
		offset = grid_msg_body_get_length(&message);
			
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    9144:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 9318 <grid_sys_nvm_store_configuration+0x1e0>
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9148:	4606      	mov	r6, r0
	grid_msg_init(&message);
    914a:	a86c      	add	r0, sp, #432	; 0x1b0
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    914c:	460f      	mov	r7, r1
	grid_msg_init(&message);
    914e:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9150:	22ff      	movs	r2, #255	; 0xff
    9152:	4611      	mov	r1, r2
    9154:	2300      	movs	r3, #0
    9156:	a86c      	add	r0, sp, #432	; 0x1b0
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9158:	2500      	movs	r5, #0
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    915a:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    915c:	4b65      	ldr	r3, [pc, #404]	; (92f4 <grid_sys_nvm_store_configuration+0x1bc>)
    915e:	9508      	str	r5, [sp, #32]
    9160:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9164:	4629      	mov	r1, r5
    9166:	a809      	add	r0, sp, #36	; 0x24
    9168:	4798      	blx	r3
	for(uint8_t i=0; i<4; i++){
    916a:	3613      	adds	r6, #19
		offset = grid_msg_body_get_length(&message);
    916c:	4b62      	ldr	r3, [pc, #392]	; (92f8 <grid_sys_nvm_store_configuration+0x1c0>)
		payload_length = strlen(payload);
    916e:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 9324 <grid_sys_nvm_store_configuration+0x1ec>
			
		grid_msg_body_append_text(&message, payload, payload_length);
    9172:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 9328 <grid_sys_nvm_store_configuration+0x1f0>
			
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9176:	4c61      	ldr	r4, [pc, #388]	; (92fc <grid_sys_nvm_store_configuration+0x1c4>)
		offset = grid_msg_body_get_length(&message);
    9178:	a86c      	add	r0, sp, #432	; 0x1b0
    917a:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    917c:	2203      	movs	r2, #3
		offset = grid_msg_body_get_length(&message);
    917e:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    9180:	2331      	movs	r3, #49	; 0x31
    9182:	495f      	ldr	r1, [pc, #380]	; (9300 <grid_sys_nvm_store_configuration+0x1c8>)
    9184:	9200      	str	r2, [sp, #0]
    9186:	a808      	add	r0, sp, #32
    9188:	2202      	movs	r2, #2
    918a:	47d0      	blx	sl
		payload_length = strlen(payload);
    918c:	a808      	add	r0, sp, #32
    918e:	47d8      	blx	fp
		grid_msg_body_append_text(&message, payload, payload_length);
    9190:	a908      	add	r1, sp, #32
    9192:	b2c2      	uxtb	r2, r0
    9194:	a86c      	add	r0, sp, #432	; 0x1b0
    9196:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9198:	220e      	movs	r2, #14
    919a:	4641      	mov	r1, r8
    919c:	9200      	str	r2, [sp, #0]
    919e:	2301      	movs	r3, #1
    91a0:	2204      	movs	r2, #4
    91a2:	a86c      	add	r0, sp, #432	; 0x1b0
    91a4:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    91a6:	4641      	mov	r1, r8
    91a8:	9500      	str	r5, [sp, #0]
    91aa:	2302      	movs	r3, #2
    91ac:	2205      	movs	r2, #5
    91ae:	a86c      	add	r0, sp, #432	; 0x1b0
    91b0:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);		
    91b2:	f816 3b01 	ldrb.w	r3, [r6], #1
    91b6:	9300      	str	r3, [sp, #0]
    91b8:	4641      	mov	r1, r8
    91ba:	2207      	movs	r2, #7
    91bc:	2302      	movs	r3, #2
    91be:	a86c      	add	r0, sp, #432	; 0x1b0
    91c0:	47a0      	blx	r4
			
		// BANK COLOR	
		offset = grid_msg_body_get_length(&message);
    91c2:	4b4d      	ldr	r3, [pc, #308]	; (92f8 <grid_sys_nvm_store_configuration+0x1c0>)
    91c4:	a86c      	add	r0, sp, #432	; 0x1b0
    91c6:	4798      	blx	r3
		
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    91c8:	2303      	movs	r3, #3
		offset = grid_msg_body_get_length(&message);
    91ca:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    91cc:	494d      	ldr	r1, [pc, #308]	; (9304 <grid_sys_nvm_store_configuration+0x1cc>)
    91ce:	9300      	str	r3, [sp, #0]
    91d0:	2202      	movs	r2, #2
    91d2:	2332      	movs	r3, #50	; 0x32
    91d4:	a808      	add	r0, sp, #32
    91d6:	47d0      	blx	sl
		payload_length = strlen(payload);
    91d8:	a808      	add	r0, sp, #32
    91da:	47d8      	blx	fp
		
		grid_msg_body_append_text(&message, payload, payload_length);
    91dc:	a908      	add	r1, sp, #32
    91de:	b2c2      	uxtb	r2, r0
    91e0:	a86c      	add	r0, sp, #432	; 0x1b0
    91e2:	47c8      	blx	r9

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    91e4:	230e      	movs	r3, #14
    91e6:	4641      	mov	r1, r8
    91e8:	9300      	str	r3, [sp, #0]
    91ea:	2204      	movs	r2, #4
    91ec:	2301      	movs	r3, #1
    91ee:	a86c      	add	r0, sp, #432	; 0x1b0
    91f0:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    91f2:	4641      	mov	r1, r8
    91f4:	9500      	str	r5, [sp, #0]
    91f6:	2302      	movs	r3, #2
    91f8:	2205      	movs	r2, #5
    91fa:	a86c      	add	r0, sp, #432	; 0x1b0
    91fc:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    91fe:	78f3      	ldrb	r3, [r6, #3]
    9200:	9300      	str	r3, [sp, #0]
    9202:	4641      	mov	r1, r8
    9204:	2302      	movs	r3, #2
    9206:	2207      	movs	r2, #7
    9208:	a86c      	add	r0, sp, #432	; 0x1b0
    920a:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    920c:	79f3      	ldrb	r3, [r6, #7]
    920e:	9300      	str	r3, [sp, #0]
    9210:	4641      	mov	r1, r8
    9212:	2302      	movs	r3, #2
    9214:	2209      	movs	r2, #9
    9216:	a86c      	add	r0, sp, #432	; 0x1b0
    9218:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    921a:	7af3      	ldrb	r3, [r6, #11]
    921c:	9300      	str	r3, [sp, #0]
    921e:	4641      	mov	r1, r8
    9220:	2302      	movs	r3, #2
    9222:	220b      	movs	r2, #11
    9224:	a86c      	add	r0, sp, #432	; 0x1b0
    9226:	3501      	adds	r5, #1
    9228:	47a0      	blx	r4
	for(uint8_t i=0; i<4; i++){
    922a:	2d04      	cmp	r5, #4
    922c:	46d8      	mov	r8, fp
    922e:	d19d      	bne.n	916c <grid_sys_nvm_store_configuration+0x34>
		
		
	}
	
	grid_msg_packet_close(&message);
    9230:	4e35      	ldr	r6, [pc, #212]	; (9308 <grid_sys_nvm_store_configuration+0x1d0>)

	grid_nvm_clear_write_buffer(nvm);
	
	uint8_t acknowledge = 0;
	
	if (grid_msg_packet_get_length(&message)){
    9232:	4d36      	ldr	r5, [pc, #216]	; (930c <grid_sys_nvm_store_configuration+0x1d4>)
	grid_msg_packet_close(&message);
    9234:	a86c      	add	r0, sp, #432	; 0x1b0
    9236:	47b0      	blx	r6
	grid_nvm_clear_write_buffer(nvm);
    9238:	4b35      	ldr	r3, [pc, #212]	; (9310 <grid_sys_nvm_store_configuration+0x1d8>)
    923a:	4638      	mov	r0, r7
    923c:	4798      	blx	r3
	if (grid_msg_packet_get_length(&message)){
    923e:	a86c      	add	r0, sp, #432	; 0x1b0
    9240:	47a8      	blx	r5
    9242:	9602      	str	r6, [sp, #8]
    9244:	2800      	cmp	r0, #0
    9246:	d04c      	beq.n	92e2 <grid_sys_nvm_store_configuration+0x1aa>

		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    9248:	a86c      	add	r0, sp, #432	; 0x1b0
    924a:	47a8      	blx	r5
    924c:	f507 7a06 	add.w	sl, r7, #536	; 0x218
		
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
			
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9250:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 932c <grid_sys_nvm_store_configuration+0x1f4>
		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    9254:	f8c7 0418 	str.w	r0, [r7, #1048]	; 0x418
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    9258:	2500      	movs	r5, #0
    925a:	4652      	mov	r2, sl
    925c:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
    9260:	42ab      	cmp	r3, r5
    9262:	d835      	bhi.n	92d0 <grid_sys_nvm_store_configuration+0x198>
		}
		
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    9264:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    9268:	4d2a      	ldr	r5, [pc, #168]	; (9314 <grid_sys_nvm_store_configuration+0x1dc>)
    926a:	6838      	ldr	r0, [r7, #0]
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    926c:	f8c7 1420 	str.w	r1, [r7, #1056]	; 0x420
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    9270:	47a8      	blx	r5
		
		acknowledge = 1;
    9272:	2501      	movs	r5, #1

	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    9274:	4b1d      	ldr	r3, [pc, #116]	; (92ec <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9276:	4f1e      	ldr	r7, [pc, #120]	; (92f0 <grid_sys_nvm_store_configuration+0x1b8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    9278:	4e27      	ldr	r6, [pc, #156]	; (9318 <grid_sys_nvm_store_configuration+0x1e0>)
	grid_msg_init(&response);
    927a:	a8d3      	add	r0, sp, #844	; 0x34c
    927c:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    927e:	227f      	movs	r2, #127	; 0x7f
    9280:	4611      	mov	r1, r2
    9282:	2300      	movs	r3, #0
    9284:	a8d3      	add	r0, sp, #844	; 0x34c
    9286:	47b8      	blx	r7
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    9288:	2303      	movs	r3, #3
    928a:	4924      	ldr	r1, [pc, #144]	; (931c <grid_sys_nvm_store_configuration+0x1e4>)
    928c:	9300      	str	r3, [sp, #0]
    928e:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    9290:	2700      	movs	r7, #0
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    9292:	2360      	movs	r3, #96	; 0x60
    9294:	a805      	add	r0, sp, #20
	uint8_t response_payload[10] = {0};
    9296:	e9cd 7705 	strd	r7, r7, [sp, #20]
    929a:	f8ad 701c 	strh.w	r7, [sp, #28]
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    929e:	47b0      	blx	r6

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    92a0:	a805      	add	r0, sp, #20
    92a2:	47c0      	blx	r8
    92a4:	a905      	add	r1, sp, #20
    92a6:	4602      	mov	r2, r0
    92a8:	a8d3      	add	r0, sp, #844	; 0x34c
    92aa:	47c8      	blx	r9
	
	if (acknowledge == 1){
    92ac:	b1dd      	cbz	r5, 92e6 <grid_sys_nvm_store_configuration+0x1ae>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);	
    92ae:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    92b0:	2204      	movs	r2, #4
    92b2:	4639      	mov	r1, r7
    92b4:	9300      	str	r3, [sp, #0]
    92b6:	a8d3      	add	r0, sp, #844	; 0x34c
    92b8:	2301      	movs	r3, #1
    92ba:	47a0      	blx	r4
	}

	
	grid_msg_packet_close(&response);
    92bc:	9b02      	ldr	r3, [sp, #8]
    92be:	a8d3      	add	r0, sp, #844	; 0x34c
    92c0:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    92c2:	4b17      	ldr	r3, [pc, #92]	; (9320 <grid_sys_nvm_store_configuration+0x1e8>)
    92c4:	a8d3      	add	r0, sp, #844	; 0x34c
    92c6:	4798      	blx	r3
		
	
}
    92c8:	f20d 4dec 	addw	sp, sp, #1260	; 0x4ec
    92cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    92d0:	4629      	mov	r1, r5
    92d2:	a86c      	add	r0, sp, #432	; 0x1b0
    92d4:	9203      	str	r2, [sp, #12]
    92d6:	47d8      	blx	fp
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    92d8:	3501      	adds	r5, #1
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    92da:	f80a 0b01 	strb.w	r0, [sl], #1
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    92de:	9a03      	ldr	r2, [sp, #12]
    92e0:	e7bc      	b.n	925c <grid_sys_nvm_store_configuration+0x124>
	uint8_t acknowledge = 0;
    92e2:	4605      	mov	r5, r0
    92e4:	e7c6      	b.n	9274 <grid_sys_nvm_store_configuration+0x13c>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    92e6:	230b      	movs	r3, #11
    92e8:	e7e2      	b.n	92b0 <grid_sys_nvm_store_configuration+0x178>
    92ea:	bf00      	nop
    92ec:	0000896d 	.word	0x0000896d
    92f0:	000089a1 	.word	0x000089a1
    92f4:	000147c5 	.word	0x000147c5
    92f8:	000088d7 	.word	0x000088d7
    92fc:	00008951 	.word	0x00008951
    9300:	00016295 	.word	0x00016295
    9304:	00015fce 	.word	0x00015fce
    9308:	00008a99 	.word	0x00008a99
    930c:	000088c9 	.word	0x000088c9
    9310:	00009079 	.word	0x00009079
    9314:	0000f1d1 	.word	0x0000f1d1
    9318:	00014c8d 	.word	0x00014c8d
    931c:	0001628b 	.word	0x0001628b
    9320:	00008b6d 	.word	0x00008b6d
    9324:	00014d0b 	.word	0x00014d0b
    9328:	000088dd 	.word	0x000088dd
    932c:	00008a63 	.word	0x00008a63

00009330 <grid_sys_recall_configuration>:


void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    9330:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9334:	f5ad 7d51 	sub.w	sp, sp, #836	; 0x344

	struct grid_msg message;
	
	grid_msg_init(&message);
    9338:	4b48      	ldr	r3, [pc, #288]	; (945c <grid_sys_recall_configuration+0x12c>)
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    933a:	4c49      	ldr	r4, [pc, #292]	; (9460 <grid_sys_recall_configuration+0x130>)
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    933c:	4605      	mov	r5, r0
	grid_msg_init(&message);
    933e:	a869      	add	r0, sp, #420	; 0x1a4
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    9340:	468a      	mov	sl, r1
	grid_msg_init(&message);
    9342:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9344:	227f      	movs	r2, #127	; 0x7f
    9346:	4611      	mov	r1, r2
    9348:	2300      	movs	r3, #0
    934a:	a869      	add	r0, sp, #420	; 0x1a4
    934c:	47a0      	blx	r4


	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    934e:	2400      	movs	r4, #0
    9350:	4b44      	ldr	r3, [pc, #272]	; (9464 <grid_sys_recall_configuration+0x134>)
    9352:	9405      	str	r4, [sp, #20]
    9354:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9358:	4621      	mov	r1, r4
    935a:	a806      	add	r0, sp, #24
    935c:	4798      	blx	r3
	uint8_t payload_length = 0;
	uint32_t offset = 0;
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    935e:	3513      	adds	r5, #19
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9360:	9403      	str	r4, [sp, #12]
		
		if (bank > GRID_SYS_BANK_MAXNUMBER || bank == i){
    9362:	f1ba 0f04 	cmp.w	sl, #4
    9366:	d803      	bhi.n	9370 <grid_sys_recall_configuration+0x40>
    9368:	f89d 300c 	ldrb.w	r3, [sp, #12]
    936c:	459a      	cmp	sl, r3
    936e:	d164      	bne.n	943a <grid_sys_recall_configuration+0x10a>
			
			// BANK ENABLED
			offset = grid_msg_body_get_length(&message);
    9370:	4b3d      	ldr	r3, [pc, #244]	; (9468 <grid_sys_recall_configuration+0x138>)
		
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    9372:	4e3e      	ldr	r6, [pc, #248]	; (946c <grid_sys_recall_configuration+0x13c>)
			payload_length = strlen(payload);
		
			grid_msg_body_append_text(&message, payload, payload_length);
    9374:	f8df 9110 	ldr.w	r9, [pc, #272]	; 9488 <grid_sys_recall_configuration+0x158>
			offset = grid_msg_body_get_length(&message);
    9378:	a869      	add	r0, sp, #420	; 0x1a4
    937a:	4798      	blx	r3
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    937c:	f04f 0b03 	mov.w	fp, #3
			offset = grid_msg_body_get_length(&message);
    9380:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    9382:	2331      	movs	r3, #49	; 0x31
    9384:	493a      	ldr	r1, [pc, #232]	; (9470 <grid_sys_recall_configuration+0x140>)
    9386:	f8cd b000 	str.w	fp, [sp]
    938a:	2202      	movs	r2, #2
    938c:	a805      	add	r0, sp, #20
    938e:	47b0      	blx	r6
			payload_length = strlen(payload);
    9390:	4a38      	ldr	r2, [pc, #224]	; (9474 <grid_sys_recall_configuration+0x144>)
    9392:	a805      	add	r0, sp, #20
    9394:	4790      	blx	r2
		
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9396:	f04f 080d 	mov.w	r8, #13
			grid_msg_body_append_text(&message, payload, payload_length);
    939a:	b2c2      	uxtb	r2, r0
    939c:	a905      	add	r1, sp, #20
    939e:	a869      	add	r0, sp, #420	; 0x1a4
    93a0:	47c8      	blx	r9
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    93a2:	4634      	mov	r4, r6
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    93a4:	4639      	mov	r1, r7
    93a6:	4e34      	ldr	r6, [pc, #208]	; (9478 <grid_sys_recall_configuration+0x148>)
    93a8:	f8cd 8000 	str.w	r8, [sp]
    93ac:	2301      	movs	r3, #1
    93ae:	2204      	movs	r2, #4
    93b0:	a869      	add	r0, sp, #420	; 0x1a4
    93b2:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    93b4:	9b03      	ldr	r3, [sp, #12]
    93b6:	9300      	str	r3, [sp, #0]
    93b8:	4639      	mov	r1, r7
    93ba:	2302      	movs	r3, #2
    93bc:	2205      	movs	r2, #5
    93be:	a869      	add	r0, sp, #420	; 0x1a4
    93c0:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);
    93c2:	782b      	ldrb	r3, [r5, #0]
    93c4:	9300      	str	r3, [sp, #0]
    93c6:	4639      	mov	r1, r7
    93c8:	2207      	movs	r2, #7
    93ca:	2302      	movs	r3, #2
    93cc:	a869      	add	r0, sp, #420	; 0x1a4
    93ce:	47b0      	blx	r6
		
			// BANK COLOR
			offset = grid_msg_body_get_length(&message);
    93d0:	4b25      	ldr	r3, [pc, #148]	; (9468 <grid_sys_recall_configuration+0x138>)
    93d2:	a869      	add	r0, sp, #420	; 0x1a4
    93d4:	4798      	blx	r3
		
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    93d6:	2332      	movs	r3, #50	; 0x32
			offset = grid_msg_body_get_length(&message);
    93d8:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    93da:	4928      	ldr	r1, [pc, #160]	; (947c <grid_sys_recall_configuration+0x14c>)
    93dc:	f8cd b000 	str.w	fp, [sp]
    93e0:	2202      	movs	r2, #2
    93e2:	a805      	add	r0, sp, #20
    93e4:	47a0      	blx	r4
			payload_length = strlen(payload);
    93e6:	4a23      	ldr	r2, [pc, #140]	; (9474 <grid_sys_recall_configuration+0x144>)
    93e8:	a805      	add	r0, sp, #20
    93ea:	4790      	blx	r2
		
			grid_msg_body_append_text(&message, payload, payload_length);
    93ec:	a905      	add	r1, sp, #20
    93ee:	b2c2      	uxtb	r2, r0
    93f0:	a869      	add	r0, sp, #420	; 0x1a4
    93f2:	47c8      	blx	r9

			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    93f4:	2301      	movs	r3, #1
    93f6:	2204      	movs	r2, #4
    93f8:	4639      	mov	r1, r7
    93fa:	a869      	add	r0, sp, #420	; 0x1a4
    93fc:	f8cd 8000 	str.w	r8, [sp]
    9400:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    9402:	9b03      	ldr	r3, [sp, #12]
    9404:	9300      	str	r3, [sp, #0]
    9406:	2205      	movs	r2, #5
    9408:	2302      	movs	r3, #2
    940a:	4639      	mov	r1, r7
    940c:	a869      	add	r0, sp, #420	; 0x1a4
    940e:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    9410:	792b      	ldrb	r3, [r5, #4]
    9412:	9300      	str	r3, [sp, #0]
    9414:	2207      	movs	r2, #7
    9416:	2302      	movs	r3, #2
    9418:	4639      	mov	r1, r7
    941a:	a869      	add	r0, sp, #420	; 0x1a4
    941c:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    941e:	7a2b      	ldrb	r3, [r5, #8]
    9420:	9300      	str	r3, [sp, #0]
    9422:	2209      	movs	r2, #9
    9424:	2302      	movs	r3, #2
    9426:	4639      	mov	r1, r7
    9428:	a869      	add	r0, sp, #420	; 0x1a4
    942a:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    942c:	7b2b      	ldrb	r3, [r5, #12]
    942e:	9300      	str	r3, [sp, #0]
    9430:	220b      	movs	r2, #11
    9432:	2302      	movs	r3, #2
    9434:	4639      	mov	r1, r7
    9436:	a869      	add	r0, sp, #420	; 0x1a4
    9438:	47b0      	blx	r6
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    943a:	9b03      	ldr	r3, [sp, #12]
    943c:	3301      	adds	r3, #1
    943e:	2b04      	cmp	r3, #4
    9440:	9303      	str	r3, [sp, #12]
    9442:	f105 0501 	add.w	r5, r5, #1
    9446:	d18c      	bne.n	9362 <grid_sys_recall_configuration+0x32>
		}

		
	}
	
	grid_msg_packet_close(&message);
    9448:	4b0d      	ldr	r3, [pc, #52]	; (9480 <grid_sys_recall_configuration+0x150>)
    944a:	a869      	add	r0, sp, #420	; 0x1a4
    944c:	4798      	blx	r3

	grid_msg_packet_send_everywhere(&message);
    944e:	4b0d      	ldr	r3, [pc, #52]	; (9484 <grid_sys_recall_configuration+0x154>)
    9450:	a869      	add	r0, sp, #420	; 0x1a4
    9452:	4798      	blx	r3
// 	
// 	grid_msg_packet_close(&response);
// 	grid_msg_packet_send_everywhere(&response);
	
	
}
    9454:	f50d 7d51 	add.w	sp, sp, #836	; 0x344
    9458:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    945c:	0000896d 	.word	0x0000896d
    9460:	000089a1 	.word	0x000089a1
    9464:	000147c5 	.word	0x000147c5
    9468:	000088d7 	.word	0x000088d7
    946c:	00014c8d 	.word	0x00014c8d
    9470:	00016295 	.word	0x00016295
    9474:	00014d0b 	.word	0x00014d0b
    9478:	00008951 	.word	0x00008951
    947c:	00015fce 	.word	0x00015fce
    9480:	00008a99 	.word	0x00008a99
    9484:	00008b6d 	.word	0x00008b6d
    9488:	000088dd 	.word	0x000088dd

0000948c <grid_sys_nvm_load_configuration>:


void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    948c:	b5f0      	push	{r4, r5, r6, r7, lr}
    948e:	f5ad 7d6d 	sub.w	sp, sp, #948	; 0x3b4
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    9492:	2400      	movs	r4, #0
void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9494:	460e      	mov	r6, r1
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    9496:	4b2f      	ldr	r3, [pc, #188]	; (9554 <grid_sys_nvm_load_configuration+0xc8>)
    9498:	946c      	str	r4, [sp, #432]	; 0x1b0
    949a:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
    949e:	4621      	mov	r1, r4
    94a0:	a86d      	add	r0, sp, #436	; 0x1b4
    94a2:	4798      	blx	r3
    94a4:	ad6c      	add	r5, sp, #432	; 0x1b0
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    94a6:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
    94aa:	f8c6 1214 	str.w	r1, [r6, #532]	; 0x214
	
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    94ae:	6830      	ldr	r0, [r6, #0]
    94b0:	4e29      	ldr	r6, [pc, #164]	; (9558 <grid_sys_nvm_load_configuration+0xcc>)
    94b2:	f44f 7300 	mov.w	r3, #512	; 0x200
    94b6:	462a      	mov	r2, r5
    94b8:	47b0      	blx	r6
			}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    94ba:	4a28      	ldr	r2, [pc, #160]	; (955c <grid_sys_nvm_load_configuration+0xd0>)
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    94bc:	4621      	mov	r1, r4
	uint8_t acknowledge = 0;	
    94be:	4626      	mov	r6, r4
	uint8_t copydone = 0;
    94c0:	4623      	mov	r3, r4
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    94c2:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    94c6:	1c4c      	adds	r4, r1, #1
    94c8:	b943      	cbnz	r3, 94dc <grid_sys_nvm_load_configuration+0x50>
			if (temp[i] == '\n'){ // END OF PACKET, copy newline character
    94ca:	5c68      	ldrb	r0, [r5, r1]
    94cc:	280a      	cmp	r0, #10
    94ce:	d139      	bne.n	9544 <grid_sys_nvm_load_configuration+0xb8>
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    94d0:	4411      	add	r1, r2
    94d2:	55c8      	strb	r0, [r1, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    94d4:	6214      	str	r4, [r2, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    94d6:	6293      	str	r3, [r2, #40]	; 0x28
				acknowledge = 1;
    94d8:	2301      	movs	r3, #1
				copydone = 1;
    94da:	461e      	mov	r6, r3
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){		
    94dc:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    94e0:	4621      	mov	r1, r4
    94e2:	d1f0      	bne.n	94c6 <grid_sys_nvm_load_configuration+0x3a>
	
	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    94e4:	4b1e      	ldr	r3, [pc, #120]	; (9560 <grid_sys_nvm_load_configuration+0xd4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    94e6:	4c1f      	ldr	r4, [pc, #124]	; (9564 <grid_sys_nvm_load_configuration+0xd8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    94e8:	4d1f      	ldr	r5, [pc, #124]	; (9568 <grid_sys_nvm_load_configuration+0xdc>)
	grid_msg_init(&response);
    94ea:	a805      	add	r0, sp, #20
    94ec:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    94ee:	227f      	movs	r2, #127	; 0x7f
    94f0:	4611      	mov	r1, r2
    94f2:	2300      	movs	r3, #0
    94f4:	a805      	add	r0, sp, #20
    94f6:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    94f8:	2303      	movs	r3, #3
    94fa:	491c      	ldr	r1, [pc, #112]	; (956c <grid_sys_nvm_load_configuration+0xe0>)
    94fc:	9300      	str	r3, [sp, #0]
    94fe:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    9500:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9502:	2361      	movs	r3, #97	; 0x61
    9504:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    9506:	e9cd 4402 	strd	r4, r4, [sp, #8]
    950a:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    950e:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9510:	4b17      	ldr	r3, [pc, #92]	; (9570 <grid_sys_nvm_load_configuration+0xe4>)
    9512:	4d18      	ldr	r5, [pc, #96]	; (9574 <grid_sys_nvm_load_configuration+0xe8>)
    9514:	a802      	add	r0, sp, #8
    9516:	4798      	blx	r3
    9518:	4b17      	ldr	r3, [pc, #92]	; (9578 <grid_sys_nvm_load_configuration+0xec>)
    951a:	4602      	mov	r2, r0
    951c:	a902      	add	r1, sp, #8
    951e:	a805      	add	r0, sp, #20
    9520:	4798      	blx	r3
	
	if (acknowledge == 1){
    9522:	b1ae      	cbz	r6, 9550 <grid_sys_nvm_load_configuration+0xc4>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9524:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9526:	2204      	movs	r2, #4
    9528:	4621      	mov	r1, r4
    952a:	9300      	str	r3, [sp, #0]
    952c:	a805      	add	r0, sp, #20
    952e:	2301      	movs	r3, #1
    9530:	47a8      	blx	r5
	}

	
	grid_msg_packet_close(&response);
    9532:	4b12      	ldr	r3, [pc, #72]	; (957c <grid_sys_nvm_load_configuration+0xf0>)
    9534:	a805      	add	r0, sp, #20
    9536:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9538:	4b11      	ldr	r3, [pc, #68]	; (9580 <grid_sys_nvm_load_configuration+0xf4>)
    953a:	a805      	add	r0, sp, #20
    953c:	4798      	blx	r3
	
}
    953e:	f50d 7d6d 	add.w	sp, sp, #948	; 0x3b4
    9542:	bdf0      	pop	{r4, r5, r6, r7, pc}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    9544:	28ff      	cmp	r0, #255	; 0xff
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9546:	bf16      	itet	ne
    9548:	1889      	addne	r1, r1, r2
				copydone = 1;
    954a:	2301      	moveq	r3, #1
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    954c:	55c8      	strbne	r0, [r1, r7]
    954e:	e7c5      	b.n	94dc <grid_sys_nvm_load_configuration+0x50>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9550:	230b      	movs	r3, #11
    9552:	e7e8      	b.n	9526 <grid_sys_nvm_load_configuration+0x9a>
    9554:	000147c5 	.word	0x000147c5
    9558:	0000f165 	.word	0x0000f165
    955c:	2000c0b0 	.word	0x2000c0b0
    9560:	0000896d 	.word	0x0000896d
    9564:	000089a1 	.word	0x000089a1
    9568:	00014c8d 	.word	0x00014c8d
    956c:	0001628b 	.word	0x0001628b
    9570:	00014d0b 	.word	0x00014d0b
    9574:	00008951 	.word	0x00008951
    9578:	000088dd 	.word	0x000088dd
    957c:	00008a99 	.word	0x00008a99
    9580:	00008b6d 	.word	0x00008b6d

00009584 <grid_sys_nvm_clear_configuration>:

void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9584:	b530      	push	{r4, r5, lr}
    9586:	460b      	mov	r3, r1
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    9588:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    958c:	b0ed      	sub	sp, #436	; 0x1b4
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    958e:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    9592:	2201      	movs	r2, #1
    9594:	6818      	ldr	r0, [r3, #0]
    9596:	4b18      	ldr	r3, [pc, #96]	; (95f8 <grid_sys_nvm_clear_configuration+0x74>)

	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
		
	grid_msg_init(&response);
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9598:	4c18      	ldr	r4, [pc, #96]	; (95fc <grid_sys_nvm_clear_configuration+0x78>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    959a:	4d19      	ldr	r5, [pc, #100]	; (9600 <grid_sys_nvm_clear_configuration+0x7c>)
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    959c:	4798      	blx	r3
	grid_msg_init(&response);
    959e:	a805      	add	r0, sp, #20
    95a0:	4b18      	ldr	r3, [pc, #96]	; (9604 <grid_sys_nvm_clear_configuration+0x80>)
    95a2:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    95a4:	227f      	movs	r2, #127	; 0x7f
    95a6:	4611      	mov	r1, r2
    95a8:	a805      	add	r0, sp, #20
    95aa:	2300      	movs	r3, #0
    95ac:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    95ae:	2303      	movs	r3, #3
	uint8_t response_payload[10] = {0};
    95b0:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    95b2:	4915      	ldr	r1, [pc, #84]	; (9608 <grid_sys_nvm_clear_configuration+0x84>)
    95b4:	9300      	str	r3, [sp, #0]
    95b6:	2202      	movs	r2, #2
    95b8:	2362      	movs	r3, #98	; 0x62
    95ba:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    95bc:	e9cd 4402 	strd	r4, r4, [sp, #8]
    95c0:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    95c4:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    95c6:	4b11      	ldr	r3, [pc, #68]	; (960c <grid_sys_nvm_clear_configuration+0x88>)
    95c8:	a802      	add	r0, sp, #8
    95ca:	4798      	blx	r3
    95cc:	a902      	add	r1, sp, #8
    95ce:	4602      	mov	r2, r0
    95d0:	4b0f      	ldr	r3, [pc, #60]	; (9610 <grid_sys_nvm_clear_configuration+0x8c>)
    95d2:	a805      	add	r0, sp, #20
    95d4:	4798      	blx	r3
		
	if (acknowledge == 1){
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    95d6:	230a      	movs	r3, #10
    95d8:	4621      	mov	r1, r4
    95da:	2204      	movs	r2, #4
    95dc:	9300      	str	r3, [sp, #0]
    95de:	a805      	add	r0, sp, #20
    95e0:	4c0c      	ldr	r4, [pc, #48]	; (9614 <grid_sys_nvm_clear_configuration+0x90>)
    95e2:	2301      	movs	r3, #1
    95e4:	47a0      	blx	r4
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
	}

		
	grid_msg_packet_close(&response);
    95e6:	4b0c      	ldr	r3, [pc, #48]	; (9618 <grid_sys_nvm_clear_configuration+0x94>)
    95e8:	a805      	add	r0, sp, #20
    95ea:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    95ec:	4b0b      	ldr	r3, [pc, #44]	; (961c <grid_sys_nvm_clear_configuration+0x98>)
    95ee:	a805      	add	r0, sp, #20
    95f0:	4798      	blx	r3
	
	
}
    95f2:	b06d      	add	sp, #436	; 0x1b4
    95f4:	bd30      	pop	{r4, r5, pc}
    95f6:	bf00      	nop
    95f8:	0000f251 	.word	0x0000f251
    95fc:	000089a1 	.word	0x000089a1
    9600:	00014c8d 	.word	0x00014c8d
    9604:	0000896d 	.word	0x0000896d
    9608:	0001628b 	.word	0x0001628b
    960c:	00014d0b 	.word	0x00014d0b
    9610:	000088dd 	.word	0x000088dd
    9614:	00008951 	.word	0x00008951
    9618:	00008a99 	.word	0x00008a99
    961c:	00008b6d 	.word	0x00008b6d

00009620 <grid_debug_print_text>:



void grid_debug_print_text(uint8_t* debug_string){
    9620:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	uint32_t debug_string_length = strlen(debug_string);
    9624:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 9708 <grid_debug_print_text+0xe8>
	
	struct grid_msg message;
	
	grid_msg_init(&message);
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9628:	4c2b      	ldr	r4, [pc, #172]	; (96d8 <grid_debug_print_text+0xb8>)
	
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
	uint32_t offset = 0;
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    962a:	4e2c      	ldr	r6, [pc, #176]	; (96dc <grid_debug_print_text+0xbc>)
	offset += strlen(&payload[offset]);
		
	sprintf(&payload[offset], "# ");
    962c:	4f2c      	ldr	r7, [pc, #176]	; (96e0 <grid_debug_print_text+0xc0>)
void grid_debug_print_text(uint8_t* debug_string){
    962e:	f5ad 7d4c 	sub.w	sp, sp, #816	; 0x330
    9632:	4681      	mov	r9, r0
	uint32_t debug_string_length = strlen(debug_string);
    9634:	47d0      	blx	sl
	grid_msg_init(&message);
    9636:	4b2b      	ldr	r3, [pc, #172]	; (96e4 <grid_debug_print_text+0xc4>)
	uint32_t debug_string_length = strlen(debug_string);
    9638:	4680      	mov	r8, r0
	grid_msg_init(&message);
    963a:	a865      	add	r0, sp, #404	; 0x194
    963c:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    963e:	227f      	movs	r2, #127	; 0x7f
    9640:	4611      	mov	r1, r2
    9642:	2300      	movs	r3, #0
    9644:	a865      	add	r0, sp, #404	; 0x194
    9646:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9648:	2400      	movs	r4, #0
    964a:	4621      	mov	r1, r4
    964c:	4b26      	ldr	r3, [pc, #152]	; (96e8 <grid_debug_print_text+0xc8>)
    964e:	9401      	str	r4, [sp, #4]
    9650:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9654:	a802      	add	r0, sp, #8
    9656:	4798      	blx	r3
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    9658:	2202      	movs	r2, #2
    965a:	4924      	ldr	r1, [pc, #144]	; (96ec <grid_debug_print_text+0xcc>)
    965c:	2320      	movs	r3, #32
    965e:	a801      	add	r0, sp, #4
    9660:	47b0      	blx	r6
	offset += strlen(&payload[offset]);
    9662:	a801      	add	r0, sp, #4
    9664:	47d0      	blx	sl
	sprintf(&payload[offset], "# ");
    9666:	ab01      	add	r3, sp, #4
    9668:	4403      	add	r3, r0
    966a:	4921      	ldr	r1, [pc, #132]	; (96f0 <grid_debug_print_text+0xd0>)
	offset += strlen(&payload[offset]);
    966c:	4605      	mov	r5, r0
	sprintf(&payload[offset], "# ");
    966e:	4618      	mov	r0, r3
    9670:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    9672:	47d0      	blx	sl
    9674:	ab01      	add	r3, sp, #4
    9676:	4405      	add	r5, r0

	for(uint32_t i=0; i<debug_string_length; i++){
    9678:	1958      	adds	r0, r3, r5
    967a:	4621      	mov	r1, r4
    967c:	4603      	mov	r3, r0
    967e:	4654      	mov	r4, sl
    9680:	4541      	cmp	r1, r8
    9682:	d006      	beq.n	9692 <grid_debug_print_text+0x72>
		
		payload[offset+i] = debug_string[i];
    9684:	f819 2001 	ldrb.w	r2, [r9, r1]
    9688:	f803 2b01 	strb.w	r2, [r3], #1
		
		if (offset + i > GRID_PARAMETER_PACKET_marign)
    968c:	194a      	adds	r2, r1, r5
    968e:	2ac8      	cmp	r2, #200	; 0xc8
    9690:	d91f      	bls.n	96d2 <grid_debug_print_text+0xb2>
		{
			break;
		}
	}
	offset += strlen(&payload[offset]);
    9692:	47a0      	blx	r4
	
	
	sprintf(&payload[offset], " #");
    9694:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    9696:	4405      	add	r5, r0
	sprintf(&payload[offset], " #");
    9698:	442b      	add	r3, r5
    969a:	4916      	ldr	r1, [pc, #88]	; (96f4 <grid_debug_print_text+0xd4>)
    969c:	4618      	mov	r0, r3
    969e:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    96a0:	47a0      	blx	r4
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    96a2:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    96a4:	4405      	add	r5, r0
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    96a6:	195f      	adds	r7, r3, r5
    96a8:	4913      	ldr	r1, [pc, #76]	; (96f8 <grid_debug_print_text+0xd8>)
    96aa:	2203      	movs	r2, #3
    96ac:	4638      	mov	r0, r7
    96ae:	47b0      	blx	r6
	offset += strlen(&payload[offset]);	
    96b0:	4638      	mov	r0, r7
    96b2:	47a0      	blx	r4
	
	grid_msg_body_append_text(&message, payload, offset);
    96b4:	a901      	add	r1, sp, #4
    96b6:	1942      	adds	r2, r0, r5
    96b8:	4b10      	ldr	r3, [pc, #64]	; (96fc <grid_debug_print_text+0xdc>)
    96ba:	a865      	add	r0, sp, #404	; 0x194
    96bc:	4798      	blx	r3
	grid_msg_packet_close(&message);
    96be:	4b10      	ldr	r3, [pc, #64]	; (9700 <grid_debug_print_text+0xe0>)
    96c0:	a865      	add	r0, sp, #404	; 0x194
    96c2:	4798      	blx	r3
	
	grid_msg_packet_send_everywhere(&message);
    96c4:	4b0f      	ldr	r3, [pc, #60]	; (9704 <grid_debug_print_text+0xe4>)
    96c6:	a865      	add	r0, sp, #404	; 0x194
    96c8:	4798      	blx	r3
	

	
	
}
    96ca:	f50d 7d4c 	add.w	sp, sp, #816	; 0x330
    96ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for(uint32_t i=0; i<debug_string_length; i++){
    96d2:	3101      	adds	r1, #1
    96d4:	e7d4      	b.n	9680 <grid_debug_print_text+0x60>
    96d6:	bf00      	nop
    96d8:	000089a1 	.word	0x000089a1
    96dc:	00014c8d 	.word	0x00014c8d
    96e0:	00014cfb 	.word	0x00014cfb
    96e4:	0000896d 	.word	0x0000896d
    96e8:	000147c5 	.word	0x000147c5
    96ec:	000162a3 	.word	0x000162a3
    96f0:	000162ab 	.word	0x000162ab
    96f4:	000162ae 	.word	0x000162ae
    96f8:	00015fcb 	.word	0x00015fcb
    96fc:	000088dd 	.word	0x000088dd
    9700:	00008a99 	.word	0x00008a99
    9704:	00008b6d 	.word	0x00008b6d
    9708:	00014d0b 	.word	0x00014d0b

0000970c <tx_cb_USART_GRID>:
static void tx_cb_USART_GRID_W(const struct usart_async_descriptor *const descr)
{
	tx_cb_USART_GRID(&GRID_PORT_W);
}

void tx_cb_USART_GRID(struct grid_port* const por){
    970c:	b530      	push	{r4, r5, lr}
	
	
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    970e:	f06f 052b 	mvn.w	r5, #43	; 0x2b
    9712:	8984      	ldrh	r4, [r0, #12]
    9714:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9718:	1a2d      	subs	r5, r5, r0
    971a:	2200      	movs	r2, #0
    971c:	18e9      	adds	r1, r5, r3
    971e:	428c      	cmp	r4, r1
    9720:	d801      	bhi.n	9726 <tx_cb_USART_GRID+0x1a>
		por->tx_double_buffer[i] = 0;
	}
	por->tx_double_buffer_status = 0;	
    9722:	8182      	strh	r2, [r0, #12]
}
    9724:	bd30      	pop	{r4, r5, pc}
		por->tx_double_buffer[i] = 0;
    9726:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    972a:	e7f7      	b.n	971c <tx_cb_USART_GRID+0x10>

0000972c <tx_cb_USART_GRID_W>:
	tx_cb_USART_GRID(&GRID_PORT_W);
    972c:	4801      	ldr	r0, [pc, #4]	; (9734 <tx_cb_USART_GRID_W+0x8>)
    972e:	4b02      	ldr	r3, [pc, #8]	; (9738 <tx_cb_USART_GRID_W+0xc>)
    9730:	4718      	bx	r3
    9732:	bf00      	nop
    9734:	200102d4 	.word	0x200102d4
    9738:	0000970d 	.word	0x0000970d

0000973c <tx_cb_USART_GRID_S>:
	tx_cb_USART_GRID(&GRID_PORT_S);
    973c:	4801      	ldr	r0, [pc, #4]	; (9744 <tx_cb_USART_GRID_S+0x8>)
    973e:	4b02      	ldr	r3, [pc, #8]	; (9748 <tx_cb_USART_GRID_S+0xc>)
    9740:	4718      	bx	r3
    9742:	bf00      	nop
    9744:	200138d4 	.word	0x200138d4
    9748:	0000970d 	.word	0x0000970d

0000974c <tx_cb_USART_GRID_E>:
	tx_cb_USART_GRID(&GRID_PORT_E);
    974c:	4801      	ldr	r0, [pc, #4]	; (9754 <tx_cb_USART_GRID_E+0x8>)
    974e:	4b02      	ldr	r3, [pc, #8]	; (9758 <tx_cb_USART_GRID_E+0xc>)
    9750:	4718      	bx	r3
    9752:	bf00      	nop
    9754:	20019870 	.word	0x20019870
    9758:	0000970d 	.word	0x0000970d

0000975c <tx_cb_USART_GRID_N>:
	tx_cb_USART_GRID(&GRID_PORT_N);
    975c:	4801      	ldr	r0, [pc, #4]	; (9764 <tx_cb_USART_GRID_N+0x8>)
    975e:	4b02      	ldr	r3, [pc, #8]	; (9768 <tx_cb_USART_GRID_N+0xc>)
    9760:	4718      	bx	r3
    9762:	bf00      	nop
    9764:	20009150 	.word	0x20009150
    9768:	0000970d 	.word	0x0000970d

0000976c <err_cb_USART_GRID>:
	err_cb_USART_GRID(&GRID_PORT_W);
}


void err_cb_USART_GRID(struct grid_port* const por){
	por->usart_error_flag = 1;	
    976c:	2301      	movs	r3, #1
    976e:	7603      	strb	r3, [r0, #24]
	
	usart_async_disable(por->usart);
    9770:	6840      	ldr	r0, [r0, #4]
    9772:	4b01      	ldr	r3, [pc, #4]	; (9778 <err_cb_USART_GRID+0xc>)
    9774:	4718      	bx	r3
    9776:	bf00      	nop
    9778:	00010bd1 	.word	0x00010bd1

0000977c <err_cb_USART_GRID_W>:
	err_cb_USART_GRID(&GRID_PORT_W);
    977c:	4801      	ldr	r0, [pc, #4]	; (9784 <err_cb_USART_GRID_W+0x8>)
    977e:	4b02      	ldr	r3, [pc, #8]	; (9788 <err_cb_USART_GRID_W+0xc>)
    9780:	4718      	bx	r3
    9782:	bf00      	nop
    9784:	200102d4 	.word	0x200102d4
    9788:	0000976d 	.word	0x0000976d

0000978c <err_cb_USART_GRID_S>:
	err_cb_USART_GRID(&GRID_PORT_S);
    978c:	4801      	ldr	r0, [pc, #4]	; (9794 <err_cb_USART_GRID_S+0x8>)
    978e:	4b02      	ldr	r3, [pc, #8]	; (9798 <err_cb_USART_GRID_S+0xc>)
    9790:	4718      	bx	r3
    9792:	bf00      	nop
    9794:	200138d4 	.word	0x200138d4
    9798:	0000976d 	.word	0x0000976d

0000979c <err_cb_USART_GRID_E>:
	err_cb_USART_GRID(&GRID_PORT_E);
    979c:	4801      	ldr	r0, [pc, #4]	; (97a4 <err_cb_USART_GRID_E+0x8>)
    979e:	4b02      	ldr	r3, [pc, #8]	; (97a8 <err_cb_USART_GRID_E+0xc>)
    97a0:	4718      	bx	r3
    97a2:	bf00      	nop
    97a4:	20019870 	.word	0x20019870
    97a8:	0000976d 	.word	0x0000976d

000097ac <err_cb_USART_GRID_N>:
	err_cb_USART_GRID(&GRID_PORT_N);
    97ac:	4801      	ldr	r0, [pc, #4]	; (97b4 <err_cb_USART_GRID_N+0x8>)
    97ae:	4b02      	ldr	r3, [pc, #8]	; (97b8 <err_cb_USART_GRID_N+0xc>)
    97b0:	4718      	bx	r3
    97b2:	bf00      	nop
    97b4:	20009150 	.word	0x20009150
    97b8:	0000976d 	.word	0x0000976d

000097bc <grid_sys_port_reset_dma>:
#define DMA_SOUTH_RX_CHANNEL	2
#define DMA_WEST_RX_CHANNEL		3

void grid_sys_port_reset_dma(struct grid_port* por){
	
	hri_dmac_clear_CHCTRLA_ENABLE_bit(DMAC, por->dma_channel);
    97bc:	7a80      	ldrb	r0, [r0, #10]
}

static inline void hri_dmac_clear_CHCTRLA_ENABLE_bit(const void *const hw, uint8_t submodule_index)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    97be:	0103      	lsls	r3, r0, #4
    97c0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    97c4:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
	_dma_enable_transaction(por->dma_channel, false);
    97c8:	2100      	movs	r1, #0
    97ca:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    97cc:	f022 0202 	bic.w	r2, r2, #2
    97d0:	641a      	str	r2, [r3, #64]	; 0x40
    97d2:	4b01      	ldr	r3, [pc, #4]	; (97d8 <grid_sys_port_reset_dma+0x1c>)
    97d4:	4718      	bx	r3
    97d6:	bf00      	nop
    97d8:	0000e635 	.word	0x0000e635

000097dc <dma_transfer_complete_n_cb>:
	grid_sys_port_reset_dma(por);
    97dc:	4801      	ldr	r0, [pc, #4]	; (97e4 <dma_transfer_complete_n_cb+0x8>)
    97de:	4b02      	ldr	r3, [pc, #8]	; (97e8 <dma_transfer_complete_n_cb+0xc>)
    97e0:	4718      	bx	r3
    97e2:	bf00      	nop
    97e4:	20009150 	.word	0x20009150
    97e8:	000097bd 	.word	0x000097bd

000097ec <dma_transfer_complete_e_cb>:
    97ec:	4801      	ldr	r0, [pc, #4]	; (97f4 <dma_transfer_complete_e_cb+0x8>)
    97ee:	4b02      	ldr	r3, [pc, #8]	; (97f8 <dma_transfer_complete_e_cb+0xc>)
    97f0:	4718      	bx	r3
    97f2:	bf00      	nop
    97f4:	20019870 	.word	0x20019870
    97f8:	000097bd 	.word	0x000097bd

000097fc <dma_transfer_complete_s_cb>:
    97fc:	4801      	ldr	r0, [pc, #4]	; (9804 <dma_transfer_complete_s_cb+0x8>)
    97fe:	4b02      	ldr	r3, [pc, #8]	; (9808 <dma_transfer_complete_s_cb+0xc>)
    9800:	4718      	bx	r3
    9802:	bf00      	nop
    9804:	200138d4 	.word	0x200138d4
    9808:	000097bd 	.word	0x000097bd

0000980c <dma_transfer_complete_w_cb>:
    980c:	4801      	ldr	r0, [pc, #4]	; (9814 <dma_transfer_complete_w_cb+0x8>)
    980e:	4b02      	ldr	r3, [pc, #8]	; (9818 <dma_transfer_complete_w_cb+0xc>)
    9810:	4718      	bx	r3
    9812:	bf00      	nop
    9814:	200102d4 	.word	0x200102d4
    9818:	000097bd 	.word	0x000097bd

0000981c <grid_sys_uart_init>:

}


void grid_sys_uart_init(){
    981c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    9820:	211c      	movs	r1, #28
    9822:	4c2c      	ldr	r4, [pc, #176]	; (98d4 <grid_sys_uart_init+0xb8>)
	gpio_set_pin_pull_mode(PC28, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC16, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC12, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PB09, GPIO_PULL_UP);
	
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    9824:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 9920 <grid_sys_uart_init+0x104>
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9828:	4f2b      	ldr	r7, [pc, #172]	; (98d8 <grid_sys_uart_init+0xbc>)
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    982a:	4e2c      	ldr	r6, [pc, #176]	; (98dc <grid_sys_uart_init+0xc0>)
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    982c:	4d2c      	ldr	r5, [pc, #176]	; (98e0 <grid_sys_uart_init+0xc4>)
			
	// Set parity for grid uart communication
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    982e:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 9924 <grid_sys_uart_init+0x108>
    9832:	2002      	movs	r0, #2
    9834:	47a0      	blx	r4
    9836:	2110      	movs	r1, #16
    9838:	2002      	movs	r0, #2
    983a:	47a0      	blx	r4
    983c:	210c      	movs	r1, #12
    983e:	2002      	movs	r0, #2
    9840:	47a0      	blx	r4
    9842:	2109      	movs	r1, #9
    9844:	2001      	movs	r0, #1
    9846:	47a0      	blx	r4
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    9848:	4c26      	ldr	r4, [pc, #152]	; (98e4 <grid_sys_uart_init+0xc8>)
    984a:	4a27      	ldr	r2, [pc, #156]	; (98e8 <grid_sys_uart_init+0xcc>)
    984c:	2101      	movs	r1, #1
    984e:	4640      	mov	r0, r8
    9850:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9852:	4a26      	ldr	r2, [pc, #152]	; (98ec <grid_sys_uart_init+0xd0>)
    9854:	2101      	movs	r1, #1
    9856:	4638      	mov	r0, r7
    9858:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    985a:	4a25      	ldr	r2, [pc, #148]	; (98f0 <grid_sys_uart_init+0xd4>)
    985c:	2101      	movs	r1, #1
    985e:	4630      	mov	r0, r6
    9860:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    9862:	4a24      	ldr	r2, [pc, #144]	; (98f4 <grid_sys_uart_init+0xd8>)
    9864:	2101      	movs	r1, #1
    9866:	4628      	mov	r0, r5
    9868:	47a0      	blx	r4
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    986a:	2101      	movs	r1, #1
    986c:	4640      	mov	r0, r8
    986e:	47c8      	blx	r9
	usart_async_set_parity(&USART_EAST, USART_PARITY_ODD);	
    9870:	2101      	movs	r1, #1
    9872:	4638      	mov	r0, r7
    9874:	47c8      	blx	r9
	usart_async_set_parity(&USART_SOUTH, USART_PARITY_ODD);
    9876:	2101      	movs	r1, #1
    9878:	4630      	mov	r0, r6
    987a:	47c8      	blx	r9
	usart_async_set_parity(&USART_WEST, USART_PARITY_ODD);
    987c:	2101      	movs	r1, #1
    987e:	4628      	mov	r0, r5
    9880:	47c8      	blx	r9
	
	// Set callback function for parity error
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_N);
    9882:	4a1d      	ldr	r2, [pc, #116]	; (98f8 <grid_sys_uart_init+0xdc>)
    9884:	2102      	movs	r1, #2
    9886:	4640      	mov	r0, r8
    9888:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_E);
    988a:	4a1c      	ldr	r2, [pc, #112]	; (98fc <grid_sys_uart_init+0xe0>)
    988c:	2102      	movs	r1, #2
    988e:	4638      	mov	r0, r7
    9890:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_S);
    9892:	4a1b      	ldr	r2, [pc, #108]	; (9900 <grid_sys_uart_init+0xe4>)
    9894:	2102      	movs	r1, #2
    9896:	4630      	mov	r0, r6
    9898:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_W);
    989a:	4a1a      	ldr	r2, [pc, #104]	; (9904 <grid_sys_uart_init+0xe8>)
    989c:	2102      	movs	r1, #2
    989e:	4628      	mov	r0, r5
    98a0:	47a0      	blx	r4
// 	usart_async_register_callback(&USART_EAST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_E);
// 	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_RXC_CB, rx_cb_USART_GRID_S);
// 	usart_async_register_callback(&USART_WEST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_W);

	
	usart_async_get_io_descriptor(&USART_NORTH, &grid_sys_north_io);
    98a2:	4c19      	ldr	r4, [pc, #100]	; (9908 <grid_sys_uart_init+0xec>)
    98a4:	4919      	ldr	r1, [pc, #100]	; (990c <grid_sys_uart_init+0xf0>)
    98a6:	4640      	mov	r0, r8
    98a8:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_EAST,  &grid_sys_east_io);
    98aa:	4919      	ldr	r1, [pc, #100]	; (9910 <grid_sys_uart_init+0xf4>)
    98ac:	4638      	mov	r0, r7
    98ae:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_SOUTH, &grid_sys_south_io);
    98b0:	4918      	ldr	r1, [pc, #96]	; (9914 <grid_sys_uart_init+0xf8>)
    98b2:	4630      	mov	r0, r6
    98b4:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_WEST,  &grid_sys_west_io);
    98b6:	4918      	ldr	r1, [pc, #96]	; (9918 <grid_sys_uart_init+0xfc>)
    98b8:	4628      	mov	r0, r5
    98ba:	47a0      	blx	r4
	
	
	usart_async_enable(&USART_NORTH);
    98bc:	4c17      	ldr	r4, [pc, #92]	; (991c <grid_sys_uart_init+0x100>)
    98be:	4640      	mov	r0, r8
    98c0:	47a0      	blx	r4
	usart_async_enable(&USART_EAST);
    98c2:	4638      	mov	r0, r7
    98c4:	47a0      	blx	r4
	usart_async_enable(&USART_SOUTH);
    98c6:	4630      	mov	r0, r6
    98c8:	47a0      	blx	r4
	usart_async_enable(&USART_WEST);
    98ca:	4628      	mov	r0, r5
    98cc:	4623      	mov	r3, r4




}
    98ce:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	usart_async_enable(&USART_WEST);
    98d2:	4718      	bx	r3
    98d4:	00009101 	.word	0x00009101
    98d8:	2001cdb0 	.word	0x2001cdb0
    98dc:	2001cf08 	.word	0x2001cf08
    98e0:	2001ceb8 	.word	0x2001ceb8
    98e4:	00010c21 	.word	0x00010c21
    98e8:	0000975d 	.word	0x0000975d
    98ec:	0000974d 	.word	0x0000974d
    98f0:	0000973d 	.word	0x0000973d
    98f4:	0000972d 	.word	0x0000972d
    98f8:	000097ad 	.word	0x000097ad
    98fc:	0000979d 	.word	0x0000979d
    9900:	0000978d 	.word	0x0000978d
    9904:	0000977d 	.word	0x0000977d
    9908:	00010bfd 	.word	0x00010bfd
    990c:	2000f004 	.word	0x2000f004
    9910:	200138d0 	.word	0x200138d0
    9914:	20016820 	.word	0x20016820
    9918:	2001c850 	.word	0x2001c850
    991c:	00010ba5 	.word	0x00010ba5
    9920:	2001ce04 	.word	0x2001ce04
    9924:	00010c81 	.word	0x00010c81

00009928 <grid_sys_dma_rx_init_one>:



void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9928:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	
	uint8_t dma_rx_channel = por->dma_channel;
	
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    992a:	6843      	ldr	r3, [r0, #4]
	uint8_t dma_rx_channel = por->dma_channel;
    992c:	7a84      	ldrb	r4, [r0, #10]
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    992e:	460f      	mov	r7, r1
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9930:	6a19      	ldr	r1, [r3, #32]
    9932:	4b10      	ldr	r3, [pc, #64]	; (9974 <grid_sys_dma_rx_init_one+0x4c>)
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9934:	4605      	mov	r5, r0
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9936:	3128      	adds	r1, #40	; 0x28
    9938:	4620      	mov	r0, r4
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    993a:	4616      	mov	r6, r2
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    993c:	4798      	blx	r3
	_dma_set_destination_address(dma_rx_channel, (uint32_t *)por->rx_double_buffer);
    993e:	f505 519d 	add.w	r1, r5, #5024	; 0x13a0
    9942:	4b0d      	ldr	r3, [pc, #52]	; (9978 <grid_sys_dma_rx_init_one+0x50>)
    9944:	3114      	adds	r1, #20
    9946:	4620      	mov	r0, r4
    9948:	4798      	blx	r3
	_dma_set_data_amount(dma_rx_channel, (uint32_t)buffer_length);
    994a:	4639      	mov	r1, r7
    994c:	4b0b      	ldr	r3, [pc, #44]	; (997c <grid_sys_dma_rx_init_one+0x54>)
    994e:	4620      	mov	r0, r4
    9950:	4798      	blx	r3
	
	struct _dma_resource *resource_rx;
	_dma_get_channel_resource(&resource_rx, dma_rx_channel);
    9952:	4621      	mov	r1, r4
    9954:	4b0a      	ldr	r3, [pc, #40]	; (9980 <grid_sys_dma_rx_init_one+0x58>)
    9956:	a801      	add	r0, sp, #4
    9958:	4798      	blx	r3
	
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    995a:	9b01      	ldr	r3, [sp, #4]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    995c:	2201      	movs	r2, #1
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    995e:	601e      	str	r6, [r3, #0]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    9960:	4620      	mov	r0, r4
    9962:	4b08      	ldr	r3, [pc, #32]	; (9984 <grid_sys_dma_rx_init_one+0x5c>)
    9964:	2100      	movs	r1, #0
    9966:	4798      	blx	r3
	
	//resource_rx->dma_cb.error         = function_cb;
	_dma_enable_transaction(dma_rx_channel, false);
    9968:	4b07      	ldr	r3, [pc, #28]	; (9988 <grid_sys_dma_rx_init_one+0x60>)
    996a:	2100      	movs	r1, #0
    996c:	4620      	mov	r0, r4
    996e:	4798      	blx	r3
	

}
    9970:	b003      	add	sp, #12
    9972:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9974:	0000e5c5 	.word	0x0000e5c5
    9978:	0000e5b5 	.word	0x0000e5b5
    997c:	0000e5f1 	.word	0x0000e5f1
    9980:	0000e671 	.word	0x0000e671
    9984:	0000e58d 	.word	0x0000e58d
    9988:	0000e635 	.word	0x0000e635

0000998c <grid_sys_dma_rx_init>:

void grid_sys_dma_rx_init(){
    998c:	b510      	push	{r4, lr}
	
	grid_sys_dma_rx_init_one(&GRID_PORT_N, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_n_cb);
    998e:	4a10      	ldr	r2, [pc, #64]	; (99d0 <grid_sys_dma_rx_init+0x44>)
    9990:	4c10      	ldr	r4, [pc, #64]	; (99d4 <grid_sys_dma_rx_init+0x48>)
    9992:	4811      	ldr	r0, [pc, #68]	; (99d8 <grid_sys_dma_rx_init+0x4c>)
    9994:	f241 3188 	movw	r1, #5000	; 0x1388
    9998:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_E, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_e_cb);
    999a:	4a10      	ldr	r2, [pc, #64]	; (99dc <grid_sys_dma_rx_init+0x50>)
    999c:	4810      	ldr	r0, [pc, #64]	; (99e0 <grid_sys_dma_rx_init+0x54>)
    999e:	f241 3188 	movw	r1, #5000	; 0x1388
    99a2:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_S, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_s_cb);
    99a4:	4a0f      	ldr	r2, [pc, #60]	; (99e4 <grid_sys_dma_rx_init+0x58>)
    99a6:	4810      	ldr	r0, [pc, #64]	; (99e8 <grid_sys_dma_rx_init+0x5c>)
    99a8:	f241 3188 	movw	r1, #5000	; 0x1388
    99ac:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_W, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_w_cb);
    99ae:	4a0f      	ldr	r2, [pc, #60]	; (99ec <grid_sys_dma_rx_init+0x60>)
    99b0:	480f      	ldr	r0, [pc, #60]	; (99f0 <grid_sys_dma_rx_init+0x64>)
    99b2:	f241 3188 	movw	r1, #5000	; 0x1388
    99b6:	47a0      	blx	r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    99b8:	4b0e      	ldr	r3, [pc, #56]	; (99f4 <grid_sys_dma_rx_init+0x68>)
    99ba:	2200      	movs	r2, #0
    99bc:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
    99c0:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
    99c4:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
    99c8:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
	NVIC_SetPriority(DMAC_0_IRQn, 0);
	NVIC_SetPriority(DMAC_1_IRQn, 0);
	NVIC_SetPriority(DMAC_2_IRQn, 0);
	NVIC_SetPriority(DMAC_3_IRQn, 0);
	
}
    99cc:	bd10      	pop	{r4, pc}
    99ce:	bf00      	nop
    99d0:	000097dd 	.word	0x000097dd
    99d4:	00009929 	.word	0x00009929
    99d8:	20009150 	.word	0x20009150
    99dc:	000097ed 	.word	0x000097ed
    99e0:	20019870 	.word	0x20019870
    99e4:	000097fd 	.word	0x000097fd
    99e8:	200138d4 	.word	0x200138d4
    99ec:	0000980d 	.word	0x0000980d
    99f0:	200102d4 	.word	0x200102d4
    99f4:	e000e100 	.word	0xe000e100

000099f8 <grid_sys_init>:
	return tmp;
}

static inline hri_rstc_rcause_reg_t hri_rstc_read_RCAUSE_reg(const void *const hw)
{
	return ((Rstc *)hw)->RCAUSE.reg;
    99f8:	4b16      	ldr	r3, [pc, #88]	; (9a54 <grid_sys_init+0x5c>)

void grid_sys_init(struct grid_sys_model* mod){
    99fa:	b570      	push	{r4, r5, r6, lr}
    99fc:	781b      	ldrb	r3, [r3, #0]
	
	mod->uptime = 0;
	mod->reset_cause = hri_rstc_read_RCAUSE_reg(RSTC);
    99fe:	7103      	strb	r3, [r0, #4]
	mod->uptime = 0;
    9a00:	2500      	movs	r5, #0
void grid_sys_init(struct grid_sys_model* mod){
    9a02:	4604      	mov	r4, r0
	mod->uptime = 0;
    9a04:	6005      	str	r5, [r0, #0]
	
    
	mod->sessionid = rand_sync_read8(&RAND_0);
    9a06:	4b14      	ldr	r3, [pc, #80]	; (9a58 <grid_sys_init+0x60>)
    9a08:	4814      	ldr	r0, [pc, #80]	; (9a5c <grid_sys_init+0x64>)
    9a0a:	4798      	blx	r3
	mod->bank_color_r[3] = 100;
	mod->bank_color_g[3] = 0;
	mod->bank_color_b[3] = 200;
	
	mod->bank_enabled[0] = 1;
	mod->bank_enabled[1] = 1;
    9a0c:	4a14      	ldr	r2, [pc, #80]	; (9a60 <grid_sys_init+0x68>)
    9a0e:	4b15      	ldr	r3, [pc, #84]	; (9a64 <grid_sys_init+0x6c>)
	mod->bank_color_g[1] = 100;
    9a10:	4915      	ldr	r1, [pc, #84]	; (9a68 <grid_sys_init+0x70>)
	mod->sessionid = rand_sync_read8(&RAND_0);
    9a12:	7160      	strb	r0, [r4, #5]
	mod->bank_enabled[1] = 1;
    9a14:	e9c4 2304 	strd	r2, r3, [r4, #16]
	mod->bank_color_g[1] = 100;
    9a18:	4b14      	ldr	r3, [pc, #80]	; (9a6c <grid_sys_init+0x74>)
	mod->bank_setting_changed_flag = 0;
	
	mod->bank_init_flag = 0;


	mod->bank_activebank_number = 0;
    9a1a:	73e5      	strb	r5, [r4, #15]
	mod->bank_color_g[1] = 100;
    9a1c:	e9c4 1306 	strd	r1, r3, [r4, #24]
	mod->bank_color_b[1] = 0;
    9a20:	f44f 5348 	mov.w	r3, #12800	; 0x3200
    9a24:	8423      	strh	r3, [r4, #32]
	mod->bank_color_b[3] = 200;
    9a26:	23c8      	movs	r3, #200	; 0xc8
    9a28:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	if (banknumber == 255){
			
		//mod->bank_activebank_number = 0;
		mod->bank_activebank_valid = 0;
		
		mod->bank_active_changed = 1;
    9a2c:	4b10      	ldr	r3, [pc, #64]	; (9a70 <grid_sys_init+0x78>)
	mod->bank_activebank_color_r = 0;
    9a2e:	6265      	str	r5, [r4, #36]	; 0x24
		mod->bank_active_changed = 1;
    9a30:	2201      	movs	r2, #1
    9a32:	745a      	strb	r2, [r3, #17]
				
		mod->bank_activebank_color_r = 127;
    9a34:	f647 727f 	movw	r2, #32639	; 0x7f7f
		mod->bank_activebank_valid = 0;
    9a38:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9a3c:	849a      	strh	r2, [r3, #36]	; 0x24
		mod->bank_activebank_color_g = 127;
		mod->bank_activebank_color_b = 127;
    9a3e:	227f      	movs	r2, #127	; 0x7f
    9a40:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	grid_port_init_all();
    9a44:	4b0b      	ldr	r3, [pc, #44]	; (9a74 <grid_sys_init+0x7c>)
    9a46:	4798      	blx	r3
	grid_sys_uart_init();
    9a48:	4b0b      	ldr	r3, [pc, #44]	; (9a78 <grid_sys_init+0x80>)
    9a4a:	4798      	blx	r3
}
    9a4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	grid_sys_dma_rx_init();
    9a50:	4b0a      	ldr	r3, [pc, #40]	; (9a7c <grid_sys_init+0x84>)
    9a52:	4718      	bx	r3
    9a54:	40000c00 	.word	0x40000c00
    9a58:	0000eba5 	.word	0x0000eba5
    9a5c:	2001cd7c 	.word	0x2001cd7c
    9a60:	01000001 	.word	0x01000001
    9a64:	00010101 	.word	0x00010101
    9a68:	646432c8 	.word	0x646432c8
    9a6c:	c800c864 	.word	0xc800c864
    9a70:	2000f008 	.word	0x2000f008
    9a74:	0000511d 	.word	0x0000511d
    9a78:	0000981d 	.word	0x0000981d
    9a7c:	0000998d 	.word	0x0000998d

00009a80 <grid_sys_bank_enable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9a80:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 1;
    9a82:	bf9e      	ittt	ls
    9a84:	1809      	addls	r1, r1, r0
    9a86:	2301      	movls	r3, #1
    9a88:	74cb      	strbls	r3, [r1, #19]
}
    9a8a:	4770      	bx	lr

00009a8c <grid_sys_bank_disable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9a8c:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 0;
    9a8e:	bf9e      	ittt	ls
    9a90:	1809      	addls	r1, r1, r0
    9a92:	2300      	movls	r3, #0
    9a94:	74cb      	strbls	r3, [r1, #19]
}
    9a96:	4770      	bx	lr

00009a98 <grid_sys_bank_set_color>:
	if (banknumber>GRID_SYS_BANK_MAXNUMBER){
    9a98:	2904      	cmp	r1, #4
    9a9a:	d901      	bls.n	9aa0 <grid_sys_bank_set_color+0x8>
		return false;
    9a9c:	2000      	movs	r0, #0
    9a9e:	4770      	bx	lr
	mod->bank_color_r[banknumber] = ((rgb&0x00FF0000)>>16);
    9aa0:	4401      	add	r1, r0
    9aa2:	0c13      	lsrs	r3, r2, #16
    9aa4:	75cb      	strb	r3, [r1, #23]
	mod->bank_color_g[banknumber] = ((rgb&0x0000FF00)>>8);
    9aa6:	0a13      	lsrs	r3, r2, #8
    9aa8:	76cb      	strb	r3, [r1, #27]
	mod->bank_color_b[banknumber] = ((rgb&0x000000FF)>>0);
    9aaa:	77ca      	strb	r2, [r1, #31]
}
    9aac:	4770      	bx	lr

00009aae <grid_sys_get_bank_num>:
}
    9aae:	7bc0      	ldrb	r0, [r0, #15]
    9ab0:	4770      	bx	lr

00009ab2 <grid_sys_get_bank_valid>:
}
    9ab2:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
    9ab6:	4770      	bx	lr

00009ab8 <grid_sys_get_bank_red>:
}
    9ab8:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    9abc:	4770      	bx	lr

00009abe <grid_sys_get_bank_gre>:
}
    9abe:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
    9ac2:	4770      	bx	lr

00009ac4 <grid_sys_get_bank_blu>:
}
    9ac4:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
    9ac8:	4770      	bx	lr

00009aca <grid_sys_get_map_state>:
}
    9aca:	7c00      	ldrb	r0, [r0, #16]
    9acc:	4770      	bx	lr

00009ace <grid_sys_get_bank_next>:
uint8_t grid_sys_get_bank_next(struct grid_sys_model* mod){
    9ace:	b530      	push	{r4, r5, lr}
    9ad0:	4602      	mov	r2, r0
	return mod->bank_activebank_number;
    9ad2:	7bc0      	ldrb	r0, [r0, #15]
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9ad4:	1c43      	adds	r3, r0, #1
    9ad6:	1d44      	adds	r4, r0, #5
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    9ad8:	f003 0103 	and.w	r1, r3, #3
		if (mod->bank_enabled[bank_check] == 1){
    9adc:	1855      	adds	r5, r2, r1
    9ade:	7ced      	ldrb	r5, [r5, #19]
    9ae0:	2d01      	cmp	r5, #1
    9ae2:	d003      	beq.n	9aec <grid_sys_get_bank_next+0x1e>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9ae4:	3301      	adds	r3, #1
    9ae6:	42a3      	cmp	r3, r4
    9ae8:	d1f6      	bne.n	9ad8 <grid_sys_get_bank_next+0xa>
}
    9aea:	bd30      	pop	{r4, r5, pc}
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    9aec:	b2c8      	uxtb	r0, r1
    9aee:	e7fc      	b.n	9aea <grid_sys_get_bank_next+0x1c>

00009af0 <grid_sys_get_bank_number_of_first_valid>:
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9af0:	f100 0213 	add.w	r2, r0, #19
uint8_t grid_sys_get_bank_number_of_first_valid(struct grid_sys_model* mod){
    9af4:	2300      	movs	r3, #0
		if (mod->bank_enabled[i] == 1){
    9af6:	f812 1b01 	ldrb.w	r1, [r2], #1
    9afa:	2901      	cmp	r1, #1
    9afc:	b2d8      	uxtb	r0, r3
    9afe:	d003      	beq.n	9b08 <grid_sys_get_bank_number_of_first_valid+0x18>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    9b00:	3301      	adds	r3, #1
    9b02:	2b04      	cmp	r3, #4
    9b04:	d1f7      	bne.n	9af6 <grid_sys_get_bank_number_of_first_valid+0x6>
	return 255;
    9b06:	20ff      	movs	r0, #255	; 0xff
}
    9b08:	4770      	bx	lr

00009b0a <grid_sys_set_bank>:
	if (banknumber == 255){
    9b0a:	29ff      	cmp	r1, #255	; 0xff
    9b0c:	d10b      	bne.n	9b26 <grid_sys_set_bank+0x1c>
		mod->bank_active_changed = 1;
    9b0e:	2301      	movs	r3, #1
    9b10:	7443      	strb	r3, [r0, #17]
		mod->bank_activebank_valid = 0;
    9b12:	2300      	movs	r3, #0
    9b14:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9b18:	f647 737f 	movw	r3, #32639	; 0x7f7f
    9b1c:	8483      	strh	r3, [r0, #36]	; 0x24
		mod->bank_activebank_color_b = 127;
    9b1e:	237f      	movs	r3, #127	; 0x7f
			
			mod->bank_active_changed = 1;
			
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    9b20:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
		//grid_debug_print_text("Invalid Bank Number");	
				
	}

	
}
    9b24:	4770      	bx	lr
	else if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9b26:	2903      	cmp	r1, #3
    9b28:	d8fc      	bhi.n	9b24 <grid_sys_set_bank+0x1a>
		mod->bank_init_flag = 1;
    9b2a:	2301      	movs	r3, #1
    9b2c:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
		if (mod->bank_enabled[banknumber] == 1){
    9b30:	1843      	adds	r3, r0, r1
    9b32:	7cda      	ldrb	r2, [r3, #19]
    9b34:	2a01      	cmp	r2, #1
    9b36:	d1f5      	bne.n	9b24 <grid_sys_set_bank+0x1a>
			mod->bank_activebank_number = banknumber;
    9b38:	73c1      	strb	r1, [r0, #15]
			mod->bank_activebank_valid = 1;
    9b3a:	f880 2023 	strb.w	r2, [r0, #35]	; 0x23
			mod->bank_active_changed = 1;
    9b3e:	7442      	strb	r2, [r0, #17]
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
    9b40:	7dda      	ldrb	r2, [r3, #23]
    9b42:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
    9b46:	7eda      	ldrb	r2, [r3, #27]
    9b48:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    9b4c:	7fdb      	ldrb	r3, [r3, #31]
    9b4e:	e7e7      	b.n	9b20 <grid_sys_set_bank+0x16>

00009b50 <grid_sys_rtc_get_time>:

// REALTIME

uint32_t grid_sys_rtc_get_time(struct grid_sys_model* mod){
	return mod->realtime;
}
    9b50:	6a80      	ldr	r0, [r0, #40]	; 0x28
    9b52:	4770      	bx	lr

00009b54 <grid_sys_rtc_get_elapsed_time>:
	mod->realtime = tvalue;
}

uint32_t grid_sys_rtc_get_elapsed_time(struct grid_sys_model* mod, uint32_t t_old){
	
	return mod->realtime-t_old;
    9b54:	6a80      	ldr	r0, [r0, #40]	; 0x28
	
	

}
    9b56:	1a40      	subs	r0, r0, r1
    9b58:	4770      	bx	lr

00009b5a <grid_sys_rtc_tick_time>:

void grid_sys_rtc_tick_time(struct grid_sys_model* mod){
	
	mod->realtime++;
    9b5a:	6a83      	ldr	r3, [r0, #40]	; 0x28
    9b5c:	3301      	adds	r3, #1
    9b5e:	6283      	str	r3, [r0, #40]	; 0x28
	if (mod->uptime != -1){
    9b60:	6803      	ldr	r3, [r0, #0]
    9b62:	1c5a      	adds	r2, r3, #1
		mod->uptime++;
    9b64:	bf1c      	itt	ne
    9b66:	3301      	addne	r3, #1
    9b68:	6003      	strne	r3, [r0, #0]
	}
	
}
    9b6a:	4770      	bx	lr

00009b6c <grid_sys_alert_read_color_changed_flag>:

uint8_t grid_sys_alert_read_color_changed_flag(struct grid_sys_model* mod){
		
	return mod->alert_color_changed;
	
}
    9b6c:	7b80      	ldrb	r0, [r0, #14]
    9b6e:	4770      	bx	lr

00009b70 <grid_sys_alert_clear_color_changed_flag>:
	
}

void grid_sys_alert_clear_color_changed_flag(struct grid_sys_model* mod){
	
	mod->alert_color_changed = 0;
    9b70:	2300      	movs	r3, #0
    9b72:	7383      	strb	r3, [r0, #14]
	
}
    9b74:	4770      	bx	lr

00009b76 <grid_sys_alert_get_color_intensity>:

uint8_t grid_sys_alert_get_color_intensity(struct grid_sys_model* mod){
	
	if (mod->alert_style == 0){ // TRIANGLE
    9b76:	7b03      	ldrb	r3, [r0, #12]
    9b78:	b963      	cbnz	r3, 9b94 <grid_sys_alert_get_color_intensity+0x1e>
		
		return (250-abs(mod->alert_state/2-250))/2;
    9b7a:	8940      	ldrh	r0, [r0, #10]
    9b7c:	0840      	lsrs	r0, r0, #1
    9b7e:	38fa      	subs	r0, #250	; 0xfa
    9b80:	2800      	cmp	r0, #0
    9b82:	bfb8      	it	lt
    9b84:	4240      	neglt	r0, r0
    9b86:	f1c0 00fa 	rsb	r0, r0, #250	; 0xfa
    9b8a:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    9b8e:	f3c0 0047 	ubfx	r0, r0, #1, #8
    9b92:	4770      	bx	lr
	}
	else if (mod->alert_style == 1){ // SQUARE
    9b94:	2b01      	cmp	r3, #1
    9b96:	d107      	bne.n	9ba8 <grid_sys_alert_get_color_intensity+0x32>
		
		return 255*(mod->alert_state/250%2);
    9b98:	8940      	ldrh	r0, [r0, #10]
    9b9a:	23fa      	movs	r3, #250	; 0xfa
    9b9c:	fbb0 f0f3 	udiv	r0, r0, r3
    9ba0:	f340 0000 	sbfx	r0, r0, #0, #1
    9ba4:	b2c0      	uxtb	r0, r0
    9ba6:	4770      	bx	lr
	}
	else if (mod->alert_style == 2){ // CONST
    9ba8:	2b02      	cmp	r3, #2
    9baa:	d105      	bne.n	9bb8 <grid_sys_alert_get_color_intensity+0x42>
		
		return 255*(mod->alert_state>100);
    9bac:	8940      	ldrh	r0, [r0, #10]
    9bae:	2864      	cmp	r0, #100	; 0x64
    9bb0:	bf8c      	ite	hi
    9bb2:	20ff      	movhi	r0, #255	; 0xff
    9bb4:	2000      	movls	r0, #0
    9bb6:	4770      	bx	lr
	}
	
	
}
    9bb8:	4770      	bx	lr

00009bba <grid_sys_alert_set_alert>:
	mod->alert_color_green = green;
	mod->alert_color_blue = blue;
		
}

void grid_sys_alert_set_alert(struct grid_sys_model* mod, uint8_t red, uint8_t green, uint8_t blue, uint8_t style, uint16_t duration){
    9bba:	b510      	push	{r4, lr}
	mod->alert_color_blue = blue;
    9bbc:	7203      	strb	r3, [r0, #8]
	
	grid_sys_alert_set_color(mod, red, green, blue);

	
	mod->alert_state = duration;
    9bbe:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    9bc2:	8143      	strh	r3, [r0, #10]
	mod->alert_color_changed = 1;
    9bc4:	2401      	movs	r4, #1
	mod->alert_style = style;
    9bc6:	f89d 3008 	ldrb.w	r3, [sp, #8]
	mod->alert_color_changed = 1;
    9bca:	7384      	strb	r4, [r0, #14]
	mod->alert_color_red = red;
    9bcc:	7181      	strb	r1, [r0, #6]
	mod->alert_color_green = green;
    9bce:	71c2      	strb	r2, [r0, #7]
	mod->alert_style = style;
    9bd0:	7303      	strb	r3, [r0, #12]
	
}
    9bd2:	bd10      	pop	{r4, pc}

00009bd4 <grid_sys_alert_get_color_r>:

uint8_t grid_sys_alert_get_color_r(struct grid_sys_model* mod){
	
	return mod->alert_color_red;
}
    9bd4:	7980      	ldrb	r0, [r0, #6]
    9bd6:	4770      	bx	lr

00009bd8 <grid_sys_alert_get_color_g>:

uint8_t grid_sys_alert_get_color_g(struct grid_sys_model* mod){
	
	return mod->alert_color_green;
}
    9bd8:	79c0      	ldrb	r0, [r0, #7]
    9bda:	4770      	bx	lr

00009bdc <grid_sys_alert_get_color_b>:

uint8_t grid_sys_alert_get_color_b(struct grid_sys_model* mod){
	
	return mod->alert_color_blue;
}
    9bdc:	7a00      	ldrb	r0, [r0, #8]
    9bde:	4770      	bx	lr

00009be0 <grid_sys_read_hex_char_value>:

uint8_t grid_sys_read_hex_char_value(uint8_t ascii, uint8_t* error_flag){
		
	uint8_t result = 0;
	
	if (ascii>47 && ascii<58){
    9be0:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    9be4:	b2db      	uxtb	r3, r3
    9be6:	2b09      	cmp	r3, #9
    9be8:	d905      	bls.n	9bf6 <grid_sys_read_hex_char_value+0x16>
		result = ascii-48;
	}
	else if(ascii>96 && ascii<103){
    9bea:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
    9bee:	2b05      	cmp	r3, #5
    9bf0:	d803      	bhi.n	9bfa <grid_sys_read_hex_char_value+0x1a>
		result = ascii - 97 + 10;
    9bf2:	3857      	subs	r0, #87	; 0x57
    9bf4:	b2c3      	uxtb	r3, r0
			*error_flag = ascii;
		}
	}
	
	return result;	
}
    9bf6:	4618      	mov	r0, r3
    9bf8:	4770      	bx	lr
		if (error_flag != NULL){
    9bfa:	b111      	cbz	r1, 9c02 <grid_sys_read_hex_char_value+0x22>
			*error_flag = ascii;
    9bfc:	7008      	strb	r0, [r1, #0]
	uint8_t result = 0;
    9bfe:	2300      	movs	r3, #0
    9c00:	e7f9      	b.n	9bf6 <grid_sys_read_hex_char_value+0x16>
    9c02:	460b      	mov	r3, r1
    9c04:	e7f7      	b.n	9bf6 <grid_sys_read_hex_char_value+0x16>
	...

00009c08 <grid_sys_read_hex_string_value>:

uint32_t grid_sys_read_hex_string_value(uint8_t* start_location, uint8_t length, uint8_t* error_flag){
    9c08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	uint32_t result  = 0;
	
	for(uint8_t i=0; i<length; i++){
		
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    9c0a:	4f08      	ldr	r7, [pc, #32]	; (9c2c <grid_sys_read_hex_string_value+0x24>)
    9c0c:	1e45      	subs	r5, r0, #1
    9c0e:	008c      	lsls	r4, r1, #2
	uint32_t result  = 0;
    9c10:	2600      	movs	r6, #0
	for(uint8_t i=0; i<length; i++){
    9c12:	3c04      	subs	r4, #4
    9c14:	1d23      	adds	r3, r4, #4
    9c16:	d101      	bne.n	9c1c <grid_sys_read_hex_string_value+0x14>

		
	}

	return result;
}
    9c18:	4630      	mov	r0, r6
    9c1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    9c1c:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    9c20:	4611      	mov	r1, r2
    9c22:	47b8      	blx	r7
    9c24:	40a0      	lsls	r0, r4
    9c26:	4406      	add	r6, r0
	for(uint8_t i=0; i<length; i++){
    9c28:	e7f3      	b.n	9c12 <grid_sys_read_hex_string_value+0xa>
    9c2a:	bf00      	nop
    9c2c:	00009be1 	.word	0x00009be1

00009c30 <grid_sys_write_hex_string_value>:

void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    9c30:	b530      	push	{r4, r5, lr}
    9c32:	b085      	sub	sp, #20
	
	uint8_t str[10];
	
	sprintf(str, "%08x", value);
    9c34:	4b0a      	ldr	r3, [pc, #40]	; (9c60 <grid_sys_write_hex_string_value+0x30>)
void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    9c36:	460c      	mov	r4, r1
    9c38:	4605      	mov	r5, r0
	sprintf(str, "%08x", value);
    9c3a:	490a      	ldr	r1, [pc, #40]	; (9c64 <grid_sys_write_hex_string_value+0x34>)
    9c3c:	a801      	add	r0, sp, #4
    9c3e:	4798      	blx	r3
		
	for(uint8_t i=0; i<size; i++){	
    9c40:	aa01      	add	r2, sp, #4
    9c42:	f1c4 0308 	rsb	r3, r4, #8
    9c46:	4413      	add	r3, r2
    9c48:	2200      	movs	r2, #0
    9c4a:	b2d1      	uxtb	r1, r2
    9c4c:	428c      	cmp	r4, r1
    9c4e:	d801      	bhi.n	9c54 <grid_sys_write_hex_string_value+0x24>
		start_location[i] = str[8-size+i];	
	}

}
    9c50:	b005      	add	sp, #20
    9c52:	bd30      	pop	{r4, r5, pc}
		start_location[i] = str[8-size+i];	
    9c54:	f813 1b01 	ldrb.w	r1, [r3], #1
    9c58:	54a9      	strb	r1, [r5, r2]
	for(uint8_t i=0; i<size; i++){	
    9c5a:	3201      	adds	r2, #1
    9c5c:	e7f5      	b.n	9c4a <grid_sys_write_hex_string_value+0x1a>
    9c5e:	bf00      	nop
    9c60:	00014c8d 	.word	0x00014c8d
    9c64:	000162b1 	.word	0x000162b1

00009c68 <grid_sys_get_id>:



uint32_t grid_sys_get_id(uint32_t* return_array){
			
	return_array[0] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_0);
    9c68:	4b06      	ldr	r3, [pc, #24]	; (9c84 <grid_sys_get_id+0x1c>)
    9c6a:	681b      	ldr	r3, [r3, #0]
    9c6c:	6003      	str	r3, [r0, #0]
	return_array[1] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_1);
    9c6e:	4b06      	ldr	r3, [pc, #24]	; (9c88 <grid_sys_get_id+0x20>)
    9c70:	681b      	ldr	r3, [r3, #0]
    9c72:	6043      	str	r3, [r0, #4]
	return_array[2] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_2);
    9c74:	4b05      	ldr	r3, [pc, #20]	; (9c8c <grid_sys_get_id+0x24>)
    9c76:	681b      	ldr	r3, [r3, #0]
    9c78:	6083      	str	r3, [r0, #8]
	return_array[3] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_3);
    9c7a:	4b05      	ldr	r3, [pc, #20]	; (9c90 <grid_sys_get_id+0x28>)
    9c7c:	681b      	ldr	r3, [r3, #0]
    9c7e:	60c3      	str	r3, [r0, #12]
	
	return 1;
	
}
    9c80:	2001      	movs	r0, #1
    9c82:	4770      	bx	lr
    9c84:	008061fc 	.word	0x008061fc
    9c88:	00806010 	.word	0x00806010
    9c8c:	00806014 	.word	0x00806014
    9c90:	00806018 	.word	0x00806018

00009c94 <grid_sys_get_hwcfg>:

uint32_t grid_sys_get_hwcfg(){
    9c94:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	// Read the register for the first time, then later just return the saved value

	if (grid_sys_hwfcg == -1){
    9c98:	4e30      	ldr	r6, [pc, #192]	; (9d5c <grid_sys_get_hwcfg+0xc8>)
    9c9a:	6833      	ldr	r3, [r6, #0]
    9c9c:	3301      	adds	r3, #1
    9c9e:	d158      	bne.n	9d52 <grid_sys_get_hwcfg+0xbe>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9ca0:	4c2f      	ldr	r4, [pc, #188]	; (9d60 <grid_sys_get_hwcfg+0xcc>)
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9ca2:	4b30      	ldr	r3, [pc, #192]	; (9d64 <grid_sys_get_hwcfg+0xd0>)
		gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
		gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
			
		// LOAD DATA
		gpio_set_pin_level(HWCFG_SHIFT, 0);
		delay_ms(1);
    9ca4:	4f30      	ldr	r7, [pc, #192]	; (9d68 <grid_sys_get_hwcfg+0xd4>)
	CRITICAL_SECTION_ENTER();
    9ca6:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 9d74 <grid_sys_get_hwcfg+0xe0>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9caa:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    9cae:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    9cb2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9cb6:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9cba:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    9cbe:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    9cc2:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9cc6:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    9cca:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
    9cce:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    9cd2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    9cd6:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    9cda:	4b24      	ldr	r3, [pc, #144]	; (9d6c <grid_sys_get_hwcfg+0xd8>)
    9cdc:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9ce0:	f1a3 2380 	sub.w	r3, r3, #2147516416	; 0x80008000
    9ce4:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    9ce8:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9cea:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    9cee:	47b8      	blx	r7
    9cf0:	f04f 0a00 	mov.w	sl, #0
			
			
			
		uint8_t hwcfg_value = 0;
    9cf4:	46d3      	mov	fp, sl
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9cf6:	46a8      	mov	r8, r5
			
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
				
			// SHIFT DATA
			gpio_set_pin_level(HWCFG_SHIFT, 1); //This outputs the first value to HWCFG_DATA
			delay_ms(1);
    9cf8:	2001      	movs	r0, #1
    9cfa:	f8c4 8098 	str.w	r8, [r4, #152]	; 0x98
    9cfe:	47b8      	blx	r7
    9d00:	a801      	add	r0, sp, #4
    9d02:	47c8      	blx	r9
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    9d04:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    9d08:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    9d0c:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    9d10:	405d      	eors	r5, r3
    9d12:	4015      	ands	r5, r2
    9d14:	405d      	eors	r5, r3
	CRITICAL_SECTION_LEAVE();
    9d16:	a801      	add	r0, sp, #4
    9d18:	4b15      	ldr	r3, [pc, #84]	; (9d70 <grid_sys_get_hwcfg+0xdc>)
    9d1a:	4798      	blx	r3
				
				
			if(gpio_get_pin_level(HWCFG_DATA)){
    9d1c:	042b      	lsls	r3, r5, #16
					
				hwcfg_value |= (1<<i);
    9d1e:	bf41      	itttt	mi
    9d20:	2301      	movmi	r3, #1
    9d22:	fa03 f30a 	lslmi.w	r3, r3, sl
    9d26:	ea43 0b0b 	orrmi.w	fp, r3, fp
    9d2a:	fa5f fb8b 	uxtbmi.w	fp, fp
				}else{
					
					
			}
				
			if(i!=7){
    9d2e:	f1ba 0f07 	cmp.w	sl, #7
    9d32:	d007      	beq.n	9d44 <grid_sys_get_hwcfg+0xb0>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9d34:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    9d38:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
					
				// Clock rise
				gpio_set_pin_level(HWCFG_CLOCK, 1);
					
				delay_ms(1);
    9d3c:	2001      	movs	r0, #1
    9d3e:	47b8      	blx	r7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    9d40:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
    9d44:	f10a 0a01 	add.w	sl, sl, #1
    9d48:	f1ba 0f08 	cmp.w	sl, #8
    9d4c:	d1d4      	bne.n	9cf8 <grid_sys_get_hwcfg+0x64>
				gpio_set_pin_level(HWCFG_CLOCK, 0);
			}
							
		}
		
		grid_sys_hwfcg = hwcfg_value;
    9d4e:	f8c6 b000 	str.w	fp, [r6]
	}

	
	return grid_sys_hwfcg;

}
    9d52:	6830      	ldr	r0, [r6, #0]
    9d54:	b003      	add	sp, #12
    9d56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    9d5a:	bf00      	nop
    9d5c:	2000034c 	.word	0x2000034c
    9d60:	41008000 	.word	0x41008000
    9d64:	40002000 	.word	0x40002000
    9d68:	0000e17d 	.word	0x0000e17d
    9d6c:	40028000 	.word	0x40028000
    9d70:	00011f07 	.word	0x00011f07
    9d74:	00011ef9 	.word	0x00011ef9

00009d78 <grid_msg_calculate_checksum_of_packet_string>:
	grid_sys_ping(&GRID_PORT_S);
	grid_sys_ping(&GRID_PORT_W);
	
}

uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    9d78:	b510      	push	{r4, lr}
	
	uint8_t checksum = 0;
	for (uint32_t i=0; i<length-3; i++){
    9d7a:	2300      	movs	r3, #0
uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    9d7c:	4602      	mov	r2, r0
	for (uint32_t i=0; i<length-3; i++){
    9d7e:	3903      	subs	r1, #3
	uint8_t checksum = 0;
    9d80:	4618      	mov	r0, r3
	for (uint32_t i=0; i<length-3; i++){
    9d82:	4299      	cmp	r1, r3
    9d84:	d800      	bhi.n	9d88 <grid_msg_calculate_checksum_of_packet_string+0x10>
		checksum ^= str[i];
	}
	
	return checksum;
	
}
    9d86:	bd10      	pop	{r4, pc}
		checksum ^= str[i];
    9d88:	5cd4      	ldrb	r4, [r2, r3]
	for (uint32_t i=0; i<length-3; i++){
    9d8a:	3301      	adds	r3, #1
		checksum ^= str[i];
    9d8c:	4060      	eors	r0, r4
	for (uint32_t i=0; i<length-3; i++){
    9d8e:	e7f8      	b.n	9d82 <grid_msg_calculate_checksum_of_packet_string+0xa>

00009d90 <grid_msg_checksum_read>:
	return checksum;
	
}


uint8_t grid_msg_checksum_read(uint8_t* str, uint32_t length){
    9d90:	b507      	push	{r0, r1, r2, lr}
	uint8_t error_flag;
	return grid_sys_read_hex_string_value(&str[length-3], 2, &error_flag);
    9d92:	1ecb      	subs	r3, r1, #3
    9d94:	f10d 0207 	add.w	r2, sp, #7
    9d98:	2102      	movs	r1, #2
    9d9a:	4418      	add	r0, r3
    9d9c:	4b02      	ldr	r3, [pc, #8]	; (9da8 <grid_msg_checksum_read+0x18>)
    9d9e:	4798      	blx	r3
}
    9da0:	b2c0      	uxtb	r0, r0
    9da2:	b003      	add	sp, #12
    9da4:	f85d fb04 	ldr.w	pc, [sp], #4
    9da8:	00009c09 	.word	0x00009c09

00009dac <grid_msg_checksum_write>:
// 	sprintf(checksum_string, "%02x", checksum);
// 
// 	message[length-3] = checksum_string[0];
// 	message[length-2] = checksum_string[1];
	
	grid_sys_write_hex_string_value(&message[length-3], 2, checksum);
    9dac:	1ecb      	subs	r3, r1, #3
    9dae:	4418      	add	r0, r3
    9db0:	2102      	movs	r1, #2
    9db2:	4b01      	ldr	r3, [pc, #4]	; (9db8 <grid_msg_checksum_write+0xc>)
    9db4:	4718      	bx	r3
    9db6:	bf00      	nop
    9db8:	00009c31 	.word	0x00009c31

00009dbc <grid_msg_get_parameter>:
}


// MESSAGE PARAMETER FUNCTIONS

uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    9dbc:	b410      	push	{r4}
    9dbe:	460c      	mov	r4, r1
		
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    9dc0:	4420      	add	r0, r4
uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    9dc2:	4611      	mov	r1, r2
}
    9dc4:	f85d 4b04 	ldr.w	r4, [sp], #4
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    9dc8:	461a      	mov	r2, r3
    9dca:	4b01      	ldr	r3, [pc, #4]	; (9dd0 <grid_msg_get_parameter+0x14>)
    9dcc:	4718      	bx	r3
    9dce:	bf00      	nop
    9dd0:	00009c09 	.word	0x00009c09

00009dd4 <grid_msg_set_parameter>:

uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    9dd4:	b510      	push	{r4, lr}
    9dd6:	460c      	mov	r4, r1
	
	grid_sys_write_hex_string_value(&message[offset], length, value);
    9dd8:	4420      	add	r0, r4
uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    9dda:	4611      	mov	r1, r2
	grid_sys_write_hex_string_value(&message[offset], length, value);
    9ddc:	461a      	mov	r2, r3
    9dde:	4b01      	ldr	r3, [pc, #4]	; (9de4 <grid_msg_set_parameter+0x10>)
    9de0:	4798      	blx	r3
	
}
    9de2:	bd10      	pop	{r4, pc}
    9de4:	00009c31 	.word	0x00009c31

00009de8 <grid_msg_find_recent>:

uint8_t grid_msg_find_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
    //uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9de8:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9dec:	30ac      	adds	r0, #172	; 0xac
		
		if (model->recent_messages[i%GRID_SYS_RECENT_MESSAGES_LENGTH] == fingerprint){
    9dee:	f853 2b04 	ldr.w	r2, [r3], #4
    9df2:	428a      	cmp	r2, r1
    9df4:	d003      	beq.n	9dfe <grid_msg_find_recent+0x16>
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    9df6:	4283      	cmp	r3, r0
    9df8:	d1f9      	bne.n	9dee <grid_msg_find_recent+0x6>
			
		}
		
	}
	
	return 0;
    9dfa:	2000      	movs	r0, #0
    9dfc:	4770      	bx	lr
			return 1;
    9dfe:	2001      	movs	r0, #1
}
    9e00:	4770      	bx	lr

00009e02 <grid_msg_push_recent>:

void grid_msg_push_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
	model->recent_messages_index+=1;
    9e02:	f890 30ac 	ldrb.w	r3, [r0, #172]	; 0xac
    9e06:	3301      	adds	r3, #1
	model->recent_messages_index%=GRID_SYS_RECENT_MESSAGES_LENGTH;
    9e08:	f003 031f 	and.w	r3, r3, #31
    9e0c:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
	
	model->recent_messages[model->recent_messages_index] = fingerprint;
    9e10:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    9e14:	62c1      	str	r1, [r0, #44]	; 0x2c
	
}
    9e16:	4770      	bx	lr

00009e18 <grid_ui_model_init>:
	}
	
}


void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9e18:	b538      	push	{r3, r4, r5, lr}
	
	mod->status = GRID_UI_STATUS_INITIALIZED;
    9e1a:	2301      	movs	r3, #1
    9e1c:	7003      	strb	r3, [r0, #0]
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9e1e:	4605      	mov	r5, r0
	
	mod->bank_list_length = bank_list_length;	
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9e20:	4b09      	ldr	r3, [pc, #36]	; (9e48 <grid_ui_model_init+0x30>)
	mod->bank_list_length = bank_list_length;	
    9e22:	7041      	strb	r1, [r0, #1]
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9e24:	0108      	lsls	r0, r1, #4
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    9e26:	460c      	mov	r4, r1
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9e28:	4798      	blx	r3
	
	for(uint8_t i=0; i<bank_list_length; i++){
    9e2a:	2300      	movs	r3, #0
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    9e2c:	6068      	str	r0, [r5, #4]
		
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9e2e:	461a      	mov	r2, r3
	for(uint8_t i=0; i<bank_list_length; i++){
    9e30:	b2d9      	uxtb	r1, r3
    9e32:	428c      	cmp	r4, r1
    9e34:	f100 0010 	add.w	r0, r0, #16
    9e38:	d800      	bhi.n	9e3c <grid_ui_model_init+0x24>
		mod->bank_list[i].element_list_length = 0;
		
	}
	
}
    9e3a:	bd38      	pop	{r3, r4, r5, pc}
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    9e3c:	f800 2c10 	strb.w	r2, [r0, #-16]
		mod->bank_list[i].element_list_length = 0;
    9e40:	f800 2c07 	strb.w	r2, [r0, #-7]
	for(uint8_t i=0; i<bank_list_length; i++){
    9e44:	3301      	adds	r3, #1
    9e46:	e7f3      	b.n	9e30 <grid_ui_model_init+0x18>
    9e48:	00014799 	.word	0x00014799

00009e4c <grid_ui_bank_init>:

void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9e4c:	b538      	push	{r3, r4, r5, lr}
	
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9e4e:	6843      	ldr	r3, [r0, #4]
    9e50:	eb03 1501 	add.w	r5, r3, r1, lsl #4
void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    9e54:	4614      	mov	r4, r2
	struct grid_ui_bank* bank = &parent->bank_list[index];
    9e56:	010a      	lsls	r2, r1, #4
	bank->parent = parent;
    9e58:	6068      	str	r0, [r5, #4]
	bank->index = index;
    9e5a:	7229      	strb	r1, [r5, #8]
	
	
	bank->status = GRID_UI_STATUS_INITIALIZED;
	
	bank->element_list_length = element_list_length;
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9e5c:	2064      	movs	r0, #100	; 0x64
	bank->status = GRID_UI_STATUS_INITIALIZED;
    9e5e:	2101      	movs	r1, #1
    9e60:	5499      	strb	r1, [r3, r2]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9e62:	4360      	muls	r0, r4
    9e64:	4b08      	ldr	r3, [pc, #32]	; (9e88 <grid_ui_bank_init+0x3c>)
	bank->element_list_length = element_list_length;
    9e66:	726c      	strb	r4, [r5, #9]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9e68:	4798      	blx	r3
	
	for(uint8_t i=0; i<element_list_length; i++){
    9e6a:	2300      	movs	r3, #0
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    9e6c:	60e8      	str	r0, [r5, #12]
		
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9e6e:	461a      	mov	r2, r3
	for(uint8_t i=0; i<element_list_length; i++){
    9e70:	b2d9      	uxtb	r1, r3
    9e72:	428c      	cmp	r4, r1
    9e74:	f100 0064 	add.w	r0, r0, #100	; 0x64
    9e78:	d800      	bhi.n	9e7c <grid_ui_bank_init+0x30>
		bank->element_list[i].event_list_length = 0;
		
	}
	
}
    9e7a:	bd38      	pop	{r3, r4, r5, pc}
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    9e7c:	f800 2c64 	strb.w	r2, [r0, #-100]
		bank->element_list[i].event_list_length = 0;
    9e80:	f800 2c08 	strb.w	r2, [r0, #-8]
	for(uint8_t i=0; i<element_list_length; i++){
    9e84:	3301      	adds	r3, #1
    9e86:	e7f3      	b.n	9e70 <grid_ui_bank_init+0x24>
    9e88:	00014799 	.word	0x00014799

00009e8c <grid_ui_nvm_store_all_configuration>:
	
}



void grid_ui_nvm_store_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9e8c:	460b      	mov	r3, r1
	
    grid_nvm_ui_bulk_store_init(nvm, ui);
    9e8e:	4601      	mov	r1, r0
    9e90:	4618      	mov	r0, r3
    9e92:	4b01      	ldr	r3, [pc, #4]	; (9e98 <grid_ui_nvm_store_all_configuration+0xc>)
    9e94:	4718      	bx	r3
    9e96:	bf00      	nop
    9e98:	00008cdd 	.word	0x00008cdd

00009e9c <grid_ui_nvm_load_all_configuration>:

}

void grid_ui_nvm_load_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9e9c:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_read_init(nvm, ui);
    9e9e:	4601      	mov	r1, r0
    9ea0:	4618      	mov	r0, r3
    9ea2:	4b01      	ldr	r3, [pc, #4]	; (9ea8 <grid_ui_nvm_load_all_configuration+0xc>)
    9ea4:	4718      	bx	r3
    9ea6:	bf00      	nop
    9ea8:	00008bc9 	.word	0x00008bc9

00009eac <grid_ui_nvm_clear_all_configuration>:

		
	
}

void grid_ui_nvm_clear_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    9eac:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_clear_init(nvm, ui);
    9eae:	4601      	mov	r1, r0
    9eb0:	4618      	mov	r0, r3
    9eb2:	4b01      	ldr	r3, [pc, #4]	; (9eb8 <grid_ui_nvm_clear_all_configuration+0xc>)
    9eb4:	4718      	bx	r3
    9eb6:	bf00      	nop
    9eb8:	00008ea1 	.word	0x00008ea1

00009ebc <grid_ui_recall_event_configuration>:

}


uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9ebc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9ec0:	4698      	mov	r8, r3
	
	struct grid_ui_element* ele = NULL;
	struct grid_ui_event* eve = NULL;
	uint8_t event_index = 255;
	
	if (bank < ui->bank_list_length){
    9ec2:	7843      	ldrb	r3, [r0, #1]
    9ec4:	428b      	cmp	r3, r1
uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    9ec6:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
    9eca:	460e      	mov	r6, r1
    9ecc:	4615      	mov	r5, r2
	if (bank < ui->bank_list_length){
    9ece:	f240 8082 	bls.w	9fd6 <grid_ui_recall_event_configuration+0x11a>
		
		if (element < ui->bank_list[bank].element_list_length){
    9ed2:	6843      	ldr	r3, [r0, #4]
    9ed4:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    9ed8:	7a5a      	ldrb	r2, [r3, #9]
    9eda:	42aa      	cmp	r2, r5
    9edc:	d97b      	bls.n	9fd6 <grid_ui_recall_event_configuration+0x11a>
			
			ele = &ui->bank_list[bank].element_list[element];
    9ede:	68da      	ldr	r2, [r3, #12]
    9ee0:	2364      	movs	r3, #100	; 0x64
    9ee2:	fb05 2303 	mla	r3, r5, r3, r2
			
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9ee6:	2200      	movs	r2, #0
    9ee8:	f893 c05c 	ldrb.w	ip, [r3, #92]	; 0x5c
	uint8_t event_index = 255;
    9eec:	20ff      	movs	r0, #255	; 0xff
	struct grid_ui_event* eve = NULL;
    9eee:	4614      	mov	r4, r2
				if (ele->event_list[i].type == event_type){
    9ef0:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    9ef4:	b2d7      	uxtb	r7, r2
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9ef6:	45bc      	cmp	ip, r7
    9ef8:	d862      	bhi.n	9fc0 <grid_ui_recall_event_configuration+0x104>
		
		
	}
	
	
	if (event_index != 255){ // OK
    9efa:	28ff      	cmp	r0, #255	; 0xff
    9efc:	d06b      	beq.n	9fd6 <grid_ui_recall_event_configuration+0x11a>
		
		struct grid_msg message;

		grid_msg_init(&message);
    9efe:	4b5b      	ldr	r3, [pc, #364]	; (a06c <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9f00:	4d5b      	ldr	r5, [pc, #364]	; (a070 <grid_ui_recall_event_configuration+0x1b4>)
		uint32_t offset = 0;



		// BANK ENABLED
		offset = grid_msg_body_get_length(&message);
    9f02:	f8df a190 	ldr.w	sl, [pc, #400]	; a094 <grid_ui_recall_event_configuration+0x1d8>

		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9f06:	f8df 9190 	ldr.w	r9, [pc, #400]	; a098 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9f0a:	f8df 8190 	ldr.w	r8, [pc, #400]	; a09c <grid_ui_recall_event_configuration+0x1e0>

		grid_msg_body_append_text(&message, payload, payload_length);
    9f0e:	4f59      	ldr	r7, [pc, #356]	; (a074 <grid_ui_recall_event_configuration+0x1b8>)

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9f10:	4e59      	ldr	r6, [pc, #356]	; (a078 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9f12:	a867      	add	r0, sp, #412	; 0x19c
    9f14:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9f16:	227f      	movs	r2, #127	; 0x7f
    9f18:	4611      	mov	r1, r2
    9f1a:	2300      	movs	r3, #0
    9f1c:	a867      	add	r0, sp, #412	; 0x19c
    9f1e:	47a8      	blx	r5
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9f20:	2100      	movs	r1, #0
    9f22:	4b56      	ldr	r3, [pc, #344]	; (a07c <grid_ui_recall_event_configuration+0x1c0>)
    9f24:	9103      	str	r1, [sp, #12]
    9f26:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9f2a:	a804      	add	r0, sp, #16
    9f2c:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    9f2e:	a867      	add	r0, sp, #412	; 0x19c
    9f30:	47d0      	blx	sl
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9f32:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    9f34:	4605      	mov	r5, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9f36:	4952      	ldr	r1, [pc, #328]	; (a080 <grid_ui_recall_event_configuration+0x1c4>)
    9f38:	2202      	movs	r2, #2
    9f3a:	a803      	add	r0, sp, #12
    9f3c:	47c8      	blx	r9
		payload_length = strlen(payload);
    9f3e:	a803      	add	r0, sp, #12
    9f40:	47c0      	blx	r8
		grid_msg_body_append_text(&message, payload, payload_length);
    9f42:	a903      	add	r1, sp, #12
    9f44:	b2c2      	uxtb	r2, r0
    9f46:	a867      	add	r0, sp, #412	; 0x19c
    9f48:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    9f4a:	230d      	movs	r3, #13
    9f4c:	9300      	str	r3, [sp, #0]
    9f4e:	2204      	movs	r2, #4
    9f50:	2301      	movs	r3, #1
    9f52:	4629      	mov	r1, r5
    9f54:	a867      	add	r0, sp, #412	; 0x19c
    9f56:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    9f58:	6863      	ldr	r3, [r4, #4]
    9f5a:	685b      	ldr	r3, [r3, #4]
    9f5c:	7a1b      	ldrb	r3, [r3, #8]
    9f5e:	9300      	str	r3, [sp, #0]
    9f60:	2205      	movs	r2, #5
    9f62:	2302      	movs	r3, #2
    9f64:	4629      	mov	r1, r5
    9f66:	a867      	add	r0, sp, #412	; 0x19c
    9f68:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    9f6a:	6863      	ldr	r3, [r4, #4]
    9f6c:	7a1b      	ldrb	r3, [r3, #8]
    9f6e:	9300      	str	r3, [sp, #0]
    9f70:	2207      	movs	r2, #7
    9f72:	2302      	movs	r3, #2
    9f74:	4629      	mov	r1, r5
    9f76:	a867      	add	r0, sp, #412	; 0x19c
    9f78:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    9f7a:	7aa3      	ldrb	r3, [r4, #10]
    9f7c:	9300      	str	r3, [sp, #0]
    9f7e:	2209      	movs	r2, #9
    9f80:	2302      	movs	r3, #2
    9f82:	4629      	mov	r1, r5
    9f84:	a867      	add	r0, sp, #412	; 0x19c
    9f86:	47b0      	blx	r6

		offset = grid_msg_body_get_length(&message);
    9f88:	a867      	add	r0, sp, #412	; 0x19c
    9f8a:	47d0      	blx	sl
		grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    9f8c:	4b3d      	ldr	r3, [pc, #244]	; (a084 <grid_ui_recall_event_configuration+0x1c8>)
    9f8e:	6b22      	ldr	r2, [r4, #48]	; 0x30
    9f90:	f104 0134 	add.w	r1, r4, #52	; 0x34
    9f94:	a867      	add	r0, sp, #412	; 0x19c
    9f96:	4798      	blx	r3





		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    9f98:	493b      	ldr	r1, [pc, #236]	; (a088 <grid_ui_recall_event_configuration+0x1cc>)
    9f9a:	2203      	movs	r2, #3
    9f9c:	a803      	add	r0, sp, #12
    9f9e:	47c8      	blx	r9
		payload_length = strlen(payload);
    9fa0:	a803      	add	r0, sp, #12
    9fa2:	47c0      	blx	r8

		grid_msg_body_append_text(&message, payload, payload_length);
    9fa4:	a903      	add	r1, sp, #12
    9fa6:	b2c2      	uxtb	r2, r0
    9fa8:	a867      	add	r0, sp, #412	; 0x19c
    9faa:	47b8      	blx	r7
		payload_length = strlen(payload);

		grid_msg_body_append_text(&message, payload, payload_length);


		grid_msg_packet_close(&message);
    9fac:	4b37      	ldr	r3, [pc, #220]	; (a08c <grid_ui_recall_event_configuration+0x1d0>)
    9fae:	a867      	add	r0, sp, #412	; 0x19c
    9fb0:	4798      	blx	r3
		grid_msg_packet_send_everywhere(&message);		
    9fb2:	4b37      	ldr	r3, [pc, #220]	; (a090 <grid_ui_recall_event_configuration+0x1d4>)
    9fb4:	a867      	add	r0, sp, #412	; 0x19c
    9fb6:	4798      	blx	r3
		
		
	}

	
}
    9fb8:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    9fbc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (ele->event_list[i].type == event_type){
    9fc0:	6e19      	ldr	r1, [r3, #96]	; 0x60
    9fc2:	fb0e 1102 	mla	r1, lr, r2, r1
    9fc6:	3201      	adds	r2, #1
    9fc8:	f891 900a 	ldrb.w	r9, [r1, #10]
    9fcc:	45c1      	cmp	r9, r8
    9fce:	bf04      	itt	eq
    9fd0:	4638      	moveq	r0, r7
    9fd2:	460c      	moveq	r4, r1
			for(uint8_t i=0; i<ele->event_list_length; i++){
    9fd4:	e78e      	b.n	9ef4 <grid_ui_recall_event_configuration+0x38>
		grid_msg_init(&message);
    9fd6:	a867      	add	r0, sp, #412	; 0x19c
    9fd8:	4b24      	ldr	r3, [pc, #144]	; (a06c <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9fda:	4c25      	ldr	r4, [pc, #148]	; (a070 <grid_ui_recall_event_configuration+0x1b4>)
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    9fdc:	f8df b0b8 	ldr.w	fp, [pc, #184]	; a098 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    9fe0:	f8df a0b8 	ldr.w	sl, [pc, #184]	; a09c <grid_ui_recall_event_configuration+0x1e0>
		grid_msg_body_append_text(&message, payload, payload_length);
    9fe4:	f8df 908c 	ldr.w	r9, [pc, #140]	; a074 <grid_ui_recall_event_configuration+0x1b8>
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9fe8:	4f23      	ldr	r7, [pc, #140]	; (a078 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    9fea:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9fec:	227f      	movs	r2, #127	; 0x7f
    9fee:	4611      	mov	r1, r2
    9ff0:	a867      	add	r0, sp, #412	; 0x19c
    9ff2:	2300      	movs	r3, #0
    9ff4:	47a0      	blx	r4
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9ff6:	2100      	movs	r1, #0
    9ff8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9ffc:	4b1f      	ldr	r3, [pc, #124]	; (a07c <grid_ui_recall_event_configuration+0x1c0>)
    9ffe:	9103      	str	r1, [sp, #12]
    a000:	a804      	add	r0, sp, #16
    a002:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    a004:	4b23      	ldr	r3, [pc, #140]	; (a094 <grid_ui_recall_event_configuration+0x1d8>)
    a006:	a867      	add	r0, sp, #412	; 0x19c
    a008:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a00a:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    a00c:	4604      	mov	r4, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a00e:	491c      	ldr	r1, [pc, #112]	; (a080 <grid_ui_recall_event_configuration+0x1c4>)
    a010:	2202      	movs	r2, #2
    a012:	a803      	add	r0, sp, #12
    a014:	47d8      	blx	fp
		payload_length = strlen(payload);
    a016:	a803      	add	r0, sp, #12
    a018:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    a01a:	a903      	add	r1, sp, #12
    a01c:	b2c2      	uxtb	r2, r0
    a01e:	a867      	add	r0, sp, #412	; 0x19c
    a020:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    a022:	230b      	movs	r3, #11
    a024:	9300      	str	r3, [sp, #0]
    a026:	4621      	mov	r1, r4
    a028:	a867      	add	r0, sp, #412	; 0x19c
    a02a:	2301      	movs	r3, #1
    a02c:	2204      	movs	r2, #4
    a02e:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, bank);
    a030:	4621      	mov	r1, r4
    a032:	a867      	add	r0, sp, #412	; 0x19c
    a034:	9600      	str	r6, [sp, #0]
    a036:	2302      	movs	r3, #2
    a038:	2205      	movs	r2, #5
    a03a:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, element);
    a03c:	4621      	mov	r1, r4
    a03e:	a867      	add	r0, sp, #412	; 0x19c
    a040:	9500      	str	r5, [sp, #0]
    a042:	2302      	movs	r3, #2
    a044:	2207      	movs	r2, #7
    a046:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, event_type);
    a048:	2302      	movs	r3, #2
    a04a:	4621      	mov	r1, r4
    a04c:	a867      	add	r0, sp, #412	; 0x19c
    a04e:	f8cd 8000 	str.w	r8, [sp]
    a052:	2209      	movs	r2, #9
    a054:	47b8      	blx	r7
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    a056:	490c      	ldr	r1, [pc, #48]	; (a088 <grid_ui_recall_event_configuration+0x1cc>)
    a058:	2203      	movs	r2, #3
    a05a:	a803      	add	r0, sp, #12
    a05c:	47d8      	blx	fp
		payload_length = strlen(payload);
    a05e:	a803      	add	r0, sp, #12
    a060:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    a062:	a903      	add	r1, sp, #12
    a064:	b2c2      	uxtb	r2, r0
    a066:	a867      	add	r0, sp, #412	; 0x19c
    a068:	47c8      	blx	r9
    a06a:	e79f      	b.n	9fac <grid_ui_recall_event_configuration+0xf0>
    a06c:	0000896d 	.word	0x0000896d
    a070:	000089a1 	.word	0x000089a1
    a074:	000088dd 	.word	0x000088dd
    a078:	00008951 	.word	0x00008951
    a07c:	000147c5 	.word	0x000147c5
    a080:	00016359 	.word	0x00016359
    a084:	000088fd 	.word	0x000088fd
    a088:	00015fcb 	.word	0x00015fcb
    a08c:	00008a99 	.word	0x00008a99
    a090:	00008b6d 	.word	0x00008b6d
    a094:	000088d7 	.word	0x000088d7
    a098:	00014c8d 	.word	0x00014c8d
    a09c:	00014d0b 	.word	0x00014d0b

0000a0a0 <grid_ui_nvm_store_event_configuration>:



uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a0a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a0a4:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
	

	struct grid_msg message;

	grid_msg_init(&message);
    a0a8:	4b52      	ldr	r3, [pc, #328]	; (a1f4 <grid_ui_nvm_store_event_configuration+0x154>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a0aa:	4e53      	ldr	r6, [pc, #332]	; (a1f8 <grid_ui_nvm_store_event_configuration+0x158>)
	uint32_t offset = 0;



	// BANK ENABLED
	offset = grid_msg_body_get_length(&message);
    a0ac:	f8df b178 	ldr.w	fp, [pc, #376]	; a228 <grid_ui_nvm_store_event_configuration+0x188>

	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a0b0:	f8df a178 	ldr.w	sl, [pc, #376]	; a22c <grid_ui_nvm_store_event_configuration+0x18c>
	payload_length = strlen(payload);

	grid_msg_body_append_text(&message, payload, payload_length);
    a0b4:	f8df 9178 	ldr.w	r9, [pc, #376]	; a230 <grid_ui_nvm_store_event_configuration+0x190>

	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    a0b8:	f8df 8178 	ldr.w	r8, [pc, #376]	; a234 <grid_ui_nvm_store_event_configuration+0x194>
	grid_msg_init(&message);
    a0bc:	a867      	add	r0, sp, #412	; 0x19c
uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a0be:	4614      	mov	r4, r2
    a0c0:	460d      	mov	r5, r1
	grid_msg_init(&message);
    a0c2:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a0c4:	22ff      	movs	r2, #255	; 0xff
    a0c6:	4611      	mov	r1, r2
    a0c8:	2300      	movs	r3, #0
    a0ca:	a867      	add	r0, sp, #412	; 0x19c
    a0cc:	47b0      	blx	r6
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    a0ce:	2600      	movs	r6, #0
    a0d0:	4b4a      	ldr	r3, [pc, #296]	; (a1fc <grid_ui_nvm_store_event_configuration+0x15c>)
    a0d2:	9603      	str	r6, [sp, #12]
    a0d4:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a0d8:	4631      	mov	r1, r6
    a0da:	a804      	add	r0, sp, #16
    a0dc:	4798      	blx	r3
	offset = grid_msg_body_get_length(&message);
    a0de:	a867      	add	r0, sp, #412	; 0x19c
    a0e0:	47d8      	blx	fp
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a0e2:	4947      	ldr	r1, [pc, #284]	; (a200 <grid_ui_nvm_store_event_configuration+0x160>)
	offset = grid_msg_body_get_length(&message);
    a0e4:	4607      	mov	r7, r0
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a0e6:	2202      	movs	r2, #2
    a0e8:	2380      	movs	r3, #128	; 0x80
    a0ea:	a803      	add	r0, sp, #12
    a0ec:	47d0      	blx	sl
	payload_length = strlen(payload);
    a0ee:	4b45      	ldr	r3, [pc, #276]	; (a204 <grid_ui_nvm_store_event_configuration+0x164>)
    a0f0:	a803      	add	r0, sp, #12
    a0f2:	4798      	blx	r3
	grid_msg_body_append_text(&message, payload, payload_length);
    a0f4:	a903      	add	r1, sp, #12
    a0f6:	b2c2      	uxtb	r2, r0
    a0f8:	a867      	add	r0, sp, #412	; 0x19c
    a0fa:	47c8      	blx	r9
	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    a0fc:	230e      	movs	r3, #14
    a0fe:	4639      	mov	r1, r7
    a100:	9300      	str	r3, [sp, #0]
    a102:	2204      	movs	r2, #4
    a104:	2301      	movs	r3, #1
    a106:	a867      	add	r0, sp, #412	; 0x19c
    a108:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    a10a:	6863      	ldr	r3, [r4, #4]
    a10c:	685b      	ldr	r3, [r3, #4]
    a10e:	7a1b      	ldrb	r3, [r3, #8]
    a110:	9300      	str	r3, [sp, #0]
    a112:	4639      	mov	r1, r7
    a114:	2302      	movs	r3, #2
    a116:	2205      	movs	r2, #5
    a118:	a867      	add	r0, sp, #412	; 0x19c
    a11a:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    a11c:	6863      	ldr	r3, [r4, #4]
    a11e:	7a1b      	ldrb	r3, [r3, #8]
    a120:	9300      	str	r3, [sp, #0]
    a122:	4639      	mov	r1, r7
    a124:	2302      	movs	r3, #2
    a126:	2207      	movs	r2, #7
    a128:	a867      	add	r0, sp, #412	; 0x19c
    a12a:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    a12c:	7aa3      	ldrb	r3, [r4, #10]
    a12e:	9300      	str	r3, [sp, #0]
    a130:	4639      	mov	r1, r7
    a132:	2302      	movs	r3, #2
    a134:	2209      	movs	r2, #9
    a136:	a867      	add	r0, sp, #412	; 0x19c
    a138:	47c0      	blx	r8

	offset = grid_msg_body_get_length(&message);
    a13a:	a867      	add	r0, sp, #412	; 0x19c
    a13c:	47d8      	blx	fp
	grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    a13e:	4b32      	ldr	r3, [pc, #200]	; (a208 <grid_ui_nvm_store_event_configuration+0x168>)
    a140:	6b22      	ldr	r2, [r4, #48]	; 0x30
    a142:	f104 0134 	add.w	r1, r4, #52	; 0x34
    a146:	a867      	add	r0, sp, #412	; 0x19c
    a148:	4798      	blx	r3





	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    a14a:	4930      	ldr	r1, [pc, #192]	; (a20c <grid_ui_nvm_store_event_configuration+0x16c>)
    a14c:	2203      	movs	r2, #3
    a14e:	a803      	add	r0, sp, #12
    a150:	47d0      	blx	sl
	payload_length = strlen(payload);
    a152:	4b2c      	ldr	r3, [pc, #176]	; (a204 <grid_ui_nvm_store_event_configuration+0x164>)
    a154:	a803      	add	r0, sp, #12
    a156:	4798      	blx	r3

	grid_msg_body_append_text(&message, payload, payload_length);
    a158:	a903      	add	r1, sp, #12
    a15a:	b2c2      	uxtb	r2, r0
    a15c:	a867      	add	r0, sp, #412	; 0x19c
    a15e:	47c8      	blx	r9


	grid_msg_packet_close(&message);
    a160:	4b2b      	ldr	r3, [pc, #172]	; (a210 <grid_ui_nvm_store_event_configuration+0x170>)
    a162:	a867      	add	r0, sp, #412	; 0x19c
    a164:	4798      	blx	r3

	grid_nvm_clear_write_buffer(nvm);
    a166:	4b2b      	ldr	r3, [pc, #172]	; (a214 <grid_ui_nvm_store_event_configuration+0x174>)
    a168:	4628      	mov	r0, r5
    a16a:	4798      	blx	r3

	uint32_t message_length = grid_msg_packet_get_length(&message);
    a16c:	4b2a      	ldr	r3, [pc, #168]	; (a218 <grid_ui_nvm_store_event_configuration+0x178>)
    a16e:	a867      	add	r0, sp, #412	; 0x19c
    a170:	4798      	blx	r3

	if (message_length){
    a172:	4607      	mov	r7, r0
    a174:	b970      	cbnz	r0, a194 <grid_ui_nvm_store_event_configuration+0xf4>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
		}

	}

	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    a176:	4621      	mov	r1, r4
    a178:	4b28      	ldr	r3, [pc, #160]	; (a21c <grid_ui_nvm_store_event_configuration+0x17c>)
    a17a:	4628      	mov	r0, r5
    a17c:	4798      	blx	r3
	nvm->write_target_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;
    a17e:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    a182:	0241      	lsls	r1, r0, #9
    a184:	f8c5 1420 	str.w	r1, [r5, #1056]	; 0x420
	int status = 0;
	
	
	uint8_t debugtext[200] = {0};

	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    a188:	f894 60b7 	ldrb.w	r6, [r4, #183]	; 0xb7
    a18c:	2e01      	cmp	r6, #1
    a18e:	d010      	beq.n	a1b2 <grid_ui_nvm_store_event_configuration+0x112>
	int status = 0;
    a190:	2000      	movs	r0, #0
    a192:	e019      	b.n	a1c8 <grid_ui_nvm_store_event_configuration+0x128>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    a194:	f8df 90a0 	ldr.w	r9, [pc, #160]	; a238 <grid_ui_nvm_store_event_configuration+0x198>
		nvm->write_buffer_length = message_length;
    a198:	f8c5 0418 	str.w	r0, [r5, #1048]	; 0x418
		for(uint32_t i = 0; i<message_length; i++){
    a19c:	f505 7806 	add.w	r8, r5, #536	; 0x218
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    a1a0:	4631      	mov	r1, r6
    a1a2:	a867      	add	r0, sp, #412	; 0x19c
    a1a4:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    a1a6:	3601      	adds	r6, #1
    a1a8:	42b7      	cmp	r7, r6
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    a1aa:	f808 0b01 	strb.w	r0, [r8], #1
		for(uint32_t i = 0; i<message_length; i++){
    a1ae:	d1f7      	bne.n	a1a0 <grid_ui_nvm_store_event_configuration+0x100>
    a1b0:	e7e1      	b.n	a176 <grid_ui_nvm_store_event_configuration+0xd6>
	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    a1b2:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    a1b6:	2b00      	cmp	r3, #0
    a1b8:	d1ea      	bne.n	a190 <grid_ui_nvm_store_event_configuration+0xf0>
		
		//sprintf(debugtext, "Cfg: Default B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);
		flash_erase(nvm->flash, nvm->write_target_address, 1);
    a1ba:	6828      	ldr	r0, [r5, #0]
    a1bc:	4b18      	ldr	r3, [pc, #96]	; (a220 <grid_ui_nvm_store_event_configuration+0x180>)
    a1be:	4632      	mov	r2, r6
    a1c0:	4798      	blx	r3
		eve->cfg_flashempty_flag = 1;
    a1c2:	f884 60b8 	strb.w	r6, [r4, #184]	; 0xb8
		status = 1;
    a1c6:	4630      	mov	r0, r6
	}
	
	
	if (eve->cfg_default_flag == 0 && eve->cfg_changed_flag == 1){
    a1c8:	f8b4 60b6 	ldrh.w	r6, [r4, #182]	; 0xb6
    a1cc:	2e01      	cmp	r6, #1
    a1ce:	d109      	bne.n	a1e4 <grid_ui_nvm_store_event_configuration+0x144>
		
		//sprintf(debugtext, "Cfg: Store B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);		
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, GRID_NVM_PAGE_SIZE);
    a1d0:	f8d5 1420 	ldr.w	r1, [r5, #1056]	; 0x420
    a1d4:	6828      	ldr	r0, [r5, #0]
    a1d6:	f505 7206 	add.w	r2, r5, #536	; 0x218
    a1da:	f44f 7300 	mov.w	r3, #512	; 0x200
    a1de:	4d11      	ldr	r5, [pc, #68]	; (a224 <grid_ui_nvm_store_event_configuration+0x184>)
    a1e0:	47a8      	blx	r5
		status = 1;
    a1e2:	4630      	mov	r0, r6
	}


	//grid_debug_print_text(debugtext);

	eve->cfg_changed_flag = 0;
    a1e4:	2300      	movs	r3, #0
    a1e6:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	
	return status;
	
}
    a1ea:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    a1ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a1f2:	bf00      	nop
    a1f4:	0000896d 	.word	0x0000896d
    a1f8:	000089a1 	.word	0x000089a1
    a1fc:	000147c5 	.word	0x000147c5
    a200:	00016359 	.word	0x00016359
    a204:	00014d0b 	.word	0x00014d0b
    a208:	000088fd 	.word	0x000088fd
    a20c:	00015fcb 	.word	0x00015fcb
    a210:	00008a99 	.word	0x00008a99
    a214:	00009079 	.word	0x00009079
    a218:	000088c9 	.word	0x000088c9
    a21c:	000090e5 	.word	0x000090e5
    a220:	0000f251 	.word	0x0000f251
    a224:	0000f1d1 	.word	0x0000f1d1
    a228:	000088d7 	.word	0x000088d7
    a22c:	00014c8d 	.word	0x00014c8d
    a230:	000088dd 	.word	0x000088dd
    a234:	00008951 	.word	0x00008951
    a238:	00008a63 	.word	0x00008a63

0000a23c <grid_ui_nvm_load_event_configuration>:



uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a23c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
		
	grid_nvm_clear_read_buffer(nvm);
    a23e:	4b19      	ldr	r3, [pc, #100]	; (a2a4 <grid_ui_nvm_load_event_configuration+0x68>)
uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a240:	9201      	str	r2, [sp, #4]
    a242:	460c      	mov	r4, r1
	grid_nvm_clear_read_buffer(nvm);
    a244:	4608      	mov	r0, r1
    a246:	4798      	blx	r3
	
	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);	
    a248:	9901      	ldr	r1, [sp, #4]
    a24a:	4b17      	ldr	r3, [pc, #92]	; (a2a8 <grid_ui_nvm_load_event_configuration+0x6c>)
    a24c:	4620      	mov	r0, r4
    a24e:	4798      	blx	r3
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    a250:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    a254:	0241      	lsls	r1, r0, #9
	

	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    a256:	f104 0609 	add.w	r6, r4, #9
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    a25a:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    a25e:	6820      	ldr	r0, [r4, #0]
    a260:	4c12      	ldr	r4, [pc, #72]	; (a2ac <grid_ui_nvm_load_event_configuration+0x70>)
    a262:	f44f 7300 	mov.w	r3, #512	; 0x200
    a266:	4632      	mov	r2, r6
    a268:	47a0      	blx	r4
    a26a:	2300      	movs	r3, #0
			}
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a26c:	4c10      	ldr	r4, [pc, #64]	; (a2b0 <grid_ui_nvm_load_event_configuration+0x74>)
	uint8_t cfgfound = 0;
    a26e:	4618      	mov	r0, r3
	uint8_t copydone = 0;
    a270:	4619      	mov	r1, r3
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a272:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    a276:	1c5a      	adds	r2, r3, #1
    a278:	b971      	cbnz	r1, a298 <grid_ui_nvm_load_event_configuration+0x5c>
			if (nvm->read_buffer[i] == '\n'){ // END OF PACKET, copy newline character
    a27a:	5cf5      	ldrb	r5, [r6, r3]
    a27c:	2d0a      	cmp	r5, #10
    a27e:	d106      	bne.n	a28e <grid_ui_nvm_load_event_configuration+0x52>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a280:	4423      	add	r3, r4
				cfgfound=2;
    a282:	2002      	movs	r0, #2
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a284:	55dd      	strb	r5, [r3, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    a286:	6222      	str	r2, [r4, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    a288:	62a1      	str	r1, [r4, #40]	; 0x28
				copydone = 1;
    a28a:	2101      	movs	r1, #1
    a28c:	e004      	b.n	a298 <grid_ui_nvm_load_event_configuration+0x5c>
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    a28e:	2dff      	cmp	r5, #255	; 0xff
    a290:	d0fb      	beq.n	a28a <grid_ui_nvm_load_event_configuration+0x4e>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a292:	4423      	add	r3, r4
				
				cfgfound=1;
    a294:	2001      	movs	r0, #1
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a296:	55dd      	strb	r5, [r3, r7]
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    a298:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    a29c:	4613      	mov	r3, r2
    a29e:	d1ea      	bne.n	a276 <grid_ui_nvm_load_event_configuration+0x3a>
	}
	
	return cfgfound;
	
	
}
    a2a0:	b003      	add	sp, #12
    a2a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a2a4:	00009059 	.word	0x00009059
    a2a8:	000090e5 	.word	0x000090e5
    a2ac:	0000f165 	.word	0x0000f165
    a2b0:	2000c0b0 	.word	0x2000c0b0

0000a2b4 <grid_ui_nvm_clear_event_configuration>:
uint8_t grid_ui_nvm_clear_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a2b4:	b510      	push	{r4, lr}
    a2b6:	460c      	mov	r4, r1
		
		uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    a2b8:	4b06      	ldr	r3, [pc, #24]	; (a2d4 <grid_ui_nvm_clear_event_configuration+0x20>)
    a2ba:	4611      	mov	r1, r2
    a2bc:	4620      	mov	r0, r4
    a2be:	4798      	blx	r3
		
		

		flash_erase(nvm->flash, GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset, 1);
    a2c0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    a2c4:	0241      	lsls	r1, r0, #9
    a2c6:	4b04      	ldr	r3, [pc, #16]	; (a2d8 <grid_ui_nvm_clear_event_configuration+0x24>)
    a2c8:	6820      	ldr	r0, [r4, #0]
    a2ca:	2201      	movs	r2, #1
    a2cc:	4798      	blx	r3

		
		
		return 1;
		
}
    a2ce:	2001      	movs	r0, #1
    a2d0:	bd10      	pop	{r4, pc}
    a2d2:	bf00      	nop
    a2d4:	000090e5 	.word	0x000090e5
    a2d8:	0000f251 	.word	0x0000f251

0000a2dc <grid_ui_event_register_actionstring>:
	ele->event_list[event_index].cfg_default_flag = 1;	
	
}


void grid_ui_event_register_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* action_string, uint32_t action_string_length){
    a2dc:	b5f0      	push	{r4, r5, r6, r7, lr}
		
	uint8_t event_index = 255;
	
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a2de:	f890 c05c 	ldrb.w	ip, [r0, #92]	; 0x5c
    a2e2:	2500      	movs	r5, #0
	uint8_t event_index = 255;
    a2e4:	24ff      	movs	r4, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a2e6:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    a2ea:	b2ef      	uxtb	r7, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a2ec:	45bc      	cmp	ip, r7
    a2ee:	d819      	bhi.n	a324 <grid_ui_event_register_actionstring+0x48>
			event_index = i;
		}
	}
	
	if (event_index == 255){
    a2f0:	2cff      	cmp	r4, #255	; 0xff
    a2f2:	d016      	beq.n	a322 <grid_ui_event_register_actionstring+0x46>
	
	
	
	// Clear Action String
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
		ele->event_list[event_index].action_string[i] = 0;
    a2f4:	21bc      	movs	r1, #188	; 0xbc
    a2f6:	fb14 f401 	smulbb	r4, r4, r1
    a2fa:	6e01      	ldr	r1, [r0, #96]	; 0x60
    a2fc:	4421      	add	r1, r4
    a2fe:	f101 0434 	add.w	r4, r1, #52	; 0x34
    a302:	f101 06b6 	add.w	r6, r1, #182	; 0xb6
    a306:	4620      	mov	r0, r4
    a308:	2500      	movs	r5, #0
    a30a:	f800 5b01 	strb.w	r5, [r0], #1
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a30e:	4286      	cmp	r6, r0
    a310:	d1fb      	bne.n	a30a <grid_ui_event_register_actionstring+0x2e>
	}
	ele->event_list[event_index].action_string_length = 0;
    a312:	630d      	str	r5, [r1, #48]	; 0x30
	

	uint8_t escaped_characters = 0;
	
	for (uint32_t i=0; i<action_string_length; i++){
    a314:	2000      	movs	r0, #0
    a316:	4298      	cmp	r0, r3
    a318:	d10d      	bne.n	a336 <grid_ui_event_register_actionstring+0x5a>
	}
	

	ele->event_list[event_index].action_string_length = action_string_length;
	
	ele->event_list[event_index].cfg_changed_flag = 1;
    a31a:	2301      	movs	r3, #1
	ele->event_list[event_index].action_string_length = action_string_length;
    a31c:	6308      	str	r0, [r1, #48]	; 0x30
	ele->event_list[event_index].cfg_changed_flag = 1;
    a31e:	f881 30b6 	strb.w	r3, [r1, #182]	; 0xb6
	
	
}
    a322:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a324:	6e06      	ldr	r6, [r0, #96]	; 0x60
    a326:	fb0e 6605 	mla	r6, lr, r5, r6
    a32a:	3501      	adds	r5, #1
    a32c:	7ab6      	ldrb	r6, [r6, #10]
    a32e:	428e      	cmp	r6, r1
    a330:	bf08      	it	eq
    a332:	463c      	moveq	r4, r7
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a334:	e7d9      	b.n	a2ea <grid_ui_event_register_actionstring+0xe>
		if (ele->event_list[event_index].action_string[i] > 127){
    a336:	5616      	ldrsb	r6, [r2, r0]
		ele->event_list[event_index].action_string[i] = action_string[i];
    a338:	5c15      	ldrb	r5, [r2, r0]
		if (ele->event_list[event_index].action_string[i] > 127){
    a33a:	2e00      	cmp	r6, #0
			ele->event_list[event_index].action_string[i] -= 128;
    a33c:	bfb8      	it	lt
    a33e:	3d80      	sublt	r5, #128	; 0x80
    a340:	7025      	strb	r5, [r4, #0]
	for (uint32_t i=0; i<action_string_length; i++){
    a342:	3001      	adds	r0, #1
    a344:	3401      	adds	r4, #1
    a346:	e7e6      	b.n	a316 <grid_ui_event_register_actionstring+0x3a>

0000a348 <grid_ui_event_generate_actionstring>:
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a348:	b5f0      	push	{r4, r5, r6, r7, lr}
    a34a:	4605      	mov	r5, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a34c:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a350:	b0a3      	sub	sp, #140	; 0x8c
    a352:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a354:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a356:	26ff      	movs	r6, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a358:	27bc      	movs	r7, #188	; 0xbc
    a35a:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a35c:	4288      	cmp	r0, r1
    a35e:	d82a      	bhi.n	a3b6 <grid_ui_event_generate_actionstring+0x6e>
	if (event_index == 255){
    a360:	2eff      	cmp	r6, #255	; 0xff
    a362:	d026      	beq.n	a3b2 <grid_ui_event_generate_actionstring+0x6a>
	uint8_t action_string[GRID_UI_ACTION_STRING_maxlength] = {0};
    a364:	4b35      	ldr	r3, [pc, #212]	; (a43c <grid_ui_event_generate_actionstring+0xf4>)
    a366:	2100      	movs	r1, #0
    a368:	227e      	movs	r2, #126	; 0x7e
    a36a:	a802      	add	r0, sp, #8
    a36c:	9101      	str	r1, [sp, #4]
    a36e:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    a370:	7a6b      	ldrb	r3, [r5, #9]
    a372:	2b02      	cmp	r3, #2
    a374:	d12c      	bne.n	a3d0 <grid_ui_event_generate_actionstring+0x88>
		switch(event_type){
    a376:	2c04      	cmp	r4, #4
    a378:	d026      	beq.n	a3c8 <grid_ui_event_generate_actionstring+0x80>
    a37a:	2c05      	cmp	r4, #5
    a37c:	d026      	beq.n	a3cc <grid_ui_event_generate_actionstring+0x84>
    a37e:	b91c      	cbnz	r4, a388 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_INIT:	sprintf(action_string, GRID_ACTIONSTRING_INIT_BUT);		break;
    a380:	492f      	ldr	r1, [pc, #188]	; (a440 <grid_ui_event_generate_actionstring+0xf8>)
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a382:	4b30      	ldr	r3, [pc, #192]	; (a444 <grid_ui_event_generate_actionstring+0xfc>)
    a384:	a801      	add	r0, sp, #4
    a386:	4798      	blx	r3
	if (strlen(action_string)){
    a388:	f89d 3004 	ldrb.w	r3, [sp, #4]
    a38c:	b143      	cbz	r3, a3a0 <grid_ui_event_generate_actionstring+0x58>
		grid_ui_event_register_actionstring(ele, event_type, action_string, strlen(action_string));
    a38e:	4b2e      	ldr	r3, [pc, #184]	; (a448 <grid_ui_event_generate_actionstring+0x100>)
    a390:	a801      	add	r0, sp, #4
    a392:	4798      	blx	r3
    a394:	4621      	mov	r1, r4
    a396:	4603      	mov	r3, r0
    a398:	4c2c      	ldr	r4, [pc, #176]	; (a44c <grid_ui_event_generate_actionstring+0x104>)
    a39a:	aa01      	add	r2, sp, #4
    a39c:	4628      	mov	r0, r5
    a39e:	47a0      	blx	r4
	ele->event_list[event_index].cfg_changed_flag = 0;
    a3a0:	23bc      	movs	r3, #188	; 0xbc
    a3a2:	fb16 f603 	smulbb	r6, r6, r3
    a3a6:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    a3a8:	441e      	add	r6, r3
    a3aa:	f44f 7380 	mov.w	r3, #256	; 0x100
    a3ae:	f8a6 30b6 	strh.w	r3, [r6, #182]	; 0xb6
}
    a3b2:	b023      	add	sp, #140	; 0x8c
    a3b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a3b6:	6e2a      	ldr	r2, [r5, #96]	; 0x60
    a3b8:	fb07 2203 	mla	r2, r7, r3, r2
    a3bc:	3301      	adds	r3, #1
    a3be:	7a92      	ldrb	r2, [r2, #10]
    a3c0:	42a2      	cmp	r2, r4
    a3c2:	bf08      	it	eq
    a3c4:	460e      	moveq	r6, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a3c6:	e7c8      	b.n	a35a <grid_ui_event_generate_actionstring+0x12>
			case GRID_UI_EVENT_DP:		sprintf(action_string, GRID_ACTIONSTRING_DP_BUT);		break;
    a3c8:	4921      	ldr	r1, [pc, #132]	; (a450 <grid_ui_event_generate_actionstring+0x108>)
    a3ca:	e7da      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:		sprintf(action_string, GRID_ACTIONSTRING_DR_BUT);		break;
    a3cc:	4921      	ldr	r1, [pc, #132]	; (a454 <grid_ui_event_generate_actionstring+0x10c>)
    a3ce:	e7d8      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a3d0:	2b01      	cmp	r3, #1
    a3d2:	d105      	bne.n	a3e0 <grid_ui_event_generate_actionstring+0x98>
		switch(event_type){
    a3d4:	2c00      	cmp	r4, #0
    a3d6:	d0d3      	beq.n	a380 <grid_ui_event_generate_actionstring+0x38>
    a3d8:	2c01      	cmp	r4, #1
    a3da:	d1d5      	bne.n	a388 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_AVC7:	sprintf(action_string, GRID_ACTIONSTRING_AVC7_POT);		break;
    a3dc:	491e      	ldr	r1, [pc, #120]	; (a458 <grid_ui_event_generate_actionstring+0x110>)
    a3de:	e7d0      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a3e0:	2b03      	cmp	r3, #3
    a3e2:	d1d1      	bne.n	a388 <grid_ui_event_generate_actionstring+0x40>
		switch(event_type){
    a3e4:	2c0d      	cmp	r4, #13
    a3e6:	d8cf      	bhi.n	a388 <grid_ui_event_generate_actionstring+0x40>
    a3e8:	a301      	add	r3, pc, #4	; (adr r3, a3f0 <grid_ui_event_generate_actionstring+0xa8>)
    a3ea:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
    a3ee:	bf00      	nop
    a3f0:	0000a429 	.word	0x0000a429
    a3f4:	0000a42d 	.word	0x0000a42d
    a3f8:	0000a389 	.word	0x0000a389
    a3fc:	0000a389 	.word	0x0000a389
    a400:	0000a435 	.word	0x0000a435
    a404:	0000a439 	.word	0x0000a439
    a408:	0000a389 	.word	0x0000a389
    a40c:	0000a389 	.word	0x0000a389
    a410:	0000a389 	.word	0x0000a389
    a414:	0000a389 	.word	0x0000a389
    a418:	0000a389 	.word	0x0000a389
    a41c:	0000a389 	.word	0x0000a389
    a420:	0000a389 	.word	0x0000a389
    a424:	0000a431 	.word	0x0000a431
			case GRID_UI_EVENT_INIT:        sprintf(action_string, GRID_ACTIONSTRING_INIT_ENC);	break;
    a428:	490c      	ldr	r1, [pc, #48]	; (a45c <grid_ui_event_generate_actionstring+0x114>)
    a42a:	e7aa      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_AVC7:        sprintf(action_string, GRID_ACTIONSTRING_AVC7_ENC);	break;
    a42c:	490c      	ldr	r1, [pc, #48]	; (a460 <grid_ui_event_generate_actionstring+0x118>)
    a42e:	e7a8      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_ENCPUSHROT:	sprintf(action_string, GRID_ACTIONSTRING_PUSHROT_ENC);	break;
    a430:	490c      	ldr	r1, [pc, #48]	; (a464 <grid_ui_event_generate_actionstring+0x11c>)
    a432:	e7a6      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DP:          sprintf(action_string, GRID_ACTIONSTRING_DP_ENC);	break;
    a434:	490c      	ldr	r1, [pc, #48]	; (a468 <grid_ui_event_generate_actionstring+0x120>)
    a436:	e7a4      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a438:	490c      	ldr	r1, [pc, #48]	; (a46c <grid_ui_event_generate_actionstring+0x124>)
    a43a:	e7a2      	b.n	a382 <grid_ui_event_generate_actionstring+0x3a>
    a43c:	000147c5 	.word	0x000147c5
    a440:	00016367 	.word	0x00016367
    a444:	00014cfb 	.word	0x00014cfb
    a448:	00014d0b 	.word	0x00014d0b
    a44c:	0000a2dd 	.word	0x0000a2dd
    a450:	0001638c 	.word	0x0001638c
    a454:	000163bb 	.word	0x000163bb
    a458:	000163ea 	.word	0x000163ea
    a45c:	00016419 	.word	0x00016419
    a460:	00016462 	.word	0x00016462
    a464:	000164cc 	.word	0x000164cc
    a468:	000164fb 	.word	0x000164fb
    a46c:	0001652a 	.word	0x0001652a

0000a470 <grid_ui_reinit>:
void grid_ui_reinit(struct grid_ui_model* ui){
    a470:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a474:	4606      	mov	r6, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a476:	2700      	movs	r7, #0
    a478:	7873      	ldrb	r3, [r6, #1]
    a47a:	b2fc      	uxtb	r4, r7
    a47c:	42a3      	cmp	r3, r4
    a47e:	d805      	bhi.n	a48c <grid_ui_reinit+0x1c>
	grid_sys_state.bank_active_changed = 1;
    a480:	4b18      	ldr	r3, [pc, #96]	; (a4e4 <grid_ui_reinit+0x74>)
    a482:	2201      	movs	r2, #1
    a484:	745a      	strb	r2, [r3, #17]
}
    a486:	b003      	add	sp, #12
    a488:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a48c:	6873      	ldr	r3, [r6, #4]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a48e:	f04f 0800 	mov.w	r8, #0
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a492:	eb03 1404 	add.w	r4, r3, r4, lsl #4
			struct grid_ui_element* ele = &bank->element_list[j];
    a496:	f04f 0b64 	mov.w	fp, #100	; 0x64
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a49a:	7a63      	ldrb	r3, [r4, #9]
    a49c:	fa5f f088 	uxtb.w	r0, r8
    a4a0:	4283      	cmp	r3, r0
    a4a2:	d801      	bhi.n	a4a8 <grid_ui_reinit+0x38>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a4a4:	3701      	adds	r7, #1
    a4a6:	e7e7      	b.n	a478 <grid_ui_reinit+0x8>
			struct grid_ui_element* ele = &bank->element_list[j];
    a4a8:	68e3      	ldr	r3, [r4, #12]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a4aa:	f04f 0900 	mov.w	r9, #0
			struct grid_ui_element* ele = &bank->element_list[j];
    a4ae:	fb0b 3000 	mla	r0, fp, r0, r3
				struct grid_ui_event* eve = &ele->event_list[k];
    a4b2:	f04f 0abc 	mov.w	sl, #188	; 0xbc
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a4b6:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
    a4ba:	fa5f f589 	uxtb.w	r5, r9
    a4be:	42a9      	cmp	r1, r5
    a4c0:	d802      	bhi.n	a4c8 <grid_ui_reinit+0x58>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a4c2:	f108 0801 	add.w	r8, r8, #1
    a4c6:	e7e8      	b.n	a49a <grid_ui_reinit+0x2a>
				struct grid_ui_event* eve = &ele->event_list[k];
    a4c8:	6e01      	ldr	r1, [r0, #96]	; 0x60
				grid_ui_event_generate_actionstring(ele, eve->type);
    a4ca:	4b07      	ldr	r3, [pc, #28]	; (a4e8 <grid_ui_reinit+0x78>)
    a4cc:	9001      	str	r0, [sp, #4]
				struct grid_ui_event* eve = &ele->event_list[k];
    a4ce:	fb0a 1505 	mla	r5, sl, r5, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a4d2:	f109 0901 	add.w	r9, r9, #1
    a4d6:	7aa9      	ldrb	r1, [r5, #10]
    a4d8:	4798      	blx	r3
}


void grid_ui_event_reset(struct grid_ui_event* eve){
	
	eve->trigger = GRID_UI_STATUS_READY;
    a4da:	2204      	movs	r2, #4
    a4dc:	9801      	ldr	r0, [sp, #4]
    a4de:	726a      	strb	r2, [r5, #9]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a4e0:	e7e9      	b.n	a4b6 <grid_ui_reinit+0x46>
    a4e2:	bf00      	nop
    a4e4:	2000f008 	.word	0x2000f008
    a4e8:	0000a349 	.word	0x0000a349

0000a4ec <grid_ui_event_find>:
uint8_t grid_ui_event_find(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a4ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a4ee:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
    a4f2:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a4f4:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a4f6:	27bc      	movs	r7, #188	; 0xbc
    a4f8:	b2dd      	uxtb	r5, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a4fa:	42ae      	cmp	r6, r5
    a4fc:	d801      	bhi.n	a502 <grid_ui_event_find+0x16>
}
    a4fe:	4610      	mov	r0, r2
    a500:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a502:	6e04      	ldr	r4, [r0, #96]	; 0x60
    a504:	fb07 4403 	mla	r4, r7, r3, r4
    a508:	3301      	adds	r3, #1
    a50a:	7aa4      	ldrb	r4, [r4, #10]
    a50c:	428c      	cmp	r4, r1
    a50e:	bf08      	it	eq
    a510:	462a      	moveq	r2, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a512:	e7f1      	b.n	a4f8 <grid_ui_event_find+0xc>

0000a514 <grid_ui_event_trigger>:
	if (event_index == 255){
    a514:	29ff      	cmp	r1, #255	; 0xff
    a516:	d005      	beq.n	a524 <grid_ui_event_trigger+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED;
    a518:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a51a:	23bc      	movs	r3, #188	; 0xbc
    a51c:	fb01 2103 	mla	r1, r1, r3, r2
    a520:	2305      	movs	r3, #5
    a522:	724b      	strb	r3, [r1, #9]
}
    a524:	4770      	bx	lr

0000a526 <grid_ui_event_trigger_local>:
	if (event_index == 255){
    a526:	29ff      	cmp	r1, #255	; 0xff
    a528:	d005      	beq.n	a536 <grid_ui_event_trigger_local+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED_LOCAL;
    a52a:	6e02      	ldr	r2, [r0, #96]	; 0x60
    a52c:	23bc      	movs	r3, #188	; 0xbc
    a52e:	fb01 2103 	mla	r1, r1, r3, r2
    a532:	2306      	movs	r3, #6
    a534:	724b      	strb	r3, [r1, #9]
}
    a536:	4770      	bx	lr

0000a538 <grid_ui_smart_trigger>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a538:	6840      	ldr	r0, [r0, #4]
    a53a:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a53e:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a540:	68c4      	ldr	r4, [r0, #12]
    a542:	2064      	movs	r0, #100	; 0x64
    a544:	fb02 4400 	mla	r4, r2, r0, r4
    a548:	4619      	mov	r1, r3
    a54a:	4620      	mov	r0, r4
    a54c:	4b05      	ldr	r3, [pc, #20]	; (a564 <grid_ui_smart_trigger+0x2c>)
    a54e:	4798      	blx	r3
	if (event_index == 255){
    a550:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a552:	4601      	mov	r1, r0
	if (event_index == 255){
    a554:	d004      	beq.n	a560 <grid_ui_smart_trigger+0x28>
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a556:	4620      	mov	r0, r4
    a558:	4b03      	ldr	r3, [pc, #12]	; (a568 <grid_ui_smart_trigger+0x30>)
}
    a55a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    a55e:	4718      	bx	r3
}
    a560:	bd10      	pop	{r4, pc}
    a562:	bf00      	nop
    a564:	0000a4ed 	.word	0x0000a4ed
    a568:	0000a515 	.word	0x0000a515

0000a56c <grid_ui_event_register_eventstring>:
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a56c:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a570:	4604      	mov	r4, r0
	grid_debug_print_text("Register Action");
    a572:	4e28      	ldr	r6, [pc, #160]	; (a614 <grid_ui_event_register_eventstring+0xa8>)
    a574:	4828      	ldr	r0, [pc, #160]	; (a618 <grid_ui_event_register_eventstring+0xac>)
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    a576:	4699      	mov	r9, r3
    a578:	4688      	mov	r8, r1
    a57a:	4692      	mov	sl, r2
	grid_debug_print_text("Register Action");
    a57c:	47b0      	blx	r6
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a57e:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    a582:	46b3      	mov	fp, r6
    a584:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a586:	25ff      	movs	r5, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a588:	26bc      	movs	r6, #188	; 0xbc
    a58a:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a58c:	4288      	cmp	r0, r1
    a58e:	d807      	bhi.n	a5a0 <grid_ui_event_register_eventstring+0x34>
	if (event_index == 255){
    a590:	2dff      	cmp	r5, #255	; 0xff
    a592:	d10e      	bne.n	a5b2 <grid_ui_event_register_eventstring+0x46>
		grid_debug_print_text("Event Not Found");
    a594:	4821      	ldr	r0, [pc, #132]	; (a61c <grid_ui_event_register_eventstring+0xb0>)
    a596:	465b      	mov	r3, fp
}
    a598:	b001      	add	sp, #4
    a59a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		grid_debug_print_text("Event Not Found");
    a59e:	4718      	bx	r3
		if (ele->event_list[i].type == event_type){
    a5a0:	6e22      	ldr	r2, [r4, #96]	; 0x60
    a5a2:	fb06 2203 	mla	r2, r6, r3, r2
    a5a6:	3301      	adds	r3, #1
    a5a8:	7a92      	ldrb	r2, [r2, #10]
    a5aa:	4542      	cmp	r2, r8
    a5ac:	bf08      	it	eq
    a5ae:	460d      	moveq	r5, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a5b0:	e7eb      	b.n	a58a <grid_ui_event_register_eventstring+0x1e>
		ele->event_list[event_index].event_string[i] = 0;
    a5b2:	23bc      	movs	r3, #188	; 0xbc
    a5b4:	fb15 f503 	smulbb	r5, r5, r3
    a5b8:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a5ba:	442b      	add	r3, r5
    a5bc:	f103 0210 	add.w	r2, r3, #16
    a5c0:	f103 002e 	add.w	r0, r3, #46	; 0x2e
    a5c4:	2100      	movs	r1, #0
    a5c6:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a5ca:	4282      	cmp	r2, r0
    a5cc:	d1fb      	bne.n	a5c6 <grid_ui_event_register_eventstring+0x5a>
			grid_debug_print_text(" Escaped Char Found ");
    a5ce:	4814      	ldr	r0, [pc, #80]	; (a620 <grid_ui_event_register_eventstring+0xb4>)
	ele->event_list[event_index].event_string_length = 0;
    a5d0:	60d9      	str	r1, [r3, #12]
	for (uint32_t i=0; i<event_string_length; i++){
    a5d2:	2600      	movs	r6, #0
    a5d4:	6e27      	ldr	r7, [r4, #96]	; 0x60
    a5d6:	454e      	cmp	r6, r9
    a5d8:	442f      	add	r7, r5
    a5da:	d10b      	bne.n	a5f4 <grid_ui_event_register_eventstring+0x88>
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a5dc:	6860      	ldr	r0, [r4, #4]
	ele->event_list[event_index].event_string_length = event_string_length;
    a5de:	60fe      	str	r6, [r7, #12]
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a5e0:	7a22      	ldrb	r2, [r4, #8]
    a5e2:	4c10      	ldr	r4, [pc, #64]	; (a624 <grid_ui_event_register_eventstring+0xb8>)
    a5e4:	7a01      	ldrb	r1, [r0, #8]
    a5e6:	6840      	ldr	r0, [r0, #4]
    a5e8:	4643      	mov	r3, r8
    a5ea:	46a4      	mov	ip, r4
}
    a5ec:	b001      	add	sp, #4
    a5ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    a5f2:	4760      	bx	ip
		ele->event_list[event_index].event_string[i] = event_string[i];
    a5f4:	f81a 3006 	ldrb.w	r3, [sl, r6]
    a5f8:	4437      	add	r7, r6
    a5fa:	743b      	strb	r3, [r7, #16]
		if (ele->event_list[event_index].event_string[i] > 127){
    a5fc:	061b      	lsls	r3, r3, #24
    a5fe:	d507      	bpl.n	a610 <grid_ui_event_register_eventstring+0xa4>
			grid_debug_print_text(" Escaped Char Found ");
    a600:	47d8      	blx	fp
			ele->event_list[event_index].event_string[i] -= 128;
    a602:	6e23      	ldr	r3, [r4, #96]	; 0x60
    a604:	4806      	ldr	r0, [pc, #24]	; (a620 <grid_ui_event_register_eventstring+0xb4>)
    a606:	442b      	add	r3, r5
    a608:	4433      	add	r3, r6
    a60a:	7c1a      	ldrb	r2, [r3, #16]
    a60c:	3a80      	subs	r2, #128	; 0x80
    a60e:	741a      	strb	r2, [r3, #16]
	for (uint32_t i=0; i<event_string_length; i++){
    a610:	3601      	adds	r6, #1
    a612:	e7df      	b.n	a5d4 <grid_ui_event_register_eventstring+0x68>
    a614:	00009621 	.word	0x00009621
    a618:	00016559 	.word	0x00016559
    a61c:	00016569 	.word	0x00016569
    a620:	00016579 	.word	0x00016579
    a624:	0000a539 	.word	0x0000a539

0000a628 <grid_ui_event_generate_eventstring>:
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a628:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a62a:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a62e:	b089      	sub	sp, #36	; 0x24
    a630:	4605      	mov	r5, r0
    a632:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a634:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a636:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a638:	27bc      	movs	r7, #188	; 0xbc
    a63a:	b2d8      	uxtb	r0, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a63c:	4286      	cmp	r6, r0
    a63e:	d81a      	bhi.n	a676 <grid_ui_event_generate_eventstring+0x4e>
	if (event_index == 255){
    a640:	2aff      	cmp	r2, #255	; 0xff
    a642:	d016      	beq.n	a672 <grid_ui_event_generate_eventstring+0x4a>
	uint8_t event_string[GRID_UI_EVENT_STRING_maxlength] = {0};	
    a644:	4b27      	ldr	r3, [pc, #156]	; (a6e4 <grid_ui_event_generate_eventstring+0xbc>)
    a646:	2100      	movs	r1, #0
    a648:	221a      	movs	r2, #26
    a64a:	a801      	add	r0, sp, #4
    a64c:	9100      	str	r1, [sp, #0]
    a64e:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    a650:	7a6b      	ldrb	r3, [r5, #9]
    a652:	2b02      	cmp	r3, #2
    a654:	d132      	bne.n	a6bc <grid_ui_event_generate_eventstring+0x94>
		if (event_type == GRID_UI_EVENT_INIT){
    a656:	b9bc      	cbnz	r4, a688 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_INIT_BUT); // !!
    a658:	4923      	ldr	r1, [pc, #140]	; (a6e8 <grid_ui_event_generate_eventstring+0xc0>)
    a65a:	4b24      	ldr	r3, [pc, #144]	; (a6ec <grid_ui_event_generate_eventstring+0xc4>)
    a65c:	4668      	mov	r0, sp
    a65e:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a660:	4b23      	ldr	r3, [pc, #140]	; (a6f0 <grid_ui_event_generate_eventstring+0xc8>)
    a662:	4668      	mov	r0, sp
    a664:	4798      	blx	r3
    a666:	466a      	mov	r2, sp
    a668:	4603      	mov	r3, r0
    a66a:	2100      	movs	r1, #0
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a66c:	4c21      	ldr	r4, [pc, #132]	; (a6f4 <grid_ui_event_generate_eventstring+0xcc>)
    a66e:	4628      	mov	r0, r5
    a670:	47a0      	blx	r4
}
    a672:	b009      	add	sp, #36	; 0x24
    a674:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a676:	6e29      	ldr	r1, [r5, #96]	; 0x60
    a678:	fb07 1103 	mla	r1, r7, r3, r1
    a67c:	3301      	adds	r3, #1
    a67e:	7a89      	ldrb	r1, [r1, #10]
    a680:	42a1      	cmp	r1, r4
    a682:	bf08      	it	eq
    a684:	4602      	moveq	r2, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a686:	e7d8      	b.n	a63a <grid_ui_event_generate_eventstring+0x12>
		else if (event_type == GRID_UI_EVENT_DP){
    a688:	2c04      	cmp	r4, #4
    a68a:	d10a      	bne.n	a6a2 <grid_ui_event_generate_eventstring+0x7a>
			sprintf(event_string, GRID_EVENTSTRING_DP_BUT); // !!
    a68c:	491a      	ldr	r1, [pc, #104]	; (a6f8 <grid_ui_event_generate_eventstring+0xd0>)
    a68e:	4b17      	ldr	r3, [pc, #92]	; (a6ec <grid_ui_event_generate_eventstring+0xc4>)
    a690:	4668      	mov	r0, sp
    a692:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a694:	4b16      	ldr	r3, [pc, #88]	; (a6f0 <grid_ui_event_generate_eventstring+0xc8>)
    a696:	4668      	mov	r0, sp
    a698:	4798      	blx	r3
    a69a:	466a      	mov	r2, sp
    a69c:	4603      	mov	r3, r0
    a69e:	2104      	movs	r1, #4
    a6a0:	e7e4      	b.n	a66c <grid_ui_event_generate_eventstring+0x44>
		else if (event_type == GRID_UI_EVENT_DR){
    a6a2:	2c05      	cmp	r4, #5
    a6a4:	d1e5      	bne.n	a672 <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_DR_BUT); // !!
    a6a6:	4915      	ldr	r1, [pc, #84]	; (a6fc <grid_ui_event_generate_eventstring+0xd4>)
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a6a8:	4b10      	ldr	r3, [pc, #64]	; (a6ec <grid_ui_event_generate_eventstring+0xc4>)
    a6aa:	4668      	mov	r0, sp
    a6ac:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    a6ae:	4b10      	ldr	r3, [pc, #64]	; (a6f0 <grid_ui_event_generate_eventstring+0xc8>)
    a6b0:	4668      	mov	r0, sp
    a6b2:	4798      	blx	r3
    a6b4:	466a      	mov	r2, sp
    a6b6:	4603      	mov	r3, r0
    a6b8:	4621      	mov	r1, r4
    a6ba:	e7d7      	b.n	a66c <grid_ui_event_generate_eventstring+0x44>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a6bc:	2b01      	cmp	r3, #1
    a6be:	d105      	bne.n	a6cc <grid_ui_event_generate_eventstring+0xa4>
		if (event_type == GRID_UI_EVENT_INIT){
    a6c0:	2c00      	cmp	r4, #0
    a6c2:	d0c9      	beq.n	a658 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a6c4:	2c01      	cmp	r4, #1
    a6c6:	d1d4      	bne.n	a672 <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_POT); // !!
    a6c8:	490d      	ldr	r1, [pc, #52]	; (a700 <grid_ui_event_generate_eventstring+0xd8>)
    a6ca:	e7ed      	b.n	a6a8 <grid_ui_event_generate_eventstring+0x80>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a6cc:	2b03      	cmp	r3, #3
    a6ce:	d1d0      	bne.n	a672 <grid_ui_event_generate_eventstring+0x4a>
		if (event_type == GRID_UI_EVENT_INIT){
    a6d0:	2c00      	cmp	r4, #0
    a6d2:	d0c1      	beq.n	a658 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    a6d4:	2c01      	cmp	r4, #1
    a6d6:	d101      	bne.n	a6dc <grid_ui_event_generate_eventstring+0xb4>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_ENC); // !!
    a6d8:	490a      	ldr	r1, [pc, #40]	; (a704 <grid_ui_event_generate_eventstring+0xdc>)
    a6da:	e7e5      	b.n	a6a8 <grid_ui_event_generate_eventstring+0x80>
		else if (event_type == GRID_UI_EVENT_ENCPUSHROT){
    a6dc:	2c0d      	cmp	r4, #13
    a6de:	d1d3      	bne.n	a688 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    a6e0:	4909      	ldr	r1, [pc, #36]	; (a708 <grid_ui_event_generate_eventstring+0xe0>)
    a6e2:	e7e1      	b.n	a6a8 <grid_ui_event_generate_eventstring+0x80>
    a6e4:	000147c5 	.word	0x000147c5
    a6e8:	0001658e 	.word	0x0001658e
    a6ec:	00014cfb 	.word	0x00014cfb
    a6f0:	00014d0b 	.word	0x00014d0b
    a6f4:	0000a56d 	.word	0x0000a56d
    a6f8:	000165a7 	.word	0x000165a7
    a6fc:	000165c5 	.word	0x000165c5
    a700:	000165e3 	.word	0x000165e3
    a704:	00016601 	.word	0x00016601
    a708:	0001661f 	.word	0x0001661f

0000a70c <grid_ui_event_init>:
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a70c:	b570      	push	{r4, r5, r6, lr}
	struct grid_ui_event* eve = &parent->event_list[index];
    a70e:	6e06      	ldr	r6, [r0, #96]	; 0x60
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    a710:	4615      	mov	r5, r2
	struct grid_ui_event* eve = &parent->event_list[index];
    a712:	22bc      	movs	r2, #188	; 0xbc
    a714:	fb11 f202 	smulbb	r2, r1, r2
    a718:	18b4      	adds	r4, r6, r2
	eve->cfg_changed_flag = 0;
    a71a:	2300      	movs	r3, #0
	eve->index = index;
    a71c:	7221      	strb	r1, [r4, #8]
	eve->status = GRID_UI_STATUS_READY;
    a71e:	2104      	movs	r1, #4
	eve->parent = parent;
    a720:	6060      	str	r0, [r4, #4]
	eve->cfg_changed_flag = 0;
    a722:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	eve->type   = event_type;	
    a726:	72a5      	strb	r5, [r4, #10]
	eve->status = GRID_UI_STATUS_READY;
    a728:	54b1      	strb	r1, [r6, r2]
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a72a:	f104 0210 	add.w	r2, r4, #16
    a72e:	f104 012e 	add.w	r1, r4, #46	; 0x2e
		eve->event_string[i] = 0;
    a732:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    a736:	428a      	cmp	r2, r1
    a738:	d1fb      	bne.n	a732 <grid_ui_event_init+0x26>
	eve->event_string_length = 0;
    a73a:	60e3      	str	r3, [r4, #12]
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a73c:	f104 01b6 	add.w	r1, r4, #182	; 0xb6
    a740:	f104 0334 	add.w	r3, r4, #52	; 0x34
		eve->action_string[i] = 0;
    a744:	2200      	movs	r2, #0
    a746:	f803 2b01 	strb.w	r2, [r3], #1
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a74a:	4299      	cmp	r1, r3
    a74c:	d1fb      	bne.n	a746 <grid_ui_event_init+0x3a>
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a74e:	4b08      	ldr	r3, [pc, #32]	; (a770 <grid_ui_event_init+0x64>)
	eve->action_string_length = 0;
    a750:	6322      	str	r2, [r4, #48]	; 0x30
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    a752:	4629      	mov	r1, r5
    a754:	4798      	blx	r3
	grid_ui_event_generate_actionstring(eve->parent, event_type);	
    a756:	4b07      	ldr	r3, [pc, #28]	; (a774 <grid_ui_event_init+0x68>)
    a758:	6860      	ldr	r0, [r4, #4]
    a75a:	4629      	mov	r1, r5
    a75c:	4798      	blx	r3
	eve->cfg_changed_flag = 0;
    a75e:	f44f 7380 	mov.w	r3, #256	; 0x100
    a762:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
	eve->cfg_flashempty_flag = 1;
    a766:	2301      	movs	r3, #1
    a768:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
}
    a76c:	bd70      	pop	{r4, r5, r6, pc}
    a76e:	bf00      	nop
    a770:	0000a629 	.word	0x0000a629
    a774:	0000a349 	.word	0x0000a349

0000a778 <grid_ui_element_init>:
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a778:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct grid_ui_element* ele = &parent->element_list[index];
    a77c:	2364      	movs	r3, #100	; 0x64
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    a77e:	4615      	mov	r5, r2
	struct grid_ui_element* ele = &parent->element_list[index];
    a780:	68c2      	ldr	r2, [r0, #12]
    a782:	fb11 f303 	smulbb	r3, r1, r3
    a786:	18d4      	adds	r4, r2, r3
	ele->index = index;
    a788:	7221      	strb	r1, [r4, #8]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a78a:	2101      	movs	r1, #1
	ele->parent = parent;
    a78c:	6060      	str	r0, [r4, #4]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    a78e:	54d1      	strb	r1, [r2, r3]
	ele->type = element_type;
    a790:	7265      	strb	r5, [r4, #9]
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a792:	f104 030c 	add.w	r3, r4, #12
    a796:	f104 025c 	add.w	r2, r4, #92	; 0x5c
		ele->template_parameter_list[i] = 0;
    a79a:	2100      	movs	r1, #0
    a79c:	f843 1b04 	str.w	r1, [r3], #4
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    a7a0:	429a      	cmp	r2, r3
    a7a2:	d1fb      	bne.n	a79c <grid_ui_element_init+0x24>
	if (element_type == GRID_UI_ELEMENT_SYSTEM){
    a7a4:	bb1d      	cbnz	r5, a7ee <grid_ui_element_init+0x76>
		ele->event_list_length = 6;
    a7a6:	2306      	movs	r3, #6
    a7a8:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a7ac:	f44f 608d 	mov.w	r0, #1128	; 0x468
    a7b0:	4b34      	ldr	r3, [pc, #208]	; (a884 <grid_ui_element_init+0x10c>)
    a7b2:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a7b4:	462a      	mov	r2, r5
    a7b6:	4629      	mov	r1, r5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a7b8:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a7ba:	4d33      	ldr	r5, [pc, #204]	; (a888 <grid_ui_element_init+0x110>)
    a7bc:	4620      	mov	r0, r4
    a7be:	47a8      	blx	r5
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_HEARTBEAT); // Heartbeat
    a7c0:	220c      	movs	r2, #12
    a7c2:	2101      	movs	r1, #1
    a7c4:	4620      	mov	r0, r4
    a7c6:	47a8      	blx	r5
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_MAPMODE_PRESS); // Mapmode press
    a7c8:	2207      	movs	r2, #7
    a7ca:	2102      	movs	r1, #2
    a7cc:	4620      	mov	r0, r4
    a7ce:	47a8      	blx	r5
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_MAPMODE_RELEASE); // Mapmode release
    a7d0:	2208      	movs	r2, #8
    a7d2:	2103      	movs	r1, #3
    a7d4:	4620      	mov	r0, r4
    a7d6:	47a8      	blx	r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_CFG_RESPONSE); //
    a7d8:	2209      	movs	r2, #9
    a7da:	2104      	movs	r1, #4
    a7dc:	4620      	mov	r0, r4
    a7de:	47a8      	blx	r5
		grid_ui_event_init(ele, 5, GRID_UI_EVENT_CFG_REQUEST); //
    a7e0:	220a      	movs	r2, #10
    a7e2:	2105      	movs	r1, #5
    a7e4:	4620      	mov	r0, r4
    a7e6:	462b      	mov	r3, r5
}
    a7e8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a7ec:	4718      	bx	r3
	else if (element_type == GRID_UI_ELEMENT_POTENTIOMETER){
    a7ee:	2d01      	cmp	r5, #1
    a7f0:	d111      	bne.n	a816 <grid_ui_element_init+0x9e>
		ele->event_list_length = 2;
    a7f2:	2302      	movs	r3, #2
    a7f4:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a7f8:	f44f 70bc 	mov.w	r0, #376	; 0x178
    a7fc:	4b21      	ldr	r3, [pc, #132]	; (a884 <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a7fe:	4e22      	ldr	r6, [pc, #136]	; (a888 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a800:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a802:	2200      	movs	r2, #0
    a804:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a806:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a808:	4620      	mov	r0, r4
    a80a:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a80c:	462a      	mov	r2, r5
    a80e:	4629      	mov	r1, r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a810:	4620      	mov	r0, r4
    a812:	4633      	mov	r3, r6
    a814:	e7e8      	b.n	a7e8 <grid_ui_element_init+0x70>
	else if (element_type == GRID_UI_ELEMENT_BUTTON){
    a816:	2d02      	cmp	r5, #2
    a818:	d113      	bne.n	a842 <grid_ui_element_init+0xca>
		ele->event_list_length = 3;
    a81a:	2303      	movs	r3, #3
    a81c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a820:	f44f 700d 	mov.w	r0, #564	; 0x234
    a824:	4b17      	ldr	r3, [pc, #92]	; (a884 <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a826:	4e18      	ldr	r6, [pc, #96]	; (a888 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a828:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a82a:	2200      	movs	r2, #0
    a82c:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a82e:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a830:	4620      	mov	r0, r4
    a832:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a834:	2204      	movs	r2, #4
    a836:	2101      	movs	r1, #1
    a838:	4620      	mov	r0, r4
    a83a:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a83c:	2205      	movs	r2, #5
    a83e:	4629      	mov	r1, r5
    a840:	e7e6      	b.n	a810 <grid_ui_element_init+0x98>
	else if (element_type == GRID_UI_ELEMENT_ENCODER){
    a842:	2d03      	cmp	r5, #3
    a844:	d11b      	bne.n	a87e <grid_ui_element_init+0x106>
		ele->event_list_length = 5;
    a846:	2705      	movs	r7, #5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a848:	4b0e      	ldr	r3, [pc, #56]	; (a884 <grid_ui_element_init+0x10c>)
		ele->event_list_length = 5;
    a84a:	f884 705c 	strb.w	r7, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a84e:	f44f 706b 	mov.w	r0, #940	; 0x3ac
    a852:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a854:	2200      	movs	r2, #0
    a856:	4e0c      	ldr	r6, [pc, #48]	; (a888 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    a858:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    a85a:	4611      	mov	r1, r2
    a85c:	4620      	mov	r0, r4
    a85e:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    a860:	2204      	movs	r2, #4
    a862:	2101      	movs	r1, #1
    a864:	4620      	mov	r0, r4
    a866:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    a868:	463a      	mov	r2, r7
    a86a:	2102      	movs	r1, #2
    a86c:	4620      	mov	r0, r4
    a86e:	47b0      	blx	r6
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    a870:	2201      	movs	r2, #1
    a872:	4629      	mov	r1, r5
    a874:	4620      	mov	r0, r4
    a876:	47b0      	blx	r6
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    a878:	220d      	movs	r2, #13
    a87a:	2104      	movs	r1, #4
    a87c:	e7c8      	b.n	a810 <grid_ui_element_init+0x98>
}
    a87e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    a882:	bf00      	nop
    a884:	00014799 	.word	0x00014799
    a888:	0000a70d 	.word	0x0000a70d

0000a88c <grid_ui_smart_trigger_local>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a88c:	6840      	ldr	r0, [r0, #4]
    a88e:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger_local(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    a892:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a894:	68c4      	ldr	r4, [r0, #12]
    a896:	2064      	movs	r0, #100	; 0x64
    a898:	fb02 4400 	mla	r4, r2, r0, r4
    a89c:	4619      	mov	r1, r3
    a89e:	4620      	mov	r0, r4
    a8a0:	4b05      	ldr	r3, [pc, #20]	; (a8b8 <grid_ui_smart_trigger_local+0x2c>)
    a8a2:	4798      	blx	r3
	if (event_index == 255){
    a8a4:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    a8a6:	4601      	mov	r1, r0
	if (event_index == 255){
    a8a8:	d004      	beq.n	a8b4 <grid_ui_smart_trigger_local+0x28>
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a8aa:	4620      	mov	r0, r4
    a8ac:	4b03      	ldr	r3, [pc, #12]	; (a8bc <grid_ui_smart_trigger_local+0x30>)
}
    a8ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    a8b2:	4718      	bx	r3
}
    a8b4:	bd10      	pop	{r4, pc}
    a8b6:	bf00      	nop
    a8b8:	0000a4ed 	.word	0x0000a4ed
    a8bc:	0000a527 	.word	0x0000a527

0000a8c0 <grid_ui_reinit_local>:
void grid_ui_reinit_local(struct grid_ui_model* ui){
    a8c0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a8c4:	4604      	mov	r4, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a8c6:	f04f 0800 	mov.w	r8, #0
    a8ca:	7863      	ldrb	r3, [r4, #1]
    a8cc:	fa5f f788 	uxtb.w	r7, r8
    a8d0:	42bb      	cmp	r3, r7
    a8d2:	d805      	bhi.n	a8e0 <grid_ui_reinit_local+0x20>
	grid_sys_state.bank_active_changed = 1;
    a8d4:	4b1c      	ldr	r3, [pc, #112]	; (a948 <grid_ui_reinit_local+0x88>)
    a8d6:	2201      	movs	r2, #1
    a8d8:	745a      	strb	r2, [r3, #17]
}
    a8da:	b003      	add	sp, #12
    a8dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a8e0:	6866      	ldr	r6, [r4, #4]
    a8e2:	eb06 1307 	add.w	r3, r6, r7, lsl #4
    a8e6:	9300      	str	r3, [sp, #0]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a8e8:	f04f 0900 	mov.w	r9, #0
    a8ec:	9b00      	ldr	r3, [sp, #0]
    a8ee:	7a5b      	ldrb	r3, [r3, #9]
    a8f0:	fa5f fb89 	uxtb.w	fp, r9
    a8f4:	455b      	cmp	r3, fp
    a8f6:	d802      	bhi.n	a8fe <grid_ui_reinit_local+0x3e>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a8f8:	f108 0801 	add.w	r8, r8, #1
    a8fc:	e7e5      	b.n	a8ca <grid_ui_reinit_local+0xa>
			struct grid_ui_element* ele = &bank->element_list[j];
    a8fe:	9b00      	ldr	r3, [sp, #0]
    a900:	68db      	ldr	r3, [r3, #12]
    a902:	2564      	movs	r5, #100	; 0x64
    a904:	fb05 350b 	mla	r5, r5, fp, r3
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a908:	f04f 0a00 	mov.w	sl, #0
    a90c:	f895 105c 	ldrb.w	r1, [r5, #92]	; 0x5c
    a910:	fa5f f38a 	uxtb.w	r3, sl
    a914:	4299      	cmp	r1, r3
    a916:	d802      	bhi.n	a91e <grid_ui_reinit_local+0x5e>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a918:	f109 0901 	add.w	r9, r9, #1
    a91c:	e7e6      	b.n	a8ec <grid_ui_reinit_local+0x2c>
				struct grid_ui_event* eve = &ele->event_list[k];
    a91e:	6e29      	ldr	r1, [r5, #96]	; 0x60
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a920:	4e0a      	ldr	r6, [pc, #40]	; (a94c <grid_ui_reinit_local+0x8c>)
				struct grid_ui_event* eve = &ele->event_list[k];
    a922:	22bc      	movs	r2, #188	; 0xbc
    a924:	fb02 1303 	mla	r3, r2, r3, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    a928:	9301      	str	r3, [sp, #4]
    a92a:	7a99      	ldrb	r1, [r3, #10]
    a92c:	4b08      	ldr	r3, [pc, #32]	; (a950 <grid_ui_reinit_local+0x90>)
    a92e:	4628      	mov	r0, r5
    a930:	4798      	blx	r3
	eve->trigger = GRID_UI_STATUS_READY;
    a932:	9b01      	ldr	r3, [sp, #4]
    a934:	2104      	movs	r1, #4
    a936:	7259      	strb	r1, [r3, #9]
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    a938:	465a      	mov	r2, fp
    a93a:	7a9b      	ldrb	r3, [r3, #10]
    a93c:	4639      	mov	r1, r7
    a93e:	4620      	mov	r0, r4
    a940:	47b0      	blx	r6
			for (uint8_t k=0; k<ele->event_list_length; k++){
    a942:	f10a 0a01 	add.w	sl, sl, #1
    a946:	e7e1      	b.n	a90c <grid_ui_reinit_local+0x4c>
    a948:	2000f008 	.word	0x2000f008
    a94c:	0000a88d 	.word	0x0000a88d
    a950:	0000a349 	.word	0x0000a349

0000a954 <grid_ui_event_render_action>:
		return 0;
	}
			
}

uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a954:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a958:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
    a95c:	4606      	mov	r6, r0

	
	uint8_t temp[500] = {0};
    a95e:	ac05      	add	r4, sp, #20
    a960:	4b74      	ldr	r3, [pc, #464]	; (ab34 <grid_ui_event_render_action+0x1e0>)
uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    a962:	9102      	str	r1, [sp, #8]
	uint8_t temp[500] = {0};
    a964:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
    a968:	2100      	movs	r1, #0
    a96a:	a806      	add	r0, sp, #24
    a96c:	6021      	str	r1, [r4, #0]
    a96e:	4798      	blx	r3

	uint32_t i=0;
	
	// copy event string
	for(true; i<eve->event_string_length; i++){
    a970:	68f3      	ldr	r3, [r6, #12]
    a972:	18f1      	adds	r1, r6, r3
    a974:	f106 0210 	add.w	r2, r6, #16
    a978:	4620      	mov	r0, r4
    a97a:	3110      	adds	r1, #16
    a97c:	4291      	cmp	r1, r2
    a97e:	d11e      	bne.n	a9be <grid_ui_event_render_action+0x6a>
		temp[i] = eve->event_string[i];
	
	}

	// copy action string
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a980:	6b32      	ldr	r2, [r6, #48]	; 0x30
    a982:	f106 0134 	add.w	r1, r6, #52	; 0x34
    a986:	441a      	add	r2, r3
    a988:	429a      	cmp	r2, r3
    a98a:	d81d      	bhi.n	a9c8 <grid_ui_event_render_action+0x74>


	uint32_t total_substituted_length = 0;

	uint8_t condition_state = 0;
	uint8_t condition_istrue = 0;
    a98c:	2700      	movs	r7, #0
	uint8_t condition_state = 0;
    a98e:	9701      	str	r7, [sp, #4]
	uint32_t total_substituted_length = 0;
    a990:	463d      	mov	r5, r7
	uint32_t block_start = 0;
    a992:	9700      	str	r7, [sp, #0]


	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    a994:	463c      	mov	r4, r7
    a996:	68f0      	ldr	r0, [r6, #12]
    a998:	6b33      	ldr	r3, [r6, #48]	; 0x30
    a99a:	4418      	add	r0, r3
    a99c:	42a0      	cmp	r0, r4
    a99e:	d818      	bhi.n	a9d2 <grid_ui_event_render_action+0x7e>

	}
	
	
	// RESET ENCODER RELATIVE TEMPLATE PARAMETER VALUES
	if(eve->parent->type == GRID_UI_ELEMENT_ENCODER){	
    a9a0:	6873      	ldr	r3, [r6, #4]
    a9a2:	7a5a      	ldrb	r2, [r3, #9]
    a9a4:	2a03      	cmp	r2, #3
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = 255;	
    a9a6:	bf08      	it	eq
    a9a8:	22ff      	moveq	r2, #255	; 0xff
    }
	
	
	return eve->event_string_length + eve->action_string_length - total_substituted_length;
		
}
    a9aa:	eba0 0005 	sub.w	r0, r0, r5
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = 255;	
    a9ae:	bf04      	itt	eq
    a9b0:	e9c3 220d 	strdeq	r2, r2, [r3, #52]	; 0x34
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = 255;	
    a9b4:	63da      	streq	r2, [r3, #60]	; 0x3c
}
    a9b6:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
    a9ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		temp[i] = eve->event_string[i];
    a9be:	f812 5b01 	ldrb.w	r5, [r2], #1
    a9c2:	f800 5b01 	strb.w	r5, [r0], #1
	for(true; i<eve->event_string_length; i++){
    a9c6:	e7d9      	b.n	a97c <grid_ui_event_render_action+0x28>
		temp[i] = eve->action_string[i - eve->event_string_length];
    a9c8:	f811 0b01 	ldrb.w	r0, [r1], #1
    a9cc:	54e0      	strb	r0, [r4, r3]
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    a9ce:	3301      	adds	r3, #1
    a9d0:	e7da      	b.n	a988 <grid_ui_event_render_action+0x34>
		target_string[i-total_substituted_length] = temp[i];
    a9d2:	f10d 0914 	add.w	r9, sp, #20
    a9d6:	9a02      	ldr	r2, [sp, #8]
    a9d8:	f819 3004 	ldrb.w	r3, [r9, r4]
    a9dc:	eba4 0805 	sub.w	r8, r4, r5
		if (temp[i] == '{'){
    a9e0:	2b7b      	cmp	r3, #123	; 0x7b
		target_string[i-total_substituted_length] = temp[i];
    a9e2:	f802 3008 	strb.w	r3, [r2, r8]
		if (temp[i] == '{'){
    a9e6:	f000 80a2 	beq.w	ab2e <grid_ui_event_render_action+0x1da>
		else if (temp[i] == '}'){
    a9ea:	2b7d      	cmp	r3, #125	; 0x7d
    a9ec:	f104 0a01 	add.w	sl, r4, #1
    a9f0:	d145      	bne.n	aa7e <grid_ui_event_render_action+0x12a>
			if (block_length){
    a9f2:	9b00      	ldr	r3, [sp, #0]
    a9f4:	ebba 0b03 	subs.w	fp, sl, r3
    a9f8:	d030      	beq.n	aa5c <grid_ui_event_render_action+0x108>
				grid_expr_set_current_event(&grid_expr_state, eve);
    a9fa:	4b4f      	ldr	r3, [pc, #316]	; (ab38 <grid_ui_event_render_action+0x1e4>)
    a9fc:	484f      	ldr	r0, [pc, #316]	; (ab3c <grid_ui_event_render_action+0x1e8>)
    a9fe:	4631      	mov	r1, r6
    aa00:	4798      	blx	r3
				grid_expr_evaluate(&grid_expr_state, &temp[block_start+1], block_length-2); // -2 to not include {
    aa02:	9b00      	ldr	r3, [sp, #0]
    aa04:	484d      	ldr	r0, [pc, #308]	; (ab3c <grid_ui_event_render_action+0x1e8>)
    aa06:	3301      	adds	r3, #1
    aa08:	f1ab 0202 	sub.w	r2, fp, #2
    aa0c:	eb09 0103 	add.w	r1, r9, r3
    aa10:	b2d2      	uxtb	r2, r2
    aa12:	f8df 9134 	ldr.w	r9, [pc, #308]	; ab48 <grid_ui_event_render_action+0x1f4>
    aa16:	9303      	str	r3, [sp, #12]
    aa18:	47c8      	blx	r9
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    aa1a:	9b03      	ldr	r3, [sp, #12]
				for (uint8_t j = 0; j<block_length; j++){
    aa1c:	2100      	movs	r1, #0
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    aa1e:	eb08 0003 	add.w	r0, r8, r3
    aa22:	eba0 0e0a 	sub.w	lr, r0, sl
    aa26:	468c      	mov	ip, r1
				for (uint8_t j = 0; j<block_length; j++){
    aa28:	b2ca      	uxtb	r2, r1
    aa2a:	4593      	cmp	fp, r2
    aa2c:	f101 0101 	add.w	r1, r1, #1
    aa30:	d816      	bhi.n	aa60 <grid_ui_event_render_action+0x10c>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    aa32:	4498      	add	r8, r3
    aa34:	9b02      	ldr	r3, [sp, #8]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    aa36:	4a41      	ldr	r2, [pc, #260]	; (ab3c <grid_ui_event_render_action+0x1e8>)
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    aa38:	eba8 0a0a 	sub.w	sl, r8, sl
    aa3c:	2000      	movs	r0, #0
    aa3e:	449a      	add	sl, r3
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    aa40:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
    aa44:	b2c1      	uxtb	r1, r0
    aa46:	428b      	cmp	r3, r1
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    aa48:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    aa4c:	d80d      	bhi.n	aa6a <grid_ui_event_render_action+0x116>
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    aa4e:	1aed      	subs	r5, r5, r3
				if (condition_state == 1){
    aa50:	9b01      	ldr	r3, [sp, #4]
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    aa52:	445d      	add	r5, fp
				if (condition_state == 1){
    aa54:	b113      	cbz	r3, aa5c <grid_ui_event_render_action+0x108>
					condition_istrue = grid_expr_state.return_value;
    aa56:	f8d2 71fc 	ldr.w	r7, [r2, #508]	; 0x1fc
    aa5a:	b2ff      	uxtb	r7, r7
	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    aa5c:	3401      	adds	r4, #1
    aa5e:	e79a      	b.n	a996 <grid_ui_event_render_action+0x42>
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    aa60:	9802      	ldr	r0, [sp, #8]
    aa62:	4402      	add	r2, r0
    aa64:	f802 c00e 	strb.w	ip, [r2, lr]
				for (uint8_t j = 0; j<block_length; j++){
    aa68:	e7de      	b.n	aa28 <grid_ui_event_render_action+0xd4>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    aa6a:	f1c3 03fa 	rsb	r3, r3, #250	; 0xfa
    aa6e:	440b      	add	r3, r1
    aa70:	4413      	add	r3, r2
    aa72:	3001      	adds	r0, #1
    aa74:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
    aa78:	f80a 3001 	strb.w	r3, [sl, r1]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    aa7c:	e7e0      	b.n	aa40 <grid_ui_event_render_action+0xec>
		else if(temp[i] == '#'){
    aa7e:	2b23      	cmp	r3, #35	; 0x23
    aa80:	d1ec      	bne.n	aa5c <grid_ui_event_render_action+0x108>
			if (temp[i+1] == 'I' && temp[i+2] == 'F' ){
    aa82:	f819 300a 	ldrb.w	r3, [r9, sl]
    aa86:	2b49      	cmp	r3, #73	; 0x49
    aa88:	d109      	bne.n	aa9e <grid_ui_event_render_action+0x14a>
    aa8a:	1ca3      	adds	r3, r4, #2
    aa8c:	f819 2003 	ldrb.w	r2, [r9, r3]
    aa90:	2a46      	cmp	r2, #70	; 0x46
    aa92:	d1e3      	bne.n	aa5c <grid_ui_event_render_action+0x108>
				i+=2;
    aa94:	461c      	mov	r4, r3
				condition_state = 1;
    aa96:	2301      	movs	r3, #1
				total_substituted_length += 3;
    aa98:	3503      	adds	r5, #3
				condition_state = 1;
    aa9a:	9301      	str	r3, [sp, #4]
    aa9c:	e7de      	b.n	aa5c <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'T' && temp[i+2] == 'H' ){
    aa9e:	2b54      	cmp	r3, #84	; 0x54
    aaa0:	d121      	bne.n	aae6 <grid_ui_event_render_action+0x192>
    aaa2:	1ca3      	adds	r3, r4, #2
    aaa4:	f819 2003 	ldrb.w	r2, [r9, r3]
    aaa8:	2a48      	cmp	r2, #72	; 0x48
    aaaa:	d1d7      	bne.n	aa5c <grid_ui_event_render_action+0x108>
				if (!condition_istrue){
    aaac:	bbaf      	cbnz	r7, ab1a <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    aaae:	f04f 0801 	mov.w	r8, #1
    aab2:	e009      	b.n	aac8 <grid_ui_event_render_action+0x174>
						else if(j==(eve->event_string_length + eve->action_string_length)-i-1){
    aab4:	3b01      	subs	r3, #1
    aab6:	4543      	cmp	r3, r8
    aab8:	d102      	bne.n	aac0 <grid_ui_event_render_action+0x16c>
							printf("Syntax Error!\r\n");
    aaba:	4821      	ldr	r0, [pc, #132]	; (ab40 <grid_ui_event_render_action+0x1ec>)
    aabc:	4b21      	ldr	r3, [pc, #132]	; (ab44 <grid_ui_event_render_action+0x1f0>)
    aabe:	4798      	blx	r3
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    aac0:	f108 0801 	add.w	r8, r8, #1
    aac4:	fa5f f888 	uxtb.w	r8, r8
    aac8:	68f3      	ldr	r3, [r6, #12]
    aaca:	6b32      	ldr	r2, [r6, #48]	; 0x30
    aacc:	4413      	add	r3, r2
    aace:	1b1b      	subs	r3, r3, r4
    aad0:	4598      	cmp	r8, r3
    aad2:	d2c3      	bcs.n	aa5c <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    aad4:	eb08 0204 	add.w	r2, r8, r4
    aad8:	f819 1002 	ldrb.w	r1, [r9, r2]
    aadc:	2923      	cmp	r1, #35	; 0x23
    aade:	d1e9      	bne.n	aab4 <grid_ui_event_render_action+0x160>
							total_substituted_length += j;
    aae0:	4445      	add	r5, r8
							i+=j-1;
    aae2:	1e54      	subs	r4, r2, #1
							break;
    aae4:	e7ba      	b.n	aa5c <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'L' ){
    aae6:	2b45      	cmp	r3, #69	; 0x45
    aae8:	d1b8      	bne.n	aa5c <grid_ui_event_render_action+0x108>
    aaea:	1ca3      	adds	r3, r4, #2
    aaec:	f819 2003 	ldrb.w	r2, [r9, r3]
    aaf0:	2a4c      	cmp	r2, #76	; 0x4c
    aaf2:	d115      	bne.n	ab20 <grid_ui_event_render_action+0x1cc>
				if (condition_istrue){
    aaf4:	b18f      	cbz	r7, ab1a <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    aaf6:	6b32      	ldr	r2, [r6, #48]	; 0x30
    aaf8:	68f3      	ldr	r3, [r6, #12]
    aafa:	4413      	add	r3, r2
    aafc:	1b1a      	subs	r2, r3, r4
    aafe:	2301      	movs	r3, #1
    ab00:	4293      	cmp	r3, r2
    ab02:	d2ab      	bcs.n	aa5c <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    ab04:	1919      	adds	r1, r3, r4
    ab06:	f819 0001 	ldrb.w	r0, [r9, r1]
    ab0a:	2823      	cmp	r0, #35	; 0x23
    ab0c:	d102      	bne.n	ab14 <grid_ui_event_render_action+0x1c0>
							total_substituted_length += j;
    ab0e:	441d      	add	r5, r3
							i+=j-1;
    ab10:	1e4c      	subs	r4, r1, #1
							break;
    ab12:	e7a3      	b.n	aa5c <grid_ui_event_render_action+0x108>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    ab14:	3301      	adds	r3, #1
    ab16:	b2db      	uxtb	r3, r3
    ab18:	e7f2      	b.n	ab00 <grid_ui_event_render_action+0x1ac>
					total_substituted_length += 3;
    ab1a:	3503      	adds	r5, #3
					i+=2;
    ab1c:	461c      	mov	r4, r3
    ab1e:	e79d      	b.n	aa5c <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'N' ){
    ab20:	2a4e      	cmp	r2, #78	; 0x4e
    ab22:	d19b      	bne.n	aa5c <grid_ui_event_render_action+0x108>
				condition_istrue = 0;
    ab24:	2700      	movs	r7, #0
				total_substituted_length += 3;
    ab26:	3503      	adds	r5, #3
				i+=2;
    ab28:	461c      	mov	r4, r3
				condition_state = 0;
    ab2a:	9701      	str	r7, [sp, #4]
    ab2c:	e796      	b.n	aa5c <grid_ui_event_render_action+0x108>
    ab2e:	9400      	str	r4, [sp, #0]
    ab30:	e794      	b.n	aa5c <grid_ui_event_render_action+0x108>
    ab32:	bf00      	nop
    ab34:	000147c5 	.word	0x000147c5
    ab38:	000067b9 	.word	0x000067b9
    ab3c:	20013220 	.word	0x20013220
    ab40:	0001663d 	.word	0x0001663d
    ab44:	00014a59 	.word	0x00014a59
    ab48:	00006f49 	.word	0x00006f49

0000ab4c <grid_port_process_ui>:
void grid_port_process_ui(struct grid_port* por){
    ab4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    ab50:	4fb1      	ldr	r7, [pc, #708]	; (ae18 <grid_port_process_ui+0x2cc>)
void grid_port_process_ui(struct grid_port* por){
    ab52:	f5ad 7d57 	sub.w	sp, sp, #860	; 0x35c
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    ab56:	2100      	movs	r1, #0
void grid_port_process_ui(struct grid_port* por){
    ab58:	9001      	str	r0, [sp, #4]
	uint8_t message_local_action_available = 0;
    ab5a:	4688      	mov	r8, r1
	uint8_t message_broadcast_action_available = 0;
    ab5c:	460d      	mov	r5, r1
    ab5e:	46ba      	mov	sl, r7
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    ab60:	f04f 0c64 	mov.w	ip, #100	; 0x64
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab64:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    ab68:	787a      	ldrb	r2, [r7, #1]
    ab6a:	b2cb      	uxtb	r3, r1
    ab6c:	429a      	cmp	r2, r3
    ab6e:	d95e      	bls.n	ac2e <grid_port_process_ui+0xe2>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    ab70:	011b      	lsls	r3, r3, #4
    ab72:	2400      	movs	r4, #0
    ab74:	e02e      	b.n	abd4 <grid_port_process_ui+0x88>
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab76:	f8da 9004 	ldr.w	r9, [sl, #4]
    ab7a:	4499      	add	r9, r3
    ab7c:	fb0e f000 	mul.w	r0, lr, r0
    ab80:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ab84:	4491      	add	r9, r2
    ab86:	3601      	adds	r6, #1
    ab88:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    ab8c:	4481      	add	r9, r0
    ab8e:	f899 9009 	ldrb.w	r9, [r9, #9]
    ab92:	f1b9 0f05 	cmp.w	r9, #5
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    ab96:	f8da 9004 	ldr.w	r9, [sl, #4]
    ab9a:	4499      	add	r9, r3
					message_broadcast_action_available++;
    ab9c:	bf08      	it	eq
    ab9e:	3501      	addeq	r5, #1
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    aba0:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    aba4:	4491      	add	r9, r2
					message_broadcast_action_available++;
    aba6:	bf08      	it	eq
    aba8:	b2ed      	uxtbeq	r5, r5
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    abaa:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    abae:	4448      	add	r0, r9
    abb0:	7a40      	ldrb	r0, [r0, #9]
    abb2:	2806      	cmp	r0, #6
                    message_local_action_available++;
    abb4:	bf04      	itt	eq
    abb6:	f108 0801 	addeq.w	r8, r8, #1
    abba:	fa5f f888 	uxtbeq.w	r8, r8
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    abbe:	f8da 0004 	ldr.w	r0, [sl, #4]
    abc2:	4418      	add	r0, r3
    abc4:	68c0      	ldr	r0, [r0, #12]
    abc6:	4410      	add	r0, r2
    abc8:	f890 905c 	ldrb.w	r9, [r0, #92]	; 0x5c
    abcc:	b2f0      	uxtb	r0, r6
    abce:	4581      	cmp	r9, r0
    abd0:	d8d1      	bhi.n	ab76 <grid_port_process_ui+0x2a>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    abd2:	3401      	adds	r4, #1
    abd4:	f8da 2004 	ldr.w	r2, [sl, #4]
    abd8:	441a      	add	r2, r3
    abda:	7a50      	ldrb	r0, [r2, #9]
    abdc:	b2e2      	uxtb	r2, r4
    abde:	4290      	cmp	r0, r2
    abe0:	d903      	bls.n	abea <grid_port_process_ui+0x9e>
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    abe2:	fb0c f202 	mul.w	r2, ip, r2
    abe6:	2600      	movs	r6, #0
    abe8:	e7e9      	b.n	abbe <grid_port_process_ui+0x72>
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    abea:	3101      	adds	r1, #1
    abec:	e7bc      	b.n	ab68 <grid_port_process_ui+0x1c>
			if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    abee:	6870      	ldr	r0, [r6, #4]
    abf0:	68c0      	ldr	r0, [r0, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    abf2:	eb00 0e03 	add.w	lr, r0, r3
    abf6:	3201      	adds	r2, #1
    abf8:	f8de 0060 	ldr.w	r0, [lr, #96]	; 0x60
    abfc:	fb0c 0009 	mla	r0, ip, r9, r0
    ac00:	7a40      	ldrb	r0, [r0, #9]
    ac02:	2805      	cmp	r0, #5
				message_broadcast_action_available++;
    ac04:	bf04      	itt	eq
    ac06:	3501      	addeq	r5, #1
    ac08:	b2ed      	uxtbeq	r5, r5
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ac0a:	6870      	ldr	r0, [r6, #4]
    ac0c:	68c0      	ldr	r0, [r0, #12]
    ac0e:	4418      	add	r0, r3
    ac10:	fa5f f982 	uxtb.w	r9, r2
    ac14:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
    ac18:	4548      	cmp	r0, r9
    ac1a:	d8e8      	bhi.n	abee <grid_port_process_ui+0xa2>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    ac1c:	3101      	adds	r1, #1
    ac1e:	6863      	ldr	r3, [r4, #4]
    ac20:	7a5a      	ldrb	r2, [r3, #9]
    ac22:	b2cb      	uxtb	r3, r1
    ac24:	429a      	cmp	r2, r3
    ac26:	d909      	bls.n	ac3c <grid_port_process_ui+0xf0>
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ac28:	437b      	muls	r3, r7
    ac2a:	2200      	movs	r2, #0
    ac2c:	e7ed      	b.n	ac0a <grid_port_process_ui+0xbe>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    ac2e:	4c7b      	ldr	r4, [pc, #492]	; (ae1c <grid_port_process_ui+0x2d0>)
    ac30:	2100      	movs	r1, #0
    ac32:	4626      	mov	r6, r4
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ac34:	2764      	movs	r7, #100	; 0x64
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ac36:	f04f 0cbc 	mov.w	ip, #188	; 0xbc
    ac3a:	e7f0      	b.n	ac1e <grid_port_process_ui+0xd2>
	struct grid_port* port[4] = {&GRID_PORT_N, &GRID_PORT_E, &GRID_PORT_S, &GRID_PORT_W};
    ac3c:	4b78      	ldr	r3, [pc, #480]	; (ae20 <grid_port_process_ui+0x2d4>)
    ac3e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    ac40:	ae07      	add	r6, sp, #28
    ac42:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    ac46:	2404      	movs	r4, #4
		if (port[k]->ping_flag == 1){
    ac48:	f856 7b04 	ldr.w	r7, [r6], #4
    ac4c:	f642 7348 	movw	r3, #12104	; 0x2f48
    ac50:	5cfb      	ldrb	r3, [r7, r3]
    ac52:	2b01      	cmp	r3, #1
    ac54:	d11f      	bne.n	ac96 <grid_port_process_ui+0x14a>
			if (grid_buffer_write_init(&port[k]->tx_buffer, port[k]->ping_packet_length)){
    ac56:	f642 7347 	movw	r3, #12103	; 0x2f47
    ac5a:	f507 591c 	add.w	r9, r7, #9984	; 0x2700
    ac5e:	f109 093c 	add.w	r9, r9, #60	; 0x3c
    ac62:	18fa      	adds	r2, r7, r3
    ac64:	5cf9      	ldrb	r1, [r7, r3]
    ac66:	4b6f      	ldr	r3, [pc, #444]	; (ae24 <grid_port_process_ui+0x2d8>)
    ac68:	9202      	str	r2, [sp, #8]
    ac6a:	4648      	mov	r0, r9
    ac6c:	4798      	blx	r3
    ac6e:	b170      	cbz	r0, ac8e <grid_port_process_ui+0x142>
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    ac70:	4b6d      	ldr	r3, [pc, #436]	; (ae28 <grid_port_process_ui+0x2dc>)
    ac72:	f507 5b3c 	add.w	fp, r7, #12032	; 0x2f00
    ac76:	f10b 0b33 	add.w	fp, fp, #51	; 0x33
    ac7a:	1bdb      	subs	r3, r3, r7
    ac7c:	9a02      	ldr	r2, [sp, #8]
    ac7e:	7811      	ldrb	r1, [r2, #0]
    ac80:	eb03 020b 	add.w	r2, r3, fp
    ac84:	4291      	cmp	r1, r2
    ac86:	d826      	bhi.n	acd6 <grid_port_process_ui+0x18a>
				grid_buffer_write_acknowledge(&port[k]->tx_buffer);
    ac88:	4b68      	ldr	r3, [pc, #416]	; (ae2c <grid_port_process_ui+0x2e0>)
    ac8a:	4648      	mov	r0, r9
    ac8c:	4798      	blx	r3
			port[k]->ping_flag = 0;
    ac8e:	f642 7248 	movw	r2, #12104	; 0x2f48
    ac92:	2300      	movs	r3, #0
    ac94:	54bb      	strb	r3, [r7, r2]
	for (uint8_t k = 0; k<4; k++){
    ac96:	3c01      	subs	r4, #1
    ac98:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    ac9c:	d1d4      	bne.n	ac48 <grid_port_process_ui+0xfc>
	if (message_local_action_available){
    ac9e:	f1b8 0f00 	cmp.w	r8, #0
    aca2:	d07e      	beq.n	ada2 <grid_port_process_ui+0x256>
		grid_msg_init(&message);
    aca4:	4b62      	ldr	r3, [pc, #392]	; (ae30 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    aca6:	4e63      	ldr	r6, [pc, #396]	; (ae34 <grid_port_process_ui+0x2e8>)
		grid_msg_init(&message);
    aca8:	a86f      	add	r0, sp, #444	; 0x1bc
    acaa:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    acac:	227f      	movs	r2, #127	; 0x7f
    acae:	4611      	mov	r1, r2
    acb0:	4623      	mov	r3, r4
    acb2:	a86f      	add	r0, sp, #444	; 0x1bc
    acb4:	47b0      	blx	r6
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};				
    acb6:	4b60      	ldr	r3, [pc, #384]	; (ae38 <grid_port_process_ui+0x2ec>)
    acb8:	940b      	str	r4, [sp, #44]	; 0x2c
    acba:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    acbe:	4621      	mov	r1, r4
    acc0:	a80c      	add	r0, sp, #48	; 0x30
    acc2:	4798      	blx	r3
		uint32_t offset=0;
    acc4:	46a0      	mov	r8, r4
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    acc6:	f89a 3001 	ldrb.w	r3, [sl, #1]
    acca:	b2e6      	uxtb	r6, r4
    accc:	42b3      	cmp	r3, r6
    acce:	d956      	bls.n	ad7e <grid_port_process_ui+0x232>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    acd0:	0136      	lsls	r6, r6, #4
    acd2:	2300      	movs	r3, #0
    acd4:	e043      	b.n	ad5e <grid_port_process_ui+0x212>
    acd6:	9303      	str	r3, [sp, #12]
					grid_buffer_write_character(&port[k]->tx_buffer, port[k]->ping_packet[i]);
    acd8:	f81b 1b01 	ldrb.w	r1, [fp], #1
    acdc:	4b57      	ldr	r3, [pc, #348]	; (ae3c <grid_port_process_ui+0x2f0>)
    acde:	4648      	mov	r0, r9
    ace0:	4798      	blx	r3
    ace2:	9b03      	ldr	r3, [sp, #12]
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    ace4:	e7ca      	b.n	ac7c <grid_port_process_ui+0x130>
					if (offset>GRID_PARAMETER_PACKET_marign){
    ace6:	f1b8 0fc8 	cmp.w	r8, #200	; 0xc8
    acea:	d829      	bhi.n	ad40 <grid_port_process_ui+0x1f4>
						CRITICAL_SECTION_ENTER()
    acec:	4b54      	ldr	r3, [pc, #336]	; (ae40 <grid_port_process_ui+0x2f4>)
    acee:	a805      	add	r0, sp, #20
    acf0:	4798      	blx	r3
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    acf2:	f8da 3004 	ldr.w	r3, [sl, #4]
    acf6:	4433      	add	r3, r6
    acf8:	22bc      	movs	r2, #188	; 0xbc
    acfa:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    acfc:	443b      	add	r3, r7
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    acfe:	fb02 fb0b 	mul.w	fp, r2, fp
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    ad02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ad04:	445b      	add	r3, fp
    ad06:	7a5b      	ldrb	r3, [r3, #9]
    ad08:	2b06      	cmp	r3, #6
    ad0a:	d116      	bne.n	ad3a <grid_port_process_ui+0x1ee>
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    ad0c:	f8da 3004 	ldr.w	r3, [sl, #4]
    ad10:	4433      	add	r3, r6
    ad12:	68db      	ldr	r3, [r3, #12]
    ad14:	443b      	add	r3, r7
    ad16:	6e18      	ldr	r0, [r3, #96]	; 0x60
    ad18:	ab0b      	add	r3, sp, #44	; 0x2c
    ad1a:	eb03 0108 	add.w	r1, r3, r8
    ad1e:	4458      	add	r0, fp
    ad20:	4b48      	ldr	r3, [pc, #288]	; (ae44 <grid_port_process_ui+0x2f8>)
    ad22:	4798      	blx	r3
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ad24:	f8da 3004 	ldr.w	r3, [sl, #4]
    ad28:	4433      	add	r3, r6
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    ad2a:	4480      	add	r8, r0
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    ad2c:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    ad2e:	443b      	add	r3, r7
    ad30:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ad32:	449b      	add	fp, r3
    ad34:	2304      	movs	r3, #4
    ad36:	f88b 3009 	strb.w	r3, [fp, #9]
						CRITICAL_SECTION_LEAVE()
    ad3a:	4b43      	ldr	r3, [pc, #268]	; (ae48 <grid_port_process_ui+0x2fc>)
    ad3c:	a805      	add	r0, sp, #20
    ad3e:	4798      	blx	r3
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    ad40:	f109 0901 	add.w	r9, r9, #1
    ad44:	f8da 3004 	ldr.w	r3, [sl, #4]
    ad48:	4433      	add	r3, r6
    ad4a:	fa5f fb89 	uxtb.w	fp, r9
    ad4e:	68db      	ldr	r3, [r3, #12]
    ad50:	443b      	add	r3, r7
    ad52:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    ad56:	455b      	cmp	r3, fp
    ad58:	d8c5      	bhi.n	ace6 <grid_port_process_ui+0x19a>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    ad5a:	9b02      	ldr	r3, [sp, #8]
    ad5c:	3301      	adds	r3, #1
    ad5e:	9302      	str	r3, [sp, #8]
    ad60:	f8da 3004 	ldr.w	r3, [sl, #4]
    ad64:	4433      	add	r3, r6
    ad66:	7a5a      	ldrb	r2, [r3, #9]
    ad68:	f89d 3008 	ldrb.w	r3, [sp, #8]
    ad6c:	429a      	cmp	r2, r3
    ad6e:	d904      	bls.n	ad7a <grid_port_process_ui+0x22e>
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    ad70:	2764      	movs	r7, #100	; 0x64
    ad72:	435f      	muls	r7, r3
    ad74:	f04f 0900 	mov.w	r9, #0
    ad78:	e7e4      	b.n	ad44 <grid_port_process_ui+0x1f8>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    ad7a:	3401      	adds	r4, #1
    ad7c:	e7a3      	b.n	acc6 <grid_port_process_ui+0x17a>
		grid_msg_body_append_text(&message, payload, offset);
    ad7e:	a90b      	add	r1, sp, #44	; 0x2c
    ad80:	4642      	mov	r2, r8
    ad82:	4b32      	ldr	r3, [pc, #200]	; (ae4c <grid_port_process_ui+0x300>)
    ad84:	a86f      	add	r0, sp, #444	; 0x1bc
    ad86:	4798      	blx	r3
		grid_msg_packet_close(&message);
    ad88:	4b31      	ldr	r3, [pc, #196]	; (ae50 <grid_port_process_ui+0x304>)
    ad8a:	a86f      	add	r0, sp, #444	; 0x1bc
    ad8c:	4798      	blx	r3
		uint32_t message_length = grid_msg_packet_get_length(&message);
    ad8e:	4b31      	ldr	r3, [pc, #196]	; (ae54 <grid_port_process_ui+0x308>)
    ad90:	a86f      	add	r0, sp, #444	; 0x1bc
    ad92:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    ad94:	4b23      	ldr	r3, [pc, #140]	; (ae24 <grid_port_process_ui+0x2d8>)
		uint32_t message_length = grid_msg_packet_get_length(&message);
    ad96:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    ad98:	b281      	uxth	r1, r0
    ad9a:	482f      	ldr	r0, [pc, #188]	; (ae58 <grid_port_process_ui+0x30c>)
    ad9c:	4798      	blx	r3
    ad9e:	2800      	cmp	r0, #0
    ada0:	d132      	bne.n	ae08 <grid_port_process_ui+0x2bc>
	if (por->cooldown > 0){
    ada2:	9b01      	ldr	r3, [sp, #4]
    ada4:	681b      	ldr	r3, [r3, #0]
    ada6:	b12b      	cbz	r3, adb4 <grid_port_process_ui+0x268>
		por->cooldown--;
    ada8:	3b01      	subs	r3, #1
    adaa:	9a01      	ldr	r2, [sp, #4]
	if (por->cooldown > 10){
    adac:	2b0a      	cmp	r3, #10
		por->cooldown--;
    adae:	6013      	str	r3, [r2, #0]
	if (por->cooldown > 10){
    adb0:	f200 80fc 	bhi.w	afac <grid_port_process_ui+0x460>
	if (message_broadcast_action_available){
    adb4:	2d00      	cmp	r5, #0
    adb6:	f000 80f9 	beq.w	afac <grid_port_process_ui+0x460>
		grid_msg_init(&message);
    adba:	4b1d      	ldr	r3, [pc, #116]	; (ae30 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    adbc:	4c1d      	ldr	r4, [pc, #116]	; (ae34 <grid_port_process_ui+0x2e8>)
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    adbe:	f8df 805c 	ldr.w	r8, [pc, #92]	; ae1c <grid_port_process_ui+0x2d0>
		grid_msg_init(&message);
    adc2:	a86f      	add	r0, sp, #444	; 0x1bc
    adc4:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    adc6:	227f      	movs	r2, #127	; 0x7f
    adc8:	2300      	movs	r3, #0
    adca:	4611      	mov	r1, r2
    adcc:	a86f      	add	r0, sp, #444	; 0x1bc
    adce:	47a0      	blx	r4
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    add0:	2700      	movs	r7, #0
    add2:	4645      	mov	r5, r8
    add4:	f8d8 3004 	ldr.w	r3, [r8, #4]
    add8:	7a5a      	ldrb	r2, [r3, #9]
    adda:	b2fb      	uxtb	r3, r7
    addc:	429a      	cmp	r2, r3
    adde:	f240 80d2 	bls.w	af86 <grid_port_process_ui+0x43a>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ade2:	2464      	movs	r4, #100	; 0x64
					CRITICAL_SECTION_LEAVE()
    ade4:	f8df b060 	ldr.w	fp, [pc, #96]	; ae48 <grid_port_process_ui+0x2fc>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    ade8:	435c      	muls	r4, r3
    adea:	2600      	movs	r6, #0
    adec:	e067      	b.n	aebe <grid_port_process_ui+0x372>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    adee:	4631      	mov	r1, r6
    adf0:	a86f      	add	r0, sp, #444	; 0x1bc
    adf2:	47b8      	blx	r7
    adf4:	4601      	mov	r1, r0
    adf6:	4640      	mov	r0, r8
    adf8:	47c8      	blx	r9
			for(uint32_t i = 0; i<message_length; i++){
    adfa:	3601      	adds	r6, #1
    adfc:	42a6      	cmp	r6, r4
    adfe:	d1f6      	bne.n	adee <grid_port_process_ui+0x2a2>
			grid_buffer_write_acknowledge(&GRID_PORT_U.tx_buffer);
    ae00:	4b0a      	ldr	r3, [pc, #40]	; (ae2c <grid_port_process_ui+0x2e0>)
    ae02:	4815      	ldr	r0, [pc, #84]	; (ae58 <grid_port_process_ui+0x30c>)
    ae04:	4798      	blx	r3
		}
    ae06:	e7cc      	b.n	ada2 <grid_port_process_ui+0x256>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    ae08:	4f14      	ldr	r7, [pc, #80]	; (ae5c <grid_port_process_ui+0x310>)
    ae0a:	f8df 804c 	ldr.w	r8, [pc, #76]	; ae58 <grid_port_process_ui+0x30c>
    ae0e:	f8df 902c 	ldr.w	r9, [pc, #44]	; ae3c <grid_port_process_ui+0x2f0>
			for(uint32_t i = 0; i<message_length; i++){
    ae12:	2600      	movs	r6, #0
    ae14:	e7f2      	b.n	adfc <grid_port_process_ui+0x2b0>
    ae16:	bf00      	nop
    ae18:	2000effc 	.word	0x2000effc
    ae1c:	2001c7c0 	.word	0x2001c7c0
    ae20:	0001664c 	.word	0x0001664c
    ae24:	000047f1 	.word	0x000047f1
    ae28:	ffffd0cd 	.word	0xffffd0cd
    ae2c:	0000484d 	.word	0x0000484d
    ae30:	0000896d 	.word	0x0000896d
    ae34:	000089a1 	.word	0x000089a1
    ae38:	000147c5 	.word	0x000147c5
    ae3c:	0000482d 	.word	0x0000482d
    ae40:	00011ef9 	.word	0x00011ef9
    ae44:	0000a955 	.word	0x0000a955
    ae48:	00011f07 	.word	0x00011f07
    ae4c:	000088dd 	.word	0x000088dd
    ae50:	00008a99 	.word	0x00008a99
    ae54:	000088c9 	.word	0x000088c9
    ae58:	2000e7ec 	.word	0x2000e7ec
    ae5c:	00008a63 	.word	0x00008a63
				if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    ae60:	4b5e      	ldr	r3, [pc, #376]	; (afdc <grid_port_process_ui+0x490>)
    ae62:	a86f      	add	r0, sp, #444	; 0x1bc
    ae64:	4798      	blx	r3
    ae66:	28c8      	cmp	r0, #200	; 0xc8
    ae68:	d828      	bhi.n	aebc <grid_port_process_ui+0x370>
					CRITICAL_SECTION_ENTER()
    ae6a:	4b5d      	ldr	r3, [pc, #372]	; (afe0 <grid_port_process_ui+0x494>)
    ae6c:	a806      	add	r0, sp, #24
    ae6e:	4798      	blx	r3
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    ae70:	686b      	ldr	r3, [r5, #4]
    ae72:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ae74:	4423      	add	r3, r4
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    ae76:	22bc      	movs	r2, #188	; 0xbc
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ae78:	6e1b      	ldr	r3, [r3, #96]	; 0x60
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    ae7a:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    ae7e:	444b      	add	r3, r9
    ae80:	7a5b      	ldrb	r3, [r3, #9]
    ae82:	2b05      	cmp	r3, #5
    ae84:	d118      	bne.n	aeb8 <grid_port_process_ui+0x36c>
						uint32_t offset = grid_msg_body_get_length(&message); 
    ae86:	4b57      	ldr	r3, [pc, #348]	; (afe4 <grid_port_process_ui+0x498>)
    ae88:	a86f      	add	r0, sp, #444	; 0x1bc
    ae8a:	4798      	blx	r3
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    ae8c:	686b      	ldr	r3, [r5, #4]
    ae8e:	68db      	ldr	r3, [r3, #12]
    ae90:	4423      	add	r3, r4
    ae92:	3014      	adds	r0, #20
    ae94:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    ae96:	aa6f      	add	r2, sp, #444	; 0x1bc
    ae98:	1811      	adds	r1, r2, r0
    ae9a:	eb03 0009 	add.w	r0, r3, r9
    ae9e:	4b52      	ldr	r3, [pc, #328]	; (afe8 <grid_port_process_ui+0x49c>)
    aea0:	4798      	blx	r3
    aea2:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    aea4:	4418      	add	r0, r3
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    aea6:	686b      	ldr	r3, [r5, #4]
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    aea8:	90d4      	str	r0, [sp, #848]	; 0x350
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    aeaa:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    aeac:	4423      	add	r3, r4
    aeae:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    aeb0:	4499      	add	r9, r3
    aeb2:	2304      	movs	r3, #4
    aeb4:	f889 3009 	strb.w	r3, [r9, #9]
					CRITICAL_SECTION_LEAVE()
    aeb8:	a806      	add	r0, sp, #24
    aeba:	47d8      	blx	fp
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    aebc:	3601      	adds	r6, #1
    aebe:	686b      	ldr	r3, [r5, #4]
    aec0:	68db      	ldr	r3, [r3, #12]
    aec2:	4423      	add	r3, r4
    aec4:	fa5f f986 	uxtb.w	r9, r6
    aec8:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    aecc:	454b      	cmp	r3, r9
    aece:	d8c7      	bhi.n	ae60 <grid_port_process_ui+0x314>
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    aed0:	3701      	adds	r7, #1
    aed2:	e77f      	b.n	add4 <grid_port_process_ui+0x288>
					if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    aed4:	4b41      	ldr	r3, [pc, #260]	; (afdc <grid_port_process_ui+0x490>)
    aed6:	a86f      	add	r0, sp, #444	; 0x1bc
    aed8:	4798      	blx	r3
    aeda:	28c8      	cmp	r0, #200	; 0xc8
    aedc:	d82e      	bhi.n	af3c <grid_port_process_ui+0x3f0>
						CRITICAL_SECTION_ENTER()
    aede:	4b40      	ldr	r3, [pc, #256]	; (afe0 <grid_port_process_ui+0x494>)
    aee0:	a80b      	add	r0, sp, #44	; 0x2c
    aee2:	4798      	blx	r3
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    aee4:	f8da 3004 	ldr.w	r3, [sl, #4]
    aee8:	4423      	add	r3, r4
    aeea:	22bc      	movs	r2, #188	; 0xbc
    aeec:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aeee:	442b      	add	r3, r5
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    aef0:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    aef4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    aef6:	444b      	add	r3, r9
    aef8:	7a5b      	ldrb	r3, [r3, #9]
    aefa:	2b05      	cmp	r3, #5
    aefc:	d11c      	bne.n	af38 <grid_port_process_ui+0x3ec>
							uint32_t offset = grid_msg_body_get_length(&message); 
    aefe:	4b39      	ldr	r3, [pc, #228]	; (afe4 <grid_port_process_ui+0x498>)
    af00:	a86f      	add	r0, sp, #444	; 0x1bc
    af02:	4798      	blx	r3
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    af04:	f8da 3004 	ldr.w	r3, [sl, #4]
    af08:	4423      	add	r3, r4
    af0a:	3014      	adds	r0, #20
    af0c:	68db      	ldr	r3, [r3, #12]
    af0e:	442b      	add	r3, r5
    af10:	aa6f      	add	r2, sp, #444	; 0x1bc
    af12:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    af14:	1811      	adds	r1, r2, r0
    af16:	eb03 0009 	add.w	r0, r3, r9
    af1a:	4b33      	ldr	r3, [pc, #204]	; (afe8 <grid_port_process_ui+0x49c>)
    af1c:	4798      	blx	r3
    af1e:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    af20:	4418      	add	r0, r3
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    af22:	f8da 3004 	ldr.w	r3, [sl, #4]
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    af26:	90d4      	str	r0, [sp, #848]	; 0x350
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    af28:	4423      	add	r3, r4
    af2a:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    af2c:	442b      	add	r3, r5
    af2e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    af30:	4499      	add	r9, r3
    af32:	2304      	movs	r3, #4
    af34:	f889 3009 	strb.w	r3, [r9, #9]
						CRITICAL_SECTION_LEAVE()
    af38:	a80b      	add	r0, sp, #44	; 0x2c
    af3a:	47d8      	blx	fp
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    af3c:	f108 0801 	add.w	r8, r8, #1
    af40:	f8da 3004 	ldr.w	r3, [sl, #4]
    af44:	4423      	add	r3, r4
    af46:	fa5f f988 	uxtb.w	r9, r8
    af4a:	68db      	ldr	r3, [r3, #12]
    af4c:	442b      	add	r3, r5
    af4e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    af52:	454b      	cmp	r3, r9
    af54:	d8be      	bhi.n	aed4 <grid_port_process_ui+0x388>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    af56:	3601      	adds	r6, #1
    af58:	f8da 3004 	ldr.w	r3, [sl, #4]
    af5c:	4423      	add	r3, r4
    af5e:	7a5a      	ldrb	r2, [r3, #9]
    af60:	b2f3      	uxtb	r3, r6
    af62:	429a      	cmp	r2, r3
    af64:	d906      	bls.n	af74 <grid_port_process_ui+0x428>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    af66:	2564      	movs	r5, #100	; 0x64
						CRITICAL_SECTION_LEAVE()
    af68:	f8df b094 	ldr.w	fp, [pc, #148]	; b000 <grid_port_process_ui+0x4b4>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    af6c:	435d      	muls	r5, r3
    af6e:	f04f 0800 	mov.w	r8, #0
    af72:	e7e5      	b.n	af40 <grid_port_process_ui+0x3f4>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    af74:	3701      	adds	r7, #1
    af76:	f89a 3001 	ldrb.w	r3, [sl, #1]
    af7a:	b2fc      	uxtb	r4, r7
    af7c:	42a3      	cmp	r3, r4
    af7e:	d904      	bls.n	af8a <grid_port_process_ui+0x43e>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    af80:	0124      	lsls	r4, r4, #4
    af82:	2600      	movs	r6, #0
    af84:	e7e8      	b.n	af58 <grid_port_process_ui+0x40c>
    af86:	2700      	movs	r7, #0
    af88:	e7f5      	b.n	af76 <grid_port_process_ui+0x42a>
		por->cooldown += 10;
    af8a:	9b01      	ldr	r3, [sp, #4]
    af8c:	9a01      	ldr	r2, [sp, #4]
    af8e:	681b      	ldr	r3, [r3, #0]
    af90:	330a      	adds	r3, #10
    af92:	6013      	str	r3, [r2, #0]
		grid_msg_packet_close(&message);
    af94:	a86f      	add	r0, sp, #444	; 0x1bc
    af96:	4b15      	ldr	r3, [pc, #84]	; (afec <grid_port_process_ui+0x4a0>)
    af98:	4798      	blx	r3
		uint32_t length = grid_msg_packet_get_length(&message);
    af9a:	4b10      	ldr	r3, [pc, #64]	; (afdc <grid_port_process_ui+0x490>)
    af9c:	a86f      	add	r0, sp, #444	; 0x1bc
    af9e:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    afa0:	4b13      	ldr	r3, [pc, #76]	; (aff0 <grid_port_process_ui+0x4a4>)
		uint32_t length = grid_msg_packet_get_length(&message);
    afa2:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    afa4:	b281      	uxth	r1, r0
    afa6:	4813      	ldr	r0, [pc, #76]	; (aff4 <grid_port_process_ui+0x4a8>)
    afa8:	4798      	blx	r3
    afaa:	b988      	cbnz	r0, afd0 <grid_port_process_ui+0x484>
}
    afac:	f50d 7d57 	add.w	sp, sp, #860	; 0x35c
    afb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    afb4:	a86f      	add	r0, sp, #444	; 0x1bc
    afb6:	47b0      	blx	r6
    afb8:	4601      	mov	r1, r0
    afba:	4638      	mov	r0, r7
    afbc:	47c0      	blx	r8
			for(uint16_t i = 0; i<length; i++){
    afbe:	b2a9      	uxth	r1, r5
    afc0:	428c      	cmp	r4, r1
    afc2:	f105 0501 	add.w	r5, r5, #1
    afc6:	d8f5      	bhi.n	afb4 <grid_port_process_ui+0x468>
			grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    afc8:	4b0b      	ldr	r3, [pc, #44]	; (aff8 <grid_port_process_ui+0x4ac>)
    afca:	480a      	ldr	r0, [pc, #40]	; (aff4 <grid_port_process_ui+0x4a8>)
    afcc:	4798      	blx	r3
		}
    afce:	e7ed      	b.n	afac <grid_port_process_ui+0x460>
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    afd0:	4e0a      	ldr	r6, [pc, #40]	; (affc <grid_port_process_ui+0x4b0>)
    afd2:	4f08      	ldr	r7, [pc, #32]	; (aff4 <grid_port_process_ui+0x4a8>)
    afd4:	f8df 802c 	ldr.w	r8, [pc, #44]	; b004 <grid_port_process_ui+0x4b8>
    afd8:	2500      	movs	r5, #0
    afda:	e7f0      	b.n	afbe <grid_port_process_ui+0x472>
    afdc:	000088c9 	.word	0x000088c9
    afe0:	00011ef9 	.word	0x00011ef9
    afe4:	000088d7 	.word	0x000088d7
    afe8:	0000a955 	.word	0x0000a955
    afec:	00008a99 	.word	0x00008a99
    aff0:	000047f1 	.word	0x000047f1
    aff4:	2000ebe4 	.word	0x2000ebe4
    aff8:	0000484d 	.word	0x0000484d
    affc:	00008a63 	.word	0x00008a63
    b000:	00011f07 	.word	0x00011f07
    b004:	0000482d 	.word	0x0000482d

0000b008 <grid_usb_serial_bulkout_cb>:
	//grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	
	//cdcdf_acm_write(cdcdf_demo_buf, count); /* Echo data */
	return false;                           /* No error. */
}
    b008:	2000      	movs	r0, #0
    b00a:	4770      	bx	lr

0000b00c <grid_usb_serial_statechange_cb>:

//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS); /* Another read */
	return false;                                                                                 /* No error. */
}
static bool grid_usb_serial_statechange_cb(usb_cdc_control_signal_t state)
{
    b00c:	b513      	push	{r0, r1, r4, lr}
	
	//grid_sys_alert_set_alert(&grid_sys_state, 0,255,255,2,300);
	
	if (state.rs232.DTR || 1) {
		/* After connection the R/W callbacks can be registered */
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    b00e:	4c06      	ldr	r4, [pc, #24]	; (b028 <grid_usb_serial_statechange_cb+0x1c>)
{
    b010:	f8ad 0004 	strh.w	r0, [sp, #4]
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    b014:	4905      	ldr	r1, [pc, #20]	; (b02c <grid_usb_serial_statechange_cb+0x20>)
    b016:	2000      	movs	r0, #0
    b018:	47a0      	blx	r4
		cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE, (FUNC_PTR)grid_usb_serial_bulkin_cb);
    b01a:	4905      	ldr	r1, [pc, #20]	; (b030 <grid_usb_serial_statechange_cb+0x24>)
    b01c:	2001      	movs	r0, #1
    b01e:	47a0      	blx	r4
		/* Start Rx */
		//cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	}
	return false; /* No error. */
}
    b020:	2000      	movs	r0, #0
    b022:	b002      	add	sp, #8
    b024:	bd10      	pop	{r4, pc}
    b026:	bf00      	nop
    b028:	0000c16d 	.word	0x0000c16d
    b02c:	0000b009 	.word	0x0000b009
    b030:	0000b085 	.word	0x0000b085

0000b034 <grid_usb_midi_bulkin_cb>:

	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
	return false;
}
static bool grid_usb_midi_bulkin_cb(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
    b034:	b513      	push	{r0, r1, r4, lr}

	grid_sys_alert_set_alert(&grid_sys_state, 255,0,255,2,300);
    b036:	2302      	movs	r3, #2
    b038:	f44f 7296 	mov.w	r2, #300	; 0x12c
    b03c:	e9cd 3200 	strd	r3, r2, [sp]
    b040:	23ff      	movs	r3, #255	; 0xff
    b042:	4804      	ldr	r0, [pc, #16]	; (b054 <grid_usb_midi_bulkin_cb+0x20>)
    b044:	4c04      	ldr	r4, [pc, #16]	; (b058 <grid_usb_midi_bulkin_cb+0x24>)
    b046:	2200      	movs	r2, #0
    b048:	4619      	mov	r1, r3
    b04a:	47a0      	blx	r4
	return false;
}
    b04c:	2000      	movs	r0, #0
    b04e:	b002      	add	sp, #8
    b050:	bd10      	pop	{r4, pc}
    b052:	bf00      	nop
    b054:	2000f008 	.word	0x2000f008
    b058:	00009bbb 	.word	0x00009bbb

0000b05c <grid_usb_midi_bulkout_cb>:
{
    b05c:	b513      	push	{r0, r1, r4, lr}
	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
    b05e:	2302      	movs	r3, #2
    b060:	f44f 7296 	mov.w	r2, #300	; 0x12c
    b064:	e9cd 3200 	strd	r3, r2, [sp]
    b068:	22ff      	movs	r2, #255	; 0xff
    b06a:	4804      	ldr	r0, [pc, #16]	; (b07c <grid_usb_midi_bulkout_cb+0x20>)
    b06c:	4c04      	ldr	r4, [pc, #16]	; (b080 <grid_usb_midi_bulkout_cb+0x24>)
    b06e:	2300      	movs	r3, #0
    b070:	4611      	mov	r1, r2
    b072:	47a0      	blx	r4
}
    b074:	2000      	movs	r0, #0
    b076:	b002      	add	sp, #8
    b078:	bd10      	pop	{r4, pc}
    b07a:	bf00      	nop
    b07c:	2000f008 	.word	0x2000f008
    b080:	00009bbb 	.word	0x00009bbb

0000b084 <grid_usb_serial_bulkin_cb>:
    b084:	2000      	movs	r0, #0
    b086:	4770      	bx	lr

0000b088 <grid_usb_serial_init>:
	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)grid_usb_serial_statechange_cb);
    b088:	4901      	ldr	r1, [pc, #4]	; (b090 <grid_usb_serial_init+0x8>)
    b08a:	4b02      	ldr	r3, [pc, #8]	; (b094 <grid_usb_serial_init+0xc>)
    b08c:	2003      	movs	r0, #3
    b08e:	4718      	bx	r3
    b090:	0000b00d 	.word	0x0000b00d
    b094:	0000c16d 	.word	0x0000c16d

0000b098 <grid_keyboard_cleanup>:
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
	
	uint8_t changed_flag = 0;
	
	// Remove all inactive (released) keys
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b098:	2300      	movs	r3, #0
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    b09a:	b5f0      	push	{r4, r5, r6, r7, lr}
			
			changed_flag = 1;
			
			kb->key_list[i].ismodifier = 0;
			kb->key_list[i].ispressed = 0;
			kb->key_list[i].keycode = 255;	
    b09c:	f04f 0cff 	mov.w	ip, #255	; 0xff
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    b0a0:	4604      	mov	r4, r0
			// Pop item, move each remaining after this forvard one index
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
				
				kb->key_list[j-1] = kb->key_list[j];
				
				kb->key_list[j].ismodifier = 0;
    b0a2:	469e      	mov	lr, r3
	uint8_t changed_flag = 0;
    b0a4:	4618      	mov	r0, r3
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b0a6:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    b0aa:	429d      	cmp	r5, r3
    b0ac:	d800      	bhi.n	b0b0 <grid_keyboard_cleanup+0x18>
		// USB SEND
	}
	
	return changed_flag;
	
}
    b0ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (kb->key_list[i].ispressed == false){
    b0b0:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    b0b4:	7d8f      	ldrb	r7, [r1, #22]
    b0b6:	b98f      	cbnz	r7, b0dc <grid_keyboard_cleanup+0x44>
    b0b8:	1c5a      	adds	r2, r3, #1
    b0ba:	b2d6      	uxtb	r6, r2
			kb->key_list[i].ismodifier = 0;
    b0bc:	754f      	strb	r7, [r1, #21]
			kb->key_list[i].ispressed = 0;
    b0be:	758f      	strb	r7, [r1, #22]
			kb->key_list[i].keycode = 255;	
    b0c0:	f881 c014 	strb.w	ip, [r1, #20]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b0c4:	eb04 02c6 	add.w	r2, r4, r6, lsl #3
    b0c8:	42b5      	cmp	r5, r6
    b0ca:	f102 0208 	add.w	r2, r2, #8
    b0ce:	d108      	bne.n	b0e2 <grid_keyboard_cleanup+0x4a>
			kb->key_active_count--;
    b0d0:	3d01      	subs	r5, #1
			i--; // Retest this index, because it now points to a new item
    b0d2:	3b01      	subs	r3, #1
			kb->key_active_count--;
    b0d4:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
			i--; // Retest this index, because it now points to a new item
    b0d8:	b2db      	uxtb	r3, r3
			changed_flag = 1;
    b0da:	2001      	movs	r0, #1
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b0dc:	3301      	adds	r3, #1
    b0de:	b2db      	uxtb	r3, r3
    b0e0:	e7e1      	b.n	b0a6 <grid_keyboard_cleanup+0xe>
				kb->key_list[j-1] = kb->key_list[j];
    b0e2:	e9d2 0103 	ldrd	r0, r1, [r2, #12]
    b0e6:	1d17      	adds	r7, r2, #4
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b0e8:	3601      	adds	r6, #1
				kb->key_list[j-1] = kb->key_list[j];
    b0ea:	e887 0003 	stmia.w	r7, {r0, r1}
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b0ee:	b2f6      	uxtb	r6, r6
				kb->key_list[j].ismodifier = 0;
    b0f0:	f882 e00d 	strb.w	lr, [r2, #13]
				kb->key_list[j].ispressed = 0;
    b0f4:	f882 e00e 	strb.w	lr, [r2, #14]
				kb->key_list[j].keycode = 255;
    b0f8:	f882 c00c 	strb.w	ip, [r2, #12]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b0fc:	e7e4      	b.n	b0c8 <grid_keyboard_cleanup+0x30>
	...

0000b100 <grid_keyboard_keychange>:


uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    b100:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b104:	4604      	mov	r4, r0
	uint8_t item_index = 255;
	uint8_t remove_flag = 0;
	uint8_t changed_flag = 0;
	

	grid_keyboard_cleanup(kb);
    b106:	f8df 814c 	ldr.w	r8, [pc, #332]	; b254 <grid_keyboard_keychange+0x154>
uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    b10a:	b0ec      	sub	sp, #432	; 0x1b0
    b10c:	460d      	mov	r5, r1
	grid_keyboard_cleanup(kb);
    b10e:	47c0      	blx	r8
	

	for(uint8_t i=0; i<kb->key_active_count; i++){
    b110:	2200      	movs	r2, #0
    b112:	f894 c044 	ldrb.w	ip, [r4, #68]	; 0x44
    b116:	4626      	mov	r6, r4
    b118:	4623      	mov	r3, r4
	uint8_t changed_flag = 0;
    b11a:	4691      	mov	r9, r2
	uint8_t item_index = 255;
    b11c:	27ff      	movs	r7, #255	; 0xff
				if (key->ispressed == true){
					// OK nothing to do here
				}
				else{
					// Release the damn key
					kb->key_list[i].ispressed = false;
    b11e:	4696      	mov	lr, r2
    b120:	b2d1      	uxtb	r1, r2
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b122:	458c      	cmp	ip, r1
    b124:	d82e      	bhi.n	b184 <grid_keyboard_keychange+0x84>
		}
		
	}
	
	
	uint8_t print_happened = grid_keyboard_cleanup(kb);
    b126:	4620      	mov	r0, r4
    b128:	47c0      	blx	r8
	
	
	if (item_index == 255){
    b12a:	2fff      	cmp	r7, #255	; 0xff
    b12c:	d143      	bne.n	b1b6 <grid_keyboard_keychange+0xb6>
		
		// item not in list
		
		if (kb->key_active_count< GRID_KEYBOARD_KEY_maxcount){
    b12e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    b132:	2b05      	cmp	r3, #5
    b134:	d83f      	bhi.n	b1b6 <grid_keyboard_keychange+0xb6>
			
			if (key->ispressed == true){
    b136:	78aa      	ldrb	r2, [r5, #2]
    b138:	2a01      	cmp	r2, #1
    b13a:	d13c      	bne.n	b1b6 <grid_keyboard_keychange+0xb6>
				
				kb->key_list[kb->key_active_count] = *key;
    b13c:	e895 0003 	ldmia.w	r5, {r0, r1}
    b140:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    b144:	3214      	adds	r2, #20
				kb->key_active_count++;
    b146:	3301      	adds	r3, #1
				kb->key_list[kb->key_active_count] = *key;
    b148:	e882 0003 	stmia.w	r2, {r0, r1}
				kb->key_active_count++;
    b14c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		}
		
	}
	
	
	if (changed_flag == 1){
    b150:	f104 0112 	add.w	r1, r4, #18
	uint8_t item_index = 255;
    b154:	4623      	mov	r3, r4
//		}
			
		
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
		
			kb->hid_key_array[i].b_modifier = kb->key_list[i].ismodifier;
    b156:	7d72      	ldrb	r2, [r6, #21]
    b158:	3a00      	subs	r2, #0
    b15a:	bf18      	it	ne
    b15c:	2201      	movne	r2, #1
    b15e:	705a      	strb	r2, [r3, #1]
			kb->hid_key_array[i].key_id = kb->key_list[i].keycode;
    b160:	7d32      	ldrb	r2, [r6, #20]
    b162:	701a      	strb	r2, [r3, #0]
			kb->hid_key_array[i].state = kb->key_list[i].ispressed;
    b164:	7db2      	ldrb	r2, [r6, #22]
    b166:	709a      	strb	r2, [r3, #2]
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
    b168:	3303      	adds	r3, #3
    b16a:	428b      	cmp	r3, r1
    b16c:	f106 0608 	add.w	r6, r6, #8
    b170:	d1f1      	bne.n	b156 <grid_keyboard_keychange+0x56>
		
		}
        
        
        if (kb->isenabled){
    b172:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    b176:	b325      	cbz	r5, b1c2 <grid_keyboard_keychange+0xc2>
            
            
    		hiddf_keyboard_keys_state_change(kb->hid_key_array, kb->key_active_count);    
    b178:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    b17c:	4b2b      	ldr	r3, [pc, #172]	; (b22c <grid_keyboard_keychange+0x12c>)
    b17e:	4620      	mov	r0, r4
    b180:	4798      	blx	r3
    b182:	e01b      	b.n	b1bc <grid_keyboard_keychange+0xbc>
		if (kb->key_list[i].keycode == key->keycode && kb->key_list[i].ismodifier == key->ismodifier){
    b184:	f893 a014 	ldrb.w	sl, [r3, #20]
    b188:	7828      	ldrb	r0, [r5, #0]
    b18a:	4582      	cmp	sl, r0
    b18c:	d111      	bne.n	b1b2 <grid_keyboard_keychange+0xb2>
    b18e:	f893 a015 	ldrb.w	sl, [r3, #21]
    b192:	7868      	ldrb	r0, [r5, #1]
    b194:	4582      	cmp	sl, r0
    b196:	d10c      	bne.n	b1b2 <grid_keyboard_keychange+0xb2>
			if (kb->key_list[i].ispressed == true){
    b198:	7d98      	ldrb	r0, [r3, #22]
    b19a:	2801      	cmp	r0, #1
    b19c:	d105      	bne.n	b1aa <grid_keyboard_keychange+0xaa>
				if (key->ispressed == true){
    b19e:	78af      	ldrb	r7, [r5, #2]
    b1a0:	2f01      	cmp	r7, #1
    b1a2:	d002      	beq.n	b1aa <grid_keyboard_keychange+0xaa>
					kb->key_list[i].ispressed = false;
    b1a4:	f883 e016 	strb.w	lr, [r3, #22]
					changed_flag = 1;
    b1a8:	4681      	mov	r9, r0
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b1aa:	3201      	adds	r2, #1
    b1ac:	3308      	adds	r3, #8
	uint8_t item_index = 255;
    b1ae:	460f      	mov	r7, r1
    b1b0:	e7b6      	b.n	b120 <grid_keyboard_keychange+0x20>
    b1b2:	4639      	mov	r1, r7
    b1b4:	e7f9      	b.n	b1aa <grid_keyboard_keychange+0xaa>
	if (changed_flag == 1){
    b1b6:	f1b9 0f00 	cmp.w	r9, #0
    b1ba:	d1c9      	bne.n	b150 <grid_keyboard_keychange+0x50>
		
		
		// USB SEND
	}
	
}
    b1bc:	b06c      	add	sp, #432	; 0x1b0
    b1be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            grid_msg_init(&response);
    b1c2:	a805      	add	r0, sp, #20
    b1c4:	4b1a      	ldr	r3, [pc, #104]	; (b230 <grid_keyboard_keychange+0x130>)
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b1c6:	4e1b      	ldr	r6, [pc, #108]	; (b234 <grid_keyboard_keychange+0x134>)
            grid_msg_init(&response);
    b1c8:	4798      	blx	r3
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b1ca:	227f      	movs	r2, #127	; 0x7f
    b1cc:	462b      	mov	r3, r5
    b1ce:	4611      	mov	r1, r2
    b1d0:	a805      	add	r0, sp, #20
    b1d2:	47b0      	blx	r6
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    b1d4:	2303      	movs	r3, #3
    b1d6:	4918      	ldr	r1, [pc, #96]	; (b238 <grid_keyboard_keychange+0x138>)
    b1d8:	9300      	str	r3, [sp, #0]
    b1da:	2202      	movs	r2, #2
    b1dc:	4e17      	ldr	r6, [pc, #92]	; (b23c <grid_keyboard_keychange+0x13c>)
            uint8_t response_payload[10] = {0};
    b1de:	f8ad 5010 	strh.w	r5, [sp, #16]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    b1e2:	2392      	movs	r3, #146	; 0x92
    b1e4:	a802      	add	r0, sp, #8
            uint8_t response_payload[10] = {0};
    b1e6:	e9cd 5502 	strd	r5, r5, [sp, #8]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    b1ea:	47b0      	blx	r6
            grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    b1ec:	4b14      	ldr	r3, [pc, #80]	; (b240 <grid_keyboard_keychange+0x140>)
    b1ee:	a802      	add	r0, sp, #8
    b1f0:	4798      	blx	r3
    b1f2:	a902      	add	r1, sp, #8
    b1f4:	4602      	mov	r2, r0
    b1f6:	4b13      	ldr	r3, [pc, #76]	; (b244 <grid_keyboard_keychange+0x144>)
    b1f8:	a805      	add	r0, sp, #20
    b1fa:	4798      	blx	r3
            grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, kb->isenabled);
    b1fc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    b200:	9300      	str	r3, [sp, #0]
    b202:	4c11      	ldr	r4, [pc, #68]	; (b248 <grid_keyboard_keychange+0x148>)
    b204:	4629      	mov	r1, r5
    b206:	a805      	add	r0, sp, #20
    b208:	2302      	movs	r3, #2
    b20a:	2205      	movs	r2, #5
    b20c:	47a0      	blx	r4
            grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    b20e:	230d      	movs	r3, #13
    b210:	9300      	str	r3, [sp, #0]
    b212:	2204      	movs	r2, #4
    b214:	4629      	mov	r1, r5
    b216:	a805      	add	r0, sp, #20
    b218:	2301      	movs	r3, #1
    b21a:	47a0      	blx	r4
            grid_msg_packet_close(&response);
    b21c:	4b0b      	ldr	r3, [pc, #44]	; (b24c <grid_keyboard_keychange+0x14c>)
    b21e:	a805      	add	r0, sp, #20
    b220:	4798      	blx	r3
            grid_msg_packet_send_everywhere(&response);
    b222:	4b0b      	ldr	r3, [pc, #44]	; (b250 <grid_keyboard_keychange+0x150>)
    b224:	a805      	add	r0, sp, #20
    b226:	4798      	blx	r3
    b228:	e7c8      	b.n	b1bc <grid_keyboard_keychange+0xbc>
    b22a:	bf00      	nop
    b22c:	0000ee71 	.word	0x0000ee71
    b230:	0000896d 	.word	0x0000896d
    b234:	000089a1 	.word	0x000089a1
    b238:	00015fe0 	.word	0x00015fe0
    b23c:	00014c8d 	.word	0x00014c8d
    b240:	00014d0b 	.word	0x00014d0b
    b244:	000088dd 	.word	0x000088dd
    b248:	00008951 	.word	0x00008951
    b24c:	00008a99 	.word	0x00008a99
    b250:	00008b6d 	.word	0x00008b6d
    b254:	0000b099 	.word	0x0000b099

0000b258 <grid_midi_buffer_init>:



void grid_midi_buffer_init(struct grid_midi_event_desc* buf, uint16_t length){
    b258:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    b25a:	2300      	movs	r3, #0
	{
		buf[i].byte0 = 0;
    b25c:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    b25e:	b29c      	uxth	r4, r3
    b260:	42a1      	cmp	r1, r4
    b262:	f100 0004 	add.w	r0, r0, #4
    b266:	d800      	bhi.n	b26a <grid_midi_buffer_init+0x12>
		buf[i].byte1 = 0;
		buf[i].byte2 = 0;
		buf[i].byte3 = 0;
	}
	
}
    b268:	bd10      	pop	{r4, pc}
		buf[i].byte0 = 0;
    b26a:	f800 2c04 	strb.w	r2, [r0, #-4]
		buf[i].byte1 = 0;
    b26e:	f800 2c03 	strb.w	r2, [r0, #-3]
		buf[i].byte2 = 0;
    b272:	f800 2c02 	strb.w	r2, [r0, #-2]
		buf[i].byte3 = 0;
    b276:	f800 2c01 	strb.w	r2, [r0, #-1]
	for (uint16_t i=0; i<length; i++)
    b27a:	3301      	adds	r3, #1
    b27c:	e7ef      	b.n	b25e <grid_midi_buffer_init+0x6>
	...

0000b280 <grid_usb_midi_init>:
	grid_midi_tx_write_index = 0;
    b280:	4b0a      	ldr	r3, [pc, #40]	; (b2ac <grid_usb_midi_init+0x2c>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    b282:	480b      	ldr	r0, [pc, #44]	; (b2b0 <grid_usb_midi_init+0x30>)
{
    b284:	b510      	push	{r4, lr}
	grid_midi_tx_write_index = 0;
    b286:	2400      	movs	r4, #0
    b288:	801c      	strh	r4, [r3, #0]
	grid_midi_tx_read_index = 0;
    b28a:	4b0a      	ldr	r3, [pc, #40]	; (b2b4 <grid_usb_midi_init+0x34>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    b28c:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_midi_tx_read_index = 0;
    b290:	801c      	strh	r4, [r3, #0]
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    b292:	4b09      	ldr	r3, [pc, #36]	; (b2b8 <grid_usb_midi_init+0x38>)
    b294:	4798      	blx	r3
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_READ, (FUNC_PTR)grid_usb_midi_bulkout_cb);
    b296:	4620      	mov	r0, r4
    b298:	4c08      	ldr	r4, [pc, #32]	; (b2bc <grid_usb_midi_init+0x3c>)
    b29a:	4909      	ldr	r1, [pc, #36]	; (b2c0 <grid_usb_midi_init+0x40>)
    b29c:	47a0      	blx	r4
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    b29e:	4623      	mov	r3, r4
    b2a0:	4908      	ldr	r1, [pc, #32]	; (b2c4 <grid_usb_midi_init+0x44>)
}
    b2a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    b2a6:	2001      	movs	r0, #1
    b2a8:	4718      	bx	r3
    b2aa:	bf00      	nop
    b2ac:	2000c0a4 	.word	0x2000c0a4
    b2b0:	20013420 	.word	0x20013420
    b2b4:	20010260 	.word	0x20010260
    b2b8:	0000b259 	.word	0x0000b259
    b2bc:	0000453d 	.word	0x0000453d
    b2c0:	0000b05d 	.word	0x0000b05d
    b2c4:	0000b035 	.word	0x0000b035

0000b2c8 <grid_midi_tx_push>:

uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){


	grid_midi_tx_buffer[grid_midi_tx_write_index] = midi_event;
    b2c8:	4907      	ldr	r1, [pc, #28]	; (b2e8 <grid_midi_tx_push+0x20>)
    b2ca:	4a08      	ldr	r2, [pc, #32]	; (b2ec <grid_midi_tx_push+0x24>)
    b2cc:	880b      	ldrh	r3, [r1, #0]
    b2ce:	f842 0023 	str.w	r0, [r2, r3, lsl #2]

	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    b2d2:	f44f 7096 	mov.w	r0, #300	; 0x12c
    b2d6:	3301      	adds	r3, #1
uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){
    b2d8:	b082      	sub	sp, #8
	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    b2da:	fbb3 f2f0 	udiv	r2, r3, r0
    b2de:	fb00 3312 	mls	r3, r0, r2, r3
    b2e2:	800b      	strh	r3, [r1, #0]




}
    b2e4:	b002      	add	sp, #8
    b2e6:	4770      	bx	lr
    b2e8:	2000c0a4 	.word	0x2000c0a4
    b2ec:	20013420 	.word	0x20013420

0000b2f0 <grid_midi_tx_pop>:

uint8_t grid_midi_tx_pop(){
    b2f0:	b538      	push	{r3, r4, r5, lr}

	if (grid_midi_tx_read_index != grid_midi_tx_write_index){
    b2f2:	4c0f      	ldr	r4, [pc, #60]	; (b330 <grid_midi_tx_pop+0x40>)
    b2f4:	4b0f      	ldr	r3, [pc, #60]	; (b334 <grid_midi_tx_pop+0x44>)
    b2f6:	8822      	ldrh	r2, [r4, #0]
    b2f8:	881b      	ldrh	r3, [r3, #0]
    b2fa:	429a      	cmp	r2, r3
    b2fc:	d017      	beq.n	b32e <grid_midi_tx_pop+0x3e>
		
		if (audiodf_midi_write_status() != USB_BUSY){
    b2fe:	4b0e      	ldr	r3, [pc, #56]	; (b338 <grid_midi_tx_pop+0x48>)
    b300:	4798      	blx	r3
    b302:	2801      	cmp	r0, #1
    b304:	d013      	beq.n	b32e <grid_midi_tx_pop+0x3e>

			uint8_t byte0 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte0;
    b306:	8825      	ldrh	r5, [r4, #0]
			uint8_t byte1 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte1;
			uint8_t byte2 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte2;
			uint8_t byte3 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte3;
    b308:	480c      	ldr	r0, [pc, #48]	; (b33c <grid_midi_tx_pop+0x4c>)
    b30a:	eb00 0185 	add.w	r1, r0, r5, lsl #2
			
			audiodf_midi_write(byte0, byte1, byte2, byte3);
    b30e:	f810 0025 	ldrb.w	r0, [r0, r5, lsl #2]
    b312:	78cb      	ldrb	r3, [r1, #3]
    b314:	788a      	ldrb	r2, [r1, #2]
    b316:	4d0a      	ldr	r5, [pc, #40]	; (b340 <grid_midi_tx_pop+0x50>)
    b318:	7849      	ldrb	r1, [r1, #1]
    b31a:	47a8      	blx	r5

			grid_midi_tx_read_index = (grid_midi_tx_read_index+1)%GRID_MIDI_TX_BUFFER_length;
    b31c:	8823      	ldrh	r3, [r4, #0]
    b31e:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b322:	3301      	adds	r3, #1
    b324:	fbb3 f2f1 	udiv	r2, r3, r1
    b328:	fb01 3312 	mls	r3, r1, r2, r3
    b32c:	8023      	strh	r3, [r4, #0]

		}
		
	}

}
    b32e:	bd38      	pop	{r3, r4, r5, pc}
    b330:	20010260 	.word	0x20010260
    b334:	2000c0a4 	.word	0x2000c0a4
    b338:	00004501 	.word	0x00004501
    b33c:	20013420 	.word	0x20013420
    b340:	000044d9 	.word	0x000044d9

0000b344 <grid_keyboard_buffer_init>:


void grid_keyboard_buffer_init(struct grid_keyboard_event_desc* buf, uint16_t length){
    b344:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    b346:	2300      	movs	r3, #0
	{
		buf[i].ismodifier = 0;
    b348:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    b34a:	b29c      	uxth	r4, r3
    b34c:	42a1      	cmp	r1, r4
    b34e:	f100 0008 	add.w	r0, r0, #8
    b352:	d800      	bhi.n	b356 <grid_keyboard_buffer_init+0x12>
		buf[i].keycode = 0;
		buf[i].ispressed = 0;
		buf[i].delay = 0;
	}
	
}
    b354:	bd10      	pop	{r4, pc}
		buf[i].ismodifier = 0;
    b356:	f800 2c07 	strb.w	r2, [r0, #-7]
		buf[i].keycode = 0;
    b35a:	f800 2c08 	strb.w	r2, [r0, #-8]
		buf[i].ispressed = 0;
    b35e:	f800 2c06 	strb.w	r2, [r0, #-6]
		buf[i].delay = 0;
    b362:	f840 2c04 	str.w	r2, [r0, #-4]
	for (uint16_t i=0; i<length; i++)
    b366:	3301      	adds	r3, #1
    b368:	e7ef      	b.n	b34a <grid_keyboard_buffer_init+0x6>
	...

0000b36c <grid_keyboard_init>:
void grid_keyboard_init(struct grid_keyboard_model* kb){
    b36c:	b570      	push	{r4, r5, r6, lr}
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b36e:	4b13      	ldr	r3, [pc, #76]	; (b3bc <grid_keyboard_init+0x50>)
void grid_keyboard_init(struct grid_keyboard_model* kb){
    b370:	4605      	mov	r5, r0
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b372:	4813      	ldr	r0, [pc, #76]	; (b3c0 <grid_keyboard_init+0x54>)
    b374:	4798      	blx	r3
    b376:	4b13      	ldr	r3, [pc, #76]	; (b3c4 <grid_keyboard_init+0x58>)
    b378:	6018      	str	r0, [r3, #0]
    grid_keyboard_tx_write_index = 0;
    b37a:	4b13      	ldr	r3, [pc, #76]	; (b3c8 <grid_keyboard_init+0x5c>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b37c:	4813      	ldr	r0, [pc, #76]	; (b3cc <grid_keyboard_init+0x60>)
    grid_keyboard_tx_write_index = 0;
    b37e:	2400      	movs	r4, #0
    b380:	801c      	strh	r4, [r3, #0]
	grid_keyboard_tx_read_index = 0;
    b382:	4b13      	ldr	r3, [pc, #76]	; (b3d0 <grid_keyboard_init+0x64>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b384:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_keyboard_tx_read_index = 0;
    b388:	801c      	strh	r4, [r3, #0]
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b38a:	4b12      	ldr	r3, [pc, #72]	; (b3d4 <grid_keyboard_init+0x68>)
    b38c:	4798      	blx	r3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b38e:	f105 0612 	add.w	r6, r5, #18
    b392:	462a      	mov	r2, r5
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b394:	4629      	mov	r1, r5
		kb->hid_key_array[i].b_modifier = false;
    b396:	4623      	mov	r3, r4
		kb->hid_key_array[i].key_id = 255;
    b398:	20ff      	movs	r0, #255	; 0xff
		kb->hid_key_array[i].b_modifier = false;
    b39a:	7053      	strb	r3, [r2, #1]
		kb->hid_key_array[i].key_id = 255;
    b39c:	7010      	strb	r0, [r2, #0]
		kb->hid_key_array[i].state = HID_KB_KEY_UP;
    b39e:	7093      	strb	r3, [r2, #2]
		kb->key_list[i].ismodifier = 0;
    b3a0:	3203      	adds	r2, #3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b3a2:	42b2      	cmp	r2, r6
		kb->key_list[i].ismodifier = 0;
    b3a4:	754b      	strb	r3, [r1, #21]
		kb->key_list[i].ispressed = 0;
    b3a6:	758b      	strb	r3, [r1, #22]
		kb->key_list[i].keycode = 255;
    b3a8:	7508      	strb	r0, [r1, #20]
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b3aa:	f101 0108 	add.w	r1, r1, #8
    b3ae:	d1f4      	bne.n	b39a <grid_keyboard_init+0x2e>
	kb->key_active_count = 0;
    b3b0:	f44f 7380 	mov.w	r3, #256	; 0x100
    b3b4:	f8a5 3044 	strh.w	r3, [r5, #68]	; 0x44
}
    b3b8:	bd70      	pop	{r4, r5, r6, pc}
    b3ba:	bf00      	nop
    b3bc:	00009b51 	.word	0x00009b51
    b3c0:	2000f008 	.word	0x2000f008
    b3c4:	2001c7cc 	.word	0x2001c7cc
    b3c8:	2000f0b8 	.word	0x2000f0b8
    b3cc:	2000f0bc 	.word	0x2000f0bc
    b3d0:	200102ac 	.word	0x200102ac
    b3d4:	0000b345 	.word	0x0000b345

0000b3d8 <grid_keyboard_tx_push>:

uint8_t grid_keyboard_tx_push(struct grid_keyboard_event_desc keyboard_event){
    b3d8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b3da:	466c      	mov	r4, sp
    b3dc:	e884 0003 	stmia.w	r4, {r0, r1}


	grid_keyboard_tx_buffer[grid_keyboard_tx_write_index] = keyboard_event;
    b3e0:	4d09      	ldr	r5, [pc, #36]	; (b408 <grid_keyboard_tx_push+0x30>)
    b3e2:	4a0a      	ldr	r2, [pc, #40]	; (b40c <grid_keyboard_tx_push+0x34>)
    b3e4:	882b      	ldrh	r3, [r5, #0]
    b3e6:	e894 0003 	ldmia.w	r4, {r0, r1}
    b3ea:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    b3ee:	e882 0003 	stmia.w	r2, {r0, r1}

	grid_keyboard_tx_write_index = (grid_keyboard_tx_write_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b3f2:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b3f6:	3301      	adds	r3, #1
    b3f8:	fbb3 f2f1 	udiv	r2, r3, r1
    b3fc:	fb01 3312 	mls	r3, r1, r2, r3
    b400:	802b      	strh	r3, [r5, #0]



}
    b402:	b003      	add	sp, #12
    b404:	bd30      	pop	{r4, r5, pc}
    b406:	bf00      	nop
    b408:	2000f0b8 	.word	0x2000f0b8
    b40c:	2000f0bc 	.word	0x2000f0bc

0000b410 <grid_keyboard_tx_pop>:

uint8_t grid_keyboard_tx_pop(){
    b410:	b573      	push	{r0, r1, r4, r5, r6, lr}

	if (grid_keyboard_tx_read_index != grid_keyboard_tx_write_index){
    b412:	4b17      	ldr	r3, [pc, #92]	; (b470 <grid_keyboard_tx_pop+0x60>)
    b414:	4c17      	ldr	r4, [pc, #92]	; (b474 <grid_keyboard_tx_pop+0x64>)
    b416:	881b      	ldrh	r3, [r3, #0]
    b418:	8822      	ldrh	r2, [r4, #0]
    b41a:	429a      	cmp	r2, r3
    b41c:	d026      	beq.n	b46c <grid_keyboard_tx_pop+0x5c>
		
        
        
        uint32_t elapsed = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_keyboard_tx_rtc_lasttimestamp);
    b41e:	4d16      	ldr	r5, [pc, #88]	; (b478 <grid_keyboard_tx_pop+0x68>)
    b420:	4b16      	ldr	r3, [pc, #88]	; (b47c <grid_keyboard_tx_pop+0x6c>)
    b422:	6829      	ldr	r1, [r5, #0]
    b424:	4816      	ldr	r0, [pc, #88]	; (b480 <grid_keyboard_tx_pop+0x70>)
    b426:	4798      	blx	r3
        
        
		if (elapsed > grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].delay*RTC1MS){
    b428:	8822      	ldrh	r2, [r4, #0]
    b42a:	4b16      	ldr	r3, [pc, #88]	; (b484 <grid_keyboard_tx_pop+0x74>)
    b42c:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    b430:	684e      	ldr	r6, [r1, #4]
    b432:	ebb0 1f06 	cmp.w	r0, r6, lsl #4
    b436:	d919      	bls.n	b46c <grid_keyboard_tx_pop+0x5c>
            
            struct grid_keyboard_event_desc key;
            
            key.ismodifier = grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ismodifier;
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b438:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b43c:	7889      	ldrb	r1, [r1, #2]
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b43e:	f8ad 3000 	strh.w	r3, [sp]
            key.delay = 0;
    b442:	2300      	movs	r3, #0
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b444:	f88d 1002 	strb.w	r1, [sp, #2]
            key.delay = 0;
    b448:	9301      	str	r3, [sp, #4]
            
                  
            //grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 50);
            
            grid_keyboard_keychange(&grid_keyboard_state, &key);
    b44a:	4669      	mov	r1, sp
    b44c:	4b0e      	ldr	r3, [pc, #56]	; (b488 <grid_keyboard_tx_pop+0x78>)
    b44e:	480f      	ldr	r0, [pc, #60]	; (b48c <grid_keyboard_tx_pop+0x7c>)
    b450:	4798      	blx	r3

			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b452:	8823      	ldrh	r3, [r4, #0]
            
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b454:	480a      	ldr	r0, [pc, #40]	; (b480 <grid_keyboard_tx_pop+0x70>)
			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b456:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b45a:	3301      	adds	r3, #1
    b45c:	fbb3 f2f1 	udiv	r2, r3, r1
    b460:	fb01 3312 	mls	r3, r1, r2, r3
    b464:	8023      	strh	r3, [r4, #0]
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b466:	4b0a      	ldr	r3, [pc, #40]	; (b490 <grid_keyboard_tx_pop+0x80>)
    b468:	4798      	blx	r3
    b46a:	6028      	str	r0, [r5, #0]

		}
		
	}

}
    b46c:	b002      	add	sp, #8
    b46e:	bd70      	pop	{r4, r5, r6, pc}
    b470:	2000f0b8 	.word	0x2000f0b8
    b474:	200102ac 	.word	0x200102ac
    b478:	2001c7cc 	.word	0x2001c7cc
    b47c:	00009b55 	.word	0x00009b55
    b480:	2000f008 	.word	0x2000f008
    b484:	2000f0bc 	.word	0x2000f0bc
    b488:	0000b101 	.word	0x0000b101
    b48c:	20010264 	.word	0x20010264
    b490:	00009b51 	.word	0x00009b51

0000b494 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    b494:	b570      	push	{r4, r5, r6, lr}
    b496:	460d      	mov	r5, r1
    b498:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b49a:	4604      	mov	r4, r0
    b49c:	b110      	cbz	r0, b4a4 <io_write+0x10>
    b49e:	1e08      	subs	r0, r1, #0
    b4a0:	bf18      	it	ne
    b4a2:	2001      	movne	r0, #1
    b4a4:	4905      	ldr	r1, [pc, #20]	; (b4bc <io_write+0x28>)
    b4a6:	4b06      	ldr	r3, [pc, #24]	; (b4c0 <io_write+0x2c>)
    b4a8:	2234      	movs	r2, #52	; 0x34
    b4aa:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    b4ac:	6823      	ldr	r3, [r4, #0]
    b4ae:	4632      	mov	r2, r6
    b4b0:	4629      	mov	r1, r5
    b4b2:	4620      	mov	r0, r4
}
    b4b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    b4b8:	4718      	bx	r3
    b4ba:	bf00      	nop
    b4bc:	0001665c 	.word	0x0001665c
    b4c0:	0000e42d 	.word	0x0000e42d

0000b4c4 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    b4c4:	b570      	push	{r4, r5, r6, lr}
    b4c6:	460d      	mov	r5, r1
    b4c8:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    b4ca:	4604      	mov	r4, r0
    b4cc:	b110      	cbz	r0, b4d4 <io_read+0x10>
    b4ce:	1e08      	subs	r0, r1, #0
    b4d0:	bf18      	it	ne
    b4d2:	2001      	movne	r0, #1
    b4d4:	4905      	ldr	r1, [pc, #20]	; (b4ec <io_read+0x28>)
    b4d6:	4b06      	ldr	r3, [pc, #24]	; (b4f0 <io_read+0x2c>)
    b4d8:	223d      	movs	r2, #61	; 0x3d
    b4da:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    b4dc:	6863      	ldr	r3, [r4, #4]
    b4de:	4632      	mov	r2, r6
    b4e0:	4629      	mov	r1, r5
    b4e2:	4620      	mov	r0, r4
}
    b4e4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    b4e8:	4718      	bx	r3
    b4ea:	bf00      	nop
    b4ec:	0001665c 	.word	0x0001665c
    b4f0:	0000e42d 	.word	0x0000e42d

0000b4f4 <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    b4f4:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    b4f8:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    b4fc:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    b500:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    b502:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    b504:	2300      	movs	r3, #0
    b506:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    b508:	4770      	bx	lr

0000b50a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    b50a:	2300      	movs	r3, #0
    b50c:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    b50e:	4770      	bx	lr

0000b510 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    b510:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    b512:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    b514:	689a      	ldr	r2, [r3, #8]
    b516:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    b518:	689a      	ldr	r2, [r3, #8]
    b51a:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    b51c:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b51e:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b520:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b522:	3301      	adds	r3, #1
    b524:	6003      	str	r3, [r0, #0]
}
    b526:	4770      	bx	lr

0000b528 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    b528:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    b52a:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    b52c:	1c63      	adds	r3, r4, #1
    b52e:	d10a      	bne.n	b546 <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    b530:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    b532:	685a      	ldr	r2, [r3, #4]
    b534:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    b536:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    b538:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    b53a:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    b53c:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    b53e:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    b540:	3301      	adds	r3, #1
    b542:	6003      	str	r3, [r0, #0]
}
    b544:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    b546:	f100 0208 	add.w	r2, r0, #8
    b54a:	4613      	mov	r3, r2
    b54c:	6852      	ldr	r2, [r2, #4]
    b54e:	6815      	ldr	r5, [r2, #0]
    b550:	42a5      	cmp	r5, r4
    b552:	d9fa      	bls.n	b54a <vListInsert+0x22>
    b554:	e7ed      	b.n	b532 <vListInsert+0xa>

0000b556 <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b556:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    b55a:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    b55c:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    b55e:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    b560:	6859      	ldr	r1, [r3, #4]
    b562:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    b564:	bf08      	it	eq
    b566:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    b568:	2200      	movs	r2, #0
    b56a:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    b56c:	681a      	ldr	r2, [r3, #0]
    b56e:	3a01      	subs	r2, #1
    b570:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    b572:	6818      	ldr	r0, [r3, #0]
}
    b574:	4770      	bx	lr
	...

0000b578 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    b578:	4808      	ldr	r0, [pc, #32]	; (b59c <prvPortStartFirstTask+0x24>)
    b57a:	6800      	ldr	r0, [r0, #0]
    b57c:	6800      	ldr	r0, [r0, #0]
    b57e:	f380 8808 	msr	MSP, r0
    b582:	f04f 0000 	mov.w	r0, #0
    b586:	f380 8814 	msr	CONTROL, r0
    b58a:	b662      	cpsie	i
    b58c:	b661      	cpsie	f
    b58e:	f3bf 8f4f 	dsb	sy
    b592:	f3bf 8f6f 	isb	sy
    b596:	df00      	svc	0
    b598:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    b59a:	0000      	.short	0x0000
    b59c:	e000ed08 	.word	0xe000ed08

0000b5a0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    b5a0:	f8df 000c 	ldr.w	r0, [pc, #12]	; b5b0 <vPortEnableVFP+0x10>
    b5a4:	6801      	ldr	r1, [r0, #0]
    b5a6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    b5aa:	6001      	str	r1, [r0, #0]
    b5ac:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    b5ae:	0000      	.short	0x0000
    b5b0:	e000ed88 	.word	0xe000ed88

0000b5b4 <prvTaskExitError>:
{
    b5b4:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
    b5b6:	2300      	movs	r3, #0
    b5b8:	9301      	str	r3, [sp, #4]
	configASSERT(uxCriticalNesting == ~0UL);
    b5ba:	4b0d      	ldr	r3, [pc, #52]	; (b5f0 <prvTaskExitError+0x3c>)
    b5bc:	681b      	ldr	r3, [r3, #0]
    b5be:	3301      	adds	r3, #1
    b5c0:	d008      	beq.n	b5d4 <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    b5c2:	f04f 0380 	mov.w	r3, #128	; 0x80
    b5c6:	f383 8811 	msr	BASEPRI, r3
    b5ca:	f3bf 8f6f 	isb	sy
    b5ce:	f3bf 8f4f 	dsb	sy
    b5d2:	e7fe      	b.n	b5d2 <prvTaskExitError+0x1e>
    b5d4:	f04f 0380 	mov.w	r3, #128	; 0x80
    b5d8:	f383 8811 	msr	BASEPRI, r3
    b5dc:	f3bf 8f6f 	isb	sy
    b5e0:	f3bf 8f4f 	dsb	sy
	while (ulDummy == 0) {
    b5e4:	9b01      	ldr	r3, [sp, #4]
    b5e6:	2b00      	cmp	r3, #0
    b5e8:	d0fc      	beq.n	b5e4 <prvTaskExitError+0x30>
}
    b5ea:	b002      	add	sp, #8
    b5ec:	4770      	bx	lr
    b5ee:	bf00      	nop
    b5f0:	20000350 	.word	0x20000350

0000b5f4 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    b5f4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    b5f8:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    b5fc:	4b07      	ldr	r3, [pc, #28]	; (b61c <pxPortInitialiseStack+0x28>)
    b5fe:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b602:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b606:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    b60a:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    b60e:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    b612:	f840 3c24 	str.w	r3, [r0, #-36]
}
    b616:	3844      	subs	r0, #68	; 0x44
    b618:	4770      	bx	lr
    b61a:	bf00      	nop
    b61c:	0000b5b5 	.word	0x0000b5b5

0000b620 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    b620:	4b07      	ldr	r3, [pc, #28]	; (b640 <pxCurrentTCBConst2>)
    b622:	6819      	ldr	r1, [r3, #0]
    b624:	6808      	ldr	r0, [r1, #0]
    b626:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b62a:	f380 8809 	msr	PSP, r0
    b62e:	f3bf 8f6f 	isb	sy
    b632:	f04f 0000 	mov.w	r0, #0
    b636:	f380 8811 	msr	BASEPRI, r0
    b63a:	4770      	bx	lr
    b63c:	f3af 8000 	nop.w

0000b640 <pxCurrentTCBConst2>:
    b640:	200090ac 	.word	0x200090ac

0000b644 <vPortEnterCritical>:
    b644:	f04f 0380 	mov.w	r3, #128	; 0x80
    b648:	f383 8811 	msr	BASEPRI, r3
    b64c:	f3bf 8f6f 	isb	sy
    b650:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    b654:	4a0a      	ldr	r2, [pc, #40]	; (b680 <vPortEnterCritical+0x3c>)
    b656:	6813      	ldr	r3, [r2, #0]
    b658:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    b65a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    b65c:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    b65e:	d10d      	bne.n	b67c <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    b660:	4b08      	ldr	r3, [pc, #32]	; (b684 <vPortEnterCritical+0x40>)
    b662:	681b      	ldr	r3, [r3, #0]
    b664:	f013 0fff 	tst.w	r3, #255	; 0xff
    b668:	d008      	beq.n	b67c <vPortEnterCritical+0x38>
    b66a:	f04f 0380 	mov.w	r3, #128	; 0x80
    b66e:	f383 8811 	msr	BASEPRI, r3
    b672:	f3bf 8f6f 	isb	sy
    b676:	f3bf 8f4f 	dsb	sy
    b67a:	e7fe      	b.n	b67a <vPortEnterCritical+0x36>
}
    b67c:	4770      	bx	lr
    b67e:	bf00      	nop
    b680:	20000350 	.word	0x20000350
    b684:	e000ed04 	.word	0xe000ed04

0000b688 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    b688:	4a08      	ldr	r2, [pc, #32]	; (b6ac <vPortExitCritical+0x24>)
    b68a:	6813      	ldr	r3, [r2, #0]
    b68c:	b943      	cbnz	r3, b6a0 <vPortExitCritical+0x18>
    b68e:	f04f 0380 	mov.w	r3, #128	; 0x80
    b692:	f383 8811 	msr	BASEPRI, r3
    b696:	f3bf 8f6f 	isb	sy
    b69a:	f3bf 8f4f 	dsb	sy
    b69e:	e7fe      	b.n	b69e <vPortExitCritical+0x16>
	uxCriticalNesting--;
    b6a0:	3b01      	subs	r3, #1
    b6a2:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    b6a4:	b90b      	cbnz	r3, b6aa <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b6a6:	f383 8811 	msr	BASEPRI, r3
}
    b6aa:	4770      	bx	lr
    b6ac:	20000350 	.word	0x20000350

0000b6b0 <PendSV_Handler>:
	__asm volatile(
    b6b0:	f3ef 8009 	mrs	r0, PSP
    b6b4:	f3bf 8f6f 	isb	sy
    b6b8:	4b15      	ldr	r3, [pc, #84]	; (b710 <pxCurrentTCBConst>)
    b6ba:	681a      	ldr	r2, [r3, #0]
    b6bc:	f01e 0f10 	tst.w	lr, #16
    b6c0:	bf08      	it	eq
    b6c2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    b6c6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b6ca:	6010      	str	r0, [r2, #0]
    b6cc:	e92d 0009 	stmdb	sp!, {r0, r3}
    b6d0:	f04f 0080 	mov.w	r0, #128	; 0x80
    b6d4:	f380 8811 	msr	BASEPRI, r0
    b6d8:	f3bf 8f4f 	dsb	sy
    b6dc:	f3bf 8f6f 	isb	sy
    b6e0:	f007 fbf2 	bl	12ec8 <vTaskSwitchContext>
    b6e4:	f04f 0000 	mov.w	r0, #0
    b6e8:	f380 8811 	msr	BASEPRI, r0
    b6ec:	bc09      	pop	{r0, r3}
    b6ee:	6819      	ldr	r1, [r3, #0]
    b6f0:	6808      	ldr	r0, [r1, #0]
    b6f2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b6f6:	f01e 0f10 	tst.w	lr, #16
    b6fa:	bf08      	it	eq
    b6fc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    b700:	f380 8809 	msr	PSP, r0
    b704:	f3bf 8f6f 	isb	sy
    b708:	4770      	bx	lr
    b70a:	bf00      	nop
    b70c:	f3af 8000 	nop.w

0000b710 <pxCurrentTCBConst>:
    b710:	200090ac 	.word	0x200090ac

0000b714 <SysTick_Handler>:
{
    b714:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
    b716:	f04f 0380 	mov.w	r3, #128	; 0x80
    b71a:	f383 8811 	msr	BASEPRI, r3
    b71e:	f3bf 8f6f 	isb	sy
    b722:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    b726:	4b05      	ldr	r3, [pc, #20]	; (b73c <SysTick_Handler+0x28>)
    b728:	4798      	blx	r3
    b72a:	b118      	cbz	r0, b734 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    b72c:	4b04      	ldr	r3, [pc, #16]	; (b740 <SysTick_Handler+0x2c>)
    b72e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    b732:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    b734:	2300      	movs	r3, #0
    b736:	f383 8811 	msr	BASEPRI, r3
}
    b73a:	bd08      	pop	{r3, pc}
    b73c:	00012c79 	.word	0x00012c79
    b740:	e000ed04 	.word	0xe000ed04

0000b744 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b744:	4b05      	ldr	r3, [pc, #20]	; (b75c <vPortSetupTimerInterrupt+0x18>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b746:	4906      	ldr	r1, [pc, #24]	; (b760 <vPortSetupTimerInterrupt+0x1c>)
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    b748:	2200      	movs	r2, #0
    b74a:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    b74c:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    b74e:	4a05      	ldr	r2, [pc, #20]	; (b764 <vPortSetupTimerInterrupt+0x20>)
    b750:	f645 51bf 	movw	r1, #23999	; 0x5dbf
    b754:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    b756:	2207      	movs	r2, #7
    b758:	601a      	str	r2, [r3, #0]
}
    b75a:	4770      	bx	lr
    b75c:	e000e010 	.word	0xe000e010
    b760:	e000e018 	.word	0xe000e018
    b764:	e000e014 	.word	0xe000e014

0000b768 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b768:	4b37      	ldr	r3, [pc, #220]	; (b848 <xPortStartScheduler+0xe0>)
    b76a:	4a38      	ldr	r2, [pc, #224]	; (b84c <xPortStartScheduler+0xe4>)
{
    b76c:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    b76e:	6819      	ldr	r1, [r3, #0]
    b770:	4291      	cmp	r1, r2
    b772:	d108      	bne.n	b786 <xPortStartScheduler+0x1e>
	__asm volatile("	mov %0, %1												\n"
    b774:	f04f 0380 	mov.w	r3, #128	; 0x80
    b778:	f383 8811 	msr	BASEPRI, r3
    b77c:	f3bf 8f6f 	isb	sy
    b780:	f3bf 8f4f 	dsb	sy
    b784:	e7fe      	b.n	b784 <xPortStartScheduler+0x1c>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    b786:	681a      	ldr	r2, [r3, #0]
    b788:	4b31      	ldr	r3, [pc, #196]	; (b850 <xPortStartScheduler+0xe8>)
    b78a:	429a      	cmp	r2, r3
    b78c:	d108      	bne.n	b7a0 <xPortStartScheduler+0x38>
    b78e:	f04f 0380 	mov.w	r3, #128	; 0x80
    b792:	f383 8811 	msr	BASEPRI, r3
    b796:	f3bf 8f6f 	isb	sy
    b79a:	f3bf 8f4f 	dsb	sy
    b79e:	e7fe      	b.n	b79e <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    b7a0:	4b2c      	ldr	r3, [pc, #176]	; (b854 <xPortStartScheduler+0xec>)
    b7a2:	781a      	ldrb	r2, [r3, #0]
    b7a4:	b2d2      	uxtb	r2, r2
    b7a6:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    b7a8:	22ff      	movs	r2, #255	; 0xff
    b7aa:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b7ac:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b7ae:	4a2a      	ldr	r2, [pc, #168]	; (b858 <xPortStartScheduler+0xf0>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    b7b0:	b2db      	uxtb	r3, r3
    b7b2:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    b7b6:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b7ba:	f003 0380 	and.w	r3, r3, #128	; 0x80
    b7be:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    b7c0:	2307      	movs	r3, #7
    b7c2:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    b7c4:	2100      	movs	r1, #0
    b7c6:	f89d 0003 	ldrb.w	r0, [sp, #3]
    b7ca:	0600      	lsls	r0, r0, #24
    b7cc:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    b7d0:	d40c      	bmi.n	b7ec <xPortStartScheduler+0x84>
    b7d2:	b111      	cbz	r1, b7da <xPortStartScheduler+0x72>
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
    b7d4:	2b04      	cmp	r3, #4
    b7d6:	6053      	str	r3, [r2, #4]
    b7d8:	d011      	beq.n	b7fe <xPortStartScheduler+0x96>
    b7da:	f04f 0380 	mov.w	r3, #128	; 0x80
    b7de:	f383 8811 	msr	BASEPRI, r3
    b7e2:	f3bf 8f6f 	isb	sy
    b7e6:	f3bf 8f4f 	dsb	sy
    b7ea:	e7fe      	b.n	b7ea <xPortStartScheduler+0x82>
			ucMaxPriorityValue <<= (uint8_t)0x01;
    b7ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
    b7f0:	005b      	lsls	r3, r3, #1
    b7f2:	b2db      	uxtb	r3, r3
    b7f4:	f88d 3003 	strb.w	r3, [sp, #3]
    b7f8:	2101      	movs	r1, #1
    b7fa:	4623      	mov	r3, r4
    b7fc:	e7e3      	b.n	b7c6 <xPortStartScheduler+0x5e>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    b7fe:	f44f 6380 	mov.w	r3, #1024	; 0x400
    b802:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    b804:	9b01      	ldr	r3, [sp, #4]
    b806:	4a13      	ldr	r2, [pc, #76]	; (b854 <xPortStartScheduler+0xec>)
    b808:	b2db      	uxtb	r3, r3
    b80a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    b80c:	4b13      	ldr	r3, [pc, #76]	; (b85c <xPortStartScheduler+0xf4>)
    b80e:	681a      	ldr	r2, [r3, #0]
    b810:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    b814:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    b816:	681a      	ldr	r2, [r3, #0]
    b818:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    b81c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    b81e:	4b10      	ldr	r3, [pc, #64]	; (b860 <xPortStartScheduler+0xf8>)
    b820:	4798      	blx	r3
	uxCriticalNesting = 0;
    b822:	4b10      	ldr	r3, [pc, #64]	; (b864 <xPortStartScheduler+0xfc>)
    b824:	2400      	movs	r4, #0
    b826:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
    b828:	4b0f      	ldr	r3, [pc, #60]	; (b868 <xPortStartScheduler+0x100>)
    b82a:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    b82c:	4a0f      	ldr	r2, [pc, #60]	; (b86c <xPortStartScheduler+0x104>)
    b82e:	6813      	ldr	r3, [r2, #0]
    b830:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    b834:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    b836:	4b0e      	ldr	r3, [pc, #56]	; (b870 <xPortStartScheduler+0x108>)
    b838:	4798      	blx	r3
	vTaskSwitchContext();
    b83a:	4b0e      	ldr	r3, [pc, #56]	; (b874 <xPortStartScheduler+0x10c>)
    b83c:	4798      	blx	r3
	prvTaskExitError();
    b83e:	4b0e      	ldr	r3, [pc, #56]	; (b878 <xPortStartScheduler+0x110>)
    b840:	4798      	blx	r3
}
    b842:	4620      	mov	r0, r4
    b844:	b002      	add	sp, #8
    b846:	bd10      	pop	{r4, pc}
    b848:	e000ed00 	.word	0xe000ed00
    b84c:	410fc271 	.word	0x410fc271
    b850:	410fc270 	.word	0x410fc270
    b854:	e000e400 	.word	0xe000e400
    b858:	20000800 	.word	0x20000800
    b85c:	e000ed20 	.word	0xe000ed20
    b860:	0000b745 	.word	0x0000b745
    b864:	20000350 	.word	0x20000350
    b868:	0000b5a1 	.word	0x0000b5a1
    b86c:	e000ef34 	.word	0xe000ef34
    b870:	0000b579 	.word	0x0000b579
    b874:	00012ec9 	.word	0x00012ec9
    b878:	0000b5b5 	.word	0x0000b5b5

0000b87c <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
    b87c:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    b880:	2b0f      	cmp	r3, #15
    b882:	4a10      	ldr	r2, [pc, #64]	; (b8c4 <vPortValidateInterruptPriority+0x48>)
    b884:	d90d      	bls.n	b8a2 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    b886:	4910      	ldr	r1, [pc, #64]	; (b8c8 <vPortValidateInterruptPriority+0x4c>)
    b888:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    b88a:	7811      	ldrb	r1, [r2, #0]
    b88c:	4299      	cmp	r1, r3
    b88e:	d908      	bls.n	b8a2 <vPortValidateInterruptPriority+0x26>
    b890:	f04f 0380 	mov.w	r3, #128	; 0x80
    b894:	f383 8811 	msr	BASEPRI, r3
    b898:	f3bf 8f6f 	isb	sy
    b89c:	f3bf 8f4f 	dsb	sy
    b8a0:	e7fe      	b.n	b8a0 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    b8a2:	4b0a      	ldr	r3, [pc, #40]	; (b8cc <vPortValidateInterruptPriority+0x50>)
    b8a4:	6852      	ldr	r2, [r2, #4]
    b8a6:	681b      	ldr	r3, [r3, #0]
    b8a8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    b8ac:	4293      	cmp	r3, r2
    b8ae:	d908      	bls.n	b8c2 <vPortValidateInterruptPriority+0x46>
    b8b0:	f04f 0380 	mov.w	r3, #128	; 0x80
    b8b4:	f383 8811 	msr	BASEPRI, r3
    b8b8:	f3bf 8f6f 	isb	sy
    b8bc:	f3bf 8f4f 	dsb	sy
    b8c0:	e7fe      	b.n	b8c0 <vPortValidateInterruptPriority+0x44>
}
    b8c2:	4770      	bx	lr
    b8c4:	20000800 	.word	0x20000800
    b8c8:	e000e3f0 	.word	0xe000e3f0
    b8cc:	e000ed0c 	.word	0xe000ed0c

0000b8d0 <i2c_m_async_write>:

/**
 * \brief Async version of I2C I/O write
 */
static int32_t i2c_m_async_write(struct io_descriptor *const io, const uint8_t *buf, const uint16_t n)
{
    b8d0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct i2c_m_async_desc *i2c = CONTAINER_OF(io, struct i2c_m_async_desc, io);
	struct _i2c_m_msg        msg;
	int32_t                  ret;

	msg.addr   = i2c->slave_addr;
    b8d2:	8a83      	ldrh	r3, [r0, #20]
    b8d4:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
    b8d8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    b8dc:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
    b8e0:	9103      	str	r1, [sp, #12]

	/* start transfer then return */
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b8e2:	4b05      	ldr	r3, [pc, #20]	; (b8f8 <i2c_m_async_write+0x28>)
	msg.len    = n;
    b8e4:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b8e6:	a901      	add	r1, sp, #4
    b8e8:	3828      	subs	r0, #40	; 0x28
{
    b8ea:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b8ec:	4798      	blx	r3
		/* error occurred */
		return ret;
	}

	return (int32_t)n;
}
    b8ee:	2800      	cmp	r0, #0
    b8f0:	bf08      	it	eq
    b8f2:	4620      	moveq	r0, r4
    b8f4:	b004      	add	sp, #16
    b8f6:	bd10      	pop	{r4, pc}
    b8f8:	00011559 	.word	0x00011559

0000b8fc <i2c_m_async_read>:
{
    b8fc:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.addr   = i2c->slave_addr;
    b8fe:	8a83      	ldrh	r3, [r0, #20]
    b900:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    b904:	f248 0301 	movw	r3, #32769	; 0x8001
    b908:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
    b90c:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b90e:	4b05      	ldr	r3, [pc, #20]	; (b924 <i2c_m_async_read+0x28>)
	msg.len    = n;
    b910:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b912:	a901      	add	r1, sp, #4
    b914:	3828      	subs	r0, #40	; 0x28
{
    b916:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    b918:	4798      	blx	r3
}
    b91a:	2800      	cmp	r0, #0
    b91c:	bf08      	it	eq
    b91e:	4620      	moveq	r0, r4
    b920:	b004      	add	sp, #16
    b922:	bd10      	pop	{r4, pc}
    b924:	00011559 	.word	0x00011559

0000b928 <i2c_tx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b928:	8842      	ldrh	r2, [r0, #2]
    b92a:	05d2      	lsls	r2, r2, #23
    b92c:	d402      	bmi.n	b934 <i2c_tx_complete+0xc>
		if (i2c->i2c_cb.tx_complete) {
    b92e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    b930:	b103      	cbz	r3, b934 <i2c_tx_complete+0xc>
			i2c->i2c_cb.tx_complete(i2c);
    b932:	4718      	bx	r3
}
    b934:	4770      	bx	lr

0000b936 <i2c_rx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b936:	8842      	ldrh	r2, [r0, #2]
    b938:	05d2      	lsls	r2, r2, #23
    b93a:	d402      	bmi.n	b942 <i2c_rx_complete+0xc>
		if (i2c->i2c_cb.rx_complete) {
    b93c:	6b83      	ldr	r3, [r0, #56]	; 0x38
    b93e:	b103      	cbz	r3, b942 <i2c_rx_complete+0xc>
			i2c->i2c_cb.rx_complete(i2c);
    b940:	4718      	bx	r3
}
    b942:	4770      	bx	lr

0000b944 <i2c_error>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    b944:	8842      	ldrh	r2, [r0, #2]
    b946:	05d2      	lsls	r2, r2, #23
    b948:	d402      	bmi.n	b950 <i2c_error+0xc>
		if (i2c->i2c_cb.error) {
    b94a:	6b03      	ldr	r3, [r0, #48]	; 0x30
    b94c:	b103      	cbz	r3, b950 <i2c_error+0xc>
			i2c->i2c_cb.error(i2c, error);
    b94e:	4718      	bx	r3
}
    b950:	4770      	bx	lr
	...

0000b954 <i2c_m_async_init>:

/**
 * \brief Async version of i2c initialize
 */
int32_t i2c_m_async_init(struct i2c_m_async_desc *const i2c, void *const hw)
{
    b954:	b570      	push	{r4, r5, r6, lr}
	int32_t init_status;
	ASSERT(i2c);
    b956:	4604      	mov	r4, r0
    b958:	3800      	subs	r0, #0
{
    b95a:	460d      	mov	r5, r1
	ASSERT(i2c);
    b95c:	bf18      	it	ne
    b95e:	2001      	movne	r0, #1
    b960:	490e      	ldr	r1, [pc, #56]	; (b99c <i2c_m_async_init+0x48>)
    b962:	4b0f      	ldr	r3, [pc, #60]	; (b9a0 <i2c_m_async_init+0x4c>)
    b964:	2289      	movs	r2, #137	; 0x89
    b966:	4798      	blx	r3

	init_status = _i2c_m_async_init(&i2c->device, hw);
    b968:	4629      	mov	r1, r5
    b96a:	4b0e      	ldr	r3, [pc, #56]	; (b9a4 <i2c_m_async_init+0x50>)
    b96c:	4620      	mov	r0, r4
    b96e:	4798      	blx	r3
	if (init_status) {
    b970:	4605      	mov	r5, r0
    b972:	b980      	cbnz	r0, b996 <i2c_m_async_init+0x42>
		return init_status;
	}
	/* Init I/O */
	i2c->io.read  = i2c_m_async_read;
    b974:	4b0c      	ldr	r3, [pc, #48]	; (b9a8 <i2c_m_async_init+0x54>)
    b976:	62e3      	str	r3, [r4, #44]	; 0x2c
	i2c->io.write = i2c_m_async_write;
    b978:	4b0c      	ldr	r3, [pc, #48]	; (b9ac <i2c_m_async_init+0x58>)

	/* Init callbacks */
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b97a:	4a0d      	ldr	r2, [pc, #52]	; (b9b0 <i2c_m_async_init+0x5c>)
    b97c:	4e0d      	ldr	r6, [pc, #52]	; (b9b4 <i2c_m_async_init+0x60>)
	i2c->io.write = i2c_m_async_write;
    b97e:	62a3      	str	r3, [r4, #40]	; 0x28
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    b980:	2101      	movs	r1, #1
    b982:	4620      	mov	r0, r4
    b984:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_RX_COMPLETE, (FUNC_PTR)i2c_rx_complete);
    b986:	4a0c      	ldr	r2, [pc, #48]	; (b9b8 <i2c_m_async_init+0x64>)
    b988:	2102      	movs	r1, #2
    b98a:	4620      	mov	r0, r4
    b98c:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_ERROR, (FUNC_PTR)i2c_error);
    b98e:	4a0b      	ldr	r2, [pc, #44]	; (b9bc <i2c_m_async_init+0x68>)
    b990:	4629      	mov	r1, r5
    b992:	4620      	mov	r0, r4
    b994:	47b0      	blx	r6

	return ERR_NONE;
}
    b996:	4628      	mov	r0, r5
    b998:	bd70      	pop	{r4, r5, r6, pc}
    b99a:	bf00      	nop
    b99c:	00016670 	.word	0x00016670
    b9a0:	0000e42d 	.word	0x0000e42d
    b9a4:	000114dd 	.word	0x000114dd
    b9a8:	0000b8fd 	.word	0x0000b8fd
    b9ac:	0000b8d1 	.word	0x0000b8d1
    b9b0:	0000b929 	.word	0x0000b929
    b9b4:	00011661 	.word	0x00011661
    b9b8:	0000b937 	.word	0x0000b937
    b9bc:	0000b945 	.word	0x0000b945

0000b9c0 <prvInsertBlockIntoFreeList>:
	BlockLink_t *pxIterator;
	uint8_t *    puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    b9c0:	4b0f      	ldr	r3, [pc, #60]	; (ba00 <prvInsertBlockIntoFreeList+0x40>)
{
    b9c2:	b530      	push	{r4, r5, lr}
    b9c4:	461d      	mov	r5, r3
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    b9c6:	461a      	mov	r2, r3
    b9c8:	681b      	ldr	r3, [r3, #0]
    b9ca:	4283      	cmp	r3, r0
    b9cc:	d3fb      	bcc.n	b9c6 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = (uint8_t *)pxIterator;
	if ((puc + pxIterator->xBlockSize) == (uint8_t *)pxBlockToInsert) {
    b9ce:	6854      	ldr	r4, [r2, #4]
    b9d0:	1911      	adds	r1, r2, r4
    b9d2:	4288      	cmp	r0, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    b9d4:	bf01      	itttt	eq
    b9d6:	6841      	ldreq	r1, [r0, #4]
    b9d8:	4610      	moveq	r0, r2
    b9da:	1909      	addeq	r1, r1, r4
    b9dc:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = (uint8_t *)pxBlockToInsert;
	if ((puc + pxBlockToInsert->xBlockSize) == (uint8_t *)pxIterator->pxNextFreeBlock) {
    b9de:	6844      	ldr	r4, [r0, #4]
    b9e0:	1901      	adds	r1, r0, r4
    b9e2:	428b      	cmp	r3, r1
    b9e4:	d106      	bne.n	b9f4 <prvInsertBlockIntoFreeList+0x34>
		if (pxIterator->pxNextFreeBlock != pxEnd) {
    b9e6:	68a9      	ldr	r1, [r5, #8]
    b9e8:	428b      	cmp	r3, r1
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    b9ea:	bf1f      	itttt	ne
    b9ec:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    b9ee:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    b9f0:	1909      	addne	r1, r1, r4
    b9f2:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if (pxIterator != pxBlockToInsert) {
    b9f4:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    b9f6:	6003      	str	r3, [r0, #0]
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    b9f8:	bf18      	it	ne
    b9fa:	6010      	strne	r0, [r2, #0]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    b9fc:	bd30      	pop	{r4, r5, pc}
    b9fe:	bf00      	nop
    ba00:	20000808 	.word	0x20000808

0000ba04 <pvPortMalloc>:
{
    ba04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (pxEnd == NULL) {
    ba08:	4d39      	ldr	r5, [pc, #228]	; (baf0 <pvPortMalloc+0xec>)
	vTaskSuspendAll();
    ba0a:	4b3a      	ldr	r3, [pc, #232]	; (baf4 <pvPortMalloc+0xf0>)
{
    ba0c:	4604      	mov	r4, r0
	vTaskSuspendAll();
    ba0e:	4798      	blx	r3
		if (pxEnd == NULL) {
    ba10:	68ab      	ldr	r3, [r5, #8]
    ba12:	b9bb      	cbnz	r3, ba44 <pvPortMalloc+0x40>
	uxAddress = (size_t)ucHeap;
    ba14:	4a38      	ldr	r2, [pc, #224]	; (baf8 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
    ba16:	4b39      	ldr	r3, [pc, #228]	; (bafc <pvPortMalloc+0xf8>)
	if ((uxAddress & portBYTE_ALIGNMENT_MASK) != 0) {
    ba18:	0756      	lsls	r6, r2, #29
		uxAddress += (portBYTE_ALIGNMENT - 1);
    ba1a:	bf18      	it	ne
    ba1c:	3207      	addne	r2, #7
	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    ba1e:	f023 0307 	bic.w	r3, r3, #7
		uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    ba22:	bf18      	it	ne
    ba24:	f022 0207 	bicne.w	r2, r2, #7
	xStart.xBlockSize      = (size_t)0;
    ba28:	2100      	movs	r1, #0
    ba2a:	6069      	str	r1, [r5, #4]
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
    ba2c:	602a      	str	r2, [r5, #0]
	pxEnd->pxNextFreeBlock = NULL;
    ba2e:	e9c3 1100 	strd	r1, r1, [r3]
	pxFirstFreeBlock->xBlockSize      = uxAddress - (size_t)pxFirstFreeBlock;
    ba32:	1a99      	subs	r1, r3, r2
	xFreeBytesRemaining            = pxFirstFreeBlock->xBlockSize;
    ba34:	e9c5 1103 	strd	r1, r1, [r5, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    ba38:	e9c2 3100 	strd	r3, r1, [r2]
	pxEnd                  = (void *)uxAddress;
    ba3c:	60ab      	str	r3, [r5, #8]
	xBlockAllocatedBit = ((size_t)1) << ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);
    ba3e:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    ba42:	616b      	str	r3, [r5, #20]
		if ((xWantedSize & xBlockAllocatedBit) == 0) {
    ba44:	f8d5 8014 	ldr.w	r8, [r5, #20]
    ba48:	ea18 0f04 	tst.w	r8, r4
    ba4c:	d14b      	bne.n	bae6 <pvPortMalloc+0xe2>
			if (xWantedSize > 0) {
    ba4e:	2c00      	cmp	r4, #0
    ba50:	d03c      	beq.n	bacc <pvPortMalloc+0xc8>
				xWantedSize += xHeapStructSize;
    ba52:	f104 0308 	add.w	r3, r4, #8
				if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0x00) {
    ba56:	0760      	lsls	r0, r4, #29
					xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    ba58:	bf1c      	itt	ne
    ba5a:	f023 0307 	bicne.w	r3, r3, #7
    ba5e:	3308      	addne	r3, #8
			if ((xWantedSize > 0) && (xWantedSize <= xFreeBytesRemaining)) {
    ba60:	2b00      	cmp	r3, #0
    ba62:	d040      	beq.n	bae6 <pvPortMalloc+0xe2>
    ba64:	692f      	ldr	r7, [r5, #16]
    ba66:	429f      	cmp	r7, r3
    ba68:	d33d      	bcc.n	bae6 <pvPortMalloc+0xe2>
				pxBlock         = xStart.pxNextFreeBlock;
    ba6a:	682e      	ldr	r6, [r5, #0]
				pxPreviousBlock = &xStart;
    ba6c:	4820      	ldr	r0, [pc, #128]	; (baf0 <pvPortMalloc+0xec>)
				while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    ba6e:	6872      	ldr	r2, [r6, #4]
    ba70:	429a      	cmp	r2, r3
    ba72:	d201      	bcs.n	ba78 <pvPortMalloc+0x74>
    ba74:	6831      	ldr	r1, [r6, #0]
    ba76:	b9a1      	cbnz	r1, baa2 <pvPortMalloc+0x9e>
				if (pxBlock != pxEnd) {
    ba78:	68a9      	ldr	r1, [r5, #8]
    ba7a:	42b1      	cmp	r1, r6
    ba7c:	d033      	beq.n	bae6 <pvPortMalloc+0xe2>
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    ba7e:	1ad2      	subs	r2, r2, r3
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    ba80:	6831      	ldr	r1, [r6, #0]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    ba82:	6804      	ldr	r4, [r0, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    ba84:	6001      	str	r1, [r0, #0]
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    ba86:	2a10      	cmp	r2, #16
    ba88:	d912      	bls.n	bab0 <pvPortMalloc+0xac>
						pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    ba8a:	18f0      	adds	r0, r6, r3
						configASSERT((((size_t)pxNewBlockLink) & portBYTE_ALIGNMENT_MASK) == 0);
    ba8c:	0741      	lsls	r1, r0, #29
    ba8e:	d00b      	beq.n	baa8 <pvPortMalloc+0xa4>
    ba90:	f04f 0380 	mov.w	r3, #128	; 0x80
    ba94:	f383 8811 	msr	BASEPRI, r3
    ba98:	f3bf 8f6f 	isb	sy
    ba9c:	f3bf 8f4f 	dsb	sy
    baa0:	e7fe      	b.n	baa0 <pvPortMalloc+0x9c>
    baa2:	4630      	mov	r0, r6
    baa4:	460e      	mov	r6, r1
    baa6:	e7e2      	b.n	ba6e <pvPortMalloc+0x6a>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    baa8:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize        = xWantedSize;
    baaa:	6073      	str	r3, [r6, #4]
						prvInsertBlockIntoFreeList(pxNewBlockLink);
    baac:	4b14      	ldr	r3, [pc, #80]	; (bb00 <pvPortMalloc+0xfc>)
    baae:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    bab0:	6873      	ldr	r3, [r6, #4]
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    bab2:	68e9      	ldr	r1, [r5, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    bab4:	1aff      	subs	r7, r7, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    bab6:	ea48 0303 	orr.w	r3, r8, r3
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    baba:	428f      	cmp	r7, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    babc:	6073      	str	r3, [r6, #4]
					pxBlock->pxNextFreeBlock = NULL;
    babe:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    bac2:	612f      	str	r7, [r5, #16]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    bac4:	bf38      	it	cc
    bac6:	60ef      	strcc	r7, [r5, #12]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    bac8:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
    baca:	6033      	str	r3, [r6, #0]
	(void)xTaskResumeAll();
    bacc:	4b0d      	ldr	r3, [pc, #52]	; (bb04 <pvPortMalloc+0x100>)
    bace:	4798      	blx	r3
	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);
    bad0:	0763      	lsls	r3, r4, #29
    bad2:	d00a      	beq.n	baea <pvPortMalloc+0xe6>
    bad4:	f04f 0380 	mov.w	r3, #128	; 0x80
    bad8:	f383 8811 	msr	BASEPRI, r3
    badc:	f3bf 8f6f 	isb	sy
    bae0:	f3bf 8f4f 	dsb	sy
    bae4:	e7fe      	b.n	bae4 <pvPortMalloc+0xe0>
	void *       pvReturn = NULL;
    bae6:	2400      	movs	r4, #0
    bae8:	e7f0      	b.n	bacc <pvPortMalloc+0xc8>
}
    baea:	4620      	mov	r0, r4
    baec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    baf0:	20000808 	.word	0x20000808
    baf4:	00012c35 	.word	0x00012c35
    baf8:	20000820 	.word	0x20000820
    bafc:	20008518 	.word	0x20008518
    bb00:	0000b9c1 	.word	0x0000b9c1
    bb04:	00012d7d 	.word	0x00012d7d

0000bb08 <vPortFree>:
{
    bb08:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    bb0a:	4604      	mov	r4, r0
    bb0c:	b368      	cbz	r0, bb6a <vPortFree+0x62>
		configASSERT((pxLink->xBlockSize & xBlockAllocatedBit) != 0);
    bb0e:	4d17      	ldr	r5, [pc, #92]	; (bb6c <vPortFree+0x64>)
    bb10:	f850 3c04 	ldr.w	r3, [r0, #-4]
    bb14:	696a      	ldr	r2, [r5, #20]
    bb16:	4213      	tst	r3, r2
    bb18:	d108      	bne.n	bb2c <vPortFree+0x24>
    bb1a:	f04f 0380 	mov.w	r3, #128	; 0x80
    bb1e:	f383 8811 	msr	BASEPRI, r3
    bb22:	f3bf 8f6f 	isb	sy
    bb26:	f3bf 8f4f 	dsb	sy
    bb2a:	e7fe      	b.n	bb2a <vPortFree+0x22>
		configASSERT(pxLink->pxNextFreeBlock == NULL);
    bb2c:	f850 1c08 	ldr.w	r1, [r0, #-8]
    bb30:	b141      	cbz	r1, bb44 <vPortFree+0x3c>
    bb32:	f04f 0380 	mov.w	r3, #128	; 0x80
    bb36:	f383 8811 	msr	BASEPRI, r3
    bb3a:	f3bf 8f6f 	isb	sy
    bb3e:	f3bf 8f4f 	dsb	sy
    bb42:	e7fe      	b.n	bb42 <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    bb44:	ea23 0302 	bic.w	r3, r3, r2
    bb48:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
    bb4c:	4b08      	ldr	r3, [pc, #32]	; (bb70 <vPortFree+0x68>)
    bb4e:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
    bb50:	692a      	ldr	r2, [r5, #16]
    bb52:	f854 3c04 	ldr.w	r3, [r4, #-4]
    bb56:	4413      	add	r3, r2
    bb58:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    bb5a:	f1a4 0008 	sub.w	r0, r4, #8
    bb5e:	4b05      	ldr	r3, [pc, #20]	; (bb74 <vPortFree+0x6c>)
    bb60:	4798      	blx	r3
}
    bb62:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				(void)xTaskResumeAll();
    bb66:	4b04      	ldr	r3, [pc, #16]	; (bb78 <vPortFree+0x70>)
    bb68:	4718      	bx	r3
}
    bb6a:	bd70      	pop	{r4, r5, r6, pc}
    bb6c:	20000808 	.word	0x20000808
    bb70:	00012c35 	.word	0x00012c35
    bb74:	0000b9c1 	.word	0x0000b9c1
    bb78:	00012d7d 	.word	0x00012d7d

0000bb7c <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    bb7c:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    bb7e:	4604      	mov	r4, r0
    bb80:	b118      	cbz	r0, bb8a <_wdt_init+0xe>
    bb82:	6800      	ldr	r0, [r0, #0]
    bb84:	3800      	subs	r0, #0
    bb86:	bf18      	it	ne
    bb88:	2001      	movne	r0, #1
    bb8a:	4b12      	ldr	r3, [pc, #72]	; (bbd4 <_wdt_init+0x58>)
    bb8c:	4912      	ldr	r1, [pc, #72]	; (bbd8 <_wdt_init+0x5c>)
    bb8e:	2250      	movs	r2, #80	; 0x50
    bb90:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    bb92:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    bb94:	689a      	ldr	r2, [r3, #8]
    bb96:	f012 0f0e 	tst.w	r2, #14
    bb9a:	d1fb      	bne.n	bb94 <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    bb9c:	781a      	ldrb	r2, [r3, #0]
    bb9e:	09d2      	lsrs	r2, r2, #7
    bba0:	d115      	bne.n	bbce <_wdt_init+0x52>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    bba2:	689a      	ldr	r2, [r3, #8]
    bba4:	f012 0f0e 	tst.w	r2, #14
    bba8:	d1fb      	bne.n	bba2 <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    bbaa:	781a      	ldrb	r2, [r3, #0]
    bbac:	0792      	lsls	r2, r2, #30
    bbae:	d40e      	bmi.n	bbce <_wdt_init+0x52>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    bbb0:	781a      	ldrb	r2, [r3, #0]
    bbb2:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    bbb6:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    bbb8:	6898      	ldr	r0, [r3, #8]
    bbba:	f010 000e 	ands.w	r0, r0, #14
    bbbe:	d1fb      	bne.n	bbb8 <_wdt_init+0x3c>

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    bbc0:	785a      	ldrb	r2, [r3, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    bbc2:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= WDT_CONFIG_PER(data);
    bbc6:	f042 020b 	orr.w	r2, r2, #11
	((Wdt *)hw)->CONFIG.reg = tmp;
    bbca:	705a      	strb	r2, [r3, #1]

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
	}

	return ERR_NONE;
}
    bbcc:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    bbce:	f06f 0010 	mvn.w	r0, #16
    bbd2:	e7fb      	b.n	bbcc <_wdt_init+0x50>
    bbd4:	0000e42d 	.word	0x0000e42d
    bbd8:	0001668d 	.word	0x0001668d

0000bbdc <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    bbdc:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    bbde:	4288      	cmp	r0, r1
    bbe0:	d301      	bcc.n	bbe6 <usb_find_desc+0xa>
		_desc_len_check();
    bbe2:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    bbe4:	bd10      	pop	{r4, pc}
		_desc_len_check();
    bbe6:	7803      	ldrb	r3, [r0, #0]
    bbe8:	2b01      	cmp	r3, #1
    bbea:	d9fa      	bls.n	bbe2 <usb_find_desc+0x6>
		if (type == usb_desc_type(desc)) {
    bbec:	7844      	ldrb	r4, [r0, #1]
    bbee:	4294      	cmp	r4, r2
    bbf0:	d0f8      	beq.n	bbe4 <usb_find_desc+0x8>
    bbf2:	4418      	add	r0, r3
    bbf4:	e7f3      	b.n	bbde <usb_find_desc+0x2>

0000bbf6 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    bbf6:	4288      	cmp	r0, r1
    bbf8:	d301      	bcc.n	bbfe <usb_find_ep_desc+0x8>
		_desc_len_check();
    bbfa:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    bbfc:	4770      	bx	lr
		_desc_len_check();
    bbfe:	7803      	ldrb	r3, [r0, #0]
    bc00:	2b01      	cmp	r3, #1
    bc02:	d9fa      	bls.n	bbfa <usb_find_ep_desc+0x4>
	return desc[1];
    bc04:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    bc06:	2a04      	cmp	r2, #4
    bc08:	d0f7      	beq.n	bbfa <usb_find_ep_desc+0x4>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    bc0a:	2a05      	cmp	r2, #5
    bc0c:	d0f6      	beq.n	bbfc <usb_find_ep_desc+0x6>
	return (desc + usb_desc_len(desc));
    bc0e:	4418      	add	r0, r3
    bc10:	e7f1      	b.n	bbf6 <usb_find_ep_desc>
	...

0000bc14 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    bc14:	b538      	push	{r3, r4, r5, lr}
    bc16:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    bc18:	4b0c      	ldr	r3, [pc, #48]	; (bc4c <usb_find_cfg_desc+0x38>)
    bc1a:	2202      	movs	r2, #2
{
    bc1c:	460c      	mov	r4, r1
	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    bc1e:	4798      	blx	r3
	if (!desc) {
    bc20:	b978      	cbnz	r0, bc42 <usb_find_cfg_desc+0x2e>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
}
    bc22:	bd38      	pop	{r3, r4, r5, pc}
		_desc_len_check();
    bc24:	7803      	ldrb	r3, [r0, #0]
    bc26:	2b01      	cmp	r3, #1
    bc28:	d90d      	bls.n	bc46 <usb_find_cfg_desc+0x32>
		if (desc[1] != USB_DT_CONFIG) {
    bc2a:	7843      	ldrb	r3, [r0, #1]
    bc2c:	2b02      	cmp	r3, #2
    bc2e:	d10a      	bne.n	bc46 <usb_find_cfg_desc+0x32>
		if (desc[5] == cfg_value) {
    bc30:	7943      	ldrb	r3, [r0, #5]
    bc32:	42ab      	cmp	r3, r5
    bc34:	d0f5      	beq.n	bc22 <usb_find_cfg_desc+0xe>
	return (ptr[0] + (ptr[1] << 8));
    bc36:	78c2      	ldrb	r2, [r0, #3]
    bc38:	7883      	ldrb	r3, [r0, #2]
    bc3a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    bc3e:	fa10 f083 	uxtah	r0, r0, r3
	while (desc < eof) {
    bc42:	42a0      	cmp	r0, r4
    bc44:	d3ee      	bcc.n	bc24 <usb_find_cfg_desc+0x10>
		return NULL;
    bc46:	2000      	movs	r0, #0
    bc48:	e7eb      	b.n	bc22 <usb_find_cfg_desc+0xe>
    bc4a:	bf00      	nop
    bc4c:	0000bbdd 	.word	0x0000bbdd

0000bc50 <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    bc50:	b570      	push	{r4, r5, r6, lr}
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    bc52:	4e09      	ldr	r6, [pc, #36]	; (bc78 <usb_find_str_desc+0x28>)
{
    bc54:	4615      	mov	r5, r2
	for (i = 0; desc < eof;) {
    bc56:	2400      	movs	r4, #0
    bc58:	4288      	cmp	r0, r1
    bc5a:	d301      	bcc.n	bc60 <usb_find_str_desc+0x10>
				return desc;
			}
			i++;
			desc = usb_desc_next(desc);
		} else {
			return NULL;
    bc5c:	2000      	movs	r0, #0
		}
	}
	return NULL;
}
    bc5e:	bd70      	pop	{r4, r5, r6, pc}
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    bc60:	2203      	movs	r2, #3
    bc62:	47b0      	blx	r6
		if (desc) {
    bc64:	2800      	cmp	r0, #0
    bc66:	d0fa      	beq.n	bc5e <usb_find_str_desc+0xe>
			_desc_len_check();
    bc68:	7803      	ldrb	r3, [r0, #0]
    bc6a:	2b01      	cmp	r3, #1
    bc6c:	d9f6      	bls.n	bc5c <usb_find_str_desc+0xc>
			if (i == str_index) {
    bc6e:	42ac      	cmp	r4, r5
    bc70:	d0f5      	beq.n	bc5e <usb_find_str_desc+0xe>
	return (desc + usb_desc_len(desc));
    bc72:	4418      	add	r0, r3
    bc74:	3401      	adds	r4, #1
    bc76:	e7ef      	b.n	bc58 <usb_find_str_desc+0x8>
    bc78:	0000bbdd 	.word	0x0000bbdd

0000bc7c <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    bc7c:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    bc7e:	4e07      	ldr	r6, [pc, #28]	; (bc9c <stdio_io_init+0x20>)
    bc80:	4d07      	ldr	r5, [pc, #28]	; (bca0 <stdio_io_init+0x24>)
    bc82:	6833      	ldr	r3, [r6, #0]
{
    bc84:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
    bc86:	2100      	movs	r1, #0
    bc88:	6898      	ldr	r0, [r3, #8]
    bc8a:	47a8      	blx	r5
	setbuf(stdin, NULL);
    bc8c:	6833      	ldr	r3, [r6, #0]
    bc8e:	2100      	movs	r1, #0
    bc90:	6858      	ldr	r0, [r3, #4]
    bc92:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    bc94:	4b03      	ldr	r3, [pc, #12]	; (bca4 <stdio_io_init+0x28>)
    bc96:	601c      	str	r4, [r3, #0]
}
    bc98:	bd70      	pop	{r4, r5, r6, pc}
    bc9a:	bf00      	nop
    bc9c:	2000054c 	.word	0x2000054c
    bca0:	00014a89 	.word	0x00014a89
    bca4:	20008520 	.word	0x20008520

0000bca8 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    bca8:	4a04      	ldr	r2, [pc, #16]	; (bcbc <stdio_io_read+0x14>)
{
    bcaa:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    bcac:	6810      	ldr	r0, [r2, #0]
    bcae:	b118      	cbz	r0, bcb8 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
    bcb0:	b28a      	uxth	r2, r1
    bcb2:	4619      	mov	r1, r3
    bcb4:	4b02      	ldr	r3, [pc, #8]	; (bcc0 <stdio_io_read+0x18>)
    bcb6:	4718      	bx	r3
}
    bcb8:	4770      	bx	lr
    bcba:	bf00      	nop
    bcbc:	20008520 	.word	0x20008520
    bcc0:	0000b4c5 	.word	0x0000b4c5

0000bcc4 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    bcc4:	4a04      	ldr	r2, [pc, #16]	; (bcd8 <stdio_io_write+0x14>)
{
    bcc6:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    bcc8:	6810      	ldr	r0, [r2, #0]
    bcca:	b118      	cbz	r0, bcd4 <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
    bccc:	b28a      	uxth	r2, r1
    bcce:	4619      	mov	r1, r3
    bcd0:	4b02      	ldr	r3, [pc, #8]	; (bcdc <stdio_io_write+0x18>)
    bcd2:	4718      	bx	r3
}
    bcd4:	4770      	bx	lr
    bcd6:	bf00      	nop
    bcd8:	20008520 	.word	0x20008520
    bcdc:	0000b495 	.word	0x0000b495

0000bce0 <_spi_m_dma_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_dma_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    bce0:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    bce2:	4604      	mov	r4, r0
    bce4:	3800      	subs	r0, #0
{
    bce6:	460d      	mov	r5, r1
    bce8:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    bcea:	bf18      	it	ne
    bcec:	2001      	movne	r0, #1
    bcee:	4907      	ldr	r1, [pc, #28]	; (bd0c <_spi_m_dma_io_write+0x2c>)
    bcf0:	4e07      	ldr	r6, [pc, #28]	; (bd10 <_spi_m_dma_io_write+0x30>)
    bcf2:	2298      	movs	r2, #152	; 0x98
    bcf4:	47b0      	blx	r6

	struct spi_m_dma_descriptor *spi = CONTAINER_OF(io, struct spi_m_dma_descriptor, io);
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    bcf6:	f1a4 001c 	sub.w	r0, r4, #28
    bcfa:	4c06      	ldr	r4, [pc, #24]	; (bd14 <_spi_m_dma_io_write+0x34>)
    bcfc:	9b01      	ldr	r3, [sp, #4]
    bcfe:	2200      	movs	r2, #0
    bd00:	4629      	mov	r1, r5
    bd02:	46a4      	mov	ip, r4
}
    bd04:	b002      	add	sp, #8
    bd06:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    bd0a:	4760      	bx	ip
    bd0c:	000166a2 	.word	0x000166a2
    bd10:	0000e42d 	.word	0x0000e42d
    bd14:	00011ce5 	.word	0x00011ce5

0000bd18 <_spi_m_dma_io_read>:
{
    bd18:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    bd1a:	4604      	mov	r4, r0
    bd1c:	3800      	subs	r0, #0
{
    bd1e:	460d      	mov	r5, r1
    bd20:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    bd22:	bf18      	it	ne
    bd24:	2001      	movne	r0, #1
    bd26:	4907      	ldr	r1, [pc, #28]	; (bd44 <_spi_m_dma_io_read+0x2c>)
    bd28:	4e07      	ldr	r6, [pc, #28]	; (bd48 <_spi_m_dma_io_read+0x30>)
    bd2a:	2281      	movs	r2, #129	; 0x81
    bd2c:	47b0      	blx	r6
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    bd2e:	f1a4 001c 	sub.w	r0, r4, #28
    bd32:	4c06      	ldr	r4, [pc, #24]	; (bd4c <_spi_m_dma_io_read+0x34>)
    bd34:	9b01      	ldr	r3, [sp, #4]
    bd36:	462a      	mov	r2, r5
    bd38:	2100      	movs	r1, #0
    bd3a:	46a4      	mov	ip, r4
}
    bd3c:	b002      	add	sp, #8
    bd3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    bd42:	4760      	bx	ip
    bd44:	000166a2 	.word	0x000166a2
    bd48:	0000e42d 	.word	0x0000e42d
    bd4c:	00011ce5 	.word	0x00011ce5

0000bd50 <spi_m_dma_init>:
{
    bd50:	b538      	push	{r3, r4, r5, lr}
    bd52:	460d      	mov	r5, r1
	ASSERT(spi && hw);
    bd54:	4604      	mov	r4, r0
    bd56:	b110      	cbz	r0, bd5e <spi_m_dma_init+0xe>
    bd58:	1e08      	subs	r0, r1, #0
    bd5a:	bf18      	it	ne
    bd5c:	2001      	movne	r0, #1
    bd5e:	4908      	ldr	r1, [pc, #32]	; (bd80 <spi_m_dma_init+0x30>)
    bd60:	4b08      	ldr	r3, [pc, #32]	; (bd84 <spi_m_dma_init+0x34>)
    bd62:	223b      	movs	r2, #59	; 0x3b
    bd64:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    bd66:	4620      	mov	r0, r4
	rc            = _spi_m_dma_init(&spi->dev, hw);
    bd68:	4b07      	ldr	r3, [pc, #28]	; (bd88 <spi_m_dma_init+0x38>)
	spi->dev.prvt = (void *)hw;
    bd6a:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_dma_init(&spi->dev, hw);
    bd6e:	4629      	mov	r1, r5
    bd70:	4798      	blx	r3
	if (rc) {
    bd72:	b918      	cbnz	r0, bd7c <spi_m_dma_init+0x2c>
	spi->io.read  = _spi_m_dma_io_read;
    bd74:	4b05      	ldr	r3, [pc, #20]	; (bd8c <spi_m_dma_init+0x3c>)
    bd76:	6263      	str	r3, [r4, #36]	; 0x24
	spi->io.write = _spi_m_dma_io_write;
    bd78:	4b05      	ldr	r3, [pc, #20]	; (bd90 <spi_m_dma_init+0x40>)
    bd7a:	6223      	str	r3, [r4, #32]
}
    bd7c:	bd38      	pop	{r3, r4, r5, pc}
    bd7e:	bf00      	nop
    bd80:	000166a2 	.word	0x000166a2
    bd84:	0000e42d 	.word	0x0000e42d
    bd88:	00011b5d 	.word	0x00011b5d
    bd8c:	0000bd19 	.word	0x0000bd19
    bd90:	0000bce1 	.word	0x0000bce1

0000bd94 <spi_m_dma_enable>:
{
    bd94:	b510      	push	{r4, lr}
	ASSERT(spi);
    bd96:	4604      	mov	r4, r0
    bd98:	3800      	subs	r0, #0
    bd9a:	4b05      	ldr	r3, [pc, #20]	; (bdb0 <spi_m_dma_enable+0x1c>)
    bd9c:	4905      	ldr	r1, [pc, #20]	; (bdb4 <spi_m_dma_enable+0x20>)
    bd9e:	bf18      	it	ne
    bda0:	2001      	movne	r0, #1
    bda2:	2251      	movs	r2, #81	; 0x51
    bda4:	4798      	blx	r3
	_spi_m_dma_enable(&spi->dev);
    bda6:	1d20      	adds	r0, r4, #4
    bda8:	4b03      	ldr	r3, [pc, #12]	; (bdb8 <spi_m_dma_enable+0x24>)
}
    bdaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_dma_enable(&spi->dev);
    bdae:	4718      	bx	r3
    bdb0:	0000e42d 	.word	0x0000e42d
    bdb4:	000166a2 	.word	0x000166a2
    bdb8:	00011c21 	.word	0x00011c21

0000bdbc <spi_m_dma_register_callback>:
	return _spi_m_dma_transfer(&spi->dev, txbuf, rxbuf, length);
}

void spi_m_dma_register_callback(struct spi_m_dma_descriptor *spi, const enum spi_m_dma_cb_type type,
                                 spi_m_dma_cb_t func)
{
    bdbc:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    bdbe:	4604      	mov	r4, r0
    bdc0:	3800      	subs	r0, #0
{
    bdc2:	460d      	mov	r5, r1
    bdc4:	4616      	mov	r6, r2
	ASSERT(spi);
    bdc6:	4907      	ldr	r1, [pc, #28]	; (bde4 <spi_m_dma_register_callback+0x28>)
    bdc8:	4b07      	ldr	r3, [pc, #28]	; (bde8 <spi_m_dma_register_callback+0x2c>)
    bdca:	f04f 02a8 	mov.w	r2, #168	; 0xa8
    bdce:	bf18      	it	ne
    bdd0:	2001      	movne	r0, #1
    bdd2:	4798      	blx	r3
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    bdd4:	4632      	mov	r2, r6
    bdd6:	4629      	mov	r1, r5
    bdd8:	1d20      	adds	r0, r4, #4
    bdda:	4b04      	ldr	r3, [pc, #16]	; (bdec <spi_m_dma_register_callback+0x30>)
}
    bddc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    bde0:	4718      	bx	r3
    bde2:	bf00      	nop
    bde4:	000166a2 	.word	0x000166a2
    bde8:	0000e42d 	.word	0x0000e42d
    bdec:	00011c51 	.word	0x00011c51

0000bdf0 <spi_m_dma_get_io_descriptor>:

int32_t spi_m_dma_get_io_descriptor(struct spi_m_dma_descriptor *const spi, struct io_descriptor **io)
{
    bdf0:	b538      	push	{r3, r4, r5, lr}
    bdf2:	460d      	mov	r5, r1
	ASSERT(spi && io);
    bdf4:	4604      	mov	r4, r0
    bdf6:	b110      	cbz	r0, bdfe <spi_m_dma_get_io_descriptor+0xe>
    bdf8:	1e08      	subs	r0, r1, #0
    bdfa:	bf18      	it	ne
    bdfc:	2001      	movne	r0, #1
    bdfe:	4904      	ldr	r1, [pc, #16]	; (be10 <spi_m_dma_get_io_descriptor+0x20>)
    be00:	4b04      	ldr	r3, [pc, #16]	; (be14 <spi_m_dma_get_io_descriptor+0x24>)
    be02:	22ae      	movs	r2, #174	; 0xae
	*io = &spi->io;
    be04:	3420      	adds	r4, #32
	ASSERT(spi && io);
    be06:	4798      	blx	r3
	*io = &spi->io;
    be08:	602c      	str	r4, [r5, #0]

	return 0;
}
    be0a:	2000      	movs	r0, #0
    be0c:	bd38      	pop	{r3, r4, r5, pc}
    be0e:	bf00      	nop
    be10:	000166a2 	.word	0x000166a2
    be14:	0000e42d 	.word	0x0000e42d

0000be18 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    be18:	3801      	subs	r0, #1
    be1a:	2802      	cmp	r0, #2
{
    be1c:	b508      	push	{r3, lr}
    be1e:	460b      	mov	r3, r1
    be20:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    be22:	d805      	bhi.n	be30 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    be24:	4618      	mov	r0, r3
    be26:	4b04      	ldr	r3, [pc, #16]	; (be38 <_write+0x20>)
    be28:	4798      	blx	r3
	if (n < 0) {
    be2a:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    be2e:	bd08      	pop	{r3, pc}
		return -1;
    be30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    be34:	e7fb      	b.n	be2e <_write+0x16>
    be36:	bf00      	nop
    be38:	0000bcc5 	.word	0x0000bcc5

0000be3c <_event_system_init>:

/**
 * \brief Initialize event system
 */
int32_t _event_system_init(void)
{
    be3c:	b510      	push	{r4, lr}
    be3e:	4a13      	ldr	r2, [pc, #76]	; (be8c <_event_system_init+0x50>)
}

static inline void hri_evsys_write_USER_reg(const void *const hw, uint8_t index, hri_evsys_user_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->USER[index].reg = data;
    be40:	4913      	ldr	r1, [pc, #76]	; (be90 <_event_system_init+0x54>)
    be42:	2300      	movs	r3, #0
    be44:	f103 0048 	add.w	r0, r3, #72	; 0x48
    be48:	3301      	adds	r3, #1
	uint8_t i;
	/* configure user multiplexers */
	for (i = 0; i < EVSYS_USERS; i++) {
		hri_evsys_write_USER_reg(EVSYS, i, user_mux_confs[i]);
    be4a:	f812 4b01 	ldrb.w	r4, [r2], #1
    be4e:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	for (i = 0; i < EVSYS_USERS; i++) {
    be52:	2b43      	cmp	r3, #67	; 0x43
    be54:	d1f6      	bne.n	be44 <_event_system_init+0x8>
    be56:	480f      	ldr	r0, [pc, #60]	; (be94 <_event_system_init+0x58>)
    be58:	2100      	movs	r1, #0
    be5a:	f100 0440 	add.w	r4, r0, #64	; 0x40
	}

	/* configure channels */
	for (i = 0; i < EVSYS_CHANNELS; i++) {
		hri_evsys_write_CHANNEL_reg(EVSYS, i, channel_confs[i]);
    be5e:	00ca      	lsls	r2, r1, #3
    be60:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    be64:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    be68:	f830 3b02 	ldrh.w	r3, [r0], #2

static inline void hri_evsys_write_CHANNEL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_channel_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->Channel[submodule_index].CHANNEL.reg = data;
    be6c:	6213      	str	r3, [r2, #32]
		hri_evsys_write_CHINTEN_reg(EVSYS, i, interrupt_cfg[i]);
    be6e:	f854 3b04 	ldr.w	r3, [r4], #4
    be72:	b2db      	uxtb	r3, r3
	((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg = data;
    be74:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
	((Evsys *)hw)->Channel[submodule_index].CHINTENCLR.reg = ~data;
    be78:	3101      	adds	r1, #1
    be7a:	43db      	mvns	r3, r3
    be7c:	b2db      	uxtb	r3, r3
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    be7e:	2920      	cmp	r1, #32
    be80:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    be84:	d1eb      	bne.n	be5e <_event_system_init+0x22>
	}

	return ERR_NONE;
}
    be86:	2000      	movs	r0, #0
    be88:	bd10      	pop	{r4, pc}
    be8a:	bf00      	nop
    be8c:	000166c0 	.word	0x000166c0
    be90:	4100e000 	.word	0x4100e000
    be94:	00016704 	.word	0x00016704

0000be98 <_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    be98:	0943      	lsrs	r3, r0, #5
    be9a:	2201      	movs	r2, #1
    be9c:	f000 001f 	and.w	r0, r0, #31
    bea0:	fa02 f000 	lsl.w	r0, r2, r0
    bea4:	3340      	adds	r3, #64	; 0x40
    bea6:	4a02      	ldr	r2, [pc, #8]	; (beb0 <_irq_set+0x18>)
    bea8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
}
    beac:	4770      	bx	lr
    beae:	bf00      	nop
    beb0:	e000e100 	.word	0xe000e100

0000beb4 <_get_cycles_for_ms>:
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    beb4:	4b01      	ldr	r3, [pc, #4]	; (bebc <_get_cycles_for_ms+0x8>)
    beb6:	4358      	muls	r0, r3
    beb8:	4770      	bx	lr
    beba:	bf00      	nop
    bebc:	0001d4c0 	.word	0x0001d4c0

0000bec0 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    bec0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    bec4:	4615      	mov	r5, r2
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    bec6:	780a      	ldrb	r2, [r1, #0]
    bec8:	f3c2 1341 	ubfx	r3, r2, #5, #2
    becc:	2b01      	cmp	r3, #1
{
    bece:	4606      	mov	r6, r0
    bed0:	460c      	mov	r4, r1
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    bed2:	d155      	bne.n	bf80 <cdcdf_acm_req+0xc0>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    bed4:	4b2d      	ldr	r3, [pc, #180]	; (bf8c <cdcdf_acm_req+0xcc>)
    bed6:	8889      	ldrh	r1, [r1, #4]
    bed8:	7818      	ldrb	r0, [r3, #0]
    beda:	4288      	cmp	r0, r1
    bedc:	4698      	mov	r8, r3
    bede:	d002      	beq.n	bee6 <cdcdf_acm_req+0x26>
    bee0:	785b      	ldrb	r3, [r3, #1]
    bee2:	428b      	cmp	r3, r1
    bee4:	d14c      	bne.n	bf80 <cdcdf_acm_req+0xc0>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    bee6:	0613      	lsls	r3, r2, #24
    bee8:	88e7      	ldrh	r7, [r4, #6]
    beea:	d50f      	bpl.n	bf0c <cdcdf_acm_req+0x4c>
	if (USB_DATA_STAGE == stage) {
    beec:	2d01      	cmp	r5, #1
    beee:	d033      	beq.n	bf58 <cdcdf_acm_req+0x98>
	switch (req->bRequest) {
    bef0:	7863      	ldrb	r3, [r4, #1]
    bef2:	2b21      	cmp	r3, #33	; 0x21
    bef4:	d112      	bne.n	bf1c <cdcdf_acm_req+0x5c>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    bef6:	2f07      	cmp	r7, #7
    bef8:	d145      	bne.n	bf86 <cdcdf_acm_req+0xc6>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    befa:	4925      	ldr	r1, [pc, #148]	; (bf90 <cdcdf_acm_req+0xd0>)
    befc:	2300      	movs	r3, #0
    befe:	463a      	mov	r2, r7
			return usbdc_xfer(ep, ctrl_buf, len, false);
    bf00:	4c24      	ldr	r4, [pc, #144]	; (bf94 <cdcdf_acm_req+0xd4>)
    bf02:	4630      	mov	r0, r6
    bf04:	47a0      	blx	r4
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    bf06:	b002      	add	sp, #8
    bf08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    bf0c:	4b22      	ldr	r3, [pc, #136]	; (bf98 <cdcdf_acm_req+0xd8>)
    bf0e:	4798      	blx	r3
	switch (req->bRequest) {
    bf10:	7863      	ldrb	r3, [r4, #1]
    bf12:	2b20      	cmp	r3, #32
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    bf14:	4601      	mov	r1, r0
	switch (req->bRequest) {
    bf16:	d004      	beq.n	bf22 <cdcdf_acm_req+0x62>
    bf18:	2b22      	cmp	r3, #34	; 0x22
    bf1a:	d024      	beq.n	bf66 <cdcdf_acm_req+0xa6>
		return ERR_INVALID_ARG;
    bf1c:	f06f 000c 	mvn.w	r0, #12
    bf20:	e7f1      	b.n	bf06 <cdcdf_acm_req+0x46>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    bf22:	2f07      	cmp	r7, #7
    bf24:	d12f      	bne.n	bf86 <cdcdf_acm_req+0xc6>
		if (USB_SETUP_STAGE == stage) {
    bf26:	b915      	cbnz	r5, bf2e <cdcdf_acm_req+0x6e>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    bf28:	462b      	mov	r3, r5
    bf2a:	463a      	mov	r2, r7
    bf2c:	e7e8      	b.n	bf00 <cdcdf_acm_req+0x40>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    bf2e:	6800      	ldr	r0, [r0, #0]
    bf30:	9000      	str	r0, [sp, #0]
    bf32:	798b      	ldrb	r3, [r1, #6]
    bf34:	888a      	ldrh	r2, [r1, #4]
    bf36:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bf3a:	f8d8 3010 	ldr.w	r3, [r8, #16]
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    bf3e:	f8ad 2004 	strh.w	r2, [sp, #4]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bf42:	b95b      	cbnz	r3, bf5c <cdcdf_acm_req+0x9c>
				usbd_cdc_line_coding = line_coding_tmp;
    bf44:	4b12      	ldr	r3, [pc, #72]	; (bf90 <cdcdf_acm_req+0xd0>)
    bf46:	9800      	ldr	r0, [sp, #0]
    bf48:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    bf4c:	f89d 2006 	ldrb.w	r2, [sp, #6]
    bf50:	f8c8 0006 	str.w	r0, [r8, #6]
    bf54:	8099      	strh	r1, [r3, #4]
    bf56:	719a      	strb	r2, [r3, #6]
		return ERR_NONE;
    bf58:	2000      	movs	r0, #0
    bf5a:	e7d4      	b.n	bf06 <cdcdf_acm_req+0x46>
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    bf5c:	4668      	mov	r0, sp
    bf5e:	4798      	blx	r3
    bf60:	2800      	cmp	r0, #0
    bf62:	d1ef      	bne.n	bf44 <cdcdf_acm_req+0x84>
    bf64:	e7f8      	b.n	bf58 <cdcdf_acm_req+0x98>
		usbdc_xfer(0, NULL, 0, 0);
    bf66:	2300      	movs	r3, #0
    bf68:	461a      	mov	r2, r3
    bf6a:	4619      	mov	r1, r3
    bf6c:	4618      	mov	r0, r3
    bf6e:	4d09      	ldr	r5, [pc, #36]	; (bf94 <cdcdf_acm_req+0xd4>)
    bf70:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    bf72:	f8d8 3014 	ldr.w	r3, [r8, #20]
    bf76:	2b00      	cmp	r3, #0
    bf78:	d0ee      	beq.n	bf58 <cdcdf_acm_req+0x98>
			cdcdf_acm_notify_state(req->wValue);
    bf7a:	8860      	ldrh	r0, [r4, #2]
    bf7c:	4798      	blx	r3
    bf7e:	e7eb      	b.n	bf58 <cdcdf_acm_req+0x98>
		return ERR_NOT_FOUND;
    bf80:	f06f 0009 	mvn.w	r0, #9
    bf84:	e7bf      	b.n	bf06 <cdcdf_acm_req+0x46>
			return ERR_INVALID_DATA;
    bf86:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    bf8a:	e7bc      	b.n	bf06 <cdcdf_acm_req+0x46>
    bf8c:	20008524 	.word	0x20008524
    bf90:	2000852a 	.word	0x2000852a
    bf94:	00013711 	.word	0x00013711
    bf98:	00013b3d 	.word	0x00013b3d

0000bf9c <cdcdf_acm_ctrl>:
	switch (ctrl) {
    bf9c:	2901      	cmp	r1, #1
{
    bf9e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bfa2:	4615      	mov	r5, r2
	switch (ctrl) {
    bfa4:	d04f      	beq.n	c046 <cdcdf_acm_ctrl+0xaa>
    bfa6:	2902      	cmp	r1, #2
    bfa8:	d076      	beq.n	c098 <cdcdf_acm_ctrl+0xfc>
    bfaa:	2900      	cmp	r1, #0
    bfac:	d177      	bne.n	c09e <cdcdf_acm_ctrl+0x102>
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    bfae:	6887      	ldr	r7, [r0, #8]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bfb0:	f8df 8114 	ldr.w	r8, [pc, #276]	; c0c8 <cdcdf_acm_ctrl+0x12c>
	ifc = desc->sod;
    bfb4:	6810      	ldr	r0, [r2, #0]
	for (i = 0; i < 2; i++) {
    bfb6:	1e7e      	subs	r6, r7, #1
		if (NULL == ifc) {
    bfb8:	b928      	cbnz	r0, bfc6 <cdcdf_acm_ctrl+0x2a>
			return ERR_NOT_FOUND;
    bfba:	f06f 0009 	mvn.w	r0, #9
}
    bfbe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    bfc2:	464e      	mov	r6, r9
    bfc4:	e7f8      	b.n	bfb8 <cdcdf_acm_ctrl+0x1c>
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bfc6:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    bfc8:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    bfca:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    bfce:	2b02      	cmp	r3, #2
    bfd0:	d1f3      	bne.n	bfba <cdcdf_acm_ctrl+0x1e>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    bfd2:	7873      	ldrb	r3, [r6, #1]
    bfd4:	429a      	cmp	r2, r3
    bfd6:	d065      	beq.n	c0a4 <cdcdf_acm_ctrl+0x108>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    bfd8:	2bff      	cmp	r3, #255	; 0xff
    bfda:	d166      	bne.n	c0aa <cdcdf_acm_ctrl+0x10e>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    bfdc:	7072      	strb	r2, [r6, #1]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    bfde:	6869      	ldr	r1, [r5, #4]
    bfe0:	f8df a0e8 	ldr.w	sl, [pc, #232]	; c0cc <cdcdf_acm_ctrl+0x130>
    bfe4:	2205      	movs	r2, #5
    bfe6:	47c0      	blx	r8
    bfe8:	f106 0901 	add.w	r9, r6, #1
    bfec:	4604      	mov	r4, r0
		while (NULL != ep) {
    bfee:	b964      	cbnz	r4, c00a <cdcdf_acm_ctrl+0x6e>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    bff0:	682b      	ldr	r3, [r5, #0]
    bff2:	6869      	ldr	r1, [r5, #4]
    bff4:	7818      	ldrb	r0, [r3, #0]
    bff6:	2204      	movs	r2, #4
    bff8:	4418      	add	r0, r3
    bffa:	47c0      	blx	r8
	for (i = 0; i < 2; i++) {
    bffc:	42be      	cmp	r6, r7
    bffe:	d1e0      	bne.n	bfc2 <cdcdf_acm_ctrl+0x26>
	_cdcdf_acm_funcd.enabled = true;
    c000:	4b2d      	ldr	r3, [pc, #180]	; (c0b8 <cdcdf_acm_ctrl+0x11c>)
    c002:	2201      	movs	r2, #1
    c004:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    c006:	4620      	mov	r0, r4
    c008:	e7d9      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
	return (ptr[0] + (ptr[1] << 8));
    c00a:	7961      	ldrb	r1, [r4, #5]
    c00c:	7922      	ldrb	r2, [r4, #4]
			ep_desc.bEndpointAddress = ep[2];
    c00e:	f894 b002 	ldrb.w	fp, [r4, #2]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    c012:	4b2a      	ldr	r3, [pc, #168]	; (c0bc <cdcdf_acm_ctrl+0x120>)
    c014:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    c018:	b292      	uxth	r2, r2
    c01a:	78e1      	ldrb	r1, [r4, #3]
    c01c:	4658      	mov	r0, fp
    c01e:	4798      	blx	r3
    c020:	2800      	cmp	r0, #0
    c022:	d145      	bne.n	c0b0 <cdcdf_acm_ctrl+0x114>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    c024:	f01b 0f80 	tst.w	fp, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    c028:	bf14      	ite	ne
    c02a:	f889 b002 	strbne.w	fp, [r9, #2]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    c02e:	f887 b004 	strbeq.w	fp, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    c032:	4658      	mov	r0, fp
    c034:	47d0      	blx	sl
			desc->sod = ep;
    c036:	602c      	str	r4, [r5, #0]
	return (desc + usb_desc_len(desc));
    c038:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    c03a:	6869      	ldr	r1, [r5, #4]
    c03c:	4b20      	ldr	r3, [pc, #128]	; (c0c0 <cdcdf_acm_ctrl+0x124>)
    c03e:	4420      	add	r0, r4
    c040:	4798      	blx	r3
    c042:	4604      	mov	r4, r0
    c044:	e7d3      	b.n	bfee <cdcdf_acm_ctrl+0x52>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    c046:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    c048:	b12a      	cbz	r2, c056 <cdcdf_acm_ctrl+0xba>
		ifc_desc.bInterfaceClass = desc->sod[5];
    c04a:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    c04c:	795b      	ldrb	r3, [r3, #5]
    c04e:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    c052:	2b02      	cmp	r3, #2
    c054:	d1b1      	bne.n	bfba <cdcdf_acm_ctrl+0x1e>
		if (func_data->func_iface[i] == 0xFF) {
    c056:	7823      	ldrb	r3, [r4, #0]
    c058:	2bff      	cmp	r3, #255	; 0xff
    c05a:	d007      	beq.n	c06c <cdcdf_acm_ctrl+0xd0>
			if (func_data->func_ep_in[i] != 0xFF) {
    c05c:	78a0      	ldrb	r0, [r4, #2]
			func_data->func_iface[i] = 0xFF;
    c05e:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    c060:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    c062:	7025      	strb	r5, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    c064:	d002      	beq.n	c06c <cdcdf_acm_ctrl+0xd0>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    c066:	4b17      	ldr	r3, [pc, #92]	; (c0c4 <cdcdf_acm_ctrl+0x128>)
    c068:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    c06a:	70a5      	strb	r5, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    c06c:	7863      	ldrb	r3, [r4, #1]
    c06e:	2bff      	cmp	r3, #255	; 0xff
    c070:	d007      	beq.n	c082 <cdcdf_acm_ctrl+0xe6>
			if (func_data->func_ep_in[i] != 0xFF) {
    c072:	78e0      	ldrb	r0, [r4, #3]
			func_data->func_iface[i] = 0xFF;
    c074:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    c076:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    c078:	7065      	strb	r5, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    c07a:	d002      	beq.n	c082 <cdcdf_acm_ctrl+0xe6>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    c07c:	4b11      	ldr	r3, [pc, #68]	; (c0c4 <cdcdf_acm_ctrl+0x128>)
    c07e:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    c080:	70e5      	strb	r5, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    c082:	7920      	ldrb	r0, [r4, #4]
    c084:	28ff      	cmp	r0, #255	; 0xff
    c086:	d003      	beq.n	c090 <cdcdf_acm_ctrl+0xf4>
		usb_d_ep_deinit(func_data->func_ep_out);
    c088:	4b0e      	ldr	r3, [pc, #56]	; (c0c4 <cdcdf_acm_ctrl+0x128>)
    c08a:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    c08c:	23ff      	movs	r3, #255	; 0xff
    c08e:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    c090:	4b09      	ldr	r3, [pc, #36]	; (c0b8 <cdcdf_acm_ctrl+0x11c>)
    c092:	2000      	movs	r0, #0
    c094:	7158      	strb	r0, [r3, #5]
	return ERR_NONE;
    c096:	e792      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
		return ERR_UNSUPPORTED_OP;
    c098:	f06f 001a 	mvn.w	r0, #26
    c09c:	e78f      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
	switch (ctrl) {
    c09e:	f06f 000c 	mvn.w	r0, #12
    c0a2:	e78c      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
				return ERR_ALREADY_INITIALIZED;
    c0a4:	f06f 0011 	mvn.w	r0, #17
    c0a8:	e789      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
				return ERR_NO_RESOURCE;
    c0aa:	f06f 001b 	mvn.w	r0, #27
    c0ae:	e786      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
				return ERR_NOT_INITIALIZED;
    c0b0:	f06f 0013 	mvn.w	r0, #19
    c0b4:	e783      	b.n	bfbe <cdcdf_acm_ctrl+0x22>
    c0b6:	bf00      	nop
    c0b8:	20008524 	.word	0x20008524
    c0bc:	0000f911 	.word	0x0000f911
    c0c0:	0000bbf7 	.word	0x0000bbf7
    c0c4:	0000f975 	.word	0x0000f975
    c0c8:	0000bbdd 	.word	0x0000bbdd
    c0cc:	0000f9a1 	.word	0x0000f9a1

0000c0d0 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    c0d0:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    c0d2:	4b0a      	ldr	r3, [pc, #40]	; (c0fc <cdcdf_acm_init+0x2c>)
    c0d4:	4798      	blx	r3
    c0d6:	2801      	cmp	r0, #1
    c0d8:	d80c      	bhi.n	c0f4 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    c0da:	4809      	ldr	r0, [pc, #36]	; (c100 <cdcdf_acm_init+0x30>)
    c0dc:	4b09      	ldr	r3, [pc, #36]	; (c104 <cdcdf_acm_init+0x34>)
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    c0de:	e9c0 3007 	strd	r3, r0, [r0, #28]

	usbdc_register_function(&_cdcdf_acm);
    c0e2:	4b09      	ldr	r3, [pc, #36]	; (c108 <cdcdf_acm_init+0x38>)
    c0e4:	3018      	adds	r0, #24
    c0e6:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    c0e8:	2001      	movs	r0, #1
    c0ea:	4908      	ldr	r1, [pc, #32]	; (c10c <cdcdf_acm_init+0x3c>)
    c0ec:	4b08      	ldr	r3, [pc, #32]	; (c110 <cdcdf_acm_init+0x40>)
    c0ee:	4798      	blx	r3
	return ERR_NONE;
    c0f0:	2000      	movs	r0, #0
}
    c0f2:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    c0f4:	f06f 0010 	mvn.w	r0, #16
    c0f8:	e7fb      	b.n	c0f2 <cdcdf_acm_init+0x22>
    c0fa:	bf00      	nop
    c0fc:	00013b49 	.word	0x00013b49
    c100:	20008524 	.word	0x20008524
    c104:	0000bf9d 	.word	0x0000bf9d
    c108:	00013af1 	.word	0x00013af1
    c10c:	20000354 	.word	0x20000354
    c110:	00013a69 	.word	0x00013a69

0000c114 <cdcdf_acm_read>:

/**
 * \brief USB CDC ACM Function Read Data
 */
int32_t cdcdf_acm_read(uint8_t *buf, uint32_t size)
{
    c114:	b410      	push	{r4}
/**
 * \brief Check whether CDC ACM Function is enabled
 */
bool cdcdf_acm_is_enabled(void)
{
	return _cdcdf_acm_funcd.enabled;
    c116:	4c08      	ldr	r4, [pc, #32]	; (c138 <cdcdf_acm_read+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    c118:	7963      	ldrb	r3, [r4, #5]
{
    c11a:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    c11c:	b13b      	cbz	r3, c12e <cdcdf_acm_read+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    c11e:	4601      	mov	r1, r0
    c120:	7920      	ldrb	r0, [r4, #4]
    c122:	4c06      	ldr	r4, [pc, #24]	; (c13c <cdcdf_acm_read+0x28>)
    c124:	2300      	movs	r3, #0
    c126:	46a4      	mov	ip, r4
}
    c128:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    c12c:	4760      	bx	ip
}
    c12e:	f06f 0010 	mvn.w	r0, #16
    c132:	f85d 4b04 	ldr.w	r4, [sp], #4
    c136:	4770      	bx	lr
    c138:	20008524 	.word	0x20008524
    c13c:	00013711 	.word	0x00013711

0000c140 <cdcdf_acm_write>:
{
    c140:	b410      	push	{r4}
	return _cdcdf_acm_funcd.enabled;
    c142:	4c08      	ldr	r4, [pc, #32]	; (c164 <cdcdf_acm_write+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    c144:	7963      	ldrb	r3, [r4, #5]
{
    c146:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    c148:	b13b      	cbz	r3, c15a <cdcdf_acm_write+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    c14a:	4601      	mov	r1, r0
    c14c:	78e0      	ldrb	r0, [r4, #3]
    c14e:	4c06      	ldr	r4, [pc, #24]	; (c168 <cdcdf_acm_write+0x28>)
    c150:	2301      	movs	r3, #1
    c152:	46a4      	mov	ip, r4
}
    c154:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    c158:	4760      	bx	ip
}
    c15a:	f06f 0010 	mvn.w	r0, #16
    c15e:	f85d 4b04 	ldr.w	r4, [sp], #4
    c162:	4770      	bx	lr
    c164:	20008524 	.word	0x20008524
    c168:	00013711 	.word	0x00013711

0000c16c <cdcdf_acm_register_callback>:
{
    c16c:	b508      	push	{r3, lr}
    c16e:	460a      	mov	r2, r1
    c170:	2803      	cmp	r0, #3
    c172:	d814      	bhi.n	c19e <cdcdf_acm_register_callback+0x32>
    c174:	e8df f000 	tbb	[pc, r0]
    c178:	100d0902 	.word	0x100d0902
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    c17c:	4b09      	ldr	r3, [pc, #36]	; (c1a4 <cdcdf_acm_register_callback+0x38>)
    c17e:	7918      	ldrb	r0, [r3, #4]
    c180:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    c182:	4b09      	ldr	r3, [pc, #36]	; (c1a8 <cdcdf_acm_register_callback+0x3c>)
    c184:	4798      	blx	r3
	return ERR_NONE;
    c186:	2000      	movs	r0, #0
}
    c188:	bd08      	pop	{r3, pc}
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    c18a:	4b06      	ldr	r3, [pc, #24]	; (c1a4 <cdcdf_acm_register_callback+0x38>)
    c18c:	2102      	movs	r1, #2
    c18e:	78d8      	ldrb	r0, [r3, #3]
    c190:	e7f7      	b.n	c182 <cdcdf_acm_register_callback+0x16>
		cdcdf_acm_set_line_coding = (cdcdf_acm_set_line_coding_t)func;
    c192:	4b04      	ldr	r3, [pc, #16]	; (c1a4 <cdcdf_acm_register_callback+0x38>)
    c194:	6119      	str	r1, [r3, #16]
		break;
    c196:	e7f6      	b.n	c186 <cdcdf_acm_register_callback+0x1a>
		cdcdf_acm_notify_state = (cdcdf_acm_notify_state_t)func;
    c198:	4b02      	ldr	r3, [pc, #8]	; (c1a4 <cdcdf_acm_register_callback+0x38>)
    c19a:	6159      	str	r1, [r3, #20]
    c19c:	e7f3      	b.n	c186 <cdcdf_acm_register_callback+0x1a>
	return ERR_NONE;
    c19e:	f06f 000c 	mvn.w	r0, #12
    c1a2:	e7f1      	b.n	c188 <cdcdf_acm_register_callback+0x1c>
    c1a4:	20008524 	.word	0x20008524
    c1a8:	0000fb89 	.word	0x0000fb89

0000c1ac <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    c1ac:	4b04      	ldr	r3, [pc, #16]	; (c1c0 <_sbrk+0x14>)
    c1ae:	6819      	ldr	r1, [r3, #0]
{
    c1b0:	4602      	mov	r2, r0
	if (heap == NULL) {
    c1b2:	b909      	cbnz	r1, c1b8 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
    c1b4:	4903      	ldr	r1, [pc, #12]	; (c1c4 <_sbrk+0x18>)
    c1b6:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
    c1b8:	6818      	ldr	r0, [r3, #0]

	heap += incr;
    c1ba:	4402      	add	r2, r0
    c1bc:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
}
    c1be:	4770      	bx	lr
    c1c0:	20008548 	.word	0x20008548
    c1c4:	2002cfe8 	.word	0x2002cfe8

0000c1c8 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    c1c8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c1cc:	4770      	bx	lr

0000c1ce <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    c1ce:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c1d2:	604b      	str	r3, [r1, #4]

	return 0;
}
    c1d4:	2000      	movs	r0, #0
    c1d6:	4770      	bx	lr

0000c1d8 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    c1d8:	2001      	movs	r0, #1
    c1da:	4770      	bx	lr

0000c1dc <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    c1dc:	2000      	movs	r0, #0
    c1de:	4770      	bx	lr

0000c1e0 <_qspi_dma_rx_complete>:
 *  \brief Callback for RX
 *  \param[in, out] dev Pointer to the DMA resource.
 */
static void _qspi_dma_rx_complete(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;
    c1e0:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_qspi_write_CTRLA_reg(const void *const hw, hri_qspi_ctrla_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLA.reg = data;
    c1e2:	4903      	ldr	r1, [pc, #12]	; (c1f0 <_qspi_dma_rx_complete+0x10>)

	_qspi_end_transfer(dev->prvt);
    c1e4:	681a      	ldr	r2, [r3, #0]

	if (dev->cb.xfer_done) {
    c1e6:	685b      	ldr	r3, [r3, #4]
    c1e8:	6011      	str	r1, [r2, #0]
    c1ea:	b103      	cbz	r3, c1ee <_qspi_dma_rx_complete+0xe>
		dev->cb.xfer_done(resource);
    c1ec:	4718      	bx	r3
	}
}
    c1ee:	4770      	bx	lr
    c1f0:	01000002 	.word	0x01000002

0000c1f4 <_qspi_dma_tx_complete>:
    c1f4:	4b00      	ldr	r3, [pc, #0]	; (c1f8 <_qspi_dma_tx_complete+0x4>)
    c1f6:	4718      	bx	r3
    c1f8:	0000c1e1 	.word	0x0000c1e1

0000c1fc <_qspi_dma_error_occured>:
 */
static void _qspi_dma_error_occured(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;

	if (dev->cb.error) {
    c1fc:	6883      	ldr	r3, [r0, #8]
    c1fe:	689b      	ldr	r3, [r3, #8]
    c200:	b103      	cbz	r3, c204 <_qspi_dma_error_occured+0x8>
		dev->cb.error(resource);
    c202:	4718      	bx	r3
	}
}
    c204:	4770      	bx	lr
	...

0000c208 <_qspi_dma_init>:

int32_t _qspi_dma_init(struct _qspi_dma_dev *dev, void *const hw)
{
    c208:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c20a:	460d      	mov	r5, r1
	ASSERT(dev && hw);
    c20c:	4604      	mov	r4, r0
    c20e:	b110      	cbz	r0, c216 <_qspi_dma_init+0xe>
    c210:	1e08      	subs	r0, r1, #0
    c212:	bf18      	it	ne
    c214:	2001      	movne	r0, #1
	dev->prvt = hw;
    c216:	4626      	mov	r6, r4
	ASSERT(dev && hw);
    c218:	22cb      	movs	r2, #203	; 0xcb
    c21a:	490f      	ldr	r1, [pc, #60]	; (c258 <_qspi_dma_init+0x50>)
    c21c:	4b0f      	ldr	r3, [pc, #60]	; (c25c <_qspi_dma_init+0x54>)
	hri_qspi_write_BAUD_reg(hw,
	                        CONF_QSPI_CPOL << QSPI_BAUD_CPOL_Pos | CONF_QSPI_CPHA << QSPI_BAUD_CPHA_Pos
	                            | QSPI_BAUD_BAUD(CONF_QSPI_BAUD_RATE) | QSPI_BAUD_DLYBS(CONF_QSPI_DLYBS));

	/* Initialize DMA rx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    c21e:	4f10      	ldr	r7, [pc, #64]	; (c260 <_qspi_dma_init+0x58>)
	ASSERT(dev && hw);
    c220:	4798      	blx	r3
    c222:	2301      	movs	r3, #1
	dev->prvt = hw;
    c224:	f846 5b0c 	str.w	r5, [r6], #12
    c228:	602b      	str	r3, [r5, #0]
}

static inline void hri_qspi_write_CTRLB_reg(const void *const hw, hri_qspi_ctrlb_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLB.reg = data;
    c22a:	4b0e      	ldr	r3, [pc, #56]	; (c264 <_qspi_dma_init+0x5c>)
    c22c:	606b      	str	r3, [r5, #4]
}

static inline void hri_qspi_write_BAUD_reg(const void *const hw, hri_qspi_baud_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->BAUD.reg = data;
    c22e:	4b0e      	ldr	r3, [pc, #56]	; (c268 <_qspi_dma_init+0x60>)
    c230:	60ab      	str	r3, [r5, #8]
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    c232:	211f      	movs	r1, #31
    c234:	4630      	mov	r0, r6
    c236:	47b8      	blx	r7
	dev->resource->back                 = dev;
    c238:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    c23a:	4a0c      	ldr	r2, [pc, #48]	; (c26c <_qspi_dma_init+0x64>)
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    c23c:	4d0c      	ldr	r5, [pc, #48]	; (c270 <_qspi_dma_init+0x68>)
	dev->resource->back                 = dev;
    c23e:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    c240:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    c242:	605d      	str	r5, [r3, #4]
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_TX_CHANNEL);
    c244:	211e      	movs	r1, #30
    c246:	4630      	mov	r0, r6
    c248:	47b8      	blx	r7
	dev->resource->back                 = dev;
    c24a:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_tx_complete;
    c24c:	4a09      	ldr	r2, [pc, #36]	; (c274 <_qspi_dma_init+0x6c>)
	dev->resource->back                 = dev;
    c24e:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    c250:	e9c3 2500 	strd	r2, r5, [r3]

	return ERR_NONE;
}
    c254:	2000      	movs	r0, #0
    c256:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c258:	000167c4 	.word	0x000167c4
    c25c:	0000e42d 	.word	0x0000e42d
    c260:	0000e671 	.word	0x0000e671
    c264:	06000011 	.word	0x06000011
    c268:	00243b00 	.word	0x00243b00
    c26c:	0000c1e1 	.word	0x0000c1e1
    c270:	0000c1fd 	.word	0x0000c1fd
    c274:	0000c1f5 	.word	0x0000c1f5

0000c278 <_flash_program>:
 * \param[in]  buffer        Pointer to buffer where the data to
 *                           write is stored
 * \param[in] size           The size of data to write to a page
 */
static void _flash_program(void *const hw, const uint32_t dst_addr, const uint8_t *buffer, const uint16_t size)
{
    c278:	b570      	push	{r4, r5, r6, lr}
	uint32_t *ptr_read    = (uint32_t *)buffer;
	uint32_t  nvm_address = dst_addr / 4;
    c27a:	088d      	lsrs	r5, r1, #2
	return ((Nvmctrl *)hw)->PARAM.reg;
}

static inline bool hri_nvmctrl_get_STATUS_READY_bit(const void *const hw)
{
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c27c:	8a44      	ldrh	r4, [r0, #18]
	uint16_t  i;

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c27e:	07e6      	lsls	r6, r4, #31
    c280:	d5fc      	bpl.n	c27c <_flash_program+0x4>
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c282:	f24a 5415 	movw	r4, #42261	; 0xa515
    c286:	8084      	strh	r4, [r0, #4]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c288:	8a44      	ldrh	r4, [r0, #18]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_PBC | NVMCTRL_CTRLB_CMDEX_KEY);

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c28a:	07e4      	lsls	r4, r4, #31
    c28c:	d5fc      	bpl.n	c288 <_flash_program+0x10>
    c28e:	00ad      	lsls	r5, r5, #2
    c290:	2400      	movs	r4, #0
		/* Wait until this module isn't busy */
	}

	/* Writes to the page buffer must be 32 bits, perform manual copy
	 * to ensure alignment */
	for (i = 0; i < size; i += 4) {
    c292:	b2a6      	uxth	r6, r4
    c294:	429e      	cmp	r6, r3
    c296:	d307      	bcc.n	c2a8 <_flash_program+0x30>
    c298:	8a43      	ldrh	r3, [r0, #18]
		NVM_MEMORY[nvm_address++] = *ptr_read;
		ptr_read++;
	}

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c29a:	07db      	lsls	r3, r3, #31
    c29c:	d5fc      	bpl.n	c298 <_flash_program+0x20>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c29e:	f24a 5303 	movw	r3, #42243	; 0xa503
	((Nvmctrl *)hw)->ADDR.reg = data;
    c2a2:	6141      	str	r1, [r0, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c2a4:	8083      	strh	r3, [r0, #4]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_ADDR_reg(hw, dst_addr);
	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_WP | NVMCTRL_CTRLB_CMDEX_KEY);
}
    c2a6:	bd70      	pop	{r4, r5, r6, pc}
		NVM_MEMORY[nvm_address++] = *ptr_read;
    c2a8:	5916      	ldr	r6, [r2, r4]
    c2aa:	5166      	str	r6, [r4, r5]
	for (i = 0; i < size; i += 4) {
    c2ac:	3404      	adds	r4, #4
    c2ae:	e7f0      	b.n	c292 <_flash_program+0x1a>

0000c2b0 <_flash_init>:
{
    c2b0:	b538      	push	{r3, r4, r5, lr}
    c2b2:	460d      	mov	r5, r1
	ASSERT(device && (hw == NVMCTRL));
    c2b4:	4604      	mov	r4, r0
    c2b6:	b118      	cbz	r0, c2c0 <_flash_init+0x10>
    c2b8:	4814      	ldr	r0, [pc, #80]	; (c30c <_flash_init+0x5c>)
    c2ba:	1a0b      	subs	r3, r1, r0
    c2bc:	4258      	negs	r0, r3
    c2be:	4158      	adcs	r0, r3
    c2c0:	4913      	ldr	r1, [pc, #76]	; (c310 <_flash_init+0x60>)
    c2c2:	4b14      	ldr	r3, [pc, #80]	; (c314 <_flash_init+0x64>)
    c2c4:	224b      	movs	r2, #75	; 0x4b
    c2c6:	4798      	blx	r3
	return ((Nvmctrl *)hw)->CTRLA.reg;
    c2c8:	882b      	ldrh	r3, [r5, #0]
	device->hw = hw;
    c2ca:	6125      	str	r5, [r4, #16]
	hri_nvmctrl_write_CTRLA_reg(hw, ctrla);
    c2cc:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    c2d0:	049b      	lsls	r3, r3, #18
    c2d2:	0c9b      	lsrs	r3, r3, #18
	((Nvmctrl *)hw)->CTRLA.reg = data;
    c2d4:	802b      	strh	r3, [r5, #0]
	_nvm_dev = device;
    c2d6:	4b10      	ldr	r3, [pc, #64]	; (c318 <_flash_init+0x68>)
    c2d8:	601c      	str	r4, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c2da:	4b10      	ldr	r3, [pc, #64]	; (c31c <_flash_init+0x6c>)
    c2dc:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    c2e0:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
    c2e4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    c2e8:	f3bf 8f6f 	isb	sy
    c2ec:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    c2f0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    c2f4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    c2f8:	f3bf 8f6f 	isb	sy
}
    c2fc:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c2fe:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    c302:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c306:	6019      	str	r1, [r3, #0]
    c308:	601a      	str	r2, [r3, #0]
    c30a:	bd38      	pop	{r3, r4, r5, pc}
    c30c:	41004000 	.word	0x41004000
    c310:	000167db 	.word	0x000167db
    c314:	0000e42d 	.word	0x0000e42d
    c318:	2000854c 	.word	0x2000854c
    c31c:	e000e100 	.word	0xe000e100

0000c320 <_flash_get_page_size>:
}
    c320:	f44f 7000 	mov.w	r0, #512	; 0x200
    c324:	4770      	bx	lr

0000c326 <_flash_get_total_pages>:
	return (uint32_t)hri_nvmctrl_read_PARAM_NVMP_bf(device->hw);
    c326:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->PARAM.reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;
    c328:	6898      	ldr	r0, [r3, #8]
}
    c32a:	b280      	uxth	r0, r0
    c32c:	4770      	bx	lr

0000c32e <_flash_read>:
{
    c32e:	b510      	push	{r4, lr}
	while (!hri_nvmctrl_get_STATUS_READY_bit(device->hw)) {
    c330:	6904      	ldr	r4, [r0, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c332:	8a60      	ldrh	r0, [r4, #18]
    c334:	07c0      	lsls	r0, r0, #31
    c336:	d5fc      	bpl.n	c332 <_flash_read+0x4>
	for (i = 0; i < length; i++) {
    c338:	2000      	movs	r0, #0
    c33a:	e002      	b.n	c342 <_flash_read+0x14>
		buffer[i] = nvm_addr[src_addr + i];
    c33c:	5c44      	ldrb	r4, [r0, r1]
    c33e:	5414      	strb	r4, [r2, r0]
	for (i = 0; i < length; i++) {
    c340:	3001      	adds	r0, #1
    c342:	4298      	cmp	r0, r3
    c344:	d1fa      	bne.n	c33c <_flash_read+0xe>
}
    c346:	bd10      	pop	{r4, pc}

0000c348 <_flash_write>:
{
    c348:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c34c:	f5ad 5d00 	sub.w	sp, sp, #8192	; 0x2000
    c350:	b083      	sub	sp, #12
    c352:	4606      	mov	r6, r0
    c354:	460c      	mov	r4, r1
    c356:	4617      	mov	r7, r2
    c358:	9301      	str	r3, [sp, #4]
		block_start_addr = wr_start_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c35a:	f424 59ff 	bic.w	r9, r4, #8160	; 0x1fe0
    c35e:	f029 091f 	bic.w	r9, r9, #31
		block_end_addr   = block_start_addr + NVMCTRL_BLOCK_SIZE - 1;
    c362:	f509 5aff 	add.w	sl, r9, #8160	; 0x1fe0
    c366:	f10a 0a1f 	add.w	sl, sl, #31
    c36a:	f04f 0800 	mov.w	r8, #0
			_flash_read(device, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    c36e:	aa02      	add	r2, sp, #8
    c370:	4442      	add	r2, r8
    c372:	eb09 0108 	add.w	r1, r9, r8
    c376:	4d24      	ldr	r5, [pc, #144]	; (c408 <_flash_write+0xc0>)
    c378:	f44f 7300 	mov.w	r3, #512	; 0x200
    c37c:	4630      	mov	r0, r6
    c37e:	f508 7800 	add.w	r8, r8, #512	; 0x200
    c382:	47a8      	blx	r5
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    c384:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    c388:	d1f1      	bne.n	c36e <_flash_write+0x26>
		j = (wr_start_addr - block_start_addr) / NVMCTRL_PAGE_SIZE;
    c38a:	eba4 0309 	sub.w	r3, r4, r9
    c38e:	0a5a      	lsrs	r2, r3, #9
		k = wr_start_addr - block_start_addr - j * NVMCTRL_PAGE_SIZE;
    c390:	4639      	mov	r1, r7
    c392:	f3c3 0308 	ubfx	r3, r3, #0, #9
		while ((wr_start_addr <= block_end_addr) && (length > 0)) {
    c396:	4554      	cmp	r4, sl
    c398:	460f      	mov	r7, r1
    c39a:	d801      	bhi.n	c3a0 <_flash_write+0x58>
    c39c:	9801      	ldr	r0, [sp, #4]
    c39e:	bb18      	cbnz	r0, c3e8 <_flash_write+0xa0>
		_flash_erase_block(device->hw, block_start_addr);
    c3a0:	6933      	ldr	r3, [r6, #16]
    c3a2:	8a5a      	ldrh	r2, [r3, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c3a4:	07d2      	lsls	r2, r2, #31
    c3a6:	d5fc      	bpl.n	c3a2 <_flash_write+0x5a>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c3a8:	f24a 5201 	movw	r2, #42241	; 0xa501
			_flash_program(device->hw, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    c3ac:	f8df b05c 	ldr.w	fp, [pc, #92]	; c40c <_flash_write+0xc4>
	((Nvmctrl *)hw)->ADDR.reg = data;
    c3b0:	f8c3 9014 	str.w	r9, [r3, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c3b4:	f04f 0800 	mov.w	r8, #0
    c3b8:	809a      	strh	r2, [r3, #4]
    c3ba:	aa02      	add	r2, sp, #8
    c3bc:	4442      	add	r2, r8
    c3be:	eb09 0108 	add.w	r1, r9, r8
    c3c2:	6930      	ldr	r0, [r6, #16]
    c3c4:	f44f 7300 	mov.w	r3, #512	; 0x200
    c3c8:	f508 7800 	add.w	r8, r8, #512	; 0x200
    c3cc:	47d8      	blx	fp
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    c3ce:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    c3d2:	d1f2      	bne.n	c3ba <_flash_write+0x72>
	} while (block_end_addr < (wr_start_addr + length - 1));
    c3d4:	9b01      	ldr	r3, [sp, #4]
    c3d6:	4423      	add	r3, r4
    c3d8:	3b01      	subs	r3, #1
    c3da:	4553      	cmp	r3, sl
    c3dc:	d8bd      	bhi.n	c35a <_flash_write+0x12>
}
    c3de:	f50d 5d00 	add.w	sp, sp, #8192	; 0x2000
    c3e2:	b003      	add	sp, #12
    c3e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tmp_buffer[j][k] = *buffer;
    c3e8:	a802      	add	r0, sp, #8
    c3ea:	eb00 2042 	add.w	r0, r0, r2, lsl #9
    c3ee:	783f      	ldrb	r7, [r7, #0]
    c3f0:	54c7      	strb	r7, [r0, r3]
			k                = (k + 1) % NVMCTRL_PAGE_SIZE;
    c3f2:	3301      	adds	r3, #1
    c3f4:	f3c3 0308 	ubfx	r3, r3, #0, #9
			if (0 == k) {
    c3f8:	3101      	adds	r1, #1
    c3fa:	b903      	cbnz	r3, c3fe <_flash_write+0xb6>
				j++;
    c3fc:	3201      	adds	r2, #1
			length--;
    c3fe:	9801      	ldr	r0, [sp, #4]
    c400:	3801      	subs	r0, #1
			wr_start_addr++;
    c402:	3401      	adds	r4, #1
			length--;
    c404:	9001      	str	r0, [sp, #4]
    c406:	e7c6      	b.n	c396 <_flash_write+0x4e>
    c408:	0000c32f 	.word	0x0000c32f
    c40c:	0000c279 	.word	0x0000c279

0000c410 <_flash_erase>:
{
    c410:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c414:	f421 54ff 	bic.w	r4, r1, #8160	; 0x1fe0
{
    c418:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
    c41c:	460e      	mov	r6, r1
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c41e:	4b25      	ldr	r3, [pc, #148]	; (c4b4 <_flash_erase+0xa4>)
{
    c420:	4607      	mov	r7, r0
    c422:	4615      	mov	r5, r2
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c424:	f024 041f 	bic.w	r4, r4, #31
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c428:	f44f 7200 	mov.w	r2, #512	; 0x200
    c42c:	21ff      	movs	r1, #255	; 0xff
    c42e:	4668      	mov	r0, sp
    c430:	4798      	blx	r3
	if (dst_addr != block_start_addr) {
    c432:	42a6      	cmp	r6, r4
    c434:	d11e      	bne.n	c474 <_flash_erase+0x64>
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c436:	4622      	mov	r2, r4
    c438:	462b      	mov	r3, r5
    c43a:	f24a 5001 	movw	r0, #42241	; 0xa501
	while (page_nums >= NVMCTRL_BLOCK_PAGES) {
    c43e:	2b0f      	cmp	r3, #15
    c440:	d82e      	bhi.n	c4a0 <_flash_erase+0x90>
    c442:	0929      	lsrs	r1, r5, #4
    c444:	f06f 020f 	mvn.w	r2, #15
    c448:	fb02 5501 	mla	r5, r2, r1, r5
    c44c:	eb04 3441 	add.w	r4, r4, r1, lsl #13
	if (page_nums != 0) {
    c450:	b165      	cbz	r5, c46c <_flash_erase+0x5c>
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c452:	4e19      	ldr	r6, [pc, #100]	; (c4b8 <_flash_erase+0xa8>)
    c454:	eb04 2545 	add.w	r5, r4, r5, lsl #9
    c458:	4621      	mov	r1, r4
    c45a:	f44f 7300 	mov.w	r3, #512	; 0x200
    c45e:	466a      	mov	r2, sp
    c460:	4638      	mov	r0, r7
			block_start_addr += NVMCTRL_PAGE_SIZE;
    c462:	f504 7400 	add.w	r4, r4, #512	; 0x200
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c466:	47b0      	blx	r6
		for (i = 0; i < page_nums; i++) {
    c468:	42a5      	cmp	r5, r4
    c46a:	d1f5      	bne.n	c458 <_flash_erase+0x48>
}
    c46c:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
    c470:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c474:	f504 5800 	add.w	r8, r4, #8192	; 0x2000
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    c478:	f506 59f0 	add.w	r9, r6, #7680	; 0x1e00
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c47c:	4634      	mov	r4, r6
			_flash_write(device, dst_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c47e:	4e0e      	ldr	r6, [pc, #56]	; (c4b8 <_flash_erase+0xa8>)
    c480:	f44f 7300 	mov.w	r3, #512	; 0x200
    c484:	466a      	mov	r2, sp
    c486:	4621      	mov	r1, r4
    c488:	4638      	mov	r0, r7
    c48a:	47b0      	blx	r6
			if (--page_nums == 0) {
    c48c:	3d01      	subs	r5, #1
    c48e:	d0ed      	beq.n	c46c <_flash_erase+0x5c>
			dst_addr += NVMCTRL_PAGE_SIZE;
    c490:	f504 7400 	add.w	r4, r4, #512	; 0x200
			if (dst_addr == block_start_addr) {
    c494:	45a0      	cmp	r8, r4
    c496:	d0ce      	beq.n	c436 <_flash_erase+0x26>
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    c498:	45a1      	cmp	r9, r4
    c49a:	d1f1      	bne.n	c480 <_flash_erase+0x70>
    c49c:	4644      	mov	r4, r8
    c49e:	e7ca      	b.n	c436 <_flash_erase+0x26>
		_flash_erase_block(device->hw, block_start_addr);
    c4a0:	6939      	ldr	r1, [r7, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c4a2:	8a4e      	ldrh	r6, [r1, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c4a4:	07f6      	lsls	r6, r6, #31
    c4a6:	d5fc      	bpl.n	c4a2 <_flash_erase+0x92>
	((Nvmctrl *)hw)->ADDR.reg = data;
    c4a8:	614a      	str	r2, [r1, #20]
		page_nums -= NVMCTRL_BLOCK_PAGES;
    c4aa:	3b10      	subs	r3, #16
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c4ac:	8088      	strh	r0, [r1, #4]
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c4ae:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		page_nums -= NVMCTRL_BLOCK_PAGES;
    c4b2:	e7c4      	b.n	c43e <_flash_erase+0x2e>
    c4b4:	000147c5 	.word	0x000147c5
    c4b8:	0000c349 	.word	0x0000c349

0000c4bc <_flash_is_locked>:
	return !(hri_nvmctrl_get_RUNLOCK_reg(device->hw, 1 << region_id));
    c4bc:	6903      	ldr	r3, [r0, #16]
    c4be:	f3c1 31cf 	ubfx	r1, r1, #15, #16
	tmp = ((Nvmctrl *)hw)->RUNLOCK.reg;
    c4c2:	699a      	ldr	r2, [r3, #24]
    c4c4:	2301      	movs	r3, #1
    c4c6:	fa03 f101 	lsl.w	r1, r3, r1
    c4ca:	4211      	tst	r1, r2
}
    c4cc:	bf0c      	ite	eq
    c4ce:	4618      	moveq	r0, r3
    c4d0:	2000      	movne	r0, #0
    c4d2:	4770      	bx	lr

0000c4d4 <NVMCTRL_0_Handler>:
/**
 * \internal NVM 0 interrupt handler
 */
void NVMCTRL_0_Handler(void)
{
	_nvm_interrupt_handler(_nvm_dev);
    c4d4:	4b09      	ldr	r3, [pc, #36]	; (c4fc <NVMCTRL_0_Handler+0x28>)
    c4d6:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    c4d8:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_DONE) >> NVMCTRL_INTFLAG_DONE_Pos;
    c4da:	8a1a      	ldrh	r2, [r3, #16]
	if (hri_nvmctrl_get_INTFLAG_DONE_bit(hw)) {
    c4dc:	07d2      	lsls	r2, r2, #31
    c4de:	d504      	bpl.n	c4ea <NVMCTRL_0_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_DONE;
    c4e0:	2201      	movs	r2, #1
    c4e2:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.ready_cb) {
    c4e4:	6803      	ldr	r3, [r0, #0]
		if (NULL != device->flash_cb.error_cb) {
    c4e6:	b143      	cbz	r3, c4fa <NVMCTRL_0_Handler+0x26>
			device->flash_cb.error_cb(device);
    c4e8:	4718      	bx	r3
	return ((Nvmctrl *)hw)->INTFLAG.reg;
    c4ea:	8a1a      	ldrh	r2, [r3, #16]
    c4ec:	b292      	uxth	r2, r2
	} else if (hri_nvmctrl_read_INTFLAG_reg(hw) && ~NVMCTRL_INTFLAG_ERR) {
    c4ee:	b122      	cbz	r2, c4fa <NVMCTRL_0_Handler+0x26>
	((Nvmctrl *)hw)->INTFLAG.reg = mask;
    c4f0:	f240 225e 	movw	r2, #606	; 0x25e
    c4f4:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.error_cb) {
    c4f6:	6843      	ldr	r3, [r0, #4]
    c4f8:	e7f5      	b.n	c4e6 <NVMCTRL_0_Handler+0x12>
}
    c4fa:	4770      	bx	lr
    c4fc:	2000854c 	.word	0x2000854c

0000c500 <NVMCTRL_1_Handler>:
    c500:	4b00      	ldr	r3, [pc, #0]	; (c504 <NVMCTRL_1_Handler+0x4>)
    c502:	4718      	bx	r3
    c504:	0000c4d5 	.word	0x0000c4d5

0000c508 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    c508:	b510      	push	{r4, lr}
    c50a:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    c50c:	4b04      	ldr	r3, [pc, #16]	; (c520 <prvIsQueueEmpty+0x18>)
    c50e:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    c510:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    c512:	4b04      	ldr	r3, [pc, #16]	; (c524 <prvIsQueueEmpty+0x1c>)
    c514:	4798      	blx	r3

	return xReturn;
}
    c516:	fab4 f084 	clz	r0, r4
    c51a:	0940      	lsrs	r0, r0, #5
    c51c:	bd10      	pop	{r4, pc}
    c51e:	bf00      	nop
    c520:	0000b645 	.word	0x0000b645
    c524:	0000b689 	.word	0x0000b689

0000c528 <prvCopyDataToQueue>:
{
    c528:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c52a:	4615      	mov	r5, r2
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c52c:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    c52e:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
    c530:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    c532:	b952      	cbnz	r2, c54a <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    c534:	6807      	ldr	r7, [r0, #0]
    c536:	bb3f      	cbnz	r7, c588 <prvCopyDataToQueue+0x60>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c538:	6840      	ldr	r0, [r0, #4]
    c53a:	4b15      	ldr	r3, [pc, #84]	; (c590 <prvCopyDataToQueue+0x68>)
    c53c:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    c53e:	6067      	str	r7, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    c540:	4605      	mov	r5, r0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    c542:	3601      	adds	r6, #1
    c544:	63a6      	str	r6, [r4, #56]	; 0x38
}
    c546:	4628      	mov	r0, r5
    c548:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    c54a:	4b12      	ldr	r3, [pc, #72]	; (c594 <prvCopyDataToQueue+0x6c>)
    c54c:	b95d      	cbnz	r5, c566 <prvCopyDataToQueue+0x3e>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    c54e:	6880      	ldr	r0, [r0, #8]
    c550:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c552:	68a3      	ldr	r3, [r4, #8]
    c554:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c556:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c558:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    c55a:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    c55c:	4293      	cmp	r3, r2
    c55e:	d3f0      	bcc.n	c542 <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    c560:	6823      	ldr	r3, [r4, #0]
    c562:	60a3      	str	r3, [r4, #8]
    c564:	e7ed      	b.n	c542 <prvCopyDataToQueue+0x1a>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    c566:	68c0      	ldr	r0, [r0, #12]
    c568:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c56a:	6c22      	ldr	r2, [r4, #64]	; 0x40
    c56c:	68e3      	ldr	r3, [r4, #12]
    c56e:	4251      	negs	r1, r2
    c570:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
    c572:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    c574:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
    c576:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    c578:	bf3e      	ittt	cc
    c57a:	6863      	ldrcc	r3, [r4, #4]
    c57c:	185b      	addcc	r3, r3, r1
    c57e:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    c580:	2d02      	cmp	r5, #2
    c582:	d101      	bne.n	c588 <prvCopyDataToQueue+0x60>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    c584:	b116      	cbz	r6, c58c <prvCopyDataToQueue+0x64>
				--uxMessagesWaiting;
    c586:	3e01      	subs	r6, #1
	BaseType_t  xReturn = pdFALSE;
    c588:	2500      	movs	r5, #0
    c58a:	e7da      	b.n	c542 <prvCopyDataToQueue+0x1a>
    c58c:	4635      	mov	r5, r6
    c58e:	e7d8      	b.n	c542 <prvCopyDataToQueue+0x1a>
    c590:	00013121 	.word	0x00013121
    c594:	000147a9 	.word	0x000147a9

0000c598 <prvCopyDataFromQueue>:
{
    c598:	4603      	mov	r3, r0
    c59a:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c59c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    c59e:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    c5a0:	b16a      	cbz	r2, c5be <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c5a2:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c5a4:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c5a6:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    c5a8:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c5aa:	bf28      	it	cs
    c5ac:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    c5ae:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    c5b0:	bf28      	it	cs
    c5b2:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
    c5b4:	68d9      	ldr	r1, [r3, #12]
}
    c5b6:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
    c5ba:	4b02      	ldr	r3, [pc, #8]	; (c5c4 <prvCopyDataFromQueue+0x2c>)
    c5bc:	4718      	bx	r3
}
    c5be:	f85d 4b04 	ldr.w	r4, [sp], #4
    c5c2:	4770      	bx	lr
    c5c4:	000147a9 	.word	0x000147a9

0000c5c8 <prvNotifyQueueSetContainer.part.0>:
    c5c8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5cc:	f383 8811 	msr	BASEPRI, r3
    c5d0:	f3bf 8f6f 	isb	sy
    c5d4:	f3bf 8f4f 	dsb	sy
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    c5d8:	e7fe      	b.n	c5d8 <prvNotifyQueueSetContainer.part.0+0x10>
	...

0000c5dc <prvNotifyQueueSetContainer>:
{
    c5dc:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    c5de:	6c84      	ldr	r4, [r0, #72]	; 0x48
{
    c5e0:	9001      	str	r0, [sp, #4]
    c5e2:	460a      	mov	r2, r1
	configASSERT(pxQueueSetContainer);
    c5e4:	b90c      	cbnz	r4, c5ea <prvNotifyQueueSetContainer+0xe>
    c5e6:	4b17      	ldr	r3, [pc, #92]	; (c644 <prvNotifyQueueSetContainer+0x68>)
    c5e8:	4798      	blx	r3
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    c5ea:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c5ec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c5ee:	4299      	cmp	r1, r3
    c5f0:	d308      	bcc.n	c604 <prvNotifyQueueSetContainer+0x28>
    c5f2:	f04f 0380 	mov.w	r3, #128	; 0x80
    c5f6:	f383 8811 	msr	BASEPRI, r3
    c5fa:	f3bf 8f6f 	isb	sy
    c5fe:	f3bf 8f4f 	dsb	sy
    c602:	e7fe      	b.n	c602 <prvNotifyQueueSetContainer+0x26>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    c604:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    c606:	428b      	cmp	r3, r1
    c608:	d91a      	bls.n	c640 <prvNotifyQueueSetContainer+0x64>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c60a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c60e:	4b0e      	ldr	r3, [pc, #56]	; (c648 <prvNotifyQueueSetContainer+0x6c>)
    c610:	a901      	add	r1, sp, #4
    c612:	4620      	mov	r0, r4
    c614:	4798      	blx	r3
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    c616:	b26d      	sxtb	r5, r5

		if (cTxLock == queueUNLOCKED) {
    c618:	1c6b      	adds	r3, r5, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    c61a:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
    c61c:	d10b      	bne.n	c636 <prvNotifyQueueSetContainer+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    c61e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c620:	b133      	cbz	r3, c630 <prvNotifyQueueSetContainer+0x54>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    c622:	4b0a      	ldr	r3, [pc, #40]	; (c64c <prvNotifyQueueSetContainer+0x70>)
    c624:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c628:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
    c62a:	2800      	cmp	r0, #0
    c62c:	bf18      	it	ne
    c62e:	2601      	movne	r6, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    c630:	4630      	mov	r0, r6
    c632:	b002      	add	sp, #8
    c634:	bd70      	pop	{r4, r5, r6, pc}
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    c636:	3501      	adds	r5, #1
    c638:	b26d      	sxtb	r5, r5
    c63a:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    c63e:	e7f7      	b.n	c630 <prvNotifyQueueSetContainer+0x54>
	BaseType_t xReturn             = pdFALSE;
    c640:	2600      	movs	r6, #0
	return xReturn;
    c642:	e7f5      	b.n	c630 <prvNotifyQueueSetContainer+0x54>
    c644:	0000c5c9 	.word	0x0000c5c9
    c648:	0000c529 	.word	0x0000c529
    c64c:	00012fd9 	.word	0x00012fd9

0000c650 <prvUnlockQueue>:
{
    c650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c654:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    c656:	4f1f      	ldr	r7, [pc, #124]	; (c6d4 <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c658:	4e1f      	ldr	r6, [pc, #124]	; (c6d8 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
    c65a:	f8df 8084 	ldr.w	r8, [pc, #132]	; c6e0 <prvUnlockQueue+0x90>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c65e:	f8df 9084 	ldr.w	r9, [pc, #132]	; c6e4 <prvUnlockQueue+0x94>
	taskENTER_CRITICAL();
    c662:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
    c664:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    c668:	b26d      	sxtb	r5, r5
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    c66a:	2d00      	cmp	r5, #0
    c66c:	dc17      	bgt.n	c69e <prvUnlockQueue+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
    c66e:	23ff      	movs	r3, #255	; 0xff
    c670:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    c674:	4e19      	ldr	r6, [pc, #100]	; (c6dc <prvUnlockQueue+0x8c>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c676:	f8df 8060 	ldr.w	r8, [pc, #96]	; c6d8 <prvUnlockQueue+0x88>
					vTaskMissedYield();
    c67a:	f8df 9064 	ldr.w	r9, [pc, #100]	; c6e0 <prvUnlockQueue+0x90>
	taskEXIT_CRITICAL();
    c67e:	47b0      	blx	r6
	taskENTER_CRITICAL();
    c680:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
    c682:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c686:	f104 0710 	add.w	r7, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
    c68a:	b26d      	sxtb	r5, r5
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    c68c:	2d00      	cmp	r5, #0
    c68e:	dc17      	bgt.n	c6c0 <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
    c690:	23ff      	movs	r3, #255	; 0xff
    c692:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    c696:	4633      	mov	r3, r6
}
    c698:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	taskEXIT_CRITICAL();
    c69c:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
    c69e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c6a0:	b13b      	cbz	r3, c6b2 <prvUnlockQueue+0x62>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    c6a2:	2100      	movs	r1, #0
    c6a4:	4620      	mov	r0, r4
    c6a6:	47c8      	blx	r9
    c6a8:	b100      	cbz	r0, c6ac <prvUnlockQueue+0x5c>
						vTaskMissedYield();
    c6aa:	47c0      	blx	r8
			--cTxLock;
    c6ac:	3d01      	subs	r5, #1
    c6ae:	b26d      	sxtb	r5, r5
    c6b0:	e7db      	b.n	c66a <prvUnlockQueue+0x1a>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c6b2:	6a63      	ldr	r3, [r4, #36]	; 0x24
    c6b4:	2b00      	cmp	r3, #0
    c6b6:	d0da      	beq.n	c66e <prvUnlockQueue+0x1e>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c6b8:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c6bc:	47b0      	blx	r6
    c6be:	e7f3      	b.n	c6a8 <prvUnlockQueue+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c6c0:	6923      	ldr	r3, [r4, #16]
    c6c2:	2b00      	cmp	r3, #0
    c6c4:	d0e4      	beq.n	c690 <prvUnlockQueue+0x40>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c6c6:	4638      	mov	r0, r7
    c6c8:	47c0      	blx	r8
    c6ca:	b100      	cbz	r0, c6ce <prvUnlockQueue+0x7e>
					vTaskMissedYield();
    c6cc:	47c8      	blx	r9
				--cRxLock;
    c6ce:	3d01      	subs	r5, #1
    c6d0:	b26d      	sxtb	r5, r5
    c6d2:	e7db      	b.n	c68c <prvUnlockQueue+0x3c>
    c6d4:	0000b645 	.word	0x0000b645
    c6d8:	00012fd9 	.word	0x00012fd9
    c6dc:	0000b689 	.word	0x0000b689
    c6e0:	000130f1 	.word	0x000130f1
    c6e4:	0000c5dd 	.word	0x0000c5dd

0000c6e8 <xQueueGenericReset>:
{
    c6e8:	b538      	push	{r3, r4, r5, lr}
    c6ea:	460d      	mov	r5, r1
	configASSERT(pxQueue);
    c6ec:	4604      	mov	r4, r0
    c6ee:	b908      	cbnz	r0, c6f4 <xQueueGenericReset+0xc>
    c6f0:	4b18      	ldr	r3, [pc, #96]	; (c754 <xQueueGenericReset+0x6c>)
    c6f2:	4798      	blx	r3
	taskENTER_CRITICAL();
    c6f4:	4b18      	ldr	r3, [pc, #96]	; (c758 <xQueueGenericReset+0x70>)
    c6f6:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c6f8:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    c6fc:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    c6fe:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c700:	434b      	muls	r3, r1
    c702:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c704:	1a5b      	subs	r3, r3, r1
    c706:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    c708:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    c70a:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c70c:	2000      	movs	r0, #0
		pxQueue->cRxLock           = queueUNLOCKED;
    c70e:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    c710:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock           = queueUNLOCKED;
    c712:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
    c716:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
    c71a:	b995      	cbnz	r5, c742 <xQueueGenericReset+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    c71c:	6923      	ldr	r3, [r4, #16]
    c71e:	b163      	cbz	r3, c73a <xQueueGenericReset+0x52>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    c720:	4b0e      	ldr	r3, [pc, #56]	; (c75c <xQueueGenericReset+0x74>)
    c722:	f104 0010 	add.w	r0, r4, #16
    c726:	4798      	blx	r3
    c728:	b138      	cbz	r0, c73a <xQueueGenericReset+0x52>
					queueYIELD_IF_USING_PREEMPTION();
    c72a:	4b0d      	ldr	r3, [pc, #52]	; (c760 <xQueueGenericReset+0x78>)
    c72c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c730:	601a      	str	r2, [r3, #0]
    c732:	f3bf 8f4f 	dsb	sy
    c736:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
    c73a:	4b0a      	ldr	r3, [pc, #40]	; (c764 <xQueueGenericReset+0x7c>)
    c73c:	4798      	blx	r3
}
    c73e:	2001      	movs	r0, #1
    c740:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    c742:	f104 0010 	add.w	r0, r4, #16
    c746:	4d08      	ldr	r5, [pc, #32]	; (c768 <xQueueGenericReset+0x80>)
    c748:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    c74a:	f104 0024 	add.w	r0, r4, #36	; 0x24
    c74e:	47a8      	blx	r5
    c750:	e7f3      	b.n	c73a <xQueueGenericReset+0x52>
    c752:	bf00      	nop
    c754:	0000c5c9 	.word	0x0000c5c9
    c758:	0000b645 	.word	0x0000b645
    c75c:	00012fd9 	.word	0x00012fd9
    c760:	e000ed04 	.word	0xe000ed04
    c764:	0000b689 	.word	0x0000b689
    c768:	0000b4f5 	.word	0x0000b4f5

0000c76c <xQueueGenericCreate>:
{
    c76c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c76e:	460d      	mov	r5, r1
    c770:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    c772:	4606      	mov	r6, r0
    c774:	b940      	cbnz	r0, c788 <xQueueGenericCreate+0x1c>
    c776:	f04f 0380 	mov.w	r3, #128	; 0x80
    c77a:	f383 8811 	msr	BASEPRI, r3
    c77e:	f3bf 8f6f 	isb	sy
    c782:	f3bf 8f4f 	dsb	sy
    c786:	e7fe      	b.n	c786 <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = (size_t)(
    c788:	4348      	muls	r0, r1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    c78a:	4b0b      	ldr	r3, [pc, #44]	; (c7b8 <xQueueGenericCreate+0x4c>)
    c78c:	3054      	adds	r0, #84	; 0x54
    c78e:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    c790:	4604      	mov	r4, r0
    c792:	b168      	cbz	r0, c7b0 <xQueueGenericCreate+0x44>
	if (uxItemSize == (UBaseType_t)0) {
    c794:	b175      	cbz	r5, c7b4 <xQueueGenericCreate+0x48>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    c796:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    c79a:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
    c79c:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    c7a0:	4b06      	ldr	r3, [pc, #24]	; (c7bc <xQueueGenericCreate+0x50>)
    c7a2:	2101      	movs	r1, #1
    c7a4:	4620      	mov	r0, r4
    c7a6:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
    c7a8:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
    c7aa:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    c7ae:	64a3      	str	r3, [r4, #72]	; 0x48
}
    c7b0:	4620      	mov	r0, r4
    c7b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c7b4:	4603      	mov	r3, r0
    c7b6:	e7f0      	b.n	c79a <xQueueGenericCreate+0x2e>
    c7b8:	0000ba05 	.word	0x0000ba05
    c7bc:	0000c6e9 	.word	0x0000c6e9

0000c7c0 <xQueueGenericSend>:
{
    c7c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c7c4:	b085      	sub	sp, #20
    c7c6:	460e      	mov	r6, r1
    c7c8:	9201      	str	r2, [sp, #4]
    c7ca:	461c      	mov	r4, r3
	configASSERT(pxQueue);
    c7cc:	4683      	mov	fp, r0
    c7ce:	b940      	cbnz	r0, c7e2 <xQueueGenericSend+0x22>
    c7d0:	f04f 0380 	mov.w	r3, #128	; 0x80
    c7d4:	f383 8811 	msr	BASEPRI, r3
    c7d8:	f3bf 8f6f 	isb	sy
    c7dc:	f3bf 8f4f 	dsb	sy
    c7e0:	e7fe      	b.n	c7e0 <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c7e2:	b951      	cbnz	r1, c7fa <xQueueGenericSend+0x3a>
    c7e4:	6c02      	ldr	r2, [r0, #64]	; 0x40
    c7e6:	b142      	cbz	r2, c7fa <xQueueGenericSend+0x3a>
    c7e8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c7ec:	f383 8811 	msr	BASEPRI, r3
    c7f0:	f3bf 8f6f 	isb	sy
    c7f4:	f3bf 8f4f 	dsb	sy
    c7f8:	e7fe      	b.n	c7f8 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c7fa:	2c02      	cmp	r4, #2
    c7fc:	d10c      	bne.n	c818 <xQueueGenericSend+0x58>
    c7fe:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c802:	2a01      	cmp	r2, #1
    c804:	d008      	beq.n	c818 <xQueueGenericSend+0x58>
    c806:	f04f 0380 	mov.w	r3, #128	; 0x80
    c80a:	f383 8811 	msr	BASEPRI, r3
    c80e:	f3bf 8f6f 	isb	sy
    c812:	f3bf 8f4f 	dsb	sy
    c816:	e7fe      	b.n	c816 <xQueueGenericSend+0x56>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    c818:	4a47      	ldr	r2, [pc, #284]	; (c938 <xQueueGenericSend+0x178>)
    c81a:	4790      	blx	r2
    c81c:	4680      	mov	r8, r0
    c81e:	b950      	cbnz	r0, c836 <xQueueGenericSend+0x76>
    c820:	9a01      	ldr	r2, [sp, #4]
    c822:	b152      	cbz	r2, c83a <xQueueGenericSend+0x7a>
    c824:	f04f 0380 	mov.w	r3, #128	; 0x80
    c828:	f383 8811 	msr	BASEPRI, r3
    c82c:	f3bf 8f6f 	isb	sy
    c830:	f3bf 8f4f 	dsb	sy
    c834:	e7fe      	b.n	c834 <xQueueGenericSend+0x74>
    c836:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
    c83a:	f8df 9128 	ldr.w	r9, [pc, #296]	; c964 <xQueueGenericSend+0x1a4>
    c83e:	46ca      	mov	sl, r9
    c840:	e042      	b.n	c8c8 <xQueueGenericSend+0x108>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    c842:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    c846:	2a00      	cmp	r2, #0
    c848:	d055      	beq.n	c8f6 <xQueueGenericSend+0x136>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    c84a:	4b3c      	ldr	r3, [pc, #240]	; (c93c <xQueueGenericSend+0x17c>)
    c84c:	f10b 0024 	add.w	r0, fp, #36	; 0x24
    c850:	4798      	blx	r3
    c852:	e050      	b.n	c8f6 <xQueueGenericSend+0x136>
				if (xTicksToWait == (TickType_t)0) {
    c854:	9f01      	ldr	r7, [sp, #4]
    c856:	b917      	cbnz	r7, c85e <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
    c858:	47a8      	blx	r5
			return errQUEUE_FULL;
    c85a:	2000      	movs	r0, #0
    c85c:	e056      	b.n	c90c <xQueueGenericSend+0x14c>
				} else if (xEntryTimeSet == pdFALSE) {
    c85e:	f1b8 0f00 	cmp.w	r8, #0
    c862:	d102      	bne.n	c86a <xQueueGenericSend+0xaa>
					vTaskInternalSetTimeOutState(&xTimeOut);
    c864:	4a36      	ldr	r2, [pc, #216]	; (c940 <xQueueGenericSend+0x180>)
    c866:	a802      	add	r0, sp, #8
    c868:	4790      	blx	r2
		taskEXIT_CRITICAL();
    c86a:	47a8      	blx	r5
		vTaskSuspendAll();
    c86c:	4a35      	ldr	r2, [pc, #212]	; (c944 <xQueueGenericSend+0x184>)
    c86e:	f8df 80f8 	ldr.w	r8, [pc, #248]	; c968 <xQueueGenericSend+0x1a8>
    c872:	4f35      	ldr	r7, [pc, #212]	; (c948 <xQueueGenericSend+0x188>)
    c874:	4790      	blx	r2
		prvLockQueue(pxQueue);
    c876:	47d0      	blx	sl
    c878:	f89b 2044 	ldrb.w	r2, [fp, #68]	; 0x44
    c87c:	2aff      	cmp	r2, #255	; 0xff
    c87e:	bf04      	itt	eq
    c880:	2200      	moveq	r2, #0
    c882:	f88b 2044 	strbeq.w	r2, [fp, #68]	; 0x44
    c886:	f89b 2045 	ldrb.w	r2, [fp, #69]	; 0x45
    c88a:	2aff      	cmp	r2, #255	; 0xff
    c88c:	bf04      	itt	eq
    c88e:	2200      	moveq	r2, #0
    c890:	f88b 2045 	strbeq.w	r2, [fp, #69]	; 0x45
    c894:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    c896:	4a2d      	ldr	r2, [pc, #180]	; (c94c <xQueueGenericSend+0x18c>)
    c898:	a901      	add	r1, sp, #4
    c89a:	a802      	add	r0, sp, #8
    c89c:	4790      	blx	r2
    c89e:	2800      	cmp	r0, #0
    c8a0:	d145      	bne.n	c92e <xQueueGenericSend+0x16e>
	taskENTER_CRITICAL();
    c8a2:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    c8a4:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c8a8:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c8ac:	4291      	cmp	r1, r2
    c8ae:	d130      	bne.n	c912 <xQueueGenericSend+0x152>
	taskEXIT_CRITICAL();
    c8b0:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    c8b2:	9901      	ldr	r1, [sp, #4]
    c8b4:	4a26      	ldr	r2, [pc, #152]	; (c950 <xQueueGenericSend+0x190>)
    c8b6:	f10b 0010 	add.w	r0, fp, #16
    c8ba:	4790      	blx	r2
				prvUnlockQueue(pxQueue);
    c8bc:	4658      	mov	r0, fp
    c8be:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
    c8c0:	47b8      	blx	r7
    c8c2:	b358      	cbz	r0, c91c <xQueueGenericSend+0x15c>
    c8c4:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
    c8c8:	47c8      	blx	r9
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c8ca:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    c8ce:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    c8d2:	4d20      	ldr	r5, [pc, #128]	; (c954 <xQueueGenericSend+0x194>)
    c8d4:	4291      	cmp	r1, r2
    c8d6:	d301      	bcc.n	c8dc <xQueueGenericSend+0x11c>
    c8d8:	2c02      	cmp	r4, #2
    c8da:	d1bb      	bne.n	c854 <xQueueGenericSend+0x94>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c8dc:	4622      	mov	r2, r4
    c8de:	4631      	mov	r1, r6
    c8e0:	4658      	mov	r0, fp
    c8e2:	4e1d      	ldr	r6, [pc, #116]	; (c958 <xQueueGenericSend+0x198>)
    c8e4:	47b0      	blx	r6
					if (pxQueue->pxQueueSetContainer != NULL) {
    c8e6:	f8db 2048 	ldr.w	r2, [fp, #72]	; 0x48
    c8ea:	2a00      	cmp	r2, #0
    c8ec:	d0a9      	beq.n	c842 <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c8ee:	4b1b      	ldr	r3, [pc, #108]	; (c95c <xQueueGenericSend+0x19c>)
    c8f0:	4621      	mov	r1, r4
    c8f2:	4658      	mov	r0, fp
    c8f4:	4798      	blx	r3
						} else if (xYieldRequired != pdFALSE) {
    c8f6:	b138      	cbz	r0, c908 <xQueueGenericSend+0x148>
							queueYIELD_IF_USING_PREEMPTION();
    c8f8:	4b19      	ldr	r3, [pc, #100]	; (c960 <xQueueGenericSend+0x1a0>)
    c8fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c8fe:	601a      	str	r2, [r3, #0]
    c900:	f3bf 8f4f 	dsb	sy
    c904:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    c908:	47a8      	blx	r5
				return pdPASS;
    c90a:	2001      	movs	r0, #1
}
    c90c:	b005      	add	sp, #20
    c90e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    c912:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
    c914:	4658      	mov	r0, fp
    c916:	47c0      	blx	r8
				(void)xTaskResumeAll();
    c918:	47b8      	blx	r7
    c91a:	e7d3      	b.n	c8c4 <xQueueGenericSend+0x104>
					portYIELD_WITHIN_API();
    c91c:	4b10      	ldr	r3, [pc, #64]	; (c960 <xQueueGenericSend+0x1a0>)
    c91e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    c922:	601a      	str	r2, [r3, #0]
    c924:	f3bf 8f4f 	dsb	sy
    c928:	f3bf 8f6f 	isb	sy
    c92c:	e7ca      	b.n	c8c4 <xQueueGenericSend+0x104>
			prvUnlockQueue(pxQueue);
    c92e:	4658      	mov	r0, fp
    c930:	47c0      	blx	r8
			(void)xTaskResumeAll();
    c932:	47b8      	blx	r7
    c934:	e791      	b.n	c85a <xQueueGenericSend+0x9a>
    c936:	bf00      	nop
    c938:	00013101 	.word	0x00013101
    c93c:	00012fd9 	.word	0x00012fd9
    c940:	00013059 	.word	0x00013059
    c944:	00012c35 	.word	0x00012c35
    c948:	00012d7d 	.word	0x00012d7d
    c94c:	0001306d 	.word	0x0001306d
    c950:	00012f55 	.word	0x00012f55
    c954:	0000b689 	.word	0x0000b689
    c958:	0000c529 	.word	0x0000c529
    c95c:	0000c5dd 	.word	0x0000c5dd
    c960:	e000ed04 	.word	0xe000ed04
    c964:	0000b645 	.word	0x0000b645
    c968:	0000c651 	.word	0x0000c651

0000c96c <xQueueGenericSendFromISR>:
{
    c96c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    c970:	4689      	mov	r9, r1
    c972:	4690      	mov	r8, r2
    c974:	461f      	mov	r7, r3
	configASSERT(pxQueue);
    c976:	4604      	mov	r4, r0
    c978:	b940      	cbnz	r0, c98c <xQueueGenericSendFromISR+0x20>
    c97a:	f04f 0380 	mov.w	r3, #128	; 0x80
    c97e:	f383 8811 	msr	BASEPRI, r3
    c982:	f3bf 8f6f 	isb	sy
    c986:	f3bf 8f4f 	dsb	sy
    c98a:	e7fe      	b.n	c98a <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    c98c:	b951      	cbnz	r1, c9a4 <xQueueGenericSendFromISR+0x38>
    c98e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    c990:	b143      	cbz	r3, c9a4 <xQueueGenericSendFromISR+0x38>
    c992:	f04f 0380 	mov.w	r3, #128	; 0x80
    c996:	f383 8811 	msr	BASEPRI, r3
    c99a:	f3bf 8f6f 	isb	sy
    c99e:	f3bf 8f4f 	dsb	sy
    c9a2:	e7fe      	b.n	c9a2 <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    c9a4:	2f02      	cmp	r7, #2
    c9a6:	d10b      	bne.n	c9c0 <xQueueGenericSendFromISR+0x54>
    c9a8:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c9aa:	2b01      	cmp	r3, #1
    c9ac:	d008      	beq.n	c9c0 <xQueueGenericSendFromISR+0x54>
    c9ae:	f04f 0380 	mov.w	r3, #128	; 0x80
    c9b2:	f383 8811 	msr	BASEPRI, r3
    c9b6:	f3bf 8f6f 	isb	sy
    c9ba:	f3bf 8f4f 	dsb	sy
    c9be:	e7fe      	b.n	c9be <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    c9c0:	4b1e      	ldr	r3, [pc, #120]	; (ca3c <xQueueGenericSendFromISR+0xd0>)
    c9c2:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    c9c4:	f3ef 8611 	mrs	r6, BASEPRI
    c9c8:	f04f 0380 	mov.w	r3, #128	; 0x80
    c9cc:	f383 8811 	msr	BASEPRI, r3
    c9d0:	f3bf 8f6f 	isb	sy
    c9d4:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    c9d8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    c9da:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    c9dc:	429a      	cmp	r2, r3
    c9de:	d301      	bcc.n	c9e4 <xQueueGenericSendFromISR+0x78>
    c9e0:	2f02      	cmp	r7, #2
    c9e2:	d129      	bne.n	ca38 <xQueueGenericSendFromISR+0xcc>
			const int8_t cTxLock = pxQueue->cTxLock;
    c9e4:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c9e8:	4b15      	ldr	r3, [pc, #84]	; (ca40 <xQueueGenericSendFromISR+0xd4>)
			const int8_t cTxLock = pxQueue->cTxLock;
    c9ea:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    c9ec:	463a      	mov	r2, r7
    c9ee:	4649      	mov	r1, r9
    c9f0:	4620      	mov	r0, r4
    c9f2:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    c9f4:	1c6b      	adds	r3, r5, #1
    c9f6:	d11a      	bne.n	ca2e <xQueueGenericSendFromISR+0xc2>
					if (pxQueue->pxQueueSetContainer != NULL) {
    c9f8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    c9fa:	b183      	cbz	r3, ca1e <xQueueGenericSendFromISR+0xb2>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    c9fc:	4b11      	ldr	r3, [pc, #68]	; (ca44 <xQueueGenericSendFromISR+0xd8>)
    c9fe:	4639      	mov	r1, r7
    ca00:	4620      	mov	r0, r4
    ca02:	4798      	blx	r3
    ca04:	b908      	cbnz	r0, ca0a <xQueueGenericSendFromISR+0x9e>
			xReturn = pdPASS;
    ca06:	2001      	movs	r0, #1
    ca08:	e005      	b.n	ca16 <xQueueGenericSendFromISR+0xaa>
							if (pxHigherPriorityTaskWoken != NULL) {
    ca0a:	f1b8 0f00 	cmp.w	r8, #0
    ca0e:	d0fa      	beq.n	ca06 <xQueueGenericSendFromISR+0x9a>
								*pxHigherPriorityTaskWoken = pdTRUE;
    ca10:	2001      	movs	r0, #1
    ca12:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    ca16:	f386 8811 	msr	BASEPRI, r6
}
    ca1a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    ca1e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    ca20:	2b00      	cmp	r3, #0
    ca22:	d0f0      	beq.n	ca06 <xQueueGenericSendFromISR+0x9a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    ca24:	4b08      	ldr	r3, [pc, #32]	; (ca48 <xQueueGenericSendFromISR+0xdc>)
    ca26:	f104 0024 	add.w	r0, r4, #36	; 0x24
    ca2a:	4798      	blx	r3
    ca2c:	e7ea      	b.n	ca04 <xQueueGenericSendFromISR+0x98>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    ca2e:	3501      	adds	r5, #1
    ca30:	b26d      	sxtb	r5, r5
    ca32:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    ca36:	e7e6      	b.n	ca06 <xQueueGenericSendFromISR+0x9a>
			xReturn = errQUEUE_FULL;
    ca38:	2000      	movs	r0, #0
    ca3a:	e7ec      	b.n	ca16 <xQueueGenericSendFromISR+0xaa>
    ca3c:	0000b87d 	.word	0x0000b87d
    ca40:	0000c529 	.word	0x0000c529
    ca44:	0000c5dd 	.word	0x0000c5dd
    ca48:	00012fd9 	.word	0x00012fd9

0000ca4c <xQueueReceive>:
{
    ca4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ca50:	b085      	sub	sp, #20
    ca52:	460f      	mov	r7, r1
    ca54:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    ca56:	4604      	mov	r4, r0
    ca58:	b940      	cbnz	r0, ca6c <xQueueReceive+0x20>
	__asm volatile("	mov %0, %1												\n"
    ca5a:	f04f 0380 	mov.w	r3, #128	; 0x80
    ca5e:	f383 8811 	msr	BASEPRI, r3
    ca62:	f3bf 8f6f 	isb	sy
    ca66:	f3bf 8f4f 	dsb	sy
    ca6a:	e7fe      	b.n	ca6a <xQueueReceive+0x1e>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    ca6c:	b951      	cbnz	r1, ca84 <xQueueReceive+0x38>
    ca6e:	6c03      	ldr	r3, [r0, #64]	; 0x40
    ca70:	b143      	cbz	r3, ca84 <xQueueReceive+0x38>
    ca72:	f04f 0380 	mov.w	r3, #128	; 0x80
    ca76:	f383 8811 	msr	BASEPRI, r3
    ca7a:	f3bf 8f6f 	isb	sy
    ca7e:	f3bf 8f4f 	dsb	sy
    ca82:	e7fe      	b.n	ca82 <xQueueReceive+0x36>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    ca84:	4b3e      	ldr	r3, [pc, #248]	; (cb80 <xQueueReceive+0x134>)
    ca86:	4798      	blx	r3
    ca88:	4606      	mov	r6, r0
    ca8a:	b950      	cbnz	r0, caa2 <xQueueReceive+0x56>
    ca8c:	9b01      	ldr	r3, [sp, #4]
    ca8e:	b14b      	cbz	r3, caa4 <xQueueReceive+0x58>
    ca90:	f04f 0380 	mov.w	r3, #128	; 0x80
    ca94:	f383 8811 	msr	BASEPRI, r3
    ca98:	f3bf 8f6f 	isb	sy
    ca9c:	f3bf 8f4f 	dsb	sy
    caa0:	e7fe      	b.n	caa0 <xQueueReceive+0x54>
    caa2:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    caa4:	f8df 9100 	ldr.w	r9, [pc, #256]	; cba8 <xQueueReceive+0x15c>
					portYIELD_WITHIN_API();
    caa8:	f8df b0f8 	ldr.w	fp, [pc, #248]	; cba4 <xQueueReceive+0x158>
    caac:	46ca      	mov	sl, r9
    caae:	e03b      	b.n	cb28 <xQueueReceive+0xdc>
				if (xTicksToWait == (TickType_t)0) {
    cab0:	9d01      	ldr	r5, [sp, #4]
    cab2:	b915      	cbnz	r5, caba <xQueueReceive+0x6e>
					taskEXIT_CRITICAL();
    cab4:	47c0      	blx	r8
				return errQUEUE_EMPTY;
    cab6:	2000      	movs	r0, #0
    cab8:	e053      	b.n	cb62 <xQueueReceive+0x116>
				} else if (xEntryTimeSet == pdFALSE) {
    caba:	b916      	cbnz	r6, cac2 <xQueueReceive+0x76>
					vTaskInternalSetTimeOutState(&xTimeOut);
    cabc:	4b31      	ldr	r3, [pc, #196]	; (cb84 <xQueueReceive+0x138>)
    cabe:	a802      	add	r0, sp, #8
    cac0:	4798      	blx	r3
		taskEXIT_CRITICAL();
    cac2:	47c0      	blx	r8
		vTaskSuspendAll();
    cac4:	4b30      	ldr	r3, [pc, #192]	; (cb88 <xQueueReceive+0x13c>)
    cac6:	4e31      	ldr	r6, [pc, #196]	; (cb8c <xQueueReceive+0x140>)
    cac8:	4d31      	ldr	r5, [pc, #196]	; (cb90 <xQueueReceive+0x144>)
    caca:	4798      	blx	r3
		prvLockQueue(pxQueue);
    cacc:	47d0      	blx	sl
    cace:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    cad2:	2bff      	cmp	r3, #255	; 0xff
    cad4:	bf04      	itt	eq
    cad6:	2300      	moveq	r3, #0
    cad8:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    cadc:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    cae0:	2bff      	cmp	r3, #255	; 0xff
    cae2:	bf04      	itt	eq
    cae4:	2300      	moveq	r3, #0
    cae6:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    caea:	47c0      	blx	r8
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    caec:	4b29      	ldr	r3, [pc, #164]	; (cb94 <xQueueReceive+0x148>)
    caee:	f8df 80bc 	ldr.w	r8, [pc, #188]	; cbac <xQueueReceive+0x160>
    caf2:	a901      	add	r1, sp, #4
    caf4:	a802      	add	r0, sp, #8
    caf6:	4798      	blx	r3
    caf8:	2800      	cmp	r0, #0
    cafa:	d139      	bne.n	cb70 <xQueueReceive+0x124>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    cafc:	4620      	mov	r0, r4
    cafe:	47c0      	blx	r8
    cb00:	2800      	cmp	r0, #0
    cb02:	d031      	beq.n	cb68 <xQueueReceive+0x11c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    cb04:	9901      	ldr	r1, [sp, #4]
    cb06:	4b24      	ldr	r3, [pc, #144]	; (cb98 <xQueueReceive+0x14c>)
    cb08:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cb0c:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    cb0e:	4620      	mov	r0, r4
    cb10:	47b0      	blx	r6
				if (xTaskResumeAll() == pdFALSE) {
    cb12:	47a8      	blx	r5
    cb14:	b938      	cbnz	r0, cb26 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
    cb16:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    cb1a:	f8cb 3000 	str.w	r3, [fp]
    cb1e:	f3bf 8f4f 	dsb	sy
    cb22:	f3bf 8f6f 	isb	sy
    cb26:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    cb28:	47c8      	blx	r9
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    cb2a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    cb2c:	f8df 8080 	ldr.w	r8, [pc, #128]	; cbb0 <xQueueReceive+0x164>
    cb30:	2d00      	cmp	r5, #0
    cb32:	d0bd      	beq.n	cab0 <xQueueReceive+0x64>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    cb34:	4b19      	ldr	r3, [pc, #100]	; (cb9c <xQueueReceive+0x150>)
    cb36:	4639      	mov	r1, r7
    cb38:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    cb3a:	3d01      	subs	r5, #1
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    cb3c:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    cb3e:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    cb40:	6923      	ldr	r3, [r4, #16]
    cb42:	b163      	cbz	r3, cb5e <xQueueReceive+0x112>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    cb44:	4b16      	ldr	r3, [pc, #88]	; (cba0 <xQueueReceive+0x154>)
    cb46:	f104 0010 	add.w	r0, r4, #16
    cb4a:	4798      	blx	r3
    cb4c:	b138      	cbz	r0, cb5e <xQueueReceive+0x112>
						queueYIELD_IF_USING_PREEMPTION();
    cb4e:	4b15      	ldr	r3, [pc, #84]	; (cba4 <xQueueReceive+0x158>)
    cb50:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    cb54:	601a      	str	r2, [r3, #0]
    cb56:	f3bf 8f4f 	dsb	sy
    cb5a:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    cb5e:	47c0      	blx	r8
				return pdPASS;
    cb60:	2001      	movs	r0, #1
}
    cb62:	b005      	add	sp, #20
    cb64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				prvUnlockQueue(pxQueue);
    cb68:	4620      	mov	r0, r4
    cb6a:	47b0      	blx	r6
				(void)xTaskResumeAll();
    cb6c:	47a8      	blx	r5
    cb6e:	e7da      	b.n	cb26 <xQueueReceive+0xda>
			prvUnlockQueue(pxQueue);
    cb70:	4620      	mov	r0, r4
    cb72:	47b0      	blx	r6
			(void)xTaskResumeAll();
    cb74:	47a8      	blx	r5
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    cb76:	4620      	mov	r0, r4
    cb78:	47c0      	blx	r8
    cb7a:	2800      	cmp	r0, #0
    cb7c:	d0d3      	beq.n	cb26 <xQueueReceive+0xda>
    cb7e:	e79a      	b.n	cab6 <xQueueReceive+0x6a>
    cb80:	00013101 	.word	0x00013101
    cb84:	00013059 	.word	0x00013059
    cb88:	00012c35 	.word	0x00012c35
    cb8c:	0000c651 	.word	0x0000c651
    cb90:	00012d7d 	.word	0x00012d7d
    cb94:	0001306d 	.word	0x0001306d
    cb98:	00012f55 	.word	0x00012f55
    cb9c:	0000c599 	.word	0x0000c599
    cba0:	00012fd9 	.word	0x00012fd9
    cba4:	e000ed04 	.word	0xe000ed04
    cba8:	0000b645 	.word	0x0000b645
    cbac:	0000c509 	.word	0x0000c509
    cbb0:	0000b689 	.word	0x0000b689

0000cbb4 <vQueueWaitForMessageRestricted>:
{
    cbb4:	b570      	push	{r4, r5, r6, lr}
    cbb6:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
    cbb8:	4b10      	ldr	r3, [pc, #64]	; (cbfc <vQueueWaitForMessageRestricted+0x48>)
{
    cbba:	460d      	mov	r5, r1
    cbbc:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    cbbe:	4798      	blx	r3
    cbc0:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    cbc4:	2bff      	cmp	r3, #255	; 0xff
    cbc6:	bf04      	itt	eq
    cbc8:	2300      	moveq	r3, #0
    cbca:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    cbce:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    cbd2:	2bff      	cmp	r3, #255	; 0xff
    cbd4:	bf04      	itt	eq
    cbd6:	2300      	moveq	r3, #0
    cbd8:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    cbdc:	4b08      	ldr	r3, [pc, #32]	; (cc00 <vQueueWaitForMessageRestricted+0x4c>)
    cbde:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    cbe0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    cbe2:	b92b      	cbnz	r3, cbf0 <vQueueWaitForMessageRestricted+0x3c>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    cbe4:	4b07      	ldr	r3, [pc, #28]	; (cc04 <vQueueWaitForMessageRestricted+0x50>)
    cbe6:	4632      	mov	r2, r6
    cbe8:	4629      	mov	r1, r5
    cbea:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cbee:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
    cbf0:	4620      	mov	r0, r4
    cbf2:	4b05      	ldr	r3, [pc, #20]	; (cc08 <vQueueWaitForMessageRestricted+0x54>)
}
    cbf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
    cbf8:	4718      	bx	r3
    cbfa:	bf00      	nop
    cbfc:	0000b645 	.word	0x0000b645
    cc00:	0000b689 	.word	0x0000b689
    cc04:	00012f91 	.word	0x00012f91
    cc08:	0000c651 	.word	0x0000c651

0000cc0c <gpio_get_pin_level>:
{
    cc0c:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CRITICAL_SECTION_ENTER();
    cc0e:	4b0e      	ldr	r3, [pc, #56]	; (cc48 <gpio_get_pin_level+0x3c>)
    cc10:	4605      	mov	r5, r0
    cc12:	a801      	add	r0, sp, #4
    cc14:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    cc16:	4a0d      	ldr	r2, [pc, #52]	; (cc4c <gpio_get_pin_level+0x40>)
    cc18:	096b      	lsrs	r3, r5, #5
    cc1a:	01d9      	lsls	r1, r3, #7
    cc1c:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    cc20:	5851      	ldr	r1, [r2, r1]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    cc22:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    cc24:	691c      	ldr	r4, [r3, #16]
	CRITICAL_SECTION_LEAVE();
    cc26:	4b0a      	ldr	r3, [pc, #40]	; (cc50 <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    cc28:	4054      	eors	r4, r2
    cc2a:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    cc2c:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    cc2e:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    cc30:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    cc34:	4798      	blx	r3
    cc36:	2001      	movs	r0, #1
    cc38:	fa00 f505 	lsl.w	r5, r0, r5
    cc3c:	4225      	tst	r5, r4
}
    cc3e:	bf08      	it	eq
    cc40:	2000      	moveq	r0, #0
    cc42:	b003      	add	sp, #12
    cc44:	bd30      	pop	{r4, r5, pc}
    cc46:	bf00      	nop
    cc48:	00011ef9 	.word	0x00011ef9
    cc4c:	41008000 	.word	0x41008000
    cc50:	00011f07 	.word	0x00011f07

0000cc54 <hiddf_demo_sof_event>:
#endif /* CONF_USB_COMPOSITE_CDC_ECHO_DEMO */

#if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO
static uint32_t pin_btn1, pin_btn2, pin_btn3;
static void     hiddf_demo_sof_event(void)
{
    cc54:	b570      	push	{r4, r5, r6, lr}
        {HID_CAPS_LOCK, false, HID_KB_KEY_UP},
    };
	uint8_t b_btn_state;
#endif

	if (interval++ > 10) {
    cc56:	4a15      	ldr	r2, [pc, #84]	; (ccac <hiddf_demo_sof_event+0x58>)
    cc58:	7913      	ldrb	r3, [r2, #4]
    cc5a:	2b0a      	cmp	r3, #10
    cc5c:	4614      	mov	r4, r2
    cc5e:	d802      	bhi.n	cc66 <hiddf_demo_sof_event+0x12>
    cc60:	3301      	adds	r3, #1
    cc62:	7113      	strb	r3, [r2, #4]
#endif
	}
	(void)pin_btn1;
	(void)pin_btn2;
	(void)pin_btn3;
}
    cc64:	bd70      	pop	{r4, r5, r6, pc}
		interval = 0;
    cc66:	2300      	movs	r3, #0
		if (!gpio_get_pin_level(pin_btn1)) {
    cc68:	7a10      	ldrb	r0, [r2, #8]
    cc6a:	4d11      	ldr	r5, [pc, #68]	; (ccb0 <hiddf_demo_sof_event+0x5c>)
		interval = 0;
    cc6c:	7113      	strb	r3, [r2, #4]
		if (!gpio_get_pin_level(pin_btn1)) {
    cc6e:	47a8      	blx	r5
    cc70:	b920      	cbnz	r0, cc7c <hiddf_demo_sof_event+0x28>
			hiddf_mouse_move(-5, HID_MOUSE_X_AXIS_MV);
    cc72:	4b10      	ldr	r3, [pc, #64]	; (ccb4 <hiddf_demo_sof_event+0x60>)
    cc74:	2101      	movs	r1, #1
    cc76:	f06f 0004 	mvn.w	r0, #4
    cc7a:	4798      	blx	r3
		if (!gpio_get_pin_level(pin_btn3)) {
    cc7c:	7b20      	ldrb	r0, [r4, #12]
    cc7e:	47a8      	blx	r5
    cc80:	b918      	cbnz	r0, cc8a <hiddf_demo_sof_event+0x36>
			hiddf_mouse_move(5, HID_MOUSE_X_AXIS_MV);
    cc82:	4b0c      	ldr	r3, [pc, #48]	; (ccb4 <hiddf_demo_sof_event+0x60>)
    cc84:	2101      	movs	r1, #1
    cc86:	2005      	movs	r0, #5
    cc88:	4798      	blx	r3
		if (b_btn_last_state != (b_btn_state = !gpio_get_pin_level(pin_btn2))) {
    cc8a:	7c20      	ldrb	r0, [r4, #16]
    cc8c:	47a8      	blx	r5
    cc8e:	7d22      	ldrb	r2, [r4, #20]
    cc90:	f080 0001 	eor.w	r0, r0, #1
    cc94:	b2c3      	uxtb	r3, r0
    cc96:	429a      	cmp	r2, r3
    cc98:	d0e4      	beq.n	cc64 <hiddf_demo_sof_event+0x10>
			b_btn_last_state = b_btn_state;
    cc9a:	4807      	ldr	r0, [pc, #28]	; (ccb8 <hiddf_demo_sof_event+0x64>)
    cc9c:	7523      	strb	r3, [r4, #20]
			if (1 == b_btn_last_state) {
    cc9e:	7083      	strb	r3, [r0, #2]
}
    cca0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			hiddf_keyboard_keys_state_change(key_array, 1);
    cca4:	4b05      	ldr	r3, [pc, #20]	; (ccbc <hiddf_demo_sof_event+0x68>)
    cca6:	2101      	movs	r1, #1
    cca8:	4718      	bx	r3
    ccaa:	bf00      	nop
    ccac:	20008550 	.word	0x20008550
    ccb0:	0000cc0d 	.word	0x0000cc0d
    ccb4:	0000e3e5 	.word	0x0000e3e5
    ccb8:	2000035c 	.word	0x2000035c
    ccbc:	0000ee71 	.word	0x0000ee71

0000ccc0 <composite_device_init>:
	usbdc_register_handler(USBDC_HDL_SOF, &hiddf_demo_sof_event_h);
}
#endif /* #if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO */

void composite_device_init(void)
{
    ccc0:	b510      	push	{r4, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    ccc2:	4b05      	ldr	r3, [pc, #20]	; (ccd8 <composite_device_init+0x18>)
    ccc4:	4805      	ldr	r0, [pc, #20]	; (ccdc <composite_device_init+0x1c>)
    ccc6:	4798      	blx	r3

	/* usbdc_register_funcion inside */
#if CONF_USB_COMPOSITE_CDC_ACM_EN
	cdcdf_acm_init();
    ccc8:	4b05      	ldr	r3, [pc, #20]	; (cce0 <composite_device_init+0x20>)
    ccca:	4798      	blx	r3
#endif
#if CONF_USB_COMPOSITE_HID_MOUSE_EN
	hiddf_mouse_init();
    cccc:	4b05      	ldr	r3, [pc, #20]	; (cce4 <composite_device_init+0x24>)
    ccce:	4798      	blx	r3
	hiddf_keyboard_init();
#endif
#if CONF_USB_COMPOSITE_MSC_EN
	mscdf_init(CONF_USB_MSC_MAX_LUN);
#endif
}
    ccd0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hiddf_keyboard_init();
    ccd4:	4b04      	ldr	r3, [pc, #16]	; (cce8 <composite_device_init+0x28>)
    ccd6:	4718      	bx	r3
    ccd8:	00013a95 	.word	0x00013a95
    ccdc:	20008565 	.word	0x20008565
    cce0:	0000c0d1 	.word	0x0000c0d1
    cce4:	0000e3a1 	.word	0x0000e3a1
    cce8:	0000ee2d 	.word	0x0000ee2d

0000ccec <composite_device_start>:

void composite_device_start(void)
{
    ccec:	b510      	push	{r4, lr}
	usbdc_start(multi_desc);
    ccee:	4b03      	ldr	r3, [pc, #12]	; (ccfc <composite_device_start+0x10>)
    ccf0:	4803      	ldr	r0, [pc, #12]	; (cd00 <composite_device_start+0x14>)
    ccf2:	4798      	blx	r3
	usbdc_attach();
}
    ccf4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	usbdc_attach();
    ccf8:	4b02      	ldr	r3, [pc, #8]	; (cd04 <composite_device_start+0x18>)
    ccfa:	4718      	bx	r3
    ccfc:	00013b01 	.word	0x00013b01
    cd00:	20000368 	.word	0x20000368
    cd04:	00013b35 	.word	0x00013b35

0000cd08 <usb_init>:
}

void usb_init(void)
{

	composite_device_init();
    cd08:	4b00      	ldr	r3, [pc, #0]	; (cd0c <usb_init+0x4>)
    cd0a:	4718      	bx	r3
    cd0c:	0000ccc1 	.word	0x0000ccc1

0000cd10 <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    cd10:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    cd12:	6805      	ldr	r5, [r0, #0]

	if (!head) {
    cd14:	b91d      	cbnz	r5, cd1e <timer_add_timer_task+0xe>
		list_insert_as_head(list, new_task);
    cd16:	4b0f      	ldr	r3, [pc, #60]	; (cd54 <timer_add_timer_task+0x44>)
	if (it == head) {
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
	}
}
    cd18:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		list_insert_after(prev, new_task);
    cd1c:	4718      	bx	r3
		if (time_left >= new_task->interval)
    cd1e:	f8d1 c008 	ldr.w	ip, [r1, #8]
    cd22:	462c      	mov	r4, r5
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    cd24:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    cd26:	f1c2 0e01 	rsb	lr, r2, #1
		if (it->time_label <= time) {
    cd2a:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
    cd2e:	4293      	cmp	r3, r2
			time_left = it->interval - (time - it->time_label);
    cd30:	bf95      	itete	ls
    cd32:	19db      	addls	r3, r3, r7
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    cd34:	4473      	addhi	r3, lr
			time_left = it->interval - (time - it->time_label);
    cd36:	1a9b      	subls	r3, r3, r2
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    cd38:	19db      	addhi	r3, r3, r7
		if (time_left >= new_task->interval)
    cd3a:	459c      	cmp	ip, r3
    cd3c:	d907      	bls.n	cd4e <timer_add_timer_task+0x3e>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    cd3e:	6823      	ldr	r3, [r4, #0]
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    cd40:	4626      	mov	r6, r4
    cd42:	b913      	cbnz	r3, cd4a <timer_add_timer_task+0x3a>
		list_insert_after(prev, new_task);
    cd44:	4b04      	ldr	r3, [pc, #16]	; (cd58 <timer_add_timer_task+0x48>)
    cd46:	4630      	mov	r0, r6
    cd48:	e7e6      	b.n	cd18 <timer_add_timer_task+0x8>
    cd4a:	461c      	mov	r4, r3
    cd4c:	e7ed      	b.n	cd2a <timer_add_timer_task+0x1a>
	if (it == head) {
    cd4e:	42a5      	cmp	r5, r4
    cd50:	d0e1      	beq.n	cd16 <timer_add_timer_task+0x6>
    cd52:	e7f7      	b.n	cd44 <timer_add_timer_task+0x34>
    cd54:	0000fbe5 	.word	0x0000fbe5
    cd58:	0000fc11 	.word	0x0000fc11

0000cd5c <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    cd5c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    cd60:	e9d0 6504 	ldrd	r6, r5, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    cd64:	7e03      	ldrb	r3, [r0, #24]
	uint32_t                 time  = ++timer->time;
    cd66:	3601      	adds	r6, #1
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    cd68:	07da      	lsls	r2, r3, #31
{
    cd6a:	4604      	mov	r4, r0
	uint32_t                 time  = ++timer->time;
    cd6c:	6106      	str	r6, [r0, #16]
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    cd6e:	d41f      	bmi.n	cdb0 <timer_process_counted+0x54>
    cd70:	7e03      	ldrb	r3, [r0, #24]
    cd72:	079b      	lsls	r3, r3, #30
    cd74:	d41c      	bmi.n	cdb0 <timer_process_counted+0x54>
	}

	while (it && ((time - it->time_label) >= it->interval)) {
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    cd76:	f8df 8044 	ldr.w	r8, [pc, #68]	; cdbc <timer_process_counted+0x60>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    cd7a:	f8df 9044 	ldr.w	r9, [pc, #68]	; cdc0 <timer_process_counted+0x64>
		list_remove_head(&timer->tasks);
    cd7e:	f100 0714 	add.w	r7, r0, #20
	while (it && ((time - it->time_label) >= it->interval)) {
    cd82:	b1cd      	cbz	r5, cdb8 <timer_process_counted+0x5c>
    cd84:	686b      	ldr	r3, [r5, #4]
    cd86:	68aa      	ldr	r2, [r5, #8]
    cd88:	1af3      	subs	r3, r6, r3
    cd8a:	4293      	cmp	r3, r2
    cd8c:	d314      	bcc.n	cdb8 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
    cd8e:	4638      	mov	r0, r7
    cd90:	47c0      	blx	r8
		if (TIMER_TASK_REPEAT == tmp->mode) {
    cd92:	7c2b      	ldrb	r3, [r5, #16]
    cd94:	2b01      	cmp	r3, #1
    cd96:	d104      	bne.n	cda2 <timer_process_counted+0x46>
			tmp->time_label = time;
    cd98:	606e      	str	r6, [r5, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    cd9a:	4632      	mov	r2, r6
    cd9c:	4629      	mov	r1, r5
    cd9e:	4638      	mov	r0, r7
    cda0:	47c8      	blx	r9
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);
    cda2:	f8d4 a014 	ldr.w	sl, [r4, #20]

		tmp->cb(tmp);
    cda6:	68eb      	ldr	r3, [r5, #12]
    cda8:	4628      	mov	r0, r5
    cdaa:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    cdac:	4655      	mov	r5, sl
    cdae:	e7e8      	b.n	cd82 <timer_process_counted+0x26>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    cdb0:	7e23      	ldrb	r3, [r4, #24]
    cdb2:	f043 0302 	orr.w	r3, r3, #2
    cdb6:	7623      	strb	r3, [r4, #24]
	}
}
    cdb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    cdbc:	0000fc59 	.word	0x0000fc59
    cdc0:	0000cd11 	.word	0x0000cd11

0000cdc4 <timer_init>:
{
    cdc4:	b570      	push	{r4, r5, r6, lr}
    cdc6:	460d      	mov	r5, r1
    cdc8:	4616      	mov	r6, r2
	ASSERT(descr && hw && func);
    cdca:	4604      	mov	r4, r0
    cdcc:	b118      	cbz	r0, cdd6 <timer_init+0x12>
    cdce:	b189      	cbz	r1, cdf4 <timer_init+0x30>
    cdd0:	1e10      	subs	r0, r2, #0
    cdd2:	bf18      	it	ne
    cdd4:	2001      	movne	r0, #1
    cdd6:	223b      	movs	r2, #59	; 0x3b
    cdd8:	4907      	ldr	r1, [pc, #28]	; (cdf8 <timer_init+0x34>)
    cdda:	4b08      	ldr	r3, [pc, #32]	; (cdfc <timer_init+0x38>)
    cddc:	4798      	blx	r3
	descr->func = func;
    cdde:	4620      	mov	r0, r4
	descr->func->init(&descr->device, hw);
    cde0:	6833      	ldr	r3, [r6, #0]
	descr->func = func;
    cde2:	f840 6b04 	str.w	r6, [r0], #4
	descr->func->init(&descr->device, hw);
    cde6:	4629      	mov	r1, r5
    cde8:	4798      	blx	r3
	descr->device.timer_cb.period_expired = timer_process_counted;
    cdea:	4b05      	ldr	r3, [pc, #20]	; (ce00 <timer_init+0x3c>)
    cdec:	6063      	str	r3, [r4, #4]
	descr->time                           = 0;
    cdee:	2000      	movs	r0, #0
    cdf0:	6160      	str	r0, [r4, #20]
}
    cdf2:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw && func);
    cdf4:	4608      	mov	r0, r1
    cdf6:	e7ee      	b.n	cdd6 <timer_init+0x12>
    cdf8:	000167f8 	.word	0x000167f8
    cdfc:	0000e42d 	.word	0x0000e42d
    ce00:	0000cd5d 	.word	0x0000cd5d

0000ce04 <timer_start>:
{
    ce04:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr && descr->func);
    ce06:	4605      	mov	r5, r0
    ce08:	b118      	cbz	r0, ce12 <timer_start+0xe>
    ce0a:	6800      	ldr	r0, [r0, #0]
    ce0c:	3800      	subs	r0, #0
    ce0e:	bf18      	it	ne
    ce10:	2001      	movne	r0, #1
	if (descr->func->is_timer_started(&descr->device)) {
    ce12:	462e      	mov	r6, r5
	ASSERT(descr && descr->func);
    ce14:	4909      	ldr	r1, [pc, #36]	; (ce3c <timer_start+0x38>)
    ce16:	4b0a      	ldr	r3, [pc, #40]	; (ce40 <timer_start+0x3c>)
    ce18:	2254      	movs	r2, #84	; 0x54
    ce1a:	4798      	blx	r3
	if (descr->func->is_timer_started(&descr->device)) {
    ce1c:	f856 3b04 	ldr.w	r3, [r6], #4
    ce20:	699b      	ldr	r3, [r3, #24]
    ce22:	4630      	mov	r0, r6
    ce24:	4798      	blx	r3
    ce26:	4604      	mov	r4, r0
    ce28:	b928      	cbnz	r0, ce36 <timer_start+0x32>
	descr->func->start_timer(&descr->device);
    ce2a:	682b      	ldr	r3, [r5, #0]
    ce2c:	4630      	mov	r0, r6
    ce2e:	689b      	ldr	r3, [r3, #8]
    ce30:	4798      	blx	r3
	return ERR_NONE;
    ce32:	4620      	mov	r0, r4
}
    ce34:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
    ce36:	f06f 0010 	mvn.w	r0, #16
    ce3a:	e7fb      	b.n	ce34 <timer_start+0x30>
    ce3c:	000167f8 	.word	0x000167f8
    ce40:	0000e42d 	.word	0x0000e42d

0000ce44 <timer_add_task>:
{
    ce44:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    ce48:	460d      	mov	r5, r1
	ASSERT(descr && task && descr->func);
    ce4a:	4604      	mov	r4, r0
    ce4c:	b120      	cbz	r0, ce58 <timer_add_task+0x14>
    ce4e:	b309      	cbz	r1, ce94 <timer_add_task+0x50>
    ce50:	6800      	ldr	r0, [r0, #0]
    ce52:	3800      	subs	r0, #0
    ce54:	bf18      	it	ne
    ce56:	2001      	movne	r0, #1
    ce58:	4920      	ldr	r1, [pc, #128]	; (cedc <timer_add_task+0x98>)
    ce5a:	f8df 8094 	ldr.w	r8, [pc, #148]	; cef0 <timer_add_task+0xac>
    ce5e:	227b      	movs	r2, #123	; 0x7b
    ce60:	47c0      	blx	r8
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    ce62:	7f23      	ldrb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    ce64:	f104 0718 	add.w	r7, r4, #24
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    ce68:	f043 0301 	orr.w	r3, r3, #1
    ce6c:	7723      	strb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    ce6e:	4629      	mov	r1, r5
    ce70:	4b1b      	ldr	r3, [pc, #108]	; (cee0 <timer_add_task+0x9c>)
    ce72:	4638      	mov	r0, r7
    ce74:	4798      	blx	r3
    ce76:	4606      	mov	r6, r0
    ce78:	b170      	cbz	r0, ce98 <timer_add_task+0x54>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    ce7a:	7f23      	ldrb	r3, [r4, #28]
		ASSERT(false);
    ce7c:	4917      	ldr	r1, [pc, #92]	; (cedc <timer_add_task+0x98>)
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    ce7e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
		ASSERT(false);
    ce82:	2000      	movs	r0, #0
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    ce84:	7723      	strb	r3, [r4, #28]
		ASSERT(false);
    ce86:	2280      	movs	r2, #128	; 0x80
    ce88:	47c0      	blx	r8
		return ERR_ALREADY_INITIALIZED;
    ce8a:	f06f 0011 	mvn.w	r0, #17
}
    ce8e:	b002      	add	sp, #8
    ce90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(descr && task && descr->func);
    ce94:	4608      	mov	r0, r1
    ce96:	e7df      	b.n	ce58 <timer_add_task+0x14>
	task->time_label = descr->time;
    ce98:	6962      	ldr	r2, [r4, #20]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    ce9a:	4b12      	ldr	r3, [pc, #72]	; (cee4 <timer_add_task+0xa0>)
	task->time_label = descr->time;
    ce9c:	606a      	str	r2, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    ce9e:	4629      	mov	r1, r5
    cea0:	4638      	mov	r0, r7
    cea2:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    cea4:	7f23      	ldrb	r3, [r4, #28]
    cea6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    ceaa:	7723      	strb	r3, [r4, #28]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    ceac:	7f23      	ldrb	r3, [r4, #28]
    ceae:	f013 0302 	ands.w	r3, r3, #2
    ceb2:	d010      	beq.n	ced6 <timer_add_task+0x92>
		CRITICAL_SECTION_ENTER()
    ceb4:	4b0c      	ldr	r3, [pc, #48]	; (cee8 <timer_add_task+0xa4>)
    ceb6:	a801      	add	r0, sp, #4
    ceb8:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    ceba:	7f23      	ldrb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    cebc:	4620      	mov	r0, r4
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    cebe:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    cec2:	7723      	strb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    cec4:	f850 3b04 	ldr.w	r3, [r0], #4
    cec8:	69db      	ldr	r3, [r3, #28]
    ceca:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    cecc:	a801      	add	r0, sp, #4
    cece:	4b07      	ldr	r3, [pc, #28]	; (ceec <timer_add_task+0xa8>)
    ced0:	4798      	blx	r3
	return ERR_NONE;
    ced2:	4630      	mov	r0, r6
    ced4:	e7db      	b.n	ce8e <timer_add_task+0x4a>
    ced6:	4618      	mov	r0, r3
    ced8:	e7d9      	b.n	ce8e <timer_add_task+0x4a>
    ceda:	bf00      	nop
    cedc:	000167f8 	.word	0x000167f8
    cee0:	0000fbd5 	.word	0x0000fbd5
    cee4:	0000cd11 	.word	0x0000cd11
    cee8:	00011ef9 	.word	0x00011ef9
    ceec:	00011f07 	.word	0x00011f07
    cef0:	0000e42d 	.word	0x0000e42d

0000cef4 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    cef4:	2000      	movs	r0, #0
    cef6:	4770      	bx	lr

0000cef8 <_usb_d_dev_wait_dfll_rdy>:
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    cef8:	4b07      	ldr	r3, [pc, #28]	; (cf18 <_usb_d_dev_wait_dfll_rdy+0x20>)
    cefa:	f893 2020 	ldrb.w	r2, [r3, #32]
/**
 * \brief Wait DFLL clock to be ready
 */
static inline void _usb_d_dev_wait_dfll_rdy(void)
{
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    cefe:	07d1      	lsls	r1, r2, #31
    cf00:	d506      	bpl.n	cf10 <_usb_d_dev_wait_dfll_rdy+0x18>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    cf02:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    cf04:	f402 6210 	and.w	r2, r2, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    cf08:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    cf0c:	d1f9      	bne.n	cf02 <_usb_d_dev_wait_dfll_rdy+0xa>
    cf0e:	4770      	bx	lr
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    cf10:	691a      	ldr	r2, [r3, #16]
		       != (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
			;
	} else {
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    cf12:	05d2      	lsls	r2, r2, #23
    cf14:	d5fc      	bpl.n	cf10 <_usb_d_dev_wait_dfll_rdy+0x18>
			;
	}
}
    cf16:	4770      	bx	lr
    cf18:	40001000 	.word	0x40001000

0000cf1c <_usb_d_dev_ept>:
 * \param[in] epn Endpoint number.
 * \param[in] dir Endpoint direction.
 */
static inline struct _usb_d_dev_ep *_usb_d_dev_ept(uint8_t epn, bool dir)
{
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    cf1c:	b110      	cbz	r0, cf24 <_usb_d_dev_ept+0x8>
    cf1e:	b109      	cbz	r1, cf24 <_usb_d_dev_ept+0x8>
    cf20:	3005      	adds	r0, #5
    cf22:	b2c0      	uxtb	r0, r0
	return &dev_inst.ep[ep_index];
    cf24:	2314      	movs	r3, #20
    cf26:	fb00 3003 	mla	r0, r0, r3, r3
}
    cf2a:	4b01      	ldr	r3, [pc, #4]	; (cf30 <_usb_d_dev_ept+0x14>)
    cf2c:	4418      	add	r0, r3
    cf2e:	4770      	bx	lr
    cf30:	200085a8 	.word	0x200085a8

0000cf34 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    cf34:	b430      	push	{r4, r5}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    cf36:	7cc1      	ldrb	r1, [r0, #19]
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    cf38:	7c85      	ldrb	r5, [r0, #18]

	if (!is_ctrl) {
    cf3a:	f001 0307 	and.w	r3, r1, #7
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    cf3e:	f005 020f 	and.w	r2, r5, #15
	if (!is_ctrl) {
    cf42:	2b01      	cmp	r3, #1
    cf44:	ea4f 1442 	mov.w	r4, r2, lsl #5
    cf48:	f102 0308 	add.w	r3, r2, #8
    cf4c:	d00a      	beq.n	cf64 <_usb_d_dev_handle_setup+0x30>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cf4e:	015a      	lsls	r2, r3, #5
    cf50:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    cf54:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cf58:	2110      	movs	r1, #16
    cf5a:	71d1      	strb	r1, [r2, #7]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    cf5c:	bc30      	pop	{r4, r5}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    cf5e:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    cf62:	4770      	bx	lr
	if (_usb_d_dev_ep_is_busy(ept)) {
    cf64:	f011 0f40 	tst.w	r1, #64	; 0x40
    cf68:	d00b      	beq.n	cf82 <_usb_d_dev_handle_setup+0x4e>
		ept->flags.bits.is_busy = 0;
    cf6a:	0152      	lsls	r2, r2, #5
    cf6c:	f36f 1186 	bfc	r1, #6, #1
    cf70:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    cf74:	74c1      	strb	r1, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    cf76:	2180      	movs	r1, #128	; 0x80
    cf78:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    cf7c:	2140      	movs	r1, #64	; 0x40
    cf7e:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105
	ept->flags.bits.is_stalled = 0;
    cf82:	7cc2      	ldrb	r2, [r0, #19]
    cf84:	f36f 02c3 	bfc	r2, #3, #1
    cf88:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    cf8a:	4a0a      	ldr	r2, [pc, #40]	; (cfb4 <_usb_d_dev_handle_setup+0x80>)
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    cf8c:	015b      	lsls	r3, r3, #5
    cf8e:	1911      	adds	r1, r2, r4
    cf90:	2000      	movs	r0, #0
    cf92:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    cf96:	f881 023a 	strb.w	r0, [r1, #570]	; 0x23a
    cf9a:	f881 024a 	strb.w	r0, [r1, #586]	; 0x24a
    cf9e:	216f      	movs	r1, #111	; 0x6f
    cfa0:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    cfa2:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	dev_inst.ep_callbacks.setup(ept->ep);
    cfa6:	4628      	mov	r0, r5
    cfa8:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    cfac:	bc30      	pop	{r4, r5}
	dev_inst.ep_callbacks.setup(ept->ep);
    cfae:	6893      	ldr	r3, [r2, #8]
    cfb0:	4718      	bx	r3
    cfb2:	bf00      	nop
    cfb4:	200085a8 	.word	0x200085a8

0000cfb8 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    cfb8:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    cfba:	7c84      	ldrb	r4, [r0, #18]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cfbc:	6882      	ldr	r2, [r0, #8]
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    cfbe:	2320      	movs	r3, #32
    cfc0:	fa03 f101 	lsl.w	r1, r3, r1
    cfc4:	f004 030f 	and.w	r3, r4, #15
    cfc8:	015b      	lsls	r3, r3, #5
    cfca:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    cfce:	b2c9      	uxtb	r1, r1
    cfd0:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cfd4:	4b03      	ldr	r3, [pc, #12]	; (cfe4 <_usb_d_dev_handle_stall+0x2c>)
    cfd6:	4620      	mov	r0, r4
    cfd8:	691b      	ldr	r3, [r3, #16]
}
    cfda:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    cfde:	2101      	movs	r1, #1
    cfe0:	4718      	bx	r3
    cfe2:	bf00      	nop
    cfe4:	200085a8 	.word	0x200085a8

0000cfe8 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    cfe8:	b410      	push	{r4}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    cfea:	7c84      	ldrb	r4, [r0, #18]
    cfec:	2cff      	cmp	r4, #255	; 0xff
    cfee:	d00c      	beq.n	d00a <_usb_d_dev_trans_done+0x22>
    cff0:	7cc3      	ldrb	r3, [r0, #19]
    cff2:	065a      	lsls	r2, r3, #25
    cff4:	d509      	bpl.n	d00a <_usb_d_dev_trans_done+0x22>
		return;
	}
	ept->flags.bits.is_busy = 0;
    cff6:	f36f 1386 	bfc	r3, #6, #1
    cffa:	74c3      	strb	r3, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    cffc:	4b04      	ldr	r3, [pc, #16]	; (d010 <_usb_d_dev_trans_done+0x28>)
    cffe:	6882      	ldr	r2, [r0, #8]
    d000:	691b      	ldr	r3, [r3, #16]
    d002:	4620      	mov	r0, r4
}
    d004:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    d008:	4718      	bx	r3
}
    d00a:	f85d 4b04 	ldr.w	r4, [sp], #4
    d00e:	4770      	bx	lr
    d010:	200085a8 	.word	0x200085a8

0000d014 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    d014:	b477      	push	{r0, r1, r2, r4, r5, r6}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d016:	7c83      	ldrb	r3, [r0, #18]
{
    d018:	460d      	mov	r5, r1
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    d01a:	2bff      	cmp	r3, #255	; 0xff
{
    d01c:	4611      	mov	r1, r2
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    d01e:	f644 2225 	movw	r2, #18981	; 0x4a25
    d022:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    d026:	d020      	beq.n	d06a <_usb_d_dev_trans_stop+0x56>
    d028:	7cc2      	ldrb	r2, [r0, #19]
    d02a:	0652      	lsls	r2, r2, #25
    d02c:	d51d      	bpl.n	d06a <_usb_d_dev_trans_stop+0x56>
		return;
	}
	/* Stop transfer */
	if (dir) {
    d02e:	f003 030f 	and.w	r3, r3, #15
    d032:	f103 0408 	add.w	r4, r3, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d036:	0162      	lsls	r2, r4, #5
    d038:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d03c:	b195      	cbz	r5, d064 <_usb_d_dev_trans_stop+0x50>
    d03e:	2680      	movs	r6, #128	; 0x80
    d040:	7116      	strb	r6, [r2, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    d042:	aa02      	add	r2, sp, #8
    d044:	4415      	add	r5, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d046:	0164      	lsls	r4, r4, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d048:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d04a:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d04e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d052:	f815 2c04 	ldrb.w	r2, [r5, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d056:	71e2      	strb	r2, [r4, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d058:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    d05c:	4b04      	ldr	r3, [pc, #16]	; (d070 <_usb_d_dev_trans_stop+0x5c>)
}
    d05e:	b003      	add	sp, #12
    d060:	bc70      	pop	{r4, r5, r6}
	_usb_d_dev_trans_done(ept, code);
    d062:	4718      	bx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d064:	2640      	movs	r6, #64	; 0x40
    d066:	7156      	strb	r6, [r2, #5]
}
    d068:	e7eb      	b.n	d042 <_usb_d_dev_trans_stop+0x2e>
}
    d06a:	b003      	add	sp, #12
    d06c:	bc70      	pop	{r4, r5, r6}
    d06e:	4770      	bx	lr
    d070:	0000cfe9 	.word	0x0000cfe9

0000d074 <_usb_d_dev_handle_trfail>:
{
    d074:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    d076:	7c83      	ldrb	r3, [r0, #18]
    d078:	f003 0c0f 	and.w	ip, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    d07c:	f640 0204 	movw	r2, #2052	; 0x804
    d080:	4663      	mov	r3, ip
    d082:	f8ad 2004 	strh.w	r2, [sp, #4]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    d086:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    d088:	f10c 0308 	add.w	r3, ip, #8
    d08c:	460c      	mov	r4, r1

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d08e:	0159      	lsls	r1, r3, #5
    d090:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    d094:	780f      	ldrb	r7, [r1, #0]
    d096:	b334      	cbz	r4, d0e6 <_usb_d_dev_handle_trfail+0x72>
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    d098:	f3c7 1702 	ubfx	r7, r7, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    d09c:	4e2c      	ldr	r6, [pc, #176]	; (d150 <_usb_d_dev_handle_trfail+0xdc>)
    d09e:	eb02 1204 	add.w	r2, r2, r4, lsl #4
    d0a2:	4416      	add	r6, r2
    d0a4:	aa02      	add	r2, sp, #8
    d0a6:	4422      	add	r2, r4
    d0a8:	7ab5      	ldrb	r5, [r6, #10]
    d0aa:	f812 ec04 	ldrb.w	lr, [r2, #-4]
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    d0ae:	2f02      	cmp	r7, #2
	st.reg = bank[bank_n].STATUS_BK.reg;
    d0b0:	b2ed      	uxtb	r5, r5
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    d0b2:	ea4f 124c 	mov.w	r2, ip, lsl #5
    d0b6:	d119      	bne.n	d0ec <_usb_d_dev_handle_trfail+0x78>
    d0b8:	07e9      	lsls	r1, r5, #31
    d0ba:	d517      	bpl.n	d0ec <_usb_d_dev_handle_trfail+0x78>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    d0bc:	7ab1      	ldrb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d0be:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d0c0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d0c4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d0c8:	f36f 0100 	bfc	r1, #0, #1
    d0cc:	72b1      	strb	r1, [r6, #10]
    d0ce:	f883 e007 	strb.w	lr, [r3, #7]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    d0d2:	f004 0101 	and.w	r1, r4, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d0d6:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    d0da:	2204      	movs	r2, #4
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    d0dc:	4b1d      	ldr	r3, [pc, #116]	; (d154 <_usb_d_dev_handle_trfail+0xe0>)
}
    d0de:	b003      	add	sp, #12
    d0e0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    d0e4:	4718      	bx	r3
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    d0e6:	f007 0707 	and.w	r7, r7, #7
	return tmp;
    d0ea:	e7d7      	b.n	d09c <_usb_d_dev_handle_trfail+0x28>
	} else if (st.bit.ERRORFLOW) {
    d0ec:	f015 0502 	ands.w	r5, r5, #2
    d0f0:	d01b      	beq.n	d12a <_usb_d_dev_handle_trfail+0xb6>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    d0f2:	7ab1      	ldrb	r1, [r6, #10]
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d0f4:	7cc5      	ldrb	r5, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d0f6:	015b      	lsls	r3, r3, #5
    d0f8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    d0fc:	f36f 0141 	bfc	r1, #1, #1
    d100:	72b1      	strb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d102:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d106:	f883 e007 	strb.w	lr, [r3, #7]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    d10a:	f005 0307 	and.w	r3, r5, #7
    d10e:	2b01      	cmp	r3, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d110:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    d114:	d119      	bne.n	d14a <_usb_d_dev_handle_trfail+0xd6>
    d116:	066b      	lsls	r3, r5, #25
    d118:	d517      	bpl.n	d14a <_usb_d_dev_handle_trfail+0xd6>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    d11a:	7cc3      	ldrb	r3, [r0, #19]
    d11c:	ebb4 1fd3 	cmp.w	r4, r3, lsr #7
    d120:	ea4f 11d3 	mov.w	r1, r3, lsr #7
    d124:	d011      	beq.n	d14a <_usb_d_dev_handle_trfail+0xd6>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    d126:	2200      	movs	r2, #0
    d128:	e7d8      	b.n	d0dc <_usb_d_dev_handle_trfail+0x68>
	bank->STATUS_BK.reg     = 0;
    d12a:	490b      	ldr	r1, [pc, #44]	; (d158 <_usb_d_dev_handle_trfail+0xe4>)
    d12c:	eb04 044c 	add.w	r4, r4, ip, lsl #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d130:	015b      	lsls	r3, r3, #5
    d132:	eb01 1404 	add.w	r4, r1, r4, lsl #4
    d136:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d13a:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d13e:	f884 523a 	strb.w	r5, [r4, #570]	; 0x23a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d142:	f883 e007 	strb.w	lr, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d146:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
}
    d14a:	b003      	add	sp, #12
    d14c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d14e:	bf00      	nop
    d150:	200087d8 	.word	0x200087d8
    d154:	0000d015 	.word	0x0000d015
    d158:	200085a8 	.word	0x200085a8

0000d15c <_usb_d_dev_reset_epts>:
{
    d15c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d160:	4c0a      	ldr	r4, [pc, #40]	; (d18c <_usb_d_dev_reset_epts+0x30>)
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    d162:	4f0b      	ldr	r7, [pc, #44]	; (d190 <_usb_d_dev_reset_epts+0x34>)
{
    d164:	2501      	movs	r5, #1
		dev_inst.ep[i].ep       = 0xFF;
    d166:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    d168:	2103      	movs	r1, #3
    d16a:	4620      	mov	r0, r4
    d16c:	3501      	adds	r5, #1
    d16e:	47b8      	blx	r7
		dev_inst.ep[i].flags.u8 = 0;
    d170:	2100      	movs	r1, #0
	for (i = 0; i < USB_D_N_EP; i++) {
    d172:	2d1c      	cmp	r5, #28
		dev_inst.ep[i].ep       = 0xFF;
    d174:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    d176:	74e1      	strb	r1, [r4, #19]
	for (i = 0; i < USB_D_N_EP; i++) {
    d178:	f104 0414 	add.w	r4, r4, #20
    d17c:	d1f4      	bne.n	d168 <_usb_d_dev_reset_epts+0xc>
}
    d17e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    d182:	4804      	ldr	r0, [pc, #16]	; (d194 <_usb_d_dev_reset_epts+0x38>)
    d184:	4b04      	ldr	r3, [pc, #16]	; (d198 <_usb_d_dev_reset_epts+0x3c>)
    d186:	22c0      	movs	r2, #192	; 0xc0
    d188:	4718      	bx	r3
    d18a:	bf00      	nop
    d18c:	200085bc 	.word	0x200085bc
    d190:	0000cfe9 	.word	0x0000cfe9
    d194:	200087d8 	.word	0x200087d8
    d198:	000147c5 	.word	0x000147c5

0000d19c <_usb_d_dev_in_next>:
{
    d19c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d1a0:	4604      	mov	r4, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    d1a2:	7c80      	ldrb	r0, [r0, #18]
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d1a4:	4688      	mov	r8, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    d1a6:	f000 070f 	and.w	r7, r0, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d1aa:	2900      	cmp	r1, #0
    d1ac:	d05b      	beq.n	d266 <_usb_d_dev_in_next+0xca>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    d1ae:	4b4d      	ldr	r3, [pc, #308]	; (d2e4 <_usb_d_dev_in_next+0x148>)
    d1b0:	eb03 1347 	add.w	r3, r3, r7, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d1b4:	695e      	ldr	r6, [r3, #20]
    d1b6:	f3c6 060d 	ubfx	r6, r6, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    d1ba:	8a22      	ldrh	r2, [r4, #16]
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    d1bc:	f894 e013 	ldrb.w	lr, [r4, #19]
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    d1c0:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d1c4:	429a      	cmp	r2, r3
    d1c6:	bf1a      	itte	ne
    d1c8:	f102 3cff 	addne.w	ip, r2, #4294967295	; 0xffffffff
    d1cc:	fa0f fc8c 	sxthne.w	ip, ip
    d1d0:	4694      	moveq	ip, r2
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    d1d2:	f00e 0907 	and.w	r9, lr, #7
	if (isr) {
    d1d6:	f1b8 0f00 	cmp.w	r8, #0
    d1da:	d005      	beq.n	d1e8 <_usb_d_dev_in_next+0x4c>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d1dc:	017b      	lsls	r3, r7, #5
    d1de:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d1e2:	2102      	movs	r1, #2
    d1e4:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	ept->trans_count += trans_count;
    d1e8:	68a1      	ldr	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    d1ea:	6863      	ldr	r3, [r4, #4]
	ept->trans_count += trans_count;
    d1ec:	4431      	add	r1, r6
	if (ept->trans_count < ept->trans_size) {
    d1ee:	4299      	cmp	r1, r3
	ept->trans_count += trans_count;
    d1f0:	60a1      	str	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    d1f2:	ea4f 1547 	mov.w	r5, r7, lsl #5
    d1f6:	d242      	bcs.n	d27e <_usb_d_dev_in_next+0xe2>
		trans_next = ept->trans_size - ept->trans_count;
    d1f8:	1a5b      	subs	r3, r3, r1
    d1fa:	b29e      	uxth	r6, r3
		if (ept->flags.bits.use_cache) {
    d1fc:	6823      	ldr	r3, [r4, #0]
    d1fe:	f8df a0f0 	ldr.w	sl, [pc, #240]	; d2f0 <_usb_d_dev_in_next+0x154>
    d202:	f01e 0f20 	tst.w	lr, #32
    d206:	4419      	add	r1, r3
    d208:	d02f      	beq.n	d26a <_usb_d_dev_in_next+0xce>
			if (trans_next > ept->size) {
    d20a:	4296      	cmp	r6, r2
    d20c:	bf28      	it	cs
    d20e:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    d210:	4b35      	ldr	r3, [pc, #212]	; (d2e8 <_usb_d_dev_in_next+0x14c>)
    d212:	68e0      	ldr	r0, [r4, #12]
    d214:	4632      	mov	r2, r6
    d216:	4798      	blx	r3
	bank->ADDR.reg          = addr;
    d218:	eb0a 0305 	add.w	r3, sl, r5
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    d21c:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    d21e:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    d222:	eb0a 0205 	add.w	r2, sl, r5
    d226:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    d22a:	f366 030d 	bfi	r3, r6, #0, #14
    d22e:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    d232:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    d236:	f36f 339b 	bfc	r3, #14, #14
    d23a:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	if (!isr) {
    d23e:	f1b8 0f00 	cmp.w	r8, #0
    d242:	d108      	bne.n	d256 <_usb_d_dev_in_next+0xba>
			inten = USB_D_BANK1_INT_FLAGS;
    d244:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d248:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d24c:	bf0c      	ite	eq
    d24e:	234e      	moveq	r3, #78	; 0x4e
    d250:	234a      	movne	r3, #74	; 0x4a
    d252:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d256:	017b      	lsls	r3, r7, #5
    d258:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d25c:	2280      	movs	r2, #128	; 0x80
    d25e:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
}
    d262:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d266:	460e      	mov	r6, r1
    d268:	e7a7      	b.n	d1ba <_usb_d_dev_in_next+0x1e>
	bank->ADDR.reg          = addr;
    d26a:	eb0a 0305 	add.w	r3, sl, r5
    d26e:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    d272:	bf28      	it	cs
    d274:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
    d278:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
}
    d27c:	e7d1      	b.n	d222 <_usb_d_dev_in_next+0x86>
	} else if (ept->flags.bits.need_zlp) {
    d27e:	f01e 0f10 	tst.w	lr, #16
    d282:	d00e      	beq.n	d2a2 <_usb_d_dev_in_next+0x106>
		ept->flags.bits.need_zlp = 0;
    d284:	7ce3      	ldrb	r3, [r4, #19]
    d286:	f36f 1304 	bfc	r3, #4, #1
    d28a:	74e3      	strb	r3, [r4, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    d28c:	4b17      	ldr	r3, [pc, #92]	; (d2ec <_usb_d_dev_in_next+0x150>)
    d28e:	442b      	add	r3, r5
    d290:	685a      	ldr	r2, [r3, #4]
    d292:	f36f 020d 	bfc	r2, #0, #14
    d296:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    d298:	685a      	ldr	r2, [r3, #4]
    d29a:	f36f 329b 	bfc	r2, #14, #14
    d29e:	605a      	str	r2, [r3, #4]
		goto _in_tx_exec;
    d2a0:	e7cd      	b.n	d23e <_usb_d_dev_in_next+0xa2>
	if (is_ctrl) {
    d2a2:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d2a6:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
	if (last_pkt == ept->size) {
    d2aa:	ea0c 0c06 	and.w	ip, ip, r6
    d2ae:	bf0c      	ite	eq
    d2b0:	234b      	moveq	r3, #75	; 0x4b
    d2b2:	234a      	movne	r3, #74	; 0x4a
    d2b4:	4562      	cmp	r2, ip
    d2b6:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
    d2ba:	d10c      	bne.n	d2d6 <_usb_d_dev_in_next+0x13a>
		ept->flags.bits.is_busy = 0;
    d2bc:	7ce3      	ldrb	r3, [r4, #19]
    d2be:	f36f 1386 	bfc	r3, #6, #1
    d2c2:	74e3      	strb	r3, [r4, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    d2c4:	4b0a      	ldr	r3, [pc, #40]	; (d2f0 <_usb_d_dev_in_next+0x154>)
    d2c6:	68db      	ldr	r3, [r3, #12]
    d2c8:	4798      	blx	r3
    d2ca:	2800      	cmp	r0, #0
    d2cc:	d1c9      	bne.n	d262 <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    d2ce:	7ce3      	ldrb	r3, [r4, #19]
    d2d0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d2d4:	74e3      	strb	r3, [r4, #19]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d2d6:	4620      	mov	r0, r4
    d2d8:	4b06      	ldr	r3, [pc, #24]	; (d2f4 <_usb_d_dev_in_next+0x158>)
}
    d2da:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d2de:	2100      	movs	r1, #0
    d2e0:	4718      	bx	r3
    d2e2:	bf00      	nop
    d2e4:	200087d8 	.word	0x200087d8
    d2e8:	000147a9 	.word	0x000147a9
    d2ec:	200087e8 	.word	0x200087e8
    d2f0:	200085a8 	.word	0x200085a8
    d2f4:	0000cfe9 	.word	0x0000cfe9

0000d2f8 <_usb_d_dev_out_next>:
{
    d2f8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    d2fc:	7c86      	ldrb	r6, [r0, #18]
    d2fe:	f006 060f 	and.w	r6, r6, #15
{
    d302:	4604      	mov	r4, r0
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d304:	460f      	mov	r7, r1
    d306:	0175      	lsls	r5, r6, #5
    d308:	2900      	cmp	r1, #0
    d30a:	d060      	beq.n	d3ce <_usb_d_dev_out_next+0xd6>
    d30c:	4b5d      	ldr	r3, [pc, #372]	; (d484 <_usb_d_dev_out_next+0x18c>)
    d30e:	442b      	add	r3, r5
    d310:	685a      	ldr	r2, [r3, #4]
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d312:	685b      	ldr	r3, [r3, #4]
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d314:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d318:	f3c3 090d 	ubfx	r9, r3, #0, #14
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d31c:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d320:	7ce2      	ldrb	r2, [r4, #19]
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d322:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d326:	4598      	cmp	r8, r3
    d328:	bf1c      	itt	ne
    d32a:	f108 38ff 	addne.w	r8, r8, #4294967295	; 0xffffffff
    d32e:	fa1f f888 	uxthne.w	r8, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d332:	f002 0307 	and.w	r3, r2, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    d336:	ea09 0b08 	and.w	fp, r9, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d33a:	9301      	str	r3, [sp, #4]
	if (isr) {
    d33c:	b12f      	cbz	r7, d34a <_usb_d_dev_out_next+0x52>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d33e:	0173      	lsls	r3, r6, #5
    d340:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d344:	2101      	movs	r1, #1
    d346:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    d34a:	0690      	lsls	r0, r2, #26
    d34c:	d50c      	bpl.n	d368 <_usb_d_dev_out_next+0x70>
    d34e:	6862      	ldr	r2, [r4, #4]
    d350:	b152      	cbz	r2, d368 <_usb_d_dev_out_next+0x70>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    d352:	68a0      	ldr	r0, [r4, #8]
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    d354:	6823      	ldr	r3, [r4, #0]
    d356:	68e1      	ldr	r1, [r4, #12]
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    d358:	1a12      	subs	r2, r2, r0
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    d35a:	b292      	uxth	r2, r2
    d35c:	455a      	cmp	r2, fp
    d35e:	4418      	add	r0, r3
    d360:	bf28      	it	cs
    d362:	465a      	movcs	r2, fp
    d364:	4b48      	ldr	r3, [pc, #288]	; (d488 <_usb_d_dev_out_next+0x190>)
    d366:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    d368:	6863      	ldr	r3, [r4, #4]
    d36a:	2b00      	cmp	r3, #0
    d36c:	d132      	bne.n	d3d4 <_usb_d_dev_out_next+0xdc>
    d36e:	7ce2      	ldrb	r2, [r4, #19]
    d370:	06d1      	lsls	r1, r2, #27
    d372:	d52f      	bpl.n	d3d4 <_usb_d_dev_out_next+0xdc>
	bank->ADDR.reg          = addr;
    d374:	4845      	ldr	r0, [pc, #276]	; (d48c <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d376:	68e1      	ldr	r1, [r4, #12]
		ept->flags.bits.need_zlp  = 0;
    d378:	f022 0230 	bic.w	r2, r2, #48	; 0x30
	bank->ADDR.reg          = addr;
    d37c:	4428      	add	r0, r5
		ept->flags.bits.need_zlp  = 0;
    d37e:	f042 0220 	orr.w	r2, r2, #32
    d382:	74e2      	strb	r2, [r4, #19]
	bank->ADDR.reg          = addr;
    d384:	f500 720c 	add.w	r2, r0, #560	; 0x230
    d388:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d38c:	6851      	ldr	r1, [r2, #4]
    d38e:	8a20      	ldrh	r0, [r4, #16]
    d390:	f360 319b 	bfi	r1, r0, #14, #14
    d394:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d396:	6851      	ldr	r1, [r2, #4]
    d398:	f363 010d 	bfi	r1, r3, #0, #14
    d39c:	6051      	str	r1, [r2, #4]
	if (!isr) {
    d39e:	b96f      	cbnz	r7, d3bc <_usb_d_dev_out_next+0xc4>
		if (is_ctrl) {
    d3a0:	9b01      	ldr	r3, [sp, #4]
    d3a2:	2b01      	cmp	r3, #1
	bank->STATUS_BK.reg     = 0;
    d3a4:	bf04      	itt	eq
    d3a6:	4b39      	ldreq	r3, [pc, #228]	; (d48c <_usb_d_dev_out_next+0x194>)
    d3a8:	195b      	addeq	r3, r3, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d3aa:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d3ae:	bf0a      	itet	eq
    d3b0:	f883 724a 	strbeq.w	r7, [r3, #586]	; 0x24a
			inten = USB_D_BANK0_INT_FLAGS;
    d3b4:	2325      	movne	r3, #37	; 0x25
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    d3b6:	232d      	moveq	r3, #45	; 0x2d
    d3b8:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d3bc:	0176      	lsls	r6, r6, #5
    d3be:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
    d3c2:	2340      	movs	r3, #64	; 0x40
    d3c4:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
}
    d3c8:	b003      	add	sp, #12
    d3ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d3ce:	468a      	mov	sl, r1
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d3d0:	4689      	mov	r9, r1
    d3d2:	e7a3      	b.n	d31c <_usb_d_dev_out_next+0x24>
	} else if (isr && last_pkt < ept->size) {
    d3d4:	68a1      	ldr	r1, [r4, #8]
    d3d6:	b1ef      	cbz	r7, d414 <_usb_d_dev_out_next+0x11c>
    d3d8:	8a22      	ldrh	r2, [r4, #16]
    d3da:	455a      	cmp	r2, fp
    d3dc:	d91a      	bls.n	d414 <_usb_d_dev_out_next+0x11c>
		ept->flags.bits.need_zlp = 0;
    d3de:	7ce3      	ldrb	r3, [r4, #19]
		ept->trans_count += last_trans;
    d3e0:	4449      	add	r1, r9
		ept->flags.bits.need_zlp = 0;
    d3e2:	f36f 1304 	bfc	r3, #4, #1
    d3e6:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    d3e8:	60a1      	str	r1, [r4, #8]
	if (is_ctrl) {
    d3ea:	9b01      	ldr	r3, [sp, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d3ec:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d3f0:	2b01      	cmp	r3, #1
    d3f2:	bf0c      	ite	eq
    d3f4:	232d      	moveq	r3, #45	; 0x2d
    d3f6:	2325      	movne	r3, #37	; 0x25
    d3f8:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
	if (0 == epn) {
    d3fc:	b91e      	cbnz	r6, d406 <_usb_d_dev_out_next+0x10e>
	bank->ADDR.reg          = addr;
    d3fe:	4b23      	ldr	r3, [pc, #140]	; (d48c <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d400:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    d402:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d406:	4b22      	ldr	r3, [pc, #136]	; (d490 <_usb_d_dev_out_next+0x198>)
    d408:	2100      	movs	r1, #0
    d40a:	4620      	mov	r0, r4
}
    d40c:	b003      	add	sp, #12
    d40e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d412:	4718      	bx	r3
		ept->trans_count += trans_size;
    d414:	4451      	add	r1, sl
		if (ept->trans_count < ept->trans_size) {
    d416:	428b      	cmp	r3, r1
		ept->trans_count += trans_size;
    d418:	60a1      	str	r1, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    d41a:	d9e6      	bls.n	d3ea <_usb_d_dev_out_next+0xf2>
			if (ept->flags.bits.use_cache) {
    d41c:	7ce0      	ldrb	r0, [r4, #19]
    d41e:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    d422:	4a1a      	ldr	r2, [pc, #104]	; (d48c <_usb_d_dev_out_next+0x194>)
			trans_next = ept->trans_size - ept->trans_count;
    d424:	1a5b      	subs	r3, r3, r1
			if (ept->flags.bits.use_cache) {
    d426:	f010 0f20 	tst.w	r0, #32
			trans_next = ept->trans_size - ept->trans_count;
    d42a:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    d42c:	d014      	beq.n	d458 <_usb_d_dev_out_next+0x160>
	bank->ADDR.reg          = addr;
    d42e:	1951      	adds	r1, r2, r5
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d430:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    d432:	f8c1 0230 	str.w	r0, [r1, #560]	; 0x230
    d436:	4563      	cmp	r3, ip
    d438:	bf28      	it	cs
    d43a:	4663      	movcs	r3, ip
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d43c:	442a      	add	r2, r5
    d43e:	f8d2 1234 	ldr.w	r1, [r2, #564]	; 0x234
    d442:	f363 319b 	bfi	r1, r3, #14, #14
    d446:	f8c2 1234 	str.w	r1, [r2, #564]	; 0x234
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d44a:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
    d44e:	f36f 030d 	bfc	r3, #0, #14
    d452:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
			goto _out_rx_exec;
    d456:	e7a2      	b.n	d39e <_usb_d_dev_out_next+0xa6>
				if (trans_next > ept->size) {
    d458:	4563      	cmp	r3, ip
    d45a:	d90a      	bls.n	d472 <_usb_d_dev_out_next+0x17a>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    d45c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    d460:	d80c      	bhi.n	d47c <_usb_d_dev_out_next+0x184>
						trans_next -= trans_next & size_mask;
    d462:	ea23 0308 	bic.w	r3, r3, r8
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    d466:	6820      	ldr	r0, [r4, #0]
    d468:	4401      	add	r1, r0
	bank->ADDR.reg          = addr;
    d46a:	1950      	adds	r0, r2, r5
    d46c:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
}
    d470:	e7e4      	b.n	d43c <_usb_d_dev_out_next+0x144>
				} else if (trans_next < ept->size) {
    d472:	d2f8      	bcs.n	d466 <_usb_d_dev_out_next+0x16e>
					ept->flags.bits.use_cache = 1;
    d474:	f040 0020 	orr.w	r0, r0, #32
    d478:	74e0      	strb	r0, [r4, #19]
    d47a:	e7f4      	b.n	d466 <_usb_d_dev_out_next+0x16e>
						trans_next = USB_D_DEV_TRANS_MAX;
    d47c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    d480:	e7f1      	b.n	d466 <_usb_d_dev_out_next+0x16e>
    d482:	bf00      	nop
    d484:	200087d8 	.word	0x200087d8
    d488:	000147a9 	.word	0x000147a9
    d48c:	200085a8 	.word	0x200085a8
    d490:	0000cfe9 	.word	0x0000cfe9

0000d494 <_usb_d_dev_handler>:
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    d494:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
{
    d498:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    d49c:	8c1f      	ldrh	r7, [r3, #32]
    d49e:	4d69      	ldr	r5, [pc, #420]	; (d644 <_usb_d_dev_handler+0x1b0>)
    d4a0:	b2bf      	uxth	r7, r7
	if (0 == epint) {
    d4a2:	2f00      	cmp	r7, #0
    d4a4:	d163      	bne.n	d56e <_usb_d_dev_handler+0xda>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    d4a6:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    d4a8:	8b1a      	ldrh	r2, [r3, #24]
    d4aa:	b292      	uxth	r2, r2
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    d4ac:	400a      	ands	r2, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    d4ae:	f012 0004 	ands.w	r0, r2, #4
    d4b2:	d005      	beq.n	d4c0 <_usb_d_dev_handler+0x2c>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d4b4:	2204      	movs	r2, #4
    d4b6:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    d4b8:	682b      	ldr	r3, [r5, #0]
}
    d4ba:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.sof();
    d4be:	4718      	bx	r3
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    d4c0:	f412 7100 	ands.w	r1, r2, #512	; 0x200
    d4c4:	d01f      	beq.n	d506 <_usb_d_dev_handler+0x72>
    d4c6:	f240 2201 	movw	r2, #513	; 0x201
    d4ca:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d4cc:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d4ce:	2270      	movs	r2, #112	; 0x70
    d4d0:	831a      	strh	r2, [r3, #24]
    d4d2:	4603      	mov	r3, r0
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    d4d4:	eb05 1243 	add.w	r2, r5, r3, lsl #5
    d4d8:	f502 700e 	add.w	r0, r2, #568	; 0x238
    d4dc:	f8b2 2238 	ldrh.w	r2, [r2, #568]	; 0x238
    d4e0:	f002 020f 	and.w	r2, r2, #15
    d4e4:	2a03      	cmp	r2, #3
    d4e6:	d109      	bne.n	d4fc <_usb_d_dev_handler+0x68>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d4e8:	8801      	ldrh	r1, [r0, #0]
			bank->EXTREG.reg = 0;
    d4ea:	2300      	movs	r3, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    d4ec:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    d4f0:	8003      	strh	r3, [r0, #0]
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    d4f2:	686b      	ldr	r3, [r5, #4]
    d4f4:	2003      	movs	r0, #3
}
    d4f6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d4fa:	4718      	bx	r3
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    d4fc:	3301      	adds	r3, #1
    d4fe:	2b05      	cmp	r3, #5
    d500:	d1e8      	bne.n	d4d4 <_usb_d_dev_handler+0x40>
	uint32_t lpm_variable = 0;
    d502:	2100      	movs	r1, #0
    d504:	e7f5      	b.n	d4f2 <_usb_d_dev_handler+0x5e>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    d506:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    d50a:	d004      	beq.n	d516 <_usb_d_dev_handler+0x82>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d50c:	2280      	movs	r2, #128	; 0x80
    d50e:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    d510:	2005      	movs	r0, #5
    d512:	686b      	ldr	r3, [r5, #4]
    d514:	e7ef      	b.n	d4f6 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    d516:	f012 0470 	ands.w	r4, r2, #112	; 0x70
    d51a:	d00b      	beq.n	d534 <_usb_d_dev_handler+0xa0>
    d51c:	2270      	movs	r2, #112	; 0x70
    d51e:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d520:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d522:	f240 2201 	movw	r2, #513	; 0x201
    d526:	831a      	strh	r2, [r3, #24]
		_usb_d_dev_wait_dfll_rdy();
    d528:	4b47      	ldr	r3, [pc, #284]	; (d648 <_usb_d_dev_handler+0x1b4>)
    d52a:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    d52c:	686b      	ldr	r3, [r5, #4]
    d52e:	4601      	mov	r1, r0
    d530:	2002      	movs	r0, #2
    d532:	e7e0      	b.n	d4f6 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    d534:	f012 0108 	ands.w	r1, r2, #8
    d538:	d00e      	beq.n	d558 <_usb_d_dev_handler+0xc4>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d53a:	2208      	movs	r2, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d53c:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d540:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d542:	2270      	movs	r2, #112	; 0x70
    d544:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d546:	f240 2201 	movw	r2, #513	; 0x201
    d54a:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    d54c:	4b3f      	ldr	r3, [pc, #252]	; (d64c <_usb_d_dev_handler+0x1b8>)
    d54e:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    d550:	686b      	ldr	r3, [r5, #4]
    d552:	4621      	mov	r1, r4
    d554:	2001      	movs	r0, #1
    d556:	e7ce      	b.n	d4f6 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    d558:	07d0      	lsls	r0, r2, #31
    d55a:	d508      	bpl.n	d56e <_usb_d_dev_handler+0xda>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    d55c:	f240 2201 	movw	r2, #513	; 0x201
    d560:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    d562:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d564:	2270      	movs	r2, #112	; 0x70
    d566:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    d568:	2004      	movs	r0, #4
    d56a:	686b      	ldr	r3, [r5, #4]
    d56c:	e7c3      	b.n	d4f6 <_usb_d_dev_handler+0x62>
    d56e:	4c35      	ldr	r4, [pc, #212]	; (d644 <_usb_d_dev_handler+0x1b0>)
			_usb_d_dev_handle_setup(ept);
    d570:	f8df 90e4 	ldr.w	r9, [pc, #228]	; d658 <_usb_d_dev_handler+0x1c4>
			_usb_d_dev_handle_trfail(ept, 1);
    d574:	f8df 80e4 	ldr.w	r8, [pc, #228]	; d65c <_usb_d_dev_handler+0x1c8>
		_usb_d_dev_out_next(ept, true);
    d578:	f8df a0e4 	ldr.w	sl, [pc, #228]	; d660 <_usb_d_dev_handler+0x1cc>
	uint32_t lpm_variable = 0;
    d57c:	2600      	movs	r6, #0
		if (ept->ep == 0xFF) {
    d57e:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
    d582:	2aff      	cmp	r2, #255	; 0xff
    d584:	f104 0414 	add.w	r4, r4, #20
    d588:	d029      	beq.n	d5de <_usb_d_dev_handler+0x14a>
	if (!(epint & (1u << epn))) {
    d58a:	f002 020f 	and.w	r2, r2, #15
    d58e:	2101      	movs	r1, #1
    d590:	fa01 f302 	lsl.w	r3, r1, r2
    d594:	423b      	tst	r3, r7
    d596:	d022      	beq.n	d5de <_usb_d_dev_handler+0x14a>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d598:	0153      	lsls	r3, r2, #5
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d59a:	0152      	lsls	r2, r2, #5
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d59c:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d5a0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    d5a4:	f893 0107 	ldrb.w	r0, [r3, #263]	; 0x107
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    d5a8:	f892 3109 	ldrb.w	r3, [r2, #265]	; 0x109
	if (flags) {
    d5ac:	4003      	ands	r3, r0
    d5ae:	d016      	beq.n	d5de <_usb_d_dev_handler+0x14a>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    d5b0:	2214      	movs	r2, #20
    d5b2:	fb02 5206 	mla	r2, r2, r6, r5
    d5b6:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
    d5ba:	f002 0047 	and.w	r0, r2, #71	; 0x47
    d5be:	4288      	cmp	r0, r1
    d5c0:	d112      	bne.n	d5e8 <_usb_d_dev_handler+0x154>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d5c2:	06da      	lsls	r2, r3, #27
    d5c4:	d502      	bpl.n	d5cc <_usb_d_dev_handler+0x138>
			_usb_d_dev_handle_setup(ept);
    d5c6:	4620      	mov	r0, r4
    d5c8:	47c8      	blx	r9
    d5ca:	e008      	b.n	d5de <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d5cc:	f013 0140 	ands.w	r1, r3, #64	; 0x40
    d5d0:	d003      	beq.n	d5da <_usb_d_dev_handler+0x146>
		_usb_d_dev_handle_stall(ept, 1);
    d5d2:	4601      	mov	r1, r0
		_usb_d_dev_handle_stall(ept, 0);
    d5d4:	4b1e      	ldr	r3, [pc, #120]	; (d650 <_usb_d_dev_handler+0x1bc>)
    d5d6:	4620      	mov	r0, r4
    d5d8:	e013      	b.n	d602 <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d5da:	069b      	lsls	r3, r3, #26
    d5dc:	d4fa      	bmi.n	d5d4 <_usb_d_dev_handler+0x140>
	for (i = 0; i < USB_D_N_EP; i++) {
    d5de:	3601      	adds	r6, #1
    d5e0:	2e1b      	cmp	r6, #27
    d5e2:	d1cc      	bne.n	d57e <_usb_d_dev_handler+0xea>
}
    d5e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (_usb_d_dev_ep_is_in(ept)) {
    d5e8:	0610      	lsls	r0, r2, #24
    d5ea:	d514      	bpl.n	d616 <_usb_d_dev_handler+0x182>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    d5ec:	0658      	lsls	r0, r3, #25
    d5ee:	d4f1      	bmi.n	d5d4 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d5f0:	0718      	lsls	r0, r3, #28
    d5f2:	d502      	bpl.n	d5fa <_usb_d_dev_handler+0x166>
			_usb_d_dev_handle_trfail(ept, 1);
    d5f4:	4620      	mov	r0, r4
    d5f6:	47c0      	blx	r8
    d5f8:	e7f1      	b.n	d5de <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    d5fa:	0798      	lsls	r0, r3, #30
    d5fc:	d503      	bpl.n	d606 <_usb_d_dev_handler+0x172>
		_usb_d_dev_in_next(ept, true);
    d5fe:	4b15      	ldr	r3, [pc, #84]	; (d654 <_usb_d_dev_handler+0x1c0>)
    d600:	4620      	mov	r0, r4
		_usb_d_dev_handle_stall(ept, 0);
    d602:	4798      	blx	r3
    d604:	e7eb      	b.n	d5de <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d606:	f002 0207 	and.w	r2, r2, #7
    d60a:	2a01      	cmp	r2, #1
    d60c:	d1e7      	bne.n	d5de <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d60e:	075a      	lsls	r2, r3, #29
    d610:	d515      	bpl.n	d63e <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 0);
    d612:	2100      	movs	r1, #0
    d614:	e7ee      	b.n	d5f4 <_usb_d_dev_handler+0x160>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    d616:	f013 0020 	ands.w	r0, r3, #32
    d61a:	d001      	beq.n	d620 <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    d61c:	2100      	movs	r1, #0
    d61e:	e7d9      	b.n	d5d4 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    d620:	0758      	lsls	r0, r3, #29
    d622:	d4f6      	bmi.n	d612 <_usb_d_dev_handler+0x17e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    d624:	07d8      	lsls	r0, r3, #31
    d626:	d502      	bpl.n	d62e <_usb_d_dev_handler+0x19a>
		_usb_d_dev_out_next(ept, true);
    d628:	4620      	mov	r0, r4
    d62a:	47d0      	blx	sl
    d62c:	e7d7      	b.n	d5de <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    d62e:	f002 0207 	and.w	r2, r2, #7
    d632:	2a01      	cmp	r2, #1
    d634:	d1d3      	bne.n	d5de <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    d636:	071a      	lsls	r2, r3, #28
    d638:	d501      	bpl.n	d63e <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 1);
    d63a:	2101      	movs	r1, #1
    d63c:	e7da      	b.n	d5f4 <_usb_d_dev_handler+0x160>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    d63e:	06db      	lsls	r3, r3, #27
    d640:	d5cd      	bpl.n	d5de <_usb_d_dev_handler+0x14a>
    d642:	e7c0      	b.n	d5c6 <_usb_d_dev_handler+0x132>
    d644:	200085a8 	.word	0x200085a8
    d648:	0000cef9 	.word	0x0000cef9
    d64c:	0000d15d 	.word	0x0000d15d
    d650:	0000cfb9 	.word	0x0000cfb9
    d654:	0000d19d 	.word	0x0000d19d
    d658:	0000cf35 	.word	0x0000cf35
    d65c:	0000d075 	.word	0x0000d075
    d660:	0000d2f9 	.word	0x0000d2f9

0000d664 <_usbd_ep_pcksize_size>:
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    d664:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    d668:	d80f      	bhi.n	d68a <_usbd_ep_pcksize_size+0x26>
    d66a:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    d66e:	d80e      	bhi.n	d68e <_usbd_ep_pcksize_size+0x2a>
    d670:	2880      	cmp	r0, #128	; 0x80
    d672:	d80e      	bhi.n	d692 <_usbd_ep_pcksize_size+0x2e>
    d674:	2840      	cmp	r0, #64	; 0x40
    d676:	d80e      	bhi.n	d696 <_usbd_ep_pcksize_size+0x32>
    d678:	2820      	cmp	r0, #32
    d67a:	d80e      	bhi.n	d69a <_usbd_ep_pcksize_size+0x36>
    d67c:	2810      	cmp	r0, #16
    d67e:	d80e      	bhi.n	d69e <_usbd_ep_pcksize_size+0x3a>
    d680:	2808      	cmp	r0, #8
    d682:	bf94      	ite	ls
    d684:	2000      	movls	r0, #0
    d686:	2001      	movhi	r0, #1
    d688:	4770      	bx	lr
    d68a:	2007      	movs	r0, #7
    d68c:	4770      	bx	lr
    d68e:	2006      	movs	r0, #6
    d690:	4770      	bx	lr
    d692:	2005      	movs	r0, #5
    d694:	4770      	bx	lr
    d696:	2004      	movs	r0, #4
    d698:	4770      	bx	lr
    d69a:	2003      	movs	r0, #3
    d69c:	4770      	bx	lr
    d69e:	2002      	movs	r0, #2
}
    d6a0:	4770      	bx	lr
	...

0000d6a4 <_usb_d_dev_init>:
{
    d6a4:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    d6a6:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d6aa:	789a      	ldrb	r2, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    d6ac:	07d0      	lsls	r0, r2, #31
    d6ae:	d41a      	bmi.n	d6e6 <_usb_d_dev_init+0x42>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d6b0:	789a      	ldrb	r2, [r3, #2]
    d6b2:	0791      	lsls	r1, r2, #30
    d6b4:	d1fc      	bne.n	d6b0 <_usb_d_dev_init+0xc>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    d6b6:	781a      	ldrb	r2, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    d6b8:	0792      	lsls	r2, r2, #30
    d6ba:	d50d      	bpl.n	d6d8 <_usb_d_dev_init+0x34>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    d6bc:	781a      	ldrb	r2, [r3, #0]
    d6be:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    d6c2:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d6c4:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d6c8:	7893      	ldrb	r3, [r2, #2]
    d6ca:	0798      	lsls	r0, r3, #30
    d6cc:	d1fc      	bne.n	d6c8 <_usb_d_dev_init+0x24>
    d6ce:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d6d2:	7893      	ldrb	r3, [r2, #2]
    d6d4:	0799      	lsls	r1, r3, #30
    d6d6:	d4fc      	bmi.n	d6d2 <_usb_d_dev_init+0x2e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d6d8:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d6dc:	2201      	movs	r2, #1
    d6de:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d6e0:	789a      	ldrb	r2, [r3, #2]
    d6e2:	0792      	lsls	r2, r2, #30
    d6e4:	d1fc      	bne.n	d6e0 <_usb_d_dev_init+0x3c>
    d6e6:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d6ea:	7893      	ldrb	r3, [r2, #2]
    d6ec:	07db      	lsls	r3, r3, #31
    d6ee:	d4fc      	bmi.n	d6ea <_usb_d_dev_init+0x46>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    d6f0:	4a1e      	ldr	r2, [pc, #120]	; (d76c <_usb_d_dev_init+0xc8>)
    d6f2:	4b1f      	ldr	r3, [pc, #124]	; (d770 <_usb_d_dev_init+0xcc>)
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    d6f4:	e9c3 2200 	strd	r2, r2, [r3]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    d6f8:	e9c3 2202 	strd	r2, r2, [r3, #8]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    d6fc:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    d6fe:	4b1d      	ldr	r3, [pc, #116]	; (d774 <_usb_d_dev_init+0xd0>)
    d700:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    d702:	4b1d      	ldr	r3, [pc, #116]	; (d778 <_usb_d_dev_init+0xd4>)
    d704:	681a      	ldr	r2, [r3, #0]
	uint32_t pad_transp
    d706:	f3c2 1344 	ubfx	r3, r2, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    d70a:	f3c2 2182 	ubfx	r1, r2, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    d70e:	f012 021f 	ands.w	r2, r2, #31
    d712:	d025      	beq.n	d760 <_usb_d_dev_init+0xbc>
		pad_transn = 9;
    d714:	2a1f      	cmp	r2, #31
    d716:	bf08      	it	eq
    d718:	2209      	moveq	r2, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    d71a:	b31b      	cbz	r3, d764 <_usb_d_dev_init+0xc0>
		pad_transp = 25;
    d71c:	2b1f      	cmp	r3, #31
    d71e:	bf08      	it	eq
    d720:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    d722:	b309      	cbz	r1, d768 <_usb_d_dev_init+0xc4>
		pad_trim = 6;
    d724:	2907      	cmp	r1, #7
    d726:	bf08      	it	eq
    d728:	2106      	moveq	r1, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    d72a:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    d72e:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    d732:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d736:	b29b      	uxth	r3, r3
    d738:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    d73a:	78d3      	ldrb	r3, [r2, #3]
    d73c:	f043 0303 	orr.w	r3, r3, #3
    d740:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    d742:	78d3      	ldrb	r3, [r2, #3]
    d744:	f043 030c 	orr.w	r3, r3, #12
    d748:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d74a:	2304      	movs	r3, #4
    d74c:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d74e:	7890      	ldrb	r0, [r2, #2]
    d750:	f010 0003 	ands.w	r0, r0, #3
    d754:	d1fb      	bne.n	d74e <_usb_d_dev_init+0xaa>
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    d756:	4b09      	ldr	r3, [pc, #36]	; (d77c <_usb_d_dev_init+0xd8>)
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    d758:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    d75a:	2301      	movs	r3, #1
    d75c:	8113      	strh	r3, [r2, #8]
}
    d75e:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    d760:	2209      	movs	r2, #9
    d762:	e7da      	b.n	d71a <_usb_d_dev_init+0x76>
		pad_transp = 25;
    d764:	2319      	movs	r3, #25
    d766:	e7dc      	b.n	d722 <_usb_d_dev_init+0x7e>
		pad_trim = 6;
    d768:	2106      	movs	r1, #6
    d76a:	e7de      	b.n	d72a <_usb_d_dev_init+0x86>
    d76c:	0000cef5 	.word	0x0000cef5
    d770:	200085a8 	.word	0x200085a8
    d774:	0000d15d 	.word	0x0000d15d
    d778:	00800084 	.word	0x00800084
    d77c:	200087d8 	.word	0x200087d8

0000d780 <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    d780:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d784:	789a      	ldrb	r2, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    d786:	0792      	lsls	r2, r2, #30
    d788:	d122      	bne.n	d7d0 <_usb_d_dev_enable+0x50>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d78a:	789a      	ldrb	r2, [r3, #2]
    d78c:	0790      	lsls	r0, r2, #30
    d78e:	d1fc      	bne.n	d78a <_usb_d_dev_enable+0xa>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    d790:	7819      	ldrb	r1, [r3, #0]
    d792:	b2ca      	uxtb	r2, r1
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    d794:	0789      	lsls	r1, r1, #30
    d796:	d407      	bmi.n	d7a8 <_usb_d_dev_enable+0x28>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    d798:	f042 0202 	orr.w	r2, r2, #2
	((Usb *)hw)->HOST.CTRLA.reg = data;
    d79c:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    d79e:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d7a2:	7893      	ldrb	r3, [r2, #2]
    d7a4:	079b      	lsls	r3, r3, #30
    d7a6:	d1fc      	bne.n	d7a2 <_usb_d_dev_enable+0x22>
    d7a8:	4b0b      	ldr	r3, [pc, #44]	; (d7d8 <_usb_d_dev_enable+0x58>)
    d7aa:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    d7ae:	609a      	str	r2, [r3, #8]
    d7b0:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    d7b4:	609a      	str	r2, [r3, #8]
    d7b6:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    d7ba:	609a      	str	r2, [r3, #8]
    d7bc:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    d7c0:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    d7c2:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d7c6:	f240 228d 	movw	r2, #653	; 0x28d
    d7ca:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    d7cc:	2000      	movs	r0, #0
    d7ce:	4770      	bx	lr
		return -USB_ERR_DENIED;
    d7d0:	f06f 0010 	mvn.w	r0, #16
}
    d7d4:	4770      	bx	lr
    d7d6:	bf00      	nop
    d7d8:	e000e100 	.word	0xe000e100

0000d7dc <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    d7dc:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    d7e0:	8913      	ldrh	r3, [r2, #8]
    d7e2:	f023 0301 	bic.w	r3, r3, #1
    d7e6:	041b      	lsls	r3, r3, #16
    d7e8:	0c1b      	lsrs	r3, r3, #16
    d7ea:	8113      	strh	r3, [r2, #8]
}
    d7ec:	4770      	bx	lr

0000d7ee <_usb_d_dev_set_address>:
	((Usb *)hw)->DEVICE.DADD.reg = data;
    d7ee:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    d7f2:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    d7f6:	7298      	strb	r0, [r3, #10]
}
    d7f8:	4770      	bx	lr

0000d7fa <_usb_d_dev_get_frame_n>:
	return (((Usb *)hw)->DEVICE.FNUM.reg & USB_DEVICE_FNUM_FNUM_Msk) >> USB_DEVICE_FNUM_FNUM_Pos;
    d7fa:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    d7fe:	8a18      	ldrh	r0, [r3, #16]
}
    d800:	f3c0 00ca 	ubfx	r0, r0, #3, #11
    d804:	4770      	bx	lr
	...

0000d808 <_usb_d_dev_ep_init>:
{
    d808:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d80c:	f000 040f 	and.w	r4, r0, #15
{
    d810:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d812:	f8df 90b0 	ldr.w	r9, [pc, #176]	; d8c4 <_usb_d_dev_ep_init+0xbc>
    d816:	09c1      	lsrs	r1, r0, #7
{
    d818:	4607      	mov	r7, r0
    d81a:	fa4f f880 	sxtb.w	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d81e:	4620      	mov	r0, r4
    d820:	47c8      	blx	r9
	if (epn > CONF_USB_D_MAX_EP_N) {
    d822:	2c05      	cmp	r4, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d824:	4606      	mov	r6, r0
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    d826:	f005 0503 	and.w	r5, r5, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
    d82a:	d83f      	bhi.n	d8ac <_usb_d_dev_ep_init+0xa4>
	if (ept->ep != 0xFF) {
    d82c:	7c83      	ldrb	r3, [r0, #18]
    d82e:	2bff      	cmp	r3, #255	; 0xff
    d830:	d13f      	bne.n	d8b2 <_usb_d_dev_ep_init+0xaa>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    d832:	b985      	cbnz	r5, d856 <_usb_d_dev_ep_init+0x4e>
		struct _usb_d_dev_ep *ept_in = _usb_d_dev_ept(epn, !dir);
    d834:	ea6f 0108 	mvn.w	r1, r8
    d838:	0fc9      	lsrs	r1, r1, #31
    d83a:	4620      	mov	r0, r4
    d83c:	47c8      	blx	r9
		if (ept_in->ep != 0xFF) {
    d83e:	7c83      	ldrb	r3, [r0, #18]
    d840:	2bff      	cmp	r3, #255	; 0xff
    d842:	d136      	bne.n	d8b2 <_usb_d_dev_ep_init+0xaa>
		if (pcfg->cache == NULL) {
    d844:	230c      	movs	r3, #12
    d846:	491e      	ldr	r1, [pc, #120]	; (d8c0 <_usb_d_dev_ep_init+0xb8>)
    d848:	4363      	muls	r3, r4
    d84a:	58cb      	ldr	r3, [r1, r3]
    d84c:	2b00      	cmp	r3, #0
    d84e:	d133      	bne.n	d8b8 <_usb_d_dev_ep_init+0xb0>
			return -USB_ERR_FUNC;
    d850:	f06f 0012 	mvn.w	r0, #18
    d854:	e018      	b.n	d888 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d856:	f1b8 0f00 	cmp.w	r8, #0
    d85a:	da17      	bge.n	d88c <_usb_d_dev_ep_init+0x84>
    d85c:	4918      	ldr	r1, [pc, #96]	; (d8c0 <_usb_d_dev_ep_init+0xb8>)
    d85e:	230c      	movs	r3, #12
    d860:	fb03 1304 	mla	r3, r3, r4, r1
    d864:	6859      	ldr	r1, [r3, #4]
    d866:	b9e9      	cbnz	r1, d8a4 <_usb_d_dev_ep_init+0x9c>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d868:	4915      	ldr	r1, [pc, #84]	; (d8c0 <_usb_d_dev_ep_init+0xb8>)
	ept->size     = max_pkt_siz;
    d86a:	8232      	strh	r2, [r6, #16]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d86c:	230c      	movs	r3, #12
    d86e:	435c      	muls	r4, r3
    d870:	190b      	adds	r3, r1, r4
    d872:	5909      	ldr	r1, [r1, r4]
    d874:	685b      	ldr	r3, [r3, #4]
	ept->ep       = ep;
    d876:	74b7      	strb	r7, [r6, #18]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d878:	ea13 0328 	ands.w	r3, r3, r8, asr #32
    d87c:	bf38      	it	cc
    d87e:	460b      	movcc	r3, r1
	ept->flags.u8 = (ep_type + 1);
    d880:	3501      	adds	r5, #1
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    d882:	60f3      	str	r3, [r6, #12]
	ept->flags.u8 = (ep_type + 1);
    d884:	74f5      	strb	r5, [r6, #19]
	return USB_OK;
    d886:	2000      	movs	r0, #0
}
    d888:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d88c:	230c      	movs	r3, #12
    d88e:	490c      	ldr	r1, [pc, #48]	; (d8c0 <_usb_d_dev_ep_init+0xb8>)
    d890:	4363      	muls	r3, r4
    d892:	58cb      	ldr	r3, [r1, r3]
    d894:	2b00      	cmp	r3, #0
    d896:	d0e7      	beq.n	d868 <_usb_d_dev_ep_init+0x60>
    d898:	4909      	ldr	r1, [pc, #36]	; (d8c0 <_usb_d_dev_ep_init+0xb8>)
    d89a:	230c      	movs	r3, #12
    d89c:	fb03 1304 	mla	r3, r3, r4, r1
    d8a0:	891b      	ldrh	r3, [r3, #8]
    d8a2:	e000      	b.n	d8a6 <_usb_d_dev_ep_init+0x9e>
    d8a4:	895b      	ldrh	r3, [r3, #10]
    d8a6:	429a      	cmp	r2, r3
    d8a8:	ddde      	ble.n	d868 <_usb_d_dev_ep_init+0x60>
    d8aa:	e7d1      	b.n	d850 <_usb_d_dev_ep_init+0x48>
		return -USB_ERR_PARAM;
    d8ac:	f06f 0011 	mvn.w	r0, #17
    d8b0:	e7ea      	b.n	d888 <_usb_d_dev_ep_init+0x80>
		return -USB_ERR_REDO;
    d8b2:	f06f 0013 	mvn.w	r0, #19
    d8b6:	e7e7      	b.n	d888 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    d8b8:	f1b8 0f00 	cmp.w	r8, #0
    d8bc:	daec      	bge.n	d898 <_usb_d_dev_ep_init+0x90>
    d8be:	e7cd      	b.n	d85c <_usb_d_dev_ep_init+0x54>
    d8c0:	00016810 	.word	0x00016810
    d8c4:	0000cf1d 	.word	0x0000cf1d

0000d8c8 <_usb_d_dev_ep_deinit>:
{
    d8c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    d8ca:	f000 050f 	and.w	r5, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d8ce:	2d05      	cmp	r5, #5
{
    d8d0:	4604      	mov	r4, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d8d2:	d818      	bhi.n	d906 <_usb_d_dev_ep_deinit+0x3e>
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d8d4:	4b17      	ldr	r3, [pc, #92]	; (d934 <_usb_d_dev_ep_deinit+0x6c>)
	bool                  dir = USB_EP_GET_DIR(ep);
    d8d6:	09c1      	lsrs	r1, r0, #7
    d8d8:	b247      	sxtb	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d8da:	4628      	mov	r0, r5
    d8dc:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d8de:	7c83      	ldrb	r3, [r0, #18]
    d8e0:	2bff      	cmp	r3, #255	; 0xff
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    d8e2:	4606      	mov	r6, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d8e4:	d00f      	beq.n	d906 <_usb_d_dev_ep_deinit+0x3e>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    d8e6:	4b14      	ldr	r3, [pc, #80]	; (d938 <_usb_d_dev_ep_deinit+0x70>)
    d8e8:	2203      	movs	r2, #3
    d8ea:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    d8ec:	7cf3      	ldrb	r3, [r6, #19]
    d8ee:	f003 0307 	and.w	r3, r3, #7
    d8f2:	2b01      	cmp	r3, #1
    d8f4:	d108      	bne.n	d908 <_usb_d_dev_ep_deinit+0x40>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    d8f6:	0164      	lsls	r4, r4, #5
    d8f8:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d8fc:	2300      	movs	r3, #0
    d8fe:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	ept->ep       = 0xFF;
    d902:	23ff      	movs	r3, #255	; 0xff
    d904:	8273      	strh	r3, [r6, #18]
}
    d906:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (USB_EP_GET_DIR(ep)) {
    d908:	2f00      	cmp	r7, #0
    d90a:	da09      	bge.n	d920 <_usb_d_dev_ep_deinit+0x58>
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    d90c:	016b      	lsls	r3, r5, #5
    d90e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d912:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    d916:	f002 028f 	and.w	r2, r2, #143	; 0x8f
    d91a:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    d91e:	e7f0      	b.n	d902 <_usb_d_dev_ep_deinit+0x3a>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    d920:	0164      	lsls	r4, r4, #5
    d922:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    d926:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
    d92a:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    d92e:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
    d932:	e7e6      	b.n	d902 <_usb_d_dev_ep_deinit+0x3a>
    d934:	0000cf1d 	.word	0x0000cf1d
    d938:	0000d015 	.word	0x0000d015

0000d93c <_usb_d_dev_ep_enable>:
{
    d93c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    d940:	f000 050f 	and.w	r5, r0, #15
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d944:	09c1      	lsrs	r1, r0, #7
    d946:	4b55      	ldr	r3, [pc, #340]	; (da9c <_usb_d_dev_ep_enable+0x160>)
    d948:	fa4f f980 	sxtb.w	r9, r0
    d94c:	4628      	mov	r0, r5
    d94e:	4798      	blx	r3
    d950:	ea4f 1c45 	mov.w	ip, r5, lsl #5
    d954:	f10c 4682 	add.w	r6, ip, #1090519040	; 0x41000000
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d958:	2d05      	cmp	r5, #5
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d95a:	f896 1100 	ldrb.w	r1, [r6, #256]	; 0x100
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    d95e:	4607      	mov	r7, r0
    d960:	b2c8      	uxtb	r0, r1
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    d962:	f200 8094 	bhi.w	da8e <_usb_d_dev_ep_enable+0x152>
    d966:	7cba      	ldrb	r2, [r7, #18]
    d968:	2aff      	cmp	r2, #255	; 0xff
    d96a:	f000 8090 	beq.w	da8e <_usb_d_dev_ep_enable+0x152>
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d96e:	7cf9      	ldrb	r1, [r7, #19]
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d970:	4c4b      	ldr	r4, [pc, #300]	; (daa0 <_usb_d_dev_ep_enable+0x164>)
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d972:	f001 0307 	and.w	r3, r1, #7
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d976:	f504 780c 	add.w	r8, r4, #560	; 0x230
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d97a:	2b01      	cmp	r3, #1
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    d97c:	44e0      	add	r8, ip
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    d97e:	d147      	bne.n	da10 <_usb_d_dev_ep_enable+0xd4>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    d980:	f010 0377 	ands.w	r3, r0, #119	; 0x77
    d984:	f040 8086 	bne.w	da94 <_usb_d_dev_ep_enable+0x158>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d988:	f8b7 9010 	ldrh.w	r9, [r7, #16]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    d98c:	2111      	movs	r1, #17
    d98e:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d992:	4648      	mov	r0, r9
    d994:	4943      	ldr	r1, [pc, #268]	; (daa4 <_usb_d_dev_ep_enable+0x168>)
    d996:	4788      	blx	r1
    d998:	0700      	lsls	r0, r0, #28
    d99a:	f000 41e0 	and.w	r1, r0, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d99e:	4842      	ldr	r0, [pc, #264]	; (daa8 <_usb_d_dev_ep_enable+0x16c>)
    d9a0:	ea00 3089 	and.w	r0, r0, r9, lsl #14
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d9a4:	f3c9 090d 	ubfx	r9, r9, #0, #14
	bank->STATUS_BK.reg     = 0;
    d9a8:	eb04 1545 	add.w	r5, r4, r5, lsl #5
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d9ac:	4308      	orrs	r0, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d9ae:	f002 020f 	and.w	r2, r2, #15
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d9b2:	ea49 0101 	orr.w	r1, r9, r1
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    d9b6:	f8c8 0004 	str.w	r0, [r8, #4]
	bank->ADDR.reg          = addr;
    d9ba:	eb04 1442 	add.w	r4, r4, r2, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    d9be:	f8c8 1014 	str.w	r1, [r8, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d9c2:	f04f 0c40 	mov.w	ip, #64	; 0x40
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d9c6:	2180      	movs	r1, #128	; 0x80
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d9c8:	f886 c105 	strb.w	ip, [r6, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d9cc:	f886 1104 	strb.w	r1, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    d9d0:	f885 323a 	strb.w	r3, [r5, #570]	; 0x23a
    d9d4:	f885 324a 	strb.w	r3, [r5, #586]	; 0x24a
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d9d8:	68fd      	ldr	r5, [r7, #12]
	bank->ADDR.reg          = addr;
    d9da:	f8c4 5230 	str.w	r5, [r4, #560]	; 0x230
    d9de:	f504 710c 	add.w	r1, r4, #560	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d9e2:	f8d4 4234 	ldr.w	r4, [r4, #564]	; 0x234
    d9e6:	f369 349b 	bfi	r4, r9, #14, #14
    d9ea:	604c      	str	r4, [r1, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d9ec:	684c      	ldr	r4, [r1, #4]
	bank->ADDR.reg          = addr;
    d9ee:	0150      	lsls	r0, r2, #5
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d9f0:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    d9f4:	f363 040d 	bfi	r4, r3, #0, #14
    d9f8:	604c      	str	r4, [r1, #4]
    d9fa:	21b0      	movs	r1, #176	; 0xb0
    d9fc:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    da00:	2110      	movs	r1, #16
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    da02:	f882 c105 	strb.w	ip, [r2, #261]	; 0x105
	return USB_OK;
    da06:	4618      	mov	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    da08:	f882 1109 	strb.w	r1, [r2, #265]	; 0x109
}
    da0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (dir) {
    da10:	f1b9 0f00 	cmp.w	r9, #0
    da14:	da1e      	bge.n	da54 <_usb_d_dev_ep_enable+0x118>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    da16:	f010 0270 	ands.w	r2, r0, #112	; 0x70
    da1a:	d13b      	bne.n	da94 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    da1c:	f3c1 0102 	ubfx	r1, r1, #0, #3
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    da20:	8a3b      	ldrh	r3, [r7, #16]
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    da22:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
    da26:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    da28:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    da2c:	4618      	mov	r0, r3
    da2e:	491d      	ldr	r1, [pc, #116]	; (daa4 <_usb_d_dev_ep_enable+0x168>)
    da30:	4788      	blx	r1
    da32:	0700      	lsls	r0, r0, #28
    da34:	f3c3 030d 	ubfx	r3, r3, #0, #14
    da38:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
	bank->STATUS_BK.reg     = 0;
    da3c:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    da40:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    da42:	2380      	movs	r3, #128	; 0x80
    da44:	f8c8 0014 	str.w	r0, [r8, #20]
    da48:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    da4c:	f884 224a 	strb.w	r2, [r4, #586]	; 0x24a
	return USB_OK;
    da50:	4610      	mov	r0, r2
}
    da52:	e7db      	b.n	da0c <_usb_d_dev_ep_enable+0xd0>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    da54:	f010 0207 	ands.w	r2, r0, #7
    da58:	d11c      	bne.n	da94 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    da5a:	f001 0107 	and.w	r1, r1, #7
    da5e:	4301      	orrs	r1, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    da60:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    da64:	8a39      	ldrh	r1, [r7, #16]
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    da66:	4b0f      	ldr	r3, [pc, #60]	; (daa4 <_usb_d_dev_ep_enable+0x168>)
    da68:	4608      	mov	r0, r1
    da6a:	4798      	blx	r3
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    da6c:	4b0e      	ldr	r3, [pc, #56]	; (daa8 <_usb_d_dev_ep_enable+0x16c>)
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    da6e:	0700      	lsls	r0, r0, #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    da70:	ea03 3381 	and.w	r3, r3, r1, lsl #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    da74:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    da78:	4303      	orrs	r3, r0
	bank->STATUS_BK.reg     = 0;
    da7a:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    da7e:	f8c8 3004 	str.w	r3, [r8, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    da82:	2340      	movs	r3, #64	; 0x40
    da84:	f886 3105 	strb.w	r3, [r6, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    da88:	f884 223a 	strb.w	r2, [r4, #570]	; 0x23a
    da8c:	e7e0      	b.n	da50 <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    da8e:	f06f 0011 	mvn.w	r0, #17
    da92:	e7bb      	b.n	da0c <_usb_d_dev_ep_enable+0xd0>
			return -USB_ERR_REDO;
    da94:	f06f 0013 	mvn.w	r0, #19
    da98:	e7b8      	b.n	da0c <_usb_d_dev_ep_enable+0xd0>
    da9a:	bf00      	nop
    da9c:	0000cf1d 	.word	0x0000cf1d
    daa0:	200085a8 	.word	0x200085a8
    daa4:	0000d665 	.word	0x0000d665
    daa8:	0fffc000 	.word	0x0fffc000

0000daac <_usb_d_dev_ep_stall>:
{
    daac:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    daae:	f000 020f 	and.w	r2, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    dab2:	09c4      	lsrs	r4, r0, #7
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dab4:	4b2f      	ldr	r3, [pc, #188]	; (db74 <_usb_d_dev_ep_stall+0xc8>)
{
    dab6:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dab8:	4610      	mov	r0, r2
    daba:	4621      	mov	r1, r4
    dabc:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    dabe:	2a05      	cmp	r2, #5
    dac0:	d855      	bhi.n	db6e <_usb_d_dev_ep_stall+0xc2>
	if (USB_EP_STALL_SET == ctrl) {
    dac2:	7c83      	ldrb	r3, [r0, #18]
    dac4:	2210      	movs	r2, #16
    dac6:	2d01      	cmp	r5, #1
    dac8:	f003 030f 	and.w	r3, r3, #15
    dacc:	fa02 f204 	lsl.w	r2, r2, r4
    dad0:	d113      	bne.n	dafa <_usb_d_dev_ep_stall+0x4e>
    dad2:	0159      	lsls	r1, r3, #5
    dad4:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    dad8:	b2d2      	uxtb	r2, r2
    dada:	f881 2105 	strb.w	r2, [r1, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    dade:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    dae0:	2120      	movs	r1, #32
    dae2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    dae6:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    dae8:	b2c9      	uxtb	r1, r1
    daea:	f883 1109 	strb.w	r1, [r3, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    daee:	7cc3      	ldrb	r3, [r0, #19]
    daf0:	f043 0308 	orr.w	r3, r3, #8
    daf4:	74c3      	strb	r3, [r0, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    daf6:	2000      	movs	r0, #0
}
    daf8:	bd38      	pop	{r3, r4, r5, pc}
	} else if (USB_EP_STALL_CLR == ctrl) {
    dafa:	bb6d      	cbnz	r5, db58 <_usb_d_dev_ep_stall+0xac>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    dafc:	015d      	lsls	r5, r3, #5
    dafe:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    db02:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
	if (!is_stalled) {
    db06:	4211      	tst	r1, r2
    db08:	d0f5      	beq.n	daf6 <_usb_d_dev_ep_stall+0x4a>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    db0a:	b2d2      	uxtb	r2, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    db0c:	f885 2104 	strb.w	r2, [r5, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    db10:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    db12:	2220      	movs	r2, #32
    db14:	40a2      	lsls	r2, r4
    db16:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    db1a:	b2d1      	uxtb	r1, r2
    db1c:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    db20:	f895 3107 	ldrb.w	r3, [r5, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    db24:	4213      	tst	r3, r2
    db26:	d006      	beq.n	db36 <_usb_d_dev_ep_stall+0x8a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    db28:	f885 1107 	strb.w	r1, [r5, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    db2c:	2101      	movs	r1, #1
    db2e:	40a1      	lsls	r1, r4
    db30:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    db32:	f885 1104 	strb.w	r1, [r5, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    db36:	7cc2      	ldrb	r2, [r0, #19]
    db38:	f002 0307 	and.w	r3, r2, #7
    db3c:	2b01      	cmp	r3, #1
    db3e:	d108      	bne.n	db52 <_usb_d_dev_ep_stall+0xa6>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    db40:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    db44:	f013 0330 	ands.w	r3, r3, #48	; 0x30
    db48:	d1d5      	bne.n	daf6 <_usb_d_dev_ep_stall+0x4a>
			ept->flags.bits.is_stalled = 0;
    db4a:	f363 02c3 	bfi	r2, r3, #3, #1
		ept->flags.bits.is_stalled = 0;
    db4e:	74c2      	strb	r2, [r0, #19]
    db50:	e7d1      	b.n	daf6 <_usb_d_dev_ep_stall+0x4a>
    db52:	f36f 02c3 	bfc	r2, #3, #1
    db56:	e7fa      	b.n	db4e <_usb_d_dev_ep_stall+0xa2>
    db58:	015b      	lsls	r3, r3, #5
    db5a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    db5e:	f503 7380 	add.w	r3, r3, #256	; 0x100
    db62:	799b      	ldrb	r3, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    db64:	4213      	tst	r3, r2
    db66:	bf14      	ite	ne
    db68:	2001      	movne	r0, #1
    db6a:	2000      	moveq	r0, #0
    db6c:	e7c4      	b.n	daf8 <_usb_d_dev_ep_stall+0x4c>
		return -USB_ERR_PARAM;
    db6e:	f06f 0011 	mvn.w	r0, #17
    db72:	e7c1      	b.n	daf8 <_usb_d_dev_ep_stall+0x4c>
    db74:	0000cf1d 	.word	0x0000cf1d

0000db78 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    db78:	b570      	push	{r4, r5, r6, lr}
	uint8_t            epn   = USB_EP_GET_N(ep);
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    db7a:	4b13      	ldr	r3, [pc, #76]	; (dbc8 <_usb_d_dev_ep_read_req+0x50>)
	uint8_t            epn   = USB_EP_GET_N(ep);
    db7c:	f000 060f 	and.w	r6, r0, #15
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    db80:	0172      	lsls	r2, r6, #5
    db82:	eb03 1046 	add.w	r0, r3, r6, lsl #5
	uint32_t           addr  = bank[0].ADDR.reg;
    db86:	589d      	ldr	r5, [r3, r2]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    db88:	6844      	ldr	r4, [r0, #4]

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    db8a:	2e05      	cmp	r6, #5
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    db8c:	f3c4 040d 	ubfx	r4, r4, #0, #14
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    db90:	d814      	bhi.n	dbbc <_usb_d_dev_ep_read_req+0x44>
    db92:	b199      	cbz	r1, dbbc <_usb_d_dev_ep_read_req+0x44>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    db94:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    db98:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    db9c:	2b11      	cmp	r3, #17
    db9e:	d110      	bne.n	dbc2 <_usb_d_dev_ep_read_req+0x4a>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    dba0:	f892 3107 	ldrb.w	r3, [r2, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    dba4:	f013 0010 	ands.w	r0, r3, #16
    dba8:	d007      	beq.n	dbba <_usb_d_dev_ep_read_req+0x42>
		return ERR_NONE;
	}
	memcpy(req_buf, (void *)addr, 8);
    dbaa:	682b      	ldr	r3, [r5, #0]
    dbac:	600b      	str	r3, [r1, #0]
    dbae:	686b      	ldr	r3, [r5, #4]
    dbb0:	604b      	str	r3, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    dbb2:	2310      	movs	r3, #16
    dbb4:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	_usbd_ep_ack_setup(epn);

	return bytes;
    dbb8:	4620      	mov	r0, r4
}
    dbba:	bd70      	pop	{r4, r5, r6, pc}
		return -USB_ERR_PARAM;
    dbbc:	f06f 0011 	mvn.w	r0, #17
    dbc0:	e7fb      	b.n	dbba <_usb_d_dev_ep_read_req+0x42>
		return -USB_ERR_FUNC;
    dbc2:	f06f 0012 	mvn.w	r0, #18
    dbc6:	e7f8      	b.n	dbba <_usb_d_dev_ep_read_req+0x42>
    dbc8:	200087d8 	.word	0x200087d8

0000dbcc <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    dbcc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    dbd0:	f890 9008 	ldrb.w	r9, [r0, #8]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dbd4:	4b39      	ldr	r3, [pc, #228]	; (dcbc <_usb_d_dev_ep_trans+0xf0>)
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    dbd6:	f009 050f 	and.w	r5, r9, #15
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    dbda:	fa4f f789 	sxtb.w	r7, r9
    dbde:	ea4f 19d9 	mov.w	r9, r9, lsr #7
{
    dbe2:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dbe4:	4649      	mov	r1, r9
    dbe6:	4628      	mov	r0, r5
    dbe8:	4798      	blx	r3

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    dbea:	8a02      	ldrh	r2, [r0, #16]
	bool     size_n_aligned = (trans->size & size_mask);
    dbec:	f8d8 1004 	ldr.w	r1, [r8, #4]
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    dbf0:	f240 33ff 	movw	r3, #1023	; 0x3ff
    dbf4:	429a      	cmp	r2, r3
    dbf6:	bf1a      	itte	ne
    dbf8:	f102 33ff 	addne.w	r3, r2, #4294967295	; 0xffffffff
    dbfc:	b29b      	uxthne	r3, r3
    dbfe:	4613      	moveq	r3, r2

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    dc00:	2d05      	cmp	r5, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dc02:	4604      	mov	r4, r0
	bool     size_n_aligned = (trans->size & size_mask);
    dc04:	ea03 0601 	and.w	r6, r3, r1
	if (epn > CONF_USB_D_MAX_EP_N) {
    dc08:	d828      	bhi.n	dc5c <_usb_d_dev_ep_trans+0x90>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    dc0a:	f8d8 5000 	ldr.w	r5, [r8]
    dc0e:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
    dc12:	d30a      	bcc.n	dc2a <_usb_d_dev_ep_trans+0x5e>
    dc14:	4b2a      	ldr	r3, [pc, #168]	; (dcc0 <_usb_d_dev_ep_trans+0xf4>)
    dc16:	1948      	adds	r0, r1, r5
    dc18:	4298      	cmp	r0, r3
    dc1a:	d206      	bcs.n	dc2a <_usb_d_dev_ep_trans+0x5e>
    dc1c:	f015 0503 	ands.w	r5, r5, #3
    dc20:	d103      	bne.n	dc2a <_usb_d_dev_ep_trans+0x5e>
	    || (!dir && (trans->size < ept->size))) {
    dc22:	2f00      	cmp	r7, #0
    dc24:	db05      	blt.n	dc32 <_usb_d_dev_ep_trans+0x66>
    dc26:	4291      	cmp	r1, r2
    dc28:	d214      	bcs.n	dc54 <_usb_d_dev_ep_trans+0x88>
		if (!ept->cache) {
    dc2a:	68e3      	ldr	r3, [r4, #12]
    dc2c:	2b00      	cmp	r3, #0
    dc2e:	d03f      	beq.n	dcb0 <_usb_d_dev_ep_trans+0xe4>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    dc30:	2501      	movs	r5, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    dc32:	7ce3      	ldrb	r3, [r4, #19]
    dc34:	071b      	lsls	r3, r3, #28
    dc36:	d43e      	bmi.n	dcb6 <_usb_d_dev_ep_trans+0xea>
		return USB_HALTED;
	}

	/* Try to start transactions. */

	atomic_enter_critical(&flags);
    dc38:	4b22      	ldr	r3, [pc, #136]	; (dcc4 <_usb_d_dev_ep_trans+0xf8>)
    dc3a:	a801      	add	r0, sp, #4
    dc3c:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    dc3e:	7ce3      	ldrb	r3, [r4, #19]
    dc40:	4a21      	ldr	r2, [pc, #132]	; (dcc8 <_usb_d_dev_ep_trans+0xfc>)
    dc42:	f013 0a40 	ands.w	sl, r3, #64	; 0x40
    dc46:	d00e      	beq.n	dc66 <_usb_d_dev_ep_trans+0x9a>
		atomic_leave_critical(&flags);
    dc48:	a801      	add	r0, sp, #4
    dc4a:	4790      	blx	r2
		return USB_BUSY;
    dc4c:	2001      	movs	r0, #1
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    dc4e:	b002      	add	sp, #8
    dc50:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!dir && size_n_aligned) {
    dc54:	b12e      	cbz	r6, dc62 <_usb_d_dev_ep_trans+0x96>
		if (!ept->cache) {
    dc56:	68e3      	ldr	r3, [r4, #12]
    dc58:	2b00      	cmp	r3, #0
    dc5a:	d1ea      	bne.n	dc32 <_usb_d_dev_ep_trans+0x66>
		return -USB_ERR_PARAM;
    dc5c:	f06f 0011 	mvn.w	r0, #17
    dc60:	e7f5      	b.n	dc4e <_usb_d_dev_ep_trans+0x82>
	bool use_cache = false;
    dc62:	4635      	mov	r5, r6
    dc64:	e7e5      	b.n	dc32 <_usb_d_dev_ep_trans+0x66>
	ept->flags.bits.is_busy = 1;
    dc66:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    dc6a:	74e3      	strb	r3, [r4, #19]
	atomic_leave_critical(&flags);
    dc6c:	a801      	add	r0, sp, #4
    dc6e:	4790      	blx	r2
	ept->trans_buf   = trans->buf;
    dc70:	f8d8 3000 	ldr.w	r3, [r8]
    dc74:	6023      	str	r3, [r4, #0]
	ept->trans_size  = trans->size;
    dc76:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ept->trans_count = 0;
    dc7a:	e9c4 3a01 	strd	r3, sl, [r4, #4]
	ept->flags.bits.dir       = dir;
    dc7e:	7ce3      	ldrb	r3, [r4, #19]
    dc80:	f369 13c7 	bfi	r3, r9, #7, #1
	ept->flags.bits.use_cache = use_cache;
    dc84:	f365 1345 	bfi	r3, r5, #5, #1
    dc88:	74e3      	strb	r3, [r4, #19]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    dc8a:	f898 3009 	ldrb.w	r3, [r8, #9]
    dc8e:	b113      	cbz	r3, dc96 <_usb_d_dev_ep_trans+0xca>
    dc90:	fab6 f386 	clz	r3, r6
    dc94:	095b      	lsrs	r3, r3, #5
    dc96:	7ce2      	ldrb	r2, [r4, #19]
	if (dir) {
    dc98:	2f00      	cmp	r7, #0
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    dc9a:	f363 1204 	bfi	r2, r3, #4, #1
		_usb_d_dev_in_next(ept, false);
    dc9e:	4620      	mov	r0, r4
    dca0:	bfb4      	ite	lt
    dca2:	4b0a      	ldrlt	r3, [pc, #40]	; (dccc <_usb_d_dev_ep_trans+0x100>)
		_usb_d_dev_out_next(ept, false);
    dca4:	4b0a      	ldrge	r3, [pc, #40]	; (dcd0 <_usb_d_dev_ep_trans+0x104>)
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    dca6:	74e2      	strb	r2, [r4, #19]
		_usb_d_dev_in_next(ept, false);
    dca8:	2100      	movs	r1, #0
		_usb_d_dev_out_next(ept, false);
    dcaa:	4798      	blx	r3
	return ERR_NONE;
    dcac:	2000      	movs	r0, #0
    dcae:	e7ce      	b.n	dc4e <_usb_d_dev_ep_trans+0x82>
			return -USB_ERR_FUNC;
    dcb0:	f06f 0012 	mvn.w	r0, #18
    dcb4:	e7cb      	b.n	dc4e <_usb_d_dev_ep_trans+0x82>
		return USB_HALTED;
    dcb6:	2002      	movs	r0, #2
    dcb8:	e7c9      	b.n	dc4e <_usb_d_dev_ep_trans+0x82>
    dcba:	bf00      	nop
    dcbc:	0000cf1d 	.word	0x0000cf1d
    dcc0:	20042000 	.word	0x20042000
    dcc4:	00011ef9 	.word	0x00011ef9
    dcc8:	00011f07 	.word	0x00011f07
    dccc:	0000d19d 	.word	0x0000d19d
    dcd0:	0000d2f9 	.word	0x0000d2f9

0000dcd4 <_usb_d_dev_ep_get_status>:
	}
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_ABORT);
}

int32_t _usb_d_dev_ep_get_status(const uint8_t ep, struct usb_d_trans_status *stat)
{
    dcd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    dcd6:	f000 040f 	and.w	r4, r0, #15
{
    dcda:	460a      	mov	r2, r1
	bool                  dir = USB_EP_GET_DIR(ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dcdc:	4b19      	ldr	r3, [pc, #100]	; (dd44 <_usb_d_dev_ep_get_status+0x70>)
    dcde:	09c1      	lsrs	r1, r0, #7
{
    dce0:	4607      	mov	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dce2:	4620      	mov	r0, r4
    dce4:	4798      	blx	r3
	bool                  busy, stall;

	if (epn > CONF_USB_D_MAX_EP_N) {
    dce6:	2c05      	cmp	r4, #5
    dce8:	d82a      	bhi.n	dd40 <_usb_d_dev_ep_get_status+0x6c>
		return USB_ERR_PARAM;
	}
	busy  = ept->flags.bits.is_busy;
    dcea:	7cc5      	ldrb	r5, [r0, #19]
    dcec:	f3c5 1180 	ubfx	r1, r5, #6, #1
	stall = ept->flags.bits.is_stalled;
    dcf0:	f3c5 06c0 	ubfx	r6, r5, #3, #1
	if (stat) {
    dcf4:	b1fa      	cbz	r2, dd36 <_usb_d_dev_ep_get_status+0x62>
		stat->stall = stall;
    dcf6:	7a53      	ldrb	r3, [r2, #9]
		stat->busy  = busy;
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    dcf8:	0164      	lsls	r4, r4, #5
		stat->stall = stall;
    dcfa:	f366 1304 	bfi	r3, r6, #4, #1
		stat->busy  = busy;
    dcfe:	f361 0382 	bfi	r3, r1, #2, #1
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    dd02:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
		stat->busy  = busy;
    dd06:	7253      	strb	r3, [r2, #9]
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    dd08:	f894 3107 	ldrb.w	r3, [r4, #263]	; 0x107
    dd0c:	f3c3 1400 	ubfx	r4, r3, #4, #1
		stat->dir   = ept->flags.bits.dir;
		stat->size  = ept->trans_size;
    dd10:	6843      	ldr	r3, [r0, #4]
    dd12:	6013      	str	r3, [r2, #0]
		stat->count = ept->trans_count;
    dd14:	6883      	ldr	r3, [r0, #8]
		stat->ep    = ep;
    dd16:	7217      	strb	r7, [r2, #8]
		stat->count = ept->trans_count;
    dd18:	6053      	str	r3, [r2, #4]
		stat->xtype = ept->flags.bits.eptype - 1;
    dd1a:	7cc3      	ldrb	r3, [r0, #19]
    dd1c:	7a50      	ldrb	r0, [r2, #9]
    dd1e:	3303      	adds	r3, #3
    dd20:	f003 0303 	and.w	r3, r3, #3
		stat->dir   = ept->flags.bits.dir;
    dd24:	09ed      	lsrs	r5, r5, #7
		stat->xtype = ept->flags.bits.eptype - 1;
    dd26:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
    dd2a:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
    dd2e:	f020 002b 	bic.w	r0, r0, #43	; 0x2b
    dd32:	4303      	orrs	r3, r0
    dd34:	7253      	strb	r3, [r2, #9]
		return USB_ERR_PARAM;
    dd36:	2e00      	cmp	r6, #0
    dd38:	bf0c      	ite	eq
    dd3a:	4608      	moveq	r0, r1
    dd3c:	2002      	movne	r0, #2
	}
	if (busy) {
		return USB_BUSY;
	}
	return USB_OK;
}
    dd3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return USB_ERR_PARAM;
    dd40:	2012      	movs	r0, #18
    dd42:	e7fc      	b.n	dd3e <_usb_d_dev_ep_get_status+0x6a>
    dd44:	0000cf1d 	.word	0x0000cf1d

0000dd48 <_usb_d_dev_register_callback>:

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    dd48:	4b06      	ldr	r3, [pc, #24]	; (dd64 <_usb_d_dev_register_callback+0x1c>)
    dd4a:	2900      	cmp	r1, #0
    dd4c:	bf08      	it	eq
    dd4e:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    dd50:	2801      	cmp	r0, #1
    dd52:	d102      	bne.n	dd5a <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    dd54:	4b04      	ldr	r3, [pc, #16]	; (dd68 <_usb_d_dev_register_callback+0x20>)
    dd56:	6059      	str	r1, [r3, #4]
    dd58:	4770      	bx	lr
	} else if (type == USB_D_CB_SOF) {
    dd5a:	b908      	cbnz	r0, dd60 <_usb_d_dev_register_callback+0x18>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    dd5c:	4b02      	ldr	r3, [pc, #8]	; (dd68 <_usb_d_dev_register_callback+0x20>)
    dd5e:	6019      	str	r1, [r3, #0]
	}
}
    dd60:	4770      	bx	lr
    dd62:	bf00      	nop
    dd64:	0000cef5 	.word	0x0000cef5
    dd68:	200085a8 	.word	0x200085a8

0000dd6c <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    dd6c:	4b08      	ldr	r3, [pc, #32]	; (dd90 <_usb_d_dev_register_ep_callback+0x24>)
    dd6e:	2900      	cmp	r1, #0
    dd70:	bf08      	it	eq
    dd72:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    dd74:	b910      	cbnz	r0, dd7c <_usb_d_dev_register_ep_callback+0x10>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    dd76:	4b07      	ldr	r3, [pc, #28]	; (dd94 <_usb_d_dev_register_ep_callback+0x28>)
    dd78:	6099      	str	r1, [r3, #8]
    dd7a:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    dd7c:	2801      	cmp	r0, #1
    dd7e:	d102      	bne.n	dd86 <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    dd80:	4b04      	ldr	r3, [pc, #16]	; (dd94 <_usb_d_dev_register_ep_callback+0x28>)
    dd82:	60d9      	str	r1, [r3, #12]
    dd84:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    dd86:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    dd88:	bf04      	itt	eq
    dd8a:	4b02      	ldreq	r3, [pc, #8]	; (dd94 <_usb_d_dev_register_ep_callback+0x28>)
    dd8c:	6119      	streq	r1, [r3, #16]
	}
}
    dd8e:	4770      	bx	lr
    dd90:	0000cef5 	.word	0x0000cef5
    dd94:	200085a8 	.word	0x200085a8

0000dd98 <USB_0_Handler>:
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{

	_usb_d_dev_handler();
    dd98:	4b00      	ldr	r3, [pc, #0]	; (dd9c <USB_0_Handler+0x4>)
    dd9a:	4718      	bx	r3
    dd9c:	0000d495 	.word	0x0000d495

0000dda0 <USB_1_Handler>:
    dda0:	4b00      	ldr	r3, [pc, #0]	; (dda4 <USB_1_Handler+0x4>)
    dda2:	4718      	bx	r3
    dda4:	0000d495 	.word	0x0000d495

0000dda8 <USB_2_Handler>:
    dda8:	4b00      	ldr	r3, [pc, #0]	; (ddac <USB_2_Handler+0x4>)
    ddaa:	4718      	bx	r3
    ddac:	0000d495 	.word	0x0000d495

0000ddb0 <USB_3_Handler>:
    ddb0:	4b00      	ldr	r3, [pc, #0]	; (ddb4 <USB_3_Handler+0x4>)
    ddb2:	4718      	bx	r3
    ddb4:	0000d495 	.word	0x0000d495

0000ddb8 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    ddb8:	b508      	push	{r3, lr}
    ddba:	4603      	mov	r3, r0
    ddbc:	4608      	mov	r0, r1
    ddbe:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
    ddc0:	b923      	cbnz	r3, ddcc <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    ddc2:	4b04      	ldr	r3, [pc, #16]	; (ddd4 <_read+0x1c>)
    ddc4:	4798      	blx	r3
	if (n < 0) {
    ddc6:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    ddca:	bd08      	pop	{r3, pc}
		return -1;
    ddcc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    ddd0:	e7fb      	b.n	ddca <_read+0x12>
    ddd2:	bf00      	nop
    ddd4:	0000bca9 	.word	0x0000bca9

0000ddd8 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    ddd8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    dddc:	4c0c      	ldr	r4, [pc, #48]	; (de10 <prvCheckForValidListAndQueue+0x38>)
	taskENTER_CRITICAL();
    ddde:	4b0d      	ldr	r3, [pc, #52]	; (de14 <prvCheckForValidListAndQueue+0x3c>)
    dde0:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    dde2:	6825      	ldr	r5, [r4, #0]
    dde4:	b985      	cbnz	r5, de08 <prvCheckForValidListAndQueue+0x30>
			vListInitialise(&xActiveTimerList1);
    dde6:	1d27      	adds	r7, r4, #4
    dde8:	f8df 8034 	ldr.w	r8, [pc, #52]	; de20 <prvCheckForValidListAndQueue+0x48>
    ddec:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    ddee:	f104 0618 	add.w	r6, r4, #24
			vListInitialise(&xActiveTimerList1);
    ddf2:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    ddf4:	4630      	mov	r0, r6
    ddf6:	47c0      	blx	r8
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    ddf8:	4b07      	ldr	r3, [pc, #28]	; (de18 <prvCheckForValidListAndQueue+0x40>)
    ddfa:	462a      	mov	r2, r5
    ddfc:	210c      	movs	r1, #12
    ddfe:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    de00:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    de04:	4798      	blx	r3
    de06:	6020      	str	r0, [r4, #0]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    de08:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    de0c:	4b03      	ldr	r3, [pc, #12]	; (de1c <prvCheckForValidListAndQueue+0x44>)
    de0e:	4718      	bx	r3
    de10:	20008968 	.word	0x20008968
    de14:	0000b645 	.word	0x0000b645
    de18:	0000c76d 	.word	0x0000c76d
    de1c:	0000b689 	.word	0x0000b689
    de20:	0000b4f5 	.word	0x0000b4f5

0000de24 <prvInsertTimerInActiveList>:
	if (xNextExpiryTime <= xTimeNow) {
    de24:	4291      	cmp	r1, r2
{
    de26:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    de28:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    de2a:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    de2c:	d80a      	bhi.n	de44 <prvInsertTimerInActiveList+0x20>
		if (((TickType_t)(xTimeNow - xCommandTime))
    de2e:	1ad2      	subs	r2, r2, r3
    de30:	6983      	ldr	r3, [r0, #24]
    de32:	429a      	cmp	r2, r3
    de34:	d20e      	bcs.n	de54 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    de36:	4b08      	ldr	r3, [pc, #32]	; (de58 <prvInsertTimerInActiveList+0x34>)
    de38:	1d01      	adds	r1, r0, #4
    de3a:	6b18      	ldr	r0, [r3, #48]	; 0x30
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    de3c:	4b07      	ldr	r3, [pc, #28]	; (de5c <prvInsertTimerInActiveList+0x38>)
    de3e:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    de40:	2000      	movs	r0, #0
}
    de42:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    de44:	429a      	cmp	r2, r3
    de46:	d201      	bcs.n	de4c <prvInsertTimerInActiveList+0x28>
    de48:	4299      	cmp	r1, r3
    de4a:	d203      	bcs.n	de54 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    de4c:	4b02      	ldr	r3, [pc, #8]	; (de58 <prvInsertTimerInActiveList+0x34>)
    de4e:	1d01      	adds	r1, r0, #4
    de50:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    de52:	e7f3      	b.n	de3c <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    de54:	2001      	movs	r0, #1
	return xProcessTimerNow;
    de56:	e7f4      	b.n	de42 <prvInsertTimerInActiveList+0x1e>
    de58:	20008968 	.word	0x20008968
    de5c:	0000b529 	.word	0x0000b529

0000de60 <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    de60:	4b0e      	ldr	r3, [pc, #56]	; (de9c <xTimerCreateTimerTask+0x3c>)
{
    de62:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    de64:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    de66:	4b0e      	ldr	r3, [pc, #56]	; (dea0 <xTimerCreateTimerTask+0x40>)
    de68:	681a      	ldr	r2, [r3, #0]
    de6a:	b942      	cbnz	r2, de7e <xTimerCreateTimerTask+0x1e>
    de6c:	f04f 0380 	mov.w	r3, #128	; 0x80
    de70:	f383 8811 	msr	BASEPRI, r3
    de74:	f3bf 8f6f 	isb	sy
    de78:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
    de7c:	e7fe      	b.n	de7c <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(prvTimerTask,
    de7e:	3334      	adds	r3, #52	; 0x34
    de80:	9301      	str	r3, [sp, #4]
    de82:	2302      	movs	r3, #2
    de84:	9300      	str	r3, [sp, #0]
    de86:	4907      	ldr	r1, [pc, #28]	; (dea4 <xTimerCreateTimerTask+0x44>)
    de88:	4807      	ldr	r0, [pc, #28]	; (dea8 <xTimerCreateTimerTask+0x48>)
    de8a:	4c08      	ldr	r4, [pc, #32]	; (deac <xTimerCreateTimerTask+0x4c>)
    de8c:	2300      	movs	r3, #0
    de8e:	2240      	movs	r2, #64	; 0x40
    de90:	47a0      	blx	r4
	configASSERT(xReturn);
    de92:	2800      	cmp	r0, #0
    de94:	d0ea      	beq.n	de6c <xTimerCreateTimerTask+0xc>
}
    de96:	b002      	add	sp, #8
    de98:	bd10      	pop	{r4, pc}
    de9a:	bf00      	nop
    de9c:	0000ddd9 	.word	0x0000ddd9
    dea0:	20008968 	.word	0x20008968
    dea4:	00016858 	.word	0x00016858
    dea8:	0000df91 	.word	0x0000df91
    deac:	00012a0d 	.word	0x00012a0d

0000deb0 <xTimerGenericCommand>:
{
    deb0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    deb2:	4616      	mov	r6, r2
	configASSERT(xTimer);
    deb4:	4604      	mov	r4, r0
{
    deb6:	461a      	mov	r2, r3
	configASSERT(xTimer);
    deb8:	b940      	cbnz	r0, decc <xTimerGenericCommand+0x1c>
    deba:	f04f 0380 	mov.w	r3, #128	; 0x80
    debe:	f383 8811 	msr	BASEPRI, r3
    dec2:	f3bf 8f6f 	isb	sy
    dec6:	f3bf 8f4f 	dsb	sy
    deca:	e7fe      	b.n	deca <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    decc:	4d0d      	ldr	r5, [pc, #52]	; (df04 <xTimerGenericCommand+0x54>)
    dece:	6828      	ldr	r0, [r5, #0]
    ded0:	b188      	cbz	r0, def6 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    ded2:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    ded4:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    ded8:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    deda:	dc0e      	bgt.n	defa <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    dedc:	4b0a      	ldr	r3, [pc, #40]	; (df08 <xTimerGenericCommand+0x58>)
    dede:	4c0b      	ldr	r4, [pc, #44]	; (df0c <xTimerGenericCommand+0x5c>)
    dee0:	4798      	blx	r3
    dee2:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    dee4:	f04f 0300 	mov.w	r3, #0
    dee8:	bf08      	it	eq
    deea:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    deec:	6828      	ldr	r0, [r5, #0]
    deee:	bf18      	it	ne
    def0:	461a      	movne	r2, r3
    def2:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    def4:	47a0      	blx	r4
}
    def6:	b004      	add	sp, #16
    def8:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    defa:	4c05      	ldr	r4, [pc, #20]	; (df10 <xTimerGenericCommand+0x60>)
    defc:	2300      	movs	r3, #0
    defe:	a901      	add	r1, sp, #4
    df00:	e7f8      	b.n	def4 <xTimerGenericCommand+0x44>
    df02:	bf00      	nop
    df04:	20008968 	.word	0x20008968
    df08:	00013101 	.word	0x00013101
    df0c:	0000c7c1 	.word	0x0000c7c1
    df10:	0000c96d 	.word	0x0000c96d

0000df14 <prvSwitchTimerLists>:
{
    df14:	b5f0      	push	{r4, r5, r6, r7, lr}
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    df16:	4d1a      	ldr	r5, [pc, #104]	; (df80 <prvSwitchTimerLists+0x6c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    df18:	4f1a      	ldr	r7, [pc, #104]	; (df84 <prvSwitchTimerLists+0x70>)
{
    df1a:	b085      	sub	sp, #20
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    df1c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    df1e:	681a      	ldr	r2, [r3, #0]
    df20:	b922      	cbnz	r2, df2c <prvSwitchTimerLists+0x18>
	pxCurrentTimerList  = pxOverflowTimerList;
    df22:	6b2a      	ldr	r2, [r5, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
    df24:	e9c5 230b 	strd	r2, r3, [r5, #44]	; 0x2c
}
    df28:	b005      	add	sp, #20
    df2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    df2c:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    df2e:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    df30:	681e      	ldr	r6, [r3, #0]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    df32:	1d21      	adds	r1, r4, #4
    df34:	4608      	mov	r0, r1
    df36:	9103      	str	r1, [sp, #12]
    df38:	47b8      	blx	r7
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    df3a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    df3c:	4620      	mov	r0, r4
    df3e:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    df40:	69e3      	ldr	r3, [r4, #28]
    df42:	9903      	ldr	r1, [sp, #12]
    df44:	2b01      	cmp	r3, #1
    df46:	d1e9      	bne.n	df1c <prvSwitchTimerLists+0x8>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    df48:	69a3      	ldr	r3, [r4, #24]
    df4a:	4433      	add	r3, r6
			if (xReloadTime > xNextExpireTime) {
    df4c:	429e      	cmp	r6, r3
    df4e:	d205      	bcs.n	df5c <prvSwitchTimerLists+0x48>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    df50:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    df52:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    df54:	4b0c      	ldr	r3, [pc, #48]	; (df88 <prvSwitchTimerLists+0x74>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    df56:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    df58:	4798      	blx	r3
    df5a:	e7df      	b.n	df1c <prvSwitchTimerLists+0x8>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    df5c:	2300      	movs	r3, #0
    df5e:	4620      	mov	r0, r4
    df60:	9300      	str	r3, [sp, #0]
    df62:	4c0a      	ldr	r4, [pc, #40]	; (df8c <prvSwitchTimerLists+0x78>)
    df64:	4632      	mov	r2, r6
    df66:	4619      	mov	r1, r3
    df68:	47a0      	blx	r4
				configASSERT(xResult);
    df6a:	2800      	cmp	r0, #0
    df6c:	d1d6      	bne.n	df1c <prvSwitchTimerLists+0x8>
    df6e:	f04f 0380 	mov.w	r3, #128	; 0x80
    df72:	f383 8811 	msr	BASEPRI, r3
    df76:	f3bf 8f6f 	isb	sy
    df7a:	f3bf 8f4f 	dsb	sy
    df7e:	e7fe      	b.n	df7e <prvSwitchTimerLists+0x6a>
    df80:	20008968 	.word	0x20008968
    df84:	0000b557 	.word	0x0000b557
    df88:	0000b529 	.word	0x0000b529
    df8c:	0000deb1 	.word	0x0000deb1

0000df90 <prvTimerTask>:
{
    df90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    df94:	f8df 81c8 	ldr.w	r8, [pc, #456]	; e160 <prvTimerTask+0x1d0>
{
    df98:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    df9a:	4c68      	ldr	r4, [pc, #416]	; (e13c <prvTimerTask+0x1ac>)
    df9c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    df9e:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    dfa2:	4627      	mov	r7, r4
    dfa4:	f1bb 0f00 	cmp.w	fp, #0
    dfa8:	d044      	beq.n	e034 <prvTimerTask+0xa4>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    dfaa:	68db      	ldr	r3, [r3, #12]
    dfac:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
    dfb0:	4b63      	ldr	r3, [pc, #396]	; (e140 <prvTimerTask+0x1b0>)
	xTimeNow = xTaskGetTickCount();
    dfb2:	4e64      	ldr	r6, [pc, #400]	; (e144 <prvTimerTask+0x1b4>)
    dfb4:	f8df a1ac 	ldr.w	sl, [pc, #428]	; e164 <prvTimerTask+0x1d4>
	vTaskSuspendAll();
    dfb8:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    dfba:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dfbc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    dfbe:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dfc0:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dfc2:	d239      	bcs.n	e038 <prvTimerTask+0xa8>
		prvSwitchTimerLists();
    dfc4:	4b60      	ldr	r3, [pc, #384]	; (e148 <prvTimerTask+0x1b8>)
    dfc6:	4798      	blx	r3
	xLastTime = xTimeNow;
    dfc8:	63a5      	str	r5, [r4, #56]	; 0x38
			(void)xTaskResumeAll();
    dfca:	47d0      	blx	sl
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dfcc:	f8df 9198 	ldr.w	r9, [pc, #408]	; e168 <prvTimerTask+0x1d8>
		prvSwitchTimerLists();
    dfd0:	f8df a174 	ldr.w	sl, [pc, #372]	; e148 <prvTimerTask+0x1b8>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    dfd4:	6838      	ldr	r0, [r7, #0]
    dfd6:	2200      	movs	r2, #0
    dfd8:	a903      	add	r1, sp, #12
    dfda:	47c8      	blx	r9
    dfdc:	2800      	cmp	r0, #0
    dfde:	d0dc      	beq.n	df9a <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    dfe0:	9b03      	ldr	r3, [sp, #12]
    dfe2:	2b00      	cmp	r3, #0
    dfe4:	dbf6      	blt.n	dfd4 <prvTimerTask+0x44>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    dfe6:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    dfe8:	6963      	ldr	r3, [r4, #20]
    dfea:	b10b      	cbz	r3, dff0 <prvTimerTask+0x60>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    dfec:	1d20      	adds	r0, r4, #4
    dfee:	47c0      	blx	r8
	xTimeNow = xTaskGetTickCount();
    dff0:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    dff2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    dff4:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    dff6:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    dff8:	d200      	bcs.n	dffc <prvTimerTask+0x6c>
		prvSwitchTimerLists();
    dffa:	47d0      	blx	sl
	xLastTime = xTimeNow;
    dffc:	9b03      	ldr	r3, [sp, #12]
    dffe:	63bd      	str	r5, [r7, #56]	; 0x38
			switch (xMessage.xMessageID) {
    e000:	2b09      	cmp	r3, #9
    e002:	d8e7      	bhi.n	dfd4 <prvTimerTask+0x44>
    e004:	a201      	add	r2, pc, #4	; (adr r2, e00c <prvTimerTask+0x7c>)
    e006:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    e00a:	bf00      	nop
    e00c:	0000e0c1 	.word	0x0000e0c1
    e010:	0000e0c1 	.word	0x0000e0c1
    e014:	0000e0c1 	.word	0x0000e0c1
    e018:	0000dfd5 	.word	0x0000dfd5
    e01c:	0000e10d 	.word	0x0000e10d
    e020:	0000e133 	.word	0x0000e133
    e024:	0000e0c1 	.word	0x0000e0c1
    e028:	0000e0c1 	.word	0x0000e0c1
    e02c:	0000dfd5 	.word	0x0000dfd5
    e030:	0000e10d 	.word	0x0000e10d
		xNextExpireTime = (TickType_t)0U;
    e034:	46d9      	mov	r9, fp
    e036:	e7bb      	b.n	dfb0 <prvTimerTask+0x20>
	xLastTime = xTimeNow;
    e038:	63a0      	str	r0, [r4, #56]	; 0x38
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    e03a:	f1bb 0f00 	cmp.w	fp, #0
    e03e:	d027      	beq.n	e090 <prvTimerTask+0x100>
    e040:	4581      	cmp	r9, r0
    e042:	d83b      	bhi.n	e0bc <prvTimerTask+0x12c>
				(void)xTaskResumeAll();
    e044:	47d0      	blx	sl
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    e046:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e048:	68db      	ldr	r3, [r3, #12]
    e04a:	68dc      	ldr	r4, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    e04c:	1d20      	adds	r0, r4, #4
    e04e:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    e050:	69e3      	ldr	r3, [r4, #28]
    e052:	2b01      	cmp	r3, #1
    e054:	d118      	bne.n	e088 <prvTimerTask+0xf8>
		if (prvInsertTimerInActiveList(
    e056:	69a1      	ldr	r1, [r4, #24]
    e058:	462a      	mov	r2, r5
    e05a:	464b      	mov	r3, r9
    e05c:	4d3b      	ldr	r5, [pc, #236]	; (e14c <prvTimerTask+0x1bc>)
    e05e:	4449      	add	r1, r9
    e060:	4620      	mov	r0, r4
    e062:	47a8      	blx	r5
    e064:	b180      	cbz	r0, e088 <prvTimerTask+0xf8>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    e066:	2300      	movs	r3, #0
    e068:	4d39      	ldr	r5, [pc, #228]	; (e150 <prvTimerTask+0x1c0>)
    e06a:	9300      	str	r3, [sp, #0]
    e06c:	464a      	mov	r2, r9
    e06e:	4619      	mov	r1, r3
    e070:	4620      	mov	r0, r4
    e072:	47a8      	blx	r5
			configASSERT(xResult);
    e074:	b940      	cbnz	r0, e088 <prvTimerTask+0xf8>
    e076:	f04f 0380 	mov.w	r3, #128	; 0x80
    e07a:	f383 8811 	msr	BASEPRI, r3
    e07e:	f3bf 8f6f 	isb	sy
    e082:	f3bf 8f4f 	dsb	sy
    e086:	e7fe      	b.n	e086 <prvTimerTask+0xf6>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    e088:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e08a:	4620      	mov	r0, r4
    e08c:	4798      	blx	r3
}
    e08e:	e79d      	b.n	dfcc <prvTimerTask+0x3c>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    e090:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e092:	681a      	ldr	r2, [r3, #0]
    e094:	fab2 f282 	clz	r2, r2
    e098:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    e09a:	6820      	ldr	r0, [r4, #0]
    e09c:	4b2d      	ldr	r3, [pc, #180]	; (e154 <prvTimerTask+0x1c4>)
    e09e:	eba9 0105 	sub.w	r1, r9, r5
    e0a2:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    e0a4:	47d0      	blx	sl
    e0a6:	2800      	cmp	r0, #0
    e0a8:	d190      	bne.n	dfcc <prvTimerTask+0x3c>
					portYIELD_WITHIN_API();
    e0aa:	4b2b      	ldr	r3, [pc, #172]	; (e158 <prvTimerTask+0x1c8>)
    e0ac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e0b0:	601a      	str	r2, [r3, #0]
    e0b2:	f3bf 8f4f 	dsb	sy
    e0b6:	f3bf 8f6f 	isb	sy
    e0ba:	e787      	b.n	dfcc <prvTimerTask+0x3c>
    e0bc:	2200      	movs	r2, #0
    e0be:	e7ec      	b.n	e09a <prvTimerTask+0x10a>
				if (prvInsertTimerInActiveList(pxTimer,
    e0c0:	69a1      	ldr	r1, [r4, #24]
    e0c2:	9b04      	ldr	r3, [sp, #16]
    e0c4:	462a      	mov	r2, r5
    e0c6:	4419      	add	r1, r3
    e0c8:	4d20      	ldr	r5, [pc, #128]	; (e14c <prvTimerTask+0x1bc>)
    e0ca:	4620      	mov	r0, r4
    e0cc:	47a8      	blx	r5
    e0ce:	2800      	cmp	r0, #0
    e0d0:	f43f af7e 	beq.w	dfd0 <prvTimerTask+0x40>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    e0d4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e0d6:	4620      	mov	r0, r4
    e0d8:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    e0da:	69e3      	ldr	r3, [r4, #28]
    e0dc:	2b01      	cmp	r3, #1
    e0de:	f47f af77 	bne.w	dfd0 <prvTimerTask+0x40>
						xResult = xTimerGenericCommand(pxTimer,
    e0e2:	69a2      	ldr	r2, [r4, #24]
    e0e4:	9904      	ldr	r1, [sp, #16]
    e0e6:	2300      	movs	r3, #0
    e0e8:	440a      	add	r2, r1
    e0ea:	4620      	mov	r0, r4
    e0ec:	9300      	str	r3, [sp, #0]
    e0ee:	4c18      	ldr	r4, [pc, #96]	; (e150 <prvTimerTask+0x1c0>)
    e0f0:	4619      	mov	r1, r3
    e0f2:	47a0      	blx	r4
						configASSERT(xResult);
    e0f4:	2800      	cmp	r0, #0
    e0f6:	f47f af6b 	bne.w	dfd0 <prvTimerTask+0x40>
    e0fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    e0fe:	f383 8811 	msr	BASEPRI, r3
    e102:	f3bf 8f6f 	isb	sy
    e106:	f3bf 8f4f 	dsb	sy
    e10a:	e7fe      	b.n	e10a <prvTimerTask+0x17a>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    e10c:	9904      	ldr	r1, [sp, #16]
    e10e:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    e110:	b941      	cbnz	r1, e124 <prvTimerTask+0x194>
    e112:	f04f 0380 	mov.w	r3, #128	; 0x80
    e116:	f383 8811 	msr	BASEPRI, r3
    e11a:	f3bf 8f6f 	isb	sy
    e11e:	f3bf 8f4f 	dsb	sy
    e122:	e7fe      	b.n	e122 <prvTimerTask+0x192>
				(void)prvInsertTimerInActiveList(
    e124:	462b      	mov	r3, r5
    e126:	462a      	mov	r2, r5
    e128:	4429      	add	r1, r5
    e12a:	4620      	mov	r0, r4
    e12c:	4c07      	ldr	r4, [pc, #28]	; (e14c <prvTimerTask+0x1bc>)
    e12e:	47a0      	blx	r4
				break;
    e130:	e74e      	b.n	dfd0 <prvTimerTask+0x40>
				vPortFree(pxTimer);
    e132:	4b0a      	ldr	r3, [pc, #40]	; (e15c <prvTimerTask+0x1cc>)
    e134:	4620      	mov	r0, r4
    e136:	4798      	blx	r3
			break;
    e138:	e74a      	b.n	dfd0 <prvTimerTask+0x40>
    e13a:	bf00      	nop
    e13c:	20008968 	.word	0x20008968
    e140:	00012c35 	.word	0x00012c35
    e144:	00012c49 	.word	0x00012c49
    e148:	0000df15 	.word	0x0000df15
    e14c:	0000de25 	.word	0x0000de25
    e150:	0000deb1 	.word	0x0000deb1
    e154:	0000cbb5 	.word	0x0000cbb5
    e158:	e000ed04 	.word	0xe000ed04
    e15c:	0000bb09 	.word	0x0000bb09
    e160:	0000b557 	.word	0x0000b557
    e164:	00012d7d 	.word	0x00012d7d
    e168:	0000ca4d 	.word	0x0000ca4d

0000e16c <delay_init>:
/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
	_delay_init(hardware = hw);
    e16c:	4b01      	ldr	r3, [pc, #4]	; (e174 <delay_init+0x8>)
    e16e:	6018      	str	r0, [r3, #0]
    e170:	4b01      	ldr	r3, [pc, #4]	; (e178 <delay_init+0xc>)
    e172:	4718      	bx	r3
    e174:	200089a4 	.word	0x200089a4
    e178:	00013f21 	.word	0x00013f21

0000e17c <delay_ms>:
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    e17c:	4b05      	ldr	r3, [pc, #20]	; (e194 <delay_ms+0x18>)
{
    e17e:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    e180:	681c      	ldr	r4, [r3, #0]
    e182:	4b05      	ldr	r3, [pc, #20]	; (e198 <delay_ms+0x1c>)
    e184:	4798      	blx	r3
    e186:	4b05      	ldr	r3, [pc, #20]	; (e19c <delay_ms+0x20>)
    e188:	4601      	mov	r1, r0
    e18a:	4620      	mov	r0, r4
}
    e18c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    e190:	4718      	bx	r3
    e192:	bf00      	nop
    e194:	200089a4 	.word	0x200089a4
    e198:	0000beb5 	.word	0x0000beb5
    e19c:	00013f35 	.word	0x00013f35

0000e1a0 <_init_chip>:
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    e1a0:	4a0e      	ldr	r2, [pc, #56]	; (e1dc <_init_chip+0x3c>)
    e1a2:	8813      	ldrh	r3, [r2, #0]
    e1a4:	b29b      	uxth	r3, r3
    e1a6:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    e1aa:	b510      	push	{r4, lr}
    e1ac:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    e1ae:	4b0c      	ldr	r3, [pc, #48]	; (e1e0 <_init_chip+0x40>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    e1b0:	4c0c      	ldr	r4, [pc, #48]	; (e1e4 <_init_chip+0x44>)
	_osc32kctrl_init_sources();
    e1b2:	4798      	blx	r3
	_oscctrl_init_sources();
    e1b4:	4b0c      	ldr	r3, [pc, #48]	; (e1e8 <_init_chip+0x48>)
    e1b6:	4798      	blx	r3
	_mclk_init();
    e1b8:	4b0c      	ldr	r3, [pc, #48]	; (e1ec <_init_chip+0x4c>)
    e1ba:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    e1bc:	2004      	movs	r0, #4
    e1be:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    e1c0:	4b0b      	ldr	r3, [pc, #44]	; (e1f0 <_init_chip+0x50>)
    e1c2:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    e1c4:	f640 70fb 	movw	r0, #4091	; 0xffb
    e1c8:	47a0      	blx	r4
}

static inline void hri_mclk_set_AHBMASK_DMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    e1ca:	4a0a      	ldr	r2, [pc, #40]	; (e1f4 <_init_chip+0x54>)
    e1cc:	6913      	ldr	r3, [r2, #16]
    e1ce:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    e1d2:	6113      	str	r3, [r2, #16]
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    e1d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_dma_init();
    e1d8:	4b07      	ldr	r3, [pc, #28]	; (e1f8 <_init_chip+0x58>)
    e1da:	4718      	bx	r3
    e1dc:	41004000 	.word	0x41004000
    e1e0:	0000fc65 	.word	0x0000fc65
    e1e4:	0000f065 	.word	0x0000f065
    e1e8:	0000ea0d 	.word	0x0000ea0d
    e1ec:	0000f045 	.word	0x0000f045
    e1f0:	0000ea11 	.word	0x0000ea11
    e1f4:	40000800 	.word	0x40000800
    e1f8:	0000e481 	.word	0x0000e481

0000e1fc <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    e1fc:	4a0b      	ldr	r2, [pc, #44]	; (e22c <RAMECC_Handler+0x30>)
    e1fe:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    e200:	b082      	sub	sp, #8
    e202:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    e204:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    e206:	9b01      	ldr	r3, [sp, #4]
    e208:	0799      	lsls	r1, r3, #30
    e20a:	d505      	bpl.n	e218 <RAMECC_Handler+0x1c>
    e20c:	4b08      	ldr	r3, [pc, #32]	; (e230 <RAMECC_Handler+0x34>)
    e20e:	681b      	ldr	r3, [r3, #0]
    e210:	b113      	cbz	r3, e218 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    e212:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    e214:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    e216:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    e218:	9b01      	ldr	r3, [sp, #4]
    e21a:	07db      	lsls	r3, r3, #31
    e21c:	d504      	bpl.n	e228 <RAMECC_Handler+0x2c>
    e21e:	4b04      	ldr	r3, [pc, #16]	; (e230 <RAMECC_Handler+0x34>)
    e220:	685b      	ldr	r3, [r3, #4]
    e222:	b10b      	cbz	r3, e228 <RAMECC_Handler+0x2c>
    e224:	4a01      	ldr	r2, [pc, #4]	; (e22c <RAMECC_Handler+0x30>)
    e226:	e7f4      	b.n	e212 <RAMECC_Handler+0x16>
}
    e228:	b002      	add	sp, #8
    e22a:	4770      	bx	lr
    e22c:	41020000 	.word	0x41020000
    e230:	2001c858 	.word	0x2001c858

0000e234 <hid_mouse_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    e234:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    e236:	780a      	ldrb	r2, [r1, #0]
    e238:	2a81      	cmp	r2, #129	; 0x81
    e23a:	d11c      	bne.n	e276 <hid_mouse_req+0x42>
    e23c:	784b      	ldrb	r3, [r1, #1]
    e23e:	2b06      	cmp	r3, #6
    e240:	d131      	bne.n	e2a6 <hid_mouse_req+0x72>
    e242:	4a1a      	ldr	r2, [pc, #104]	; (e2ac <hid_mouse_req+0x78>)
    e244:	888c      	ldrh	r4, [r1, #4]
    e246:	7a13      	ldrb	r3, [r2, #8]
    e248:	429c      	cmp	r4, r3
    e24a:	d12c      	bne.n	e2a6 <hid_mouse_req+0x72>
	switch (req->wValue >> 8) {
    e24c:	884b      	ldrh	r3, [r1, #2]
    e24e:	0a1b      	lsrs	r3, r3, #8
    e250:	2b21      	cmp	r3, #33	; 0x21
    e252:	d005      	beq.n	e260 <hid_mouse_req+0x2c>
    e254:	2b22      	cmp	r3, #34	; 0x22
    e256:	d00a      	beq.n	e26e <hid_mouse_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
			switch (req->bRequest) {
    e258:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    e25c:	bc30      	pop	{r4, r5}
    e25e:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
    e260:	6811      	ldr	r1, [r2, #0]
    e262:	780a      	ldrb	r2, [r1, #0]
    e264:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    e266:	4c12      	ldr	r4, [pc, #72]	; (e2b0 <hid_mouse_req+0x7c>)
    e268:	46a4      	mov	ip, r4
}
    e26a:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    e26c:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
    e26e:	4911      	ldr	r1, [pc, #68]	; (e2b4 <hid_mouse_req+0x80>)
    e270:	2300      	movs	r3, #0
    e272:	2234      	movs	r2, #52	; 0x34
    e274:	e7f7      	b.n	e266 <hid_mouse_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    e276:	f3c2 1241 	ubfx	r2, r2, #5, #2
    e27a:	2a01      	cmp	r2, #1
    e27c:	d113      	bne.n	e2a6 <hid_mouse_req+0x72>
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
    e27e:	4c0b      	ldr	r4, [pc, #44]	; (e2ac <hid_mouse_req+0x78>)
    e280:	888d      	ldrh	r5, [r1, #4]
    e282:	7a23      	ldrb	r3, [r4, #8]
    e284:	429d      	cmp	r5, r3
    e286:	d10e      	bne.n	e2a6 <hid_mouse_req+0x72>
			switch (req->bRequest) {
    e288:	784b      	ldrb	r3, [r1, #1]
    e28a:	2b03      	cmp	r3, #3
    e28c:	d007      	beq.n	e29e <hid_mouse_req+0x6a>
    e28e:	2b0b      	cmp	r3, #11
    e290:	d1e2      	bne.n	e258 <hid_mouse_req+0x24>
				_hiddf_mouse_funcd.protocol = req->wValue;
    e292:	884b      	ldrh	r3, [r1, #2]
    e294:	72a3      	strb	r3, [r4, #10]
				return usbdc_xfer(ep, NULL, 0, 0);
    e296:	2300      	movs	r3, #0
    e298:	461a      	mov	r2, r3
    e29a:	4619      	mov	r1, r3
    e29c:	e7e3      	b.n	e266 <hid_mouse_req+0x32>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
    e29e:	2300      	movs	r3, #0
    e2a0:	f104 010a 	add.w	r1, r4, #10
    e2a4:	e7df      	b.n	e266 <hid_mouse_req+0x32>
			return ERR_NOT_FOUND;
    e2a6:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    e2aa:	e7d7      	b.n	e25c <hid_mouse_req+0x28>
    e2ac:	200089a8 	.word	0x200089a8
    e2b0:	00013711 	.word	0x00013711
    e2b4:	00016860 	.word	0x00016860

0000e2b8 <hid_mouse_ctrl>:
	switch (ctrl) {
    e2b8:	2901      	cmp	r1, #1
{
    e2ba:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e2bc:	4614      	mov	r4, r2
	switch (ctrl) {
    e2be:	d03b      	beq.n	e338 <hid_mouse_ctrl+0x80>
    e2c0:	2902      	cmp	r1, #2
    e2c2:	d04f      	beq.n	e364 <hid_mouse_ctrl+0xac>
    e2c4:	2900      	cmp	r1, #0
    e2c6:	d150      	bne.n	e36a <hid_mouse_ctrl+0xb2>
	ifc = desc->sod;
    e2c8:	6813      	ldr	r3, [r2, #0]
		return hid_mouse_enable(drv, (struct usbd_descriptors *)param);
    e2ca:	6886      	ldr	r6, [r0, #8]
	if (NULL == ifc) {
    e2cc:	b91b      	cbnz	r3, e2d6 <hid_mouse_ctrl+0x1e>
		return ERR_NOT_FOUND;
    e2ce:	f06f 0409 	mvn.w	r4, #9
}
    e2d2:	4620      	mov	r0, r4
    e2d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e2d6:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    e2d8:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e2da:	2903      	cmp	r1, #3
    e2dc:	d1f7      	bne.n	e2ce <hid_mouse_ctrl+0x16>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    e2de:	7a31      	ldrb	r1, [r6, #8]
    e2e0:	428a      	cmp	r2, r1
    e2e2:	d045      	beq.n	e370 <hid_mouse_ctrl+0xb8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    e2e4:	29ff      	cmp	r1, #255	; 0xff
    e2e6:	d146      	bne.n	e376 <hid_mouse_ctrl+0xbe>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    e2e8:	7232      	strb	r2, [r6, #8]
    e2ea:	7818      	ldrb	r0, [r3, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e2ec:	6861      	ldr	r1, [r4, #4]
    e2ee:	4f26      	ldr	r7, [pc, #152]	; (e388 <hid_mouse_ctrl+0xd0>)
    e2f0:	2221      	movs	r2, #33	; 0x21
    e2f2:	4418      	add	r0, r3
    e2f4:	4b25      	ldr	r3, [pc, #148]	; (e38c <hid_mouse_ctrl+0xd4>)
    e2f6:	4798      	blx	r3
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e2f8:	6823      	ldr	r3, [r4, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e2fa:	6038      	str	r0, [r7, #0]
    e2fc:	7818      	ldrb	r0, [r3, #0]
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e2fe:	6861      	ldr	r1, [r4, #4]
    e300:	4418      	add	r0, r3
    e302:	4b23      	ldr	r3, [pc, #140]	; (e390 <hid_mouse_ctrl+0xd8>)
    e304:	4798      	blx	r3
	desc->sod = ep;
    e306:	6020      	str	r0, [r4, #0]
	if (NULL != ep) {
    e308:	2800      	cmp	r0, #0
    e30a:	d0e0      	beq.n	e2ce <hid_mouse_ctrl+0x16>
	return (ptr[0] + (ptr[1] << 8));
    e30c:	7943      	ldrb	r3, [r0, #5]
    e30e:	7902      	ldrb	r2, [r0, #4]
		ep_desc.bEndpointAddress = ep[2];
    e310:	7885      	ldrb	r5, [r0, #2]
		if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e312:	78c1      	ldrb	r1, [r0, #3]
    e314:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    e318:	b292      	uxth	r2, r2
    e31a:	4b1e      	ldr	r3, [pc, #120]	; (e394 <hid_mouse_ctrl+0xdc>)
    e31c:	4628      	mov	r0, r5
    e31e:	4798      	blx	r3
    e320:	4604      	mov	r4, r0
    e322:	bb58      	cbnz	r0, e37c <hid_mouse_ctrl+0xc4>
		if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    e324:	062b      	lsls	r3, r5, #24
    e326:	d52c      	bpl.n	e382 <hid_mouse_ctrl+0xca>
			usb_d_ep_enable(func_data->func_ep_in);
    e328:	4b1b      	ldr	r3, [pc, #108]	; (e398 <hid_mouse_ctrl+0xe0>)
			func_data->func_ep_in = ep_desc.bEndpointAddress;
    e32a:	7275      	strb	r5, [r6, #9]
			usb_d_ep_enable(func_data->func_ep_in);
    e32c:	4628      	mov	r0, r5
    e32e:	4798      	blx	r3
	_hiddf_mouse_funcd.protocol = 1;
    e330:	f240 1301 	movw	r3, #257	; 0x101
    e334:	817b      	strh	r3, [r7, #10]
	return ERR_NONE;
    e336:	e7cc      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
		return hid_mouse_disable(drv, (struct usbd_descriptors *)param);
    e338:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    e33a:	b11a      	cbz	r2, e344 <hid_mouse_ctrl+0x8c>
		ifc_desc.bInterfaceClass = desc->sod[5];
    e33c:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    e33e:	795b      	ldrb	r3, [r3, #5]
    e340:	2b03      	cmp	r3, #3
    e342:	d1c4      	bne.n	e2ce <hid_mouse_ctrl+0x16>
	if (func_data->func_iface != 0xFF) {
    e344:	7a2b      	ldrb	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    e346:	7a68      	ldrb	r0, [r5, #9]
	if (func_data->func_iface != 0xFF) {
    e348:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    e34a:	bf1c      	itt	ne
    e34c:	23ff      	movne	r3, #255	; 0xff
    e34e:	722b      	strbne	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    e350:	28ff      	cmp	r0, #255	; 0xff
    e352:	d003      	beq.n	e35c <hid_mouse_ctrl+0xa4>
		usb_d_ep_deinit(func_data->func_ep_in);
    e354:	4b11      	ldr	r3, [pc, #68]	; (e39c <hid_mouse_ctrl+0xe4>)
    e356:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    e358:	23ff      	movs	r3, #255	; 0xff
    e35a:	726b      	strb	r3, [r5, #9]
	_hiddf_mouse_funcd.enabled = false;
    e35c:	4b0a      	ldr	r3, [pc, #40]	; (e388 <hid_mouse_ctrl+0xd0>)
    e35e:	2400      	movs	r4, #0
    e360:	72dc      	strb	r4, [r3, #11]
	return ERR_NONE;
    e362:	e7b6      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
		return ERR_UNSUPPORTED_OP;
    e364:	f06f 041a 	mvn.w	r4, #26
    e368:	e7b3      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
	switch (ctrl) {
    e36a:	f06f 040c 	mvn.w	r4, #12
    e36e:	e7b0      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
			return ERR_ALREADY_INITIALIZED;
    e370:	f06f 0411 	mvn.w	r4, #17
    e374:	e7ad      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
			return ERR_NO_RESOURCE;
    e376:	f06f 041b 	mvn.w	r4, #27
    e37a:	e7aa      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
			return ERR_NOT_INITIALIZED;
    e37c:	f06f 0413 	mvn.w	r4, #19
    e380:	e7a7      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
			return ERR_INVALID_DATA;
    e382:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    e386:	e7a4      	b.n	e2d2 <hid_mouse_ctrl+0x1a>
    e388:	200089a8 	.word	0x200089a8
    e38c:	0000bbdd 	.word	0x0000bbdd
    e390:	0000bbf7 	.word	0x0000bbf7
    e394:	0000f911 	.word	0x0000f911
    e398:	0000f9a1 	.word	0x0000f9a1
    e39c:	0000f975 	.word	0x0000f975

0000e3a0 <hiddf_mouse_init>:

/**
 * \brief Initialize the USB HID Mouse Function Driver
 */
int32_t hiddf_mouse_init(void)
{
    e3a0:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    e3a2:	4b0a      	ldr	r3, [pc, #40]	; (e3cc <hiddf_mouse_init+0x2c>)
    e3a4:	4798      	blx	r3
    e3a6:	2801      	cmp	r0, #1
    e3a8:	d80c      	bhi.n	e3c4 <hiddf_mouse_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_mouse.ctrl      = hid_mouse_ctrl;
    e3aa:	4809      	ldr	r0, [pc, #36]	; (e3d0 <hiddf_mouse_init+0x30>)
    e3ac:	4b09      	ldr	r3, [pc, #36]	; (e3d4 <hiddf_mouse_init+0x34>)
	_hiddf_mouse.func_data = &_hiddf_mouse_funcd;
    e3ae:	e9c0 3004 	strd	r3, r0, [r0, #16]

	usbdc_register_function(&_hiddf_mouse);
    e3b2:	4b09      	ldr	r3, [pc, #36]	; (e3d8 <hiddf_mouse_init+0x38>)
    e3b4:	300c      	adds	r0, #12
    e3b6:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_mouse_req_h);
    e3b8:	2001      	movs	r0, #1
    e3ba:	4908      	ldr	r1, [pc, #32]	; (e3dc <hiddf_mouse_init+0x3c>)
    e3bc:	4b08      	ldr	r3, [pc, #32]	; (e3e0 <hiddf_mouse_init+0x40>)
    e3be:	4798      	blx	r3
	return ERR_NONE;
    e3c0:	2000      	movs	r0, #0
}
    e3c2:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    e3c4:	f06f 0010 	mvn.w	r0, #16
    e3c8:	e7fb      	b.n	e3c2 <hiddf_mouse_init+0x22>
    e3ca:	bf00      	nop
    e3cc:	00013b49 	.word	0x00013b49
    e3d0:	200089a8 	.word	0x200089a8
    e3d4:	0000e2b9 	.word	0x0000e2b9
    e3d8:	00013af1 	.word	0x00013af1
    e3dc:	200004fc 	.word	0x200004fc
    e3e0:	00013a69 	.word	0x00013a69

0000e3e4 <hiddf_mouse_move>:
 * \param pos     Signed value to move
 * \param type    HID mouse class pointer move type
 * \return Operation status.
 */
int32_t hiddf_mouse_move(int8_t pos, enum hiddf_mouse_move_type type)
{
    e3e4:	b410      	push	{r4}

	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    e3e6:	4c0e      	ldr	r4, [pc, #56]	; (e420 <hiddf_mouse_move+0x3c>)
    e3e8:	2300      	movs	r3, #0

	if (type == HID_MOUSE_X_AXIS_MV) {
    e3ea:	2901      	cmp	r1, #1
	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    e3ec:	6063      	str	r3, [r4, #4]
	if (type == HID_MOUSE_X_AXIS_MV) {
    e3ee:	d109      	bne.n	e404 <hiddf_mouse_move+0x20>
		_hiddf_mouse_funcd.mouse_report.bytes.x_axis_var = pos;
    e3f0:	7160      	strb	r0, [r4, #5]
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
	} else {
		return ERR_INVALID_ARG;
	}

	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e3f2:	7a60      	ldrb	r0, [r4, #9]
    e3f4:	4c0b      	ldr	r4, [pc, #44]	; (e424 <hiddf_mouse_move+0x40>)
    e3f6:	490c      	ldr	r1, [pc, #48]	; (e428 <hiddf_mouse_move+0x44>)
    e3f8:	46a4      	mov	ip, r4
    e3fa:	2300      	movs	r3, #0
}
    e3fc:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e400:	2204      	movs	r2, #4
    e402:	4760      	bx	ip
	} else if (type == HID_MOUSE_Y_AXIS_MV) {
    e404:	2902      	cmp	r1, #2
    e406:	d101      	bne.n	e40c <hiddf_mouse_move+0x28>
		_hiddf_mouse_funcd.mouse_report.bytes.y_axis_var = pos;
    e408:	71a0      	strb	r0, [r4, #6]
    e40a:	e7f2      	b.n	e3f2 <hiddf_mouse_move+0xe>
	} else if (type == HID_MOUSE_SCROLL_MV) {
    e40c:	2903      	cmp	r1, #3
    e40e:	d101      	bne.n	e414 <hiddf_mouse_move+0x30>
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
    e410:	71e0      	strb	r0, [r4, #7]
    e412:	e7ee      	b.n	e3f2 <hiddf_mouse_move+0xe>
}
    e414:	f06f 000c 	mvn.w	r0, #12
    e418:	f85d 4b04 	ldr.w	r4, [sp], #4
    e41c:	4770      	bx	lr
    e41e:	bf00      	nop
    e420:	200089a8 	.word	0x200089a8
    e424:	00013711 	.word	0x00013711
    e428:	200089ac 	.word	0x200089ac

0000e42c <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    e42c:	b900      	cbnz	r0, e430 <assert+0x4>
		__asm("BKPT #0");
    e42e:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    e430:	4770      	bx	lr
	...

0000e434 <_dmac_handler>:
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e434:	4b10      	ldr	r3, [pc, #64]	; (e478 <_dmac_handler+0x44>)
    e436:	8c1a      	ldrh	r2, [r3, #32]
}
/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    e438:	b430      	push	{r4, r5}
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e43a:	8c1d      	ldrh	r5, [r3, #32]
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
	struct _dma_resource *tmp_resource = &_resources[channel];
    e43c:	4c0f      	ldr	r4, [pc, #60]	; (e47c <_dmac_handler+0x48>)
	tmp &= mask;
    e43e:	f002 021f 	and.w	r2, r2, #31
    e442:	210c      	movs	r1, #12
    e444:	4351      	muls	r1, r2

	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e446:	05ed      	lsls	r5, r5, #23
	struct _dma_resource *tmp_resource = &_resources[channel];
    e448:	eb04 0001 	add.w	r0, r4, r1
	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e44c:	d507      	bpl.n	e45e <_dmac_handler+0x2a>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    e44e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e452:	2201      	movs	r2, #1
    e454:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
		tmp_resource->dma_cb.error(tmp_resource);
    e458:	6843      	ldr	r3, [r0, #4]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		tmp_resource->dma_cb.transfer_done(tmp_resource);
	}
}
    e45a:	bc30      	pop	{r4, r5}
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e45c:	4718      	bx	r3
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e45e:	8c1d      	ldrh	r5, [r3, #32]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
    e460:	05ad      	lsls	r5, r5, #22
    e462:	d506      	bpl.n	e472 <_dmac_handler+0x3e>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    e464:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e468:	2202      	movs	r2, #2
    e46a:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e46e:	5863      	ldr	r3, [r4, r1]
    e470:	e7f3      	b.n	e45a <_dmac_handler+0x26>
}
    e472:	bc30      	pop	{r4, r5}
    e474:	4770      	bx	lr
    e476:	bf00      	nop
    e478:	4100a000 	.word	0x4100a000
    e47c:	200089c0 	.word	0x200089c0

0000e480 <_dma_init>:
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    e480:	4b3d      	ldr	r3, [pc, #244]	; (e578 <_dma_init+0xf8>)
    e482:	881a      	ldrh	r2, [r3, #0]
    e484:	f022 0202 	bic.w	r2, r2, #2
    e488:	0412      	lsls	r2, r2, #16
    e48a:	0c12      	lsrs	r2, r2, #16
{
    e48c:	b570      	push	{r4, r5, r6, lr}
    e48e:	801a      	strh	r2, [r3, #0]
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    e490:	885a      	ldrh	r2, [r3, #2]
    e492:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    e496:	0412      	lsls	r2, r2, #16
    e498:	0c12      	lsrs	r2, r2, #16
    e49a:	805a      	strh	r2, [r3, #2]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    e49c:	881a      	ldrh	r2, [r3, #0]
    e49e:	b292      	uxth	r2, r2
    e4a0:	f042 0201 	orr.w	r2, r2, #1
    e4a4:	801a      	strh	r2, [r3, #0]
	tmp = ((Dmac *)hw)->CTRL.reg;
    e4a6:	881a      	ldrh	r2, [r3, #0]
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    e4a8:	f012 0201 	ands.w	r2, r2, #1
    e4ac:	d1fb      	bne.n	e4a6 <_dma_init+0x26>
	((Dmac *)hw)->CTRL.reg = data;
    e4ae:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    e4b2:	8019      	strh	r1, [r3, #0]
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    e4b4:	7b59      	ldrb	r1, [r3, #13]
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    e4b6:	4831      	ldr	r0, [pc, #196]	; (e57c <_dma_init+0xfc>)
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    e4b8:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << DMAC_DBGCTRL_DBGRUN_Pos;
    e4bc:	f041 0101 	orr.w	r1, r1, #1
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    e4c0:	7359      	strb	r1, [r3, #13]
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    e4c2:	492f      	ldr	r1, [pc, #188]	; (e580 <_dma_init+0x100>)
	((Dmac *)hw)->PRICTRL0.reg = data;
    e4c4:	615a      	str	r2, [r3, #20]
	((Dmac *)hw)->BASEADDR.reg = data;
    e4c6:	6358      	str	r0, [r3, #52]	; 0x34
	((Dmac *)hw)->WRBADDR.reg = data;
    e4c8:	6399      	str	r1, [r3, #56]	; 0x38
    e4ca:	4613      	mov	r3, r2
    e4cc:	492d      	ldr	r1, [pc, #180]	; (e584 <_dma_init+0x104>)
    e4ce:	4602      	mov	r2, r0
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e4d0:	461d      	mov	r5, r3
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    e4d2:	011c      	lsls	r4, r3, #4
    e4d4:	f104 4082 	add.w	r0, r4, #1090519040	; 0x41000000
    e4d8:	f500 4020 	add.w	r0, r0, #40960	; 0xa000
    e4dc:	680e      	ldr	r6, [r1, #0]

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    e4de:	6406      	str	r6, [r0, #64]	; 0x40
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    e4e0:	790e      	ldrb	r6, [r1, #4]

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    e4e2:	f880 6045 	strb.w	r6, [r0, #69]	; 0x45
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    e4e6:	794e      	ldrb	r6, [r1, #5]

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    e4e8:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    e4ec:	3301      	adds	r3, #1
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    e4ee:	1910      	adds	r0, r2, r4
    e4f0:	88ce      	ldrh	r6, [r1, #6]
    e4f2:	5316      	strh	r6, [r2, r4]
	for (i = 0; i < DMAC_CH_NUM; i++) {
    e4f4:	2b20      	cmp	r3, #32
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    e4f6:	60c5      	str	r5, [r0, #12]
    e4f8:	f101 0108 	add.w	r1, r1, #8
    e4fc:	d1e9      	bne.n	e4d2 <_dma_init+0x52>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e4fe:	4b22      	ldr	r3, [pc, #136]	; (e588 <_dma_init+0x108>)
    e500:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    e504:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    e508:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e50c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e510:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e514:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e516:	2201      	movs	r2, #1
    e518:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e51c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e520:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e524:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e528:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e52a:	2202      	movs	r2, #2
    e52c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e530:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e534:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e538:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e53c:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e53e:	2204      	movs	r2, #4
    e540:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e544:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e548:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e54c:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e550:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e552:	2208      	movs	r2, #8
    e554:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    e558:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    e55c:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e560:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    e564:	605a      	str	r2, [r3, #4]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    e566:	4a04      	ldr	r2, [pc, #16]	; (e578 <_dma_init+0xf8>)
    e568:	8813      	ldrh	r3, [r2, #0]
    e56a:	b29b      	uxth	r3, r3
    e56c:	f043 0302 	orr.w	r3, r3, #2
    e570:	8013      	strh	r3, [r2, #0]
}
    e572:	2000      	movs	r0, #0
    e574:	bd70      	pop	{r4, r5, r6, pc}
    e576:	bf00      	nop
    e578:	4100a000 	.word	0x4100a000
    e57c:	2001c870 	.word	0x2001c870
    e580:	2001ca70 	.word	0x2001ca70
    e584:	00016894 	.word	0x00016894
    e588:	e000e100 	.word	0xe000e100

0000e58c <_dma_set_irq_state>:
	if (DMA_TRANSFER_COMPLETE_CB == type) {
    e58c:	b939      	cbnz	r1, e59e <_dma_set_irq_state+0x12>
	if (value == 0x0) {
    e58e:	4b08      	ldr	r3, [pc, #32]	; (e5b0 <_dma_set_irq_state+0x24>)
    e590:	0100      	lsls	r0, r0, #4
    e592:	2102      	movs	r1, #2
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e594:	4418      	add	r0, r3
	if (value == 0x0) {
    e596:	b93a      	cbnz	r2, e5a8 <_dma_set_irq_state+0x1c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    e598:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
    e59c:	4770      	bx	lr
	} else if (DMA_TRANSFER_ERROR_CB == type) {
    e59e:	2901      	cmp	r1, #1
    e5a0:	d104      	bne.n	e5ac <_dma_set_irq_state+0x20>
	if (value == 0x0) {
    e5a2:	4b03      	ldr	r3, [pc, #12]	; (e5b0 <_dma_set_irq_state+0x24>)
    e5a4:	0100      	lsls	r0, r0, #4
    e5a6:	e7f5      	b.n	e594 <_dma_set_irq_state+0x8>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
    e5a8:	f880 104d 	strb.w	r1, [r0, #77]	; 0x4d
}
    e5ac:	4770      	bx	lr
    e5ae:	bf00      	nop
    e5b0:	4100a000 	.word	0x4100a000

0000e5b4 <_dma_set_destination_address>:
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e5b4:	4b02      	ldr	r3, [pc, #8]	; (e5c0 <_dma_set_destination_address+0xc>)
    e5b6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e5ba:	6081      	str	r1, [r0, #8]
}
    e5bc:	2000      	movs	r0, #0
    e5be:	4770      	bx	lr
    e5c0:	2001c870 	.word	0x2001c870

0000e5c4 <_dma_set_source_address>:
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e5c4:	4b02      	ldr	r3, [pc, #8]	; (e5d0 <_dma_set_source_address+0xc>)
    e5c6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e5ca:	6041      	str	r1, [r0, #4]
}
    e5cc:	2000      	movs	r0, #0
    e5ce:	4770      	bx	lr
    e5d0:	2001c870 	.word	0x2001c870

0000e5d4 <_dma_srcinc_enable>:
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e5d4:	4a05      	ldr	r2, [pc, #20]	; (e5ec <_dma_srcinc_enable+0x18>)
    e5d6:	0100      	lsls	r0, r0, #4
    e5d8:	5a13      	ldrh	r3, [r2, r0]
    e5da:	b29b      	uxth	r3, r3
	tmp &= ~DMAC_BTCTRL_SRCINC;
    e5dc:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
	tmp |= value << DMAC_BTCTRL_SRCINC_Pos;
    e5e0:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
    e5e4:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->BTCTRL.reg = tmp;
    e5e6:	5211      	strh	r1, [r2, r0]
}
    e5e8:	2000      	movs	r0, #0
    e5ea:	4770      	bx	lr
    e5ec:	2001c870 	.word	0x2001c870

0000e5f0 <_dma_set_data_amount>:
	return ((DmacDescriptor *)hw)->DSTADDR.reg;
    e5f0:	4b0f      	ldr	r3, [pc, #60]	; (e630 <_dma_set_data_amount+0x40>)
{
    e5f2:	b570      	push	{r4, r5, r6, lr}
    e5f4:	0104      	lsls	r4, r0, #4
    e5f6:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    e5fa:	6886      	ldr	r6, [r0, #8]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e5fc:	5b1a      	ldrh	r2, [r3, r4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e5fe:	5b1d      	ldrh	r5, [r3, r4]
	tmp = (tmp & DMAC_BTCTRL_BEATSIZE_Msk) >> DMAC_BTCTRL_BEATSIZE_Pos;
    e600:	f3c2 2201 	ubfx	r2, r2, #8, #2
	if (hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(&_descriptor_section[channel])) {
    e604:	052d      	lsls	r5, r5, #20
		hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e606:	bf42      	ittt	mi
    e608:	fa01 f502 	lslmi.w	r5, r1, r2
    e60c:	19ad      	addmi	r5, r5, r6
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    e60e:	6085      	strmi	r5, [r0, #8]
	return ((DmacDescriptor *)hw)->SRCADDR.reg;
    e610:	1918      	adds	r0, r3, r4
    e612:	6845      	ldr	r5, [r0, #4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    e614:	5b1e      	ldrh	r6, [r3, r4]
	if (hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(&_descriptor_section[channel])) {
    e616:	0576      	lsls	r6, r6, #21
		hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    e618:	bf48      	it	mi
    e61a:	fa01 f202 	lslmi.w	r2, r1, r2
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e61e:	4423      	add	r3, r4
    e620:	bf48      	it	mi
    e622:	1952      	addmi	r2, r2, r5
	hri_dmacdescriptor_write_BTCNT_reg(&_descriptor_section[channel], amount);
    e624:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    e626:	bf48      	it	mi
    e628:	6042      	strmi	r2, [r0, #4]
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    e62a:	8059      	strh	r1, [r3, #2]
}
    e62c:	2000      	movs	r0, #0
    e62e:	bd70      	pop	{r4, r5, r6, pc}
    e630:	2001c870 	.word	0x2001c870

0000e634 <_dma_enable_transaction>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_VALID;
    e634:	0102      	lsls	r2, r0, #4
{
    e636:	b510      	push	{r4, lr}
    e638:	4c0b      	ldr	r4, [pc, #44]	; (e668 <_dma_enable_transaction+0x34>)
    e63a:	5aa3      	ldrh	r3, [r4, r2]
    e63c:	b29b      	uxth	r3, r3
    e63e:	f043 0301 	orr.w	r3, r3, #1
    e642:	52a3      	strh	r3, [r4, r2]
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    e644:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    e648:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    e64c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    e64e:	f042 0202 	orr.w	r2, r2, #2
    e652:	641a      	str	r2, [r3, #64]	; 0x40
	if (software_trigger) {
    e654:	b131      	cbz	r1, e664 <_dma_enable_transaction+0x30>
	((Dmac *)hw)->SWTRIGCTRL.reg |= mask;
    e656:	4a05      	ldr	r2, [pc, #20]	; (e66c <_dma_enable_transaction+0x38>)
		hri_dmac_set_SWTRIGCTRL_reg(DMAC, 1 << channel);
    e658:	2301      	movs	r3, #1
    e65a:	6911      	ldr	r1, [r2, #16]
    e65c:	fa03 f000 	lsl.w	r0, r3, r0
    e660:	4308      	orrs	r0, r1
    e662:	6110      	str	r0, [r2, #16]
}
    e664:	2000      	movs	r0, #0
    e666:	bd10      	pop	{r4, pc}
    e668:	2001c870 	.word	0x2001c870
    e66c:	4100a000 	.word	0x4100a000

0000e670 <_dma_get_channel_resource>:
	*resource = &_resources[channel];
    e670:	4b03      	ldr	r3, [pc, #12]	; (e680 <_dma_get_channel_resource+0x10>)
    e672:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    e676:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    e67a:	6001      	str	r1, [r0, #0]
}
    e67c:	2000      	movs	r0, #0
    e67e:	4770      	bx	lr
    e680:	200089c0 	.word	0x200089c0

0000e684 <DMAC_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void DMAC_0_Handler(void)
{
	_dmac_handler();
    e684:	4b00      	ldr	r3, [pc, #0]	; (e688 <DMAC_0_Handler+0x4>)
    e686:	4718      	bx	r3
    e688:	0000e435 	.word	0x0000e435

0000e68c <DMAC_1_Handler>:
    e68c:	4b00      	ldr	r3, [pc, #0]	; (e690 <DMAC_1_Handler+0x4>)
    e68e:	4718      	bx	r3
    e690:	0000e435 	.word	0x0000e435

0000e694 <DMAC_2_Handler>:
    e694:	4b00      	ldr	r3, [pc, #0]	; (e698 <DMAC_2_Handler+0x4>)
    e696:	4718      	bx	r3
    e698:	0000e435 	.word	0x0000e435

0000e69c <DMAC_3_Handler>:
    e69c:	4b00      	ldr	r3, [pc, #0]	; (e6a0 <DMAC_3_Handler+0x4>)
    e69e:	4718      	bx	r3
    e6a0:	0000e435 	.word	0x0000e435

0000e6a4 <DMAC_4_Handler>:
    e6a4:	4b00      	ldr	r3, [pc, #0]	; (e6a8 <DMAC_4_Handler+0x4>)
    e6a6:	4718      	bx	r3
    e6a8:	0000e435 	.word	0x0000e435

0000e6ac <adc_async_window_threshold_reached>:

static void adc_async_window_threshold_reached(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.monitor) {
    e6ac:	6983      	ldr	r3, [r0, #24]
    e6ae:	b103      	cbz	r3, e6b2 <adc_async_window_threshold_reached+0x6>
		descr->adc_async_cb.monitor(descr, channel);
    e6b0:	4718      	bx	r3
	}
}
    e6b2:	4770      	bx	lr

0000e6b4 <adc_async_error_occured>:

static void adc_async_error_occured(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.error) {
    e6b4:	69c3      	ldr	r3, [r0, #28]
    e6b6:	b103      	cbz	r3, e6ba <adc_async_error_occured+0x6>
		descr->adc_async_cb.error(descr, channel);
    e6b8:	4718      	bx	r3
	}
}
    e6ba:	4770      	bx	lr

0000e6bc <adc_async_channel_conversion_done>:
{
    e6bc:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t                              index    = descr->channel_map[channel];
    e6c0:	6a03      	ldr	r3, [r0, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e6c2:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
    e6c6:	5c5c      	ldrb	r4, [r3, r1]
	ringbuffer_put(&descr_ch->convert, data);
    e6c8:	f8df a054 	ldr.w	sl, [pc, #84]	; e720 <adc_async_channel_conversion_done+0x64>
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e6cc:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    e6d0:	ea4f 09c4 	mov.w	r9, r4, lsl #3
    e6d4:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
	ringbuffer_put(&descr_ch->convert, data);
    e6d8:	f104 0b04 	add.w	fp, r4, #4
{
    e6dc:	4605      	mov	r5, r0
    e6de:	460e      	mov	r6, r1
	ringbuffer_put(&descr_ch->convert, data);
    e6e0:	4658      	mov	r0, fp
    e6e2:	b2d1      	uxtb	r1, r2
{
    e6e4:	4617      	mov	r7, r2
	ringbuffer_put(&descr_ch->convert, data);
    e6e6:	47d0      	blx	sl
	if (1 < _adc_async_get_data_size(&descr->device)) {
    e6e8:	4b0c      	ldr	r3, [pc, #48]	; (e71c <adc_async_channel_conversion_done+0x60>)
    e6ea:	4628      	mov	r0, r5
    e6ec:	4798      	blx	r3
    e6ee:	2801      	cmp	r0, #1
    e6f0:	d905      	bls.n	e6fe <adc_async_channel_conversion_done+0x42>
		ringbuffer_put(&descr_ch->convert, data >> 8);
    e6f2:	0a39      	lsrs	r1, r7, #8
    e6f4:	4658      	mov	r0, fp
    e6f6:	47d0      	blx	sl
		++descr_ch->bytes_in_buffer;
    e6f8:	8aa3      	ldrh	r3, [r4, #20]
    e6fa:	3301      	adds	r3, #1
    e6fc:	82a3      	strh	r3, [r4, #20]
	++descr_ch->bytes_in_buffer;
    e6fe:	8aa3      	ldrh	r3, [r4, #20]
    e700:	3301      	adds	r3, #1
    e702:	82a3      	strh	r3, [r4, #20]
	if (descr_ch->adc_async_ch_cb.convert_done) {
    e704:	f858 3009 	ldr.w	r3, [r8, r9]
    e708:	b12b      	cbz	r3, e716 <adc_async_channel_conversion_done+0x5a>
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e70a:	4631      	mov	r1, r6
    e70c:	4628      	mov	r0, r5
}
    e70e:	b001      	add	sp, #4
    e710:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    e714:	4718      	bx	r3
}
    e716:	b001      	add	sp, #4
    e718:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e71c:	00013491 	.word	0x00013491
    e720:	00011e91 	.word	0x00011e91

0000e724 <adc_async_init>:
{
    e724:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    e728:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    e72c:	f89d 8020 	ldrb.w	r8, [sp, #32]
    e730:	460e      	mov	r6, r1
    e732:	4615      	mov	r5, r2
    e734:	461f      	mov	r7, r3
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e736:	4604      	mov	r4, r0
    e738:	b150      	cbz	r0, e750 <adc_async_init+0x2c>
    e73a:	2900      	cmp	r1, #0
    e73c:	d032      	beq.n	e7a4 <adc_async_init+0x80>
    e73e:	2a00      	cmp	r2, #0
    e740:	d032      	beq.n	e7a8 <adc_async_init+0x84>
    e742:	f1b8 0f00 	cmp.w	r8, #0
    e746:	d031      	beq.n	e7ac <adc_async_init+0x88>
    e748:	f1b9 0000 	subs.w	r0, r9, #0
    e74c:	bf18      	it	ne
    e74e:	2001      	movne	r0, #1
    e750:	4917      	ldr	r1, [pc, #92]	; (e7b0 <adc_async_init+0x8c>)
    e752:	f8df a070 	ldr.w	sl, [pc, #112]	; e7c4 <adc_async_init+0xa0>
    e756:	223f      	movs	r2, #63	; 0x3f
    e758:	47d0      	blx	sl
	ASSERT(channel_amount <= (channel_max + 1));
    e75a:	1c78      	adds	r0, r7, #1
    e75c:	4580      	cmp	r8, r0
    e75e:	4914      	ldr	r1, [pc, #80]	; (e7b0 <adc_async_init+0x8c>)
    e760:	f04f 0240 	mov.w	r2, #64	; 0x40
    e764:	bfcc      	ite	gt
    e766:	2000      	movgt	r0, #0
    e768:	2001      	movle	r0, #1
    e76a:	47d0      	blx	sl
	device = &descr->device;
    e76c:	2300      	movs	r3, #0
		channel_map[i] = 0xFF;
    e76e:	21ff      	movs	r1, #255	; 0xff
    e770:	b2da      	uxtb	r2, r3
    e772:	3301      	adds	r3, #1
    e774:	54a9      	strb	r1, [r5, r2]
	for (uint8_t i = 0; i <= channel_max; i++) {
    e776:	b2da      	uxtb	r2, r3
    e778:	4297      	cmp	r7, r2
    e77a:	d2f9      	bcs.n	e770 <adc_async_init+0x4c>
	init_status           = _adc_async_init(device, hw);
    e77c:	4b0d      	ldr	r3, [pc, #52]	; (e7b4 <adc_async_init+0x90>)
	descr->channel_map    = channel_map;
    e77e:	6225      	str	r5, [r4, #32]
	descr->channel_max    = channel_max;
    e780:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	descr->channel_amount = channel_amount;
    e784:	f884 8025 	strb.w	r8, [r4, #37]	; 0x25
	descr->descr_ch       = descr_ch;
    e788:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	init_status           = _adc_async_init(device, hw);
    e78c:	4631      	mov	r1, r6
    e78e:	4620      	mov	r0, r4
    e790:	4798      	blx	r3
	if (init_status) {
    e792:	b928      	cbnz	r0, e7a0 <adc_async_init+0x7c>
	device->adc_async_ch_cb.convert_done = adc_async_channel_conversion_done;
    e794:	4b08      	ldr	r3, [pc, #32]	; (e7b8 <adc_async_init+0x94>)
    e796:	60a3      	str	r3, [r4, #8]
	device->adc_async_cb.window_cb       = adc_async_window_threshold_reached;
    e798:	4b08      	ldr	r3, [pc, #32]	; (e7bc <adc_async_init+0x98>)
    e79a:	6023      	str	r3, [r4, #0]
	device->adc_async_cb.error_cb        = adc_async_error_occured;
    e79c:	4b08      	ldr	r3, [pc, #32]	; (e7c0 <adc_async_init+0x9c>)
    e79e:	6063      	str	r3, [r4, #4]
}
    e7a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    e7a4:	4608      	mov	r0, r1
    e7a6:	e7d3      	b.n	e750 <adc_async_init+0x2c>
    e7a8:	4610      	mov	r0, r2
    e7aa:	e7d1      	b.n	e750 <adc_async_init+0x2c>
    e7ac:	4640      	mov	r0, r8
    e7ae:	e7cf      	b.n	e750 <adc_async_init+0x2c>
    e7b0:	00016994 	.word	0x00016994
    e7b4:	000133b9 	.word	0x000133b9
    e7b8:	0000e6bd 	.word	0x0000e6bd
    e7bc:	0000e6ad 	.word	0x0000e6ad
    e7c0:	0000e6b5 	.word	0x0000e6b5
    e7c4:	0000e42d 	.word	0x0000e42d

0000e7c8 <adc_async_register_channel_buffer>:
{
    e7c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    e7cc:	460e      	mov	r6, r1
    e7ce:	4617      	mov	r7, r2
    e7d0:	4698      	mov	r8, r3
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e7d2:	4604      	mov	r4, r0
    e7d4:	b118      	cbz	r0, e7de <adc_async_register_channel_buffer+0x16>
    e7d6:	b1c2      	cbz	r2, e80a <adc_async_register_channel_buffer+0x42>
    e7d8:	1e18      	subs	r0, r3, #0
    e7da:	bf18      	it	ne
    e7dc:	2001      	movne	r0, #1
    e7de:	4921      	ldr	r1, [pc, #132]	; (e864 <adc_async_register_channel_buffer+0x9c>)
    e7e0:	4d21      	ldr	r5, [pc, #132]	; (e868 <adc_async_register_channel_buffer+0xa0>)
    e7e2:	2266      	movs	r2, #102	; 0x66
    e7e4:	47a8      	blx	r5
	ASSERT(descr->channel_max >= channel);
    e7e6:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e7ea:	491e      	ldr	r1, [pc, #120]	; (e864 <adc_async_register_channel_buffer+0x9c>)
    e7ec:	42b0      	cmp	r0, r6
    e7ee:	f04f 0267 	mov.w	r2, #103	; 0x67
    e7f2:	bf34      	ite	cc
    e7f4:	2000      	movcc	r0, #0
    e7f6:	2001      	movcs	r0, #1
    e7f8:	47a8      	blx	r5
	if (descr->channel_map[channel] != 0xFF) {
    e7fa:	6a23      	ldr	r3, [r4, #32]
    e7fc:	5d9a      	ldrb	r2, [r3, r6]
    e7fe:	2aff      	cmp	r2, #255	; 0xff
    e800:	d005      	beq.n	e80e <adc_async_register_channel_buffer+0x46>
		return ERR_INVALID_ARG;
    e802:	f06f 000c 	mvn.w	r0, #12
}
    e806:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && convert_buffer && convert_buffer_length);
    e80a:	4610      	mov	r0, r2
    e80c:	e7e7      	b.n	e7de <adc_async_register_channel_buffer+0x16>
	for (i = 0; i <= descr->channel_max; i++) {
    e80e:	2200      	movs	r2, #0
    e810:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	uint8_t i, index = 0;
    e814:	4615      	mov	r5, r2
		if (descr->channel_map[i] != 0xFF) {
    e816:	b2d1      	uxtb	r1, r2
    e818:	3201      	adds	r2, #1
    e81a:	5c59      	ldrb	r1, [r3, r1]
    e81c:	29ff      	cmp	r1, #255	; 0xff
			index++;
    e81e:	bf18      	it	ne
    e820:	3501      	addne	r5, #1
	for (i = 0; i <= descr->channel_max; i++) {
    e822:	b2d1      	uxtb	r1, r2
			index++;
    e824:	bf18      	it	ne
    e826:	b2ed      	uxtbne	r5, r5
	for (i = 0; i <= descr->channel_max; i++) {
    e828:	4288      	cmp	r0, r1
    e82a:	d2f4      	bcs.n	e816 <adc_async_register_channel_buffer+0x4e>
	if (index > descr->channel_amount) {
    e82c:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    e830:	42ab      	cmp	r3, r5
    e832:	d313      	bcc.n	e85c <adc_async_register_channel_buffer+0x94>
	if (ERR_NONE != ringbuffer_init(&descr->descr_ch[index].convert, convert_buffer, convert_buffer_length)) {
    e834:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    e836:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    e83a:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    e83e:	ea4f 09c3 	mov.w	r9, r3, lsl #3
    e842:	4642      	mov	r2, r8
    e844:	4b09      	ldr	r3, [pc, #36]	; (e86c <adc_async_register_channel_buffer+0xa4>)
    e846:	4639      	mov	r1, r7
    e848:	3004      	adds	r0, #4
    e84a:	4798      	blx	r3
    e84c:	2800      	cmp	r0, #0
    e84e:	d1d8      	bne.n	e802 <adc_async_register_channel_buffer+0x3a>
	descr->channel_map[channel]            = index;
    e850:	6a23      	ldr	r3, [r4, #32]
    e852:	559d      	strb	r5, [r3, r6]
	descr->descr_ch[index].bytes_in_buffer = 0;
    e854:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e856:	444b      	add	r3, r9
    e858:	8298      	strh	r0, [r3, #20]
	return ERR_NONE;
    e85a:	e7d4      	b.n	e806 <adc_async_register_channel_buffer+0x3e>
		return ERR_NO_RESOURCE;
    e85c:	f06f 001b 	mvn.w	r0, #27
    e860:	e7d1      	b.n	e806 <adc_async_register_channel_buffer+0x3e>
    e862:	bf00      	nop
    e864:	00016994 	.word	0x00016994
    e868:	0000e42d 	.word	0x0000e42d
    e86c:	00011e15 	.word	0x00011e15

0000e870 <adc_async_enable_channel>:
{
    e870:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    e872:	4604      	mov	r4, r0
    e874:	3800      	subs	r0, #0
{
    e876:	460d      	mov	r5, r1
	ASSERT(descr);
    e878:	bf18      	it	ne
    e87a:	2001      	movne	r0, #1
    e87c:	4e09      	ldr	r6, [pc, #36]	; (e8a4 <adc_async_enable_channel+0x34>)
    e87e:	490a      	ldr	r1, [pc, #40]	; (e8a8 <adc_async_enable_channel+0x38>)
    e880:	2283      	movs	r2, #131	; 0x83
    e882:	47b0      	blx	r6
	ASSERT(descr->channel_max >= channel);
    e884:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e888:	4907      	ldr	r1, [pc, #28]	; (e8a8 <adc_async_enable_channel+0x38>)
    e88a:	42a8      	cmp	r0, r5
    e88c:	bf34      	ite	cc
    e88e:	2000      	movcc	r0, #0
    e890:	2001      	movcs	r0, #1
    e892:	2284      	movs	r2, #132	; 0x84
    e894:	47b0      	blx	r6
	_adc_async_enable_channel(&descr->device, channel);
    e896:	4620      	mov	r0, r4
    e898:	4b04      	ldr	r3, [pc, #16]	; (e8ac <adc_async_enable_channel+0x3c>)
    e89a:	4629      	mov	r1, r5
    e89c:	4798      	blx	r3
}
    e89e:	2000      	movs	r0, #0
    e8a0:	bd70      	pop	{r4, r5, r6, pc}
    e8a2:	bf00      	nop
    e8a4:	0000e42d 	.word	0x0000e42d
    e8a8:	00016994 	.word	0x00016994
    e8ac:	00013485 	.word	0x00013485

0000e8b0 <adc_async_register_callback>:
{
    e8b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(descr);
    e8b4:	4604      	mov	r4, r0
    e8b6:	3800      	subs	r0, #0
    e8b8:	bf18      	it	ne
    e8ba:	2001      	movne	r0, #1
    e8bc:	f8df 8064 	ldr.w	r8, [pc, #100]	; e924 <adc_async_register_callback+0x74>
{
    e8c0:	460f      	mov	r7, r1
    e8c2:	4615      	mov	r5, r2
	ASSERT(descr);
    e8c4:	4915      	ldr	r1, [pc, #84]	; (e91c <adc_async_register_callback+0x6c>)
    e8c6:	229c      	movs	r2, #156	; 0x9c
{
    e8c8:	461e      	mov	r6, r3
	ASSERT(descr);
    e8ca:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e8cc:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e8d0:	4912      	ldr	r1, [pc, #72]	; (e91c <adc_async_register_callback+0x6c>)
    e8d2:	42b8      	cmp	r0, r7
    e8d4:	bf34      	ite	cc
    e8d6:	2000      	movcc	r0, #0
    e8d8:	2001      	movcs	r0, #1
    e8da:	229d      	movs	r2, #157	; 0x9d
    e8dc:	47c0      	blx	r8
	switch (type) {
    e8de:	2d01      	cmp	r5, #1
    e8e0:	d014      	beq.n	e90c <adc_async_register_callback+0x5c>
    e8e2:	2d02      	cmp	r5, #2
    e8e4:	d014      	beq.n	e910 <adc_async_register_callback+0x60>
    e8e6:	b9ad      	cbnz	r5, e914 <adc_async_register_callback+0x64>
	uint8_t index = descr->channel_map[channel];
    e8e8:	6a23      	ldr	r3, [r4, #32]
		descr->descr_ch[index].adc_async_ch_cb.convert_done = cb;
    e8ea:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    e8ec:	5ddb      	ldrb	r3, [r3, r7]
    e8ee:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    e8f2:	f842 6033 	str.w	r6, [r2, r3, lsl #3]
	_adc_async_set_irq_state(&descr->device, channel, (enum _adc_async_callback_type)type, cb != NULL);
    e8f6:	1e33      	subs	r3, r6, #0
    e8f8:	4620      	mov	r0, r4
    e8fa:	bf18      	it	ne
    e8fc:	2301      	movne	r3, #1
    e8fe:	4c08      	ldr	r4, [pc, #32]	; (e920 <adc_async_register_callback+0x70>)
    e900:	462a      	mov	r2, r5
    e902:	4639      	mov	r1, r7
    e904:	47a0      	blx	r4
	return ERR_NONE;
    e906:	2000      	movs	r0, #0
}
    e908:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		descr->adc_async_cb.monitor = cb;
    e90c:	61a6      	str	r6, [r4, #24]
		break;
    e90e:	e7f2      	b.n	e8f6 <adc_async_register_callback+0x46>
		descr->adc_async_cb.error = cb;
    e910:	61e6      	str	r6, [r4, #28]
		break;
    e912:	e7f0      	b.n	e8f6 <adc_async_register_callback+0x46>
	switch (type) {
    e914:	f06f 000c 	mvn.w	r0, #12
    e918:	e7f6      	b.n	e908 <adc_async_register_callback+0x58>
    e91a:	bf00      	nop
    e91c:	00016994 	.word	0x00016994
    e920:	000134bd 	.word	0x000134bd
    e924:	0000e42d 	.word	0x0000e42d

0000e928 <adc_async_read_channel>:
{
    e928:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    e92c:	460e      	mov	r6, r1
    e92e:	4617      	mov	r7, r2
    e930:	461d      	mov	r5, r3
	ASSERT(descr && buffer && length);
    e932:	4604      	mov	r4, r0
    e934:	b120      	cbz	r0, e940 <adc_async_read_channel+0x18>
    e936:	2a00      	cmp	r2, #0
    e938:	d03f      	beq.n	e9ba <adc_async_read_channel+0x92>
    e93a:	1e18      	subs	r0, r3, #0
    e93c:	bf18      	it	ne
    e93e:	2001      	movne	r0, #1
    e940:	f8df 8098 	ldr.w	r8, [pc, #152]	; e9dc <adc_async_read_channel+0xb4>
    e944:	4920      	ldr	r1, [pc, #128]	; (e9c8 <adc_async_read_channel+0xa0>)
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e946:	f8df a098 	ldr.w	sl, [pc, #152]	; e9e0 <adc_async_read_channel+0xb8>
	ASSERT(descr && buffer && length);
    e94a:	22bc      	movs	r2, #188	; 0xbc
    e94c:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    e94e:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    e952:	491d      	ldr	r1, [pc, #116]	; (e9c8 <adc_async_read_channel+0xa0>)
    e954:	42b0      	cmp	r0, r6
    e956:	bf34      	ite	cc
    e958:	2000      	movcc	r0, #0
    e95a:	2001      	movcs	r0, #1
    e95c:	22bd      	movs	r2, #189	; 0xbd
    e95e:	47c0      	blx	r8
	data_size = _adc_async_get_data_size(&descr->device);
    e960:	4b1a      	ldr	r3, [pc, #104]	; (e9cc <adc_async_read_channel+0xa4>)
    e962:	4620      	mov	r0, r4
    e964:	4798      	blx	r3
	ASSERT(!(length % data_size));
    e966:	fbb5 f3f0 	udiv	r3, r5, r0
    e96a:	fb03 5010 	mls	r0, r3, r0, r5
    e96e:	fab0 f080 	clz	r0, r0
    e972:	4915      	ldr	r1, [pc, #84]	; (e9c8 <adc_async_read_channel+0xa0>)
    e974:	22bf      	movs	r2, #191	; 0xbf
    e976:	0940      	lsrs	r0, r0, #5
    e978:	47c0      	blx	r8
	index                                         = descr->channel_map[channel];
    e97a:	6a23      	ldr	r3, [r4, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    e97c:	5d9e      	ldrb	r6, [r3, r6]
    e97e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    e980:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    e984:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
	CRITICAL_SECTION_ENTER()
    e988:	a801      	add	r0, sp, #4
    e98a:	4b11      	ldr	r3, [pc, #68]	; (e9d0 <adc_async_read_channel+0xa8>)
	num = ringbuffer_num(&descr_ch->convert);
    e98c:	f106 0904 	add.w	r9, r6, #4
	CRITICAL_SECTION_ENTER()
    e990:	4798      	blx	r3
	num = ringbuffer_num(&descr_ch->convert);
    e992:	4b10      	ldr	r3, [pc, #64]	; (e9d4 <adc_async_read_channel+0xac>)
    e994:	4648      	mov	r0, r9
    e996:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    e998:	4b0f      	ldr	r3, [pc, #60]	; (e9d8 <adc_async_read_channel+0xb0>)
	num = ringbuffer_num(&descr_ch->convert);
    e99a:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
    e99c:	a801      	add	r0, sp, #4
    e99e:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    e9a0:	2400      	movs	r4, #0
    e9a2:	45a0      	cmp	r8, r4
    e9a4:	b2a2      	uxth	r2, r4
    e9a6:	d001      	beq.n	e9ac <adc_async_read_channel+0x84>
    e9a8:	42a5      	cmp	r5, r4
    e9aa:	d108      	bne.n	e9be <adc_async_read_channel+0x96>
	descr_ch->bytes_in_buffer -= was_read;
    e9ac:	8ab3      	ldrh	r3, [r6, #20]
}
    e9ae:	4620      	mov	r0, r4
	descr_ch->bytes_in_buffer -= was_read;
    e9b0:	1a9b      	subs	r3, r3, r2
    e9b2:	82b3      	strh	r3, [r6, #20]
}
    e9b4:	b002      	add	sp, #8
    e9b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && buffer && length);
    e9ba:	4610      	mov	r0, r2
    e9bc:	e7c0      	b.n	e940 <adc_async_read_channel+0x18>
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    e9be:	1939      	adds	r1, r7, r4
    e9c0:	4648      	mov	r0, r9
    e9c2:	47d0      	blx	sl
    e9c4:	3401      	adds	r4, #1
    e9c6:	e7ec      	b.n	e9a2 <adc_async_read_channel+0x7a>
    e9c8:	00016994 	.word	0x00016994
    e9cc:	00013491 	.word	0x00013491
    e9d0:	00011ef9 	.word	0x00011ef9
    e9d4:	00011ed5 	.word	0x00011ed5
    e9d8:	00011f07 	.word	0x00011f07
    e9dc:	0000e42d 	.word	0x0000e42d
    e9e0:	00011e51 	.word	0x00011e51

0000e9e4 <adc_async_start_conversion>:
{
    e9e4:	b510      	push	{r4, lr}
	ASSERT(descr);
    e9e6:	4604      	mov	r4, r0
    e9e8:	3800      	subs	r0, #0
    e9ea:	bf18      	it	ne
    e9ec:	2001      	movne	r0, #1
    e9ee:	4904      	ldr	r1, [pc, #16]	; (ea00 <adc_async_start_conversion+0x1c>)
    e9f0:	4b04      	ldr	r3, [pc, #16]	; (ea04 <adc_async_start_conversion+0x20>)
    e9f2:	22d6      	movs	r2, #214	; 0xd6
    e9f4:	4798      	blx	r3
	_adc_async_convert(&descr->device);
    e9f6:	4620      	mov	r0, r4
    e9f8:	4b03      	ldr	r3, [pc, #12]	; (ea08 <adc_async_start_conversion+0x24>)
    e9fa:	4798      	blx	r3
}
    e9fc:	2000      	movs	r0, #0
    e9fe:	bd10      	pop	{r4, pc}
    ea00:	00016994 	.word	0x00016994
    ea04:	0000e42d 	.word	0x0000e42d
    ea08:	000134a5 	.word	0x000134a5

0000ea0c <_oscctrl_init_sources>:
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    ea0c:	4770      	bx	lr
	...

0000ea10 <_oscctrl_init_referenced_generators>:

static inline void hri_gclk_write_GENCTRL_SRC_bf(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	uint32_t tmp;
	GCLK_CRITICAL_SECTION_ENTER();
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    ea10:	4b3b      	ldr	r3, [pc, #236]	; (eb00 <_oscctrl_init_referenced_generators+0xf0>)
    ea12:	6a1a      	ldr	r2, [r3, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    ea14:	f022 020f 	bic.w	r2, r2, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    ea18:	f042 0204 	orr.w	r2, r2, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    ea1c:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    ea1e:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    ea22:	6859      	ldr	r1, [r3, #4]
    ea24:	4211      	tst	r1, r2
    ea26:	d1fc      	bne.n	ea22 <_oscctrl_init_referenced_generators+0x12>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    ea28:	685a      	ldr	r2, [r3, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    ea2a:	0750      	lsls	r0, r2, #29
    ea2c:	f3c2 0180 	ubfx	r1, r2, #2, #1
    ea30:	d4fa      	bmi.n	ea28 <_oscctrl_init_referenced_generators+0x18>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    ea32:	4b34      	ldr	r3, [pc, #208]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    ea34:	4a34      	ldr	r2, [pc, #208]	; (eb08 <_oscctrl_init_referenced_generators+0xf8>)
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    ea36:	7719      	strb	r1, [r3, #28]
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    ea38:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    ea3a:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    ea3e:	f3c2 1100 	ubfx	r1, r2, #4, #1
    ea42:	06d2      	lsls	r2, r2, #27
    ea44:	d4f9      	bmi.n	ea3a <_oscctrl_init_referenced_generators+0x2a>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    ea46:	f883 1020 	strb.w	r1, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    ea4a:	4b2e      	ldr	r3, [pc, #184]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
    ea4c:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    ea50:	0750      	lsls	r0, r2, #29
    ea52:	d4fb      	bmi.n	ea4c <_oscctrl_init_referenced_generators+0x3c>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    ea54:	2202      	movs	r2, #2
    ea56:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    ea58:	4b2a      	ldr	r3, [pc, #168]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
    ea5a:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    ea5e:	0791      	lsls	r1, r2, #30
    ea60:	d4fb      	bmi.n	ea5a <_oscctrl_init_referenced_generators+0x4a>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    ea62:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    ea64:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    ea66:	4b27      	ldr	r3, [pc, #156]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
    ea68:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    ea6c:	0712      	lsls	r2, r2, #28
    ea6e:	d4fb      	bmi.n	ea68 <_oscctrl_init_referenced_generators+0x58>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    ea70:	2288      	movs	r2, #136	; 0x88
    ea72:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    ea76:	4a23      	ldr	r2, [pc, #140]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
    ea78:	4613      	mov	r3, r2
    ea7a:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    ea7e:	0748      	lsls	r0, r1, #29
    ea80:	d4fb      	bmi.n	ea7a <_oscctrl_init_referenced_generators+0x6a>
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    ea82:	491f      	ldr	r1, [pc, #124]	; (eb00 <_oscctrl_init_referenced_generators+0xf0>)
    ea84:	2042      	movs	r0, #66	; 0x42
    ea86:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    ea8a:	2127      	movs	r1, #39	; 0x27
    ea8c:	6491      	str	r1, [r2, #72]	; 0x48
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    ea8e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    ea90:	f012 0f06 	tst.w	r2, #6
    ea94:	d1fb      	bne.n	ea8e <_oscctrl_init_referenced_generators+0x7e>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    ea96:	f44f 6200 	mov.w	r2, #2048	; 0x800
    ea9a:	64da      	str	r2, [r3, #76]	; 0x4c
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    ea9c:	2202      	movs	r2, #2
    ea9e:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    eaa2:	4b18      	ldr	r3, [pc, #96]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
    eaa4:	461a      	mov	r2, r3
    eaa6:	6d19      	ldr	r1, [r3, #80]	; 0x50
    eaa8:	0789      	lsls	r1, r1, #30
    eaaa:	d4fc      	bmi.n	eaa6 <_oscctrl_init_referenced_generators+0x96>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    eaac:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    eab0:	07db      	lsls	r3, r3, #31
    eab2:	d521      	bpl.n	eaf8 <_oscctrl_init_referenced_generators+0xe8>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    eab4:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    eab6:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    eaba:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    eabe:	d1f9      	bne.n	eab4 <_oscctrl_init_referenced_generators+0xa4>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    eac0:	4b10      	ldr	r3, [pc, #64]	; (eb04 <_oscctrl_init_referenced_generators+0xf4>)
    eac2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
#endif
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 1) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 1)))
    eac4:	07d1      	lsls	r1, r2, #31
    eac6:	d402      	bmi.n	eace <_oscctrl_init_referenced_generators+0xbe>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    eac8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    eaca:	0792      	lsls	r2, r2, #30
    eacc:	d5f9      	bpl.n	eac2 <_oscctrl_init_referenced_generators+0xb2>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    eace:	4a0c      	ldr	r2, [pc, #48]	; (eb00 <_oscctrl_init_referenced_generators+0xf0>)
    ead0:	4611      	mov	r1, r2
    ead2:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    ead4:	2b00      	cmp	r3, #0
    ead6:	d1fc      	bne.n	ead2 <_oscctrl_init_referenced_generators+0xc2>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    ead8:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    eada:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    eade:	f043 0308 	orr.w	r3, r3, #8
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    eae2:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    eae4:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    eae8:	684a      	ldr	r2, [r1, #4]
    eaea:	421a      	tst	r2, r3
    eaec:	d1fc      	bne.n	eae8 <_oscctrl_init_referenced_generators+0xd8>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    eaee:	4a04      	ldr	r2, [pc, #16]	; (eb00 <_oscctrl_init_referenced_generators+0xf0>)
    eaf0:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    eaf2:	075b      	lsls	r3, r3, #29
    eaf4:	d4fc      	bmi.n	eaf0 <_oscctrl_init_referenced_generators+0xe0>
		;
#endif
	(void)hw;
}
    eaf6:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    eaf8:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    eafa:	05d8      	lsls	r0, r3, #23
    eafc:	d5fc      	bpl.n	eaf8 <_oscctrl_init_referenced_generators+0xe8>
    eafe:	e7df      	b.n	eac0 <_oscctrl_init_referenced_generators+0xb0>
    eb00:	40001c00 	.word	0x40001c00
    eb04:	40001000 	.word	0x40001000
    eb08:	04010000 	.word	0x04010000

0000eb0c <_rand_sync_read_data>:

/**
 * \brief Read data bits
 */
static uint32_t _rand_sync_read_data(const struct _rand_sync_dev *dev, const uint8_t n_bits)
{
    eb0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    eb10:	f890 8004 	ldrb.w	r8, [r0, #4]
    eb14:	f8df 9034 	ldr.w	r9, [pc, #52]	; eb4c <_rand_sync_read_data+0x40>
{
    eb18:	4605      	mov	r5, r0
    eb1a:	460f      	mov	r7, r1
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    eb1c:	f1b8 0f00 	cmp.w	r8, #0
    eb20:	d00f      	beq.n	eb42 <_rand_sync_read_data+0x36>
	if (r_bits < n_bits) {
    eb22:	4588      	cmp	r8, r1
    eb24:	d20d      	bcs.n	eb42 <_rand_sync_read_data+0x36>
		uint8_t  i;
		uint32_t d = 0;
    eb26:	2600      	movs	r6, #0
		/* Join read bits */
		for (i = 0; i < n_bits; i += r_bits) {
    eb28:	4634      	mov	r4, r6
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    eb2a:	4628      	mov	r0, r5
    eb2c:	47c8      	blx	r9
    eb2e:	40a0      	lsls	r0, r4
		for (i = 0; i < n_bits; i += r_bits) {
    eb30:	4444      	add	r4, r8
    eb32:	b2e4      	uxtb	r4, r4
    eb34:	42a7      	cmp	r7, r4
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    eb36:	ea46 0600 	orr.w	r6, r6, r0
		for (i = 0; i < n_bits; i += r_bits) {
    eb3a:	d8f6      	bhi.n	eb2a <_rand_sync_read_data+0x1e>
		}
		return d;
	} else {
		return _rand_sync_read_one(dev);
	}
}
    eb3c:	4630      	mov	r0, r6
    eb3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return _rand_sync_read_one(dev);
    eb42:	4628      	mov	r0, r5
    eb44:	464b      	mov	r3, r9
}
    eb46:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return _rand_sync_read_one(dev);
    eb4a:	4718      	bx	r3
    eb4c:	0000ec51 	.word	0x0000ec51

0000eb50 <rand_sync_init>:
{
    eb50:	b570      	push	{r4, r5, r6, lr}
	ASSERT(desc);
    eb52:	4604      	mov	r4, r0
    eb54:	3800      	subs	r0, #0
{
    eb56:	460d      	mov	r5, r1
	ASSERT(desc);
    eb58:	4b05      	ldr	r3, [pc, #20]	; (eb70 <rand_sync_init+0x20>)
    eb5a:	4906      	ldr	r1, [pc, #24]	; (eb74 <rand_sync_init+0x24>)
    eb5c:	bf18      	it	ne
    eb5e:	2001      	movne	r0, #1
    eb60:	2229      	movs	r2, #41	; 0x29
    eb62:	4798      	blx	r3
	return _rand_sync_init(&desc->dev, hw);
    eb64:	4629      	mov	r1, r5
    eb66:	4620      	mov	r0, r4
    eb68:	4b03      	ldr	r3, [pc, #12]	; (eb78 <rand_sync_init+0x28>)
}
    eb6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _rand_sync_init(&desc->dev, hw);
    eb6e:	4718      	bx	r3
    eb70:	0000e42d 	.word	0x0000e42d
    eb74:	000169af 	.word	0x000169af
    eb78:	0000ebd1 	.word	0x0000ebd1

0000eb7c <rand_sync_enable>:
{
    eb7c:	b510      	push	{r4, lr}
	ASSERT(desc);
    eb7e:	4604      	mov	r4, r0
    eb80:	3800      	subs	r0, #0
    eb82:	4b05      	ldr	r3, [pc, #20]	; (eb98 <rand_sync_enable+0x1c>)
    eb84:	4905      	ldr	r1, [pc, #20]	; (eb9c <rand_sync_enable+0x20>)
    eb86:	bf18      	it	ne
    eb88:	2001      	movne	r0, #1
    eb8a:	2236      	movs	r2, #54	; 0x36
    eb8c:	4798      	blx	r3
	return _rand_sync_enable(&desc->dev);
    eb8e:	4620      	mov	r0, r4
    eb90:	4b03      	ldr	r3, [pc, #12]	; (eba0 <rand_sync_enable+0x24>)
}
    eb92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _rand_sync_enable(&desc->dev);
    eb96:	4718      	bx	r3
    eb98:	0000e42d 	.word	0x0000e42d
    eb9c:	000169af 	.word	0x000169af
    eba0:	0000ec19 	.word	0x0000ec19

0000eba4 <rand_sync_read8>:

uint8_t rand_sync_read8(const struct rand_sync_desc *const desc)
{
    eba4:	b510      	push	{r4, lr}
	ASSERT(desc);
    eba6:	4604      	mov	r4, r0
    eba8:	3800      	subs	r0, #0
    ebaa:	bf18      	it	ne
    ebac:	2001      	movne	r0, #1
    ebae:	225b      	movs	r2, #91	; 0x5b
    ebb0:	4904      	ldr	r1, [pc, #16]	; (ebc4 <rand_sync_read8+0x20>)
    ebb2:	4b05      	ldr	r3, [pc, #20]	; (ebc8 <rand_sync_read8+0x24>)
    ebb4:	4798      	blx	r3
	return (uint8_t)_rand_sync_read_data(&desc->dev, 8);
    ebb6:	4b05      	ldr	r3, [pc, #20]	; (ebcc <rand_sync_read8+0x28>)
    ebb8:	2108      	movs	r1, #8
    ebba:	4620      	mov	r0, r4
    ebbc:	4798      	blx	r3
}
    ebbe:	b2c0      	uxtb	r0, r0
    ebc0:	bd10      	pop	{r4, pc}
    ebc2:	bf00      	nop
    ebc4:	000169af 	.word	0x000169af
    ebc8:	0000e42d 	.word	0x0000e42d
    ebcc:	0000eb0d 	.word	0x0000eb0d

0000ebd0 <_rand_sync_init>:
	}
	return ERR_NONE;
}

int32_t _rand_sync_init(struct _rand_sync_dev *const dev, void *const hw)
{
    ebd0:	b538      	push	{r3, r4, r5, lr}
    ebd2:	460c      	mov	r4, r1
	int32_t rc;

	ASSERT(dev && hw);
    ebd4:	4605      	mov	r5, r0
    ebd6:	b110      	cbz	r0, ebde <_rand_sync_init+0xe>
    ebd8:	1e08      	subs	r0, r1, #0
    ebda:	bf18      	it	ne
    ebdc:	2001      	movne	r0, #1
    ebde:	4b0c      	ldr	r3, [pc, #48]	; (ec10 <_rand_sync_init+0x40>)
    ebe0:	490c      	ldr	r1, [pc, #48]	; (ec14 <_rand_sync_init+0x44>)
    ebe2:	223d      	movs	r2, #61	; 0x3d
    ebe4:	4798      	blx	r3
}

static inline hri_trng_ctrla_reg_t hri_trng_get_CTRLA_reg(const void *const hw, hri_trng_ctrla_reg_t mask)
{
	uint8_t tmp;
	tmp = ((Trng *)hw)->CTRLA.reg;
    ebe6:	7823      	ldrb	r3, [r4, #0]
	if (hri_trng_get_CTRLA_reg(hw, TRNG_CTRLA_ENABLE)) {
    ebe8:	f013 0302 	ands.w	r3, r3, #2
    ebec:	d10c      	bne.n	ec08 <_rand_sync_init+0x38>
	((Trng *)hw)->CTRLA.reg &= ~TRNG_CTRLA_RUNSTDBY;
    ebee:	7822      	ldrb	r2, [r4, #0]
    ebf0:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
    ebf4:	7022      	strb	r2, [r4, #0]
}

static inline void hri_trng_clear_EVCTRL_DATARDYEO_bit(const void *const hw)
{
	TRNG_CRITICAL_SECTION_ENTER();
	((Trng *)hw)->EVCTRL.reg &= ~TRNG_EVCTRL_DATARDYEO;
    ebf6:	7922      	ldrb	r2, [r4, #4]
    ebf8:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    ebfc:	7122      	strb	r2, [r4, #4]

	rc = _trng_init(hw);
	if (rc == ERR_NONE) {
		dev->prvt   = hw;
		dev->n_bits = 32;
    ebfe:	2220      	movs	r2, #32
		dev->prvt   = hw;
    ec00:	602c      	str	r4, [r5, #0]
		dev->n_bits = 32;
    ec02:	712a      	strb	r2, [r5, #4]
	return ERR_NONE;
    ec04:	4618      	mov	r0, r3
	}
	return rc;
}
    ec06:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
    ec08:	f06f 0010 	mvn.w	r0, #16
	return rc;
    ec0c:	e7fb      	b.n	ec06 <_rand_sync_init+0x36>
    ec0e:	bf00      	nop
    ec10:	0000e42d 	.word	0x0000e42d
    ec14:	000169ca 	.word	0x000169ca

0000ec18 <_rand_sync_enable>:
{
	_rand_sync_disable(dev);
}

int32_t _rand_sync_enable(struct _rand_sync_dev *const dev)
{
    ec18:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    ec1a:	4604      	mov	r4, r0
    ec1c:	3800      	subs	r0, #0
    ec1e:	bf18      	it	ne
    ec20:	2001      	movne	r0, #1
    ec22:	4d09      	ldr	r5, [pc, #36]	; (ec48 <_rand_sync_enable+0x30>)
    ec24:	4909      	ldr	r1, [pc, #36]	; (ec4c <_rand_sync_enable+0x34>)
    ec26:	224e      	movs	r2, #78	; 0x4e
    ec28:	47a8      	blx	r5
	ASSERT(dev->prvt);
    ec2a:	6820      	ldr	r0, [r4, #0]
    ec2c:	4907      	ldr	r1, [pc, #28]	; (ec4c <_rand_sync_enable+0x34>)
    ec2e:	3800      	subs	r0, #0
    ec30:	bf18      	it	ne
    ec32:	2001      	movne	r0, #1
    ec34:	224f      	movs	r2, #79	; 0x4f
    ec36:	47a8      	blx	r5

	hri_trng_set_CTRLA_ENABLE_bit(dev->prvt);
    ec38:	6822      	ldr	r2, [r4, #0]
	((Trng *)hw)->CTRLA.reg |= TRNG_CTRLA_ENABLE;
    ec3a:	7813      	ldrb	r3, [r2, #0]
    ec3c:	f043 0302 	orr.w	r3, r3, #2
    ec40:	7013      	strb	r3, [r2, #0]
	return ERR_NONE;
}
    ec42:	2000      	movs	r0, #0
    ec44:	bd38      	pop	{r3, r4, r5, pc}
    ec46:	bf00      	nop
    ec48:	0000e42d 	.word	0x0000e42d
    ec4c:	000169ca 	.word	0x000169ca

0000ec50 <_rand_sync_read_one>:
	(void)seed;
	return ERR_UNSUPPORTED_OP;
}

uint32_t _rand_sync_read_one(const struct _rand_sync_dev *const dev)
{
    ec50:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    ec52:	4604      	mov	r4, r0
    ec54:	3800      	subs	r0, #0
    ec56:	4d0d      	ldr	r5, [pc, #52]	; (ec8c <_rand_sync_read_one+0x3c>)
    ec58:	490d      	ldr	r1, [pc, #52]	; (ec90 <_rand_sync_read_one+0x40>)
    ec5a:	bf18      	it	ne
    ec5c:	2001      	movne	r0, #1
    ec5e:	2266      	movs	r2, #102	; 0x66
    ec60:	47a8      	blx	r5
	ASSERT(dev->prvt);
    ec62:	6820      	ldr	r0, [r4, #0]
    ec64:	490a      	ldr	r1, [pc, #40]	; (ec90 <_rand_sync_read_one+0x40>)
    ec66:	3800      	subs	r0, #0
    ec68:	bf18      	it	ne
    ec6a:	2001      	movne	r0, #1
    ec6c:	2267      	movs	r2, #103	; 0x67
    ec6e:	47a8      	blx	r5
	ASSERT(hri_trng_get_CTRLA_reg(dev->prvt, TRNG_CTRLA_ENABLE));
    ec70:	6823      	ldr	r3, [r4, #0]
    ec72:	4907      	ldr	r1, [pc, #28]	; (ec90 <_rand_sync_read_one+0x40>)
	tmp = ((Trng *)hw)->CTRLA.reg;
    ec74:	7818      	ldrb	r0, [r3, #0]
    ec76:	2268      	movs	r2, #104	; 0x68
    ec78:	f3c0 0040 	ubfx	r0, r0, #1, #1
    ec7c:	47a8      	blx	r5

	while (!hri_trng_get_INTFLAG_reg(dev->prvt, TRNG_INTFLAG_DATARDY)) {
    ec7e:	6823      	ldr	r3, [r4, #0]
	tmp = ((Trng *)hw)->INTFLAG.reg;
    ec80:	7a9a      	ldrb	r2, [r3, #10]
    ec82:	07d2      	lsls	r2, r2, #31
    ec84:	d5fc      	bpl.n	ec80 <_rand_sync_read_one+0x30>
	return ((Trng *)hw)->DATA.reg;
    ec86:	6a18      	ldr	r0, [r3, #32]
		/* Wait until data ready. */
	}
	return hri_trng_read_DATA_reg(dev->prvt);
}
    ec88:	bd38      	pop	{r3, r4, r5, pc}
    ec8a:	bf00      	nop
    ec8c:	0000e42d 	.word	0x0000e42d
    ec90:	000169ca 	.word	0x000169ca

0000ec94 <hid_keyboard_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    ec94:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    ec96:	780a      	ldrb	r2, [r1, #0]
    ec98:	2a81      	cmp	r2, #129	; 0x81
    ec9a:	d11c      	bne.n	ecd6 <hid_keyboard_req+0x42>
    ec9c:	784b      	ldrb	r3, [r1, #1]
    ec9e:	2b06      	cmp	r3, #6
    eca0:	d131      	bne.n	ed06 <hid_keyboard_req+0x72>
    eca2:	4a1a      	ldr	r2, [pc, #104]	; (ed0c <hid_keyboard_req+0x78>)
    eca4:	888c      	ldrh	r4, [r1, #4]
    eca6:	7b13      	ldrb	r3, [r2, #12]
    eca8:	429c      	cmp	r4, r3
    ecaa:	d12c      	bne.n	ed06 <hid_keyboard_req+0x72>
	switch (req->wValue >> 8) {
    ecac:	884b      	ldrh	r3, [r1, #2]
    ecae:	0a1b      	lsrs	r3, r3, #8
    ecb0:	2b21      	cmp	r3, #33	; 0x21
    ecb2:	d005      	beq.n	ecc0 <hid_keyboard_req+0x2c>
    ecb4:	2b22      	cmp	r3, #34	; 0x22
    ecb6:	d00a      	beq.n	ecce <hid_keyboard_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
			switch (req->bRequest) {
    ecb8:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    ecbc:	bc30      	pop	{r4, r5}
    ecbe:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
    ecc0:	6811      	ldr	r1, [r2, #0]
    ecc2:	780a      	ldrb	r2, [r1, #0]
    ecc4:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    ecc6:	4c12      	ldr	r4, [pc, #72]	; (ed10 <hid_keyboard_req+0x7c>)
    ecc8:	46a4      	mov	ip, r4
}
    ecca:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    eccc:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
    ecce:	4911      	ldr	r1, [pc, #68]	; (ed14 <hid_keyboard_req+0x80>)
    ecd0:	2300      	movs	r3, #0
    ecd2:	223b      	movs	r2, #59	; 0x3b
    ecd4:	e7f7      	b.n	ecc6 <hid_keyboard_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    ecd6:	f3c2 1241 	ubfx	r2, r2, #5, #2
    ecda:	2a01      	cmp	r2, #1
    ecdc:	d113      	bne.n	ed06 <hid_keyboard_req+0x72>
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
    ecde:	4c0b      	ldr	r4, [pc, #44]	; (ed0c <hid_keyboard_req+0x78>)
    ece0:	888d      	ldrh	r5, [r1, #4]
    ece2:	7b23      	ldrb	r3, [r4, #12]
    ece4:	429d      	cmp	r5, r3
    ece6:	d10e      	bne.n	ed06 <hid_keyboard_req+0x72>
			switch (req->bRequest) {
    ece8:	784b      	ldrb	r3, [r1, #1]
    ecea:	2b03      	cmp	r3, #3
    ecec:	d007      	beq.n	ecfe <hid_keyboard_req+0x6a>
    ecee:	2b0b      	cmp	r3, #11
    ecf0:	d1e2      	bne.n	ecb8 <hid_keyboard_req+0x24>
				_hiddf_keyboard_funcd.protocol = req->wValue;
    ecf2:	884b      	ldrh	r3, [r1, #2]
    ecf4:	73e3      	strb	r3, [r4, #15]
				return usbdc_xfer(ep, NULL, 0, 0);
    ecf6:	2300      	movs	r3, #0
    ecf8:	461a      	mov	r2, r3
    ecfa:	4619      	mov	r1, r3
    ecfc:	e7e3      	b.n	ecc6 <hid_keyboard_req+0x32>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
    ecfe:	2300      	movs	r3, #0
    ed00:	f104 010f 	add.w	r1, r4, #15
    ed04:	e7df      	b.n	ecc6 <hid_keyboard_req+0x32>
			return ERR_NOT_FOUND;
    ed06:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    ed0a:	e7d7      	b.n	ecbc <hid_keyboard_req+0x28>
    ed0c:	20008b40 	.word	0x20008b40
    ed10:	00013711 	.word	0x00013711
    ed14:	000169e1 	.word	0x000169e1

0000ed18 <hid_keyboard_ctrl>:
	switch (ctrl) {
    ed18:	2901      	cmp	r1, #1
{
    ed1a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ed1e:	4615      	mov	r5, r2
	switch (ctrl) {
    ed20:	d04b      	beq.n	edba <hid_keyboard_ctrl+0xa2>
    ed22:	2902      	cmp	r1, #2
    ed24:	d066      	beq.n	edf4 <hid_keyboard_ctrl+0xdc>
    ed26:	2900      	cmp	r1, #0
    ed28:	d167      	bne.n	edfa <hid_keyboard_ctrl+0xe2>
	ifc = desc->sod;
    ed2a:	6813      	ldr	r3, [r2, #0]
		return hid_keyboard_enable(drv, (struct usbd_descriptors *)param);
    ed2c:	f8d0 8008 	ldr.w	r8, [r0, #8]
	if (NULL == ifc) {
    ed30:	b923      	cbnz	r3, ed3c <hid_keyboard_ctrl+0x24>
		return ERR_NOT_FOUND;
    ed32:	f06f 0409 	mvn.w	r4, #9
}
    ed36:	4620      	mov	r0, r4
    ed38:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    ed3c:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    ed3e:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    ed40:	2903      	cmp	r1, #3
    ed42:	d1f6      	bne.n	ed32 <hid_keyboard_ctrl+0x1a>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    ed44:	f898 100c 	ldrb.w	r1, [r8, #12]
    ed48:	428a      	cmp	r2, r1
    ed4a:	d059      	beq.n	ee00 <hid_keyboard_ctrl+0xe8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    ed4c:	29ff      	cmp	r1, #255	; 0xff
    ed4e:	d15a      	bne.n	ee06 <hid_keyboard_ctrl+0xee>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    ed50:	f888 200c 	strb.w	r2, [r8, #12]
	return (desc + usb_desc_len(desc));
    ed54:	7818      	ldrb	r0, [r3, #0]
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    ed56:	6869      	ldr	r1, [r5, #4]
    ed58:	4e2e      	ldr	r6, [pc, #184]	; (ee14 <hid_keyboard_ctrl+0xfc>)
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    ed5a:	f8df b0c8 	ldr.w	fp, [pc, #200]	; ee24 <hid_keyboard_ctrl+0x10c>
    ed5e:	f8df 90c8 	ldr.w	r9, [pc, #200]	; ee28 <hid_keyboard_ctrl+0x110>
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    ed62:	4418      	add	r0, r3
    ed64:	2221      	movs	r2, #33	; 0x21
    ed66:	4b2c      	ldr	r3, [pc, #176]	; (ee18 <hid_keyboard_ctrl+0x100>)
    ed68:	4798      	blx	r3
    ed6a:	2702      	movs	r7, #2
    ed6c:	6030      	str	r0, [r6, #0]
		ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    ed6e:	682b      	ldr	r3, [r5, #0]
    ed70:	6869      	ldr	r1, [r5, #4]
    ed72:	7818      	ldrb	r0, [r3, #0]
    ed74:	4418      	add	r0, r3
    ed76:	4b29      	ldr	r3, [pc, #164]	; (ee1c <hid_keyboard_ctrl+0x104>)
    ed78:	4798      	blx	r3
		desc->sod = ep;
    ed7a:	6028      	str	r0, [r5, #0]
		if (NULL != ep) {
    ed7c:	2800      	cmp	r0, #0
    ed7e:	d0d8      	beq.n	ed32 <hid_keyboard_ctrl+0x1a>
	return (ptr[0] + (ptr[1] << 8));
    ed80:	7941      	ldrb	r1, [r0, #5]
    ed82:	7902      	ldrb	r2, [r0, #4]
			ep_desc.bEndpointAddress = ep[2];
    ed84:	f890 a002 	ldrb.w	sl, [r0, #2]
    ed88:	eb02 2201 	add.w	r2, r2, r1, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    ed8c:	b292      	uxth	r2, r2
    ed8e:	78c1      	ldrb	r1, [r0, #3]
    ed90:	4650      	mov	r0, sl
    ed92:	47d8      	blx	fp
    ed94:	4604      	mov	r4, r0
    ed96:	2800      	cmp	r0, #0
    ed98:	d138      	bne.n	ee0c <hid_keyboard_ctrl+0xf4>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    ed9a:	f01a 0f80 	tst.w	sl, #128	; 0x80
				func_data->func_ep_in = ep_desc.bEndpointAddress;
    ed9e:	bf14      	ite	ne
    eda0:	f888 a00d 	strbne.w	sl, [r8, #13]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    eda4:	f888 a00e 	strbeq.w	sl, [r8, #14]
				usb_d_ep_enable(func_data->func_ep_out);
    eda8:	4650      	mov	r0, sl
    edaa:	47c8      	blx	r9
	for (i = 0; i < 2; i++) {
    edac:	2f01      	cmp	r7, #1
    edae:	d102      	bne.n	edb6 <hid_keyboard_ctrl+0x9e>
	_hiddf_keyboard_funcd.protocol = 1;
    edb0:	73f7      	strb	r7, [r6, #15]
	_hiddf_keyboard_funcd.enabled  = true;
    edb2:	7437      	strb	r7, [r6, #16]
	return ERR_NONE;
    edb4:	e7bf      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
    edb6:	2701      	movs	r7, #1
    edb8:	e7d9      	b.n	ed6e <hid_keyboard_ctrl+0x56>
		return hid_keyboard_disable(drv, (struct usbd_descriptors *)param);
    edba:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    edbc:	b11a      	cbz	r2, edc6 <hid_keyboard_ctrl+0xae>
		ifc_desc.bInterfaceClass = desc->sod[5];
    edbe:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    edc0:	795b      	ldrb	r3, [r3, #5]
    edc2:	2b03      	cmp	r3, #3
    edc4:	d1b5      	bne.n	ed32 <hid_keyboard_ctrl+0x1a>
	if (func_data->func_iface != 0xFF) {
    edc6:	7b23      	ldrb	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    edc8:	7b60      	ldrb	r0, [r4, #13]
	if (func_data->func_iface != 0xFF) {
    edca:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    edcc:	bf1c      	itt	ne
    edce:	23ff      	movne	r3, #255	; 0xff
    edd0:	7323      	strbne	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    edd2:	28ff      	cmp	r0, #255	; 0xff
    edd4:	d003      	beq.n	edde <hid_keyboard_ctrl+0xc6>
		usb_d_ep_deinit(func_data->func_ep_in);
    edd6:	4b12      	ldr	r3, [pc, #72]	; (ee20 <hid_keyboard_ctrl+0x108>)
    edd8:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    edda:	23ff      	movs	r3, #255	; 0xff
    eddc:	7363      	strb	r3, [r4, #13]
	if (func_data->func_ep_out != 0xFF) {
    edde:	7ba0      	ldrb	r0, [r4, #14]
    ede0:	28ff      	cmp	r0, #255	; 0xff
    ede2:	d003      	beq.n	edec <hid_keyboard_ctrl+0xd4>
		usb_d_ep_deinit(func_data->func_ep_out);
    ede4:	4b0e      	ldr	r3, [pc, #56]	; (ee20 <hid_keyboard_ctrl+0x108>)
    ede6:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    ede8:	23ff      	movs	r3, #255	; 0xff
    edea:	73a3      	strb	r3, [r4, #14]
	_hiddf_keyboard_funcd.enabled = false;
    edec:	4b09      	ldr	r3, [pc, #36]	; (ee14 <hid_keyboard_ctrl+0xfc>)
    edee:	2400      	movs	r4, #0
    edf0:	741c      	strb	r4, [r3, #16]
	return ERR_NONE;
    edf2:	e7a0      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
		return ERR_UNSUPPORTED_OP;
    edf4:	f06f 041a 	mvn.w	r4, #26
    edf8:	e79d      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
	switch (ctrl) {
    edfa:	f06f 040c 	mvn.w	r4, #12
    edfe:	e79a      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
			return ERR_ALREADY_INITIALIZED;
    ee00:	f06f 0411 	mvn.w	r4, #17
    ee04:	e797      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
			return ERR_NO_RESOURCE;
    ee06:	f06f 041b 	mvn.w	r4, #27
    ee0a:	e794      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
				return ERR_NOT_INITIALIZED;
    ee0c:	f06f 0413 	mvn.w	r4, #19
    ee10:	e791      	b.n	ed36 <hid_keyboard_ctrl+0x1e>
    ee12:	bf00      	nop
    ee14:	20008b40 	.word	0x20008b40
    ee18:	0000bbdd 	.word	0x0000bbdd
    ee1c:	0000bbf7 	.word	0x0000bbf7
    ee20:	0000f975 	.word	0x0000f975
    ee24:	0000f911 	.word	0x0000f911
    ee28:	0000f9a1 	.word	0x0000f9a1

0000ee2c <hiddf_keyboard_init>:

/**
 * \brief Initialize the USB HID Keyboard Function Driver
 */
int32_t hiddf_keyboard_init(void)
{
    ee2c:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    ee2e:	4b0a      	ldr	r3, [pc, #40]	; (ee58 <hiddf_keyboard_init+0x2c>)
    ee30:	4798      	blx	r3
    ee32:	2801      	cmp	r0, #1
    ee34:	d80c      	bhi.n	ee50 <hiddf_keyboard_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_keyboard.ctrl      = hid_keyboard_ctrl;
    ee36:	4809      	ldr	r0, [pc, #36]	; (ee5c <hiddf_keyboard_init+0x30>)
    ee38:	4b09      	ldr	r3, [pc, #36]	; (ee60 <hiddf_keyboard_init+0x34>)
	_hiddf_keyboard.func_data = &_hiddf_keyboard_funcd;
    ee3a:	e9c0 3006 	strd	r3, r0, [r0, #24]

	usbdc_register_function(&_hiddf_keyboard);
    ee3e:	4b09      	ldr	r3, [pc, #36]	; (ee64 <hiddf_keyboard_init+0x38>)
    ee40:	3014      	adds	r0, #20
    ee42:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_keyboard_req_h);
    ee44:	2001      	movs	r0, #1
    ee46:	4908      	ldr	r1, [pc, #32]	; (ee68 <hiddf_keyboard_init+0x3c>)
    ee48:	4b08      	ldr	r3, [pc, #32]	; (ee6c <hiddf_keyboard_init+0x40>)
    ee4a:	4798      	blx	r3
	return ERR_NONE;
    ee4c:	2000      	movs	r0, #0
}
    ee4e:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    ee50:	f06f 0010 	mvn.w	r0, #16
    ee54:	e7fb      	b.n	ee4e <hiddf_keyboard_init+0x22>
    ee56:	bf00      	nop
    ee58:	00013b49 	.word	0x00013b49
    ee5c:	20008b40 	.word	0x20008b40
    ee60:	0000ed19 	.word	0x0000ed19
    ee64:	00013af1 	.word	0x00013af1
    ee68:	20000504 	.word	0x20000504
    ee6c:	00013a69 	.word	0x00013a69

0000ee70 <hiddf_keyboard_keys_state_change>:
 * \param keys_desc[]  keys_descriptor array for state changing
 * \param keys_count   total keys amount for state changing
 * \return Operation status.
 */
int32_t hiddf_keyboard_keys_state_change(struct hiddf_kb_key_descriptors keys_desc[], uint8_t keys_count)
{
    ee70:	b470      	push	{r4, r5, r6}
	return _hiddf_keyboard_funcd.enabled;
    ee72:	4c20      	ldr	r4, [pc, #128]	; (eef4 <hiddf_keyboard_keys_state_change+0x84>)
	uint8_t i, j;
	uint8_t modifier_keys, regular_keys;

	if (!hiddf_keyboard_is_enabled()) {
    ee74:	7c23      	ldrb	r3, [r4, #16]
    ee76:	2b00      	cmp	r3, #0
    ee78:	d037      	beq.n	eeea <hiddf_keyboard_keys_state_change+0x7a>
		return ERR_DENIED;
	}

	memset(_hiddf_keyboard_funcd.kb_report, 0x00, 8);
    ee7a:	2300      	movs	r3, #0
    ee7c:	e9c4 3301 	strd	r3, r3, [r4, #4]
	modifier_keys = 0;
    ee80:	461a      	mov	r2, r3

	for (i = 0; i < keys_count; i++) {
		if (true == keys_desc[i].b_modifier) {
    ee82:	1c46      	adds	r6, r0, #1
	for (i = 0; i < keys_count; i++) {
    ee84:	b2dd      	uxtb	r5, r3
    ee86:	42a9      	cmp	r1, r5
    ee88:	d814      	bhi.n	eeb4 <hiddf_keyboard_keys_state_change+0x44>
			modifier_keys++;
		}
	}

	regular_keys = keys_count - modifier_keys;
    ee8a:	1a8a      	subs	r2, r1, r2

	if (regular_keys > 6) {
    ee8c:	b2d2      	uxtb	r2, r2
    ee8e:	2a06      	cmp	r2, #6
    ee90:	d818      	bhi.n	eec4 <hiddf_keyboard_keys_state_change+0x54>
    ee92:	2500      	movs	r5, #0
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
	} else {
		i = 2;
    ee94:	2302      	movs	r3, #2
		for (j = 0; j < keys_count; j++) {
    ee96:	b2ea      	uxtb	r2, r5
    ee98:	4291      	cmp	r1, r2
    ee9a:	d919      	bls.n	eed0 <hiddf_keyboard_keys_state_change+0x60>
			if (HID_KB_KEY_DOWN == keys_desc[j].state) {
    ee9c:	7882      	ldrb	r2, [r0, #2]
    ee9e:	2a01      	cmp	r2, #1
    eea0:	d105      	bne.n	eeae <hiddf_keyboard_keys_state_change+0x3e>
				if (true == keys_desc[j].b_modifier) {
    eea2:	7846      	ldrb	r6, [r0, #1]
    eea4:	7802      	ldrb	r2, [r0, #0]
    eea6:	b1de      	cbz	r6, eee0 <hiddf_keyboard_keys_state_change+0x70>
					_hiddf_keyboard_funcd.kb_report[0] |= keys_desc[j].key_id;
    eea8:	7926      	ldrb	r6, [r4, #4]
    eeaa:	4332      	orrs	r2, r6
    eeac:	7122      	strb	r2, [r4, #4]
		for (j = 0; j < keys_count; j++) {
    eeae:	3501      	adds	r5, #1
    eeb0:	3003      	adds	r0, #3
    eeb2:	e7f0      	b.n	ee96 <hiddf_keyboard_keys_state_change+0x26>
		if (true == keys_desc[i].b_modifier) {
    eeb4:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    eeb8:	5d75      	ldrb	r5, [r6, r5]
    eeba:	b10d      	cbz	r5, eec0 <hiddf_keyboard_keys_state_change+0x50>
			modifier_keys++;
    eebc:	3201      	adds	r2, #1
    eebe:	b2d2      	uxtb	r2, r2
	for (i = 0; i < keys_count; i++) {
    eec0:	3301      	adds	r3, #1
    eec2:	e7df      	b.n	ee84 <hiddf_keyboard_keys_state_change+0x14>
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
    eec4:	4a0c      	ldr	r2, [pc, #48]	; (eef8 <hiddf_keyboard_keys_state_change+0x88>)
    eec6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    eeca:	f8c4 3006 	str.w	r3, [r4, #6]
    eece:	8093      	strh	r3, [r2, #4]
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
				}
			}
		}
	}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    eed0:	7b60      	ldrb	r0, [r4, #13]
    eed2:	4c0a      	ldr	r4, [pc, #40]	; (eefc <hiddf_keyboard_keys_state_change+0x8c>)
    eed4:	490a      	ldr	r1, [pc, #40]	; (ef00 <hiddf_keyboard_keys_state_change+0x90>)
    eed6:	46a4      	mov	ip, r4
    eed8:	2300      	movs	r3, #0
}
    eeda:	bc70      	pop	{r4, r5, r6}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    eedc:	2208      	movs	r2, #8
    eede:	4760      	bx	ip
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
    eee0:	1c5e      	adds	r6, r3, #1
    eee2:	4423      	add	r3, r4
    eee4:	711a      	strb	r2, [r3, #4]
    eee6:	b2f3      	uxtb	r3, r6
    eee8:	e7e1      	b.n	eeae <hiddf_keyboard_keys_state_change+0x3e>
}
    eeea:	f06f 0010 	mvn.w	r0, #16
    eeee:	bc70      	pop	{r4, r5, r6}
    eef0:	4770      	bx	lr
    eef2:	bf00      	nop
    eef4:	20008b40 	.word	0x20008b40
    eef8:	20008b46 	.word	0x20008b46
    eefc:	00013711 	.word	0x00013711
    ef00:	20008b44 	.word	0x20008b44

0000ef04 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    ef04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ef08:	460e      	mov	r6, r1
    ef0a:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    ef0c:	4604      	mov	r4, r0
    ef0e:	b118      	cbz	r0, ef18 <usart_sync_write+0x14>
    ef10:	b329      	cbz	r1, ef5e <usart_sync_write+0x5a>
    ef12:	1e10      	subs	r0, r2, #0
    ef14:	bf18      	it	ne
    ef16:	2001      	movne	r0, #1
    ef18:	4912      	ldr	r1, [pc, #72]	; (ef64 <usart_sync_write+0x60>)
    ef1a:	4b13      	ldr	r3, [pc, #76]	; (ef68 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
    ef1c:	4f13      	ldr	r7, [pc, #76]	; (ef6c <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
    ef1e:	22f1      	movs	r2, #241	; 0xf1
    ef20:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    ef22:	3408      	adds	r4, #8
    ef24:	46b9      	mov	r9, r7
    ef26:	4620      	mov	r0, r4
    ef28:	47b8      	blx	r7
    ef2a:	2800      	cmp	r0, #0
    ef2c:	d0fb      	beq.n	ef26 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    ef2e:	f8df 8044 	ldr.w	r8, [pc, #68]	; ef74 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
    ef32:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
    ef34:	5df1      	ldrb	r1, [r6, r7]
    ef36:	4620      	mov	r0, r4
    ef38:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
    ef3a:	4620      	mov	r0, r4
    ef3c:	47c8      	blx	r9
    ef3e:	2800      	cmp	r0, #0
    ef40:	d0fb      	beq.n	ef3a <usart_sync_write+0x36>
			;
	} while (++offset < length);
    ef42:	3701      	adds	r7, #1
    ef44:	42bd      	cmp	r5, r7
    ef46:	d8f5      	bhi.n	ef34 <usart_sync_write+0x30>
    ef48:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
    ef4a:	4e09      	ldr	r6, [pc, #36]	; (ef70 <usart_sync_write+0x6c>)
    ef4c:	bf08      	it	eq
    ef4e:	2501      	moveq	r5, #1
    ef50:	4620      	mov	r0, r4
    ef52:	47b0      	blx	r6
    ef54:	2800      	cmp	r0, #0
    ef56:	d0fb      	beq.n	ef50 <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
    ef58:	4628      	mov	r0, r5
    ef5a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    ef5e:	4608      	mov	r0, r1
    ef60:	e7da      	b.n	ef18 <usart_sync_write+0x14>
    ef62:	bf00      	nop
    ef64:	00016a1c 	.word	0x00016a1c
    ef68:	0000e42d 	.word	0x0000e42d
    ef6c:	00011459 	.word	0x00011459
    ef70:	00011463 	.word	0x00011463
    ef74:	00011445 	.word	0x00011445

0000ef78 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    ef78:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ef7c:	460e      	mov	r6, r1
    ef7e:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    ef80:	4604      	mov	r4, r0
    ef82:	b118      	cbz	r0, ef8c <usart_sync_read+0x14>
    ef84:	b1e9      	cbz	r1, efc2 <usart_sync_read+0x4a>
    ef86:	1e10      	subs	r0, r2, #0
    ef88:	bf18      	it	ne
    ef8a:	2001      	movne	r0, #1
    ef8c:	490e      	ldr	r1, [pc, #56]	; (efc8 <usart_sync_read+0x50>)
    ef8e:	4b0f      	ldr	r3, [pc, #60]	; (efcc <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    ef90:	f8df 903c 	ldr.w	r9, [pc, #60]	; efd0 <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    ef94:	f8df 803c 	ldr.w	r8, [pc, #60]	; efd4 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
    ef98:	f44f 7286 	mov.w	r2, #268	; 0x10c
    ef9c:	4798      	blx	r3
	uint32_t                      offset = 0;
    ef9e:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
    efa0:	3408      	adds	r4, #8
    efa2:	4620      	mov	r0, r4
    efa4:	47c8      	blx	r9
    efa6:	2800      	cmp	r0, #0
    efa8:	d0fb      	beq.n	efa2 <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    efaa:	4620      	mov	r0, r4
    efac:	47c0      	blx	r8
    efae:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
    efb0:	3701      	adds	r7, #1
    efb2:	42bd      	cmp	r5, r7
    efb4:	d8f5      	bhi.n	efa2 <usart_sync_read+0x2a>

	return (int32_t)offset;
    efb6:	2d00      	cmp	r5, #0
}
    efb8:	bf14      	ite	ne
    efba:	4628      	movne	r0, r5
    efbc:	2001      	moveq	r0, #1
    efbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    efc2:	4608      	mov	r0, r1
    efc4:	e7e2      	b.n	ef8c <usart_sync_read+0x14>
    efc6:	bf00      	nop
    efc8:	00016a1c 	.word	0x00016a1c
    efcc:	0000e42d 	.word	0x0000e42d
    efd0:	0001146d 	.word	0x0001146d
    efd4:	00011451 	.word	0x00011451

0000efd8 <usart_sync_init>:
{
    efd8:	b538      	push	{r3, r4, r5, lr}
    efda:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    efdc:	4604      	mov	r4, r0
    efde:	b110      	cbz	r0, efe6 <usart_sync_init+0xe>
    efe0:	1e08      	subs	r0, r1, #0
    efe2:	bf18      	it	ne
    efe4:	2001      	movne	r0, #1
    efe6:	4907      	ldr	r1, [pc, #28]	; (f004 <usart_sync_init+0x2c>)
    efe8:	4b07      	ldr	r3, [pc, #28]	; (f008 <usart_sync_init+0x30>)
    efea:	2234      	movs	r2, #52	; 0x34
    efec:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    efee:	4b07      	ldr	r3, [pc, #28]	; (f00c <usart_sync_init+0x34>)
    eff0:	4629      	mov	r1, r5
    eff2:	f104 0008 	add.w	r0, r4, #8
    eff6:	4798      	blx	r3
	if (init_status) {
    eff8:	b918      	cbnz	r0, f002 <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
    effa:	4b05      	ldr	r3, [pc, #20]	; (f010 <usart_sync_init+0x38>)
    effc:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    effe:	4b05      	ldr	r3, [pc, #20]	; (f014 <usart_sync_init+0x3c>)
    f000:	6023      	str	r3, [r4, #0]
}
    f002:	bd38      	pop	{r3, r4, r5, pc}
    f004:	00016a1c 	.word	0x00016a1c
    f008:	0000e42d 	.word	0x0000e42d
    f00c:	00011361 	.word	0x00011361
    f010:	0000ef79 	.word	0x0000ef79
    f014:	0000ef05 	.word	0x0000ef05

0000f018 <usart_sync_enable>:
{
    f018:	b510      	push	{r4, lr}
	ASSERT(descr);
    f01a:	4604      	mov	r4, r0
    f01c:	3800      	subs	r0, #0
    f01e:	bf18      	it	ne
    f020:	2001      	movne	r0, #1
    f022:	4905      	ldr	r1, [pc, #20]	; (f038 <usart_sync_enable+0x20>)
    f024:	4b05      	ldr	r3, [pc, #20]	; (f03c <usart_sync_enable+0x24>)
    f026:	2253      	movs	r2, #83	; 0x53
    f028:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    f02a:	f104 0008 	add.w	r0, r4, #8
    f02e:	4b04      	ldr	r3, [pc, #16]	; (f040 <usart_sync_enable+0x28>)
    f030:	4798      	blx	r3
}
    f032:	2000      	movs	r0, #0
    f034:	bd10      	pop	{r4, pc}
    f036:	bf00      	nop
    f038:	00016a1c 	.word	0x00016a1c
    f03c:	0000e42d 	.word	0x0000e42d
    f040:	00011405 	.word	0x00011405

0000f044 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    f044:	4b01      	ldr	r3, [pc, #4]	; (f04c <_mclk_init+0x8>)
    f046:	2201      	movs	r2, #1
    f048:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    f04a:	4770      	bx	lr
    f04c:	40000800 	.word	0x40000800

0000f050 <hri_gclk_wait_for_sync.constprop.0>:
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    f050:	4903      	ldr	r1, [pc, #12]	; (f060 <hri_gclk_wait_for_sync.constprop.0+0x10>)
    f052:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    f056:	684a      	ldr	r2, [r1, #4]
    f058:	421a      	tst	r2, r3
    f05a:	d1fc      	bne.n	f056 <hri_gclk_wait_for_sync.constprop.0+0x6>
}
    f05c:	4770      	bx	lr
    f05e:	bf00      	nop
    f060:	40001c00 	.word	0x40001c00

0000f064 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    f064:	b510      	push	{r4, lr}

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    f066:	07c4      	lsls	r4, r0, #31
    f068:	d504      	bpl.n	f074 <_gclk_init_generators_by_fref+0x10>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f06a:	4b0e      	ldr	r3, [pc, #56]	; (f0a4 <_gclk_init_generators_by_fref+0x40>)
    f06c:	4a0e      	ldr	r2, [pc, #56]	; (f0a8 <_gclk_init_generators_by_fref+0x44>)
    f06e:	621a      	str	r2, [r3, #32]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f070:	4b0e      	ldr	r3, [pc, #56]	; (f0ac <_gclk_init_generators_by_fref+0x48>)
    f072:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    f074:	0781      	lsls	r1, r0, #30
    f076:	d504      	bpl.n	f082 <_gclk_init_generators_by_fref+0x1e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f078:	4b0a      	ldr	r3, [pc, #40]	; (f0a4 <_gclk_init_generators_by_fref+0x40>)
    f07a:	4a0d      	ldr	r2, [pc, #52]	; (f0b0 <_gclk_init_generators_by_fref+0x4c>)
    f07c:	625a      	str	r2, [r3, #36]	; 0x24
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f07e:	4b0b      	ldr	r3, [pc, #44]	; (f0ac <_gclk_init_generators_by_fref+0x48>)
    f080:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    f082:	0742      	lsls	r2, r0, #29
    f084:	d504      	bpl.n	f090 <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f086:	4b07      	ldr	r3, [pc, #28]	; (f0a4 <_gclk_init_generators_by_fref+0x40>)
    f088:	4a0a      	ldr	r2, [pc, #40]	; (f0b4 <_gclk_init_generators_by_fref+0x50>)
    f08a:	629a      	str	r2, [r3, #40]	; 0x28
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f08c:	4b07      	ldr	r3, [pc, #28]	; (f0ac <_gclk_init_generators_by_fref+0x48>)
    f08e:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    f090:	0703      	lsls	r3, r0, #28
    f092:	d506      	bpl.n	f0a2 <_gclk_init_generators_by_fref+0x3e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f094:	4b03      	ldr	r3, [pc, #12]	; (f0a4 <_gclk_init_generators_by_fref+0x40>)
    f096:	4a08      	ldr	r2, [pc, #32]	; (f0b8 <_gclk_init_generators_by_fref+0x54>)
    f098:	62da      	str	r2, [r3, #44]	; 0x2c
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    f09a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f09e:	4b03      	ldr	r3, [pc, #12]	; (f0ac <_gclk_init_generators_by_fref+0x48>)
    f0a0:	4718      	bx	r3
    f0a2:	bd10      	pop	{r4, pc}
    f0a4:	40001c00 	.word	0x40001c00
    f0a8:	00010108 	.word	0x00010108
    f0ac:	0000f051 	.word	0x0000f051
    f0b0:	00010106 	.word	0x00010106
    f0b4:	00100106 	.word	0x00100106
    f0b8:	00010104 	.word	0x00010104

0000f0bc <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    f0bc:	b510      	push	{r4, lr}

	usart_sync_enable(&GRID_AUX);
    f0be:	4c04      	ldr	r4, [pc, #16]	; (f0d0 <stdio_redirect_init+0x14>)
    f0c0:	4b04      	ldr	r3, [pc, #16]	; (f0d4 <stdio_redirect_init+0x18>)
    f0c2:	4620      	mov	r0, r4
    f0c4:	4798      	blx	r3
	stdio_io_init(&GRID_AUX.io);
    f0c6:	4620      	mov	r0, r4
    f0c8:	4b03      	ldr	r3, [pc, #12]	; (f0d8 <stdio_redirect_init+0x1c>)
}
    f0ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&GRID_AUX.io);
    f0ce:	4718      	bx	r3
    f0d0:	2001cd70 	.word	0x2001cd70
    f0d4:	0000f019 	.word	0x0000f019
    f0d8:	0000bc7d 	.word	0x0000bc7d

0000f0dc <flash_ready>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    f0dc:	6943      	ldr	r3, [r0, #20]
    f0de:	b103      	cbz	r3, f0e2 <flash_ready+0x6>
		descr->callbacks.cb_ready(descr);
    f0e0:	4718      	bx	r3
	}
}
    f0e2:	4770      	bx	lr

0000f0e4 <flash_error>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    f0e4:	6983      	ldr	r3, [r0, #24]
    f0e6:	b103      	cbz	r3, f0ea <flash_error+0x6>
		descr->callbacks.cb_error(descr);
    f0e8:	4718      	bx	r3
	}
}
    f0ea:	4770      	bx	lr

0000f0ec <flash_is_address_aligned>:
{
    f0ec:	b538      	push	{r3, r4, r5, lr}
	ASSERT(flash);
    f0ee:	4604      	mov	r4, r0
    f0f0:	3800      	subs	r0, #0
    f0f2:	bf18      	it	ne
    f0f4:	2001      	movne	r0, #1
{
    f0f6:	460d      	mov	r5, r1
	ASSERT(flash);
    f0f8:	f240 1217 	movw	r2, #279	; 0x117
    f0fc:	4906      	ldr	r1, [pc, #24]	; (f118 <flash_is_address_aligned+0x2c>)
    f0fe:	4b07      	ldr	r3, [pc, #28]	; (f11c <flash_is_address_aligned+0x30>)
    f100:	4798      	blx	r3
	uint32_t page_size = _flash_get_page_size(&flash->dev);
    f102:	4b07      	ldr	r3, [pc, #28]	; (f120 <flash_is_address_aligned+0x34>)
    f104:	4620      	mov	r0, r4
    f106:	4798      	blx	r3
	if (flash_addr & (page_size - 1)) {
    f108:	3801      	subs	r0, #1
    f10a:	4228      	tst	r0, r5
}
    f10c:	bf14      	ite	ne
    f10e:	f06f 000d 	mvnne.w	r0, #13
    f112:	2000      	moveq	r0, #0
    f114:	bd38      	pop	{r3, r4, r5, pc}
    f116:	bf00      	nop
    f118:	00016a38 	.word	0x00016a38
    f11c:	0000e42d 	.word	0x0000e42d
    f120:	0000c321 	.word	0x0000c321

0000f124 <flash_init>:
{
    f124:	b538      	push	{r3, r4, r5, lr}
    f126:	460d      	mov	r5, r1
	ASSERT(flash && hw);
    f128:	4604      	mov	r4, r0
    f12a:	b110      	cbz	r0, f132 <flash_init+0xe>
    f12c:	1e08      	subs	r0, r1, #0
    f12e:	bf18      	it	ne
    f130:	2001      	movne	r0, #1
    f132:	4907      	ldr	r1, [pc, #28]	; (f150 <flash_init+0x2c>)
    f134:	4b07      	ldr	r3, [pc, #28]	; (f154 <flash_init+0x30>)
    f136:	2238      	movs	r2, #56	; 0x38
    f138:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    f13a:	4b07      	ldr	r3, [pc, #28]	; (f158 <flash_init+0x34>)
    f13c:	4629      	mov	r1, r5
    f13e:	4620      	mov	r0, r4
    f140:	4798      	blx	r3
	if (rc) {
    f142:	b918      	cbnz	r0, f14c <flash_init+0x28>
	flash->dev.flash_cb.ready_cb = flash_ready;
    f144:	4b05      	ldr	r3, [pc, #20]	; (f15c <flash_init+0x38>)
    f146:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    f148:	4b05      	ldr	r3, [pc, #20]	; (f160 <flash_init+0x3c>)
    f14a:	6063      	str	r3, [r4, #4]
}
    f14c:	bd38      	pop	{r3, r4, r5, pc}
    f14e:	bf00      	nop
    f150:	00016a38 	.word	0x00016a38
    f154:	0000e42d 	.word	0x0000e42d
    f158:	0000c2b1 	.word	0x0000c2b1
    f15c:	0000f0dd 	.word	0x0000f0dd
    f160:	0000f0e5 	.word	0x0000f0e5

0000f164 <flash_read>:
{
    f164:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f168:	460d      	mov	r5, r1
    f16a:	4616      	mov	r6, r2
    f16c:	461f      	mov	r7, r3
	ASSERT(flash && buffer && length);
    f16e:	4604      	mov	r4, r0
    f170:	b118      	cbz	r0, f17a <flash_read+0x16>
    f172:	b1ea      	cbz	r2, f1b0 <flash_read+0x4c>
    f174:	1e18      	subs	r0, r3, #0
    f176:	bf18      	it	ne
    f178:	2001      	movne	r0, #1
    f17a:	4910      	ldr	r1, [pc, #64]	; (f1bc <flash_read+0x58>)
    f17c:	4b10      	ldr	r3, [pc, #64]	; (f1c0 <flash_read+0x5c>)
    f17e:	2256      	movs	r2, #86	; 0x56
    f180:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f182:	4b10      	ldr	r3, [pc, #64]	; (f1c4 <flash_read+0x60>)
    f184:	4620      	mov	r0, r4
    f186:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f188:	4b0f      	ldr	r3, [pc, #60]	; (f1c8 <flash_read+0x64>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f18a:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f18c:	4620      	mov	r0, r4
    f18e:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    f190:	fb00 f008 	mul.w	r0, r0, r8
    f194:	42a8      	cmp	r0, r5
    f196:	d30d      	bcc.n	f1b4 <flash_read+0x50>
    f198:	197b      	adds	r3, r7, r5
    f19a:	4298      	cmp	r0, r3
    f19c:	d30a      	bcc.n	f1b4 <flash_read+0x50>
	_flash_read(&flash->dev, src_addr, buffer, length);
    f19e:	4620      	mov	r0, r4
    f1a0:	463b      	mov	r3, r7
    f1a2:	4c0a      	ldr	r4, [pc, #40]	; (f1cc <flash_read+0x68>)
    f1a4:	4632      	mov	r2, r6
    f1a6:	4629      	mov	r1, r5
    f1a8:	47a0      	blx	r4
	return ERR_NONE;
    f1aa:	2000      	movs	r0, #0
}
    f1ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    f1b0:	4610      	mov	r0, r2
    f1b2:	e7e2      	b.n	f17a <flash_read+0x16>
		return ERR_BAD_ADDRESS;
    f1b4:	f06f 000d 	mvn.w	r0, #13
    f1b8:	e7f8      	b.n	f1ac <flash_read+0x48>
    f1ba:	bf00      	nop
    f1bc:	00016a38 	.word	0x00016a38
    f1c0:	0000e42d 	.word	0x0000e42d
    f1c4:	0000c321 	.word	0x0000c321
    f1c8:	0000c327 	.word	0x0000c327
    f1cc:	0000c32f 	.word	0x0000c32f

0000f1d0 <flash_write>:
{
    f1d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f1d4:	460e      	mov	r6, r1
    f1d6:	4617      	mov	r7, r2
    f1d8:	4698      	mov	r8, r3
	ASSERT(flash && buffer && length);
    f1da:	4605      	mov	r5, r0
    f1dc:	b118      	cbz	r0, f1e6 <flash_write+0x16>
    f1de:	b31a      	cbz	r2, f228 <flash_write+0x58>
    f1e0:	1e18      	subs	r0, r3, #0
    f1e2:	bf18      	it	ne
    f1e4:	2001      	movne	r0, #1
    f1e6:	4914      	ldr	r1, [pc, #80]	; (f238 <flash_write+0x68>)
    f1e8:	4b14      	ldr	r3, [pc, #80]	; (f23c <flash_write+0x6c>)
    f1ea:	226a      	movs	r2, #106	; 0x6a
    f1ec:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f1ee:	4b14      	ldr	r3, [pc, #80]	; (f240 <flash_write+0x70>)
    f1f0:	4628      	mov	r0, r5
    f1f2:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f1f4:	4b13      	ldr	r3, [pc, #76]	; (f244 <flash_write+0x74>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f1f6:	4604      	mov	r4, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f1f8:	4628      	mov	r0, r5
    f1fa:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    f1fc:	4360      	muls	r0, r4
    f1fe:	42b0      	cmp	r0, r6
    f200:	d314      	bcc.n	f22c <flash_write+0x5c>
    f202:	eb08 0306 	add.w	r3, r8, r6
    f206:	4298      	cmp	r0, r3
    f208:	d310      	bcc.n	f22c <flash_write+0x5c>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    f20a:	4b0f      	ldr	r3, [pc, #60]	; (f248 <flash_write+0x78>)
    f20c:	4631      	mov	r1, r6
    f20e:	4628      	mov	r0, r5
    f210:	4798      	blx	r3
    f212:	4604      	mov	r4, r0
    f214:	b968      	cbnz	r0, f232 <flash_write+0x62>
	_flash_write(&flash->dev, dst_addr, buffer, length);
    f216:	4628      	mov	r0, r5
    f218:	4643      	mov	r3, r8
    f21a:	4d0c      	ldr	r5, [pc, #48]	; (f24c <flash_write+0x7c>)
    f21c:	463a      	mov	r2, r7
    f21e:	4631      	mov	r1, r6
    f220:	47a8      	blx	r5
	return ERR_NONE;
    f222:	4620      	mov	r0, r4
}
    f224:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    f228:	4610      	mov	r0, r2
    f22a:	e7dc      	b.n	f1e6 <flash_write+0x16>
		return ERR_BAD_ADDRESS;
    f22c:	f06f 000d 	mvn.w	r0, #13
    f230:	e7f8      	b.n	f224 <flash_write+0x54>
		return ERR_DENIED;
    f232:	f06f 0010 	mvn.w	r0, #16
    f236:	e7f5      	b.n	f224 <flash_write+0x54>
    f238:	00016a38 	.word	0x00016a38
    f23c:	0000e42d 	.word	0x0000e42d
    f240:	0000c321 	.word	0x0000c321
    f244:	0000c327 	.word	0x0000c327
    f248:	0000c4bd 	.word	0x0000c4bd
    f24c:	0000c349 	.word	0x0000c349

0000f250 <flash_erase>:
{
    f250:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f254:	4688      	mov	r8, r1
    f256:	4617      	mov	r7, r2
	ASSERT(flash && page_nums);
    f258:	4604      	mov	r4, r0
    f25a:	b110      	cbz	r0, f262 <flash_erase+0x12>
    f25c:	1e10      	subs	r0, r2, #0
    f25e:	bf18      	it	ne
    f260:	2001      	movne	r0, #1
    f262:	4912      	ldr	r1, [pc, #72]	; (f2ac <flash_erase+0x5c>)
    f264:	4b12      	ldr	r3, [pc, #72]	; (f2b0 <flash_erase+0x60>)
    f266:	229a      	movs	r2, #154	; 0x9a
    f268:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f26a:	4b12      	ldr	r3, [pc, #72]	; (f2b4 <flash_erase+0x64>)
    f26c:	4620      	mov	r0, r4
    f26e:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f270:	4b11      	ldr	r3, [pc, #68]	; (f2b8 <flash_erase+0x68>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f272:	4605      	mov	r5, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f274:	4620      	mov	r0, r4
    f276:	4798      	blx	r3
	rc = flash_is_address_aligned(flash, dst_addr);
    f278:	4b10      	ldr	r3, [pc, #64]	; (f2bc <flash_erase+0x6c>)
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f27a:	4681      	mov	r9, r0
	rc = flash_is_address_aligned(flash, dst_addr);
    f27c:	4641      	mov	r1, r8
    f27e:	4620      	mov	r0, r4
    f280:	4798      	blx	r3
	if (rc) {
    f282:	4606      	mov	r6, r0
    f284:	b958      	cbnz	r0, f29e <flash_erase+0x4e>
	if ((page_nums > total_pages) || (dst_addr / page_size + page_nums > total_pages)) {
    f286:	454f      	cmp	r7, r9
    f288:	d80c      	bhi.n	f2a4 <flash_erase+0x54>
    f28a:	fbb8 f5f5 	udiv	r5, r8, r5
    f28e:	443d      	add	r5, r7
    f290:	454d      	cmp	r5, r9
    f292:	d807      	bhi.n	f2a4 <flash_erase+0x54>
	_flash_erase(&flash->dev, dst_addr, page_nums);
    f294:	4b0a      	ldr	r3, [pc, #40]	; (f2c0 <flash_erase+0x70>)
    f296:	463a      	mov	r2, r7
    f298:	4641      	mov	r1, r8
    f29a:	4620      	mov	r0, r4
    f29c:	4798      	blx	r3
}
    f29e:	4630      	mov	r0, r6
    f2a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ERR_INVALID_ARG;
    f2a4:	f06f 060c 	mvn.w	r6, #12
    f2a8:	e7f9      	b.n	f29e <flash_erase+0x4e>
    f2aa:	bf00      	nop
    f2ac:	00016a38 	.word	0x00016a38
    f2b0:	0000e42d 	.word	0x0000e42d
    f2b4:	0000c321 	.word	0x0000c321
    f2b8:	0000c327 	.word	0x0000c327
    f2bc:	0000f0ed 	.word	0x0000f0ed
    f2c0:	0000c411 	.word	0x0000c411

0000f2c4 <_spi_m_async_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_async_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    f2c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(io);
    f2c6:	4604      	mov	r4, r0
    f2c8:	3800      	subs	r0, #0
    f2ca:	bf18      	it	ne
    f2cc:	2001      	movne	r0, #1
{
    f2ce:	460f      	mov	r7, r1
    f2d0:	4616      	mov	r6, r2
	ASSERT(io);
    f2d2:	4909      	ldr	r1, [pc, #36]	; (f2f8 <_spi_m_async_io_write+0x34>)
    f2d4:	4b09      	ldr	r3, [pc, #36]	; (f2fc <_spi_m_async_io_write+0x38>)
    f2d6:	f240 1227 	movw	r2, #295	; 0x127
    f2da:	4798      	blx	r3
	struct spi_m_async_descriptor *spi = CONTAINER_OF(io, struct spi_m_async_descriptor, io);

	spi->xfer.rxbuf = NULL;
    f2dc:	2500      	movs	r5, #0
	spi->xfer.txbuf = (uint8_t *)buf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f2de:	2310      	movs	r3, #16
    f2e0:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = (uint8_t *)buf;
    f2e2:	e9c4 7505 	strd	r7, r5, [r4, #20]
	spi->xfercnt    = 0;
    f2e6:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_tx(&spi->dev, true);
    f2ea:	4b05      	ldr	r3, [pc, #20]	; (f300 <_spi_m_async_io_write+0x3c>)
    f2ec:	2101      	movs	r1, #1
    f2ee:	f1a4 0020 	sub.w	r0, r4, #32
    f2f2:	4798      	blx	r3

	return ERR_NONE;
}
    f2f4:	4628      	mov	r0, r5
    f2f6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f2f8:	00016a4f 	.word	0x00016a4f
    f2fc:	0000e42d 	.word	0x0000e42d
    f300:	00011a0d 	.word	0x00011a0d

0000f304 <_spi_m_async_io_read>:
{
    f304:	b570      	push	{r4, r5, r6, lr}
	ASSERT(io);
    f306:	4604      	mov	r4, r0
    f308:	3800      	subs	r0, #0
    f30a:	bf18      	it	ne
    f30c:	2001      	movne	r0, #1
{
    f30e:	460d      	mov	r5, r1
    f310:	4616      	mov	r6, r2
	ASSERT(io);
    f312:	490c      	ldr	r1, [pc, #48]	; (f344 <_spi_m_async_io_read+0x40>)
    f314:	4b0c      	ldr	r3, [pc, #48]	; (f348 <_spi_m_async_io_read+0x44>)
    f316:	f240 1205 	movw	r2, #261	; 0x105
    f31a:	4798      	blx	r3
	spi->xfer.rxbuf = buf;
    f31c:	61a5      	str	r5, [r4, #24]
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f31e:	2310      	movs	r3, #16
	spi->xfer.txbuf = NULL;
    f320:	2500      	movs	r5, #0
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f322:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = NULL;
    f324:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
    f326:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_rx(&spi->dev, true);
    f32a:	3c20      	subs	r4, #32
    f32c:	4b07      	ldr	r3, [pc, #28]	; (f34c <_spi_m_async_io_read+0x48>)
    f32e:	2101      	movs	r1, #1
    f330:	4620      	mov	r0, r4
    f332:	4798      	blx	r3
	_spi_m_async_write_one(&spi->dev, SPI_DUMMY_CHAR);
    f334:	4b06      	ldr	r3, [pc, #24]	; (f350 <_spi_m_async_io_read+0x4c>)
    f336:	f240 11ff 	movw	r1, #511	; 0x1ff
    f33a:	4620      	mov	r0, r4
    f33c:	4798      	blx	r3
}
    f33e:	4628      	mov	r0, r5
    f340:	bd70      	pop	{r4, r5, r6, pc}
    f342:	bf00      	nop
    f344:	00016a4f 	.word	0x00016a4f
    f348:	0000e42d 	.word	0x0000e42d
    f34c:	00011a39 	.word	0x00011a39
    f350:	00011aa5 	.word	0x00011aa5

0000f354 <_spi_dev_error>:
{
    f354:	b570      	push	{r4, r5, r6, lr}
	_spi_m_async_enable_tx(dev, false);
    f356:	4b0c      	ldr	r3, [pc, #48]	; (f388 <_spi_dev_error+0x34>)
{
    f358:	4604      	mov	r4, r0
    f35a:	460d      	mov	r5, r1
	_spi_m_async_enable_tx(dev, false);
    f35c:	2100      	movs	r1, #0
    f35e:	4798      	blx	r3
	_spi_m_async_enable_rx(dev, false);
    f360:	4b0a      	ldr	r3, [pc, #40]	; (f38c <_spi_dev_error+0x38>)
    f362:	2100      	movs	r1, #0
    f364:	4620      	mov	r0, r4
    f366:	4798      	blx	r3
	_spi_m_async_enable_tx_complete(dev, false);
    f368:	4b09      	ldr	r3, [pc, #36]	; (f390 <_spi_dev_error+0x3c>)
    f36a:	2100      	movs	r1, #0
    f36c:	4620      	mov	r0, r4
    f36e:	4798      	blx	r3
	spi->stat = 0;
    f370:	2300      	movs	r3, #0
    f372:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	if (spi->callbacks.cb_error) {
    f376:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f378:	b123      	cbz	r3, f384 <_spi_dev_error+0x30>
		spi->callbacks.cb_error(spi, status);
    f37a:	4629      	mov	r1, r5
    f37c:	1f20      	subs	r0, r4, #4
}
    f37e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		spi->callbacks.cb_error(spi, status);
    f382:	4718      	bx	r3
}
    f384:	bd70      	pop	{r4, r5, r6, pc}
    f386:	bf00      	nop
    f388:	00011a0d 	.word	0x00011a0d
    f38c:	00011a39 	.word	0x00011a39
    f390:	00011a71 	.word	0x00011a71

0000f394 <_spi_dev_complete>:
	if (spi->xfercnt >= spi->xfer.size) {
    f394:	e9d0 320f 	ldrd	r3, r2, [r0, #60]	; 0x3c
    f398:	429a      	cmp	r2, r3
{
    f39a:	b510      	push	{r4, lr}
    f39c:	4604      	mov	r4, r0
	if (spi->xfercnt >= spi->xfer.size) {
    f39e:	d30b      	bcc.n	f3b8 <_spi_dev_complete+0x24>
		_spi_m_async_enable_tx_complete(dev, false);
    f3a0:	4b06      	ldr	r3, [pc, #24]	; (f3bc <_spi_dev_complete+0x28>)
    f3a2:	2100      	movs	r1, #0
    f3a4:	4798      	blx	r3
		spi->stat = 0;
    f3a6:	2300      	movs	r3, #0
    f3a8:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f3ac:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f3ae:	b11b      	cbz	r3, f3b8 <_spi_dev_complete+0x24>
			spi->callbacks.cb_xfer(spi);
    f3b0:	1f20      	subs	r0, r4, #4
}
    f3b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			spi->callbacks.cb_xfer(spi);
    f3b6:	4718      	bx	r3
}
    f3b8:	bd10      	pop	{r4, pc}
    f3ba:	bf00      	nop
    f3bc:	00011a71 	.word	0x00011a71

0000f3c0 <_spi_dev_rx>:
{
    f3c0:	b570      	push	{r4, r5, r6, lr}
	if (spi->xfer.rxbuf) {
    f3c2:	6b85      	ldr	r5, [r0, #56]	; 0x38
    f3c4:	4b1c      	ldr	r3, [pc, #112]	; (f438 <_spi_dev_rx+0x78>)
{
    f3c6:	4604      	mov	r4, r0
	if (spi->xfer.rxbuf) {
    f3c8:	b305      	cbz	r5, f40c <_spi_dev_rx+0x4c>
		if (!(dev->char_size > 1)) {
    f3ca:	7902      	ldrb	r2, [r0, #4]
    f3cc:	2a01      	cmp	r2, #1
    f3ce:	d816      	bhi.n	f3fe <_spi_dev_rx+0x3e>
			spi->xfer.rxbuf[spi->xfercnt++] = (uint8_t)_spi_m_async_read_one(dev);
    f3d0:	4798      	blx	r3
    f3d2:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f3d4:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    f3d6:	1c59      	adds	r1, r3, #1
    f3d8:	6421      	str	r1, [r4, #64]	; 0x40
    f3da:	54d0      	strb	r0, [r2, r3]
	if (spi->xfercnt < spi->xfer.size) {
    f3dc:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    f3e0:	4299      	cmp	r1, r3
    f3e2:	d21a      	bcs.n	f41a <_spi_dev_rx+0x5a>
		if (spi->xfer.txbuf) {
    f3e4:	6b62      	ldr	r2, [r4, #52]	; 0x34
    f3e6:	4b15      	ldr	r3, [pc, #84]	; (f43c <_spi_dev_rx+0x7c>)
    f3e8:	b1aa      	cbz	r2, f416 <_spi_dev_rx+0x56>
			if (!(dev->char_size > 1)) {
    f3ea:	7920      	ldrb	r0, [r4, #4]
    f3ec:	2801      	cmp	r0, #1
				_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt]);
    f3ee:	bf94      	ite	ls
    f3f0:	5c51      	ldrbls	r1, [r2, r1]
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f3f2:	f832 1011 	ldrhhi.w	r1, [r2, r1, lsl #1]
    f3f6:	4620      	mov	r0, r4
}
    f3f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f3fc:	4718      	bx	r3
			((uint16_t *)spi->xfer.rxbuf)[spi->xfercnt++] = (uint16_t)_spi_m_async_read_one(dev);
    f3fe:	6c06      	ldr	r6, [r0, #64]	; 0x40
    f400:	1c72      	adds	r2, r6, #1
    f402:	6402      	str	r2, [r0, #64]	; 0x40
    f404:	4798      	blx	r3
    f406:	f825 0016 	strh.w	r0, [r5, r6, lsl #1]
    f40a:	e7e7      	b.n	f3dc <_spi_dev_rx+0x1c>
		_spi_m_async_read_one(dev);
    f40c:	4798      	blx	r3
		spi->xfercnt++;
    f40e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f410:	3301      	adds	r3, #1
    f412:	6423      	str	r3, [r4, #64]	; 0x40
    f414:	e7e2      	b.n	f3dc <_spi_dev_rx+0x1c>
			_spi_m_async_write_one(dev, dev->dummy_byte);
    f416:	88e1      	ldrh	r1, [r4, #6]
    f418:	e7ed      	b.n	f3f6 <_spi_dev_rx+0x36>
		_spi_m_async_enable_rx(dev, false);
    f41a:	4b09      	ldr	r3, [pc, #36]	; (f440 <_spi_dev_rx+0x80>)
    f41c:	2100      	movs	r1, #0
    f41e:	4620      	mov	r0, r4
    f420:	4798      	blx	r3
		spi->stat = 0;
    f422:	2300      	movs	r3, #0
    f424:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f428:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f42a:	b11b      	cbz	r3, f434 <_spi_dev_rx+0x74>
			spi->callbacks.cb_xfer(spi);
    f42c:	1f20      	subs	r0, r4, #4
}
    f42e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			spi->callbacks.cb_xfer(spi);
    f432:	4718      	bx	r3
}
    f434:	bd70      	pop	{r4, r5, r6, pc}
    f436:	bf00      	nop
    f438:	00011ad1 	.word	0x00011ad1
    f43c:	00011aa5 	.word	0x00011aa5
    f440:	00011a39 	.word	0x00011a39

0000f444 <_spi_dev_tx>:
{
    f444:	b570      	push	{r4, r5, r6, lr}
    f446:	6c03      	ldr	r3, [r0, #64]	; 0x40
	if (!(dev->char_size > 1)) {
    f448:	7902      	ldrb	r2, [r0, #4]
    f44a:	6b41      	ldr	r1, [r0, #52]	; 0x34
    f44c:	1c5d      	adds	r5, r3, #1
    f44e:	2a01      	cmp	r2, #1
		_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt++]);
    f450:	6405      	str	r5, [r0, #64]	; 0x40
    f452:	bf94      	ite	ls
    f454:	5cc9      	ldrbls	r1, [r1, r3]
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f456:	f831 1013 	ldrhhi.w	r1, [r1, r3, lsl #1]
    f45a:	4a09      	ldr	r2, [pc, #36]	; (f480 <_spi_dev_tx+0x3c>)
{
    f45c:	4604      	mov	r4, r0
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f45e:	4790      	blx	r2
	if (spi->xfercnt == spi->xfer.size) {
    f460:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
    f464:	429a      	cmp	r2, r3
    f466:	d109      	bne.n	f47c <_spi_dev_tx+0x38>
		_spi_m_async_enable_tx(dev, false);
    f468:	4b06      	ldr	r3, [pc, #24]	; (f484 <_spi_dev_tx+0x40>)
    f46a:	2100      	movs	r1, #0
    f46c:	4620      	mov	r0, r4
    f46e:	4798      	blx	r3
		_spi_m_async_enable_tx_complete(dev, true);
    f470:	4620      	mov	r0, r4
    f472:	4b05      	ldr	r3, [pc, #20]	; (f488 <_spi_dev_tx+0x44>)
}
    f474:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_enable_tx_complete(dev, true);
    f478:	2101      	movs	r1, #1
    f47a:	4718      	bx	r3
}
    f47c:	bd70      	pop	{r4, r5, r6, pc}
    f47e:	bf00      	nop
    f480:	00011aa5 	.word	0x00011aa5
    f484:	00011a0d 	.word	0x00011a0d
    f488:	00011a71 	.word	0x00011a71

0000f48c <spi_m_async_init>:
{
    f48c:	b570      	push	{r4, r5, r6, lr}
    f48e:	460e      	mov	r6, r1
	ASSERT(spi && hw);
    f490:	4604      	mov	r4, r0
    f492:	b110      	cbz	r0, f49a <spi_m_async_init+0xe>
    f494:	1e08      	subs	r0, r1, #0
    f496:	bf18      	it	ne
    f498:	2001      	movne	r0, #1
	spi->dev.prvt = (void *)hw;
    f49a:	4625      	mov	r5, r4
	ASSERT(spi && hw);
    f49c:	4911      	ldr	r1, [pc, #68]	; (f4e4 <spi_m_async_init+0x58>)
    f49e:	4b12      	ldr	r3, [pc, #72]	; (f4e8 <spi_m_async_init+0x5c>)
    f4a0:	22a5      	movs	r2, #165	; 0xa5
    f4a2:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    f4a4:	f845 6f04 	str.w	r6, [r5, #4]!
	rc            = _spi_m_async_init(&spi->dev, hw);
    f4a8:	4b10      	ldr	r3, [pc, #64]	; (f4ec <spi_m_async_init+0x60>)
    f4aa:	4631      	mov	r1, r6
    f4ac:	4628      	mov	r0, r5
    f4ae:	4798      	blx	r3
	if (rc >= 0) {
    f4b0:	2800      	cmp	r0, #0
    f4b2:	db15      	blt.n	f4e0 <spi_m_async_init+0x54>
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (FUNC_PTR)_spi_dev_tx);
    f4b4:	4e0e      	ldr	r6, [pc, #56]	; (f4f0 <spi_m_async_init+0x64>)
    f4b6:	4a0f      	ldr	r2, [pc, #60]	; (f4f4 <spi_m_async_init+0x68>)
    f4b8:	2100      	movs	r1, #0
    f4ba:	4628      	mov	r0, r5
    f4bc:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (FUNC_PTR)_spi_dev_rx);
    f4be:	4a0e      	ldr	r2, [pc, #56]	; (f4f8 <spi_m_async_init+0x6c>)
    f4c0:	2101      	movs	r1, #1
    f4c2:	4628      	mov	r0, r5
    f4c4:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (FUNC_PTR)_spi_dev_complete);
    f4c6:	4a0d      	ldr	r2, [pc, #52]	; (f4fc <spi_m_async_init+0x70>)
    f4c8:	2102      	movs	r1, #2
    f4ca:	4628      	mov	r0, r5
    f4cc:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_ERROR, (FUNC_PTR)_spi_dev_error);
    f4ce:	4a0c      	ldr	r2, [pc, #48]	; (f500 <spi_m_async_init+0x74>)
    f4d0:	2103      	movs	r1, #3
    f4d2:	4628      	mov	r0, r5
    f4d4:	47b0      	blx	r6
	spi->io.read  = _spi_m_async_io_read;
    f4d6:	4b0b      	ldr	r3, [pc, #44]	; (f504 <spi_m_async_init+0x78>)
    f4d8:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->io.write = _spi_m_async_io_write;
    f4da:	4b0b      	ldr	r3, [pc, #44]	; (f508 <spi_m_async_init+0x7c>)
    f4dc:	6263      	str	r3, [r4, #36]	; 0x24
	return ERR_NONE;
    f4de:	2000      	movs	r0, #0
}
    f4e0:	bd70      	pop	{r4, r5, r6, pc}
    f4e2:	bf00      	nop
    f4e4:	00016a4f 	.word	0x00016a4f
    f4e8:	0000e42d 	.word	0x0000e42d
    f4ec:	00011919 	.word	0x00011919
    f4f0:	00011af9 	.word	0x00011af9
    f4f4:	0000f445 	.word	0x0000f445
    f4f8:	0000f3c1 	.word	0x0000f3c1
    f4fc:	0000f395 	.word	0x0000f395
    f500:	0000f355 	.word	0x0000f355
    f504:	0000f305 	.word	0x0000f305
    f508:	0000f2c5 	.word	0x0000f2c5

0000f50c <spi_m_async_enable>:
{
    f50c:	b510      	push	{r4, lr}
	ASSERT(spi);
    f50e:	4604      	mov	r4, r0
    f510:	3800      	subs	r0, #0
    f512:	4b05      	ldr	r3, [pc, #20]	; (f528 <spi_m_async_enable+0x1c>)
    f514:	4905      	ldr	r1, [pc, #20]	; (f52c <spi_m_async_enable+0x20>)
    f516:	bf18      	it	ne
    f518:	2001      	movne	r0, #1
    f51a:	22c1      	movs	r2, #193	; 0xc1
    f51c:	4798      	blx	r3
	_spi_m_async_enable(&spi->dev);
    f51e:	1d20      	adds	r0, r4, #4
    f520:	4b03      	ldr	r3, [pc, #12]	; (f530 <spi_m_async_enable+0x24>)
}
    f522:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_async_enable(&spi->dev);
    f526:	4718      	bx	r3
    f528:	0000e42d 	.word	0x0000e42d
    f52c:	00016a4f 	.word	0x00016a4f
    f530:	00011971 	.word	0x00011971

0000f534 <spi_m_async_set_baudrate>:
{
    f534:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f536:	4604      	mov	r4, r0
    f538:	3800      	subs	r0, #0
    f53a:	4b0a      	ldr	r3, [pc, #40]	; (f564 <spi_m_async_set_baudrate+0x30>)
    f53c:	bf18      	it	ne
    f53e:	2001      	movne	r0, #1
{
    f540:	460d      	mov	r5, r1
	ASSERT(spi);
    f542:	22cf      	movs	r2, #207	; 0xcf
    f544:	4908      	ldr	r1, [pc, #32]	; (f568 <spi_m_async_set_baudrate+0x34>)
    f546:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f548:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f54c:	06db      	lsls	r3, r3, #27
    f54e:	d405      	bmi.n	f55c <spi_m_async_set_baudrate+0x28>
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f550:	4629      	mov	r1, r5
    f552:	1d20      	adds	r0, r4, #4
    f554:	4b05      	ldr	r3, [pc, #20]	; (f56c <spi_m_async_set_baudrate+0x38>)
}
    f556:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    f55a:	4718      	bx	r3
}
    f55c:	f06f 0003 	mvn.w	r0, #3
    f560:	bd70      	pop	{r4, r5, r6, pc}
    f562:	bf00      	nop
    f564:	0000e42d 	.word	0x0000e42d
    f568:	00016a4f 	.word	0x00016a4f
    f56c:	000119d5 	.word	0x000119d5

0000f570 <spi_m_async_set_mode>:
{
    f570:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    f572:	4604      	mov	r4, r0
    f574:	3800      	subs	r0, #0
    f576:	4b0a      	ldr	r3, [pc, #40]	; (f5a0 <spi_m_async_set_mode+0x30>)
    f578:	bf18      	it	ne
    f57a:	2001      	movne	r0, #1
{
    f57c:	460d      	mov	r5, r1
	ASSERT(spi);
    f57e:	22d9      	movs	r2, #217	; 0xd9
    f580:	4908      	ldr	r1, [pc, #32]	; (f5a4 <spi_m_async_set_mode+0x34>)
    f582:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    f584:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    f588:	06db      	lsls	r3, r3, #27
    f58a:	d405      	bmi.n	f598 <spi_m_async_set_mode+0x28>
	return _spi_m_async_set_mode(&spi->dev, mode);
    f58c:	4629      	mov	r1, r5
    f58e:	1d20      	adds	r0, r4, #4
    f590:	4b05      	ldr	r3, [pc, #20]	; (f5a8 <spi_m_async_set_mode+0x38>)
}
    f592:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_mode(&spi->dev, mode);
    f596:	4718      	bx	r3
}
    f598:	f06f 0003 	mvn.w	r0, #3
    f59c:	bd70      	pop	{r4, r5, r6, pc}
    f59e:	bf00      	nop
    f5a0:	0000e42d 	.word	0x0000e42d
    f5a4:	00016a4f 	.word	0x00016a4f
    f5a8:	000119a1 	.word	0x000119a1

0000f5ac <spi_m_async_transfer>:

int32_t spi_m_async_transfer(struct spi_m_async_descriptor *spi, uint8_t const *txbuf, uint8_t *const rxbuf,
                             const uint16_t length)
{
    f5ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(spi);
    f5ae:	4604      	mov	r4, r0
    f5b0:	3800      	subs	r0, #0
{
    f5b2:	461e      	mov	r6, r3
	ASSERT(spi);
    f5b4:	bf18      	it	ne
    f5b6:	2001      	movne	r0, #1
    f5b8:	4b11      	ldr	r3, [pc, #68]	; (f600 <spi_m_async_transfer+0x54>)
{
    f5ba:	460d      	mov	r5, r1
    f5bc:	4617      	mov	r7, r2
	ASSERT(spi);
    f5be:	4911      	ldr	r1, [pc, #68]	; (f604 <spi_m_async_transfer+0x58>)
    f5c0:	f44f 729c 	mov.w	r2, #312	; 0x138
    f5c4:	4798      	blx	r3

	/* Fill transfer descriptor */
	spi->xfer.rxbuf = (uint8_t *)rxbuf;
	spi->xfer.txbuf = (uint8_t *)txbuf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;
    f5c6:	2300      	movs	r3, #0
	spi->xfer.size  = length;
    f5c8:	6426      	str	r6, [r4, #64]	; 0x40
	spi->xfercnt    = 0;
    f5ca:	6463      	str	r3, [r4, #68]	; 0x44

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
	_spi_m_async_enable_rx(&spi->dev, true);
    f5cc:	1d26      	adds	r6, r4, #4
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f5ce:	2310      	movs	r3, #16
    f5d0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	spi->xfer.txbuf = (uint8_t *)txbuf;
    f5d4:	e9c4 570e 	strd	r5, r7, [r4, #56]	; 0x38
	_spi_m_async_enable_rx(&spi->dev, true);
    f5d8:	4b0b      	ldr	r3, [pc, #44]	; (f608 <spi_m_async_transfer+0x5c>)
    f5da:	2101      	movs	r1, #1
    f5dc:	4630      	mov	r0, r6
    f5de:	4798      	blx	r3
	if (txbuf) {
    f5e0:	4b0a      	ldr	r3, [pc, #40]	; (f60c <spi_m_async_transfer+0x60>)
    f5e2:	b155      	cbz	r5, f5fa <spi_m_async_transfer+0x4e>
		if (!(spi->dev.char_size > 1)) {
    f5e4:	7a21      	ldrb	r1, [r4, #8]
    f5e6:	6c62      	ldr	r2, [r4, #68]	; 0x44
    f5e8:	2901      	cmp	r1, #1
			_spi_m_async_write_one(&spi->dev, txbuf[spi->xfercnt]);
    f5ea:	bf94      	ite	ls
    f5ec:	5ca9      	ldrbls	r1, [r5, r2]
		} else {
			_spi_m_async_write_one(&spi->dev, ((uint16_t *)txbuf)[spi->xfercnt]);
    f5ee:	f835 1012 	ldrhhi.w	r1, [r5, r2, lsl #1]
		}
	} else {
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f5f2:	4630      	mov	r0, r6
    f5f4:	4798      	blx	r3
	}

	return ERR_NONE;
}
    f5f6:	2000      	movs	r0, #0
    f5f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    f5fa:	8961      	ldrh	r1, [r4, #10]
    f5fc:	e7f9      	b.n	f5f2 <spi_m_async_transfer+0x46>
    f5fe:	bf00      	nop
    f600:	0000e42d 	.word	0x0000e42d
    f604:	00016a4f 	.word	0x00016a4f
    f608:	00011a39 	.word	0x00011a39
    f60c:	00011aa5 	.word	0x00011aa5

0000f610 <spi_m_async_register_callback>:
	return ERR_NONE;
}

void spi_m_async_register_callback(struct spi_m_async_descriptor *spi, const enum spi_m_async_cb_type type,
                                   FUNC_PTR func)
{
    f610:	b570      	push	{r4, r5, r6, lr}
    f612:	460e      	mov	r6, r1
    f614:	4615      	mov	r5, r2
	ASSERT(spi && (type < SPI_M_ASYNC_CB_N));
    f616:	4604      	mov	r4, r0
    f618:	b118      	cbz	r0, f622 <spi_m_async_register_callback+0x12>
    f61a:	2901      	cmp	r1, #1
    f61c:	bf8c      	ite	hi
    f61e:	2000      	movhi	r0, #0
    f620:	2001      	movls	r0, #1
    f622:	4909      	ldr	r1, [pc, #36]	; (f648 <spi_m_async_register_callback+0x38>)
    f624:	4b09      	ldr	r3, [pc, #36]	; (f64c <spi_m_async_register_callback+0x3c>)
    f626:	f240 1263 	movw	r2, #355	; 0x163
    f62a:	4798      	blx	r3

	if (SPI_M_ASYNC_CB_XFER == type) {
    f62c:	b90e      	cbnz	r6, f632 <spi_m_async_register_callback+0x22>
		spi->callbacks.cb_xfer = (spi_m_async_cb_xfer_t)func;
    f62e:	6325      	str	r5, [r4, #48]	; 0x30
	} else {
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
	}
}
    f630:	bd70      	pop	{r4, r5, r6, pc}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f632:	1e2a      	subs	r2, r5, #0
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
    f634:	6365      	str	r5, [r4, #52]	; 0x34
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f636:	f104 0004 	add.w	r0, r4, #4
    f63a:	4b05      	ldr	r3, [pc, #20]	; (f650 <spi_m_async_register_callback+0x40>)
}
    f63c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    f640:	bf18      	it	ne
    f642:	2201      	movne	r2, #1
    f644:	2103      	movs	r1, #3
    f646:	4718      	bx	r3
    f648:	00016a4f 	.word	0x00016a4f
    f64c:	0000e42d 	.word	0x0000e42d
    f650:	00011b29 	.word	0x00011b29

0000f654 <spi_m_async_get_io_descriptor>:

int32_t spi_m_async_get_io_descriptor(struct spi_m_async_descriptor *const spi, struct io_descriptor **io)
{
    f654:	b538      	push	{r3, r4, r5, lr}
    f656:	460d      	mov	r5, r1
	ASSERT(spi && io);
    f658:	4604      	mov	r4, r0
    f65a:	b110      	cbz	r0, f662 <spi_m_async_get_io_descriptor+0xe>
    f65c:	1e08      	subs	r0, r1, #0
    f65e:	bf18      	it	ne
    f660:	2001      	movne	r0, #1
    f662:	4904      	ldr	r1, [pc, #16]	; (f674 <spi_m_async_get_io_descriptor+0x20>)
    f664:	4b04      	ldr	r3, [pc, #16]	; (f678 <spi_m_async_get_io_descriptor+0x24>)
    f666:	f240 126f 	movw	r2, #367	; 0x16f
	*io = &spi->io;
    f66a:	3424      	adds	r4, #36	; 0x24
	ASSERT(spi && io);
    f66c:	4798      	blx	r3
	*io = &spi->io;
    f66e:	602c      	str	r4, [r5, #0]
	return 0;
}
    f670:	2000      	movs	r0, #0
    f672:	bd38      	pop	{r3, r4, r5, pc}
    f674:	00016a4f 	.word	0x00016a4f
    f678:	0000e42d 	.word	0x0000e42d

0000f67c <crc_sync_init>:

/**
 * \brief Initialize CRC.
 */
int32_t crc_sync_init(struct crc_sync_descriptor *const descr, void *const hw)
{
    f67c:	b570      	push	{r4, r5, r6, lr}
    f67e:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    f680:	4604      	mov	r4, r0
    f682:	b110      	cbz	r0, f68a <crc_sync_init+0xe>
    f684:	1e08      	subs	r0, r1, #0
    f686:	bf18      	it	ne
    f688:	2001      	movne	r0, #1
    f68a:	4905      	ldr	r1, [pc, #20]	; (f6a0 <crc_sync_init+0x24>)
    f68c:	4b05      	ldr	r3, [pc, #20]	; (f6a4 <crc_sync_init+0x28>)
    f68e:	222b      	movs	r2, #43	; 0x2b
    f690:	4798      	blx	r3

	return _crc_sync_init(&descr->dev, hw);
    f692:	4629      	mov	r1, r5
    f694:	4620      	mov	r0, r4
    f696:	4b04      	ldr	r3, [pc, #16]	; (f6a8 <crc_sync_init+0x2c>)
}
    f698:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _crc_sync_init(&descr->dev, hw);
    f69c:	4718      	bx	r3
    f69e:	bf00      	nop
    f6a0:	00016a6c 	.word	0x00016a6c
    f6a4:	0000e42d 	.word	0x0000e42d
    f6a8:	00013f6d 	.word	0x00013f6d

0000f6ac <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f6ac:	4a0a      	ldr	r2, [pc, #40]	; (f6d8 <_usb_d_find_ep+0x2c>)
{
    f6ae:	b570      	push	{r4, r5, r6, lr}
    f6b0:	2300      	movs	r3, #0
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f6b2:	f000 050f 	and.w	r5, r0, #15
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    f6b6:	7854      	ldrb	r4, [r2, #1]
    f6b8:	4284      	cmp	r4, r0
    f6ba:	b259      	sxtb	r1, r3
    f6bc:	d00a      	beq.n	f6d4 <_usb_d_find_ep+0x28>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    f6be:	7816      	ldrb	r6, [r2, #0]
    f6c0:	b90e      	cbnz	r6, f6c6 <_usb_d_find_ep+0x1a>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    f6c2:	42ac      	cmp	r4, r5
    f6c4:	d006      	beq.n	f6d4 <_usb_d_find_ep+0x28>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f6c6:	3301      	adds	r3, #1
    f6c8:	2b0d      	cmp	r3, #13
    f6ca:	f102 0220 	add.w	r2, r2, #32
    f6ce:	d1f2      	bne.n	f6b6 <_usb_d_find_ep+0xa>
			return i;
		}
	}
	return -1;
    f6d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
}
    f6d4:	4608      	mov	r0, r1
    f6d6:	bd70      	pop	{r4, r5, r6, pc}
    f6d8:	20008b60 	.word	0x20008b60

0000f6dc <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    f6dc:	2000      	movs	r0, #0
    f6de:	4770      	bx	lr

0000f6e0 <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    f6e0:	b513      	push	{r0, r1, r4, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f6e2:	4b0a      	ldr	r3, [pc, #40]	; (f70c <usb_d_cb_trans_more+0x2c>)
{
    f6e4:	9101      	str	r1, [sp, #4]
    f6e6:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f6e8:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    f6ea:	4b09      	ldr	r3, [pc, #36]	; (f710 <usb_d_cb_trans_more+0x30>)
    f6ec:	9901      	ldr	r1, [sp, #4]
    f6ee:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    f6f2:	789a      	ldrb	r2, [r3, #2]
    f6f4:	2a03      	cmp	r2, #3
    f6f6:	d105      	bne.n	f704 <usb_d_cb_trans_more+0x24>
		return ept->callbacks.more(ep, transfered);
    f6f8:	699b      	ldr	r3, [r3, #24]
    f6fa:	4620      	mov	r0, r4
	}
	return false;
}
    f6fc:	b002      	add	sp, #8
    f6fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return ept->callbacks.more(ep, transfered);
    f702:	4718      	bx	r3
}
    f704:	2000      	movs	r0, #0
    f706:	b002      	add	sp, #8
    f708:	bd10      	pop	{r4, pc}
    f70a:	bf00      	nop
    f70c:	0000f6ad 	.word	0x0000f6ad
    f710:	20008b60 	.word	0x20008b60

0000f714 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    f714:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f718:	4b37      	ldr	r3, [pc, #220]	; (f7f8 <_usb_d_cb_trans_done+0xe4>)
    f71a:	4c38      	ldr	r4, [pc, #224]	; (f7fc <_usb_d_cb_trans_done+0xe8>)
{
    f71c:	b085      	sub	sp, #20
    f71e:	4680      	mov	r8, r0
    f720:	460f      	mov	r7, r1
    f722:	4691      	mov	r9, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f724:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    f726:	0146      	lsls	r6, r0, #5
    f728:	2f00      	cmp	r7, #0
    f72a:	d143      	bne.n	f7b4 <_usb_d_cb_trans_done+0xa0>
		ept->xfer.hdr.status = USB_XFER_DONE;
    f72c:	19a5      	adds	r5, r4, r6
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f72e:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_DONE;
    f730:	70ef      	strb	r7, [r5, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f732:	2900      	cmp	r1, #0
    f734:	d135      	bne.n	f7a2 <_usb_d_cb_trans_done+0x8e>
	if (state == USB_EP_S_X_DATA) {
    f736:	2320      	movs	r3, #32
    f738:	220c      	movs	r2, #12
    f73a:	fb13 2000 	smlabb	r0, r3, r0, r2
    f73e:	78ab      	ldrb	r3, [r5, #2]
    f740:	2b03      	cmp	r3, #3
    f742:	eb04 0200 	add.w	r2, r4, r0
    f746:	69eb      	ldr	r3, [r5, #28]
    f748:	7868      	ldrb	r0, [r5, #1]
    f74a:	d126      	bne.n	f79a <_usb_d_cb_trans_done+0x86>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    f74c:	2101      	movs	r1, #1
    f74e:	f995 400c 	ldrsb.w	r4, [r5, #12]
    f752:	4798      	blx	r3
		if (err) {
    f754:	786b      	ldrb	r3, [r5, #1]
    f756:	b168      	cbz	r0, f774 <_usb_d_cb_trans_done+0x60>
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f758:	2c00      	cmp	r4, #0
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f75a:	f240 2205 	movw	r2, #517	; 0x205
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f75e:	bfb4      	ite	lt
    f760:	4618      	movlt	r0, r3
    f762:	f043 0080 	orrge.w	r0, r3, #128	; 0x80
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    f766:	806a      	strh	r2, [r5, #2]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    f768:	4b25      	ldr	r3, [pc, #148]	; (f800 <_usb_d_cb_trans_done+0xec>)
    f76a:	2101      	movs	r1, #1
    f76c:	4798      	blx	r3
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
}
    f76e:	b005      	add	sp, #20
    f770:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct usb_d_transfer trans
    f774:	2c00      	cmp	r4, #0
    f776:	bfac      	ite	ge
    f778:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    f77c:	f003 030f 	andlt.w	r3, r3, #15
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f780:	2204      	movs	r2, #4
	struct usb_d_transfer trans
    f782:	f88d 300c 	strb.w	r3, [sp, #12]
    f786:	2301      	movs	r3, #1
    f788:	e9cd 0001 	strd	r0, r0, [sp, #4]
    f78c:	f88d 300d 	strb.w	r3, [sp, #13]
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    f790:	70aa      	strb	r2, [r5, #2]
	return _usb_d_dev_ep_trans(&trans);
    f792:	4b1c      	ldr	r3, [pc, #112]	; (f804 <_usb_d_cb_trans_done+0xf0>)
    f794:	a801      	add	r0, sp, #4
    f796:	4798      	blx	r3
    f798:	e7e9      	b.n	f76e <_usb_d_cb_trans_done+0x5a>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    f79a:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f79c:	2302      	movs	r3, #2
    f79e:	70ab      	strb	r3, [r5, #2]
    f7a0:	e7e5      	b.n	f76e <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f7a2:	2301      	movs	r3, #1
    f7a4:	70ab      	strb	r3, [r5, #2]
	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    f7a6:	4434      	add	r4, r6
    f7a8:	464a      	mov	r2, r9
    f7aa:	69e3      	ldr	r3, [r4, #28]
    f7ac:	78e1      	ldrb	r1, [r4, #3]
    f7ae:	4640      	mov	r0, r8
    f7b0:	4798      	blx	r3
    f7b2:	e7dc      	b.n	f76e <_usb_d_cb_trans_done+0x5a>
	} else if (code == USB_TRANS_STALL) {
    f7b4:	2f01      	cmp	r7, #1
		ept->xfer.hdr.status = USB_XFER_HALT;
    f7b6:	eb04 0306 	add.w	r3, r4, r6
	} else if (code == USB_TRANS_STALL) {
    f7ba:	d10b      	bne.n	f7d4 <_usb_d_cb_trans_done+0xc0>
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f7bc:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_HALT;
    f7be:	2202      	movs	r2, #2
    f7c0:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f7c2:	b921      	cbnz	r1, f7ce <_usb_d_cb_trans_done+0xba>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f7c4:	709a      	strb	r2, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f7c6:	4640      	mov	r0, r8
    f7c8:	4b0d      	ldr	r3, [pc, #52]	; (f800 <_usb_d_cb_trans_done+0xec>)
    f7ca:	4798      	blx	r3
    f7cc:	e7eb      	b.n	f7a6 <_usb_d_cb_trans_done+0x92>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    f7ce:	2205      	movs	r2, #5
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f7d0:	709a      	strb	r2, [r3, #2]
    f7d2:	e7e8      	b.n	f7a6 <_usb_d_cb_trans_done+0x92>
	} else if (code == USB_TRANS_ABORT) {
    f7d4:	2f02      	cmp	r7, #2
    f7d6:	d107      	bne.n	f7e8 <_usb_d_cb_trans_done+0xd4>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    f7d8:	2204      	movs	r2, #4
    f7da:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    f7dc:	5da2      	ldrb	r2, [r4, r6]
    f7de:	b90a      	cbnz	r2, f7e4 <_usb_d_cb_trans_done+0xd0>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    f7e0:	709f      	strb	r7, [r3, #2]
			return;
    f7e2:	e7c4      	b.n	f76e <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    f7e4:	2201      	movs	r2, #1
    f7e6:	e7f3      	b.n	f7d0 <_usb_d_cb_trans_done+0xbc>
	} else if (code == USB_TRANS_RESET) {
    f7e8:	2f03      	cmp	r7, #3
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    f7ea:	bf0c      	ite	eq
    f7ec:	f44f 62a0 	moveq.w	r2, #1280	; 0x500
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    f7f0:	f240 6206 	movwne	r2, #1542	; 0x606
    f7f4:	805a      	strh	r2, [r3, #2]
    f7f6:	e7d6      	b.n	f7a6 <_usb_d_cb_trans_done+0x92>
    f7f8:	0000f6ad 	.word	0x0000f6ad
    f7fc:	20008b60 	.word	0x20008b60
    f800:	0000daad 	.word	0x0000daad
    f804:	0000dbcd 	.word	0x0000dbcd

0000f808 <usb_d_cb_trans_setup>:
{
    f808:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f80c:	4b18      	ldr	r3, [pc, #96]	; (f870 <usb_d_cb_trans_setup+0x68>)
	uint8_t *        req      = ept->xfer.req;
    f80e:	4f19      	ldr	r7, [pc, #100]	; (f874 <usb_d_cb_trans_setup+0x6c>)
    f810:	4d19      	ldr	r5, [pc, #100]	; (f878 <usb_d_cb_trans_setup+0x70>)
{
    f812:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f814:	4798      	blx	r3
	uint8_t *        req      = ept->xfer.req;
    f816:	f04f 0820 	mov.w	r8, #32
    f81a:	230c      	movs	r3, #12
    f81c:	fb18 3800 	smlabb	r8, r8, r0, r3
    f820:	44b8      	add	r8, r7
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f822:	4b16      	ldr	r3, [pc, #88]	; (f87c <usb_d_cb_trans_setup+0x74>)
	int8_t           ep_index = _usb_d_find_ep(ep);
    f824:	4606      	mov	r6, r0
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    f826:	4641      	mov	r1, r8
    f828:	4620      	mov	r0, r4
    f82a:	4798      	blx	r3
	if (n != 8) {
    f82c:	b2c0      	uxtb	r0, r0
    f82e:	2808      	cmp	r0, #8
    f830:	f044 0980 	orr.w	r9, r4, #128	; 0x80
    f834:	d008      	beq.n	f848 <usb_d_cb_trans_setup+0x40>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f836:	2101      	movs	r1, #1
    f838:	4620      	mov	r0, r4
    f83a:	47a8      	blx	r5
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f83c:	4648      	mov	r0, r9
    f83e:	462b      	mov	r3, r5
    f840:	2101      	movs	r1, #1
}
    f842:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    f846:	4718      	bx	r3
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f848:	eb07 1646 	add.w	r6, r7, r6, lsl #5
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    f84c:	2100      	movs	r1, #0
    f84e:	4620      	mov	r0, r4
    f850:	47a8      	blx	r5
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f852:	2701      	movs	r7, #1
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    f854:	2100      	movs	r1, #0
    f856:	4648      	mov	r0, r9
    f858:	47a8      	blx	r5
	if (!ept->callbacks.req(ep, req)) {
    f85a:	6973      	ldr	r3, [r6, #20]
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    f85c:	70b7      	strb	r7, [r6, #2]
	if (!ept->callbacks.req(ep, req)) {
    f85e:	4641      	mov	r1, r8
    f860:	4620      	mov	r0, r4
    f862:	4798      	blx	r3
    f864:	b910      	cbnz	r0, f86c <usb_d_cb_trans_setup+0x64>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    f866:	2305      	movs	r3, #5
    f868:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    f86a:	e7e4      	b.n	f836 <usb_d_cb_trans_setup+0x2e>
}
    f86c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    f870:	0000f6ad 	.word	0x0000f6ad
    f874:	20008b60 	.word	0x20008b60
    f878:	0000daad 	.word	0x0000daad
    f87c:	0000db79 	.word	0x0000db79

0000f880 <usb_d_init>:

int32_t usb_d_init(void)
{
    f880:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    f882:	4b11      	ldr	r3, [pc, #68]	; (f8c8 <usb_d_init+0x48>)
    f884:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    f886:	2800      	cmp	r0, #0
    f888:	db1d      	blt.n	f8c6 <usb_d_init+0x46>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f88a:	4b10      	ldr	r3, [pc, #64]	; (f8cc <usb_d_init+0x4c>)
    f88c:	4810      	ldr	r0, [pc, #64]	; (f8d0 <usb_d_init+0x50>)
    f88e:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    f892:	2100      	movs	r1, #0
    f894:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f896:	4b0e      	ldr	r3, [pc, #56]	; (f8d0 <usb_d_init+0x50>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    f898:	490e      	ldr	r1, [pc, #56]	; (f8d4 <usb_d_init+0x54>)
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    f89a:	2200      	movs	r2, #0
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f89c:	20ff      	movs	r0, #255	; 0xff
    f89e:	3201      	adds	r2, #1
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f8a0:	2a0d      	cmp	r2, #13
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    f8a2:	e9c3 1105 	strd	r1, r1, [r3, #20]
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    f8a6:	7058      	strb	r0, [r3, #1]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    f8a8:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    f8aa:	f103 0320 	add.w	r3, r3, #32
    f8ae:	d1f6      	bne.n	f89e <usb_d_init+0x1e>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    f8b0:	4c09      	ldr	r4, [pc, #36]	; (f8d8 <usb_d_init+0x58>)
    f8b2:	490a      	ldr	r1, [pc, #40]	; (f8dc <usb_d_init+0x5c>)
    f8b4:	2000      	movs	r0, #0
    f8b6:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    f8b8:	4909      	ldr	r1, [pc, #36]	; (f8e0 <usb_d_init+0x60>)
    f8ba:	2001      	movs	r0, #1
    f8bc:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    f8be:	2002      	movs	r0, #2
    f8c0:	4908      	ldr	r1, [pc, #32]	; (f8e4 <usb_d_init+0x64>)
    f8c2:	47a0      	blx	r4
	return ERR_NONE;
    f8c4:	2000      	movs	r0, #0
}
    f8c6:	bd10      	pop	{r4, pc}
    f8c8:	0000d6a5 	.word	0x0000d6a5
    f8cc:	000147c5 	.word	0x000147c5
    f8d0:	20008b60 	.word	0x20008b60
    f8d4:	0000f6dd 	.word	0x0000f6dd
    f8d8:	0000dd6d 	.word	0x0000dd6d
    f8dc:	0000f809 	.word	0x0000f809
    f8e0:	0000f6e1 	.word	0x0000f6e1
    f8e4:	0000f715 	.word	0x0000f715

0000f8e8 <usb_d_register_callback>:
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    f8e8:	4b00      	ldr	r3, [pc, #0]	; (f8ec <usb_d_register_callback+0x4>)
    f8ea:	4718      	bx	r3
    f8ec:	0000dd49 	.word	0x0000dd49

0000f8f0 <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
	return _usb_d_dev_enable();
    f8f0:	4b00      	ldr	r3, [pc, #0]	; (f8f4 <usb_d_enable+0x4>)
    f8f2:	4718      	bx	r3
    f8f4:	0000d781 	.word	0x0000d781

0000f8f8 <usb_d_attach>:
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
	_usb_d_dev_attach();
    f8f8:	4b00      	ldr	r3, [pc, #0]	; (f8fc <usb_d_attach+0x4>)
    f8fa:	4718      	bx	r3
    f8fc:	0000d7dd 	.word	0x0000d7dd

0000f900 <usb_d_get_frame_num>:
	return _usb_d_dev_get_speed();
}

uint16_t usb_d_get_frame_num(void)
{
	return _usb_d_dev_get_frame_n();
    f900:	4b00      	ldr	r3, [pc, #0]	; (f904 <usb_d_get_frame_num+0x4>)
    f902:	4718      	bx	r3
    f904:	0000d7fb 	.word	0x0000d7fb

0000f908 <usb_d_set_address>:
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
	_usb_d_dev_set_address(addr);
    f908:	4b00      	ldr	r3, [pc, #0]	; (f90c <usb_d_set_address+0x4>)
    f90a:	4718      	bx	r3
    f90c:	0000d7ef 	.word	0x0000d7ef

0000f910 <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    f910:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    f912:	4c11      	ldr	r4, [pc, #68]	; (f958 <usb_d_ep_init+0x48>)
{
    f914:	4606      	mov	r6, r0
    f916:	460d      	mov	r5, r1
    f918:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    f91a:	47a0      	blx	r4
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    f91c:	2800      	cmp	r0, #0
    f91e:	da14      	bge.n	f94a <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    f920:	20ff      	movs	r0, #255	; 0xff
    f922:	47a0      	blx	r4
		if (ep_index < 0) {
    f924:	1e04      	subs	r4, r0, #0
    f926:	db13      	blt.n	f950 <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    f928:	4b0c      	ldr	r3, [pc, #48]	; (f95c <usb_d_ep_init+0x4c>)
    f92a:	463a      	mov	r2, r7
    f92c:	4629      	mov	r1, r5
    f92e:	4630      	mov	r0, r6
    f930:	4798      	blx	r3
	if (rc < 0) {
    f932:	2800      	cmp	r0, #0
    f934:	db08      	blt.n	f948 <usb_d_ep_init+0x38>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    f936:	4b0a      	ldr	r3, [pc, #40]	; (f960 <usb_d_ep_init+0x50>)
    f938:	0162      	lsls	r2, r4, #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f93a:	f005 0503 	and.w	r5, r5, #3
	ept->xfer.hdr.ep   = ep;
    f93e:	eb03 1444 	add.w	r4, r3, r4, lsl #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    f942:	549d      	strb	r5, [r3, r2]
	ept->xfer.hdr.ep   = ep;
    f944:	7066      	strb	r6, [r4, #1]
	return ERR_NONE;
    f946:	2000      	movs	r0, #0
}
    f948:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    f94a:	f06f 0013 	mvn.w	r0, #19
    f94e:	e7fb      	b.n	f948 <usb_d_ep_init+0x38>
			return -USB_ERR_ALLOC_FAIL;
    f950:	f06f 0014 	mvn.w	r0, #20
    f954:	e7f8      	b.n	f948 <usb_d_ep_init+0x38>
    f956:	bf00      	nop
    f958:	0000f6ad 	.word	0x0000f6ad
    f95c:	0000d809 	.word	0x0000d809
    f960:	20008b60 	.word	0x20008b60

0000f964 <usb_d_ep0_init>:
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f964:	2100      	movs	r1, #0
{
    f966:	4602      	mov	r2, r0
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    f968:	4b01      	ldr	r3, [pc, #4]	; (f970 <usb_d_ep0_init+0xc>)
    f96a:	4608      	mov	r0, r1
    f96c:	4718      	bx	r3
    f96e:	bf00      	nop
    f970:	0000f911 	.word	0x0000f911

0000f974 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    f974:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f976:	4b07      	ldr	r3, [pc, #28]	; (f994 <usb_d_ep_deinit+0x20>)
{
    f978:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f97a:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    f97c:	1e04      	subs	r4, r0, #0
    f97e:	db07      	blt.n	f990 <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    f980:	4b05      	ldr	r3, [pc, #20]	; (f998 <usb_d_ep_deinit+0x24>)
    f982:	4628      	mov	r0, r5
    f984:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    f986:	4805      	ldr	r0, [pc, #20]	; (f99c <usb_d_ep_deinit+0x28>)
    f988:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    f98c:	23ff      	movs	r3, #255	; 0xff
    f98e:	7043      	strb	r3, [r0, #1]
}
    f990:	bd38      	pop	{r3, r4, r5, pc}
    f992:	bf00      	nop
    f994:	0000f6ad 	.word	0x0000f6ad
    f998:	0000d8c9 	.word	0x0000d8c9
    f99c:	20008b60 	.word	0x20008b60

0000f9a0 <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    f9a0:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    f9a2:	4b0c      	ldr	r3, [pc, #48]	; (f9d4 <usb_d_ep_enable+0x34>)
{
    f9a4:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    f9a6:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    f9a8:	1e03      	subs	r3, r0, #0
    f9aa:	db10      	blt.n	f9ce <usb_d_ep_enable+0x2e>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f9ac:	015b      	lsls	r3, r3, #5
    f9ae:	4c0a      	ldr	r4, [pc, #40]	; (f9d8 <usb_d_ep_enable+0x38>)
    f9b0:	5ce2      	ldrb	r2, [r4, r3]
    f9b2:	441c      	add	r4, r3
    f9b4:	2a00      	cmp	r2, #0
    f9b6:	bf0c      	ite	eq
    f9b8:	2202      	moveq	r2, #2
    f9ba:	2201      	movne	r2, #1
	rc                  = _usb_d_dev_ep_enable(ep);
    f9bc:	4b07      	ldr	r3, [pc, #28]	; (f9dc <usb_d_ep_enable+0x3c>)
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    f9be:	70a2      	strb	r2, [r4, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    f9c0:	4628      	mov	r0, r5
    f9c2:	4798      	blx	r3
	if (rc < 0) {
    f9c4:	2800      	cmp	r0, #0
    f9c6:	da01      	bge.n	f9cc <usb_d_ep_enable+0x2c>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    f9c8:	2300      	movs	r3, #0
    f9ca:	70a3      	strb	r3, [r4, #2]
	}
	return rc;
}
    f9cc:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    f9ce:	f06f 0011 	mvn.w	r0, #17
    f9d2:	e7fb      	b.n	f9cc <usb_d_ep_enable+0x2c>
    f9d4:	0000f6ad 	.word	0x0000f6ad
    f9d8:	20008b60 	.word	0x20008b60
    f9dc:	0000d93d 	.word	0x0000d93d

0000f9e0 <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    f9e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f9e4:	f890 8008 	ldrb.w	r8, [r0, #8]
    f9e8:	4b31      	ldr	r3, [pc, #196]	; (fab0 <usb_d_ep_transfer+0xd0>)
{
    f9ea:	4605      	mov	r5, r0
    f9ec:	b087      	sub	sp, #28
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    f9ee:	4640      	mov	r0, r8
    f9f0:	4798      	blx	r3
	uint32_t              len = xfer->size;
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    f9f2:	1e04      	subs	r4, r0, #0
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    f9f4:	7a6f      	ldrb	r7, [r5, #9]
	uint32_t              len = xfer->size;
    f9f6:	686e      	ldr	r6, [r5, #4]
	if (ep_index < 0) {
    f9f8:	db55      	blt.n	faa6 <usb_d_ep_transfer+0xc6>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
	state = ept->xfer.hdr.state;
    f9fa:	f8df a0c8 	ldr.w	sl, [pc, #200]	; fac4 <usb_d_ep_transfer+0xe4>
	atomic_enter_critical(&flags);
    f9fe:	4b2d      	ldr	r3, [pc, #180]	; (fab4 <usb_d_ep_transfer+0xd4>)
	state = ept->xfer.hdr.state;
    fa00:	ea4f 1b44 	mov.w	fp, r4, lsl #5
    fa04:	eb0a 1444 	add.w	r4, sl, r4, lsl #5
	atomic_enter_critical(&flags);
    fa08:	a802      	add	r0, sp, #8
    fa0a:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    fa0c:	78a3      	ldrb	r3, [r4, #2]
    fa0e:	f88d 3007 	strb.w	r3, [sp, #7]
	if (state == USB_EP_S_IDLE) {
    fa12:	f89d 3007 	ldrb.w	r3, [sp, #7]
    fa16:	2b01      	cmp	r3, #1
    fa18:	fa5f f983 	uxtb.w	r9, r3
    fa1c:	4b26      	ldr	r3, [pc, #152]	; (fab8 <usb_d_ep_transfer+0xd8>)
    fa1e:	d11a      	bne.n	fa56 <usb_d_ep_transfer+0x76>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    fa20:	2203      	movs	r2, #3
    fa22:	70a2      	strb	r2, [r4, #2]
		atomic_leave_critical(&flags);
    fa24:	a802      	add	r0, sp, #8
    fa26:	4798      	blx	r3
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    fa28:	f81a 300b 	ldrb.w	r3, [sl, fp]
    fa2c:	b1fb      	cbz	r3, fa6e <usb_d_ep_transfer+0x8e>
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    fa2e:	1e3b      	subs	r3, r7, #0
    fa30:	ea4f 12d8 	mov.w	r2, r8, lsr #7
    fa34:	bf18      	it	ne
    fa36:	2301      	movne	r3, #1
	struct usb_d_transfer trans
    fa38:	6828      	ldr	r0, [r5, #0]
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    fa3a:	7a29      	ldrb	r1, [r5, #8]
	struct usb_d_transfer trans
    fa3c:	e9cd 0603 	strd	r0, r6, [sp, #12]
    fa40:	b372      	cbz	r2, faa0 <usb_d_ep_transfer+0xc0>
    fa42:	f041 0280 	orr.w	r2, r1, #128	; 0x80
    fa46:	f88d 3015 	strb.w	r3, [sp, #21]
	return _usb_d_dev_ep_trans(&trans);
    fa4a:	a803      	add	r0, sp, #12
    fa4c:	4b1b      	ldr	r3, [pc, #108]	; (fabc <usb_d_ep_transfer+0xdc>)
	struct usb_d_transfer trans
    fa4e:	f88d 2014 	strb.w	r2, [sp, #20]
	return _usb_d_dev_ep_trans(&trans);
    fa52:	4798      	blx	r3
	return rc;
    fa54:	e008      	b.n	fa68 <usb_d_ep_transfer+0x88>
		atomic_leave_critical(&flags);
    fa56:	a802      	add	r0, sp, #8
    fa58:	4798      	blx	r3
		switch (state) {
    fa5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    fa5e:	2b06      	cmp	r3, #6
    fa60:	b2da      	uxtb	r2, r3
    fa62:	d823      	bhi.n	faac <usb_d_ep_transfer+0xcc>
    fa64:	4b16      	ldr	r3, [pc, #88]	; (fac0 <usb_d_ep_transfer+0xe0>)
    fa66:	5698      	ldrsb	r0, [r3, r2]
}
    fa68:	b007      	add	sp, #28
    fa6a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    fa6e:	7ce1      	ldrb	r1, [r4, #19]
    fa70:	7ca2      	ldrb	r2, [r4, #18]
    fa72:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    fa76:	b292      	uxth	r2, r2
		if (req_len == 0) {
    fa78:	b92a      	cbnz	r2, fa86 <usb_d_ep_transfer+0xa6>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    fa7a:	2304      	movs	r3, #4
    fa7c:	70a3      	strb	r3, [r4, #2]
			len                 = 0;
    fa7e:	4616      	mov	r6, r2
			zlp                 = true;
    fa80:	464b      	mov	r3, r9
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    fa82:	461a      	mov	r2, r3
    fa84:	e7d8      	b.n	fa38 <usb_d_ep_transfer+0x58>
			if (dir) {
    fa86:	f994 100c 	ldrsb.w	r1, [r4, #12]
    fa8a:	4296      	cmp	r6, r2
    fa8c:	bf28      	it	cs
    fa8e:	4616      	movcs	r6, r2
    fa90:	2900      	cmp	r1, #0
    fa92:	daf6      	bge.n	fa82 <usb_d_ep_transfer+0xa2>
				zlp = (req_len > len);
    fa94:	42b2      	cmp	r2, r6
    fa96:	bf94      	ite	ls
    fa98:	2300      	movls	r3, #0
    fa9a:	2301      	movhi	r3, #1
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
    fa9c:	464a      	mov	r2, r9
    fa9e:	e7cb      	b.n	fa38 <usb_d_ep_transfer+0x58>
	struct usb_d_transfer trans
    faa0:	f001 020f 	and.w	r2, r1, #15
    faa4:	e7cf      	b.n	fa46 <usb_d_ep_transfer+0x66>
		return -USB_ERR_PARAM;
    faa6:	f06f 0011 	mvn.w	r0, #17
    faaa:	e7dd      	b.n	fa68 <usb_d_ep_transfer+0x88>
		switch (state) {
    faac:	2001      	movs	r0, #1
    faae:	e7db      	b.n	fa68 <usb_d_ep_transfer+0x88>
    fab0:	0000f6ad 	.word	0x0000f6ad
    fab4:	00011ef9 	.word	0x00011ef9
    fab8:	00011f07 	.word	0x00011f07
    fabc:	0000dbcd 	.word	0x0000dbcd
    fac0:	00016a86 	.word	0x00016a86
    fac4:	20008b60 	.word	0x20008b60

0000fac8 <usb_d_ep_get_status>:
	ept->xfer.hdr.state  = USB_EP_S_IDLE;
	ept->xfer.hdr.status = USB_XFER_ABORT;
}

int32_t usb_d_ep_get_status(const uint8_t ep, struct usb_d_ep_status *stat)
{
    fac8:	b5f0      	push	{r4, r5, r6, r7, lr}
	int8_t                    ep_index = _usb_d_find_ep(ep);
    faca:	4b12      	ldr	r3, [pc, #72]	; (fb14 <usb_d_ep_get_status+0x4c>)
	struct usb_d_ep *         ept      = &usb_d_inst.ep[ep_index];
	struct usb_d_trans_status tmp;
	uint8_t                   state = ept->xfer.hdr.state;
    facc:	4d12      	ldr	r5, [pc, #72]	; (fb18 <usb_d_ep_get_status+0x50>)
{
    face:	b085      	sub	sp, #20
    fad0:	4606      	mov	r6, r0
    fad2:	460c      	mov	r4, r1
	int8_t                    ep_index = _usb_d_find_ep(ep);
    fad4:	4798      	blx	r3
	uint8_t                   state = ept->xfer.hdr.state;
    fad6:	eb05 1540 	add.w	r5, r5, r0, lsl #5
	if (ep_index < 0) {
    fada:	2800      	cmp	r0, #0
	uint8_t                   state = ept->xfer.hdr.state;
    fadc:	78af      	ldrb	r7, [r5, #2]
	if (ep_index < 0) {
    fade:	db14      	blt.n	fb0a <usb_d_ep_get_status+0x42>
		return -USB_ERR_PARAM;
	}
	if (stat) {
    fae0:	b15c      	cbz	r4, fafa <usb_d_ep_get_status+0x32>
		/* Check transaction status if transferring data. */
		_usb_d_dev_ep_get_status(ep, &tmp);
    fae2:	4b0e      	ldr	r3, [pc, #56]	; (fb1c <usb_d_ep_get_status+0x54>)
    fae4:	a901      	add	r1, sp, #4
    fae6:	4630      	mov	r0, r6
    fae8:	4798      	blx	r3
		stat->ep    = ep;
    faea:	7026      	strb	r6, [r4, #0]
		stat->state = state;
    faec:	70e7      	strb	r7, [r4, #3]
		stat->code  = ept->xfer.hdr.status;
    faee:	78eb      	ldrb	r3, [r5, #3]
    faf0:	7063      	strb	r3, [r4, #1]
		stat->count = tmp.count;
    faf2:	9b02      	ldr	r3, [sp, #8]
    faf4:	6063      	str	r3, [r4, #4]
		stat->size  = tmp.size;
    faf6:	9b01      	ldr	r3, [sp, #4]
    faf8:	60a3      	str	r3, [r4, #8]
	}
	switch (state) {
    fafa:	2f06      	cmp	r7, #6
    fafc:	d808      	bhi.n	fb10 <usb_d_ep_get_status+0x48>
    fafe:	4b08      	ldr	r3, [pc, #32]	; (fb20 <usb_d_ep_get_status+0x58>)
    fb00:	443b      	add	r3, r7
    fb02:	f993 0007 	ldrsb.w	r0, [r3, #7]
		return -USB_ERR_FUNC;
	default:
		/* Busy */
		return USB_BUSY;
	}
}
    fb06:	b005      	add	sp, #20
    fb08:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -USB_ERR_PARAM;
    fb0a:	f06f 0011 	mvn.w	r0, #17
    fb0e:	e7fa      	b.n	fb06 <usb_d_ep_get_status+0x3e>
    fb10:	2001      	movs	r0, #1
    fb12:	e7f8      	b.n	fb06 <usb_d_ep_get_status+0x3e>
    fb14:	0000f6ad 	.word	0x0000f6ad
    fb18:	20008b60 	.word	0x20008b60
    fb1c:	0000dcd5 	.word	0x0000dcd5
    fb20:	00016a86 	.word	0x00016a86

0000fb24 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
    fb24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    fb28:	4605      	mov	r5, r0
	if (ctrl == USB_EP_HALT_CLR) {
    fb2a:	460c      	mov	r4, r1
    fb2c:	b9d9      	cbnz	r1, fb66 <usb_d_ep_halt+0x42>
	int8_t           ep_index = _usb_d_find_ep(ep);
    fb2e:	4b13      	ldr	r3, [pc, #76]	; (fb7c <usb_d_ep_halt+0x58>)
    fb30:	4798      	blx	r3
	if (ep_index < 0) {
    fb32:	1e06      	subs	r6, r0, #0
    fb34:	db1e      	blt.n	fb74 <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
    fb36:	4f12      	ldr	r7, [pc, #72]	; (fb80 <usb_d_ep_halt+0x5c>)
    fb38:	2102      	movs	r1, #2
    fb3a:	4628      	mov	r0, r5
    fb3c:	47b8      	blx	r7
    fb3e:	b180      	cbz	r0, fb62 <usb_d_ep_halt+0x3e>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    fb40:	4621      	mov	r1, r4
    fb42:	4628      	mov	r0, r5
    fb44:	47b8      	blx	r7
		if (rc < 0) {
    fb46:	2800      	cmp	r0, #0
    fb48:	db0b      	blt.n	fb62 <usb_d_ep_halt+0x3e>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
    fb4a:	480e      	ldr	r0, [pc, #56]	; (fb84 <usb_d_ep_halt+0x60>)
    fb4c:	eb00 1046 	add.w	r0, r0, r6, lsl #5
    fb50:	f240 3301 	movw	r3, #769	; 0x301
    fb54:	8043      	strh	r3, [r0, #2]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
    fb56:	4622      	mov	r2, r4
    fb58:	69c3      	ldr	r3, [r0, #28]
    fb5a:	2103      	movs	r1, #3
    fb5c:	4628      	mov	r0, r5
    fb5e:	4798      	blx	r3
	return ERR_NONE;
    fb60:	4620      	mov	r0, r4
	} else if (ctrl == USB_EP_HALT_SET) {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
	}
}
    fb62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ctrl == USB_EP_HALT_SET) {
    fb66:	2901      	cmp	r1, #1
}
    fb68:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    fb6c:	4b04      	ldr	r3, [pc, #16]	; (fb80 <usb_d_ep_halt+0x5c>)
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
    fb6e:	bf18      	it	ne
    fb70:	2102      	movne	r1, #2
    fb72:	4718      	bx	r3
		return -USB_ERR_PARAM;
    fb74:	f06f 0011 	mvn.w	r0, #17
    fb78:	e7f3      	b.n	fb62 <usb_d_ep_halt+0x3e>
    fb7a:	bf00      	nop
    fb7c:	0000f6ad 	.word	0x0000f6ad
    fb80:	0000daad 	.word	0x0000daad
    fb84:	20008b60 	.word	0x20008b60

0000fb88 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
    fb88:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    fb8a:	4b0f      	ldr	r3, [pc, #60]	; (fbc8 <usb_d_ep_register_callback+0x40>)
{
    fb8c:	4614      	mov	r4, r2
    fb8e:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
    fb90:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
    fb92:	4b0e      	ldr	r3, [pc, #56]	; (fbcc <usb_d_ep_register_callback+0x44>)
    fb94:	2c00      	cmp	r4, #0
    fb96:	bf08      	it	eq
    fb98:	461c      	moveq	r4, r3
	if (ep_index < 0) {
    fb9a:	2800      	cmp	r0, #0
    fb9c:	db08      	blt.n	fbb0 <usb_d_ep_register_callback+0x28>
		return;
	}
	switch (type) {
    fb9e:	2d01      	cmp	r5, #1
    fba0:	d007      	beq.n	fbb2 <usb_d_ep_register_callback+0x2a>
    fba2:	2d02      	cmp	r5, #2
    fba4:	d00a      	beq.n	fbbc <usb_d_ep_register_callback+0x34>
    fba6:	b91d      	cbnz	r5, fbb0 <usb_d_ep_register_callback+0x28>
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
    fba8:	4b09      	ldr	r3, [pc, #36]	; (fbd0 <usb_d_ep_register_callback+0x48>)
    fbaa:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    fbae:	6144      	str	r4, [r0, #20]
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
    fbb0:	bd38      	pop	{r3, r4, r5, pc}
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
    fbb2:	4b07      	ldr	r3, [pc, #28]	; (fbd0 <usb_d_ep_register_callback+0x48>)
    fbb4:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    fbb8:	6184      	str	r4, [r0, #24]
		break;
    fbba:	e7f9      	b.n	fbb0 <usb_d_ep_register_callback+0x28>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
    fbbc:	4b04      	ldr	r3, [pc, #16]	; (fbd0 <usb_d_ep_register_callback+0x48>)
    fbbe:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    fbc2:	61c4      	str	r4, [r0, #28]
		break;
    fbc4:	e7f4      	b.n	fbb0 <usb_d_ep_register_callback+0x28>
    fbc6:	bf00      	nop
    fbc8:	0000f6ad 	.word	0x0000f6ad
    fbcc:	0000f6dd 	.word	0x0000f6dd
    fbd0:	20008b60 	.word	0x20008b60

0000fbd4 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
    fbd4:	6800      	ldr	r0, [r0, #0]
    fbd6:	b900      	cbnz	r0, fbda <is_list_element+0x6>
    fbd8:	4770      	bx	lr
		if (it == element) {
    fbda:	4288      	cmp	r0, r1
    fbdc:	d1fa      	bne.n	fbd4 <is_list_element>
			return true;
    fbde:	2001      	movs	r0, #1
		}
	}

	return false;
}
    fbe0:	4770      	bx	lr
	...

0000fbe4 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
    fbe4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(!is_list_element(list, element));
    fbe6:	4b07      	ldr	r3, [pc, #28]	; (fc04 <list_insert_as_head+0x20>)
{
    fbe8:	460d      	mov	r5, r1
    fbea:	4604      	mov	r4, r0
	ASSERT(!is_list_element(list, element));
    fbec:	4798      	blx	r3
    fbee:	f080 0001 	eor.w	r0, r0, #1
    fbf2:	4b05      	ldr	r3, [pc, #20]	; (fc08 <list_insert_as_head+0x24>)
    fbf4:	4905      	ldr	r1, [pc, #20]	; (fc0c <list_insert_as_head+0x28>)
    fbf6:	2239      	movs	r2, #57	; 0x39
    fbf8:	b2c0      	uxtb	r0, r0
    fbfa:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
    fbfc:	6823      	ldr	r3, [r4, #0]
    fbfe:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
    fc00:	6025      	str	r5, [r4, #0]
}
    fc02:	bd38      	pop	{r3, r4, r5, pc}
    fc04:	0000fbd5 	.word	0x0000fbd5
    fc08:	0000e42d 	.word	0x0000e42d
    fc0c:	00016a94 	.word	0x00016a94

0000fc10 <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
    fc10:	6803      	ldr	r3, [r0, #0]
    fc12:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
    fc14:	6001      	str	r1, [r0, #0]
}
    fc16:	4770      	bx	lr

0000fc18 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
    fc18:	b570      	push	{r4, r5, r6, lr}
	struct list_element *it = list->head;

	ASSERT(!is_list_element(list, element));
    fc1a:	4b0c      	ldr	r3, [pc, #48]	; (fc4c <list_insert_at_end+0x34>)
	struct list_element *it = list->head;
    fc1c:	6805      	ldr	r5, [r0, #0]
{
    fc1e:	4606      	mov	r6, r0
    fc20:	460c      	mov	r4, r1
	ASSERT(!is_list_element(list, element));
    fc22:	4798      	blx	r3
    fc24:	f080 0001 	eor.w	r0, r0, #1
    fc28:	4b09      	ldr	r3, [pc, #36]	; (fc50 <list_insert_at_end+0x38>)
    fc2a:	490a      	ldr	r1, [pc, #40]	; (fc54 <list_insert_at_end+0x3c>)
    fc2c:	224f      	movs	r2, #79	; 0x4f
    fc2e:	b2c0      	uxtb	r0, r0
    fc30:	4798      	blx	r3

	if (!list->head) {
    fc32:	6833      	ldr	r3, [r6, #0]
    fc34:	b913      	cbnz	r3, fc3c <list_insert_at_end+0x24>
		list->head                             = (struct list_element *)element;
    fc36:	6034      	str	r4, [r6, #0]
		((struct list_element *)element)->next = NULL;
    fc38:	6023      	str	r3, [r4, #0]
	while (it->next) {
		it = it->next;
	}
	it->next                               = (struct list_element *)element;
	((struct list_element *)element)->next = NULL;
}
    fc3a:	bd70      	pop	{r4, r5, r6, pc}
	while (it->next) {
    fc3c:	462b      	mov	r3, r5
    fc3e:	682d      	ldr	r5, [r5, #0]
    fc40:	2d00      	cmp	r5, #0
    fc42:	d1fb      	bne.n	fc3c <list_insert_at_end+0x24>
	it->next                               = (struct list_element *)element;
    fc44:	601c      	str	r4, [r3, #0]
	((struct list_element *)element)->next = NULL;
    fc46:	6025      	str	r5, [r4, #0]
    fc48:	e7f7      	b.n	fc3a <list_insert_at_end+0x22>
    fc4a:	bf00      	nop
    fc4c:	0000fbd5 	.word	0x0000fbd5
    fc50:	0000e42d 	.word	0x0000e42d
    fc54:	00016a94 	.word	0x00016a94

0000fc58 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
    fc58:	6803      	ldr	r3, [r0, #0]
    fc5a:	b10b      	cbz	r3, fc60 <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
    fc5c:	681a      	ldr	r2, [r3, #0]
    fc5e:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
    fc60:	4618      	mov	r0, r3
    fc62:	4770      	bx	lr

0000fc64 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
    fc64:	4b03      	ldr	r3, [pc, #12]	; (fc74 <_osc32kctrl_init_sources+0x10>)
    fc66:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
    fc68:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
    fc6c:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
    fc6e:	2201      	movs	r2, #1
    fc70:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
    fc72:	4770      	bx	lr
    fc74:	40001400 	.word	0x40001400

0000fc78 <hri_rtcmode0_wait_for_sync>:
typedef uint8_t  hri_rtcalarm_mask_reg_t;
typedef uint8_t  hri_rtcmode2_mask_reg_t;

static inline void hri_rtcmode0_wait_for_sync(const void *const hw, hri_rtcmode0_syncbusy_reg_t reg)
{
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
    fc78:	6903      	ldr	r3, [r0, #16]
    fc7a:	420b      	tst	r3, r1
    fc7c:	d1fc      	bne.n	fc78 <hri_rtcmode0_wait_for_sync>
	};
}
    fc7e:	4770      	bx	lr

0000fc80 <_rtc_timer_set_period>:
/**
 * \brief Set timer period
 */
void _rtc_timer_set_period(struct _timer_device *const dev, const uint32_t clock_cycles)
{
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, clock_cycles);
    fc80:	68c0      	ldr	r0, [r0, #12]

static inline void hri_rtcmode0_write_COMP_reg(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fc82:	4b02      	ldr	r3, [pc, #8]	; (fc8c <_rtc_timer_set_period+0xc>)
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    fc84:	6201      	str	r1, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fc86:	2160      	movs	r1, #96	; 0x60
    fc88:	4718      	bx	r3
    fc8a:	bf00      	nop
    fc8c:	0000fc79 	.word	0x0000fc79

0000fc90 <_rtc_timer_get_period>:

/**
 * \brief Retrieve timer period
 */
uint32_t _rtc_timer_get_period(const struct _timer_device *const dev)
{
    fc90:	b508      	push	{r3, lr}
	return hri_rtcmode0_read_COMP_reg(dev->hw, 0);
    fc92:	68c0      	ldr	r0, [r0, #12]
	RTC_CRITICAL_SECTION_LEAVE();
}

static inline hri_rtcmode0_comp_reg_t hri_rtcmode0_read_COMP_reg(const void *const hw, uint8_t index)
{
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fc94:	4b02      	ldr	r3, [pc, #8]	; (fca0 <_rtc_timer_get_period+0x10>)
    fc96:	2160      	movs	r1, #96	; 0x60
    fc98:	4798      	blx	r3
	return ((Rtc *)hw)->MODE0.COMP[index].reg;
    fc9a:	6a00      	ldr	r0, [r0, #32]
}
    fc9c:	bd08      	pop	{r3, pc}
    fc9e:	bf00      	nop
    fca0:	0000fc79 	.word	0x0000fc79

0000fca4 <_rtc_timer_is_started>:

/**
 * \brief Check if timer is running
 */
bool _rtc_timer_is_started(const struct _timer_device *const dev)
{
    fca4:	b508      	push	{r3, lr}
	return hri_rtcmode0_get_CTRLA_ENABLE_bit(dev->hw);
    fca6:	68c0      	ldr	r0, [r0, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fca8:	4b03      	ldr	r3, [pc, #12]	; (fcb8 <_rtc_timer_is_started+0x14>)
    fcaa:	f248 0103 	movw	r1, #32771	; 0x8003
    fcae:	4798      	blx	r3
	tmp = ((Rtc *)hw)->MODE0.CTRLA.reg;
    fcb0:	8800      	ldrh	r0, [r0, #0]
}
    fcb2:	f3c0 0040 	ubfx	r0, r0, #1, #1
    fcb6:	bd08      	pop	{r3, pc}
    fcb8:	0000fc79 	.word	0x0000fc79

0000fcbc <_rtc_timer_set_irq>:
 * \brief Set timer IRQ
 */
void _rtc_timer_set_irq(struct _timer_device *const dev)
{
	(void)dev;
}
    fcbc:	4770      	bx	lr
	...

0000fcc0 <_rtc_timer_stop>:
{
    fcc0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    fcc2:	4604      	mov	r4, r0
    fcc4:	b118      	cbz	r0, fcce <_rtc_timer_stop+0xe>
    fcc6:	68c0      	ldr	r0, [r0, #12]
    fcc8:	3800      	subs	r0, #0
    fcca:	bf18      	it	ne
    fccc:	2001      	movne	r0, #1
    fcce:	4908      	ldr	r1, [pc, #32]	; (fcf0 <_rtc_timer_stop+0x30>)
    fcd0:	4b08      	ldr	r3, [pc, #32]	; (fcf4 <_rtc_timer_stop+0x34>)
    fcd2:	226b      	movs	r2, #107	; 0x6b
    fcd4:	4798      	blx	r3
	hri_rtcmode0_clear_CTRLA_ENABLE_bit(dev->hw);
    fcd6:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg &= ~RTC_MODE0_CTRLA_ENABLE;
    fcd8:	8803      	ldrh	r3, [r0, #0]
    fcda:	f023 0302 	bic.w	r3, r3, #2
    fcde:	041b      	lsls	r3, r3, #16
    fce0:	0c1b      	lsrs	r3, r3, #16
    fce2:	8003      	strh	r3, [r0, #0]
}
    fce4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fce8:	4b03      	ldr	r3, [pc, #12]	; (fcf8 <_rtc_timer_stop+0x38>)
    fcea:	f248 0103 	movw	r1, #32771	; 0x8003
    fcee:	4718      	bx	r3
    fcf0:	00016ab2 	.word	0x00016ab2
    fcf4:	0000e42d 	.word	0x0000e42d
    fcf8:	0000fc79 	.word	0x0000fc79

0000fcfc <_rtc_timer_start>:
{
    fcfc:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    fcfe:	4604      	mov	r4, r0
    fd00:	b118      	cbz	r0, fd0a <_rtc_timer_start+0xe>
    fd02:	68c0      	ldr	r0, [r0, #12]
    fd04:	3800      	subs	r0, #0
    fd06:	bf18      	it	ne
    fd08:	2001      	movne	r0, #1
    fd0a:	490e      	ldr	r1, [pc, #56]	; (fd44 <_rtc_timer_start+0x48>)
    fd0c:	4b0e      	ldr	r3, [pc, #56]	; (fd48 <_rtc_timer_start+0x4c>)
    fd0e:	225e      	movs	r2, #94	; 0x5e
    fd10:	4798      	blx	r3
    fd12:	4b0e      	ldr	r3, [pc, #56]	; (fd4c <_rtc_timer_start+0x50>)
	hri_rtcmode0_write_COUNT_reg(dev->hw, 0);
    fd14:	68e0      	ldr	r0, [r4, #12]
    fd16:	f44f 6200 	mov.w	r2, #2048	; 0x800
    fd1a:	601a      	str	r2, [r3, #0]
	((Rtc *)hw)->MODE0.COUNT.reg = data;
    fd1c:	2300      	movs	r3, #0
    fd1e:	6183      	str	r3, [r0, #24]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COUNT);
    fd20:	4a0b      	ldr	r2, [pc, #44]	; (fd50 <_rtc_timer_start+0x54>)
    fd22:	2108      	movs	r1, #8
    fd24:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_COUNT);
    fd26:	68e0      	ldr	r0, [r4, #12]
    fd28:	2108      	movs	r1, #8
    fd2a:	4790      	blx	r2
	hri_rtcmode0_set_CTRLA_ENABLE_bit(dev->hw);
    fd2c:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
    fd2e:	8803      	ldrh	r3, [r0, #0]
    fd30:	b29b      	uxth	r3, r3
    fd32:	f043 0302 	orr.w	r3, r3, #2
}
    fd36:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    fd3a:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fd3c:	f248 0103 	movw	r1, #32771	; 0x8003
    fd40:	4710      	bx	r2
    fd42:	bf00      	nop
    fd44:	00016ab2 	.word	0x00016ab2
    fd48:	0000e42d 	.word	0x0000e42d
    fd4c:	e000e100 	.word	0xe000e100
    fd50:	0000fc79 	.word	0x0000fc79

0000fd54 <_rtc_timer_deinit>:
{
    fd54:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
    fd56:	4604      	mov	r4, r0
    fd58:	b118      	cbz	r0, fd62 <_rtc_timer_deinit+0xe>
    fd5a:	68c0      	ldr	r0, [r0, #12]
    fd5c:	3800      	subs	r0, #0
    fd5e:	bf18      	it	ne
    fd60:	2001      	movne	r0, #1
    fd62:	490b      	ldr	r1, [pc, #44]	; (fd90 <_rtc_timer_deinit+0x3c>)
    fd64:	4b0b      	ldr	r3, [pc, #44]	; (fd94 <_rtc_timer_deinit+0x40>)
    fd66:	2252      	movs	r2, #82	; 0x52
    fd68:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    fd6a:	4b0b      	ldr	r3, [pc, #44]	; (fd98 <_rtc_timer_deinit+0x44>)
    fd6c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    fd70:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    fd74:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    fd78:	f3bf 8f6f 	isb	sy
	hri_rtcmode0_write_CTRLA_reg(dev->hw, RTC_MODE0_CTRLA_SWRST);
    fd7c:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fd7e:	2301      	movs	r3, #1
    fd80:	8003      	strh	r3, [r0, #0]
}
    fd82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fd86:	4b05      	ldr	r3, [pc, #20]	; (fd9c <_rtc_timer_deinit+0x48>)
    fd88:	f248 0103 	movw	r1, #32771	; 0x8003
    fd8c:	4718      	bx	r3
    fd8e:	bf00      	nop
    fd90:	00016ab2 	.word	0x00016ab2
    fd94:	0000e42d 	.word	0x0000e42d
    fd98:	e000e100 	.word	0xe000e100
    fd9c:	0000fc79 	.word	0x0000fc79

0000fda0 <_rtc_timer_init>:
{
    fda0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(dev);
    fda2:	4604      	mov	r4, r0
{
    fda4:	460d      	mov	r5, r1
	ASSERT(dev);
    fda6:	3800      	subs	r0, #0
    fda8:	bf18      	it	ne
    fdaa:	2001      	movne	r0, #1
    fdac:	4b10      	ldr	r3, [pc, #64]	; (fdf0 <_rtc_timer_init+0x50>)
    fdae:	4911      	ldr	r1, [pc, #68]	; (fdf4 <_rtc_timer_init+0x54>)
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fdb0:	2601      	movs	r6, #1
    fdb2:	2230      	movs	r2, #48	; 0x30
    fdb4:	4798      	blx	r3
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fdb6:	4a10      	ldr	r2, [pc, #64]	; (fdf8 <_rtc_timer_init+0x58>)
	dev->hw = hw;
    fdb8:	60e5      	str	r5, [r4, #12]
    fdba:	4628      	mov	r0, r5
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fdbc:	802e      	strh	r6, [r5, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fdbe:	f248 0103 	movw	r1, #32771	; 0x8003
    fdc2:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
    fdc4:	68e0      	ldr	r0, [r4, #12]
    fdc6:	4631      	mov	r1, r6
    fdc8:	4790      	blx	r2
	    dev->hw, RTC_MODE0_CTRLA_PRESCALER(CONF_RTC_PRESCALER) | RTC_MODE0_CTRLA_COUNTSYNC | RTC_MODE0_CTRLA_MATCHCLR);
    fdca:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
    fdcc:	f248 0380 	movw	r3, #32896	; 0x8080
    fdd0:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
    fdd2:	f248 0103 	movw	r1, #32771	; 0x8003
    fdd6:	4790      	blx	r2
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, CONF_RTC_COMP_VAL);
    fdd8:	68e0      	ldr	r0, [r4, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fdda:	2160      	movs	r1, #96	; 0x60
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
    fddc:	6206      	str	r6, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
    fdde:	4790      	blx	r2
	hri_rtcmode0_set_INTEN_CMP0_bit(dev->hw);
    fde0:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
    fde2:	f44f 7280 	mov.w	r2, #256	; 0x100
    fde6:	815a      	strh	r2, [r3, #10]
	_rtc_dev = dev;
    fde8:	4b04      	ldr	r3, [pc, #16]	; (fdfc <_rtc_timer_init+0x5c>)
}
    fdea:	2000      	movs	r0, #0
	_rtc_dev = dev;
    fdec:	601c      	str	r4, [r3, #0]
}
    fdee:	bd70      	pop	{r4, r5, r6, pc}
    fdf0:	0000e42d 	.word	0x0000e42d
    fdf4:	00016ab2 	.word	0x00016ab2
    fdf8:	0000fc79 	.word	0x0000fc79
    fdfc:	20008d00 	.word	0x20008d00

0000fe00 <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return &_rtc_timer_functions;
}
    fe00:	4800      	ldr	r0, [pc, #0]	; (fe04 <_rtc_get_timer+0x4>)
    fe02:	4770      	bx	lr
    fe04:	2000050c 	.word	0x2000050c

0000fe08 <RTC_Handler>:
/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
	_rtc_timer_interrupt_handler(_rtc_dev);
    fe08:	4b07      	ldr	r3, [pc, #28]	; (fe28 <RTC_Handler+0x20>)
{
    fe0a:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
    fe0c:	681c      	ldr	r4, [r3, #0]
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
    fe0e:	68e3      	ldr	r3, [r4, #12]
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
    fe10:	899b      	ldrh	r3, [r3, #12]
	if (flag & RTC_MODE0_INTFLAG_CMP0) {
    fe12:	05db      	lsls	r3, r3, #23
    fe14:	d507      	bpl.n	fe26 <RTC_Handler+0x1e>
		if (dev->timer_cb.period_expired) {
    fe16:	6823      	ldr	r3, [r4, #0]
    fe18:	b10b      	cbz	r3, fe1e <RTC_Handler+0x16>
			dev->timer_cb.period_expired(dev);
    fe1a:	4620      	mov	r0, r4
    fe1c:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
    fe1e:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
    fe20:	f44f 7280 	mov.w	r2, #256	; 0x100
    fe24:	819a      	strh	r2, [r3, #12]
}
    fe26:	bd10      	pop	{r4, pc}
    fe28:	20008d00 	.word	0x20008d00

0000fe2c <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
    fe2c:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
    fe2e:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
    fe30:	b2c5      	uxtb	r5, r0
    fe32:	4b18      	ldr	r3, [pc, #96]	; (fe94 <_gpio_set_pin_function+0x68>)
    fe34:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
    fe38:	ea4f 1050 	mov.w	r0, r0, lsr #5
    fe3c:	ea4f 10c0 	mov.w	r0, r0, lsl #7
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    fe40:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
    fe42:	d107      	bne.n	fe54 <_gpio_set_pin_function+0x28>
    fe44:	4423      	add	r3, r4
    fe46:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    fe4a:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    fe4e:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
    fe52:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    fe54:	1918      	adds	r0, r3, r4
    fe56:	eb03 0354 	add.w	r3, r3, r4, lsr #1
    fe5a:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
    fe5e:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
    fe62:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    fe66:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
    fe6a:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
    fe6e:	f015 0f01 	tst.w	r5, #1
    fe72:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
    fe74:	bf19      	ittee	ne
    fe76:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
    fe7a:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
    fe7e:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
    fe82:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
    fe86:	bf14      	ite	ne
    fe88:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
    fe8a:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
    fe8c:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
    fe90:	e7df      	b.n	fe52 <_gpio_set_pin_function+0x26>
    fe92:	bf00      	nop
    fe94:	41008000 	.word	0x41008000

0000fe98 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    fe98:	f000 031f 	and.w	r3, r0, #31
{
    fe9c:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    fe9e:	2501      	movs	r5, #1
    fea0:	409d      	lsls	r5, r3
	switch (direction) {
    fea2:	0940      	lsrs	r0, r0, #5
    fea4:	4b0f      	ldr	r3, [pc, #60]	; (fee4 <gpio_set_pin_direction+0x4c>)
    fea6:	01c0      	lsls	r0, r0, #7
    fea8:	2901      	cmp	r1, #1
    feaa:	b2ac      	uxth	r4, r5
    feac:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    feb0:	4403      	add	r3, r0
    feb2:	d008      	beq.n	fec6 <gpio_set_pin_direction+0x2e>
    feb4:	2902      	cmp	r1, #2
    feb6:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    feba:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    febe:	d00e      	beq.n	fede <gpio_set_pin_direction+0x46>
    fec0:	605d      	str	r5, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    fec2:	629c      	str	r4, [r3, #40]	; 0x28
    fec4:	e009      	b.n	feda <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    fec6:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    feca:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
    fece:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    fed2:	605d      	str	r5, [r3, #4]
    fed4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    fed8:	629c      	str	r4, [r3, #40]	; 0x28
    feda:	629a      	str	r2, [r3, #40]	; 0x28
}
    fedc:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    fede:	609d      	str	r5, [r3, #8]
    fee0:	e7ef      	b.n	fec2 <gpio_set_pin_direction+0x2a>
    fee2:	bf00      	nop
    fee4:	41008000 	.word	0x41008000

0000fee8 <gpio_set_pin_pull_mode>:
	switch (pull_mode) {
    fee8:	0942      	lsrs	r2, r0, #5
    feea:	2901      	cmp	r1, #1
    feec:	4b0d      	ldr	r3, [pc, #52]	; (ff24 <gpio_set_pin_pull_mode+0x3c>)
    feee:	f000 001f 	and.w	r0, r0, #31
    fef2:	ea4f 12c2 	mov.w	r2, r2, lsl #7
    fef6:	d008      	beq.n	ff0a <gpio_set_pin_pull_mode+0x22>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    fef8:	4413      	add	r3, r2
    fefa:	4418      	add	r0, r3
    fefc:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
    ff00:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
    ff04:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
}
    ff08:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    ff0a:	4413      	add	r3, r2
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    ff0c:	4081      	lsls	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    ff0e:	4418      	add	r0, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    ff10:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    ff12:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
    ff16:	f042 0204 	orr.w	r2, r2, #4
    ff1a:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    ff1e:	6199      	str	r1, [r3, #24]
}
    ff20:	4770      	bx	lr
    ff22:	bf00      	nop
    ff24:	41008000 	.word	0x41008000

0000ff28 <ADC_0_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
    ff28:	4a14      	ldr	r2, [pc, #80]	; (ff7c <ADC_0_init+0x54>)
 */
void ADC_0_init(void)
{
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    ff2a:	4915      	ldr	r1, [pc, #84]	; (ff80 <ADC_0_init+0x58>)
    ff2c:	6a13      	ldr	r3, [r2, #32]
{
    ff2e:	b5f0      	push	{r4, r5, r6, r7, lr}
    ff30:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    ff34:	6213      	str	r3, [r2, #32]
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    ff36:	4b13      	ldr	r3, [pc, #76]	; (ff84 <ADC_0_init+0x5c>)
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    ff38:	4e13      	ldr	r6, [pc, #76]	; (ff88 <ADC_0_init+0x60>)
    ff3a:	4d14      	ldr	r5, [pc, #80]	; (ff8c <ADC_0_init+0x64>)
    ff3c:	4f14      	ldr	r7, [pc, #80]	; (ff90 <ADC_0_init+0x68>)
{
    ff3e:	b085      	sub	sp, #20
    ff40:	2241      	movs	r2, #65	; 0x41
    ff42:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
    ff46:	4b13      	ldr	r3, [pc, #76]	; (ff94 <ADC_0_init+0x6c>)
    ff48:	9301      	str	r3, [sp, #4]
    ff4a:	2400      	movs	r4, #0
    ff4c:	2301      	movs	r3, #1
    ff4e:	9300      	str	r3, [sp, #0]
    ff50:	4632      	mov	r2, r6
    ff52:	4623      	mov	r3, r4
    ff54:	9402      	str	r4, [sp, #8]
    ff56:	4628      	mov	r0, r5
    ff58:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_0, 0, ADC_0_buffer, ADC_0_BUFFER_SIZE);
    ff5a:	1c72      	adds	r2, r6, #1
    ff5c:	4621      	mov	r1, r4
    ff5e:	2310      	movs	r3, #16
    ff60:	4628      	mov	r0, r5
    ff62:	4d0d      	ldr	r5, [pc, #52]	; (ff98 <ADC_0_init+0x70>)
    ff64:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PA07, GPIO_DIRECTION_OFF);
    ff66:	4621      	mov	r1, r4
    ff68:	4b0c      	ldr	r3, [pc, #48]	; (ff9c <ADC_0_init+0x74>)
    ff6a:	2007      	movs	r0, #7
    ff6c:	4798      	blx	r3
	_gpio_set_pin_function(pin, function);
    ff6e:	490c      	ldr	r1, [pc, #48]	; (ffa0 <ADC_0_init+0x78>)
    ff70:	4b0c      	ldr	r3, [pc, #48]	; (ffa4 <ADC_0_init+0x7c>)
    ff72:	2007      	movs	r0, #7

	gpio_set_pin_function(PA07, PINMUX_PA07B_ADC0_AIN7);
}
    ff74:	b005      	add	sp, #20
    ff76:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    ff7a:	4718      	bx	r3
    ff7c:	40000800 	.word	0x40000800
    ff80:	43001c00 	.word	0x43001c00
    ff84:	40001c00 	.word	0x40001c00
    ff88:	20008d04 	.word	0x20008d04
    ff8c:	2001cd84 	.word	0x2001cd84
    ff90:	0000e725 	.word	0x0000e725
    ff94:	2001ce80 	.word	0x2001ce80
    ff98:	0000e7c9 	.word	0x0000e7c9
    ff9c:	0000fe99 	.word	0x0000fe99
    ffa0:	00070001 	.word	0x00070001
    ffa4:	0000fe2d 	.word	0x0000fe2d

0000ffa8 <ADC_1_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
    ffa8:	4a15      	ldr	r2, [pc, #84]	; (10000 <STACK_SIZE>)
 */
void ADC_1_init(void)
{
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    ffaa:	4916      	ldr	r1, [pc, #88]	; (10004 <STACK_SIZE+0x4>)
    ffac:	6a13      	ldr	r3, [r2, #32]
{
    ffae:	b5f0      	push	{r4, r5, r6, r7, lr}
    ffb0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
    ffb4:	6213      	str	r3, [r2, #32]
    ffb6:	4b14      	ldr	r3, [pc, #80]	; (10008 <STACK_SIZE+0x8>)
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    ffb8:	4e14      	ldr	r6, [pc, #80]	; (1000c <STACK_SIZE+0xc>)
    ffba:	4d15      	ldr	r5, [pc, #84]	; (10010 <STACK_SIZE+0x10>)
    ffbc:	4f15      	ldr	r7, [pc, #84]	; (10014 <STACK_SIZE+0x14>)
{
    ffbe:	b085      	sub	sp, #20
    ffc0:	2241      	movs	r2, #65	; 0x41
    ffc2:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
    ffc6:	4b14      	ldr	r3, [pc, #80]	; (10018 <STACK_SIZE+0x18>)
    ffc8:	9301      	str	r3, [sp, #4]
    ffca:	2400      	movs	r4, #0
    ffcc:	2301      	movs	r3, #1
    ffce:	9300      	str	r3, [sp, #0]
    ffd0:	f106 0211 	add.w	r2, r6, #17
    ffd4:	4623      	mov	r3, r4
    ffd6:	9402      	str	r4, [sp, #8]
    ffd8:	4628      	mov	r0, r5
    ffda:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_1, 0, ADC_1_buffer, ADC_1_BUFFER_SIZE);
    ffdc:	f106 0212 	add.w	r2, r6, #18
    ffe0:	4621      	mov	r1, r4
    ffe2:	2310      	movs	r3, #16
    ffe4:	4628      	mov	r0, r5
    ffe6:	4d0d      	ldr	r5, [pc, #52]	; (1001c <STACK_SIZE+0x1c>)
    ffe8:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PC02, GPIO_DIRECTION_OFF);
    ffea:	4621      	mov	r1, r4
    ffec:	4b0c      	ldr	r3, [pc, #48]	; (10020 <STACK_SIZE+0x20>)
    ffee:	2042      	movs	r0, #66	; 0x42
    fff0:	4798      	blx	r3
    fff2:	490c      	ldr	r1, [pc, #48]	; (10024 <STACK_SIZE+0x24>)
    fff4:	4b0c      	ldr	r3, [pc, #48]	; (10028 <STACK_SIZE+0x28>)
    fff6:	2042      	movs	r0, #66	; 0x42

	gpio_set_pin_function(PC02, PINMUX_PC02B_ADC1_AIN4);
}
    fff8:	b005      	add	sp, #20
    fffa:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    fffe:	4718      	bx	r3
   10000:	40000800 	.word	0x40000800
   10004:	43002000 	.word	0x43002000
   10008:	40001c00 	.word	0x40001c00
   1000c:	20008d04 	.word	0x20008d04
   10010:	2001cf58 	.word	0x2001cf58
   10014:	0000e725 	.word	0x0000e725
   10018:	2001cd18 	.word	0x2001cd18
   1001c:	0000e7c9 	.word	0x0000e7c9
   10020:	0000fe99 	.word	0x0000fe99
   10024:	00420001 	.word	0x00420001
   10028:	0000fe2d 	.word	0x0000fe2d

0001002c <CRC_0_init>:
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_DSU;
   1002c:	4a04      	ldr	r2, [pc, #16]	; (10040 <CRC_0_init+0x14>)
 * Enables CRC peripheral, clocks and initializes CRC driver
 */
void CRC_0_init(void)
{
	hri_mclk_set_APBBMASK_DSU_bit(MCLK);
	crc_sync_init(&CRC_0, DSU);
   1002e:	4905      	ldr	r1, [pc, #20]	; (10044 <CRC_0_init+0x18>)
   10030:	6993      	ldr	r3, [r2, #24]
   10032:	4805      	ldr	r0, [pc, #20]	; (10048 <CRC_0_init+0x1c>)
   10034:	f043 0302 	orr.w	r3, r3, #2
   10038:	6193      	str	r3, [r2, #24]
   1003a:	4b04      	ldr	r3, [pc, #16]	; (1004c <CRC_0_init+0x20>)
   1003c:	4718      	bx	r3
   1003e:	bf00      	nop
   10040:	40000800 	.word	0x40000800
   10044:	41002000 	.word	0x41002000
   10048:	2001cd14 	.word	0x2001cd14
   1004c:	0000f67d 	.word	0x0000f67d

00010050 <EVENT_SYSTEM_0_init>:
   10050:	4b08      	ldr	r3, [pc, #32]	; (10074 <EVENT_SYSTEM_0_init+0x24>)
   10052:	2240      	movs	r2, #64	; 0x40
   10054:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
   10058:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
   1005c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
   10060:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_EVSYS;
   10064:	4a04      	ldr	r2, [pc, #16]	; (10078 <EVENT_SYSTEM_0_init+0x28>)
   10066:	6993      	ldr	r3, [r2, #24]
   10068:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1006c:	6193      	str	r3, [r2, #24]
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_2, CONF_GCLK_EVSYS_CHANNEL_2_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_3, CONF_GCLK_EVSYS_CHANNEL_3_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_EVSYS_bit(MCLK);

	event_system_init();
   1006e:	4b03      	ldr	r3, [pc, #12]	; (1007c <EVENT_SYSTEM_0_init+0x2c>)
   10070:	4718      	bx	r3
   10072:	bf00      	nop
   10074:	40001c00 	.word	0x40001c00
   10078:	40000800 	.word	0x40000800
   1007c:	000131ad 	.word	0x000131ad

00010080 <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
   10080:	4a02      	ldr	r2, [pc, #8]	; (1008c <FLASH_0_CLOCK_init+0xc>)
   10082:	6913      	ldr	r3, [r2, #16]
   10084:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10088:	6113      	str	r3, [r2, #16]

void FLASH_0_CLOCK_init(void)
{

	hri_mclk_set_AHBMASK_NVMCTRL_bit(MCLK);
}
   1008a:	4770      	bx	lr
   1008c:	40000800 	.word	0x40000800

00010090 <FLASH_0_init>:

void FLASH_0_init(void)
{
   10090:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
   10092:	4b04      	ldr	r3, [pc, #16]	; (100a4 <FLASH_0_init+0x14>)
   10094:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
}
   10096:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	flash_init(&FLASH_0, NVMCTRL);
   1009a:	4903      	ldr	r1, [pc, #12]	; (100a8 <FLASH_0_init+0x18>)
   1009c:	4803      	ldr	r0, [pc, #12]	; (100ac <FLASH_0_init+0x1c>)
   1009e:	4b04      	ldr	r3, [pc, #16]	; (100b0 <FLASH_0_init+0x20>)
   100a0:	4718      	bx	r3
   100a2:	bf00      	nop
   100a4:	00010081 	.word	0x00010081
   100a8:	41004000 	.word	0x41004000
   100ac:	2001ccf8 	.word	0x2001ccf8
   100b0:	0000f125 	.word	0x0000f125

000100b4 <QSPI_INSTANCE_PORT_init>:

void QSPI_INSTANCE_PORT_init(void)
{
   100b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	// Set pin direction to input
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
   100b8:	2101      	movs	r1, #1
   100ba:	4e24      	ldr	r6, [pc, #144]	; (1014c <QSPI_INSTANCE_PORT_init+0x98>)

	gpio_set_pin_pull_mode(PB11,
   100bc:	4d24      	ldr	r5, [pc, #144]	; (10150 <QSPI_INSTANCE_PORT_init+0x9c>)
   100be:	4c25      	ldr	r4, [pc, #148]	; (10154 <QSPI_INSTANCE_PORT_init+0xa0>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   100c0:	4f25      	ldr	r7, [pc, #148]	; (10158 <QSPI_INSTANCE_PORT_init+0xa4>)
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
   100c2:	202b      	movs	r0, #43	; 0x2b
   100c4:	47b0      	blx	r6
	gpio_set_pin_pull_mode(PB11,
   100c6:	2100      	movs	r1, #0
   100c8:	202b      	movs	r0, #43	; 0x2b
   100ca:	47a8      	blx	r5
   100cc:	4923      	ldr	r1, [pc, #140]	; (1015c <QSPI_INSTANCE_PORT_init+0xa8>)
   100ce:	202b      	movs	r0, #43	; 0x2b
   100d0:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB11, PINMUX_PB11H_QSPI_CS);

	gpio_set_pin_direction(PA08,
   100d2:	2102      	movs	r1, #2
   100d4:	2008      	movs	r0, #8
   100d6:	47b0      	blx	r6
   100d8:	f44f 7380 	mov.w	r3, #256	; 0x100
   100dc:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA08,
   100de:	2100      	movs	r1, #0
   100e0:	2008      	movs	r0, #8
   100e2:	47a8      	blx	r5
   100e4:	491e      	ldr	r1, [pc, #120]	; (10160 <QSPI_INSTANCE_PORT_init+0xac>)
   100e6:	2008      	movs	r0, #8
   100e8:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA08H_QSPI_DATA0);

	gpio_set_pin_direction(PA09,
   100ea:	2102      	movs	r1, #2
   100ec:	2009      	movs	r0, #9
   100ee:	47b0      	blx	r6
   100f0:	f44f 7300 	mov.w	r3, #512	; 0x200
   100f4:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA09,
   100f6:	2100      	movs	r1, #0
   100f8:	2009      	movs	r0, #9
   100fa:	47a8      	blx	r5
   100fc:	4919      	ldr	r1, [pc, #100]	; (10164 <QSPI_INSTANCE_PORT_init+0xb0>)
   100fe:	2009      	movs	r0, #9
   10100:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA09H_QSPI_DATA1);

	gpio_set_pin_direction(PA10,
   10102:	2102      	movs	r1, #2
   10104:	200a      	movs	r0, #10
   10106:	47b0      	blx	r6
   10108:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1010c:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA10,
   1010e:	2100      	movs	r1, #0
   10110:	200a      	movs	r0, #10
   10112:	47a8      	blx	r5
   10114:	4914      	ldr	r1, [pc, #80]	; (10168 <QSPI_INSTANCE_PORT_init+0xb4>)
   10116:	200a      	movs	r0, #10
   10118:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA10H_QSPI_DATA2);

	gpio_set_pin_direction(PA11,
   1011a:	2102      	movs	r1, #2
   1011c:	200b      	movs	r0, #11
   1011e:	47b0      	blx	r6
   10120:	f44f 6300 	mov.w	r3, #2048	; 0x800
   10124:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA11,
   10126:	2100      	movs	r1, #0
   10128:	200b      	movs	r0, #11
   1012a:	47a8      	blx	r5
   1012c:	490f      	ldr	r1, [pc, #60]	; (1016c <QSPI_INSTANCE_PORT_init+0xb8>)
   1012e:	200b      	movs	r0, #11
   10130:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA11H_QSPI_DATA3);

	// Set pin direction to input
	gpio_set_pin_direction(PB10, GPIO_DIRECTION_IN);
   10132:	2101      	movs	r1, #1
   10134:	202a      	movs	r0, #42	; 0x2a
   10136:	47b0      	blx	r6

	gpio_set_pin_pull_mode(PB10,
   10138:	2100      	movs	r1, #0
   1013a:	202a      	movs	r0, #42	; 0x2a
   1013c:	47a8      	blx	r5
   1013e:	4623      	mov	r3, r4
   10140:	490b      	ldr	r1, [pc, #44]	; (10170 <QSPI_INSTANCE_PORT_init+0xbc>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB10, PINMUX_PB10H_QSPI_SCK);
}
   10142:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10146:	202a      	movs	r0, #42	; 0x2a
   10148:	4718      	bx	r3
   1014a:	bf00      	nop
   1014c:	0000fe99 	.word	0x0000fe99
   10150:	0000fee9 	.word	0x0000fee9
   10154:	0000fe2d 	.word	0x0000fe2d
   10158:	41008000 	.word	0x41008000
   1015c:	002b0007 	.word	0x002b0007
   10160:	00080007 	.word	0x00080007
   10164:	00090007 	.word	0x00090007
   10168:	000a0007 	.word	0x000a0007
   1016c:	000b0007 	.word	0x000b0007
   10170:	002a0007 	.word	0x002a0007

00010174 <QSPI_INSTANCE_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI;
   10174:	4b06      	ldr	r3, [pc, #24]	; (10190 <QSPI_INSTANCE_CLOCK_init+0x1c>)
   10176:	691a      	ldr	r2, [r3, #16]
   10178:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   1017c:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI_2X;
   1017e:	691a      	ldr	r2, [r3, #16]
   10180:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   10184:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_QSPI;
   10186:	69da      	ldr	r2, [r3, #28]
   10188:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   1018c:	61da      	str	r2, [r3, #28]
void QSPI_INSTANCE_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_QSPI_bit(MCLK);
	hri_mclk_set_AHBMASK_QSPI_2X_bit(MCLK);
	hri_mclk_set_APBCMASK_QSPI_bit(MCLK);
}
   1018e:	4770      	bx	lr
   10190:	40000800 	.word	0x40000800

00010194 <QSPI_INSTANCE_init>:

void QSPI_INSTANCE_init(void)
{
   10194:	b510      	push	{r4, lr}
	QSPI_INSTANCE_CLOCK_init();
   10196:	4b05      	ldr	r3, [pc, #20]	; (101ac <QSPI_INSTANCE_init+0x18>)
   10198:	4798      	blx	r3
	qspi_dma_init(&QSPI_INSTANCE, QSPI);
   1019a:	4b05      	ldr	r3, [pc, #20]	; (101b0 <QSPI_INSTANCE_init+0x1c>)
   1019c:	4905      	ldr	r1, [pc, #20]	; (101b4 <QSPI_INSTANCE_init+0x20>)
   1019e:	4806      	ldr	r0, [pc, #24]	; (101b8 <QSPI_INSTANCE_init+0x24>)
   101a0:	4798      	blx	r3
	QSPI_INSTANCE_PORT_init();
}
   101a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	QSPI_INSTANCE_PORT_init();
   101a6:	4b05      	ldr	r3, [pc, #20]	; (101bc <QSPI_INSTANCE_init+0x28>)
   101a8:	4718      	bx	r3
   101aa:	bf00      	nop
   101ac:	00010175 	.word	0x00010175
   101b0:	00012919 	.word	0x00012919
   101b4:	42003400 	.word	0x42003400
   101b8:	2001cfc4 	.word	0x2001cfc4
   101bc:	000100b5 	.word	0x000100b5

000101c0 <USART_EAST_CLOCK_init>:
   101c0:	4b06      	ldr	r3, [pc, #24]	; (101dc <USART_EAST_CLOCK_init+0x1c>)
   101c2:	2241      	movs	r2, #65	; 0x41
   101c4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
   101c8:	2242      	movs	r2, #66	; 0x42
   101ca:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
   101ce:	4a04      	ldr	r2, [pc, #16]	; (101e0 <USART_EAST_CLOCK_init+0x20>)
   101d0:	6953      	ldr	r3, [r2, #20]
   101d2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   101d6:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}
   101d8:	4770      	bx	lr
   101da:	bf00      	nop
   101dc:	40001c00 	.word	0x40001c00
   101e0:	40000800 	.word	0x40000800

000101e4 <USART_EAST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_EAST_PORT_init()
{
   101e4:	b510      	push	{r4, lr}
   101e6:	4c05      	ldr	r4, [pc, #20]	; (101fc <USART_EAST_PORT_init+0x18>)
   101e8:	4905      	ldr	r1, [pc, #20]	; (10200 <USART_EAST_PORT_init+0x1c>)
   101ea:	2051      	movs	r0, #81	; 0x51
   101ec:	47a0      	blx	r4
   101ee:	4623      	mov	r3, r4
   101f0:	4904      	ldr	r1, [pc, #16]	; (10204 <USART_EAST_PORT_init+0x20>)

	gpio_set_pin_function(PC17, PINMUX_PC17D_SERCOM0_PAD0);

	gpio_set_pin_function(PC16, PINMUX_PC16D_SERCOM0_PAD1);
}
   101f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   101f6:	2050      	movs	r0, #80	; 0x50
   101f8:	4718      	bx	r3
   101fa:	bf00      	nop
   101fc:	0000fe2d 	.word	0x0000fe2d
   10200:	00510003 	.word	0x00510003
   10204:	00500003 	.word	0x00500003

00010208 <USART_EAST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_EAST_init(void)
{
   10208:	b513      	push	{r0, r1, r4, lr}
	USART_EAST_CLOCK_init();
   1020a:	4b07      	ldr	r3, [pc, #28]	; (10228 <USART_EAST_init+0x20>)
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
   1020c:	4c07      	ldr	r4, [pc, #28]	; (1022c <USART_EAST_init+0x24>)
	USART_EAST_CLOCK_init();
   1020e:	4798      	blx	r3
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
   10210:	2300      	movs	r3, #0
   10212:	9300      	str	r3, [sp, #0]
   10214:	4a06      	ldr	r2, [pc, #24]	; (10230 <USART_EAST_init+0x28>)
   10216:	4907      	ldr	r1, [pc, #28]	; (10234 <USART_EAST_init+0x2c>)
   10218:	4807      	ldr	r0, [pc, #28]	; (10238 <USART_EAST_init+0x30>)
   1021a:	2310      	movs	r3, #16
   1021c:	47a0      	blx	r4
	USART_EAST_PORT_init();
   1021e:	4b07      	ldr	r3, [pc, #28]	; (1023c <USART_EAST_init+0x34>)
}
   10220:	b002      	add	sp, #8
   10222:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_EAST_PORT_init();
   10226:	4718      	bx	r3
   10228:	000101c1 	.word	0x000101c1
   1022c:	00010b1d 	.word	0x00010b1d
   10230:	20008d26 	.word	0x20008d26
   10234:	40003000 	.word	0x40003000
   10238:	2001cdb0 	.word	0x2001cdb0
   1023c:	000101e5 	.word	0x000101e5

00010240 <USART_NORTH_CLOCK_init>:
   10240:	4b06      	ldr	r3, [pc, #24]	; (1025c <USART_NORTH_CLOCK_init+0x1c>)
   10242:	2241      	movs	r2, #65	; 0x41
   10244:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
   10248:	2242      	movs	r2, #66	; 0x42
   1024a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
   1024e:	4a04      	ldr	r2, [pc, #16]	; (10260 <USART_NORTH_CLOCK_init+0x20>)
   10250:	6953      	ldr	r3, [r2, #20]
   10252:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10256:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}
   10258:	4770      	bx	lr
   1025a:	bf00      	nop
   1025c:	40001c00 	.word	0x40001c00
   10260:	40000800 	.word	0x40000800

00010264 <USART_NORTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_NORTH_PORT_init()
{
   10264:	b510      	push	{r4, lr}
   10266:	4c05      	ldr	r4, [pc, #20]	; (1027c <USART_NORTH_PORT_init+0x18>)
   10268:	4905      	ldr	r1, [pc, #20]	; (10280 <USART_NORTH_PORT_init+0x1c>)
   1026a:	205b      	movs	r0, #91	; 0x5b
   1026c:	47a0      	blx	r4
   1026e:	4623      	mov	r3, r4
   10270:	4904      	ldr	r1, [pc, #16]	; (10284 <USART_NORTH_PORT_init+0x20>)

	gpio_set_pin_function(PC27, PINMUX_PC27C_SERCOM1_PAD0);

	gpio_set_pin_function(PC28, PINMUX_PC28C_SERCOM1_PAD1);
}
   10272:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10276:	205c      	movs	r0, #92	; 0x5c
   10278:	4718      	bx	r3
   1027a:	bf00      	nop
   1027c:	0000fe2d 	.word	0x0000fe2d
   10280:	005b0002 	.word	0x005b0002
   10284:	005c0002 	.word	0x005c0002

00010288 <USART_NORTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_NORTH_init(void)
{
   10288:	b513      	push	{r0, r1, r4, lr}
	USART_NORTH_CLOCK_init();
   1028a:	4b07      	ldr	r3, [pc, #28]	; (102a8 <USART_NORTH_init+0x20>)
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
   1028c:	4c07      	ldr	r4, [pc, #28]	; (102ac <USART_NORTH_init+0x24>)
	USART_NORTH_CLOCK_init();
   1028e:	4798      	blx	r3
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
   10290:	2300      	movs	r3, #0
   10292:	9300      	str	r3, [sp, #0]
   10294:	4a06      	ldr	r2, [pc, #24]	; (102b0 <USART_NORTH_init+0x28>)
   10296:	4907      	ldr	r1, [pc, #28]	; (102b4 <USART_NORTH_init+0x2c>)
   10298:	4807      	ldr	r0, [pc, #28]	; (102b8 <USART_NORTH_init+0x30>)
   1029a:	2310      	movs	r3, #16
   1029c:	47a0      	blx	r4
	USART_NORTH_PORT_init();
   1029e:	4b07      	ldr	r3, [pc, #28]	; (102bc <USART_NORTH_init+0x34>)
}
   102a0:	b002      	add	sp, #8
   102a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_NORTH_PORT_init();
   102a6:	4718      	bx	r3
   102a8:	00010241 	.word	0x00010241
   102ac:	00010b1d 	.word	0x00010b1d
   102b0:	20008d36 	.word	0x20008d36
   102b4:	40003400 	.word	0x40003400
   102b8:	2001ce04 	.word	0x2001ce04
   102bc:	00010265 	.word	0x00010265

000102c0 <GRID_AUX_PORT_init>:

void GRID_AUX_PORT_init(void)
{
   102c0:	b510      	push	{r4, lr}
   102c2:	4c05      	ldr	r4, [pc, #20]	; (102d8 <GRID_AUX_PORT_init+0x18>)
   102c4:	4905      	ldr	r1, [pc, #20]	; (102dc <GRID_AUX_PORT_init+0x1c>)
   102c6:	2039      	movs	r0, #57	; 0x39
   102c8:	47a0      	blx	r4
   102ca:	4623      	mov	r3, r4
   102cc:	4904      	ldr	r1, [pc, #16]	; (102e0 <GRID_AUX_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
   102ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   102d2:	2038      	movs	r0, #56	; 0x38
   102d4:	4718      	bx	r3
   102d6:	bf00      	nop
   102d8:	0000fe2d 	.word	0x0000fe2d
   102dc:	00390003 	.word	0x00390003
   102e0:	00380003 	.word	0x00380003

000102e4 <GRID_AUX_CLOCK_init>:
   102e4:	4b06      	ldr	r3, [pc, #24]	; (10300 <GRID_AUX_CLOCK_init+0x1c>)
   102e6:	2241      	movs	r2, #65	; 0x41
   102e8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
   102ec:	2242      	movs	r2, #66	; 0x42
   102ee:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
   102f2:	4a04      	ldr	r2, [pc, #16]	; (10304 <GRID_AUX_CLOCK_init+0x20>)
   102f4:	6993      	ldr	r3, [r2, #24]
   102f6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   102fa:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
   102fc:	4770      	bx	lr
   102fe:	bf00      	nop
   10300:	40001c00 	.word	0x40001c00
   10304:	40000800 	.word	0x40000800

00010308 <GRID_AUX_init>:

void GRID_AUX_init(void)
{
   10308:	b510      	push	{r4, lr}
	GRID_AUX_CLOCK_init();
   1030a:	4b05      	ldr	r3, [pc, #20]	; (10320 <GRID_AUX_init+0x18>)
   1030c:	4798      	blx	r3
	usart_sync_init(&GRID_AUX, SERCOM2, (void *)NULL);
   1030e:	4b05      	ldr	r3, [pc, #20]	; (10324 <GRID_AUX_init+0x1c>)
   10310:	4905      	ldr	r1, [pc, #20]	; (10328 <GRID_AUX_init+0x20>)
   10312:	4806      	ldr	r0, [pc, #24]	; (1032c <GRID_AUX_init+0x24>)
   10314:	2200      	movs	r2, #0
   10316:	4798      	blx	r3
	GRID_AUX_PORT_init();
}
   10318:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_AUX_PORT_init();
   1031c:	4b04      	ldr	r3, [pc, #16]	; (10330 <GRID_AUX_init+0x28>)
   1031e:	4718      	bx	r3
   10320:	000102e5 	.word	0x000102e5
   10324:	0000efd9 	.word	0x0000efd9
   10328:	41012000 	.word	0x41012000
   1032c:	2001cd70 	.word	0x2001cd70
   10330:	000102c1 	.word	0x000102c1

00010334 <UI_SPI_PORT_init>:

void UI_SPI_PORT_init(void)
{
   10334:	b570      	push	{r4, r5, r6, lr}
   10336:	4e12      	ldr	r6, [pc, #72]	; (10380 <UI_SPI_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB20, GPIO_DIRECTION_OUT);
   10338:	4d12      	ldr	r5, [pc, #72]	; (10384 <UI_SPI_PORT_init+0x50>)
   1033a:	4c13      	ldr	r4, [pc, #76]	; (10388 <UI_SPI_PORT_init+0x54>)
   1033c:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   10340:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   10344:	2102      	movs	r1, #2
   10346:	2034      	movs	r0, #52	; 0x34
   10348:	47a8      	blx	r5
   1034a:	4910      	ldr	r1, [pc, #64]	; (1038c <UI_SPI_PORT_init+0x58>)
   1034c:	2034      	movs	r0, #52	; 0x34
   1034e:	47a0      	blx	r4
   10350:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
   10354:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB21, GPIO_DIRECTION_OUT);
   10358:	2102      	movs	r1, #2
   1035a:	2035      	movs	r0, #53	; 0x35
   1035c:	47a8      	blx	r5
   1035e:	490c      	ldr	r1, [pc, #48]	; (10390 <UI_SPI_PORT_init+0x5c>)
   10360:	2035      	movs	r0, #53	; 0x35
   10362:	47a0      	blx	r4

	gpio_set_pin_function(PB21, PINMUX_PB21C_SERCOM3_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA20, GPIO_DIRECTION_IN);
   10364:	2101      	movs	r1, #1
   10366:	2014      	movs	r0, #20
   10368:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA20,
   1036a:	4b0a      	ldr	r3, [pc, #40]	; (10394 <UI_SPI_PORT_init+0x60>)
   1036c:	2100      	movs	r1, #0
   1036e:	2014      	movs	r0, #20
   10370:	4798      	blx	r3
   10372:	4623      	mov	r3, r4
   10374:	4908      	ldr	r1, [pc, #32]	; (10398 <UI_SPI_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA20, PINMUX_PA20D_SERCOM3_PAD2);
}
   10376:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1037a:	2014      	movs	r0, #20
   1037c:	4718      	bx	r3
   1037e:	bf00      	nop
   10380:	41008000 	.word	0x41008000
   10384:	0000fe99 	.word	0x0000fe99
   10388:	0000fe2d 	.word	0x0000fe2d
   1038c:	00340002 	.word	0x00340002
   10390:	00350002 	.word	0x00350002
   10394:	0000fee9 	.word	0x0000fee9
   10398:	00140003 	.word	0x00140003

0001039c <UI_SPI_CLOCK_init>:
   1039c:	4b06      	ldr	r3, [pc, #24]	; (103b8 <UI_SPI_CLOCK_init+0x1c>)
   1039e:	2241      	movs	r2, #65	; 0x41
   103a0:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   103a4:	2243      	movs	r2, #67	; 0x43
   103a6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
   103aa:	4a04      	ldr	r2, [pc, #16]	; (103bc <UI_SPI_CLOCK_init+0x20>)
   103ac:	6993      	ldr	r3, [r2, #24]
   103ae:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   103b2:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}
   103b4:	4770      	bx	lr
   103b6:	bf00      	nop
   103b8:	40001c00 	.word	0x40001c00
   103bc:	40000800 	.word	0x40000800

000103c0 <UI_SPI_init>:

void UI_SPI_init(void)
{
   103c0:	b510      	push	{r4, lr}
	UI_SPI_CLOCK_init();
   103c2:	4b05      	ldr	r3, [pc, #20]	; (103d8 <UI_SPI_init+0x18>)
   103c4:	4798      	blx	r3
	spi_m_async_init(&UI_SPI, SERCOM3);
   103c6:	4b05      	ldr	r3, [pc, #20]	; (103dc <UI_SPI_init+0x1c>)
   103c8:	4905      	ldr	r1, [pc, #20]	; (103e0 <UI_SPI_init+0x20>)
   103ca:	4806      	ldr	r0, [pc, #24]	; (103e4 <UI_SPI_init+0x24>)
   103cc:	4798      	blx	r3
	UI_SPI_PORT_init();
}
   103ce:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UI_SPI_PORT_init();
   103d2:	4b05      	ldr	r3, [pc, #20]	; (103e8 <UI_SPI_init+0x28>)
   103d4:	4718      	bx	r3
   103d6:	bf00      	nop
   103d8:	0001039d 	.word	0x0001039d
   103dc:	0000f48d 	.word	0x0000f48d
   103e0:	41014000 	.word	0x41014000
   103e4:	2001cc70 	.word	0x2001cc70
   103e8:	00010335 	.word	0x00010335

000103ec <USART_WEST_CLOCK_init>:
   103ec:	4b06      	ldr	r3, [pc, #24]	; (10408 <USART_WEST_CLOCK_init+0x1c>)
   103ee:	2241      	movs	r2, #65	; 0x41
   103f0:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   103f4:	2242      	movs	r2, #66	; 0x42
   103f6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM4;
   103fa:	4a04      	ldr	r2, [pc, #16]	; (1040c <USART_WEST_CLOCK_init+0x20>)
   103fc:	6a13      	ldr	r3, [r2, #32]
   103fe:	f043 0301 	orr.w	r3, r3, #1
   10402:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM4_bit(MCLK);
}
   10404:	4770      	bx	lr
   10406:	bf00      	nop
   10408:	40001c00 	.word	0x40001c00
   1040c:	40000800 	.word	0x40000800

00010410 <USART_WEST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_WEST_PORT_init()
{
   10410:	b510      	push	{r4, lr}
   10412:	4c05      	ldr	r4, [pc, #20]	; (10428 <USART_WEST_PORT_init+0x18>)
   10414:	4905      	ldr	r1, [pc, #20]	; (1042c <USART_WEST_PORT_init+0x1c>)
   10416:	2028      	movs	r0, #40	; 0x28
   10418:	47a0      	blx	r4
   1041a:	4623      	mov	r3, r4
   1041c:	4904      	ldr	r1, [pc, #16]	; (10430 <USART_WEST_PORT_init+0x20>)

	gpio_set_pin_function(PB08, PINMUX_PB08D_SERCOM4_PAD0);

	gpio_set_pin_function(PB09, PINMUX_PB09D_SERCOM4_PAD1);
}
   1041e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10422:	2029      	movs	r0, #41	; 0x29
   10424:	4718      	bx	r3
   10426:	bf00      	nop
   10428:	0000fe2d 	.word	0x0000fe2d
   1042c:	00280003 	.word	0x00280003
   10430:	00290003 	.word	0x00290003

00010434 <USART_WEST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_WEST_init(void)
{
   10434:	b513      	push	{r0, r1, r4, lr}
	USART_WEST_CLOCK_init();
   10436:	4b08      	ldr	r3, [pc, #32]	; (10458 <USART_WEST_init+0x24>)
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   10438:	4c08      	ldr	r4, [pc, #32]	; (1045c <USART_WEST_init+0x28>)
	USART_WEST_CLOCK_init();
   1043a:	4798      	blx	r3
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   1043c:	2300      	movs	r3, #0
   1043e:	9300      	str	r3, [sp, #0]
   10440:	4a07      	ldr	r2, [pc, #28]	; (10460 <USART_WEST_init+0x2c>)
   10442:	4808      	ldr	r0, [pc, #32]	; (10464 <USART_WEST_init+0x30>)
   10444:	2310      	movs	r3, #16
   10446:	f04f 4186 	mov.w	r1, #1124073472	; 0x43000000
   1044a:	47a0      	blx	r4
	USART_WEST_PORT_init();
   1044c:	4b06      	ldr	r3, [pc, #24]	; (10468 <USART_WEST_init+0x34>)
}
   1044e:	b002      	add	sp, #8
   10450:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_WEST_PORT_init();
   10454:	4718      	bx	r3
   10456:	bf00      	nop
   10458:	000103ed 	.word	0x000103ed
   1045c:	00010b1d 	.word	0x00010b1d
   10460:	20008d46 	.word	0x20008d46
   10464:	2001ceb8 	.word	0x2001ceb8
   10468:	00010411 	.word	0x00010411

0001046c <SYS_I2C_PORT_init>:

void SYS_I2C_PORT_init(void)
{
   1046c:	b570      	push	{r4, r5, r6, lr}

	gpio_set_pin_pull_mode(PA23,
   1046e:	2100      	movs	r1, #0
   10470:	4d07      	ldr	r5, [pc, #28]	; (10490 <SYS_I2C_PORT_init+0x24>)
   10472:	4c08      	ldr	r4, [pc, #32]	; (10494 <SYS_I2C_PORT_init+0x28>)
   10474:	2017      	movs	r0, #23
   10476:	47a8      	blx	r5
   10478:	4907      	ldr	r1, [pc, #28]	; (10498 <SYS_I2C_PORT_init+0x2c>)
   1047a:	2017      	movs	r0, #23
   1047c:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA23, PINMUX_PA23D_SERCOM5_PAD0);

	gpio_set_pin_pull_mode(PA22,
   1047e:	2100      	movs	r1, #0
   10480:	2016      	movs	r0, #22
   10482:	47a8      	blx	r5
   10484:	4623      	mov	r3, r4
   10486:	4905      	ldr	r1, [pc, #20]	; (1049c <SYS_I2C_PORT_init+0x30>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA22, PINMUX_PA22D_SERCOM5_PAD1);
}
   10488:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   1048c:	2016      	movs	r0, #22
   1048e:	4718      	bx	r3
   10490:	0000fee9 	.word	0x0000fee9
   10494:	0000fe2d 	.word	0x0000fe2d
   10498:	00170003 	.word	0x00170003
   1049c:	00160003 	.word	0x00160003

000104a0 <SYS_I2C_CLOCK_init>:
   104a0:	4b06      	ldr	r3, [pc, #24]	; (104bc <SYS_I2C_CLOCK_init+0x1c>)
   104a2:	2241      	movs	r2, #65	; 0x41
   104a4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
   104a8:	2242      	movs	r2, #66	; 0x42
   104aa:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM5;
   104ae:	4a04      	ldr	r2, [pc, #16]	; (104c0 <SYS_I2C_CLOCK_init+0x20>)
   104b0:	6a13      	ldr	r3, [r2, #32]
   104b2:	f043 0302 	orr.w	r3, r3, #2
   104b6:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_SLOW, CONF_GCLK_SERCOM5_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM5_bit(MCLK);
}
   104b8:	4770      	bx	lr
   104ba:	bf00      	nop
   104bc:	40001c00 	.word	0x40001c00
   104c0:	40000800 	.word	0x40000800

000104c4 <SYS_I2C_init>:

void SYS_I2C_init(void)
{
   104c4:	b510      	push	{r4, lr}
	SYS_I2C_CLOCK_init();
   104c6:	4b05      	ldr	r3, [pc, #20]	; (104dc <SYS_I2C_init+0x18>)
   104c8:	4798      	blx	r3
	i2c_m_async_init(&SYS_I2C, SERCOM5);
   104ca:	4b05      	ldr	r3, [pc, #20]	; (104e0 <SYS_I2C_init+0x1c>)
   104cc:	4905      	ldr	r1, [pc, #20]	; (104e4 <SYS_I2C_init+0x20>)
   104ce:	4806      	ldr	r0, [pc, #24]	; (104e8 <SYS_I2C_init+0x24>)
   104d0:	4798      	blx	r3
	SYS_I2C_PORT_init();
}
   104d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SYS_I2C_PORT_init();
   104d6:	4b05      	ldr	r3, [pc, #20]	; (104ec <SYS_I2C_init+0x28>)
   104d8:	4718      	bx	r3
   104da:	bf00      	nop
   104dc:	000104a1 	.word	0x000104a1
   104e0:	0000b955 	.word	0x0000b955
   104e4:	43000400 	.word	0x43000400
   104e8:	2001cd30 	.word	0x2001cd30
   104ec:	0001046d 	.word	0x0001046d

000104f0 <USART_SOUTH_CLOCK_init>:
   104f0:	4b06      	ldr	r3, [pc, #24]	; (1050c <USART_SOUTH_CLOCK_init+0x1c>)
   104f2:	2241      	movs	r2, #65	; 0x41
   104f4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   104f8:	2242      	movs	r2, #66	; 0x42
   104fa:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM6;
   104fe:	4a04      	ldr	r2, [pc, #16]	; (10510 <USART_SOUTH_CLOCK_init+0x20>)
   10500:	6a13      	ldr	r3, [r2, #32]
   10502:	f043 0304 	orr.w	r3, r3, #4
   10506:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_CORE, CONF_GCLK_SERCOM6_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_SLOW, CONF_GCLK_SERCOM6_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM6_bit(MCLK);
}
   10508:	4770      	bx	lr
   1050a:	bf00      	nop
   1050c:	40001c00 	.word	0x40001c00
   10510:	40000800 	.word	0x40000800

00010514 <USART_SOUTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_SOUTH_PORT_init()
{
   10514:	b510      	push	{r4, lr}
   10516:	4c05      	ldr	r4, [pc, #20]	; (1052c <USART_SOUTH_PORT_init+0x18>)
   10518:	4905      	ldr	r1, [pc, #20]	; (10530 <USART_SOUTH_PORT_init+0x1c>)
   1051a:	204d      	movs	r0, #77	; 0x4d
   1051c:	47a0      	blx	r4
   1051e:	4623      	mov	r3, r4
   10520:	4904      	ldr	r1, [pc, #16]	; (10534 <USART_SOUTH_PORT_init+0x20>)

	gpio_set_pin_function(PC13, PINMUX_PC13D_SERCOM6_PAD0);

	gpio_set_pin_function(PC12, PINMUX_PC12D_SERCOM6_PAD1);
}
   10522:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10526:	204c      	movs	r0, #76	; 0x4c
   10528:	4718      	bx	r3
   1052a:	bf00      	nop
   1052c:	0000fe2d 	.word	0x0000fe2d
   10530:	004d0003 	.word	0x004d0003
   10534:	004c0003 	.word	0x004c0003

00010538 <USART_SOUTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_SOUTH_init(void)
{
   10538:	b513      	push	{r0, r1, r4, lr}
	USART_SOUTH_CLOCK_init();
   1053a:	4b07      	ldr	r3, [pc, #28]	; (10558 <USART_SOUTH_init+0x20>)
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   1053c:	4c07      	ldr	r4, [pc, #28]	; (1055c <USART_SOUTH_init+0x24>)
	USART_SOUTH_CLOCK_init();
   1053e:	4798      	blx	r3
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   10540:	2300      	movs	r3, #0
   10542:	9300      	str	r3, [sp, #0]
   10544:	4a06      	ldr	r2, [pc, #24]	; (10560 <USART_SOUTH_init+0x28>)
   10546:	4907      	ldr	r1, [pc, #28]	; (10564 <USART_SOUTH_init+0x2c>)
   10548:	4807      	ldr	r0, [pc, #28]	; (10568 <USART_SOUTH_init+0x30>)
   1054a:	2310      	movs	r3, #16
   1054c:	47a0      	blx	r4
	USART_SOUTH_PORT_init();
   1054e:	4b07      	ldr	r3, [pc, #28]	; (1056c <USART_SOUTH_init+0x34>)
}
   10550:	b002      	add	sp, #8
   10552:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_SOUTH_PORT_init();
   10556:	4718      	bx	r3
   10558:	000104f1 	.word	0x000104f1
   1055c:	00010b1d 	.word	0x00010b1d
   10560:	20008d56 	.word	0x20008d56
   10564:	43000800 	.word	0x43000800
   10568:	2001cf08 	.word	0x2001cf08
   1056c:	00010515 	.word	0x00010515

00010570 <GRID_LED_PORT_init>:

void GRID_LED_PORT_init(void)
{
   10570:	b570      	push	{r4, r5, r6, lr}
   10572:	4e12      	ldr	r6, [pc, #72]	; (105bc <GRID_LED_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB30, GPIO_DIRECTION_OUT);
   10574:	4d12      	ldr	r5, [pc, #72]	; (105c0 <GRID_LED_PORT_init+0x50>)
   10576:	4c13      	ldr	r4, [pc, #76]	; (105c4 <GRID_LED_PORT_init+0x54>)
   10578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   1057c:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   10580:	2102      	movs	r1, #2
   10582:	203e      	movs	r0, #62	; 0x3e
   10584:	47a8      	blx	r5
   10586:	4910      	ldr	r1, [pc, #64]	; (105c8 <GRID_LED_PORT_init+0x58>)
   10588:	203e      	movs	r0, #62	; 0x3e
   1058a:	47a0      	blx	r4
   1058c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   10590:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB31, GPIO_DIRECTION_OUT);
   10594:	2102      	movs	r1, #2
   10596:	203f      	movs	r0, #63	; 0x3f
   10598:	47a8      	blx	r5
   1059a:	490c      	ldr	r1, [pc, #48]	; (105cc <GRID_LED_PORT_init+0x5c>)
   1059c:	203f      	movs	r0, #63	; 0x3f
   1059e:	47a0      	blx	r4

	gpio_set_pin_function(PB31, PINMUX_PB31C_SERCOM7_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA30, GPIO_DIRECTION_IN);
   105a0:	2101      	movs	r1, #1
   105a2:	201e      	movs	r0, #30
   105a4:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA30,
   105a6:	4b0a      	ldr	r3, [pc, #40]	; (105d0 <GRID_LED_PORT_init+0x60>)
   105a8:	2100      	movs	r1, #0
   105aa:	201e      	movs	r0, #30
   105ac:	4798      	blx	r3
   105ae:	4623      	mov	r3, r4
   105b0:	4908      	ldr	r1, [pc, #32]	; (105d4 <GRID_LED_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA30, PINMUX_PA30C_SERCOM7_PAD2);
}
   105b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   105b6:	201e      	movs	r0, #30
   105b8:	4718      	bx	r3
   105ba:	bf00      	nop
   105bc:	41008000 	.word	0x41008000
   105c0:	0000fe99 	.word	0x0000fe99
   105c4:	0000fe2d 	.word	0x0000fe2d
   105c8:	003e0002 	.word	0x003e0002
   105cc:	003f0002 	.word	0x003f0002
   105d0:	0000fee9 	.word	0x0000fee9
   105d4:	001e0002 	.word	0x001e0002

000105d8 <GRID_LED_CLOCK_init>:
   105d8:	4b06      	ldr	r3, [pc, #24]	; (105f4 <GRID_LED_CLOCK_init+0x1c>)
   105da:	2241      	movs	r2, #65	; 0x41
   105dc:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   105e0:	2242      	movs	r2, #66	; 0x42
   105e2:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
   105e6:	4a04      	ldr	r2, [pc, #16]	; (105f8 <GRID_LED_CLOCK_init+0x20>)
   105e8:	6a13      	ldr	r3, [r2, #32]
   105ea:	f043 0308 	orr.w	r3, r3, #8
   105ee:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}
   105f0:	4770      	bx	lr
   105f2:	bf00      	nop
   105f4:	40001c00 	.word	0x40001c00
   105f8:	40000800 	.word	0x40000800

000105fc <GRID_LED_init>:

void GRID_LED_init(void)
{
   105fc:	b510      	push	{r4, lr}
	GRID_LED_CLOCK_init();
   105fe:	4b05      	ldr	r3, [pc, #20]	; (10614 <GRID_LED_init+0x18>)
   10600:	4798      	blx	r3
	spi_m_dma_init(&GRID_LED, SERCOM7);
   10602:	4b05      	ldr	r3, [pc, #20]	; (10618 <GRID_LED_init+0x1c>)
   10604:	4905      	ldr	r1, [pc, #20]	; (1061c <GRID_LED_init+0x20>)
   10606:	4806      	ldr	r0, [pc, #24]	; (10620 <GRID_LED_init+0x24>)
   10608:	4798      	blx	r3
	GRID_LED_PORT_init();
}
   1060a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_LED_PORT_init();
   1060e:	4b05      	ldr	r3, [pc, #20]	; (10624 <GRID_LED_init+0x28>)
   10610:	4718      	bx	r3
   10612:	bf00      	nop
   10614:	000105d9 	.word	0x000105d9
   10618:	0000bd51 	.word	0x0000bd51
   1061c:	43000c00 	.word	0x43000c00
   10620:	2001ce54 	.word	0x2001ce54
   10624:	00010571 	.word	0x00010571

00010628 <delay_driver_init>:

void delay_driver_init(void)
{
	delay_init(SysTick);
   10628:	4801      	ldr	r0, [pc, #4]	; (10630 <delay_driver_init+0x8>)
   1062a:	4b02      	ldr	r3, [pc, #8]	; (10634 <delay_driver_init+0xc>)
   1062c:	4718      	bx	r3
   1062e:	bf00      	nop
   10630:	e000e010 	.word	0xe000e010
   10634:	0000e16d 	.word	0x0000e16d

00010638 <RAND_0_CLOCK_init>:
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TRNG;
   10638:	4a02      	ldr	r2, [pc, #8]	; (10644 <RAND_0_CLOCK_init+0xc>)
   1063a:	69d3      	ldr	r3, [r2, #28]
   1063c:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   10640:	61d3      	str	r3, [r2, #28]
}

void RAND_0_CLOCK_init(void)
{
	hri_mclk_set_APBCMASK_TRNG_bit(MCLK);
}
   10642:	4770      	bx	lr
   10644:	40000800 	.word	0x40000800

00010648 <RAND_0_init>:

void RAND_0_init(void)
{
   10648:	b510      	push	{r4, lr}
	RAND_0_CLOCK_init();
   1064a:	4b04      	ldr	r3, [pc, #16]	; (1065c <RAND_0_init+0x14>)
   1064c:	4798      	blx	r3
	rand_sync_init(&RAND_0, TRNG);
}
   1064e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rand_sync_init(&RAND_0, TRNG);
   10652:	4903      	ldr	r1, [pc, #12]	; (10660 <RAND_0_init+0x18>)
   10654:	4803      	ldr	r0, [pc, #12]	; (10664 <RAND_0_init+0x1c>)
   10656:	4b04      	ldr	r3, [pc, #16]	; (10668 <RAND_0_init+0x20>)
   10658:	4718      	bx	r3
   1065a:	bf00      	nop
   1065c:	00010639 	.word	0x00010639
   10660:	42002800 	.word	0x42002800
   10664:	2001cd7c 	.word	0x2001cd7c
   10668:	0000eb51 	.word	0x0000eb51

0001066c <USB_DEVICE_INSTANCE_PORT_init>:

void USB_DEVICE_INSTANCE_PORT_init(void)
{
   1066c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	gpio_set_pin_direction(PA24,
   10670:	2102      	movs	r1, #2
   10672:	4f0f      	ldr	r7, [pc, #60]	; (106b0 <USB_DEVICE_INSTANCE_PORT_init+0x44>)
   10674:	4e0f      	ldr	r6, [pc, #60]	; (106b4 <USB_DEVICE_INSTANCE_PORT_init+0x48>)
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA24,
   10676:	4d10      	ldr	r5, [pc, #64]	; (106b8 <USB_DEVICE_INSTANCE_PORT_init+0x4c>)
   10678:	4c10      	ldr	r4, [pc, #64]	; (106bc <USB_DEVICE_INSTANCE_PORT_init+0x50>)
	gpio_set_pin_direction(PA24,
   1067a:	2018      	movs	r0, #24
   1067c:	47b8      	blx	r7
   1067e:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   10682:	6173      	str	r3, [r6, #20]
	gpio_set_pin_pull_mode(PA24,
   10684:	2100      	movs	r1, #0
   10686:	2018      	movs	r0, #24
   10688:	47a8      	blx	r5
   1068a:	490d      	ldr	r1, [pc, #52]	; (106c0 <USB_DEVICE_INSTANCE_PORT_init+0x54>)
   1068c:	2018      	movs	r0, #24
   1068e:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA24H_USB_DM);

	gpio_set_pin_direction(PA25,
   10690:	2102      	movs	r1, #2
   10692:	2019      	movs	r0, #25
   10694:	47b8      	blx	r7
   10696:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   1069a:	6173      	str	r3, [r6, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA25,
   1069c:	2100      	movs	r1, #0
   1069e:	2019      	movs	r0, #25
   106a0:	47a8      	blx	r5
   106a2:	4623      	mov	r3, r4
   106a4:	4907      	ldr	r1, [pc, #28]	; (106c4 <USB_DEVICE_INSTANCE_PORT_init+0x58>)
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA25H_USB_DP);
}
   106a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   106aa:	2019      	movs	r0, #25
   106ac:	4718      	bx	r3
   106ae:	bf00      	nop
   106b0:	0000fe99 	.word	0x0000fe99
   106b4:	41008000 	.word	0x41008000
   106b8:	0000fee9 	.word	0x0000fee9
   106bc:	0000fe2d 	.word	0x0000fe2d
   106c0:	00180007 	.word	0x00180007
   106c4:	00190007 	.word	0x00190007

000106c8 <USB_DEVICE_INSTANCE_CLOCK_init>:
   106c8:	4b07      	ldr	r3, [pc, #28]	; (106e8 <USB_DEVICE_INSTANCE_CLOCK_init+0x20>)
   106ca:	2241      	movs	r2, #65	; 0x41
   106cc:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
   106d0:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
   106d4:	691a      	ldr	r2, [r3, #16]
   106d6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   106da:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
   106dc:	699a      	ldr	r2, [r3, #24]
   106de:	f042 0201 	orr.w	r2, r2, #1
   106e2:	619a      	str	r2, [r3, #24]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, USB_GCLK_ID, CONF_GCLK_USB_SRC | GCLK_PCHCTRL_CHEN);
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}
   106e4:	4770      	bx	lr
   106e6:	bf00      	nop
   106e8:	40001c00 	.word	0x40001c00

000106ec <USB_DEVICE_INSTANCE_init>:

void USB_DEVICE_INSTANCE_init(void)
{
   106ec:	b510      	push	{r4, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
   106ee:	4b04      	ldr	r3, [pc, #16]	; (10700 <USB_DEVICE_INSTANCE_init+0x14>)
   106f0:	4798      	blx	r3
	usb_d_init();
   106f2:	4b04      	ldr	r3, [pc, #16]	; (10704 <USB_DEVICE_INSTANCE_init+0x18>)
   106f4:	4798      	blx	r3
	USB_DEVICE_INSTANCE_PORT_init();
}
   106f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_DEVICE_INSTANCE_PORT_init();
   106fa:	4b03      	ldr	r3, [pc, #12]	; (10708 <USB_DEVICE_INSTANCE_init+0x1c>)
   106fc:	4718      	bx	r3
   106fe:	bf00      	nop
   10700:	000106c9 	.word	0x000106c9
   10704:	0000f881 	.word	0x0000f881
   10708:	0001066d 	.word	0x0001066d

0001070c <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
   1070c:	4a02      	ldr	r2, [pc, #8]	; (10718 <WDT_0_CLOCK_init+0xc>)
   1070e:	6953      	ldr	r3, [r2, #20]
   10710:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10714:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
   10716:	4770      	bx	lr
   10718:	40000800 	.word	0x40000800

0001071c <WDT_0_init>:

void WDT_0_init(void)
{
   1071c:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
   1071e:	4b07      	ldr	r3, [pc, #28]	; (1073c <WDT_0_init+0x20>)
   10720:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
   10722:	4b07      	ldr	r3, [pc, #28]	; (10740 <WDT_0_init+0x24>)
   10724:	4907      	ldr	r1, [pc, #28]	; (10744 <WDT_0_init+0x28>)
   10726:	2001      	movs	r0, #1
   10728:	2248      	movs	r2, #72	; 0x48
   1072a:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
   1072c:	4806      	ldr	r0, [pc, #24]	; (10748 <WDT_0_init+0x2c>)
   1072e:	4b07      	ldr	r3, [pc, #28]	; (1074c <WDT_0_init+0x30>)
   10730:	6003      	str	r3, [r0, #0]
	wdt_init(&WDT_0, WDT);
}
   10732:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	return _wdt_init(&wdt->dev);
   10736:	4b06      	ldr	r3, [pc, #24]	; (10750 <WDT_0_init+0x34>)
   10738:	4718      	bx	r3
   1073a:	bf00      	nop
   1073c:	0001070d 	.word	0x0001070d
   10740:	0000e42d 	.word	0x0000e42d
   10744:	00016ac7 	.word	0x00016ac7
   10748:	2001ce00 	.word	0x2001ce00
   1074c:	40002000 	.word	0x40002000
   10750:	0000bb7d 	.word	0x0000bb7d

00010754 <system_init>:

void system_init(void)
{
   10754:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
   10758:	4b7c      	ldr	r3, [pc, #496]	; (1094c <system_init+0x1f8>)
   1075a:	4c7d      	ldr	r4, [pc, #500]	; (10950 <system_init+0x1fc>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   1075c:	4d7d      	ldr	r5, [pc, #500]	; (10954 <system_init+0x200>)
	// GPIO on PA21

	// Set pin direction to input
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);

	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   1075e:	4e7e      	ldr	r6, [pc, #504]	; (10958 <system_init+0x204>)
   10760:	4798      	blx	r3
   10762:	2320      	movs	r3, #32
   10764:	6163      	str	r3, [r4, #20]
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   10766:	2102      	movs	r1, #2
   10768:	2005      	movs	r0, #5
   1076a:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1076c:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
   10770:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10774:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);
   10778:	2101      	movs	r1, #1
   1077a:	2015      	movs	r0, #21
   1077c:	47a8      	blx	r5
	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   1077e:	2100      	movs	r1, #0
   10780:	2015      	movs	r0, #21
   10782:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10784:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
   10788:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1078c:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
	gpio_set_pin_function(PIN_UI_SPI_CS0, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB07

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_2, GPIO_DIRECTION_IN);
   10790:	2101      	movs	r1, #1
   10792:	2027      	movs	r0, #39	; 0x27
   10794:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_2,
   10796:	2100      	movs	r1, #0
   10798:	2027      	movs	r0, #39	; 0x27
   1079a:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1079c:	f894 30c7 	ldrb.w	r3, [r4, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
   107a0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   107a4:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   107a8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   107ac:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_SHIFT, GPIO_DIRECTION_OUT);
   107b0:	2102      	movs	r1, #2
   107b2:	202d      	movs	r0, #45	; 0x2d
   107b4:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   107b6:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   107ba:	f44f 4780 	mov.w	r7, #16384	; 0x4000
	tmp &= ~PORT_PINCFG_PMUXEN;
   107be:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   107c2:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
   107c6:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   107c8:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
   107cc:	202e      	movs	r0, #46	; 0x2e
   107ce:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   107d0:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
   107d4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   107d8:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	gpio_set_pin_function(HWCFG_CLOCK, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB15

	// Set pin direction to input
	gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
   107dc:	2101      	movs	r1, #1
   107de:	202f      	movs	r0, #47	; 0x2f
   107e0:	47a8      	blx	r5

	gpio_set_pin_pull_mode(HWCFG_DATA,
   107e2:	2100      	movs	r1, #0
   107e4:	202f      	movs	r0, #47	; 0x2f
   107e6:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   107e8:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
   107ec:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   107f0:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
	gpio_set_pin_function(HWCFG_DATA, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC11

	// Set pin direction to input
	gpio_set_pin_direction(MAP_MODE, GPIO_DIRECTION_IN);
   107f4:	2101      	movs	r1, #1
   107f6:	204b      	movs	r0, #75	; 0x4b
   107f8:	47a8      	blx	r5

	gpio_set_pin_pull_mode(MAP_MODE,
   107fa:	2101      	movs	r1, #1
   107fc:	204b      	movs	r0, #75	; 0x4b
   107fe:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10800:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
   10804:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10808:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(UI_PWR_EN, GPIO_DIRECTION_OUT);
   1080c:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1080e:	f8c4 7114 	str.w	r7, [r4, #276]	; 0x114
   10812:	204e      	movs	r0, #78	; 0x4e
   10814:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10816:	f894 314e 	ldrb.w	r3, [r4, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
   1081a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1081e:	f884 314e 	strb.w	r3, [r4, #334]	; 0x14e
	gpio_set_pin_function(UI_PWR_EN, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC18

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_1, GPIO_DIRECTION_IN);
   10822:	2101      	movs	r1, #1
   10824:	2052      	movs	r0, #82	; 0x52
   10826:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_1,
   10828:	2100      	movs	r1, #0
   1082a:	2052      	movs	r0, #82	; 0x52
   1082c:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1082e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   10832:	4e4a      	ldr	r6, [pc, #296]	; (1095c <system_init+0x208>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10834:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10838:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1083c:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   10840:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_A, GPIO_DIRECTION_OUT);
   10844:	2102      	movs	r1, #2
   10846:	2053      	movs	r0, #83	; 0x53
   10848:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1084a:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
   1084e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10852:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10856:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   1085a:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_B, GPIO_DIRECTION_OUT);
   1085e:	2102      	movs	r1, #2
   10860:	2054      	movs	r0, #84	; 0x54
   10862:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10864:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
   10868:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   1086c:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10870:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_C, GPIO_DIRECTION_OUT);
   10874:	2102      	movs	r1, #2
   10876:	2055      	movs	r0, #85	; 0x55
   10878:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
   1087c:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   1087e:	f894 3155 	ldrb.w	r3, [r4, #341]	; 0x155
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   10882:	4d37      	ldr	r5, [pc, #220]	; (10960 <system_init+0x20c>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10884:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10888:	f884 3155 	strb.w	r3, [r4, #341]	; 0x155

	gpio_set_pin_function(MUX_C, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
   1088c:	4b35      	ldr	r3, [pc, #212]	; (10964 <system_init+0x210>)
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_RTC;
   1088e:	4c36      	ldr	r4, [pc, #216]	; (10968 <system_init+0x214>)
   10890:	4798      	blx	r3
	ADC_1_init();
   10892:	4b36      	ldr	r3, [pc, #216]	; (1096c <system_init+0x218>)
   10894:	4798      	blx	r3

	CRC_0_init();
   10896:	4b36      	ldr	r3, [pc, #216]	; (10970 <system_init+0x21c>)
   10898:	4798      	blx	r3

	EVENT_SYSTEM_0_init();
   1089a:	4b36      	ldr	r3, [pc, #216]	; (10974 <system_init+0x220>)
   1089c:	4798      	blx	r3

	FLASH_0_init();
   1089e:	4b36      	ldr	r3, [pc, #216]	; (10978 <system_init+0x224>)
   108a0:	4798      	blx	r3

	QSPI_INSTANCE_init();
   108a2:	4b36      	ldr	r3, [pc, #216]	; (1097c <system_init+0x228>)
   108a4:	4798      	blx	r3
   108a6:	6963      	ldr	r3, [r4, #20]
   108a8:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   108ac:	6163      	str	r3, [r4, #20]
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   108ae:	4b34      	ldr	r3, [pc, #208]	; (10980 <system_init+0x22c>)
   108b0:	4798      	blx	r3
   108b2:	4934      	ldr	r1, [pc, #208]	; (10984 <system_init+0x230>)
   108b4:	4602      	mov	r2, r0
   108b6:	4834      	ldr	r0, [pc, #208]	; (10988 <system_init+0x234>)
   108b8:	47a8      	blx	r5

	RTC_Scheduler_init();
	USART_EAST_init();
   108ba:	4b34      	ldr	r3, [pc, #208]	; (1098c <system_init+0x238>)
   108bc:	4798      	blx	r3
	USART_NORTH_init();
   108be:	4b34      	ldr	r3, [pc, #208]	; (10990 <system_init+0x23c>)
   108c0:	4798      	blx	r3

	GRID_AUX_init();
   108c2:	4b34      	ldr	r3, [pc, #208]	; (10994 <system_init+0x240>)
   108c4:	4798      	blx	r3

	UI_SPI_init();
   108c6:	4b34      	ldr	r3, [pc, #208]	; (10998 <system_init+0x244>)
   108c8:	4798      	blx	r3
	USART_WEST_init();
   108ca:	4b34      	ldr	r3, [pc, #208]	; (1099c <system_init+0x248>)
   108cc:	4798      	blx	r3

	SYS_I2C_init();
   108ce:	4b34      	ldr	r3, [pc, #208]	; (109a0 <system_init+0x24c>)
   108d0:	4798      	blx	r3
	USART_SOUTH_init();
   108d2:	4b34      	ldr	r3, [pc, #208]	; (109a4 <system_init+0x250>)
   108d4:	4798      	blx	r3

	GRID_LED_init();
   108d6:	4b34      	ldr	r3, [pc, #208]	; (109a8 <system_init+0x254>)
   108d8:	4798      	blx	r3

	delay_driver_init();
   108da:	4b34      	ldr	r3, [pc, #208]	; (109ac <system_init+0x258>)
   108dc:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
   108de:	6963      	ldr	r3, [r4, #20]
   108e0:	433b      	orrs	r3, r7
   108e2:	4f33      	ldr	r7, [pc, #204]	; (109b0 <system_init+0x25c>)
   108e4:	6163      	str	r3, [r4, #20]
   108e6:	f04f 0840 	mov.w	r8, #64	; 0x40
   108ea:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   108ee:	47b0      	blx	r6
   108f0:	4930      	ldr	r1, [pc, #192]	; (109b4 <system_init+0x260>)
   108f2:	4602      	mov	r2, r0
   108f4:	4830      	ldr	r0, [pc, #192]	; (109b8 <system_init+0x264>)
   108f6:	47a8      	blx	r5
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
   108f8:	6963      	ldr	r3, [r4, #20]
   108fa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   108fe:	6163      	str	r3, [r4, #20]
   10900:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_1, TC1, _tc_get_timer());
   10904:	47b0      	blx	r6
   10906:	492d      	ldr	r1, [pc, #180]	; (109bc <system_init+0x268>)
   10908:	4602      	mov	r2, r0
   1090a:	482d      	ldr	r0, [pc, #180]	; (109c0 <system_init+0x26c>)
   1090c:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC2;
   1090e:	69a3      	ldr	r3, [r4, #24]
   10910:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10914:	61a3      	str	r3, [r4, #24]
   10916:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_2, TC2, _tc_get_timer());
   1091a:	47b0      	blx	r6
   1091c:	4929      	ldr	r1, [pc, #164]	; (109c4 <system_init+0x270>)
   1091e:	4602      	mov	r2, r0
   10920:	4829      	ldr	r0, [pc, #164]	; (109c8 <system_init+0x274>)
   10922:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC3;
   10924:	69a3      	ldr	r3, [r4, #24]
   10926:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   1092a:	61a3      	str	r3, [r4, #24]
   1092c:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_3, TC3, _tc_get_timer());
   10930:	47b0      	blx	r6
   10932:	4926      	ldr	r1, [pc, #152]	; (109cc <system_init+0x278>)
   10934:	4602      	mov	r2, r0
   10936:	4826      	ldr	r0, [pc, #152]	; (109d0 <system_init+0x27c>)
   10938:	47a8      	blx	r5

	TIMER_0_init();
	TIMER_1_init();
	TIMER_2_init();
	TIMER_3_init();
	RAND_0_init();
   1093a:	4b26      	ldr	r3, [pc, #152]	; (109d4 <system_init+0x280>)
   1093c:	4798      	blx	r3

	USB_DEVICE_INSTANCE_init();
   1093e:	4b26      	ldr	r3, [pc, #152]	; (109d8 <system_init+0x284>)
   10940:	4798      	blx	r3

	WDT_0_init();
}
   10942:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WDT_0_init();
   10946:	4b25      	ldr	r3, [pc, #148]	; (109dc <system_init+0x288>)
   10948:	4718      	bx	r3
   1094a:	bf00      	nop
   1094c:	0000e1a1 	.word	0x0000e1a1
   10950:	41008000 	.word	0x41008000
   10954:	0000fe99 	.word	0x0000fe99
   10958:	0000fee9 	.word	0x0000fee9
   1095c:	00013ed9 	.word	0x00013ed9
   10960:	0000cdc5 	.word	0x0000cdc5
   10964:	0000ff29 	.word	0x0000ff29
   10968:	40000800 	.word	0x40000800
   1096c:	0000ffa9 	.word	0x0000ffa9
   10970:	0001002d 	.word	0x0001002d
   10974:	00010051 	.word	0x00010051
   10978:	00010091 	.word	0x00010091
   1097c:	00010195 	.word	0x00010195
   10980:	0000fe01 	.word	0x0000fe01
   10984:	40002400 	.word	0x40002400
   10988:	2001ccb8 	.word	0x2001ccb8
   1098c:	00010209 	.word	0x00010209
   10990:	00010289 	.word	0x00010289
   10994:	00010309 	.word	0x00010309
   10998:	000103c1 	.word	0x000103c1
   1099c:	00010435 	.word	0x00010435
   109a0:	000104c5 	.word	0x000104c5
   109a4:	00010539 	.word	0x00010539
   109a8:	000105fd 	.word	0x000105fd
   109ac:	00010629 	.word	0x00010629
   109b0:	40001c00 	.word	0x40001c00
   109b4:	40003800 	.word	0x40003800
   109b8:	2001cfa4 	.word	0x2001cfa4
   109bc:	40003c00 	.word	0x40003c00
   109c0:	2001ce98 	.word	0x2001ce98
   109c4:	4101a000 	.word	0x4101a000
   109c8:	2001ccd8 	.word	0x2001ccd8
   109cc:	4101c000 	.word	0x4101c000
   109d0:	2001cf84 	.word	0x2001cf84
   109d4:	00010649 	.word	0x00010649
   109d8:	000106ed 	.word	0x000106ed
   109dc:	0001071d 	.word	0x0001071d

000109e0 <usart_transmission_complete>:
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   109e0:	2300      	movs	r3, #0
   109e2:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
   109e4:	69c3      	ldr	r3, [r0, #28]
   109e6:	b10b      	cbz	r3, 109ec <usart_transmission_complete+0xc>
		descr->usart_cb.tx_done(descr);
   109e8:	3808      	subs	r0, #8
   109ea:	4718      	bx	r3
	}
}
   109ec:	4770      	bx	lr

000109ee <usart_error>:
 */
static void usart_error(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   109ee:	2300      	movs	r3, #0
   109f0:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
   109f2:	6a43      	ldr	r3, [r0, #36]	; 0x24
   109f4:	b10b      	cbz	r3, 109fa <usart_error+0xc>
		descr->usart_cb.error(descr);
   109f6:	3808      	subs	r0, #8
   109f8:	4718      	bx	r3
	}
}
   109fa:	4770      	bx	lr

000109fc <usart_fill_rx_buffer>:
{
   109fc:	b570      	push	{r4, r5, r6, lr}
   109fe:	4604      	mov	r4, r0
	ringbuffer_put(&descr->rx, data);
   10a00:	4b05      	ldr	r3, [pc, #20]	; (10a18 <usart_fill_rx_buffer+0x1c>)
   10a02:	f1a0 0508 	sub.w	r5, r0, #8
   10a06:	302c      	adds	r0, #44	; 0x2c
   10a08:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
   10a0a:	6a23      	ldr	r3, [r4, #32]
   10a0c:	b11b      	cbz	r3, 10a16 <usart_fill_rx_buffer+0x1a>
		descr->usart_cb.rx_done(descr);
   10a0e:	4628      	mov	r0, r5
}
   10a10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		descr->usart_cb.rx_done(descr);
   10a14:	4718      	bx	r3
}
   10a16:	bd70      	pop	{r4, r5, r6, pc}
   10a18:	00011e91 	.word	0x00011e91

00010a1c <usart_async_write>:
{
   10a1c:	b570      	push	{r4, r5, r6, lr}
   10a1e:	460e      	mov	r6, r1
   10a20:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
   10a22:	4604      	mov	r4, r0
   10a24:	b118      	cbz	r0, 10a2e <usart_async_write+0x12>
   10a26:	b1d9      	cbz	r1, 10a60 <usart_async_write+0x44>
   10a28:	1e10      	subs	r0, r2, #0
   10a2a:	bf18      	it	ne
   10a2c:	2001      	movne	r0, #1
   10a2e:	4b0f      	ldr	r3, [pc, #60]	; (10a6c <usart_async_write+0x50>)
   10a30:	490f      	ldr	r1, [pc, #60]	; (10a70 <usart_async_write+0x54>)
   10a32:	f240 123b 	movw	r2, #315	; 0x13b
   10a36:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
   10a38:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
   10a3c:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
   10a40:	429a      	cmp	r2, r3
   10a42:	d10f      	bne.n	10a64 <usart_async_write+0x48>
	descr->tx_por           = 0;
   10a44:	2300      	movs	r3, #0
   10a46:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
   10a4a:	2301      	movs	r3, #1
   10a4c:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
   10a4e:	f104 0008 	add.w	r0, r4, #8
   10a52:	4b08      	ldr	r3, [pc, #32]	; (10a74 <usart_async_write+0x58>)
	descr->tx_buffer        = (uint8_t *)buf;
   10a54:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
   10a56:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	_usart_async_enable_byte_sent_irq(&descr->device);
   10a5a:	4798      	blx	r3
	return (int32_t)length;
   10a5c:	4628      	mov	r0, r5
}
   10a5e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
   10a60:	4608      	mov	r0, r1
   10a62:	e7e4      	b.n	10a2e <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
   10a64:	f06f 001b 	mvn.w	r0, #27
   10a68:	e7f9      	b.n	10a5e <usart_async_write+0x42>
   10a6a:	bf00      	nop
   10a6c:	0000e42d 	.word	0x0000e42d
   10a70:	00016ae0 	.word	0x00016ae0
   10a74:	00011477 	.word	0x00011477

00010a78 <usart_process_byte_sent>:
	if (descr->tx_por != descr->tx_buffer_length) {
   10a78:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   10a7a:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
   10a7e:	429a      	cmp	r2, r3
{
   10a80:	b510      	push	{r4, lr}
   10a82:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
   10a84:	d00a      	beq.n	10a9c <usart_process_byte_sent+0x24>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
   10a86:	6c02      	ldr	r2, [r0, #64]	; 0x40
   10a88:	1c59      	adds	r1, r3, #1
   10a8a:	8781      	strh	r1, [r0, #60]	; 0x3c
   10a8c:	5cd1      	ldrb	r1, [r2, r3]
   10a8e:	4b04      	ldr	r3, [pc, #16]	; (10aa0 <usart_process_byte_sent+0x28>)
   10a90:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
   10a92:	4b04      	ldr	r3, [pc, #16]	; (10aa4 <usart_process_byte_sent+0x2c>)
   10a94:	4620      	mov	r0, r4
}
   10a96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_usart_async_enable_tx_done_irq(&descr->device);
   10a9a:	4718      	bx	r3
   10a9c:	4b02      	ldr	r3, [pc, #8]	; (10aa8 <usart_process_byte_sent+0x30>)
   10a9e:	e7fa      	b.n	10a96 <usart_process_byte_sent+0x1e>
   10aa0:	0001144b 	.word	0x0001144b
   10aa4:	00011477 	.word	0x00011477
   10aa8:	0001147f 	.word	0x0001147f

00010aac <usart_async_read>:
{
   10aac:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   10ab0:	460e      	mov	r6, r1
   10ab2:	4617      	mov	r7, r2
	ASSERT(descr && buf && length);
   10ab4:	4604      	mov	r4, r0
   10ab6:	b118      	cbz	r0, 10ac0 <usart_async_read+0x14>
   10ab8:	b1e9      	cbz	r1, 10af6 <usart_async_read+0x4a>
   10aba:	1e10      	subs	r0, r2, #0
   10abc:	bf18      	it	ne
   10abe:	2001      	movne	r0, #1
   10ac0:	4910      	ldr	r1, [pc, #64]	; (10b04 <usart_async_read+0x58>)
   10ac2:	4b11      	ldr	r3, [pc, #68]	; (10b08 <usart_async_read+0x5c>)
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   10ac4:	f8df 9050 	ldr.w	r9, [pc, #80]	; 10b18 <usart_async_read+0x6c>
	ASSERT(descr && buf && length);
   10ac8:	f44f 72ac 	mov.w	r2, #344	; 0x158
   10acc:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   10ace:	3434      	adds	r4, #52	; 0x34
	CRITICAL_SECTION_ENTER()
   10ad0:	4b0e      	ldr	r3, [pc, #56]	; (10b0c <usart_async_read+0x60>)
   10ad2:	a801      	add	r0, sp, #4
   10ad4:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   10ad6:	4b0e      	ldr	r3, [pc, #56]	; (10b10 <usart_async_read+0x64>)
   10ad8:	4620      	mov	r0, r4
   10ada:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
   10adc:	4b0d      	ldr	r3, [pc, #52]	; (10b14 <usart_async_read+0x68>)
	num = ringbuffer_num(&descr->rx);
   10ade:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
   10ae0:	a801      	add	r0, sp, #4
   10ae2:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
   10ae4:	2500      	movs	r5, #0
   10ae6:	45a8      	cmp	r8, r5
   10ae8:	d001      	beq.n	10aee <usart_async_read+0x42>
   10aea:	42bd      	cmp	r5, r7
   10aec:	d105      	bne.n	10afa <usart_async_read+0x4e>
}
   10aee:	4628      	mov	r0, r5
   10af0:	b003      	add	sp, #12
   10af2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && buf && length);
   10af6:	4608      	mov	r0, r1
   10af8:	e7e2      	b.n	10ac0 <usart_async_read+0x14>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   10afa:	1971      	adds	r1, r6, r5
   10afc:	4620      	mov	r0, r4
   10afe:	47c8      	blx	r9
   10b00:	3501      	adds	r5, #1
   10b02:	e7f0      	b.n	10ae6 <usart_async_read+0x3a>
   10b04:	00016ae0 	.word	0x00016ae0
   10b08:	0000e42d 	.word	0x0000e42d
   10b0c:	00011ef9 	.word	0x00011ef9
   10b10:	00011ed5 	.word	0x00011ed5
   10b14:	00011f07 	.word	0x00011f07
   10b18:	00011e51 	.word	0x00011e51

00010b1c <usart_async_init>:
{
   10b1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10b1e:	460d      	mov	r5, r1
   10b20:	4616      	mov	r6, r2
   10b22:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   10b24:	4604      	mov	r4, r0
   10b26:	b120      	cbz	r0, 10b32 <usart_async_init+0x16>
   10b28:	b309      	cbz	r1, 10b6e <usart_async_init+0x52>
   10b2a:	b312      	cbz	r2, 10b72 <usart_async_init+0x56>
   10b2c:	1e18      	subs	r0, r3, #0
   10b2e:	bf18      	it	ne
   10b30:	2001      	movne	r0, #1
   10b32:	4912      	ldr	r1, [pc, #72]	; (10b7c <usart_async_init+0x60>)
   10b34:	4b12      	ldr	r3, [pc, #72]	; (10b80 <usart_async_init+0x64>)
   10b36:	223a      	movs	r2, #58	; 0x3a
   10b38:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
   10b3a:	4b12      	ldr	r3, [pc, #72]	; (10b84 <usart_async_init+0x68>)
   10b3c:	463a      	mov	r2, r7
   10b3e:	4631      	mov	r1, r6
   10b40:	f104 0034 	add.w	r0, r4, #52	; 0x34
   10b44:	4798      	blx	r3
   10b46:	b9b0      	cbnz	r0, 10b76 <usart_async_init+0x5a>
	init_status = _usart_async_init(&descr->device, hw);
   10b48:	4b0f      	ldr	r3, [pc, #60]	; (10b88 <usart_async_init+0x6c>)
   10b4a:	4629      	mov	r1, r5
   10b4c:	f104 0008 	add.w	r0, r4, #8
   10b50:	4798      	blx	r3
	if (init_status) {
   10b52:	b958      	cbnz	r0, 10b6c <usart_async_init+0x50>
	descr->io.read  = usart_async_read;
   10b54:	4b0d      	ldr	r3, [pc, #52]	; (10b8c <usart_async_init+0x70>)
   10b56:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
   10b58:	4b0d      	ldr	r3, [pc, #52]	; (10b90 <usart_async_init+0x74>)
   10b5a:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
   10b5c:	4b0d      	ldr	r3, [pc, #52]	; (10b94 <usart_async_init+0x78>)
   10b5e:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
   10b60:	4b0d      	ldr	r3, [pc, #52]	; (10b98 <usart_async_init+0x7c>)
   10b62:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
   10b64:	4b0d      	ldr	r3, [pc, #52]	; (10b9c <usart_async_init+0x80>)
   10b66:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
   10b68:	4b0d      	ldr	r3, [pc, #52]	; (10ba0 <usart_async_init+0x84>)
   10b6a:	6163      	str	r3, [r4, #20]
}
   10b6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   10b6e:	4608      	mov	r0, r1
   10b70:	e7df      	b.n	10b32 <usart_async_init+0x16>
   10b72:	4610      	mov	r0, r2
   10b74:	e7dd      	b.n	10b32 <usart_async_init+0x16>
		return ERR_INVALID_ARG;
   10b76:	f06f 000c 	mvn.w	r0, #12
   10b7a:	e7f7      	b.n	10b6c <usart_async_init+0x50>
   10b7c:	00016ae0 	.word	0x00016ae0
   10b80:	0000e42d 	.word	0x0000e42d
   10b84:	00011e15 	.word	0x00011e15
   10b88:	0001138d 	.word	0x0001138d
   10b8c:	00010aad 	.word	0x00010aad
   10b90:	00010a1d 	.word	0x00010a1d
   10b94:	00010a79 	.word	0x00010a79
   10b98:	000109fd 	.word	0x000109fd
   10b9c:	000109e1 	.word	0x000109e1
   10ba0:	000109ef 	.word	0x000109ef

00010ba4 <usart_async_enable>:
{
   10ba4:	b510      	push	{r4, lr}
	ASSERT(descr);
   10ba6:	4604      	mov	r4, r0
   10ba8:	3800      	subs	r0, #0
   10baa:	bf18      	it	ne
   10bac:	2001      	movne	r0, #1
   10bae:	4905      	ldr	r1, [pc, #20]	; (10bc4 <usart_async_enable+0x20>)
   10bb0:	4b05      	ldr	r3, [pc, #20]	; (10bc8 <usart_async_enable+0x24>)
   10bb2:	2261      	movs	r2, #97	; 0x61
   10bb4:	4798      	blx	r3
	_usart_async_enable(&descr->device);
   10bb6:	f104 0008 	add.w	r0, r4, #8
   10bba:	4b04      	ldr	r3, [pc, #16]	; (10bcc <usart_async_enable+0x28>)
   10bbc:	4798      	blx	r3
}
   10bbe:	2000      	movs	r0, #0
   10bc0:	bd10      	pop	{r4, pc}
   10bc2:	bf00      	nop
   10bc4:	00016ae0 	.word	0x00016ae0
   10bc8:	0000e42d 	.word	0x0000e42d
   10bcc:	00011419 	.word	0x00011419

00010bd0 <usart_async_disable>:
{
   10bd0:	b510      	push	{r4, lr}
	ASSERT(descr);
   10bd2:	4604      	mov	r4, r0
   10bd4:	3800      	subs	r0, #0
   10bd6:	bf18      	it	ne
   10bd8:	2001      	movne	r0, #1
   10bda:	4905      	ldr	r1, [pc, #20]	; (10bf0 <usart_async_disable+0x20>)
   10bdc:	4b05      	ldr	r3, [pc, #20]	; (10bf4 <usart_async_disable+0x24>)
   10bde:	226c      	movs	r2, #108	; 0x6c
   10be0:	4798      	blx	r3
	_usart_async_disable(&descr->device);
   10be2:	f104 0008 	add.w	r0, r4, #8
   10be6:	4b04      	ldr	r3, [pc, #16]	; (10bf8 <usart_async_disable+0x28>)
   10be8:	4798      	blx	r3
}
   10bea:	2000      	movs	r0, #0
   10bec:	bd10      	pop	{r4, pc}
   10bee:	bf00      	nop
   10bf0:	00016ae0 	.word	0x00016ae0
   10bf4:	0000e42d 	.word	0x0000e42d
   10bf8:	0001142d 	.word	0x0001142d

00010bfc <usart_async_get_io_descriptor>:
{
   10bfc:	b538      	push	{r3, r4, r5, lr}
   10bfe:	460d      	mov	r5, r1
	ASSERT(descr && io);
   10c00:	4604      	mov	r4, r0
   10c02:	b110      	cbz	r0, 10c0a <usart_async_get_io_descriptor+0xe>
   10c04:	1e08      	subs	r0, r1, #0
   10c06:	bf18      	it	ne
   10c08:	2001      	movne	r0, #1
   10c0a:	4903      	ldr	r1, [pc, #12]	; (10c18 <usart_async_get_io_descriptor+0x1c>)
   10c0c:	4b03      	ldr	r3, [pc, #12]	; (10c1c <usart_async_get_io_descriptor+0x20>)
   10c0e:	2277      	movs	r2, #119	; 0x77
   10c10:	4798      	blx	r3
	*io = &descr->io;
   10c12:	602c      	str	r4, [r5, #0]
}
   10c14:	2000      	movs	r0, #0
   10c16:	bd38      	pop	{r3, r4, r5, pc}
   10c18:	00016ae0 	.word	0x00016ae0
   10c1c:	0000e42d 	.word	0x0000e42d

00010c20 <usart_async_register_callback>:
{
   10c20:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
   10c22:	4605      	mov	r5, r0
   10c24:	3800      	subs	r0, #0
{
   10c26:	460c      	mov	r4, r1
	ASSERT(descr);
   10c28:	bf18      	it	ne
   10c2a:	2001      	movne	r0, #1
   10c2c:	4911      	ldr	r1, [pc, #68]	; (10c74 <usart_async_register_callback+0x54>)
   10c2e:	4b12      	ldr	r3, [pc, #72]	; (10c78 <usart_async_register_callback+0x58>)
{
   10c30:	4616      	mov	r6, r2
	ASSERT(descr);
   10c32:	2283      	movs	r2, #131	; 0x83
   10c34:	4798      	blx	r3
	switch (type) {
   10c36:	2c01      	cmp	r4, #1
   10c38:	d00d      	beq.n	10c56 <usart_async_register_callback+0x36>
   10c3a:	2c02      	cmp	r4, #2
   10c3c:	d011      	beq.n	10c62 <usart_async_register_callback+0x42>
   10c3e:	b9b4      	cbnz	r4, 10c6e <usart_async_register_callback+0x4e>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   10c40:	1e32      	subs	r2, r6, #0
		descr->usart_cb.rx_done = cb;
   10c42:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   10c44:	bf18      	it	ne
   10c46:	2201      	movne	r2, #1
   10c48:	2101      	movs	r1, #1
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   10c4a:	f105 0008 	add.w	r0, r5, #8
   10c4e:	4b0b      	ldr	r3, [pc, #44]	; (10c7c <usart_async_register_callback+0x5c>)
   10c50:	4798      	blx	r3
	return ERR_NONE;
   10c52:	2000      	movs	r0, #0
}
   10c54:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   10c56:	1e32      	subs	r2, r6, #0
		descr->usart_cb.tx_done = cb;
   10c58:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   10c5a:	bf18      	it	ne
   10c5c:	2201      	movne	r2, #1
   10c5e:	2102      	movs	r1, #2
   10c60:	e7f3      	b.n	10c4a <usart_async_register_callback+0x2a>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   10c62:	1e32      	subs	r2, r6, #0
		descr->usart_cb.error = cb;
   10c64:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   10c66:	bf18      	it	ne
   10c68:	2201      	movne	r2, #1
   10c6a:	2103      	movs	r1, #3
   10c6c:	e7ed      	b.n	10c4a <usart_async_register_callback+0x2a>
	switch (type) {
   10c6e:	f06f 000c 	mvn.w	r0, #12
   10c72:	e7ef      	b.n	10c54 <usart_async_register_callback+0x34>
   10c74:	00016ae0 	.word	0x00016ae0
   10c78:	0000e42d 	.word	0x0000e42d
   10c7c:	00011489 	.word	0x00011489

00010c80 <usart_async_set_parity>:
{
   10c80:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr);
   10c82:	4604      	mov	r4, r0
   10c84:	3800      	subs	r0, #0
   10c86:	bf18      	it	ne
   10c88:	2001      	movne	r0, #1
{
   10c8a:	460d      	mov	r5, r1
	ASSERT(descr);
   10c8c:	22cb      	movs	r2, #203	; 0xcb
   10c8e:	4905      	ldr	r1, [pc, #20]	; (10ca4 <usart_async_set_parity+0x24>)
   10c90:	4b05      	ldr	r3, [pc, #20]	; (10ca8 <usart_async_set_parity+0x28>)
   10c92:	4798      	blx	r3
	_usart_async_set_parity(&descr->device, parity);
   10c94:	f104 0008 	add.w	r0, r4, #8
   10c98:	4b04      	ldr	r3, [pc, #16]	; (10cac <usart_async_set_parity+0x2c>)
   10c9a:	4629      	mov	r1, r5
   10c9c:	4798      	blx	r3
}
   10c9e:	2000      	movs	r0, #0
   10ca0:	bd38      	pop	{r3, r4, r5, pc}
   10ca2:	bf00      	nop
   10ca4:	00016ae0 	.word	0x00016ae0
   10ca8:	0000e42d 	.word	0x0000e42d
   10cac:	00011439 	.word	0x00011439

00010cb0 <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
   10cb0:	69c3      	ldr	r3, [r0, #28]
   10cb2:	420b      	tst	r3, r1
   10cb4:	d1fc      	bne.n	10cb0 <hri_sercomi2cm_wait_for_sync>
	};
}
   10cb6:	4770      	bx	lr

00010cb8 <hri_sercomspi_wait_for_sync>:
	return ((Sercom *)hw)->I2CS.SYNCBUSY.reg & reg;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
   10cb8:	69c3      	ldr	r3, [r0, #28]
   10cba:	420b      	tst	r3, r1
   10cbc:	d1fc      	bne.n	10cb8 <hri_sercomspi_wait_for_sync>
	};
}
   10cbe:	4770      	bx	lr

00010cc0 <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
   10cc0:	69c3      	ldr	r3, [r0, #28]
   10cc2:	420b      	tst	r3, r1
   10cc4:	d1fc      	bne.n	10cc0 <hri_sercomusart_wait_for_sync>
	};
}
   10cc6:	4770      	bx	lr

00010cc8 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   10cc8:	6802      	ldr	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10cca:	4b03      	ldr	r3, [pc, #12]	; (10cd8 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   10ccc:	f022 0202 	bic.w	r2, r2, #2
   10cd0:	6002      	str	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   10cd2:	2103      	movs	r1, #3
   10cd4:	4718      	bx	r3
   10cd6:	bf00      	nop
   10cd8:	00010cb1 	.word	0x00010cb1

00010cdc <hri_sercomspi_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomspi_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   10cdc:	6802      	ldr	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10cde:	4b03      	ldr	r3, [pc, #12]	; (10cec <hri_sercomspi_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   10ce0:	f022 0202 	bic.w	r2, r2, #2
   10ce4:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10ce6:	2103      	movs	r1, #3
   10ce8:	4718      	bx	r3
   10cea:	bf00      	nop
   10cec:	00010cb9 	.word	0x00010cb9

00010cf0 <hri_sercomusart_get_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomusart_get_CTRLA_ENABLE_bit(const void *const hw)
{
   10cf0:	b508      	push	{r3, lr}
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10cf2:	2103      	movs	r1, #3
   10cf4:	4b02      	ldr	r3, [pc, #8]	; (10d00 <hri_sercomusart_get_CTRLA_ENABLE_bit+0x10>)
   10cf6:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10cf8:	6800      	ldr	r0, [r0, #0]
	tmp = (tmp & SERCOM_USART_CTRLA_ENABLE) >> SERCOM_USART_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}
   10cfa:	f3c0 0040 	ubfx	r0, r0, #1, #1
   10cfe:	bd08      	pop	{r3, pc}
   10d00:	00010cc1 	.word	0x00010cc1

00010d04 <hri_sercomusart_write_CTRLA_ENABLE_bit>:

static inline void hri_sercomusart_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   10d04:	6803      	ldr	r3, [r0, #0]
	tmp &= ~SERCOM_USART_CTRLA_ENABLE;
   10d06:	f023 0302 	bic.w	r3, r3, #2
	tmp |= value << SERCOM_USART_CTRLA_ENABLE_Pos;
   10d0a:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
	((Sercom *)hw)->USART.CTRLA.reg = tmp;
   10d0e:	6001      	str	r1, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10d10:	4b01      	ldr	r3, [pc, #4]	; (10d18 <hri_sercomusart_write_CTRLA_ENABLE_bit+0x14>)
   10d12:	2103      	movs	r1, #3
   10d14:	4718      	bx	r3
   10d16:	bf00      	nop
   10d18:	00010cc1 	.word	0x00010cc1

00010d1c <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   10d1c:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10d1e:	4b03      	ldr	r3, [pc, #12]	; (10d2c <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   10d20:	f022 0202 	bic.w	r2, r2, #2
   10d24:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   10d26:	2103      	movs	r1, #3
   10d28:	4718      	bx	r3
   10d2a:	bf00      	nop
   10d2c:	00010cc1 	.word	0x00010cc1

00010d30 <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
   10d30:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10d32:	4d0c      	ldr	r5, [pc, #48]	; (10d64 <_sercom_get_hardware_index+0x34>)
{
   10d34:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10d36:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   10d38:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   10d3a:	466c      	mov	r4, sp
   10d3c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   10d3e:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   10d42:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   10d46:	466a      	mov	r2, sp
   10d48:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
   10d4a:	f852 1b04 	ldr.w	r1, [r2], #4
   10d4e:	42b1      	cmp	r1, r6
   10d50:	d102      	bne.n	10d58 <_sercom_get_hardware_index+0x28>
			return i;
   10d52:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
   10d54:	b008      	add	sp, #32
   10d56:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   10d58:	3301      	adds	r3, #1
   10d5a:	2b08      	cmp	r3, #8
   10d5c:	d1f5      	bne.n	10d4a <_sercom_get_hardware_index+0x1a>
	return 0;
   10d5e:	2000      	movs	r0, #0
   10d60:	e7f8      	b.n	10d54 <_sercom_get_hardware_index+0x24>
   10d62:	bf00      	nop
   10d64:	00016b18 	.word	0x00016b18

00010d68 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
   10d68:	b510      	push	{r4, lr}
	void *hw = device->hw;
   10d6a:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   10d6c:	7e22      	ldrb	r2, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   10d6e:	07d1      	lsls	r1, r2, #31
{
   10d70:	4603      	mov	r3, r0
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   10d72:	d508      	bpl.n	10d86 <_sercom_usart_interrupt_handler+0x1e>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
   10d74:	7da2      	ldrb	r2, [r4, #22]
   10d76:	07d2      	lsls	r2, r2, #31
   10d78:	d505      	bpl.n	10d86 <_sercom_usart_interrupt_handler+0x1e>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   10d7a:	2201      	movs	r2, #1
   10d7c:	7522      	strb	r2, [r4, #20]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
   10d7e:	6803      	ldr	r3, [r0, #0]
		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
		status = hri_sercomusart_read_STATUS_reg(hw);
		hri_sercomusart_clear_STATUS_reg(hw, status);
	}
}
   10d80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_byte_sent(device);
   10d84:	4718      	bx	r3
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   10d86:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
   10d88:	0790      	lsls	r0, r2, #30
   10d8a:	d509      	bpl.n	10da0 <_sercom_usart_interrupt_handler+0x38>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
   10d8c:	7da2      	ldrb	r2, [r4, #22]
   10d8e:	0791      	lsls	r1, r2, #30
   10d90:	d506      	bpl.n	10da0 <_sercom_usart_interrupt_handler+0x38>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
   10d92:	2202      	movs	r2, #2
   10d94:	7522      	strb	r2, [r4, #20]
		device->usart_cb.tx_done_cb(device);
   10d96:	4618      	mov	r0, r3
}
   10d98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_done_cb(device);
   10d9c:	689a      	ldr	r2, [r3, #8]
   10d9e:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   10da0:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
   10da2:	0752      	lsls	r2, r2, #29
   10da4:	d50d      	bpl.n	10dc2 <_sercom_usart_interrupt_handler+0x5a>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
   10da6:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
   10da8:	f002 0237 	and.w	r2, r2, #55	; 0x37
   10dac:	b112      	cbz	r2, 10db4 <_sercom_usart_interrupt_handler+0x4c>
	((Sercom *)hw)->USART.STATUS.reg = mask;
   10dae:	23ff      	movs	r3, #255	; 0xff
   10db0:	8363      	strh	r3, [r4, #26]
}
   10db2:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
   10db4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   10db6:	685a      	ldr	r2, [r3, #4]
}
   10db8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   10dbc:	b2c9      	uxtb	r1, r1
   10dbe:	4618      	mov	r0, r3
   10dc0:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
   10dc2:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
   10dc4:	09d2      	lsrs	r2, r2, #7
   10dc6:	d0f4      	beq.n	10db2 <_sercom_usart_interrupt_handler+0x4a>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
   10dc8:	2280      	movs	r2, #128	; 0x80
   10dca:	7622      	strb	r2, [r4, #24]
		device->usart_cb.error_cb(device);
   10dcc:	4618      	mov	r0, r3
   10dce:	68da      	ldr	r2, [r3, #12]
   10dd0:	4790      	blx	r2
	return ((Sercom *)hw)->USART.STATUS.reg;
   10dd2:	8b63      	ldrh	r3, [r4, #26]
   10dd4:	b29b      	uxth	r3, r3
   10dd6:	e7eb      	b.n	10db0 <_sercom_usart_interrupt_handler+0x48>

00010dd8 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM0) {
   10dd8:	4b11      	ldr	r3, [pc, #68]	; (10e20 <_sercom_init_irq_param+0x48>)
   10dda:	4298      	cmp	r0, r3
   10ddc:	d105      	bne.n	10dea <_sercom_init_irq_param+0x12>
		_sercom0_dev = (struct _usart_async_device *)dev;
   10dde:	4b11      	ldr	r3, [pc, #68]	; (10e24 <_sercom_init_irq_param+0x4c>)
   10de0:	6019      	str	r1, [r3, #0]

	if (hw == SERCOM5) {
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
	}

	if (hw == SERCOM6) {
   10de2:	4b11      	ldr	r3, [pc, #68]	; (10e28 <_sercom_init_irq_param+0x50>)
   10de4:	4298      	cmp	r0, r3
   10de6:	d018      	beq.n	10e1a <_sercom_init_irq_param+0x42>
   10de8:	4770      	bx	lr
	if (hw == SERCOM1) {
   10dea:	4b10      	ldr	r3, [pc, #64]	; (10e2c <_sercom_init_irq_param+0x54>)
   10dec:	4298      	cmp	r0, r3
   10dee:	d00b      	beq.n	10e08 <_sercom_init_irq_param+0x30>
	if (hw == SERCOM3) {
   10df0:	4b0f      	ldr	r3, [pc, #60]	; (10e30 <_sercom_init_irq_param+0x58>)
   10df2:	4298      	cmp	r0, r3
   10df4:	d00b      	beq.n	10e0e <_sercom_init_irq_param+0x36>
	if (hw == SERCOM4) {
   10df6:	f1b0 4f86 	cmp.w	r0, #1124073472	; 0x43000000
   10dfa:	d00b      	beq.n	10e14 <_sercom_init_irq_param+0x3c>
	if (hw == SERCOM5) {
   10dfc:	4b0d      	ldr	r3, [pc, #52]	; (10e34 <_sercom_init_irq_param+0x5c>)
   10dfe:	4298      	cmp	r0, r3
   10e00:	d1ef      	bne.n	10de2 <_sercom_init_irq_param+0xa>
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
   10e02:	4b08      	ldr	r3, [pc, #32]	; (10e24 <_sercom_init_irq_param+0x4c>)
   10e04:	6119      	str	r1, [r3, #16]
	if (hw == SERCOM6) {
   10e06:	4770      	bx	lr
		_sercom1_dev = (struct _usart_async_device *)dev;
   10e08:	4b06      	ldr	r3, [pc, #24]	; (10e24 <_sercom_init_irq_param+0x4c>)
   10e0a:	6059      	str	r1, [r3, #4]
	if (hw == SERCOM5) {
   10e0c:	e7e9      	b.n	10de2 <_sercom_init_irq_param+0xa>
		_sercom3_dev = (struct _spi_async_dev *)dev;
   10e0e:	4b05      	ldr	r3, [pc, #20]	; (10e24 <_sercom_init_irq_param+0x4c>)
   10e10:	6099      	str	r1, [r3, #8]
	if (hw == SERCOM6) {
   10e12:	4770      	bx	lr
		_sercom4_dev = (struct _usart_async_device *)dev;
   10e14:	4b03      	ldr	r3, [pc, #12]	; (10e24 <_sercom_init_irq_param+0x4c>)
   10e16:	60d9      	str	r1, [r3, #12]
	if (hw == SERCOM6) {
   10e18:	4770      	bx	lr
		_sercom6_dev = (struct _usart_async_device *)dev;
   10e1a:	4b02      	ldr	r3, [pc, #8]	; (10e24 <_sercom_init_irq_param+0x4c>)
   10e1c:	6159      	str	r1, [r3, #20]
	}
}
   10e1e:	4770      	bx	lr
   10e20:	40003000 	.word	0x40003000
   10e24:	20008d68 	.word	0x20008d68
   10e28:	43000800 	.word	0x43000800
   10e2c:	40003400 	.word	0x40003400
   10e30:	41014000 	.word	0x41014000
   10e34:	43000400 	.word	0x43000400

00010e38 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
   10e38:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
   10e3a:	4b03      	ldr	r3, [pc, #12]	; (10e48 <_sercom_get_irq_num+0x10>)
   10e3c:	4798      	blx	r3
   10e3e:	0080      	lsls	r0, r0, #2
   10e40:	302e      	adds	r0, #46	; 0x2e
}
   10e42:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   10e46:	bd08      	pop	{r3, pc}
   10e48:	00010d31 	.word	0x00010d31

00010e4c <_spi_sync_enable>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   10e4c:	69c2      	ldr	r2, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10e4e:	f012 0201 	ands.w	r2, r2, #1
{
   10e52:	b508      	push	{r3, lr}
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   10e54:	d108      	bne.n	10e68 <_spi_sync_enable+0x1c>
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   10e56:	6803      	ldr	r3, [r0, #0]
   10e58:	f043 0302 	orr.w	r3, r3, #2
   10e5c:	6003      	str	r3, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   10e5e:	2103      	movs	r1, #3
   10e60:	4b03      	ldr	r3, [pc, #12]	; (10e70 <_spi_sync_enable+0x24>)
   10e62:	4798      	blx	r3
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
   10e64:	4610      	mov	r0, r2
}
   10e66:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
   10e68:	f06f 0003 	mvn.w	r0, #3
   10e6c:	e7fb      	b.n	10e66 <_spi_sync_enable+0x1a>
   10e6e:	bf00      	nop
   10e70:	00010cb9 	.word	0x00010cb9

00010e74 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
   10e74:	b508      	push	{r3, lr}
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
   10e76:	4b08      	ldr	r3, [pc, #32]	; (10e98 <_spi_get_regs+0x24>)
   10e78:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
		if (sercomspi_regs[i].n == n) {
   10e7a:	2803      	cmp	r0, #3
   10e7c:	d007      	beq.n	10e8e <_spi_get_regs+0x1a>
   10e7e:	2807      	cmp	r0, #7
   10e80:	d107      	bne.n	10e92 <_spi_get_regs+0x1e>
   10e82:	2301      	movs	r3, #1
			return &sercomspi_regs[i];
   10e84:	4805      	ldr	r0, [pc, #20]	; (10e9c <_spi_get_regs+0x28>)
   10e86:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   10e8a:	4418      	add	r0, r3
		}
	}

	return NULL;
}
   10e8c:	bd08      	pop	{r3, pc}
		if (sercomspi_regs[i].n == n) {
   10e8e:	2300      	movs	r3, #0
   10e90:	e7f8      	b.n	10e84 <_spi_get_regs+0x10>
	return NULL;
   10e92:	2000      	movs	r0, #0
   10e94:	e7fa      	b.n	10e8c <_spi_get_regs+0x18>
   10e96:	bf00      	nop
   10e98:	00010d31 	.word	0x00010d31
   10e9c:	00016b38 	.word	0x00016b38

00010ea0 <_spi_dma_tx_complete>:
 */
static void _spi_dma_tx_complete(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.tx) {
   10ea0:	6883      	ldr	r3, [r0, #8]
   10ea2:	685b      	ldr	r3, [r3, #4]
   10ea4:	b103      	cbz	r3, 10ea8 <_spi_dma_tx_complete+0x8>
		dev->callbacks.tx(resource);
   10ea6:	4718      	bx	r3
	}
}
   10ea8:	4770      	bx	lr

00010eaa <_spi_dma_error_occured>:
 */
static void _spi_dma_error_occured(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.error) {
   10eaa:	6883      	ldr	r3, [r0, #8]
   10eac:	68db      	ldr	r3, [r3, #12]
   10eae:	b103      	cbz	r3, 10eb2 <_spi_dma_error_occured+0x8>
		dev->callbacks.error(resource);
   10eb0:	4718      	bx	r3
	}
}
   10eb2:	4770      	bx	lr

00010eb4 <__NVIC_EnableIRQ>:
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10eb4:	0942      	lsrs	r2, r0, #5
   10eb6:	2301      	movs	r3, #1
   10eb8:	f000 001f 	and.w	r0, r0, #31
   10ebc:	fa03 f000 	lsl.w	r0, r3, r0
   10ec0:	4b01      	ldr	r3, [pc, #4]	; (10ec8 <__NVIC_EnableIRQ+0x14>)
   10ec2:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
   10ec6:	4770      	bx	lr
   10ec8:	e000e100 	.word	0xe000e100

00010ecc <_spi_async_enable>:
{
   10ecc:	b538      	push	{r3, r4, r5, lr}
   10ece:	4604      	mov	r4, r0
	_spi_sync_enable(hw);
   10ed0:	4b07      	ldr	r3, [pc, #28]	; (10ef0 <_spi_async_enable+0x24>)
		NVIC_EnableIRQ((IRQn_Type)irq++);
   10ed2:	4d08      	ldr	r5, [pc, #32]	; (10ef4 <_spi_async_enable+0x28>)
	_spi_sync_enable(hw);
   10ed4:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   10ed6:	4620      	mov	r0, r4
   10ed8:	4b07      	ldr	r3, [pc, #28]	; (10ef8 <_spi_async_enable+0x2c>)
   10eda:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   10edc:	2100      	movs	r1, #0
	uint8_t irq = _sercom_get_irq_num(hw);
   10ede:	4604      	mov	r4, r0
		NVIC_EnableIRQ((IRQn_Type)irq++);
   10ee0:	1860      	adds	r0, r4, r1
   10ee2:	b2c0      	uxtb	r0, r0
   10ee4:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   10ee6:	3101      	adds	r1, #1
   10ee8:	2904      	cmp	r1, #4
   10eea:	d1f9      	bne.n	10ee0 <_spi_async_enable+0x14>
}
   10eec:	2000      	movs	r0, #0
   10eee:	bd38      	pop	{r3, r4, r5, pc}
   10ef0:	00010e4d 	.word	0x00010e4d
   10ef4:	00010eb5 	.word	0x00010eb5
   10ef8:	00010e39 	.word	0x00010e39

00010efc <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10efc:	0943      	lsrs	r3, r0, #5
   10efe:	2201      	movs	r2, #1
   10f00:	f000 001f 	and.w	r0, r0, #31
   10f04:	fa02 f000 	lsl.w	r0, r2, r0
   10f08:	3320      	adds	r3, #32
   10f0a:	4a04      	ldr	r2, [pc, #16]	; (10f1c <__NVIC_DisableIRQ+0x20>)
   10f0c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   10f10:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   10f14:	f3bf 8f6f 	isb	sy
}
   10f18:	4770      	bx	lr
   10f1a:	bf00      	nop
   10f1c:	e000e100 	.word	0xe000e100

00010f20 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   10f20:	0943      	lsrs	r3, r0, #5
   10f22:	2201      	movs	r2, #1
   10f24:	f000 001f 	and.w	r0, r0, #31
   10f28:	fa02 f000 	lsl.w	r0, r2, r0
   10f2c:	3360      	adds	r3, #96	; 0x60
   10f2e:	4a02      	ldr	r2, [pc, #8]	; (10f38 <__NVIC_ClearPendingIRQ+0x18>)
   10f30:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   10f34:	4770      	bx	lr
   10f36:	bf00      	nop
   10f38:	e000e100 	.word	0xe000e100

00010f3c <_get_i2cm_index>:
{
   10f3c:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   10f3e:	4b07      	ldr	r3, [pc, #28]	; (10f5c <_get_i2cm_index+0x20>)
   10f40:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
   10f42:	2805      	cmp	r0, #5
   10f44:	d008      	beq.n	10f58 <_get_i2cm_index+0x1c>
	ASSERT(false);
   10f46:	2000      	movs	r0, #0
   10f48:	4905      	ldr	r1, [pc, #20]	; (10f60 <_get_i2cm_index+0x24>)
   10f4a:	4b06      	ldr	r3, [pc, #24]	; (10f64 <_get_i2cm_index+0x28>)
   10f4c:	f240 32ed 	movw	r2, #1005	; 0x3ed
   10f50:	4798      	blx	r3
   10f52:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   10f56:	bd08      	pop	{r3, pc}
			return i;
   10f58:	2000      	movs	r0, #0
   10f5a:	e7fc      	b.n	10f56 <_get_i2cm_index+0x1a>
   10f5c:	00010d31 	.word	0x00010d31
   10f60:	00016afd 	.word	0x00016afd
   10f64:	0000e42d 	.word	0x0000e42d

00010f68 <_sercom_i2c_send_stop>:
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10f68:	6842      	ldr	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10f6a:	4b03      	ldr	r3, [pc, #12]	; (10f78 <_sercom_i2c_send_stop+0x10>)
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   10f6c:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
   10f70:	6042      	str	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10f72:	2104      	movs	r1, #4
   10f74:	4718      	bx	r3
   10f76:	bf00      	nop
   10f78:	00010cb1 	.word	0x00010cb1

00010f7c <_sercom_i2c_sync_analyse_flags>:
{
   10f7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10f80:	460e      	mov	r6, r1
   10f82:	4614      	mov	r4, r2
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10f84:	2104      	movs	r1, #4
   10f86:	4a56      	ldr	r2, [pc, #344]	; (110e0 <_sercom_i2c_sync_analyse_flags+0x164>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   10f88:	f8d0 8000 	ldr.w	r8, [r0]
   10f8c:	4605      	mov	r5, r0
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   10f8e:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.STATUS.reg;
   10f90:	8b43      	ldrh	r3, [r0, #26]
	if (flags & MB_FLAG) {
   10f92:	f016 0f01 	tst.w	r6, #1
   10f96:	b29b      	uxth	r3, r3
   10f98:	4617      	mov	r7, r2
   10f9a:	d064      	beq.n	11066 <_sercom_i2c_sync_analyse_flags+0xea>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
   10f9c:	079f      	lsls	r7, r3, #30
   10f9e:	d516      	bpl.n	10fce <_sercom_i2c_sync_analyse_flags+0x52>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
   10fa0:	2201      	movs	r2, #1
   10fa2:	7602      	strb	r2, [r0, #24]
			msg->flags |= I2C_M_FAIL;
   10fa4:	8862      	ldrh	r2, [r4, #2]
   10fa6:	b292      	uxth	r2, r2
   10fa8:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   10fac:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
   10fae:	8862      	ldrh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10fb0:	f003 0601 	and.w	r6, r3, #1
			msg->flags &= ~I2C_M_BUSY;
   10fb4:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   10fb8:	0412      	lsls	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10fba:	f1c6 26ff 	rsb	r6, r6, #4278255360	; 0xff00ff00
			msg->flags &= ~I2C_M_BUSY;
   10fbe:	0c12      	lsrs	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10fc0:	f506 067f 	add.w	r6, r6, #16711680	; 0xff0000
			msg->flags &= ~I2C_M_BUSY;
   10fc4:	8062      	strh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   10fc6:	36fc      	adds	r6, #252	; 0xfc
}
   10fc8:	4630      	mov	r0, r6
   10fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
   10fce:	f013 0604 	ands.w	r6, r3, #4
   10fd2:	d015      	beq.n	11000 <_sercom_i2c_sync_analyse_flags+0x84>
				if (msg->len > 0) {
   10fd4:	6863      	ldr	r3, [r4, #4]
   10fd6:	2b00      	cmp	r3, #0
					msg->flags |= I2C_M_FAIL;
   10fd8:	bfc1      	itttt	gt
   10fda:	8863      	ldrhgt	r3, [r4, #2]
   10fdc:	b29b      	uxthgt	r3, r3
   10fde:	f443 5380 	orrgt.w	r3, r3, #4096	; 0x1000
   10fe2:	8063      	strhgt	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
   10fe4:	8863      	ldrh	r3, [r4, #2]
   10fe6:	041e      	lsls	r6, r3, #16
   10fe8:	d501      	bpl.n	10fee <_sercom_i2c_sync_analyse_flags+0x72>
					_sercom_i2c_send_stop(hw);
   10fea:	4b3e      	ldr	r3, [pc, #248]	; (110e4 <_sercom_i2c_sync_analyse_flags+0x168>)
   10fec:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   10fee:	8863      	ldrh	r3, [r4, #2]
   10ff0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   10ff4:	041b      	lsls	r3, r3, #16
   10ff6:	0c1b      	lsrs	r3, r3, #16
   10ff8:	8063      	strh	r3, [r4, #2]
			return I2C_NACK;
   10ffa:	f06f 0601 	mvn.w	r6, #1
   10ffe:	e7e3      	b.n	10fc8 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->flags & I2C_M_TEN) {
   11000:	8863      	ldrh	r3, [r4, #2]
   11002:	f413 6780 	ands.w	r7, r3, #1024	; 0x400
   11006:	d015      	beq.n	11034 <_sercom_i2c_sync_analyse_flags+0xb8>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
   11008:	8823      	ldrh	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1100a:	2104      	movs	r1, #4
   1100c:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   1100e:	f003 0706 	and.w	r7, r3, #6
   11012:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11014:	6a43      	ldr	r3, [r0, #36]	; 0x24
   11016:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   1101a:	433b      	orrs	r3, r7
				hri_sercomi2cm_write_ADDR_reg(hw,
   1101c:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   11020:	6243      	str	r3, [r0, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11022:	2104      	movs	r1, #4
   11024:	4790      	blx	r2
				msg->flags &= ~I2C_M_TEN;
   11026:	8863      	ldrh	r3, [r4, #2]
   11028:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
				msg->flags &= ~I2C_M_BUSY;
   1102c:	041b      	lsls	r3, r3, #16
   1102e:	0c1b      	lsrs	r3, r3, #16
   11030:	8063      	strh	r3, [r4, #2]
   11032:	e7c9      	b.n	10fc8 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->len == 0) {
   11034:	6866      	ldr	r6, [r4, #4]
   11036:	b94e      	cbnz	r6, 1104c <_sercom_i2c_sync_analyse_flags+0xd0>
				if (msg->flags & I2C_M_STOP) {
   11038:	8863      	ldrh	r3, [r4, #2]
   1103a:	0418      	lsls	r0, r3, #16
   1103c:	d502      	bpl.n	11044 <_sercom_i2c_sync_analyse_flags+0xc8>
					_sercom_i2c_send_stop(hw);
   1103e:	4b29      	ldr	r3, [pc, #164]	; (110e4 <_sercom_i2c_sync_analyse_flags+0x168>)
   11040:	4628      	mov	r0, r5
   11042:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   11044:	8863      	ldrh	r3, [r4, #2]
   11046:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1104a:	e7ef      	b.n	1102c <_sercom_i2c_sync_analyse_flags+0xb0>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
   1104c:	68a3      	ldr	r3, [r4, #8]
   1104e:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
   11050:	6283      	str	r3, [r0, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11052:	2104      	movs	r1, #4
   11054:	4790      	blx	r2
				msg->buffer++;
   11056:	68a3      	ldr	r3, [r4, #8]
   11058:	3301      	adds	r3, #1
   1105a:	60a3      	str	r3, [r4, #8]
				msg->len--;
   1105c:	6863      	ldr	r3, [r4, #4]
   1105e:	3b01      	subs	r3, #1
   11060:	6063      	str	r3, [r4, #4]
	return I2C_OK;
   11062:	2600      	movs	r6, #0
}
   11064:	e7b0      	b.n	10fc8 <_sercom_i2c_sync_analyse_flags+0x4c>
	} else if (flags & SB_FLAG) {
   11066:	f016 0602 	ands.w	r6, r6, #2
   1106a:	d0ad      	beq.n	10fc8 <_sercom_i2c_sync_analyse_flags+0x4c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
   1106c:	6862      	ldr	r2, [r4, #4]
   1106e:	2a00      	cmp	r2, #0
   11070:	d032      	beq.n	110d8 <_sercom_i2c_sync_analyse_flags+0x15c>
   11072:	0759      	lsls	r1, r3, #29
   11074:	d430      	bmi.n	110d8 <_sercom_i2c_sync_analyse_flags+0x15c>
			msg->len--;
   11076:	3a01      	subs	r2, #1
   11078:	f3c8 61c0 	ubfx	r1, r8, #27, #1
   1107c:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   1107e:	b99a      	cbnz	r2, 110a8 <_sercom_i2c_sync_analyse_flags+0x12c>
   11080:	b1a9      	cbz	r1, 110ae <_sercom_i2c_sync_analyse_flags+0x132>
				if (msg->flags & I2C_M_STOP) {
   11082:	8863      	ldrh	r3, [r4, #2]
   11084:	041b      	lsls	r3, r3, #16
   11086:	d508      	bpl.n	1109a <_sercom_i2c_sync_analyse_flags+0x11e>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
   11088:	686b      	ldr	r3, [r5, #4]
   1108a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1108e:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11090:	2104      	movs	r1, #4
   11092:	4628      	mov	r0, r5
   11094:	47b8      	blx	r7
					_sercom_i2c_send_stop(hw);
   11096:	4b13      	ldr	r3, [pc, #76]	; (110e4 <_sercom_i2c_sync_analyse_flags+0x168>)
   11098:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   1109a:	8863      	ldrh	r3, [r4, #2]
   1109c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   110a0:	041b      	lsls	r3, r3, #16
   110a2:	0c1b      	lsrs	r3, r3, #16
   110a4:	8063      	strh	r3, [r4, #2]
   110a6:	e00c      	b.n	110c2 <_sercom_i2c_sync_analyse_flags+0x146>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   110a8:	2a01      	cmp	r2, #1
   110aa:	d10a      	bne.n	110c2 <_sercom_i2c_sync_analyse_flags+0x146>
   110ac:	b149      	cbz	r1, 110c2 <_sercom_i2c_sync_analyse_flags+0x146>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   110ae:	686b      	ldr	r3, [r5, #4]
   110b0:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   110b4:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   110b6:	2104      	movs	r1, #4
   110b8:	4628      	mov	r0, r5
   110ba:	47b8      	blx	r7
			if (msg->len == 0) {
   110bc:	6863      	ldr	r3, [r4, #4]
   110be:	2b00      	cmp	r3, #0
   110c0:	d0df      	beq.n	11082 <_sercom_i2c_sync_analyse_flags+0x106>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   110c2:	2104      	movs	r1, #4
   110c4:	4628      	mov	r0, r5
   110c6:	47b8      	blx	r7
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
   110c8:	68a3      	ldr	r3, [r4, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
   110ca:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   110cc:	1c59      	adds	r1, r3, #1
   110ce:	60a1      	str	r1, [r4, #8]
   110d0:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   110d2:	2302      	movs	r3, #2
   110d4:	762b      	strb	r3, [r5, #24]
   110d6:	e7c4      	b.n	11062 <_sercom_i2c_sync_analyse_flags+0xe6>
   110d8:	2302      	movs	r3, #2
   110da:	762b      	strb	r3, [r5, #24]
   110dc:	e78d      	b.n	10ffa <_sercom_i2c_sync_analyse_flags+0x7e>
   110de:	bf00      	nop
   110e0:	00010cb1 	.word	0x00010cb1
   110e4:	00010f69 	.word	0x00010f69

000110e8 <_usart_set_parity>:
{
   110e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   110ea:	4b16      	ldr	r3, [pc, #88]	; (11144 <_usart_set_parity+0x5c>)
{
   110ec:	4604      	mov	r4, r0
   110ee:	460d      	mov	r5, r1
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   110f0:	4798      	blx	r3
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   110f2:	4b15      	ldr	r3, [pc, #84]	; (11148 <_usart_set_parity+0x60>)
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   110f4:	4606      	mov	r6, r0
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   110f6:	4620      	mov	r0, r4
   110f8:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
   110fa:	4b14      	ldr	r3, [pc, #80]	; (1114c <_usart_set_parity+0x64>)
   110fc:	a801      	add	r0, sp, #4
   110fe:	4798      	blx	r3
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   11100:	4a13      	ldr	r2, [pc, #76]	; (11150 <_usart_set_parity+0x68>)
   11102:	4620      	mov	r0, r4
   11104:	2102      	movs	r1, #2
   11106:	4790      	blx	r2
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_FORM(mask);
   11108:	6823      	ldr	r3, [r4, #0]
	if (USART_PARITY_NONE != parity) {
   1110a:	2d02      	cmp	r5, #2
   1110c:	bf14      	ite	ne
   1110e:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_FORM(mask);
   11112:	f023 7380 	biceq.w	r3, r3, #16777216	; 0x1000000
   11116:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   11118:	211f      	movs	r1, #31
   1111a:	4790      	blx	r2
	tmp = ((Sercom *)hw)->USART.CTRLB.reg;
   1111c:	6863      	ldr	r3, [r4, #4]
	hri_sercomusart_write_CTRLB_PMODE_bit(hw, parity);
   1111e:	3d00      	subs	r5, #0
   11120:	bf18      	it	ne
   11122:	2501      	movne	r5, #1
	tmp &= ~SERCOM_USART_CTRLB_PMODE;
   11124:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
	tmp |= value << SERCOM_USART_CTRLB_PMODE_Pos;
   11128:	ea43 3545 	orr.w	r5, r3, r5, lsl #13
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   1112c:	211f      	movs	r1, #31
	((Sercom *)hw)->USART.CTRLB.reg = tmp;
   1112e:	6065      	str	r5, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   11130:	4790      	blx	r2
	CRITICAL_SECTION_LEAVE()
   11132:	a801      	add	r0, sp, #4
   11134:	4b07      	ldr	r3, [pc, #28]	; (11154 <_usart_set_parity+0x6c>)
   11136:	4798      	blx	r3
	hri_sercomusart_write_CTRLA_ENABLE_bit(hw, enabled);
   11138:	4b07      	ldr	r3, [pc, #28]	; (11158 <_usart_set_parity+0x70>)
   1113a:	4631      	mov	r1, r6
   1113c:	4620      	mov	r0, r4
   1113e:	4798      	blx	r3
}
   11140:	b002      	add	sp, #8
   11142:	bd70      	pop	{r4, r5, r6, pc}
   11144:	00010cf1 	.word	0x00010cf1
   11148:	00010d1d 	.word	0x00010d1d
   1114c:	00011ef9 	.word	0x00011ef9
   11150:	00010cc1 	.word	0x00010cc1
   11154:	00011f07 	.word	0x00011f07
   11158:	00010d05 	.word	0x00010d05

0001115c <_spi_set_mode>:
{
   1115c:	b570      	push	{r4, r5, r6, lr}
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   1115e:	69c4      	ldr	r4, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   11160:	f014 0403 	ands.w	r4, r4, #3
{
   11164:	460a      	mov	r2, r1
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   11166:	d10e      	bne.n	11186 <_spi_set_mode+0x2a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11168:	4e08      	ldr	r6, [pc, #32]	; (1118c <_spi_set_mode+0x30>)
   1116a:	2103      	movs	r1, #3
   1116c:	47b0      	blx	r6
	return ((Sercom *)hw)->SPI.CTRLA.reg;
   1116e:	6803      	ldr	r3, [r0, #0]
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   11170:	0712      	lsls	r2, r2, #28
	ctrla &= ~(SERCOM_SPI_CTRLA_CPOL | SERCOM_SPI_CTRLA_CPHA);
   11172:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   11176:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
   1117a:	431a      	orrs	r2, r3
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   1117c:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1117e:	2103      	movs	r1, #3
   11180:	47b0      	blx	r6
	return ERR_NONE;
   11182:	4620      	mov	r0, r4
}
   11184:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
   11186:	f06f 0003 	mvn.w	r0, #3
   1118a:	e7fb      	b.n	11184 <_spi_set_mode+0x28>
   1118c:	00010cb9 	.word	0x00010cb9

00011190 <_spi_load_regs_master>:
{
   11190:	b538      	push	{r3, r4, r5, lr}
   11192:	460d      	mov	r5, r1
	ASSERT(hw && regs);
   11194:	4604      	mov	r4, r0
   11196:	b110      	cbz	r0, 1119e <_spi_load_regs_master+0xe>
   11198:	1e08      	subs	r0, r1, #0
   1119a:	bf18      	it	ne
   1119c:	2001      	movne	r0, #1
   1119e:	490f      	ldr	r1, [pc, #60]	; (111dc <_spi_load_regs_master+0x4c>)
   111a0:	4b0f      	ldr	r3, [pc, #60]	; (111e0 <_spi_load_regs_master+0x50>)
   111a2:	f640 127a 	movw	r2, #2426	; 0x97a
   111a6:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   111a8:	682b      	ldr	r3, [r5, #0]
   111aa:	4a0e      	ldr	r2, [pc, #56]	; (111e4 <_spi_load_regs_master+0x54>)
	hri_sercomspi_write_CTRLA_reg(
   111ac:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   111b0:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   111b4:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   111b6:	2103      	movs	r1, #3
   111b8:	4620      	mov	r0, r4
   111ba:	4790      	blx	r2
	    (regs->ctrlb
   111bc:	686b      	ldr	r3, [r5, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
   111be:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
   111c2:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
   111c6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   111ca:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   111cc:	2117      	movs	r1, #23
   111ce:	4790      	blx	r2
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
   111d0:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
   111d2:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   111d4:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   111d6:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
   111da:	bd38      	pop	{r3, r4, r5, pc}
   111dc:	00016afd 	.word	0x00016afd
   111e0:	0000e42d 	.word	0x0000e42d
   111e4:	00010cb9 	.word	0x00010cb9

000111e8 <_i2c_m_sync_init_impl>:
{
   111e8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   111ec:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
   111ee:	4b23      	ldr	r3, [pc, #140]	; (1127c <_i2c_m_sync_init_impl+0x94>)
   111f0:	f8df 9094 	ldr.w	r9, [pc, #148]	; 11288 <_i2c_m_sync_init_impl+0xa0>
   111f4:	4d22      	ldr	r5, [pc, #136]	; (11280 <_i2c_m_sync_init_impl+0x98>)
{
   111f6:	4607      	mov	r7, r0
	uint8_t i = _get_i2cm_index(hw);
   111f8:	4608      	mov	r0, r1
   111fa:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
   111fc:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
   111fe:	f013 0f01 	tst.w	r3, #1
   11202:	fa5f f880 	uxtb.w	r8, r0
   11206:	d115      	bne.n	11234 <_i2c_m_sync_init_impl+0x4c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   11208:	2318      	movs	r3, #24
   1120a:	fb03 9308 	mla	r3, r3, r8, r9
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   1120e:	2103      	movs	r1, #3
   11210:	4620      	mov	r0, r4
   11212:	6c9e      	ldr	r6, [r3, #72]	; 0x48
   11214:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   11216:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   11218:	079b      	lsls	r3, r3, #30
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   1121a:	f006 061c 	and.w	r6, r6, #28
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   1121e:	d503      	bpl.n	11228 <_i2c_m_sync_init_impl+0x40>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
   11220:	4b18      	ldr	r3, [pc, #96]	; (11284 <_i2c_m_sync_init_impl+0x9c>)
   11222:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
   11224:	2102      	movs	r1, #2
   11226:	47a8      	blx	r5
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
   11228:	f046 0601 	orr.w	r6, r6, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   1122c:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   1122e:	2103      	movs	r1, #3
   11230:	4620      	mov	r0, r4
   11232:	47a8      	blx	r5
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
   11234:	4620      	mov	r0, r4
   11236:	2101      	movs	r1, #1
   11238:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
   1123a:	2218      	movs	r2, #24
   1123c:	fb02 9208 	mla	r2, r2, r8, r9
   11240:	2103      	movs	r1, #3
   11242:	6c96      	ldr	r6, [r2, #72]	; 0x48
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   11244:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   11246:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
   11248:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
   1124a:	6063      	str	r3, [r4, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1124c:	2104      	movs	r1, #4
   1124e:	47a8      	blx	r5
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
   11250:	6d13      	ldr	r3, [r2, #80]	; 0x50
	((Sercom *)hw)->I2CM.BAUD.reg = data;
   11252:	60e3      	str	r3, [r4, #12]
	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
   11254:	f3c6 6301 	ubfx	r3, r6, #24, #2
   11258:	81bb      	strh	r3, [r7, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
   1125a:	6a63      	ldr	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
   1125c:	f3c6 6640 	ubfx	r6, r6, #25, #1
	tmp &= ~SERCOM_I2CM_ADDR_HS;
   11260:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
   11264:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
   11268:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1126a:	2104      	movs	r1, #4
   1126c:	47a8      	blx	r5
	service->trise = _i2cms[i].trise;
   1126e:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
   11272:	81fb      	strh	r3, [r7, #14]
}
   11274:	2000      	movs	r0, #0
   11276:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1127a:	bf00      	nop
   1127c:	00010f3d 	.word	0x00010f3d
   11280:	00010cb1 	.word	0x00010cb1
   11284:	00010cc9 	.word	0x00010cc9
   11288:	00016b18 	.word	0x00016b18

0001128c <_usart_init>:
{
   1128c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   11290:	4b2d      	ldr	r3, [pc, #180]	; (11348 <_usart_init+0xbc>)
{
   11292:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   11294:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
   11296:	4605      	mov	r5, r0
   11298:	b170      	cbz	r0, 112b8 <_usart_init+0x2c>
   1129a:	2801      	cmp	r0, #1
   1129c:	d00c      	beq.n	112b8 <_usart_init+0x2c>
   1129e:	2802      	cmp	r0, #2
   112a0:	d00a      	beq.n	112b8 <_usart_init+0x2c>
   112a2:	2804      	cmp	r0, #4
   112a4:	d04b      	beq.n	1133e <_usart_init+0xb2>
   112a6:	2806      	cmp	r0, #6
   112a8:	d04b      	beq.n	11342 <_usart_init+0xb6>
	ASSERT(false);
   112aa:	4928      	ldr	r1, [pc, #160]	; (1134c <_usart_init+0xc0>)
   112ac:	4b28      	ldr	r3, [pc, #160]	; (11350 <_usart_init+0xc4>)
   112ae:	f240 2276 	movw	r2, #630	; 0x276
   112b2:	2000      	movs	r0, #0
   112b4:	4798      	blx	r3
	return 0;
   112b6:	2500      	movs	r5, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
   112b8:	69e3      	ldr	r3, [r4, #28]
   112ba:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1135c <_usart_init+0xd0>
   112be:	4e25      	ldr	r6, [pc, #148]	; (11354 <_usart_init+0xc8>)
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
   112c0:	f013 0f01 	tst.w	r3, #1
   112c4:	d115      	bne.n	112f2 <_usart_init+0x66>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   112c6:	2318      	movs	r3, #24
   112c8:	fb03 8305 	mla	r3, r3, r5, r8
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   112cc:	2103      	movs	r1, #3
   112ce:	4620      	mov	r0, r4
   112d0:	6e1f      	ldr	r7, [r3, #96]	; 0x60
   112d2:	47b0      	blx	r6
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   112d4:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   112d6:	079b      	lsls	r3, r3, #30
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   112d8:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   112dc:	d503      	bpl.n	112e6 <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   112de:	4b1e      	ldr	r3, [pc, #120]	; (11358 <_usart_init+0xcc>)
   112e0:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   112e2:	2102      	movs	r1, #2
   112e4:	47b0      	blx	r6
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
   112e6:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
   112ea:	6027      	str	r7, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   112ec:	2103      	movs	r1, #3
   112ee:	4620      	mov	r0, r4
   112f0:	47b0      	blx	r6
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
   112f2:	2101      	movs	r1, #1
   112f4:	4620      	mov	r0, r4
   112f6:	47b0      	blx	r6
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
   112f8:	2018      	movs	r0, #24
   112fa:	fb00 8505 	mla	r5, r0, r5, r8
   112fe:	2103      	movs	r1, #3
   11300:	6e2a      	ldr	r2, [r5, #96]	; 0x60
	((Sercom *)hw)->USART.CTRLA.reg = data;
   11302:	6022      	str	r2, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11304:	4620      	mov	r0, r4
   11306:	47b0      	blx	r6
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
   11308:	6e6b      	ldr	r3, [r5, #100]	; 0x64
	((Sercom *)hw)->USART.CTRLB.reg = data;
   1130a:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   1130c:	211f      	movs	r1, #31
   1130e:	47b0      	blx	r6
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
   11310:	6eab      	ldr	r3, [r5, #104]	; 0x68
	((Sercom *)hw)->USART.CTRLC.reg = data;
   11312:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
   11314:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
   11318:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
   1131c:	d008      	beq.n	11330 <_usart_init+0xa4>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
   1131e:	89a2      	ldrh	r2, [r4, #12]
   11320:	f363 020c 	bfi	r2, r3, #0, #13
   11324:	81a2      	strh	r2, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
   11326:	89a3      	ldrh	r3, [r4, #12]
   11328:	f895 206e 	ldrb.w	r2, [r5, #110]	; 0x6e
   1132c:	f362 334f 	bfi	r3, r2, #13, #3
	((Sercom *)hw)->USART.RXPL.reg = data;
   11330:	2000      	movs	r0, #0
	((Sercom *)hw)->USART.BAUD.reg = data;
   11332:	81a3      	strh	r3, [r4, #12]
	((Sercom *)hw)->USART.RXPL.reg = data;
   11334:	73a0      	strb	r0, [r4, #14]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
   11336:	f884 0030 	strb.w	r0, [r4, #48]	; 0x30
}
   1133a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
   1133e:	2503      	movs	r5, #3
   11340:	e7ba      	b.n	112b8 <_usart_init+0x2c>
   11342:	2504      	movs	r5, #4
   11344:	e7b8      	b.n	112b8 <_usart_init+0x2c>
   11346:	bf00      	nop
   11348:	00010d31 	.word	0x00010d31
   1134c:	00016afd 	.word	0x00016afd
   11350:	0000e42d 	.word	0x0000e42d
   11354:	00010cc1 	.word	0x00010cc1
   11358:	00010d1d 	.word	0x00010d1d
   1135c:	00016b18 	.word	0x00016b18

00011360 <_usart_sync_init>:
{
   11360:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   11362:	4605      	mov	r5, r0
   11364:	3800      	subs	r0, #0
{
   11366:	460c      	mov	r4, r1
	ASSERT(device);
   11368:	4b05      	ldr	r3, [pc, #20]	; (11380 <_usart_sync_init+0x20>)
   1136a:	4906      	ldr	r1, [pc, #24]	; (11384 <_usart_sync_init+0x24>)
   1136c:	bf18      	it	ne
   1136e:	2001      	movne	r0, #1
   11370:	22c8      	movs	r2, #200	; 0xc8
   11372:	4798      	blx	r3
	device->hw = hw;
   11374:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
   11376:	4620      	mov	r0, r4
   11378:	4b03      	ldr	r3, [pc, #12]	; (11388 <_usart_sync_init+0x28>)
}
   1137a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
   1137e:	4718      	bx	r3
   11380:	0000e42d 	.word	0x0000e42d
   11384:	00016afd 	.word	0x00016afd
   11388:	0001128d 	.word	0x0001128d

0001138c <_usart_async_init>:
{
   1138c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(device);
   11390:	4606      	mov	r6, r0
   11392:	3800      	subs	r0, #0
   11394:	bf18      	it	ne
   11396:	2001      	movne	r0, #1
   11398:	4b12      	ldr	r3, [pc, #72]	; (113e4 <_usart_async_init+0x58>)
{
   1139a:	460c      	mov	r4, r1
	ASSERT(device);
   1139c:	22d6      	movs	r2, #214	; 0xd6
   1139e:	4912      	ldr	r1, [pc, #72]	; (113e8 <_usart_async_init+0x5c>)
   113a0:	4798      	blx	r3
	init_status = _usart_init(hw);
   113a2:	4b12      	ldr	r3, [pc, #72]	; (113ec <_usart_async_init+0x60>)
   113a4:	4620      	mov	r0, r4
   113a6:	4798      	blx	r3
	if (init_status) {
   113a8:	4605      	mov	r5, r0
   113aa:	b9b8      	cbnz	r0, 113dc <_usart_async_init+0x50>
	_sercom_init_irq_param(hw, (void *)device);
   113ac:	4631      	mov	r1, r6
	device->hw = hw;
   113ae:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
   113b0:	4620      	mov	r0, r4
   113b2:	4b0f      	ldr	r3, [pc, #60]	; (113f0 <_usart_async_init+0x64>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   113b4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 11400 <_usart_async_init+0x74>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   113b8:	4f0e      	ldr	r7, [pc, #56]	; (113f4 <_usart_async_init+0x68>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   113ba:	4e0f      	ldr	r6, [pc, #60]	; (113f8 <_usart_async_init+0x6c>)
	_sercom_init_irq_param(hw, (void *)device);
   113bc:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   113be:	4b0f      	ldr	r3, [pc, #60]	; (113fc <_usart_async_init+0x70>)
   113c0:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   113c2:	4629      	mov	r1, r5
	uint8_t irq = _sercom_get_irq_num(hw);
   113c4:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   113c6:	1863      	adds	r3, r4, r1
   113c8:	b2d8      	uxtb	r0, r3
   113ca:	9001      	str	r0, [sp, #4]
   113cc:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   113ce:	9801      	ldr	r0, [sp, #4]
   113d0:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   113d2:	9801      	ldr	r0, [sp, #4]
   113d4:	47b0      	blx	r6
	for (uint32_t i = 0; i < 4; i++) {
   113d6:	3101      	adds	r1, #1
   113d8:	2904      	cmp	r1, #4
   113da:	d1f4      	bne.n	113c6 <_usart_async_init+0x3a>
}
   113dc:	4628      	mov	r0, r5
   113de:	b002      	add	sp, #8
   113e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   113e4:	0000e42d 	.word	0x0000e42d
   113e8:	00016afd 	.word	0x00016afd
   113ec:	0001128d 	.word	0x0001128d
   113f0:	00010dd9 	.word	0x00010dd9
   113f4:	00010f21 	.word	0x00010f21
   113f8:	00010eb5 	.word	0x00010eb5
   113fc:	00010e39 	.word	0x00010e39
   11400:	00010efd 	.word	0x00010efd

00011404 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11404:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   11406:	6803      	ldr	r3, [r0, #0]
   11408:	f043 0302 	orr.w	r3, r3, #2
   1140c:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1140e:	2103      	movs	r1, #3
   11410:	4b00      	ldr	r3, [pc, #0]	; (11414 <_usart_sync_enable+0x10>)
   11412:	4718      	bx	r3
   11414:	00010cc1 	.word	0x00010cc1

00011418 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11418:	6980      	ldr	r0, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   1141a:	6803      	ldr	r3, [r0, #0]
   1141c:	f043 0302 	orr.w	r3, r3, #2
   11420:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11422:	2103      	movs	r1, #3
   11424:	4b00      	ldr	r3, [pc, #0]	; (11428 <_usart_async_enable+0x10>)
   11426:	4718      	bx	r3
   11428:	00010cc1 	.word	0x00010cc1

0001142c <_usart_async_disable>:
	hri_sercomusart_clear_CTRLA_ENABLE_bit(device->hw);
   1142c:	6980      	ldr	r0, [r0, #24]
   1142e:	4b01      	ldr	r3, [pc, #4]	; (11434 <_usart_async_disable+0x8>)
   11430:	4718      	bx	r3
   11432:	bf00      	nop
   11434:	00010d1d 	.word	0x00010d1d

00011438 <_usart_async_set_parity>:
	_usart_set_parity(device->hw, parity);
   11438:	6980      	ldr	r0, [r0, #24]
   1143a:	4b01      	ldr	r3, [pc, #4]	; (11440 <_usart_async_set_parity+0x8>)
   1143c:	4718      	bx	r3
   1143e:	bf00      	nop
   11440:	000110e9 	.word	0x000110e9

00011444 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   11444:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
   11446:	6299      	str	r1, [r3, #40]	; 0x28
}
   11448:	4770      	bx	lr

0001144a <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   1144a:	6983      	ldr	r3, [r0, #24]
   1144c:	6299      	str	r1, [r3, #40]	; 0x28
}
   1144e:	4770      	bx	lr

00011450 <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
   11450:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
   11452:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   11454:	b2c0      	uxtb	r0, r0
   11456:	4770      	bx	lr

00011458 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
   11458:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   1145a:	7e18      	ldrb	r0, [r3, #24]
}
   1145c:	f000 0001 	and.w	r0, r0, #1
   11460:	4770      	bx	lr

00011462 <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
   11462:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   11464:	7e18      	ldrb	r0, [r3, #24]
}
   11466:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1146a:	4770      	bx	lr

0001146c <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
   1146c:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   1146e:	7e18      	ldrb	r0, [r3, #24]
}
   11470:	f3c0 0080 	ubfx	r0, r0, #2, #1
   11474:	4770      	bx	lr

00011476 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
   11476:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   11478:	2201      	movs	r2, #1
   1147a:	759a      	strb	r2, [r3, #22]
}
   1147c:	4770      	bx	lr

0001147e <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
   1147e:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
   11480:	2202      	movs	r2, #2
   11482:	759a      	strb	r2, [r3, #22]
}
   11484:	4770      	bx	lr
	...

00011488 <_usart_async_set_irq_state>:
{
   11488:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   1148a:	4604      	mov	r4, r0
   1148c:	3800      	subs	r0, #0
{
   1148e:	460e      	mov	r6, r1
	ASSERT(device);
   11490:	bf18      	it	ne
   11492:	2001      	movne	r0, #1
   11494:	490f      	ldr	r1, [pc, #60]	; (114d4 <_usart_async_set_irq_state+0x4c>)
   11496:	4b10      	ldr	r3, [pc, #64]	; (114d8 <_usart_async_set_irq_state+0x50>)
{
   11498:	4615      	mov	r5, r2
	ASSERT(device);
   1149a:	f240 2236 	movw	r2, #566	; 0x236
   1149e:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
   114a0:	f016 0ffd 	tst.w	r6, #253	; 0xfd
   114a4:	d109      	bne.n	114ba <_usart_async_set_irq_state+0x32>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
   114a6:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   114a8:	2101      	movs	r1, #1
   114aa:	2202      	movs	r2, #2
   114ac:	b915      	cbnz	r5, 114b4 <_usart_async_set_irq_state+0x2c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   114ae:	7519      	strb	r1, [r3, #20]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
   114b0:	751a      	strb	r2, [r3, #20]
}
   114b2:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   114b4:	7599      	strb	r1, [r3, #22]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
   114b6:	759a      	strb	r2, [r3, #22]
   114b8:	e7fb      	b.n	114b2 <_usart_async_set_irq_state+0x2a>
	} else if (USART_ASYNC_RX_DONE == type) {
   114ba:	2e01      	cmp	r6, #1
   114bc:	d104      	bne.n	114c8 <_usart_async_set_irq_state+0x40>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
   114be:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   114c0:	2204      	movs	r2, #4
	if (value == 0x0) {
   114c2:	2d00      	cmp	r5, #0
   114c4:	d1f7      	bne.n	114b6 <_usart_async_set_irq_state+0x2e>
   114c6:	e7f3      	b.n	114b0 <_usart_async_set_irq_state+0x28>
	} else if (USART_ASYNC_ERROR == type) {
   114c8:	2e03      	cmp	r6, #3
   114ca:	d1f2      	bne.n	114b2 <_usart_async_set_irq_state+0x2a>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
   114cc:	69a3      	ldr	r3, [r4, #24]
   114ce:	2280      	movs	r2, #128	; 0x80
   114d0:	e7f7      	b.n	114c2 <_usart_async_set_irq_state+0x3a>
   114d2:	bf00      	nop
   114d4:	00016afd 	.word	0x00016afd
   114d8:	0000e42d 	.word	0x0000e42d

000114dc <_i2c_m_async_init>:
{
   114dc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   114e0:	4605      	mov	r5, r0
   114e2:	3800      	subs	r0, #0
{
   114e4:	460c      	mov	r4, r1
	ASSERT(i2c_dev);
   114e6:	bf18      	it	ne
   114e8:	2001      	movne	r0, #1
   114ea:	4913      	ldr	r1, [pc, #76]	; (11538 <_i2c_m_async_init+0x5c>)
   114ec:	4b13      	ldr	r3, [pc, #76]	; (1153c <_i2c_m_async_init+0x60>)
   114ee:	f240 42d3 	movw	r2, #1235	; 0x4d3
   114f2:	4798      	blx	r3
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   114f4:	4b12      	ldr	r3, [pc, #72]	; (11540 <_i2c_m_async_init+0x64>)
	i2c_dev->hw = hw;
   114f6:	612c      	str	r4, [r5, #16]
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   114f8:	4621      	mov	r1, r4
   114fa:	4628      	mov	r0, r5
   114fc:	4798      	blx	r3
	if (init_status) {
   114fe:	4606      	mov	r6, r0
   11500:	b9b0      	cbnz	r0, 11530 <_i2c_m_async_init+0x54>
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11502:	4629      	mov	r1, r5
   11504:	4620      	mov	r0, r4
   11506:	4b0f      	ldr	r3, [pc, #60]	; (11544 <_i2c_m_async_init+0x68>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11508:	f8df 8048 	ldr.w	r8, [pc, #72]	; 11554 <_i2c_m_async_init+0x78>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1150c:	4f0e      	ldr	r7, [pc, #56]	; (11548 <_i2c_m_async_init+0x6c>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   1150e:	4d0f      	ldr	r5, [pc, #60]	; (1154c <_i2c_m_async_init+0x70>)
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11510:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   11512:	4b0f      	ldr	r3, [pc, #60]	; (11550 <_i2c_m_async_init+0x74>)
   11514:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11516:	4631      	mov	r1, r6
	uint8_t irq = _sercom_get_irq_num(hw);
   11518:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   1151a:	1863      	adds	r3, r4, r1
   1151c:	b2d8      	uxtb	r0, r3
   1151e:	9001      	str	r0, [sp, #4]
   11520:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11522:	9801      	ldr	r0, [sp, #4]
   11524:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   11526:	9801      	ldr	r0, [sp, #4]
   11528:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   1152a:	3101      	adds	r1, #1
   1152c:	2904      	cmp	r1, #4
   1152e:	d1f4      	bne.n	1151a <_i2c_m_async_init+0x3e>
}
   11530:	4630      	mov	r0, r6
   11532:	b002      	add	sp, #8
   11534:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11538:	00016afd 	.word	0x00016afd
   1153c:	0000e42d 	.word	0x0000e42d
   11540:	000111e9 	.word	0x000111e9
   11544:	00010dd9 	.word	0x00010dd9
   11548:	00010f21 	.word	0x00010f21
   1154c:	00010eb5 	.word	0x00010eb5
   11550:	00010e39 	.word	0x00010e39
   11554:	00010efd 	.word	0x00010efd

00011558 <_i2c_m_async_transfer>:
{
   11558:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   1155c:	4604      	mov	r4, r0
   1155e:	3800      	subs	r0, #0
   11560:	4e3c      	ldr	r6, [pc, #240]	; (11654 <_i2c_m_async_transfer+0xfc>)
{
   11562:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
   11564:	bf18      	it	ne
   11566:	2001      	movne	r0, #1
   11568:	493b      	ldr	r1, [pc, #236]	; (11658 <_i2c_m_async_transfer+0x100>)
   1156a:	f240 5229 	movw	r2, #1321	; 0x529
   1156e:	47b0      	blx	r6
	ASSERT(i2c_dev->hw);
   11570:	6920      	ldr	r0, [r4, #16]
   11572:	4939      	ldr	r1, [pc, #228]	; (11658 <_i2c_m_async_transfer+0x100>)
   11574:	3800      	subs	r0, #0
   11576:	f240 522a 	movw	r2, #1322	; 0x52a
   1157a:	bf18      	it	ne
   1157c:	2001      	movne	r0, #1
   1157e:	47b0      	blx	r6
	ASSERT(msg);
   11580:	1e28      	subs	r0, r5, #0
   11582:	bf18      	it	ne
   11584:	2001      	movne	r0, #1
   11586:	4934      	ldr	r1, [pc, #208]	; (11658 <_i2c_m_async_transfer+0x100>)
   11588:	f240 522b 	movw	r2, #1323	; 0x52b
   1158c:	47b0      	blx	r6
	if (msg->len == 0) {
   1158e:	6868      	ldr	r0, [r5, #4]
   11590:	2800      	cmp	r0, #0
   11592:	d048      	beq.n	11626 <_i2c_m_async_transfer+0xce>
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
   11594:	8863      	ldrh	r3, [r4, #2]
   11596:	05da      	lsls	r2, r3, #23
   11598:	d458      	bmi.n	1164c <_i2c_m_async_transfer+0xf4>
	msg->flags |= I2C_M_BUSY;
   1159a:	886b      	ldrh	r3, [r5, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1159c:	4f2f      	ldr	r7, [pc, #188]	; (1165c <_i2c_m_async_transfer+0x104>)
   1159e:	b29b      	uxth	r3, r3
   115a0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   115a4:	806b      	strh	r3, [r5, #2]
	i2c_dev->service.msg = *msg;
   115a6:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   115aa:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(i2c_dev->hw);
   115ae:	6920      	ldr	r0, [r4, #16]
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
   115b0:	6843      	ldr	r3, [r0, #4]
   115b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   115b6:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   115b8:	2104      	movs	r1, #4
   115ba:	47b8      	blx	r7
	void *             hw    = i2c_dev->hw;
   115bc:	6925      	ldr	r5, [r4, #16]
	ASSERT(i2c_dev);
   115be:	4926      	ldr	r1, [pc, #152]	; (11658 <_i2c_m_async_transfer+0x100>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   115c0:	f8d5 8000 	ldr.w	r8, [r5]
   115c4:	f240 5201 	movw	r2, #1281	; 0x501
   115c8:	2001      	movs	r0, #1
   115ca:	47b0      	blx	r6
	if (msg->len == 1 && sclsm) {
   115cc:	6863      	ldr	r3, [r4, #4]
   115ce:	2b01      	cmp	r3, #1
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   115d0:	686b      	ldr	r3, [r5, #4]
   115d2:	d12a      	bne.n	1162a <_i2c_m_async_transfer+0xd2>
   115d4:	f018 6f00 	tst.w	r8, #134217728	; 0x8000000
   115d8:	d027      	beq.n	1162a <_i2c_m_async_transfer+0xd2>
   115da:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   115de:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   115e0:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   115e2:	2104      	movs	r1, #4
   115e4:	47b8      	blx	r7
	if (msg->addr & I2C_M_TEN) {
   115e6:	8820      	ldrh	r0, [r4, #0]
   115e8:	f410 6680 	ands.w	r6, r0, #1024	; 0x400
   115ec:	ea4f 0240 	mov.w	r2, r0, lsl #1
   115f0:	d01e      	beq.n	11630 <_i2c_m_async_transfer+0xd8>
		if (msg->flags & I2C_M_RD) {
   115f2:	8863      	ldrh	r3, [r4, #2]
   115f4:	07db      	lsls	r3, r3, #31
			msg->flags |= I2C_M_TEN;
   115f6:	bf41      	itttt	mi
   115f8:	8863      	ldrhmi	r3, [r4, #2]
   115fa:	b29b      	uxthmi	r3, r3
   115fc:	f443 6380 	orrmi.w	r3, r3, #1024	; 0x400
   11600:	8063      	strhmi	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11602:	2104      	movs	r1, #4
   11604:	4628      	mov	r0, r5
   11606:	47b8      	blx	r7
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11608:	6a6b      	ldr	r3, [r5, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   1160a:	f022 0201 	bic.w	r2, r2, #1
   1160e:	0552      	lsls	r2, r2, #21
   11610:	0d52      	lsrs	r2, r2, #21
   11612:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   11616:	431a      	orrs	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
   11618:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1161c:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   1161e:	626a      	str	r2, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11620:	2104      	movs	r1, #4
   11622:	47b8      	blx	r7
	return ERR_NONE;
   11624:	2000      	movs	r0, #0
}
   11626:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   1162a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
   1162e:	e7d6      	b.n	115de <_i2c_m_async_transfer+0x86>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11630:	2104      	movs	r1, #4
   11632:	4628      	mov	r0, r5
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
   11634:	8864      	ldrh	r4, [r4, #2]
   11636:	47b8      	blx	r7
   11638:	b2a4      	uxth	r4, r4
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   1163a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   1163c:	b2d2      	uxtb	r2, r2
   1163e:	f004 0401 	and.w	r4, r4, #1
   11642:	4322      	orrs	r2, r4
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   11644:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
   11648:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   1164a:	e7e7      	b.n	1161c <_i2c_m_async_transfer+0xc4>
		return ERR_BUSY;
   1164c:	f06f 0003 	mvn.w	r0, #3
   11650:	e7e9      	b.n	11626 <_i2c_m_async_transfer+0xce>
   11652:	bf00      	nop
   11654:	0000e42d 	.word	0x0000e42d
   11658:	00016afd 	.word	0x00016afd
   1165c:	00010cb1 	.word	0x00010cb1

00011660 <_i2c_m_async_register_callback>:
	switch (type) {
   11660:	2901      	cmp	r1, #1
   11662:	d005      	beq.n	11670 <_i2c_m_async_register_callback+0x10>
   11664:	2902      	cmp	r1, #2
   11666:	d005      	beq.n	11674 <_i2c_m_async_register_callback+0x14>
   11668:	b901      	cbnz	r1, 1166c <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.error = (_i2c_error_cb_t)func;
   1166a:	6142      	str	r2, [r0, #20]
}
   1166c:	2000      	movs	r0, #0
   1166e:	4770      	bx	lr
		i2c_dev->cb.tx_complete = (_i2c_complete_cb_t)func;
   11670:	6182      	str	r2, [r0, #24]
		break;
   11672:	e7fb      	b.n	1166c <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.rx_complete = (_i2c_complete_cb_t)func;
   11674:	61c2      	str	r2, [r0, #28]
		break;
   11676:	e7f9      	b.n	1166c <_i2c_m_async_register_callback+0xc>

00011678 <SERCOM0_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom0_dev);
   11678:	4b01      	ldr	r3, [pc, #4]	; (11680 <SERCOM0_0_Handler+0x8>)
   1167a:	6818      	ldr	r0, [r3, #0]
   1167c:	4b01      	ldr	r3, [pc, #4]	; (11684 <SERCOM0_0_Handler+0xc>)
   1167e:	4718      	bx	r3
   11680:	20008d68 	.word	0x20008d68
   11684:	00010d69 	.word	0x00010d69

00011688 <SERCOM0_1_Handler>:
   11688:	4b00      	ldr	r3, [pc, #0]	; (1168c <SERCOM0_1_Handler+0x4>)
   1168a:	4718      	bx	r3
   1168c:	00011679 	.word	0x00011679

00011690 <SERCOM0_2_Handler>:
   11690:	4b00      	ldr	r3, [pc, #0]	; (11694 <SERCOM0_2_Handler+0x4>)
   11692:	4718      	bx	r3
   11694:	00011679 	.word	0x00011679

00011698 <SERCOM0_3_Handler>:
   11698:	4b00      	ldr	r3, [pc, #0]	; (1169c <SERCOM0_3_Handler+0x4>)
   1169a:	4718      	bx	r3
   1169c:	00011679 	.word	0x00011679

000116a0 <SERCOM1_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom1_dev);
   116a0:	4b01      	ldr	r3, [pc, #4]	; (116a8 <SERCOM1_0_Handler+0x8>)
   116a2:	6858      	ldr	r0, [r3, #4]
   116a4:	4b01      	ldr	r3, [pc, #4]	; (116ac <SERCOM1_0_Handler+0xc>)
   116a6:	4718      	bx	r3
   116a8:	20008d68 	.word	0x20008d68
   116ac:	00010d69 	.word	0x00010d69

000116b0 <SERCOM1_1_Handler>:
   116b0:	4b00      	ldr	r3, [pc, #0]	; (116b4 <SERCOM1_1_Handler+0x4>)
   116b2:	4718      	bx	r3
   116b4:	000116a1 	.word	0x000116a1

000116b8 <SERCOM1_2_Handler>:
   116b8:	4b00      	ldr	r3, [pc, #0]	; (116bc <SERCOM1_2_Handler+0x4>)
   116ba:	4718      	bx	r3
   116bc:	000116a1 	.word	0x000116a1

000116c0 <SERCOM1_3_Handler>:
   116c0:	4b00      	ldr	r3, [pc, #0]	; (116c4 <SERCOM1_3_Handler+0x4>)
   116c2:	4718      	bx	r3
   116c4:	000116a1 	.word	0x000116a1

000116c8 <SERCOM3_0_Handler>:
	_spi_handler(_sercom3_dev);
   116c8:	4b0f      	ldr	r3, [pc, #60]	; (11708 <SERCOM3_0_Handler+0x40>)
   116ca:	6898      	ldr	r0, [r3, #8]
	void *                      hw = dev->prvt;
   116cc:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
   116ce:	7e13      	ldrb	r3, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
   116d0:	7d91      	ldrb	r1, [r2, #22]
	st &= hri_sercomspi_read_INTEN_reg(hw);
   116d2:	400b      	ands	r3, r1
	if (st & SERCOM_SPI_INTFLAG_DRE) {
   116d4:	07d9      	lsls	r1, r3, #31
   116d6:	d501      	bpl.n	116dc <SERCOM3_0_Handler+0x14>
		dev->callbacks.tx(dev);
   116d8:	6883      	ldr	r3, [r0, #8]
		dev->callbacks.rx(dev);
   116da:	4718      	bx	r3
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
   116dc:	0759      	lsls	r1, r3, #29
   116de:	d501      	bpl.n	116e4 <SERCOM3_0_Handler+0x1c>
		dev->callbacks.rx(dev);
   116e0:	68c3      	ldr	r3, [r0, #12]
   116e2:	e7fa      	b.n	116da <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
   116e4:	0799      	lsls	r1, r3, #30
   116e6:	d503      	bpl.n	116f0 <SERCOM3_0_Handler+0x28>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   116e8:	2302      	movs	r3, #2
   116ea:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
   116ec:	6903      	ldr	r3, [r0, #16]
   116ee:	e7f4      	b.n	116da <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
   116f0:	061b      	lsls	r3, r3, #24
   116f2:	d507      	bpl.n	11704 <SERCOM3_0_Handler+0x3c>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
   116f4:	2304      	movs	r3, #4
   116f6:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   116f8:	2380      	movs	r3, #128	; 0x80
   116fa:	7613      	strb	r3, [r2, #24]
		dev->callbacks.err(dev, ERR_OVERFLOW);
   116fc:	f06f 0112 	mvn.w	r1, #18
   11700:	6943      	ldr	r3, [r0, #20]
   11702:	4718      	bx	r3
}
   11704:	4770      	bx	lr
   11706:	bf00      	nop
   11708:	20008d68 	.word	0x20008d68

0001170c <SERCOM3_1_Handler>:
   1170c:	4b00      	ldr	r3, [pc, #0]	; (11710 <SERCOM3_1_Handler+0x4>)
   1170e:	4718      	bx	r3
   11710:	000116c9 	.word	0x000116c9

00011714 <SERCOM3_2_Handler>:
   11714:	4b00      	ldr	r3, [pc, #0]	; (11718 <SERCOM3_2_Handler+0x4>)
   11716:	4718      	bx	r3
   11718:	000116c9 	.word	0x000116c9

0001171c <SERCOM3_3_Handler>:
   1171c:	4b00      	ldr	r3, [pc, #0]	; (11720 <SERCOM3_3_Handler+0x4>)
   1171e:	4718      	bx	r3
   11720:	000116c9 	.word	0x000116c9

00011724 <SERCOM4_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom4_dev);
   11724:	4b01      	ldr	r3, [pc, #4]	; (1172c <SERCOM4_0_Handler+0x8>)
   11726:	68d8      	ldr	r0, [r3, #12]
   11728:	4b01      	ldr	r3, [pc, #4]	; (11730 <SERCOM4_0_Handler+0xc>)
   1172a:	4718      	bx	r3
   1172c:	20008d68 	.word	0x20008d68
   11730:	00010d69 	.word	0x00010d69

00011734 <SERCOM4_1_Handler>:
   11734:	4b00      	ldr	r3, [pc, #0]	; (11738 <SERCOM4_1_Handler+0x4>)
   11736:	4718      	bx	r3
   11738:	00011725 	.word	0x00011725

0001173c <SERCOM4_2_Handler>:
   1173c:	4b00      	ldr	r3, [pc, #0]	; (11740 <SERCOM4_2_Handler+0x4>)
   1173e:	4718      	bx	r3
   11740:	00011725 	.word	0x00011725

00011744 <SERCOM4_3_Handler>:
   11744:	4b00      	ldr	r3, [pc, #0]	; (11748 <SERCOM4_3_Handler+0x4>)
   11746:	4718      	bx	r3
   11748:	00011725 	.word	0x00011725

0001174c <SERCOM5_0_Handler>:
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   1174c:	4b1f      	ldr	r3, [pc, #124]	; (117cc <SERCOM5_0_Handler+0x80>)
	ASSERT(i2c_dev);
   1174e:	4920      	ldr	r1, [pc, #128]	; (117d0 <SERCOM5_0_Handler+0x84>)
{
   11750:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   11754:	691c      	ldr	r4, [r3, #16]
	ASSERT(i2c_dev);
   11756:	4f1f      	ldr	r7, [pc, #124]	; (117d4 <SERCOM5_0_Handler+0x88>)
	void *   hw    = i2c_dev->hw;
   11758:	6926      	ldr	r6, [r4, #16]
	ASSERT(i2c_dev);
   1175a:	f240 425f 	movw	r2, #1119	; 0x45f
   1175e:	2001      	movs	r0, #1
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
   11760:	7e35      	ldrb	r5, [r6, #24]
   11762:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
   11764:	6920      	ldr	r0, [r4, #16]
   11766:	491a      	ldr	r1, [pc, #104]	; (117d0 <SERCOM5_0_Handler+0x84>)
   11768:	3800      	subs	r0, #0
   1176a:	bf18      	it	ne
   1176c:	2001      	movne	r0, #1
   1176e:	b2ed      	uxtb	r5, r5
   11770:	f44f 628c 	mov.w	r2, #1120	; 0x460
   11774:	47b8      	blx	r7
	while (!(flags & ERROR_FLAG)) {
   11776:	0629      	lsls	r1, r5, #24
   11778:	d415      	bmi.n	117a6 <SERCOM5_0_Handler+0x5a>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
   1177a:	4629      	mov	r1, r5
   1177c:	4b16      	ldr	r3, [pc, #88]	; (117d8 <SERCOM5_0_Handler+0x8c>)
   1177e:	4622      	mov	r2, r4
   11780:	4630      	mov	r0, r6
   11782:	4798      	blx	r3
		if (ret != 0) {
   11784:	4601      	mov	r1, r0
   11786:	b978      	cbnz	r0, 117a8 <SERCOM5_0_Handler+0x5c>
		if ((flags & MB_FLAG) && i2c_dev->cb.tx_complete) {
   11788:	07ea      	lsls	r2, r5, #31
   1178a:	d505      	bpl.n	11798 <SERCOM5_0_Handler+0x4c>
   1178c:	69a3      	ldr	r3, [r4, #24]
   1178e:	b11b      	cbz	r3, 11798 <SERCOM5_0_Handler+0x4c>
			i2c_dev->cb.rx_complete(i2c_dev);
   11790:	4620      	mov	r0, r4
}
   11792:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			i2c_dev->cb.rx_complete(i2c_dev);
   11796:	4718      	bx	r3
		} else if ((flags & SB_FLAG) && i2c_dev->cb.rx_complete) {
   11798:	07ab      	lsls	r3, r5, #30
   1179a:	d502      	bpl.n	117a2 <SERCOM5_0_Handler+0x56>
   1179c:	69e3      	ldr	r3, [r4, #28]
   1179e:	2b00      	cmp	r3, #0
   117a0:	d1f6      	bne.n	11790 <SERCOM5_0_Handler+0x44>
}
   117a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int32_t  ret   = I2C_OK;
   117a6:	2100      	movs	r1, #0
	i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
   117a8:	8863      	ldrh	r3, [r4, #2]
   117aa:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   117ae:	041b      	lsls	r3, r3, #16
   117b0:	0c1b      	lsrs	r3, r3, #16
   117b2:	8063      	strh	r3, [r4, #2]
	if (i2c_dev->cb.error) {
   117b4:	6963      	ldr	r3, [r4, #20]
   117b6:	2b00      	cmp	r3, #0
   117b8:	d0f3      	beq.n	117a2 <SERCOM5_0_Handler+0x56>
		if (ret != I2C_OK) {
   117ba:	b121      	cbz	r1, 117c6 <SERCOM5_0_Handler+0x7a>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   117bc:	4620      	mov	r0, r4
   117be:	4798      	blx	r3
	((Sercom *)hw)->I2CM.INTFLAG.reg = mask;
   117c0:	2380      	movs	r3, #128	; 0x80
   117c2:	7633      	strb	r3, [r6, #24]
}
   117c4:	e7ed      	b.n	117a2 <SERCOM5_0_Handler+0x56>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   117c6:	f06f 0104 	mvn.w	r1, #4
   117ca:	e7f7      	b.n	117bc <SERCOM5_0_Handler+0x70>
   117cc:	20008d68 	.word	0x20008d68
   117d0:	00016afd 	.word	0x00016afd
   117d4:	0000e42d 	.word	0x0000e42d
   117d8:	00010f7d 	.word	0x00010f7d

000117dc <SERCOM5_1_Handler>:
   117dc:	4b00      	ldr	r3, [pc, #0]	; (117e0 <SERCOM5_1_Handler+0x4>)
   117de:	4718      	bx	r3
   117e0:	0001174d 	.word	0x0001174d

000117e4 <SERCOM5_2_Handler>:
   117e4:	4b00      	ldr	r3, [pc, #0]	; (117e8 <SERCOM5_2_Handler+0x4>)
   117e6:	4718      	bx	r3
   117e8:	0001174d 	.word	0x0001174d

000117ec <SERCOM5_3_Handler>:
   117ec:	4b00      	ldr	r3, [pc, #0]	; (117f0 <SERCOM5_3_Handler+0x4>)
   117ee:	4718      	bx	r3
   117f0:	0001174d 	.word	0x0001174d

000117f4 <SERCOM6_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom6_dev);
   117f4:	4b01      	ldr	r3, [pc, #4]	; (117fc <SERCOM6_0_Handler+0x8>)
   117f6:	6958      	ldr	r0, [r3, #20]
   117f8:	4b01      	ldr	r3, [pc, #4]	; (11800 <SERCOM6_0_Handler+0xc>)
   117fa:	4718      	bx	r3
   117fc:	20008d68 	.word	0x20008d68
   11800:	00010d69 	.word	0x00010d69

00011804 <SERCOM6_1_Handler>:
   11804:	4b00      	ldr	r3, [pc, #0]	; (11808 <SERCOM6_1_Handler+0x4>)
   11806:	4718      	bx	r3
   11808:	000117f5 	.word	0x000117f5

0001180c <SERCOM6_2_Handler>:
   1180c:	4b00      	ldr	r3, [pc, #0]	; (11810 <SERCOM6_2_Handler+0x4>)
   1180e:	4718      	bx	r3
   11810:	000117f5 	.word	0x000117f5

00011814 <SERCOM6_3_Handler>:
   11814:	4b00      	ldr	r3, [pc, #0]	; (11818 <SERCOM6_3_Handler+0x4>)
   11816:	4718      	bx	r3
   11818:	000117f5 	.word	0x000117f5

0001181c <_spi_m_sync_init>:
{
   1181c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11820:	4b37      	ldr	r3, [pc, #220]	; (11900 <_spi_m_sync_init+0xe4>)
{
   11822:	4606      	mov	r6, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11824:	4608      	mov	r0, r1
{
   11826:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11828:	4798      	blx	r3
   1182a:	4605      	mov	r5, r0
	ASSERT(dev && hw);
   1182c:	2e00      	cmp	r6, #0
   1182e:	d05d      	beq.n	118ec <_spi_m_sync_init+0xd0>
   11830:	1e20      	subs	r0, r4, #0
   11832:	bf18      	it	ne
   11834:	2001      	movne	r0, #1
   11836:	4f33      	ldr	r7, [pc, #204]	; (11904 <_spi_m_sync_init+0xe8>)
   11838:	4933      	ldr	r1, [pc, #204]	; (11908 <_spi_m_sync_init+0xec>)
   1183a:	f640 2278 	movw	r2, #2680	; 0xa78
   1183e:	47b8      	blx	r7
	if (regs == NULL) {
   11840:	46b9      	mov	r9, r7
   11842:	2d00      	cmp	r5, #0
   11844:	d058      	beq.n	118f8 <_spi_m_sync_init+0xdc>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11846:	69e3      	ldr	r3, [r4, #28]
   11848:	4f30      	ldr	r7, [pc, #192]	; (1190c <_spi_m_sync_init+0xf0>)
	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   1184a:	f013 0f01 	tst.w	r3, #1
   1184e:	d113      	bne.n	11878 <_spi_m_sync_init+0x5c>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11850:	2103      	movs	r1, #3
   11852:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11854:	f8d5 8000 	ldr.w	r8, [r5]
   11858:	47b8      	blx	r7
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   1185a:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   1185c:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   1185e:	f008 081c 	and.w	r8, r8, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11862:	d503      	bpl.n	1186c <_spi_m_sync_init+0x50>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   11864:	4b2a      	ldr	r3, [pc, #168]	; (11910 <_spi_m_sync_init+0xf4>)
   11866:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   11868:	2102      	movs	r1, #2
   1186a:	47b8      	blx	r7
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   1186c:	f048 0301 	orr.w	r3, r8, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11870:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11872:	2103      	movs	r1, #3
   11874:	4620      	mov	r0, r4
   11876:	47b8      	blx	r7
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   11878:	2101      	movs	r1, #1
   1187a:	4620      	mov	r0, r4
   1187c:	47b8      	blx	r7
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   1187e:	682b      	ldr	r3, [r5, #0]
	dev->prvt = hw;
   11880:	6034      	str	r4, [r6, #0]
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   11882:	f003 031c 	and.w	r3, r3, #28
   11886:	2b08      	cmp	r3, #8
   11888:	d132      	bne.n	118f0 <_spi_m_sync_init+0xd4>
	ASSERT(hw && regs);
   1188a:	f640 128e 	movw	r2, #2446	; 0x98e
   1188e:	491e      	ldr	r1, [pc, #120]	; (11908 <_spi_m_sync_init+0xec>)
   11890:	2001      	movs	r0, #1
   11892:	47c8      	blx	r9
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   11894:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
   11896:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   1189a:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   1189e:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   118a0:	2103      	movs	r1, #3
   118a2:	4620      	mov	r0, r4
   118a4:	47b8      	blx	r7
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
   118a6:	686b      	ldr	r3, [r5, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
   118a8:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
   118ac:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
   118b0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   118b4:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   118b8:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   118ba:	2117      	movs	r1, #23
   118bc:	47b8      	blx	r7
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
   118be:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
   118c0:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   118c2:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   118c4:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   118c8:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
   118ca:	2b00      	cmp	r3, #0
   118cc:	d1fc      	bne.n	118c8 <_spi_m_sync_init+0xac>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
   118ce:	686b      	ldr	r3, [r5, #4]
   118d0:	f013 0f07 	tst.w	r3, #7
   118d4:	bf0c      	ite	eq
   118d6:	2301      	moveq	r3, #1
   118d8:	2302      	movne	r3, #2
   118da:	7133      	strb	r3, [r6, #4]
	dev->dummy_byte = regs->dummy_byte;
   118dc:	7bab      	ldrb	r3, [r5, #14]
   118de:	7bea      	ldrb	r2, [r5, #15]
   118e0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   118e4:	80f3      	strh	r3, [r6, #6]
	return ERR_NONE;
   118e6:	2000      	movs	r0, #0
}
   118e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(dev && hw);
   118ec:	4630      	mov	r0, r6
   118ee:	e7a2      	b.n	11836 <_spi_m_sync_init+0x1a>
		_spi_load_regs_master(hw, regs);
   118f0:	4b08      	ldr	r3, [pc, #32]	; (11914 <_spi_m_sync_init+0xf8>)
   118f2:	4629      	mov	r1, r5
   118f4:	4798      	blx	r3
   118f6:	e7ea      	b.n	118ce <_spi_m_sync_init+0xb2>
		return ERR_INVALID_ARG;
   118f8:	f06f 000c 	mvn.w	r0, #12
   118fc:	e7f4      	b.n	118e8 <_spi_m_sync_init+0xcc>
   118fe:	bf00      	nop
   11900:	00010e75 	.word	0x00010e75
   11904:	0000e42d 	.word	0x0000e42d
   11908:	00016afd 	.word	0x00016afd
   1190c:	00010cb9 	.word	0x00010cb9
   11910:	00010cdd 	.word	0x00010cdd
   11914:	00011191 	.word	0x00011191

00011918 <_spi_m_async_init>:
{
   11918:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   1191a:	4b10      	ldr	r3, [pc, #64]	; (1195c <_spi_m_async_init+0x44>)
{
   1191c:	4605      	mov	r5, r0
   1191e:	460e      	mov	r6, r1
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11920:	4798      	blx	r3
	if (rc < 0) {
   11922:	2800      	cmp	r0, #0
   11924:	db17      	blt.n	11956 <_spi_m_async_init+0x3e>
	_sercom_init_irq_param(hw, (void *)dev);
   11926:	4629      	mov	r1, r5
	spid->callbacks.complete = NULL;
   11928:	2400      	movs	r4, #0
	_sercom_init_irq_param(hw, (void *)dev);
   1192a:	4630      	mov	r0, r6
   1192c:	4b0c      	ldr	r3, [pc, #48]	; (11960 <_spi_m_async_init+0x48>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   1192e:	4e0d      	ldr	r6, [pc, #52]	; (11964 <_spi_m_async_init+0x4c>)
	_sercom_init_irq_param(hw, (void *)dev);
   11930:	4798      	blx	r3
	spid->callbacks.rx       = NULL;
   11932:	e9c5 4403 	strd	r4, r4, [r5, #12]
	spid->callbacks.tx       = NULL;
   11936:	60ac      	str	r4, [r5, #8]
	uint8_t irq              = _sercom_get_irq_num(hw);
   11938:	4b0b      	ldr	r3, [pc, #44]	; (11968 <_spi_m_async_init+0x50>)
   1193a:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   1193c:	4621      	mov	r1, r4
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1193e:	4c0b      	ldr	r4, [pc, #44]	; (1196c <_spi_m_async_init+0x54>)
	uint8_t irq              = _sercom_get_irq_num(hw);
   11940:	4605      	mov	r5, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11942:	186b      	adds	r3, r5, r1
   11944:	b2d8      	uxtb	r0, r3
   11946:	9001      	str	r0, [sp, #4]
   11948:	47b0      	blx	r6
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1194a:	9801      	ldr	r0, [sp, #4]
   1194c:	47a0      	blx	r4
	for (uint32_t i = 0; i < 4; i++) {
   1194e:	3101      	adds	r1, #1
   11950:	2904      	cmp	r1, #4
   11952:	d1f6      	bne.n	11942 <_spi_m_async_init+0x2a>
   11954:	2000      	movs	r0, #0
}
   11956:	b002      	add	sp, #8
   11958:	bd70      	pop	{r4, r5, r6, pc}
   1195a:	bf00      	nop
   1195c:	0001181d 	.word	0x0001181d
   11960:	00010dd9 	.word	0x00010dd9
   11964:	00010efd 	.word	0x00010efd
   11968:	00010e39 	.word	0x00010e39
   1196c:	00010f21 	.word	0x00010f21

00011970 <_spi_m_async_enable>:
{
   11970:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11972:	4604      	mov	r4, r0
   11974:	b118      	cbz	r0, 1197e <_spi_m_async_enable+0xe>
   11976:	6800      	ldr	r0, [r0, #0]
   11978:	3800      	subs	r0, #0
   1197a:	bf18      	it	ne
   1197c:	2001      	movne	r0, #1
   1197e:	4b05      	ldr	r3, [pc, #20]	; (11994 <_spi_m_async_enable+0x24>)
   11980:	4905      	ldr	r1, [pc, #20]	; (11998 <_spi_m_async_enable+0x28>)
   11982:	f640 22e5 	movw	r2, #2789	; 0xae5
   11986:	4798      	blx	r3
	return _spi_async_enable(dev->prvt);
   11988:	6820      	ldr	r0, [r4, #0]
   1198a:	4b04      	ldr	r3, [pc, #16]	; (1199c <_spi_m_async_enable+0x2c>)
}
   1198c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_async_enable(dev->prvt);
   11990:	4718      	bx	r3
   11992:	bf00      	nop
   11994:	0000e42d 	.word	0x0000e42d
   11998:	00016afd 	.word	0x00016afd
   1199c:	00010ecd 	.word	0x00010ecd

000119a0 <_spi_m_async_set_mode>:
{
   119a0:	b570      	push	{r4, r5, r6, lr}
   119a2:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   119a4:	4604      	mov	r4, r0
   119a6:	b118      	cbz	r0, 119b0 <_spi_m_async_set_mode+0x10>
   119a8:	6800      	ldr	r0, [r0, #0]
   119aa:	3800      	subs	r0, #0
   119ac:	bf18      	it	ne
   119ae:	2001      	movne	r0, #1
   119b0:	4905      	ldr	r1, [pc, #20]	; (119c8 <_spi_m_async_set_mode+0x28>)
   119b2:	4b06      	ldr	r3, [pc, #24]	; (119cc <_spi_m_async_set_mode+0x2c>)
   119b4:	f640 3216 	movw	r2, #2838	; 0xb16
   119b8:	4798      	blx	r3
	return _spi_set_mode(dev->prvt, mode);
   119ba:	6820      	ldr	r0, [r4, #0]
   119bc:	4b04      	ldr	r3, [pc, #16]	; (119d0 <_spi_m_async_set_mode+0x30>)
   119be:	4629      	mov	r1, r5
}
   119c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_set_mode(dev->prvt, mode);
   119c4:	4718      	bx	r3
   119c6:	bf00      	nop
   119c8:	00016afd 	.word	0x00016afd
   119cc:	0000e42d 	.word	0x0000e42d
   119d0:	0001115d 	.word	0x0001115d

000119d4 <_spi_m_async_set_baudrate>:
{
   119d4:	b538      	push	{r3, r4, r5, lr}
   119d6:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   119d8:	4604      	mov	r4, r0
   119da:	b118      	cbz	r0, 119e4 <_spi_m_async_set_baudrate+0x10>
   119dc:	6800      	ldr	r0, [r0, #0]
   119de:	3800      	subs	r0, #0
   119e0:	bf18      	it	ne
   119e2:	2001      	movne	r0, #1
   119e4:	4907      	ldr	r1, [pc, #28]	; (11a04 <_spi_m_async_set_baudrate+0x30>)
   119e6:	4b08      	ldr	r3, [pc, #32]	; (11a08 <_spi_m_async_set_baudrate+0x34>)
   119e8:	f640 3245 	movw	r2, #2885	; 0xb45
   119ec:	4798      	blx	r3
	return _spi_set_baudrate(dev->prvt, baud_val);
   119ee:	6823      	ldr	r3, [r4, #0]
   119f0:	69d8      	ldr	r0, [r3, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   119f2:	f010 0001 	ands.w	r0, r0, #1
	hri_sercomspi_write_BAUD_reg(hw, baud_val);
   119f6:	bf06      	itte	eq
   119f8:	b2ed      	uxtbeq	r5, r5
	((Sercom *)hw)->SPI.BAUD.reg = data;
   119fa:	731d      	strbeq	r5, [r3, #12]
		return ERR_BUSY;
   119fc:	f06f 0003 	mvnne.w	r0, #3
}
   11a00:	bd38      	pop	{r3, r4, r5, pc}
   11a02:	bf00      	nop
   11a04:	00016afd 	.word	0x00016afd
   11a08:	0000e42d 	.word	0x0000e42d

00011a0c <_spi_m_async_enable_tx>:
{
   11a0c:	b538      	push	{r3, r4, r5, lr}
	void *hw = dev->prvt;
   11a0e:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev && hw);
   11a10:	4b07      	ldr	r3, [pc, #28]	; (11a30 <_spi_m_async_enable_tx+0x24>)
   11a12:	1e20      	subs	r0, r4, #0
{
   11a14:	460d      	mov	r5, r1
	ASSERT(dev && hw);
   11a16:	f640 4208 	movw	r2, #3080	; 0xc08
   11a1a:	4906      	ldr	r1, [pc, #24]	; (11a34 <_spi_m_async_enable_tx+0x28>)
   11a1c:	bf18      	it	ne
   11a1e:	2001      	movne	r0, #1
   11a20:	4798      	blx	r3
	if (state) {
   11a22:	2301      	movs	r3, #1
   11a24:	b115      	cbz	r5, 11a2c <_spi_m_async_enable_tx+0x20>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
   11a26:	75a3      	strb	r3, [r4, #22]
}
   11a28:	2000      	movs	r0, #0
   11a2a:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
   11a2c:	7523      	strb	r3, [r4, #20]
}
   11a2e:	e7fb      	b.n	11a28 <_spi_m_async_enable_tx+0x1c>
   11a30:	0000e42d 	.word	0x0000e42d
   11a34:	00016afd 	.word	0x00016afd

00011a38 <_spi_m_async_enable_rx>:
{
   11a38:	b570      	push	{r4, r5, r6, lr}
	void *hw = dev->prvt;
   11a3a:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev);
   11a3c:	4e0a      	ldr	r6, [pc, #40]	; (11a68 <_spi_m_async_enable_rx+0x30>)
   11a3e:	f640 421c 	movw	r2, #3100	; 0xc1c
   11a42:	2001      	movs	r0, #1
{
   11a44:	460d      	mov	r5, r1
	ASSERT(dev);
   11a46:	4909      	ldr	r1, [pc, #36]	; (11a6c <_spi_m_async_enable_rx+0x34>)
   11a48:	47b0      	blx	r6
	ASSERT(hw);
   11a4a:	1e20      	subs	r0, r4, #0
   11a4c:	4907      	ldr	r1, [pc, #28]	; (11a6c <_spi_m_async_enable_rx+0x34>)
   11a4e:	f640 421d 	movw	r2, #3101	; 0xc1d
   11a52:	bf18      	it	ne
   11a54:	2001      	movne	r0, #1
   11a56:	47b0      	blx	r6
	if (state) {
   11a58:	2304      	movs	r3, #4
   11a5a:	b115      	cbz	r5, 11a62 <_spi_m_async_enable_rx+0x2a>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
   11a5c:	75a3      	strb	r3, [r4, #22]
}
   11a5e:	2000      	movs	r0, #0
   11a60:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
   11a62:	7523      	strb	r3, [r4, #20]
}
   11a64:	e7fb      	b.n	11a5e <_spi_m_async_enable_rx+0x26>
   11a66:	bf00      	nop
   11a68:	0000e42d 	.word	0x0000e42d
   11a6c:	00016afd 	.word	0x00016afd

00011a70 <_spi_m_async_enable_tx_complete>:
{
   11a70:	b538      	push	{r3, r4, r5, lr}
   11a72:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11a74:	4604      	mov	r4, r0
   11a76:	b118      	cbz	r0, 11a80 <_spi_m_async_enable_tx_complete+0x10>
   11a78:	6800      	ldr	r0, [r0, #0]
   11a7a:	3800      	subs	r0, #0
   11a7c:	bf18      	it	ne
   11a7e:	2001      	movne	r0, #1
   11a80:	4b06      	ldr	r3, [pc, #24]	; (11a9c <_spi_m_async_enable_tx_complete+0x2c>)
   11a82:	4907      	ldr	r1, [pc, #28]	; (11aa0 <_spi_m_async_enable_tx_complete+0x30>)
   11a84:	f640 422f 	movw	r2, #3119	; 0xc2f
   11a88:	4798      	blx	r3
	if (state) {
   11a8a:	6823      	ldr	r3, [r4, #0]
   11a8c:	2202      	movs	r2, #2
   11a8e:	b115      	cbz	r5, 11a96 <_spi_m_async_enable_tx_complete+0x26>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
   11a90:	759a      	strb	r2, [r3, #22]
}
   11a92:	2000      	movs	r0, #0
   11a94:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
   11a96:	751a      	strb	r2, [r3, #20]
}
   11a98:	e7fb      	b.n	11a92 <_spi_m_async_enable_tx_complete+0x22>
   11a9a:	bf00      	nop
   11a9c:	0000e42d 	.word	0x0000e42d
   11aa0:	00016afd 	.word	0x00016afd

00011aa4 <_spi_m_async_write_one>:
{
   11aa4:	b538      	push	{r3, r4, r5, lr}
   11aa6:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11aa8:	4604      	mov	r4, r0
   11aaa:	b118      	cbz	r0, 11ab4 <_spi_m_async_write_one+0x10>
   11aac:	6800      	ldr	r0, [r0, #0]
   11aae:	3800      	subs	r0, #0
   11ab0:	bf18      	it	ne
   11ab2:	2001      	movne	r0, #1
   11ab4:	4904      	ldr	r1, [pc, #16]	; (11ac8 <_spi_m_async_write_one+0x24>)
   11ab6:	4b05      	ldr	r3, [pc, #20]	; (11acc <_spi_m_async_write_one+0x28>)
   11ab8:	f640 4241 	movw	r2, #3137	; 0xc41
   11abc:	4798      	blx	r3
	hri_sercomspi_write_DATA_reg(dev->prvt, data);
   11abe:	6823      	ldr	r3, [r4, #0]
}
   11ac0:	2000      	movs	r0, #0
	((Sercom *)hw)->SPI.DATA.reg = data;
   11ac2:	629d      	str	r5, [r3, #40]	; 0x28
   11ac4:	bd38      	pop	{r3, r4, r5, pc}
   11ac6:	bf00      	nop
   11ac8:	00016afd 	.word	0x00016afd
   11acc:	0000e42d 	.word	0x0000e42d

00011ad0 <_spi_m_async_read_one>:
{
   11ad0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11ad2:	4604      	mov	r4, r0
   11ad4:	b118      	cbz	r0, 11ade <_spi_m_async_read_one+0xe>
   11ad6:	6800      	ldr	r0, [r0, #0]
   11ad8:	3800      	subs	r0, #0
   11ada:	bf18      	it	ne
   11adc:	2001      	movne	r0, #1
   11ade:	4904      	ldr	r1, [pc, #16]	; (11af0 <_spi_m_async_read_one+0x20>)
   11ae0:	4b04      	ldr	r3, [pc, #16]	; (11af4 <_spi_m_async_read_one+0x24>)
   11ae2:	f640 425c 	movw	r2, #3164	; 0xc5c
   11ae6:	4798      	blx	r3
	return hri_sercomspi_read_DATA_reg(dev->prvt);
   11ae8:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
   11aea:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   11aec:	b280      	uxth	r0, r0
   11aee:	bd10      	pop	{r4, pc}
   11af0:	00016afd 	.word	0x00016afd
   11af4:	0000e42d 	.word	0x0000e42d

00011af8 <_spi_m_async_register_callback>:
{
   11af8:	b570      	push	{r4, r5, r6, lr}
   11afa:	460d      	mov	r5, r1
   11afc:	4616      	mov	r6, r2
	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
   11afe:	4604      	mov	r4, r0
   11b00:	b118      	cbz	r0, 11b0a <_spi_m_async_register_callback+0x12>
   11b02:	2903      	cmp	r1, #3
   11b04:	bf8c      	ite	hi
   11b06:	2000      	movhi	r0, #0
   11b08:	2001      	movls	r0, #1
   11b0a:	4905      	ldr	r1, [pc, #20]	; (11b20 <_spi_m_async_register_callback+0x28>)
   11b0c:	4b05      	ldr	r3, [pc, #20]	; (11b24 <_spi_m_async_register_callback+0x2c>)
   11b0e:	f640 4275 	movw	r2, #3189	; 0xc75
   11b12:	4798      	blx	r3
	p_ls[cb_type] = (func_t)func;
   11b14:	eb04 0185 	add.w	r1, r4, r5, lsl #2
}
   11b18:	2000      	movs	r0, #0
	p_ls[cb_type] = (func_t)func;
   11b1a:	608e      	str	r6, [r1, #8]
}
   11b1c:	bd70      	pop	{r4, r5, r6, pc}
   11b1e:	bf00      	nop
   11b20:	00016afd 	.word	0x00016afd
   11b24:	0000e42d 	.word	0x0000e42d

00011b28 <_spi_m_async_set_irq_state>:
{
   11b28:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   11b2a:	4604      	mov	r4, r0
   11b2c:	3800      	subs	r0, #0
{
   11b2e:	460e      	mov	r6, r1
	ASSERT(device);
   11b30:	bf18      	it	ne
   11b32:	2001      	movne	r0, #1
   11b34:	4907      	ldr	r1, [pc, #28]	; (11b54 <_spi_m_async_set_irq_state+0x2c>)
   11b36:	4b08      	ldr	r3, [pc, #32]	; (11b58 <_spi_m_async_set_irq_state+0x30>)
{
   11b38:	4615      	mov	r5, r2
	ASSERT(device);
   11b3a:	f640 42b6 	movw	r2, #3254	; 0xcb6
   11b3e:	4798      	blx	r3
	if (SPI_DEV_CB_ERROR == type) {
   11b40:	2e03      	cmp	r6, #3
   11b42:	d103      	bne.n	11b4c <_spi_m_async_set_irq_state+0x24>
		hri_sercomspi_write_INTEN_ERROR_bit(device->prvt, state);
   11b44:	6823      	ldr	r3, [r4, #0]
	if (value == 0x0) {
   11b46:	2280      	movs	r2, #128	; 0x80
   11b48:	b90d      	cbnz	r5, 11b4e <_spi_m_async_set_irq_state+0x26>
		((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_ERROR;
   11b4a:	751a      	strb	r2, [r3, #20]
}
   11b4c:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_ERROR;
   11b4e:	759a      	strb	r2, [r3, #22]
   11b50:	e7fc      	b.n	11b4c <_spi_m_async_set_irq_state+0x24>
   11b52:	bf00      	nop
   11b54:	00016afd 	.word	0x00016afd
   11b58:	0000e42d 	.word	0x0000e42d

00011b5c <_spi_m_dma_init>:

int32_t _spi_m_dma_init(struct _spi_m_dma_dev *dev, void *const hw)
{
   11b5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11b60:	4b25      	ldr	r3, [pc, #148]	; (11bf8 <_spi_m_dma_init+0x9c>)
{
   11b62:	4605      	mov	r5, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11b64:	4608      	mov	r0, r1
{
   11b66:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11b68:	4798      	blx	r3
   11b6a:	4606      	mov	r6, r0

	ASSERT(dev && hw);
   11b6c:	2d00      	cmp	r5, #0
   11b6e:	d03e      	beq.n	11bee <_spi_m_dma_init+0x92>
   11b70:	1e20      	subs	r0, r4, #0
   11b72:	bf18      	it	ne
   11b74:	2001      	movne	r0, #1
   11b76:	4921      	ldr	r1, [pc, #132]	; (11bfc <_spi_m_dma_init+0xa0>)
   11b78:	4b21      	ldr	r3, [pc, #132]	; (11c00 <_spi_m_dma_init+0xa4>)
   11b7a:	f640 52e3 	movw	r2, #3555	; 0xde3
   11b7e:	4798      	blx	r3

	if (regs == NULL) {
   11b80:	2e00      	cmp	r6, #0
   11b82:	d036      	beq.n	11bf2 <_spi_m_dma_init+0x96>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11b84:	69e3      	ldr	r3, [r4, #28]
   11b86:	f8df 8094 	ldr.w	r8, [pc, #148]	; 11c1c <_spi_m_dma_init+0xc0>
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   11b8a:	f013 0f01 	tst.w	r3, #1
   11b8e:	d112      	bne.n	11bb6 <_spi_m_dma_init+0x5a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11b90:	2103      	movs	r1, #3
   11b92:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11b94:	6837      	ldr	r7, [r6, #0]
   11b96:	47c0      	blx	r8
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   11b98:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11b9a:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11b9c:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11ba0:	d503      	bpl.n	11baa <_spi_m_dma_init+0x4e>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   11ba2:	4b18      	ldr	r3, [pc, #96]	; (11c04 <_spi_m_dma_init+0xa8>)
   11ba4:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   11ba6:	2102      	movs	r1, #2
   11ba8:	47c0      	blx	r8
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   11baa:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11bae:	6027      	str	r7, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11bb0:	2103      	movs	r1, #3
   11bb2:	4620      	mov	r0, r4
   11bb4:	47c0      	blx	r8
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
   11bb6:	462f      	mov	r7, r5
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   11bb8:	4620      	mov	r0, r4
   11bba:	2101      	movs	r1, #1
   11bbc:	47c0      	blx	r8

	_spi_load_regs_master(hw, regs);
   11bbe:	4631      	mov	r1, r6
	dev->prvt = hw;
   11bc0:	f847 4b18 	str.w	r4, [r7], #24
	_spi_load_regs_master(hw, regs);
   11bc4:	4b10      	ldr	r3, [pc, #64]	; (11c08 <_spi_m_dma_init+0xac>)
   11bc6:	4798      	blx	r3
	uint8_t index = _sercom_get_hardware_index(hw);
   11bc8:	4b10      	ldr	r3, [pc, #64]	; (11c0c <_spi_m_dma_init+0xb0>)
   11bca:	4620      	mov	r0, r4
   11bcc:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11bce:	2807      	cmp	r0, #7
		dev->resource->back                 = dev;
		dev->resource->dma_cb.transfer_done = _spi_dma_rx_complete;
		dev->resource->dma_cb.error         = _spi_dma_error_occured;
	}
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, _spi_get_tx_dma_channel(hw));
   11bd0:	4b0f      	ldr	r3, [pc, #60]	; (11c10 <_spi_m_dma_init+0xb4>)
   11bd2:	bf0c      	ite	eq
   11bd4:	2108      	moveq	r1, #8
   11bd6:	2100      	movne	r1, #0
   11bd8:	4638      	mov	r0, r7
   11bda:	4798      	blx	r3
	dev->resource->back                 = dev;
   11bdc:	69ab      	ldr	r3, [r5, #24]
	dev->resource->dma_cb.transfer_done = _spi_dma_tx_complete;
   11bde:	4a0d      	ldr	r2, [pc, #52]	; (11c14 <_spi_m_dma_init+0xb8>)
   11be0:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   11be2:	4a0d      	ldr	r2, [pc, #52]	; (11c18 <_spi_m_dma_init+0xbc>)
	dev->resource->back                 = dev;
   11be4:	609d      	str	r5, [r3, #8]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   11be6:	605a      	str	r2, [r3, #4]

	return ERR_NONE;
   11be8:	2000      	movs	r0, #0
}
   11bea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(dev && hw);
   11bee:	4628      	mov	r0, r5
   11bf0:	e7c1      	b.n	11b76 <_spi_m_dma_init+0x1a>
		return ERR_INVALID_ARG;
   11bf2:	f06f 000c 	mvn.w	r0, #12
   11bf6:	e7f8      	b.n	11bea <_spi_m_dma_init+0x8e>
   11bf8:	00010e75 	.word	0x00010e75
   11bfc:	00016afd 	.word	0x00016afd
   11c00:	0000e42d 	.word	0x0000e42d
   11c04:	00010cdd 	.word	0x00010cdd
   11c08:	00011191 	.word	0x00011191
   11c0c:	00010d31 	.word	0x00010d31
   11c10:	0000e671 	.word	0x0000e671
   11c14:	00010ea1 	.word	0x00010ea1
   11c18:	00010eab 	.word	0x00010eab
   11c1c:	00010cb9 	.word	0x00010cb9

00011c20 <_spi_m_dma_enable>:
{
	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_dma_enable(struct _spi_m_dma_dev *dev)
{
   11c20:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11c22:	4604      	mov	r4, r0
   11c24:	b118      	cbz	r0, 11c2e <_spi_m_dma_enable+0xe>
   11c26:	6800      	ldr	r0, [r0, #0]
   11c28:	3800      	subs	r0, #0
   11c2a:	bf18      	it	ne
   11c2c:	2001      	movne	r0, #1
   11c2e:	4b05      	ldr	r3, [pc, #20]	; (11c44 <_spi_m_dma_enable+0x24>)
   11c30:	4905      	ldr	r1, [pc, #20]	; (11c48 <_spi_m_dma_enable+0x28>)
   11c32:	f640 620e 	movw	r2, #3598	; 0xe0e
   11c36:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
   11c38:	6820      	ldr	r0, [r4, #0]
   11c3a:	4b04      	ldr	r3, [pc, #16]	; (11c4c <_spi_m_dma_enable+0x2c>)
}
   11c3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_sync_enable(dev->prvt);
   11c40:	4718      	bx	r3
   11c42:	bf00      	nop
   11c44:	0000e42d 	.word	0x0000e42d
   11c48:	00016afd 	.word	0x00016afd
   11c4c:	00010e4d 	.word	0x00010e4d

00011c50 <_spi_m_dma_register_callback>:
	return size;
}

void _spi_m_dma_register_callback(struct _spi_m_dma_dev *dev, enum _spi_dma_dev_cb_type type, _spi_dma_cb_t func)
{
	switch (type) {
   11c50:	2901      	cmp	r1, #1
{
   11c52:	b573      	push	{r0, r1, r4, r5, r6, lr}
   11c54:	4605      	mov	r5, r0
   11c56:	460e      	mov	r6, r1
   11c58:	4614      	mov	r4, r2
	switch (type) {
   11c5a:	d014      	beq.n	11c86 <_spi_m_dma_register_callback+0x36>
   11c5c:	2902      	cmp	r1, #2
   11c5e:	d020      	beq.n	11ca2 <_spi_m_dma_register_callback+0x52>
   11c60:	2900      	cmp	r1, #0
   11c62:	d138      	bne.n	11cd6 <_spi_m_dma_register_callback+0x86>
	case SPI_DEV_CB_DMA_TX:
		dev->callbacks.tx = func;
   11c64:	6042      	str	r2, [r0, #4]
	uint8_t index = _sercom_get_hardware_index(hw);
   11c66:	4b1d      	ldr	r3, [pc, #116]	; (11cdc <_spi_m_dma_register_callback+0x8c>)
   11c68:	6800      	ldr	r0, [r0, #0]
   11c6a:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11c6c:	2807      	cmp	r0, #7
   11c6e:	bf08      	it	eq
   11c70:	2608      	moveq	r6, #8
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   11c72:	1e22      	subs	r2, r4, #0
   11c74:	bf18      	it	ne
   11c76:	2201      	movne	r2, #1
   11c78:	2100      	movs	r1, #0
   11c7a:	4630      	mov	r0, r6
		break;
	case SPI_DEV_CB_DMA_RX:
		dev->callbacks.rx = func;
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   11c7c:	4b18      	ldr	r3, [pc, #96]	; (11ce0 <_spi_m_dma_register_callback+0x90>)
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
		break;
	case SPI_DEV_CB_DMA_N:
		break;
	}
}
   11c7e:	b002      	add	sp, #8
   11c80:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   11c84:	4718      	bx	r3
		dev->callbacks.rx = func;
   11c86:	6082      	str	r2, [r0, #8]
	uint8_t index = _sercom_get_hardware_index(hw);
   11c88:	4b14      	ldr	r3, [pc, #80]	; (11cdc <_spi_m_dma_register_callback+0x8c>)
   11c8a:	6800      	ldr	r0, [r0, #0]
   11c8c:	4798      	blx	r3
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   11c8e:	1e22      	subs	r2, r4, #0
   11c90:	bf18      	it	ne
   11c92:	2201      	movne	r2, #1
   11c94:	2807      	cmp	r0, #7
   11c96:	f04f 0100 	mov.w	r1, #0
   11c9a:	bf8c      	ite	hi
   11c9c:	2000      	movhi	r0, #0
   11c9e:	2001      	movls	r0, #1
   11ca0:	e7ec      	b.n	11c7c <_spi_m_dma_register_callback+0x2c>
		dev->callbacks.error = func;
   11ca2:	60c2      	str	r2, [r0, #12]
	uint8_t index = _sercom_get_hardware_index(hw);
   11ca4:	4e0d      	ldr	r6, [pc, #52]	; (11cdc <_spi_m_dma_register_callback+0x8c>)
   11ca6:	6800      	ldr	r0, [r0, #0]
   11ca8:	47b0      	blx	r6
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   11caa:	1e22      	subs	r2, r4, #0
   11cac:	bf18      	it	ne
   11cae:	2201      	movne	r2, #1
   11cb0:	2807      	cmp	r0, #7
   11cb2:	bf8c      	ite	hi
   11cb4:	2000      	movhi	r0, #0
   11cb6:	2001      	movls	r0, #1
   11cb8:	2101      	movs	r1, #1
   11cba:	4c09      	ldr	r4, [pc, #36]	; (11ce0 <_spi_m_dma_register_callback+0x90>)
   11cbc:	9201      	str	r2, [sp, #4]
   11cbe:	47a0      	blx	r4
	uint8_t index = _sercom_get_hardware_index(hw);
   11cc0:	6828      	ldr	r0, [r5, #0]
   11cc2:	47b0      	blx	r6
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11cc4:	2807      	cmp	r0, #7
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   11cc6:	9a01      	ldr	r2, [sp, #4]
   11cc8:	f04f 0101 	mov.w	r1, #1
   11ccc:	bf0c      	ite	eq
   11cce:	2008      	moveq	r0, #8
   11cd0:	2000      	movne	r0, #0
   11cd2:	4623      	mov	r3, r4
   11cd4:	e7d3      	b.n	11c7e <_spi_m_dma_register_callback+0x2e>
}
   11cd6:	b002      	add	sp, #8
   11cd8:	bd70      	pop	{r4, r5, r6, pc}
   11cda:	bf00      	nop
   11cdc:	00010d31 	.word	0x00010d31
   11ce0:	0000e58d 	.word	0x0000e58d

00011ce4 <_spi_m_dma_transfer>:

int32_t _spi_m_dma_transfer(struct _spi_m_dma_dev *dev, uint8_t const *txbuf, uint8_t *const rxbuf,
                            const uint16_t length)
{
   11ce4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   11ce8:	f8d0 8000 	ldr.w	r8, [r0]
	uint8_t index = _sercom_get_hardware_index(hw);
   11cec:	f8df 911c 	ldr.w	r9, [pc, #284]	; 11e0c <_spi_m_dma_transfer+0x128>
{
   11cf0:	4605      	mov	r5, r0
   11cf2:	461f      	mov	r7, r3
	uint8_t index = _sercom_get_hardware_index(hw);
   11cf4:	4640      	mov	r0, r8
   11cf6:	4b3d      	ldr	r3, [pc, #244]	; (11dec <_spi_m_dma_transfer+0x108>)
{
   11cf8:	460e      	mov	r6, r1
   11cfa:	4692      	mov	sl, r2
	uint8_t index = _sercom_get_hardware_index(hw);
   11cfc:	4798      	blx	r3
	switch (index) {
   11cfe:	2807      	cmp	r0, #7
   11d00:	4b3b      	ldr	r3, [pc, #236]	; (11df0 <_spi_m_dma_transfer+0x10c>)
   11d02:	d86a      	bhi.n	11dda <_spi_m_dma_transfer+0xf6>
	switch (index) {
   11d04:	d06c      	beq.n	11de0 <_spi_m_dma_transfer+0xfc>
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   11d06:	f04f 0b01 	mov.w	fp, #1
	uint8_t                          rx_ch = _spi_get_rx_dma_channel(dev->prvt);
	uint8_t                          tx_ch = _spi_get_tx_dma_channel(dev->prvt);

	if (rxbuf) {
   11d0a:	f1ba 0f00 	cmp.w	sl, #0
   11d0e:	d114      	bne.n	11d3a <_spi_m_dma_transfer+0x56>
   11d10:	4654      	mov	r4, sl
	ASSERT(dev && dev->prvt);
   11d12:	f1b8 0000 	subs.w	r0, r8, #0
   11d16:	bf18      	it	ne
   11d18:	2001      	movne	r0, #1
   11d1a:	4936      	ldr	r1, [pc, #216]	; (11df4 <_spi_m_dma_transfer+0x110>)
   11d1c:	f640 523d 	movw	r2, #3389	; 0xd3d
   11d20:	4798      	blx	r3
	return _spi_sync_rx_disable(dev->prvt);
   11d22:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11d24:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   11d26:	075b      	lsls	r3, r3, #29
   11d28:	d42b      	bmi.n	11d82 <_spi_m_dma_transfer+0x9e>
	((Sercom *)hw)->SPI.CTRLB.reg &= ~SERCOM_SPI_CTRLB_RXEN;
   11d2a:	6843      	ldr	r3, [r0, #4]
   11d2c:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   11d30:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11d32:	2117      	movs	r1, #23
   11d34:	4b30      	ldr	r3, [pc, #192]	; (11df8 <_spi_m_dma_transfer+0x114>)
   11d36:	4798      	blx	r3
}
   11d38:	e023      	b.n	11d82 <_spi_m_dma_transfer+0x9e>
	if (rxbuf) {
   11d3a:	2400      	movs	r4, #0
	ASSERT(dev && dev->prvt);
   11d3c:	f1b8 0000 	subs.w	r0, r8, #0
   11d40:	bf18      	it	ne
   11d42:	2001      	movne	r0, #1
   11d44:	f640 5236 	movw	r2, #3382	; 0xd36
   11d48:	492a      	ldr	r1, [pc, #168]	; (11df4 <_spi_m_dma_transfer+0x110>)
   11d4a:	4798      	blx	r3
	return _spi_sync_rx_enable(dev->prvt);
   11d4c:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11d4e:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   11d50:	075a      	lsls	r2, r3, #29
   11d52:	d406      	bmi.n	11d62 <_spi_m_dma_transfer+0x7e>
	((Sercom *)hw)->SPI.CTRLB.reg |= SERCOM_SPI_CTRLB_RXEN;
   11d54:	6843      	ldr	r3, [r0, #4]
   11d56:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11d5a:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11d5c:	2117      	movs	r1, #23
   11d5e:	4b26      	ldr	r3, [pc, #152]	; (11df8 <_spi_m_dma_transfer+0x114>)
   11d60:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   11d62:	6829      	ldr	r1, [r5, #0]
		/* Enable spi rx */
		_spi_m_dma_rx_enable(dev);
		_dma_set_source_address(rx_ch, (void *)_spi_m_get_source_for_dma(dev->prvt));
   11d64:	4b25      	ldr	r3, [pc, #148]	; (11dfc <_spi_m_dma_transfer+0x118>)
   11d66:	3128      	adds	r1, #40	; 0x28
   11d68:	4658      	mov	r0, fp
   11d6a:	4798      	blx	r3
		_dma_set_destination_address(rx_ch, rxbuf);
   11d6c:	4651      	mov	r1, sl
   11d6e:	4658      	mov	r0, fp
   11d70:	47c8      	blx	r9
		_dma_set_data_amount(rx_ch, length);
   11d72:	4b23      	ldr	r3, [pc, #140]	; (11e00 <_spi_m_dma_transfer+0x11c>)
   11d74:	4639      	mov	r1, r7
   11d76:	4658      	mov	r0, fp
   11d78:	4798      	blx	r3
		_dma_enable_transaction(rx_ch, false);
   11d7a:	4b22      	ldr	r3, [pc, #136]	; (11e04 <_spi_m_dma_transfer+0x120>)
   11d7c:	2100      	movs	r1, #0
   11d7e:	4658      	mov	r0, fp
   11d80:	4798      	blx	r3
	} else {
		/* Disable spi rx */
		_spi_m_dma_rx_disable(dev);
	}

	if (txbuf) {
   11d82:	f8df a07c 	ldr.w	sl, [pc, #124]	; 11e00 <_spi_m_dma_transfer+0x11c>
   11d86:	f8df b088 	ldr.w	fp, [pc, #136]	; 11e10 <_spi_m_dma_transfer+0x12c>
   11d8a:	b1c6      	cbz	r6, 11dbe <_spi_m_dma_transfer+0xda>
		/* Enable spi tx */
		_dma_set_source_address(tx_ch, txbuf);
   11d8c:	4b1b      	ldr	r3, [pc, #108]	; (11dfc <_spi_m_dma_transfer+0x118>)
   11d8e:	4631      	mov	r1, r6
   11d90:	4620      	mov	r0, r4
   11d92:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   11d94:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   11d96:	4620      	mov	r0, r4
   11d98:	3128      	adds	r1, #40	; 0x28
   11d9a:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, true);
   11d9c:	2101      	movs	r1, #1
		_dma_set_data_amount(tx_ch, length);
	} else {
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
		_dma_srcinc_enable(tx_ch, false);
   11d9e:	4620      	mov	r0, r4
   11da0:	47d8      	blx	fp
		_dma_set_data_amount(tx_ch, length);
   11da2:	4639      	mov	r1, r7
   11da4:	4620      	mov	r0, r4
   11da6:	47d0      	blx	sl
	}
	_dma_enable_transaction(tx_ch, false);
   11da8:	4b16      	ldr	r3, [pc, #88]	; (11e04 <_spi_m_dma_transfer+0x120>)
   11daa:	2100      	movs	r1, #0
   11dac:	4620      	mov	r0, r4
   11dae:	4798      	blx	r3

	return ERR_NONE;
}
   11db0:	2000      	movs	r0, #0
   11db2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   11db6:	f04f 0b01 	mov.w	fp, #1
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11dba:	2408      	movs	r4, #8
   11dbc:	e7be      	b.n	11d3c <_spi_m_dma_transfer+0x58>
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   11dbe:	4b12      	ldr	r3, [pc, #72]	; (11e08 <_spi_m_dma_transfer+0x124>)
   11dc0:	4640      	mov	r0, r8
   11dc2:	4798      	blx	r3
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
   11dc4:	4b0d      	ldr	r3, [pc, #52]	; (11dfc <_spi_m_dma_transfer+0x118>)
   11dc6:	f100 010e 	add.w	r1, r0, #14
   11dca:	4620      	mov	r0, r4
   11dcc:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   11dce:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   11dd0:	4620      	mov	r0, r4
   11dd2:	3128      	adds	r1, #40	; 0x28
   11dd4:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, false);
   11dd6:	4631      	mov	r1, r6
   11dd8:	e7e1      	b.n	11d9e <_spi_m_dma_transfer+0xba>
		return CONF_SERCOM_0_SPI_M_DMA_TX_CHANNEL;
   11dda:	f04f 0b00 	mov.w	fp, #0
   11dde:	e794      	b.n	11d0a <_spi_m_dma_transfer+0x26>
	if (rxbuf) {
   11de0:	f1ba 0f00 	cmp.w	sl, #0
   11de4:	d1e7      	bne.n	11db6 <_spi_m_dma_transfer+0xd2>
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   11de6:	2408      	movs	r4, #8
   11de8:	e793      	b.n	11d12 <_spi_m_dma_transfer+0x2e>
   11dea:	bf00      	nop
   11dec:	00010d31 	.word	0x00010d31
   11df0:	0000e42d 	.word	0x0000e42d
   11df4:	00016afd 	.word	0x00016afd
   11df8:	00010cb9 	.word	0x00010cb9
   11dfc:	0000e5c5 	.word	0x0000e5c5
   11e00:	0000e5f1 	.word	0x0000e5f1
   11e04:	0000e635 	.word	0x0000e635
   11e08:	00010e75 	.word	0x00010e75
   11e0c:	0000e5b5 	.word	0x0000e5b5
   11e10:	0000e5d5 	.word	0x0000e5d5

00011e14 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
   11e14:	b570      	push	{r4, r5, r6, lr}
   11e16:	460e      	mov	r6, r1
   11e18:	4614      	mov	r4, r2
	ASSERT(rb && buf && size);
   11e1a:	4605      	mov	r5, r0
   11e1c:	b118      	cbz	r0, 11e26 <ringbuffer_init+0x12>
   11e1e:	b189      	cbz	r1, 11e44 <ringbuffer_init+0x30>
   11e20:	1e10      	subs	r0, r2, #0
   11e22:	bf18      	it	ne
   11e24:	2001      	movne	r0, #1
   11e26:	4908      	ldr	r1, [pc, #32]	; (11e48 <ringbuffer_init+0x34>)
   11e28:	4b08      	ldr	r3, [pc, #32]	; (11e4c <ringbuffer_init+0x38>)
   11e2a:	2228      	movs	r2, #40	; 0x28
   11e2c:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
   11e2e:	1e63      	subs	r3, r4, #1
   11e30:	ea13 0004 	ands.w	r0, r3, r4
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
	rb->read_index  = 0;
   11e34:	bf03      	ittte	eq
   11e36:	e9c5 3001 	strdeq	r3, r0, [r5, #4]
	rb->write_index = rb->read_index;
   11e3a:	60e8      	streq	r0, [r5, #12]
	rb->buf         = (uint8_t *)buf;
   11e3c:	602e      	streq	r6, [r5, #0]
		return ERR_INVALID_ARG;
   11e3e:	f06f 000c 	mvnne.w	r0, #12

	return ERR_NONE;
}
   11e42:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
   11e44:	4608      	mov	r0, r1
   11e46:	e7ee      	b.n	11e26 <ringbuffer_init+0x12>
   11e48:	00016bec 	.word	0x00016bec
   11e4c:	0000e42d 	.word	0x0000e42d

00011e50 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
   11e50:	b538      	push	{r3, r4, r5, lr}
   11e52:	460d      	mov	r5, r1
	ASSERT(rb && data);
   11e54:	4604      	mov	r4, r0
   11e56:	b110      	cbz	r0, 11e5e <ringbuffer_get+0xe>
   11e58:	1e08      	subs	r0, r1, #0
   11e5a:	bf18      	it	ne
   11e5c:	2001      	movne	r0, #1
   11e5e:	4b0a      	ldr	r3, [pc, #40]	; (11e88 <ringbuffer_get+0x38>)
   11e60:	490a      	ldr	r1, [pc, #40]	; (11e8c <ringbuffer_get+0x3c>)
   11e62:	2240      	movs	r2, #64	; 0x40
   11e64:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
   11e66:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   11e6a:	429a      	cmp	r2, r3
   11e6c:	d009      	beq.n	11e82 <ringbuffer_get+0x32>
		*data = rb->buf[rb->read_index & rb->size];
   11e6e:	6862      	ldr	r2, [r4, #4]
   11e70:	4013      	ands	r3, r2
   11e72:	6822      	ldr	r2, [r4, #0]
   11e74:	5cd3      	ldrb	r3, [r2, r3]
   11e76:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
   11e78:	68a3      	ldr	r3, [r4, #8]
   11e7a:	3301      	adds	r3, #1
   11e7c:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
   11e7e:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
   11e80:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NOT_FOUND;
   11e82:	f06f 0009 	mvn.w	r0, #9
   11e86:	e7fb      	b.n	11e80 <ringbuffer_get+0x30>
   11e88:	0000e42d 	.word	0x0000e42d
   11e8c:	00016bec 	.word	0x00016bec

00011e90 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
   11e90:	b538      	push	{r3, r4, r5, lr}
	ASSERT(rb);
   11e92:	4604      	mov	r4, r0
   11e94:	3800      	subs	r0, #0
   11e96:	bf18      	it	ne
   11e98:	2001      	movne	r0, #1
{
   11e9a:	460d      	mov	r5, r1
	ASSERT(rb);
   11e9c:	4b0b      	ldr	r3, [pc, #44]	; (11ecc <ringbuffer_put+0x3c>)
   11e9e:	490c      	ldr	r1, [pc, #48]	; (11ed0 <ringbuffer_put+0x40>)
   11ea0:	2251      	movs	r2, #81	; 0x51
   11ea2:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
   11ea4:	68e3      	ldr	r3, [r4, #12]
   11ea6:	6862      	ldr	r2, [r4, #4]
   11ea8:	4013      	ands	r3, r2
   11eaa:	6822      	ldr	r2, [r4, #0]
   11eac:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
   11eae:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   11eb2:	68e3      	ldr	r3, [r4, #12]
   11eb4:	1a59      	subs	r1, r3, r1
   11eb6:	4291      	cmp	r1, r2
		rb->read_index = rb->write_index - rb->size;
   11eb8:	bf88      	it	hi
   11eba:	1a9a      	subhi	r2, r3, r2
	}

	rb->write_index++;
   11ebc:	f103 0301 	add.w	r3, r3, #1
		rb->read_index = rb->write_index - rb->size;
   11ec0:	bf88      	it	hi
   11ec2:	60a2      	strhi	r2, [r4, #8]
	rb->write_index++;
   11ec4:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
   11ec6:	2000      	movs	r0, #0
   11ec8:	bd38      	pop	{r3, r4, r5, pc}
   11eca:	bf00      	nop
   11ecc:	0000e42d 	.word	0x0000e42d
   11ed0:	00016bec 	.word	0x00016bec

00011ed4 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
   11ed4:	b510      	push	{r4, lr}
	ASSERT(rb);
   11ed6:	4604      	mov	r4, r0
   11ed8:	3800      	subs	r0, #0
   11eda:	bf18      	it	ne
   11edc:	2001      	movne	r0, #1
   11ede:	4904      	ldr	r1, [pc, #16]	; (11ef0 <ringbuffer_num+0x1c>)
   11ee0:	4b04      	ldr	r3, [pc, #16]	; (11ef4 <ringbuffer_num+0x20>)
   11ee2:	2267      	movs	r2, #103	; 0x67
   11ee4:	4798      	blx	r3

	return rb->write_index - rb->read_index;
   11ee6:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
}
   11eea:	1ac0      	subs	r0, r0, r3
   11eec:	bd10      	pop	{r4, pc}
   11eee:	bf00      	nop
   11ef0:	00016bec 	.word	0x00016bec
   11ef4:	0000e42d 	.word	0x0000e42d

00011ef8 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   11ef8:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
   11efc:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   11efe:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   11f00:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
   11f04:	4770      	bx	lr

00011f06 <atomic_leave_critical>:
   11f06:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
   11f0a:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   11f0c:	f383 8810 	msr	PRIMASK, r3
}
   11f10:	4770      	bx	lr
	...

00011f14 <RTC_Scheduler_ping_cb>:
static struct timer_task RTC_Scheduler_heartbeat;

void RTC_Scheduler_ping_cb(const struct timer_task *const timer_task)
{

	pingflag++;
   11f14:	4a0d      	ldr	r2, [pc, #52]	; (11f4c <RTC_Scheduler_ping_cb+0x38>)
   11f16:	7813      	ldrb	r3, [r2, #0]
   11f18:	3301      	adds	r3, #1
   11f1a:	b2db      	uxtb	r3, r3
   11f1c:	7013      	strb	r3, [r2, #0]
	
	switch (pingflag%4)
   11f1e:	7813      	ldrb	r3, [r2, #0]
   11f20:	f003 0303 	and.w	r3, r3, #3
   11f24:	2b02      	cmp	r3, #2
   11f26:	f642 7248 	movw	r2, #12104	; 0x2f48
   11f2a:	d00a      	beq.n	11f42 <RTC_Scheduler_ping_cb+0x2e>
   11f2c:	2b03      	cmp	r3, #3
   11f2e:	d00a      	beq.n	11f46 <RTC_Scheduler_ping_cb+0x32>
   11f30:	2b01      	cmp	r3, #1
   11f32:	d003      	beq.n	11f3c <RTC_Scheduler_ping_cb+0x28>
	{
		case 0:
			GRID_PORT_N.ping_flag = 1;
   11f34:	4b06      	ldr	r3, [pc, #24]	; (11f50 <RTC_Scheduler_ping_cb+0x3c>)
			break;
		case 2:
			GRID_PORT_S.ping_flag = 1;
			break;
		case 3:
			GRID_PORT_W.ping_flag = 1;
   11f36:	2101      	movs	r1, #1
   11f38:	5499      	strb	r1, [r3, r2]
			break;
	}
	
}
   11f3a:	4770      	bx	lr
			GRID_PORT_E.ping_flag = 1;
   11f3c:	4905      	ldr	r1, [pc, #20]	; (11f54 <RTC_Scheduler_ping_cb+0x40>)
   11f3e:	548b      	strb	r3, [r1, r2]
			break;
   11f40:	4770      	bx	lr
			GRID_PORT_S.ping_flag = 1;
   11f42:	4b05      	ldr	r3, [pc, #20]	; (11f58 <RTC_Scheduler_ping_cb+0x44>)
   11f44:	e7f7      	b.n	11f36 <RTC_Scheduler_ping_cb+0x22>
			GRID_PORT_W.ping_flag = 1;
   11f46:	4b05      	ldr	r3, [pc, #20]	; (11f5c <RTC_Scheduler_ping_cb+0x48>)
   11f48:	e7f5      	b.n	11f36 <RTC_Scheduler_ping_cb+0x22>
   11f4a:	bf00      	nop
   11f4c:	20008d80 	.word	0x20008d80
   11f50:	20009150 	.word	0x20009150
   11f54:	20019870 	.word	0x20019870
   11f58:	200138d4 	.word	0x200138d4
   11f5c:	200102d4 	.word	0x200102d4

00011f60 <RTC_Scheduler_heartbeat_cb>:
	}

}

void RTC_Scheduler_heartbeat_cb(const struct timer_task *const timer_task)
{
   11f60:	b410      	push	{r4}
	
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11f62:	4c04      	ldr	r4, [pc, #16]	; (11f74 <RTC_Scheduler_heartbeat_cb+0x14>)
   11f64:	4804      	ldr	r0, [pc, #16]	; (11f78 <RTC_Scheduler_heartbeat_cb+0x18>)
   11f66:	2200      	movs	r2, #0
   11f68:	46a4      	mov	ip, r4
   11f6a:	230c      	movs	r3, #12

}
   11f6c:	f85d 4b04 	ldr.w	r4, [sp], #4
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   11f70:	4611      	mov	r1, r2
   11f72:	4760      	bx	ip
   11f74:	0000a539 	.word	0x0000a539
   11f78:	2001c7c0 	.word	0x2001c7c0

00011f7c <example_task>:
{
   11f7c:	b507      	push	{r0, r1, r2, lr}
		CRITICAL_SECTION_ENTER()
   11f7e:	4e08      	ldr	r6, [pc, #32]	; (11fa0 <example_task+0x24>)
		printf("ExampleTask ????... %d \r\n", globaltest);
   11f80:	4d08      	ldr	r5, [pc, #32]	; (11fa4 <example_task+0x28>)
   11f82:	4c09      	ldr	r4, [pc, #36]	; (11fa8 <example_task+0x2c>)
		CRITICAL_SECTION_ENTER()
   11f84:	a801      	add	r0, sp, #4
   11f86:	47b0      	blx	r6
		printf("ExampleTask ????... %d \r\n", globaltest);
   11f88:	6869      	ldr	r1, [r5, #4]
   11f8a:	4b08      	ldr	r3, [pc, #32]	; (11fac <example_task+0x30>)
   11f8c:	4620      	mov	r0, r4
   11f8e:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
   11f90:	a801      	add	r0, sp, #4
   11f92:	4b07      	ldr	r3, [pc, #28]	; (11fb0 <example_task+0x34>)
   11f94:	4798      	blx	r3
		vTaskDelay(1000*configTICK_RATE_HZ/1000);
   11f96:	4b07      	ldr	r3, [pc, #28]	; (11fb4 <example_task+0x38>)
   11f98:	f241 3088 	movw	r0, #5000	; 0x1388
   11f9c:	4798      	blx	r3
	while (1) {
   11f9e:	e7f1      	b.n	11f84 <example_task+0x8>
   11fa0:	00011ef9 	.word	0x00011ef9
   11fa4:	20008d80 	.word	0x20008d80
   11fa8:	00016c10 	.word	0x00016c10
   11fac:	00014925 	.word	0x00014925
   11fb0:	00011f07 	.word	0x00011f07
   11fb4:	00012e71 	.word	0x00012e71

00011fb8 <inbound_task>:
static void inbound_task(void *p){
   11fb8:	b508      	push	{r3, lr}
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   11fba:	4c02      	ldr	r4, [pc, #8]	; (11fc4 <inbound_task+0xc>)
   11fbc:	2005      	movs	r0, #5
   11fbe:	47a0      	blx	r4
	while (1) {
   11fc0:	e7fc      	b.n	11fbc <inbound_task+0x4>
   11fc2:	bf00      	nop
   11fc4:	00012e71 	.word	0x00012e71

00011fc8 <usb_task_inner>:
static void usb_task_inner(){
   11fc8:	b570      	push	{r4, r5, r6, lr}
	grid_keyboard_tx_pop();
   11fca:	4b2c      	ldr	r3, [pc, #176]	; (1207c <usb_task_inner+0xb4>)
static void usb_task_inner(){
   11fcc:	b08a      	sub	sp, #40	; 0x28
	grid_keyboard_tx_pop();
   11fce:	4798      	blx	r3
	grid_midi_tx_pop();        
   11fd0:	4b2b      	ldr	r3, [pc, #172]	; (12080 <usb_task_inner+0xb8>)
   11fd2:	4798      	blx	r3
	audiodf_midi_read(midi_rx_buffer,16);
   11fd4:	4b2b      	ldr	r3, [pc, #172]	; (12084 <usb_task_inner+0xbc>)
   11fd6:	482c      	ldr	r0, [pc, #176]	; (12088 <usb_task_inner+0xc0>)
   11fd8:	2110      	movs	r1, #16
   11fda:	4798      	blx	r3
		if (midi_rx_buffer[i]){
   11fdc:	492b      	ldr	r1, [pc, #172]	; (1208c <usb_task_inner+0xc4>)
	audiodf_midi_read(midi_rx_buffer,16);
   11fde:	2200      	movs	r2, #0
	uint8_t found = 0;
   11fe0:	4613      	mov	r3, r2
   11fe2:	460d      	mov	r5, r1
		if (midi_rx_buffer[i]){
   11fe4:	1888      	adds	r0, r1, r2
   11fe6:	7a00      	ldrb	r0, [r0, #8]
   11fe8:	b108      	cbz	r0, 11fee <usb_task_inner+0x26>
			found++;
   11fea:	3301      	adds	r3, #1
   11fec:	b2db      	uxtb	r3, r3
	for (uint8_t i=0; i<16; i++){
   11fee:	3201      	adds	r2, #1
   11ff0:	2a10      	cmp	r2, #16
   11ff2:	d1f7      	bne.n	11fe4 <usb_task_inner+0x1c>
	if (found){
   11ff4:	b313      	cbz	r3, 1203c <usb_task_inner+0x74>
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   11ff6:	7a29      	ldrb	r1, [r5, #8]
   11ff8:	7a6a      	ldrb	r2, [r5, #9]
   11ffa:	7aab      	ldrb	r3, [r5, #10]
   11ffc:	7ae8      	ldrb	r0, [r5, #11]
   11ffe:	4c24      	ldr	r4, [pc, #144]	; (12090 <usb_task_inner+0xc8>)
   12000:	9000      	str	r0, [sp, #0]
   12002:	4824      	ldr	r0, [pc, #144]	; (12094 <usb_task_inner+0xcc>)
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   12004:	4e24      	ldr	r6, [pc, #144]	; (12098 <usb_task_inner+0xd0>)
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   12006:	47a0      	blx	r4
		uint8_t message[30] = {0};
   12008:	2400      	movs	r4, #0
   1200a:	4b24      	ldr	r3, [pc, #144]	; (1209c <usb_task_inner+0xd4>)
   1200c:	9402      	str	r4, [sp, #8]
   1200e:	221a      	movs	r2, #26
   12010:	4621      	mov	r1, r4
   12012:	a803      	add	r0, sp, #12
   12014:	4798      	blx	r3
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   12016:	7a2a      	ldrb	r2, [r5, #8]
   12018:	7a6b      	ldrb	r3, [r5, #9]
   1201a:	7aa9      	ldrb	r1, [r5, #10]
   1201c:	7ae8      	ldrb	r0, [r5, #11]
   1201e:	e9cd 1000 	strd	r1, r0, [sp]
   12022:	491c      	ldr	r1, [pc, #112]	; (12094 <usb_task_inner+0xcc>)
   12024:	a802      	add	r0, sp, #8
   12026:	47b0      	blx	r6
		grid_debug_print_text(message);
   12028:	4b1d      	ldr	r3, [pc, #116]	; (120a0 <usb_task_inner+0xd8>)
   1202a:	a802      	add	r0, sp, #8
   1202c:	4798      	blx	r3
   1202e:	4621      	mov	r1, r4
			midi_rx_buffer[i] = 0;
   12030:	4622      	mov	r2, r4
   12032:	186b      	adds	r3, r5, r1
   12034:	3101      	adds	r1, #1
		for (uint8_t i=0; i<16; i++){
   12036:	2910      	cmp	r1, #16
			midi_rx_buffer[i] = 0;
   12038:	721a      	strb	r2, [r3, #8]
		for (uint8_t i=0; i<16; i++){
   1203a:	d1fa      	bne.n	12032 <usb_task_inner+0x6a>
	cdcdf_acm_read(GRID_PORT_H.rx_double_buffer, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);			
   1203c:	4b19      	ldr	r3, [pc, #100]	; (120a4 <usb_task_inner+0xdc>)
   1203e:	481a      	ldr	r0, [pc, #104]	; (120a8 <usb_task_inner+0xe0>)
   12040:	f44f 7100 	mov.w	r1, #512	; 0x200
   12044:	4798      	blx	r3
	uint16_t usblength = strlen(GRID_PORT_H.rx_double_buffer);
   12046:	4818      	ldr	r0, [pc, #96]	; (120a8 <usb_task_inner+0xe0>)
   12048:	4b18      	ldr	r3, [pc, #96]	; (120ac <usb_task_inner+0xe4>)
   1204a:	4798      	blx	r3
	if (usblength){	
   1204c:	4606      	mov	r6, r0
   1204e:	b190      	cbz	r0, 12076 <usb_task_inner+0xae>
		GRID_PORT_H.rx_double_buffer_status = 1;			
   12050:	4d17      	ldr	r5, [pc, #92]	; (120b0 <usb_task_inner+0xe8>)
   12052:	2301      	movs	r3, #1
   12054:	622b      	str	r3, [r5, #32]
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   12056:	2400      	movs	r4, #0
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   12058:	1ec3      	subs	r3, r0, #3
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   1205a:	62ac      	str	r4, [r5, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_H);
   1205c:	4628      	mov	r0, r5
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   1205e:	626b      	str	r3, [r5, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_H);
   12060:	4b14      	ldr	r3, [pc, #80]	; (120b4 <usb_task_inner+0xec>)
   12062:	4798      	blx	r3
		for(uint32_t i=0; i<usblength; i++){
   12064:	4623      	mov	r3, r4
			GRID_PORT_H.rx_double_buffer[i] = 0;
   12066:	f241 32b4 	movw	r2, #5044	; 0x13b4
   1206a:	4620      	mov	r0, r4
   1206c:	18e9      	adds	r1, r5, r3
		for(uint32_t i=0; i<usblength; i++){
   1206e:	3301      	adds	r3, #1
   12070:	429e      	cmp	r6, r3
			GRID_PORT_H.rx_double_buffer[i] = 0;
   12072:	5488      	strb	r0, [r1, r2]
		for(uint32_t i=0; i<usblength; i++){
   12074:	d1fa      	bne.n	1206c <usb_task_inner+0xa4>
}
   12076:	b00a      	add	sp, #40	; 0x28
   12078:	bd70      	pop	{r4, r5, r6, pc}
   1207a:	bf00      	nop
   1207c:	0000b411 	.word	0x0000b411
   12080:	0000b2f1 	.word	0x0000b2f1
   12084:	0000451d 	.word	0x0000451d
   12088:	20008d88 	.word	0x20008d88
   1208c:	20008d80 	.word	0x20008d80
   12090:	00014925 	.word	0x00014925
   12094:	00016c2a 	.word	0x00016c2a
   12098:	00014c8d 	.word	0x00014c8d
   1209c:	000147c5 	.word	0x000147c5
   120a0:	00009621 	.word	0x00009621
   120a4:	0000c115 	.word	0x0000c115
   120a8:	20017bd8 	.word	0x20017bd8
   120ac:	00014d0b 	.word	0x00014d0b
   120b0:	20016824 	.word	0x20016824
   120b4:	00004d41 	.word	0x00004d41

000120b8 <usb_task>:
{
   120b8:	b508      	push	{r3, lr}
		usb_task_inner();
   120ba:	4d03      	ldr	r5, [pc, #12]	; (120c8 <usb_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   120bc:	4c03      	ldr	r4, [pc, #12]	; (120cc <usb_task+0x14>)
		usb_task_inner();
   120be:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   120c0:	2005      	movs	r0, #5
   120c2:	47a0      	blx	r4
	while (1) {
   120c4:	e7fb      	b.n	120be <usb_task+0x6>
   120c6:	bf00      	nop
   120c8:	00011fc9 	.word	0x00011fc9
   120cc:	00012e71 	.word	0x00012e71

000120d0 <receive_task_inner>:
static void receive_task_inner(){
   120d0:	b510      	push	{r4, lr}
	grid_port_receive_task(&GRID_PORT_N);
   120d2:	4806      	ldr	r0, [pc, #24]	; (120ec <receive_task_inner+0x1c>)
   120d4:	4c06      	ldr	r4, [pc, #24]	; (120f0 <receive_task_inner+0x20>)
   120d6:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_E);
   120d8:	4806      	ldr	r0, [pc, #24]	; (120f4 <receive_task_inner+0x24>)
   120da:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_S);
   120dc:	4806      	ldr	r0, [pc, #24]	; (120f8 <receive_task_inner+0x28>)
   120de:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_W);							
   120e0:	4623      	mov	r3, r4
   120e2:	4806      	ldr	r0, [pc, #24]	; (120fc <receive_task_inner+0x2c>)
}
   120e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_receive_task(&GRID_PORT_W);							
   120e8:	4718      	bx	r3
   120ea:	bf00      	nop
   120ec:	20009150 	.word	0x20009150
   120f0:	00004d41 	.word	0x00004d41
   120f4:	20019870 	.word	0x20019870
   120f8:	200138d4 	.word	0x200138d4
   120fc:	200102d4 	.word	0x200102d4

00012100 <receive_task>:
static void receive_task(void *p){
   12100:	b508      	push	{r3, lr}
		receive_task_inner();
   12102:	4d03      	ldr	r5, [pc, #12]	; (12110 <receive_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12104:	4c03      	ldr	r4, [pc, #12]	; (12114 <receive_task+0x14>)
		receive_task_inner();
   12106:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12108:	2005      	movs	r0, #5
   1210a:	47a0      	blx	r4
	while (1) {
   1210c:	e7fb      	b.n	12106 <receive_task+0x6>
   1210e:	bf00      	nop
   12110:	000120d1 	.word	0x000120d1
   12114:	00012e71 	.word	0x00012e71

00012118 <nvm_task_inner>:
static void nvm_task_inner(){
   12118:	b510      	push	{r4, lr}
	if (GRID_PORT_U.rx_double_buffer_status == 0){
   1211a:	4c1a      	ldr	r4, [pc, #104]	; (12184 <nvm_task_inner+0x6c>)
   1211c:	6a23      	ldr	r3, [r4, #32]
   1211e:	b943      	cbnz	r3, 12132 <nvm_task_inner+0x1a>
		if (grid_nvm_ui_bulk_read_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   12120:	4919      	ldr	r1, [pc, #100]	; (12188 <nvm_task_inner+0x70>)
   12122:	481a      	ldr	r0, [pc, #104]	; (1218c <nvm_task_inner+0x74>)
   12124:	4b1a      	ldr	r3, [pc, #104]	; (12190 <nvm_task_inner+0x78>)
   12126:	4798      	blx	r3
   12128:	b118      	cbz	r0, 12132 <nvm_task_inner+0x1a>
			grid_nvm_ui_bulk_read_next(&grid_nvm_state, &grid_ui_state);
   1212a:	4917      	ldr	r1, [pc, #92]	; (12188 <nvm_task_inner+0x70>)
   1212c:	4817      	ldr	r0, [pc, #92]	; (1218c <nvm_task_inner+0x74>)
   1212e:	4b19      	ldr	r3, [pc, #100]	; (12194 <nvm_task_inner+0x7c>)
   12130:	4798      	blx	r3
	if (grid_nvm_ui_bulk_clear_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   12132:	4915      	ldr	r1, [pc, #84]	; (12188 <nvm_task_inner+0x70>)
   12134:	4815      	ldr	r0, [pc, #84]	; (1218c <nvm_task_inner+0x74>)
   12136:	4b18      	ldr	r3, [pc, #96]	; (12198 <nvm_task_inner+0x80>)
   12138:	4798      	blx	r3
   1213a:	b118      	cbz	r0, 12144 <nvm_task_inner+0x2c>
		grid_nvm_ui_bulk_clear_next(&grid_nvm_state, &grid_ui_state);
   1213c:	4912      	ldr	r1, [pc, #72]	; (12188 <nvm_task_inner+0x70>)
   1213e:	4813      	ldr	r0, [pc, #76]	; (1218c <nvm_task_inner+0x74>)
   12140:	4b16      	ldr	r3, [pc, #88]	; (1219c <nvm_task_inner+0x84>)
   12142:	4798      	blx	r3
	if (grid_nvm_ui_bulk_store_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   12144:	4910      	ldr	r1, [pc, #64]	; (12188 <nvm_task_inner+0x70>)
   12146:	4811      	ldr	r0, [pc, #68]	; (1218c <nvm_task_inner+0x74>)
   12148:	4b15      	ldr	r3, [pc, #84]	; (121a0 <nvm_task_inner+0x88>)
   1214a:	4798      	blx	r3
   1214c:	b118      	cbz	r0, 12156 <nvm_task_inner+0x3e>
		grid_nvm_ui_bulk_store_next(&grid_nvm_state, &grid_ui_state);
   1214e:	490e      	ldr	r1, [pc, #56]	; (12188 <nvm_task_inner+0x70>)
   12150:	480e      	ldr	r0, [pc, #56]	; (1218c <nvm_task_inner+0x74>)
   12152:	4b14      	ldr	r3, [pc, #80]	; (121a4 <nvm_task_inner+0x8c>)
   12154:	4798      	blx	r3
	uint32_t nvmlength = GRID_PORT_U.rx_double_buffer_status;
   12156:	6a23      	ldr	r3, [r4, #32]
	if (nvmlength){
   12158:	b143      	cbz	r3, 1216c <nvm_task_inner+0x54>
		GRID_PORT_U.rx_double_buffer_status = 1;
   1215a:	2201      	movs	r2, #1
   1215c:	6222      	str	r2, [r4, #32]
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   1215e:	3b01      	subs	r3, #1
		GRID_PORT_U.rx_double_buffer_read_start_index = 0;
   12160:	2200      	movs	r2, #0
   12162:	62a2      	str	r2, [r4, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_U);	
   12164:	4807      	ldr	r0, [pc, #28]	; (12184 <nvm_task_inner+0x6c>)
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   12166:	6263      	str	r3, [r4, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_U);	
   12168:	4b0f      	ldr	r3, [pc, #60]	; (121a8 <nvm_task_inner+0x90>)
   1216a:	4798      	blx	r3
static void nvm_task_inner(){
   1216c:	2300      	movs	r3, #0
		GRID_PORT_U.rx_double_buffer[i] = 0;
   1216e:	f241 32b4 	movw	r2, #5044	; 0x13b4
   12172:	4618      	mov	r0, r3
   12174:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   12176:	3301      	adds	r3, #1
   12178:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
		GRID_PORT_U.rx_double_buffer[i] = 0;
   1217c:	5488      	strb	r0, [r1, r2]
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   1217e:	d1f9      	bne.n	12174 <nvm_task_inner+0x5c>
}
   12180:	bd10      	pop	{r4, pc}
   12182:	bf00      	nop
   12184:	2000c0b0 	.word	0x2000c0b0
   12188:	2000effc 	.word	0x2000effc
   1218c:	2000fa1c 	.word	0x2000fa1c
   12190:	00008bd7 	.word	0x00008bd7
   12194:	00008bdd 	.word	0x00008bdd
   12198:	00008eaf 	.word	0x00008eaf
   1219c:	00008eb5 	.word	0x00008eb5
   121a0:	00008ceb 	.word	0x00008ceb
   121a4:	00008cf1 	.word	0x00008cf1
   121a8:	00004d41 	.word	0x00004d41

000121ac <inbound_task_inner>:
static void inbound_task_inner(){
   121ac:	b510      	push	{r4, lr}
	grid_port_process_inbound(&GRID_PORT_U, 1); // Loopback
   121ae:	2101      	movs	r1, #1
   121b0:	4c0a      	ldr	r4, [pc, #40]	; (121dc <inbound_task_inner+0x30>)
   121b2:	480b      	ldr	r0, [pc, #44]	; (121e0 <inbound_task_inner+0x34>)
   121b4:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_N, 0);		
   121b6:	2100      	movs	r1, #0
   121b8:	480a      	ldr	r0, [pc, #40]	; (121e4 <inbound_task_inner+0x38>)
   121ba:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_E, 0);		
   121bc:	2100      	movs	r1, #0
   121be:	480a      	ldr	r0, [pc, #40]	; (121e8 <inbound_task_inner+0x3c>)
   121c0:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_S, 0);
   121c2:	2100      	movs	r1, #0
   121c4:	4809      	ldr	r0, [pc, #36]	; (121ec <inbound_task_inner+0x40>)
   121c6:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_W, 0);
   121c8:	2100      	movs	r1, #0
   121ca:	4809      	ldr	r0, [pc, #36]	; (121f0 <inbound_task_inner+0x44>)
   121cc:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   121ce:	4623      	mov	r3, r4
   121d0:	4808      	ldr	r0, [pc, #32]	; (121f4 <inbound_task_inner+0x48>)
}
   121d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   121d6:	2100      	movs	r1, #0
   121d8:	4718      	bx	r3
   121da:	bf00      	nop
   121dc:	000051c1 	.word	0x000051c1
   121e0:	2000c0b0 	.word	0x2000c0b0
   121e4:	20009150 	.word	0x20009150
   121e8:	20019870 	.word	0x20019870
   121ec:	200138d4 	.word	0x200138d4
   121f0:	200102d4 	.word	0x200102d4
   121f4:	20016824 	.word	0x20016824

000121f8 <outbound_task_inner>:
static void outbound_task_inner(){
   121f8:	b510      	push	{r4, lr}
	grid_port_process_outbound_usart(&GRID_PORT_N);
   121fa:	4808      	ldr	r0, [pc, #32]	; (1221c <outbound_task_inner+0x24>)
   121fc:	4c08      	ldr	r4, [pc, #32]	; (12220 <outbound_task_inner+0x28>)
   121fe:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_E);
   12200:	4808      	ldr	r0, [pc, #32]	; (12224 <outbound_task_inner+0x2c>)
   12202:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_S);
   12204:	4808      	ldr	r0, [pc, #32]	; (12228 <outbound_task_inner+0x30>)
   12206:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_W);
   12208:	4808      	ldr	r0, [pc, #32]	; (1222c <outbound_task_inner+0x34>)
   1220a:	47a0      	blx	r4
	grid_port_process_outbound_usb(&GRID_PORT_H);
   1220c:	4b08      	ldr	r3, [pc, #32]	; (12230 <outbound_task_inner+0x38>)
   1220e:	4809      	ldr	r0, [pc, #36]	; (12234 <outbound_task_inner+0x3c>)
   12210:	4798      	blx	r3
}
   12212:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_outbound_ui(&GRID_PORT_U);
   12216:	4808      	ldr	r0, [pc, #32]	; (12238 <outbound_task_inner+0x40>)
   12218:	4b08      	ldr	r3, [pc, #32]	; (1223c <outbound_task_inner+0x44>)
   1221a:	4718      	bx	r3
   1221c:	20009150 	.word	0x20009150
   12220:	000062cd 	.word	0x000062cd
   12224:	20019870 	.word	0x20019870
   12228:	200138d4 	.word	0x200138d4
   1222c:	200102d4 	.word	0x200102d4
   12230:	00005385 	.word	0x00005385
   12234:	20016824 	.word	0x20016824
   12238:	2000c0b0 	.word	0x2000c0b0
   1223c:	00005679 	.word	0x00005679

00012240 <led_task_inner>:
static void led_task_inner(){
   12240:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (grid_sys_state.alert_state){
   12244:	4c45      	ldr	r4, [pc, #276]	; (1235c <led_task_inner+0x11c>)
static void led_task_inner(){
   12246:	ed2d 8b02 	vpush	{d8}
	if (grid_sys_state.alert_state){
   1224a:	8963      	ldrh	r3, [r4, #10]
   1224c:	b29b      	uxth	r3, r3
static void led_task_inner(){
   1224e:	b083      	sub	sp, #12
	if (grid_sys_state.alert_state){
   12250:	b98b      	cbnz	r3, 12276 <led_task_inner+0x36>
	grid_task_enter_task(&grid_task_state, GRID_TASK_LED);
   12252:	2106      	movs	r1, #6
   12254:	4b42      	ldr	r3, [pc, #264]	; (12360 <led_task_inner+0x120>)
   12256:	4843      	ldr	r0, [pc, #268]	; (12364 <led_task_inner+0x124>)
   12258:	4798      	blx	r3
	grid_led_tick(&grid_led_state);
   1225a:	4843      	ldr	r0, [pc, #268]	; (12368 <led_task_inner+0x128>)
   1225c:	4b43      	ldr	r3, [pc, #268]	; (1236c <led_task_inner+0x12c>)
   1225e:	4798      	blx	r3
	grid_led_lowlevel_render_all(&grid_led_state);	
   12260:	4841      	ldr	r0, [pc, #260]	; (12368 <led_task_inner+0x128>)
   12262:	4b43      	ldr	r3, [pc, #268]	; (12370 <led_task_inner+0x130>)
   12264:	4798      	blx	r3
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   12266:	4840      	ldr	r0, [pc, #256]	; (12368 <led_task_inner+0x128>)
   12268:	4b42      	ldr	r3, [pc, #264]	; (12374 <led_task_inner+0x134>)
}
   1226a:	b003      	add	sp, #12
   1226c:	ecbd 8b02 	vpop	{d8}
   12270:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   12274:	4718      	bx	r3
		grid_sys_state.alert_state--;
   12276:	8963      	ldrh	r3, [r4, #10]
   12278:	3b01      	subs	r3, #1
   1227a:	b29b      	uxth	r3, r3
   1227c:	8163      	strh	r3, [r4, #10]
		if (grid_sys_alert_read_color_changed_flag(&grid_sys_state)){
   1227e:	4620      	mov	r0, r4
   12280:	4b3d      	ldr	r3, [pc, #244]	; (12378 <led_task_inner+0x138>)
   12282:	4798      	blx	r3
   12284:	b988      	cbnz	r0, 122aa <led_task_inner+0x6a>
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   12286:	4835      	ldr	r0, [pc, #212]	; (1235c <led_task_inner+0x11c>)
   12288:	4b3c      	ldr	r3, [pc, #240]	; (1237c <led_task_inner+0x13c>)
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   1228a:	4e37      	ldr	r6, [pc, #220]	; (12368 <led_task_inner+0x128>)
   1228c:	4f3c      	ldr	r7, [pc, #240]	; (12380 <led_task_inner+0x140>)
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   1228e:	4798      	blx	r3
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   12290:	2400      	movs	r4, #0
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   12292:	4605      	mov	r5, r0
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   12294:	4b34      	ldr	r3, [pc, #208]	; (12368 <led_task_inner+0x128>)
   12296:	785b      	ldrb	r3, [r3, #1]
   12298:	b2e1      	uxtb	r1, r4
   1229a:	428b      	cmp	r3, r1
   1229c:	d9d9      	bls.n	12252 <led_task_inner+0x12>
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   1229e:	462b      	mov	r3, r5
   122a0:	2200      	movs	r2, #0
   122a2:	4630      	mov	r0, r6
   122a4:	47b8      	blx	r7
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   122a6:	3401      	adds	r4, #1
   122a8:	e7f4      	b.n	12294 <led_task_inner+0x54>
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   122aa:	4b36      	ldr	r3, [pc, #216]	; (12384 <led_task_inner+0x144>)
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   122ac:	4e2e      	ldr	r6, [pc, #184]	; (12368 <led_task_inner+0x128>)
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   122ae:	4620      	mov	r0, r4
   122b0:	4798      	blx	r3
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   122b2:	4b35      	ldr	r3, [pc, #212]	; (12388 <led_task_inner+0x148>)
   122b4:	4620      	mov	r0, r4
   122b6:	4798      	blx	r3
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   122b8:	4b34      	ldr	r3, [pc, #208]	; (1238c <led_task_inner+0x14c>)
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   122ba:	ee08 0a10 	vmov	s16, r0
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   122be:	4620      	mov	r0, r4
   122c0:	4798      	blx	r3
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   122c2:	4b33      	ldr	r3, [pc, #204]	; (12390 <led_task_inner+0x150>)
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   122c4:	4682      	mov	sl, r0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   122c6:	4620      	mov	r0, r4
   122c8:	4798      	blx	r3
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   122ca:	f04f 0900 	mov.w	r9, #0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   122ce:	4683      	mov	fp, r0
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   122d0:	4b30      	ldr	r3, [pc, #192]	; (12394 <led_task_inner+0x154>)
   122d2:	4630      	mov	r0, r6
   122d4:	4798      	blx	r3
   122d6:	fa5f f589 	uxtb.w	r5, r9
   122da:	42a8      	cmp	r0, r5
   122dc:	f109 0901 	add.w	r9, r9, #1
   122e0:	d9d1      	bls.n	12286 <led_task_inner+0x46>
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   122e2:	2400      	movs	r4, #0
   122e4:	4622      	mov	r2, r4
   122e6:	e9cd 4400 	strd	r4, r4, [sp]
   122ea:	4623      	mov	r3, r4
   122ec:	4629      	mov	r1, r5
   122ee:	4630      	mov	r0, r6
   122f0:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 123a8 <led_task_inner+0x168>
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   122f4:	4f28      	ldr	r7, [pc, #160]	; (12398 <led_task_inner+0x158>)
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   122f6:	47c0      	blx	r8
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   122f8:	ee18 0a10 	vmov	r0, s16
   122fc:	4b27      	ldr	r3, [pc, #156]	; (1239c <led_task_inner+0x15c>)
   122fe:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 123ac <led_task_inner+0x16c>
   12302:	4798      	blx	r3
   12304:	4b26      	ldr	r3, [pc, #152]	; (123a0 <led_task_inner+0x160>)
   12306:	2200      	movs	r2, #0
   12308:	47b8      	blx	r7
   1230a:	47c0      	blx	r8
   1230c:	4b23      	ldr	r3, [pc, #140]	; (1239c <led_task_inner+0x15c>)
   1230e:	b2c2      	uxtb	r2, r0
   12310:	4658      	mov	r0, fp
   12312:	ee08 2a90 	vmov	s17, r2
   12316:	4798      	blx	r3
   12318:	2200      	movs	r2, #0
   1231a:	4b21      	ldr	r3, [pc, #132]	; (123a0 <led_task_inner+0x160>)
   1231c:	47b8      	blx	r7
   1231e:	47c0      	blx	r8
   12320:	b2c0      	uxtb	r0, r0
   12322:	9001      	str	r0, [sp, #4]
   12324:	4b1d      	ldr	r3, [pc, #116]	; (1239c <led_task_inner+0x15c>)
   12326:	4650      	mov	r0, sl
   12328:	4798      	blx	r3
   1232a:	4b1d      	ldr	r3, [pc, #116]	; (123a0 <led_task_inner+0x160>)
   1232c:	2200      	movs	r2, #0
   1232e:	47b8      	blx	r7
   12330:	47c0      	blx	r8
   12332:	b2c0      	uxtb	r0, r0
   12334:	ee18 3a90 	vmov	r3, s17
   12338:	9000      	str	r0, [sp, #0]
   1233a:	4622      	mov	r2, r4
   1233c:	4629      	mov	r1, r5
   1233e:	4630      	mov	r0, r6
   12340:	f8df 806c 	ldr.w	r8, [pc, #108]	; 123b0 <led_task_inner+0x170>
   12344:	47c0      	blx	r8
				grid_led_set_max(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*1   , color_g*1   , color_b*1);
   12346:	4622      	mov	r2, r4
   12348:	e9cd ab00 	strd	sl, fp, [sp]
   1234c:	ee18 3a10 	vmov	r3, s16
   12350:	4c14      	ldr	r4, [pc, #80]	; (123a4 <led_task_inner+0x164>)
   12352:	4629      	mov	r1, r5
   12354:	4630      	mov	r0, r6
   12356:	47a0      	blx	r4
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   12358:	e7ba      	b.n	122d0 <led_task_inner+0x90>
   1235a:	bf00      	nop
   1235c:	2000f008 	.word	0x2000f008
   12360:	00009123 	.word	0x00009123
   12364:	200102b0 	.word	0x200102b0
   12368:	2001c838 	.word	0x2001c838
   1236c:	00007031 	.word	0x00007031
   12370:	00007421 	.word	0x00007421
   12374:	00007441 	.word	0x00007441
   12378:	00009b6d 	.word	0x00009b6d
   1237c:	00009b77 	.word	0x00009b77
   12380:	00007139 	.word	0x00007139
   12384:	00009b71 	.word	0x00009b71
   12388:	00009bd5 	.word	0x00009bd5
   1238c:	00009bd9 	.word	0x00009bd9
   12390:	00009bdd 	.word	0x00009bdd
   12394:	0000702d 	.word	0x0000702d
   12398:	000142ed 	.word	0x000142ed
   1239c:	00014219 	.word	0x00014219
   123a0:	3fe00000 	.word	0x3fe00000
   123a4:	000070a9 	.word	0x000070a9
   123a8:	00007069 	.word	0x00007069
   123ac:	00014711 	.word	0x00014711
   123b0:	00007089 	.word	0x00007089

000123b4 <RTC_Scheduler_realtime_cb>:
{
   123b4:	b537      	push	{r0, r1, r2, r4, r5, lr}
	grid_sys_rtc_tick_time(&grid_sys_state);	
   123b6:	4d16      	ldr	r5, [pc, #88]	; (12410 <RTC_Scheduler_realtime_cb+0x5c>)
   123b8:	4b16      	ldr	r3, [pc, #88]	; (12414 <RTC_Scheduler_realtime_cb+0x60>)
   123ba:	4628      	mov	r0, r5
   123bc:	4798      	blx	r3
	grid_task_timer_tick(&grid_task_state);
   123be:	4816      	ldr	r0, [pc, #88]	; (12418 <RTC_Scheduler_realtime_cb+0x64>)
   123c0:	4b16      	ldr	r3, [pc, #88]	; (1241c <RTC_Scheduler_realtime_cb+0x68>)
   123c2:	4798      	blx	r3
	CRITICAL_SECTION_ENTER();
   123c4:	4b16      	ldr	r3, [pc, #88]	; (12420 <RTC_Scheduler_realtime_cb+0x6c>)
   123c6:	a801      	add	r0, sp, #4
   123c8:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
   123ca:	4a16      	ldr	r2, [pc, #88]	; (12424 <RTC_Scheduler_realtime_cb+0x70>)
   123cc:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
	return ((Port *)hw)->Group[submodule_index].IN.reg;
   123d0:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
   123d4:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
   123d8:	405c      	eors	r4, r3
   123da:	400c      	ands	r4, r1
   123dc:	405c      	eors	r4, r3
	CRITICAL_SECTION_LEAVE();
   123de:	a801      	add	r0, sp, #4
   123e0:	4b11      	ldr	r3, [pc, #68]	; (12428 <RTC_Scheduler_realtime_cb+0x74>)
   123e2:	4798      	blx	r3
	if (mapmode_value != grid_sys_state.mapmodestate){
   123e4:	7c2a      	ldrb	r2, [r5, #16]
	uint8_t mapmode_value = !gpio_get_pin_level(MAP_MODE);
   123e6:	f484 6300 	eor.w	r3, r4, #2048	; 0x800
   123ea:	f3c3 23c0 	ubfx	r3, r3, #11, #1
	if (mapmode_value != grid_sys_state.mapmodestate){
   123ee:	429a      	cmp	r2, r3
   123f0:	d009      	beq.n	12406 <RTC_Scheduler_realtime_cb+0x52>
		grid_sys_state.mapmodestate = mapmode_value;
   123f2:	742b      	strb	r3, [r5, #16]
		if (grid_sys_state.mapmodestate == 0){ // RELEASE
   123f4:	7c2b      	ldrb	r3, [r5, #16]
   123f6:	4c0d      	ldr	r4, [pc, #52]	; (1242c <RTC_Scheduler_realtime_cb+0x78>)
   123f8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   123fc:	b92b      	cbnz	r3, 1240a <RTC_Scheduler_realtime_cb+0x56>
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_RELEASE);
   123fe:	2308      	movs	r3, #8
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   12400:	480b      	ldr	r0, [pc, #44]	; (12430 <RTC_Scheduler_realtime_cb+0x7c>)
   12402:	4611      	mov	r1, r2
   12404:	47a0      	blx	r4
}
   12406:	b003      	add	sp, #12
   12408:	bd30      	pop	{r4, r5, pc}
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   1240a:	2307      	movs	r3, #7
   1240c:	2200      	movs	r2, #0
   1240e:	e7f7      	b.n	12400 <RTC_Scheduler_realtime_cb+0x4c>
   12410:	2000f008 	.word	0x2000f008
   12414:	00009b5b 	.word	0x00009b5b
   12418:	200102b0 	.word	0x200102b0
   1241c:	0000912b 	.word	0x0000912b
   12420:	00011ef9 	.word	0x00011ef9
   12424:	41008000 	.word	0x41008000
   12428:	00011f07 	.word	0x00011f07
   1242c:	0000a539 	.word	0x0000a539
   12430:	2001c7c0 	.word	0x2001c7c0

00012434 <outbound_task>:
   12434:	b508      	push	{r3, lr}
   12436:	4c02      	ldr	r4, [pc, #8]	; (12440 <outbound_task+0xc>)
   12438:	2005      	movs	r0, #5
   1243a:	47a0      	blx	r4
   1243c:	e7fc      	b.n	12438 <outbound_task+0x4>
   1243e:	bf00      	nop
   12440:	00012e71 	.word	0x00012e71

00012444 <led_task>:
{
   12444:	b508      	push	{r3, lr}
		globaltest++;
   12446:	4c08      	ldr	r4, [pc, #32]	; (12468 <led_task+0x24>)
		inbound_task_inner();
   12448:	4e08      	ldr	r6, [pc, #32]	; (1246c <led_task+0x28>)
		outbound_task_inner();
   1244a:	4d09      	ldr	r5, [pc, #36]	; (12470 <led_task+0x2c>)
		globaltest++;
   1244c:	6863      	ldr	r3, [r4, #4]
   1244e:	3301      	adds	r3, #1
   12450:	6063      	str	r3, [r4, #4]
		inbound_task_inner();
   12452:	47b0      	blx	r6
		outbound_task_inner();
   12454:	47a8      	blx	r5
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12456:	4807      	ldr	r0, [pc, #28]	; (12474 <led_task+0x30>)
   12458:	4b07      	ldr	r3, [pc, #28]	; (12478 <led_task+0x34>)
   1245a:	4798      	blx	r3
		led_task_inner();
   1245c:	4b07      	ldr	r3, [pc, #28]	; (1247c <led_task+0x38>)
   1245e:	4798      	blx	r3
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12460:	4b07      	ldr	r3, [pc, #28]	; (12480 <led_task+0x3c>)
   12462:	2005      	movs	r0, #5
   12464:	4798      	blx	r3
	while (1) {
   12466:	e7f1      	b.n	1244c <led_task+0x8>
   12468:	20008d80 	.word	0x20008d80
   1246c:	000121ad 	.word	0x000121ad
   12470:	000121f9 	.word	0x000121f9
   12474:	2000c0b0 	.word	0x2000c0b0
   12478:	0000ab4d 	.word	0x0000ab4d
   1247c:	00012241 	.word	0x00012241
   12480:	00012e71 	.word	0x00012e71

00012484 <vApplicationStackOverflowHook>:
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   12484:	b583      	push	{r0, r1, r7, lr}
	CRITICAL_SECTION_ENTER()
   12486:	4b08      	ldr	r3, [pc, #32]	; (124a8 <vApplicationStackOverflowHook+0x24>)
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   12488:	4f08      	ldr	r7, [pc, #32]	; (124ac <vApplicationStackOverflowHook+0x28>)
   1248a:	4e09      	ldr	r6, [pc, #36]	; (124b0 <vApplicationStackOverflowHook+0x2c>)
   1248c:	4d09      	ldr	r5, [pc, #36]	; (124b4 <vApplicationStackOverflowHook+0x30>)
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   1248e:	4604      	mov	r4, r0
	CRITICAL_SECTION_ENTER()
   12490:	a801      	add	r0, sp, #4
   12492:	4798      	blx	r3
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   12494:	4620      	mov	r0, r4
   12496:	47b8      	blx	r7
   12498:	4601      	mov	r1, r0
   1249a:	4630      	mov	r0, r6
   1249c:	47a8      	blx	r5
		delay_ms(1000);
   1249e:	4b06      	ldr	r3, [pc, #24]	; (124b8 <vApplicationStackOverflowHook+0x34>)
   124a0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   124a4:	4798      	blx	r3
	while(1){
   124a6:	e7f5      	b.n	12494 <vApplicationStackOverflowHook+0x10>
   124a8:	00011ef9 	.word	0x00011ef9
   124ac:	00012c55 	.word	0x00012c55
   124b0:	00016c45 	.word	0x00016c45
   124b4:	00014925 	.word	0x00014925
   124b8:	0000e17d 	.word	0x0000e17d

000124bc <init_timer>:


void init_timer(void)
{
   124bc:	b570      	push	{r4, r5, r6, lr}
	
		
	//RTC_Scheduler_ping.interval = RTC1SEC/20; //50ms
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   124be:	4c14      	ldr	r4, [pc, #80]	; (12510 <init_timer+0x54>)
	
	RTC_Scheduler_realtime.interval = 1;
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;

	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   124c0:	4d14      	ldr	r5, [pc, #80]	; (12514 <init_timer+0x58>)
   124c2:	4e15      	ldr	r6, [pc, #84]	; (12518 <init_timer+0x5c>)
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   124c4:	f44f 63c8 	mov.w	r3, #1600	; 0x640
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   124c8:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   124cc:	6223      	str	r3, [r4, #32]
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   124ce:	6362      	str	r2, [r4, #52]	; 0x34
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   124d0:	4b12      	ldr	r3, [pc, #72]	; (1251c <init_timer+0x60>)
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   124d2:	4a13      	ldr	r2, [pc, #76]	; (12520 <init_timer+0x64>)
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   124d4:	6263      	str	r3, [r4, #36]	; 0x24
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   124d6:	63a2      	str	r2, [r4, #56]	; 0x38
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   124d8:	2301      	movs	r3, #1
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   124da:	4a12      	ldr	r2, [pc, #72]	; (12524 <init_timer+0x68>)
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   124dc:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   124e0:	f104 0118 	add.w	r1, r4, #24
   124e4:	4628      	mov	r0, r5
	RTC_Scheduler_heartbeat.mode     = TIMER_TASK_REPEAT;
   124e6:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	RTC_Scheduler_realtime.interval = 1;
   124ea:	64a3      	str	r3, [r4, #72]	; 0x48
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;
   124ec:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   124f0:	64e2      	str	r2, [r4, #76]	; 0x4c
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   124f2:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_heartbeat);
   124f4:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   124f8:	4628      	mov	r0, r5
   124fa:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_realtime);
   124fc:	f104 0140 	add.w	r1, r4, #64	; 0x40
   12500:	4628      	mov	r0, r5
   12502:	47b0      	blx	r6
	
	timer_start(&RTC_Scheduler);
   12504:	4628      	mov	r0, r5
   12506:	4b08      	ldr	r3, [pc, #32]	; (12528 <init_timer+0x6c>)
	
}
   12508:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	timer_start(&RTC_Scheduler);
   1250c:	4718      	bx	r3
   1250e:	bf00      	nop
   12510:	20008d80 	.word	0x20008d80
   12514:	2001ccb8 	.word	0x2001ccb8
   12518:	0000ce45 	.word	0x0000ce45
   1251c:	00011f15 	.word	0x00011f15
   12520:	00011f61 	.word	0x00011f61
   12524:	000123b5 	.word	0x000123b5
   12528:	0000ce05 	.word	0x0000ce05

0001252c <main>:

//====================== USB TEST =====================//

int main(void)
{
   1252c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	

	// boundary scan here

	uint32_t boundary_result[4] = {0};
   12530:	2210      	movs	r2, #16
{
   12532:	b08d      	sub	sp, #52	; 0x34
	uint32_t boundary_result[4] = {0};
   12534:	eb0d 0002 	add.w	r0, sp, r2
   12538:	2100      	movs	r1, #0
   1253a:	4d93      	ldr	r5, [pc, #588]	; (12788 <main+0x25c>)


	atmel_start_init();	
    
            
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   1253c:	4c93      	ldr	r4, [pc, #588]	; (1278c <main+0x260>)


	printf("test.mcu.ATSAMD51N20A\r\n");
   1253e:	4f94      	ldr	r7, [pc, #592]	; (12790 <main+0x264>)

	printf("test.serialno.%08x %08x %08x %08x\r\n", uniqueid[0], uniqueid[1], uniqueid[2], uniqueid[3]);

	for (uint8_t i=0; i<4; i++){

		delay_ms(10);
   12540:	f8df 8348 	ldr.w	r8, [pc, #840]	; 1288c <main+0x360>
		printf("test.boundary.%d.", i);
   12544:	f8df a348 	ldr.w	sl, [pc, #840]	; 12890 <main+0x364>
	uint32_t boundary_result[4] = {0};
   12548:	47a8      	blx	r5
	grid_d51_boundary_scan(boundary_result);
   1254a:	4b92      	ldr	r3, [pc, #584]	; (12794 <main+0x268>)
   1254c:	a804      	add	r0, sp, #16
   1254e:	4798      	blx	r3
	atmel_start_init();	
   12550:	4b91      	ldr	r3, [pc, #580]	; (12798 <main+0x26c>)
   12552:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   12554:	4991      	ldr	r1, [pc, #580]	; (1279c <main+0x270>)
   12556:	4892      	ldr	r0, [pc, #584]	; (127a0 <main+0x274>)
   12558:	47a0      	blx	r4
	printf("test.mcu.ATSAMD51N20A\r\n");
   1255a:	4892      	ldr	r0, [pc, #584]	; (127a4 <main+0x278>)
   1255c:	47b8      	blx	r7
	printf("test.hwcfg.%d\r\n", grid_sys_get_hwcfg());
   1255e:	4b92      	ldr	r3, [pc, #584]	; (127a8 <main+0x27c>)
   12560:	4798      	blx	r3
   12562:	4601      	mov	r1, r0
   12564:	4891      	ldr	r0, [pc, #580]	; (127ac <main+0x280>)
   12566:	47a0      	blx	r4
	uint32_t uniqueid[4] = {0};
   12568:	2210      	movs	r2, #16
   1256a:	2100      	movs	r1, #0
   1256c:	a808      	add	r0, sp, #32
   1256e:	47a8      	blx	r5
	grid_sys_get_id(uniqueid);	
   12570:	4b8f      	ldr	r3, [pc, #572]	; (127b0 <main+0x284>)
   12572:	a808      	add	r0, sp, #32
   12574:	4798      	blx	r3
	printf("test.serialno.%08x %08x %08x %08x\r\n", uniqueid[0], uniqueid[1], uniqueid[2], uniqueid[3]);
   12576:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12578:	9300      	str	r3, [sp, #0]
   1257a:	9908      	ldr	r1, [sp, #32]
   1257c:	488d      	ldr	r0, [pc, #564]	; (127b4 <main+0x288>)
   1257e:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   12582:	47a0      	blx	r4
	for (uint8_t i=0; i<4; i++){
   12584:	ad04      	add	r5, sp, #16
   12586:	9703      	str	r7, [sp, #12]
	printf("test.serialno.%08x %08x %08x %08x\r\n", uniqueid[0], uniqueid[1], uniqueid[2], uniqueid[3]);
   12588:	2600      	movs	r6, #0
   1258a:	4647      	mov	r7, r8
		delay_ms(10);
   1258c:	200a      	movs	r0, #10
   1258e:	47c0      	blx	r8
		printf("test.boundary.%d.", i);
   12590:	4631      	mov	r1, r6
   12592:	4650      	mov	r0, sl
   12594:	47a0      	blx	r4

		for (uint8_t j=0; j<32; j++){
   12596:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 12894 <main+0x368>
		printf("test.boundary.%d.", i);
   1259a:	f04f 0b00 	mov.w	fp, #0

			if (boundary_result[i]&(1<<j)){
   1259e:	6829      	ldr	r1, [r5, #0]
   125a0:	2301      	movs	r3, #1
   125a2:	fa03 f20b 	lsl.w	r2, r3, fp
   125a6:	420a      	tst	r2, r1
				printf("1");
   125a8:	bf14      	ite	ne
   125aa:	2031      	movne	r0, #49	; 0x31
			}
			else{
				printf("0");
   125ac:	2030      	moveq	r0, #48	; 0x30
   125ae:	f10b 0b01 	add.w	fp, fp, #1
   125b2:	47c8      	blx	r9
		for (uint8_t j=0; j<32; j++){
   125b4:	f1bb 0f20 	cmp.w	fp, #32
   125b8:	d1f1      	bne.n	1259e <main+0x72>
			}
		}


		printf("\r\n");
   125ba:	487f      	ldr	r0, [pc, #508]	; (127b8 <main+0x28c>)
   125bc:	9b03      	ldr	r3, [sp, #12]
   125be:	3601      	adds	r6, #1
   125c0:	4798      	blx	r3
	for (uint8_t i=0; i<4; i++){
   125c2:	2e04      	cmp	r6, #4
   125c4:	f105 0504 	add.w	r5, r5, #4
   125c8:	d1e0      	bne.n	1258c <main+0x60>

	}


	printf("Hello %d %d %d %d", boundary_result[0], boundary_result[1], boundary_result[2], boundary_result[3]);
   125ca:	9b07      	ldr	r3, [sp, #28]
   125cc:	9904      	ldr	r1, [sp, #16]
   125ce:	9300      	str	r3, [sp, #0]
   125d0:	487a      	ldr	r0, [pc, #488]	; (127bc <main+0x290>)
	// 	}
	// }


    
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   125d2:	4d7b      	ldr	r5, [pc, #492]	; (127c0 <main+0x294>)
   125d4:	f8df 82c0 	ldr.w	r8, [pc, #704]	; 12898 <main+0x36c>
	printf("Hello %d %d %d %d", boundary_result[0], boundary_result[1], boundary_result[2], boundary_result[3]);
   125d8:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
   125dc:	47a0      	blx	r4
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "D51 Init");
   125de:	4979      	ldr	r1, [pc, #484]	; (127c4 <main+0x298>)
   125e0:	486f      	ldr	r0, [pc, #444]	; (127a0 <main+0x274>)
   125e2:	47a0      	blx	r4
	grid_d51_init(); // Check User Row
   125e4:	4b78      	ldr	r3, [pc, #480]	; (127c8 <main+0x29c>)
   125e6:	4798      	blx	r3
	audiodf_midi_init();
   125e8:	4b78      	ldr	r3, [pc, #480]	; (127cc <main+0x2a0>)
   125ea:	4798      	blx	r3
	composite_device_start();
   125ec:	4b78      	ldr	r3, [pc, #480]	; (127d0 <main+0x2a4>)
   125ee:	4798      	blx	r3
	grid_usb_serial_init();
   125f0:	4b78      	ldr	r3, [pc, #480]	; (127d4 <main+0x2a8>)
   125f2:	4798      	blx	r3
	grid_usb_midi_init();
   125f4:	4b78      	ldr	r3, [pc, #480]	; (127d8 <main+0x2ac>)
   125f6:	4798      	blx	r3
	grid_keyboard_init(&grid_keyboard_state);
   125f8:	4b78      	ldr	r3, [pc, #480]	; (127dc <main+0x2b0>)
   125fa:	4879      	ldr	r0, [pc, #484]	; (127e0 <main+0x2b4>)
   125fc:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Initialized");
   125fe:	4979      	ldr	r1, [pc, #484]	; (127e4 <main+0x2b8>)
   12600:	4867      	ldr	r0, [pc, #412]	; (127a0 <main+0x274>)
   12602:	47a0      	blx	r4
	rand_sync_enable(&RAND_0);	
   12604:	4b78      	ldr	r3, [pc, #480]	; (127e8 <main+0x2bc>)
   12606:	4879      	ldr	r0, [pc, #484]	; (127ec <main+0x2c0>)
   12608:	4798      	blx	r3
	grid_expr_init(&grid_expr_state);
   1260a:	4879      	ldr	r0, [pc, #484]	; (127f0 <main+0x2c4>)
   1260c:	4b79      	ldr	r3, [pc, #484]	; (127f4 <main+0x2c8>)
   1260e:	4798      	blx	r3
	grid_module_common_init();
   12610:	4b79      	ldr	r3, [pc, #484]	; (127f8 <main+0x2cc>)
   12612:	4798      	blx	r3
    grid_ui_reinit(&grid_ui_state);
   12614:	4b79      	ldr	r3, [pc, #484]	; (127fc <main+0x2d0>)
   12616:	487a      	ldr	r0, [pc, #488]	; (12800 <main+0x2d4>)
   12618:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Grid Module Initialized");
   1261a:	497a      	ldr	r1, [pc, #488]	; (12804 <main+0x2d8>)
   1261c:	4860      	ldr	r0, [pc, #384]	; (127a0 <main+0x274>)
   1261e:	47a0      	blx	r4
	init_timer();
   12620:	4b79      	ldr	r3, [pc, #484]	; (12808 <main+0x2dc>)
   12622:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Entering Main Loop");
   12624:	4979      	ldr	r1, [pc, #484]	; (1280c <main+0x2e0>)
   12626:	485e      	ldr	r0, [pc, #376]	; (127a0 <main+0x274>)
   12628:	47a0      	blx	r4
	grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
   1262a:	4979      	ldr	r1, [pc, #484]	; (12810 <main+0x2e4>)
   1262c:	4879      	ldr	r0, [pc, #484]	; (12814 <main+0x2e8>)
   1262e:	4b7a      	ldr	r3, [pc, #488]	; (12818 <main+0x2ec>)
   12630:	4798      	blx	r3
	grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);	
   12632:	4977      	ldr	r1, [pc, #476]	; (12810 <main+0x2e4>)
   12634:	4872      	ldr	r0, [pc, #456]	; (12800 <main+0x2d4>)
   12636:	4b79      	ldr	r3, [pc, #484]	; (1281c <main+0x2f0>)
   12638:	4798      	blx	r3
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   1263a:	2301      	movs	r3, #1
   1263c:	9300      	str	r3, [sp, #0]
   1263e:	4978      	ldr	r1, [pc, #480]	; (12820 <main+0x2f4>)
   12640:	4878      	ldr	r0, [pc, #480]	; (12824 <main+0x2f8>)
   12642:	9501      	str	r5, [sp, #4]
   12644:	2300      	movs	r3, #0
   12646:	f44f 7200 	mov.w	r2, #512	; 0x200
   1264a:	47c0      	blx	r8
   1264c:	2801      	cmp	r0, #1
   1264e:	d000      	beq.n	12652 <main+0x126>
	    != pdPASS) {
		while (1) {
   12650:	e7fe      	b.n	12650 <main+0x124>
			;
		}
	}

	if (xTaskCreate(usb_task, "Nvm Task", TASK_NVM_STACK_SIZE, NULL, TASK_NVM_PRIORITY, &xCreatedNvmTask)
   12652:	1d2b      	adds	r3, r5, #4
   12654:	f04f 0902 	mov.w	r9, #2
   12658:	9301      	str	r3, [sp, #4]
   1265a:	4973      	ldr	r1, [pc, #460]	; (12828 <main+0x2fc>)
   1265c:	4871      	ldr	r0, [pc, #452]	; (12824 <main+0x2f8>)
   1265e:	f8cd 9000 	str.w	r9, [sp]
   12662:	2300      	movs	r3, #0
   12664:	f44f 7280 	mov.w	r2, #256	; 0x100
   12668:	47c0      	blx	r8
   1266a:	2801      	cmp	r0, #1
   1266c:	d000      	beq.n	12670 <main+0x144>
	    != pdPASS) {
		while (1) {
   1266e:	e7fe      	b.n	1266e <main+0x142>
			;
		}
	}

	if (xTaskCreate(usb_task, "Ui Task", TASK_UI_STACK_SIZE, NULL, TASK_UI_PRIORITY, &xCreatedUiTask)
   12670:	f105 0308 	add.w	r3, r5, #8
   12674:	9301      	str	r3, [sp, #4]
   12676:	2305      	movs	r3, #5
   12678:	9300      	str	r3, [sp, #0]
   1267a:	496c      	ldr	r1, [pc, #432]	; (1282c <main+0x300>)
   1267c:	4869      	ldr	r0, [pc, #420]	; (12824 <main+0x2f8>)
   1267e:	2300      	movs	r3, #0
   12680:	f44f 6280 	mov.w	r2, #1024	; 0x400
   12684:	47c0      	blx	r8
   12686:	2801      	cmp	r0, #1
   12688:	d000      	beq.n	1268c <main+0x160>
	    != pdPASS) {
		while (1) {
   1268a:	e7fe      	b.n	1268a <main+0x15e>
			;
		}
	}

	if (xTaskCreate(receive_task, "Receive Task", TASK_RECEIVE_STACK_SIZE, NULL, TASK_RECEIVE_PRIORITY, &xCreatedReceiveTask)
   1268c:	f105 030c 	add.w	r3, r5, #12
   12690:	e9cd 9300 	strd	r9, r3, [sp]
   12694:	4966      	ldr	r1, [pc, #408]	; (12830 <main+0x304>)
   12696:	4867      	ldr	r0, [pc, #412]	; (12834 <main+0x308>)
   12698:	2300      	movs	r3, #0
   1269a:	f44f 7280 	mov.w	r2, #256	; 0x100
   1269e:	47c0      	blx	r8
   126a0:	2801      	cmp	r0, #1
   126a2:	d000      	beq.n	126a6 <main+0x17a>
	    != pdPASS) {
		while (1) {
   126a4:	e7fe      	b.n	126a4 <main+0x178>
			;
		}
	}

	if (xTaskCreate(inbound_task, "Inbound Task", TASK_INBOUND_STACK_SIZE, NULL, TASK_INBOUND_PRIORITY, &xCreatedInboundTask)
   126a6:	f105 0310 	add.w	r3, r5, #16
   126aa:	e9cd 9300 	strd	r9, r3, [sp]
   126ae:	4962      	ldr	r1, [pc, #392]	; (12838 <main+0x30c>)
   126b0:	4862      	ldr	r0, [pc, #392]	; (1283c <main+0x310>)
   126b2:	2300      	movs	r3, #0
   126b4:	f44f 7280 	mov.w	r2, #256	; 0x100
   126b8:	47c0      	blx	r8
   126ba:	2801      	cmp	r0, #1
   126bc:	d000      	beq.n	126c0 <main+0x194>
	    != pdPASS) {
		while (1) {
   126be:	e7fe      	b.n	126be <main+0x192>
			;
		}
	}

	if (xTaskCreate(outbound_task, "Outbound Task", TASK_OUTBOUND_STACK_SIZE, NULL, TASK_OUTBOUND_PRIORITY, &xCreatedOutboundTask)
   126c0:	f105 0314 	add.w	r3, r5, #20
   126c4:	e9cd 9300 	strd	r9, r3, [sp]
   126c8:	495d      	ldr	r1, [pc, #372]	; (12840 <main+0x314>)
   126ca:	485e      	ldr	r0, [pc, #376]	; (12844 <main+0x318>)
   126cc:	2300      	movs	r3, #0
   126ce:	f44f 7280 	mov.w	r2, #256	; 0x100
   126d2:	47c0      	blx	r8
   126d4:	2801      	cmp	r0, #1
   126d6:	d000      	beq.n	126da <main+0x1ae>
	    != pdPASS) {
		while (1) {
   126d8:	e7fe      	b.n	126d8 <main+0x1ac>
			;
		}
	}


	if (xTaskCreate(led_task, "Led Task", TASK_LED_STACK_SIZE, NULL, TASK_LED_PRIORITY, &xCreatedLedTask)
   126da:	f105 0318 	add.w	r3, r5, #24
   126de:	e9cd 6300 	strd	r6, r3, [sp]
   126e2:	4959      	ldr	r1, [pc, #356]	; (12848 <main+0x31c>)
   126e4:	4859      	ldr	r0, [pc, #356]	; (1284c <main+0x320>)
   126e6:	2300      	movs	r3, #0
   126e8:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   126ec:	47c0      	blx	r8
   126ee:	2801      	cmp	r0, #1
   126f0:	d000      	beq.n	126f4 <main+0x1c8>
	    != pdPASS) {
		while (1) {
   126f2:	e7fe      	b.n	126f2 <main+0x1c6>
			;
		}
	}
    
	if (xTaskCreate(example_task, "Example", TASK_EXAMPLE_STACK_SIZE, NULL, TASK_EXAMPLE_STACK_PRIORITY, &xCreatedExampleTask)
   126f4:	351c      	adds	r5, #28
   126f6:	e9cd 9500 	strd	r9, r5, [sp]
   126fa:	4955      	ldr	r1, [pc, #340]	; (12850 <main+0x324>)
   126fc:	4855      	ldr	r0, [pc, #340]	; (12854 <main+0x328>)
   126fe:	2300      	movs	r3, #0
   12700:	2280      	movs	r2, #128	; 0x80
   12702:	47c0      	blx	r8
   12704:	2801      	cmp	r0, #1
   12706:	d000      	beq.n	1270a <main+0x1de>
	    != pdPASS) {
		while (1) {
   12708:	e7fe      	b.n	12708 <main+0x1dc>
   1270a:	f8df 9190 	ldr.w	r9, [pc, #400]	; 1289c <main+0x370>
   1270e:	f8df 8190 	ldr.w	r8, [pc, #400]	; 128a0 <main+0x374>
	uint32_t loopcounter = 0;
   12712:	2500      	movs	r5, #0
	
		
		if (usb_init_flag == 0){
			
			
			if (usb_d_get_frame_num() == 0){
   12714:	4b50      	ldr	r3, [pc, #320]	; (12858 <main+0x32c>)
   12716:	4e51      	ldr	r6, [pc, #324]	; (1285c <main+0x330>)
   12718:	f8df b188 	ldr.w	fp, [pc, #392]	; 128a4 <main+0x378>
   1271c:	4798      	blx	r3
   1271e:	2800      	cmp	r0, #0
   12720:	f000 80c4 	beq.w	128ac <main+0x380>
				
			}
			else{			
			
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN	
   12724:	2500      	movs	r5, #0
   12726:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   1272a:	22ff      	movs	r2, #255	; 0xff
   1272c:	e9cd 5300 	strd	r5, r3, [sp]
   12730:	4629      	mov	r1, r5
   12732:	462b      	mov	r3, r5
   12734:	4837      	ldr	r0, [pc, #220]	; (12814 <main+0x2e8>)
   12736:	f8df a170 	ldr.w	sl, [pc, #368]	; 128a8 <main+0x37c>
   1273a:	47d0      	blx	sl
				
				GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Connected");
   1273c:	4948      	ldr	r1, [pc, #288]	; (12860 <main+0x334>)
   1273e:	4818      	ldr	r0, [pc, #96]	; (127a0 <main+0x274>)
   12740:	47a0      	blx	r4
				
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   12742:	4b48      	ldr	r3, [pc, #288]	; (12864 <main+0x338>)
   12744:	4833      	ldr	r0, [pc, #204]	; (12814 <main+0x2e8>)
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   12746:	4c48      	ldr	r4, [pc, #288]	; (12868 <main+0x33c>)
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   12748:	4798      	blx	r3
   1274a:	4b48      	ldr	r3, [pc, #288]	; (1286c <main+0x340>)
   1274c:	4601      	mov	r1, r0
   1274e:	4831      	ldr	r0, [pc, #196]	; (12814 <main+0x2e8>)
   12750:	4798      	blx	r3
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   12752:	462a      	mov	r2, r5
   12754:	4629      	mov	r1, r5
   12756:	4846      	ldr	r0, [pc, #280]	; (12870 <main+0x344>)
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12758:	4d46      	ldr	r5, [pc, #280]	; (12874 <main+0x348>)
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   1275a:	2309      	movs	r3, #9
   1275c:	47a0      	blx	r4
				
				usb_init_flag = 1;
				
				

				printf("Forever! \r\n");
   1275e:	9b03      	ldr	r3, [sp, #12]
   12760:	4845      	ldr	r0, [pc, #276]	; (12878 <main+0x34c>)

					inbound_task_inner();

					outbound_task_inner();

					led_task_inner();
   12762:	4c46      	ldr	r4, [pc, #280]	; (1287c <main+0x350>)
				printf("Forever! \r\n");
   12764:	4798      	blx	r3
				delay_ms(2);
   12766:	2002      	movs	r0, #2
   12768:	47b8      	blx	r7
				vTaskStartScheduler();
   1276a:	4b45      	ldr	r3, [pc, #276]	; (12880 <main+0x354>)
   1276c:	4798      	blx	r3
					usb_task_inner();
   1276e:	47c8      	blx	r9
					nvm_task_inner();
   12770:	47c0      	blx	r8
					receive_task_inner();
   12772:	47b0      	blx	r6
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12774:	4628      	mov	r0, r5
   12776:	47d8      	blx	fp
					inbound_task_inner();
   12778:	4b42      	ldr	r3, [pc, #264]	; (12884 <main+0x358>)
   1277a:	4798      	blx	r3
					outbound_task_inner();
   1277c:	4b42      	ldr	r3, [pc, #264]	; (12888 <main+0x35c>)
   1277e:	4798      	blx	r3
					led_task_inner();
   12780:	47a0      	blx	r4

					delay_ms(1);
   12782:	2001      	movs	r0, #1
   12784:	47b8      	blx	r7
				while(1){
   12786:	e7f2      	b.n	1276e <main+0x242>
   12788:	000147c5 	.word	0x000147c5
   1278c:	00014925 	.word	0x00014925
   12790:	00014a59 	.word	0x00014a59
   12794:	00006475 	.word	0x00006475
   12798:	00013589 	.word	0x00013589
   1279c:	00016c61 	.word	0x00016c61
   127a0:	0001605f 	.word	0x0001605f
   127a4:	00016c73 	.word	0x00016c73
   127a8:	00009c95 	.word	0x00009c95
   127ac:	00016c8a 	.word	0x00016c8a
   127b0:	00009c69 	.word	0x00009c69
   127b4:	00016c9a 	.word	0x00016c9a
   127b8:	00016daa 	.word	0x00016daa
   127bc:	00016cd0 	.word	0x00016cd0
   127c0:	20008dd4 	.word	0x20008dd4
   127c4:	00016ce2 	.word	0x00016ce2
   127c8:	00006431 	.word	0x00006431
   127cc:	00004495 	.word	0x00004495
   127d0:	0000cced 	.word	0x0000cced
   127d4:	0000b089 	.word	0x0000b089
   127d8:	0000b281 	.word	0x0000b281
   127dc:	0000b36d 	.word	0x0000b36d
   127e0:	20010264 	.word	0x20010264
   127e4:	00016ceb 	.word	0x00016ceb
   127e8:	0000eb7d 	.word	0x0000eb7d
   127ec:	2001cd7c 	.word	0x2001cd7c
   127f0:	20013220 	.word	0x20013220
   127f4:	00006799 	.word	0x00006799
   127f8:	00007471 	.word	0x00007471
   127fc:	0000a471 	.word	0x0000a471
   12800:	2000effc 	.word	0x2000effc
   12804:	00016d08 	.word	0x00016d08
   12808:	000124bd 	.word	0x000124bd
   1280c:	00016d20 	.word	0x00016d20
   12810:	2000fa1c 	.word	0x2000fa1c
   12814:	2000f008 	.word	0x2000f008
   12818:	0000948d 	.word	0x0000948d
   1281c:	00009e9d 	.word	0x00009e9d
   12820:	00016d33 	.word	0x00016d33
   12824:	000120b9 	.word	0x000120b9
   12828:	00016d3c 	.word	0x00016d3c
   1282c:	00016d45 	.word	0x00016d45
   12830:	00016d4d 	.word	0x00016d4d
   12834:	00012101 	.word	0x00012101
   12838:	00016d5a 	.word	0x00016d5a
   1283c:	00011fb9 	.word	0x00011fb9
   12840:	00016d67 	.word	0x00016d67
   12844:	00012435 	.word	0x00012435
   12848:	00016d75 	.word	0x00016d75
   1284c:	00012445 	.word	0x00012445
   12850:	00016d7e 	.word	0x00016d7e
   12854:	00011f7d 	.word	0x00011f7d
   12858:	0000f901 	.word	0x0000f901
   1285c:	000120d1 	.word	0x000120d1
   12860:	00016d86 	.word	0x00016d86
   12864:	00009af1 	.word	0x00009af1
   12868:	0000a539 	.word	0x0000a539
   1286c:	00009b0b 	.word	0x00009b0b
   12870:	2001c7c0 	.word	0x2001c7c0
   12874:	2000c0b0 	.word	0x2000c0b0
   12878:	00016da1 	.word	0x00016da1
   1287c:	00012241 	.word	0x00012241
   12880:	00012bb1 	.word	0x00012bb1
   12884:	000121ad 	.word	0x000121ad
   12888:	000121f9 	.word	0x000121f9
   1288c:	0000e17d 	.word	0x0000e17d
   12890:	00016cbe 	.word	0x00016cbe
   12894:	00014955 	.word	0x00014955
   12898:	00012a0d 	.word	0x00012a0d
   1289c:	00011fc9 	.word	0x00011fc9
   128a0:	00012119 	.word	0x00012119
   128a4:	0000ab4d 	.word	0x0000ab4d
   128a8:	00009bbb 	.word	0x00009bbb
		
		
		
		// Request neighbor bank settings if we don't have it initialized
		
 		if (grid_sys_get_bank_valid(&grid_sys_state) == 0 && loopcounter%80 == 0){
   128ac:	f8df a060 	ldr.w	sl, [pc, #96]	; 12910 <main+0x3e4>
   128b0:	4b11      	ldr	r3, [pc, #68]	; (128f8 <main+0x3cc>)
   128b2:	4650      	mov	r0, sl
   128b4:	4798      	blx	r3
   128b6:	b980      	cbnz	r0, 128da <main+0x3ae>
   128b8:	2250      	movs	r2, #80	; 0x50
   128ba:	fbb5 f3f2 	udiv	r3, r5, r2
   128be:	fb02 5313 	mls	r3, r2, r3, r5
   128c2:	b953      	cbnz	r3, 128da <main+0x3ae>
 								
			if (grid_sys_state.bank_init_flag == 0)	{
   128c4:	f89a 3027 	ldrb.w	r3, [sl, #39]	; 0x27
   128c8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   128cc:	b92b      	cbnz	r3, 128da <main+0x3ae>
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_REQUEST);
   128ce:	480b      	ldr	r0, [pc, #44]	; (128fc <main+0x3d0>)
   128d0:	f8df a040 	ldr.w	sl, [pc, #64]	; 12914 <main+0x3e8>
   128d4:	230a      	movs	r3, #10
   128d6:	4611      	mov	r1, r2
   128d8:	47d0      	blx	sl
	

		
		
		
		usb_task_inner();
   128da:	47c8      	blx	r9
		


		nvm_task_inner();
   128dc:	47c0      	blx	r8
		
					


		receive_task_inner();
   128de:	47b0      	blx	r6
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   128e0:	4807      	ldr	r0, [pc, #28]	; (12900 <main+0x3d4>)
   128e2:	47d8      	blx	fp
		
		
		
		
		
		inbound_task_inner();
   128e4:	4b07      	ldr	r3, [pc, #28]	; (12904 <main+0x3d8>)
   128e6:	4798      	blx	r3

		outbound_task_inner();
   128e8:	4b07      	ldr	r3, [pc, #28]	; (12908 <main+0x3dc>)
   128ea:	4798      	blx	r3

		led_task_inner();
   128ec:	4b07      	ldr	r3, [pc, #28]	; (1290c <main+0x3e0>)
   128ee:	4798      	blx	r3

		delay_ms(1);
   128f0:	2001      	movs	r0, #1
		loopcounter++;
   128f2:	3501      	adds	r5, #1
		delay_ms(1);
   128f4:	47b8      	blx	r7
		if (usb_init_flag == 0){
   128f6:	e70d      	b.n	12714 <main+0x1e8>
   128f8:	00009ab3 	.word	0x00009ab3
   128fc:	2001c7c0 	.word	0x2001c7c0
   12900:	2000c0b0 	.word	0x2000c0b0
   12904:	000121ad 	.word	0x000121ad
   12908:	000121f9 	.word	0x000121f9
   1290c:	00012241 	.word	0x00012241
   12910:	2000f008 	.word	0x2000f008
   12914:	0000a539 	.word	0x0000a539

00012918 <qspi_dma_init>:
 * \brief Driver version
 */
#define QSPI_DMA_DRIVER_VERSION 0x00000001u

int32_t qspi_dma_init(struct qspi_dma_descriptor *qspi, void *const hw)
{
   12918:	b570      	push	{r4, r5, r6, lr}
   1291a:	460d      	mov	r5, r1
	ASSERT(qspi && hw);
   1291c:	4604      	mov	r4, r0
   1291e:	b110      	cbz	r0, 12926 <qspi_dma_init+0xe>
   12920:	1e08      	subs	r0, r1, #0
   12922:	bf18      	it	ne
   12924:	2001      	movne	r0, #1
   12926:	4905      	ldr	r1, [pc, #20]	; (1293c <qspi_dma_init+0x24>)
   12928:	4b05      	ldr	r3, [pc, #20]	; (12940 <qspi_dma_init+0x28>)
   1292a:	2231      	movs	r2, #49	; 0x31
   1292c:	4798      	blx	r3

	return _qspi_dma_init(&qspi->dev, hw);
   1292e:	4629      	mov	r1, r5
   12930:	4620      	mov	r0, r4
   12932:	4b04      	ldr	r3, [pc, #16]	; (12944 <qspi_dma_init+0x2c>)
}
   12934:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _qspi_dma_init(&qspi->dev, hw);
   12938:	4718      	bx	r3
   1293a:	bf00      	nop
   1293c:	00016dac 	.word	0x00016dac
   12940:	0000e42d 	.word	0x0000e42d
   12944:	0000c209 	.word	0x0000c209

00012948 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12948:	4906      	ldr	r1, [pc, #24]	; (12964 <prvIdleTask+0x1c>)
				taskYIELD();
   1294a:	4b07      	ldr	r3, [pc, #28]	; (12968 <prvIdleTask+0x20>)
   1294c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12950:	6808      	ldr	r0, [r1, #0]
   12952:	2801      	cmp	r0, #1
   12954:	d9fc      	bls.n	12950 <prvIdleTask+0x8>
				taskYIELD();
   12956:	601a      	str	r2, [r3, #0]
   12958:	f3bf 8f4f 	dsb	sy
   1295c:	f3bf 8f6f 	isb	sy
   12960:	e7f6      	b.n	12950 <prvIdleTask+0x8>
   12962:	bf00      	nop
   12964:	20008df8 	.word	0x20008df8
   12968:	e000ed04 	.word	0xe000ed04

0001296c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   1296c:	4b07      	ldr	r3, [pc, #28]	; (1298c <prvResetNextTaskUnblockTime+0x20>)
   1296e:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   12972:	6812      	ldr	r2, [r2, #0]
   12974:	b922      	cbnz	r2, 12980 <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   12976:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   1297a:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
	}
}
   1297e:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   12980:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   12984:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   12986:	68d2      	ldr	r2, [r2, #12]
   12988:	6852      	ldr	r2, [r2, #4]
   1298a:	e7f6      	b.n	1297a <prvResetNextTaskUnblockTime+0xe>
   1298c:	20008df8 	.word	0x20008df8

00012990 <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
   12990:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
   12994:	4f19      	ldr	r7, [pc, #100]	; (129fc <prvAddCurrentTaskToDelayedList+0x6c>)
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12996:	4b1a      	ldr	r3, [pc, #104]	; (12a00 <prvAddCurrentTaskToDelayedList+0x70>)
	const TickType_t xConstTickCount = xTickCount;
   12998:	f8d7 62b0 	ldr.w	r6, [r7, #688]	; 0x2b0
{
   1299c:	4605      	mov	r5, r0
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   1299e:	f8d7 02b4 	ldr.w	r0, [r7, #692]	; 0x2b4
   129a2:	3004      	adds	r0, #4
{
   129a4:	4688      	mov	r8, r1
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   129a6:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
   129a8:	1c6b      	adds	r3, r5, #1
   129aa:	463c      	mov	r4, r7
   129ac:	d10b      	bne.n	129c6 <prvAddCurrentTaskToDelayedList+0x36>
   129ae:	f1b8 0f00 	cmp.w	r8, #0
   129b2:	d008      	beq.n	129c6 <prvAddCurrentTaskToDelayedList+0x36>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
   129b4:	f8d7 12b4 	ldr.w	r1, [r7, #692]	; 0x2b4
   129b8:	4b12      	ldr	r3, [pc, #72]	; (12a04 <prvAddCurrentTaskToDelayedList+0x74>)
   129ba:	3104      	adds	r1, #4
   129bc:	f507 7020 	add.w	r0, r7, #640	; 0x280

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
   129c0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   129c4:	4718      	bx	r3
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
   129c6:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   129ca:	1975      	adds	r5, r6, r5
   129cc:	605d      	str	r5, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
   129ce:	4b0e      	ldr	r3, [pc, #56]	; (12a08 <prvAddCurrentTaskToDelayedList+0x78>)
   129d0:	d305      	bcc.n	129de <prvAddCurrentTaskToDelayedList+0x4e>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   129d2:	f8d4 02b8 	ldr.w	r0, [r4, #696]	; 0x2b8
   129d6:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   129da:	3104      	adds	r1, #4
   129dc:	e7f0      	b.n	129c0 <prvAddCurrentTaskToDelayedList+0x30>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   129de:	f8d4 02a8 	ldr.w	r0, [r4, #680]	; 0x2a8
   129e2:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   129e6:	3104      	adds	r1, #4
   129e8:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
   129ea:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   129ee:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
   129f0:	bf88      	it	hi
   129f2:	f8c4 52ac 	strhi.w	r5, [r4, #684]	; 0x2ac
}
   129f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   129fa:	bf00      	nop
   129fc:	20008df8 	.word	0x20008df8
   12a00:	0000b557 	.word	0x0000b557
   12a04:	0000b511 	.word	0x0000b511
   12a08:	0000b529 	.word	0x0000b529

00012a0c <xTaskCreate>:
{
   12a0c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pxStack = (StackType_t *)pvPortMalloc(
   12a10:	0095      	lsls	r5, r2, #2
   12a12:	4c5b      	ldr	r4, [pc, #364]	; (12b80 <xTaskCreate+0x174>)
{
   12a14:	4607      	mov	r7, r0
		pxStack = (StackType_t *)pvPortMalloc(
   12a16:	4628      	mov	r0, r5
{
   12a18:	460e      	mov	r6, r1
   12a1a:	4698      	mov	r8, r3
		pxStack = (StackType_t *)pvPortMalloc(
   12a1c:	47a0      	blx	r4
		if (pxStack != NULL) {
   12a1e:	4681      	mov	r9, r0
   12a20:	2800      	cmp	r0, #0
   12a22:	f000 809b 	beq.w	12b5c <xTaskCreate+0x150>
			pxNewTCB = (TCB_t *)pvPortMalloc(
   12a26:	2054      	movs	r0, #84	; 0x54
   12a28:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
   12a2a:	4604      	mov	r4, r0
   12a2c:	2800      	cmp	r0, #0
   12a2e:	f000 8092 	beq.w	12b56 <xTaskCreate+0x14a>
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   12a32:	4b54      	ldr	r3, [pc, #336]	; (12b84 <xTaskCreate+0x178>)
				pxNewTCB->pxStack = pxStack;
   12a34:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   12a38:	462a      	mov	r2, r5
   12a3a:	21a5      	movs	r1, #165	; 0xa5
   12a3c:	4648      	mov	r0, r9
   12a3e:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12a40:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12a44:	1e73      	subs	r3, r6, #1
   12a46:	f104 0234 	add.w	r2, r4, #52	; 0x34
   12a4a:	3607      	adds	r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
   12a4c:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   12a50:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
   12a54:	7819      	ldrb	r1, [r3, #0]
   12a56:	b109      	cbz	r1, 12a5c <xTaskCreate+0x50>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12a58:	42b3      	cmp	r3, r6
   12a5a:	d1f7      	bne.n	12a4c <xTaskCreate+0x40>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12a5c:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12a5e:	4a4a      	ldr	r2, [pc, #296]	; (12b88 <xTaskCreate+0x17c>)
   12a60:	2e1f      	cmp	r6, #31
   12a62:	bf28      	it	cs
   12a64:	261f      	movcs	r6, #31
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12a66:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12a6a:	f104 0904 	add.w	r9, r4, #4
		pxNewTCB->uxMutexesHeld  = 0;
   12a6e:	e9c4 6a11 	strd	r6, sl, [r4, #68]	; 0x44
	pxNewTCB->uxPriority = uxPriority;
   12a72:	62e6      	str	r6, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12a74:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12a76:	f884 a03b 	strb.w	sl, [r4, #59]	; 0x3b
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12a7a:	3d04      	subs	r5, #4
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12a7c:	4790      	blx	r2
	listSET_LIST_ITEM_VALUE(
   12a7e:	f1c6 0620 	rsb	r6, r6, #32
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   12a82:	4a41      	ldr	r2, [pc, #260]	; (12b88 <xTaskCreate+0x17c>)
   12a84:	f104 0018 	add.w	r0, r4, #24
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12a88:	445d      	add	r5, fp
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   12a8a:	4790      	blx	r2
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12a8c:	4b3f      	ldr	r3, [pc, #252]	; (12b8c <xTaskCreate+0x180>)
		pxNewTCB->ulNotifiedValue = 0;
   12a8e:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
   12a92:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
   12a94:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
   12a96:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
   12a98:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12a9c:	4642      	mov	r2, r8
   12a9e:	4639      	mov	r1, r7
   12aa0:	f025 0007 	bic.w	r0, r5, #7
   12aa4:	4798      	blx	r3
	if ((void *)pxCreatedTask != NULL) {
   12aa6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   12aa8:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
   12aaa:	b103      	cbz	r3, 12aae <xTaskCreate+0xa2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
   12aac:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
   12aae:	4d38      	ldr	r5, [pc, #224]	; (12b90 <xTaskCreate+0x184>)
	taskENTER_CRITICAL();
   12ab0:	4b38      	ldr	r3, [pc, #224]	; (12b94 <xTaskCreate+0x188>)
   12ab2:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   12ab4:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   12ab8:	3301      	adds	r3, #1
   12aba:	f8c5 32bc 	str.w	r3, [r5, #700]	; 0x2bc
		if (pxCurrentTCB == NULL) {
   12abe:	f8d5 62b4 	ldr.w	r6, [r5, #692]	; 0x2b4
   12ac2:	2e00      	cmp	r6, #0
   12ac4:	d14e      	bne.n	12b64 <xTaskCreate+0x158>
			pxCurrentTCB = pxNewTCB;
   12ac6:	f8c5 42b4 	str.w	r4, [r5, #692]	; 0x2b4
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
   12aca:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   12ace:	2b01      	cmp	r3, #1
   12ad0:	d119      	bne.n	12b06 <xTaskCreate+0xfa>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   12ad2:	4f31      	ldr	r7, [pc, #196]	; (12b98 <xTaskCreate+0x18c>)
   12ad4:	46a8      	mov	r8, r5
   12ad6:	4640      	mov	r0, r8
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   12ad8:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   12ada:	47b8      	blx	r7
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   12adc:	2e20      	cmp	r6, #32
   12ade:	f108 0814 	add.w	r8, r8, #20
   12ae2:	d1f8      	bne.n	12ad6 <xTaskCreate+0xca>
	vListInitialise(&xDelayedTaskList1);
   12ae4:	4e2d      	ldr	r6, [pc, #180]	; (12b9c <xTaskCreate+0x190>)
   12ae6:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
   12ae8:	f106 0814 	add.w	r8, r6, #20
	vListInitialise(&xDelayedTaskList1);
   12aec:	47b8      	blx	r7
	vListInitialise(&xDelayedTaskList2);
   12aee:	4640      	mov	r0, r8
   12af0:	47b8      	blx	r7
	vListInitialise(&xPendingReadyList);
   12af2:	f1a6 002c 	sub.w	r0, r6, #44	; 0x2c
   12af6:	47b8      	blx	r7
		vListInitialise(&xSuspendedTaskList);
   12af8:	f1a6 0040 	sub.w	r0, r6, #64	; 0x40
   12afc:	47b8      	blx	r7
	pxDelayedTaskList         = &xDelayedTaskList1;
   12afe:	f8c5 62a8 	str.w	r6, [r5, #680]	; 0x2a8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   12b02:	f8c5 82b8 	str.w	r8, [r5, #696]	; 0x2b8
		uxTaskNumber++;
   12b06:	f8d5 32ec 	ldr.w	r3, [r5, #748]	; 0x2ec
		prvAddTaskToReadyList(pxNewTCB);
   12b0a:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
		uxTaskNumber++;
   12b0e:	3301      	adds	r3, #1
   12b10:	f8c5 32ec 	str.w	r3, [r5, #748]	; 0x2ec
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   12b14:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
   12b16:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   12b18:	2014      	movs	r0, #20
   12b1a:	4293      	cmp	r3, r2
   12b1c:	bf88      	it	hi
   12b1e:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   12b22:	fb00 5003 	mla	r0, r0, r3, r5
   12b26:	4649      	mov	r1, r9
   12b28:	4b1d      	ldr	r3, [pc, #116]	; (12ba0 <xTaskCreate+0x194>)
   12b2a:	4798      	blx	r3
	taskEXIT_CRITICAL();
   12b2c:	4b1d      	ldr	r3, [pc, #116]	; (12ba4 <xTaskCreate+0x198>)
   12b2e:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
   12b30:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   12b34:	b16b      	cbz	r3, 12b52 <xTaskCreate+0x146>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
   12b36:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   12b3a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12b3c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   12b3e:	429a      	cmp	r2, r3
   12b40:	d207      	bcs.n	12b52 <xTaskCreate+0x146>
			taskYIELD_IF_USING_PREEMPTION();
   12b42:	4b19      	ldr	r3, [pc, #100]	; (12ba8 <xTaskCreate+0x19c>)
   12b44:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12b48:	601a      	str	r2, [r3, #0]
   12b4a:	f3bf 8f4f 	dsb	sy
   12b4e:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
   12b52:	2001      	movs	r0, #1
	return xReturn;
   12b54:	e004      	b.n	12b60 <xTaskCreate+0x154>
				vPortFree(pxStack);
   12b56:	4b15      	ldr	r3, [pc, #84]	; (12bac <xTaskCreate+0x1a0>)
   12b58:	4648      	mov	r0, r9
   12b5a:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   12b5c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   12b60:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (xSchedulerRunning == pdFALSE) {
   12b64:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   12b68:	2b00      	cmp	r3, #0
   12b6a:	d1cc      	bne.n	12b06 <xTaskCreate+0xfa>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
   12b6c:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   12b70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12b72:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   12b74:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
   12b76:	bf98      	it	ls
   12b78:	f8c5 42b4 	strls.w	r4, [r5, #692]	; 0x2b4
   12b7c:	e7c3      	b.n	12b06 <xTaskCreate+0xfa>
   12b7e:	bf00      	nop
   12b80:	0000ba05 	.word	0x0000ba05
   12b84:	000147c5 	.word	0x000147c5
   12b88:	0000b50b 	.word	0x0000b50b
   12b8c:	0000b5f5 	.word	0x0000b5f5
   12b90:	20008df8 	.word	0x20008df8
   12b94:	0000b645 	.word	0x0000b645
   12b98:	0000b4f5 	.word	0x0000b4f5
   12b9c:	200090b8 	.word	0x200090b8
   12ba0:	0000b511 	.word	0x0000b511
   12ba4:	0000b689 	.word	0x0000b689
   12ba8:	e000ed04 	.word	0xe000ed04
   12bac:	0000bb09 	.word	0x0000bb09

00012bb0 <vTaskStartScheduler>:
{
   12bb0:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(prvIdleTask,
   12bb2:	4c1a      	ldr	r4, [pc, #104]	; (12c1c <vTaskStartScheduler+0x6c>)
   12bb4:	491a      	ldr	r1, [pc, #104]	; (12c20 <vTaskStartScheduler+0x70>)
   12bb6:	481b      	ldr	r0, [pc, #108]	; (12c24 <vTaskStartScheduler+0x74>)
   12bb8:	4e1b      	ldr	r6, [pc, #108]	; (12c28 <vTaskStartScheduler+0x78>)
   12bba:	f504 733e 	add.w	r3, r4, #760	; 0x2f8
   12bbe:	2500      	movs	r5, #0
   12bc0:	9301      	str	r3, [sp, #4]
   12bc2:	9500      	str	r5, [sp, #0]
   12bc4:	462b      	mov	r3, r5
   12bc6:	2240      	movs	r2, #64	; 0x40
   12bc8:	47b0      	blx	r6
		if (xReturn == pdPASS) {
   12bca:	2801      	cmp	r0, #1
   12bcc:	d118      	bne.n	12c00 <vTaskStartScheduler+0x50>
			xReturn = xTimerCreateTimerTask();
   12bce:	4b17      	ldr	r3, [pc, #92]	; (12c2c <vTaskStartScheduler+0x7c>)
   12bd0:	4798      	blx	r3
	if (xReturn == pdPASS) {
   12bd2:	2801      	cmp	r0, #1
   12bd4:	d114      	bne.n	12c00 <vTaskStartScheduler+0x50>
   12bd6:	f04f 0380 	mov.w	r3, #128	; 0x80
   12bda:	f383 8811 	msr	BASEPRI, r3
   12bde:	f3bf 8f6f 	isb	sy
   12be2:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   12be6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   12bea:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
		if (xPortStartScheduler() != pdFALSE) {
   12bee:	4b10      	ldr	r3, [pc, #64]	; (12c30 <vTaskStartScheduler+0x80>)
		xSchedulerRunning    = pdTRUE;
   12bf0:	f8c4 02e8 	str.w	r0, [r4, #744]	; 0x2e8
		xTickCount           = (TickType_t)0U;
   12bf4:	f8c4 52b0 	str.w	r5, [r4, #688]	; 0x2b0
}
   12bf8:	b002      	add	sp, #8
   12bfa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (xPortStartScheduler() != pdFALSE) {
   12bfe:	4718      	bx	r3
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
   12c00:	3001      	adds	r0, #1
   12c02:	d108      	bne.n	12c16 <vTaskStartScheduler+0x66>
   12c04:	f04f 0380 	mov.w	r3, #128	; 0x80
   12c08:	f383 8811 	msr	BASEPRI, r3
   12c0c:	f3bf 8f6f 	isb	sy
   12c10:	f3bf 8f4f 	dsb	sy
   12c14:	e7fe      	b.n	12c14 <vTaskStartScheduler+0x64>
}
   12c16:	b002      	add	sp, #8
   12c18:	bd70      	pop	{r4, r5, r6, pc}
   12c1a:	bf00      	nop
   12c1c:	20008df8 	.word	0x20008df8
   12c20:	00016dc6 	.word	0x00016dc6
   12c24:	00012949 	.word	0x00012949
   12c28:	00012a0d 	.word	0x00012a0d
   12c2c:	0000de61 	.word	0x0000de61
   12c30:	0000b769 	.word	0x0000b769

00012c34 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   12c34:	4a03      	ldr	r2, [pc, #12]	; (12c44 <vTaskSuspendAll+0x10>)
   12c36:	f8d2 32f4 	ldr.w	r3, [r2, #756]	; 0x2f4
   12c3a:	3301      	adds	r3, #1
   12c3c:	f8c2 32f4 	str.w	r3, [r2, #756]	; 0x2f4
}
   12c40:	4770      	bx	lr
   12c42:	bf00      	nop
   12c44:	20008df8 	.word	0x20008df8

00012c48 <xTaskGetTickCount>:
		xTicks = xTickCount;
   12c48:	4b01      	ldr	r3, [pc, #4]	; (12c50 <xTaskGetTickCount+0x8>)
   12c4a:	f8d3 02b0 	ldr.w	r0, [r3, #688]	; 0x2b0
}
   12c4e:	4770      	bx	lr
   12c50:	20008df8 	.word	0x20008df8

00012c54 <pcTaskGetName>:
	pxTCB = prvGetTCBFromHandle(xTaskToQuery);
   12c54:	b960      	cbnz	r0, 12c70 <pcTaskGetName+0x1c>
   12c56:	4b07      	ldr	r3, [pc, #28]	; (12c74 <pcTaskGetName+0x20>)
   12c58:	f8d3 02b4 	ldr.w	r0, [r3, #692]	; 0x2b4
	configASSERT(pxTCB);
   12c5c:	b940      	cbnz	r0, 12c70 <pcTaskGetName+0x1c>
   12c5e:	f04f 0380 	mov.w	r3, #128	; 0x80
   12c62:	f383 8811 	msr	BASEPRI, r3
   12c66:	f3bf 8f6f 	isb	sy
   12c6a:	f3bf 8f4f 	dsb	sy
   12c6e:	e7fe      	b.n	12c6e <pcTaskGetName+0x1a>
}
   12c70:	3034      	adds	r0, #52	; 0x34
   12c72:	4770      	bx	lr
   12c74:	20008df8 	.word	0x20008df8

00012c78 <xTaskIncrementTick>:
{
   12c78:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12c7c:	4b3b      	ldr	r3, [pc, #236]	; (12d6c <xTaskIncrementTick+0xf4>)
   12c7e:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   12c82:	461c      	mov	r4, r3
   12c84:	2a00      	cmp	r2, #0
   12c86:	d16a      	bne.n	12d5e <xTaskIncrementTick+0xe6>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
   12c88:	f8d3 72b0 	ldr.w	r7, [r3, #688]	; 0x2b0
   12c8c:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   12c8e:	f8c3 72b0 	str.w	r7, [r3, #688]	; 0x2b0
		if (xConstTickCount
   12c92:	b9df      	cbnz	r7, 12ccc <xTaskIncrementTick+0x54>
			taskSWITCH_DELAYED_LISTS();
   12c94:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
   12c98:	681b      	ldr	r3, [r3, #0]
   12c9a:	b143      	cbz	r3, 12cae <xTaskIncrementTick+0x36>
   12c9c:	f04f 0380 	mov.w	r3, #128	; 0x80
   12ca0:	f383 8811 	msr	BASEPRI, r3
   12ca4:	f3bf 8f6f 	isb	sy
   12ca8:	f3bf 8f4f 	dsb	sy
   12cac:	e7fe      	b.n	12cac <xTaskIncrementTick+0x34>
   12cae:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12cb2:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
   12cb6:	f8c4 22a8 	str.w	r2, [r4, #680]	; 0x2a8
   12cba:	f8c4 32b8 	str.w	r3, [r4, #696]	; 0x2b8
   12cbe:	f8d4 32fc 	ldr.w	r3, [r4, #764]	; 0x2fc
   12cc2:	3301      	adds	r3, #1
   12cc4:	f8c4 32fc 	str.w	r3, [r4, #764]	; 0x2fc
   12cc8:	4b29      	ldr	r3, [pc, #164]	; (12d70 <xTaskIncrementTick+0xf8>)
   12cca:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12ccc:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   12cd0:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
   12cd2:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
   12cd6:	d910      	bls.n	12cfa <xTaskIncrementTick+0x82>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
   12cd8:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12cdc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   12cde:	2314      	movs	r3, #20
   12ce0:	4353      	muls	r3, r2
   12ce2:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
   12ce4:	2b02      	cmp	r3, #2
   12ce6:	bf28      	it	cs
   12ce8:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
   12cea:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
			xSwitchRequired = pdTRUE;
   12cee:	2b00      	cmp	r3, #0
}
   12cf0:	bf0c      	ite	eq
   12cf2:	4628      	moveq	r0, r5
   12cf4:	2001      	movne	r0, #1
   12cf6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12cfa:	f8df 8078 	ldr.w	r8, [pc, #120]	; 12d74 <xTaskIncrementTick+0xfc>
					prvAddTaskToReadyList(pxTCB);
   12cfe:	f8df 9078 	ldr.w	r9, [pc, #120]	; 12d78 <xTaskIncrementTick+0x100>
   12d02:	f04f 0a14 	mov.w	sl, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   12d06:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12d0a:	681b      	ldr	r3, [r3, #0]
   12d0c:	b923      	cbnz	r3, 12d18 <xTaskIncrementTick+0xa0>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   12d0e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
						xNextTaskUnblockTime = xItemValue;
   12d12:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
						break;
   12d16:	e7df      	b.n	12cd8 <xTaskIncrementTick+0x60>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   12d18:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   12d1c:	68db      	ldr	r3, [r3, #12]
   12d1e:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
   12d20:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
   12d22:	429f      	cmp	r7, r3
   12d24:	d3f5      	bcc.n	12d12 <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12d26:	f106 0b04 	add.w	fp, r6, #4
   12d2a:	4658      	mov	r0, fp
   12d2c:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
   12d2e:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   12d30:	b113      	cbz	r3, 12d38 <xTaskIncrementTick+0xc0>
						(void)uxListRemove(&(pxTCB->xEventListItem));
   12d32:	f106 0018 	add.w	r0, r6, #24
   12d36:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
   12d38:	6af0      	ldr	r0, [r6, #44]	; 0x2c
   12d3a:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   12d3e:	4298      	cmp	r0, r3
   12d40:	bf88      	it	hi
   12d42:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   12d46:	4659      	mov	r1, fp
   12d48:	fb0a 4000 	mla	r0, sl, r0, r4
   12d4c:	47c8      	blx	r9
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   12d4e:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12d52:	6af2      	ldr	r2, [r6, #44]	; 0x2c
   12d54:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   12d56:	429a      	cmp	r2, r3
   12d58:	bf28      	it	cs
   12d5a:	2501      	movcs	r5, #1
   12d5c:	e7d3      	b.n	12d06 <xTaskIncrementTick+0x8e>
		++uxPendedTicks;
   12d5e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
   12d62:	3301      	adds	r3, #1
   12d64:	f8c4 3300 	str.w	r3, [r4, #768]	; 0x300
	BaseType_t xSwitchRequired = pdFALSE;
   12d68:	2500      	movs	r5, #0
   12d6a:	e7be      	b.n	12cea <xTaskIncrementTick+0x72>
   12d6c:	20008df8 	.word	0x20008df8
   12d70:	0001296d 	.word	0x0001296d
   12d74:	0000b557 	.word	0x0000b557
   12d78:	0000b511 	.word	0x0000b511

00012d7c <xTaskResumeAll>:
{
   12d7c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
   12d80:	4c33      	ldr	r4, [pc, #204]	; (12e50 <xTaskResumeAll+0xd4>)
   12d82:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   12d86:	b943      	cbnz	r3, 12d9a <xTaskResumeAll+0x1e>
   12d88:	f04f 0380 	mov.w	r3, #128	; 0x80
   12d8c:	f383 8811 	msr	BASEPRI, r3
   12d90:	f3bf 8f6f 	isb	sy
   12d94:	f3bf 8f4f 	dsb	sy
   12d98:	e7fe      	b.n	12d98 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
   12d9a:	4b2e      	ldr	r3, [pc, #184]	; (12e54 <xTaskResumeAll+0xd8>)
   12d9c:	4798      	blx	r3
		--uxSchedulerSuspended;
   12d9e:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   12da2:	3b01      	subs	r3, #1
   12da4:	f8c4 32f4 	str.w	r3, [r4, #756]	; 0x2f4
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12da8:	f8d4 52f4 	ldr.w	r5, [r4, #756]	; 0x2f4
   12dac:	b135      	cbz	r5, 12dbc <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
   12dae:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   12db0:	4b29      	ldr	r3, [pc, #164]	; (12e58 <xTaskResumeAll+0xdc>)
   12db2:	4798      	blx	r3
}
   12db4:	4620      	mov	r0, r4
   12db6:	b002      	add	sp, #8
   12db8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
   12dbc:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
   12dc0:	2b00      	cmp	r3, #0
   12dc2:	d0f4      	beq.n	12dae <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12dc4:	4e25      	ldr	r6, [pc, #148]	; (12e5c <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
   12dc6:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 12e6c <xTaskResumeAll+0xf0>
   12dca:	2714      	movs	r7, #20
   12dcc:	e01d      	b.n	12e0a <xTaskResumeAll+0x8e>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
   12dce:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
   12dd2:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
   12dd4:	f105 0018 	add.w	r0, r5, #24
   12dd8:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
   12dda:	1d29      	adds	r1, r5, #4
   12ddc:	4608      	mov	r0, r1
   12dde:	9101      	str	r1, [sp, #4]
   12de0:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
   12de2:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   12de4:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   12de8:	9901      	ldr	r1, [sp, #4]
   12dea:	4298      	cmp	r0, r3
   12dec:	bf88      	it	hi
   12dee:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   12df2:	fb07 4000 	mla	r0, r7, r0, r4
   12df6:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   12df8:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12dfc:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   12dfe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   12e00:	429a      	cmp	r2, r3
   12e02:	d302      	bcc.n	12e0a <xTaskResumeAll+0x8e>
						xYieldPending = pdTRUE;
   12e04:	2301      	movs	r3, #1
   12e06:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
   12e0a:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
   12e0e:	2b00      	cmp	r3, #0
   12e10:	d1dd      	bne.n	12dce <xTaskResumeAll+0x52>
				if (pxTCB != NULL) {
   12e12:	b10d      	cbz	r5, 12e18 <xTaskResumeAll+0x9c>
					prvResetNextTaskUnblockTime();
   12e14:	4b12      	ldr	r3, [pc, #72]	; (12e60 <xTaskResumeAll+0xe4>)
   12e16:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   12e18:	f8d4 5300 	ldr.w	r5, [r4, #768]	; 0x300
					if (uxPendedCounts > (UBaseType_t)0U) {
   12e1c:	b14d      	cbz	r5, 12e32 <xTaskResumeAll+0xb6>
							if (xTaskIncrementTick() != pdFALSE) {
   12e1e:	4e11      	ldr	r6, [pc, #68]	; (12e64 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
   12e20:	2701      	movs	r7, #1
							if (xTaskIncrementTick() != pdFALSE) {
   12e22:	47b0      	blx	r6
   12e24:	b108      	cbz	r0, 12e2a <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
   12e26:	f8c4 7304 	str.w	r7, [r4, #772]	; 0x304
						} while (uxPendedCounts > (UBaseType_t)0U);
   12e2a:	3d01      	subs	r5, #1
   12e2c:	d1f9      	bne.n	12e22 <xTaskResumeAll+0xa6>
						uxPendedTicks = 0;
   12e2e:	f8c4 5300 	str.w	r5, [r4, #768]	; 0x300
				if (xYieldPending != pdFALSE) {
   12e32:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
   12e36:	2b00      	cmp	r3, #0
   12e38:	d0b9      	beq.n	12dae <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
   12e3a:	4b0b      	ldr	r3, [pc, #44]	; (12e68 <xTaskResumeAll+0xec>)
   12e3c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12e40:	601a      	str	r2, [r3, #0]
   12e42:	f3bf 8f4f 	dsb	sy
   12e46:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   12e4a:	2401      	movs	r4, #1
   12e4c:	e7b0      	b.n	12db0 <xTaskResumeAll+0x34>
   12e4e:	bf00      	nop
   12e50:	20008df8 	.word	0x20008df8
   12e54:	0000b645 	.word	0x0000b645
   12e58:	0000b689 	.word	0x0000b689
   12e5c:	0000b557 	.word	0x0000b557
   12e60:	0001296d 	.word	0x0001296d
   12e64:	00012c79 	.word	0x00012c79
   12e68:	e000ed04 	.word	0xe000ed04
   12e6c:	0000b511 	.word	0x0000b511

00012e70 <vTaskDelay>:
{
   12e70:	b508      	push	{r3, lr}
	if (xTicksToDelay > (TickType_t)0U) {
   12e72:	b940      	cbnz	r0, 12e86 <vTaskDelay+0x16>
		portYIELD_WITHIN_API();
   12e74:	4b0f      	ldr	r3, [pc, #60]	; (12eb4 <vTaskDelay+0x44>)
   12e76:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   12e7a:	601a      	str	r2, [r3, #0]
   12e7c:	f3bf 8f4f 	dsb	sy
   12e80:	f3bf 8f6f 	isb	sy
}
   12e84:	bd08      	pop	{r3, pc}
		configASSERT(uxSchedulerSuspended == 0);
   12e86:	4b0c      	ldr	r3, [pc, #48]	; (12eb8 <vTaskDelay+0x48>)
   12e88:	f8d3 12f4 	ldr.w	r1, [r3, #756]	; 0x2f4
   12e8c:	b141      	cbz	r1, 12ea0 <vTaskDelay+0x30>
   12e8e:	f04f 0380 	mov.w	r3, #128	; 0x80
   12e92:	f383 8811 	msr	BASEPRI, r3
   12e96:	f3bf 8f6f 	isb	sy
   12e9a:	f3bf 8f4f 	dsb	sy
   12e9e:	e7fe      	b.n	12e9e <vTaskDelay+0x2e>
		vTaskSuspendAll();
   12ea0:	4b06      	ldr	r3, [pc, #24]	; (12ebc <vTaskDelay+0x4c>)
   12ea2:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
   12ea4:	4b06      	ldr	r3, [pc, #24]	; (12ec0 <vTaskDelay+0x50>)
   12ea6:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
   12ea8:	4b06      	ldr	r3, [pc, #24]	; (12ec4 <vTaskDelay+0x54>)
   12eaa:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
   12eac:	2800      	cmp	r0, #0
   12eae:	d0e1      	beq.n	12e74 <vTaskDelay+0x4>
   12eb0:	e7e8      	b.n	12e84 <vTaskDelay+0x14>
   12eb2:	bf00      	nop
   12eb4:	e000ed04 	.word	0xe000ed04
   12eb8:	20008df8 	.word	0x20008df8
   12ebc:	00012c35 	.word	0x00012c35
   12ec0:	00012991 	.word	0x00012991
   12ec4:	00012d7d 	.word	0x00012d7d

00012ec8 <vTaskSwitchContext>:
{
   12ec8:	b538      	push	{r3, r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
   12eca:	4b20      	ldr	r3, [pc, #128]	; (12f4c <vTaskSwitchContext+0x84>)
   12ecc:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   12ed0:	461c      	mov	r4, r3
   12ed2:	b11a      	cbz	r2, 12edc <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
   12ed4:	2201      	movs	r2, #1
   12ed6:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   12eda:	bd38      	pop	{r3, r4, r5, pc}
		xYieldPending = pdFALSE;
   12edc:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		taskCHECK_FOR_STACK_OVERFLOW();
   12ee0:	f8d3 22b4 	ldr.w	r2, [r3, #692]	; 0x2b4
   12ee4:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
   12ee8:	6812      	ldr	r2, [r2, #0]
   12eea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   12eec:	429a      	cmp	r2, r3
   12eee:	d806      	bhi.n	12efe <vTaskSwitchContext+0x36>
   12ef0:	f8d4 02b4 	ldr.w	r0, [r4, #692]	; 0x2b4
   12ef4:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12ef8:	4b15      	ldr	r3, [pc, #84]	; (12f50 <vTaskSwitchContext+0x88>)
   12efa:	3134      	adds	r1, #52	; 0x34
   12efc:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12efe:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   12f02:	2514      	movs	r5, #20
   12f04:	fb05 f302 	mul.w	r3, r5, r2
   12f08:	18e1      	adds	r1, r4, r3
   12f0a:	58e0      	ldr	r0, [r4, r3]
   12f0c:	b190      	cbz	r0, 12f34 <vTaskSwitchContext+0x6c>
   12f0e:	6848      	ldr	r0, [r1, #4]
   12f10:	3308      	adds	r3, #8
   12f12:	6840      	ldr	r0, [r0, #4]
   12f14:	6048      	str	r0, [r1, #4]
   12f16:	4423      	add	r3, r4
   12f18:	4298      	cmp	r0, r3
   12f1a:	bf04      	itt	eq
   12f1c:	6843      	ldreq	r3, [r0, #4]
   12f1e:	604b      	streq	r3, [r1, #4]
   12f20:	2314      	movs	r3, #20
   12f22:	fb03 4302 	mla	r3, r3, r2, r4
   12f26:	685b      	ldr	r3, [r3, #4]
   12f28:	68db      	ldr	r3, [r3, #12]
   12f2a:	f8c4 32b4 	str.w	r3, [r4, #692]	; 0x2b4
   12f2e:	f8c4 22f0 	str.w	r2, [r4, #752]	; 0x2f0
}
   12f32:	e7d2      	b.n	12eda <vTaskSwitchContext+0x12>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   12f34:	b942      	cbnz	r2, 12f48 <vTaskSwitchContext+0x80>
   12f36:	f04f 0380 	mov.w	r3, #128	; 0x80
   12f3a:	f383 8811 	msr	BASEPRI, r3
   12f3e:	f3bf 8f6f 	isb	sy
   12f42:	f3bf 8f4f 	dsb	sy
   12f46:	e7fe      	b.n	12f46 <vTaskSwitchContext+0x7e>
   12f48:	3a01      	subs	r2, #1
   12f4a:	e7db      	b.n	12f04 <vTaskSwitchContext+0x3c>
   12f4c:	20008df8 	.word	0x20008df8
   12f50:	00012485 	.word	0x00012485

00012f54 <vTaskPlaceOnEventList>:
{
   12f54:	b510      	push	{r4, lr}
   12f56:	460c      	mov	r4, r1
	configASSERT(pxEventList);
   12f58:	b940      	cbnz	r0, 12f6c <vTaskPlaceOnEventList+0x18>
   12f5a:	f04f 0380 	mov.w	r3, #128	; 0x80
   12f5e:	f383 8811 	msr	BASEPRI, r3
   12f62:	f3bf 8f6f 	isb	sy
   12f66:	f3bf 8f4f 	dsb	sy
   12f6a:	e7fe      	b.n	12f6a <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
   12f6c:	4b05      	ldr	r3, [pc, #20]	; (12f84 <vTaskPlaceOnEventList+0x30>)
   12f6e:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   12f72:	4b05      	ldr	r3, [pc, #20]	; (12f88 <vTaskPlaceOnEventList+0x34>)
   12f74:	3118      	adds	r1, #24
   12f76:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12f78:	4620      	mov	r0, r4
   12f7a:	4b04      	ldr	r3, [pc, #16]	; (12f8c <vTaskPlaceOnEventList+0x38>)
}
   12f7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   12f80:	2101      	movs	r1, #1
   12f82:	4718      	bx	r3
   12f84:	20008df8 	.word	0x20008df8
   12f88:	0000b529 	.word	0x0000b529
   12f8c:	00012991 	.word	0x00012991

00012f90 <vTaskPlaceOnEventListRestricted>:
{
   12f90:	b570      	push	{r4, r5, r6, lr}
   12f92:	460d      	mov	r5, r1
   12f94:	4614      	mov	r4, r2
	configASSERT(pxEventList);
   12f96:	b940      	cbnz	r0, 12faa <vTaskPlaceOnEventListRestricted+0x1a>
   12f98:	f04f 0380 	mov.w	r3, #128	; 0x80
   12f9c:	f383 8811 	msr	BASEPRI, r3
   12fa0:	f3bf 8f6f 	isb	sy
   12fa4:	f3bf 8f4f 	dsb	sy
   12fa8:	e7fe      	b.n	12fa8 <vTaskPlaceOnEventListRestricted+0x18>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
   12faa:	4b08      	ldr	r3, [pc, #32]	; (12fcc <vTaskPlaceOnEventListRestricted+0x3c>)
   12fac:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   12fb0:	4b07      	ldr	r3, [pc, #28]	; (12fd0 <vTaskPlaceOnEventListRestricted+0x40>)
   12fb2:	3118      	adds	r1, #24
   12fb4:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
   12fb6:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12fb8:	4621      	mov	r1, r4
   12fba:	bf08      	it	eq
   12fbc:	4628      	moveq	r0, r5
   12fbe:	4b05      	ldr	r3, [pc, #20]	; (12fd4 <vTaskPlaceOnEventListRestricted+0x44>)
}
   12fc0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   12fc4:	bf18      	it	ne
   12fc6:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   12fca:	4718      	bx	r3
   12fcc:	20008df8 	.word	0x20008df8
   12fd0:	0000b511 	.word	0x0000b511
   12fd4:	00012991 	.word	0x00012991

00012fd8 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12fd8:	68c3      	ldr	r3, [r0, #12]
{
   12fda:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   12fdc:	68df      	ldr	r7, [r3, #12]
	configASSERT(pxUnblockedTCB);
   12fde:	b947      	cbnz	r7, 12ff2 <xTaskRemoveFromEventList+0x1a>
   12fe0:	f04f 0380 	mov.w	r3, #128	; 0x80
   12fe4:	f383 8811 	msr	BASEPRI, r3
   12fe8:	f3bf 8f6f 	isb	sy
   12fec:	f3bf 8f4f 	dsb	sy
   12ff0:	e7fe      	b.n	12ff0 <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12ff2:	f107 0118 	add.w	r1, r7, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   12ff6:	4c15      	ldr	r4, [pc, #84]	; (1304c <xTaskRemoveFromEventList+0x74>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   12ff8:	4e15      	ldr	r6, [pc, #84]	; (13050 <xTaskRemoveFromEventList+0x78>)
   12ffa:	9101      	str	r1, [sp, #4]
   12ffc:	4608      	mov	r0, r1
   12ffe:	47b0      	blx	r6
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   13000:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   13004:	4d13      	ldr	r5, [pc, #76]	; (13054 <xTaskRemoveFromEventList+0x7c>)
   13006:	9901      	ldr	r1, [sp, #4]
   13008:	b9e3      	cbnz	r3, 13044 <xTaskRemoveFromEventList+0x6c>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
   1300a:	1d39      	adds	r1, r7, #4
   1300c:	4608      	mov	r0, r1
   1300e:	9101      	str	r1, [sp, #4]
   13010:	47b0      	blx	r6
		prvAddTaskToReadyList(pxUnblockedTCB);
   13012:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   13014:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   13018:	9901      	ldr	r1, [sp, #4]
   1301a:	4293      	cmp	r3, r2
   1301c:	f04f 0014 	mov.w	r0, #20
   13020:	bf88      	it	hi
   13022:	f8c4 32f0 	strhi.w	r3, [r4, #752]	; 0x2f0
   13026:	fb00 4003 	mla	r0, r0, r3, r4
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   1302a:	47a8      	blx	r5
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
   1302c:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   13030:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   13032:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   13034:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   13036:	bf8a      	itet	hi
   13038:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
   1303a:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
   1303c:	f8c4 0304 	strhi.w	r0, [r4, #772]	; 0x304
}
   13040:	b003      	add	sp, #12
   13042:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   13044:	f504 7025 	add.w	r0, r4, #660	; 0x294
   13048:	e7ef      	b.n	1302a <xTaskRemoveFromEventList+0x52>
   1304a:	bf00      	nop
   1304c:	20008df8 	.word	0x20008df8
   13050:	0000b557 	.word	0x0000b557
   13054:	0000b511 	.word	0x0000b511

00013058 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   13058:	4b03      	ldr	r3, [pc, #12]	; (13068 <vTaskInternalSetTimeOutState+0x10>)
   1305a:	f8d3 22fc 	ldr.w	r2, [r3, #764]	; 0x2fc
	pxTimeOut->xTimeOnEntering = xTickCount;
   1305e:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   13062:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   13064:	6043      	str	r3, [r0, #4]
}
   13066:	4770      	bx	lr
   13068:	20008df8 	.word	0x20008df8

0001306c <xTaskCheckForTimeOut>:
{
   1306c:	b570      	push	{r4, r5, r6, lr}
   1306e:	460c      	mov	r4, r1
	configASSERT(pxTimeOut);
   13070:	4605      	mov	r5, r0
   13072:	b940      	cbnz	r0, 13086 <xTaskCheckForTimeOut+0x1a>
   13074:	f04f 0380 	mov.w	r3, #128	; 0x80
   13078:	f383 8811 	msr	BASEPRI, r3
   1307c:	f3bf 8f6f 	isb	sy
   13080:	f3bf 8f4f 	dsb	sy
   13084:	e7fe      	b.n	13084 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
   13086:	b941      	cbnz	r1, 1309a <xTaskCheckForTimeOut+0x2e>
   13088:	f04f 0380 	mov.w	r3, #128	; 0x80
   1308c:	f383 8811 	msr	BASEPRI, r3
   13090:	f3bf 8f6f 	isb	sy
   13094:	f3bf 8f4f 	dsb	sy
   13098:	e7fe      	b.n	13098 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
   1309a:	4b11      	ldr	r3, [pc, #68]	; (130e0 <xTaskCheckForTimeOut+0x74>)
   1309c:	4798      	blx	r3
		    if (*pxTicksToWait == portMAX_DELAY) {
   1309e:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
   130a0:	4810      	ldr	r0, [pc, #64]	; (130e4 <xTaskCheckForTimeOut+0x78>)
		    if (*pxTicksToWait == portMAX_DELAY) {
   130a2:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
   130a4:	f8d0 12b0 	ldr.w	r1, [r0, #688]	; 0x2b0
		    if (*pxTicksToWait == portMAX_DELAY) {
   130a8:	d010      	beq.n	130cc <xTaskCheckForTimeOut+0x60>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   130aa:	f8d0 02fc 	ldr.w	r0, [r0, #764]	; 0x2fc
   130ae:	682e      	ldr	r6, [r5, #0]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   130b0:	686a      	ldr	r2, [r5, #4]
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   130b2:	4286      	cmp	r6, r0
   130b4:	d001      	beq.n	130ba <xTaskCheckForTimeOut+0x4e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
   130b6:	428a      	cmp	r2, r1
   130b8:	d90f      	bls.n	130da <xTaskCheckForTimeOut+0x6e>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   130ba:	1a88      	subs	r0, r1, r2
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
   130bc:	4283      	cmp	r3, r0
   130be:	d90a      	bls.n	130d6 <xTaskCheckForTimeOut+0x6a>
			*pxTicksToWait -= xElapsedTime;
   130c0:	1a5b      	subs	r3, r3, r1
   130c2:	4413      	add	r3, r2
   130c4:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
   130c6:	4628      	mov	r0, r5
   130c8:	4b07      	ldr	r3, [pc, #28]	; (130e8 <xTaskCheckForTimeOut+0x7c>)
   130ca:	4798      	blx	r3
			xReturn = pdFALSE;
   130cc:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   130ce:	4b07      	ldr	r3, [pc, #28]	; (130ec <xTaskCheckForTimeOut+0x80>)
   130d0:	4798      	blx	r3
}
   130d2:	4620      	mov	r0, r4
   130d4:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
   130d6:	2300      	movs	r3, #0
   130d8:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
   130da:	2401      	movs	r4, #1
   130dc:	e7f7      	b.n	130ce <xTaskCheckForTimeOut+0x62>
   130de:	bf00      	nop
   130e0:	0000b645 	.word	0x0000b645
   130e4:	20008df8 	.word	0x20008df8
   130e8:	00013059 	.word	0x00013059
   130ec:	0000b689 	.word	0x0000b689

000130f0 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   130f0:	4b02      	ldr	r3, [pc, #8]	; (130fc <vTaskMissedYield+0xc>)
   130f2:	2201      	movs	r2, #1
   130f4:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   130f8:	4770      	bx	lr
   130fa:	bf00      	nop
   130fc:	20008df8 	.word	0x20008df8

00013100 <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
   13100:	4b06      	ldr	r3, [pc, #24]	; (1311c <xTaskGetSchedulerState+0x1c>)
   13102:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
   13106:	b132      	cbz	r2, 13116 <xTaskGetSchedulerState+0x16>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   13108:	f8d3 32f4 	ldr.w	r3, [r3, #756]	; 0x2f4
   1310c:	2b00      	cmp	r3, #0
			xReturn = taskSCHEDULER_SUSPENDED;
   1310e:	bf0c      	ite	eq
   13110:	2002      	moveq	r0, #2
   13112:	2000      	movne	r0, #0
   13114:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
   13116:	2001      	movs	r0, #1
}
   13118:	4770      	bx	lr
   1311a:	bf00      	nop
   1311c:	20008df8 	.word	0x20008df8

00013120 <xTaskPriorityDisinherit>:
{
   13120:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (pxMutexHolder != NULL) {
   13122:	b910      	cbnz	r0, 1312a <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
   13124:	2000      	movs	r0, #0
}
   13126:	b003      	add	sp, #12
   13128:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
   1312a:	4d1d      	ldr	r5, [pc, #116]	; (131a0 <xTaskPriorityDisinherit+0x80>)
   1312c:	f8d5 42b4 	ldr.w	r4, [r5, #692]	; 0x2b4
   13130:	4284      	cmp	r4, r0
   13132:	d008      	beq.n	13146 <xTaskPriorityDisinherit+0x26>
   13134:	f04f 0380 	mov.w	r3, #128	; 0x80
   13138:	f383 8811 	msr	BASEPRI, r3
   1313c:	f3bf 8f6f 	isb	sy
   13140:	f3bf 8f4f 	dsb	sy
   13144:	e7fe      	b.n	13144 <xTaskPriorityDisinherit+0x24>
		configASSERT(pxTCB->uxMutexesHeld);
   13146:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   13148:	b943      	cbnz	r3, 1315c <xTaskPriorityDisinherit+0x3c>
   1314a:	f04f 0380 	mov.w	r3, #128	; 0x80
   1314e:	f383 8811 	msr	BASEPRI, r3
   13152:	f3bf 8f6f 	isb	sy
   13156:	f3bf 8f4f 	dsb	sy
   1315a:	e7fe      	b.n	1315a <xTaskPriorityDisinherit+0x3a>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   1315c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   1315e:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
   13160:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   13162:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
   13164:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   13166:	d0dd      	beq.n	13124 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
   13168:	2b00      	cmp	r3, #0
   1316a:	d1db      	bne.n	13124 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
   1316c:	1d21      	adds	r1, r4, #4
   1316e:	4b0d      	ldr	r3, [pc, #52]	; (131a4 <xTaskPriorityDisinherit+0x84>)
   13170:	9101      	str	r1, [sp, #4]
   13172:	4608      	mov	r0, r1
   13174:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   13176:	6c63      	ldr	r3, [r4, #68]	; 0x44
   13178:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
   1317a:	f1c3 0220 	rsb	r2, r3, #32
   1317e:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
   13180:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
   13184:	9901      	ldr	r1, [sp, #4]
   13186:	4293      	cmp	r3, r2
   13188:	f04f 0014 	mov.w	r0, #20
   1318c:	fb00 5003 	mla	r0, r0, r3, r5
   13190:	bf88      	it	hi
   13192:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   13196:	4b04      	ldr	r3, [pc, #16]	; (131a8 <xTaskPriorityDisinherit+0x88>)
   13198:	4798      	blx	r3
				xReturn = pdTRUE;
   1319a:	2001      	movs	r0, #1
	return xReturn;
   1319c:	e7c3      	b.n	13126 <xTaskPriorityDisinherit+0x6>
   1319e:	bf00      	nop
   131a0:	20008df8 	.word	0x20008df8
   131a4:	0000b557 	.word	0x0000b557
   131a8:	0000b511 	.word	0x0000b511

000131ac <event_system_init>:
/**
 * \brief Initialize event system.
 */
int32_t event_system_init(void)
{
	return _event_system_init();
   131ac:	4b00      	ldr	r3, [pc, #0]	; (131b0 <event_system_init+0x4>)
   131ae:	4718      	bx	r3
   131b0:	0000be3d 	.word	0x0000be3d

000131b4 <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
   131b4:	6b03      	ldr	r3, [r0, #48]	; 0x30
   131b6:	420b      	tst	r3, r1
   131b8:	d1fc      	bne.n	131b4 <hri_adc_wait_for_sync>
	};
}
   131ba:	4770      	bx	lr

000131bc <hri_adc_set_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
   131bc:	8803      	ldrh	r3, [r0, #0]
   131be:	b29b      	uxth	r3, r3
   131c0:	f043 0302 	orr.w	r3, r3, #2
   131c4:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   131c6:	2103      	movs	r1, #3
   131c8:	4b00      	ldr	r3, [pc, #0]	; (131cc <hri_adc_set_CTRLA_ENABLE_bit+0x10>)
   131ca:	4718      	bx	r3
   131cc:	000131b5 	.word	0x000131b5

000131d0 <hri_adc_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
   131d0:	8803      	ldrh	r3, [r0, #0]
   131d2:	f023 0302 	bic.w	r3, r3, #2
   131d6:	041b      	lsls	r3, r3, #16
   131d8:	0c1b      	lsrs	r3, r3, #16
   131da:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   131dc:	2103      	movs	r1, #3
   131de:	4b01      	ldr	r3, [pc, #4]	; (131e4 <hri_adc_clear_CTRLA_ENABLE_bit+0x14>)
   131e0:	4718      	bx	r3
   131e2:	bf00      	nop
   131e4:	000131b5 	.word	0x000131b5

000131e8 <_adc_interrupt_handler>:
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _adc_interrupt_handler(struct _adc_async_device *device)
{
	void *const hw      = device->hw;
   131e8:	6942      	ldr	r2, [r0, #20]
	return ((Adc *)hw)->INTFLAG.reg;
   131ea:	f892 102e 	ldrb.w	r1, [r2, #46]	; 0x2e
	return ((Adc *)hw)->INTENSET.reg;
   131ee:	f892 302d 	ldrb.w	r3, [r2, #45]	; 0x2d
	uint8_t     intflag = hri_adc_read_INTFLAG_reg(hw);
	intflag &= hri_adc_read_INTEN_reg(hw);
   131f2:	400b      	ands	r3, r1
{
   131f4:	b430      	push	{r4, r5}
	if (intflag & ADC_INTFLAG_RESRDY) {
   131f6:	f013 0501 	ands.w	r5, r3, #1
   131fa:	d009      	beq.n	13210 <_adc_interrupt_handler+0x28>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_RESRDY;
   131fc:	2301      	movs	r3, #1
   131fe:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
	return ((Adc *)hw)->RESULT.reg;
   13202:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
		hri_adc_clear_interrupt_RESRDY_bit(hw);
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   13206:	6883      	ldr	r3, [r0, #8]
		device->adc_async_cb.error_cb(device, 0);
	} else if (intflag & ADC_INTFLAG_WINMON) {
		hri_adc_clear_interrupt_WINMON_bit(hw);
		device->adc_async_cb.window_cb(device, 0);
	}
}
   13208:	bc30      	pop	{r4, r5}
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   1320a:	b292      	uxth	r2, r2
   1320c:	2100      	movs	r1, #0
   1320e:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_OVERRUN) {
   13210:	f013 0102 	ands.w	r1, r3, #2
   13214:	d006      	beq.n	13224 <_adc_interrupt_handler+0x3c>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
   13216:	2302      	movs	r3, #2
   13218:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.error_cb(device, 0);
   1321c:	6843      	ldr	r3, [r0, #4]
   1321e:	4629      	mov	r1, r5
}
   13220:	bc30      	pop	{r4, r5}
		device->adc_async_cb.window_cb(device, 0);
   13222:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_WINMON) {
   13224:	075b      	lsls	r3, r3, #29
   13226:	d504      	bpl.n	13232 <_adc_interrupt_handler+0x4a>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
   13228:	2304      	movs	r3, #4
   1322a:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.window_cb(device, 0);
   1322e:	6803      	ldr	r3, [r0, #0]
   13230:	e7f6      	b.n	13220 <_adc_interrupt_handler+0x38>
}
   13232:	bc30      	pop	{r4, r5}
   13234:	4770      	bx	lr
	...

00013238 <_adc_get_regs>:
{
   13238:	b508      	push	{r3, lr}
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   1323a:	f100 433d 	add.w	r3, r0, #3170893824	; 0xbd000000
   1323e:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
		if (_adcs[i].number == n) {
   13242:	f413 3f7f 	tst.w	r3, #261120	; 0x3fc00
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   13246:	f3c3 2087 	ubfx	r0, r3, #10, #8
		if (_adcs[i].number == n) {
   1324a:	d007      	beq.n	1325c <_adc_get_regs+0x24>
   1324c:	2801      	cmp	r0, #1
   1324e:	d005      	beq.n	1325c <_adc_get_regs+0x24>
	ASSERT(false);
   13250:	2000      	movs	r0, #0
   13252:	4903      	ldr	r1, [pc, #12]	; (13260 <_adc_get_regs+0x28>)
   13254:	4b03      	ldr	r3, [pc, #12]	; (13264 <_adc_get_regs+0x2c>)
   13256:	228c      	movs	r2, #140	; 0x8c
   13258:	4798      	blx	r3
	return 0;
   1325a:	2000      	movs	r0, #0
}
   1325c:	bd08      	pop	{r3, pc}
   1325e:	bf00      	nop
   13260:	00016dda 	.word	0x00016dda
   13264:	0000e42d 	.word	0x0000e42d

00013268 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13268:	0943      	lsrs	r3, r0, #5
   1326a:	2201      	movs	r2, #1
   1326c:	f000 001f 	and.w	r0, r0, #31
   13270:	fa02 f000 	lsl.w	r0, r2, r0
   13274:	3360      	adds	r3, #96	; 0x60
   13276:	4a02      	ldr	r2, [pc, #8]	; (13280 <__NVIC_ClearPendingIRQ+0x18>)
   13278:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   1327c:	4770      	bx	lr
   1327e:	bf00      	nop
   13280:	e000e100 	.word	0xe000e100

00013284 <_adc_get_irq_num.isra.0>:
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   13284:	f100 403d 	add.w	r0, r0, #3170893824	; 0xbd000000
   13288:	f5a0 50e0 	sub.w	r0, r0, #7168	; 0x1c00
   1328c:	0a80      	lsrs	r0, r0, #10
	return ADC0_0_IRQn + (_adc_get_hardware_index(device->hw) << 1);
   1328e:	0040      	lsls	r0, r0, #1
   13290:	3076      	adds	r0, #118	; 0x76
}
   13292:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   13296:	4770      	bx	lr

00013298 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13298:	0943      	lsrs	r3, r0, #5
   1329a:	2201      	movs	r2, #1
   1329c:	f000 001f 	and.w	r0, r0, #31
   132a0:	fa02 f000 	lsl.w	r0, r2, r0
   132a4:	3320      	adds	r3, #32
   132a6:	4a04      	ldr	r2, [pc, #16]	; (132b8 <__NVIC_DisableIRQ+0x20>)
   132a8:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   132ac:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   132b0:	f3bf 8f6f 	isb	sy
}
   132b4:	4770      	bx	lr
   132b6:	bf00      	nop
   132b8:	e000e100 	.word	0xe000e100

000132bc <_adc_init>:
{
   132bc:	b538      	push	{r3, r4, r5, lr}
	if (hw == ADC0) {
   132be:	4b39      	ldr	r3, [pc, #228]	; (133a4 <_adc_init+0xe8>)
   132c0:	4298      	cmp	r0, r3
{
   132c2:	460c      	mov	r4, r1
	if (hw == ADC0) {
   132c4:	d15c      	bne.n	13380 <_adc_init+0xc4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   132c6:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   132ca:	681b      	ldr	r3, [r3, #0]
   132cc:	00da      	lsls	r2, r3, #3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   132ce:	0919      	lsrs	r1, r3, #4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   132d0:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   132d4:	f001 0170 	and.w	r1, r1, #112	; 0x70
   132d8:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
   132da:	f3c3 0382 	ubfx	r3, r3, #2, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   132de:	431a      	orrs	r2, r3
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
   132e0:	6b03      	ldr	r3, [r0, #48]	; 0x30
   132e2:	4d31      	ldr	r5, [pc, #196]	; (133a8 <_adc_init+0xec>)
	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
   132e4:	f013 0f01 	tst.w	r3, #1
   132e8:	d10c      	bne.n	13304 <_adc_init+0x48>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   132ea:	2103      	movs	r1, #3
   132ec:	47a8      	blx	r5
	tmp = ((Adc *)hw)->CTRLA.reg;
   132ee:	8803      	ldrh	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
   132f0:	079b      	lsls	r3, r3, #30
   132f2:	d503      	bpl.n	132fc <_adc_init+0x40>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
   132f4:	4b2d      	ldr	r3, [pc, #180]	; (133ac <_adc_init+0xf0>)
   132f6:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
   132f8:	2102      	movs	r1, #2
   132fa:	47a8      	blx	r5
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
   132fc:	2301      	movs	r3, #1
   132fe:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   13300:	2103      	movs	r1, #3
   13302:	47a8      	blx	r5
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
   13304:	2101      	movs	r1, #1
   13306:	47a8      	blx	r5
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
   13308:	4929      	ldr	r1, [pc, #164]	; (133b0 <_adc_init+0xf4>)
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
   1330a:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
   1330e:	2316      	movs	r3, #22
   13310:	fb03 1404 	mla	r4, r3, r4, r1
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   13314:	f640 71ff 	movw	r1, #4095	; 0xfff
   13318:	88a3      	ldrh	r3, [r4, #4]
	((Adc *)hw)->CTRLB.reg = data;
   1331a:	80c3      	strh	r3, [r0, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   1331c:	47a8      	blx	r5
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
   1331e:	79a3      	ldrb	r3, [r4, #6]
	((Adc *)hw)->REFCTRL.reg = data;
   13320:	7203      	strb	r3, [r0, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   13322:	f640 71ff 	movw	r1, #4095	; 0xfff
   13326:	47a8      	blx	r5
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
   13328:	79e3      	ldrb	r3, [r4, #7]
	((Adc *)hw)->EVCTRL.reg = data;
   1332a:	7083      	strb	r3, [r0, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
   1332c:	8923      	ldrh	r3, [r4, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
   1332e:	8083      	strh	r3, [r0, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   13330:	f640 71ff 	movw	r1, #4095	; 0xfff
   13334:	47a8      	blx	r5
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
   13336:	7aa3      	ldrb	r3, [r4, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
   13338:	7283      	strb	r3, [r0, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   1333a:	f640 71ff 	movw	r1, #4095	; 0xfff
   1333e:	47a8      	blx	r5
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
   13340:	7ae3      	ldrb	r3, [r4, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
   13342:	72c3      	strb	r3, [r0, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   13344:	f640 71ff 	movw	r1, #4095	; 0xfff
   13348:	47a8      	blx	r5
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
   1334a:	89a3      	ldrh	r3, [r4, #12]
	((Adc *)hw)->WINLT.reg = data;
   1334c:	8183      	strh	r3, [r0, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
   1334e:	2180      	movs	r1, #128	; 0x80
   13350:	47a8      	blx	r5
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
   13352:	89e3      	ldrh	r3, [r4, #14]
	((Adc *)hw)->WINUT.reg = data;
   13354:	81c3      	strh	r3, [r0, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
   13356:	f44f 7180 	mov.w	r1, #256	; 0x100
   1335a:	47a8      	blx	r5
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
   1335c:	8a23      	ldrh	r3, [r4, #16]
	((Adc *)hw)->GAINCORR.reg = data;
   1335e:	8203      	strh	r3, [r0, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
   13360:	f44f 7100 	mov.w	r1, #512	; 0x200
   13364:	47a8      	blx	r5
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
   13366:	8a63      	ldrh	r3, [r4, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
   13368:	8243      	strh	r3, [r0, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
   1336a:	f44f 6180 	mov.w	r1, #1024	; 0x400
   1336e:	47a8      	blx	r5
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
   13370:	7d23      	ldrb	r3, [r4, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
   13372:	70c3      	strb	r3, [r0, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
   13374:	8863      	ldrh	r3, [r4, #2]
	((Adc *)hw)->CTRLA.reg = data;
   13376:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   13378:	2103      	movs	r1, #3
   1337a:	47a8      	blx	r5
}
   1337c:	2000      	movs	r0, #0
   1337e:	bd38      	pop	{r3, r4, r5, pc}
	} else if (hw == ADC1) {
   13380:	4b0c      	ldr	r3, [pc, #48]	; (133b4 <_adc_init+0xf8>)
   13382:	4298      	cmp	r0, r3
   13384:	d10c      	bne.n	133a0 <_adc_init+0xe4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   13386:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   1338a:	681b      	ldr	r3, [r3, #0]
   1338c:	0ada      	lsrs	r2, r3, #11
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   1338e:	0c99      	lsrs	r1, r3, #18
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   13390:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   13394:	f001 0170 	and.w	r1, r1, #112	; 0x70
   13398:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
   1339a:	f3c3 4302 	ubfx	r3, r3, #16, #3
   1339e:	e79e      	b.n	132de <_adc_init+0x22>
	uint16_t calib_reg = 0;
   133a0:	2200      	movs	r2, #0
   133a2:	e79d      	b.n	132e0 <_adc_init+0x24>
   133a4:	43001c00 	.word	0x43001c00
   133a8:	000131b5 	.word	0x000131b5
   133ac:	000131d1 	.word	0x000131d1
   133b0:	00016df0 	.word	0x00016df0
   133b4:	43002000 	.word	0x43002000

000133b8 <_adc_async_init>:
{
   133b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ASSERT(device);
   133bc:	4604      	mov	r4, r0
   133be:	3800      	subs	r0, #0
   133c0:	bf18      	it	ne
   133c2:	2001      	movne	r0, #1
{
   133c4:	460d      	mov	r5, r1
	ASSERT(device);
   133c6:	22f1      	movs	r2, #241	; 0xf1
   133c8:	4923      	ldr	r1, [pc, #140]	; (13458 <_adc_async_init+0xa0>)
   133ca:	4b24      	ldr	r3, [pc, #144]	; (1345c <_adc_async_init+0xa4>)
   133cc:	4798      	blx	r3
	init_status = _adc_init(hw, _adc_get_regs((uint32_t)hw));
   133ce:	4b24      	ldr	r3, [pc, #144]	; (13460 <_adc_async_init+0xa8>)
   133d0:	4628      	mov	r0, r5
   133d2:	4798      	blx	r3
   133d4:	4b23      	ldr	r3, [pc, #140]	; (13464 <_adc_async_init+0xac>)
   133d6:	4601      	mov	r1, r0
   133d8:	4628      	mov	r0, r5
   133da:	4798      	blx	r3
	if (init_status) {
   133dc:	4606      	mov	r6, r0
   133de:	2800      	cmp	r0, #0
   133e0:	d130      	bne.n	13444 <_adc_async_init+0x8c>
	if (hw == ADC0) {
   133e2:	4b21      	ldr	r3, [pc, #132]	; (13468 <_adc_async_init+0xb0>)
	device->hw = hw;
   133e4:	6165      	str	r5, [r4, #20]
	if (hw == ADC0) {
   133e6:	429d      	cmp	r5, r3
   133e8:	d12f      	bne.n	1344a <_adc_async_init+0x92>
		_adc0_dev = dev;
   133ea:	4b20      	ldr	r3, [pc, #128]	; (1346c <_adc_async_init+0xb4>)
   133ec:	601c      	str	r4, [r3, #0]
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   133ee:	4920      	ldr	r1, [pc, #128]	; (13470 <_adc_async_init+0xb8>)
   133f0:	f8df 9088 	ldr.w	r9, [pc, #136]	; 1347c <_adc_async_init+0xc4>
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   133f4:	f8df 8088 	ldr.w	r8, [pc, #136]	; 13480 <_adc_async_init+0xc8>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   133f8:	4f1e      	ldr	r7, [pc, #120]	; (13474 <_adc_async_init+0xbc>)
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   133fa:	4628      	mov	r0, r5
   133fc:	4788      	blx	r1
   133fe:	b200      	sxth	r0, r0
   13400:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   13402:	6960      	ldr	r0, [r4, #20]
   13404:	4788      	blx	r1
   13406:	b200      	sxth	r0, r0
   13408:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 0);
   1340a:	6960      	ldr	r0, [r4, #20]
   1340c:	4788      	blx	r1
   1340e:	2501      	movs	r5, #1
   13410:	0942      	lsrs	r2, r0, #5
   13412:	f000 031f 	and.w	r3, r0, #31
   13416:	fa05 f303 	lsl.w	r3, r5, r3
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 1);
   1341a:	4428      	add	r0, r5
   1341c:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
   13420:	b200      	sxth	r0, r0
   13422:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 1);
   13424:	6960      	ldr	r0, [r4, #20]
   13426:	4788      	blx	r1
   13428:	4428      	add	r0, r5
   1342a:	b200      	sxth	r0, r0
   1342c:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 1);
   1342e:	6960      	ldr	r0, [r4, #20]
   13430:	4788      	blx	r1
   13432:	1943      	adds	r3, r0, r5
   13434:	f3c3 124a 	ubfx	r2, r3, #5, #11
   13438:	f003 031f 	and.w	r3, r3, #31
   1343c:	fa05 f303 	lsl.w	r3, r5, r3
   13440:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
}
   13444:	4630      	mov	r0, r6
   13446:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (hw == ADC1) {
   1344a:	4b0b      	ldr	r3, [pc, #44]	; (13478 <_adc_async_init+0xc0>)
   1344c:	429d      	cmp	r5, r3
		_adc1_dev = dev;
   1344e:	bf04      	itt	eq
   13450:	4b06      	ldreq	r3, [pc, #24]	; (1346c <_adc_async_init+0xb4>)
   13452:	605c      	streq	r4, [r3, #4]
   13454:	e7cb      	b.n	133ee <_adc_async_init+0x36>
   13456:	bf00      	nop
   13458:	00016dda 	.word	0x00016dda
   1345c:	0000e42d 	.word	0x0000e42d
   13460:	00013239 	.word	0x00013239
   13464:	000132bd 	.word	0x000132bd
   13468:	43001c00 	.word	0x43001c00
   1346c:	20009100 	.word	0x20009100
   13470:	00013285 	.word	0x00013285
   13474:	e000e100 	.word	0xe000e100
   13478:	43002000 	.word	0x43002000
   1347c:	00013299 	.word	0x00013299
   13480:	00013269 	.word	0x00013269

00013484 <_adc_async_enable_channel>:
	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
   13484:	6940      	ldr	r0, [r0, #20]
   13486:	4b01      	ldr	r3, [pc, #4]	; (1348c <_adc_async_enable_channel+0x8>)
   13488:	4718      	bx	r3
   1348a:	bf00      	nop
   1348c:	000131bd 	.word	0x000131bd

00013490 <_adc_async_get_data_size>:
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
   13490:	6943      	ldr	r3, [r0, #20]
	tmp = ((Adc *)hw)->CTRLB.reg;
   13492:	88db      	ldrh	r3, [r3, #6]
   13494:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   13498:	2b03      	cmp	r3, #3
}
   1349a:	bf0c      	ite	eq
   1349c:	2001      	moveq	r0, #1
   1349e:	2002      	movne	r0, #2
   134a0:	4770      	bx	lr
	...

000134a4 <_adc_async_convert>:
	hri_adc_set_SWTRIG_START_bit(device->hw);
   134a4:	6940      	ldr	r0, [r0, #20]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
   134a6:	7d03      	ldrb	r3, [r0, #20]
   134a8:	f043 0302 	orr.w	r3, r3, #2
   134ac:	7503      	strb	r3, [r0, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   134ae:	f640 71ff 	movw	r1, #4095	; 0xfff
   134b2:	4b01      	ldr	r3, [pc, #4]	; (134b8 <_adc_async_convert+0x14>)
   134b4:	4718      	bx	r3
   134b6:	bf00      	nop
   134b8:	000131b5 	.word	0x000131b5

000134bc <_adc_async_set_irq_state>:
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   134bc:	2a01      	cmp	r2, #1
	void *const hw = device->hw;
   134be:	6941      	ldr	r1, [r0, #20]
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   134c0:	d104      	bne.n	134cc <_adc_async_set_irq_state+0x10>
	if (value == 0x0) {
   134c2:	2204      	movs	r2, #4
	if (value == 0x0) {
   134c4:	b93b      	cbnz	r3, 134d6 <_adc_async_set_irq_state+0x1a>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_RESRDY;
   134c6:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
   134ca:	4770      	bx	lr
	} else if (ADC_ASYNC_DEVICE_ERROR_CB == type) {
   134cc:	2a02      	cmp	r2, #2
   134ce:	d0f9      	beq.n	134c4 <_adc_async_set_irq_state+0x8>
	} else if (ADC_ASYNC_DEVICE_CONVERT_CB == type) {
   134d0:	b91a      	cbnz	r2, 134da <_adc_async_set_irq_state+0x1e>
	if (value == 0x0) {
   134d2:	2201      	movs	r2, #1
   134d4:	e7f6      	b.n	134c4 <_adc_async_set_irq_state+0x8>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_RESRDY;
   134d6:	f881 202d 	strb.w	r2, [r1, #45]	; 0x2d
}
   134da:	4770      	bx	lr

000134dc <ADC0_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC0_0_Handler(void)
{
	_adc_interrupt_handler(_adc0_dev);
   134dc:	4b01      	ldr	r3, [pc, #4]	; (134e4 <ADC0_0_Handler+0x8>)
   134de:	6818      	ldr	r0, [r3, #0]
   134e0:	4b01      	ldr	r3, [pc, #4]	; (134e8 <ADC0_0_Handler+0xc>)
   134e2:	4718      	bx	r3
   134e4:	20009100 	.word	0x20009100
   134e8:	000131e9 	.word	0x000131e9

000134ec <ADC0_1_Handler>:
   134ec:	4b00      	ldr	r3, [pc, #0]	; (134f0 <ADC0_1_Handler+0x4>)
   134ee:	4718      	bx	r3
   134f0:	000134dd 	.word	0x000134dd

000134f4 <ADC1_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC1_0_Handler(void)
{
	_adc_interrupt_handler(_adc1_dev);
   134f4:	4b01      	ldr	r3, [pc, #4]	; (134fc <ADC1_0_Handler+0x8>)
   134f6:	6858      	ldr	r0, [r3, #4]
   134f8:	4b01      	ldr	r3, [pc, #4]	; (13500 <ADC1_0_Handler+0xc>)
   134fa:	4718      	bx	r3
   134fc:	20009100 	.word	0x20009100
   13500:	000131e9 	.word	0x000131e9

00013504 <ADC1_1_Handler>:
   13504:	4b00      	ldr	r3, [pc, #0]	; (13508 <ADC1_1_Handler+0x4>)
   13506:	4718      	bx	r3
   13508:	000134f5 	.word	0x000134f5

0001350c <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
   1350c:	e7fe      	b.n	1350c <Dummy_Handler>
	...

00013510 <Reset_Handler>:
{
   13510:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
   13512:	4a14      	ldr	r2, [pc, #80]	; (13564 <Reset_Handler+0x54>)
   13514:	4b14      	ldr	r3, [pc, #80]	; (13568 <Reset_Handler+0x58>)
   13516:	429a      	cmp	r2, r3
   13518:	d002      	beq.n	13520 <Reset_Handler+0x10>
		for (; pDest < &_erelocate;) {
   1351a:	4914      	ldr	r1, [pc, #80]	; (1356c <Reset_Handler+0x5c>)
   1351c:	428b      	cmp	r3, r1
   1351e:	d318      	bcc.n	13552 <Reset_Handler+0x42>
	pSrc  = &_etext;
   13520:	4b13      	ldr	r3, [pc, #76]	; (13570 <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
   13522:	4a14      	ldr	r2, [pc, #80]	; (13574 <Reset_Handler+0x64>)
		*pDest++ = 0;
   13524:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
   13526:	4293      	cmp	r3, r2
   13528:	d318      	bcc.n	1355c <Reset_Handler+0x4c>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
   1352a:	4a13      	ldr	r2, [pc, #76]	; (13578 <Reset_Handler+0x68>)
   1352c:	4b13      	ldr	r3, [pc, #76]	; (1357c <Reset_Handler+0x6c>)
   1352e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   13532:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
   13534:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   13538:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   1353c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   13540:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13544:	f3bf 8f6f 	isb	sy
	__libc_init_array();
   13548:	4b0d      	ldr	r3, [pc, #52]	; (13580 <Reset_Handler+0x70>)
   1354a:	4798      	blx	r3
	main();
   1354c:	4b0d      	ldr	r3, [pc, #52]	; (13584 <Reset_Handler+0x74>)
   1354e:	4798      	blx	r3
	while (1)
   13550:	e7fe      	b.n	13550 <Reset_Handler+0x40>
			*pDest++ = *pSrc++;
   13552:	f852 0b04 	ldr.w	r0, [r2], #4
   13556:	f843 0b04 	str.w	r0, [r3], #4
   1355a:	e7df      	b.n	1351c <Reset_Handler+0xc>
		*pDest++ = 0;
   1355c:	f843 1b04 	str.w	r1, [r3], #4
   13560:	e7e1      	b.n	13526 <Reset_Handler+0x16>
   13562:	bf00      	nop
   13564:	00016f70 	.word	0x00016f70
   13568:	20000000 	.word	0x20000000
   1356c:	200005b0 	.word	0x200005b0
   13570:	200005b0 	.word	0x200005b0
   13574:	2001cfe4 	.word	0x2001cfe4
   13578:	00004000 	.word	0x00004000
   1357c:	e000ed00 	.word	0xe000ed00
   13580:	00014751 	.word	0x00014751
   13584:	0001252d 	.word	0x0001252d

00013588 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
   13588:	b510      	push	{r4, lr}
	system_init();
   1358a:	4b04      	ldr	r3, [pc, #16]	; (1359c <atmel_start_init+0x14>)
   1358c:	4798      	blx	r3
	usb_init();
   1358e:	4b04      	ldr	r3, [pc, #16]	; (135a0 <atmel_start_init+0x18>)
   13590:	4798      	blx	r3
	stdio_redirect_init();
}
   13592:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
   13596:	4b03      	ldr	r3, [pc, #12]	; (135a4 <atmel_start_init+0x1c>)
   13598:	4718      	bx	r3
   1359a:	bf00      	nop
   1359c:	00010755 	.word	0x00010755
   135a0:	0000cd09 	.word	0x0000cd09
   135a4:	0000f0bd 	.word	0x0000f0bd

000135a8 <usbdc_unconfig>:
/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   135a8:	4b05      	ldr	r3, [pc, #20]	; (135c0 <usbdc_unconfig+0x18>)
{
   135aa:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   135ac:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
   135ae:	b904      	cbnz	r4, 135b2 <usbdc_unconfig+0xa>
		func->ctrl(func, USBDF_DISABLE, NULL);
		func = func->next;
	}
}
   135b0:	bd10      	pop	{r4, pc}
		func->ctrl(func, USBDF_DISABLE, NULL);
   135b2:	6863      	ldr	r3, [r4, #4]
   135b4:	4620      	mov	r0, r4
   135b6:	2200      	movs	r2, #0
   135b8:	2101      	movs	r1, #1
   135ba:	4798      	blx	r3
		func = func->next;
   135bc:	6824      	ldr	r4, [r4, #0]
   135be:	e7f6      	b.n	135ae <usbdc_unconfig+0x6>
   135c0:	20009108 	.word	0x20009108

000135c4 <usbdc_change_notify>:
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   135c4:	4b06      	ldr	r3, [pc, #24]	; (135e0 <usbdc_change_notify+0x1c>)
{
   135c6:	b570      	push	{r4, r5, r6, lr}
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   135c8:	68dc      	ldr	r4, [r3, #12]
{
   135ca:	4605      	mov	r5, r0
   135cc:	460e      	mov	r6, r1

	while (cg != NULL) {
   135ce:	b904      	cbnz	r4, 135d2 <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
	}
}
   135d0:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
   135d2:	6863      	ldr	r3, [r4, #4]
   135d4:	b113      	cbz	r3, 135dc <usbdc_change_notify+0x18>
			cg->cb(change, value);
   135d6:	4631      	mov	r1, r6
   135d8:	4628      	mov	r0, r5
   135da:	4798      	blx	r3
		cg = cg->next;
   135dc:	6824      	ldr	r4, [r4, #0]
   135de:	e7f6      	b.n	135ce <usbdc_change_notify+0xa>
   135e0:	20009108 	.word	0x20009108

000135e4 <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
   135e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
   135e6:	4b0c      	ldr	r3, [pc, #48]	; (13618 <usbdc_request_handler+0x34>)
   135e8:	689c      	ldr	r4, [r3, #8]
{
   135ea:	4605      	mov	r5, r0
   135ec:	460e      	mov	r6, r1
   135ee:	4617      	mov	r7, r2
	int32_t                   rc;

	while (h != NULL) {
   135f0:	b90c      	cbnz	r4, 135f6 <usbdc_request_handler+0x12>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
   135f2:	4620      	mov	r0, r4
}
   135f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (NULL != h->cb) {
   135f6:	6863      	ldr	r3, [r4, #4]
   135f8:	b90b      	cbnz	r3, 135fe <usbdc_request_handler+0x1a>
		h = h->next;
   135fa:	6824      	ldr	r4, [r4, #0]
   135fc:	e7f8      	b.n	135f0 <usbdc_request_handler+0xc>
			rc = h->cb(ep, req, stage);
   135fe:	463a      	mov	r2, r7
   13600:	4631      	mov	r1, r6
   13602:	4628      	mov	r0, r5
   13604:	4798      	blx	r3
			if (0 == rc) {
   13606:	b120      	cbz	r0, 13612 <usbdc_request_handler+0x2e>
			} else if (ERR_NOT_FOUND != rc) {
   13608:	300a      	adds	r0, #10
   1360a:	d0f6      	beq.n	135fa <usbdc_request_handler+0x16>
				return -1;
   1360c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13610:	e7f0      	b.n	135f4 <usbdc_request_handler+0x10>
				return true;
   13612:	2001      	movs	r0, #1
   13614:	e7ee      	b.n	135f4 <usbdc_request_handler+0x10>
   13616:	bf00      	nop
   13618:	20009108 	.word	0x20009108

0001361c <usbd_sof_cb>:
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   1361c:	4b04      	ldr	r3, [pc, #16]	; (13630 <usbd_sof_cb+0x14>)

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
   1361e:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   13620:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
   13622:	b904      	cbnz	r4, 13626 <usbd_sof_cb+0xa>
	usbdc_sof_notify();
}
   13624:	bd10      	pop	{r4, pc}
		if (NULL != sof->cb) {
   13626:	6863      	ldr	r3, [r4, #4]
   13628:	b103      	cbz	r3, 1362c <usbd_sof_cb+0x10>
			sof->cb();
   1362a:	4798      	blx	r3
		sof = sof->next;
   1362c:	6824      	ldr	r4, [r4, #0]
   1362e:	e7f8      	b.n	13622 <usbd_sof_cb+0x6>
   13630:	20009108 	.word	0x20009108

00013634 <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
   13634:	b510      	push	{r4, lr}
   13636:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
   13638:	460a      	mov	r2, r1
   1363a:	b119      	cbz	r1, 13644 <usbdc_cb_ctl_done+0x10>
   1363c:	2901      	cmp	r1, #1
   1363e:	d021      	beq.n	13684 <usbdc_cb_ctl_done+0x50>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
   13640:	2000      	movs	r0, #0
   13642:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
   13644:	7823      	ldrb	r3, [r4, #0]
   13646:	2b00      	cmp	r3, #0
   13648:	d1fa      	bne.n	13640 <usbdc_cb_ctl_done+0xc>
	switch (req->bRequest) {
   1364a:	7863      	ldrb	r3, [r4, #1]
   1364c:	2b05      	cmp	r3, #5
   1364e:	d00d      	beq.n	1366c <usbdc_cb_ctl_done+0x38>
   13650:	2b09      	cmp	r3, #9
   13652:	d1f5      	bne.n	13640 <usbdc_cb_ctl_done+0xc>
		usbdc.cfg_value = req->wValue;
   13654:	8862      	ldrh	r2, [r4, #2]
   13656:	4b0e      	ldr	r3, [pc, #56]	; (13690 <usbdc_cb_ctl_done+0x5c>)
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   13658:	2a00      	cmp	r2, #0
		usbdc.cfg_value = req->wValue;
   1365a:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   1365c:	bf14      	ite	ne
   1365e:	2104      	movne	r1, #4
   13660:	2103      	moveq	r1, #3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   13662:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
   13664:	2001      	movs	r0, #1
   13666:	4b0b      	ldr	r3, [pc, #44]	; (13694 <usbdc_cb_ctl_done+0x60>)
   13668:	4798      	blx	r3
		break;
   1366a:	e7e9      	b.n	13640 <usbdc_cb_ctl_done+0xc>
		usbdc_set_address(req->wValue);
   1366c:	8860      	ldrh	r0, [r4, #2]
	usb_d_set_address(addr);
   1366e:	4b0a      	ldr	r3, [pc, #40]	; (13698 <usbdc_cb_ctl_done+0x64>)
   13670:	b2c0      	uxtb	r0, r0
   13672:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   13674:	8863      	ldrh	r3, [r4, #2]
   13676:	2b00      	cmp	r3, #0
   13678:	bf18      	it	ne
   1367a:	2103      	movne	r1, #3
   1367c:	4b04      	ldr	r3, [pc, #16]	; (13690 <usbdc_cb_ctl_done+0x5c>)
   1367e:	bf08      	it	eq
   13680:	2102      	moveq	r1, #2
   13682:	e7ee      	b.n	13662 <usbdc_cb_ctl_done+0x2e>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
   13684:	4b05      	ldr	r3, [pc, #20]	; (1369c <usbdc_cb_ctl_done+0x68>)
   13686:	4621      	mov	r1, r4
   13688:	2000      	movs	r0, #0
   1368a:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
   1368c:	e7d8      	b.n	13640 <usbdc_cb_ctl_done+0xc>
   1368e:	bf00      	nop
   13690:	20009108 	.word	0x20009108
   13694:	000135c5 	.word	0x000135c5
   13698:	0000f909 	.word	0x0000f909
   1369c:	000135e5 	.word	0x000135e5

000136a0 <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
   136a0:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();

	usbdc.state       = USBD_S_DEFAULT;
   136a2:	4d0d      	ldr	r5, [pc, #52]	; (136d8 <usbdc_reset+0x38>)
	usbdc_unconfig();
   136a4:	4b0d      	ldr	r3, [pc, #52]	; (136dc <usbdc_reset+0x3c>)
	usbdc.cfg_value   = 0;
	usbdc.ifc_alt_map = 0;
   136a6:	2400      	movs	r4, #0
	usbdc.state       = USBD_S_DEFAULT;
   136a8:	2602      	movs	r6, #2
	usbdc_unconfig();
   136aa:	4798      	blx	r3
	usbdc.state       = USBD_S_DEFAULT;
   136ac:	836e      	strh	r6, [r5, #26]

	// Setup EP0
	usb_d_ep_deinit(0);
   136ae:	4620      	mov	r0, r4
   136b0:	4b0b      	ldr	r3, [pc, #44]	; (136e0 <usbdc_reset+0x40>)
	usbdc.ifc_alt_map = 0;
   136b2:	776c      	strb	r4, [r5, #29]
	usb_d_ep_deinit(0);
   136b4:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
   136b6:	4b0b      	ldr	r3, [pc, #44]	; (136e4 <usbdc_reset+0x44>)
   136b8:	7f28      	ldrb	r0, [r5, #28]
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   136ba:	4d0b      	ldr	r5, [pc, #44]	; (136e8 <usbdc_reset+0x48>)
	usb_d_ep0_init(usbdc.ctrl_size);
   136bc:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   136be:	4621      	mov	r1, r4
   136c0:	4620      	mov	r0, r4
   136c2:	4a0a      	ldr	r2, [pc, #40]	; (136ec <usbdc_reset+0x4c>)
   136c4:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
   136c6:	4620      	mov	r0, r4
   136c8:	4631      	mov	r1, r6
   136ca:	4a09      	ldr	r2, [pc, #36]	; (136f0 <usbdc_reset+0x50>)
   136cc:	47a8      	blx	r5
	usb_d_ep_enable(0);
   136ce:	4620      	mov	r0, r4
   136d0:	4b08      	ldr	r3, [pc, #32]	; (136f4 <usbdc_reset+0x54>)
}
   136d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_d_ep_enable(0);
   136d6:	4718      	bx	r3
   136d8:	20009108 	.word	0x20009108
   136dc:	000135a9 	.word	0x000135a9
   136e0:	0000f975 	.word	0x0000f975
   136e4:	0000f965 	.word	0x0000f965
   136e8:	0000fb89 	.word	0x0000fb89
   136ec:	00013731 	.word	0x00013731
   136f0:	00013635 	.word	0x00013635
   136f4:	0000f9a1 	.word	0x0000f9a1

000136f8 <usbd_event_cb>:
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
	(void)param;

	switch (ev) {
   136f8:	b110      	cbz	r0, 13700 <usbd_event_cb+0x8>
   136fa:	2801      	cmp	r0, #1
   136fc:	d002      	beq.n	13704 <usbd_event_cb+0xc>
   136fe:	4770      	bx	lr
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
   13700:	4b01      	ldr	r3, [pc, #4]	; (13708 <usbd_event_cb+0x10>)
   13702:	4718      	bx	r3
		break;

	case USB_EV_RESET:
		usbdc_reset();
   13704:	4b01      	ldr	r3, [pc, #4]	; (1370c <usbd_event_cb+0x14>)
   13706:	4718      	bx	r3
   13708:	000135c5 	.word	0x000135c5
   1370c:	000136a1 	.word	0x000136a1

00013710 <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
   13710:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   13712:	f88d 000c 	strb.w	r0, [sp, #12]
   13716:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
   1371a:	a801      	add	r0, sp, #4
   1371c:	4b03      	ldr	r3, [pc, #12]	; (1372c <usbdc_xfer+0x1c>)
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   1371e:	e9cd 1201 	strd	r1, r2, [sp, #4]
	return usb_d_ep_transfer(&xfer);
   13722:	4798      	blx	r3
}
   13724:	b005      	add	sp, #20
   13726:	f85d fb04 	ldr.w	pc, [sp], #4
   1372a:	bf00      	nop
   1372c:	0000f9e1 	.word	0x0000f9e1

00013730 <usbdc_cb_ctl_req>:
{
   13730:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   13734:	4ba6      	ldr	r3, [pc, #664]	; (139d0 <usbdc_cb_ctl_req+0x2a0>)
   13736:	2200      	movs	r2, #0
{
   13738:	4605      	mov	r5, r0
   1373a:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   1373c:	4798      	blx	r3
   1373e:	1c43      	adds	r3, r0, #1
   13740:	d008      	beq.n	13754 <usbdc_cb_ctl_req+0x24>
   13742:	2801      	cmp	r0, #1
   13744:	d034      	beq.n	137b0 <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
   13746:	7823      	ldrb	r3, [r4, #0]
   13748:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
   1374c:	d004      	beq.n	13758 <usbdc_cb_ctl_req+0x28>
   1374e:	2a80      	cmp	r2, #128	; 0x80
   13750:	f000 80ca 	beq.w	138e8 <usbdc_cb_ctl_req+0x1b8>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13754:	2000      	movs	r0, #0
   13756:	e02b      	b.n	137b0 <usbdc_cb_ctl_req+0x80>
	switch (req->bRequest) {
   13758:	7862      	ldrb	r2, [r4, #1]
   1375a:	3a01      	subs	r2, #1
   1375c:	2a0a      	cmp	r2, #10
   1375e:	d8f9      	bhi.n	13754 <usbdc_cb_ctl_req+0x24>
   13760:	a101      	add	r1, pc, #4	; (adr r1, 13768 <usbdc_cb_ctl_req+0x38>)
   13762:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   13766:	bf00      	nop
   13768:	0001381b 	.word	0x0001381b
   1376c:	00013755 	.word	0x00013755
   13770:	00013841 	.word	0x00013841
   13774:	00013755 	.word	0x00013755
   13778:	0001379f 	.word	0x0001379f
   1377c:	00013755 	.word	0x00013755
   13780:	00013755 	.word	0x00013755
   13784:	00013755 	.word	0x00013755
   13788:	00013795 	.word	0x00013795
   1378c:	00013755 	.word	0x00013755
   13790:	0001385b 	.word	0x0001385b
		if (!usbdc_set_config(req->wValue)) {
   13794:	8862      	ldrh	r2, [r4, #2]
   13796:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
   13798:	b96a      	cbnz	r2, 137b6 <usbdc_cb_ctl_req+0x86>
		usbdc_unconfig();
   1379a:	4b8e      	ldr	r3, [pc, #568]	; (139d4 <usbdc_cb_ctl_req+0x2a4>)
   1379c:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
   1379e:	2200      	movs	r2, #0
   137a0:	2301      	movs	r3, #1
   137a2:	4611      	mov	r1, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   137a4:	4c8c      	ldr	r4, [pc, #560]	; (139d8 <usbdc_cb_ctl_req+0x2a8>)
   137a6:	4628      	mov	r0, r5
   137a8:	47a0      	blx	r4
   137aa:	fab0 f080 	clz	r0, r0
   137ae:	0940      	lsrs	r0, r0, #5
}
   137b0:	b004      	add	sp, #16
   137b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
   137b6:	4c89      	ldr	r4, [pc, #548]	; (139dc <usbdc_cb_ctl_req+0x2ac>)
   137b8:	6823      	ldr	r3, [r4, #0]
   137ba:	e9d3 0100 	ldrd	r0, r1, [r3]
   137be:	4b88      	ldr	r3, [pc, #544]	; (139e0 <usbdc_cb_ctl_req+0x2b0>)
   137c0:	4798      	blx	r3
	if (NULL == cfg_desc) {
   137c2:	2800      	cmp	r0, #0
   137c4:	d0c6      	beq.n	13754 <usbdc_cb_ctl_req+0x24>
   137c6:	78c2      	ldrb	r2, [r0, #3]
   137c8:	7883      	ldrb	r3, [r0, #2]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   137ca:	4f86      	ldr	r7, [pc, #536]	; (139e4 <usbdc_cb_ctl_req+0x2b4>)
   137cc:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
   137d0:	fa10 f183 	uxtah	r1, r0, r3
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   137d4:	2204      	movs	r2, #4
	desc.eod  = cfg_desc + total_len;
   137d6:	9103      	str	r1, [sp, #12]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   137d8:	47b8      	blx	r7
	uint8_t                 last_iface = 0xFF;
   137da:	23ff      	movs	r3, #255	; 0xff
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   137dc:	9002      	str	r0, [sp, #8]
	while (NULL != desc.sod) {
   137de:	9a02      	ldr	r2, [sp, #8]
   137e0:	2a00      	cmp	r2, #0
   137e2:	d0dc      	beq.n	1379e <usbdc_cb_ctl_req+0x6e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
   137e4:	f892 8002 	ldrb.w	r8, [r2, #2]
   137e8:	4598      	cmp	r8, r3
   137ea:	d014      	beq.n	13816 <usbdc_cb_ctl_req+0xe6>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
   137ec:	6926      	ldr	r6, [r4, #16]
			while (NULL != func) {
   137ee:	b94e      	cbnz	r6, 13804 <usbdc_cb_ctl_req+0xd4>
		desc.sod = usb_desc_next(desc.sod);
   137f0:	9802      	ldr	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   137f2:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   137f4:	7803      	ldrb	r3, [r0, #0]
   137f6:	2204      	movs	r2, #4
   137f8:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   137fa:	9002      	str	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   137fc:	47b8      	blx	r7
   137fe:	4643      	mov	r3, r8
   13800:	9002      	str	r0, [sp, #8]
   13802:	e7ec      	b.n	137de <usbdc_cb_ctl_req+0xae>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
   13804:	6873      	ldr	r3, [r6, #4]
   13806:	aa02      	add	r2, sp, #8
   13808:	2100      	movs	r1, #0
   1380a:	4630      	mov	r0, r6
   1380c:	4798      	blx	r3
   1380e:	2800      	cmp	r0, #0
   13810:	d0ee      	beq.n	137f0 <usbdc_cb_ctl_req+0xc0>
					func = func->next;
   13812:	6836      	ldr	r6, [r6, #0]
   13814:	e7eb      	b.n	137ee <usbdc_cb_ctl_req+0xbe>
   13816:	4698      	mov	r8, r3
   13818:	e7ea      	b.n	137f0 <usbdc_cb_ctl_req+0xc0>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   1381a:	2b02      	cmp	r3, #2
   1381c:	d19a      	bne.n	13754 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   1381e:	88e2      	ldrh	r2, [r4, #6]
   13820:	2a00      	cmp	r2, #0
   13822:	d197      	bne.n	13754 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
   13824:	88a0      	ldrh	r0, [r4, #4]
   13826:	4b70      	ldr	r3, [pc, #448]	; (139e8 <usbdc_cb_ctl_req+0x2b8>)
   13828:	9201      	str	r2, [sp, #4]
   1382a:	4611      	mov	r1, r2
   1382c:	b2c0      	uxtb	r0, r0
   1382e:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   13830:	9a01      	ldr	r2, [sp, #4]
   13832:	2301      	movs	r3, #1
		usbdc_xfer(ep, NULL, 0, true);
   13834:	4611      	mov	r1, r2
   13836:	4628      	mov	r0, r5
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13838:	4c67      	ldr	r4, [pc, #412]	; (139d8 <usbdc_cb_ctl_req+0x2a8>)
   1383a:	47a0      	blx	r4
			return true;
   1383c:	2001      	movs	r0, #1
   1383e:	e7b7      	b.n	137b0 <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13840:	2b02      	cmp	r3, #2
   13842:	d187      	bne.n	13754 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   13844:	88e6      	ldrh	r6, [r4, #6]
   13846:	2e00      	cmp	r6, #0
   13848:	d184      	bne.n	13754 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
   1384a:	88a0      	ldrh	r0, [r4, #4]
   1384c:	4b66      	ldr	r3, [pc, #408]	; (139e8 <usbdc_cb_ctl_req+0x2b8>)
   1384e:	2101      	movs	r1, #1
   13850:	b2c0      	uxtb	r0, r0
   13852:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   13854:	2301      	movs	r3, #1
   13856:	4632      	mov	r2, r6
   13858:	e7ec      	b.n	13834 <usbdc_cb_ctl_req+0x104>
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   1385a:	4d60      	ldr	r5, [pc, #384]	; (139dc <usbdc_cb_ctl_req+0x2ac>)
		return usbdc_set_interface(req->wValue, req->wIndex);
   1385c:	8866      	ldrh	r6, [r4, #2]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   1385e:	682b      	ldr	r3, [r5, #0]
   13860:	7eea      	ldrb	r2, [r5, #27]
		return usbdc_set_interface(req->wValue, req->wIndex);
   13862:	88a7      	ldrh	r7, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   13864:	e9d3 0100 	ldrd	r0, r1, [r3]
   13868:	4b5d      	ldr	r3, [pc, #372]	; (139e0 <usbdc_cb_ctl_req+0x2b0>)
   1386a:	4798      	blx	r3
	if (NULL == ifc) {
   1386c:	2800      	cmp	r0, #0
   1386e:	f43f af71 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
	desc.sod = ifc;
   13872:	9002      	str	r0, [sp, #8]
	return (ptr[0] + (ptr[1] << 8));
   13874:	78c2      	ldrb	r2, [r0, #3]
   13876:	7883      	ldrb	r3, [r0, #2]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   13878:	4c5a      	ldr	r4, [pc, #360]	; (139e4 <usbdc_cb_ctl_req+0x2b4>)
   1387a:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
   1387e:	fa10 f183 	uxtah	r1, r0, r3
   13882:	9103      	str	r1, [sp, #12]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   13884:	2204      	movs	r2, #4
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13886:	47a0      	blx	r4
		if (NULL == ifc) {
   13888:	2800      	cmp	r0, #0
   1388a:	f43f af63 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
   1388e:	7883      	ldrb	r3, [r0, #2]
   13890:	42bb      	cmp	r3, r7
   13892:	d110      	bne.n	138b6 <usbdc_cb_ctl_req+0x186>
   13894:	78c3      	ldrb	r3, [r0, #3]
   13896:	42b3      	cmp	r3, r6
   13898:	d10d      	bne.n	138b6 <usbdc_cb_ctl_req+0x186>
	func     = (struct usbdf_driver *)usbdc.func_list.head;
   1389a:	692c      	ldr	r4, [r5, #16]
	desc.sod = ifc;
   1389c:	9002      	str	r0, [sp, #8]
	while (NULL != func) {
   1389e:	2c00      	cmp	r4, #0
   138a0:	f43f af58 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
   138a4:	2101      	movs	r1, #1
   138a6:	6863      	ldr	r3, [r4, #4]
   138a8:	aa02      	add	r2, sp, #8
   138aa:	4620      	mov	r0, r4
   138ac:	4798      	blx	r3
   138ae:	4601      	mov	r1, r0
   138b0:	b140      	cbz	r0, 138c4 <usbdc_cb_ctl_req+0x194>
			func = func->next;
   138b2:	6824      	ldr	r4, [r4, #0]
   138b4:	e7f3      	b.n	1389e <usbdc_cb_ctl_req+0x16e>
		desc.sod = usb_desc_next(desc.sod);
   138b6:	9802      	ldr	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   138b8:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   138ba:	7803      	ldrb	r3, [r0, #0]
   138bc:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   138be:	9002      	str	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   138c0:	2204      	movs	r2, #4
   138c2:	e7e0      	b.n	13886 <usbdc_cb_ctl_req+0x156>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
   138c4:	6863      	ldr	r3, [r4, #4]
   138c6:	aa02      	add	r2, sp, #8
   138c8:	4620      	mov	r0, r4
   138ca:	4798      	blx	r3
   138cc:	2800      	cmp	r0, #0
   138ce:	f47f af41 	bne.w	13754 <usbdc_cb_ctl_req+0x24>
			if (alt_set) {
   138d2:	b126      	cbz	r6, 138de <usbdc_cb_ctl_req+0x1ae>
				usbdc.ifc_alt_map |= 1 << ifc_id;
   138d4:	2301      	movs	r3, #1
   138d6:	40bb      	lsls	r3, r7
   138d8:	7f6f      	ldrb	r7, [r5, #29]
   138da:	431f      	orrs	r7, r3
   138dc:	776f      	strb	r7, [r5, #29]
			usbdc_xfer(0, NULL, 0, 0);
   138de:	2300      	movs	r3, #0
   138e0:	461a      	mov	r2, r3
   138e2:	4619      	mov	r1, r3
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   138e4:	4618      	mov	r0, r3
   138e6:	e7a7      	b.n	13838 <usbdc_cb_ctl_req+0x108>
	switch (req->bRequest) {
   138e8:	7862      	ldrb	r2, [r4, #1]
   138ea:	2a0a      	cmp	r2, #10
   138ec:	f63f af32 	bhi.w	13754 <usbdc_cb_ctl_req+0x24>
   138f0:	a101      	add	r1, pc, #4	; (adr r1, 138f8 <usbdc_cb_ctl_req+0x1c8>)
   138f2:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   138f6:	bf00      	nop
   138f8:	000139f1 	.word	0x000139f1
   138fc:	00013755 	.word	0x00013755
   13900:	00013755 	.word	0x00013755
   13904:	00013755 	.word	0x00013755
   13908:	00013755 	.word	0x00013755
   1390c:	00013755 	.word	0x00013755
   13910:	00013925 	.word	0x00013925
   13914:	00013755 	.word	0x00013755
   13918:	000139c1 	.word	0x000139c1
   1391c:	00013755 	.word	0x00013755
   13920:	00013a1f 	.word	0x00013a1f
	uint8_t type = (uint8_t)(req->wValue >> 8);
   13924:	8863      	ldrh	r3, [r4, #2]
   13926:	0a19      	lsrs	r1, r3, #8
	switch (type) {
   13928:	2902      	cmp	r1, #2
	uint8_t type = (uint8_t)(req->wValue >> 8);
   1392a:	460a      	mov	r2, r1
	switch (type) {
   1392c:	d016      	beq.n	1395c <usbdc_cb_ctl_req+0x22c>
   1392e:	2903      	cmp	r1, #3
   13930:	d031      	beq.n	13996 <usbdc_cb_ctl_req+0x266>
   13932:	2901      	cmp	r1, #1
   13934:	f47f af0e 	bne.w	13754 <usbdc_cb_ctl_req+0x24>
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   13938:	4b28      	ldr	r3, [pc, #160]	; (139dc <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   1393a:	88e4      	ldrh	r4, [r4, #6]
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   1393c:	681b      	ldr	r3, [r3, #0]
   1393e:	e9d3 0100 	ldrd	r0, r1, [r3]
   13942:	4b28      	ldr	r3, [pc, #160]	; (139e4 <usbdc_cb_ctl_req+0x2b4>)
   13944:	4798      	blx	r3
	if (!dev_desc) {
   13946:	4601      	mov	r1, r0
   13948:	2800      	cmp	r0, #0
   1394a:	f43f af03 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
   1394e:	2c12      	cmp	r4, #18
   13950:	4622      	mov	r2, r4
   13952:	f04f 0300 	mov.w	r3, #0
   13956:	bf28      	it	cs
   13958:	2212      	movcs	r2, #18
   1395a:	e723      	b.n	137a4 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1395c:	4a1f      	ldr	r2, [pc, #124]	; (139dc <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   1395e:	88e4      	ldrh	r4, [r4, #6]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   13960:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13962:	7f16      	ldrb	r6, [r2, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   13964:	1c5a      	adds	r2, r3, #1
   13966:	e9d0 0100 	ldrd	r0, r1, [r0]
   1396a:	4b1d      	ldr	r3, [pc, #116]	; (139e0 <usbdc_cb_ctl_req+0x2b0>)
   1396c:	b2d2      	uxtb	r2, r2
   1396e:	4798      	blx	r3
	if (NULL == cfg_desc) {
   13970:	4601      	mov	r1, r0
   13972:	2800      	cmp	r0, #0
   13974:	f43f aeee 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
	return (ptr[0] + (ptr[1] << 8));
   13978:	78c3      	ldrb	r3, [r0, #3]
   1397a:	7882      	ldrb	r2, [r0, #2]
   1397c:	eb02 2203 	add.w	r2, r2, r3, lsl #8
   13980:	b292      	uxth	r2, r2
	if (length <= total_len) {
   13982:	4294      	cmp	r4, r2
   13984:	d91a      	bls.n	139bc <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13986:	3e01      	subs	r6, #1
   13988:	4226      	tst	r6, r4
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1398a:	bf0c      	ite	eq
   1398c:	2301      	moveq	r3, #1
   1398e:	2300      	movne	r3, #0
   13990:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   13992:	4622      	mov	r2, r4
   13994:	e706      	b.n	137a4 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13996:	4a11      	ldr	r2, [pc, #68]	; (139dc <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13998:	88e4      	ldrh	r4, [r4, #6]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   1399a:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   1399c:	7f16      	ldrb	r6, [r2, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   1399e:	e9d0 0100 	ldrd	r0, r1, [r0]
   139a2:	b2da      	uxtb	r2, r3
   139a4:	4b11      	ldr	r3, [pc, #68]	; (139ec <usbdc_cb_ctl_req+0x2bc>)
   139a6:	4798      	blx	r3
	if (NULL == str_desc) {
   139a8:	4601      	mov	r1, r0
   139aa:	2800      	cmp	r0, #0
   139ac:	f43f aed2 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
	if (length <= str_desc[0]) {
   139b0:	7802      	ldrb	r2, [r0, #0]
   139b2:	4294      	cmp	r4, r2
   139b4:	d902      	bls.n	139bc <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   139b6:	1e73      	subs	r3, r6, #1
   139b8:	4223      	tst	r3, r4
   139ba:	e7e6      	b.n	1398a <usbdc_cb_ctl_req+0x25a>
		need_zlp = false;
   139bc:	2300      	movs	r3, #0
   139be:	e7e8      	b.n	13992 <usbdc_cb_ctl_req+0x262>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
   139c0:	4906      	ldr	r1, [pc, #24]	; (139dc <usbdc_cb_ctl_req+0x2ac>)
   139c2:	694b      	ldr	r3, [r1, #20]
   139c4:	7eca      	ldrb	r2, [r1, #27]
   139c6:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
   139c8:	2300      	movs	r3, #0
   139ca:	2201      	movs	r2, #1
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   139cc:	6949      	ldr	r1, [r1, #20]
   139ce:	e732      	b.n	13836 <usbdc_cb_ctl_req+0x106>
   139d0:	000135e5 	.word	0x000135e5
   139d4:	000135a9 	.word	0x000135a9
   139d8:	00013711 	.word	0x00013711
   139dc:	20009108 	.word	0x20009108
   139e0:	0000bc15 	.word	0x0000bc15
   139e4:	0000bbdd 	.word	0x0000bbdd
   139e8:	0000fb25 	.word	0x0000fb25
   139ec:	0000bc51 	.word	0x0000bc51
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   139f0:	f003 011f 	and.w	r1, r3, #31
   139f4:	f013 031e 	ands.w	r3, r3, #30
   139f8:	d00b      	beq.n	13a12 <usbdc_cb_ctl_req+0x2e2>
   139fa:	2902      	cmp	r1, #2
   139fc:	f47f aeaa 	bne.w	13754 <usbdc_cb_ctl_req+0x24>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
   13a00:	88a0      	ldrh	r0, [r4, #4]
   13a02:	4b17      	ldr	r3, [pc, #92]	; (13a60 <usbdc_cb_ctl_req+0x330>)
   13a04:	b2c0      	uxtb	r0, r0
   13a06:	4798      	blx	r3
		if (st < 0) {
   13a08:	1e03      	subs	r3, r0, #0
   13a0a:	f6ff aea3 	blt.w	13754 <usbdc_cb_ctl_req+0x24>
		st = st & 0x1;
   13a0e:	f003 0301 	and.w	r3, r3, #1
	memcpy(usbdc.ctrl_buf, &st, 2);
   13a12:	4914      	ldr	r1, [pc, #80]	; (13a64 <usbdc_cb_ctl_req+0x334>)
   13a14:	694a      	ldr	r2, [r1, #20]
   13a16:	8013      	strh	r3, [r2, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13a18:	2300      	movs	r3, #0
   13a1a:	2202      	movs	r2, #2
   13a1c:	e7d6      	b.n	139cc <usbdc_cb_ctl_req+0x29c>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
   13a1e:	4911      	ldr	r1, [pc, #68]	; (13a64 <usbdc_cb_ctl_req+0x334>)
   13a20:	88a2      	ldrh	r2, [r4, #4]
   13a22:	7f4b      	ldrb	r3, [r1, #29]
   13a24:	4113      	asrs	r3, r2
   13a26:	f013 0301 	ands.w	r3, r3, #1
   13a2a:	460e      	mov	r6, r1
   13a2c:	d00c      	beq.n	13a48 <usbdc_cb_ctl_req+0x318>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   13a2e:	690d      	ldr	r5, [r1, #16]
	while (NULL != func) {
   13a30:	2d00      	cmp	r5, #0
   13a32:	f43f ae8f 	beq.w	13754 <usbdc_cb_ctl_req+0x24>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
   13a36:	686b      	ldr	r3, [r5, #4]
   13a38:	4622      	mov	r2, r4
   13a3a:	2102      	movs	r1, #2
   13a3c:	4628      	mov	r0, r5
   13a3e:	4798      	blx	r3
   13a40:	2800      	cmp	r0, #0
   13a42:	da06      	bge.n	13a52 <usbdc_cb_ctl_req+0x322>
			func = func->next;
   13a44:	682d      	ldr	r5, [r5, #0]
   13a46:	e7f3      	b.n	13a30 <usbdc_cb_ctl_req+0x300>
		usbdc.ctrl_buf[0] = 0;
   13a48:	694a      	ldr	r2, [r1, #20]
   13a4a:	7013      	strb	r3, [r2, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13a4c:	6949      	ldr	r1, [r1, #20]
   13a4e:	2201      	movs	r2, #1
   13a50:	e748      	b.n	138e4 <usbdc_cb_ctl_req+0x1b4>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
   13a52:	6973      	ldr	r3, [r6, #20]
   13a54:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13a56:	6971      	ldr	r1, [r6, #20]
   13a58:	2300      	movs	r3, #0
   13a5a:	2201      	movs	r2, #1
   13a5c:	e742      	b.n	138e4 <usbdc_cb_ctl_req+0x1b4>
   13a5e:	bf00      	nop
   13a60:	0000fb25 	.word	0x0000fb25
   13a64:	20009108 	.word	0x20009108

00013a68 <usbdc_register_handler>:
/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
	switch (type) {
   13a68:	2801      	cmp	r0, #1
   13a6a:	d005      	beq.n	13a78 <usbdc_register_handler+0x10>
   13a6c:	2802      	cmp	r0, #2
   13a6e:	d005      	beq.n	13a7c <usbdc_register_handler+0x14>
   13a70:	b930      	cbnz	r0, 13a80 <usbdc_register_handler+0x18>
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
   13a72:	4804      	ldr	r0, [pc, #16]	; (13a84 <usbdc_register_handler+0x1c>)
		break;
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
		break;
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   13a74:	4b04      	ldr	r3, [pc, #16]	; (13a88 <usbdc_register_handler+0x20>)
   13a76:	4718      	bx	r3
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
   13a78:	4804      	ldr	r0, [pc, #16]	; (13a8c <usbdc_register_handler+0x24>)
   13a7a:	e7fb      	b.n	13a74 <usbdc_register_handler+0xc>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   13a7c:	4804      	ldr	r0, [pc, #16]	; (13a90 <usbdc_register_handler+0x28>)
   13a7e:	e7f9      	b.n	13a74 <usbdc_register_handler+0xc>
		break;
	default:
		break;
	}
}
   13a80:	4770      	bx	lr
   13a82:	bf00      	nop
   13a84:	2000910c 	.word	0x2000910c
   13a88:	0000fc19 	.word	0x0000fc19
   13a8c:	20009110 	.word	0x20009110
   13a90:	20009114 	.word	0x20009114

00013a94 <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
   13a94:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
   13a96:	4604      	mov	r4, r0
   13a98:	3800      	subs	r0, #0
   13a9a:	bf18      	it	ne
   13a9c:	2001      	movne	r0, #1
   13a9e:	490c      	ldr	r1, [pc, #48]	; (13ad0 <usbdc_init+0x3c>)
   13aa0:	4b0c      	ldr	r3, [pc, #48]	; (13ad4 <usbdc_init+0x40>)
   13aa2:	f240 3255 	movw	r2, #853	; 0x355
   13aa6:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
   13aa8:	4b0b      	ldr	r3, [pc, #44]	; (13ad8 <usbdc_init+0x44>)
   13aaa:	4798      	blx	r3
	if (rc < 0) {
   13aac:	2800      	cmp	r0, #0
   13aae:	db0e      	blt.n	13ace <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
   13ab0:	4b0a      	ldr	r3, [pc, #40]	; (13adc <usbdc_init+0x48>)
   13ab2:	4d0b      	ldr	r5, [pc, #44]	; (13ae0 <usbdc_init+0x4c>)
   13ab4:	2220      	movs	r2, #32
   13ab6:	4618      	mov	r0, r3
   13ab8:	2100      	movs	r1, #0
   13aba:	47a8      	blx	r5
	usbdc.ctrl_buf = ctrl_buf;
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   13abc:	4909      	ldr	r1, [pc, #36]	; (13ae4 <usbdc_init+0x50>)
	usbdc.ctrl_buf = ctrl_buf;
   13abe:	6144      	str	r4, [r0, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   13ac0:	4c09      	ldr	r4, [pc, #36]	; (13ae8 <usbdc_init+0x54>)
   13ac2:	2000      	movs	r0, #0
   13ac4:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
   13ac6:	2001      	movs	r0, #1
   13ac8:	4908      	ldr	r1, [pc, #32]	; (13aec <usbdc_init+0x58>)
   13aca:	47a0      	blx	r4

	return 0;
   13acc:	2000      	movs	r0, #0
}
   13ace:	bd38      	pop	{r3, r4, r5, pc}
   13ad0:	00016e1c 	.word	0x00016e1c
   13ad4:	0000e42d 	.word	0x0000e42d
   13ad8:	0000f881 	.word	0x0000f881
   13adc:	20009108 	.word	0x20009108
   13ae0:	000147c5 	.word	0x000147c5
   13ae4:	0001361d 	.word	0x0001361d
   13ae8:	0000f8e9 	.word	0x0000f8e9
   13aec:	000136f9 	.word	0x000136f9

00013af0 <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
   13af0:	4601      	mov	r1, r0
	list_insert_at_end(&usbdc.func_list, func);
   13af2:	4b01      	ldr	r3, [pc, #4]	; (13af8 <usbdc_register_function+0x8>)
   13af4:	4801      	ldr	r0, [pc, #4]	; (13afc <usbdc_register_function+0xc>)
   13af6:	4718      	bx	r3
   13af8:	0000fc19 	.word	0x0000fc19
   13afc:	20009118 	.word	0x20009118

00013b00 <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
   13b00:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
   13b02:	4b0a      	ldr	r3, [pc, #40]	; (13b2c <usbdc_start+0x2c>)
   13b04:	7e9c      	ldrb	r4, [r3, #26]
   13b06:	b954      	cbnz	r4, 13b1e <usbdc_start+0x1e>
		return ERR_BUSY;
	}

	if (desces) {
   13b08:	b160      	cbz	r0, 13b24 <usbdc_start+0x24>
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
   13b0a:	6802      	ldr	r2, [r0, #0]
		usbdc.desces.ls_fs = desces;
   13b0c:	6018      	str	r0, [r3, #0]
	usbdc.ctrl_size = desces->sod[7];
   13b0e:	79d2      	ldrb	r2, [r2, #7]
   13b10:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
   13b12:	2201      	movs	r2, #1
   13b14:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
   13b16:	4b06      	ldr	r3, [pc, #24]	; (13b30 <usbdc_start+0x30>)
   13b18:	4798      	blx	r3
	return ERR_NONE;
   13b1a:	4620      	mov	r0, r4
}
   13b1c:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
   13b1e:	f06f 0003 	mvn.w	r0, #3
   13b22:	e7fb      	b.n	13b1c <usbdc_start+0x1c>
		return ERR_BAD_DATA;
   13b24:	f06f 0008 	mvn.w	r0, #8
   13b28:	e7f8      	b.n	13b1c <usbdc_start+0x1c>
   13b2a:	bf00      	nop
   13b2c:	20009108 	.word	0x20009108
   13b30:	0000f8f1 	.word	0x0000f8f1

00013b34 <usbdc_attach>:
/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
	usb_d_attach();
   13b34:	4b00      	ldr	r3, [pc, #0]	; (13b38 <usbdc_attach+0x4>)
   13b36:	4718      	bx	r3
   13b38:	0000f8f9 	.word	0x0000f8f9

00013b3c <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
   13b3c:	4b01      	ldr	r3, [pc, #4]	; (13b44 <usbdc_get_ctrl_buffer+0x8>)
   13b3e:	6958      	ldr	r0, [r3, #20]
   13b40:	4770      	bx	lr
   13b42:	bf00      	nop
   13b44:	20009108 	.word	0x20009108

00013b48 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
   13b48:	4b03      	ldr	r3, [pc, #12]	; (13b58 <usbdc_get_state+0x10>)
   13b4a:	7e98      	ldrb	r0, [r3, #26]
   13b4c:	f010 0f10 	tst.w	r0, #16
		return USBD_S_SUSPEND;
	}
	return usbdc.state;
}
   13b50:	bf18      	it	ne
   13b52:	2010      	movne	r0, #16
   13b54:	4770      	bx	lr
   13b56:	bf00      	nop
   13b58:	20009108 	.word	0x20009108

00013b5c <hri_tc_wait_for_sync>:
typedef uint8_t  hri_tccount8_per_reg_t;
typedef uint8_t  hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
   13b5c:	6903      	ldr	r3, [r0, #16]
   13b5e:	420b      	tst	r3, r1
   13b60:	d1fc      	bne.n	13b5c <hri_tc_wait_for_sync>
	};
}
   13b62:	4770      	bx	lr

00013b64 <_tc_timer_start>:
/**
 * \brief Start hardware timer
 */
void _tc_timer_start(struct _timer_device *const device)
{
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
   13b64:	68c0      	ldr	r0, [r0, #12]
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
   13b66:	6803      	ldr	r3, [r0, #0]
   13b68:	f043 0302 	orr.w	r3, r3, #2
   13b6c:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13b6e:	2103      	movs	r1, #3
   13b70:	4b00      	ldr	r3, [pc, #0]	; (13b74 <_tc_timer_start+0x10>)
   13b72:	4718      	bx	r3
   13b74:	00013b5d 	.word	0x00013b5d

00013b78 <_tc_timer_get_period>:
/**
 * \brief Retrieve timer period
 */
uint32_t _tc_timer_get_period(const struct _timer_device *const device)
{
	void *const hw = device->hw;
   13b78:	68c0      	ldr	r0, [r0, #12]
{
   13b7a:	b508      	push	{r3, lr}
}

static inline hri_tc_ctrla_reg_t hri_tc_read_CTRLA_MODE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13b7c:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13b7e:	f3c3 0381 	ubfx	r3, r3, #2, #2

	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13b82:	2b02      	cmp	r3, #2
   13b84:	d104      	bne.n	13b90 <_tc_timer_get_period+0x18>
	TC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tccount32_cc_reg_t hri_tccount32_read_CC_reg(const void *const hw, uint8_t index)
{
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13b86:	4b0e      	ldr	r3, [pc, #56]	; (13bc0 <_tc_timer_get_period+0x48>)
   13b88:	21c0      	movs	r1, #192	; 0xc0
   13b8a:	4798      	blx	r3
	return ((Tc *)hw)->COUNT32.CC[index].reg;
   13b8c:	69c0      	ldr	r0, [r0, #28]
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
		return hri_tccount8_read_PER_reg(hw);
	}

	return 0;
}
   13b8e:	bd08      	pop	{r3, pc}
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13b90:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13b92:	f013 0f0c 	tst.w	r3, #12
   13b96:	d105      	bne.n	13ba4 <_tc_timer_get_period+0x2c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13b98:	4b09      	ldr	r3, [pc, #36]	; (13bc0 <_tc_timer_get_period+0x48>)
   13b9a:	21c0      	movs	r1, #192	; 0xc0
   13b9c:	4798      	blx	r3
	return ((Tc *)hw)->COUNT16.CC[index].reg;
   13b9e:	8b80      	ldrh	r0, [r0, #28]
   13ba0:	b280      	uxth	r0, r0
		return hri_tccount16_read_CC_reg(hw, 0);
   13ba2:	e7f4      	b.n	13b8e <_tc_timer_get_period+0x16>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13ba4:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13ba6:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13baa:	2b01      	cmp	r3, #1
   13bac:	d105      	bne.n	13bba <_tc_timer_get_period+0x42>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13bae:	4b04      	ldr	r3, [pc, #16]	; (13bc0 <_tc_timer_get_period+0x48>)
   13bb0:	2120      	movs	r1, #32
   13bb2:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.PER.reg;
   13bb4:	7ec0      	ldrb	r0, [r0, #27]
   13bb6:	b2c0      	uxtb	r0, r0
		return hri_tccount8_read_PER_reg(hw);
   13bb8:	e7e9      	b.n	13b8e <_tc_timer_get_period+0x16>
	return 0;
   13bba:	2000      	movs	r0, #0
   13bbc:	e7e7      	b.n	13b8e <_tc_timer_get_period+0x16>
   13bbe:	bf00      	nop
   13bc0:	00013b5d 	.word	0x00013b5d

00013bc4 <_tc_timer_is_started>:
/**
 * \brief Check if timer is running
 */
bool _tc_timer_is_started(const struct _timer_device *const device)
{
   13bc4:	b508      	push	{r3, lr}
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
   13bc6:	68c0      	ldr	r0, [r0, #12]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13bc8:	4b03      	ldr	r3, [pc, #12]	; (13bd8 <_tc_timer_is_started+0x14>)
   13bca:	2103      	movs	r1, #3
   13bcc:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13bce:	6800      	ldr	r0, [r0, #0]
}
   13bd0:	f3c0 0040 	ubfx	r0, r0, #1, #1
   13bd4:	bd08      	pop	{r3, pc}
   13bd6:	bf00      	nop
   13bd8:	00013b5d 	.word	0x00013b5d

00013bdc <tc_interrupt_handler>:
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
	void *const hw = device->hw;
   13bdc:	68c2      	ldr	r2, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
   13bde:	7a91      	ldrb	r1, [r2, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
   13be0:	07c9      	lsls	r1, r1, #31
   13be2:	d503      	bpl.n	13bec <tc_interrupt_handler+0x10>
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
   13be4:	2101      	movs	r1, #1
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
   13be6:	6803      	ldr	r3, [r0, #0]
   13be8:	7291      	strb	r1, [r2, #10]
   13bea:	4718      	bx	r3
	}
}
   13bec:	4770      	bx	lr
	...

00013bf0 <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
   13bf0:	b570      	push	{r4, r5, r6, lr}
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13bf2:	4d15      	ldr	r5, [pc, #84]	; (13c48 <get_tc_index+0x58>)
{
   13bf4:	4606      	mov	r6, r0
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13bf6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   13bf8:	b088      	sub	sp, #32
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   13bfa:	466c      	mov	r4, sp
   13bfc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   13bfe:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   13c02:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   13c06:	466a      	mov	r2, sp
   13c08:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
   13c0a:	f852 1b04 	ldr.w	r1, [r2], #4
   13c0e:	42b1      	cmp	r1, r6
   13c10:	d104      	bne.n	13c1c <get_tc_index+0x2c>
			return i;
   13c12:	b2d8      	uxtb	r0, r3
		if (_tcs[i].number == index) {
   13c14:	b93b      	cbnz	r3, 13c26 <get_tc_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   13c16:	4618      	mov	r0, r3
			return i;
   13c18:	b240      	sxtb	r0, r0
   13c1a:	e012      	b.n	13c42 <get_tc_index+0x52>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   13c1c:	3301      	adds	r3, #1
   13c1e:	2b08      	cmp	r3, #8
   13c20:	d1f3      	bne.n	13c0a <get_tc_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   13c22:	2000      	movs	r0, #0
   13c24:	e7f8      	b.n	13c18 <get_tc_index+0x28>
		if (_tcs[i].number == index) {
   13c26:	2801      	cmp	r0, #1
   13c28:	d0f6      	beq.n	13c18 <get_tc_index+0x28>
   13c2a:	2802      	cmp	r0, #2
   13c2c:	d0f4      	beq.n	13c18 <get_tc_index+0x28>
   13c2e:	2803      	cmp	r0, #3
   13c30:	d0f2      	beq.n	13c18 <get_tc_index+0x28>
	ASSERT(false);
   13c32:	2000      	movs	r0, #0
   13c34:	4905      	ldr	r1, [pc, #20]	; (13c4c <get_tc_index+0x5c>)
   13c36:	4b06      	ldr	r3, [pc, #24]	; (13c50 <get_tc_index+0x60>)
   13c38:	f240 1267 	movw	r2, #359	; 0x167
   13c3c:	4798      	blx	r3
	return -1;
   13c3e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   13c42:	b008      	add	sp, #32
   13c44:	bd70      	pop	{r4, r5, r6, pc}
   13c46:	bf00      	nop
   13c48:	00016e48 	.word	0x00016e48
   13c4c:	00016e32 	.word	0x00016e32
   13c50:	0000e42d 	.word	0x0000e42d

00013c54 <_tc_timer_set_irq>:
{
   13c54:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
   13c56:	4b0a      	ldr	r3, [pc, #40]	; (13c80 <_tc_timer_set_irq+0x2c>)
   13c58:	68c0      	ldr	r0, [r0, #12]
   13c5a:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   13c5c:	4b09      	ldr	r3, [pc, #36]	; (13c84 <_tc_timer_set_irq+0x30>)
   13c5e:	490a      	ldr	r1, [pc, #40]	; (13c88 <_tc_timer_set_irq+0x34>)
	int8_t      i  = get_tc_index(hw);
   13c60:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
   13c62:	f44f 7291 	mov.w	r2, #290	; 0x122
   13c66:	2001      	movs	r0, #1
   13c68:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
   13c6a:	4808      	ldr	r0, [pc, #32]	; (13c8c <_tc_timer_set_irq+0x38>)
   13c6c:	2314      	movs	r3, #20
   13c6e:	fb03 0404 	mla	r4, r3, r4, r0
   13c72:	4b07      	ldr	r3, [pc, #28]	; (13c90 <_tc_timer_set_irq+0x3c>)
   13c74:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
}
   13c78:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_irq_set(_tcs[i].irq);
   13c7c:	4718      	bx	r3
   13c7e:	bf00      	nop
   13c80:	00013bf1 	.word	0x00013bf1
   13c84:	0000e42d 	.word	0x0000e42d
   13c88:	00016e32 	.word	0x00016e32
   13c8c:	00016e48 	.word	0x00016e48
   13c90:	0000be99 	.word	0x0000be99

00013c94 <_tc_timer_stop>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
   13c94:	68c0      	ldr	r0, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13c96:	6803      	ldr	r3, [r0, #0]
   13c98:	f023 0302 	bic.w	r3, r3, #2
   13c9c:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13c9e:	2103      	movs	r1, #3
   13ca0:	4b00      	ldr	r3, [pc, #0]	; (13ca4 <_tc_timer_stop+0x10>)
   13ca2:	4718      	bx	r3
   13ca4:	00013b5d 	.word	0x00013b5d

00013ca8 <_tc_timer_deinit>:
{
   13ca8:	b570      	push	{r4, r5, r6, lr}
	void *const hw = device->hw;
   13caa:	68c4      	ldr	r4, [r0, #12]
	int8_t      i  = get_tc_index(hw);
   13cac:	4b17      	ldr	r3, [pc, #92]	; (13d0c <_tc_timer_deinit+0x64>)
   13cae:	4620      	mov	r0, r4
   13cb0:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   13cb2:	4b17      	ldr	r3, [pc, #92]	; (13d10 <_tc_timer_deinit+0x68>)
   13cb4:	4917      	ldr	r1, [pc, #92]	; (13d14 <_tc_timer_deinit+0x6c>)
	int8_t      i  = get_tc_index(hw);
   13cb6:	4605      	mov	r5, r0
	ASSERT(ARRAY_SIZE(_tcs));
   13cb8:	22cd      	movs	r2, #205	; 0xcd
   13cba:	2001      	movs	r0, #1
   13cbc:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
   13cbe:	4816      	ldr	r0, [pc, #88]	; (13d18 <_tc_timer_deinit+0x70>)
   13cc0:	2314      	movs	r3, #20
   13cc2:	fb03 0505 	mla	r5, r3, r5, r0
   13cc6:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13cca:	2b00      	cmp	r3, #0
   13ccc:	db0d      	blt.n	13cea <_tc_timer_deinit+0x42>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13cce:	095a      	lsrs	r2, r3, #5
   13cd0:	2101      	movs	r1, #1
   13cd2:	f003 031f 	and.w	r3, r3, #31
   13cd6:	fa01 f303 	lsl.w	r3, r1, r3
   13cda:	3220      	adds	r2, #32
   13cdc:	490f      	ldr	r1, [pc, #60]	; (13d1c <_tc_timer_deinit+0x74>)
   13cde:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   13ce2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13ce6:	f3bf 8f6f 	isb	sy
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13cea:	6823      	ldr	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13cec:	4a0c      	ldr	r2, [pc, #48]	; (13d20 <_tc_timer_deinit+0x78>)
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13cee:	f023 0302 	bic.w	r3, r3, #2
   13cf2:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13cf4:	2103      	movs	r1, #3
   13cf6:	4620      	mov	r0, r4
   13cf8:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_SWRST;
   13cfa:	6823      	ldr	r3, [r4, #0]
   13cfc:	f043 0301 	orr.w	r3, r3, #1
   13d00:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   13d02:	2101      	movs	r1, #1
}
   13d04:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   13d08:	4710      	bx	r2
   13d0a:	bf00      	nop
   13d0c:	00013bf1 	.word	0x00013bf1
   13d10:	0000e42d 	.word	0x0000e42d
   13d14:	00016e32 	.word	0x00016e32
   13d18:	00016e48 	.word	0x00016e48
   13d1c:	e000e100 	.word	0xe000e100
   13d20:	00013b5d 	.word	0x00013b5d

00013d24 <_tc_timer_init>:
{
   13d24:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int8_t i = get_tc_index(hw);
   13d28:	4b51      	ldr	r3, [pc, #324]	; (13e70 <_tc_timer_init+0x14c>)
{
   13d2a:	4607      	mov	r7, r0
	int8_t i = get_tc_index(hw);
   13d2c:	4608      	mov	r0, r1
{
   13d2e:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
   13d30:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   13d32:	4b50      	ldr	r3, [pc, #320]	; (13e74 <_tc_timer_init+0x150>)
   13d34:	4950      	ldr	r1, [pc, #320]	; (13e78 <_tc_timer_init+0x154>)
	device->hw = hw;
   13d36:	60fc      	str	r4, [r7, #12]
	ASSERT(ARRAY_SIZE(_tcs));
   13d38:	22a0      	movs	r2, #160	; 0xa0
	int8_t i = get_tc_index(hw);
   13d3a:	4606      	mov	r6, r0
	ASSERT(ARRAY_SIZE(_tcs));
   13d3c:	2001      	movs	r0, #1
   13d3e:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
   13d40:	6923      	ldr	r3, [r4, #16]
   13d42:	4a4e      	ldr	r2, [pc, #312]	; (13e7c <_tc_timer_init+0x158>)
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
   13d44:	f013 0f01 	tst.w	r3, #1
   13d48:	d112      	bne.n	13d70 <_tc_timer_init+0x4c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13d4a:	2103      	movs	r1, #3
   13d4c:	4620      	mov	r0, r4
   13d4e:	4790      	blx	r2
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13d50:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
   13d52:	079b      	lsls	r3, r3, #30
   13d54:	d507      	bpl.n	13d66 <_tc_timer_init+0x42>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13d56:	6823      	ldr	r3, [r4, #0]
   13d58:	f023 0302 	bic.w	r3, r3, #2
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13d5c:	2103      	movs	r1, #3
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   13d5e:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13d60:	4790      	blx	r2
			hri_tc_wait_for_sync(hw, TC_SYNCBUSY_ENABLE);
   13d62:	2102      	movs	r1, #2
   13d64:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   13d66:	2301      	movs	r3, #1
   13d68:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13d6a:	2103      	movs	r1, #3
   13d6c:	4620      	mov	r0, r4
   13d6e:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   13d70:	f8df 9124 	ldr.w	r9, [pc, #292]	; 13e98 <_tc_timer_init+0x174>
   13d74:	2514      	movs	r5, #20
   13d76:	fb05 9506 	mla	r5, r5, r6, r9
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   13d7a:	2101      	movs	r1, #1
   13d7c:	4620      	mov	r0, r4
   13d7e:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   13d80:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   13d84:	f8c4 8000 	str.w	r8, [r4]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   13d88:	2103      	movs	r1, #3
   13d8a:	4790      	blx	r2
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
   13d8c:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
   13d90:	73e3      	strb	r3, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
   13d92:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
   13d94:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
   13d96:	2301      	movs	r3, #1
   13d98:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
   13d9a:	f008 030c 	and.w	r3, r8, #12
   13d9e:	2b08      	cmp	r3, #8
   13da0:	d13b      	bne.n	13e1a <_tc_timer_init+0xf6>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
   13da2:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13da4:	61e3      	str	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13da6:	21c0      	movs	r1, #192	; 0xc0
   13da8:	4790      	blx	r2
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
   13daa:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13dac:	6223      	str	r3, [r4, #32]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13dae:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13db0:	4620      	mov	r0, r4
   13db2:	4790      	blx	r2
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
   13db4:	2301      	movs	r3, #1
   13db6:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
   13db8:	4b31      	ldr	r3, [pc, #196]	; (13e80 <_tc_timer_init+0x15c>)
   13dba:	429c      	cmp	r4, r3
   13dbc:	d146      	bne.n	13e4c <_tc_timer_init+0x128>
		_tc0_dev = (struct _timer_device *)dev;
   13dbe:	4b31      	ldr	r3, [pc, #196]	; (13e84 <_tc_timer_init+0x160>)
   13dc0:	601f      	str	r7, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
   13dc2:	2314      	movs	r3, #20
   13dc4:	fb03 9306 	mla	r3, r3, r6, r9
   13dc8:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13dcc:	2b00      	cmp	r3, #0
   13dce:	db0d      	blt.n	13dec <_tc_timer_init+0xc8>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13dd0:	095a      	lsrs	r2, r3, #5
   13dd2:	2101      	movs	r1, #1
   13dd4:	f003 031f 	and.w	r3, r3, #31
   13dd8:	fa01 f303 	lsl.w	r3, r1, r3
   13ddc:	3220      	adds	r2, #32
   13dde:	492a      	ldr	r1, [pc, #168]	; (13e88 <_tc_timer_init+0x164>)
   13de0:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   13de4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13de8:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
   13dec:	2014      	movs	r0, #20
   13dee:	fb00 9606 	mla	r6, r0, r6, r9
   13df2:	f9b6 3022 	ldrsh.w	r3, [r6, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   13df6:	2b00      	cmp	r3, #0
   13df8:	db0c      	blt.n	13e14 <_tc_timer_init+0xf0>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13dfa:	f003 011f 	and.w	r1, r3, #31
   13dfe:	095b      	lsrs	r3, r3, #5
   13e00:	009b      	lsls	r3, r3, #2
   13e02:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   13e06:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   13e0a:	2201      	movs	r2, #1
   13e0c:	408a      	lsls	r2, r1
   13e0e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13e12:	601a      	str	r2, [r3, #0]
}
   13e14:	2000      	movs	r0, #0
   13e16:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
   13e1a:	b933      	cbnz	r3, 13e2a <_tc_timer_init+0x106>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
   13e1c:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   13e1e:	83a3      	strh	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13e20:	21c0      	movs	r1, #192	; 0xc0
   13e22:	4790      	blx	r2
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
   13e24:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   13e26:	83e3      	strh	r3, [r4, #30]
   13e28:	e7c1      	b.n	13dae <_tc_timer_init+0x8a>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
   13e2a:	2b04      	cmp	r3, #4
   13e2c:	d1c2      	bne.n	13db4 <_tc_timer_init+0x90>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
   13e2e:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   13e32:	7723      	strb	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13e34:	21c0      	movs	r1, #192	; 0xc0
   13e36:	4790      	blx	r2
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
   13e38:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   13e3c:	7763      	strb	r3, [r4, #29]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13e3e:	21c0      	movs	r1, #192	; 0xc0
   13e40:	4790      	blx	r2
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
   13e42:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
   13e46:	76e3      	strb	r3, [r4, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13e48:	2120      	movs	r1, #32
   13e4a:	e7b1      	b.n	13db0 <_tc_timer_init+0x8c>
	if (hw == TC1) {
   13e4c:	4b0f      	ldr	r3, [pc, #60]	; (13e8c <_tc_timer_init+0x168>)
   13e4e:	429c      	cmp	r4, r3
   13e50:	d008      	beq.n	13e64 <_tc_timer_init+0x140>
	if (hw == TC2) {
   13e52:	4b0f      	ldr	r3, [pc, #60]	; (13e90 <_tc_timer_init+0x16c>)
   13e54:	429c      	cmp	r4, r3
   13e56:	d008      	beq.n	13e6a <_tc_timer_init+0x146>
	if (hw == TC3) {
   13e58:	4b0e      	ldr	r3, [pc, #56]	; (13e94 <_tc_timer_init+0x170>)
   13e5a:	429c      	cmp	r4, r3
   13e5c:	d1b1      	bne.n	13dc2 <_tc_timer_init+0x9e>
		_tc3_dev = (struct _timer_device *)dev;
   13e5e:	4b09      	ldr	r3, [pc, #36]	; (13e84 <_tc_timer_init+0x160>)
   13e60:	60df      	str	r7, [r3, #12]
   13e62:	e7ae      	b.n	13dc2 <_tc_timer_init+0x9e>
		_tc1_dev = (struct _timer_device *)dev;
   13e64:	4b07      	ldr	r3, [pc, #28]	; (13e84 <_tc_timer_init+0x160>)
   13e66:	605f      	str	r7, [r3, #4]
	if (hw == TC3) {
   13e68:	e7ab      	b.n	13dc2 <_tc_timer_init+0x9e>
		_tc2_dev = (struct _timer_device *)dev;
   13e6a:	4b06      	ldr	r3, [pc, #24]	; (13e84 <_tc_timer_init+0x160>)
   13e6c:	609f      	str	r7, [r3, #8]
	if (hw == TC3) {
   13e6e:	e7a8      	b.n	13dc2 <_tc_timer_init+0x9e>
   13e70:	00013bf1 	.word	0x00013bf1
   13e74:	0000e42d 	.word	0x0000e42d
   13e78:	00016e32 	.word	0x00016e32
   13e7c:	00013b5d 	.word	0x00013b5d
   13e80:	40003800 	.word	0x40003800
   13e84:	20009128 	.word	0x20009128
   13e88:	e000e100 	.word	0xe000e100
   13e8c:	40003c00 	.word	0x40003c00
   13e90:	4101a000 	.word	0x4101a000
   13e94:	4101c000 	.word	0x4101c000
   13e98:	00016e48 	.word	0x00016e48

00013e9c <_tc_timer_set_period>:
	void *const hw = device->hw;
   13e9c:	68c0      	ldr	r0, [r0, #12]
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13e9e:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13ea0:	f3c3 0381 	ubfx	r3, r3, #2, #2
	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13ea4:	2b02      	cmp	r3, #2
   13ea6:	d103      	bne.n	13eb0 <_tc_timer_set_period+0x14>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   13ea8:	61c1      	str	r1, [r0, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   13eaa:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13eac:	4b09      	ldr	r3, [pc, #36]	; (13ed4 <_tc_timer_set_period+0x38>)
   13eae:	4718      	bx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13eb0:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13eb2:	f013 0f0c 	tst.w	r3, #12
   13eb6:	d102      	bne.n	13ebe <_tc_timer_set_period+0x22>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)clock_cycles);
   13eb8:	b289      	uxth	r1, r1
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   13eba:	8381      	strh	r1, [r0, #28]
   13ebc:	e7f5      	b.n	13eaa <_tc_timer_set_period+0xe>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   13ebe:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   13ec0:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   13ec4:	2b01      	cmp	r3, #1
   13ec6:	d103      	bne.n	13ed0 <_tc_timer_set_period+0x34>
		hri_tccount8_write_PER_reg(hw, clock_cycles);
   13ec8:	b2c9      	uxtb	r1, r1
	((Tc *)hw)->COUNT8.PER.reg = data;
   13eca:	76c1      	strb	r1, [r0, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   13ecc:	2120      	movs	r1, #32
   13ece:	e7ed      	b.n	13eac <_tc_timer_set_period+0x10>
}
   13ed0:	4770      	bx	lr
   13ed2:	bf00      	nop
   13ed4:	00013b5d 	.word	0x00013b5d

00013ed8 <_tc_get_timer>:
}
   13ed8:	4800      	ldr	r0, [pc, #0]	; (13edc <_tc_get_timer+0x4>)
   13eda:	4770      	bx	lr
   13edc:	2000052c 	.word	0x2000052c

00013ee0 <TC0_Handler>:
	tc_interrupt_handler(_tc0_dev);
   13ee0:	4b01      	ldr	r3, [pc, #4]	; (13ee8 <TC0_Handler+0x8>)
   13ee2:	6818      	ldr	r0, [r3, #0]
   13ee4:	4b01      	ldr	r3, [pc, #4]	; (13eec <TC0_Handler+0xc>)
   13ee6:	4718      	bx	r3
   13ee8:	20009128 	.word	0x20009128
   13eec:	00013bdd 	.word	0x00013bdd

00013ef0 <TC1_Handler>:
	tc_interrupt_handler(_tc1_dev);
   13ef0:	4b01      	ldr	r3, [pc, #4]	; (13ef8 <TC1_Handler+0x8>)
   13ef2:	6858      	ldr	r0, [r3, #4]
   13ef4:	4b01      	ldr	r3, [pc, #4]	; (13efc <TC1_Handler+0xc>)
   13ef6:	4718      	bx	r3
   13ef8:	20009128 	.word	0x20009128
   13efc:	00013bdd 	.word	0x00013bdd

00013f00 <TC2_Handler>:
	tc_interrupt_handler(_tc2_dev);
   13f00:	4b01      	ldr	r3, [pc, #4]	; (13f08 <TC2_Handler+0x8>)
   13f02:	6898      	ldr	r0, [r3, #8]
   13f04:	4b01      	ldr	r3, [pc, #4]	; (13f0c <TC2_Handler+0xc>)
   13f06:	4718      	bx	r3
   13f08:	20009128 	.word	0x20009128
   13f0c:	00013bdd 	.word	0x00013bdd

00013f10 <TC3_Handler>:
	tc_interrupt_handler(_tc3_dev);
   13f10:	4b01      	ldr	r3, [pc, #4]	; (13f18 <TC3_Handler+0x8>)
   13f12:	68d8      	ldr	r0, [r3, #12]
   13f14:	4b01      	ldr	r3, [pc, #4]	; (13f1c <TC3_Handler+0xc>)
   13f16:	4718      	bx	r3
   13f18:	20009128 	.word	0x20009128
   13f1c:	00013bdd 	.word	0x00013bdd

00013f20 <_delay_init>:
   13f20:	4b03      	ldr	r3, [pc, #12]	; (13f30 <_delay_init+0x10>)
   13f22:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   13f26:	605a      	str	r2, [r3, #4]
   13f28:	2205      	movs	r2, #5
   13f2a:	601a      	str	r2, [r3, #0]
   13f2c:	4770      	bx	lr
   13f2e:	bf00      	nop
   13f30:	e000e010 	.word	0xe000e010

00013f34 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
   13f34:	0e0b      	lsrs	r3, r1, #24
   13f36:	4a0c      	ldr	r2, [pc, #48]	; (13f68 <_delay_cycles+0x34>)
{
   13f38:	b530      	push	{r4, r5, lr}
	uint8_t  n   = cycles >> 24;
   13f3a:	4618      	mov	r0, r3
	uint32_t buf = cycles;

	while (n--) {
		SysTick->LOAD = 0xFFFFFF;
   13f3c:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
	while (n--) {
   13f40:	3801      	subs	r0, #1
   13f42:	b2c0      	uxtb	r0, r0
   13f44:	28ff      	cmp	r0, #255	; 0xff
   13f46:	d108      	bne.n	13f5a <_delay_cycles+0x26>
   13f48:	eba3 6303 	sub.w	r3, r3, r3, lsl #24
   13f4c:	4419      	add	r1, r3
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			;
		buf -= 0xFFFFFF;
	}

	SysTick->LOAD = buf;
   13f4e:	6051      	str	r1, [r2, #4]
	SysTick->VAL  = buf;
   13f50:	6091      	str	r1, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   13f52:	6813      	ldr	r3, [r2, #0]
   13f54:	03db      	lsls	r3, r3, #15
   13f56:	d5fc      	bpl.n	13f52 <_delay_cycles+0x1e>
		;
}
   13f58:	bd30      	pop	{r4, r5, pc}
		SysTick->LOAD = 0xFFFFFF;
   13f5a:	6054      	str	r4, [r2, #4]
		SysTick->VAL  = 0xFFFFFF;
   13f5c:	6094      	str	r4, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   13f5e:	6815      	ldr	r5, [r2, #0]
   13f60:	03ed      	lsls	r5, r5, #15
   13f62:	d5fc      	bpl.n	13f5e <_delay_cycles+0x2a>
   13f64:	e7ec      	b.n	13f40 <_delay_cycles+0xc>
   13f66:	bf00      	nop
   13f68:	e000e010 	.word	0xe000e010

00013f6c <_crc_sync_init>:
/**
 * \brief Initialize CRC.
 */
int32_t _crc_sync_init(struct _crc_sync_device *const device, void *const hw)
{
	device->hw = hw;
   13f6c:	6001      	str	r1, [r0, #0]

	return ERR_NONE;
}
   13f6e:	2000      	movs	r0, #0
   13f70:	4770      	bx	lr
	...

00013f74 <__aeabi_drsub>:
   13f74:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   13f78:	e002      	b.n	13f80 <__adddf3>
   13f7a:	bf00      	nop

00013f7c <__aeabi_dsub>:
   13f7c:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

00013f80 <__adddf3>:
   13f80:	b530      	push	{r4, r5, lr}
   13f82:	ea4f 0441 	mov.w	r4, r1, lsl #1
   13f86:	ea4f 0543 	mov.w	r5, r3, lsl #1
   13f8a:	ea94 0f05 	teq	r4, r5
   13f8e:	bf08      	it	eq
   13f90:	ea90 0f02 	teqeq	r0, r2
   13f94:	bf1f      	itttt	ne
   13f96:	ea54 0c00 	orrsne.w	ip, r4, r0
   13f9a:	ea55 0c02 	orrsne.w	ip, r5, r2
   13f9e:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   13fa2:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   13fa6:	f000 80e2 	beq.w	1416e <__adddf3+0x1ee>
   13faa:	ea4f 5454 	mov.w	r4, r4, lsr #21
   13fae:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   13fb2:	bfb8      	it	lt
   13fb4:	426d      	neglt	r5, r5
   13fb6:	dd0c      	ble.n	13fd2 <__adddf3+0x52>
   13fb8:	442c      	add	r4, r5
   13fba:	ea80 0202 	eor.w	r2, r0, r2
   13fbe:	ea81 0303 	eor.w	r3, r1, r3
   13fc2:	ea82 0000 	eor.w	r0, r2, r0
   13fc6:	ea83 0101 	eor.w	r1, r3, r1
   13fca:	ea80 0202 	eor.w	r2, r0, r2
   13fce:	ea81 0303 	eor.w	r3, r1, r3
   13fd2:	2d36      	cmp	r5, #54	; 0x36
   13fd4:	bf88      	it	hi
   13fd6:	bd30      	pophi	{r4, r5, pc}
   13fd8:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   13fdc:	ea4f 3101 	mov.w	r1, r1, lsl #12
   13fe0:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   13fe4:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   13fe8:	d002      	beq.n	13ff0 <__adddf3+0x70>
   13fea:	4240      	negs	r0, r0
   13fec:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   13ff0:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   13ff4:	ea4f 3303 	mov.w	r3, r3, lsl #12
   13ff8:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   13ffc:	d002      	beq.n	14004 <__adddf3+0x84>
   13ffe:	4252      	negs	r2, r2
   14000:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   14004:	ea94 0f05 	teq	r4, r5
   14008:	f000 80a7 	beq.w	1415a <__adddf3+0x1da>
   1400c:	f1a4 0401 	sub.w	r4, r4, #1
   14010:	f1d5 0e20 	rsbs	lr, r5, #32
   14014:	db0d      	blt.n	14032 <__adddf3+0xb2>
   14016:	fa02 fc0e 	lsl.w	ip, r2, lr
   1401a:	fa22 f205 	lsr.w	r2, r2, r5
   1401e:	1880      	adds	r0, r0, r2
   14020:	f141 0100 	adc.w	r1, r1, #0
   14024:	fa03 f20e 	lsl.w	r2, r3, lr
   14028:	1880      	adds	r0, r0, r2
   1402a:	fa43 f305 	asr.w	r3, r3, r5
   1402e:	4159      	adcs	r1, r3
   14030:	e00e      	b.n	14050 <__adddf3+0xd0>
   14032:	f1a5 0520 	sub.w	r5, r5, #32
   14036:	f10e 0e20 	add.w	lr, lr, #32
   1403a:	2a01      	cmp	r2, #1
   1403c:	fa03 fc0e 	lsl.w	ip, r3, lr
   14040:	bf28      	it	cs
   14042:	f04c 0c02 	orrcs.w	ip, ip, #2
   14046:	fa43 f305 	asr.w	r3, r3, r5
   1404a:	18c0      	adds	r0, r0, r3
   1404c:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   14050:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14054:	d507      	bpl.n	14066 <__adddf3+0xe6>
   14056:	f04f 0e00 	mov.w	lr, #0
   1405a:	f1dc 0c00 	rsbs	ip, ip, #0
   1405e:	eb7e 0000 	sbcs.w	r0, lr, r0
   14062:	eb6e 0101 	sbc.w	r1, lr, r1
   14066:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   1406a:	d31b      	bcc.n	140a4 <__adddf3+0x124>
   1406c:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   14070:	d30c      	bcc.n	1408c <__adddf3+0x10c>
   14072:	0849      	lsrs	r1, r1, #1
   14074:	ea5f 0030 	movs.w	r0, r0, rrx
   14078:	ea4f 0c3c 	mov.w	ip, ip, rrx
   1407c:	f104 0401 	add.w	r4, r4, #1
   14080:	ea4f 5244 	mov.w	r2, r4, lsl #21
   14084:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   14088:	f080 809a 	bcs.w	141c0 <__adddf3+0x240>
   1408c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   14090:	bf08      	it	eq
   14092:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   14096:	f150 0000 	adcs.w	r0, r0, #0
   1409a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1409e:	ea41 0105 	orr.w	r1, r1, r5
   140a2:	bd30      	pop	{r4, r5, pc}
   140a4:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   140a8:	4140      	adcs	r0, r0
   140aa:	eb41 0101 	adc.w	r1, r1, r1
   140ae:	3c01      	subs	r4, #1
   140b0:	bf28      	it	cs
   140b2:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   140b6:	d2e9      	bcs.n	1408c <__adddf3+0x10c>
   140b8:	f091 0f00 	teq	r1, #0
   140bc:	bf04      	itt	eq
   140be:	4601      	moveq	r1, r0
   140c0:	2000      	moveq	r0, #0
   140c2:	fab1 f381 	clz	r3, r1
   140c6:	bf08      	it	eq
   140c8:	3320      	addeq	r3, #32
   140ca:	f1a3 030b 	sub.w	r3, r3, #11
   140ce:	f1b3 0220 	subs.w	r2, r3, #32
   140d2:	da0c      	bge.n	140ee <__adddf3+0x16e>
   140d4:	320c      	adds	r2, #12
   140d6:	dd08      	ble.n	140ea <__adddf3+0x16a>
   140d8:	f102 0c14 	add.w	ip, r2, #20
   140dc:	f1c2 020c 	rsb	r2, r2, #12
   140e0:	fa01 f00c 	lsl.w	r0, r1, ip
   140e4:	fa21 f102 	lsr.w	r1, r1, r2
   140e8:	e00c      	b.n	14104 <__adddf3+0x184>
   140ea:	f102 0214 	add.w	r2, r2, #20
   140ee:	bfd8      	it	le
   140f0:	f1c2 0c20 	rsble	ip, r2, #32
   140f4:	fa01 f102 	lsl.w	r1, r1, r2
   140f8:	fa20 fc0c 	lsr.w	ip, r0, ip
   140fc:	bfdc      	itt	le
   140fe:	ea41 010c 	orrle.w	r1, r1, ip
   14102:	4090      	lslle	r0, r2
   14104:	1ae4      	subs	r4, r4, r3
   14106:	bfa2      	ittt	ge
   14108:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   1410c:	4329      	orrge	r1, r5
   1410e:	bd30      	popge	{r4, r5, pc}
   14110:	ea6f 0404 	mvn.w	r4, r4
   14114:	3c1f      	subs	r4, #31
   14116:	da1c      	bge.n	14152 <__adddf3+0x1d2>
   14118:	340c      	adds	r4, #12
   1411a:	dc0e      	bgt.n	1413a <__adddf3+0x1ba>
   1411c:	f104 0414 	add.w	r4, r4, #20
   14120:	f1c4 0220 	rsb	r2, r4, #32
   14124:	fa20 f004 	lsr.w	r0, r0, r4
   14128:	fa01 f302 	lsl.w	r3, r1, r2
   1412c:	ea40 0003 	orr.w	r0, r0, r3
   14130:	fa21 f304 	lsr.w	r3, r1, r4
   14134:	ea45 0103 	orr.w	r1, r5, r3
   14138:	bd30      	pop	{r4, r5, pc}
   1413a:	f1c4 040c 	rsb	r4, r4, #12
   1413e:	f1c4 0220 	rsb	r2, r4, #32
   14142:	fa20 f002 	lsr.w	r0, r0, r2
   14146:	fa01 f304 	lsl.w	r3, r1, r4
   1414a:	ea40 0003 	orr.w	r0, r0, r3
   1414e:	4629      	mov	r1, r5
   14150:	bd30      	pop	{r4, r5, pc}
   14152:	fa21 f004 	lsr.w	r0, r1, r4
   14156:	4629      	mov	r1, r5
   14158:	bd30      	pop	{r4, r5, pc}
   1415a:	f094 0f00 	teq	r4, #0
   1415e:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   14162:	bf06      	itte	eq
   14164:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   14168:	3401      	addeq	r4, #1
   1416a:	3d01      	subne	r5, #1
   1416c:	e74e      	b.n	1400c <__adddf3+0x8c>
   1416e:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   14172:	bf18      	it	ne
   14174:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   14178:	d029      	beq.n	141ce <__adddf3+0x24e>
   1417a:	ea94 0f05 	teq	r4, r5
   1417e:	bf08      	it	eq
   14180:	ea90 0f02 	teqeq	r0, r2
   14184:	d005      	beq.n	14192 <__adddf3+0x212>
   14186:	ea54 0c00 	orrs.w	ip, r4, r0
   1418a:	bf04      	itt	eq
   1418c:	4619      	moveq	r1, r3
   1418e:	4610      	moveq	r0, r2
   14190:	bd30      	pop	{r4, r5, pc}
   14192:	ea91 0f03 	teq	r1, r3
   14196:	bf1e      	ittt	ne
   14198:	2100      	movne	r1, #0
   1419a:	2000      	movne	r0, #0
   1419c:	bd30      	popne	{r4, r5, pc}
   1419e:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   141a2:	d105      	bne.n	141b0 <__adddf3+0x230>
   141a4:	0040      	lsls	r0, r0, #1
   141a6:	4149      	adcs	r1, r1
   141a8:	bf28      	it	cs
   141aa:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   141ae:	bd30      	pop	{r4, r5, pc}
   141b0:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   141b4:	bf3c      	itt	cc
   141b6:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   141ba:	bd30      	popcc	{r4, r5, pc}
   141bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   141c0:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   141c4:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   141c8:	f04f 0000 	mov.w	r0, #0
   141cc:	bd30      	pop	{r4, r5, pc}
   141ce:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   141d2:	bf1a      	itte	ne
   141d4:	4619      	movne	r1, r3
   141d6:	4610      	movne	r0, r2
   141d8:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   141dc:	bf1c      	itt	ne
   141de:	460b      	movne	r3, r1
   141e0:	4602      	movne	r2, r0
   141e2:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   141e6:	bf06      	itte	eq
   141e8:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   141ec:	ea91 0f03 	teqeq	r1, r3
   141f0:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   141f4:	bd30      	pop	{r4, r5, pc}
   141f6:	bf00      	nop

000141f8 <__aeabi_ui2d>:
   141f8:	f090 0f00 	teq	r0, #0
   141fc:	bf04      	itt	eq
   141fe:	2100      	moveq	r1, #0
   14200:	4770      	bxeq	lr
   14202:	b530      	push	{r4, r5, lr}
   14204:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14208:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1420c:	f04f 0500 	mov.w	r5, #0
   14210:	f04f 0100 	mov.w	r1, #0
   14214:	e750      	b.n	140b8 <__adddf3+0x138>
   14216:	bf00      	nop

00014218 <__aeabi_i2d>:
   14218:	f090 0f00 	teq	r0, #0
   1421c:	bf04      	itt	eq
   1421e:	2100      	moveq	r1, #0
   14220:	4770      	bxeq	lr
   14222:	b530      	push	{r4, r5, lr}
   14224:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14228:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1422c:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   14230:	bf48      	it	mi
   14232:	4240      	negmi	r0, r0
   14234:	f04f 0100 	mov.w	r1, #0
   14238:	e73e      	b.n	140b8 <__adddf3+0x138>
   1423a:	bf00      	nop

0001423c <__aeabi_f2d>:
   1423c:	0042      	lsls	r2, r0, #1
   1423e:	ea4f 01e2 	mov.w	r1, r2, asr #3
   14242:	ea4f 0131 	mov.w	r1, r1, rrx
   14246:	ea4f 7002 	mov.w	r0, r2, lsl #28
   1424a:	bf1f      	itttt	ne
   1424c:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   14250:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   14254:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   14258:	4770      	bxne	lr
   1425a:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   1425e:	bf08      	it	eq
   14260:	4770      	bxeq	lr
   14262:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   14266:	bf04      	itt	eq
   14268:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   1426c:	4770      	bxeq	lr
   1426e:	b530      	push	{r4, r5, lr}
   14270:	f44f 7460 	mov.w	r4, #896	; 0x380
   14274:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14278:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   1427c:	e71c      	b.n	140b8 <__adddf3+0x138>
   1427e:	bf00      	nop

00014280 <__aeabi_ul2d>:
   14280:	ea50 0201 	orrs.w	r2, r0, r1
   14284:	bf08      	it	eq
   14286:	4770      	bxeq	lr
   14288:	b530      	push	{r4, r5, lr}
   1428a:	f04f 0500 	mov.w	r5, #0
   1428e:	e00a      	b.n	142a6 <__aeabi_l2d+0x16>

00014290 <__aeabi_l2d>:
   14290:	ea50 0201 	orrs.w	r2, r0, r1
   14294:	bf08      	it	eq
   14296:	4770      	bxeq	lr
   14298:	b530      	push	{r4, r5, lr}
   1429a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   1429e:	d502      	bpl.n	142a6 <__aeabi_l2d+0x16>
   142a0:	4240      	negs	r0, r0
   142a2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   142a6:	f44f 6480 	mov.w	r4, #1024	; 0x400
   142aa:	f104 0432 	add.w	r4, r4, #50	; 0x32
   142ae:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   142b2:	f43f aed8 	beq.w	14066 <__adddf3+0xe6>
   142b6:	f04f 0203 	mov.w	r2, #3
   142ba:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   142be:	bf18      	it	ne
   142c0:	3203      	addne	r2, #3
   142c2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   142c6:	bf18      	it	ne
   142c8:	3203      	addne	r2, #3
   142ca:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   142ce:	f1c2 0320 	rsb	r3, r2, #32
   142d2:	fa00 fc03 	lsl.w	ip, r0, r3
   142d6:	fa20 f002 	lsr.w	r0, r0, r2
   142da:	fa01 fe03 	lsl.w	lr, r1, r3
   142de:	ea40 000e 	orr.w	r0, r0, lr
   142e2:	fa21 f102 	lsr.w	r1, r1, r2
   142e6:	4414      	add	r4, r2
   142e8:	e6bd      	b.n	14066 <__adddf3+0xe6>
   142ea:	bf00      	nop

000142ec <__aeabi_dmul>:
   142ec:	b570      	push	{r4, r5, r6, lr}
   142ee:	f04f 0cff 	mov.w	ip, #255	; 0xff
   142f2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   142f6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   142fa:	bf1d      	ittte	ne
   142fc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14300:	ea94 0f0c 	teqne	r4, ip
   14304:	ea95 0f0c 	teqne	r5, ip
   14308:	f000 f8de 	bleq	144c8 <__aeabi_dmul+0x1dc>
   1430c:	442c      	add	r4, r5
   1430e:	ea81 0603 	eor.w	r6, r1, r3
   14312:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   14316:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   1431a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   1431e:	bf18      	it	ne
   14320:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   14324:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14328:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   1432c:	d038      	beq.n	143a0 <__aeabi_dmul+0xb4>
   1432e:	fba0 ce02 	umull	ip, lr, r0, r2
   14332:	f04f 0500 	mov.w	r5, #0
   14336:	fbe1 e502 	umlal	lr, r5, r1, r2
   1433a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   1433e:	fbe0 e503 	umlal	lr, r5, r0, r3
   14342:	f04f 0600 	mov.w	r6, #0
   14346:	fbe1 5603 	umlal	r5, r6, r1, r3
   1434a:	f09c 0f00 	teq	ip, #0
   1434e:	bf18      	it	ne
   14350:	f04e 0e01 	orrne.w	lr, lr, #1
   14354:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   14358:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   1435c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   14360:	d204      	bcs.n	1436c <__aeabi_dmul+0x80>
   14362:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   14366:	416d      	adcs	r5, r5
   14368:	eb46 0606 	adc.w	r6, r6, r6
   1436c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   14370:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   14374:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   14378:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   1437c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   14380:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14384:	bf88      	it	hi
   14386:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   1438a:	d81e      	bhi.n	143ca <__aeabi_dmul+0xde>
   1438c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   14390:	bf08      	it	eq
   14392:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   14396:	f150 0000 	adcs.w	r0, r0, #0
   1439a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1439e:	bd70      	pop	{r4, r5, r6, pc}
   143a0:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   143a4:	ea46 0101 	orr.w	r1, r6, r1
   143a8:	ea40 0002 	orr.w	r0, r0, r2
   143ac:	ea81 0103 	eor.w	r1, r1, r3
   143b0:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   143b4:	bfc2      	ittt	gt
   143b6:	ebd4 050c 	rsbsgt	r5, r4, ip
   143ba:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   143be:	bd70      	popgt	{r4, r5, r6, pc}
   143c0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   143c4:	f04f 0e00 	mov.w	lr, #0
   143c8:	3c01      	subs	r4, #1
   143ca:	f300 80ab 	bgt.w	14524 <__aeabi_dmul+0x238>
   143ce:	f114 0f36 	cmn.w	r4, #54	; 0x36
   143d2:	bfde      	ittt	le
   143d4:	2000      	movle	r0, #0
   143d6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   143da:	bd70      	pople	{r4, r5, r6, pc}
   143dc:	f1c4 0400 	rsb	r4, r4, #0
   143e0:	3c20      	subs	r4, #32
   143e2:	da35      	bge.n	14450 <__aeabi_dmul+0x164>
   143e4:	340c      	adds	r4, #12
   143e6:	dc1b      	bgt.n	14420 <__aeabi_dmul+0x134>
   143e8:	f104 0414 	add.w	r4, r4, #20
   143ec:	f1c4 0520 	rsb	r5, r4, #32
   143f0:	fa00 f305 	lsl.w	r3, r0, r5
   143f4:	fa20 f004 	lsr.w	r0, r0, r4
   143f8:	fa01 f205 	lsl.w	r2, r1, r5
   143fc:	ea40 0002 	orr.w	r0, r0, r2
   14400:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   14404:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   14408:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   1440c:	fa21 f604 	lsr.w	r6, r1, r4
   14410:	eb42 0106 	adc.w	r1, r2, r6
   14414:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14418:	bf08      	it	eq
   1441a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1441e:	bd70      	pop	{r4, r5, r6, pc}
   14420:	f1c4 040c 	rsb	r4, r4, #12
   14424:	f1c4 0520 	rsb	r5, r4, #32
   14428:	fa00 f304 	lsl.w	r3, r0, r4
   1442c:	fa20 f005 	lsr.w	r0, r0, r5
   14430:	fa01 f204 	lsl.w	r2, r1, r4
   14434:	ea40 0002 	orr.w	r0, r0, r2
   14438:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   1443c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   14440:	f141 0100 	adc.w	r1, r1, #0
   14444:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14448:	bf08      	it	eq
   1444a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   1444e:	bd70      	pop	{r4, r5, r6, pc}
   14450:	f1c4 0520 	rsb	r5, r4, #32
   14454:	fa00 f205 	lsl.w	r2, r0, r5
   14458:	ea4e 0e02 	orr.w	lr, lr, r2
   1445c:	fa20 f304 	lsr.w	r3, r0, r4
   14460:	fa01 f205 	lsl.w	r2, r1, r5
   14464:	ea43 0302 	orr.w	r3, r3, r2
   14468:	fa21 f004 	lsr.w	r0, r1, r4
   1446c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14470:	fa21 f204 	lsr.w	r2, r1, r4
   14474:	ea20 0002 	bic.w	r0, r0, r2
   14478:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   1447c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14480:	bf08      	it	eq
   14482:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14486:	bd70      	pop	{r4, r5, r6, pc}
   14488:	f094 0f00 	teq	r4, #0
   1448c:	d10f      	bne.n	144ae <__aeabi_dmul+0x1c2>
   1448e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   14492:	0040      	lsls	r0, r0, #1
   14494:	eb41 0101 	adc.w	r1, r1, r1
   14498:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   1449c:	bf08      	it	eq
   1449e:	3c01      	subeq	r4, #1
   144a0:	d0f7      	beq.n	14492 <__aeabi_dmul+0x1a6>
   144a2:	ea41 0106 	orr.w	r1, r1, r6
   144a6:	f095 0f00 	teq	r5, #0
   144aa:	bf18      	it	ne
   144ac:	4770      	bxne	lr
   144ae:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   144b2:	0052      	lsls	r2, r2, #1
   144b4:	eb43 0303 	adc.w	r3, r3, r3
   144b8:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   144bc:	bf08      	it	eq
   144be:	3d01      	subeq	r5, #1
   144c0:	d0f7      	beq.n	144b2 <__aeabi_dmul+0x1c6>
   144c2:	ea43 0306 	orr.w	r3, r3, r6
   144c6:	4770      	bx	lr
   144c8:	ea94 0f0c 	teq	r4, ip
   144cc:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   144d0:	bf18      	it	ne
   144d2:	ea95 0f0c 	teqne	r5, ip
   144d6:	d00c      	beq.n	144f2 <__aeabi_dmul+0x206>
   144d8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   144dc:	bf18      	it	ne
   144de:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   144e2:	d1d1      	bne.n	14488 <__aeabi_dmul+0x19c>
   144e4:	ea81 0103 	eor.w	r1, r1, r3
   144e8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   144ec:	f04f 0000 	mov.w	r0, #0
   144f0:	bd70      	pop	{r4, r5, r6, pc}
   144f2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   144f6:	bf06      	itte	eq
   144f8:	4610      	moveq	r0, r2
   144fa:	4619      	moveq	r1, r3
   144fc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14500:	d019      	beq.n	14536 <__aeabi_dmul+0x24a>
   14502:	ea94 0f0c 	teq	r4, ip
   14506:	d102      	bne.n	1450e <__aeabi_dmul+0x222>
   14508:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   1450c:	d113      	bne.n	14536 <__aeabi_dmul+0x24a>
   1450e:	ea95 0f0c 	teq	r5, ip
   14512:	d105      	bne.n	14520 <__aeabi_dmul+0x234>
   14514:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   14518:	bf1c      	itt	ne
   1451a:	4610      	movne	r0, r2
   1451c:	4619      	movne	r1, r3
   1451e:	d10a      	bne.n	14536 <__aeabi_dmul+0x24a>
   14520:	ea81 0103 	eor.w	r1, r1, r3
   14524:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14528:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1452c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14530:	f04f 0000 	mov.w	r0, #0
   14534:	bd70      	pop	{r4, r5, r6, pc}
   14536:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   1453a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   1453e:	bd70      	pop	{r4, r5, r6, pc}

00014540 <__aeabi_ddiv>:
   14540:	b570      	push	{r4, r5, r6, lr}
   14542:	f04f 0cff 	mov.w	ip, #255	; 0xff
   14546:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   1454a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   1454e:	bf1d      	ittte	ne
   14550:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14554:	ea94 0f0c 	teqne	r4, ip
   14558:	ea95 0f0c 	teqne	r5, ip
   1455c:	f000 f8a7 	bleq	146ae <__aeabi_ddiv+0x16e>
   14560:	eba4 0405 	sub.w	r4, r4, r5
   14564:	ea81 0e03 	eor.w	lr, r1, r3
   14568:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   1456c:	ea4f 3101 	mov.w	r1, r1, lsl #12
   14570:	f000 8088 	beq.w	14684 <__aeabi_ddiv+0x144>
   14574:	ea4f 3303 	mov.w	r3, r3, lsl #12
   14578:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   1457c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   14580:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   14584:	ea4f 2202 	mov.w	r2, r2, lsl #8
   14588:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   1458c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   14590:	ea4f 2600 	mov.w	r6, r0, lsl #8
   14594:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   14598:	429d      	cmp	r5, r3
   1459a:	bf08      	it	eq
   1459c:	4296      	cmpeq	r6, r2
   1459e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   145a2:	f504 7440 	add.w	r4, r4, #768	; 0x300
   145a6:	d202      	bcs.n	145ae <__aeabi_ddiv+0x6e>
   145a8:	085b      	lsrs	r3, r3, #1
   145aa:	ea4f 0232 	mov.w	r2, r2, rrx
   145ae:	1ab6      	subs	r6, r6, r2
   145b0:	eb65 0503 	sbc.w	r5, r5, r3
   145b4:	085b      	lsrs	r3, r3, #1
   145b6:	ea4f 0232 	mov.w	r2, r2, rrx
   145ba:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   145be:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   145c2:	ebb6 0e02 	subs.w	lr, r6, r2
   145c6:	eb75 0e03 	sbcs.w	lr, r5, r3
   145ca:	bf22      	ittt	cs
   145cc:	1ab6      	subcs	r6, r6, r2
   145ce:	4675      	movcs	r5, lr
   145d0:	ea40 000c 	orrcs.w	r0, r0, ip
   145d4:	085b      	lsrs	r3, r3, #1
   145d6:	ea4f 0232 	mov.w	r2, r2, rrx
   145da:	ebb6 0e02 	subs.w	lr, r6, r2
   145de:	eb75 0e03 	sbcs.w	lr, r5, r3
   145e2:	bf22      	ittt	cs
   145e4:	1ab6      	subcs	r6, r6, r2
   145e6:	4675      	movcs	r5, lr
   145e8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   145ec:	085b      	lsrs	r3, r3, #1
   145ee:	ea4f 0232 	mov.w	r2, r2, rrx
   145f2:	ebb6 0e02 	subs.w	lr, r6, r2
   145f6:	eb75 0e03 	sbcs.w	lr, r5, r3
   145fa:	bf22      	ittt	cs
   145fc:	1ab6      	subcs	r6, r6, r2
   145fe:	4675      	movcs	r5, lr
   14600:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   14604:	085b      	lsrs	r3, r3, #1
   14606:	ea4f 0232 	mov.w	r2, r2, rrx
   1460a:	ebb6 0e02 	subs.w	lr, r6, r2
   1460e:	eb75 0e03 	sbcs.w	lr, r5, r3
   14612:	bf22      	ittt	cs
   14614:	1ab6      	subcs	r6, r6, r2
   14616:	4675      	movcs	r5, lr
   14618:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   1461c:	ea55 0e06 	orrs.w	lr, r5, r6
   14620:	d018      	beq.n	14654 <__aeabi_ddiv+0x114>
   14622:	ea4f 1505 	mov.w	r5, r5, lsl #4
   14626:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   1462a:	ea4f 1606 	mov.w	r6, r6, lsl #4
   1462e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   14632:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   14636:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   1463a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   1463e:	d1c0      	bne.n	145c2 <__aeabi_ddiv+0x82>
   14640:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14644:	d10b      	bne.n	1465e <__aeabi_ddiv+0x11e>
   14646:	ea41 0100 	orr.w	r1, r1, r0
   1464a:	f04f 0000 	mov.w	r0, #0
   1464e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   14652:	e7b6      	b.n	145c2 <__aeabi_ddiv+0x82>
   14654:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14658:	bf04      	itt	eq
   1465a:	4301      	orreq	r1, r0
   1465c:	2000      	moveq	r0, #0
   1465e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14662:	bf88      	it	hi
   14664:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14668:	f63f aeaf 	bhi.w	143ca <__aeabi_dmul+0xde>
   1466c:	ebb5 0c03 	subs.w	ip, r5, r3
   14670:	bf04      	itt	eq
   14672:	ebb6 0c02 	subseq.w	ip, r6, r2
   14676:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   1467a:	f150 0000 	adcs.w	r0, r0, #0
   1467e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   14682:	bd70      	pop	{r4, r5, r6, pc}
   14684:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   14688:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   1468c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   14690:	bfc2      	ittt	gt
   14692:	ebd4 050c 	rsbsgt	r5, r4, ip
   14696:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1469a:	bd70      	popgt	{r4, r5, r6, pc}
   1469c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   146a0:	f04f 0e00 	mov.w	lr, #0
   146a4:	3c01      	subs	r4, #1
   146a6:	e690      	b.n	143ca <__aeabi_dmul+0xde>
   146a8:	ea45 0e06 	orr.w	lr, r5, r6
   146ac:	e68d      	b.n	143ca <__aeabi_dmul+0xde>
   146ae:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   146b2:	ea94 0f0c 	teq	r4, ip
   146b6:	bf08      	it	eq
   146b8:	ea95 0f0c 	teqeq	r5, ip
   146bc:	f43f af3b 	beq.w	14536 <__aeabi_dmul+0x24a>
   146c0:	ea94 0f0c 	teq	r4, ip
   146c4:	d10a      	bne.n	146dc <__aeabi_ddiv+0x19c>
   146c6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   146ca:	f47f af34 	bne.w	14536 <__aeabi_dmul+0x24a>
   146ce:	ea95 0f0c 	teq	r5, ip
   146d2:	f47f af25 	bne.w	14520 <__aeabi_dmul+0x234>
   146d6:	4610      	mov	r0, r2
   146d8:	4619      	mov	r1, r3
   146da:	e72c      	b.n	14536 <__aeabi_dmul+0x24a>
   146dc:	ea95 0f0c 	teq	r5, ip
   146e0:	d106      	bne.n	146f0 <__aeabi_ddiv+0x1b0>
   146e2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   146e6:	f43f aefd 	beq.w	144e4 <__aeabi_dmul+0x1f8>
   146ea:	4610      	mov	r0, r2
   146ec:	4619      	mov	r1, r3
   146ee:	e722      	b.n	14536 <__aeabi_dmul+0x24a>
   146f0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   146f4:	bf18      	it	ne
   146f6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   146fa:	f47f aec5 	bne.w	14488 <__aeabi_dmul+0x19c>
   146fe:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   14702:	f47f af0d 	bne.w	14520 <__aeabi_dmul+0x234>
   14706:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   1470a:	f47f aeeb 	bne.w	144e4 <__aeabi_dmul+0x1f8>
   1470e:	e712      	b.n	14536 <__aeabi_dmul+0x24a>

00014710 <__aeabi_d2uiz>:
   14710:	004a      	lsls	r2, r1, #1
   14712:	d211      	bcs.n	14738 <__aeabi_d2uiz+0x28>
   14714:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   14718:	d211      	bcs.n	1473e <__aeabi_d2uiz+0x2e>
   1471a:	d50d      	bpl.n	14738 <__aeabi_d2uiz+0x28>
   1471c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   14720:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   14724:	d40e      	bmi.n	14744 <__aeabi_d2uiz+0x34>
   14726:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   1472a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1472e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   14732:	fa23 f002 	lsr.w	r0, r3, r2
   14736:	4770      	bx	lr
   14738:	f04f 0000 	mov.w	r0, #0
   1473c:	4770      	bx	lr
   1473e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   14742:	d102      	bne.n	1474a <__aeabi_d2uiz+0x3a>
   14744:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14748:	4770      	bx	lr
   1474a:	f04f 0000 	mov.w	r0, #0
   1474e:	4770      	bx	lr

00014750 <__libc_init_array>:
   14750:	b570      	push	{r4, r5, r6, lr}
   14752:	4d0d      	ldr	r5, [pc, #52]	; (14788 <__libc_init_array+0x38>)
   14754:	4c0d      	ldr	r4, [pc, #52]	; (1478c <__libc_init_array+0x3c>)
   14756:	1b64      	subs	r4, r4, r5
   14758:	10a4      	asrs	r4, r4, #2
   1475a:	2600      	movs	r6, #0
   1475c:	42a6      	cmp	r6, r4
   1475e:	d109      	bne.n	14774 <__libc_init_array+0x24>
   14760:	4d0b      	ldr	r5, [pc, #44]	; (14790 <__libc_init_array+0x40>)
   14762:	4c0c      	ldr	r4, [pc, #48]	; (14794 <__libc_init_array+0x44>)
   14764:	f002 fbf4 	bl	16f50 <_init>
   14768:	1b64      	subs	r4, r4, r5
   1476a:	10a4      	asrs	r4, r4, #2
   1476c:	2600      	movs	r6, #0
   1476e:	42a6      	cmp	r6, r4
   14770:	d105      	bne.n	1477e <__libc_init_array+0x2e>
   14772:	bd70      	pop	{r4, r5, r6, pc}
   14774:	f855 3b04 	ldr.w	r3, [r5], #4
   14778:	4798      	blx	r3
   1477a:	3601      	adds	r6, #1
   1477c:	e7ee      	b.n	1475c <__libc_init_array+0xc>
   1477e:	f855 3b04 	ldr.w	r3, [r5], #4
   14782:	4798      	blx	r3
   14784:	3601      	adds	r6, #1
   14786:	e7f2      	b.n	1476e <__libc_init_array+0x1e>
   14788:	00016f5c 	.word	0x00016f5c
   1478c:	00016f5c 	.word	0x00016f5c
   14790:	00016f5c 	.word	0x00016f5c
   14794:	00016f60 	.word	0x00016f60

00014798 <malloc>:
   14798:	4b02      	ldr	r3, [pc, #8]	; (147a4 <malloc+0xc>)
   1479a:	4601      	mov	r1, r0
   1479c:	6818      	ldr	r0, [r3, #0]
   1479e:	f000 b867 	b.w	14870 <_malloc_r>
   147a2:	bf00      	nop
   147a4:	2000054c 	.word	0x2000054c

000147a8 <memcpy>:
   147a8:	440a      	add	r2, r1
   147aa:	4291      	cmp	r1, r2
   147ac:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   147b0:	d100      	bne.n	147b4 <memcpy+0xc>
   147b2:	4770      	bx	lr
   147b4:	b510      	push	{r4, lr}
   147b6:	f811 4b01 	ldrb.w	r4, [r1], #1
   147ba:	f803 4f01 	strb.w	r4, [r3, #1]!
   147be:	4291      	cmp	r1, r2
   147c0:	d1f9      	bne.n	147b6 <memcpy+0xe>
   147c2:	bd10      	pop	{r4, pc}

000147c4 <memset>:
   147c4:	4402      	add	r2, r0
   147c6:	4603      	mov	r3, r0
   147c8:	4293      	cmp	r3, r2
   147ca:	d100      	bne.n	147ce <memset+0xa>
   147cc:	4770      	bx	lr
   147ce:	f803 1b01 	strb.w	r1, [r3], #1
   147d2:	e7f9      	b.n	147c8 <memset+0x4>

000147d4 <_free_r>:
   147d4:	b538      	push	{r3, r4, r5, lr}
   147d6:	4605      	mov	r5, r0
   147d8:	2900      	cmp	r1, #0
   147da:	d045      	beq.n	14868 <_free_r+0x94>
   147dc:	f851 3c04 	ldr.w	r3, [r1, #-4]
   147e0:	1f0c      	subs	r4, r1, #4
   147e2:	2b00      	cmp	r3, #0
   147e4:	bfb8      	it	lt
   147e6:	18e4      	addlt	r4, r4, r3
   147e8:	f000 fd76 	bl	152d8 <__malloc_lock>
   147ec:	4a1f      	ldr	r2, [pc, #124]	; (1486c <_free_r+0x98>)
   147ee:	6813      	ldr	r3, [r2, #0]
   147f0:	4610      	mov	r0, r2
   147f2:	b933      	cbnz	r3, 14802 <_free_r+0x2e>
   147f4:	6063      	str	r3, [r4, #4]
   147f6:	6014      	str	r4, [r2, #0]
   147f8:	4628      	mov	r0, r5
   147fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   147fe:	f000 bd71 	b.w	152e4 <__malloc_unlock>
   14802:	42a3      	cmp	r3, r4
   14804:	d90b      	bls.n	1481e <_free_r+0x4a>
   14806:	6821      	ldr	r1, [r4, #0]
   14808:	1862      	adds	r2, r4, r1
   1480a:	4293      	cmp	r3, r2
   1480c:	bf04      	itt	eq
   1480e:	681a      	ldreq	r2, [r3, #0]
   14810:	685b      	ldreq	r3, [r3, #4]
   14812:	6063      	str	r3, [r4, #4]
   14814:	bf04      	itt	eq
   14816:	1852      	addeq	r2, r2, r1
   14818:	6022      	streq	r2, [r4, #0]
   1481a:	6004      	str	r4, [r0, #0]
   1481c:	e7ec      	b.n	147f8 <_free_r+0x24>
   1481e:	461a      	mov	r2, r3
   14820:	685b      	ldr	r3, [r3, #4]
   14822:	b10b      	cbz	r3, 14828 <_free_r+0x54>
   14824:	42a3      	cmp	r3, r4
   14826:	d9fa      	bls.n	1481e <_free_r+0x4a>
   14828:	6811      	ldr	r1, [r2, #0]
   1482a:	1850      	adds	r0, r2, r1
   1482c:	42a0      	cmp	r0, r4
   1482e:	d10b      	bne.n	14848 <_free_r+0x74>
   14830:	6820      	ldr	r0, [r4, #0]
   14832:	4401      	add	r1, r0
   14834:	1850      	adds	r0, r2, r1
   14836:	4283      	cmp	r3, r0
   14838:	6011      	str	r1, [r2, #0]
   1483a:	d1dd      	bne.n	147f8 <_free_r+0x24>
   1483c:	6818      	ldr	r0, [r3, #0]
   1483e:	685b      	ldr	r3, [r3, #4]
   14840:	6053      	str	r3, [r2, #4]
   14842:	4401      	add	r1, r0
   14844:	6011      	str	r1, [r2, #0]
   14846:	e7d7      	b.n	147f8 <_free_r+0x24>
   14848:	d902      	bls.n	14850 <_free_r+0x7c>
   1484a:	230c      	movs	r3, #12
   1484c:	602b      	str	r3, [r5, #0]
   1484e:	e7d3      	b.n	147f8 <_free_r+0x24>
   14850:	6820      	ldr	r0, [r4, #0]
   14852:	1821      	adds	r1, r4, r0
   14854:	428b      	cmp	r3, r1
   14856:	bf04      	itt	eq
   14858:	6819      	ldreq	r1, [r3, #0]
   1485a:	685b      	ldreq	r3, [r3, #4]
   1485c:	6063      	str	r3, [r4, #4]
   1485e:	bf04      	itt	eq
   14860:	1809      	addeq	r1, r1, r0
   14862:	6021      	streq	r1, [r4, #0]
   14864:	6054      	str	r4, [r2, #4]
   14866:	e7c7      	b.n	147f8 <_free_r+0x24>
   14868:	bd38      	pop	{r3, r4, r5, pc}
   1486a:	bf00      	nop
   1486c:	20009138 	.word	0x20009138

00014870 <_malloc_r>:
   14870:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14872:	1ccd      	adds	r5, r1, #3
   14874:	f025 0503 	bic.w	r5, r5, #3
   14878:	3508      	adds	r5, #8
   1487a:	2d0c      	cmp	r5, #12
   1487c:	bf38      	it	cc
   1487e:	250c      	movcc	r5, #12
   14880:	2d00      	cmp	r5, #0
   14882:	4606      	mov	r6, r0
   14884:	db01      	blt.n	1488a <_malloc_r+0x1a>
   14886:	42a9      	cmp	r1, r5
   14888:	d903      	bls.n	14892 <_malloc_r+0x22>
   1488a:	230c      	movs	r3, #12
   1488c:	6033      	str	r3, [r6, #0]
   1488e:	2000      	movs	r0, #0
   14890:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14892:	f000 fd21 	bl	152d8 <__malloc_lock>
   14896:	4921      	ldr	r1, [pc, #132]	; (1491c <_malloc_r+0xac>)
   14898:	680a      	ldr	r2, [r1, #0]
   1489a:	4614      	mov	r4, r2
   1489c:	b99c      	cbnz	r4, 148c6 <_malloc_r+0x56>
   1489e:	4f20      	ldr	r7, [pc, #128]	; (14920 <_malloc_r+0xb0>)
   148a0:	683b      	ldr	r3, [r7, #0]
   148a2:	b923      	cbnz	r3, 148ae <_malloc_r+0x3e>
   148a4:	4621      	mov	r1, r4
   148a6:	4630      	mov	r0, r6
   148a8:	f000 f8de 	bl	14a68 <_sbrk_r>
   148ac:	6038      	str	r0, [r7, #0]
   148ae:	4629      	mov	r1, r5
   148b0:	4630      	mov	r0, r6
   148b2:	f000 f8d9 	bl	14a68 <_sbrk_r>
   148b6:	1c43      	adds	r3, r0, #1
   148b8:	d123      	bne.n	14902 <_malloc_r+0x92>
   148ba:	230c      	movs	r3, #12
   148bc:	6033      	str	r3, [r6, #0]
   148be:	4630      	mov	r0, r6
   148c0:	f000 fd10 	bl	152e4 <__malloc_unlock>
   148c4:	e7e3      	b.n	1488e <_malloc_r+0x1e>
   148c6:	6823      	ldr	r3, [r4, #0]
   148c8:	1b5b      	subs	r3, r3, r5
   148ca:	d417      	bmi.n	148fc <_malloc_r+0x8c>
   148cc:	2b0b      	cmp	r3, #11
   148ce:	d903      	bls.n	148d8 <_malloc_r+0x68>
   148d0:	6023      	str	r3, [r4, #0]
   148d2:	441c      	add	r4, r3
   148d4:	6025      	str	r5, [r4, #0]
   148d6:	e004      	b.n	148e2 <_malloc_r+0x72>
   148d8:	6863      	ldr	r3, [r4, #4]
   148da:	42a2      	cmp	r2, r4
   148dc:	bf0c      	ite	eq
   148de:	600b      	streq	r3, [r1, #0]
   148e0:	6053      	strne	r3, [r2, #4]
   148e2:	4630      	mov	r0, r6
   148e4:	f000 fcfe 	bl	152e4 <__malloc_unlock>
   148e8:	f104 000b 	add.w	r0, r4, #11
   148ec:	1d23      	adds	r3, r4, #4
   148ee:	f020 0007 	bic.w	r0, r0, #7
   148f2:	1ac2      	subs	r2, r0, r3
   148f4:	d0cc      	beq.n	14890 <_malloc_r+0x20>
   148f6:	1a1b      	subs	r3, r3, r0
   148f8:	50a3      	str	r3, [r4, r2]
   148fa:	e7c9      	b.n	14890 <_malloc_r+0x20>
   148fc:	4622      	mov	r2, r4
   148fe:	6864      	ldr	r4, [r4, #4]
   14900:	e7cc      	b.n	1489c <_malloc_r+0x2c>
   14902:	1cc4      	adds	r4, r0, #3
   14904:	f024 0403 	bic.w	r4, r4, #3
   14908:	42a0      	cmp	r0, r4
   1490a:	d0e3      	beq.n	148d4 <_malloc_r+0x64>
   1490c:	1a21      	subs	r1, r4, r0
   1490e:	4630      	mov	r0, r6
   14910:	f000 f8aa 	bl	14a68 <_sbrk_r>
   14914:	3001      	adds	r0, #1
   14916:	d1dd      	bne.n	148d4 <_malloc_r+0x64>
   14918:	e7cf      	b.n	148ba <_malloc_r+0x4a>
   1491a:	bf00      	nop
   1491c:	20009138 	.word	0x20009138
   14920:	2000913c 	.word	0x2000913c

00014924 <iprintf>:
   14924:	b40f      	push	{r0, r1, r2, r3}
   14926:	4b0a      	ldr	r3, [pc, #40]	; (14950 <iprintf+0x2c>)
   14928:	b513      	push	{r0, r1, r4, lr}
   1492a:	681c      	ldr	r4, [r3, #0]
   1492c:	b124      	cbz	r4, 14938 <iprintf+0x14>
   1492e:	69a3      	ldr	r3, [r4, #24]
   14930:	b913      	cbnz	r3, 14938 <iprintf+0x14>
   14932:	4620      	mov	r0, r4
   14934:	f000 fbcc 	bl	150d0 <__sinit>
   14938:	ab05      	add	r3, sp, #20
   1493a:	9a04      	ldr	r2, [sp, #16]
   1493c:	68a1      	ldr	r1, [r4, #8]
   1493e:	9301      	str	r3, [sp, #4]
   14940:	4620      	mov	r0, r4
   14942:	f000 fe59 	bl	155f8 <_vfiprintf_r>
   14946:	b002      	add	sp, #8
   14948:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1494c:	b004      	add	sp, #16
   1494e:	4770      	bx	lr
   14950:	2000054c 	.word	0x2000054c

00014954 <putchar>:
   14954:	b538      	push	{r3, r4, r5, lr}
   14956:	4b08      	ldr	r3, [pc, #32]	; (14978 <putchar+0x24>)
   14958:	681c      	ldr	r4, [r3, #0]
   1495a:	4605      	mov	r5, r0
   1495c:	b124      	cbz	r4, 14968 <putchar+0x14>
   1495e:	69a3      	ldr	r3, [r4, #24]
   14960:	b913      	cbnz	r3, 14968 <putchar+0x14>
   14962:	4620      	mov	r0, r4
   14964:	f000 fbb4 	bl	150d0 <__sinit>
   14968:	68a2      	ldr	r2, [r4, #8]
   1496a:	4629      	mov	r1, r5
   1496c:	4620      	mov	r0, r4
   1496e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14972:	f001 b905 	b.w	15b80 <_putc_r>
   14976:	bf00      	nop
   14978:	2000054c 	.word	0x2000054c

0001497c <_puts_r>:
   1497c:	b570      	push	{r4, r5, r6, lr}
   1497e:	460e      	mov	r6, r1
   14980:	4605      	mov	r5, r0
   14982:	b118      	cbz	r0, 1498c <_puts_r+0x10>
   14984:	6983      	ldr	r3, [r0, #24]
   14986:	b90b      	cbnz	r3, 1498c <_puts_r+0x10>
   14988:	f000 fba2 	bl	150d0 <__sinit>
   1498c:	69ab      	ldr	r3, [r5, #24]
   1498e:	68ac      	ldr	r4, [r5, #8]
   14990:	b913      	cbnz	r3, 14998 <_puts_r+0x1c>
   14992:	4628      	mov	r0, r5
   14994:	f000 fb9c 	bl	150d0 <__sinit>
   14998:	4b2c      	ldr	r3, [pc, #176]	; (14a4c <_puts_r+0xd0>)
   1499a:	429c      	cmp	r4, r3
   1499c:	d120      	bne.n	149e0 <_puts_r+0x64>
   1499e:	686c      	ldr	r4, [r5, #4]
   149a0:	6e63      	ldr	r3, [r4, #100]	; 0x64
   149a2:	07db      	lsls	r3, r3, #31
   149a4:	d405      	bmi.n	149b2 <_puts_r+0x36>
   149a6:	89a3      	ldrh	r3, [r4, #12]
   149a8:	0598      	lsls	r0, r3, #22
   149aa:	d402      	bmi.n	149b2 <_puts_r+0x36>
   149ac:	6da0      	ldr	r0, [r4, #88]	; 0x58
   149ae:	f000 fc2d 	bl	1520c <__retarget_lock_acquire_recursive>
   149b2:	89a3      	ldrh	r3, [r4, #12]
   149b4:	0719      	lsls	r1, r3, #28
   149b6:	d51d      	bpl.n	149f4 <_puts_r+0x78>
   149b8:	6923      	ldr	r3, [r4, #16]
   149ba:	b1db      	cbz	r3, 149f4 <_puts_r+0x78>
   149bc:	3e01      	subs	r6, #1
   149be:	68a3      	ldr	r3, [r4, #8]
   149c0:	f816 1f01 	ldrb.w	r1, [r6, #1]!
   149c4:	3b01      	subs	r3, #1
   149c6:	60a3      	str	r3, [r4, #8]
   149c8:	bb39      	cbnz	r1, 14a1a <_puts_r+0x9e>
   149ca:	2b00      	cmp	r3, #0
   149cc:	da38      	bge.n	14a40 <_puts_r+0xc4>
   149ce:	4622      	mov	r2, r4
   149d0:	210a      	movs	r1, #10
   149d2:	4628      	mov	r0, r5
   149d4:	f000 f9a2 	bl	14d1c <__swbuf_r>
   149d8:	3001      	adds	r0, #1
   149da:	d011      	beq.n	14a00 <_puts_r+0x84>
   149dc:	250a      	movs	r5, #10
   149de:	e011      	b.n	14a04 <_puts_r+0x88>
   149e0:	4b1b      	ldr	r3, [pc, #108]	; (14a50 <_puts_r+0xd4>)
   149e2:	429c      	cmp	r4, r3
   149e4:	d101      	bne.n	149ea <_puts_r+0x6e>
   149e6:	68ac      	ldr	r4, [r5, #8]
   149e8:	e7da      	b.n	149a0 <_puts_r+0x24>
   149ea:	4b1a      	ldr	r3, [pc, #104]	; (14a54 <_puts_r+0xd8>)
   149ec:	429c      	cmp	r4, r3
   149ee:	bf08      	it	eq
   149f0:	68ec      	ldreq	r4, [r5, #12]
   149f2:	e7d5      	b.n	149a0 <_puts_r+0x24>
   149f4:	4621      	mov	r1, r4
   149f6:	4628      	mov	r0, r5
   149f8:	f000 f9e2 	bl	14dc0 <__swsetup_r>
   149fc:	2800      	cmp	r0, #0
   149fe:	d0dd      	beq.n	149bc <_puts_r+0x40>
   14a00:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   14a04:	6e63      	ldr	r3, [r4, #100]	; 0x64
   14a06:	07da      	lsls	r2, r3, #31
   14a08:	d405      	bmi.n	14a16 <_puts_r+0x9a>
   14a0a:	89a3      	ldrh	r3, [r4, #12]
   14a0c:	059b      	lsls	r3, r3, #22
   14a0e:	d402      	bmi.n	14a16 <_puts_r+0x9a>
   14a10:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14a12:	f000 fbfc 	bl	1520e <__retarget_lock_release_recursive>
   14a16:	4628      	mov	r0, r5
   14a18:	bd70      	pop	{r4, r5, r6, pc}
   14a1a:	2b00      	cmp	r3, #0
   14a1c:	da04      	bge.n	14a28 <_puts_r+0xac>
   14a1e:	69a2      	ldr	r2, [r4, #24]
   14a20:	429a      	cmp	r2, r3
   14a22:	dc06      	bgt.n	14a32 <_puts_r+0xb6>
   14a24:	290a      	cmp	r1, #10
   14a26:	d004      	beq.n	14a32 <_puts_r+0xb6>
   14a28:	6823      	ldr	r3, [r4, #0]
   14a2a:	1c5a      	adds	r2, r3, #1
   14a2c:	6022      	str	r2, [r4, #0]
   14a2e:	7019      	strb	r1, [r3, #0]
   14a30:	e7c5      	b.n	149be <_puts_r+0x42>
   14a32:	4622      	mov	r2, r4
   14a34:	4628      	mov	r0, r5
   14a36:	f000 f971 	bl	14d1c <__swbuf_r>
   14a3a:	3001      	adds	r0, #1
   14a3c:	d1bf      	bne.n	149be <_puts_r+0x42>
   14a3e:	e7df      	b.n	14a00 <_puts_r+0x84>
   14a40:	6823      	ldr	r3, [r4, #0]
   14a42:	250a      	movs	r5, #10
   14a44:	1c5a      	adds	r2, r3, #1
   14a46:	6022      	str	r2, [r4, #0]
   14a48:	701d      	strb	r5, [r3, #0]
   14a4a:	e7db      	b.n	14a04 <_puts_r+0x88>
   14a4c:	00016edc 	.word	0x00016edc
   14a50:	00016efc 	.word	0x00016efc
   14a54:	00016ebc 	.word	0x00016ebc

00014a58 <puts>:
   14a58:	4b02      	ldr	r3, [pc, #8]	; (14a64 <puts+0xc>)
   14a5a:	4601      	mov	r1, r0
   14a5c:	6818      	ldr	r0, [r3, #0]
   14a5e:	f7ff bf8d 	b.w	1497c <_puts_r>
   14a62:	bf00      	nop
   14a64:	2000054c 	.word	0x2000054c

00014a68 <_sbrk_r>:
   14a68:	b538      	push	{r3, r4, r5, lr}
   14a6a:	4d06      	ldr	r5, [pc, #24]	; (14a84 <_sbrk_r+0x1c>)
   14a6c:	2300      	movs	r3, #0
   14a6e:	4604      	mov	r4, r0
   14a70:	4608      	mov	r0, r1
   14a72:	602b      	str	r3, [r5, #0]
   14a74:	f7f7 fb9a 	bl	c1ac <_sbrk>
   14a78:	1c43      	adds	r3, r0, #1
   14a7a:	d102      	bne.n	14a82 <_sbrk_r+0x1a>
   14a7c:	682b      	ldr	r3, [r5, #0]
   14a7e:	b103      	cbz	r3, 14a82 <_sbrk_r+0x1a>
   14a80:	6023      	str	r3, [r4, #0]
   14a82:	bd38      	pop	{r3, r4, r5, pc}
   14a84:	2001cfe0 	.word	0x2001cfe0

00014a88 <setbuf>:
   14a88:	2900      	cmp	r1, #0
   14a8a:	f44f 6380 	mov.w	r3, #1024	; 0x400
   14a8e:	bf0c      	ite	eq
   14a90:	2202      	moveq	r2, #2
   14a92:	2200      	movne	r2, #0
   14a94:	f000 b800 	b.w	14a98 <setvbuf>

00014a98 <setvbuf>:
   14a98:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   14a9c:	461d      	mov	r5, r3
   14a9e:	4b5d      	ldr	r3, [pc, #372]	; (14c14 <setvbuf+0x17c>)
   14aa0:	681f      	ldr	r7, [r3, #0]
   14aa2:	4604      	mov	r4, r0
   14aa4:	460e      	mov	r6, r1
   14aa6:	4690      	mov	r8, r2
   14aa8:	b127      	cbz	r7, 14ab4 <setvbuf+0x1c>
   14aaa:	69bb      	ldr	r3, [r7, #24]
   14aac:	b913      	cbnz	r3, 14ab4 <setvbuf+0x1c>
   14aae:	4638      	mov	r0, r7
   14ab0:	f000 fb0e 	bl	150d0 <__sinit>
   14ab4:	4b58      	ldr	r3, [pc, #352]	; (14c18 <setvbuf+0x180>)
   14ab6:	429c      	cmp	r4, r3
   14ab8:	d167      	bne.n	14b8a <setvbuf+0xf2>
   14aba:	687c      	ldr	r4, [r7, #4]
   14abc:	f1b8 0f02 	cmp.w	r8, #2
   14ac0:	d006      	beq.n	14ad0 <setvbuf+0x38>
   14ac2:	f1b8 0f01 	cmp.w	r8, #1
   14ac6:	f200 809f 	bhi.w	14c08 <setvbuf+0x170>
   14aca:	2d00      	cmp	r5, #0
   14acc:	f2c0 809c 	blt.w	14c08 <setvbuf+0x170>
   14ad0:	6e63      	ldr	r3, [r4, #100]	; 0x64
   14ad2:	07db      	lsls	r3, r3, #31
   14ad4:	d405      	bmi.n	14ae2 <setvbuf+0x4a>
   14ad6:	89a3      	ldrh	r3, [r4, #12]
   14ad8:	0598      	lsls	r0, r3, #22
   14ada:	d402      	bmi.n	14ae2 <setvbuf+0x4a>
   14adc:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14ade:	f000 fb95 	bl	1520c <__retarget_lock_acquire_recursive>
   14ae2:	4621      	mov	r1, r4
   14ae4:	4638      	mov	r0, r7
   14ae6:	f000 fa5f 	bl	14fa8 <_fflush_r>
   14aea:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14aec:	b141      	cbz	r1, 14b00 <setvbuf+0x68>
   14aee:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14af2:	4299      	cmp	r1, r3
   14af4:	d002      	beq.n	14afc <setvbuf+0x64>
   14af6:	4638      	mov	r0, r7
   14af8:	f7ff fe6c 	bl	147d4 <_free_r>
   14afc:	2300      	movs	r3, #0
   14afe:	6363      	str	r3, [r4, #52]	; 0x34
   14b00:	2300      	movs	r3, #0
   14b02:	61a3      	str	r3, [r4, #24]
   14b04:	6063      	str	r3, [r4, #4]
   14b06:	89a3      	ldrh	r3, [r4, #12]
   14b08:	0619      	lsls	r1, r3, #24
   14b0a:	d503      	bpl.n	14b14 <setvbuf+0x7c>
   14b0c:	6921      	ldr	r1, [r4, #16]
   14b0e:	4638      	mov	r0, r7
   14b10:	f7ff fe60 	bl	147d4 <_free_r>
   14b14:	89a3      	ldrh	r3, [r4, #12]
   14b16:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
   14b1a:	f023 0303 	bic.w	r3, r3, #3
   14b1e:	f1b8 0f02 	cmp.w	r8, #2
   14b22:	81a3      	strh	r3, [r4, #12]
   14b24:	d06c      	beq.n	14c00 <setvbuf+0x168>
   14b26:	ab01      	add	r3, sp, #4
   14b28:	466a      	mov	r2, sp
   14b2a:	4621      	mov	r1, r4
   14b2c:	4638      	mov	r0, r7
   14b2e:	f000 fb6f 	bl	15210 <__swhatbuf_r>
   14b32:	89a3      	ldrh	r3, [r4, #12]
   14b34:	4318      	orrs	r0, r3
   14b36:	81a0      	strh	r0, [r4, #12]
   14b38:	2d00      	cmp	r5, #0
   14b3a:	d130      	bne.n	14b9e <setvbuf+0x106>
   14b3c:	9d00      	ldr	r5, [sp, #0]
   14b3e:	4628      	mov	r0, r5
   14b40:	f7ff fe2a 	bl	14798 <malloc>
   14b44:	4606      	mov	r6, r0
   14b46:	2800      	cmp	r0, #0
   14b48:	d155      	bne.n	14bf6 <setvbuf+0x15e>
   14b4a:	f8dd 9000 	ldr.w	r9, [sp]
   14b4e:	45a9      	cmp	r9, r5
   14b50:	d14a      	bne.n	14be8 <setvbuf+0x150>
   14b52:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   14b56:	2200      	movs	r2, #0
   14b58:	60a2      	str	r2, [r4, #8]
   14b5a:	f104 0247 	add.w	r2, r4, #71	; 0x47
   14b5e:	6022      	str	r2, [r4, #0]
   14b60:	6122      	str	r2, [r4, #16]
   14b62:	2201      	movs	r2, #1
   14b64:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14b68:	6162      	str	r2, [r4, #20]
   14b6a:	6e62      	ldr	r2, [r4, #100]	; 0x64
   14b6c:	f043 0302 	orr.w	r3, r3, #2
   14b70:	07d2      	lsls	r2, r2, #31
   14b72:	81a3      	strh	r3, [r4, #12]
   14b74:	d405      	bmi.n	14b82 <setvbuf+0xea>
   14b76:	f413 7f00 	tst.w	r3, #512	; 0x200
   14b7a:	d102      	bne.n	14b82 <setvbuf+0xea>
   14b7c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14b7e:	f000 fb46 	bl	1520e <__retarget_lock_release_recursive>
   14b82:	4628      	mov	r0, r5
   14b84:	b003      	add	sp, #12
   14b86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   14b8a:	4b24      	ldr	r3, [pc, #144]	; (14c1c <setvbuf+0x184>)
   14b8c:	429c      	cmp	r4, r3
   14b8e:	d101      	bne.n	14b94 <setvbuf+0xfc>
   14b90:	68bc      	ldr	r4, [r7, #8]
   14b92:	e793      	b.n	14abc <setvbuf+0x24>
   14b94:	4b22      	ldr	r3, [pc, #136]	; (14c20 <setvbuf+0x188>)
   14b96:	429c      	cmp	r4, r3
   14b98:	bf08      	it	eq
   14b9a:	68fc      	ldreq	r4, [r7, #12]
   14b9c:	e78e      	b.n	14abc <setvbuf+0x24>
   14b9e:	2e00      	cmp	r6, #0
   14ba0:	d0cd      	beq.n	14b3e <setvbuf+0xa6>
   14ba2:	69bb      	ldr	r3, [r7, #24]
   14ba4:	b913      	cbnz	r3, 14bac <setvbuf+0x114>
   14ba6:	4638      	mov	r0, r7
   14ba8:	f000 fa92 	bl	150d0 <__sinit>
   14bac:	f1b8 0f01 	cmp.w	r8, #1
   14bb0:	bf08      	it	eq
   14bb2:	89a3      	ldrheq	r3, [r4, #12]
   14bb4:	6026      	str	r6, [r4, #0]
   14bb6:	bf04      	itt	eq
   14bb8:	f043 0301 	orreq.w	r3, r3, #1
   14bbc:	81a3      	strheq	r3, [r4, #12]
   14bbe:	89a2      	ldrh	r2, [r4, #12]
   14bc0:	f012 0308 	ands.w	r3, r2, #8
   14bc4:	e9c4 6504 	strd	r6, r5, [r4, #16]
   14bc8:	d01c      	beq.n	14c04 <setvbuf+0x16c>
   14bca:	07d3      	lsls	r3, r2, #31
   14bcc:	bf41      	itttt	mi
   14bce:	2300      	movmi	r3, #0
   14bd0:	426d      	negmi	r5, r5
   14bd2:	60a3      	strmi	r3, [r4, #8]
   14bd4:	61a5      	strmi	r5, [r4, #24]
   14bd6:	bf58      	it	pl
   14bd8:	60a5      	strpl	r5, [r4, #8]
   14bda:	6e65      	ldr	r5, [r4, #100]	; 0x64
   14bdc:	f015 0501 	ands.w	r5, r5, #1
   14be0:	d115      	bne.n	14c0e <setvbuf+0x176>
   14be2:	f412 7f00 	tst.w	r2, #512	; 0x200
   14be6:	e7c8      	b.n	14b7a <setvbuf+0xe2>
   14be8:	4648      	mov	r0, r9
   14bea:	f7ff fdd5 	bl	14798 <malloc>
   14bee:	4606      	mov	r6, r0
   14bf0:	2800      	cmp	r0, #0
   14bf2:	d0ae      	beq.n	14b52 <setvbuf+0xba>
   14bf4:	464d      	mov	r5, r9
   14bf6:	89a3      	ldrh	r3, [r4, #12]
   14bf8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   14bfc:	81a3      	strh	r3, [r4, #12]
   14bfe:	e7d0      	b.n	14ba2 <setvbuf+0x10a>
   14c00:	2500      	movs	r5, #0
   14c02:	e7a8      	b.n	14b56 <setvbuf+0xbe>
   14c04:	60a3      	str	r3, [r4, #8]
   14c06:	e7e8      	b.n	14bda <setvbuf+0x142>
   14c08:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   14c0c:	e7b9      	b.n	14b82 <setvbuf+0xea>
   14c0e:	2500      	movs	r5, #0
   14c10:	e7b7      	b.n	14b82 <setvbuf+0xea>
   14c12:	bf00      	nop
   14c14:	2000054c 	.word	0x2000054c
   14c18:	00016edc 	.word	0x00016edc
   14c1c:	00016efc 	.word	0x00016efc
   14c20:	00016ebc 	.word	0x00016ebc

00014c24 <sniprintf>:
   14c24:	b40c      	push	{r2, r3}
   14c26:	b530      	push	{r4, r5, lr}
   14c28:	4b17      	ldr	r3, [pc, #92]	; (14c88 <sniprintf+0x64>)
   14c2a:	1e0c      	subs	r4, r1, #0
   14c2c:	681d      	ldr	r5, [r3, #0]
   14c2e:	b09d      	sub	sp, #116	; 0x74
   14c30:	da08      	bge.n	14c44 <sniprintf+0x20>
   14c32:	238b      	movs	r3, #139	; 0x8b
   14c34:	602b      	str	r3, [r5, #0]
   14c36:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14c3a:	b01d      	add	sp, #116	; 0x74
   14c3c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   14c40:	b002      	add	sp, #8
   14c42:	4770      	bx	lr
   14c44:	f44f 7302 	mov.w	r3, #520	; 0x208
   14c48:	f8ad 3014 	strh.w	r3, [sp, #20]
   14c4c:	bf14      	ite	ne
   14c4e:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
   14c52:	4623      	moveq	r3, r4
   14c54:	9304      	str	r3, [sp, #16]
   14c56:	9307      	str	r3, [sp, #28]
   14c58:	f64f 73ff 	movw	r3, #65535	; 0xffff
   14c5c:	9002      	str	r0, [sp, #8]
   14c5e:	9006      	str	r0, [sp, #24]
   14c60:	f8ad 3016 	strh.w	r3, [sp, #22]
   14c64:	9a20      	ldr	r2, [sp, #128]	; 0x80
   14c66:	ab21      	add	r3, sp, #132	; 0x84
   14c68:	a902      	add	r1, sp, #8
   14c6a:	4628      	mov	r0, r5
   14c6c:	9301      	str	r3, [sp, #4]
   14c6e:	f000 fb9b 	bl	153a8 <_svfiprintf_r>
   14c72:	1c43      	adds	r3, r0, #1
   14c74:	bfbc      	itt	lt
   14c76:	238b      	movlt	r3, #139	; 0x8b
   14c78:	602b      	strlt	r3, [r5, #0]
   14c7a:	2c00      	cmp	r4, #0
   14c7c:	d0dd      	beq.n	14c3a <sniprintf+0x16>
   14c7e:	9b02      	ldr	r3, [sp, #8]
   14c80:	2200      	movs	r2, #0
   14c82:	701a      	strb	r2, [r3, #0]
   14c84:	e7d9      	b.n	14c3a <sniprintf+0x16>
   14c86:	bf00      	nop
   14c88:	2000054c 	.word	0x2000054c

00014c8c <siprintf>:
   14c8c:	b40e      	push	{r1, r2, r3}
   14c8e:	b500      	push	{lr}
   14c90:	b09c      	sub	sp, #112	; 0x70
   14c92:	ab1d      	add	r3, sp, #116	; 0x74
   14c94:	9002      	str	r0, [sp, #8]
   14c96:	9006      	str	r0, [sp, #24]
   14c98:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   14c9c:	4809      	ldr	r0, [pc, #36]	; (14cc4 <siprintf+0x38>)
   14c9e:	9107      	str	r1, [sp, #28]
   14ca0:	9104      	str	r1, [sp, #16]
   14ca2:	4909      	ldr	r1, [pc, #36]	; (14cc8 <siprintf+0x3c>)
   14ca4:	f853 2b04 	ldr.w	r2, [r3], #4
   14ca8:	9105      	str	r1, [sp, #20]
   14caa:	6800      	ldr	r0, [r0, #0]
   14cac:	9301      	str	r3, [sp, #4]
   14cae:	a902      	add	r1, sp, #8
   14cb0:	f000 fb7a 	bl	153a8 <_svfiprintf_r>
   14cb4:	9b02      	ldr	r3, [sp, #8]
   14cb6:	2200      	movs	r2, #0
   14cb8:	701a      	strb	r2, [r3, #0]
   14cba:	b01c      	add	sp, #112	; 0x70
   14cbc:	f85d eb04 	ldr.w	lr, [sp], #4
   14cc0:	b003      	add	sp, #12
   14cc2:	4770      	bx	lr
   14cc4:	2000054c 	.word	0x2000054c
   14cc8:	ffff0208 	.word	0xffff0208

00014ccc <strchr>:
   14ccc:	b2c9      	uxtb	r1, r1
   14cce:	4603      	mov	r3, r0
   14cd0:	4618      	mov	r0, r3
   14cd2:	f813 2b01 	ldrb.w	r2, [r3], #1
   14cd6:	b112      	cbz	r2, 14cde <strchr+0x12>
   14cd8:	428a      	cmp	r2, r1
   14cda:	d1f9      	bne.n	14cd0 <strchr+0x4>
   14cdc:	4770      	bx	lr
   14cde:	2900      	cmp	r1, #0
   14ce0:	bf18      	it	ne
   14ce2:	2000      	movne	r0, #0
   14ce4:	4770      	bx	lr

00014ce6 <strcmp>:
   14ce6:	f810 2b01 	ldrb.w	r2, [r0], #1
   14cea:	f811 3b01 	ldrb.w	r3, [r1], #1
   14cee:	2a01      	cmp	r2, #1
   14cf0:	bf28      	it	cs
   14cf2:	429a      	cmpcs	r2, r3
   14cf4:	d0f7      	beq.n	14ce6 <strcmp>
   14cf6:	1ad0      	subs	r0, r2, r3
   14cf8:	4770      	bx	lr

00014cfa <strcpy>:
   14cfa:	4603      	mov	r3, r0
   14cfc:	f811 2b01 	ldrb.w	r2, [r1], #1
   14d00:	f803 2b01 	strb.w	r2, [r3], #1
   14d04:	2a00      	cmp	r2, #0
   14d06:	d1f9      	bne.n	14cfc <strcpy+0x2>
   14d08:	4770      	bx	lr

00014d0a <strlen>:
   14d0a:	4603      	mov	r3, r0
   14d0c:	f813 2b01 	ldrb.w	r2, [r3], #1
   14d10:	2a00      	cmp	r2, #0
   14d12:	d1fb      	bne.n	14d0c <strlen+0x2>
   14d14:	1a18      	subs	r0, r3, r0
   14d16:	3801      	subs	r0, #1
   14d18:	4770      	bx	lr
	...

00014d1c <__swbuf_r>:
   14d1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14d1e:	460e      	mov	r6, r1
   14d20:	4614      	mov	r4, r2
   14d22:	4605      	mov	r5, r0
   14d24:	b118      	cbz	r0, 14d2e <__swbuf_r+0x12>
   14d26:	6983      	ldr	r3, [r0, #24]
   14d28:	b90b      	cbnz	r3, 14d2e <__swbuf_r+0x12>
   14d2a:	f000 f9d1 	bl	150d0 <__sinit>
   14d2e:	4b21      	ldr	r3, [pc, #132]	; (14db4 <__swbuf_r+0x98>)
   14d30:	429c      	cmp	r4, r3
   14d32:	d12b      	bne.n	14d8c <__swbuf_r+0x70>
   14d34:	686c      	ldr	r4, [r5, #4]
   14d36:	69a3      	ldr	r3, [r4, #24]
   14d38:	60a3      	str	r3, [r4, #8]
   14d3a:	89a3      	ldrh	r3, [r4, #12]
   14d3c:	071a      	lsls	r2, r3, #28
   14d3e:	d52f      	bpl.n	14da0 <__swbuf_r+0x84>
   14d40:	6923      	ldr	r3, [r4, #16]
   14d42:	b36b      	cbz	r3, 14da0 <__swbuf_r+0x84>
   14d44:	6923      	ldr	r3, [r4, #16]
   14d46:	6820      	ldr	r0, [r4, #0]
   14d48:	1ac0      	subs	r0, r0, r3
   14d4a:	6963      	ldr	r3, [r4, #20]
   14d4c:	b2f6      	uxtb	r6, r6
   14d4e:	4283      	cmp	r3, r0
   14d50:	4637      	mov	r7, r6
   14d52:	dc04      	bgt.n	14d5e <__swbuf_r+0x42>
   14d54:	4621      	mov	r1, r4
   14d56:	4628      	mov	r0, r5
   14d58:	f000 f926 	bl	14fa8 <_fflush_r>
   14d5c:	bb30      	cbnz	r0, 14dac <__swbuf_r+0x90>
   14d5e:	68a3      	ldr	r3, [r4, #8]
   14d60:	3b01      	subs	r3, #1
   14d62:	60a3      	str	r3, [r4, #8]
   14d64:	6823      	ldr	r3, [r4, #0]
   14d66:	1c5a      	adds	r2, r3, #1
   14d68:	6022      	str	r2, [r4, #0]
   14d6a:	701e      	strb	r6, [r3, #0]
   14d6c:	6963      	ldr	r3, [r4, #20]
   14d6e:	3001      	adds	r0, #1
   14d70:	4283      	cmp	r3, r0
   14d72:	d004      	beq.n	14d7e <__swbuf_r+0x62>
   14d74:	89a3      	ldrh	r3, [r4, #12]
   14d76:	07db      	lsls	r3, r3, #31
   14d78:	d506      	bpl.n	14d88 <__swbuf_r+0x6c>
   14d7a:	2e0a      	cmp	r6, #10
   14d7c:	d104      	bne.n	14d88 <__swbuf_r+0x6c>
   14d7e:	4621      	mov	r1, r4
   14d80:	4628      	mov	r0, r5
   14d82:	f000 f911 	bl	14fa8 <_fflush_r>
   14d86:	b988      	cbnz	r0, 14dac <__swbuf_r+0x90>
   14d88:	4638      	mov	r0, r7
   14d8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14d8c:	4b0a      	ldr	r3, [pc, #40]	; (14db8 <__swbuf_r+0x9c>)
   14d8e:	429c      	cmp	r4, r3
   14d90:	d101      	bne.n	14d96 <__swbuf_r+0x7a>
   14d92:	68ac      	ldr	r4, [r5, #8]
   14d94:	e7cf      	b.n	14d36 <__swbuf_r+0x1a>
   14d96:	4b09      	ldr	r3, [pc, #36]	; (14dbc <__swbuf_r+0xa0>)
   14d98:	429c      	cmp	r4, r3
   14d9a:	bf08      	it	eq
   14d9c:	68ec      	ldreq	r4, [r5, #12]
   14d9e:	e7ca      	b.n	14d36 <__swbuf_r+0x1a>
   14da0:	4621      	mov	r1, r4
   14da2:	4628      	mov	r0, r5
   14da4:	f000 f80c 	bl	14dc0 <__swsetup_r>
   14da8:	2800      	cmp	r0, #0
   14daa:	d0cb      	beq.n	14d44 <__swbuf_r+0x28>
   14dac:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   14db0:	e7ea      	b.n	14d88 <__swbuf_r+0x6c>
   14db2:	bf00      	nop
   14db4:	00016edc 	.word	0x00016edc
   14db8:	00016efc 	.word	0x00016efc
   14dbc:	00016ebc 	.word	0x00016ebc

00014dc0 <__swsetup_r>:
   14dc0:	4b32      	ldr	r3, [pc, #200]	; (14e8c <__swsetup_r+0xcc>)
   14dc2:	b570      	push	{r4, r5, r6, lr}
   14dc4:	681d      	ldr	r5, [r3, #0]
   14dc6:	4606      	mov	r6, r0
   14dc8:	460c      	mov	r4, r1
   14dca:	b125      	cbz	r5, 14dd6 <__swsetup_r+0x16>
   14dcc:	69ab      	ldr	r3, [r5, #24]
   14dce:	b913      	cbnz	r3, 14dd6 <__swsetup_r+0x16>
   14dd0:	4628      	mov	r0, r5
   14dd2:	f000 f97d 	bl	150d0 <__sinit>
   14dd6:	4b2e      	ldr	r3, [pc, #184]	; (14e90 <__swsetup_r+0xd0>)
   14dd8:	429c      	cmp	r4, r3
   14dda:	d10f      	bne.n	14dfc <__swsetup_r+0x3c>
   14ddc:	686c      	ldr	r4, [r5, #4]
   14dde:	89a3      	ldrh	r3, [r4, #12]
   14de0:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14de4:	0719      	lsls	r1, r3, #28
   14de6:	d42c      	bmi.n	14e42 <__swsetup_r+0x82>
   14de8:	06dd      	lsls	r5, r3, #27
   14dea:	d411      	bmi.n	14e10 <__swsetup_r+0x50>
   14dec:	2309      	movs	r3, #9
   14dee:	6033      	str	r3, [r6, #0]
   14df0:	f042 0340 	orr.w	r3, r2, #64	; 0x40
   14df4:	81a3      	strh	r3, [r4, #12]
   14df6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14dfa:	e03e      	b.n	14e7a <__swsetup_r+0xba>
   14dfc:	4b25      	ldr	r3, [pc, #148]	; (14e94 <__swsetup_r+0xd4>)
   14dfe:	429c      	cmp	r4, r3
   14e00:	d101      	bne.n	14e06 <__swsetup_r+0x46>
   14e02:	68ac      	ldr	r4, [r5, #8]
   14e04:	e7eb      	b.n	14dde <__swsetup_r+0x1e>
   14e06:	4b24      	ldr	r3, [pc, #144]	; (14e98 <__swsetup_r+0xd8>)
   14e08:	429c      	cmp	r4, r3
   14e0a:	bf08      	it	eq
   14e0c:	68ec      	ldreq	r4, [r5, #12]
   14e0e:	e7e6      	b.n	14dde <__swsetup_r+0x1e>
   14e10:	0758      	lsls	r0, r3, #29
   14e12:	d512      	bpl.n	14e3a <__swsetup_r+0x7a>
   14e14:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14e16:	b141      	cbz	r1, 14e2a <__swsetup_r+0x6a>
   14e18:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14e1c:	4299      	cmp	r1, r3
   14e1e:	d002      	beq.n	14e26 <__swsetup_r+0x66>
   14e20:	4630      	mov	r0, r6
   14e22:	f7ff fcd7 	bl	147d4 <_free_r>
   14e26:	2300      	movs	r3, #0
   14e28:	6363      	str	r3, [r4, #52]	; 0x34
   14e2a:	89a3      	ldrh	r3, [r4, #12]
   14e2c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   14e30:	81a3      	strh	r3, [r4, #12]
   14e32:	2300      	movs	r3, #0
   14e34:	6063      	str	r3, [r4, #4]
   14e36:	6923      	ldr	r3, [r4, #16]
   14e38:	6023      	str	r3, [r4, #0]
   14e3a:	89a3      	ldrh	r3, [r4, #12]
   14e3c:	f043 0308 	orr.w	r3, r3, #8
   14e40:	81a3      	strh	r3, [r4, #12]
   14e42:	6923      	ldr	r3, [r4, #16]
   14e44:	b94b      	cbnz	r3, 14e5a <__swsetup_r+0x9a>
   14e46:	89a3      	ldrh	r3, [r4, #12]
   14e48:	f403 7320 	and.w	r3, r3, #640	; 0x280
   14e4c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   14e50:	d003      	beq.n	14e5a <__swsetup_r+0x9a>
   14e52:	4621      	mov	r1, r4
   14e54:	4630      	mov	r0, r6
   14e56:	f000 f9ff 	bl	15258 <__smakebuf_r>
   14e5a:	89a0      	ldrh	r0, [r4, #12]
   14e5c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   14e60:	f010 0301 	ands.w	r3, r0, #1
   14e64:	d00a      	beq.n	14e7c <__swsetup_r+0xbc>
   14e66:	2300      	movs	r3, #0
   14e68:	60a3      	str	r3, [r4, #8]
   14e6a:	6963      	ldr	r3, [r4, #20]
   14e6c:	425b      	negs	r3, r3
   14e6e:	61a3      	str	r3, [r4, #24]
   14e70:	6923      	ldr	r3, [r4, #16]
   14e72:	b943      	cbnz	r3, 14e86 <__swsetup_r+0xc6>
   14e74:	f010 0080 	ands.w	r0, r0, #128	; 0x80
   14e78:	d1ba      	bne.n	14df0 <__swsetup_r+0x30>
   14e7a:	bd70      	pop	{r4, r5, r6, pc}
   14e7c:	0781      	lsls	r1, r0, #30
   14e7e:	bf58      	it	pl
   14e80:	6963      	ldrpl	r3, [r4, #20]
   14e82:	60a3      	str	r3, [r4, #8]
   14e84:	e7f4      	b.n	14e70 <__swsetup_r+0xb0>
   14e86:	2000      	movs	r0, #0
   14e88:	e7f7      	b.n	14e7a <__swsetup_r+0xba>
   14e8a:	bf00      	nop
   14e8c:	2000054c 	.word	0x2000054c
   14e90:	00016edc 	.word	0x00016edc
   14e94:	00016efc 	.word	0x00016efc
   14e98:	00016ebc 	.word	0x00016ebc

00014e9c <__sflush_r>:
   14e9c:	898a      	ldrh	r2, [r1, #12]
   14e9e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   14ea2:	4605      	mov	r5, r0
   14ea4:	0710      	lsls	r0, r2, #28
   14ea6:	460c      	mov	r4, r1
   14ea8:	d458      	bmi.n	14f5c <__sflush_r+0xc0>
   14eaa:	684b      	ldr	r3, [r1, #4]
   14eac:	2b00      	cmp	r3, #0
   14eae:	dc05      	bgt.n	14ebc <__sflush_r+0x20>
   14eb0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   14eb2:	2b00      	cmp	r3, #0
   14eb4:	dc02      	bgt.n	14ebc <__sflush_r+0x20>
   14eb6:	2000      	movs	r0, #0
   14eb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   14ebc:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   14ebe:	2e00      	cmp	r6, #0
   14ec0:	d0f9      	beq.n	14eb6 <__sflush_r+0x1a>
   14ec2:	2300      	movs	r3, #0
   14ec4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   14ec8:	682f      	ldr	r7, [r5, #0]
   14eca:	602b      	str	r3, [r5, #0]
   14ecc:	d032      	beq.n	14f34 <__sflush_r+0x98>
   14ece:	6d60      	ldr	r0, [r4, #84]	; 0x54
   14ed0:	89a3      	ldrh	r3, [r4, #12]
   14ed2:	075a      	lsls	r2, r3, #29
   14ed4:	d505      	bpl.n	14ee2 <__sflush_r+0x46>
   14ed6:	6863      	ldr	r3, [r4, #4]
   14ed8:	1ac0      	subs	r0, r0, r3
   14eda:	6b63      	ldr	r3, [r4, #52]	; 0x34
   14edc:	b10b      	cbz	r3, 14ee2 <__sflush_r+0x46>
   14ede:	6c23      	ldr	r3, [r4, #64]	; 0x40
   14ee0:	1ac0      	subs	r0, r0, r3
   14ee2:	2300      	movs	r3, #0
   14ee4:	4602      	mov	r2, r0
   14ee6:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   14ee8:	6a21      	ldr	r1, [r4, #32]
   14eea:	4628      	mov	r0, r5
   14eec:	47b0      	blx	r6
   14eee:	1c43      	adds	r3, r0, #1
   14ef0:	89a3      	ldrh	r3, [r4, #12]
   14ef2:	d106      	bne.n	14f02 <__sflush_r+0x66>
   14ef4:	6829      	ldr	r1, [r5, #0]
   14ef6:	291d      	cmp	r1, #29
   14ef8:	d82c      	bhi.n	14f54 <__sflush_r+0xb8>
   14efa:	4a2a      	ldr	r2, [pc, #168]	; (14fa4 <__sflush_r+0x108>)
   14efc:	40ca      	lsrs	r2, r1
   14efe:	07d6      	lsls	r6, r2, #31
   14f00:	d528      	bpl.n	14f54 <__sflush_r+0xb8>
   14f02:	2200      	movs	r2, #0
   14f04:	6062      	str	r2, [r4, #4]
   14f06:	04d9      	lsls	r1, r3, #19
   14f08:	6922      	ldr	r2, [r4, #16]
   14f0a:	6022      	str	r2, [r4, #0]
   14f0c:	d504      	bpl.n	14f18 <__sflush_r+0x7c>
   14f0e:	1c42      	adds	r2, r0, #1
   14f10:	d101      	bne.n	14f16 <__sflush_r+0x7a>
   14f12:	682b      	ldr	r3, [r5, #0]
   14f14:	b903      	cbnz	r3, 14f18 <__sflush_r+0x7c>
   14f16:	6560      	str	r0, [r4, #84]	; 0x54
   14f18:	6b61      	ldr	r1, [r4, #52]	; 0x34
   14f1a:	602f      	str	r7, [r5, #0]
   14f1c:	2900      	cmp	r1, #0
   14f1e:	d0ca      	beq.n	14eb6 <__sflush_r+0x1a>
   14f20:	f104 0344 	add.w	r3, r4, #68	; 0x44
   14f24:	4299      	cmp	r1, r3
   14f26:	d002      	beq.n	14f2e <__sflush_r+0x92>
   14f28:	4628      	mov	r0, r5
   14f2a:	f7ff fc53 	bl	147d4 <_free_r>
   14f2e:	2000      	movs	r0, #0
   14f30:	6360      	str	r0, [r4, #52]	; 0x34
   14f32:	e7c1      	b.n	14eb8 <__sflush_r+0x1c>
   14f34:	6a21      	ldr	r1, [r4, #32]
   14f36:	2301      	movs	r3, #1
   14f38:	4628      	mov	r0, r5
   14f3a:	47b0      	blx	r6
   14f3c:	1c41      	adds	r1, r0, #1
   14f3e:	d1c7      	bne.n	14ed0 <__sflush_r+0x34>
   14f40:	682b      	ldr	r3, [r5, #0]
   14f42:	2b00      	cmp	r3, #0
   14f44:	d0c4      	beq.n	14ed0 <__sflush_r+0x34>
   14f46:	2b1d      	cmp	r3, #29
   14f48:	d001      	beq.n	14f4e <__sflush_r+0xb2>
   14f4a:	2b16      	cmp	r3, #22
   14f4c:	d101      	bne.n	14f52 <__sflush_r+0xb6>
   14f4e:	602f      	str	r7, [r5, #0]
   14f50:	e7b1      	b.n	14eb6 <__sflush_r+0x1a>
   14f52:	89a3      	ldrh	r3, [r4, #12]
   14f54:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14f58:	81a3      	strh	r3, [r4, #12]
   14f5a:	e7ad      	b.n	14eb8 <__sflush_r+0x1c>
   14f5c:	690f      	ldr	r7, [r1, #16]
   14f5e:	2f00      	cmp	r7, #0
   14f60:	d0a9      	beq.n	14eb6 <__sflush_r+0x1a>
   14f62:	0793      	lsls	r3, r2, #30
   14f64:	680e      	ldr	r6, [r1, #0]
   14f66:	bf08      	it	eq
   14f68:	694b      	ldreq	r3, [r1, #20]
   14f6a:	600f      	str	r7, [r1, #0]
   14f6c:	bf18      	it	ne
   14f6e:	2300      	movne	r3, #0
   14f70:	eba6 0807 	sub.w	r8, r6, r7
   14f74:	608b      	str	r3, [r1, #8]
   14f76:	f1b8 0f00 	cmp.w	r8, #0
   14f7a:	dd9c      	ble.n	14eb6 <__sflush_r+0x1a>
   14f7c:	6a21      	ldr	r1, [r4, #32]
   14f7e:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   14f80:	4643      	mov	r3, r8
   14f82:	463a      	mov	r2, r7
   14f84:	4628      	mov	r0, r5
   14f86:	47b0      	blx	r6
   14f88:	2800      	cmp	r0, #0
   14f8a:	dc06      	bgt.n	14f9a <__sflush_r+0xfe>
   14f8c:	89a3      	ldrh	r3, [r4, #12]
   14f8e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   14f92:	81a3      	strh	r3, [r4, #12]
   14f94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14f98:	e78e      	b.n	14eb8 <__sflush_r+0x1c>
   14f9a:	4407      	add	r7, r0
   14f9c:	eba8 0800 	sub.w	r8, r8, r0
   14fa0:	e7e9      	b.n	14f76 <__sflush_r+0xda>
   14fa2:	bf00      	nop
   14fa4:	20400001 	.word	0x20400001

00014fa8 <_fflush_r>:
   14fa8:	b538      	push	{r3, r4, r5, lr}
   14faa:	690b      	ldr	r3, [r1, #16]
   14fac:	4605      	mov	r5, r0
   14fae:	460c      	mov	r4, r1
   14fb0:	b913      	cbnz	r3, 14fb8 <_fflush_r+0x10>
   14fb2:	2500      	movs	r5, #0
   14fb4:	4628      	mov	r0, r5
   14fb6:	bd38      	pop	{r3, r4, r5, pc}
   14fb8:	b118      	cbz	r0, 14fc2 <_fflush_r+0x1a>
   14fba:	6983      	ldr	r3, [r0, #24]
   14fbc:	b90b      	cbnz	r3, 14fc2 <_fflush_r+0x1a>
   14fbe:	f000 f887 	bl	150d0 <__sinit>
   14fc2:	4b14      	ldr	r3, [pc, #80]	; (15014 <_fflush_r+0x6c>)
   14fc4:	429c      	cmp	r4, r3
   14fc6:	d11b      	bne.n	15000 <_fflush_r+0x58>
   14fc8:	686c      	ldr	r4, [r5, #4]
   14fca:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   14fce:	2b00      	cmp	r3, #0
   14fd0:	d0ef      	beq.n	14fb2 <_fflush_r+0xa>
   14fd2:	6e62      	ldr	r2, [r4, #100]	; 0x64
   14fd4:	07d0      	lsls	r0, r2, #31
   14fd6:	d404      	bmi.n	14fe2 <_fflush_r+0x3a>
   14fd8:	0599      	lsls	r1, r3, #22
   14fda:	d402      	bmi.n	14fe2 <_fflush_r+0x3a>
   14fdc:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14fde:	f000 f915 	bl	1520c <__retarget_lock_acquire_recursive>
   14fe2:	4628      	mov	r0, r5
   14fe4:	4621      	mov	r1, r4
   14fe6:	f7ff ff59 	bl	14e9c <__sflush_r>
   14fea:	6e63      	ldr	r3, [r4, #100]	; 0x64
   14fec:	07da      	lsls	r2, r3, #31
   14fee:	4605      	mov	r5, r0
   14ff0:	d4e0      	bmi.n	14fb4 <_fflush_r+0xc>
   14ff2:	89a3      	ldrh	r3, [r4, #12]
   14ff4:	059b      	lsls	r3, r3, #22
   14ff6:	d4dd      	bmi.n	14fb4 <_fflush_r+0xc>
   14ff8:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14ffa:	f000 f908 	bl	1520e <__retarget_lock_release_recursive>
   14ffe:	e7d9      	b.n	14fb4 <_fflush_r+0xc>
   15000:	4b05      	ldr	r3, [pc, #20]	; (15018 <_fflush_r+0x70>)
   15002:	429c      	cmp	r4, r3
   15004:	d101      	bne.n	1500a <_fflush_r+0x62>
   15006:	68ac      	ldr	r4, [r5, #8]
   15008:	e7df      	b.n	14fca <_fflush_r+0x22>
   1500a:	4b04      	ldr	r3, [pc, #16]	; (1501c <_fflush_r+0x74>)
   1500c:	429c      	cmp	r4, r3
   1500e:	bf08      	it	eq
   15010:	68ec      	ldreq	r4, [r5, #12]
   15012:	e7da      	b.n	14fca <_fflush_r+0x22>
   15014:	00016edc 	.word	0x00016edc
   15018:	00016efc 	.word	0x00016efc
   1501c:	00016ebc 	.word	0x00016ebc

00015020 <std>:
   15020:	2300      	movs	r3, #0
   15022:	b510      	push	{r4, lr}
   15024:	4604      	mov	r4, r0
   15026:	e9c0 3300 	strd	r3, r3, [r0]
   1502a:	e9c0 3304 	strd	r3, r3, [r0, #16]
   1502e:	6083      	str	r3, [r0, #8]
   15030:	8181      	strh	r1, [r0, #12]
   15032:	6643      	str	r3, [r0, #100]	; 0x64
   15034:	81c2      	strh	r2, [r0, #14]
   15036:	6183      	str	r3, [r0, #24]
   15038:	4619      	mov	r1, r3
   1503a:	2208      	movs	r2, #8
   1503c:	305c      	adds	r0, #92	; 0x5c
   1503e:	f7ff fbc1 	bl	147c4 <memset>
   15042:	4b05      	ldr	r3, [pc, #20]	; (15058 <std+0x38>)
   15044:	6263      	str	r3, [r4, #36]	; 0x24
   15046:	4b05      	ldr	r3, [pc, #20]	; (1505c <std+0x3c>)
   15048:	62a3      	str	r3, [r4, #40]	; 0x28
   1504a:	4b05      	ldr	r3, [pc, #20]	; (15060 <std+0x40>)
   1504c:	62e3      	str	r3, [r4, #44]	; 0x2c
   1504e:	4b05      	ldr	r3, [pc, #20]	; (15064 <std+0x44>)
   15050:	6224      	str	r4, [r4, #32]
   15052:	6323      	str	r3, [r4, #48]	; 0x30
   15054:	bd10      	pop	{r4, pc}
   15056:	bf00      	nop
   15058:	00015c11 	.word	0x00015c11
   1505c:	00015c33 	.word	0x00015c33
   15060:	00015c6b 	.word	0x00015c6b
   15064:	00015c8f 	.word	0x00015c8f

00015068 <_cleanup_r>:
   15068:	4901      	ldr	r1, [pc, #4]	; (15070 <_cleanup_r+0x8>)
   1506a:	f000 b8af 	b.w	151cc <_fwalk_reent>
   1506e:	bf00      	nop
   15070:	00014fa9 	.word	0x00014fa9

00015074 <__sfmoreglue>:
   15074:	b570      	push	{r4, r5, r6, lr}
   15076:	1e4a      	subs	r2, r1, #1
   15078:	2568      	movs	r5, #104	; 0x68
   1507a:	4355      	muls	r5, r2
   1507c:	460e      	mov	r6, r1
   1507e:	f105 0174 	add.w	r1, r5, #116	; 0x74
   15082:	f7ff fbf5 	bl	14870 <_malloc_r>
   15086:	4604      	mov	r4, r0
   15088:	b140      	cbz	r0, 1509c <__sfmoreglue+0x28>
   1508a:	2100      	movs	r1, #0
   1508c:	e9c0 1600 	strd	r1, r6, [r0]
   15090:	300c      	adds	r0, #12
   15092:	60a0      	str	r0, [r4, #8]
   15094:	f105 0268 	add.w	r2, r5, #104	; 0x68
   15098:	f7ff fb94 	bl	147c4 <memset>
   1509c:	4620      	mov	r0, r4
   1509e:	bd70      	pop	{r4, r5, r6, pc}

000150a0 <__sfp_lock_acquire>:
   150a0:	4801      	ldr	r0, [pc, #4]	; (150a8 <__sfp_lock_acquire+0x8>)
   150a2:	f000 b8b3 	b.w	1520c <__retarget_lock_acquire_recursive>
   150a6:	bf00      	nop
   150a8:	2001cfdc 	.word	0x2001cfdc

000150ac <__sfp_lock_release>:
   150ac:	4801      	ldr	r0, [pc, #4]	; (150b4 <__sfp_lock_release+0x8>)
   150ae:	f000 b8ae 	b.w	1520e <__retarget_lock_release_recursive>
   150b2:	bf00      	nop
   150b4:	2001cfdc 	.word	0x2001cfdc

000150b8 <__sinit_lock_acquire>:
   150b8:	4801      	ldr	r0, [pc, #4]	; (150c0 <__sinit_lock_acquire+0x8>)
   150ba:	f000 b8a7 	b.w	1520c <__retarget_lock_acquire_recursive>
   150be:	bf00      	nop
   150c0:	2001cfd7 	.word	0x2001cfd7

000150c4 <__sinit_lock_release>:
   150c4:	4801      	ldr	r0, [pc, #4]	; (150cc <__sinit_lock_release+0x8>)
   150c6:	f000 b8a2 	b.w	1520e <__retarget_lock_release_recursive>
   150ca:	bf00      	nop
   150cc:	2001cfd7 	.word	0x2001cfd7

000150d0 <__sinit>:
   150d0:	b510      	push	{r4, lr}
   150d2:	4604      	mov	r4, r0
   150d4:	f7ff fff0 	bl	150b8 <__sinit_lock_acquire>
   150d8:	69a3      	ldr	r3, [r4, #24]
   150da:	b11b      	cbz	r3, 150e4 <__sinit+0x14>
   150dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   150e0:	f7ff bff0 	b.w	150c4 <__sinit_lock_release>
   150e4:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   150e8:	6523      	str	r3, [r4, #80]	; 0x50
   150ea:	4b13      	ldr	r3, [pc, #76]	; (15138 <__sinit+0x68>)
   150ec:	4a13      	ldr	r2, [pc, #76]	; (1513c <__sinit+0x6c>)
   150ee:	681b      	ldr	r3, [r3, #0]
   150f0:	62a2      	str	r2, [r4, #40]	; 0x28
   150f2:	42a3      	cmp	r3, r4
   150f4:	bf04      	itt	eq
   150f6:	2301      	moveq	r3, #1
   150f8:	61a3      	streq	r3, [r4, #24]
   150fa:	4620      	mov	r0, r4
   150fc:	f000 f820 	bl	15140 <__sfp>
   15100:	6060      	str	r0, [r4, #4]
   15102:	4620      	mov	r0, r4
   15104:	f000 f81c 	bl	15140 <__sfp>
   15108:	60a0      	str	r0, [r4, #8]
   1510a:	4620      	mov	r0, r4
   1510c:	f000 f818 	bl	15140 <__sfp>
   15110:	2200      	movs	r2, #0
   15112:	60e0      	str	r0, [r4, #12]
   15114:	2104      	movs	r1, #4
   15116:	6860      	ldr	r0, [r4, #4]
   15118:	f7ff ff82 	bl	15020 <std>
   1511c:	68a0      	ldr	r0, [r4, #8]
   1511e:	2201      	movs	r2, #1
   15120:	2109      	movs	r1, #9
   15122:	f7ff ff7d 	bl	15020 <std>
   15126:	68e0      	ldr	r0, [r4, #12]
   15128:	2202      	movs	r2, #2
   1512a:	2112      	movs	r1, #18
   1512c:	f7ff ff78 	bl	15020 <std>
   15130:	2301      	movs	r3, #1
   15132:	61a3      	str	r3, [r4, #24]
   15134:	e7d2      	b.n	150dc <__sinit+0xc>
   15136:	bf00      	nop
   15138:	00016eb8 	.word	0x00016eb8
   1513c:	00015069 	.word	0x00015069

00015140 <__sfp>:
   15140:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15142:	4607      	mov	r7, r0
   15144:	f7ff ffac 	bl	150a0 <__sfp_lock_acquire>
   15148:	4b1e      	ldr	r3, [pc, #120]	; (151c4 <__sfp+0x84>)
   1514a:	681e      	ldr	r6, [r3, #0]
   1514c:	69b3      	ldr	r3, [r6, #24]
   1514e:	b913      	cbnz	r3, 15156 <__sfp+0x16>
   15150:	4630      	mov	r0, r6
   15152:	f7ff ffbd 	bl	150d0 <__sinit>
   15156:	3648      	adds	r6, #72	; 0x48
   15158:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   1515c:	3b01      	subs	r3, #1
   1515e:	d503      	bpl.n	15168 <__sfp+0x28>
   15160:	6833      	ldr	r3, [r6, #0]
   15162:	b30b      	cbz	r3, 151a8 <__sfp+0x68>
   15164:	6836      	ldr	r6, [r6, #0]
   15166:	e7f7      	b.n	15158 <__sfp+0x18>
   15168:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   1516c:	b9d5      	cbnz	r5, 151a4 <__sfp+0x64>
   1516e:	4b16      	ldr	r3, [pc, #88]	; (151c8 <__sfp+0x88>)
   15170:	60e3      	str	r3, [r4, #12]
   15172:	f104 0058 	add.w	r0, r4, #88	; 0x58
   15176:	6665      	str	r5, [r4, #100]	; 0x64
   15178:	f000 f847 	bl	1520a <__retarget_lock_init_recursive>
   1517c:	f7ff ff96 	bl	150ac <__sfp_lock_release>
   15180:	e9c4 5501 	strd	r5, r5, [r4, #4]
   15184:	e9c4 5504 	strd	r5, r5, [r4, #16]
   15188:	6025      	str	r5, [r4, #0]
   1518a:	61a5      	str	r5, [r4, #24]
   1518c:	2208      	movs	r2, #8
   1518e:	4629      	mov	r1, r5
   15190:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   15194:	f7ff fb16 	bl	147c4 <memset>
   15198:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   1519c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   151a0:	4620      	mov	r0, r4
   151a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   151a4:	3468      	adds	r4, #104	; 0x68
   151a6:	e7d9      	b.n	1515c <__sfp+0x1c>
   151a8:	2104      	movs	r1, #4
   151aa:	4638      	mov	r0, r7
   151ac:	f7ff ff62 	bl	15074 <__sfmoreglue>
   151b0:	4604      	mov	r4, r0
   151b2:	6030      	str	r0, [r6, #0]
   151b4:	2800      	cmp	r0, #0
   151b6:	d1d5      	bne.n	15164 <__sfp+0x24>
   151b8:	f7ff ff78 	bl	150ac <__sfp_lock_release>
   151bc:	230c      	movs	r3, #12
   151be:	603b      	str	r3, [r7, #0]
   151c0:	e7ee      	b.n	151a0 <__sfp+0x60>
   151c2:	bf00      	nop
   151c4:	00016eb8 	.word	0x00016eb8
   151c8:	ffff0001 	.word	0xffff0001

000151cc <_fwalk_reent>:
   151cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   151d0:	4606      	mov	r6, r0
   151d2:	4688      	mov	r8, r1
   151d4:	f100 0448 	add.w	r4, r0, #72	; 0x48
   151d8:	2700      	movs	r7, #0
   151da:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
   151de:	f1b9 0901 	subs.w	r9, r9, #1
   151e2:	d505      	bpl.n	151f0 <_fwalk_reent+0x24>
   151e4:	6824      	ldr	r4, [r4, #0]
   151e6:	2c00      	cmp	r4, #0
   151e8:	d1f7      	bne.n	151da <_fwalk_reent+0xe>
   151ea:	4638      	mov	r0, r7
   151ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   151f0:	89ab      	ldrh	r3, [r5, #12]
   151f2:	2b01      	cmp	r3, #1
   151f4:	d907      	bls.n	15206 <_fwalk_reent+0x3a>
   151f6:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   151fa:	3301      	adds	r3, #1
   151fc:	d003      	beq.n	15206 <_fwalk_reent+0x3a>
   151fe:	4629      	mov	r1, r5
   15200:	4630      	mov	r0, r6
   15202:	47c0      	blx	r8
   15204:	4307      	orrs	r7, r0
   15206:	3568      	adds	r5, #104	; 0x68
   15208:	e7e9      	b.n	151de <_fwalk_reent+0x12>

0001520a <__retarget_lock_init_recursive>:
   1520a:	4770      	bx	lr

0001520c <__retarget_lock_acquire_recursive>:
   1520c:	4770      	bx	lr

0001520e <__retarget_lock_release_recursive>:
   1520e:	4770      	bx	lr

00015210 <__swhatbuf_r>:
   15210:	b570      	push	{r4, r5, r6, lr}
   15212:	460e      	mov	r6, r1
   15214:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15218:	2900      	cmp	r1, #0
   1521a:	b096      	sub	sp, #88	; 0x58
   1521c:	4614      	mov	r4, r2
   1521e:	461d      	mov	r5, r3
   15220:	da07      	bge.n	15232 <__swhatbuf_r+0x22>
   15222:	2300      	movs	r3, #0
   15224:	602b      	str	r3, [r5, #0]
   15226:	89b3      	ldrh	r3, [r6, #12]
   15228:	061a      	lsls	r2, r3, #24
   1522a:	d410      	bmi.n	1524e <__swhatbuf_r+0x3e>
   1522c:	f44f 6380 	mov.w	r3, #1024	; 0x400
   15230:	e00e      	b.n	15250 <__swhatbuf_r+0x40>
   15232:	466a      	mov	r2, sp
   15234:	f000 fd52 	bl	15cdc <_fstat_r>
   15238:	2800      	cmp	r0, #0
   1523a:	dbf2      	blt.n	15222 <__swhatbuf_r+0x12>
   1523c:	9a01      	ldr	r2, [sp, #4]
   1523e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   15242:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   15246:	425a      	negs	r2, r3
   15248:	415a      	adcs	r2, r3
   1524a:	602a      	str	r2, [r5, #0]
   1524c:	e7ee      	b.n	1522c <__swhatbuf_r+0x1c>
   1524e:	2340      	movs	r3, #64	; 0x40
   15250:	2000      	movs	r0, #0
   15252:	6023      	str	r3, [r4, #0]
   15254:	b016      	add	sp, #88	; 0x58
   15256:	bd70      	pop	{r4, r5, r6, pc}

00015258 <__smakebuf_r>:
   15258:	898b      	ldrh	r3, [r1, #12]
   1525a:	b573      	push	{r0, r1, r4, r5, r6, lr}
   1525c:	079d      	lsls	r5, r3, #30
   1525e:	4606      	mov	r6, r0
   15260:	460c      	mov	r4, r1
   15262:	d507      	bpl.n	15274 <__smakebuf_r+0x1c>
   15264:	f104 0347 	add.w	r3, r4, #71	; 0x47
   15268:	6023      	str	r3, [r4, #0]
   1526a:	6123      	str	r3, [r4, #16]
   1526c:	2301      	movs	r3, #1
   1526e:	6163      	str	r3, [r4, #20]
   15270:	b002      	add	sp, #8
   15272:	bd70      	pop	{r4, r5, r6, pc}
   15274:	ab01      	add	r3, sp, #4
   15276:	466a      	mov	r2, sp
   15278:	f7ff ffca 	bl	15210 <__swhatbuf_r>
   1527c:	9900      	ldr	r1, [sp, #0]
   1527e:	4605      	mov	r5, r0
   15280:	4630      	mov	r0, r6
   15282:	f7ff faf5 	bl	14870 <_malloc_r>
   15286:	b948      	cbnz	r0, 1529c <__smakebuf_r+0x44>
   15288:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   1528c:	059a      	lsls	r2, r3, #22
   1528e:	d4ef      	bmi.n	15270 <__smakebuf_r+0x18>
   15290:	f023 0303 	bic.w	r3, r3, #3
   15294:	f043 0302 	orr.w	r3, r3, #2
   15298:	81a3      	strh	r3, [r4, #12]
   1529a:	e7e3      	b.n	15264 <__smakebuf_r+0xc>
   1529c:	4b0d      	ldr	r3, [pc, #52]	; (152d4 <__smakebuf_r+0x7c>)
   1529e:	62b3      	str	r3, [r6, #40]	; 0x28
   152a0:	89a3      	ldrh	r3, [r4, #12]
   152a2:	6020      	str	r0, [r4, #0]
   152a4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   152a8:	81a3      	strh	r3, [r4, #12]
   152aa:	9b00      	ldr	r3, [sp, #0]
   152ac:	6163      	str	r3, [r4, #20]
   152ae:	9b01      	ldr	r3, [sp, #4]
   152b0:	6120      	str	r0, [r4, #16]
   152b2:	b15b      	cbz	r3, 152cc <__smakebuf_r+0x74>
   152b4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   152b8:	4630      	mov	r0, r6
   152ba:	f000 fd21 	bl	15d00 <_isatty_r>
   152be:	b128      	cbz	r0, 152cc <__smakebuf_r+0x74>
   152c0:	89a3      	ldrh	r3, [r4, #12]
   152c2:	f023 0303 	bic.w	r3, r3, #3
   152c6:	f043 0301 	orr.w	r3, r3, #1
   152ca:	81a3      	strh	r3, [r4, #12]
   152cc:	89a0      	ldrh	r0, [r4, #12]
   152ce:	4305      	orrs	r5, r0
   152d0:	81a5      	strh	r5, [r4, #12]
   152d2:	e7cd      	b.n	15270 <__smakebuf_r+0x18>
   152d4:	00015069 	.word	0x00015069

000152d8 <__malloc_lock>:
   152d8:	4801      	ldr	r0, [pc, #4]	; (152e0 <__malloc_lock+0x8>)
   152da:	f7ff bf97 	b.w	1520c <__retarget_lock_acquire_recursive>
   152de:	bf00      	nop
   152e0:	2001cfd8 	.word	0x2001cfd8

000152e4 <__malloc_unlock>:
   152e4:	4801      	ldr	r0, [pc, #4]	; (152ec <__malloc_unlock+0x8>)
   152e6:	f7ff bf92 	b.w	1520e <__retarget_lock_release_recursive>
   152ea:	bf00      	nop
   152ec:	2001cfd8 	.word	0x2001cfd8

000152f0 <__ssputs_r>:
   152f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   152f4:	688e      	ldr	r6, [r1, #8]
   152f6:	429e      	cmp	r6, r3
   152f8:	4682      	mov	sl, r0
   152fa:	460c      	mov	r4, r1
   152fc:	4690      	mov	r8, r2
   152fe:	461f      	mov	r7, r3
   15300:	d838      	bhi.n	15374 <__ssputs_r+0x84>
   15302:	898a      	ldrh	r2, [r1, #12]
   15304:	f412 6f90 	tst.w	r2, #1152	; 0x480
   15308:	d032      	beq.n	15370 <__ssputs_r+0x80>
   1530a:	6825      	ldr	r5, [r4, #0]
   1530c:	6909      	ldr	r1, [r1, #16]
   1530e:	eba5 0901 	sub.w	r9, r5, r1
   15312:	6965      	ldr	r5, [r4, #20]
   15314:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   15318:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   1531c:	3301      	adds	r3, #1
   1531e:	444b      	add	r3, r9
   15320:	106d      	asrs	r5, r5, #1
   15322:	429d      	cmp	r5, r3
   15324:	bf38      	it	cc
   15326:	461d      	movcc	r5, r3
   15328:	0553      	lsls	r3, r2, #21
   1532a:	d531      	bpl.n	15390 <__ssputs_r+0xa0>
   1532c:	4629      	mov	r1, r5
   1532e:	f7ff fa9f 	bl	14870 <_malloc_r>
   15332:	4606      	mov	r6, r0
   15334:	b950      	cbnz	r0, 1534c <__ssputs_r+0x5c>
   15336:	230c      	movs	r3, #12
   15338:	f8ca 3000 	str.w	r3, [sl]
   1533c:	89a3      	ldrh	r3, [r4, #12]
   1533e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   15342:	81a3      	strh	r3, [r4, #12]
   15344:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15348:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1534c:	6921      	ldr	r1, [r4, #16]
   1534e:	464a      	mov	r2, r9
   15350:	f7ff fa2a 	bl	147a8 <memcpy>
   15354:	89a3      	ldrh	r3, [r4, #12]
   15356:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   1535a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   1535e:	81a3      	strh	r3, [r4, #12]
   15360:	6126      	str	r6, [r4, #16]
   15362:	6165      	str	r5, [r4, #20]
   15364:	444e      	add	r6, r9
   15366:	eba5 0509 	sub.w	r5, r5, r9
   1536a:	6026      	str	r6, [r4, #0]
   1536c:	60a5      	str	r5, [r4, #8]
   1536e:	463e      	mov	r6, r7
   15370:	42be      	cmp	r6, r7
   15372:	d900      	bls.n	15376 <__ssputs_r+0x86>
   15374:	463e      	mov	r6, r7
   15376:	4632      	mov	r2, r6
   15378:	6820      	ldr	r0, [r4, #0]
   1537a:	4641      	mov	r1, r8
   1537c:	f000 fd38 	bl	15df0 <memmove>
   15380:	68a3      	ldr	r3, [r4, #8]
   15382:	6822      	ldr	r2, [r4, #0]
   15384:	1b9b      	subs	r3, r3, r6
   15386:	4432      	add	r2, r6
   15388:	60a3      	str	r3, [r4, #8]
   1538a:	6022      	str	r2, [r4, #0]
   1538c:	2000      	movs	r0, #0
   1538e:	e7db      	b.n	15348 <__ssputs_r+0x58>
   15390:	462a      	mov	r2, r5
   15392:	f000 fd47 	bl	15e24 <_realloc_r>
   15396:	4606      	mov	r6, r0
   15398:	2800      	cmp	r0, #0
   1539a:	d1e1      	bne.n	15360 <__ssputs_r+0x70>
   1539c:	6921      	ldr	r1, [r4, #16]
   1539e:	4650      	mov	r0, sl
   153a0:	f7ff fa18 	bl	147d4 <_free_r>
   153a4:	e7c7      	b.n	15336 <__ssputs_r+0x46>
	...

000153a8 <_svfiprintf_r>:
   153a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   153ac:	4698      	mov	r8, r3
   153ae:	898b      	ldrh	r3, [r1, #12]
   153b0:	061b      	lsls	r3, r3, #24
   153b2:	b09d      	sub	sp, #116	; 0x74
   153b4:	4607      	mov	r7, r0
   153b6:	460d      	mov	r5, r1
   153b8:	4614      	mov	r4, r2
   153ba:	d50e      	bpl.n	153da <_svfiprintf_r+0x32>
   153bc:	690b      	ldr	r3, [r1, #16]
   153be:	b963      	cbnz	r3, 153da <_svfiprintf_r+0x32>
   153c0:	2140      	movs	r1, #64	; 0x40
   153c2:	f7ff fa55 	bl	14870 <_malloc_r>
   153c6:	6028      	str	r0, [r5, #0]
   153c8:	6128      	str	r0, [r5, #16]
   153ca:	b920      	cbnz	r0, 153d6 <_svfiprintf_r+0x2e>
   153cc:	230c      	movs	r3, #12
   153ce:	603b      	str	r3, [r7, #0]
   153d0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   153d4:	e0d1      	b.n	1557a <_svfiprintf_r+0x1d2>
   153d6:	2340      	movs	r3, #64	; 0x40
   153d8:	616b      	str	r3, [r5, #20]
   153da:	2300      	movs	r3, #0
   153dc:	9309      	str	r3, [sp, #36]	; 0x24
   153de:	2320      	movs	r3, #32
   153e0:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   153e4:	f8cd 800c 	str.w	r8, [sp, #12]
   153e8:	2330      	movs	r3, #48	; 0x30
   153ea:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 15594 <_svfiprintf_r+0x1ec>
   153ee:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   153f2:	f04f 0901 	mov.w	r9, #1
   153f6:	4623      	mov	r3, r4
   153f8:	469a      	mov	sl, r3
   153fa:	f813 2b01 	ldrb.w	r2, [r3], #1
   153fe:	b10a      	cbz	r2, 15404 <_svfiprintf_r+0x5c>
   15400:	2a25      	cmp	r2, #37	; 0x25
   15402:	d1f9      	bne.n	153f8 <_svfiprintf_r+0x50>
   15404:	ebba 0b04 	subs.w	fp, sl, r4
   15408:	d00b      	beq.n	15422 <_svfiprintf_r+0x7a>
   1540a:	465b      	mov	r3, fp
   1540c:	4622      	mov	r2, r4
   1540e:	4629      	mov	r1, r5
   15410:	4638      	mov	r0, r7
   15412:	f7ff ff6d 	bl	152f0 <__ssputs_r>
   15416:	3001      	adds	r0, #1
   15418:	f000 80aa 	beq.w	15570 <_svfiprintf_r+0x1c8>
   1541c:	9a09      	ldr	r2, [sp, #36]	; 0x24
   1541e:	445a      	add	r2, fp
   15420:	9209      	str	r2, [sp, #36]	; 0x24
   15422:	f89a 3000 	ldrb.w	r3, [sl]
   15426:	2b00      	cmp	r3, #0
   15428:	f000 80a2 	beq.w	15570 <_svfiprintf_r+0x1c8>
   1542c:	2300      	movs	r3, #0
   1542e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15432:	e9cd 2305 	strd	r2, r3, [sp, #20]
   15436:	f10a 0a01 	add.w	sl, sl, #1
   1543a:	9304      	str	r3, [sp, #16]
   1543c:	9307      	str	r3, [sp, #28]
   1543e:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   15442:	931a      	str	r3, [sp, #104]	; 0x68
   15444:	4654      	mov	r4, sl
   15446:	2205      	movs	r2, #5
   15448:	f814 1b01 	ldrb.w	r1, [r4], #1
   1544c:	4851      	ldr	r0, [pc, #324]	; (15594 <_svfiprintf_r+0x1ec>)
   1544e:	f000 fc7f 	bl	15d50 <memchr>
   15452:	9a04      	ldr	r2, [sp, #16]
   15454:	b9d8      	cbnz	r0, 1548e <_svfiprintf_r+0xe6>
   15456:	06d0      	lsls	r0, r2, #27
   15458:	bf44      	itt	mi
   1545a:	2320      	movmi	r3, #32
   1545c:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15460:	0711      	lsls	r1, r2, #28
   15462:	bf44      	itt	mi
   15464:	232b      	movmi	r3, #43	; 0x2b
   15466:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   1546a:	f89a 3000 	ldrb.w	r3, [sl]
   1546e:	2b2a      	cmp	r3, #42	; 0x2a
   15470:	d015      	beq.n	1549e <_svfiprintf_r+0xf6>
   15472:	9a07      	ldr	r2, [sp, #28]
   15474:	4654      	mov	r4, sl
   15476:	2000      	movs	r0, #0
   15478:	f04f 0c0a 	mov.w	ip, #10
   1547c:	4621      	mov	r1, r4
   1547e:	f811 3b01 	ldrb.w	r3, [r1], #1
   15482:	3b30      	subs	r3, #48	; 0x30
   15484:	2b09      	cmp	r3, #9
   15486:	d94e      	bls.n	15526 <_svfiprintf_r+0x17e>
   15488:	b1b0      	cbz	r0, 154b8 <_svfiprintf_r+0x110>
   1548a:	9207      	str	r2, [sp, #28]
   1548c:	e014      	b.n	154b8 <_svfiprintf_r+0x110>
   1548e:	eba0 0308 	sub.w	r3, r0, r8
   15492:	fa09 f303 	lsl.w	r3, r9, r3
   15496:	4313      	orrs	r3, r2
   15498:	9304      	str	r3, [sp, #16]
   1549a:	46a2      	mov	sl, r4
   1549c:	e7d2      	b.n	15444 <_svfiprintf_r+0x9c>
   1549e:	9b03      	ldr	r3, [sp, #12]
   154a0:	1d19      	adds	r1, r3, #4
   154a2:	681b      	ldr	r3, [r3, #0]
   154a4:	9103      	str	r1, [sp, #12]
   154a6:	2b00      	cmp	r3, #0
   154a8:	bfbb      	ittet	lt
   154aa:	425b      	neglt	r3, r3
   154ac:	f042 0202 	orrlt.w	r2, r2, #2
   154b0:	9307      	strge	r3, [sp, #28]
   154b2:	9307      	strlt	r3, [sp, #28]
   154b4:	bfb8      	it	lt
   154b6:	9204      	strlt	r2, [sp, #16]
   154b8:	7823      	ldrb	r3, [r4, #0]
   154ba:	2b2e      	cmp	r3, #46	; 0x2e
   154bc:	d10c      	bne.n	154d8 <_svfiprintf_r+0x130>
   154be:	7863      	ldrb	r3, [r4, #1]
   154c0:	2b2a      	cmp	r3, #42	; 0x2a
   154c2:	d135      	bne.n	15530 <_svfiprintf_r+0x188>
   154c4:	9b03      	ldr	r3, [sp, #12]
   154c6:	1d1a      	adds	r2, r3, #4
   154c8:	681b      	ldr	r3, [r3, #0]
   154ca:	9203      	str	r2, [sp, #12]
   154cc:	2b00      	cmp	r3, #0
   154ce:	bfb8      	it	lt
   154d0:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   154d4:	3402      	adds	r4, #2
   154d6:	9305      	str	r3, [sp, #20]
   154d8:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 155a4 <_svfiprintf_r+0x1fc>
   154dc:	7821      	ldrb	r1, [r4, #0]
   154de:	2203      	movs	r2, #3
   154e0:	4650      	mov	r0, sl
   154e2:	f000 fc35 	bl	15d50 <memchr>
   154e6:	b140      	cbz	r0, 154fa <_svfiprintf_r+0x152>
   154e8:	2340      	movs	r3, #64	; 0x40
   154ea:	eba0 000a 	sub.w	r0, r0, sl
   154ee:	fa03 f000 	lsl.w	r0, r3, r0
   154f2:	9b04      	ldr	r3, [sp, #16]
   154f4:	4303      	orrs	r3, r0
   154f6:	3401      	adds	r4, #1
   154f8:	9304      	str	r3, [sp, #16]
   154fa:	f814 1b01 	ldrb.w	r1, [r4], #1
   154fe:	4826      	ldr	r0, [pc, #152]	; (15598 <_svfiprintf_r+0x1f0>)
   15500:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   15504:	2206      	movs	r2, #6
   15506:	f000 fc23 	bl	15d50 <memchr>
   1550a:	2800      	cmp	r0, #0
   1550c:	d038      	beq.n	15580 <_svfiprintf_r+0x1d8>
   1550e:	4b23      	ldr	r3, [pc, #140]	; (1559c <_svfiprintf_r+0x1f4>)
   15510:	bb1b      	cbnz	r3, 1555a <_svfiprintf_r+0x1b2>
   15512:	9b03      	ldr	r3, [sp, #12]
   15514:	3307      	adds	r3, #7
   15516:	f023 0307 	bic.w	r3, r3, #7
   1551a:	3308      	adds	r3, #8
   1551c:	9303      	str	r3, [sp, #12]
   1551e:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15520:	4433      	add	r3, r6
   15522:	9309      	str	r3, [sp, #36]	; 0x24
   15524:	e767      	b.n	153f6 <_svfiprintf_r+0x4e>
   15526:	fb0c 3202 	mla	r2, ip, r2, r3
   1552a:	460c      	mov	r4, r1
   1552c:	2001      	movs	r0, #1
   1552e:	e7a5      	b.n	1547c <_svfiprintf_r+0xd4>
   15530:	2300      	movs	r3, #0
   15532:	3401      	adds	r4, #1
   15534:	9305      	str	r3, [sp, #20]
   15536:	4619      	mov	r1, r3
   15538:	f04f 0c0a 	mov.w	ip, #10
   1553c:	4620      	mov	r0, r4
   1553e:	f810 2b01 	ldrb.w	r2, [r0], #1
   15542:	3a30      	subs	r2, #48	; 0x30
   15544:	2a09      	cmp	r2, #9
   15546:	d903      	bls.n	15550 <_svfiprintf_r+0x1a8>
   15548:	2b00      	cmp	r3, #0
   1554a:	d0c5      	beq.n	154d8 <_svfiprintf_r+0x130>
   1554c:	9105      	str	r1, [sp, #20]
   1554e:	e7c3      	b.n	154d8 <_svfiprintf_r+0x130>
   15550:	fb0c 2101 	mla	r1, ip, r1, r2
   15554:	4604      	mov	r4, r0
   15556:	2301      	movs	r3, #1
   15558:	e7f0      	b.n	1553c <_svfiprintf_r+0x194>
   1555a:	ab03      	add	r3, sp, #12
   1555c:	9300      	str	r3, [sp, #0]
   1555e:	462a      	mov	r2, r5
   15560:	4b0f      	ldr	r3, [pc, #60]	; (155a0 <_svfiprintf_r+0x1f8>)
   15562:	a904      	add	r1, sp, #16
   15564:	4638      	mov	r0, r7
   15566:	f3af 8000 	nop.w
   1556a:	1c42      	adds	r2, r0, #1
   1556c:	4606      	mov	r6, r0
   1556e:	d1d6      	bne.n	1551e <_svfiprintf_r+0x176>
   15570:	89ab      	ldrh	r3, [r5, #12]
   15572:	065b      	lsls	r3, r3, #25
   15574:	f53f af2c 	bmi.w	153d0 <_svfiprintf_r+0x28>
   15578:	9809      	ldr	r0, [sp, #36]	; 0x24
   1557a:	b01d      	add	sp, #116	; 0x74
   1557c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15580:	ab03      	add	r3, sp, #12
   15582:	9300      	str	r3, [sp, #0]
   15584:	462a      	mov	r2, r5
   15586:	4b06      	ldr	r3, [pc, #24]	; (155a0 <_svfiprintf_r+0x1f8>)
   15588:	a904      	add	r1, sp, #16
   1558a:	4638      	mov	r0, r7
   1558c:	f000 f9d2 	bl	15934 <_printf_i>
   15590:	e7eb      	b.n	1556a <_svfiprintf_r+0x1c2>
   15592:	bf00      	nop
   15594:	00016f1c 	.word	0x00016f1c
   15598:	00016f26 	.word	0x00016f26
   1559c:	00000000 	.word	0x00000000
   155a0:	000152f1 	.word	0x000152f1
   155a4:	00016f22 	.word	0x00016f22

000155a8 <__sfputc_r>:
   155a8:	6893      	ldr	r3, [r2, #8]
   155aa:	3b01      	subs	r3, #1
   155ac:	2b00      	cmp	r3, #0
   155ae:	b410      	push	{r4}
   155b0:	6093      	str	r3, [r2, #8]
   155b2:	da07      	bge.n	155c4 <__sfputc_r+0x1c>
   155b4:	6994      	ldr	r4, [r2, #24]
   155b6:	42a3      	cmp	r3, r4
   155b8:	db01      	blt.n	155be <__sfputc_r+0x16>
   155ba:	290a      	cmp	r1, #10
   155bc:	d102      	bne.n	155c4 <__sfputc_r+0x1c>
   155be:	bc10      	pop	{r4}
   155c0:	f7ff bbac 	b.w	14d1c <__swbuf_r>
   155c4:	6813      	ldr	r3, [r2, #0]
   155c6:	1c58      	adds	r0, r3, #1
   155c8:	6010      	str	r0, [r2, #0]
   155ca:	7019      	strb	r1, [r3, #0]
   155cc:	4608      	mov	r0, r1
   155ce:	bc10      	pop	{r4}
   155d0:	4770      	bx	lr

000155d2 <__sfputs_r>:
   155d2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   155d4:	4606      	mov	r6, r0
   155d6:	460f      	mov	r7, r1
   155d8:	4614      	mov	r4, r2
   155da:	18d5      	adds	r5, r2, r3
   155dc:	42ac      	cmp	r4, r5
   155de:	d101      	bne.n	155e4 <__sfputs_r+0x12>
   155e0:	2000      	movs	r0, #0
   155e2:	e007      	b.n	155f4 <__sfputs_r+0x22>
   155e4:	f814 1b01 	ldrb.w	r1, [r4], #1
   155e8:	463a      	mov	r2, r7
   155ea:	4630      	mov	r0, r6
   155ec:	f7ff ffdc 	bl	155a8 <__sfputc_r>
   155f0:	1c43      	adds	r3, r0, #1
   155f2:	d1f3      	bne.n	155dc <__sfputs_r+0xa>
   155f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

000155f8 <_vfiprintf_r>:
   155f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   155fc:	460d      	mov	r5, r1
   155fe:	b09d      	sub	sp, #116	; 0x74
   15600:	4614      	mov	r4, r2
   15602:	4698      	mov	r8, r3
   15604:	4606      	mov	r6, r0
   15606:	b118      	cbz	r0, 15610 <_vfiprintf_r+0x18>
   15608:	6983      	ldr	r3, [r0, #24]
   1560a:	b90b      	cbnz	r3, 15610 <_vfiprintf_r+0x18>
   1560c:	f7ff fd60 	bl	150d0 <__sinit>
   15610:	4b89      	ldr	r3, [pc, #548]	; (15838 <_vfiprintf_r+0x240>)
   15612:	429d      	cmp	r5, r3
   15614:	d11b      	bne.n	1564e <_vfiprintf_r+0x56>
   15616:	6875      	ldr	r5, [r6, #4]
   15618:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   1561a:	07d9      	lsls	r1, r3, #31
   1561c:	d405      	bmi.n	1562a <_vfiprintf_r+0x32>
   1561e:	89ab      	ldrh	r3, [r5, #12]
   15620:	059a      	lsls	r2, r3, #22
   15622:	d402      	bmi.n	1562a <_vfiprintf_r+0x32>
   15624:	6da8      	ldr	r0, [r5, #88]	; 0x58
   15626:	f7ff fdf1 	bl	1520c <__retarget_lock_acquire_recursive>
   1562a:	89ab      	ldrh	r3, [r5, #12]
   1562c:	071b      	lsls	r3, r3, #28
   1562e:	d501      	bpl.n	15634 <_vfiprintf_r+0x3c>
   15630:	692b      	ldr	r3, [r5, #16]
   15632:	b9eb      	cbnz	r3, 15670 <_vfiprintf_r+0x78>
   15634:	4629      	mov	r1, r5
   15636:	4630      	mov	r0, r6
   15638:	f7ff fbc2 	bl	14dc0 <__swsetup_r>
   1563c:	b1c0      	cbz	r0, 15670 <_vfiprintf_r+0x78>
   1563e:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   15640:	07dc      	lsls	r4, r3, #31
   15642:	d50e      	bpl.n	15662 <_vfiprintf_r+0x6a>
   15644:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15648:	b01d      	add	sp, #116	; 0x74
   1564a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1564e:	4b7b      	ldr	r3, [pc, #492]	; (1583c <_vfiprintf_r+0x244>)
   15650:	429d      	cmp	r5, r3
   15652:	d101      	bne.n	15658 <_vfiprintf_r+0x60>
   15654:	68b5      	ldr	r5, [r6, #8]
   15656:	e7df      	b.n	15618 <_vfiprintf_r+0x20>
   15658:	4b79      	ldr	r3, [pc, #484]	; (15840 <_vfiprintf_r+0x248>)
   1565a:	429d      	cmp	r5, r3
   1565c:	bf08      	it	eq
   1565e:	68f5      	ldreq	r5, [r6, #12]
   15660:	e7da      	b.n	15618 <_vfiprintf_r+0x20>
   15662:	89ab      	ldrh	r3, [r5, #12]
   15664:	0598      	lsls	r0, r3, #22
   15666:	d4ed      	bmi.n	15644 <_vfiprintf_r+0x4c>
   15668:	6da8      	ldr	r0, [r5, #88]	; 0x58
   1566a:	f7ff fdd0 	bl	1520e <__retarget_lock_release_recursive>
   1566e:	e7e9      	b.n	15644 <_vfiprintf_r+0x4c>
   15670:	2300      	movs	r3, #0
   15672:	9309      	str	r3, [sp, #36]	; 0x24
   15674:	2320      	movs	r3, #32
   15676:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   1567a:	f8cd 800c 	str.w	r8, [sp, #12]
   1567e:	2330      	movs	r3, #48	; 0x30
   15680:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 15844 <_vfiprintf_r+0x24c>
   15684:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   15688:	f04f 0901 	mov.w	r9, #1
   1568c:	4623      	mov	r3, r4
   1568e:	469a      	mov	sl, r3
   15690:	f813 2b01 	ldrb.w	r2, [r3], #1
   15694:	b10a      	cbz	r2, 1569a <_vfiprintf_r+0xa2>
   15696:	2a25      	cmp	r2, #37	; 0x25
   15698:	d1f9      	bne.n	1568e <_vfiprintf_r+0x96>
   1569a:	ebba 0b04 	subs.w	fp, sl, r4
   1569e:	d00b      	beq.n	156b8 <_vfiprintf_r+0xc0>
   156a0:	465b      	mov	r3, fp
   156a2:	4622      	mov	r2, r4
   156a4:	4629      	mov	r1, r5
   156a6:	4630      	mov	r0, r6
   156a8:	f7ff ff93 	bl	155d2 <__sfputs_r>
   156ac:	3001      	adds	r0, #1
   156ae:	f000 80aa 	beq.w	15806 <_vfiprintf_r+0x20e>
   156b2:	9a09      	ldr	r2, [sp, #36]	; 0x24
   156b4:	445a      	add	r2, fp
   156b6:	9209      	str	r2, [sp, #36]	; 0x24
   156b8:	f89a 3000 	ldrb.w	r3, [sl]
   156bc:	2b00      	cmp	r3, #0
   156be:	f000 80a2 	beq.w	15806 <_vfiprintf_r+0x20e>
   156c2:	2300      	movs	r3, #0
   156c4:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   156c8:	e9cd 2305 	strd	r2, r3, [sp, #20]
   156cc:	f10a 0a01 	add.w	sl, sl, #1
   156d0:	9304      	str	r3, [sp, #16]
   156d2:	9307      	str	r3, [sp, #28]
   156d4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   156d8:	931a      	str	r3, [sp, #104]	; 0x68
   156da:	4654      	mov	r4, sl
   156dc:	2205      	movs	r2, #5
   156de:	f814 1b01 	ldrb.w	r1, [r4], #1
   156e2:	4858      	ldr	r0, [pc, #352]	; (15844 <_vfiprintf_r+0x24c>)
   156e4:	f000 fb34 	bl	15d50 <memchr>
   156e8:	9a04      	ldr	r2, [sp, #16]
   156ea:	b9d8      	cbnz	r0, 15724 <_vfiprintf_r+0x12c>
   156ec:	06d1      	lsls	r1, r2, #27
   156ee:	bf44      	itt	mi
   156f0:	2320      	movmi	r3, #32
   156f2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   156f6:	0713      	lsls	r3, r2, #28
   156f8:	bf44      	itt	mi
   156fa:	232b      	movmi	r3, #43	; 0x2b
   156fc:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15700:	f89a 3000 	ldrb.w	r3, [sl]
   15704:	2b2a      	cmp	r3, #42	; 0x2a
   15706:	d015      	beq.n	15734 <_vfiprintf_r+0x13c>
   15708:	9a07      	ldr	r2, [sp, #28]
   1570a:	4654      	mov	r4, sl
   1570c:	2000      	movs	r0, #0
   1570e:	f04f 0c0a 	mov.w	ip, #10
   15712:	4621      	mov	r1, r4
   15714:	f811 3b01 	ldrb.w	r3, [r1], #1
   15718:	3b30      	subs	r3, #48	; 0x30
   1571a:	2b09      	cmp	r3, #9
   1571c:	d94e      	bls.n	157bc <_vfiprintf_r+0x1c4>
   1571e:	b1b0      	cbz	r0, 1574e <_vfiprintf_r+0x156>
   15720:	9207      	str	r2, [sp, #28]
   15722:	e014      	b.n	1574e <_vfiprintf_r+0x156>
   15724:	eba0 0308 	sub.w	r3, r0, r8
   15728:	fa09 f303 	lsl.w	r3, r9, r3
   1572c:	4313      	orrs	r3, r2
   1572e:	9304      	str	r3, [sp, #16]
   15730:	46a2      	mov	sl, r4
   15732:	e7d2      	b.n	156da <_vfiprintf_r+0xe2>
   15734:	9b03      	ldr	r3, [sp, #12]
   15736:	1d19      	adds	r1, r3, #4
   15738:	681b      	ldr	r3, [r3, #0]
   1573a:	9103      	str	r1, [sp, #12]
   1573c:	2b00      	cmp	r3, #0
   1573e:	bfbb      	ittet	lt
   15740:	425b      	neglt	r3, r3
   15742:	f042 0202 	orrlt.w	r2, r2, #2
   15746:	9307      	strge	r3, [sp, #28]
   15748:	9307      	strlt	r3, [sp, #28]
   1574a:	bfb8      	it	lt
   1574c:	9204      	strlt	r2, [sp, #16]
   1574e:	7823      	ldrb	r3, [r4, #0]
   15750:	2b2e      	cmp	r3, #46	; 0x2e
   15752:	d10c      	bne.n	1576e <_vfiprintf_r+0x176>
   15754:	7863      	ldrb	r3, [r4, #1]
   15756:	2b2a      	cmp	r3, #42	; 0x2a
   15758:	d135      	bne.n	157c6 <_vfiprintf_r+0x1ce>
   1575a:	9b03      	ldr	r3, [sp, #12]
   1575c:	1d1a      	adds	r2, r3, #4
   1575e:	681b      	ldr	r3, [r3, #0]
   15760:	9203      	str	r2, [sp, #12]
   15762:	2b00      	cmp	r3, #0
   15764:	bfb8      	it	lt
   15766:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   1576a:	3402      	adds	r4, #2
   1576c:	9305      	str	r3, [sp, #20]
   1576e:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 15854 <_vfiprintf_r+0x25c>
   15772:	7821      	ldrb	r1, [r4, #0]
   15774:	2203      	movs	r2, #3
   15776:	4650      	mov	r0, sl
   15778:	f000 faea 	bl	15d50 <memchr>
   1577c:	b140      	cbz	r0, 15790 <_vfiprintf_r+0x198>
   1577e:	2340      	movs	r3, #64	; 0x40
   15780:	eba0 000a 	sub.w	r0, r0, sl
   15784:	fa03 f000 	lsl.w	r0, r3, r0
   15788:	9b04      	ldr	r3, [sp, #16]
   1578a:	4303      	orrs	r3, r0
   1578c:	3401      	adds	r4, #1
   1578e:	9304      	str	r3, [sp, #16]
   15790:	f814 1b01 	ldrb.w	r1, [r4], #1
   15794:	482c      	ldr	r0, [pc, #176]	; (15848 <_vfiprintf_r+0x250>)
   15796:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   1579a:	2206      	movs	r2, #6
   1579c:	f000 fad8 	bl	15d50 <memchr>
   157a0:	2800      	cmp	r0, #0
   157a2:	d03f      	beq.n	15824 <_vfiprintf_r+0x22c>
   157a4:	4b29      	ldr	r3, [pc, #164]	; (1584c <_vfiprintf_r+0x254>)
   157a6:	bb1b      	cbnz	r3, 157f0 <_vfiprintf_r+0x1f8>
   157a8:	9b03      	ldr	r3, [sp, #12]
   157aa:	3307      	adds	r3, #7
   157ac:	f023 0307 	bic.w	r3, r3, #7
   157b0:	3308      	adds	r3, #8
   157b2:	9303      	str	r3, [sp, #12]
   157b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
   157b6:	443b      	add	r3, r7
   157b8:	9309      	str	r3, [sp, #36]	; 0x24
   157ba:	e767      	b.n	1568c <_vfiprintf_r+0x94>
   157bc:	fb0c 3202 	mla	r2, ip, r2, r3
   157c0:	460c      	mov	r4, r1
   157c2:	2001      	movs	r0, #1
   157c4:	e7a5      	b.n	15712 <_vfiprintf_r+0x11a>
   157c6:	2300      	movs	r3, #0
   157c8:	3401      	adds	r4, #1
   157ca:	9305      	str	r3, [sp, #20]
   157cc:	4619      	mov	r1, r3
   157ce:	f04f 0c0a 	mov.w	ip, #10
   157d2:	4620      	mov	r0, r4
   157d4:	f810 2b01 	ldrb.w	r2, [r0], #1
   157d8:	3a30      	subs	r2, #48	; 0x30
   157da:	2a09      	cmp	r2, #9
   157dc:	d903      	bls.n	157e6 <_vfiprintf_r+0x1ee>
   157de:	2b00      	cmp	r3, #0
   157e0:	d0c5      	beq.n	1576e <_vfiprintf_r+0x176>
   157e2:	9105      	str	r1, [sp, #20]
   157e4:	e7c3      	b.n	1576e <_vfiprintf_r+0x176>
   157e6:	fb0c 2101 	mla	r1, ip, r1, r2
   157ea:	4604      	mov	r4, r0
   157ec:	2301      	movs	r3, #1
   157ee:	e7f0      	b.n	157d2 <_vfiprintf_r+0x1da>
   157f0:	ab03      	add	r3, sp, #12
   157f2:	9300      	str	r3, [sp, #0]
   157f4:	462a      	mov	r2, r5
   157f6:	4b16      	ldr	r3, [pc, #88]	; (15850 <_vfiprintf_r+0x258>)
   157f8:	a904      	add	r1, sp, #16
   157fa:	4630      	mov	r0, r6
   157fc:	f3af 8000 	nop.w
   15800:	4607      	mov	r7, r0
   15802:	1c78      	adds	r0, r7, #1
   15804:	d1d6      	bne.n	157b4 <_vfiprintf_r+0x1bc>
   15806:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   15808:	07d9      	lsls	r1, r3, #31
   1580a:	d405      	bmi.n	15818 <_vfiprintf_r+0x220>
   1580c:	89ab      	ldrh	r3, [r5, #12]
   1580e:	059a      	lsls	r2, r3, #22
   15810:	d402      	bmi.n	15818 <_vfiprintf_r+0x220>
   15812:	6da8      	ldr	r0, [r5, #88]	; 0x58
   15814:	f7ff fcfb 	bl	1520e <__retarget_lock_release_recursive>
   15818:	89ab      	ldrh	r3, [r5, #12]
   1581a:	065b      	lsls	r3, r3, #25
   1581c:	f53f af12 	bmi.w	15644 <_vfiprintf_r+0x4c>
   15820:	9809      	ldr	r0, [sp, #36]	; 0x24
   15822:	e711      	b.n	15648 <_vfiprintf_r+0x50>
   15824:	ab03      	add	r3, sp, #12
   15826:	9300      	str	r3, [sp, #0]
   15828:	462a      	mov	r2, r5
   1582a:	4b09      	ldr	r3, [pc, #36]	; (15850 <_vfiprintf_r+0x258>)
   1582c:	a904      	add	r1, sp, #16
   1582e:	4630      	mov	r0, r6
   15830:	f000 f880 	bl	15934 <_printf_i>
   15834:	e7e4      	b.n	15800 <_vfiprintf_r+0x208>
   15836:	bf00      	nop
   15838:	00016edc 	.word	0x00016edc
   1583c:	00016efc 	.word	0x00016efc
   15840:	00016ebc 	.word	0x00016ebc
   15844:	00016f1c 	.word	0x00016f1c
   15848:	00016f26 	.word	0x00016f26
   1584c:	00000000 	.word	0x00000000
   15850:	000155d3 	.word	0x000155d3
   15854:	00016f22 	.word	0x00016f22

00015858 <_printf_common>:
   15858:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   1585c:	4616      	mov	r6, r2
   1585e:	4699      	mov	r9, r3
   15860:	688a      	ldr	r2, [r1, #8]
   15862:	690b      	ldr	r3, [r1, #16]
   15864:	f8dd 8020 	ldr.w	r8, [sp, #32]
   15868:	4293      	cmp	r3, r2
   1586a:	bfb8      	it	lt
   1586c:	4613      	movlt	r3, r2
   1586e:	6033      	str	r3, [r6, #0]
   15870:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   15874:	4607      	mov	r7, r0
   15876:	460c      	mov	r4, r1
   15878:	b10a      	cbz	r2, 1587e <_printf_common+0x26>
   1587a:	3301      	adds	r3, #1
   1587c:	6033      	str	r3, [r6, #0]
   1587e:	6823      	ldr	r3, [r4, #0]
   15880:	0699      	lsls	r1, r3, #26
   15882:	bf42      	ittt	mi
   15884:	6833      	ldrmi	r3, [r6, #0]
   15886:	3302      	addmi	r3, #2
   15888:	6033      	strmi	r3, [r6, #0]
   1588a:	6825      	ldr	r5, [r4, #0]
   1588c:	f015 0506 	ands.w	r5, r5, #6
   15890:	d106      	bne.n	158a0 <_printf_common+0x48>
   15892:	f104 0a19 	add.w	sl, r4, #25
   15896:	68e3      	ldr	r3, [r4, #12]
   15898:	6832      	ldr	r2, [r6, #0]
   1589a:	1a9b      	subs	r3, r3, r2
   1589c:	42ab      	cmp	r3, r5
   1589e:	dc26      	bgt.n	158ee <_printf_common+0x96>
   158a0:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   158a4:	1e13      	subs	r3, r2, #0
   158a6:	6822      	ldr	r2, [r4, #0]
   158a8:	bf18      	it	ne
   158aa:	2301      	movne	r3, #1
   158ac:	0692      	lsls	r2, r2, #26
   158ae:	d42b      	bmi.n	15908 <_printf_common+0xb0>
   158b0:	f104 0243 	add.w	r2, r4, #67	; 0x43
   158b4:	4649      	mov	r1, r9
   158b6:	4638      	mov	r0, r7
   158b8:	47c0      	blx	r8
   158ba:	3001      	adds	r0, #1
   158bc:	d01e      	beq.n	158fc <_printf_common+0xa4>
   158be:	6823      	ldr	r3, [r4, #0]
   158c0:	68e5      	ldr	r5, [r4, #12]
   158c2:	6832      	ldr	r2, [r6, #0]
   158c4:	f003 0306 	and.w	r3, r3, #6
   158c8:	2b04      	cmp	r3, #4
   158ca:	bf08      	it	eq
   158cc:	1aad      	subeq	r5, r5, r2
   158ce:	68a3      	ldr	r3, [r4, #8]
   158d0:	6922      	ldr	r2, [r4, #16]
   158d2:	bf0c      	ite	eq
   158d4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   158d8:	2500      	movne	r5, #0
   158da:	4293      	cmp	r3, r2
   158dc:	bfc4      	itt	gt
   158de:	1a9b      	subgt	r3, r3, r2
   158e0:	18ed      	addgt	r5, r5, r3
   158e2:	2600      	movs	r6, #0
   158e4:	341a      	adds	r4, #26
   158e6:	42b5      	cmp	r5, r6
   158e8:	d11a      	bne.n	15920 <_printf_common+0xc8>
   158ea:	2000      	movs	r0, #0
   158ec:	e008      	b.n	15900 <_printf_common+0xa8>
   158ee:	2301      	movs	r3, #1
   158f0:	4652      	mov	r2, sl
   158f2:	4649      	mov	r1, r9
   158f4:	4638      	mov	r0, r7
   158f6:	47c0      	blx	r8
   158f8:	3001      	adds	r0, #1
   158fa:	d103      	bne.n	15904 <_printf_common+0xac>
   158fc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15900:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15904:	3501      	adds	r5, #1
   15906:	e7c6      	b.n	15896 <_printf_common+0x3e>
   15908:	18e1      	adds	r1, r4, r3
   1590a:	1c5a      	adds	r2, r3, #1
   1590c:	2030      	movs	r0, #48	; 0x30
   1590e:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   15912:	4422      	add	r2, r4
   15914:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   15918:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   1591c:	3302      	adds	r3, #2
   1591e:	e7c7      	b.n	158b0 <_printf_common+0x58>
   15920:	2301      	movs	r3, #1
   15922:	4622      	mov	r2, r4
   15924:	4649      	mov	r1, r9
   15926:	4638      	mov	r0, r7
   15928:	47c0      	blx	r8
   1592a:	3001      	adds	r0, #1
   1592c:	d0e6      	beq.n	158fc <_printf_common+0xa4>
   1592e:	3601      	adds	r6, #1
   15930:	e7d9      	b.n	158e6 <_printf_common+0x8e>
	...

00015934 <_printf_i>:
   15934:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   15938:	460c      	mov	r4, r1
   1593a:	4691      	mov	r9, r2
   1593c:	7e27      	ldrb	r7, [r4, #24]
   1593e:	990c      	ldr	r1, [sp, #48]	; 0x30
   15940:	2f78      	cmp	r7, #120	; 0x78
   15942:	4680      	mov	r8, r0
   15944:	469a      	mov	sl, r3
   15946:	f104 0243 	add.w	r2, r4, #67	; 0x43
   1594a:	d807      	bhi.n	1595c <_printf_i+0x28>
   1594c:	2f62      	cmp	r7, #98	; 0x62
   1594e:	d80a      	bhi.n	15966 <_printf_i+0x32>
   15950:	2f00      	cmp	r7, #0
   15952:	f000 80d8 	beq.w	15b06 <_printf_i+0x1d2>
   15956:	2f58      	cmp	r7, #88	; 0x58
   15958:	f000 80a3 	beq.w	15aa2 <_printf_i+0x16e>
   1595c:	f104 0642 	add.w	r6, r4, #66	; 0x42
   15960:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
   15964:	e03a      	b.n	159dc <_printf_i+0xa8>
   15966:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
   1596a:	2b15      	cmp	r3, #21
   1596c:	d8f6      	bhi.n	1595c <_printf_i+0x28>
   1596e:	a001      	add	r0, pc, #4	; (adr r0, 15974 <_printf_i+0x40>)
   15970:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
   15974:	000159cd 	.word	0x000159cd
   15978:	000159e1 	.word	0x000159e1
   1597c:	0001595d 	.word	0x0001595d
   15980:	0001595d 	.word	0x0001595d
   15984:	0001595d 	.word	0x0001595d
   15988:	0001595d 	.word	0x0001595d
   1598c:	000159e1 	.word	0x000159e1
   15990:	0001595d 	.word	0x0001595d
   15994:	0001595d 	.word	0x0001595d
   15998:	0001595d 	.word	0x0001595d
   1599c:	0001595d 	.word	0x0001595d
   159a0:	00015aed 	.word	0x00015aed
   159a4:	00015a11 	.word	0x00015a11
   159a8:	00015acf 	.word	0x00015acf
   159ac:	0001595d 	.word	0x0001595d
   159b0:	0001595d 	.word	0x0001595d
   159b4:	00015b0f 	.word	0x00015b0f
   159b8:	0001595d 	.word	0x0001595d
   159bc:	00015a11 	.word	0x00015a11
   159c0:	0001595d 	.word	0x0001595d
   159c4:	0001595d 	.word	0x0001595d
   159c8:	00015ad7 	.word	0x00015ad7
   159cc:	680b      	ldr	r3, [r1, #0]
   159ce:	1d1a      	adds	r2, r3, #4
   159d0:	681b      	ldr	r3, [r3, #0]
   159d2:	600a      	str	r2, [r1, #0]
   159d4:	f104 0642 	add.w	r6, r4, #66	; 0x42
   159d8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   159dc:	2301      	movs	r3, #1
   159de:	e0a3      	b.n	15b28 <_printf_i+0x1f4>
   159e0:	6825      	ldr	r5, [r4, #0]
   159e2:	6808      	ldr	r0, [r1, #0]
   159e4:	062e      	lsls	r6, r5, #24
   159e6:	f100 0304 	add.w	r3, r0, #4
   159ea:	d50a      	bpl.n	15a02 <_printf_i+0xce>
   159ec:	6805      	ldr	r5, [r0, #0]
   159ee:	600b      	str	r3, [r1, #0]
   159f0:	2d00      	cmp	r5, #0
   159f2:	da03      	bge.n	159fc <_printf_i+0xc8>
   159f4:	232d      	movs	r3, #45	; 0x2d
   159f6:	426d      	negs	r5, r5
   159f8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   159fc:	485e      	ldr	r0, [pc, #376]	; (15b78 <_printf_i+0x244>)
   159fe:	230a      	movs	r3, #10
   15a00:	e019      	b.n	15a36 <_printf_i+0x102>
   15a02:	f015 0f40 	tst.w	r5, #64	; 0x40
   15a06:	6805      	ldr	r5, [r0, #0]
   15a08:	600b      	str	r3, [r1, #0]
   15a0a:	bf18      	it	ne
   15a0c:	b22d      	sxthne	r5, r5
   15a0e:	e7ef      	b.n	159f0 <_printf_i+0xbc>
   15a10:	680b      	ldr	r3, [r1, #0]
   15a12:	6825      	ldr	r5, [r4, #0]
   15a14:	1d18      	adds	r0, r3, #4
   15a16:	6008      	str	r0, [r1, #0]
   15a18:	0628      	lsls	r0, r5, #24
   15a1a:	d501      	bpl.n	15a20 <_printf_i+0xec>
   15a1c:	681d      	ldr	r5, [r3, #0]
   15a1e:	e002      	b.n	15a26 <_printf_i+0xf2>
   15a20:	0669      	lsls	r1, r5, #25
   15a22:	d5fb      	bpl.n	15a1c <_printf_i+0xe8>
   15a24:	881d      	ldrh	r5, [r3, #0]
   15a26:	4854      	ldr	r0, [pc, #336]	; (15b78 <_printf_i+0x244>)
   15a28:	2f6f      	cmp	r7, #111	; 0x6f
   15a2a:	bf0c      	ite	eq
   15a2c:	2308      	moveq	r3, #8
   15a2e:	230a      	movne	r3, #10
   15a30:	2100      	movs	r1, #0
   15a32:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   15a36:	6866      	ldr	r6, [r4, #4]
   15a38:	60a6      	str	r6, [r4, #8]
   15a3a:	2e00      	cmp	r6, #0
   15a3c:	bfa2      	ittt	ge
   15a3e:	6821      	ldrge	r1, [r4, #0]
   15a40:	f021 0104 	bicge.w	r1, r1, #4
   15a44:	6021      	strge	r1, [r4, #0]
   15a46:	b90d      	cbnz	r5, 15a4c <_printf_i+0x118>
   15a48:	2e00      	cmp	r6, #0
   15a4a:	d04d      	beq.n	15ae8 <_printf_i+0x1b4>
   15a4c:	4616      	mov	r6, r2
   15a4e:	fbb5 f1f3 	udiv	r1, r5, r3
   15a52:	fb03 5711 	mls	r7, r3, r1, r5
   15a56:	5dc7      	ldrb	r7, [r0, r7]
   15a58:	f806 7d01 	strb.w	r7, [r6, #-1]!
   15a5c:	462f      	mov	r7, r5
   15a5e:	42bb      	cmp	r3, r7
   15a60:	460d      	mov	r5, r1
   15a62:	d9f4      	bls.n	15a4e <_printf_i+0x11a>
   15a64:	2b08      	cmp	r3, #8
   15a66:	d10b      	bne.n	15a80 <_printf_i+0x14c>
   15a68:	6823      	ldr	r3, [r4, #0]
   15a6a:	07df      	lsls	r7, r3, #31
   15a6c:	d508      	bpl.n	15a80 <_printf_i+0x14c>
   15a6e:	6923      	ldr	r3, [r4, #16]
   15a70:	6861      	ldr	r1, [r4, #4]
   15a72:	4299      	cmp	r1, r3
   15a74:	bfde      	ittt	le
   15a76:	2330      	movle	r3, #48	; 0x30
   15a78:	f806 3c01 	strble.w	r3, [r6, #-1]
   15a7c:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
   15a80:	1b92      	subs	r2, r2, r6
   15a82:	6122      	str	r2, [r4, #16]
   15a84:	f8cd a000 	str.w	sl, [sp]
   15a88:	464b      	mov	r3, r9
   15a8a:	aa03      	add	r2, sp, #12
   15a8c:	4621      	mov	r1, r4
   15a8e:	4640      	mov	r0, r8
   15a90:	f7ff fee2 	bl	15858 <_printf_common>
   15a94:	3001      	adds	r0, #1
   15a96:	d14c      	bne.n	15b32 <_printf_i+0x1fe>
   15a98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15a9c:	b004      	add	sp, #16
   15a9e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15aa2:	4835      	ldr	r0, [pc, #212]	; (15b78 <_printf_i+0x244>)
   15aa4:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
   15aa8:	6823      	ldr	r3, [r4, #0]
   15aaa:	680e      	ldr	r6, [r1, #0]
   15aac:	061f      	lsls	r7, r3, #24
   15aae:	f856 5b04 	ldr.w	r5, [r6], #4
   15ab2:	600e      	str	r6, [r1, #0]
   15ab4:	d514      	bpl.n	15ae0 <_printf_i+0x1ac>
   15ab6:	07d9      	lsls	r1, r3, #31
   15ab8:	bf44      	itt	mi
   15aba:	f043 0320 	orrmi.w	r3, r3, #32
   15abe:	6023      	strmi	r3, [r4, #0]
   15ac0:	b91d      	cbnz	r5, 15aca <_printf_i+0x196>
   15ac2:	6823      	ldr	r3, [r4, #0]
   15ac4:	f023 0320 	bic.w	r3, r3, #32
   15ac8:	6023      	str	r3, [r4, #0]
   15aca:	2310      	movs	r3, #16
   15acc:	e7b0      	b.n	15a30 <_printf_i+0xfc>
   15ace:	6823      	ldr	r3, [r4, #0]
   15ad0:	f043 0320 	orr.w	r3, r3, #32
   15ad4:	6023      	str	r3, [r4, #0]
   15ad6:	2378      	movs	r3, #120	; 0x78
   15ad8:	4828      	ldr	r0, [pc, #160]	; (15b7c <_printf_i+0x248>)
   15ada:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   15ade:	e7e3      	b.n	15aa8 <_printf_i+0x174>
   15ae0:	065e      	lsls	r6, r3, #25
   15ae2:	bf48      	it	mi
   15ae4:	b2ad      	uxthmi	r5, r5
   15ae6:	e7e6      	b.n	15ab6 <_printf_i+0x182>
   15ae8:	4616      	mov	r6, r2
   15aea:	e7bb      	b.n	15a64 <_printf_i+0x130>
   15aec:	680b      	ldr	r3, [r1, #0]
   15aee:	6826      	ldr	r6, [r4, #0]
   15af0:	6960      	ldr	r0, [r4, #20]
   15af2:	1d1d      	adds	r5, r3, #4
   15af4:	600d      	str	r5, [r1, #0]
   15af6:	0635      	lsls	r5, r6, #24
   15af8:	681b      	ldr	r3, [r3, #0]
   15afa:	d501      	bpl.n	15b00 <_printf_i+0x1cc>
   15afc:	6018      	str	r0, [r3, #0]
   15afe:	e002      	b.n	15b06 <_printf_i+0x1d2>
   15b00:	0671      	lsls	r1, r6, #25
   15b02:	d5fb      	bpl.n	15afc <_printf_i+0x1c8>
   15b04:	8018      	strh	r0, [r3, #0]
   15b06:	2300      	movs	r3, #0
   15b08:	6123      	str	r3, [r4, #16]
   15b0a:	4616      	mov	r6, r2
   15b0c:	e7ba      	b.n	15a84 <_printf_i+0x150>
   15b0e:	680b      	ldr	r3, [r1, #0]
   15b10:	1d1a      	adds	r2, r3, #4
   15b12:	600a      	str	r2, [r1, #0]
   15b14:	681e      	ldr	r6, [r3, #0]
   15b16:	6862      	ldr	r2, [r4, #4]
   15b18:	2100      	movs	r1, #0
   15b1a:	4630      	mov	r0, r6
   15b1c:	f000 f918 	bl	15d50 <memchr>
   15b20:	b108      	cbz	r0, 15b26 <_printf_i+0x1f2>
   15b22:	1b80      	subs	r0, r0, r6
   15b24:	6060      	str	r0, [r4, #4]
   15b26:	6863      	ldr	r3, [r4, #4]
   15b28:	6123      	str	r3, [r4, #16]
   15b2a:	2300      	movs	r3, #0
   15b2c:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   15b30:	e7a8      	b.n	15a84 <_printf_i+0x150>
   15b32:	6923      	ldr	r3, [r4, #16]
   15b34:	4632      	mov	r2, r6
   15b36:	4649      	mov	r1, r9
   15b38:	4640      	mov	r0, r8
   15b3a:	47d0      	blx	sl
   15b3c:	3001      	adds	r0, #1
   15b3e:	d0ab      	beq.n	15a98 <_printf_i+0x164>
   15b40:	6823      	ldr	r3, [r4, #0]
   15b42:	079b      	lsls	r3, r3, #30
   15b44:	d413      	bmi.n	15b6e <_printf_i+0x23a>
   15b46:	68e0      	ldr	r0, [r4, #12]
   15b48:	9b03      	ldr	r3, [sp, #12]
   15b4a:	4298      	cmp	r0, r3
   15b4c:	bfb8      	it	lt
   15b4e:	4618      	movlt	r0, r3
   15b50:	e7a4      	b.n	15a9c <_printf_i+0x168>
   15b52:	2301      	movs	r3, #1
   15b54:	4632      	mov	r2, r6
   15b56:	4649      	mov	r1, r9
   15b58:	4640      	mov	r0, r8
   15b5a:	47d0      	blx	sl
   15b5c:	3001      	adds	r0, #1
   15b5e:	d09b      	beq.n	15a98 <_printf_i+0x164>
   15b60:	3501      	adds	r5, #1
   15b62:	68e3      	ldr	r3, [r4, #12]
   15b64:	9903      	ldr	r1, [sp, #12]
   15b66:	1a5b      	subs	r3, r3, r1
   15b68:	42ab      	cmp	r3, r5
   15b6a:	dcf2      	bgt.n	15b52 <_printf_i+0x21e>
   15b6c:	e7eb      	b.n	15b46 <_printf_i+0x212>
   15b6e:	2500      	movs	r5, #0
   15b70:	f104 0619 	add.w	r6, r4, #25
   15b74:	e7f5      	b.n	15b62 <_printf_i+0x22e>
   15b76:	bf00      	nop
   15b78:	00016f2d 	.word	0x00016f2d
   15b7c:	00016f3e 	.word	0x00016f3e

00015b80 <_putc_r>:
   15b80:	b570      	push	{r4, r5, r6, lr}
   15b82:	460d      	mov	r5, r1
   15b84:	4614      	mov	r4, r2
   15b86:	4606      	mov	r6, r0
   15b88:	b118      	cbz	r0, 15b92 <_putc_r+0x12>
   15b8a:	6983      	ldr	r3, [r0, #24]
   15b8c:	b90b      	cbnz	r3, 15b92 <_putc_r+0x12>
   15b8e:	f7ff fa9f 	bl	150d0 <__sinit>
   15b92:	4b1c      	ldr	r3, [pc, #112]	; (15c04 <_putc_r+0x84>)
   15b94:	429c      	cmp	r4, r3
   15b96:	d124      	bne.n	15be2 <_putc_r+0x62>
   15b98:	6874      	ldr	r4, [r6, #4]
   15b9a:	6e63      	ldr	r3, [r4, #100]	; 0x64
   15b9c:	07d8      	lsls	r0, r3, #31
   15b9e:	d405      	bmi.n	15bac <_putc_r+0x2c>
   15ba0:	89a3      	ldrh	r3, [r4, #12]
   15ba2:	0599      	lsls	r1, r3, #22
   15ba4:	d402      	bmi.n	15bac <_putc_r+0x2c>
   15ba6:	6da0      	ldr	r0, [r4, #88]	; 0x58
   15ba8:	f7ff fb30 	bl	1520c <__retarget_lock_acquire_recursive>
   15bac:	68a3      	ldr	r3, [r4, #8]
   15bae:	3b01      	subs	r3, #1
   15bb0:	2b00      	cmp	r3, #0
   15bb2:	60a3      	str	r3, [r4, #8]
   15bb4:	da05      	bge.n	15bc2 <_putc_r+0x42>
   15bb6:	69a2      	ldr	r2, [r4, #24]
   15bb8:	4293      	cmp	r3, r2
   15bba:	db1c      	blt.n	15bf6 <_putc_r+0x76>
   15bbc:	b2eb      	uxtb	r3, r5
   15bbe:	2b0a      	cmp	r3, #10
   15bc0:	d019      	beq.n	15bf6 <_putc_r+0x76>
   15bc2:	6823      	ldr	r3, [r4, #0]
   15bc4:	1c5a      	adds	r2, r3, #1
   15bc6:	6022      	str	r2, [r4, #0]
   15bc8:	701d      	strb	r5, [r3, #0]
   15bca:	b2ed      	uxtb	r5, r5
   15bcc:	6e63      	ldr	r3, [r4, #100]	; 0x64
   15bce:	07da      	lsls	r2, r3, #31
   15bd0:	d405      	bmi.n	15bde <_putc_r+0x5e>
   15bd2:	89a3      	ldrh	r3, [r4, #12]
   15bd4:	059b      	lsls	r3, r3, #22
   15bd6:	d402      	bmi.n	15bde <_putc_r+0x5e>
   15bd8:	6da0      	ldr	r0, [r4, #88]	; 0x58
   15bda:	f7ff fb18 	bl	1520e <__retarget_lock_release_recursive>
   15bde:	4628      	mov	r0, r5
   15be0:	bd70      	pop	{r4, r5, r6, pc}
   15be2:	4b09      	ldr	r3, [pc, #36]	; (15c08 <_putc_r+0x88>)
   15be4:	429c      	cmp	r4, r3
   15be6:	d101      	bne.n	15bec <_putc_r+0x6c>
   15be8:	68b4      	ldr	r4, [r6, #8]
   15bea:	e7d6      	b.n	15b9a <_putc_r+0x1a>
   15bec:	4b07      	ldr	r3, [pc, #28]	; (15c0c <_putc_r+0x8c>)
   15bee:	429c      	cmp	r4, r3
   15bf0:	bf08      	it	eq
   15bf2:	68f4      	ldreq	r4, [r6, #12]
   15bf4:	e7d1      	b.n	15b9a <_putc_r+0x1a>
   15bf6:	4629      	mov	r1, r5
   15bf8:	4622      	mov	r2, r4
   15bfa:	4630      	mov	r0, r6
   15bfc:	f7ff f88e 	bl	14d1c <__swbuf_r>
   15c00:	4605      	mov	r5, r0
   15c02:	e7e3      	b.n	15bcc <_putc_r+0x4c>
   15c04:	00016edc 	.word	0x00016edc
   15c08:	00016efc 	.word	0x00016efc
   15c0c:	00016ebc 	.word	0x00016ebc

00015c10 <__sread>:
   15c10:	b510      	push	{r4, lr}
   15c12:	460c      	mov	r4, r1
   15c14:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15c18:	f000 f92a 	bl	15e70 <_read_r>
   15c1c:	2800      	cmp	r0, #0
   15c1e:	bfab      	itete	ge
   15c20:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   15c22:	89a3      	ldrhlt	r3, [r4, #12]
   15c24:	181b      	addge	r3, r3, r0
   15c26:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   15c2a:	bfac      	ite	ge
   15c2c:	6563      	strge	r3, [r4, #84]	; 0x54
   15c2e:	81a3      	strhlt	r3, [r4, #12]
   15c30:	bd10      	pop	{r4, pc}

00015c32 <__swrite>:
   15c32:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   15c36:	461f      	mov	r7, r3
   15c38:	898b      	ldrh	r3, [r1, #12]
   15c3a:	05db      	lsls	r3, r3, #23
   15c3c:	4605      	mov	r5, r0
   15c3e:	460c      	mov	r4, r1
   15c40:	4616      	mov	r6, r2
   15c42:	d505      	bpl.n	15c50 <__swrite+0x1e>
   15c44:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15c48:	2302      	movs	r3, #2
   15c4a:	2200      	movs	r2, #0
   15c4c:	f000 f868 	bl	15d20 <_lseek_r>
   15c50:	89a3      	ldrh	r3, [r4, #12]
   15c52:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   15c56:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   15c5a:	81a3      	strh	r3, [r4, #12]
   15c5c:	4632      	mov	r2, r6
   15c5e:	463b      	mov	r3, r7
   15c60:	4628      	mov	r0, r5
   15c62:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   15c66:	f000 b817 	b.w	15c98 <_write_r>

00015c6a <__sseek>:
   15c6a:	b510      	push	{r4, lr}
   15c6c:	460c      	mov	r4, r1
   15c6e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15c72:	f000 f855 	bl	15d20 <_lseek_r>
   15c76:	1c43      	adds	r3, r0, #1
   15c78:	89a3      	ldrh	r3, [r4, #12]
   15c7a:	bf15      	itete	ne
   15c7c:	6560      	strne	r0, [r4, #84]	; 0x54
   15c7e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   15c82:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   15c86:	81a3      	strheq	r3, [r4, #12]
   15c88:	bf18      	it	ne
   15c8a:	81a3      	strhne	r3, [r4, #12]
   15c8c:	bd10      	pop	{r4, pc}

00015c8e <__sclose>:
   15c8e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15c92:	f000 b813 	b.w	15cbc <_close_r>
	...

00015c98 <_write_r>:
   15c98:	b538      	push	{r3, r4, r5, lr}
   15c9a:	4d07      	ldr	r5, [pc, #28]	; (15cb8 <_write_r+0x20>)
   15c9c:	4604      	mov	r4, r0
   15c9e:	4608      	mov	r0, r1
   15ca0:	4611      	mov	r1, r2
   15ca2:	2200      	movs	r2, #0
   15ca4:	602a      	str	r2, [r5, #0]
   15ca6:	461a      	mov	r2, r3
   15ca8:	f7f6 f8b6 	bl	be18 <_write>
   15cac:	1c43      	adds	r3, r0, #1
   15cae:	d102      	bne.n	15cb6 <_write_r+0x1e>
   15cb0:	682b      	ldr	r3, [r5, #0]
   15cb2:	b103      	cbz	r3, 15cb6 <_write_r+0x1e>
   15cb4:	6023      	str	r3, [r4, #0]
   15cb6:	bd38      	pop	{r3, r4, r5, pc}
   15cb8:	2001cfe0 	.word	0x2001cfe0

00015cbc <_close_r>:
   15cbc:	b538      	push	{r3, r4, r5, lr}
   15cbe:	4d06      	ldr	r5, [pc, #24]	; (15cd8 <_close_r+0x1c>)
   15cc0:	2300      	movs	r3, #0
   15cc2:	4604      	mov	r4, r0
   15cc4:	4608      	mov	r0, r1
   15cc6:	602b      	str	r3, [r5, #0]
   15cc8:	f7f6 fa7e 	bl	c1c8 <_close>
   15ccc:	1c43      	adds	r3, r0, #1
   15cce:	d102      	bne.n	15cd6 <_close_r+0x1a>
   15cd0:	682b      	ldr	r3, [r5, #0]
   15cd2:	b103      	cbz	r3, 15cd6 <_close_r+0x1a>
   15cd4:	6023      	str	r3, [r4, #0]
   15cd6:	bd38      	pop	{r3, r4, r5, pc}
   15cd8:	2001cfe0 	.word	0x2001cfe0

00015cdc <_fstat_r>:
   15cdc:	b538      	push	{r3, r4, r5, lr}
   15cde:	4d07      	ldr	r5, [pc, #28]	; (15cfc <_fstat_r+0x20>)
   15ce0:	2300      	movs	r3, #0
   15ce2:	4604      	mov	r4, r0
   15ce4:	4608      	mov	r0, r1
   15ce6:	4611      	mov	r1, r2
   15ce8:	602b      	str	r3, [r5, #0]
   15cea:	f7f6 fa70 	bl	c1ce <_fstat>
   15cee:	1c43      	adds	r3, r0, #1
   15cf0:	d102      	bne.n	15cf8 <_fstat_r+0x1c>
   15cf2:	682b      	ldr	r3, [r5, #0]
   15cf4:	b103      	cbz	r3, 15cf8 <_fstat_r+0x1c>
   15cf6:	6023      	str	r3, [r4, #0]
   15cf8:	bd38      	pop	{r3, r4, r5, pc}
   15cfa:	bf00      	nop
   15cfc:	2001cfe0 	.word	0x2001cfe0

00015d00 <_isatty_r>:
   15d00:	b538      	push	{r3, r4, r5, lr}
   15d02:	4d06      	ldr	r5, [pc, #24]	; (15d1c <_isatty_r+0x1c>)
   15d04:	2300      	movs	r3, #0
   15d06:	4604      	mov	r4, r0
   15d08:	4608      	mov	r0, r1
   15d0a:	602b      	str	r3, [r5, #0]
   15d0c:	f7f6 fa64 	bl	c1d8 <_isatty>
   15d10:	1c43      	adds	r3, r0, #1
   15d12:	d102      	bne.n	15d1a <_isatty_r+0x1a>
   15d14:	682b      	ldr	r3, [r5, #0]
   15d16:	b103      	cbz	r3, 15d1a <_isatty_r+0x1a>
   15d18:	6023      	str	r3, [r4, #0]
   15d1a:	bd38      	pop	{r3, r4, r5, pc}
   15d1c:	2001cfe0 	.word	0x2001cfe0

00015d20 <_lseek_r>:
   15d20:	b538      	push	{r3, r4, r5, lr}
   15d22:	4d07      	ldr	r5, [pc, #28]	; (15d40 <_lseek_r+0x20>)
   15d24:	4604      	mov	r4, r0
   15d26:	4608      	mov	r0, r1
   15d28:	4611      	mov	r1, r2
   15d2a:	2200      	movs	r2, #0
   15d2c:	602a      	str	r2, [r5, #0]
   15d2e:	461a      	mov	r2, r3
   15d30:	f7f6 fa54 	bl	c1dc <_lseek>
   15d34:	1c43      	adds	r3, r0, #1
   15d36:	d102      	bne.n	15d3e <_lseek_r+0x1e>
   15d38:	682b      	ldr	r3, [r5, #0]
   15d3a:	b103      	cbz	r3, 15d3e <_lseek_r+0x1e>
   15d3c:	6023      	str	r3, [r4, #0]
   15d3e:	bd38      	pop	{r3, r4, r5, pc}
   15d40:	2001cfe0 	.word	0x2001cfe0
	...

00015d50 <memchr>:
   15d50:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   15d54:	2a10      	cmp	r2, #16
   15d56:	db2b      	blt.n	15db0 <memchr+0x60>
   15d58:	f010 0f07 	tst.w	r0, #7
   15d5c:	d008      	beq.n	15d70 <memchr+0x20>
   15d5e:	f810 3b01 	ldrb.w	r3, [r0], #1
   15d62:	3a01      	subs	r2, #1
   15d64:	428b      	cmp	r3, r1
   15d66:	d02d      	beq.n	15dc4 <memchr+0x74>
   15d68:	f010 0f07 	tst.w	r0, #7
   15d6c:	b342      	cbz	r2, 15dc0 <memchr+0x70>
   15d6e:	d1f6      	bne.n	15d5e <memchr+0xe>
   15d70:	b4f0      	push	{r4, r5, r6, r7}
   15d72:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   15d76:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   15d7a:	f022 0407 	bic.w	r4, r2, #7
   15d7e:	f07f 0700 	mvns.w	r7, #0
   15d82:	2300      	movs	r3, #0
   15d84:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   15d88:	3c08      	subs	r4, #8
   15d8a:	ea85 0501 	eor.w	r5, r5, r1
   15d8e:	ea86 0601 	eor.w	r6, r6, r1
   15d92:	fa85 f547 	uadd8	r5, r5, r7
   15d96:	faa3 f587 	sel	r5, r3, r7
   15d9a:	fa86 f647 	uadd8	r6, r6, r7
   15d9e:	faa5 f687 	sel	r6, r5, r7
   15da2:	b98e      	cbnz	r6, 15dc8 <memchr+0x78>
   15da4:	d1ee      	bne.n	15d84 <memchr+0x34>
   15da6:	bcf0      	pop	{r4, r5, r6, r7}
   15da8:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   15dac:	f002 0207 	and.w	r2, r2, #7
   15db0:	b132      	cbz	r2, 15dc0 <memchr+0x70>
   15db2:	f810 3b01 	ldrb.w	r3, [r0], #1
   15db6:	3a01      	subs	r2, #1
   15db8:	ea83 0301 	eor.w	r3, r3, r1
   15dbc:	b113      	cbz	r3, 15dc4 <memchr+0x74>
   15dbe:	d1f8      	bne.n	15db2 <memchr+0x62>
   15dc0:	2000      	movs	r0, #0
   15dc2:	4770      	bx	lr
   15dc4:	3801      	subs	r0, #1
   15dc6:	4770      	bx	lr
   15dc8:	2d00      	cmp	r5, #0
   15dca:	bf06      	itte	eq
   15dcc:	4635      	moveq	r5, r6
   15dce:	3803      	subeq	r0, #3
   15dd0:	3807      	subne	r0, #7
   15dd2:	f015 0f01 	tst.w	r5, #1
   15dd6:	d107      	bne.n	15de8 <memchr+0x98>
   15dd8:	3001      	adds	r0, #1
   15dda:	f415 7f80 	tst.w	r5, #256	; 0x100
   15dde:	bf02      	ittt	eq
   15de0:	3001      	addeq	r0, #1
   15de2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   15de6:	3001      	addeq	r0, #1
   15de8:	bcf0      	pop	{r4, r5, r6, r7}
   15dea:	3801      	subs	r0, #1
   15dec:	4770      	bx	lr
   15dee:	bf00      	nop

00015df0 <memmove>:
   15df0:	4288      	cmp	r0, r1
   15df2:	b510      	push	{r4, lr}
   15df4:	eb01 0402 	add.w	r4, r1, r2
   15df8:	d902      	bls.n	15e00 <memmove+0x10>
   15dfa:	4284      	cmp	r4, r0
   15dfc:	4623      	mov	r3, r4
   15dfe:	d807      	bhi.n	15e10 <memmove+0x20>
   15e00:	1e43      	subs	r3, r0, #1
   15e02:	42a1      	cmp	r1, r4
   15e04:	d008      	beq.n	15e18 <memmove+0x28>
   15e06:	f811 2b01 	ldrb.w	r2, [r1], #1
   15e0a:	f803 2f01 	strb.w	r2, [r3, #1]!
   15e0e:	e7f8      	b.n	15e02 <memmove+0x12>
   15e10:	4402      	add	r2, r0
   15e12:	4601      	mov	r1, r0
   15e14:	428a      	cmp	r2, r1
   15e16:	d100      	bne.n	15e1a <memmove+0x2a>
   15e18:	bd10      	pop	{r4, pc}
   15e1a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   15e1e:	f802 4d01 	strb.w	r4, [r2, #-1]!
   15e22:	e7f7      	b.n	15e14 <memmove+0x24>

00015e24 <_realloc_r>:
   15e24:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15e26:	4607      	mov	r7, r0
   15e28:	4614      	mov	r4, r2
   15e2a:	460e      	mov	r6, r1
   15e2c:	b921      	cbnz	r1, 15e38 <_realloc_r+0x14>
   15e2e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   15e32:	4611      	mov	r1, r2
   15e34:	f7fe bd1c 	b.w	14870 <_malloc_r>
   15e38:	b922      	cbnz	r2, 15e44 <_realloc_r+0x20>
   15e3a:	f7fe fccb 	bl	147d4 <_free_r>
   15e3e:	4625      	mov	r5, r4
   15e40:	4628      	mov	r0, r5
   15e42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15e44:	f000 f826 	bl	15e94 <_malloc_usable_size_r>
   15e48:	42a0      	cmp	r0, r4
   15e4a:	d20f      	bcs.n	15e6c <_realloc_r+0x48>
   15e4c:	4621      	mov	r1, r4
   15e4e:	4638      	mov	r0, r7
   15e50:	f7fe fd0e 	bl	14870 <_malloc_r>
   15e54:	4605      	mov	r5, r0
   15e56:	2800      	cmp	r0, #0
   15e58:	d0f2      	beq.n	15e40 <_realloc_r+0x1c>
   15e5a:	4631      	mov	r1, r6
   15e5c:	4622      	mov	r2, r4
   15e5e:	f7fe fca3 	bl	147a8 <memcpy>
   15e62:	4631      	mov	r1, r6
   15e64:	4638      	mov	r0, r7
   15e66:	f7fe fcb5 	bl	147d4 <_free_r>
   15e6a:	e7e9      	b.n	15e40 <_realloc_r+0x1c>
   15e6c:	4635      	mov	r5, r6
   15e6e:	e7e7      	b.n	15e40 <_realloc_r+0x1c>

00015e70 <_read_r>:
   15e70:	b538      	push	{r3, r4, r5, lr}
   15e72:	4d07      	ldr	r5, [pc, #28]	; (15e90 <_read_r+0x20>)
   15e74:	4604      	mov	r4, r0
   15e76:	4608      	mov	r0, r1
   15e78:	4611      	mov	r1, r2
   15e7a:	2200      	movs	r2, #0
   15e7c:	602a      	str	r2, [r5, #0]
   15e7e:	461a      	mov	r2, r3
   15e80:	f7f7 ff9a 	bl	ddb8 <_read>
   15e84:	1c43      	adds	r3, r0, #1
   15e86:	d102      	bne.n	15e8e <_read_r+0x1e>
   15e88:	682b      	ldr	r3, [r5, #0]
   15e8a:	b103      	cbz	r3, 15e8e <_read_r+0x1e>
   15e8c:	6023      	str	r3, [r4, #0]
   15e8e:	bd38      	pop	{r3, r4, r5, pc}
   15e90:	2001cfe0 	.word	0x2001cfe0

00015e94 <_malloc_usable_size_r>:
   15e94:	f851 3c04 	ldr.w	r3, [r1, #-4]
   15e98:	1f18      	subs	r0, r3, #4
   15e9a:	2b00      	cmp	r3, #0
   15e9c:	bfbc      	itt	lt
   15e9e:	580b      	ldrlt	r3, [r1, r0]
   15ea0:	18c0      	addlt	r0, r0, r3
   15ea2:	4770      	bx	lr
   15ea4:	6d617246 	.word	0x6d617246
   15ea8:	74532065 	.word	0x74532065
   15eac:	20747261 	.word	0x20747261
   15eb0:	7366664f 	.word	0x7366664f
   15eb4:	7b007465 	.word	0x7b007465
   15eb8:	70797422 	.word	0x70797422
   15ebc:	223a2265 	.word	0x223a2265
   15ec0:	4e524157 	.word	0x4e524157
   15ec4:	22474e49 	.word	0x22474e49
   15ec8:	6422202c 	.word	0x6422202c
   15ecc:	22617461 	.word	0x22617461
   15ed0:	225b203a 	.word	0x225b203a
   15ed4:	5d227325 	.word	0x5d227325
   15ed8:	000a0d7d 	.word	0x000a0d7d
   15edc:	6e6e6f43 	.word	0x6e6e6f43
   15ee0:	00746365 	.word	0x00746365
   15ee4:	7974227b 	.word	0x7974227b
   15ee8:	3a226570 	.word	0x3a226570
   15eec:	41572220 	.word	0x41572220
   15ef0:	4e494e52 	.word	0x4e494e52
   15ef4:	202c2247 	.word	0x202c2247
   15ef8:	74616422 	.word	0x74616422
   15efc:	203a2261 	.word	0x203a2261
   15f00:	6e55225b 	.word	0x6e55225b
   15f04:	776f6e6b 	.word	0x776f6e6b
   15f08:	73654d20 	.word	0x73654d20
   15f0c:	65676173 	.word	0x65676173
   15f10:	70795420 	.word	0x70795420
   15f14:	7d5d2265 	.word	0x7d5d2265
   15f18:	227b000d 	.word	0x227b000d
   15f1c:	65707974 	.word	0x65707974
   15f20:	22203a22 	.word	0x22203a22
   15f24:	4e524157 	.word	0x4e524157
   15f28:	22474e49 	.word	0x22474e49
   15f2c:	6422202c 	.word	0x6422202c
   15f30:	22617461 	.word	0x22617461
   15f34:	225b203a 	.word	0x225b203a
   15f38:	61766e49 	.word	0x61766e49
   15f3c:	2064696c 	.word	0x2064696c
   15f40:	63656843 	.word	0x63656843
   15f44:	6d75736b 	.word	0x6d75736b
   15f48:	0d7d5d22 	.word	0x0d7d5d22
   15f4c:	6d695400 	.word	0x6d695400
   15f50:	74756f65 	.word	0x74756f65
   15f54:	73694420 	.word	0x73694420
   15f58:	6e6e6f63 	.word	0x6e6e6f63
   15f5c:	20746365 	.word	0x20746365
   15f60:	65522026 	.word	0x65522026
   15f64:	20746573 	.word	0x20746573
   15f68:	65636552 	.word	0x65636552
   15f6c:	72657669 	.word	0x72657669
   15f70:	6d695400 	.word	0x6d695400
   15f74:	74756f65 	.word	0x74756f65
   15f78:	52202620 	.word	0x52202620
   15f7c:	74657365 	.word	0x74657365
   15f80:	63655220 	.word	0x63655220
   15f84:	65766965 	.word	0x65766965
   15f88:	63250072 	.word	0x63250072
   15f8c:	63256325 	.word	0x63256325
   15f90:	30256325 	.word	0x30256325
   15f94:	30257832 	.word	0x30257832
   15f98:	30257832 	.word	0x30257832
   15f9c:	63257832 	.word	0x63257832
   15fa0:	000a3030 	.word	0x000a3030
   15fa4:	30256325 	.word	0x30256325
   15fa8:	2e5f7833 	.word	0x2e5f7833
   15fac:	2e2e2e2e 	.word	0x2e2e2e2e
   15fb0:	2e2e2e2e 	.word	0x2e2e2e2e
   15fb4:	2e2e2e2e 	.word	0x2e2e2e2e
   15fb8:	2e2e2e2e 	.word	0x2e2e2e2e
   15fbc:	2e2e2e2e 	.word	0x2e2e2e2e
   15fc0:	2e2e2e2e 	.word	0x2e2e2e2e
   15fc4:	2e2e2e2e 	.word	0x2e2e2e2e
   15fc8:	252e2e2e 	.word	0x252e2e2e
   15fcc:	63250063 	.word	0x63250063
   15fd0:	78333025 	.word	0x78333025
   15fd4:	2e2e2e5f 	.word	0x2e2e2e5f
   15fd8:	2e2e2e2e 	.word	0x2e2e2e2e
   15fdc:	0063252e 	.word	0x0063252e
   15fe0:	30256325 	.word	0x30256325
   15fe4:	2e5f7833 	.word	0x2e5f7833
   15fe8:	0063252e 	.word	0x0063252e
   15fec:	30256325 	.word	0x30256325
   15ff0:	2e5f7833 	.word	0x2e5f7833
   15ff4:	2e2e2e2e 	.word	0x2e2e2e2e
   15ff8:	0063252e 	.word	0x0063252e
   15ffc:	7974227b 	.word	0x7974227b
   16000:	3a226570 	.word	0x3a226570
   16004:	43574822 	.word	0x43574822
   16008:	2c224746 	.word	0x2c224746
   1600c:	61642220 	.word	0x61642220
   16010:	3a226174 	.word	0x3a226174
   16014:	64252220 	.word	0x64252220
   16018:	0a0d7d22 	.word	0x0a0d7d22
   1601c:	204f4e00 	.word	0x204f4e00
   16020:	52455355 	.word	0x52455355
   16024:	574f5220 	.word	0x574f5220
   16028:	45484320 	.word	0x45484320
   1602c:	00214b43 	.word	0x00214b43
   16030:	55206f4e 	.word	0x55206f4e
   16034:	2074696e 	.word	0x2074696e
   16038:	74736554 	.word	0x74736554
   1603c:	206f4e00 	.word	0x206f4e00
   16040:	64726148 	.word	0x64726148
   16044:	65726177 	.word	0x65726177
   16048:	73655420 	.word	0x73655420
   1604c:	65520074 	.word	0x65520074
   16050:	6e696461 	.word	0x6e696461
   16054:	73552067 	.word	0x73552067
   16058:	52207265 	.word	0x52207265
   1605c:	7b00776f 	.word	0x7b00776f
   16060:	70797422 	.word	0x70797422
   16064:	223a2265 	.word	0x223a2265
   16068:	22474f4c 	.word	0x22474f4c
   1606c:	6422202c 	.word	0x6422202c
   16070:	22617461 	.word	0x22617461
   16074:	225b203a 	.word	0x225b203a
   16078:	5d227325 	.word	0x5d227325
   1607c:	000a0d7d 	.word	0x000a0d7d
   16080:	69726556 	.word	0x69726556
   16084:	6e697966 	.word	0x6e697966
   16088:	73552067 	.word	0x73552067
   1608c:	52207265 	.word	0x52207265
   16090:	5500776f 	.word	0x5500776f
   16094:	74616470 	.word	0x74616470
   16098:	20676e69 	.word	0x20676e69
   1609c:	72657355 	.word	0x72657355
   160a0:	776f5220 	.word	0x776f5220
   160a4:	73795300 	.word	0x73795300
   160a8:	206d6574 	.word	0x206d6574
   160ac:	65736552 	.word	0x65736552
   160b0:	6e550074 	.word	0x6e550074
   160b4:	6e616863 	.word	0x6e616863
   160b8:	20646567 	.word	0x20646567
   160bc:	72657355 	.word	0x72657355
   160c0:	776f5220 	.word	0x776f5220
   160c4:	00          	.byte	0x00
   160c5:	45          	.byte	0x45
   160c6:	5252      	.short	0x5252
   160c8:	6920524f 	.word	0x6920524f
   160cc:	7865206e 	.word	0x7865206e
   160d0:	6c5f7270 	.word	0x6c5f7270
   160d4:	6c657665 	.word	0x6c657665
   160d8:	2928335f 	.word	0x2928335f
   160dc:	73626100 	.word	0x73626100
   160e0:	78697300 	.word	0x78697300
   160e4:	64646100 	.word	0x64646100
   160e8:	69727000 	.word	0x69727000
   160ec:	6900746e 	.word	0x6900746e
   160f0:	75460066 	.word	0x75460066
   160f4:	6974636e 	.word	0x6974636e
   160f8:	22206e6f 	.word	0x22206e6f
   160fc:	20227325 	.word	0x20227325
   16100:	20746f6e 	.word	0x20746f6e
   16104:	6e756f66 	.word	0x6e756f66
   16108:	000a2164 	.word	0x000a2164
   1610c:	29642528 	.word	0x29642528
   16110:	32302500 	.word	0x32302500
   16114:	0078      	.short	0x0078
   16116:	3002      	.short	0x3002
   16118:	7b653035 	.word	0x7b653035
   1611c:	305a2870 	.word	0x305a2870
   16120:	30307d29 	.word	0x30307d29
   16124:	30306330 	.word	0x30306330
   16128:	30020003 	.word	0x30020003
   1612c:	7b653035 	.word	0x7b653035
   16130:	305a2870 	.word	0x305a2870
   16134:	30307d29 	.word	0x30307d29
   16138:	707b3830 	.word	0x707b3830
   1613c:	29345a28 	.word	0x29345a28
   16140:	3002037d 	.word	0x3002037d
   16144:	7b653033 	.word	0x7b653033
   16148:	355a2870 	.word	0x355a2870
   1614c:	00037d29 	.word	0x00037d29
   16150:	30353002 	.word	0x30353002
   16154:	28707b65 	.word	0x28707b65
   16158:	7d29305a 	.word	0x7d29305a
   1615c:	39303030 	.word	0x39303030
   16160:	5a28707b 	.word	0x5a28707b
   16164:	037d2934 	.word	0x037d2934
   16168:	35300200 	.word	0x35300200
   1616c:	707b6530 	.word	0x707b6530
   16170:	29305a28 	.word	0x29305a28
   16174:	3030307d 	.word	0x3030307d
   16178:	28707b61 	.word	0x28707b61
   1617c:	7d29345a 	.word	0x7d29345a
   16180:	33300203 	.word	0x33300203
   16184:	707b6530 	.word	0x707b6530
   16188:	29305a28 	.word	0x29305a28
   1618c:	0200037d 	.word	0x0200037d
   16190:	65303530 	.word	0x65303530
   16194:	5a28707b 	.word	0x5a28707b
   16198:	307d2930 	.word	0x307d2930
   1619c:	7b623030 	.word	0x7b623030
   161a0:	345a2870 	.word	0x345a2870
   161a4:	02037d29 	.word	0x02037d29
   161a8:	66303330 	.word	0x66303330
   161ac:	5a28707b 	.word	0x5a28707b
   161b0:	037d2930 	.word	0x037d2930
   161b4:	20495500 	.word	0x20495500
   161b8:	65776f50 	.word	0x65776f50
   161bc:	6e452072 	.word	0x6e452072
   161c0:	656c6261 	.word	0x656c6261
   161c4:	696e4900 	.word	0x696e4900
   161c8:	6f4d2074 	.word	0x6f4d2074
   161cc:	656c7564 	.word	0x656c7564
   161d0:	4f50203a 	.word	0x4f50203a
   161d4:	49003631 	.word	0x49003631
   161d8:	2074696e 	.word	0x2074696e
   161dc:	75646f4d 	.word	0x75646f4d
   161e0:	203a656c 	.word	0x203a656c
   161e4:	36315542 	.word	0x36315542
   161e8:	696e4900 	.word	0x696e4900
   161ec:	6f4d2074 	.word	0x6f4d2074
   161f0:	656c7564 	.word	0x656c7564
   161f4:	4250203a 	.word	0x4250203a
   161f8:	49003446 	.word	0x49003446
   161fc:	2074696e 	.word	0x2074696e
   16200:	75646f4d 	.word	0x75646f4d
   16204:	203a656c 	.word	0x203a656c
   16208:	36314e45 	.word	0x36314e45
   1620c:	696e4900 	.word	0x696e4900
   16210:	6f4d2074 	.word	0x6f4d2074
   16214:	656c7564 	.word	0x656c7564
   16218:	6e55203a 	.word	0x6e55203a
   1621c:	776f6e6b 	.word	0x776f6e6b
   16220:	6f4d206e 	.word	0x6f4d206e
   16224:	656c7564 	.word	0x656c7564
   16228:	43574800 	.word	0x43574800
   1622c:	4d204746 	.word	0x4d204746
   16230:	616d7369 	.word	0x616d7369
   16234:	00686374 	.word	0x00686374
   16238:	0f0e0d0c 	.word	0x0f0e0d0c
   1623c:	0b0a0908 	.word	0x0b0a0908
   16240:	07060504 	.word	0x07060504
   16244:	03020100 	.word	0x03020100
   16248:	0f0e0d0c 	.word	0x0f0e0d0c
   1624c:	0b0a0908 	.word	0x0b0a0908
   16250:	07060504 	.word	0x07060504
   16254:	03020100 	.word	0x03020100
   16258:	0f0e0d0c 	.word	0x0f0e0d0c
   1625c:	0b0a0908 	.word	0x0b0a0908
   16260:	07060504 	.word	0x07060504
   16264:	03020100 	.word	0x03020100
   16268:	0f0e0d0c 	.word	0x0f0e0d0c
   1626c:	0b0a0908 	.word	0x0b0a0908
   16270:	07060504 	.word	0x07060504
   16274:	03020100 	.word	0x03020100
   16278:	63256325 	.word	0x63256325
   1627c:	2e2e2e2e 	.word	0x2e2e2e2e
   16280:	2e2e2e2e 	.word	0x2e2e2e2e
   16284:	2e2e2e2e 	.word	0x2e2e2e2e
   16288:	6325      	.short	0x6325
   1628a:	00          	.byte	0x00
   1628b:	25          	.byte	0x25
   1628c:	33302563 	.word	0x33302563
   16290:	63256578 	.word	0x63256578
   16294:	00          	.byte	0x00
   16295:	25          	.byte	0x25
   16296:	2563      	.short	0x2563
   16298:	5f783330 	.word	0x5f783330
   1629c:	2e2e2e2e 	.word	0x2e2e2e2e
   162a0:	25006325 	.word	0x25006325
   162a4:	33302563 	.word	0x33302563
   162a8:	23006578 	.word	0x23006578
   162ac:	23200020 	.word	0x23200020
   162b0:	38302500 	.word	0x38302500
   162b4:	72670078 	.word	0x72670078
   162b8:	735f6469 	.word	0x735f6469
   162bc:	3a3a7379 	.word	0x3a3a7379
   162c0:	63656863 	.word	0x63656863
   162c4:	6d75736b 	.word	0x6d75736b
   162c8:	65684300 	.word	0x65684300
   162cc:	75736b63 	.word	0x75736b63
   162d0:	6552206d 	.word	0x6552206d
   162d4:	432f6461 	.word	0x432f6461
   162d8:	75636c61 	.word	0x75636c61
   162dc:	6574616c 	.word	0x6574616c
   162e0:	63617000 	.word	0x63617000
   162e4:	7b74656b 	.word	0x7b74656b
   162e8:	202c6425 	.word	0x202c6425
   162ec:	202c6425 	.word	0x202c6425
   162f0:	202c6425 	.word	0x202c6425
   162f4:	202c6425 	.word	0x202c6425
   162f8:	202c6425 	.word	0x202c6425
   162fc:	202c6425 	.word	0x202c6425
   16300:	202c6425 	.word	0x202c6425
   16304:	207d6425 	.word	0x207d6425
   16308:	64616552 	.word	0x64616552
   1630c:	6425203a 	.word	0x6425203a
   16310:	6143202c 	.word	0x6143202c
   16314:	6c75636c 	.word	0x6c75636c
   16318:	3a657461 	.word	0x3a657461
   1631c:	00642520 	.word	0x00642520
   16320:	63656843 	.word	0x63656843
   16324:	6d75736b 	.word	0x6d75736b
   16328:	69725720 	.word	0x69725720
   1632c:	432f6574 	.word	0x432f6574
   16330:	75636c61 	.word	0x75636c61
   16334:	6574616c 	.word	0x6574616c
   16338:	65684300 	.word	0x65684300
   1633c:	75736b63 	.word	0x75736b63
   16340:	764f206d 	.word	0x764f206d
   16344:	72777265 	.word	0x72777265
   16348:	00657469 	.word	0x00657469
   1634c:	61726150 	.word	0x61726150
   16350:	72706170 	.word	0x72706170
   16354:	73616b69 	.word	0x73616b69
   16358:	00          	.byte	0x00
   16359:	25          	.byte	0x25
   1635a:	2563      	.short	0x2563
   1635c:	5f783330 	.word	0x5f783330
   16360:	2e2e2e2e 	.word	0x2e2e2e2e
   16364:	02002e2e 	.word	0x02002e2e
   16368:	65313430 	.word	0x65313430
   1636c:	5428707b 	.word	0x5428707b
   16370:	307d2930 	.word	0x307d2930
   16374:	28707b31 	.word	0x28707b31
   16378:	7d29315a 	.word	0x7d29315a
   1637c:	5a28707b 	.word	0x5a28707b
   16380:	7b7d2932 	.word	0x7b7d2932
   16384:	335a2870 	.word	0x335a2870
   16388:	00037d29 	.word	0x00037d29
   1638c:	30303002 	.word	0x30303002
   16390:	39303065 	.word	0x39303065
   16394:	28707b30 	.word	0x28707b30
   16398:	7d293054 	.word	0x7d293054
   1639c:	5428707b 	.word	0x5428707b
   163a0:	037d2932 	.word	0x037d2932
   163a4:	30343002 	.word	0x30343002
   163a8:	28707b65 	.word	0x28707b65
   163ac:	7d293054 	.word	0x7d293054
   163b0:	707b3130 	.word	0x707b3130
   163b4:	29325428 	.word	0x29325428
   163b8:	0200037d 	.word	0x0200037d
   163bc:	65303030 	.word	0x65303030
   163c0:	30383030 	.word	0x30383030
   163c4:	5428707b 	.word	0x5428707b
   163c8:	7b7d2930 	.word	0x7b7d2930
   163cc:	32542870 	.word	0x32542870
   163d0:	02037d29 	.word	0x02037d29
   163d4:	65303430 	.word	0x65303430
   163d8:	5428707b 	.word	0x5428707b
   163dc:	307d2930 	.word	0x307d2930
   163e0:	28707b31 	.word	0x28707b31
   163e4:	7d293254 	.word	0x7d293254
   163e8:	30020003 	.word	0x30020003
   163ec:	30653030 	.word	0x30653030
   163f0:	7b306230 	.word	0x7b306230
   163f4:	30542870 	.word	0x30542870
   163f8:	707b7d29 	.word	0x707b7d29
   163fc:	29325428 	.word	0x29325428
   16400:	3002037d 	.word	0x3002037d
   16404:	7b653034 	.word	0x7b653034
   16408:	30542870 	.word	0x30542870
   1640c:	31307d29 	.word	0x31307d29
   16410:	5428707b 	.word	0x5428707b
   16414:	037d2932 	.word	0x037d2932
   16418:	34300200 	.word	0x34300200
   1641c:	707b6531 	.word	0x707b6531
   16420:	29305428 	.word	0x29305428
   16424:	7b31307d 	.word	0x7b31307d
   16428:	315a2870 	.word	0x315a2870
   1642c:	707b7d29 	.word	0x707b7d29
   16430:	29325a28 	.word	0x29325a28
   16434:	28707b7d 	.word	0x28707b7d
   16438:	7d29335a 	.word	0x7d29335a
   1643c:	34300203 	.word	0x34300203
   16440:	707b6531 	.word	0x707b6531
   16444:	29305428 	.word	0x29305428
   16448:	7b32307d 	.word	0x7b32307d
   1644c:	315a2870 	.word	0x315a2870
   16450:	707b7d29 	.word	0x707b7d29
   16454:	29325a28 	.word	0x29325a28
   16458:	28707b7d 	.word	0x28707b7d
   1645c:	7d29335a 	.word	0x7d29335a
   16460:	30020003 	.word	0x30020003
   16464:	30653030 	.word	0x30653030
   16468:	7b306230 	.word	0x7b306230
   1646c:	30542870 	.word	0x30542870
   16470:	707b7d29 	.word	0x707b7d29
   16474:	29385428 	.word	0x29385428
   16478:	4923037d 	.word	0x4923037d
   1647c:	305a7b46 	.word	0x305a7b46
   16480:	7d333d3d 	.word	0x7d333d3d
   16484:	02485423 	.word	0x02485423
   16488:	65313430 	.word	0x65313430
   1648c:	5428707b 	.word	0x5428707b
   16490:	307d2930 	.word	0x307d2930
   16494:	28707b31 	.word	0x28707b31
   16498:	7d293854 	.word	0x7d293854
   1649c:	5a28707b 	.word	0x5a28707b
   164a0:	7b7d2932 	.word	0x7b7d2932
   164a4:	32312870 	.word	0x32312870
   164a8:	38542d38 	.word	0x38542d38
   164ac:	23037d29 	.word	0x23037d29
   164b0:	45234c45 	.word	0x45234c45
   164b4:	3430024e 	.word	0x3430024e
   164b8:	707b6530 	.word	0x707b6530
   164bc:	29305428 	.word	0x29305428
   164c0:	7b31307d 	.word	0x7b31307d
   164c4:	38542870 	.word	0x38542870
   164c8:	00037d29 	.word	0x00037d29
   164cc:	30303002 	.word	0x30303002
   164d0:	62303065 	.word	0x62303065
   164d4:	28707b30 	.word	0x28707b30
   164d8:	7d293054 	.word	0x7d293054
   164dc:	5428707b 	.word	0x5428707b
   164e0:	037d2938 	.word	0x037d2938
   164e4:	30343002 	.word	0x30343002
   164e8:	28707b65 	.word	0x28707b65
   164ec:	7d293054 	.word	0x7d293054
   164f0:	707b3130 	.word	0x707b3130
   164f4:	29385428 	.word	0x29385428
   164f8:	0200037d 	.word	0x0200037d
   164fc:	65303030 	.word	0x65303030
   16500:	30393030 	.word	0x30393030
   16504:	5428707b 	.word	0x5428707b
   16508:	7b7d2930 	.word	0x7b7d2930
   1650c:	32542870 	.word	0x32542870
   16510:	02037d29 	.word	0x02037d29
   16514:	65303430 	.word	0x65303430
   16518:	5428707b 	.word	0x5428707b
   1651c:	307d2930 	.word	0x307d2930
   16520:	28707b32 	.word	0x28707b32
   16524:	7d293254 	.word	0x7d293254
   16528:	30020003 	.word	0x30020003
   1652c:	30653030 	.word	0x30653030
   16530:	7b303830 	.word	0x7b303830
   16534:	30542870 	.word	0x30542870
   16538:	707b7d29 	.word	0x707b7d29
   1653c:	29325428 	.word	0x29325428
   16540:	3002037d 	.word	0x3002037d
   16544:	7b653034 	.word	0x7b653034
   16548:	30542870 	.word	0x30542870
   1654c:	32307d29 	.word	0x32307d29
   16550:	5428707b 	.word	0x5428707b
   16554:	037d2932 	.word	0x037d2932
   16558:	67655200 	.word	0x67655200
   1655c:	65747369 	.word	0x65747369
   16560:	63412072 	.word	0x63412072
   16564:	6e6f6974 	.word	0x6e6f6974
   16568:	65764500 	.word	0x65764500
   1656c:	4e20746e 	.word	0x4e20746e
   16570:	4620746f 	.word	0x4620746f
   16574:	646e756f 	.word	0x646e756f
   16578:	73452000 	.word	0x73452000
   1657c:	65706163 	.word	0x65706163
   16580:	68432064 	.word	0x68432064
   16584:	46207261 	.word	0x46207261
   16588:	646e756f 	.word	0x646e756f
   1658c:	30020020 	.word	0x30020020
   16590:	7b653035 	.word	0x7b653035
   16594:	305a2870 	.word	0x305a2870
   16598:	707b7d29 	.word	0x707b7d29
   1659c:	29305428 	.word	0x29305428
   165a0:	3030307d 	.word	0x3030307d
   165a4:	02000330 	.word	0x02000330
   165a8:	65303530 	.word	0x65303530
   165ac:	5a28707b 	.word	0x5a28707b
   165b0:	7b7d2930 	.word	0x7b7d2930
   165b4:	30542870 	.word	0x30542870
   165b8:	34307d29 	.word	0x34307d29
   165bc:	5428707b 	.word	0x5428707b
   165c0:	037d2932 	.word	0x037d2932
   165c4:	35300200 	.word	0x35300200
   165c8:	707b6530 	.word	0x707b6530
   165cc:	29305a28 	.word	0x29305a28
   165d0:	28707b7d 	.word	0x28707b7d
   165d4:	7d293054 	.word	0x7d293054
   165d8:	707b3530 	.word	0x707b3530
   165dc:	29325428 	.word	0x29325428
   165e0:	0200037d 	.word	0x0200037d
   165e4:	65303530 	.word	0x65303530
   165e8:	5a28707b 	.word	0x5a28707b
   165ec:	7b7d2930 	.word	0x7b7d2930
   165f0:	30542870 	.word	0x30542870
   165f4:	31307d29 	.word	0x31307d29
   165f8:	5428707b 	.word	0x5428707b
   165fc:	037d2932 	.word	0x037d2932
   16600:	35300200 	.word	0x35300200
   16604:	707b6530 	.word	0x707b6530
   16608:	29305a28 	.word	0x29305a28
   1660c:	28707b7d 	.word	0x28707b7d
   16610:	7d293054 	.word	0x7d293054
   16614:	707b3130 	.word	0x707b3130
   16618:	29355428 	.word	0x29355428
   1661c:	0200037d 	.word	0x0200037d
   16620:	65303530 	.word	0x65303530
   16624:	5a28707b 	.word	0x5a28707b
   16628:	7b7d2930 	.word	0x7b7d2930
   1662c:	30542870 	.word	0x30542870
   16630:	64307d29 	.word	0x64307d29
   16634:	5428707b 	.word	0x5428707b
   16638:	037d2935 	.word	0x037d2935
   1663c:	6e795300 	.word	0x6e795300
   16640:	20786174 	.word	0x20786174
   16644:	6f727245 	.word	0x6f727245
   16648:	000d2172 	.word	0x000d2172
   1664c:	20009150 	.word	0x20009150
   16650:	20019870 	.word	0x20019870
   16654:	200138d4 	.word	0x200138d4
   16658:	200102d4 	.word	0x200102d4
   1665c:	682f2e2e 	.word	0x682f2e2e
   16660:	732f6c61 	.word	0x732f6c61
   16664:	682f6372 	.word	0x682f6372
   16668:	695f6c61 	.word	0x695f6c61
   1666c:	00632e6f 	.word	0x00632e6f
   16670:	682f2e2e 	.word	0x682f2e2e
   16674:	732f6c61 	.word	0x732f6c61
   16678:	682f6372 	.word	0x682f6372
   1667c:	695f6c61 	.word	0x695f6c61
   16680:	6d5f6332 	.word	0x6d5f6332
   16684:	7973615f 	.word	0x7973615f
   16688:	632e636e 	.word	0x632e636e
   1668c:	00          	.byte	0x00
   1668d:	2e          	.byte	0x2e
   1668e:	2f2e      	.short	0x2f2e
   16690:	2f6c7068 	.word	0x2f6c7068
   16694:	2f746477 	.word	0x2f746477
   16698:	5f6c7068 	.word	0x5f6c7068
   1669c:	2e746477 	.word	0x2e746477
   166a0:	0063      	.short	0x0063
   166a2:	2e2e      	.short	0x2e2e
   166a4:	6c61682f 	.word	0x6c61682f
   166a8:	6372732f 	.word	0x6372732f
   166ac:	6c61682f 	.word	0x6c61682f
   166b0:	6970735f 	.word	0x6970735f
   166b4:	645f6d5f 	.word	0x645f6d5f
   166b8:	632e616d 	.word	0x632e616d
   166bc:	00000000 	.word	0x00000000

000166c0 <user_mux_confs>:
	...
   166ec:	04030201 04030201 00000000 00000000     ................
	...

00016704 <channel_confs>:
   16704:	05230522 05250524 00000000 00000000     ".#.$.%.........
	...

00016744 <interrupt_cfg>:
   16744:	00000002 00000002 00000002 00000002     ................
	...
   167c4:	682f2e2e 712f6c70 2f697073 5f6c7068     ../hpl/qspi/hpl_
   167d4:	69707371 2e00632e 70682f2e 766e2f6c     qspi.c.../hpl/nv
   167e4:	7274636d 70682f6c 766e5f6c 7274636d     mctrl/hpl_nvmctr
   167f4:	00632e6c 682f2e2e 732f6c61 682f6372     l.c.../hal/src/h
   16804:	745f6c61 72656d69 0000632e              al_timer.c..

00016810 <_usb_ep_cfgs>:
   16810:	20008928 00000000 00000040 00000000     (.. ....@.......
	...
   16828:	20008920 00000000 00000008 200088e0      .. ........... 
   16838:	200088d8 00080040 00000000 00000000     ... @...........
	...
   16850:	20008898 00400000 20726d54 00637653     ... ..@.Tmr Svc.

00016860 <mouse_report_desc>:
   16860:	02090105 010901a1 090500a1 03290119     ..............).
   16870:	01250015 03950175 05750281 01810195     ..%.u.....u.....
   16880:	30090105 38093109 7f258115 03950875     ...0.1.8..%.u...
   16890:	c0c00681                                ....

00016894 <_cfgs>:
   16894:	00200600 08068000 00200400 08068000     .. ....... .....
   168a4:	00201000 08068000 00200c00 08068000     .. ....... .....
	...
   168c4:	00200b00 14000003 00200a00 08000002     .. ....... .....
   168d4:	00201300 14000003 00000000 00000000     .. .............
	...
   16984:	00005400 1c000000 00005300 0c000000     .T.......S......
   16994:	682f2e2e 732f6c61 682f6372 615f6c61     ../hal/src/hal_a
   169a4:	615f6364 636e7973 2e00632e 61682f2e     dc_async.c.../ha
   169b4:	72732f6c 61682f63 61725f6c 735f646e     l/src/hal_rand_s
   169c4:	2e636e79 2e2e0063 6c70682f 6e72742f     ync.c.../hpl/trn
   169d4:	70682f67 72745f6c 632e676e               g/hpl_trng.c.

000169e1 <keyboard_report_desc>:
   169e1:	06090105 070501a1 e729e019 01250015     ..........)...%.
   169f1:	08950175 01810281 65290019 65250015     u.........)e..%e
   16a01:	06950875 08050081 05290119 01250015     u.........)...%.
   16a11:	05950175 03950291 2ec00191 61682f2e     u............/ha
   16a21:	72732f6c 61682f63 73755f6c 5f747261     l/src/hal_usart_
   16a31:	636e7973 2e00632e 61682f2e 72732f6c     sync.c.../hal/sr
   16a41:	61682f63 6c665f6c 2e687361 2e2e0063     c/hal_flash.c...
   16a51:	6c61682f 6372732f 6c61682f 6970735f     /hal/src/hal_spi
   16a61:	615f6d5f 636e7973 2e00632e 61682f2e     _m_async.c.../ha
   16a71:	72732f6c 61682f63 72635f6c 79735f63     l/src/hal_crc_sy
   16a81:	632e636e                                 nc.c.

00016a86 <CSWTCH.37>:
   16a86:	010101ed                                 .......

00016a8d <CSWTCH.40>:
   16a8d:	010100ed 2ef00201 61682f2e 74752f6c     ........./hal/ut
   16a9d:	2f736c69 2f637273 6c697475 696c5f73     ils/src/utils_li
   16aad:	632e7473 2f2e2e00 2f6c7068 2f637472     st.c.../hpl/rtc/
   16abd:	5f6c7068 2e637472 2e2e0063 6c61682f     hpl_rtc.c.../hal
   16acd:	636e692f 6564756c 6c61682f 7464775f     /include/hal_wdt
   16add:	2e00682e 61682f2e 72732f6c 61682f63     .h.../hal/src/ha
   16aed:	73755f6c 5f747261 6e797361 00632e63     l_usart_async.c.
   16afd:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
   16b0d:	65735f6c 6d6f6372 0000632e 00400030     l_sercom.c..0.@.
   16b1d:	00400034 00410120 00410140 00430000     4.@. .A.@.A...C.
   16b2d:	00430004 00430008                        ..C...C...C

00016b38 <sercomspi_regs>:
   16b38:	3020000c 00020000 00000000 01ff0005     .. 0............
   16b48:	20000c03 00000000 00000000 ff000600     ... ............
   16b58:	00000701                                ....

00016b5c <_i2cms>:
   16b5c:	00000005 00200014 00000100 0000e6e5     ...... .........
   16b6c:	00d70000 02dc6c00                       .....l..

00016b74 <_usarts>:
   16b74:	00000000 40100004 00030000 00700002     .......@......p.
   16b84:	0000aaaa 00000000 00000001 40100004     ...............@
   16b94:	00030000 00700002 0000aaaa 00000000     ......p.........
   16ba4:	00000002 40100004 00030000 00700002     .......@......p.
   16bb4:	00005555 00000000 00000004 40100004     UU.............@
   16bc4:	00030000 00700002 0000aaaa 00000000     ......p.........
   16bd4:	00000006 40100004 00030000 00700002     .......@......p.
   16be4:	0000aaaa 00000000 682f2e2e 752f6c61     ........../hal/u
   16bf4:	736c6974 6372732f 6974752f 725f736c     tils/src/utils_r
   16c04:	62676e69 65666675 00632e72 6d617845     ingbuffer.c.Exam
   16c14:	54656c70 206b7361 3f3f3f3f 202e2e2e     pleTask ????... 
   16c24:	0d206425 494d000a 203a4944 78323025     %d ...MIDI: %02x
   16c34:	32302520 30252078 25207832 0a783230      %02x %02x %02x.
   16c44:	61745300 6f206b63 66726576 20776f6c     .Stack overflow 
   16c54:	74206e69 206b7361 0a0d7325 61745300     in task %s...Sta
   16c64:	49207472 6974696e 7a696c61 74006465     rt Initialized.t
   16c74:	2e747365 2e75636d 41535441 3135444d     est.mcu.ATSAMD51
   16c84:	4130324e 6574000d 682e7473 67666377     N20A..test.hwcfg
   16c94:	0d64252e 6574000a 732e7473 61697265     .%d...test.seria
   16ca4:	2e6f6e6c 78383025 38302520 30252078     lno.%08x %08x %0
   16cb4:	25207838 0d783830 6574000a 622e7473     8x %08x...test.b
   16cc4:	646e756f 2e797261 002e6425 6c6c6548     oundary.%d..Hell
   16cd4:	6425206f 20642520 25206425 35440064     o %d %d %d %d.D5
   16ce4:	6e492031 43007469 6f706d6f 65746973     1 Init.Composite
   16cf4:	76654420 20656369 74696e49 696c6169      Device Initiali
   16d04:	0064657a 64697247 646f4d20 20656c75     zed.Grid Module 
   16d14:	74696e49 696c6169 0064657a 65746e45     Initialized.Ente
   16d24:	676e6972 69614d20 6f4c206e 5500706f     ring Main Loop.U
   16d34:	54206273 006b7361 206d764e 6b736154     sb Task.Nvm Task
   16d44:	20695500 6b736154 63655200 65766965     .Ui Task.Receive
   16d54:	73615420 6e49006b 6e756f62 61542064      Task.Inbound Ta
   16d64:	4f006b73 6f627475 20646e75 6b736154     sk.Outbound Task
   16d74:	64654c00 73615420 7845006b 6c706d61     .Led Task.Exampl
   16d84:	6f430065 736f706d 20657469 69766544     e.Composite Devi
   16d94:	43206563 656e6e6f 64657463 726f4600     ce Connected.For
   16da4:	72657665 000d2021 682f2e2e 732f6c61     ever! ..../hal/s
   16db4:	682f6372 715f6c61 5f697073 2e616d64     rc/hal_qspi_dma.
   16dc4:	44490063 0900454c 25096325 75250975     c.IDLE..%c.%u.%u
   16dd4:	0d752509 2e2e000a 6c70682f 6364612f     .%u...../hpl/adc
   16de4:	6c70682f 6364615f 0000632e              /hpl_adc.c..

00016df0 <_adcs>:
   16df0:	01000000 0003000c 00041807 00000000     ................
   16e00:	0014080b 00010000 000c0100 18040003     ................
   16e10:	00000004 080b0000 00000014 752f2e2e     ............../u
   16e20:	642f6273 63697665 73752f65 2e636462     sb/device/usbdc.
   16e30:	2e2e0063 6c70682f 2f63742f 5f6c7068     c.../hpl/tc/hpl_
   16e40:	632e6374 00000000 40003800 40003c00     tc.c.....8.@.<.@
   16e50:	4101a000 4101c000 42001400 42001800     ...A...A...B...B
   16e60:	43001400 43001800                       ...C...C

00016e68 <_tcs>:
   16e68:	006b0000 00000308 00000021 00003a98     ..k.....!....:..
   16e78:	00000000 006c0001 00000308 00000021     ......l.....!...
   16e88:	00003a98 00000000 006d0002 00000308     .:........m.....
   16e98:	00000021 00003a98 00000000 006e0003     !....:........n.
   16ea8:	00000308 00000021 00003a98 00000000     ....!....:......

00016eb8 <_global_impure_ptr>:
   16eb8:	20000550                                P.. 

00016ebc <__sf_fake_stderr>:
	...

00016edc <__sf_fake_stdin>:
	...

00016efc <__sf_fake_stdout>:
	...
   16f1c:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   16f2c:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   16f3c:	31300046 35343332 39383736 64636261     F.0123456789abcd
   16f4c:	00006665                                ef..

00016f50 <_init>:
   16f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16f52:	bf00      	nop
   16f54:	bcf8      	pop	{r3, r4, r5, r6, r7}
   16f56:	bc08      	pop	{r3}
   16f58:	469e      	mov	lr, r3
   16f5a:	4770      	bx	lr

00016f5c <__frame_dummy_init_array_entry>:
   16f5c:	4289 0000                                   .B..

00016f60 <_fini>:
   16f60:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16f62:	bf00      	nop
   16f64:	bcf8      	pop	{r3, r4, r5, r6, r7}
   16f66:	bc08      	pop	{r3}
   16f68:	469e      	mov	lr, r3
   16f6a:	4770      	bx	lr

00016f6c <__do_global_dtors_aux_fini_array_entry>:
   16f6c:	4265 0000                                   eB..
