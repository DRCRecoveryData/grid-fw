
AtmelStart.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00013754  00004000  00004000  00004000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000005b0  20000000  00017754  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bkupram      00000000  47000000  47000000  000205b0  2**0
                  CONTENTS
  3 .qspi         00000000  04000000  04000000  000205b0  2**0
                  CONTENTS
  4 .bss          0001ca34  200005b0  00017d10  000205b0  2**4
                  ALLOC
  5 .stack        00010004  2001cfe4  00034744  000205b0  2**0
                  ALLOC
  6 .ARM.attributes 0000002e  00000000  00000000  000205b0  2**0
                  CONTENTS, READONLY
  7 .comment      0000004c  00000000  00000000  000205de  2**0
                  CONTENTS, READONLY
  8 .debug_info   000b7827  00000000  00000000  0002062a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_abbrev 000117a5  00000000  00000000  000d7e51  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_loc    00034c27  00000000  00000000  000e95f6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_aranges 00002c40  00000000  00000000  0011e21d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00008f40  00000000  00000000  00120e5d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_macro  00050dd0  00000000  00000000  00129d9d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_line   00062379  00000000  00000000  0017ab6d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_str    00128b14  00000000  00000000  001dcee6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_frame  00008d5c  00000000  00000000  003059fc  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00004000 <exception_table>:
    4000:	e8 cf 02 20 9d 3a 01 00 99 3a 01 00 99 3a 01 00     ... .:...:...:..
    4010:	99 3a 01 00 99 3a 01 00 99 3a 01 00 00 00 00 00     .:...:...:......
	...
    402c:	91 bb 00 00 99 3a 01 00 00 00 00 00 21 bc 00 00     .....:......!...
    403c:	85 bc 00 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .....:...:...:..
    404c:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    405c:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    406c:	95 03 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .....:...:...:..
    407c:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    408c:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    409c:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    40ac:	99 3a 01 00 99 3a 01 00 61 ca 00 00 8d ca 00 00     .:...:..a.......
    40bc:	11 ec 00 00 19 ec 00 00 21 ec 00 00 29 ec 00 00     ........!...)...
    40cc:	31 ec 00 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     1....:...:...:..
    40dc:	99 3a 01 00 99 3a 01 00 99 3a 01 00 00 00 00 00     .:...:...:......
	...
    40f4:	89 e7 00 00 05 1c 01 00 15 1c 01 00 1d 1c 01 00     ................
    4104:	25 1c 01 00 2d 1c 01 00 3d 1c 01 00 45 1c 01 00     %...-...=...E...
    4114:	4d 1c 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     M....:...:...:..
    4124:	99 3a 01 00 55 1c 01 00 99 1c 01 00 a1 1c 01 00     .:..U...........
    4134:	a9 1c 01 00 b1 1c 01 00 c1 1c 01 00 c9 1c 01 00     ................
    4144:	d1 1c 01 00 d9 1c 01 00 69 1d 01 00 71 1d 01 00     ........i...q...
    4154:	79 1d 01 00 81 1d 01 00 91 1d 01 00 99 1d 01 00     y...............
    4164:	a1 1d 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .....:...:...:..
    4174:	99 3a 01 00 00 00 00 00 00 00 00 00 25 e3 00 00     .:..........%...
    4184:	2d e3 00 00 35 e3 00 00 3d e3 00 00 00 00 00 00     -...5...=.......
    4194:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    41a4:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    41b4:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    41c4:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    41d4:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    41e4:	99 3a 01 00 99 3a 01 00 6d 44 01 00 7d 44 01 00     .:...:..mD..}D..
    41f4:	8d 44 01 00 9d 44 01 00 99 3a 01 00 99 3a 01 00     .D...D...:...:..
    4204:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    4214:	99 3a 01 00 69 3a 01 00 79 3a 01 00 81 3a 01 00     .:..i:..y:...:..
    4224:	91 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    4234:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    4244:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..
    4254:	99 3a 01 00 99 3a 01 00 99 3a 01 00 99 3a 01 00     .:...:...:...:..

00004264 <__do_global_dtors_aux>:
    4264:	b510      	push	{r4, lr}
    4266:	4c05      	ldr	r4, [pc, #20]	; (427c <__do_global_dtors_aux+0x18>)
    4268:	7823      	ldrb	r3, [r4, #0]
    426a:	b933      	cbnz	r3, 427a <__do_global_dtors_aux+0x16>
    426c:	4b04      	ldr	r3, [pc, #16]	; (4280 <__do_global_dtors_aux+0x1c>)
    426e:	b113      	cbz	r3, 4276 <__do_global_dtors_aux+0x12>
    4270:	4804      	ldr	r0, [pc, #16]	; (4284 <__do_global_dtors_aux+0x20>)
    4272:	f3af 8000 	nop.w
    4276:	2301      	movs	r3, #1
    4278:	7023      	strb	r3, [r4, #0]
    427a:	bd10      	pop	{r4, pc}
    427c:	200005b0 	.word	0x200005b0
    4280:	00000000 	.word	0x00000000
    4284:	00017754 	.word	0x00017754

00004288 <frame_dummy>:
    4288:	b508      	push	{r3, lr}
    428a:	4b03      	ldr	r3, [pc, #12]	; (4298 <frame_dummy+0x10>)
    428c:	b11b      	cbz	r3, 4296 <frame_dummy+0xe>
    428e:	4903      	ldr	r1, [pc, #12]	; (429c <frame_dummy+0x14>)
    4290:	4803      	ldr	r0, [pc, #12]	; (42a0 <frame_dummy+0x18>)
    4292:	f3af 8000 	nop.w
    4296:	bd08      	pop	{r3, pc}
    4298:	00000000 	.word	0x00000000
    429c:	200005b4 	.word	0x200005b4
    42a0:	00017754 	.word	0x00017754

000042a4 <audio_midi_req>:
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */

static int32_t audio_midi_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    42a4:	b410      	push	{r4}
		
	//return ERR_NOT_FOUND;	
		
	if ((0x81 == req->bmRequestType) && (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1])) {
    42a6:	780b      	ldrb	r3, [r1, #0]
    42a8:	2b81      	cmp	r3, #129	; 0x81
    42aa:	d110      	bne.n	42ce <audio_midi_req+0x2a>
    42ac:	4b1a      	ldr	r3, [pc, #104]	; (4318 <audio_midi_req+0x74>)
    42ae:	888a      	ldrh	r2, [r1, #4]
    42b0:	7919      	ldrb	r1, [r3, #4]
    42b2:	4291      	cmp	r1, r2
    42b4:	4619      	mov	r1, r3
    42b6:	d002      	beq.n	42be <audio_midi_req+0x1a>
    42b8:	795b      	ldrb	r3, [r3, #5]
    42ba:	4293      	cmp	r3, r2
    42bc:	d128      	bne.n	4310 <audio_midi_req+0x6c>
	return usbdc_xfer(ep, _audiodf_midi_funcd.audio_desc, _audiodf_midi_funcd.audio_desc[0], false);
    42be:	6809      	ldr	r1, [r1, #0]
    42c0:	780a      	ldrb	r2, [r1, #0]
    42c2:	2300      	movs	r3, #0
			switch (req->bRequest) {
				case 0x03: /* Get Protocol */
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
				case 0x0B: /* Set Protocol */
				_audiodf_midi_funcd.protocol = req->wValue;
				return usbdc_xfer(ep, NULL, 0, 0);
    42c4:	4c15      	ldr	r4, [pc, #84]	; (431c <audio_midi_req+0x78>)
    42c6:	46a4      	mov	ip, r4
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    42c8:	f85d 4b04 	ldr.w	r4, [sp], #4
				return usbdc_xfer(ep, NULL, 0, 0);
    42cc:	4760      	bx	ip
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    42ce:	f3c3 1341 	ubfx	r3, r3, #5, #2
    42d2:	2b01      	cmp	r3, #1
    42d4:	d11c      	bne.n	4310 <audio_midi_req+0x6c>
		if (req->wIndex == _audiodf_midi_funcd.func_iface[0] || req->wIndex == _audiodf_midi_funcd.func_iface[1]) {
    42d6:	4b10      	ldr	r3, [pc, #64]	; (4318 <audio_midi_req+0x74>)
    42d8:	888a      	ldrh	r2, [r1, #4]
    42da:	791c      	ldrb	r4, [r3, #4]
    42dc:	4294      	cmp	r4, r2
    42de:	461c      	mov	r4, r3
    42e0:	d002      	beq.n	42e8 <audio_midi_req+0x44>
    42e2:	795b      	ldrb	r3, [r3, #5]
    42e4:	4293      	cmp	r3, r2
    42e6:	d113      	bne.n	4310 <audio_midi_req+0x6c>
			switch (req->bRequest) {
    42e8:	784b      	ldrb	r3, [r1, #1]
    42ea:	2b03      	cmp	r3, #3
    42ec:	d006      	beq.n	42fc <audio_midi_req+0x58>
    42ee:	2b0b      	cmp	r3, #11
    42f0:	d008      	beq.n	4304 <audio_midi_req+0x60>
    42f2:	f06f 000c 	mvn.w	r0, #12
}
    42f6:	f85d 4b04 	ldr.w	r4, [sp], #4
    42fa:	4770      	bx	lr
				return usbdc_xfer(ep, &_audiodf_midi_funcd.protocol, 1, 0);
    42fc:	4908      	ldr	r1, [pc, #32]	; (4320 <audio_midi_req+0x7c>)
    42fe:	2300      	movs	r3, #0
    4300:	2201      	movs	r2, #1
    4302:	e7df      	b.n	42c4 <audio_midi_req+0x20>
				_audiodf_midi_funcd.protocol = req->wValue;
    4304:	884b      	ldrh	r3, [r1, #2]
    4306:	7223      	strb	r3, [r4, #8]
				return usbdc_xfer(ep, NULL, 0, 0);
    4308:	2300      	movs	r3, #0
    430a:	461a      	mov	r2, r3
    430c:	4619      	mov	r1, r3
    430e:	e7d9      	b.n	42c4 <audio_midi_req+0x20>
			return ERR_NOT_FOUND; // Never hit breakpoint here
    4310:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    4314:	e7ef      	b.n	42f6 <audio_midi_req+0x52>
    4316:	bf00      	nop
    4318:	200005cc 	.word	0x200005cc
    431c:	00013c9d 	.word	0x00013c9d
    4320:	200005d4 	.word	0x200005d4

00004324 <audio_midi_ctrl>:
	switch (ctrl) {
    4324:	2901      	cmp	r1, #1
{
    4326:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    432a:	460d      	mov	r5, r1
    432c:	4614      	mov	r4, r2
	switch (ctrl) {
    432e:	d070      	beq.n	4412 <audio_midi_ctrl+0xee>
    4330:	2902      	cmp	r1, #2
    4332:	f000 8092 	beq.w	445a <audio_midi_ctrl+0x136>
    4336:	2900      	cmp	r1, #0
    4338:	f040 8092 	bne.w	4460 <audio_midi_ctrl+0x13c>
		return audio_midi_enable(drv, (struct usbd_descriptors *)param);
    433c:	6886      	ldr	r6, [r0, #8]
	ifc = desc->sod;
    433e:	f8df 8148 	ldr.w	r8, [pc, #328]	; 4488 <audio_midi_ctrl+0x164>
    4342:	6810      	ldr	r0, [r2, #0]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    4344:	f8df 9144 	ldr.w	r9, [pc, #324]	; 448c <audio_midi_ctrl+0x168>
    4348:	1d37      	adds	r7, r6, #4
		if (NULL == ifc) {
    434a:	b920      	cbnz	r0, 4356 <audio_midi_ctrl+0x32>
			return ERR_NOT_FOUND;
    434c:	f06f 0009 	mvn.w	r0, #9
}
    4350:	b003      	add	sp, #12
    4352:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    4356:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    4358:	7882      	ldrb	r2, [r0, #2]
		if (AUDIO_AC_SUBCLASS == ifc_desc.bInterfaceClass || AUDIO_MS_SUBCLASS == ifc_desc.bInterfaceClass) {			
    435a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    435e:	2b01      	cmp	r3, #1
    4360:	d1f4      	bne.n	434c <audio_midi_ctrl+0x28>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    4362:	783b      	ldrb	r3, [r7, #0]
    4364:	429a      	cmp	r2, r3
    4366:	d07e      	beq.n	4466 <audio_midi_ctrl+0x142>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    4368:	2bff      	cmp	r3, #255	; 0xff
    436a:	d17f      	bne.n	446c <audio_midi_ctrl+0x148>
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    436c:	2d01      	cmp	r5, #1
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    436e:	f807 2b01 	strb.w	r2, [r7], #1
		if (i == 1){ // i==1 because only the second interface has endpoint descriptors
    4372:	d009      	beq.n	4388 <audio_midi_ctrl+0x64>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);		
    4374:	6823      	ldr	r3, [r4, #0]
    4376:	6861      	ldr	r1, [r4, #4]
 *  \param[in] desc Byte pointer to the descriptor start address
 *  \return Byte pointer to the next descriptor
 */
static inline uint8_t *usb_desc_next(uint8_t *desc)
{
	return (desc + usb_desc_len(desc));
    4378:	7818      	ldrb	r0, [r3, #0]
    437a:	2204      	movs	r2, #4
    437c:	4418      	add	r0, r3
    437e:	47c0      	blx	r8
	for (i=0; i<2; i++){
    4380:	2d01      	cmp	r5, #1
    4382:	d042      	beq.n	440a <audio_midi_ctrl+0xe6>
    4384:	2501      	movs	r5, #1
    4386:	e7e0      	b.n	434a <audio_midi_ctrl+0x26>
			ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    4388:	6861      	ldr	r1, [r4, #4]
    438a:	f8df a104 	ldr.w	sl, [pc, #260]	; 4490 <audio_midi_ctrl+0x16c>
    438e:	2205      	movs	r2, #5
    4390:	47c0      	blx	r8
    4392:	4683      	mov	fp, r0
			while (NULL != ep) {
    4394:	f1bb 0f00 	cmp.w	fp, #0
    4398:	d0ec      	beq.n	4374 <audio_midi_ctrl+0x50>
				ep_desc.bEndpointAddress = ep[2];
    439a:	f89b 2002 	ldrb.w	r2, [fp, #2]
    439e:	f88d 2002 	strb.w	r2, [sp, #2]
				ep_desc.bmAttributes     = ep[3];
    43a2:	f89b 2003 	ldrb.w	r2, [fp, #3]
    43a6:	f88d 2003 	strb.w	r2, [sp, #3]
	return (ptr[0] + (ptr[1] << 8));
    43aa:	f89b 1005 	ldrb.w	r1, [fp, #5]
    43ae:	f89b 2004 	ldrb.w	r2, [fp, #4]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43b2:	4b31      	ldr	r3, [pc, #196]	; (4478 <audio_midi_ctrl+0x154>)
    43b4:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    43b8:	b292      	uxth	r2, r2
				ep_desc.wMaxPacketSize   = usb_get_u16(ep + 4);
    43ba:	f8ad 2004 	strh.w	r2, [sp, #4]
				usb_debug2[4] = ep_desc.wMaxPacketSize;
    43be:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    43c2:	b2d2      	uxtb	r2, r2
    43c4:	f889 2004 	strb.w	r2, [r9, #4]
				usb_debug2[0] = i;
    43c8:	2201      	movs	r2, #1
    43ca:	f889 2000 	strb.w	r2, [r9]
				if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    43ce:	f89d 0002 	ldrb.w	r0, [sp, #2]
    43d2:	f89d 1003 	ldrb.w	r1, [sp, #3]
    43d6:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    43da:	b292      	uxth	r2, r2
    43dc:	4798      	blx	r3
    43de:	2800      	cmp	r0, #0
    43e0:	d147      	bne.n	4472 <audio_midi_ctrl+0x14e>
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    43e2:	f89d 2002 	ldrb.w	r2, [sp, #2]
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    43e6:	f89d 0002 	ldrb.w	r0, [sp, #2]
				if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    43ea:	0613      	lsls	r3, r2, #24
					func_data->func_ep_in = ep_desc.bEndpointAddress;
    43ec:	b2c0      	uxtb	r0, r0
    43ee:	bf4c      	ite	mi
    43f0:	71b0      	strbmi	r0, [r6, #6]
					func_data->func_ep_out = ep_desc.bEndpointAddress;
    43f2:	71f0      	strbpl	r0, [r6, #7]
					usb_d_ep_enable(func_data->func_ep_out);
    43f4:	47d0      	blx	sl
				desc->sod = ep;
    43f6:	f8c4 b000 	str.w	fp, [r4]
	return (desc + usb_desc_len(desc));
    43fa:	f89b 0000 	ldrb.w	r0, [fp]
				ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    43fe:	6861      	ldr	r1, [r4, #4]
    4400:	4b1e      	ldr	r3, [pc, #120]	; (447c <audio_midi_ctrl+0x158>)
    4402:	4458      	add	r0, fp
    4404:	4798      	blx	r3
    4406:	4683      	mov	fp, r0
    4408:	e7c4      	b.n	4394 <audio_midi_ctrl+0x70>
	_audiodf_midi_funcd.enabled = true;
    440a:	4b1d      	ldr	r3, [pc, #116]	; (4480 <audio_midi_ctrl+0x15c>)
	return ERR_NONE;
    440c:	2000      	movs	r0, #0
	_audiodf_midi_funcd.enabled = true;
    440e:	745d      	strb	r5, [r3, #17]
	return ERR_NONE;
    4410:	e79e      	b.n	4350 <audio_midi_ctrl+0x2c>
		return audio_midi_disable(drv, (struct usbd_descriptors *)param);
    4412:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    4414:	b12a      	cbz	r2, 4422 <audio_midi_ctrl+0xfe>
		ifc_desc.bInterfaceClass = desc->sod[5];
    4416:	6813      	ldr	r3, [r2, #0]
		if ((AUDIO_AC_SUBCLASS != ifc_desc.bInterfaceClass) && (AUDIO_MS_SUBCLASS != ifc_desc.bInterfaceClass)) {
    4418:	795b      	ldrb	r3, [r3, #5]
    441a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    441e:	2b01      	cmp	r3, #1
    4420:	d194      	bne.n	434c <audio_midi_ctrl+0x28>
	if (func_data->func_iface[0] != 0xFF) {
    4422:	792b      	ldrb	r3, [r5, #4]
	if (func_data->func_ep_in != 0xFF) {
    4424:	79a8      	ldrb	r0, [r5, #6]
	if (func_data->func_iface[0] != 0xFF) {
    4426:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[0] = 0xFF;
    4428:	bf1c      	itt	ne
    442a:	23ff      	movne	r3, #255	; 0xff
    442c:	712b      	strbne	r3, [r5, #4]
	if (func_data->func_iface[1] != 0xFF) {
    442e:	796b      	ldrb	r3, [r5, #5]
    4430:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface[1] = 0xFF;
    4432:	bf1c      	itt	ne
    4434:	23ff      	movne	r3, #255	; 0xff
    4436:	716b      	strbne	r3, [r5, #5]
	if (func_data->func_ep_in != 0xFF) {
    4438:	28ff      	cmp	r0, #255	; 0xff
    443a:	d003      	beq.n	4444 <audio_midi_ctrl+0x120>
		usb_d_ep_deinit(func_data->func_ep_in);
    443c:	4b11      	ldr	r3, [pc, #68]	; (4484 <audio_midi_ctrl+0x160>)
    443e:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    4440:	23ff      	movs	r3, #255	; 0xff
    4442:	71ab      	strb	r3, [r5, #6]
	if (func_data->func_ep_out != 0xFF) {
    4444:	79e8      	ldrb	r0, [r5, #7]
    4446:	28ff      	cmp	r0, #255	; 0xff
    4448:	d003      	beq.n	4452 <audio_midi_ctrl+0x12e>
		usb_d_ep_deinit(func_data->func_ep_out);
    444a:	4b0e      	ldr	r3, [pc, #56]	; (4484 <audio_midi_ctrl+0x160>)
    444c:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    444e:	23ff      	movs	r3, #255	; 0xff
    4450:	71eb      	strb	r3, [r5, #7]
	_audiodf_midi_funcd.enabled = false;
    4452:	4b0b      	ldr	r3, [pc, #44]	; (4480 <audio_midi_ctrl+0x15c>)
    4454:	2000      	movs	r0, #0
    4456:	7458      	strb	r0, [r3, #17]
	return ERR_NONE;
    4458:	e77a      	b.n	4350 <audio_midi_ctrl+0x2c>
		return ERR_UNSUPPORTED_OP;
    445a:	f06f 001a 	mvn.w	r0, #26
    445e:	e777      	b.n	4350 <audio_midi_ctrl+0x2c>
	switch (ctrl) {
    4460:	f06f 000c 	mvn.w	r0, #12
    4464:	e774      	b.n	4350 <audio_midi_ctrl+0x2c>
				return ERR_ALREADY_INITIALIZED;
    4466:	f06f 0011 	mvn.w	r0, #17
    446a:	e771      	b.n	4350 <audio_midi_ctrl+0x2c>
				return ERR_NO_RESOURCE;
    446c:	f06f 001b 	mvn.w	r0, #27
    4470:	e76e      	b.n	4350 <audio_midi_ctrl+0x2c>
					return ERR_NOT_INITIALIZED;
    4472:	f06f 0013 	mvn.w	r0, #19
    4476:	e76b      	b.n	4350 <audio_midi_ctrl+0x2c>
    4478:	0000fe9d 	.word	0x0000fe9d
    447c:	0000c167 	.word	0x0000c167
    4480:	200005cc 	.word	0x200005cc
    4484:	0000ff01 	.word	0x0000ff01
    4488:	0000c14d 	.word	0x0000c14d
    448c:	20009140 	.word	0x20009140
    4490:	0000ff2d 	.word	0x0000ff2d

00004494 <audiodf_midi_init>:

/**
 * \brief Initialize the USB Audio Midi Function Driver
 */
int32_t audiodf_midi_init(void)
{
    4494:	b508      	push	{r3, lr}
	
	
	if (usbdc_get_state() > USBD_S_POWER) {
    4496:	4b0a      	ldr	r3, [pc, #40]	; (44c0 <audiodf_midi_init+0x2c>)
    4498:	4798      	blx	r3
    449a:	2801      	cmp	r0, #1
    449c:	d80c      	bhi.n	44b8 <audiodf_midi_init+0x24>
		return ERR_DENIED;
	}
	
	_audiodf_midi.ctrl      = audio_midi_ctrl;
    449e:	4809      	ldr	r0, [pc, #36]	; (44c4 <audiodf_midi_init+0x30>)
    44a0:	4b09      	ldr	r3, [pc, #36]	; (44c8 <audiodf_midi_init+0x34>)
	_audiodf_midi.func_data = &_audiodf_midi_funcd;
    44a2:	e9c0 3006 	strd	r3, r0, [r0, #24]
	
	usbdc_register_function(&_audiodf_midi);
    44a6:	4b09      	ldr	r3, [pc, #36]	; (44cc <audiodf_midi_init+0x38>)
    44a8:	3014      	adds	r0, #20
    44aa:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &audio_midi_req_h);
    44ac:	2001      	movs	r0, #1
    44ae:	4908      	ldr	r1, [pc, #32]	; (44d0 <audiodf_midi_init+0x3c>)
    44b0:	4b08      	ldr	r3, [pc, #32]	; (44d4 <audiodf_midi_init+0x40>)
    44b2:	4798      	blx	r3
	return ERR_NONE;
    44b4:	2000      	movs	r0, #0
}
    44b6:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    44b8:	f06f 0010 	mvn.w	r0, #16
    44bc:	e7fb      	b.n	44b6 <audiodf_midi_init+0x22>
    44be:	bf00      	nop
    44c0:	000140d5 	.word	0x000140d5
    44c4:	200005cc 	.word	0x200005cc
    44c8:	00004325 	.word	0x00004325
    44cc:	0001407d 	.word	0x0001407d
    44d0:	20000000 	.word	0x20000000
    44d4:	00013ff5 	.word	0x00013ff5

000044d8 <audiodf_midi_write>:
}



int32_t audiodf_midi_write(uint8_t byte0, uint8_t byte1, uint8_t byte2, uint8_t byte3)
{
    44d8:	b410      	push	{r4}
		return ERR_DENIED;
	}
	
	// if previous xfer is completed
	
	_audiodf_midi_funcd.midi_report[0] = byte0;
    44da:	4c07      	ldr	r4, [pc, #28]	; (44f8 <audiodf_midi_write+0x20>)
    44dc:	7260      	strb	r0, [r4, #9]
	_audiodf_midi_funcd.midi_report[1] = byte1;
    44de:	72a1      	strb	r1, [r4, #10]
	_audiodf_midi_funcd.midi_report[2] = byte2;
    44e0:	72e2      	strb	r2, [r4, #11]
	_audiodf_midi_funcd.midi_report[3] = byte3;
    44e2:	7323      	strb	r3, [r4, #12]

	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    44e4:	79a0      	ldrb	r0, [r4, #6]
    44e6:	f104 0109 	add.w	r1, r4, #9
    44ea:	4c04      	ldr	r4, [pc, #16]	; (44fc <audiodf_midi_write+0x24>)
    44ec:	2300      	movs	r3, #0
    44ee:	46a4      	mov	ip, r4
    44f0:	2204      	movs	r2, #4
	
}
    44f2:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_in, _audiodf_midi_funcd.midi_report, 4, false);
    44f6:	4760      	bx	ip
    44f8:	200005cc 	.word	0x200005cc
    44fc:	00013c9d 	.word	0x00013c9d

00004500 <audiodf_midi_write_status>:

int32_t audiodf_midi_write_status(){
    4500:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	
	struct usb_d_ep_status epstat;
	return usb_d_ep_get_status(_audiodf_midi_funcd.func_ep_in, &epstat);
    4502:	4b04      	ldr	r3, [pc, #16]	; (4514 <audiodf_midi_write_status+0x14>)
    4504:	a901      	add	r1, sp, #4
    4506:	7998      	ldrb	r0, [r3, #6]
    4508:	4b03      	ldr	r3, [pc, #12]	; (4518 <audiodf_midi_write_status+0x18>)
    450a:	4798      	blx	r3
	
}
    450c:	b005      	add	sp, #20
    450e:	f85d fb04 	ldr.w	pc, [sp], #4
    4512:	bf00      	nop
    4514:	200005cc 	.word	0x200005cc
    4518:	00010055 	.word	0x00010055

0000451c <audiodf_midi_read>:



int32_t audiodf_midi_read(uint8_t *buf, uint32_t size)
{
    451c:	b410      	push	{r4}
    451e:	460a      	mov	r2, r1
	if (!audiodf_midi_is_enabled()) {
		return ERR_DENIED;
	}
		
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    4520:	4c04      	ldr	r4, [pc, #16]	; (4534 <audiodf_midi_read+0x18>)
    4522:	4601      	mov	r1, r0
    4524:	4804      	ldr	r0, [pc, #16]	; (4538 <audiodf_midi_read+0x1c>)
    4526:	46a4      	mov	ip, r4
    4528:	79c0      	ldrb	r0, [r0, #7]
}
    452a:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_audiodf_midi_funcd.func_ep_out, buf, size, false);
    452e:	2300      	movs	r3, #0
    4530:	4760      	bx	ip
    4532:	bf00      	nop
    4534:	00013c9d 	.word	0x00013c9d
    4538:	200005cc 	.word	0x200005cc

0000453c <audiodf_midi_register_callback>:


int32_t audiodf_midi_register_callback(enum audiodf_midi_cb_type cb_type, FUNC_PTR func)
{
    453c:	b510      	push	{r4, lr}
    453e:	460a      	mov	r2, r1
	switch (cb_type) {
    4540:	b120      	cbz	r0, 454c <audiodf_midi_register_callback+0x10>
    4542:	2801      	cmp	r0, #1
    4544:	d009      	beq.n	455a <audiodf_midi_register_callback+0x1e>
    4546:	f06f 000c 	mvn.w	r0, #12
		break;
		default:
		return ERR_INVALID_ARG;
	}
	return ERR_NONE;
}
    454a:	bd10      	pop	{r4, pc}
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    454c:	4b05      	ldr	r3, [pc, #20]	; (4564 <audiodf_midi_register_callback+0x28>)
    454e:	79d8      	ldrb	r0, [r3, #7]
    4550:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    4552:	4b05      	ldr	r3, [pc, #20]	; (4568 <audiodf_midi_register_callback+0x2c>)
    4554:	4798      	blx	r3
	return ERR_NONE;
    4556:	2000      	movs	r0, #0
		break;
    4558:	e7f7      	b.n	454a <audiodf_midi_register_callback+0xe>
		usb_d_ep_register_callback(_audiodf_midi_funcd.func_ep_in, USB_D_EP_CB_XFER, func);
    455a:	4b02      	ldr	r3, [pc, #8]	; (4564 <audiodf_midi_register_callback+0x28>)
    455c:	2102      	movs	r1, #2
    455e:	7998      	ldrb	r0, [r3, #6]
    4560:	e7f7      	b.n	4552 <audiodf_midi_register_callback+0x16>
    4562:	bf00      	nop
    4564:	200005cc 	.word	0x200005cc
    4568:	00010115 	.word	0x00010115

0000456c <grid_ain_channel_init>:

struct AIN_Channel* ain_channel_buffer;



uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    456c:	b570      	push	{r4, r5, r6, lr}
	instance->buffer_depth = buffer_depth;
	
	instance->result_format = result_format;
	instance->result_resolution = result_resolution;
	
	instance->result_average = 0;
    456e:	2500      	movs	r5, #0
	instance->result_format = result_format;
    4570:	7142      	strb	r2, [r0, #5]
	instance->result_resolution = result_resolution;
    4572:	7183      	strb	r3, [r0, #6]
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    4574:	4604      	mov	r4, r0
	
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4576:	4b0a      	ldr	r3, [pc, #40]	; (45a0 <grid_ain_channel_init+0x34>)
	instance->buffer_depth = buffer_depth;
    4578:	7101      	strb	r1, [r0, #4]
	instance->result_average = 0;
    457a:	8145      	strh	r5, [r0, #10]
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    457c:	0048      	lsls	r0, r1, #1
uint8_t grid_ain_channel_init(struct AIN_Channel* instance , uint8_t buffer_depth, uint8_t result_format, uint8_t result_resolution){
    457e:	460e      	mov	r6, r1
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4580:	4798      	blx	r3
	
	// Init the whole buffer with zeros
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    4582:	462b      	mov	r3, r5
	instance->buffer = malloc(instance->buffer_depth * sizeof(uint16_t));
    4584:	6020      	str	r0, [r4, #0]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    4586:	462a      	mov	r2, r5
    4588:	b2d9      	uxtb	r1, r3
    458a:	428e      	cmp	r6, r1
    458c:	d803      	bhi.n	4596 <grid_ain_channel_init+0x2a>
		instance->buffer[i] = 0;
	}
	
	instance->result_changed = 0;
    458e:	81a2      	strh	r2, [r4, #12]
	instance->result_value = 0;
    4590:	8122      	strh	r2, [r4, #8]
		
	return 0;
}
    4592:	2000      	movs	r0, #0
    4594:	bd70      	pop	{r4, r5, r6, pc}
		instance->buffer[i] = 0;
    4596:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
	for(uint8_t i=0; i<instance->buffer_depth; i++){
    459a:	3301      	adds	r3, #1
    459c:	e7f4      	b.n	4588 <grid_ain_channel_init+0x1c>
    459e:	bf00      	nop
    45a0:	00014d25 	.word	0x00014d25

000045a4 <grid_ain_init>:
	}
}


/** Initialize ain buffer for a given number of analog channels */
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45a4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    45a8:	4605      	mov	r5, r0
    45aa:	4699      	mov	r9, r3
	
	// ain_channel_result_resolution = resolution
	
	
	// 2D buffer, example: 16 potentiometers, last 32 samples stored for each
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45ac:	0100      	lsls	r0, r0, #4
    45ae:	4b0b      	ldr	r3, [pc, #44]	; (45dc <grid_ain_init+0x38>)
    45b0:	4e0b      	ldr	r6, [pc, #44]	; (45e0 <grid_ain_init+0x3c>)

	for (uint8_t i=0; i<length; i++){
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45b2:	f8df a030 	ldr.w	sl, [pc, #48]	; 45e4 <grid_ain_init+0x40>
uint8_t grid_ain_init(uint8_t length, uint8_t depth, uint8_t  format, uint8_t resolution){
    45b6:	460f      	mov	r7, r1
    45b8:	4690      	mov	r8, r2
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45ba:	4798      	blx	r3
	for (uint8_t i=0; i<length; i++){
    45bc:	2400      	movs	r4, #0
	ain_channel_buffer = (struct AIN_Channel*) malloc(length * sizeof(struct AIN_Channel));
    45be:	6030      	str	r0, [r6, #0]
	for (uint8_t i=0; i<length; i++){
    45c0:	42a5      	cmp	r5, r4
    45c2:	d102      	bne.n	45ca <grid_ain_init+0x26>
	}

	return 0;
}
    45c4:	2000      	movs	r0, #0
    45c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		grid_ain_channel_init(&ain_channel_buffer[i], depth, format, resolution);
    45ca:	6830      	ldr	r0, [r6, #0]
    45cc:	464b      	mov	r3, r9
    45ce:	eb00 1004 	add.w	r0, r0, r4, lsl #4
    45d2:	4642      	mov	r2, r8
    45d4:	4639      	mov	r1, r7
    45d6:	47d0      	blx	sl
	for (uint8_t i=0; i<length; i++){
    45d8:	3401      	adds	r4, #1
    45da:	e7f1      	b.n	45c0 <grid_ain_init+0x1c>
    45dc:	00014d25 	.word	0x00014d25
    45e0:	2000c0a8 	.word	0x2000c0a8
    45e4:	0000456d 	.word	0x0000456d

000045e8 <grid_ain_add_sample>:

uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    45e8:	4b30      	ldr	r3, [pc, #192]	; (46ac <grid_ain_add_sample+0xc4>)
uint8_t grid_ain_add_sample(uint8_t channel, uint16_t value){
    45ea:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
    45ee:	681a      	ldr	r2, [r3, #0]
    45f0:	0104      	lsls	r4, r0, #4
    45f2:	eb02 1300 	add.w	r3, r2, r0, lsl #4
	uint16_t maximum = 0;

	uint8_t minimum_index = 0;
	uint8_t maximum_index = 0;
	
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    45f6:	5914      	ldr	r4, [r2, r4]
    45f8:	f893 e004 	ldrb.w	lr, [r3, #4]
    45fc:	2200      	movs	r2, #0
	uint8_t maximum_index = 0;
    45fe:	4615      	mov	r5, r2
	uint8_t minimum_index = 0;
    4600:	4616      	mov	r6, r2
	uint16_t maximum = 0;
    4602:	4691      	mov	r9, r2
	uint16_t minimum = -1; // -1 trick to get the largest possible number
    4604:	f64f 78ff 	movw	r8, #65535	; 0xffff
	uint32_t sum = 0;
    4608:	4610      	mov	r0, r2
    460a:	fa5f fc82 	uxtb.w	ip, r2
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    460e:	45e6      	cmp	lr, ip
    4610:	d83c      	bhi.n	468c <grid_ain_add_sample+0xa4>
	
	}
	
	uint16_t average = sum/instance->buffer_depth;
	
	if (value>average){		
    4612:	180a      	adds	r2, r1, r0
	uint16_t average = sum/instance->buffer_depth;
    4614:	fbb0 f0fe 	udiv	r0, r0, lr
	if (value>average){		
    4618:	b280      	uxth	r0, r0
    461a:	4288      	cmp	r0, r1
		// Replace minimum in the buffer and recalculate sum
		sum = sum - instance->buffer[minimum_index] + value;
    461c:	bf34      	ite	cc
    461e:	b230      	sxthcc	r0, r6
		instance->buffer[minimum_index] = value;		
	}else{
		// Replace maximum in the buffer and recalculate sum
		sum = sum - instance->buffer[maximum_index] + value;
    4620:	b228      	sxthcs	r0, r5
    4622:	f834 5010 	ldrh.w	r5, [r4, r0, lsl #1]
		instance->buffer[maximum_index] = value;
    4626:	f824 1010 	strh.w	r1, [r4, r0, lsl #1]
		sum = sum - instance->buffer[maximum_index] + value;
    462a:	1b52      	subs	r2, r2, r5
	}
	
	// Recalculate average
	average = sum/instance->buffer_depth;
    462c:	7919      	ldrb	r1, [r3, #4]
    462e:	fbb2 f2f1 	udiv	r2, r2, r1
	
	
	uint8_t downscale_factor = (16-instance->result_resolution);
    4632:	7999      	ldrb	r1, [r3, #6]
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    4634:	795c      	ldrb	r4, [r3, #5]
	
	uint16_t downsampled = average>>downscale_factor;
	uint16_t upscaled    = downsampled<<upscale_factor;
	
	uint8_t criteria_a = instance->result_value != upscaled;
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4636:	895e      	ldrh	r6, [r3, #10]
	
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
	uint8_t criteria_d = upscaled==0;
	
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4638:	f8b3 e008 	ldrh.w	lr, [r3, #8]
	uint8_t downscale_factor = (16-instance->result_resolution);
    463c:	f1c1 0710 	rsb	r7, r1, #16
	uint16_t downsampled = average>>downscale_factor;
    4640:	b295      	uxth	r5, r2
    4642:	b2ff      	uxtb	r7, r7
	uint8_t upscale_factor   = (instance->result_format - instance->result_resolution);
    4644:	1a61      	subs	r1, r4, r1
	uint16_t upscaled    = downsampled<<upscale_factor;
    4646:	b2c8      	uxtb	r0, r1
	uint16_t downsampled = average>>downscale_factor;
    4648:	fa45 f107 	asr.w	r1, r5, r7
	uint16_t upscaled    = downsampled<<upscale_factor;
    464c:	b289      	uxth	r1, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    464e:	1b76      	subs	r6, r6, r5
	uint16_t upscaled    = downsampled<<upscale_factor;
    4650:	4081      	lsls	r1, r0
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4652:	2e00      	cmp	r6, #0
	uint16_t upscaled    = downsampled<<upscale_factor;
    4654:	fa1f fc81 	uxth.w	ip, r1
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4658:	bfb8      	it	lt
    465a:	4276      	neglt	r6, r6
    465c:	2501      	movs	r5, #1
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    465e:	45e6      	cmp	lr, ip
	uint8_t criteria_b = abs(instance->result_average - average)>(1<<downscale_factor);
    4660:	fa05 f707 	lsl.w	r7, r5, r7
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4664:	d01f      	beq.n	46a6 <grid_ain_add_sample+0xbe>
    4666:	42be      	cmp	r6, r7
    4668:	dc09      	bgt.n	467e <grid_ain_add_sample+0x96>
	uint8_t criteria_c = upscaled==(1<<instance->result_format)-(1<<upscale_factor);
    466a:	fa05 f404 	lsl.w	r4, r5, r4
    466e:	fa05 f000 	lsl.w	r0, r5, r0
    4672:	1a20      	subs	r0, r4, r0
	if (criteria_a && (criteria_b || criteria_c || criteria_d)){
    4674:	4560      	cmp	r0, ip
    4676:	d002      	beq.n	467e <grid_ain_add_sample+0x96>
    4678:	f1bc 0f00 	cmp.w	ip, #0
    467c:	d113      	bne.n	46a6 <grid_ain_add_sample+0xbe>
		
		instance->result_average = average;
		instance->result_value = upscaled;
		instance->result_changed = 1;
    467e:	2001      	movs	r0, #1
	average = sum/instance->buffer_depth;
    4680:	815a      	strh	r2, [r3, #10]
		instance->result_value = upscaled;
    4682:	f8a3 c008 	strh.w	ip, [r3, #8]
		instance->result_changed = 1;
    4686:	8198      	strh	r0, [r3, #12]
		return 1;
	}else{		
		return 0;
	}
	
}
    4688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		uint16_t current = instance->buffer[i];
    468c:	f834 7012 	ldrh.w	r7, [r4, r2, lsl #1]
		if (current > maximum){
    4690:	45b9      	cmp	r9, r7
    4692:	bf3c      	itt	cc
    4694:	4665      	movcc	r5, ip
    4696:	46b9      	movcc	r9, r7
		if (current < minimum){
    4698:	45b8      	cmp	r8, r7
		sum += current;
    469a:	4438      	add	r0, r7
		if (current < minimum){
    469c:	bf84      	itt	hi
    469e:	4666      	movhi	r6, ip
    46a0:	46b8      	movhi	r8, r7
	for (uint8_t i = 0; i<instance->buffer_depth; i++){
    46a2:	3201      	adds	r2, #1
    46a4:	e7b1      	b.n	460a <grid_ain_add_sample+0x22>
		return 0;
    46a6:	2000      	movs	r0, #0
    46a8:	e7ee      	b.n	4688 <grid_ain_add_sample+0xa0>
    46aa:	bf00      	nop
    46ac:	2000c0a8 	.word	0x2000c0a8

000046b0 <grid_ain_get_changed>:

uint8_t grid_ain_get_changed(uint8_t channel){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];
	return instance->result_changed;
    46b0:	4b02      	ldr	r3, [pc, #8]	; (46bc <grid_ain_get_changed+0xc>)
    46b2:	681b      	ldr	r3, [r3, #0]
    46b4:	eb03 1000 	add.w	r0, r3, r0, lsl #4
}
    46b8:	7b00      	ldrb	r0, [r0, #12]
    46ba:	4770      	bx	lr
    46bc:	2000c0a8 	.word	0x2000c0a8

000046c0 <grid_ain_get_average>:
	
uint16_t grid_ain_get_average(uint8_t channel, uint8_t resolution){
	
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    46c0:	4b08      	ldr	r3, [pc, #32]	; (46e4 <grid_ain_get_average+0x24>)
    46c2:	681a      	ldr	r2, [r3, #0]
	instance->result_changed = 0;
	
	if (resolution>6 && resolution<15){
    46c4:	1fcb      	subs	r3, r1, #7
	struct AIN_Channel* instance = &ain_channel_buffer[channel];	
    46c6:	eb02 1200 	add.w	r2, r2, r0, lsl #4
	if (resolution>6 && resolution<15){
    46ca:	2b07      	cmp	r3, #7
	instance->result_changed = 0;
    46cc:	f04f 0000 	mov.w	r0, #0
    46d0:	8190      	strh	r0, [r2, #12]
	if (resolution>6 && resolution<15){
    46d2:	d805      	bhi.n	46e0 <grid_ain_get_average+0x20>
		

		
		return (instance->result_value)/(1<<(instance->result_format-resolution));
    46d4:	7950      	ldrb	r0, [r2, #5]
    46d6:	8913      	ldrh	r3, [r2, #8]
    46d8:	1a40      	subs	r0, r0, r1
    46da:	fa43 f000 	asr.w	r0, r3, r0
    46de:	b280      	uxth	r0, r0
		
	}
	else{
		return 0;
	}
}
    46e0:	4770      	bx	lr
    46e2:	bf00      	nop
    46e4:	2000c0a8 	.word	0x2000c0a8

000046e8 <grid_port_reset_receiver>:
#include "grid_buf.h"

// PORTS


void grid_port_reset_receiver(struct grid_port* por){
    46e8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	usart_async_disable(por->usart);
    46ea:	4b24      	ldr	r3, [pc, #144]	; (477c <grid_port_reset_receiver+0x94>)
	
	
	por->ping_partner_token = 255;
	por->ping_local_token = 255;
	
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    46ec:	4e24      	ldr	r6, [pc, #144]	; (4780 <grid_port_reset_receiver+0x98>)
void grid_port_reset_receiver(struct grid_port* por){
    46ee:	4604      	mov	r4, r0
	usart_async_disable(por->usart);
    46f0:	6840      	ldr	r0, [r0, #4]
    46f2:	4798      	blx	r3
	por->partner_status = 0;
    46f4:	f642 734b 	movw	r3, #12107	; 0x2f4b
	por->rx_double_buffer_seek_start_index = 0;
    46f8:	2500      	movs	r5, #0
	por->rx_double_buffer_read_start_index = 0;
    46fa:	e9c4 5509 	strd	r5, r5, [r4, #36]	; 0x24
	por->ping_local_token = 255;
    46fe:	f642 7731 	movw	r7, #12081	; 0x2f31
	por->partner_status = 0;
    4702:	54e5      	strb	r5, [r4, r3]
	por->ping_partner_token = 255;
    4704:	f642 7332 	movw	r3, #12082	; 0x2f32
    4708:	22ff      	movs	r2, #255	; 0xff
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    470a:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
	por->ping_partner_token = 255;
    470e:	54e2      	strb	r2, [r4, r3]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4710:	2102      	movs	r1, #2
	por->ping_local_token = 255;
    4712:	55e2      	strb	r2, [r4, r7]
	grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4714:	303b      	adds	r0, #59	; 0x3b
    4716:	47b0      	blx	r6
	grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4718:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    471c:	5de2      	ldrb	r2, [r4, r7]
    471e:	2102      	movs	r1, #2
    4720:	3039      	adds	r0, #57	; 0x39
    4722:	47b0      	blx	r6
	grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4724:	f642 7347 	movw	r3, #12103	; 0x2f47
    4728:	f504 563c 	add.w	r6, r4, #12032	; 0x2f00
    472c:	3633      	adds	r6, #51	; 0x33
    472e:	5ce1      	ldrb	r1, [r4, r3]
    4730:	4b14      	ldr	r3, [pc, #80]	; (4784 <grid_port_reset_receiver+0x9c>)
    4732:	9101      	str	r1, [sp, #4]
    4734:	4630      	mov	r0, r6
    4736:	4798      	blx	r3
    4738:	9901      	ldr	r1, [sp, #4]
    473a:	4b13      	ldr	r3, [pc, #76]	; (4788 <grid_port_reset_receiver+0xa0>)
    473c:	4602      	mov	r2, r0
    473e:	4630      	mov	r0, r6
    4740:	4798      	blx	r3


	
	por->rx_double_buffer_timeout = 0;
	grid_sys_port_reset_dma(por);
    4742:	4b12      	ldr	r3, [pc, #72]	; (478c <grid_port_reset_receiver+0xa4>)
	por->rx_double_buffer_timeout = 0;
    4744:	61e5      	str	r5, [r4, #28]
	grid_sys_port_reset_dma(por);
    4746:	4620      	mov	r0, r4
    4748:	4798      	blx	r3
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    474a:	f504 539d 	add.w	r3, r4, #5024	; 0x13a0
    474e:	3314      	adds	r3, #20
    4750:	f504 521c 	add.w	r2, r4, #9984	; 0x2700
    4754:	323c      	adds	r2, #60	; 0x3c
    4756:	4619      	mov	r1, r3
		por->rx_double_buffer[i] = 0;
    4758:	f803 5b01 	strb.w	r5, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    475c:	4293      	cmp	r3, r2
    475e:	d1fb      	bne.n	4758 <grid_port_reset_receiver+0x70>
    4760:	f104 032c 	add.w	r3, r4, #44	; 0x2c
	}
	
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
		por->tx_double_buffer[i] = 0;
    4764:	2200      	movs	r2, #0
    4766:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    476a:	428b      	cmp	r3, r1
    476c:	d1fb      	bne.n	4766 <grid_port_reset_receiver+0x7e>
	}
	
	usart_async_enable(por->usart);
    476e:	6860      	ldr	r0, [r4, #4]
    4770:	4b07      	ldr	r3, [pc, #28]	; (4790 <grid_port_reset_receiver+0xa8>)
	
}
    4772:	b003      	add	sp, #12
    4774:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	usart_async_enable(por->usart);
    4778:	4718      	bx	r3
    477a:	bf00      	nop
    477c:	0001115d 	.word	0x0001115d
    4780:	0000a199 	.word	0x0000a199
    4784:	0000a2e1 	.word	0x0000a2e1
    4788:	0000a315 	.word	0x0000a315
    478c:	00009d25 	.word	0x00009d25
    4790:	00011131 	.word	0x00011131

00004794 <grid_buffer_init>:



uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
	
	grid_buffer_error_count = 0;
    4794:	4a0f      	ldr	r2, [pc, #60]	; (47d4 <grid_buffer_init+0x40>)
    4796:	2300      	movs	r3, #0
uint8_t grid_buffer_init(struct grid_buffer* buf, uint16_t length){
    4798:	b510      	push	{r4, lr}
    479a:	3002      	adds	r0, #2
	grid_buffer_error_count = 0;
    479c:	7013      	strb	r3, [r2, #0]
	
	buf->buffer_length = length;
	
	buf->read_length   = 0;
    479e:	f8a0 33ee 	strh.w	r3, [r0, #1006]	; 0x3ee
	buf->buffer_length = length;
    47a2:	f820 1c02 	strh.w	r1, [r0, #-2]
	
	buf->read_start    = 0;
    47a6:	f8a0 33e8 	strh.w	r3, [r0, #1000]	; 0x3e8
	buf->read_stop     = 0;
    47aa:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
	buf->read_active   = 0;
    47ae:	f8a0 33ec 	strh.w	r3, [r0, #1004]	; 0x3ec
	
	buf->write_start    = 0;
    47b2:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
	buf->write_stop     = 0;
    47b6:	f8a0 33f2 	strh.w	r3, [r0, #1010]	; 0x3f2
	buf->write_active   = 0;
    47ba:	f8a0 33f4 	strh.w	r3, [r0, #1012]	; 0x3f4
	

	for (uint16_t i=0; i<buf->buffer_length; i++){
		buf->buffer_storage[i] = 0;
    47be:	461c      	mov	r4, r3
	for (uint16_t i=0; i<buf->buffer_length; i++){
    47c0:	b29a      	uxth	r2, r3
    47c2:	4291      	cmp	r1, r2
    47c4:	d801      	bhi.n	47ca <grid_buffer_init+0x36>
	}
	
	return 1;
	
}
    47c6:	2001      	movs	r0, #1
    47c8:	bd10      	pop	{r4, pc}
		buf->buffer_storage[i] = 0;
    47ca:	f800 4b01 	strb.w	r4, [r0], #1
	for (uint16_t i=0; i<buf->buffer_length; i++){
    47ce:	3301      	adds	r3, #1
    47d0:	e7f6      	b.n	47c0 <grid_buffer_init+0x2c>
    47d2:	bf00      	nop
    47d4:	2000c09c 	.word	0x2000c09c

000047d8 <grid_buffer_get_space>:

uint16_t grid_buffer_get_space(struct grid_buffer* buf){
	
	uint16_t space = 0;
		
	if (buf->read_start > buf->write_start){
    47d8:	f8b0 33ea 	ldrh.w	r3, [r0, #1002]	; 0x3ea
    47dc:	f8b0 23f2 	ldrh.w	r2, [r0, #1010]	; 0x3f2
    47e0:	4293      	cmp	r3, r2
		space = buf->read_start - buf->write_start;
	}
	else{
		space = buf->buffer_length - buf->write_start + buf->read_start;
    47e2:	bf9b      	ittet	ls
    47e4:	8800      	ldrhls	r0, [r0, #0]
    47e6:	18c0      	addls	r0, r0, r3
		space = buf->read_start - buf->write_start;
    47e8:	1a98      	subhi	r0, r3, r2
		space = buf->buffer_length - buf->write_start + buf->read_start;
    47ea:	1a80      	subls	r0, r0, r2
    47ec:	b280      	uxth	r0, r0
	}
	
	return space;
}
    47ee:	4770      	bx	lr

000047f0 <grid_buffer_write_init>:





uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    47f0:	b510      	push	{r4, lr}
	
	
	
	uint16_t space = grid_buffer_get_space(buf);
    47f2:	4b0c      	ldr	r3, [pc, #48]	; (4824 <grid_buffer_write_init+0x34>)
uint16_t grid_buffer_write_init(struct grid_buffer* buf, uint16_t length){
    47f4:	4604      	mov	r4, r0
	uint16_t space = grid_buffer_get_space(buf);
    47f6:	4798      	blx	r3

	
	if (space>length){
    47f8:	4288      	cmp	r0, r1
    47fa:	d90b      	bls.n	4814 <grid_buffer_write_init+0x24>
		
		buf->write_stop = (buf->write_start+length)%buf->buffer_length;
    47fc:	f8b4 33f2 	ldrh.w	r3, [r4, #1010]	; 0x3f2
    4800:	8820      	ldrh	r0, [r4, #0]
    4802:	440b      	add	r3, r1
    4804:	fbb3 f2f0 	udiv	r2, r3, r0
    4808:	fb00 3312 	mls	r3, r0, r2, r3
    480c:	f8a4 33f4 	strh.w	r3, [r4, #1012]	; 0x3f4
	}
	
	
	
	
}
    4810:	4608      	mov	r0, r1
    4812:	bd10      	pop	{r4, pc}
		grid_buffer_error_count++;
    4814:	4a04      	ldr	r2, [pc, #16]	; (4828 <grid_buffer_write_init+0x38>)
    4816:	7813      	ldrb	r3, [r2, #0]
    4818:	3301      	adds	r3, #1
    481a:	b2db      	uxtb	r3, r3
    481c:	7013      	strb	r3, [r2, #0]
		return 0; // failed
    481e:	2100      	movs	r1, #0
    4820:	e7f6      	b.n	4810 <grid_buffer_write_init+0x20>
    4822:	bf00      	nop
    4824:	000047d9 	.word	0x000047d9
    4828:	2000c09c 	.word	0x2000c09c

0000482c <grid_buffer_write_character>:

uint8_t grid_buffer_write_character(struct grid_buffer* buf, uint8_t character){
	

		
	buf->buffer_storage[buf->write_active] = character;
    482c:	f8b0 33f6 	ldrh.w	r3, [r0, #1014]	; 0x3f6
    4830:	18c2      	adds	r2, r0, r3
		
	buf->write_active++;
    4832:	3301      	adds	r3, #1
	buf->buffer_storage[buf->write_active] = character;
    4834:	7091      	strb	r1, [r2, #2]
	buf->write_active %= buf->buffer_length;
    4836:	8801      	ldrh	r1, [r0, #0]
    4838:	b29b      	uxth	r3, r3
    483a:	fbb3 f2f1 	udiv	r2, r3, r1
    483e:	fb01 3312 	mls	r3, r1, r2, r3
    4842:	f8a0 33f6 	strh.w	r3, [r0, #1014]	; 0x3f6
		
	return 1;
		

}
    4846:	2001      	movs	r0, #1
    4848:	4770      	bx	lr
	...

0000484c <grid_buffer_write_acknowledge>:

uint8_t grid_buffer_write_acknowledge(struct grid_buffer* buf){
	
	if (buf->write_active == buf->write_stop){
    484c:	f8b0 33f4 	ldrh.w	r3, [r0, #1012]	; 0x3f4
    4850:	f8b0 23f6 	ldrh.w	r2, [r0, #1014]	; 0x3f6
    4854:	4293      	cmp	r3, r2
		buf->write_start = buf->write_active;
		return 1;
	}
	else{
		
		grid_buffer_error_count++;
    4856:	bf17      	itett	ne
    4858:	4a05      	ldrne	r2, [pc, #20]	; (4870 <grid_buffer_write_acknowledge+0x24>)
		buf->write_start = buf->write_active;
    485a:	f8a0 33f2 	strheq.w	r3, [r0, #1010]	; 0x3f2
		grid_buffer_error_count++;
    485e:	7813      	ldrbne	r3, [r2, #0]
    4860:	3301      	addne	r3, #1
    4862:	bf17      	itett	ne
    4864:	b2db      	uxtbne	r3, r3
		return 1;
    4866:	2001      	moveq	r0, #1
		grid_buffer_error_count++;
    4868:	7013      	strbne	r3, [r2, #0]
    486a:	2000      	movne	r0, #0
		return 0;
	}
	
	
}
    486c:	4770      	bx	lr
    486e:	bf00      	nop
    4870:	2000c09c 	.word	0x2000c09c

00004874 <grid_port_receive_decode>:
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    4874:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4878:	ed2d 8b02 	vpush	{d8}
	uint8_t buffer[length];
    487c:	1dd3      	adds	r3, r2, #7
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    487e:	b08b      	sub	sp, #44	; 0x2c
    4880:	4690      	mov	r8, r2
	uint8_t buffer[length];
    4882:	08db      	lsrs	r3, r3, #3
    4884:	466a      	mov	r2, sp
    4886:	eba2 03c3 	sub.w	r3, r2, r3, lsl #3
	for (uint16_t i = 0; i<length; i++){
    488a:	2200      	movs	r2, #0
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    488c:	af02      	add	r7, sp, #8
	uint8_t buffer[length];
    488e:	469d      	mov	sp, r3
void grid_port_receive_decode(struct grid_port* por, uint16_t startcommand, uint16_t len){
    4890:	4604      	mov	r4, r0
    4892:	6a83      	ldr	r3, [r0, #40]	; 0x28
	uint8_t buffer[length];
    4894:	f10d 0908 	add.w	r9, sp, #8
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4898:	f241 3088 	movw	r0, #5000	; 0x1388
    489c:	f241 35b4 	movw	r5, #5044	; 0x13b4
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    48a0:	4694      	mov	ip, r2
	for (uint16_t i = 0; i<length; i++){
    48a2:	b291      	uxth	r1, r2
    48a4:	4588      	cmp	r8, r1
    48a6:	f200 80e3 	bhi.w	4a70 <grid_port_receive_decode+0x1fc>
	for (uint16_t i = 0; i<length; i++){
    48aa:	2200      	movs	r2, #0
	message = &buffer[0];
    48ac:	464d      	mov	r5, r9
	for (uint16_t i = 0; i<length; i++){
    48ae:	f241 3088 	movw	r0, #5000	; 0x1388
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    48b2:	f241 3cb4 	movw	ip, #5044	; 0x13b4
    48b6:	4696      	mov	lr, r2
	for (uint16_t i = 0; i<length; i++){
    48b8:	b291      	uxth	r1, r2
    48ba:	4588      	cmp	r8, r1
    48bc:	f200 80e5 	bhi.w	4a8a <grid_port_receive_decode+0x216>
	por->rx_double_buffer_read_start_index = (por->rx_double_buffer_read_start_index + length)%GRID_DOUBLE_BUFFER_RX_SIZE;
    48c0:	4443      	add	r3, r8
    48c2:	fbb3 f2f0 	udiv	r2, r3, r0
    48c6:	fb00 3312 	mls	r3, r0, r2, r3
	por->rx_double_buffer_seek_start_index =  por->rx_double_buffer_read_start_index;
    48ca:	e9c4 3309 	strd	r3, r3, [r4, #36]	; 0x24
	por->rx_double_buffer_status = 0;
    48ce:	2300      	movs	r3, #0
    48d0:	6223      	str	r3, [r4, #32]
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    48d2:	f8df a250 	ldr.w	sl, [pc, #592]	; 4b24 <grid_port_receive_decode+0x2b0>
    48d6:	f8df b250 	ldr.w	fp, [pc, #592]	; 4b28 <grid_port_receive_decode+0x2b4>
    48da:	4b88      	ldr	r3, [pc, #544]	; (4afc <grid_port_receive_decode+0x288>)
	for (uint16_t i = 1; i<length; i++){
    48dc:	2601      	movs	r6, #1
    48de:	45b0      	cmp	r8, r6
    48e0:	f200 80dd 	bhi.w	4a9e <grid_port_receive_decode+0x22a>
	if (message[0] == GRID_CONST_SOH && message[length-1] == GRID_CONST_LF){
    48e4:	782b      	ldrb	r3, [r5, #0]
    48e6:	2b01      	cmp	r3, #1
    48e8:	f040 80bc 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
    48ec:	eb05 0308 	add.w	r3, r5, r8
    48f0:	f813 9c01 	ldrb.w	r9, [r3, #-1]
    48f4:	f1b9 0f0a 	cmp.w	r9, #10
    48f8:	f040 80b4 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
		checksum_received = grid_msg_checksum_read(message, length);
    48fc:	4b80      	ldr	r3, [pc, #512]	; (4b00 <grid_port_receive_decode+0x28c>)
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    48fe:	4e81      	ldr	r6, [pc, #516]	; (4b04 <grid_port_receive_decode+0x290>)
		checksum_received = grid_msg_checksum_read(message, length);
    4900:	4641      	mov	r1, r8
    4902:	4628      	mov	r0, r5
    4904:	4798      	blx	r3
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    4906:	4641      	mov	r1, r8
		checksum_received = grid_msg_checksum_read(message, length);
    4908:	4682      	mov	sl, r0
		checksum_calculated = grid_msg_calculate_checksum_of_packet_string(message, length);
    490a:	4628      	mov	r0, r5
    490c:	47b0      	blx	r6
		if (checksum_calculated == checksum_received && error_flag == 0){
    490e:	4582      	cmp	sl, r0
    4910:	f040 81fc 	bne.w	4d0c <grid_port_receive_decode+0x498>
			if (message[1] == GRID_CONST_BRC){ // Broadcast message
    4914:	786b      	ldrb	r3, [r5, #1]
    4916:	2b0f      	cmp	r3, #15
    4918:	f040 810c 	bne.w	4b34 <grid_port_receive_decode+0x2c0>
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    491c:	f107 061f 	add.w	r6, r7, #31
				uint8_t error=0;
    4920:	f04f 0300 	mov.w	r3, #0
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4924:	f8df b204 	ldr.w	fp, [pc, #516]	; 4b2c <grid_port_receive_decode+0x2b8>
				uint8_t error=0;
    4928:	77fb      	strb	r3, [r7, #31]
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    492a:	2202      	movs	r2, #2
    492c:	4633      	mov	r3, r6
    492e:	2104      	movs	r1, #4
    4930:	4628      	mov	r0, r5
    4932:	47d8      	blx	fp
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4934:	4649      	mov	r1, r9
				uint8_t received_id  = grid_msg_get_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
    4936:	6078      	str	r0, [r7, #4]
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4938:	4633      	mov	r3, r6
    493a:	2202      	movs	r2, #2
    493c:	4628      	mov	r0, r5
    493e:	47d8      	blx	fp
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4940:	4633      	mov	r3, r6
				uint8_t received_age = grid_msg_get_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, &error);
    4942:	6038      	str	r0, [r7, #0]
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4944:	2202      	movs	r2, #2
    4946:	2106      	movs	r1, #6
    4948:	4628      	mov	r0, r5
    494a:	47d8      	blx	fp
    494c:	b2c3      	uxtb	r3, r0
    494e:	617b      	str	r3, [r7, #20]
    4950:	f1a3 0a7f 	sub.w	sl, r3, #127	; 0x7f
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4954:	2202      	movs	r2, #2
    4956:	4633      	mov	r3, r6
    4958:	2108      	movs	r1, #8
    495a:	4628      	mov	r0, r5
    495c:	47d8      	blx	fp
    495e:	b2c3      	uxtb	r3, r0
    4960:	613b      	str	r3, [r7, #16]
    4962:	f1a3 097f 	sub.w	r9, r3, #127	; 0x7f
				uint8_t received_rot = grid_msg_get_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
    4966:	2202      	movs	r2, #2
    4968:	4633      	mov	r3, r6
    496a:	210c      	movs	r1, #12
    496c:	4628      	mov	r0, r5
    496e:	47d8      	blx	fp
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    4970:	f642 7330 	movw	r3, #12080	; 0x2f30
				int8_t received_dx  = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4974:	fa4f fa8a 	sxtb.w	sl, sl
				uint8_t updated_rot = (received_rot + por->partner_fi)%4;
    4978:	5ce3      	ldrb	r3, [r4, r3]
    497a:	4418      	add	r0, r3
    497c:	f000 0203 	and.w	r2, r0, #3
    4980:	ee08 2a10 	vmov	s16, r2
				int8_t received_dy  = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error) - GRID_SYS_DEFAULT_POSITION;
    4984:	fa4f f989 	sxtb.w	r9, r9
				if (por->partner_fi == 0){ // 0 deg
    4988:	b143      	cbz	r3, 499c <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 1){ // 90 deg
    498a:	2b01      	cmp	r3, #1
    498c:	f040 8098 	bne.w	4ac0 <grid_port_receive_decode+0x24c>
					rotated_dx  -= received_dy;
    4990:	693b      	ldr	r3, [r7, #16]
    4992:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dy  += received_dx;
    4996:	46d1      	mov	r9, sl
					rotated_dx  -= received_dy;
    4998:	fa4f fa83 	sxtb.w	sl, r3
				uint8_t updated_dx = rotated_dx + GRID_SYS_DEFAULT_POSITION + por->dx;
    499c:	f642 7349 	movw	r3, #12105	; 0x2f49
    49a0:	f897 b000 	ldrb.w	fp, [r7]
    49a4:	5ce3      	ldrb	r3, [r4, r3]
    49a6:	337f      	adds	r3, #127	; 0x7f
    49a8:	449a      	add	sl, r3
    49aa:	fa5f f38a 	uxtb.w	r3, sl
    49ae:	60fb      	str	r3, [r7, #12]
				uint8_t updated_dy = rotated_dy + GRID_SYS_DEFAULT_POSITION + por->dy;
    49b0:	f642 734a 	movw	r3, #12106	; 0x2f4a
    49b4:	f814 a003 	ldrb.w	sl, [r4, r3]
    49b8:	f10a 0a7f 	add.w	sl, sl, #127	; 0x7f
    49bc:	44d1      	add	r9, sl
    49be:	fa5f f389 	uxtb.w	r3, r9
    49c2:	60bb      	str	r3, [r7, #8]
				if (received_dx + GRID_SYS_DEFAULT_POSITION == 0 && received_dy + GRID_SYS_DEFAULT_POSITION == 0)
    49c4:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
    49c8:	4313      	orrs	r3, r2
    49ca:	f897 a004 	ldrb.w	sl, [r7, #4]
    49ce:	d020      	beq.n	4a12 <grid_port_receive_decode+0x19e>
					grid_msg_set_parameter(message, GRID_BRC_ID_offset, GRID_BRC_ID_length, updated_id, &error);
    49d0:	f8df 915c 	ldr.w	r9, [pc, #348]	; 4b30 <grid_port_receive_decode+0x2bc>
    49d4:	9600      	str	r6, [sp, #0]
    49d6:	4653      	mov	r3, sl
    49d8:	2202      	movs	r2, #2
    49da:	2104      	movs	r1, #4
    49dc:	4628      	mov	r0, r5
    49de:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, updated_dx, &error);
    49e0:	9600      	str	r6, [sp, #0]
    49e2:	68fb      	ldr	r3, [r7, #12]
    49e4:	2202      	movs	r2, #2
    49e6:	2106      	movs	r1, #6
    49e8:	4628      	mov	r0, r5
    49ea:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, updated_dy, &error);
    49ec:	9600      	str	r6, [sp, #0]
    49ee:	68bb      	ldr	r3, [r7, #8]
    49f0:	2202      	movs	r2, #2
    49f2:	2108      	movs	r1, #8
    49f4:	4628      	mov	r0, r5
    49f6:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, updated_age, &error);
    49f8:	465b      	mov	r3, fp
    49fa:	2202      	movs	r2, #2
    49fc:	210a      	movs	r1, #10
    49fe:	9600      	str	r6, [sp, #0]
    4a00:	4628      	mov	r0, r5
    4a02:	47c8      	blx	r9
					grid_msg_set_parameter(message, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, updated_rot, &error);
    4a04:	ee18 3a10 	vmov	r3, s16
    4a08:	9600      	str	r6, [sp, #0]
    4a0a:	2202      	movs	r2, #2
    4a0c:	210c      	movs	r1, #12
    4a0e:	4628      	mov	r0, r5
    4a10:	47c8      	blx	r9
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a12:	68fb      	ldr	r3, [r7, #12]
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a14:	483c      	ldr	r0, [pc, #240]	; (4b08 <grid_port_receive_decode+0x294>)
				uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    4a16:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a1a:	68bb      	ldr	r3, [r7, #8]
    4a1c:	eb03 2a0a 	add.w	sl, r3, sl, lsl #8
    4a20:	eb0b 2a0a 	add.w	sl, fp, sl, lsl #8
				if (0 == grid_msg_find_recent(&grid_sys_state, fingerprint)){
    4a24:	4b39      	ldr	r3, [pc, #228]	; (4b0c <grid_port_receive_decode+0x298>)
    4a26:	4651      	mov	r1, sl
    4a28:	4798      	blx	r3
    4a2a:	b9d8      	cbnz	r0, 4a64 <grid_port_receive_decode+0x1f0>
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a2c:	4b35      	ldr	r3, [pc, #212]	; (4b04 <grid_port_receive_decode+0x290>)
    4a2e:	4641      	mov	r1, r8
    4a30:	4628      	mov	r0, r5
    4a32:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a34:	f504 542c 	add.w	r4, r4, #11008	; 0x2b00
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a38:	4b35      	ldr	r3, [pc, #212]	; (4b10 <grid_port_receive_decode+0x29c>)
    4a3a:	4602      	mov	r2, r0
    4a3c:	4641      	mov	r1, r8
    4a3e:	4628      	mov	r0, r5
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a40:	3434      	adds	r4, #52	; 0x34
					grid_msg_checksum_write(message, length, grid_msg_calculate_checksum_of_packet_string(message, length));
    4a42:	4798      	blx	r3
					if (grid_buffer_write_init(&por->rx_buffer, length)){
    4a44:	4b33      	ldr	r3, [pc, #204]	; (4b14 <grid_port_receive_decode+0x2a0>)
    4a46:	4641      	mov	r1, r8
    4a48:	4620      	mov	r0, r4
    4a4a:	4798      	blx	r3
    4a4c:	b150      	cbz	r0, 4a64 <grid_port_receive_decode+0x1f0>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4a4e:	4e32      	ldr	r6, [pc, #200]	; (4b18 <grid_port_receive_decode+0x2a4>)
    4a50:	44a8      	add	r8, r5
						for (uint16_t i=0; i<length; i++){
    4a52:	45a8      	cmp	r8, r5
    4a54:	d14d      	bne.n	4af2 <grid_port_receive_decode+0x27e>
						grid_buffer_write_acknowledge(&por->rx_buffer);
    4a56:	4b31      	ldr	r3, [pc, #196]	; (4b1c <grid_port_receive_decode+0x2a8>)
    4a58:	4620      	mov	r0, r4
    4a5a:	4798      	blx	r3
						grid_msg_push_recent(&grid_sys_state, fingerprint);
    4a5c:	482a      	ldr	r0, [pc, #168]	; (4b08 <grid_port_receive_decode+0x294>)
    4a5e:	4b30      	ldr	r3, [pc, #192]	; (4b20 <grid_port_receive_decode+0x2ac>)
    4a60:	4651      	mov	r1, sl
    4a62:	4798      	blx	r3
}
    4a64:	3724      	adds	r7, #36	; 0x24
    4a66:	46bd      	mov	sp, r7
    4a68:	ecbd 8b02 	vpop	{d8}
    4a6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		buffer[i] = por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE];
    4a70:	18d6      	adds	r6, r2, r3
    4a72:	fbb6 f1f0 	udiv	r1, r6, r0
    4a76:	fb00 6111 	mls	r1, r0, r1, r6
    4a7a:	4421      	add	r1, r4
    4a7c:	5d4e      	ldrb	r6, [r1, r5]
    4a7e:	f809 6002 	strb.w	r6, [r9, r2]
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE]=0;
    4a82:	f801 c005 	strb.w	ip, [r1, r5]
	for (uint16_t i = 0; i<length; i++){
    4a86:	3201      	adds	r2, #1
    4a88:	e70b      	b.n	48a2 <grid_port_receive_decode+0x2e>
		por->rx_double_buffer[(por->rx_double_buffer_read_start_index + i)%GRID_DOUBLE_BUFFER_RX_SIZE] = 0;
    4a8a:	18d6      	adds	r6, r2, r3
    4a8c:	fbb6 f1f0 	udiv	r1, r6, r0
    4a90:	fb00 6111 	mls	r1, r0, r1, r6
    4a94:	4421      	add	r1, r4
    4a96:	3201      	adds	r2, #1
    4a98:	f801 e00c 	strb.w	lr, [r1, ip]
	for (uint16_t i = 0; i<length; i++){
    4a9c:	e70c      	b.n	48b8 <grid_port_receive_decode+0x44>
		if (buffer[i] == GRID_CONST_SOH){
    4a9e:	f819 2006 	ldrb.w	r2, [r9, r6]
    4aa2:	2a01      	cmp	r2, #1
    4aa4:	d109      	bne.n	4aba <grid_port_receive_decode+0x246>
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4aa6:	4651      	mov	r1, sl
    4aa8:	4658      	mov	r0, fp
    4aaa:	4798      	blx	r3
			length -= i;
    4aac:	eba8 0806 	sub.w	r8, r8, r6
			GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Frame Start Offset");
    4ab0:	4b12      	ldr	r3, [pc, #72]	; (4afc <grid_port_receive_decode+0x288>)
			length -= i;
    4ab2:	fa1f f888 	uxth.w	r8, r8
			message = &buffer[i];
    4ab6:	eb09 0506 	add.w	r5, r9, r6
	for (uint16_t i = 1; i<length; i++){
    4aba:	3601      	adds	r6, #1
    4abc:	b2b6      	uxth	r6, r6
    4abe:	e70e      	b.n	48de <grid_port_receive_decode+0x6a>
				else if(por->partner_fi == 2){ // 180 deg
    4ac0:	2b02      	cmp	r3, #2
    4ac2:	d10a      	bne.n	4ada <grid_port_receive_decode+0x266>
					rotated_dx  -= received_dx;
    4ac4:	697b      	ldr	r3, [r7, #20]
    4ac6:	f1c3 0a7f 	rsb	sl, r3, #127	; 0x7f
					rotated_dy  -= received_dy;
    4aca:	693b      	ldr	r3, [r7, #16]
					rotated_dx  -= received_dx;
    4acc:	fa4f fa8a 	sxtb.w	sl, sl
					rotated_dy  -= received_dy;
    4ad0:	f1c3 097f 	rsb	r9, r3, #127	; 0x7f
					rotated_dy  -= received_dx;
    4ad4:	fa4f f989 	sxtb.w	r9, r9
    4ad8:	e760      	b.n	499c <grid_port_receive_decode+0x128>
				else if(por->partner_fi == 3){ // 270 deg
    4ada:	2b03      	cmp	r3, #3
    4adc:	d105      	bne.n	4aea <grid_port_receive_decode+0x276>
					rotated_dy  -= received_dx;
    4ade:	697b      	ldr	r3, [r7, #20]
    4ae0:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
					rotated_dx  += received_dy;
    4ae4:	46ca      	mov	sl, r9
					rotated_dy  -= received_dx;
    4ae6:	4699      	mov	r9, r3
    4ae8:	e7f4      	b.n	4ad4 <grid_port_receive_decode+0x260>
				int8_t rotated_dy = 0;
    4aea:	f04f 0900 	mov.w	r9, #0
				int8_t rotated_dx = 0;
    4aee:	46ca      	mov	sl, r9
    4af0:	e754      	b.n	499c <grid_port_receive_decode+0x128>
							grid_buffer_write_character(&por->rx_buffer, message[i]);
    4af2:	f815 1b01 	ldrb.w	r1, [r5], #1
    4af6:	4620      	mov	r0, r4
    4af8:	47b0      	blx	r6
						for (uint16_t i=0; i<length; i++){
    4afa:	e7aa      	b.n	4a52 <grid_port_receive_decode+0x1de>
    4afc:	00014eb1 	.word	0x00014eb1
    4b00:	0000a2f9 	.word	0x0000a2f9
    4b04:	0000a2e1 	.word	0x0000a2e1
    4b08:	2000f008 	.word	0x2000f008
    4b0c:	0000a351 	.word	0x0000a351
    4b10:	0000a315 	.word	0x0000a315
    4b14:	000047f1 	.word	0x000047f1
    4b18:	0000482d 	.word	0x0000482d
    4b1c:	0000484d 	.word	0x0000484d
    4b20:	0000a36b 	.word	0x0000a36b
    4b24:	0001659c 	.word	0x0001659c
    4b28:	000165af 	.word	0x000165af
    4b2c:	0000a325 	.word	0x0000a325
    4b30:	0000a33d 	.word	0x0000a33d
			else if (message[1] == GRID_CONST_DCT){ // Direct Message
    4b34:	2b0e      	cmp	r3, #14
    4b36:	f040 80e5 	bne.w	4d04 <grid_port_receive_decode+0x490>
				if (message[2] == GRID_CONST_ACK){
    4b3a:	78ab      	ldrb	r3, [r5, #2]
    4b3c:	2b07      	cmp	r3, #7
    4b3e:	d191      	bne.n	4a64 <grid_port_receive_decode+0x1f0>
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b40:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 4d20 <grid_port_receive_decode+0x4ac>
    4b44:	2200      	movs	r2, #0
    4b46:	2102      	movs	r1, #2
    4b48:	f105 0008 	add.w	r0, r5, #8
    4b4c:	47c8      	blx	r9
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b4e:	2200      	movs	r2, #0
					uint8_t local_token_received = grid_sys_read_hex_string_value(&message[8], 2, error_flag);
    4b50:	fa5f fa80 	uxtb.w	sl, r0
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b54:	2102      	movs	r1, #2
    4b56:	1da8      	adds	r0, r5, #6
    4b58:	47c8      	blx	r9
					if (por->partner_status == 0){
    4b5a:	f642 724b 	movw	r2, #12107	; 0x2f4b
					uint8_t partner_token_received = grid_sys_read_hex_string_value(&message[6], 2, error_flag);
    4b5e:	fa5f fb80 	uxtb.w	fp, r0
					if (por->partner_status == 0){
    4b62:	5ca2      	ldrb	r2, [r4, r2]
    4b64:	2a00      	cmp	r2, #0
    4b66:	d172      	bne.n	4c4e <grid_port_receive_decode+0x3da>
						if (por->ping_local_token == 255){ // I have no clue
    4b68:	f642 7931 	movw	r9, #12081	; 0x2f31
    4b6c:	f814 2009 	ldrb.w	r2, [r4, r9]
    4b70:	2aff      	cmp	r2, #255	; 0xff
    4b72:	d11b      	bne.n	4bac <grid_port_receive_decode+0x338>
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4b74:	4a66      	ldr	r2, [pc, #408]	; (4d10 <grid_port_receive_decode+0x49c>)
    4b76:	4867      	ldr	r0, [pc, #412]	; (4d14 <grid_port_receive_decode+0x4a0>)
    4b78:	4790      	blx	r2
    4b7a:	f000 027f 	and.w	r2, r0, #127	; 0x7f
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4b7e:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_local_token  = grid_sys_rtc_get_time(&grid_sys_state)%128;
    4b82:	f804 2009 	strb.w	r2, [r4, r9]
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4b86:	4b64      	ldr	r3, [pc, #400]	; (4d18 <grid_port_receive_decode+0x4a4>)
    4b88:	2102      	movs	r1, #2
    4b8a:	3039      	adds	r0, #57	; 0x39
    4b8c:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4b8e:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4b92:	f642 7247 	movw	r2, #12103	; 0x2f47
    4b96:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4b9a:	5ca1      	ldrb	r1, [r4, r2]
    4b9c:	6179      	str	r1, [r7, #20]
    4b9e:	4648      	mov	r0, r9
    4ba0:	47b0      	blx	r6
    4ba2:	6979      	ldr	r1, [r7, #20]
    4ba4:	4b5d      	ldr	r3, [pc, #372]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4ba6:	4602      	mov	r2, r0
    4ba8:	4648      	mov	r0, r9
    4baa:	4798      	blx	r3
						if (partner_token_received != por->ping_partner_token){
    4bac:	f642 7232 	movw	r2, #12082	; 0x2f32
    4bb0:	5ca1      	ldrb	r1, [r4, r2]
    4bb2:	4559      	cmp	r1, fp
    4bb4:	d017      	beq.n	4be6 <grid_port_receive_decode+0x372>
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bb6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = partner_token_received;							
    4bba:	f804 b002 	strb.w	fp, [r4, r2]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, partner_token_received);
    4bbe:	4b56      	ldr	r3, [pc, #344]	; (4d18 <grid_port_receive_decode+0x4a4>)
    4bc0:	465a      	mov	r2, fp
    4bc2:	2102      	movs	r1, #2
    4bc4:	303b      	adds	r0, #59	; 0x3b
    4bc6:	4798      	blx	r3
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4bc8:	f504 593c 	add.w	r9, r4, #12032	; 0x2f00
    4bcc:	f642 7347 	movw	r3, #12103	; 0x2f47
    4bd0:	f109 0933 	add.w	r9, r9, #51	; 0x33
    4bd4:	5ce1      	ldrb	r1, [r4, r3]
    4bd6:	6179      	str	r1, [r7, #20]
    4bd8:	4648      	mov	r0, r9
    4bda:	47b0      	blx	r6
    4bdc:	6979      	ldr	r1, [r7, #20]
    4bde:	4b4f      	ldr	r3, [pc, #316]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4be0:	4602      	mov	r2, r0
    4be2:	4648      	mov	r0, r9
    4be4:	4798      	blx	r3
						if (por->ping_local_token != local_token_received){
    4be6:	f642 7331 	movw	r3, #12081	; 0x2f31
    4bea:	5ce3      	ldrb	r3, [r4, r3]
    4bec:	4553      	cmp	r3, sl
    4bee:	d129      	bne.n	4c44 <grid_port_receive_decode+0x3d0>
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4bf0:	7a62      	ldrb	r2, [r4, #9]
    4bf2:	78eb      	ldrb	r3, [r5, #3]
    4bf4:	1a9b      	subs	r3, r3, r2
    4bf6:	3306      	adds	r3, #6
    4bf8:	425a      	negs	r2, r3
    4bfa:	f002 0203 	and.w	r2, r2, #3
    4bfe:	f003 0303 	and.w	r3, r3, #3
    4c02:	bf58      	it	pl
    4c04:	4253      	negpl	r3, r2
    4c06:	f642 7230 	movw	r2, #12080	; 0x2f30
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c0a:	f1a8 000a 	sub.w	r0, r8, #10
							por->partner_fi = (message[3] - por->direction + 6)%4;
    4c0e:	54a3      	strb	r3, [r4, r2]
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c10:	2102      	movs	r1, #2
    4c12:	4b43      	ldr	r3, [pc, #268]	; (4d20 <grid_port_receive_decode+0x4ac>)
    4c14:	2200      	movs	r2, #0
    4c16:	4428      	add	r0, r5
    4c18:	4798      	blx	r3
    4c1a:	f642 732c 	movw	r3, #12076	; 0x2f2c
							por->partner_status = 1;
    4c1e:	2201      	movs	r2, #1
							por->partner_hwcfg = grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c20:	50e0      	str	r0, [r4, r3]
							por->partner_status = 1;
    4c22:	f642 734b 	movw	r3, #12107	; 0x2f4b
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c26:	493f      	ldr	r1, [pc, #252]	; (4d24 <grid_port_receive_decode+0x4b0>)
							por->partner_status = 1;
    4c28:	54e2      	strb	r2, [r4, r3]
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c2a:	483f      	ldr	r0, [pc, #252]	; (4d28 <grid_port_receive_decode+0x4b4>)
    4c2c:	4b3f      	ldr	r3, [pc, #252]	; (4d2c <grid_port_receive_decode+0x4b8>)
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c2e:	4d40      	ldr	r5, [pc, #256]	; (4d30 <grid_port_receive_decode+0x4bc>)
							GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Connect");
    4c30:	4798      	blx	r3
							grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN
    4c32:	2300      	movs	r3, #0
    4c34:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
    4c38:	e9cd 3200 	strd	r3, r2, [sp]
    4c3c:	4835      	ldr	r0, [pc, #212]	; (4d14 <grid_port_receive_decode+0x4a0>)
    4c3e:	22ff      	movs	r2, #255	; 0xff
    4c40:	4619      	mov	r1, r3
    4c42:	47a8      	blx	r5
						por->ping_flag = 1;
    4c44:	f642 7348 	movw	r3, #12104	; 0x2f48
    4c48:	2201      	movs	r2, #1
    4c4a:	54e2      	strb	r2, [r4, r3]
    4c4c:	e70a      	b.n	4a64 <grid_port_receive_decode+0x1f0>
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c4e:	7a61      	ldrb	r1, [r4, #9]
    4c50:	78ea      	ldrb	r2, [r5, #3]
    4c52:	1a52      	subs	r2, r2, r1
    4c54:	3206      	adds	r2, #6
    4c56:	4251      	negs	r1, r2
						validator &= local_token_received == por->ping_local_token;
    4c58:	f642 7031 	movw	r0, #12081	; 0x2f31
						validator &= partner_token_received == por->ping_partner_token;
    4c5c:	f642 7c32 	movw	ip, #12082	; 0x2f32
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c60:	f001 0103 	and.w	r1, r1, #3
						validator &= local_token_received == por->ping_local_token;
    4c64:	5c20      	ldrb	r0, [r4, r0]
						validator &= partner_token_received == por->ping_partner_token;
    4c66:	f814 c00c 	ldrb.w	ip, [r4, ip]
						validator &= por->partner_fi == (message[3] - por->direction + 6)%4;
    4c6a:	f002 0203 	and.w	r2, r2, #3
    4c6e:	bf58      	it	pl
    4c70:	424a      	negpl	r2, r1
    4c72:	f642 7130 	movw	r1, #12080	; 0x2f30
    4c76:	4550      	cmp	r0, sl
    4c78:	bf08      	it	eq
    4c7a:	45dc      	cmpeq	ip, fp
    4c7c:	5c61      	ldrb	r1, [r4, r1]
    4c7e:	bf0c      	ite	eq
    4c80:	f04f 0a01 	moveq.w	sl, #1
    4c84:	f04f 0a00 	movne.w	sl, #0
						validator &= por->partner_hwcfg == grid_sys_read_hex_string_value(&message[length-10], 2, error_flag);
    4c88:	f642 732c 	movw	r3, #12076	; 0x2f2c
    4c8c:	f1a8 000a 	sub.w	r0, r8, #10
    4c90:	428a      	cmp	r2, r1
    4c92:	bf14      	ite	ne
    4c94:	f04f 0a00 	movne.w	sl, #0
    4c98:	f00a 0a01 	andeq.w	sl, sl, #1
    4c9c:	4428      	add	r0, r5
    4c9e:	2200      	movs	r2, #0
    4ca0:	2102      	movs	r1, #2
    4ca2:	f854 b003 	ldr.w	fp, [r4, r3]
    4ca6:	47c8      	blx	r9
						if (validator == 1){
    4ca8:	4558      	cmp	r0, fp
    4caa:	d103      	bne.n	4cb4 <grid_port_receive_decode+0x440>
    4cac:	f1ba 0f00 	cmp.w	sl, #0
    4cb0:	f47f aed8 	bne.w	4a64 <grid_port_receive_decode+0x1f0>
							por->partner_status = 0;
    4cb4:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4cb8:	2200      	movs	r2, #0
    4cba:	54e2      	strb	r2, [r4, r3]
							por->ping_local_token = 255;
    4cbc:	f642 7831 	movw	r8, #12081	; 0x2f31
							por->ping_partner_token = 255;
    4cc0:	f642 7332 	movw	r3, #12082	; 0x2f32
    4cc4:	22ff      	movs	r2, #255	; 0xff
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4cc6:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
							por->ping_partner_token = 255;
    4cca:	54e2      	strb	r2, [r4, r3]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4ccc:	4d12      	ldr	r5, [pc, #72]	; (4d18 <grid_port_receive_decode+0x4a4>)
							por->ping_local_token = 255;
    4cce:	f804 2008 	strb.w	r2, [r4, r8]
							grid_sys_write_hex_string_value(&por->ping_packet[8], 2, por->ping_partner_token);
    4cd2:	2102      	movs	r1, #2
    4cd4:	303b      	adds	r0, #59	; 0x3b
    4cd6:	47a8      	blx	r5
							grid_sys_write_hex_string_value(&por->ping_packet[6], 2, por->ping_local_token);
    4cd8:	f504 503c 	add.w	r0, r4, #12032	; 0x2f00
    4cdc:	f814 2008 	ldrb.w	r2, [r4, r8]
    4ce0:	2102      	movs	r1, #2
    4ce2:	3039      	adds	r0, #57	; 0x39
    4ce4:	47a8      	blx	r5
							grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    4ce6:	f642 7347 	movw	r3, #12103	; 0x2f47
    4cea:	f504 553c 	add.w	r5, r4, #12032	; 0x2f00
    4cee:	3533      	adds	r5, #51	; 0x33
    4cf0:	5ce1      	ldrb	r1, [r4, r3]
    4cf2:	6179      	str	r1, [r7, #20]
    4cf4:	4628      	mov	r0, r5
    4cf6:	47b0      	blx	r6
    4cf8:	6979      	ldr	r1, [r7, #20]
    4cfa:	4b08      	ldr	r3, [pc, #32]	; (4d1c <grid_port_receive_decode+0x4a8>)
    4cfc:	4602      	mov	r2, r0
    4cfe:	4628      	mov	r0, r5
    4d00:	4798      	blx	r3
    4d02:	e6af      	b.n	4a64 <grid_port_receive_decode+0x1f0>
				printf("{\"type\": \"WARNING\", \"data\": [\"Unknow Message Type\"]}\r\n");
    4d04:	480b      	ldr	r0, [pc, #44]	; (4d34 <grid_port_receive_decode+0x4c0>)
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d06:	4b0c      	ldr	r3, [pc, #48]	; (4d38 <grid_port_receive_decode+0x4c4>)
    4d08:	4798      	blx	r3
	return;
    4d0a:	e6ab      	b.n	4a64 <grid_port_receive_decode+0x1f0>
			printf("{\"type\": \"WARNING\", \"data\": [\"Invalid Checksum\"]}\r\n");
    4d0c:	480b      	ldr	r0, [pc, #44]	; (4d3c <grid_port_receive_decode+0x4c8>)
    4d0e:	e7fa      	b.n	4d06 <grid_port_receive_decode+0x492>
    4d10:	0000a0b9 	.word	0x0000a0b9
    4d14:	2000f008 	.word	0x2000f008
    4d18:	0000a199 	.word	0x0000a199
    4d1c:	0000a315 	.word	0x0000a315
    4d20:	0000a171 	.word	0x0000a171
    4d24:	000165d4 	.word	0x000165d4
    4d28:	000165af 	.word	0x000165af
    4d2c:	00014eb1 	.word	0x00014eb1
    4d30:	0000a123 	.word	0x0000a123
    4d34:	000165dc 	.word	0x000165dc
    4d38:	00014fe5 	.word	0x00014fe5
    4d3c:	00016612 	.word	0x00016612

00004d40 <grid_port_receive_task>:
void grid_port_receive_task(struct grid_port* por){
    4d40:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	if (por->usart_error_flag == 1){
    4d42:	7e03      	ldrb	r3, [r0, #24]
    4d44:	2b01      	cmp	r3, #1
void grid_port_receive_task(struct grid_port* por){
    4d46:	4604      	mov	r4, r0
	if (por->usart_error_flag == 1){
    4d48:	d10d      	bne.n	4d66 <grid_port_receive_task+0x26>
		por->usart_error_flag = 0;
    4d4a:	2500      	movs	r5, #0
    4d4c:	7605      	strb	r5, [r0, #24]
		grid_port_reset_receiver(por);
    4d4e:	4b53      	ldr	r3, [pc, #332]	; (4e9c <grid_port_receive_task+0x15c>)
    4d50:	4798      	blx	r3
		grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500); // White triangle
    4d52:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d56:	e9cd 5300 	strd	r5, r3, [sp]
    4d5a:	23ff      	movs	r3, #255	; 0xff
    4d5c:	4850      	ldr	r0, [pc, #320]	; (4ea0 <grid_port_receive_task+0x160>)
    4d5e:	4d51      	ldr	r5, [pc, #324]	; (4ea4 <grid_port_receive_task+0x164>)
    4d60:	461a      	mov	r2, r3
    4d62:	4619      	mov	r1, r3
    4d64:	47a8      	blx	r5
	if	(por->rx_double_buffer_status == 0){
    4d66:	6a25      	ldr	r5, [r4, #32]
    4d68:	bb7d      	cbnz	r5, 4dca <grid_port_receive_task+0x8a>
		if (por->usart!=NULL){ // His is GRID usart port
    4d6a:	6863      	ldr	r3, [r4, #4]
    4d6c:	b1cb      	cbz	r3, 4da2 <grid_port_receive_task+0x62>
			if (por->rx_double_buffer_timeout > 1000){
    4d6e:	69e3      	ldr	r3, [r4, #28]
    4d70:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
    4d74:	d93e      	bls.n	4df4 <grid_port_receive_task+0xb4>
				if (por->partner_status == 1){
    4d76:	f642 734b 	movw	r3, #12107	; 0x2f4b
    4d7a:	5ce3      	ldrb	r3, [r4, r3]
    4d7c:	2b01      	cmp	r3, #1
    4d7e:	d12c      	bne.n	4dda <grid_port_receive_task+0x9a>
					GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout Disconnect & Reset Receiver");
    4d80:	4949      	ldr	r1, [pc, #292]	; (4ea8 <grid_port_receive_task+0x168>)
    4d82:	4b4a      	ldr	r3, [pc, #296]	; (4eac <grid_port_receive_task+0x16c>)
    4d84:	484a      	ldr	r0, [pc, #296]	; (4eb0 <grid_port_receive_task+0x170>)
    4d86:	4798      	blx	r3
					grid_port_reset_receiver(por);
    4d88:	4b44      	ldr	r3, [pc, #272]	; (4e9c <grid_port_receive_task+0x15c>)
    4d8a:	4620      	mov	r0, r4
    4d8c:	4798      	blx	r3
					grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 500);
    4d8e:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
    4d92:	e9cd 5300 	strd	r5, r3, [sp]
    4d96:	23ff      	movs	r3, #255	; 0xff
    4d98:	4841      	ldr	r0, [pc, #260]	; (4ea0 <grid_port_receive_task+0x160>)
    4d9a:	4d42      	ldr	r5, [pc, #264]	; (4ea4 <grid_port_receive_task+0x164>)
    4d9c:	461a      	mov	r2, r3
    4d9e:	4619      	mov	r1, r3
    4da0:	47a8      	blx	r5
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4da2:	f241 3687 	movw	r6, #4999	; 0x1387
void grid_port_receive_task(struct grid_port* por){
    4da6:	f44f 71f5 	mov.w	r1, #490	; 0x1ea
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4daa:	f241 30b4 	movw	r0, #5044	; 0x13b4
    4dae:	46b4      	mov	ip, r6
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4db0:	f241 3788 	movw	r7, #5000	; 0x1388
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4db4:	f241 3e86 	movw	lr, #4998	; 0x1386
			if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 10){ // \n
    4db8:	6a62      	ldr	r2, [r4, #36]	; 0x24
    4dba:	18a3      	adds	r3, r4, r2
    4dbc:	5c1b      	ldrb	r3, [r3, r0]
    4dbe:	2b0a      	cmp	r3, #10
    4dc0:	d11b      	bne.n	4dfa <grid_port_receive_task+0xba>
				por->rx_double_buffer_timeout = 0;
    4dc2:	2300      	movs	r3, #0
    4dc4:	2501      	movs	r5, #1
    4dc6:	e9c4 3507 	strd	r3, r5, [r4, #28]
	if (por->rx_double_buffer_read_start_index < por->rx_double_buffer_seek_start_index){
    4dca:	e9d4 2109 	ldrd	r2, r1, [r4, #36]	; 0x24
    4dce:	4291      	cmp	r1, r2
    4dd0:	d359      	bcc.n	4e86 <grid_port_receive_task+0x146>
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4dd2:	f502 529c 	add.w	r2, r2, #4992	; 0x1380
    4dd6:	3209      	adds	r2, #9
    4dd8:	e056      	b.n	4e88 <grid_port_receive_task+0x148>
					if (por->rx_double_buffer_read_start_index == 0 && por->rx_double_buffer_seek_start_index == 0){
    4dda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    4ddc:	b913      	cbnz	r3, 4de4 <grid_port_receive_task+0xa4>
    4dde:	6a63      	ldr	r3, [r4, #36]	; 0x24
    4de0:	2b00      	cmp	r3, #0
    4de2:	d0de      	beq.n	4da2 <grid_port_receive_task+0x62>
						GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_PORT, "Timeout & Reset Receiver");
    4de4:	4933      	ldr	r1, [pc, #204]	; (4eb4 <grid_port_receive_task+0x174>)
    4de6:	4b31      	ldr	r3, [pc, #196]	; (4eac <grid_port_receive_task+0x16c>)
    4de8:	4831      	ldr	r0, [pc, #196]	; (4eb0 <grid_port_receive_task+0x170>)
    4dea:	4798      	blx	r3
						grid_port_reset_receiver(por);
    4dec:	4b2b      	ldr	r3, [pc, #172]	; (4e9c <grid_port_receive_task+0x15c>)
    4dee:	4620      	mov	r0, r4
    4df0:	4798      	blx	r3
    4df2:	e7d6      	b.n	4da2 <grid_port_receive_task+0x62>
				por->rx_double_buffer_timeout++;
    4df4:	3301      	adds	r3, #1
    4df6:	61e3      	str	r3, [r4, #28]
    4df8:	e7d3      	b.n	4da2 <grid_port_receive_task+0x62>
			else if (por->rx_double_buffer[por->rx_double_buffer_seek_start_index] == 0){
    4dfa:	b923      	cbnz	r3, 4e06 <grid_port_receive_task+0xc6>
	if (por->rx_double_buffer_status == 0){
    4dfc:	6a23      	ldr	r3, [r4, #32]
    4dfe:	2b00      	cmp	r3, #0
    4e00:	d1e3      	bne.n	4dca <grid_port_receive_task+0x8a>
}
    4e02:	b003      	add	sp, #12
    4e04:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (por->rx_double_buffer_seek_start_index == por->rx_double_buffer_read_start_index-1)
    4e06:	6aa5      	ldr	r5, [r4, #40]	; 0x28
    4e08:	1e6b      	subs	r3, r5, #1
    4e0a:	429a      	cmp	r2, r3
    4e0c:	d10d      	bne.n	4e2a <grid_port_receive_task+0xea>
				grid_port_reset_receiver(por);	
    4e0e:	4b23      	ldr	r3, [pc, #140]	; (4e9c <grid_port_receive_task+0x15c>)
    4e10:	4620      	mov	r0, r4
    4e12:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 255, 0, 0, 2, 200); // RED
    4e14:	2302      	movs	r3, #2
    4e16:	20c8      	movs	r0, #200	; 0xc8
    4e18:	e9cd 3000 	strd	r3, r0, [sp]
    4e1c:	2300      	movs	r3, #0
    4e1e:	461a      	mov	r2, r3
    4e20:	21ff      	movs	r1, #255	; 0xff
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e22:	481f      	ldr	r0, [pc, #124]	; (4ea0 <grid_port_receive_task+0x160>)
    4e24:	4c1f      	ldr	r4, [pc, #124]	; (4ea4 <grid_port_receive_task+0x164>)
    4e26:	47a0      	blx	r4
				return;
    4e28:	e7eb      	b.n	4e02 <grid_port_receive_task+0xc2>
			if (por->rx_double_buffer_seek_start_index == GRID_DOUBLE_BUFFER_RX_SIZE-1 && por->rx_double_buffer_read_start_index == 0)
    4e2a:	42b2      	cmp	r2, r6
    4e2c:	d10b      	bne.n	4e46 <grid_port_receive_task+0x106>
    4e2e:	b955      	cbnz	r5, 4e46 <grid_port_receive_task+0x106>
				grid_port_reset_receiver(por);
    4e30:	4b1a      	ldr	r3, [pc, #104]	; (4e9c <grid_port_receive_task+0x15c>)
    4e32:	4620      	mov	r0, r4
    4e34:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 2, 200); // RED
    4e36:	2302      	movs	r3, #2
    4e38:	21c8      	movs	r1, #200	; 0xc8
    4e3a:	e9cd 3100 	strd	r3, r1, [sp]
    4e3e:	22ff      	movs	r2, #255	; 0xff
    4e40:	462b      	mov	r3, r5
    4e42:	4629      	mov	r1, r5
    4e44:	e7ed      	b.n	4e22 <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer[(por->rx_double_buffer_read_start_index + GRID_DOUBLE_BUFFER_RX_SIZE -1)%GRID_DOUBLE_BUFFER_RX_SIZE] !=0)
    4e46:	4465      	add	r5, ip
    4e48:	fbb5 f3f7 	udiv	r3, r5, r7
    4e4c:	fb07 5513 	mls	r5, r7, r3, r5
    4e50:	4425      	add	r5, r4
    4e52:	5c2b      	ldrb	r3, [r5, r0]
    4e54:	b153      	cbz	r3, 4e6c <grid_port_receive_task+0x12c>
				grid_port_reset_receiver(por);
    4e56:	4b11      	ldr	r3, [pc, #68]	; (4e9c <grid_port_receive_task+0x15c>)
    4e58:	4620      	mov	r0, r4
    4e5a:	4798      	blx	r3
				grid_sys_alert_set_alert(&grid_sys_state, 0, 0, 255, 2, 200); // RED
    4e5c:	2302      	movs	r3, #2
    4e5e:	22c8      	movs	r2, #200	; 0xc8
    4e60:	e9cd 3200 	strd	r3, r2, [sp]
    4e64:	2200      	movs	r2, #0
    4e66:	23ff      	movs	r3, #255	; 0xff
    4e68:	4611      	mov	r1, r2
    4e6a:	e7da      	b.n	4e22 <grid_port_receive_task+0xe2>
			if (por->rx_double_buffer_seek_start_index < GRID_DOUBLE_BUFFER_RX_SIZE-1){
    4e6c:	4572      	cmp	r2, lr
				por->rx_double_buffer_seek_start_index++;
    4e6e:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
    4e72:	bf98      	it	ls
    4e74:	3201      	addls	r2, #1
    4e76:	b289      	uxth	r1, r1
				por->rx_double_buffer_timeout = 0;
    4e78:	61e3      	str	r3, [r4, #28]
				por->rx_double_buffer_seek_start_index++;
    4e7a:	bf94      	ite	ls
    4e7c:	6262      	strls	r2, [r4, #36]	; 0x24
				por->rx_double_buffer_seek_start_index=0;
    4e7e:	6263      	strhi	r3, [r4, #36]	; 0x24
		for(uint16_t i = 0; i<490; i++){
    4e80:	2900      	cmp	r1, #0
    4e82:	d199      	bne.n	4db8 <grid_port_receive_task+0x78>
    4e84:	e7ba      	b.n	4dfc <grid_port_receive_task+0xbc>
		length = por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e86:	3201      	adds	r2, #1
		length = GRID_DOUBLE_BUFFER_RX_SIZE + por->rx_double_buffer_seek_start_index - por->rx_double_buffer_read_start_index + 1;
    4e88:	1a52      	subs	r2, r2, r1
	grid_port_receive_decode(por, por->rx_double_buffer_read_start_index, length);
    4e8a:	4b0b      	ldr	r3, [pc, #44]	; (4eb8 <grid_port_receive_task+0x178>)
    4e8c:	b292      	uxth	r2, r2
    4e8e:	b289      	uxth	r1, r1
    4e90:	4620      	mov	r0, r4
    4e92:	4798      	blx	r3
	por->rx_double_buffer_status = 0;
    4e94:	2300      	movs	r3, #0
    4e96:	6223      	str	r3, [r4, #32]
    4e98:	e7b3      	b.n	4e02 <grid_port_receive_task+0xc2>
    4e9a:	bf00      	nop
    4e9c:	000046e9 	.word	0x000046e9
    4ea0:	2000f008 	.word	0x2000f008
    4ea4:	0000a123 	.word	0x0000a123
    4ea8:	00016645 	.word	0x00016645
    4eac:	00014eb1 	.word	0x00014eb1
    4eb0:	000165af 	.word	0x000165af
    4eb4:	00016669 	.word	0x00016669
    4eb8:	00004875 	.word	0x00004875

00004ebc <grid_buffer_read_size>:
	return 1;
}

uint16_t grid_buffer_read_size(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4ebc:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4ec0:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4ec4:	428b      	cmp	r3, r1
uint16_t grid_buffer_read_size(struct grid_buffer* buf){
    4ec6:	b5f0      	push	{r4, r5, r6, r7, lr}
    4ec8:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop) {
    4eca:	d000      	beq.n	4ece <grid_buffer_read_size+0x12>
		while(1){
    4ecc:	e7fe      	b.n	4ecc <grid_buffer_read_size+0x10>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4ece:	f8b0 63ea 	ldrh.w	r6, [r0, #1002]	; 0x3ea
    4ed2:	42b3      	cmp	r3, r6
    4ed4:	d000      	beq.n	4ed8 <grid_buffer_read_size+0x1c>
		while(1){
    4ed6:	e7fe      	b.n	4ed6 <grid_buffer_read_size+0x1a>
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	
	if (buf->read_start == buf->write_start) {
    4ed8:	f8b0 73f2 	ldrh.w	r7, [r0, #1010]	; 0x3f2
    4edc:	42be      	cmp	r6, r7
    4ede:	d016      	beq.n	4f0e <grid_buffer_read_size+0x52>
	}
	
	
	
	// Seek message end character
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4ee0:	8805      	ldrh	r5, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4ee2:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4ee4:	b2a3      	uxth	r3, r4
    4ee6:	429d      	cmp	r5, r3
    4ee8:	d800      	bhi.n	4eec <grid_buffer_read_size+0x30>
		}
		
		
	}
	
	while(1){
    4eea:	e7fe      	b.n	4eea <grid_buffer_read_size+0x2e>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4eec:	1930      	adds	r0, r6, r4
    4eee:	fbb0 f1f5 	udiv	r1, r0, r5
    4ef2:	fb05 0111 	mls	r1, r5, r1, r0
		if (index == buf->write_start) return 0;
    4ef6:	b288      	uxth	r0, r1
    4ef8:	4287      	cmp	r7, r0
    4efa:	d008      	beq.n	4f0e <grid_buffer_read_size+0x52>
		if (buf->buffer_storage[index] == '\n'){
    4efc:	4411      	add	r1, r2
    4efe:	3301      	adds	r3, #1
    4f00:	b298      	uxth	r0, r3
    4f02:	788b      	ldrb	r3, [r1, #2]
    4f04:	2b0a      	cmp	r3, #10
    4f06:	f104 0401 	add.w	r4, r4, #1
    4f0a:	d1eb      	bne.n	4ee4 <grid_buffer_read_size+0x28>
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f0c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f0e:	2000      	movs	r0, #0
    4f10:	e7fc      	b.n	4f0c <grid_buffer_read_size+0x50>

00004f12 <grid_buffer_read_init>:

uint16_t grid_buffer_read_init(struct grid_buffer* buf){
	
	if (buf->read_active != buf->read_stop) {
    4f12:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4f16:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f1a:	4293      	cmp	r3, r2
uint16_t grid_buffer_read_init(struct grid_buffer* buf){
    4f1c:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (buf->read_active != buf->read_stop) {
    4f1e:	d000      	beq.n	4f22 <grid_buffer_read_init+0x10>
		while(1){
    4f20:	e7fe      	b.n	4f20 <grid_buffer_read_init+0xe>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	
	if (buf->read_start	 != buf->read_stop) {
    4f22:	f8b0 53ea 	ldrh.w	r5, [r0, #1002]	; 0x3ea
    4f26:	42ab      	cmp	r3, r5
    4f28:	d000      	beq.n	4f2c <grid_buffer_read_init+0x1a>
		while(1){
    4f2a:	e7fe      	b.n	4f2a <grid_buffer_read_init+0x18>
		// TRAP: TRANSMISSION WAS NOT OVER YET
		}	
	}
	
	if (buf->read_start == buf->write_start) {
    4f2c:	f8b0 63f2 	ldrh.w	r6, [r0, #1010]	; 0x3f2
    4f30:	42b5      	cmp	r5, r6
    4f32:	d020      	beq.n	4f76 <grid_buffer_read_init+0x64>
	}
	
	
	
	// Seek message end character	
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f34:	8801      	ldrh	r1, [r0, #0]
		
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f36:	2400      	movs	r4, #0
	for (uint16_t i=0; i<buf->buffer_length; i++){
    4f38:	b2a3      	uxth	r3, r4
    4f3a:	4299      	cmp	r1, r3
    4f3c:	d800      	bhi.n	4f40 <grid_buffer_read_init+0x2e>
		}
		
		
	}
		
	while(1){
    4f3e:	e7fe      	b.n	4f3e <grid_buffer_read_init+0x2c>
		uint16_t index = (buf->read_start + i)%buf->buffer_length;
    4f40:	192f      	adds	r7, r5, r4
    4f42:	fbb7 f2f1 	udiv	r2, r7, r1
    4f46:	fb01 7212 	mls	r2, r1, r2, r7
		if (index == buf->write_start) return 0;	
    4f4a:	b297      	uxth	r7, r2
    4f4c:	42be      	cmp	r6, r7
    4f4e:	d012      	beq.n	4f76 <grid_buffer_read_init+0x64>
		if (buf->buffer_storage[index] == '\n'){
    4f50:	1887      	adds	r7, r0, r2
    4f52:	3301      	adds	r3, #1
    4f54:	78bf      	ldrb	r7, [r7, #2]
    4f56:	2f0a      	cmp	r7, #10
    4f58:	b29b      	uxth	r3, r3
    4f5a:	f104 0401 	add.w	r4, r4, #1
    4f5e:	d1eb      	bne.n	4f38 <grid_buffer_read_init+0x26>
			buf->read_stop = (index+1)%buf->buffer_length;
    4f60:	3201      	adds	r2, #1
    4f62:	fbb2 f4f1 	udiv	r4, r2, r1
    4f66:	fb01 2214 	mls	r2, r1, r4, r2
    4f6a:	f8a0 23ec 	strh.w	r2, [r0, #1004]	; 0x3ec
			buf->read_length = i+1;
    4f6e:	f8a0 33f0 	strh.w	r3, [r0, #1008]	; 0x3f0
		// TRAP: TRANSMISSION WAS NOT OVER YET
	}
	
	
}
    4f72:	4618      	mov	r0, r3
    4f74:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return 0;
    4f76:	2300      	movs	r3, #0
    4f78:	e7fb      	b.n	4f72 <grid_buffer_read_init+0x60>

00004f7a <grid_buffer_read_character>:

uint8_t grid_buffer_read_character(struct grid_buffer* buf){
	
	// Check if packet is not over
	if (buf->read_active != buf->read_stop){
    4f7a:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4f7e:	f8b0 13ec 	ldrh.w	r1, [r0, #1004]	; 0x3ec
    4f82:	4299      	cmp	r1, r3
uint8_t grid_buffer_read_character(struct grid_buffer* buf){
    4f84:	b510      	push	{r4, lr}
    4f86:	4602      	mov	r2, r0
	if (buf->read_active != buf->read_stop){
    4f88:	d00b      	beq.n	4fa2 <grid_buffer_read_character+0x28>
		
		uint8_t character = buf->buffer_storage[buf->read_active];
		
		buf->read_active++;
		buf->read_active %= buf->buffer_length;
    4f8a:	8814      	ldrh	r4, [r2, #0]
		uint8_t character = buf->buffer_storage[buf->read_active];
    4f8c:	18c1      	adds	r1, r0, r3
		buf->read_active++;
    4f8e:	3301      	adds	r3, #1
		buf->read_active %= buf->buffer_length;
    4f90:	b29b      	uxth	r3, r3
		uint8_t character = buf->buffer_storage[buf->read_active];
    4f92:	7888      	ldrb	r0, [r1, #2]
		buf->read_active %= buf->buffer_length;
    4f94:	fbb3 f1f4 	udiv	r1, r3, r4
    4f98:	fb04 3311 	mls	r3, r4, r1, r3
    4f9c:	f8a2 33ee 	strh.w	r3, [r2, #1006]	; 0x3ee
			// TRAP: TRANSMISSION WAS OVER ALREADY
		}
	}
	

}
    4fa0:	bd10      	pop	{r4, pc}
		while(1){
    4fa2:	e7fe      	b.n	4fa2 <grid_buffer_read_character+0x28>

00004fa4 <grid_buffer_read_acknowledge>:

// TRANSMISSION WAS ACKNOWLEDGED, PACKET CAN BE DELETED
uint8_t grid_buffer_read_acknowledge(struct grid_buffer* buf){
	
	// Check if packet is really over
	if (buf->read_active == buf->read_stop){
    4fa4:	f8b0 23ec 	ldrh.w	r2, [r0, #1004]	; 0x3ec
    4fa8:	f8b0 33ee 	ldrh.w	r3, [r0, #1006]	; 0x3ee
    4fac:	4293      	cmp	r3, r2
    4fae:	d000      	beq.n	4fb2 <grid_buffer_read_acknowledge+0xe>
		buf->read_start = buf->read_stop;
		return 1;
	}else{
		
		while(1){
    4fb0:	e7fe      	b.n	4fb0 <grid_buffer_read_acknowledge+0xc>
		buf->read_start = buf->read_stop;
    4fb2:	f8a0 33ea 	strh.w	r3, [r0, #1002]	; 0x3ea
			// TRAP: TRANSMISSION WAS NOT OVER YET
		}
	}
	

}
    4fb6:	2001      	movs	r0, #1
    4fb8:	4770      	bx	lr
	...

00004fbc <grid_port_init>:
	buf->read_start  = buf->read_stop;
	
	return 1;
}

void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fbc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    4fc0:	4604      	mov	r4, r0
	
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fc2:	f500 501c 	add.w	r0, r0, #9984	; 0x2700
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fc6:	b087      	sub	sp, #28
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fc8:	f8df 8148 	ldr.w	r8, [pc, #328]	; 5114 <grid_port_init+0x158>
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fcc:	460d      	mov	r5, r1
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fce:	303c      	adds	r0, #60	; 0x3c
    4fd0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
void grid_port_init(volatile struct grid_port* por, struct usart_async_descriptor*  usart, uint8_t type, uint8_t dir, uint8_t dma){
    4fd4:	4616      	mov	r6, r2
    4fd6:	461f      	mov	r7, r3
	grid_buffer_init(&por->tx_buffer, GRID_BUFFER_SIZE);
    4fd8:	47c0      	blx	r8
	grid_buffer_init(&por->rx_buffer, GRID_BUFFER_SIZE);
    4fda:	f504 502c 	add.w	r0, r4, #11008	; 0x2b00
    4fde:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
    4fe2:	3034      	adds	r0, #52	; 0x34
    4fe4:	47c0      	blx	r8
	
	
	por->cooldown = 0;
    4fe6:	2000      	movs	r0, #0
	
	por->dma_channel = dma;
    4fe8:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
	por->cooldown = 0;
    4fec:	6020      	str	r0, [r4, #0]
	
	por->tx_double_buffer_status	= 0;
	por->rx_double_buffer_status	= 0;
	
	
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    4fee:	f241 3288 	movw	r2, #5000	; 0x1388
	por->dma_channel = dma;
    4ff2:	72a3      	strb	r3, [r4, #10]
	por->direction = dir;
    4ff4:	7267      	strb	r7, [r4, #9]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    4ff6:	4603      	mov	r3, r0
	por->usart	= usart;
    4ff8:	6065      	str	r5, [r4, #4]
	por->type		= type;
    4ffa:	7226      	strb	r6, [r4, #8]
	por->tx_double_buffer_status	= 0;
    4ffc:	81a0      	strh	r0, [r4, #12]
	por->rx_double_buffer_status	= 0;
    4ffe:	6220      	str	r0, [r4, #32]
		por->tx_double_buffer[i] = 0;		
    5000:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    5002:	3301      	adds	r3, #1
    5004:	4293      	cmp	r3, r2
		por->tx_double_buffer[i] = 0;		
    5006:	f881 002c 	strb.w	r0, [r1, #44]	; 0x2c
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    500a:	d1f9      	bne.n	5000 <grid_port_init+0x44>
	}
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    500c:	2300      	movs	r3, #0
		por->rx_double_buffer[i] = 0;
    500e:	f241 31b4 	movw	r1, #5044	; 0x13b4
    5012:	461d      	mov	r5, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5014:	f241 3288 	movw	r2, #5000	; 0x1388
		por->rx_double_buffer[i] = 0;
    5018:	18e0      	adds	r0, r4, r3
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    501a:	3301      	adds	r3, #1
    501c:	4293      	cmp	r3, r2
		por->rx_double_buffer[i] = 0;
    501e:	5445      	strb	r5, [r0, r1]
	for (uint32_t i=0; i<GRID_DOUBLE_BUFFER_RX_SIZE; i++){
    5020:	d1fa      	bne.n	5018 <grid_port_init+0x5c>
	}
	
	por->partner_fi = 0;
	
	por->partner_hwcfg = 0;
    5022:	f642 732c 	movw	r3, #12076	; 0x2f2c
	por->partner_fi = 0;
    5026:	f642 7130 	movw	r1, #12080	; 0x2f30
	por->partner_status = 1;
	
	por->ping_local_token = 255;
    502a:	f642 7031 	movw	r0, #12081	; 0x2f31
	por->partner_fi = 0;
    502e:	5465      	strb	r5, [r4, r1]
	por->partner_hwcfg = 0;
    5030:	50e5      	str	r5, [r4, r3]
	por->partner_status = 1;
    5032:	f642 734b 	movw	r3, #12107	; 0x2f4b
    5036:	2201      	movs	r2, #1
	por->ping_local_token = 255;
    5038:	27ff      	movs	r7, #255	; 0xff
	por->partner_status = 1;
    503a:	54e2      	strb	r2, [r4, r3]
	por->ping_local_token = 255;
    503c:	5427      	strb	r7, [r4, r0]
	por->ping_partner_token = 255;
    503e:	f642 7032 	movw	r0, #12082	; 0x2f32
	
	por->ping_flag = 0;
	
	if (type == GRID_PORT_TYPE_USART){	
    5042:	4296      	cmp	r6, r2
	por->ping_partner_token = 255;
    5044:	5427      	strb	r7, [r4, r0]
	por->ping_flag = 0;
    5046:	f642 7048 	movw	r0, #12104	; 0x2f48
    504a:	5425      	strb	r5, [r4, r0]
	if (type == GRID_PORT_TYPE_USART){	
    504c:	d156      	bne.n	50fc <grid_port_init+0x140>
		
		por->partner_status = 0;
    504e:	54e5      	strb	r5, [r4, r3]
		por->partner_fi = 0;
    5050:	5465      	strb	r5, [r4, r1]
		
		
		sprintf(por->ping_packet, "%c%c%c%c%02x%02x%02x%c00\n", GRID_CONST_SOH, GRID_CONST_DCT, GRID_CONST_BELL, por->direction, grid_sys_get_hwcfg(), 255, 255, GRID_CONST_EOT);
    5052:	4b2b      	ldr	r3, [pc, #172]	; (5100 <grid_port_init+0x144>)
    5054:	f894 9009 	ldrb.w	r9, [r4, #9]
    5058:	4798      	blx	r3
    505a:	f504 583c 	add.w	r8, r4, #12032	; 0x2f00
    505e:	2304      	movs	r3, #4
    5060:	f108 0833 	add.w	r8, r8, #51	; 0x33
    5064:	e9cd 7304 	strd	r7, r3, [sp, #16]
    5068:	fa5f f989 	uxtb.w	r9, r9
    506c:	2307      	movs	r3, #7
    506e:	4632      	mov	r2, r6
    5070:	4924      	ldr	r1, [pc, #144]	; (5104 <grid_port_init+0x148>)
    5072:	f8cd 9004 	str.w	r9, [sp, #4]
    5076:	e9cd 0702 	strd	r0, r7, [sp, #8]
    507a:	f8df 909c 	ldr.w	r9, [pc, #156]	; 5118 <grid_port_init+0x15c>
    507e:	9300      	str	r3, [sp, #0]
    5080:	4640      	mov	r0, r8
    5082:	230e      	movs	r3, #14
    5084:	47c8      	blx	r9
		
		por->ping_packet_length = strlen(por->ping_packet);	
    5086:	4b20      	ldr	r3, [pc, #128]	; (5108 <grid_port_init+0x14c>)
    5088:	4640      	mov	r0, r8
    508a:	4798      	blx	r3
    508c:	f642 7347 	movw	r3, #12103	; 0x2f47
    5090:	b2c0      	uxtb	r0, r0
    5092:	54e0      	strb	r0, [r4, r3]
			
		grid_msg_checksum_write(por->ping_packet, por->ping_packet_length, grid_msg_calculate_checksum_of_packet_string(por->ping_packet, por->ping_packet_length));
    5094:	4640      	mov	r0, r8
    5096:	f814 9003 	ldrb.w	r9, [r4, r3]
    509a:	5ce1      	ldrb	r1, [r4, r3]
    509c:	4b1b      	ldr	r3, [pc, #108]	; (510c <grid_port_init+0x150>)
    509e:	4798      	blx	r3
    50a0:	fa5f f989 	uxtb.w	r9, r9
    50a4:	4b1a      	ldr	r3, [pc, #104]	; (5110 <grid_port_init+0x154>)
    50a6:	4602      	mov	r2, r0
    50a8:	4649      	mov	r1, r9
    50aa:	4640      	mov	r0, r8
    50ac:	4798      	blx	r3
		

		
		if (por->direction == GRID_CONST_NORTH){
    50ae:	7a63      	ldrb	r3, [r4, #9]
    50b0:	2b11      	cmp	r3, #17
    50b2:	d108      	bne.n	50c6 <grid_port_init+0x10a>
			por->dx = 0;
    50b4:	f642 7349 	movw	r3, #12105	; 0x2f49
    50b8:	54e5      	strb	r5, [r4, r3]
			por->dy = 1;
    50ba:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50be:	54e6      	strb	r6, [r4, r3]
	}
	else{
		por->partner_status = 1; //UI AND USB are considered to be connected by default
	}
	
}
    50c0:	b007      	add	sp, #28
    50c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		else if (por->direction == GRID_CONST_EAST){
    50c6:	7a63      	ldrb	r3, [r4, #9]
    50c8:	2b12      	cmp	r3, #18
    50ca:	d106      	bne.n	50da <grid_port_init+0x11e>
			por->dx = 1;
    50cc:	f642 7349 	movw	r3, #12105	; 0x2f49
    50d0:	54e6      	strb	r6, [r4, r3]
			por->dy = 0;
    50d2:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50d6:	54e5      	strb	r5, [r4, r3]
    50d8:	e7f2      	b.n	50c0 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_SOUTH){
    50da:	7a63      	ldrb	r3, [r4, #9]
    50dc:	2b13      	cmp	r3, #19
    50de:	d106      	bne.n	50ee <grid_port_init+0x132>
			por->dx = 0;
    50e0:	f642 7349 	movw	r3, #12105	; 0x2f49
    50e4:	54e5      	strb	r5, [r4, r3]
			por->dy = -1;
    50e6:	f642 734a 	movw	r3, #12106	; 0x2f4a
    50ea:	54e7      	strb	r7, [r4, r3]
    50ec:	e7e8      	b.n	50c0 <grid_port_init+0x104>
		else if (por->direction == GRID_CONST_WEST){
    50ee:	7a63      	ldrb	r3, [r4, #9]
    50f0:	2b14      	cmp	r3, #20
    50f2:	d1e5      	bne.n	50c0 <grid_port_init+0x104>
			por->dx = -1;
    50f4:	f642 7349 	movw	r3, #12105	; 0x2f49
    50f8:	54e7      	strb	r7, [r4, r3]
    50fa:	e7ea      	b.n	50d2 <grid_port_init+0x116>
		por->partner_status = 1; //UI AND USB are considered to be connected by default
    50fc:	54e2      	strb	r2, [r4, r3]
}
    50fe:	e7df      	b.n	50c0 <grid_port_init+0x104>
    5100:	0000a1fd 	.word	0x0000a1fd
    5104:	00016682 	.word	0x00016682
    5108:	00015317 	.word	0x00015317
    510c:	0000a2e1 	.word	0x0000a2e1
    5110:	0000a315 	.word	0x0000a315
    5114:	00004795 	.word	0x00004795
    5118:	00015299 	.word	0x00015299

0000511c <grid_port_init_all>:

void grid_port_init_all(void){
    511c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    5120:	2600      	movs	r6, #0
    5122:	4d1c      	ldr	r5, [pc, #112]	; (5194 <grid_port_init_all+0x78>)
    5124:	491c      	ldr	r1, [pc, #112]	; (5198 <grid_port_init_all+0x7c>)
    5126:	481d      	ldr	r0, [pc, #116]	; (519c <grid_port_init_all+0x80>)
    5128:	9600      	str	r6, [sp, #0]
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    512a:	2401      	movs	r4, #1
	grid_port_init(&GRID_PORT_N, &USART_NORTH, GRID_PORT_TYPE_USART, GRID_CONST_NORTH ,0);
    512c:	2311      	movs	r3, #17
    512e:	2201      	movs	r2, #1
    5130:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    5132:	f04f 0902 	mov.w	r9, #2
	grid_port_init(&GRID_PORT_E, &USART_EAST,  GRID_PORT_TYPE_USART, GRID_CONST_EAST  ,1);
    5136:	4622      	mov	r2, r4
    5138:	4919      	ldr	r1, [pc, #100]	; (51a0 <grid_port_init_all+0x84>)
    513a:	481a      	ldr	r0, [pc, #104]	; (51a4 <grid_port_init_all+0x88>)
    513c:	9400      	str	r4, [sp, #0]
    513e:	2312      	movs	r3, #18
    5140:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    5142:	2703      	movs	r7, #3
	grid_port_init(&GRID_PORT_S, &USART_SOUTH, GRID_PORT_TYPE_USART, GRID_CONST_SOUTH ,2);
    5144:	4622      	mov	r2, r4
    5146:	4918      	ldr	r1, [pc, #96]	; (51a8 <grid_port_init_all+0x8c>)
    5148:	4818      	ldr	r0, [pc, #96]	; (51ac <grid_port_init_all+0x90>)
    514a:	f8cd 9000 	str.w	r9, [sp]
    514e:	2313      	movs	r3, #19
    5150:	47a8      	blx	r5
	
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    5152:	f8df 8068 	ldr.w	r8, [pc, #104]	; 51bc <grid_port_init_all+0xa0>
	grid_port_init(&GRID_PORT_W, &USART_WEST,  GRID_PORT_TYPE_USART, GRID_CONST_WEST  ,3);
    5156:	9700      	str	r7, [sp, #0]
    5158:	4622      	mov	r2, r4
    515a:	4915      	ldr	r1, [pc, #84]	; (51b0 <grid_port_init_all+0x94>)
    515c:	4815      	ldr	r0, [pc, #84]	; (51b4 <grid_port_init_all+0x98>)
    515e:	2314      	movs	r3, #20
    5160:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    5162:	f04f 0aff 	mov.w	sl, #255	; 0xff
    5166:	463a      	mov	r2, r7
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    5168:	4f13      	ldr	r7, [pc, #76]	; (51b8 <grid_port_init_all+0x9c>)
	grid_port_init(&GRID_PORT_U, NULL, GRID_PORT_TYPE_UI, 0, -1);
    516a:	f8cd a000 	str.w	sl, [sp]
    516e:	4633      	mov	r3, r6
    5170:	4631      	mov	r1, r6
    5172:	4640      	mov	r0, r8
    5174:	47a8      	blx	r5
	grid_port_init(&GRID_PORT_H, NULL, GRID_PORT_TYPE_USB, 0, -1);	
    5176:	4633      	mov	r3, r6
    5178:	f8cd a000 	str.w	sl, [sp]
    517c:	464a      	mov	r2, r9
    517e:	4631      	mov	r1, r6
    5180:	4638      	mov	r0, r7
    5182:	47a8      	blx	r5
	
	GRID_PORT_U.partner_status = 1; // UI IS ALWAYS CONNECTED
    5184:	f642 734b 	movw	r3, #12107	; 0x2f4b
    5188:	f808 4003 	strb.w	r4, [r8, r3]
	GRID_PORT_H.partner_status = 1; // HOST IS ALWAYS CONNECTED (Not really!)
    518c:	54fc      	strb	r4, [r7, r3]
	
	
}
    518e:	b002      	add	sp, #8
    5190:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    5194:	00004fbd 	.word	0x00004fbd
    5198:	2001ce04 	.word	0x2001ce04
    519c:	20009150 	.word	0x20009150
    51a0:	2001cdb0 	.word	0x2001cdb0
    51a4:	20019870 	.word	0x20019870
    51a8:	2001cf08 	.word	0x2001cf08
    51ac:	200138d4 	.word	0x200138d4
    51b0:	2001ceb8 	.word	0x2001ceb8
    51b4:	200102d4 	.word	0x200102d4
    51b8:	20016824 	.word	0x20016824
    51bc:	2000c0b0 	.word	0x2000c0b0

000051c0 <grid_port_process_inbound>:


//=============================== PROCESS INBOUND ==============================//


uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51c4:	f500 582c 	add.w	r8, r0, #11008	; 0x2b00
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51c8:	b091      	sub	sp, #68	; 0x44
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51ca:	f108 0834 	add.w	r8, r8, #52	; 0x34
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51ce:	af02      	add	r7, sp, #8
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51d0:	4b5c      	ldr	r3, [pc, #368]	; (5344 <grid_port_process_inbound+0x184>)
uint8_t grid_port_process_inbound(struct grid_port* por, uint8_t loopback){
    51d2:	6079      	str	r1, [r7, #4]
    51d4:	4606      	mov	r6, r0
	uint16_t packet_size = grid_buffer_read_size(&por->rx_buffer);
    51d6:	4640      	mov	r0, r8
    51d8:	4798      	blx	r3
	
	if (!packet_size){
    51da:	4605      	mov	r5, r0
    51dc:	2800      	cmp	r0, #0
    51de:	f000 80af 	beq.w	5340 <grid_port_process_inbound+0x180>
		uint8_t port_count = 6;
		struct grid_port* port_array_default[port_count];
		struct grid_port* port_array[port_count];
		
		
		port_array_default[0] = &GRID_PORT_N;
    51e2:	4b59      	ldr	r3, [pc, #356]	; (5348 <grid_port_process_inbound+0x188>)
    51e4:	60bb      	str	r3, [r7, #8]
		port_array_default[1] = &GRID_PORT_E;
    51e6:	4b59      	ldr	r3, [pc, #356]	; (534c <grid_port_process_inbound+0x18c>)
    51e8:	60fb      	str	r3, [r7, #12]
		port_array_default[2] = &GRID_PORT_S;
    51ea:	4b59      	ldr	r3, [pc, #356]	; (5350 <grid_port_process_inbound+0x190>)
    51ec:	613b      	str	r3, [r7, #16]
		port_array_default[3] = &GRID_PORT_W;
    51ee:	4b59      	ldr	r3, [pc, #356]	; (5354 <grid_port_process_inbound+0x194>)
    51f0:	617b      	str	r3, [r7, #20]
		
		port_array_default[4] = &GRID_PORT_U;
    51f2:	4b59      	ldr	r3, [pc, #356]	; (5358 <grid_port_process_inbound+0x198>)
    51f4:	61bb      	str	r3, [r7, #24]
		port_array_default[5] = &GRID_PORT_H;
    51f6:	4b59      	ldr	r3, [pc, #356]	; (535c <grid_port_process_inbound+0x19c>)
    51f8:	61fb      	str	r3, [r7, #28]
	}else{
    51fa:	46eb      	mov	fp, sp
		
		uint8_t j=0;
		
		for(uint8_t i=0; i<port_count; i++){
    51fc:	f107 0308 	add.w	r3, r7, #8
		port_array_default[5] = &GRID_PORT_H;
    5200:	f04f 0906 	mov.w	r9, #6
		uint8_t j=0;
    5204:	2400      	movs	r4, #0
			if (port_array_default[i]->partner_status != 0){
    5206:	f642 714b 	movw	r1, #12107	; 0x2f4b
    520a:	f853 2b04 	ldr.w	r2, [r3], #4
    520e:	5c50      	ldrb	r0, [r2, r1]
    5210:	b138      	cbz	r0, 5222 <grid_port_process_inbound+0x62>
				port_array[j] = port_array_default[i];
    5212:	f107 0038 	add.w	r0, r7, #56	; 0x38
    5216:	eb00 0084 	add.w	r0, r0, r4, lsl #2
				j++;
    521a:	3401      	adds	r4, #1
				port_array[j] = port_array_default[i];
    521c:	f840 2c18 	str.w	r2, [r0, #-24]
				j++;
    5220:	b2e4      	uxtb	r4, r4
		for(uint8_t i=0; i<port_count; i++){
    5222:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    5226:	f019 09ff 	ands.w	r9, r9, #255	; 0xff
    522a:	d1ee      	bne.n	520a <grid_port_process_inbound+0x4a>
		
		for (uint8_t i=0; i<port_count; i++)
		{
			if (port_array[i] != por || loopback){
			
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    522c:	4a4c      	ldr	r2, [pc, #304]	; (5360 <grid_port_process_inbound+0x1a0>)
    522e:	4649      	mov	r1, r9
			if (port_array[i] != por || loopback){
    5230:	f107 0a20 	add.w	sl, r7, #32
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5234:	f242 7c3c 	movw	ip, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    5238:	b2c8      	uxtb	r0, r1
    523a:	4284      	cmp	r4, r0
    523c:	d805      	bhi.n	524a <grid_port_process_inbound+0x8a>
					return 0;
				}	
			}	
		}
		
		if (packet_size != grid_buffer_read_init(&por->rx_buffer)){
    523e:	4b49      	ldr	r3, [pc, #292]	; (5364 <grid_port_process_inbound+0x1a4>)
    5240:	4640      	mov	r0, r8
    5242:	4798      	blx	r3
    5244:	42a8      	cmp	r0, r5
    5246:	d047      	beq.n	52d8 <grid_port_process_inbound+0x118>
			while(1){			
    5248:	e7fe      	b.n	5248 <grid_port_process_inbound+0x88>
			if (port_array[i] != por || loopback){
    524a:	f85a 0021 	ldr.w	r0, [sl, r1, lsl #2]
    524e:	42b0      	cmp	r0, r6
    5250:	d101      	bne.n	5256 <grid_port_process_inbound+0x96>
    5252:	687b      	ldr	r3, [r7, #4]
    5254:	b1b3      	cbz	r3, 5284 <grid_port_process_inbound+0xc4>
				if (packet_size > grid_buffer_write_size(&port_array[i]->tx_buffer)){
    5256:	4460      	add	r0, ip
    5258:	4790      	blx	r2
    525a:	42a8      	cmp	r0, r5
    525c:	4a40      	ldr	r2, [pc, #256]	; (5360 <grid_port_process_inbound+0x1a0>)
    525e:	f242 7c3c 	movw	ip, #10044	; 0x273c
    5262:	d20f      	bcs.n	5284 <grid_port_process_inbound+0xc4>
					grid_sys_alert_set_alert(&grid_sys_state, 100,100,0,2,200);
    5264:	2302      	movs	r3, #2
    5266:	22c8      	movs	r2, #200	; 0xc8
    5268:	e9cd 3200 	strd	r3, r2, [sp]
    526c:	2264      	movs	r2, #100	; 0x64
    526e:	483e      	ldr	r0, [pc, #248]	; (5368 <grid_port_process_inbound+0x1a8>)
    5270:	4c3e      	ldr	r4, [pc, #248]	; (536c <grid_port_process_inbound+0x1ac>)
    5272:	2300      	movs	r3, #0
    5274:	4611      	mov	r1, r2
    5276:	47a0      	blx	r4
					return 0;
    5278:	46dd      	mov	sp, fp
		}	

		return 1;
	}
		
}
    527a:	4648      	mov	r0, r9
    527c:	373c      	adds	r7, #60	; 0x3c
    527e:	46bd      	mov	sp, r7
    5280:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for (uint8_t i=0; i<port_count; i++)
    5284:	3101      	adds	r1, #1
    5286:	e7d7      	b.n	5238 <grid_port_process_inbound+0x78>
			if (port_array[i] != por || loopback){
    5288:	f85a 0029 	ldr.w	r0, [sl, r9, lsl #2]
    528c:	42b0      	cmp	r0, r6
    528e:	d101      	bne.n	5294 <grid_port_process_inbound+0xd4>
    5290:	6879      	ldr	r1, [r7, #4]
    5292:	b129      	cbz	r1, 52a0 <grid_port_process_inbound+0xe0>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    5294:	4418      	add	r0, r3
    5296:	4629      	mov	r1, r5
    5298:	4790      	blx	r2
    529a:	4a35      	ldr	r2, [pc, #212]	; (5370 <grid_port_process_inbound+0x1b0>)
    529c:	f242 733c 	movw	r3, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52a0:	f109 0901 	add.w	r9, r9, #1
    52a4:	fa5f f189 	uxtb.w	r1, r9
    52a8:	428c      	cmp	r4, r1
    52aa:	d8ed      	bhi.n	5288 <grid_port_process_inbound+0xc8>
    52ac:	f04f 0a00 	mov.w	sl, #0
		for (uint16_t j=0; j<packet_size; j++)
    52b0:	fa1f f38a 	uxth.w	r3, sl
    52b4:	429d      	cmp	r5, r3
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52b6:	4640      	mov	r0, r8
		for (uint16_t j=0; j<packet_size; j++)
    52b8:	d816      	bhi.n	52e8 <grid_port_process_inbound+0x128>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    52ba:	4b2e      	ldr	r3, [pc, #184]	; (5374 <grid_port_process_inbound+0x1b4>)
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    52bc:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 5380 <grid_port_process_inbound+0x1c0>
		grid_buffer_read_acknowledge(&por->rx_buffer);
    52c0:	4798      	blx	r3
			if (port_array[i] != por || loopback){
    52c2:	f107 0520 	add.w	r5, r7, #32
		for (uint8_t i=0; i<port_count; i++)
    52c6:	2100      	movs	r1, #0
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    52c8:	f242 783c 	movw	r8, #10044	; 0x273c
		for (uint8_t i=0; i<port_count; i++)
    52cc:	b2cb      	uxtb	r3, r1
    52ce:	429c      	cmp	r4, r3
    52d0:	d82c      	bhi.n	532c <grid_port_process_inbound+0x16c>
		return 1;
    52d2:	f04f 0901 	mov.w	r9, #1
    52d6:	e7cf      	b.n	5278 <grid_port_process_inbound+0xb8>
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52d8:	4a25      	ldr	r2, [pc, #148]	; (5370 <grid_port_process_inbound+0x1b0>)
    52da:	f04f 0900 	mov.w	r9, #0
			if (port_array[i] != por || loopback){
    52de:	f107 0a20 	add.w	sl, r7, #32
				grid_buffer_write_init(&port_array[i]->tx_buffer, packet_size);
    52e2:	f242 733c 	movw	r3, #10044	; 0x273c
    52e6:	e7dd      	b.n	52a4 <grid_port_process_inbound+0xe4>
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52e8:	4b23      	ldr	r3, [pc, #140]	; (5378 <grid_port_process_inbound+0x1b8>)
    52ea:	4798      	blx	r3
			for (uint8_t i=0; i<port_count; i++){
    52ec:	f04f 0900 	mov.w	r9, #0
			uint8_t character = grid_buffer_read_character(&por->rx_buffer);
    52f0:	4601      	mov	r1, r0
				if (port_array[i] != por || loopback){
    52f2:	f107 0320 	add.w	r3, r7, #32
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    52f6:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    52fa:	fa5f f089 	uxtb.w	r0, r9
    52fe:	4284      	cmp	r4, r0
    5300:	d802      	bhi.n	5308 <grid_port_process_inbound+0x148>
		for (uint16_t j=0; j<packet_size; j++)
    5302:	f10a 0a01 	add.w	sl, sl, #1
    5306:	e7d3      	b.n	52b0 <grid_port_process_inbound+0xf0>
				if (port_array[i] != por || loopback){
    5308:	f853 0029 	ldr.w	r0, [r3, r9, lsl #2]
    530c:	42b0      	cmp	r0, r6
    530e:	d101      	bne.n	5314 <grid_port_process_inbound+0x154>
    5310:	687a      	ldr	r2, [r7, #4]
    5312:	b142      	cbz	r2, 5326 <grid_port_process_inbound+0x166>
					grid_buffer_write_character(&port_array[i]->tx_buffer, character);
    5314:	4b19      	ldr	r3, [pc, #100]	; (537c <grid_port_process_inbound+0x1bc>)
    5316:	6039      	str	r1, [r7, #0]
    5318:	4460      	add	r0, ip
    531a:	4798      	blx	r3
    531c:	6839      	ldr	r1, [r7, #0]
    531e:	f107 0320 	add.w	r3, r7, #32
    5322:	f242 7c3c 	movw	ip, #10044	; 0x273c
			for (uint8_t i=0; i<port_count; i++){
    5326:	f109 0901 	add.w	r9, r9, #1
    532a:	e7e6      	b.n	52fa <grid_port_process_inbound+0x13a>
			if (port_array[i] != por || loopback){
    532c:	f855 0021 	ldr.w	r0, [r5, r1, lsl #2]
    5330:	42b0      	cmp	r0, r6
    5332:	d101      	bne.n	5338 <grid_port_process_inbound+0x178>
    5334:	687b      	ldr	r3, [r7, #4]
    5336:	b10b      	cbz	r3, 533c <grid_port_process_inbound+0x17c>
				grid_buffer_write_acknowledge(&port_array[i]->tx_buffer);
    5338:	4440      	add	r0, r8
    533a:	47c8      	blx	r9
		for (uint8_t i=0; i<port_count; i++)
    533c:	3101      	adds	r1, #1
    533e:	e7c5      	b.n	52cc <grid_port_process_inbound+0x10c>
		return 0;
    5340:	4681      	mov	r9, r0
    5342:	e79a      	b.n	527a <grid_port_process_inbound+0xba>
    5344:	00004ebd 	.word	0x00004ebd
    5348:	20009150 	.word	0x20009150
    534c:	20019870 	.word	0x20019870
    5350:	200138d4 	.word	0x200138d4
    5354:	200102d4 	.word	0x200102d4
    5358:	2000c0b0 	.word	0x2000c0b0
    535c:	20016824 	.word	0x20016824
    5360:	000047d9 	.word	0x000047d9
    5364:	00004f13 	.word	0x00004f13
    5368:	2000f008 	.word	0x2000f008
    536c:	0000a123 	.word	0x0000a123
    5370:	000047f1 	.word	0x000047f1
    5374:	00004fa5 	.word	0x00004fa5
    5378:	00004f7b 	.word	0x00004f7b
    537c:	0000482d 	.word	0x0000482d
    5380:	0000484d 	.word	0x0000484d

00005384 <grid_port_process_outbound_usb>:



//=============================== PROCESS OUTBOUND ==============================//

uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    5384:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			

	// OLD DEBUG IMPLEMENTATION
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5388:	f500 551c 	add.w	r5, r0, #9984	; 0x2700
    538c:	353c      	adds	r5, #60	; 0x3c
    538e:	4ba7      	ldr	r3, [pc, #668]	; (562c <grid_port_process_outbound_usb+0x2a8>)
uint8_t grid_port_process_outbound_usb(struct grid_port* por){
    5390:	b0ed      	sub	sp, #436	; 0x1b4
    5392:	4680      	mov	r8, r0
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5394:	4628      	mov	r0, r5
    5396:	4798      	blx	r3
	
	if (!length){		
    5398:	4604      	mov	r4, r0
    539a:	b910      	cbnz	r0, 53a2 <grid_port_process_outbound_usb+0x1e>
			
	// Let's send the packet through USB
	cdcdf_acm_write(por->tx_double_buffer, packet_length);

	
}
    539c:	b06d      	add	sp, #436	; 0x1b4
    539e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    53a2:	f108 0b2c 	add.w	fp, r8, #44	; 0x2c
    53a6:	f508 539d 	add.w	r3, r8, #5024	; 0x13a0
    53aa:	3314      	adds	r3, #20
	if (!length){		
    53ac:	465a      	mov	r2, fp
		por->tx_double_buffer[i] = 0;
    53ae:	2100      	movs	r1, #0
    53b0:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint16_t i=0; i<GRID_DOUBLE_BUFFER_TX_SIZE; i++){
    53b4:	429a      	cmp	r2, r3
    53b6:	d1fb      	bne.n	53b0 <grid_port_process_outbound_usb+0x2c>
	grid_msg_init(&message);
    53b8:	4b9d      	ldr	r3, [pc, #628]	; (5630 <grid_port_process_outbound_usb+0x2ac>)
		grid_msg_packet_receive_char(&message, nextchar);
    53ba:	f8df 92b8 	ldr.w	r9, [pc, #696]	; 5674 <grid_port_process_outbound_usb+0x2f0>
	grid_msg_init(&message);
    53be:	a805      	add	r0, sp, #20
    53c0:	4798      	blx	r3
	grid_buffer_read_init(&por->tx_buffer);
    53c2:	4b9c      	ldr	r3, [pc, #624]	; (5634 <grid_port_process_outbound_usb+0x2b0>)
    53c4:	4628      	mov	r0, r5
    53c6:	4798      	blx	r3
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    53c8:	4b9b      	ldr	r3, [pc, #620]	; (5638 <grid_port_process_outbound_usb+0x2b4>)
	for (uint16_t i = 0; i<length; i++){
    53ca:	46da      	mov	sl, fp
    53cc:	2700      	movs	r7, #0
    53ce:	b2ba      	uxth	r2, r7
    53d0:	4294      	cmp	r4, r2
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    53d2:	4628      	mov	r0, r5
	for (uint16_t i = 0; i<length; i++){
    53d4:	d825      	bhi.n	5422 <grid_port_process_outbound_usb+0x9e>
	grid_buffer_read_acknowledge(&por->tx_buffer);
    53d6:	4b99      	ldr	r3, [pc, #612]	; (563c <grid_port_process_outbound_usb+0x2b8>)
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    53d8:	4c99      	ldr	r4, [pc, #612]	; (5640 <grid_port_process_outbound_usb+0x2bc>)
	grid_buffer_read_acknowledge(&por->tx_buffer);
    53da:	4798      	blx	r3
	int8_t dx = grid_msg_header_get_dx(&message) - GRID_SYS_DEFAULT_POSITION;
    53dc:	4b99      	ldr	r3, [pc, #612]	; (5644 <grid_port_process_outbound_usb+0x2c0>)
    53de:	a805      	add	r0, sp, #20
    53e0:	4798      	blx	r3
    53e2:	387f      	subs	r0, #127	; 0x7f
    53e4:	b243      	sxtb	r3, r0
    53e6:	9300      	str	r3, [sp, #0]
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    53e8:	a805      	add	r0, sp, #20
    53ea:	4b97      	ldr	r3, [pc, #604]	; (5648 <grid_port_process_outbound_usb+0x2c4>)
    53ec:	4798      	blx	r3
    53ee:	387f      	subs	r0, #127	; 0x7f
    53f0:	b243      	sxtb	r3, r0
	for (uint16_t i=0; i<message.body_length; i++){
    53f2:	f04f 0a00 	mov.w	sl, #0
	int8_t dy = grid_msg_header_get_dy(&message) - GRID_SYS_DEFAULT_POSITION;	
    53f6:	9301      	str	r3, [sp, #4]
	uint8_t current_start		= 0;
    53f8:	4656      	mov	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    53fa:	9a6a      	ldr	r2, [sp, #424]	; 0x1a8
    53fc:	fa1f f38a 	uxth.w	r3, sl
    5400:	429a      	cmp	r2, r3
    5402:	d818      	bhi.n	5436 <grid_port_process_outbound_usb+0xb2>
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5404:	4b91      	ldr	r3, [pc, #580]	; (564c <grid_port_process_outbound_usb+0x2c8>)
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5406:	4e92      	ldr	r6, [pc, #584]	; (5650 <grid_port_process_outbound_usb+0x2cc>)
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    5408:	a805      	add	r0, sp, #20
    540a:	4798      	blx	r3
	for (uint32_t i=0; i<packet_length; i++){
    540c:	2400      	movs	r4, #0
	uint32_t packet_length = grid_msg_packet_get_length(&message);
    540e:	4605      	mov	r5, r0
	for (uint32_t i=0; i<packet_length; i++){
    5410:	42ac      	cmp	r4, r5
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5412:	4621      	mov	r1, r4
	for (uint32_t i=0; i<packet_length; i++){
    5414:	f040 8104 	bne.w	5620 <grid_port_process_outbound_usb+0x29c>
	cdcdf_acm_write(por->tx_double_buffer, packet_length);
    5418:	4b8e      	ldr	r3, [pc, #568]	; (5654 <grid_port_process_outbound_usb+0x2d0>)
    541a:	f108 002c 	add.w	r0, r8, #44	; 0x2c
    541e:	4798      	blx	r3
}
    5420:	e7bc      	b.n	539c <grid_port_process_outbound_usb+0x18>
		uint8_t nextchar = grid_buffer_read_character(&por->tx_buffer);
    5422:	4798      	blx	r3
    5424:	4606      	mov	r6, r0
		grid_msg_packet_receive_char(&message, nextchar);
    5426:	4601      	mov	r1, r0
    5428:	a805      	add	r0, sp, #20
    542a:	47c8      	blx	r9
		por->tx_double_buffer[i] = nextchar;	
    542c:	3701      	adds	r7, #1
    542e:	f80a 6b01 	strb.w	r6, [sl], #1
	for (uint16_t i = 0; i<length; i++){
    5432:	4b81      	ldr	r3, [pc, #516]	; (5638 <grid_port_process_outbound_usb+0x2b4>)
    5434:	e7cb      	b.n	53ce <grid_port_process_outbound_usb+0x4a>
		if (message.body[i] == GRID_CONST_STX){
    5436:	aa05      	add	r2, sp, #20
    5438:	4413      	add	r3, r2
    543a:	7d1b      	ldrb	r3, [r3, #20]
    543c:	2b02      	cmp	r3, #2
    543e:	d104      	bne.n	544a <grid_port_process_outbound_usb+0xc6>
			current_start = i;
    5440:	fa5f f68a 	uxtb.w	r6, sl
	for (uint16_t i=0; i<message.body_length; i++){
    5444:	f10a 0a01 	add.w	sl, sl, #1
    5448:	e7d7      	b.n	53fa <grid_port_process_outbound_usb+0x76>
		else if (message.body[i] == GRID_CONST_ETX && current_start!=0){
    544a:	2b03      	cmp	r3, #3
    544c:	d1fa      	bne.n	5444 <grid_port_process_outbound_usb+0xc0>
    544e:	b90e      	cbnz	r6, 5454 <grid_port_process_outbound_usb+0xd0>
			current_start = 0;
    5450:	2600      	movs	r6, #0
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5452:	e7f7      	b.n	5444 <grid_port_process_outbound_usb+0xc0>
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5454:	4631      	mov	r1, r6
    5456:	2201      	movs	r2, #1
    5458:	a805      	add	r0, sp, #20
    545a:	47a0      	blx	r4
    545c:	4635      	mov	r5, r6
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    545e:	2301      	movs	r3, #1
			uint8_t msg_class = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_offset, GRID_CLASS_length);
    5460:	b2c6      	uxtb	r6, r0
			uint8_t msg_instr = grid_msg_text_get_parameter(&message, current_start, GRID_INSTR_offset, GRID_INSTR_length);
    5462:	2204      	movs	r2, #4
    5464:	4629      	mov	r1, r5
    5466:	a805      	add	r0, sp, #20
    5468:	47a0      	blx	r4
    546a:	b2c0      	uxtb	r0, r0
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    546c:	2e00      	cmp	r6, #0
    546e:	d13f      	bne.n	54f0 <grid_port_process_outbound_usb+0x16c>
    5470:	280e      	cmp	r0, #14
    5472:	d1ed      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_offset,		GRID_CLASS_MIDIRELATIVE_CABLECOMMAND_length);
    5474:	4629      	mov	r1, r5
    5476:	2302      	movs	r3, #2
    5478:	2205      	movs	r2, #5
    547a:	a805      	add	r0, sp, #20
    547c:	47a0      	blx	r4
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    547e:	4629      	mov	r1, r5
    5480:	2302      	movs	r3, #2
    5482:	2207      	movs	r2, #7
    5484:	a805      	add	r0, sp, #20
    5486:	47a0      	blx	r4
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    5488:	4629      	mov	r1, r5
				uint8_t midi_commandchannel = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_offset ,		GRID_CLASS_MIDIRELATIVE_COMMANDCHANNEL_length);
    548a:	4681      	mov	r9, r0
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    548c:	2302      	movs	r3, #2
    548e:	2209      	movs	r2, #9
    5490:	a805      	add	r0, sp, #20
    5492:	47a0      	blx	r4
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    5494:	4629      	mov	r1, r5
				uint8_t midi_param1  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM1_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM1_length);
    5496:	4607      	mov	r7, r0
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    5498:	2302      	movs	r3, #2
    549a:	220b      	movs	r2, #11
    549c:	a805      	add	r0, sp, #20
    549e:	47a0      	blx	r4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54a0:	9901      	ldr	r1, [sp, #4]
    54a2:	4a6d      	ldr	r2, [pc, #436]	; (5658 <grid_port_process_outbound_usb+0x2d4>)
				uint8_t midi_param2  = grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIRELATIVE_PARAM2_offset  ,			GRID_CLASS_MIDIRELATIVE_PARAM2_length);
    54a4:	f88d 000f 	strb.w	r0, [sp, #15]
				uint8_t midi_command = 	(midi_commandchannel&0xF0)>>4;
    54a8:	f3c9 1303 	ubfx	r3, r9, #4, #4
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54ac:	7bd2      	ldrb	r2, [r2, #15]
				midievent.byte0 = 0<<4|midi_command;
    54ae:	f88d 300c 	strb.w	r3, [sp, #12]
				uint8_t midi_channel = ((256-dy*1)%4+grid_sys_state.bank_activebank_number*4)%16;
    54b2:	f1c1 0900 	rsb	r9, r1, #0
    54b6:	f009 0903 	and.w	r9, r9, #3
    54ba:	eb09 0982 	add.w	r9, r9, r2, lsl #2
    54be:	f009 090f 	and.w	r9, r9, #15
				midievent.byte1 = midi_command<<4|midi_channel;
    54c2:	ea49 1903 	orr.w	r9, r9, r3, lsl #4
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    54c6:	b2ff      	uxtb	r7, r7
    54c8:	9b00      	ldr	r3, [sp, #0]
				midievent.byte1 = midi_command<<4|midi_channel;
    54ca:	f88d 900d 	strb.w	r9, [sp, #13]
				midi_param1  = (256-32+midi_param1 + 16*dx)%96; // 96-128 reserved
    54ce:	37e0      	adds	r7, #224	; 0xe0
    54d0:	2260      	movs	r2, #96	; 0x60
    54d2:	eb07 1703 	add.w	r7, r7, r3, lsl #4
    54d6:	fb97 f3f2 	sdiv	r3, r7, r2
    54da:	fb02 7713 	mls	r7, r2, r3, r7
    54de:	f88d 700e 	strb.w	r7, [sp, #14]
				grid_midi_tx_push(midievent);
    54e2:	9803      	ldr	r0, [sp, #12]
    54e4:	4b5d      	ldr	r3, [pc, #372]	; (565c <grid_port_process_outbound_usb+0x2d8>)
    54e6:	4798      	blx	r3
				grid_midi_tx_pop(midievent);				
    54e8:	9803      	ldr	r0, [sp, #12]
    54ea:	4b5d      	ldr	r3, [pc, #372]	; (5660 <grid_port_process_outbound_usb+0x2dc>)
    54ec:	4798      	blx	r3
			if (msg_class == GRID_CLASS_MIDIRELATIVE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54ee:	e7a9      	b.n	5444 <grid_port_process_outbound_usb+0xc0>
			else if (msg_class == GRID_CLASS_MIDIABSOLUTE_code && msg_instr == GRID_INSTR_EXECUTE_code){
    54f0:	2e01      	cmp	r6, #1
    54f2:	d127      	bne.n	5544 <grid_port_process_outbound_usb+0x1c0>
    54f4:	280e      	cmp	r0, #14
    54f6:	d1ab      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    54f8:	4629      	mov	r1, r5
    54fa:	2302      	movs	r3, #2
    54fc:	2205      	movs	r2, #5
    54fe:	a805      	add	r0, sp, #20
    5500:	47a0      	blx	r4
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5502:	4629      	mov	r1, r5
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5504:	4681      	mov	r9, r0
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5506:	2302      	movs	r3, #2
    5508:	2207      	movs	r2, #7
    550a:	a805      	add	r0, sp, #20
    550c:	47a0      	blx	r4
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    550e:	4629      	mov	r1, r5
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    5510:	4607      	mov	r7, r0
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    5512:	2302      	movs	r3, #2
    5514:	2209      	movs	r2, #9
    5516:	a805      	add	r0, sp, #20
    5518:	47a0      	blx	r4
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    551a:	220b      	movs	r2, #11
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    551c:	4606      	mov	r6, r0
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    551e:	4629      	mov	r1, r5
    5520:	2302      	movs	r3, #2
    5522:	a805      	add	r0, sp, #20
    5524:	47a0      	blx	r4
				uint8_t midi_cablecommand =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_offset,		GRID_CLASS_MIDIABSOLUTE_CABLECOMMAND_length);
    5526:	f88d 900c 	strb.w	r9, [sp, #12]
				uint8_t midi_commandchannel =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_offset,		GRID_CLASS_MIDIABSOLUTE_COMMANDCHANNEL_length);
    552a:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t midi_param1  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM1_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM1_length);
    552e:	f88d 600e 	strb.w	r6, [sp, #14]
				uint8_t midi_param2  =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_MIDIABSOLUTE_PARAM2_offset  ,			GRID_CLASS_MIDIABSOLUTE_PARAM2_length);
    5532:	f88d 000f 	strb.w	r0, [sp, #15]
				grid_midi_tx_push(midievent);
    5536:	9803      	ldr	r0, [sp, #12]
    5538:	4b48      	ldr	r3, [pc, #288]	; (565c <grid_port_process_outbound_usb+0x2d8>)
    553a:	4798      	blx	r3
				grid_midi_tx_pop(midievent);	
    553c:	9803      	ldr	r0, [sp, #12]
    553e:	4b48      	ldr	r3, [pc, #288]	; (5660 <grid_port_process_outbound_usb+0x2dc>)
    5540:	4798      	blx	r3
    5542:	e785      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYBOARD_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5544:	2e90      	cmp	r6, #144	; 0x90
    5546:	d11d      	bne.n	5584 <grid_port_process_outbound_usb+0x200>
    5548:	280e      	cmp	r0, #14
    554a:	d181      	bne.n	5450 <grid_port_process_outbound_usb+0xcc>
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    554c:	4629      	mov	r1, r5
    554e:	2302      	movs	r3, #2
    5550:	2205      	movs	r2, #5
    5552:	a805      	add	r0, sp, #20
    5554:	47a0      	blx	r4
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    5556:	4629      	mov	r1, r5
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5558:	4607      	mov	r7, r0
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    555a:	2302      	movs	r3, #2
    555c:	2207      	movs	r2, #7
    555e:	a805      	add	r0, sp, #20
    5560:	47a0      	blx	r4
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5562:	4629      	mov	r1, r5
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    5564:	4606      	mov	r6, r0
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5566:	2302      	movs	r3, #2
    5568:	2209      	movs	r2, #9
    556a:	a805      	add	r0, sp, #20
    556c:	47a0      	blx	r4
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    556e:	4b3d      	ldr	r3, [pc, #244]	; (5664 <grid_port_process_outbound_usb+0x2e0>)
				uint8_t key_state  =		grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYSTATE_offset  ,			GRID_CLASS_HIDKEYBOARD_KEYSTATE_length);
    5570:	f88d 000e 	strb.w	r0, [sp, #14]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    5574:	a903      	add	r1, sp, #12
    5576:	483c      	ldr	r0, [pc, #240]	; (5668 <grid_port_process_outbound_usb+0x2e4>)
				uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_offset,		GRID_CLASS_HIDKEYBOARD_KEYISMODIFIER_length);
    5578:	f88d 700d 	strb.w	r7, [sp, #13]
				uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYBOARD_KEYCODE_offset,				GRID_CLASS_HIDKEYBOARD_KEYCODE_length);
    557c:	f88d 600c 	strb.w	r6, [sp, #12]
				grid_keyboard_keychange(&grid_keyboard_state, &key);
    5580:	4798      	blx	r3
    5582:	e765      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
			else if (msg_class == GRID_CLASS_HIDKEYMACRO_code && msg_instr == GRID_INSTR_EXECUTE_code){
    5584:	2e91      	cmp	r6, #145	; 0x91
    5586:	f47f af63 	bne.w	5450 <grid_port_process_outbound_usb+0xcc>
    558a:	280e      	cmp	r0, #14
    558c:	f47f af60 	bne.w	5450 <grid_port_process_outbound_usb+0xcc>
    5590:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5592:	2302      	movs	r3, #2
    5594:	4632      	mov	r2, r6
    5596:	4629      	mov	r1, r5
    5598:	a805      	add	r0, sp, #20
    559a:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    559c:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    559e:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55a0:	2302      	movs	r3, #2
    55a2:	b2d2      	uxtb	r2, r2
    55a4:	4629      	mov	r1, r5
    55a6:	a805      	add	r0, sp, #20
    55a8:	47a0      	blx	r4
    55aa:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55ac:	28ff      	cmp	r0, #255	; 0xff
    55ae:	d00d      	beq.n	55cc <grid_port_process_outbound_usb+0x248>
                        key.ispressed = 1;
    55b0:	2201      	movs	r2, #1
    55b2:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    55b6:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    55b8:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55ba:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    55be:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    55c2:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    55c4:	e893 0003 	ldmia.w	r3, {r0, r1}
    55c8:	4b28      	ldr	r3, [pc, #160]	; (566c <grid_port_process_outbound_usb+0x2e8>)
    55ca:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    55cc:	3604      	adds	r6, #4
    55ce:	b2f6      	uxtb	r6, r6
    55d0:	2e1d      	cmp	r6, #29
    55d2:	d1de      	bne.n	5592 <grid_port_process_outbound_usb+0x20e>
                delay_ms(5);
    55d4:	4b26      	ldr	r3, [pc, #152]	; (5670 <grid_port_process_outbound_usb+0x2ec>)
    55d6:	2005      	movs	r0, #5
    55d8:	4798      	blx	r3
    55da:	2605      	movs	r6, #5
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55dc:	2302      	movs	r3, #2
    55de:	4632      	mov	r2, r6
    55e0:	4629      	mov	r1, r5
    55e2:	a805      	add	r0, sp, #20
    55e4:	47a0      	blx	r4
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55e6:	1cb2      	adds	r2, r6, #2
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    55e8:	4607      	mov	r7, r0
                    uint8_t key_code =			grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYCODE0_offset + k*4,          GRID_CLASS_HIDKEYMACRO_KEYCODE0_length);
    55ea:	2302      	movs	r3, #2
    55ec:	b2d2      	uxtb	r2, r2
    55ee:	4629      	mov	r1, r5
    55f0:	a805      	add	r0, sp, #20
    55f2:	47a0      	blx	r4
    55f4:	b2c0      	uxtb	r0, r0
                    if (key_code != 255){
    55f6:	28ff      	cmp	r0, #255	; 0xff
    55f8:	d00d      	beq.n	5616 <grid_port_process_outbound_usb+0x292>
                        key.ispressed = 0;
    55fa:	2200      	movs	r2, #0
    55fc:	f88d 200e 	strb.w	r2, [sp, #14]
                        key.delay = 100;
    5600:	2264      	movs	r2, #100	; 0x64
                        key.ismodifier = key_ismodifier;
    5602:	ab03      	add	r3, sp, #12
                    uint8_t key_ismodifier =	grid_msg_text_get_parameter(&message, current_start, GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_offset + k*4,	GRID_CLASS_HIDKEYMACRO_KEYISMODIFIER0_length);
    5604:	f88d 700d 	strb.w	r7, [sp, #13]
                        key.keycode = key_code;
    5608:	f88d 000c 	strb.w	r0, [sp, #12]
                        key.delay = 100;
    560c:	9204      	str	r2, [sp, #16]
                        grid_keyboard_tx_push(key);
    560e:	e893 0003 	ldmia.w	r3, {r0, r1}
    5612:	4b16      	ldr	r3, [pc, #88]	; (566c <grid_port_process_outbound_usb+0x2e8>)
    5614:	4798      	blx	r3
				for (uint8_t k=0; k<6; k++){
    5616:	3604      	adds	r6, #4
    5618:	b2f6      	uxtb	r6, r6
    561a:	2e1d      	cmp	r6, #29
    561c:	d1de      	bne.n	55dc <grid_port_process_outbound_usb+0x258>
    561e:	e717      	b.n	5450 <grid_port_process_outbound_usb+0xcc>
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5620:	a805      	add	r0, sp, #20
    5622:	47b0      	blx	r6
	for (uint32_t i=0; i<packet_length; i++){
    5624:	3401      	adds	r4, #1
		por->tx_double_buffer[i] = grid_msg_packet_send_char(&message, i);
    5626:	f80b 0b01 	strb.w	r0, [fp], #1
	for (uint32_t i=0; i<packet_length; i++){
    562a:	e6f1      	b.n	5410 <grid_port_process_outbound_usb+0x8c>
    562c:	00004ebd 	.word	0x00004ebd
    5630:	00008ed5 	.word	0x00008ed5
    5634:	00004f13 	.word	0x00004f13
    5638:	00004f7b 	.word	0x00004f7b
    563c:	00004fa5 	.word	0x00004fa5
    5640:	00008e9d 	.word	0x00008e9d
    5644:	00008d91 	.word	0x00008d91
    5648:	00008dd1 	.word	0x00008dd1
    564c:	00008e31 	.word	0x00008e31
    5650:	00008fcb 	.word	0x00008fcb
    5654:	0000c6b1 	.word	0x0000c6b1
    5658:	2000f008 	.word	0x2000f008
    565c:	0000b831 	.word	0x0000b831
    5660:	0000b859 	.word	0x0000b859
    5664:	0000b669 	.word	0x0000b669
    5668:	20010264 	.word	0x20010264
    566c:	0000b941 	.word	0x0000b941
    5670:	0000e709 	.word	0x0000e709
    5674:	00008f7d 	.word	0x00008f7d

00005678 <grid_port_process_outbound_ui>:

uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    5678:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    567c:	ed2d 8b02 	vpush	{d8}
	
	
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    5680:	f500 541c 	add.w	r4, r0, #9984	; 0x2700
    5684:	343c      	adds	r4, #60	; 0x3c
uint8_t grid_port_process_outbound_ui(struct grid_port* por){
    5686:	f5ad 7d7b 	sub.w	sp, sp, #1004	; 0x3ec
	uint16_t length = grid_buffer_read_size(&por->tx_buffer);
    568a:	4bb5      	ldr	r3, [pc, #724]	; (5960 <grid_port_process_outbound_ui+0x2e8>)
    568c:	4620      	mov	r0, r4
    568e:	4798      	blx	r3
	
	if (!length){
    5690:	2500      	movs	r5, #0
    5692:	9006      	str	r0, [sp, #24]
    5694:	b928      	cbnz	r0, 56a2 <grid_port_process_outbound_ui+0x2a>

		
	}
	
	
}
    5696:	f50d 7d7b 	add.w	sp, sp, #1004	; 0x3ec
    569a:	ecbd 8b02 	vpop	{d8}
    569e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56a2:	4bb0      	ldr	r3, [pc, #704]	; (5964 <grid_port_process_outbound_ui+0x2ec>)
    56a4:	952f      	str	r5, [sp, #188]	; 0xbc
    56a6:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    56aa:	4629      	mov	r1, r5
    56ac:	a830      	add	r0, sp, #192	; 0xc0
    56ae:	4798      	blx	r3
		grid_buffer_read_init(&por->tx_buffer);
    56b0:	4bad      	ldr	r3, [pc, #692]	; (5968 <grid_port_process_outbound_ui+0x2f0>)
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56b2:	4fae      	ldr	r7, [pc, #696]	; (596c <grid_port_process_outbound_ui+0x2f4>)
		grid_buffer_read_init(&por->tx_buffer);
    56b4:	4620      	mov	r0, r4
    56b6:	4798      	blx	r3
		uint8_t message[GRID_PARAMETER_PACKET_maxlength] = {0};
    56b8:	ae2f      	add	r6, sp, #188	; 0xbc
		for (uint16_t i = 0; i<length; i++){
    56ba:	9a06      	ldr	r2, [sp, #24]
    56bc:	b2ab      	uxth	r3, r5
    56be:	429a      	cmp	r2, r3
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    56c0:	4620      	mov	r0, r4
		for (uint16_t i = 0; i<length; i++){
    56c2:	d839      	bhi.n	5738 <grid_port_process_outbound_ui+0xc0>
		grid_buffer_read_acknowledge(&por->tx_buffer);
    56c4:	4baa      	ldr	r3, [pc, #680]	; (5970 <grid_port_process_outbound_ui+0x2f8>)
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56c6:	4fab      	ldr	r7, [pc, #684]	; (5974 <grid_port_process_outbound_ui+0x2fc>)
		grid_buffer_read_acknowledge(&por->tx_buffer);
    56c8:	4798      	blx	r3
		uint8_t error=0;
    56ca:	2500      	movs	r5, #0
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56cc:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    56d0:	2202      	movs	r2, #2
    56d2:	2106      	movs	r1, #6
    56d4:	4630      	mov	r0, r6
		uint8_t error=0;
    56d6:	f88d 5026 	strb.w	r5, [sp, #38]	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56da:	47b8      	blx	r7
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56dc:	f10d 0326 	add.w	r3, sp, #38	; 0x26
		uint8_t dx = grid_msg_get_parameter(message, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    56e0:	fa5f fb80 	uxtb.w	fp, r0
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56e4:	2202      	movs	r2, #2
    56e6:	2108      	movs	r1, #8
    56e8:	4630      	mov	r0, r6
    56ea:	47b8      	blx	r7
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    56ec:	f1bb 0f7f 	cmp.w	fp, #127	; 0x7f
		uint8_t dy = grid_msg_get_parameter(message, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    56f0:	b2c0      	uxtb	r0, r0
		if (dx == GRID_SYS_DEFAULT_POSITION && dy == GRID_SYS_DEFAULT_POSITION){
    56f2:	d125      	bne.n	5740 <grid_port_process_outbound_ui+0xc8>
			position_is_me = 1;
    56f4:	f1a0 027f 	sub.w	r2, r0, #127	; 0x7f
    56f8:	f1d2 0b00 	rsbs	fp, r2, #0
    56fc:	eb4b 0b02 	adc.w	fp, fp, r2
		uint8_t position_is_local = 0;
    5700:	462c      	mov	r4, r5
		uint8_t position_is_global = 0;
    5702:	9502      	str	r5, [sp, #8]
		uint8_t error_flag = 0;	
    5704:	2300      	movs	r3, #0
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    5706:	4d9c      	ldr	r5, [pc, #624]	; (5978 <grid_port_process_outbound_ui+0x300>)
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5708:	f8df a298 	ldr.w	sl, [pc, #664]	; 59a4 <grid_port_process_outbound_ui+0x32c>
		uint8_t error_flag = 0;	
    570c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    5710:	9303      	str	r3, [sp, #12]
		uint8_t current_start		= 0;
    5712:	4698      	mov	r8, r3
			if (message[i] == GRID_CONST_STX){
    5714:	9b03      	ldr	r3, [sp, #12]
    5716:	f10d 09bc 	add.w	r9, sp, #188	; 0xbc
    571a:	f813 1009 	ldrb.w	r1, [r3, r9]
    571e:	2902      	cmp	r1, #2
    5720:	d120      	bne.n	5764 <grid_port_process_outbound_ui+0xec>
				current_start = i;
    5722:	f89d 800c 	ldrb.w	r8, [sp, #12]
		for (uint16_t i=0; i<length; i++){
    5726:	9b03      	ldr	r3, [sp, #12]
    5728:	9a06      	ldr	r2, [sp, #24]
    572a:	3301      	adds	r3, #1
    572c:	9303      	str	r3, [sp, #12]
    572e:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    5732:	429a      	cmp	r2, r3
    5734:	d8ee      	bhi.n	5714 <grid_port_process_outbound_ui+0x9c>
    5736:	e7ae      	b.n	5696 <grid_port_process_outbound_ui+0x1e>
			message[i] = grid_buffer_read_character(&por->tx_buffer);
    5738:	47b8      	blx	r7
    573a:	5570      	strb	r0, [r6, r5]
		for (uint16_t i = 0; i<length; i++){
    573c:	3501      	adds	r5, #1
    573e:	e7bc      	b.n	56ba <grid_port_process_outbound_ui+0x42>
		else if (dx == GRID_SYS_GLOBAL_POSITION && dy==GRID_SYS_GLOBAL_POSITION){
    5740:	f1bb 0f00 	cmp.w	fp, #0
    5744:	d105      	bne.n	5752 <grid_port_process_outbound_ui+0xda>
		uint8_t position_is_global = 0;
    5746:	fab0 f380 	clz	r3, r0
    574a:	095b      	lsrs	r3, r3, #5
    574c:	9302      	str	r3, [sp, #8]
		uint8_t position_is_local = 0;
    574e:	465c      	mov	r4, fp
    5750:	e7d8      	b.n	5704 <grid_port_process_outbound_ui+0x8c>
		else if (dx == GRID_SYS_LOCAL_POSITION && dy==GRID_SYS_LOCAL_POSITION){
    5752:	ea0b 0000 	and.w	r0, fp, r0
    5756:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
    575a:	425c      	negs	r4, r3
    575c:	415c      	adcs	r4, r3
		uint8_t position_is_global = 0;
    575e:	46ab      	mov	fp, r5
		uint8_t position_is_me = 0;
    5760:	9502      	str	r5, [sp, #8]
    5762:	e7cf      	b.n	5704 <grid_port_process_outbound_ui+0x8c>
			else if (message[i] == GRID_CONST_ETX && current_start!=0){
    5764:	2903      	cmp	r1, #3
    5766:	d1de      	bne.n	5726 <grid_port_process_outbound_ui+0xae>
    5768:	f1b8 0f00 	cmp.w	r8, #0
    576c:	d102      	bne.n	5774 <grid_port_process_outbound_ui+0xfc>
				current_start = 0;
    576e:	f04f 0800 	mov.w	r8, #0
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    5772:	e7d8      	b.n	5726 <grid_port_process_outbound_ui+0xae>
				uint8_t msg_class = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_offset], GRID_CLASS_length, &error_flag);
    5774:	f108 0001 	add.w	r0, r8, #1
    5778:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    577c:	4448      	add	r0, r9
    577e:	47a8      	blx	r5
    5780:	b2c6      	uxtb	r6, r0
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    5782:	f108 0004 	add.w	r0, r8, #4
    5786:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    578a:	2101      	movs	r1, #1
    578c:	4448      	add	r0, r9
    578e:	47a8      	blx	r5
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    5790:	2e30      	cmp	r6, #48	; 0x30
				uint8_t msg_instr = grid_sys_read_hex_string_value(&message[current_start+GRID_INSTR_offset], GRID_INSTR_length, &error_flag);
    5792:	b2c7      	uxtb	r7, r0
				if (msg_class == GRID_CLASS_BANKACTIVE_code){
    5794:	d126      	bne.n	57e4 <grid_port_process_outbound_ui+0x16c>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    5796:	f108 0005 	add.w	r0, r8, #5
    579a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    579e:	2102      	movs	r1, #2
    57a0:	4448      	add	r0, r9
    57a2:	47a8      	blx	r5
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57a4:	2f0e      	cmp	r7, #14
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKACTIVE_BANKNUMBER_offset], GRID_CLASS_BANKACTIVE_BANKNUMBER_length, &error_flag);
    57a6:	4606      	mov	r6, r0
					if (msg_instr == GRID_INSTR_EXECUTE_code){ //SET BANK
    57a8:	d10e      	bne.n	57c8 <grid_port_process_outbound_ui+0x150>
						if (grid_sys_get_bank_valid(&grid_sys_state) == 0){
    57aa:	4874      	ldr	r0, [pc, #464]	; (597c <grid_port_process_outbound_ui+0x304>)
    57ac:	4b74      	ldr	r3, [pc, #464]	; (5980 <grid_port_process_outbound_ui+0x308>)
    57ae:	4798      	blx	r3
    57b0:	4602      	mov	r2, r0
    57b2:	b920      	cbnz	r0, 57be <grid_port_process_outbound_ui+0x146>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
    57b4:	4601      	mov	r1, r0
    57b6:	4f73      	ldr	r7, [pc, #460]	; (5984 <grid_port_process_outbound_ui+0x30c>)
    57b8:	4873      	ldr	r0, [pc, #460]	; (5988 <grid_port_process_outbound_ui+0x310>)
    57ba:	230c      	movs	r3, #12
    57bc:	47b8      	blx	r7
						grid_sys_set_bank(&grid_sys_state, banknumber);
    57be:	486f      	ldr	r0, [pc, #444]	; (597c <grid_port_process_outbound_ui+0x304>)
    57c0:	b2f1      	uxtb	r1, r6
								grid_sys_set_bank(&grid_sys_state, banknumber);
    57c2:	4b72      	ldr	r3, [pc, #456]	; (598c <grid_port_process_outbound_ui+0x314>)
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    57c4:	4798      	blx	r3
    57c6:	e7d2      	b.n	576e <grid_port_process_outbound_ui+0xf6>
					else if (msg_instr == GRID_INSTR_FETCH_code){ //GET BANK
    57c8:	2f0f      	cmp	r7, #15
    57ca:	d1d0      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_valid(&grid_sys_state) != 0){
    57cc:	486b      	ldr	r0, [pc, #428]	; (597c <grid_port_process_outbound_ui+0x304>)
    57ce:	4b6c      	ldr	r3, [pc, #432]	; (5980 <grid_port_process_outbound_ui+0x308>)
    57d0:	4798      	blx	r3
    57d2:	2800      	cmp	r0, #0
    57d4:	d0cb      	beq.n	576e <grid_port_process_outbound_ui+0xf6>
							grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
    57d6:	2200      	movs	r2, #0
    57d8:	486b      	ldr	r0, [pc, #428]	; (5988 <grid_port_process_outbound_ui+0x310>)
    57da:	4e6a      	ldr	r6, [pc, #424]	; (5984 <grid_port_process_outbound_ui+0x30c>)
    57dc:	2309      	movs	r3, #9
    57de:	4611      	mov	r1, r2
    57e0:	47b0      	blx	r6
    57e2:	e7c4      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_BANKENABLED_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    57e4:	2e31      	cmp	r6, #49	; 0x31
    57e6:	d140      	bne.n	586a <grid_port_process_outbound_ui+0x1f2>
    57e8:	2f0e      	cmp	r7, #14
    57ea:	d1c0      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
    57ec:	9b02      	ldr	r3, [sp, #8]
    57ee:	ea4b 0303 	orr.w	r3, fp, r3
    57f2:	4323      	orrs	r3, r4
    57f4:	d0bb      	beq.n	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_BANKNUMBER_offset], GRID_CLASS_BANKENABLED_BANKNUMBER_length, &error_flag);
    57f6:	f108 0005 	add.w	r0, r8, #5
    57fa:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    57fe:	2102      	movs	r1, #2
    5800:	4448      	add	r0, r9
    5802:	47a8      	blx	r5
    5804:	b2c6      	uxtb	r6, r0
					uint8_t isenabled  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKENABLED_ISENABLED_offset], GRID_CLASS_BANKENABLED_ISENABLED_length, &error_flag);
    5806:	f108 0007 	add.w	r0, r8, #7
    580a:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    580e:	2102      	movs	r1, #2
    5810:	4448      	add	r0, r9
    5812:	47a8      	blx	r5
    5814:	fa5f f880 	uxtb.w	r8, r0
					if (isenabled == 1){
    5818:	f1b8 0f01 	cmp.w	r8, #1
    581c:	d110      	bne.n	5840 <grid_port_process_outbound_ui+0x1c8>
						grid_sys_bank_enable(&grid_sys_state, banknumber);
    581e:	4f57      	ldr	r7, [pc, #348]	; (597c <grid_port_process_outbound_ui+0x304>)
    5820:	4b5b      	ldr	r3, [pc, #364]	; (5990 <grid_port_process_outbound_ui+0x318>)
    5822:	4631      	mov	r1, r6
    5824:	4638      	mov	r0, r7
    5826:	4798      	blx	r3
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5828:	4b5a      	ldr	r3, [pc, #360]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    582a:	4638      	mov	r0, r7
    582c:	4798      	blx	r3
    582e:	42b0      	cmp	r0, r6
    5830:	d19d      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
							if (grid_sys_state.bank_activebank_valid == 1){
    5832:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    5836:	2b01      	cmp	r3, #1
    5838:	d199      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
								grid_sys_set_bank(&grid_sys_state, banknumber);
    583a:	4631      	mov	r1, r6
    583c:	4638      	mov	r0, r7
    583e:	e7c0      	b.n	57c2 <grid_port_process_outbound_ui+0x14a>
					}else if (isenabled == 0){	
    5840:	f1b8 0f00 	cmp.w	r8, #0
    5844:	d193      	bne.n	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    5846:	484d      	ldr	r0, [pc, #308]	; (597c <grid_port_process_outbound_ui+0x304>)
    5848:	4b52      	ldr	r3, [pc, #328]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    584a:	4798      	blx	r3
    584c:	42b0      	cmp	r0, r6
    584e:	d107      	bne.n	5860 <grid_port_process_outbound_ui+0x1e8>
							if (grid_sys_state.bank_activebank_valid == 1){
    5850:	484a      	ldr	r0, [pc, #296]	; (597c <grid_port_process_outbound_ui+0x304>)
    5852:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
    5856:	2b01      	cmp	r3, #1
    5858:	d102      	bne.n	5860 <grid_port_process_outbound_ui+0x1e8>
								grid_sys_set_bank(&grid_sys_state, 255);
    585a:	4b4c      	ldr	r3, [pc, #304]	; (598c <grid_port_process_outbound_ui+0x314>)
    585c:	21ff      	movs	r1, #255	; 0xff
    585e:	4798      	blx	r3
						grid_sys_bank_disable(&grid_sys_state, banknumber);
    5860:	4b4d      	ldr	r3, [pc, #308]	; (5998 <grid_port_process_outbound_ui+0x320>)
    5862:	4846      	ldr	r0, [pc, #280]	; (597c <grid_port_process_outbound_ui+0x304>)
    5864:	4631      	mov	r1, r6
    5866:	4798      	blx	r3
    5868:	e75d      	b.n	5726 <grid_port_process_outbound_ui+0xae>
				else if (msg_class == GRID_CLASS_BANKCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_global || position_is_me || position_is_local)){
    586a:	2e32      	cmp	r6, #50	; 0x32
    586c:	d147      	bne.n	58fe <grid_port_process_outbound_ui+0x286>
    586e:	2f0e      	cmp	r7, #14
    5870:	f47f af7d 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5874:	9b02      	ldr	r3, [sp, #8]
    5876:	ea4b 0303 	orr.w	r3, fp, r3
    587a:	4323      	orrs	r3, r4
    587c:	f43f af77 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    5880:	f108 0005 	add.w	r0, r8, #5
    5884:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5888:	2102      	movs	r1, #2
    588a:	4448      	add	r0, r9
    588c:	47a8      	blx	r5
    588e:	b2c3      	uxtb	r3, r0
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    5890:	f108 0007 	add.w	r0, r8, #7
    5894:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5898:	2102      	movs	r1, #2
    589a:	4448      	add	r0, r9
					uint8_t banknumber = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_NUM_offset], GRID_CLASS_BANKCOLOR_NUM_length, &error_flag);
    589c:	ee08 3a10 	vmov	s16, r3
					uint8_t red		   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_RED_offset], GRID_CLASS_BANKCOLOR_RED_length, &error_flag);
    58a0:	47a8      	blx	r5
    58a2:	4606      	mov	r6, r0
					uint8_t green	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_GRE_offset], GRID_CLASS_BANKCOLOR_GRE_length, &error_flag);
    58a4:	f108 0009 	add.w	r0, r8, #9
    58a8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58ac:	2102      	movs	r1, #2
    58ae:	4448      	add	r0, r9
    58b0:	47a8      	blx	r5
    58b2:	4607      	mov	r7, r0
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58b4:	f108 000b 	add.w	r0, r8, #11
    58b8:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    58bc:	2102      	movs	r1, #2
    58be:	4448      	add	r0, r9
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    58c0:	0436      	lsls	r6, r6, #16
    58c2:	023f      	lsls	r7, r7, #8
					uint8_t blue	   = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_BANKCOLOR_BLU_offset], GRID_CLASS_BANKCOLOR_BLU_length, &error_flag);
    58c4:	47a8      	blx	r5
					grid_sys_bank_set_color(&grid_sys_state, banknumber, (red<<16) + (green<<8) + (blue<<0) );
    58c6:	b2bf      	uxth	r7, r7
    58c8:	f406 067f 	and.w	r6, r6, #16711680	; 0xff0000
    58cc:	433e      	orrs	r6, r7
    58ce:	4f2b      	ldr	r7, [pc, #172]	; (597c <grid_port_process_outbound_ui+0x304>)
    58d0:	4b32      	ldr	r3, [pc, #200]	; (599c <grid_port_process_outbound_ui+0x324>)
    58d2:	fa56 f280 	uxtab	r2, r6, r0
    58d6:	ee18 1a10 	vmov	r1, s16
    58da:	4638      	mov	r0, r7
    58dc:	4798      	blx	r3
					if (grid_sys_get_bank_num(&grid_sys_state) == banknumber){
    58de:	4b2d      	ldr	r3, [pc, #180]	; (5994 <grid_port_process_outbound_ui+0x31c>)
    58e0:	4638      	mov	r0, r7
    58e2:	4798      	blx	r3
    58e4:	ee18 3a10 	vmov	r3, s16
    58e8:	4298      	cmp	r0, r3
    58ea:	f47f af40 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
						if (grid_sys_state.bank_activebank_valid == 1){
    58ee:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
    58f2:	2b01      	cmp	r3, #1
    58f4:	f47f af3b 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
							grid_sys_set_bank(&grid_sys_state, banknumber);
    58f8:	ee18 1a10 	vmov	r1, s16
    58fc:	e79e      	b.n	583c <grid_port_process_outbound_ui+0x1c4>
				else if (msg_class == GRID_CLASS_LEDPHASE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    58fe:	2e40      	cmp	r6, #64	; 0x40
    5900:	d154      	bne.n	59ac <grid_port_process_outbound_ui+0x334>
    5902:	2f0e      	cmp	r7, #14
    5904:	f47f af33 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5908:	ea5b 0304 	orrs.w	r3, fp, r4
    590c:	f43f af2f 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_NUM_offset], GRID_CLASS_LEDPHASE_NUM_length, &error_flag);
    5910:	f108 0005 	add.w	r0, r8, #5
    5914:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5918:	2102      	movs	r1, #2
    591a:	4448      	add	r0, r9
    591c:	47a8      	blx	r5
    591e:	b2c6      	uxtb	r6, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_LAY_offset], GRID_CLASS_LEDPHASE_LAY_length, &error_flag);
    5920:	f108 0007 	add.w	r0, r8, #7
    5924:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5928:	2102      	movs	r1, #2
    592a:	4448      	add	r0, r9
    592c:	47a8      	blx	r5
    592e:	b2c7      	uxtb	r7, r0
					uint16_t led_pha  = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDPHASE_PHA_offset], GRID_CLASS_LEDPHASE_PHA_length, &error_flag);
    5930:	f108 0009 	add.w	r0, r8, #9
    5934:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5938:	2102      	movs	r1, #2
    593a:	4448      	add	r0, r9
    593c:	47a8      	blx	r5
					if (led_pha*2 > 255){
    593e:	b283      	uxth	r3, r0
    5940:	005b      	lsls	r3, r3, #1
    5942:	2bff      	cmp	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    5944:	bfdc      	itt	le
    5946:	0040      	lslle	r0, r0, #1
    5948:	f000 03fe 	andle.w	r3, r0, #254	; 0xfe
    594c:	f8df 8058 	ldr.w	r8, [pc, #88]	; 59a8 <grid_port_process_outbound_ui+0x330>
    5950:	4813      	ldr	r0, [pc, #76]	; (59a0 <grid_port_process_outbound_ui+0x328>)
						grid_led_set_phase(&grid_led_state, led_num, led_lay, 255);
    5952:	bfc8      	it	gt
    5954:	23ff      	movgt	r3, #255	; 0xff
						grid_led_set_phase(&grid_led_state, led_num, led_lay, led_pha*2);
    5956:	463a      	mov	r2, r7
    5958:	4631      	mov	r1, r6
    595a:	47c0      	blx	r8
    595c:	e707      	b.n	576e <grid_port_process_outbound_ui+0xf6>
    595e:	bf00      	nop
    5960:	00004ebd 	.word	0x00004ebd
    5964:	00014d51 	.word	0x00014d51
    5968:	00004f13 	.word	0x00004f13
    596c:	00004f7b 	.word	0x00004f7b
    5970:	00004fa5 	.word	0x00004fa5
    5974:	0000a325 	.word	0x0000a325
    5978:	0000a171 	.word	0x0000a171
    597c:	2000f008 	.word	0x2000f008
    5980:	0000a01b 	.word	0x0000a01b
    5984:	0000aaa1 	.word	0x0000aaa1
    5988:	2001c7c0 	.word	0x2001c7c0
    598c:	0000a073 	.word	0x0000a073
    5990:	00009fe9 	.word	0x00009fe9
    5994:	0000a017 	.word	0x0000a017
    5998:	00009ff5 	.word	0x00009ff5
    599c:	0000a001 	.word	0x0000a001
    59a0:	2001c838 	.word	0x2001c838
    59a4:	2000effc 	.word	0x2000effc
    59a8:	00007695 	.word	0x00007695
				else if (msg_class == GRID_CLASS_LEDCOLOR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_local || position_is_me)){
    59ac:	2e41      	cmp	r6, #65	; 0x41
    59ae:	d13a      	bne.n	5a26 <grid_port_process_outbound_ui+0x3ae>
    59b0:	2f0e      	cmp	r7, #14
    59b2:	f47f aedc 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    59b6:	ea5b 0304 	orrs.w	r3, fp, r4
    59ba:	f43f aed8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t led_num = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_NUM_offset], GRID_CLASS_LEDCOLOR_NUM_length, &error_flag);
    59be:	f108 0005 	add.w	r0, r8, #5
    59c2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59c6:	2102      	movs	r1, #2
    59c8:	4448      	add	r0, r9
    59ca:	47a8      	blx	r5
    59cc:	4607      	mov	r7, r0
					uint8_t led_lay = grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_LAY_offset], GRID_CLASS_LEDCOLOR_LAY_length, &error_flag);
    59ce:	f108 0007 	add.w	r0, r8, #7
    59d2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59d6:	2102      	movs	r1, #2
    59d8:	4448      	add	r0, r9
    59da:	47a8      	blx	r5
    59dc:	9004      	str	r0, [sp, #16]
					uint8_t led_red	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_RED_offset], GRID_CLASS_LEDCOLOR_RED_length, &error_flag);
    59de:	f108 0009 	add.w	r0, r8, #9
    59e2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59e6:	2102      	movs	r1, #2
    59e8:	4448      	add	r0, r9
    59ea:	47a8      	blx	r5
    59ec:	9005      	str	r0, [sp, #20]
					uint8_t led_gre	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_GRE_offset], GRID_CLASS_LEDCOLOR_GRE_length, &error_flag);
    59ee:	f108 000b 	add.w	r0, r8, #11
    59f2:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    59f6:	2102      	movs	r1, #2
    59f8:	4448      	add	r0, r9
    59fa:	47a8      	blx	r5
    59fc:	4606      	mov	r6, r0
					uint8_t led_blu	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_LEDCOLOR_BLU_offset], GRID_CLASS_LEDCOLOR_BLU_length, &error_flag);
    59fe:	f108 000d 	add.w	r0, r8, #13
    5a02:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5a06:	2102      	movs	r1, #2
    5a08:	4448      	add	r0, r9
    5a0a:	47a8      	blx	r5
					grid_led_set_color(&grid_led_state, led_num, led_lay, led_red, led_gre, led_blu);
    5a0c:	9b05      	ldr	r3, [sp, #20]
    5a0e:	f89d 2010 	ldrb.w	r2, [sp, #16]
    5a12:	b2c0      	uxtb	r0, r0
    5a14:	b2f6      	uxtb	r6, r6
    5a16:	9001      	str	r0, [sp, #4]
    5a18:	9600      	str	r6, [sp, #0]
    5a1a:	48a9      	ldr	r0, [pc, #676]	; (5cc0 <grid_port_process_outbound_ui+0x648>)
    5a1c:	4ea9      	ldr	r6, [pc, #676]	; (5cc4 <grid_port_process_outbound_ui+0x64c>)
    5a1e:	b2db      	uxtb	r3, r3
    5a20:	b2f9      	uxtb	r1, r7
    5a22:	47b0      	blx	r6
    5a24:	e6a3      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if(msg_class == GRID_CLASS_SERIALNUMBER_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5a26:	2e11      	cmp	r6, #17
    5a28:	d15d      	bne.n	5ae6 <grid_port_process_outbound_ui+0x46e>
    5a2a:	2f0f      	cmp	r7, #15
    5a2c:	f47f ae9f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5a30:	9b02      	ldr	r3, [sp, #8]
    5a32:	ea5b 0303 	orrs.w	r3, fp, r3
    5a36:	f43f ae9a 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint32_t uniqueid[4] = {0};
    5a3a:	2210      	movs	r2, #16
    5a3c:	2100      	movs	r1, #0
    5a3e:	4fa2      	ldr	r7, [pc, #648]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a40:	f8df 82ac 	ldr.w	r8, [pc, #684]	; 5cf0 <grid_port_process_outbound_ui+0x678>
					uint32_t uniqueid[4] = {0};
    5a44:	a80a      	add	r0, sp, #40	; 0x28
    5a46:	47b8      	blx	r7
					grid_sys_get_id(uniqueid);					
    5a48:	4ba0      	ldr	r3, [pc, #640]	; (5ccc <grid_port_process_outbound_ui+0x654>)
    5a4a:	a80a      	add	r0, sp, #40	; 0x28
    5a4c:	4798      	blx	r3
					grid_msg_init(&response);
    5a4e:	4ba0      	ldr	r3, [pc, #640]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
    5a50:	a893      	add	r0, sp, #588	; 0x24c
    5a52:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5a54:	227f      	movs	r2, #127	; 0x7f
    5a56:	2300      	movs	r3, #0
    5a58:	4611      	mov	r1, r2
    5a5a:	a893      	add	r0, sp, #588	; 0x24c
    5a5c:	47c0      	blx	r8
					uint8_t response_payload[50] = {0};
    5a5e:	f04f 0800 	mov.w	r8, #0
    5a62:	222e      	movs	r2, #46	; 0x2e
    5a64:	4641      	mov	r1, r8
    5a66:	a80f      	add	r0, sp, #60	; 0x3c
    5a68:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5a6c:	47b8      	blx	r7
					snprintf(response_payload, 49, GRID_CLASS_SERIALNUMBER_frame);
    5a6e:	2303      	movs	r3, #3
    5a70:	e9cd 6300 	strd	r6, r3, [sp]
    5a74:	4a97      	ldr	r2, [pc, #604]	; (5cd4 <grid_port_process_outbound_ui+0x65c>)
    5a76:	4e98      	ldr	r6, [pc, #608]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
    5a78:	2131      	movs	r1, #49	; 0x31
    5a7a:	2302      	movs	r3, #2
    5a7c:	a80e      	add	r0, sp, #56	; 0x38
    5a7e:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a80:	4b96      	ldr	r3, [pc, #600]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a82:	4e97      	ldr	r6, [pc, #604]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a84:	a80e      	add	r0, sp, #56	; 0x38
    5a86:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a88:	270d      	movs	r7, #13
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5a8a:	4602      	mov	r2, r0
    5a8c:	4b95      	ldr	r3, [pc, #596]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5a8e:	a90e      	add	r1, sp, #56	; 0x38
    5a90:	a893      	add	r0, sp, #588	; 0x24c
    5a92:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);					
    5a94:	2301      	movs	r3, #1
    5a96:	2204      	movs	r2, #4
    5a98:	4641      	mov	r1, r8
    5a9a:	a893      	add	r0, sp, #588	; 0x24c
    5a9c:	9700      	str	r7, [sp, #0]
    5a9e:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD0_offset, GRID_CLASS_SERIALNUMBER_WORD0_length, uniqueid[0]);
    5aa0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    5aa2:	9300      	str	r3, [sp, #0]
    5aa4:	2205      	movs	r2, #5
    5aa6:	2308      	movs	r3, #8
    5aa8:	4641      	mov	r1, r8
    5aaa:	a893      	add	r0, sp, #588	; 0x24c
    5aac:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD1_offset, GRID_CLASS_SERIALNUMBER_WORD1_length, uniqueid[1]);
    5aae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    5ab0:	9300      	str	r3, [sp, #0]
    5ab2:	463a      	mov	r2, r7
    5ab4:	2308      	movs	r3, #8
    5ab6:	4641      	mov	r1, r8
    5ab8:	a893      	add	r0, sp, #588	; 0x24c
    5aba:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD2_offset, GRID_CLASS_SERIALNUMBER_WORD2_length, uniqueid[2]);
    5abc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    5abe:	9300      	str	r3, [sp, #0]
    5ac0:	2215      	movs	r2, #21
    5ac2:	2308      	movs	r3, #8
    5ac4:	4641      	mov	r1, r8
    5ac6:	a893      	add	r0, sp, #588	; 0x24c
    5ac8:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_SERIALNUMBER_WORD3_offset, GRID_CLASS_SERIALNUMBER_WORD3_length, uniqueid[3]);
    5aca:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    5acc:	9300      	str	r3, [sp, #0]
    5ace:	221d      	movs	r2, #29
    5ad0:	2308      	movs	r3, #8
    5ad2:	4641      	mov	r1, r8
    5ad4:	a893      	add	r0, sp, #588	; 0x24c
    5ad6:	47b0      	blx	r6
					grid_msg_packet_close(&response);
    5ad8:	4b83      	ldr	r3, [pc, #524]	; (5ce8 <grid_port_process_outbound_ui+0x670>)
    5ada:	a893      	add	r0, sp, #588	; 0x24c
    5adc:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    5ade:	4b83      	ldr	r3, [pc, #524]	; (5cec <grid_port_process_outbound_ui+0x674>)
    5ae0:	a893      	add	r0, sp, #588	; 0x24c
    5ae2:	4798      	blx	r3
				else if(msg_class == GRID_CLASS_UPTIME_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5ae4:	e61f      	b.n	5726 <grid_port_process_outbound_ui+0xae>
    5ae6:	2e14      	cmp	r6, #20
    5ae8:	d13f      	bne.n	5b6a <grid_port_process_outbound_ui+0x4f2>
    5aea:	2f0f      	cmp	r7, #15
    5aec:	f47f ae3f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5af0:	9b02      	ldr	r3, [sp, #8]
    5af2:	ea5b 0303 	orrs.w	r3, fp, r3
    5af6:	f43f ae3a 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5afa:	4b75      	ldr	r3, [pc, #468]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5afc:	4f7c      	ldr	r7, [pc, #496]	; (5cf0 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5afe:	a893      	add	r0, sp, #588	; 0x24c
    5b00:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b02:	227f      	movs	r2, #127	; 0x7f
					uint8_t response_payload[50] = {0};
    5b04:	f04f 0800 	mov.w	r8, #0
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b08:	4611      	mov	r1, r2
    5b0a:	2300      	movs	r3, #0
    5b0c:	a893      	add	r0, sp, #588	; 0x24c
    5b0e:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b10:	4b6d      	ldr	r3, [pc, #436]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
    5b12:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    5b16:	222e      	movs	r2, #46	; 0x2e
    5b18:	4641      	mov	r1, r8
    5b1a:	a80f      	add	r0, sp, #60	; 0x3c
    5b1c:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b1e:	2303      	movs	r3, #3
    5b20:	e9cd 6300 	strd	r6, r3, [sp]
    5b24:	4a73      	ldr	r2, [pc, #460]	; (5cf4 <grid_port_process_outbound_ui+0x67c>)
    5b26:	4e6c      	ldr	r6, [pc, #432]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b28:	4f6d      	ldr	r7, [pc, #436]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					snprintf(response_payload, 49, GRID_CLASS_UPTIME_frame);
    5b2a:	2131      	movs	r1, #49	; 0x31
    5b2c:	2302      	movs	r3, #2
    5b2e:	a80e      	add	r0, sp, #56	; 0x38
    5b30:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b32:	4b6a      	ldr	r3, [pc, #424]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b34:	4e70      	ldr	r6, [pc, #448]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5b36:	a80e      	add	r0, sp, #56	; 0x38
    5b38:	4798      	blx	r3
    5b3a:	4b6a      	ldr	r3, [pc, #424]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5b3c:	4602      	mov	r2, r0
    5b3e:	a90e      	add	r1, sp, #56	; 0x38
    5b40:	a893      	add	r0, sp, #588	; 0x24c
    5b42:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5b44:	230d      	movs	r3, #13
    5b46:	9300      	str	r3, [sp, #0]
    5b48:	2204      	movs	r2, #4
    5b4a:	2301      	movs	r3, #1
    5b4c:	4641      	mov	r1, r8
    5b4e:	a893      	add	r0, sp, #588	; 0x24c
    5b50:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_UPTIME_UPTIME_offset, GRID_CLASS_UPTIME_UPTIME_length, grid_sys_state.uptime);
    5b52:	6833      	ldr	r3, [r6, #0]
    5b54:	9300      	str	r3, [sp, #0]
    5b56:	2205      	movs	r2, #5
    5b58:	2308      	movs	r3, #8
    5b5a:	4641      	mov	r1, r8
    5b5c:	a893      	add	r0, sp, #588	; 0x24c
    5b5e:	47b8      	blx	r7
					uint32_t milliseconds = grid_sys_state.uptime/RTC1MS%1000;
    5b60:	6833      	ldr	r3, [r6, #0]
					uint32_t seconds =		grid_sys_state.uptime/RTC1MS/1000%60;
    5b62:	6833      	ldr	r3, [r6, #0]
					uint32_t minutes =		grid_sys_state.uptime/RTC1MS/1000/60%60;
    5b64:	6833      	ldr	r3, [r6, #0]
					uint32_t hours =		grid_sys_state.uptime/RTC1MS/1000/60/60%60;
    5b66:	6833      	ldr	r3, [r6, #0]
    5b68:	e7b6      	b.n	5ad8 <grid_port_process_outbound_ui+0x460>
				else if(msg_class == GRID_CLASS_RESETCAUSE_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5b6a:	2e12      	cmp	r6, #18
    5b6c:	d137      	bne.n	5bde <grid_port_process_outbound_ui+0x566>
    5b6e:	2f0f      	cmp	r7, #15
    5b70:	f47f adfd 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5b74:	9b02      	ldr	r3, [sp, #8]
    5b76:	ea5b 0303 	orrs.w	r3, fp, r3
    5b7a:	f43f adf8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_msg_init(&response);
    5b7e:	4b54      	ldr	r3, [pc, #336]	; (5cd0 <grid_port_process_outbound_ui+0x658>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b80:	4f5b      	ldr	r7, [pc, #364]	; (5cf0 <grid_port_process_outbound_ui+0x678>)
					grid_msg_init(&response);
    5b82:	a893      	add	r0, sp, #588	; 0x24c
    5b84:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5b86:	227f      	movs	r2, #127	; 0x7f
    5b88:	4611      	mov	r1, r2
    5b8a:	2300      	movs	r3, #0
    5b8c:	a893      	add	r0, sp, #588	; 0x24c
    5b8e:	47b8      	blx	r7
					uint8_t response_payload[50] = {0};
    5b90:	2700      	movs	r7, #0
    5b92:	4b4d      	ldr	r3, [pc, #308]	; (5cc8 <grid_port_process_outbound_ui+0x650>)
    5b94:	970e      	str	r7, [sp, #56]	; 0x38
    5b96:	222e      	movs	r2, #46	; 0x2e
    5b98:	4639      	mov	r1, r7
    5b9a:	a80f      	add	r0, sp, #60	; 0x3c
    5b9c:	4798      	blx	r3
					snprintf(response_payload, 49, GRID_CLASS_RESETCAUSE_frame);
    5b9e:	2303      	movs	r3, #3
    5ba0:	e9cd 6300 	strd	r6, r3, [sp]
    5ba4:	4a55      	ldr	r2, [pc, #340]	; (5cfc <grid_port_process_outbound_ui+0x684>)
    5ba6:	4e4c      	ldr	r6, [pc, #304]	; (5cd8 <grid_port_process_outbound_ui+0x660>)
    5ba8:	2131      	movs	r1, #49	; 0x31
    5baa:	2302      	movs	r3, #2
    5bac:	a80e      	add	r0, sp, #56	; 0x38
    5bae:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bb0:	4b4a      	ldr	r3, [pc, #296]	; (5cdc <grid_port_process_outbound_ui+0x664>)
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bb2:	4e4b      	ldr	r6, [pc, #300]	; (5ce0 <grid_port_process_outbound_ui+0x668>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5bb4:	a80e      	add	r0, sp, #56	; 0x38
    5bb6:	4798      	blx	r3
    5bb8:	4b4a      	ldr	r3, [pc, #296]	; (5ce4 <grid_port_process_outbound_ui+0x66c>)
    5bba:	4602      	mov	r2, r0
    5bbc:	a90e      	add	r1, sp, #56	; 0x38
    5bbe:	a893      	add	r0, sp, #588	; 0x24c
    5bc0:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5bc2:	230d      	movs	r3, #13
    5bc4:	9300      	str	r3, [sp, #0]
    5bc6:	2204      	movs	r2, #4
    5bc8:	2301      	movs	r3, #1
    5bca:	4639      	mov	r1, r7
    5bcc:	a893      	add	r0, sp, #588	; 0x24c
    5bce:	47b0      	blx	r6
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_RESETCAUSE_CAUSE_offset, GRID_CLASS_RESETCAUSE_CAUSE_length,grid_sys_state.reset_cause);
    5bd0:	4b49      	ldr	r3, [pc, #292]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5bd2:	791b      	ldrb	r3, [r3, #4]
    5bd4:	9300      	str	r3, [sp, #0]
    5bd6:	2205      	movs	r2, #5
    5bd8:	2302      	movs	r3, #2
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5bda:	4639      	mov	r1, r7
    5bdc:	e26e      	b.n	60bc <grid_port_process_outbound_ui+0xa44>
				else if(msg_class == GRID_CLASS_RESET_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me)){
    5bde:	2e13      	cmp	r6, #19
    5be0:	d113      	bne.n	5c0a <grid_port_process_outbound_ui+0x592>
    5be2:	2f0e      	cmp	r7, #14
    5be4:	f47f adc3 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5be8:	f1bb 0f00 	cmp.w	fp, #0
    5bec:	f43f adbf 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    5bf0:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5bf4:	4942      	ldr	r1, [pc, #264]	; (5d00 <grid_port_process_outbound_ui+0x688>)
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5bf6:	4b43      	ldr	r3, [pc, #268]	; (5d04 <grid_port_process_outbound_ui+0x68c>)
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    5bf8:	68ca      	ldr	r2, [r1, #12]
    5bfa:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    5bfe:	4313      	orrs	r3, r2
    5c00:	60cb      	str	r3, [r1, #12]
    5c02:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    5c06:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    5c08:	e7fd      	b.n	5c06 <grid_port_process_outbound_ui+0x58e>
				else if (msg_class == GRID_CLASS_GLOBALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c0a:	2e61      	cmp	r6, #97	; 0x61
    5c0c:	d10c      	bne.n	5c28 <grid_port_process_outbound_ui+0x5b0>
    5c0e:	2f0e      	cmp	r7, #14
    5c10:	f47f adad 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c14:	9b02      	ldr	r3, [sp, #8]
    5c16:	ea5b 0303 	orrs.w	r3, fp, r3
    5c1a:	f43f ada8 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
    5c1e:	493a      	ldr	r1, [pc, #232]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c20:	4835      	ldr	r0, [pc, #212]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c22:	4b3a      	ldr	r3, [pc, #232]	; (5d0c <grid_port_process_outbound_ui+0x694>)
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5c24:	4798      	blx	r3
    5c26:	e5a2      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c28:	2e60      	cmp	r6, #96	; 0x60
    5c2a:	d117      	bne.n	5c5c <grid_port_process_outbound_ui+0x5e4>
    5c2c:	2f0e      	cmp	r7, #14
    5c2e:	f47f ad9e 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c32:	9b02      	ldr	r3, [sp, #8]
    5c34:	ea5b 0303 	orrs.w	r3, fp, r3
    5c38:	f43f ad99 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_store_configuration(&grid_sys_state, &grid_nvm_state);
    5c3c:	4932      	ldr	r1, [pc, #200]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c3e:	482e      	ldr	r0, [pc, #184]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c40:	4b33      	ldr	r3, [pc, #204]	; (5d10 <grid_port_process_outbound_ui+0x698>)
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c42:	4e34      	ldr	r6, [pc, #208]	; (5d14 <grid_port_process_outbound_ui+0x69c>)
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c44:	4798      	blx	r3
                    grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    5c46:	2700      	movs	r7, #0
    5c48:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    5c4c:	e9cd 7300 	strd	r7, r3, [sp]
    5c50:	4829      	ldr	r0, [pc, #164]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5c52:	463b      	mov	r3, r7
    5c54:	22ff      	movs	r2, #255	; 0xff
    5c56:	4639      	mov	r1, r7
    5c58:	47b0      	blx	r6
    5c5a:	e588      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_GLOBALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c5c:	2e62      	cmp	r6, #98	; 0x62
    5c5e:	d10b      	bne.n	5c78 <grid_port_process_outbound_ui+0x600>
    5c60:	2f0e      	cmp	r7, #14
    5c62:	f47f ad84 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c66:	9b02      	ldr	r3, [sp, #8]
    5c68:	ea5b 0303 	orrs.w	r3, fp, r3
    5c6c:	f43f ad7f 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_sys_nvm_clear_configuration(&grid_ui_state, &grid_nvm_state);
    5c70:	4925      	ldr	r1, [pc, #148]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5c72:	4b29      	ldr	r3, [pc, #164]	; (5d18 <grid_port_process_outbound_ui+0x6a0>)
    5c74:	4650      	mov	r0, sl
    5c76:	e7e4      	b.n	5c42 <grid_port_process_outbound_ui+0x5ca>
				else if (msg_class == GRID_CLASS_GLOBALRECALL_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5c78:	2e63      	cmp	r6, #99	; 0x63
    5c7a:	d112      	bne.n	5ca2 <grid_port_process_outbound_ui+0x62a>
    5c7c:	2f0e      	cmp	r7, #14
    5c7e:	f47f ad76 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5c82:	9b02      	ldr	r3, [sp, #8]
    5c84:	ea5b 0303 	orrs.w	r3, fp, r3
    5c88:	f43f ad71 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_GLOBALRECALL_BANKNUMBER_offset], GRID_CLASS_GLOBALRECALL_BANKNUMBER_length	, &error_flag);
    5c8c:	f108 0005 	add.w	r0, r8, #5
    5c90:	2102      	movs	r1, #2
    5c92:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5c96:	4448      	add	r0, r9
    5c98:	47a8      	blx	r5
					grid_sys_recall_configuration(&grid_sys_state, banknumber);
    5c9a:	4b20      	ldr	r3, [pc, #128]	; (5d1c <grid_port_process_outbound_ui+0x6a4>)
    5c9c:	b2c1      	uxtb	r1, r0
    5c9e:	4816      	ldr	r0, [pc, #88]	; (5cf8 <grid_port_process_outbound_ui+0x680>)
    5ca0:	e590      	b.n	57c4 <grid_port_process_outbound_ui+0x14c>
				else if (msg_class == GRID_CLASS_LOCALLOAD_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5ca2:	2e71      	cmp	r6, #113	; 0x71
    5ca4:	d13e      	bne.n	5d24 <grid_port_process_outbound_ui+0x6ac>
    5ca6:	2f0e      	cmp	r7, #14
    5ca8:	f47f ad61 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5cac:	9b02      	ldr	r3, [sp, #8]
    5cae:	ea5b 0303 	orrs.w	r3, fp, r3
    5cb2:	f43f ad5c 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);						
    5cb6:	4914      	ldr	r1, [pc, #80]	; (5d08 <grid_port_process_outbound_ui+0x690>)
    5cb8:	4b19      	ldr	r3, [pc, #100]	; (5d20 <grid_port_process_outbound_ui+0x6a8>)
    5cba:	4650      	mov	r0, sl
    5cbc:	e7b2      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
    5cbe:	bf00      	nop
    5cc0:	2001c838 	.word	0x2001c838
    5cc4:	00007625 	.word	0x00007625
    5cc8:	00014d51 	.word	0x00014d51
    5ccc:	0000a1d1 	.word	0x0000a1d1
    5cd0:	00008ed5 	.word	0x00008ed5
    5cd4:	0001669c 	.word	0x0001669c
    5cd8:	00015231 	.word	0x00015231
    5cdc:	00015317 	.word	0x00015317
    5ce0:	00008eb9 	.word	0x00008eb9
    5ce4:	00008e45 	.word	0x00008e45
    5ce8:	00009001 	.word	0x00009001
    5cec:	000090d5 	.word	0x000090d5
    5cf0:	00008f09 	.word	0x00008f09
    5cf4:	000166c6 	.word	0x000166c6
    5cf8:	2000f008 	.word	0x2000f008
    5cfc:	000166d8 	.word	0x000166d8
    5d00:	e000ed00 	.word	0xe000ed00
    5d04:	05fa0004 	.word	0x05fa0004
    5d08:	2000fa1c 	.word	0x2000fa1c
    5d0c:	000099f5 	.word	0x000099f5
    5d10:	000096a1 	.word	0x000096a1
    5d14:	0000a123 	.word	0x0000a123
    5d18:	00009aed 	.word	0x00009aed
    5d1c:	00009899 	.word	0x00009899
    5d20:	0000a405 	.word	0x0000a405
				else if (msg_class == GRID_CLASS_LOCALSTORE_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d24:	2e70      	cmp	r6, #112	; 0x70
    5d26:	d10b      	bne.n	5d40 <grid_port_process_outbound_ui+0x6c8>
    5d28:	2f0e      	cmp	r7, #14
    5d2a:	f47f ad20 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5d2e:	9b02      	ldr	r3, [sp, #8]
    5d30:	ea5b 0303 	orrs.w	r3, fp, r3
    5d34:	f43f ad1b 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_store_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d38:	49b4      	ldr	r1, [pc, #720]	; (600c <grid_port_process_outbound_ui+0x994>)
    5d3a:	4bb5      	ldr	r3, [pc, #724]	; (6010 <grid_port_process_outbound_ui+0x998>)
    5d3c:	4650      	mov	r0, sl
    5d3e:	e771      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_LOCALCLEAR_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    5d40:	2e72      	cmp	r6, #114	; 0x72
    5d42:	d10b      	bne.n	5d5c <grid_port_process_outbound_ui+0x6e4>
    5d44:	2f0e      	cmp	r7, #14
    5d46:	f47f ad12 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5d4a:	9b02      	ldr	r3, [sp, #8]
    5d4c:	ea5b 0303 	orrs.w	r3, fp, r3
    5d50:	f43f ad0d 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					grid_ui_nvm_clear_all_configuration(&grid_ui_state, &grid_nvm_state);
    5d54:	49ad      	ldr	r1, [pc, #692]	; (600c <grid_port_process_outbound_ui+0x994>)
    5d56:	4baf      	ldr	r3, [pc, #700]	; (6014 <grid_port_process_outbound_ui+0x99c>)
    5d58:	4650      	mov	r0, sl
    5d5a:	e763      	b.n	5c24 <grid_port_process_outbound_ui+0x5ac>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_FETCH_code && (position_is_me || position_is_global)){
    5d5c:	2e80      	cmp	r6, #128	; 0x80
    5d5e:	f040 81b0 	bne.w	60c2 <grid_port_process_outbound_ui+0xa4a>
    5d62:	2f0f      	cmp	r7, #15
    5d64:	d122      	bne.n	5dac <grid_port_process_outbound_ui+0x734>
    5d66:	9b02      	ldr	r3, [sp, #8]
    5d68:	ea5b 0303 	orrs.w	r3, fp, r3
    5d6c:	f43f acff 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5d70:	f108 0005 	add.w	r0, r8, #5
    5d74:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d78:	2102      	movs	r1, #2
    5d7a:	4448      	add	r0, r9
    5d7c:	47a8      	blx	r5
    5d7e:	4606      	mov	r6, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5d80:	f108 0007 	add.w	r0, r8, #7
    5d84:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d88:	2102      	movs	r1, #2
    5d8a:	4448      	add	r0, r9
    5d8c:	47a8      	blx	r5
    5d8e:	4607      	mov	r7, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5d90:	f108 0009 	add.w	r0, r8, #9
    5d94:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5d98:	2102      	movs	r1, #2
    5d9a:	4448      	add	r0, r9
    5d9c:	47a8      	blx	r5
					grid_ui_recall_event_configuration(&grid_ui_state, banknumber, elementnumber, eventtype);
    5d9e:	b2f1      	uxtb	r1, r6
    5da0:	b2c3      	uxtb	r3, r0
    5da2:	4e9d      	ldr	r6, [pc, #628]	; (6018 <grid_port_process_outbound_ui+0x9a0>)
    5da4:	b2fa      	uxtb	r2, r7
    5da6:	4650      	mov	r0, sl
    5da8:	47b0      	blx	r6
    5daa:	e4e0      	b.n	576e <grid_port_process_outbound_ui+0xf6>
				else if (msg_class == GRID_CLASS_CONFIGURATION_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    5dac:	2f0e      	cmp	r7, #14
    5dae:	f47f acde 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    5db2:	f1bb 0f00 	cmp.w	fp, #0
    5db6:	f040 80e0 	bne.w	5f7a <grid_port_process_outbound_ui+0x902>
    5dba:	2c00      	cmp	r4, #0
    5dbc:	f000 8150 	beq.w	6060 <grid_port_process_outbound_ui+0x9e8>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    5dc0:	ab2f      	add	r3, sp, #188	; 0xbc
    5dc2:	f108 0005 	add.w	r0, r8, #5
    5dc6:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dca:	2102      	movs	r1, #2
    5dcc:	4418      	add	r0, r3
    5dce:	47a8      	blx	r5
    5dd0:	b2c3      	uxtb	r3, r0
    5dd2:	9305      	str	r3, [sp, #20]
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5dd4:	f108 0007 	add.w	r0, r8, #7
    5dd8:	ab2f      	add	r3, sp, #188	; 0xbc
    5dda:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5dde:	2102      	movs	r1, #2
    5de0:	4418      	add	r0, r3
    5de2:	47a8      	blx	r5
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5de4:	ab2f      	add	r3, sp, #188	; 0xbc
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    5de6:	9007      	str	r0, [sp, #28]
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5de8:	f108 0009 	add.w	r0, r8, #9
    5dec:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    5df0:	2102      	movs	r1, #2
    5df2:	4418      	add	r0, r3
    5df4:	47a8      	blx	r5
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5df6:	2700      	movs	r7, #0
    5df8:	4b88      	ldr	r3, [pc, #544]	; (601c <grid_port_process_outbound_ui+0x9a4>)
    5dfa:	970e      	str	r7, [sp, #56]	; 0x38
    5dfc:	227e      	movs	r2, #126	; 0x7e
    5dfe:	4639      	mov	r1, r7
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGURATION_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    5e00:	fa5f f980 	uxtb.w	r9, r0
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e04:	a80f      	add	r0, sp, #60	; 0x3c
    5e06:	4798      	blx	r3
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e08:	f89d 300c 	ldrb.w	r3, [sp, #12]
    5e0c:	f108 000b 	add.w	r0, r8, #11
    5e10:	eba3 0308 	sub.w	r3, r3, r8
    5e14:	aa2f      	add	r2, sp, #188	; 0xbc
					uint8_t actionstring[GRID_UI_ACTION_STRING_maxlength]	= {0};
    5e16:	ae0e      	add	r6, sp, #56	; 0x38
					uint32_t actionstring_length = current_stop-current_start-GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset;
    5e18:	3b0b      	subs	r3, #11
					for(uint32_t j = 0; j<actionstring_length; j++){
    5e1a:	eb02 0800 	add.w	r8, r2, r0
    5e1e:	4639      	mov	r1, r7
    5e20:	4299      	cmp	r1, r3
    5e22:	f0c0 80ed 	bcc.w	6000 <grid_port_process_outbound_ui+0x988>
					grid_ui_event_register_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype, actionstring, actionstring_length);
    5e26:	9905      	ldr	r1, [sp, #20]
    5e28:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e2c:	f89d 801c 	ldrb.w	r8, [sp, #28]
    5e30:	4f7b      	ldr	r7, [pc, #492]	; (6020 <grid_port_process_outbound_ui+0x9a8>)
    5e32:	0109      	lsls	r1, r1, #4
    5e34:	9104      	str	r1, [sp, #16]
    5e36:	9905      	ldr	r1, [sp, #20]
    5e38:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    5e3c:	2664      	movs	r6, #100	; 0x64
    5e3e:	68d0      	ldr	r0, [r2, #12]
    5e40:	fb06 f608 	mul.w	r6, r6, r8
    5e44:	aa0e      	add	r2, sp, #56	; 0x38
    5e46:	4649      	mov	r1, r9
    5e48:	4430      	add	r0, r6
    5e4a:	47b8      	blx	r7
					if (banknumber == grid_sys_state.bank_activebank_number){
    5e4c:	4b75      	ldr	r3, [pc, #468]	; (6024 <grid_port_process_outbound_ui+0x9ac>)
    5e4e:	9a05      	ldr	r2, [sp, #20]
    5e50:	7bdb      	ldrb	r3, [r3, #15]
    5e52:	4293      	cmp	r3, r2
    5e54:	d105      	bne.n	5e62 <grid_port_process_outbound_ui+0x7ea>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    5e56:	9905      	ldr	r1, [sp, #20]
    5e58:	4f73      	ldr	r7, [pc, #460]	; (6028 <grid_port_process_outbound_ui+0x9b0>)
    5e5a:	464b      	mov	r3, r9
    5e5c:	4642      	mov	r2, r8
    5e5e:	4650      	mov	r0, sl
    5e60:	47b8      	blx	r7
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    5e62:	f8da 3004 	ldr.w	r3, [sl, #4]
    5e66:	9a04      	ldr	r2, [sp, #16]
    5e68:	4413      	add	r3, r2
    5e6a:	4649      	mov	r1, r9
    5e6c:	68d8      	ldr	r0, [r3, #12]
    5e6e:	4b6f      	ldr	r3, [pc, #444]	; (602c <grid_port_process_outbound_ui+0x9b4>)
    5e70:	4430      	add	r0, r6
    5e72:	4798      	blx	r3
					if (event_index != 255){
    5e74:	28ff      	cmp	r0, #255	; 0xff
    5e76:	d03d      	beq.n	5ef4 <grid_port_process_outbound_ui+0x87c>
						if (position_is_local){
    5e78:	b304      	cbz	r4, 5ebc <grid_port_process_outbound_ui+0x844>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5e7a:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e7e:	9904      	ldr	r1, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5e80:	9f04      	ldr	r7, [sp, #16]
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_flashempty_flag=0;
    5e82:	440a      	add	r2, r1
    5e84:	23bc      	movs	r3, #188	; 0xbc
    5e86:	68d2      	ldr	r2, [r2, #12]
    5e88:	4432      	add	r2, r6
    5e8a:	fb10 f303 	smulbb	r3, r0, r3
    5e8e:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5e90:	441a      	add	r2, r3
    5e92:	2100      	movs	r1, #0
    5e94:	f882 10b8 	strb.w	r1, [r2, #184]	; 0xb8
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 0;
    5e98:	f8da 2004 	ldr.w	r2, [sl, #4]
    5e9c:	443a      	add	r2, r7
    5e9e:	68d2      	ldr	r2, [r2, #12]
    5ea0:	4432      	add	r2, r6
    5ea2:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5ea4:	441a      	add	r2, r3
    5ea6:	f882 10b6 	strb.w	r1, [r2, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5eaa:	f8da 2004 	ldr.w	r2, [sl, #4]
    5eae:	443a      	add	r2, r7
    5eb0:	68d2      	ldr	r2, [r2, #12]
    5eb2:	4432      	add	r2, r6
    5eb4:	6e12      	ldr	r2, [r2, #96]	; 0x60
    5eb6:	4413      	add	r3, r2
    5eb8:	f883 10b7 	strb.w	r1, [r3, #183]	; 0xb7
						if (position_is_me){
    5ebc:	f1bb 0f00 	cmp.w	fp, #0
    5ec0:	d018      	beq.n	5ef4 <grid_port_process_outbound_ui+0x87c>
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    5ec2:	22bc      	movs	r2, #188	; 0xbc
    5ec4:	fb10 f002 	smulbb	r0, r0, r2
    5ec8:	f8da 3004 	ldr.w	r3, [sl, #4]
    5ecc:	9a04      	ldr	r2, [sp, #16]
    5ece:	4413      	add	r3, r2
    5ed0:	2201      	movs	r2, #1
    5ed2:	68db      	ldr	r3, [r3, #12]
    5ed4:	4433      	add	r3, r6
    5ed6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    5ed8:	4403      	add	r3, r0
    5eda:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
							grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 0;
    5ede:	f8da 3004 	ldr.w	r3, [sl, #4]
    5ee2:	9a04      	ldr	r2, [sp, #16]
    5ee4:	441a      	add	r2, r3
    5ee6:	68d3      	ldr	r3, [r2, #12]
    5ee8:	441e      	add	r6, r3
    5eea:	6e33      	ldr	r3, [r6, #96]	; 0x60
    5eec:	4418      	add	r0, r3
    5eee:	2300      	movs	r3, #0
    5ef0:	f880 30b7 	strb.w	r3, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    5ef4:	4b4e      	ldr	r3, [pc, #312]	; (6030 <grid_port_process_outbound_ui+0x9b8>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5ef6:	4e4f      	ldr	r6, [pc, #316]	; (6034 <grid_port_process_outbound_ui+0x9bc>)
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5ef8:	4f4f      	ldr	r7, [pc, #316]	; (6038 <grid_port_process_outbound_ui+0x9c0>)
					grid_msg_init(&response);
    5efa:	a893      	add	r0, sp, #588	; 0x24c
    5efc:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5efe:	227f      	movs	r2, #127	; 0x7f
    5f00:	4611      	mov	r1, r2
    5f02:	2300      	movs	r3, #0
    5f04:	a893      	add	r0, sp, #588	; 0x24c
    5f06:	47b0      	blx	r6
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f08:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    5f0a:	2600      	movs	r6, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f0c:	494b      	ldr	r1, [pc, #300]	; (603c <grid_port_process_outbound_ui+0x9c4>)
    5f0e:	9300      	str	r3, [sp, #0]
    5f10:	2202      	movs	r2, #2
    5f12:	2380      	movs	r3, #128	; 0x80
    5f14:	a80a      	add	r0, sp, #40	; 0x28
					uint8_t response_payload[10] = {0};
    5f16:	e9cd 660a 	strd	r6, r6, [sp, #40]	; 0x28
    5f1a:	f8ad 6030 	strh.w	r6, [sp, #48]	; 0x30
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    5f1e:	47b8      	blx	r7
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f20:	4b47      	ldr	r3, [pc, #284]	; (6040 <grid_port_process_outbound_ui+0x9c8>)
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f22:	4f48      	ldr	r7, [pc, #288]	; (6044 <grid_port_process_outbound_ui+0x9cc>)
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5f24:	a80a      	add	r0, sp, #40	; 0x28
    5f26:	4798      	blx	r3
    5f28:	4b47      	ldr	r3, [pc, #284]	; (6048 <grid_port_process_outbound_ui+0x9d0>)
    5f2a:	4602      	mov	r2, r0
    5f2c:	a90a      	add	r1, sp, #40	; 0x28
    5f2e:	a893      	add	r0, sp, #588	; 0x24c
    5f30:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    5f32:	9b05      	ldr	r3, [sp, #20]
    5f34:	9300      	str	r3, [sp, #0]
    5f36:	2205      	movs	r2, #5
    5f38:	2302      	movs	r3, #2
    5f3a:	4631      	mov	r1, r6
    5f3c:	a893      	add	r0, sp, #588	; 0x24c
    5f3e:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    5f40:	2302      	movs	r3, #2
    5f42:	2207      	movs	r2, #7
    5f44:	4631      	mov	r1, r6
    5f46:	a893      	add	r0, sp, #588	; 0x24c
    5f48:	f8cd 8000 	str.w	r8, [sp]
    5f4c:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    5f4e:	2302      	movs	r3, #2
    5f50:	2209      	movs	r2, #9
    5f52:	4631      	mov	r1, r6
    5f54:	a893      	add	r0, sp, #588	; 0x24c
    5f56:	f8cd 9000 	str.w	r9, [sp]
    5f5a:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    5f5c:	230a      	movs	r3, #10
    5f5e:	9300      	str	r3, [sp, #0]
    5f60:	2204      	movs	r2, #4
    5f62:	2301      	movs	r3, #1
    5f64:	4631      	mov	r1, r6
    5f66:	a893      	add	r0, sp, #588	; 0x24c
    5f68:	47b8      	blx	r7
                        grid_msg_packet_close(&response);
    5f6a:	4b38      	ldr	r3, [pc, #224]	; (604c <grid_port_process_outbound_ui+0x9d4>)
    5f6c:	a893      	add	r0, sp, #588	; 0x24c
    5f6e:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5f70:	4b37      	ldr	r3, [pc, #220]	; (6050 <grid_port_process_outbound_ui+0x9d8>)
    5f72:	a893      	add	r0, sp, #588	; 0x24c
    5f74:	4798      	blx	r3
    5f76:	f7ff bbfa 	b.w	576e <grid_port_process_outbound_ui+0xf6>
                    if (!position_is_local){
    5f7a:	2c00      	cmp	r4, #0
    5f7c:	f47f af20 	bne.w	5dc0 <grid_port_process_outbound_ui+0x748>
                        grid_keyboard_state.isenabled = 0;             
    5f80:	4e34      	ldr	r6, [pc, #208]	; (6054 <grid_port_process_outbound_ui+0x9dc>)
                        grid_msg_init(&response);
    5f82:	4b2b      	ldr	r3, [pc, #172]	; (6030 <grid_port_process_outbound_ui+0x9b8>)
                        grid_keyboard_state.isenabled = 0;             
    5f84:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    5f88:	a893      	add	r0, sp, #588	; 0x24c
    5f8a:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    5f8c:	227f      	movs	r2, #127	; 0x7f
    5f8e:	4623      	mov	r3, r4
    5f90:	4611      	mov	r1, r2
    5f92:	a893      	add	r0, sp, #588	; 0x24c
    5f94:	4f27      	ldr	r7, [pc, #156]	; (6034 <grid_port_process_outbound_ui+0x9bc>)
    5f96:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5f98:	2303      	movs	r3, #3
    5f9a:	492f      	ldr	r1, [pc, #188]	; (6058 <grid_port_process_outbound_ui+0x9e0>)
    5f9c:	9300      	str	r3, [sp, #0]
    5f9e:	2202      	movs	r2, #2
    5fa0:	4f25      	ldr	r7, [pc, #148]	; (6038 <grid_port_process_outbound_ui+0x9c0>)
                        uint8_t response_payload[10] = {0};
    5fa2:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fa6:	2392      	movs	r3, #146	; 0x92
    5fa8:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    5faa:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    5fae:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    5fb0:	4b23      	ldr	r3, [pc, #140]	; (6040 <grid_port_process_outbound_ui+0x9c8>)
    5fb2:	a80e      	add	r0, sp, #56	; 0x38
    5fb4:	4798      	blx	r3
    5fb6:	a90e      	add	r1, sp, #56	; 0x38
    5fb8:	4602      	mov	r2, r0
    5fba:	4b23      	ldr	r3, [pc, #140]	; (6048 <grid_port_process_outbound_ui+0x9d0>)
    5fbc:	a893      	add	r0, sp, #588	; 0x24c
    5fbe:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    5fc0:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    5fc4:	9300      	str	r3, [sp, #0]
    5fc6:	4e1f      	ldr	r6, [pc, #124]	; (6044 <grid_port_process_outbound_ui+0x9cc>)
    5fc8:	4621      	mov	r1, r4
    5fca:	a893      	add	r0, sp, #588	; 0x24c
    5fcc:	2302      	movs	r3, #2
    5fce:	2205      	movs	r2, #5
    5fd0:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    5fd2:	230d      	movs	r3, #13
    5fd4:	4621      	mov	r1, r4
    5fd6:	2204      	movs	r2, #4
    5fd8:	9300      	str	r3, [sp, #0]
    5fda:	a893      	add	r0, sp, #588	; 0x24c
    5fdc:	2301      	movs	r3, #1
    5fde:	47b0      	blx	r6
                        grid_msg_packet_close(&response);
    5fe0:	4b1a      	ldr	r3, [pc, #104]	; (604c <grid_port_process_outbound_ui+0x9d4>)
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    5fe2:	4e1e      	ldr	r6, [pc, #120]	; (605c <grid_port_process_outbound_ui+0x9e4>)
                        grid_msg_packet_close(&response);
    5fe4:	a893      	add	r0, sp, #588	; 0x24c
    5fe6:	4798      	blx	r3
                        grid_msg_packet_send_everywhere(&response);
    5fe8:	4b19      	ldr	r3, [pc, #100]	; (6050 <grid_port_process_outbound_ui+0x9d8>)
    5fea:	a893      	add	r0, sp, #588	; 0x24c
    5fec:	4798      	blx	r3
                        grid_sys_alert_set_alert(&grid_sys_state, 100, 100, 100, 0, 250);
    5fee:	23fa      	movs	r3, #250	; 0xfa
    5ff0:	e9cd 4300 	strd	r4, r3, [sp]
    5ff4:	2364      	movs	r3, #100	; 0x64
    5ff6:	480b      	ldr	r0, [pc, #44]	; (6024 <grid_port_process_outbound_ui+0x9ac>)
    5ff8:	461a      	mov	r2, r3
    5ffa:	4619      	mov	r1, r3
    5ffc:	47b0      	blx	r6
    5ffe:	e6df      	b.n	5dc0 <grid_port_process_outbound_ui+0x748>
						actionstring[j] = message[current_start+GRID_CLASS_CONFIGURATION_ACTIONSTRING_offset + j];
    6000:	f818 2b01 	ldrb.w	r2, [r8], #1
    6004:	558a      	strb	r2, [r1, r6]
					for(uint32_t j = 0; j<actionstring_length; j++){
    6006:	3101      	adds	r1, #1
    6008:	e70a      	b.n	5e20 <grid_port_process_outbound_ui+0x7a8>
    600a:	bf00      	nop
    600c:	2000fa1c 	.word	0x2000fa1c
    6010:	0000a3f5 	.word	0x0000a3f5
    6014:	0000a415 	.word	0x0000a415
    6018:	0000a425 	.word	0x0000a425
    601c:	00014d51 	.word	0x00014d51
    6020:	0000a845 	.word	0x0000a845
    6024:	2000f008 	.word	0x2000f008
    6028:	0000aaa1 	.word	0x0000aaa1
    602c:	0000aa55 	.word	0x0000aa55
    6030:	00008ed5 	.word	0x00008ed5
    6034:	00008f09 	.word	0x00008f09
    6038:	00015299 	.word	0x00015299
    603c:	000166e4 	.word	0x000166e4
    6040:	00015317 	.word	0x00015317
    6044:	00008eb9 	.word	0x00008eb9
    6048:	00008e45 	.word	0x00008e45
    604c:	00009001 	.word	0x00009001
    6050:	000090d5 	.word	0x000090d5
    6054:	20010264 	.word	0x20010264
    6058:	000166d8 	.word	0x000166d8
    605c:	0000a123 	.word	0x0000a123
                        grid_keyboard_state.isenabled = 0;             
    6060:	4e8b      	ldr	r6, [pc, #556]	; (6290 <grid_port_process_outbound_ui+0xc18>)
                        grid_msg_init(&response);
    6062:	4b8c      	ldr	r3, [pc, #560]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
                        grid_keyboard_state.isenabled = 0;             
    6064:	f886 4045 	strb.w	r4, [r6, #69]	; 0x45
                        grid_msg_init(&response);
    6068:	a893      	add	r0, sp, #588	; 0x24c
    606a:	4798      	blx	r3
                        grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    606c:	227f      	movs	r2, #127	; 0x7f
    606e:	4611      	mov	r1, r2
    6070:	4f89      	ldr	r7, [pc, #548]	; (6298 <grid_port_process_outbound_ui+0xc20>)
    6072:	4623      	mov	r3, r4
    6074:	a893      	add	r0, sp, #588	; 0x24c
    6076:	47b8      	blx	r7
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6078:	2303      	movs	r3, #3
    607a:	4988      	ldr	r1, [pc, #544]	; (629c <grid_port_process_outbound_ui+0xc24>)
    607c:	9300      	str	r3, [sp, #0]
    607e:	2202      	movs	r2, #2
    6080:	2392      	movs	r3, #146	; 0x92
    6082:	4f87      	ldr	r7, [pc, #540]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
                        uint8_t response_payload[10] = {0};
    6084:	f8ad 4040 	strh.w	r4, [sp, #64]	; 0x40
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6088:	a80e      	add	r0, sp, #56	; 0x38
                        uint8_t response_payload[10] = {0};
    608a:	e9cd 440e 	strd	r4, r4, [sp, #56]	; 0x38
                        sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    608e:	47b8      	blx	r7
                        grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6090:	4b84      	ldr	r3, [pc, #528]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
    6092:	a80e      	add	r0, sp, #56	; 0x38
    6094:	4798      	blx	r3
    6096:	4b84      	ldr	r3, [pc, #528]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    6098:	4602      	mov	r2, r0
    609a:	a90e      	add	r1, sp, #56	; 0x38
    609c:	a893      	add	r0, sp, #588	; 0x24c
    609e:	4798      	blx	r3
                        grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    60a0:	f896 3045 	ldrb.w	r3, [r6, #69]	; 0x45
    60a4:	9300      	str	r3, [sp, #0]
    60a6:	2205      	movs	r2, #5
    60a8:	2302      	movs	r3, #2
    60aa:	4621      	mov	r1, r4
    60ac:	4e7f      	ldr	r6, [pc, #508]	; (62ac <grid_port_process_outbound_ui+0xc34>)
    60ae:	a893      	add	r0, sp, #588	; 0x24c
    60b0:	47b0      	blx	r6
                        grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    60b2:	230d      	movs	r3, #13
    60b4:	9300      	str	r3, [sp, #0]
    60b6:	2204      	movs	r2, #4
    60b8:	2301      	movs	r3, #1
    60ba:	4621      	mov	r1, r4
    60bc:	a893      	add	r0, sp, #588	; 0x24c
    60be:	47b0      	blx	r6
    60c0:	e753      	b.n	5f6a <grid_port_process_outbound_ui+0x8f2>
                else if (msg_class == GRID_CLASS_HIDKEYSTATUS_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_global)){
    60c2:	2e92      	cmp	r6, #146	; 0x92
    60c4:	d13e      	bne.n	6144 <grid_port_process_outbound_ui+0xacc>
    60c6:	2f0e      	cmp	r7, #14
    60c8:	f47f ab51 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    60cc:	9b02      	ldr	r3, [sp, #8]
    60ce:	ea5b 0303 	orrs.w	r3, fp, r3
    60d2:	f43f ab4c 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    60d6:	f108 0005 	add.w	r0, r8, #5
    60da:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    60de:	2102      	movs	r1, #2
    60e0:	4448      	add	r0, r9
    60e2:	47a8      	blx	r5
                    grid_keyboard_state.isenabled = isenabled;
    60e4:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 6290 <grid_port_process_outbound_ui+0xc18>
                    grid_msg_init(&response);
    60e8:	4b6a      	ldr	r3, [pc, #424]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
                    uint8_t isenabled =	grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset]		, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length	, &error_flag);
    60ea:	f888 0045 	strb.w	r0, [r8, #69]	; 0x45
                    grid_msg_init(&response);
    60ee:	a893      	add	r0, sp, #588	; 0x24c
    60f0:	4798      	blx	r3
                    grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    60f2:	227f      	movs	r2, #127	; 0x7f
    60f4:	4611      	mov	r1, r2
    60f6:	4f68      	ldr	r7, [pc, #416]	; (6298 <grid_port_process_outbound_ui+0xc20>)
    60f8:	2300      	movs	r3, #0
    60fa:	a893      	add	r0, sp, #588	; 0x24c
    60fc:	47b8      	blx	r7
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    60fe:	2303      	movs	r3, #3
    6100:	4966      	ldr	r1, [pc, #408]	; (629c <grid_port_process_outbound_ui+0xc24>)
    6102:	9300      	str	r3, [sp, #0]
                    uint8_t response_payload[10] = {0};
    6104:	2700      	movs	r7, #0
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6106:	4633      	mov	r3, r6
    6108:	2202      	movs	r2, #2
    610a:	4e65      	ldr	r6, [pc, #404]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
                    uint8_t response_payload[10] = {0};
    610c:	f8ad 7040 	strh.w	r7, [sp, #64]	; 0x40
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6110:	a80e      	add	r0, sp, #56	; 0x38
                    uint8_t response_payload[10] = {0};
    6112:	e9cd 770e 	strd	r7, r7, [sp, #56]	; 0x38
                    sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    6116:	47b0      	blx	r6
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6118:	4b62      	ldr	r3, [pc, #392]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    611a:	4e64      	ldr	r6, [pc, #400]	; (62ac <grid_port_process_outbound_ui+0xc34>)
                    grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    611c:	a80e      	add	r0, sp, #56	; 0x38
    611e:	4798      	blx	r3
    6120:	4b61      	ldr	r3, [pc, #388]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    6122:	4602      	mov	r2, r0
    6124:	a90e      	add	r1, sp, #56	; 0x38
    6126:	a893      	add	r0, sp, #588	; 0x24c
    6128:	4798      	blx	r3
                    grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, grid_keyboard_state.isenabled);
    612a:	f898 3045 	ldrb.w	r3, [r8, #69]	; 0x45
    612e:	9300      	str	r3, [sp, #0]
    6130:	2205      	movs	r2, #5
    6132:	2302      	movs	r3, #2
    6134:	4639      	mov	r1, r7
    6136:	a893      	add	r0, sp, #588	; 0x24c
    6138:	47b0      	blx	r6
                    grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    613a:	230a      	movs	r3, #10
    613c:	9300      	str	r3, [sp, #0]
    613e:	2204      	movs	r2, #4
    6140:	2301      	movs	r3, #1
    6142:	e54a      	b.n	5bda <grid_port_process_outbound_ui+0x562>
				else if (msg_class == GRID_CLASS_CONFIGDEFAULT_code && msg_instr == GRID_INSTR_EXECUTE_code && (position_is_me || position_is_local)){
    6144:	2e81      	cmp	r6, #129	; 0x81
    6146:	f47f ab12 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    614a:	2f0e      	cmp	r7, #14
    614c:	f47f ab0f 	bne.w	576e <grid_port_process_outbound_ui+0xf6>
    6150:	ea5b 0304 	orrs.w	r3, fp, r4
    6154:	f43f ab0b 	beq.w	576e <grid_port_process_outbound_ui+0xf6>
					uint8_t banknumber		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_BANKNUMBER_offset]		, GRID_CLASS_CONFIGURATION_BANKNUMBER_length	, &error_flag);
    6158:	f108 0005 	add.w	r0, r8, #5
    615c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6160:	2102      	movs	r1, #2
    6162:	4448      	add	r0, r9
    6164:	47a8      	blx	r5
    6166:	b2c7      	uxtb	r7, r0
					uint8_t elementnumber	= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_ELEMENTNUMBER_offset]	, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length	, &error_flag);
    6168:	f108 0007 	add.w	r0, r8, #7
    616c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6170:	2102      	movs	r1, #2
    6172:	4448      	add	r0, r9
    6174:	47a8      	blx	r5
    6176:	4606      	mov	r6, r0
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    6178:	f108 0009 	add.w	r0, r8, #9
    617c:	f10d 0227 	add.w	r2, sp, #39	; 0x27
    6180:	2102      	movs	r1, #2
    6182:	4448      	add	r0, r9
    6184:	47a8      	blx	r5
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6186:	f8da 3004 	ldr.w	r3, [sl, #4]
    618a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
    618e:	b2f2      	uxtb	r2, r6
					uint8_t eventtype		= grid_sys_read_hex_string_value(&message[current_start+GRID_CLASS_CONFIGDEFAULT_EVENTTYPE_offset]		, GRID_CLASS_CONFIGURATION_EVENTTYPE_length		, &error_flag);
    6190:	fa5f f880 	uxtb.w	r8, r0
					grid_ui_event_generate_actionstring(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    6194:	f04f 0964 	mov.w	r9, #100	; 0x64
    6198:	68d8      	ldr	r0, [r3, #12]
    619a:	4b45      	ldr	r3, [pc, #276]	; (62b0 <grid_port_process_outbound_ui+0xc38>)
    619c:	9204      	str	r2, [sp, #16]
    619e:	fb09 f902 	mul.w	r9, r9, r2
    61a2:	4641      	mov	r1, r8
    61a4:	4448      	add	r0, r9
    61a6:	4798      	blx	r3
					if (banknumber == grid_sys_state.bank_activebank_number){
    61a8:	4b42      	ldr	r3, [pc, #264]	; (62b4 <grid_port_process_outbound_ui+0xc3c>)
    61aa:	7bdb      	ldrb	r3, [r3, #15]
    61ac:	42bb      	cmp	r3, r7
    61ae:	d105      	bne.n	61bc <grid_port_process_outbound_ui+0xb44>
						grid_ui_smart_trigger(&grid_ui_state, banknumber, elementnumber, eventtype);
    61b0:	9a04      	ldr	r2, [sp, #16]
    61b2:	4e41      	ldr	r6, [pc, #260]	; (62b8 <grid_port_process_outbound_ui+0xc40>)
    61b4:	4643      	mov	r3, r8
    61b6:	4639      	mov	r1, r7
    61b8:	4650      	mov	r0, sl
    61ba:	47b0      	blx	r6
					uint8_t event_index = grid_ui_event_find(&grid_ui_state.bank_list[banknumber].element_list[elementnumber], eventtype);
    61bc:	f8da 3004 	ldr.w	r3, [sl, #4]
    61c0:	013a      	lsls	r2, r7, #4
    61c2:	4413      	add	r3, r2
    61c4:	4641      	mov	r1, r8
    61c6:	68d8      	ldr	r0, [r3, #12]
    61c8:	4b3c      	ldr	r3, [pc, #240]	; (62bc <grid_port_process_outbound_ui+0xc44>)
    61ca:	4448      	add	r0, r9
    61cc:	4798      	blx	r3
					if (event_index != 255){
    61ce:	28ff      	cmp	r0, #255	; 0xff
    61d0:	d018      	beq.n	6204 <grid_port_process_outbound_ui+0xb8c>
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    61d2:	f8da 3004 	ldr.w	r3, [sl, #4]
    61d6:	22bc      	movs	r2, #188	; 0xbc
    61d8:	fb10 f002 	smulbb	r0, r0, r2
    61dc:	013a      	lsls	r2, r7, #4
    61de:	4413      	add	r3, r2
    61e0:	2201      	movs	r2, #1
    61e2:	68db      	ldr	r3, [r3, #12]
    61e4:	444b      	add	r3, r9
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    61e6:	0139      	lsls	r1, r7, #4
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_changed_flag = 1;
    61e8:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    61ea:	4403      	add	r3, r0
    61ec:	f883 20b6 	strb.w	r2, [r3, #182]	; 0xb6
						grid_ui_state.bank_list[banknumber].element_list[elementnumber].event_list[event_index].cfg_default_flag = 1;
    61f0:	f8da 3004 	ldr.w	r3, [sl, #4]
    61f4:	440b      	add	r3, r1
    61f6:	68db      	ldr	r3, [r3, #12]
    61f8:	4499      	add	r9, r3
    61fa:	f8d9 3060 	ldr.w	r3, [r9, #96]	; 0x60
    61fe:	4418      	add	r0, r3
    6200:	f880 20b7 	strb.w	r2, [r0, #183]	; 0xb7
					grid_msg_init(&response);
    6204:	4b23      	ldr	r3, [pc, #140]	; (6294 <grid_port_process_outbound_ui+0xc1c>)
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6206:	f8df 9090 	ldr.w	r9, [pc, #144]	; 6298 <grid_port_process_outbound_ui+0xc20>
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    620a:	4e25      	ldr	r6, [pc, #148]	; (62a0 <grid_port_process_outbound_ui+0xc28>)
					grid_msg_init(&response);
    620c:	a893      	add	r0, sp, #588	; 0x24c
    620e:	4798      	blx	r3
					grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    6210:	227f      	movs	r2, #127	; 0x7f
    6212:	4611      	mov	r1, r2
    6214:	2300      	movs	r3, #0
    6216:	a893      	add	r0, sp, #588	; 0x24c
    6218:	47c8      	blx	r9
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    621a:	2303      	movs	r3, #3
					uint8_t response_payload[10] = {0};
    621c:	f04f 0900 	mov.w	r9, #0
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6220:	4927      	ldr	r1, [pc, #156]	; (62c0 <grid_port_process_outbound_ui+0xc48>)
    6222:	9300      	str	r3, [sp, #0]
    6224:	2202      	movs	r2, #2
    6226:	2380      	movs	r3, #128	; 0x80
    6228:	a80e      	add	r0, sp, #56	; 0x38
					uint8_t response_payload[10] = {0};
    622a:	e9cd 990e 	strd	r9, r9, [sp, #56]	; 0x38
    622e:	f8ad 9040 	strh.w	r9, [sp, #64]	; 0x40
					sprintf(response_payload, GRID_CLASS_CONFIGURATION_frame);
    6232:	47b0      	blx	r6
					grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    6234:	4b1b      	ldr	r3, [pc, #108]	; (62a4 <grid_port_process_outbound_ui+0xc2c>)
    6236:	a80e      	add	r0, sp, #56	; 0x38
    6238:	4798      	blx	r3
    623a:	4b1b      	ldr	r3, [pc, #108]	; (62a8 <grid_port_process_outbound_ui+0xc30>)
    623c:	4602      	mov	r2, r0
    623e:	a90e      	add	r1, sp, #56	; 0x38
    6240:	a893      	add	r0, sp, #588	; 0x24c
    6242:	4798      	blx	r3
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, banknumber);
    6244:	9700      	str	r7, [sp, #0]
    6246:	2302      	movs	r3, #2
    6248:	4f18      	ldr	r7, [pc, #96]	; (62ac <grid_port_process_outbound_ui+0xc34>)
    624a:	2205      	movs	r2, #5
    624c:	4649      	mov	r1, r9
    624e:	a893      	add	r0, sp, #588	; 0x24c
    6250:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, elementnumber);
    6252:	9b04      	ldr	r3, [sp, #16]
    6254:	9300      	str	r3, [sp, #0]
    6256:	2207      	movs	r2, #7
    6258:	2302      	movs	r3, #2
    625a:	4649      	mov	r1, r9
    625c:	a893      	add	r0, sp, #588	; 0x24c
    625e:	47b8      	blx	r7
					grid_msg_text_set_parameter(&response, 0, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eventtype);
    6260:	f8cd 8000 	str.w	r8, [sp]
    6264:	2302      	movs	r3, #2
    6266:	2209      	movs	r2, #9
    6268:	4649      	mov	r1, r9
    626a:	a893      	add	r0, sp, #588	; 0x24c
    626c:	47b8      	blx	r7
						grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    626e:	230a      	movs	r3, #10
    6270:	2204      	movs	r2, #4
    6272:	4649      	mov	r1, r9
    6274:	9300      	str	r3, [sp, #0]
    6276:	a893      	add	r0, sp, #588	; 0x24c
    6278:	2301      	movs	r3, #1
    627a:	47b8      	blx	r7
					grid_msg_packet_close(&response);
    627c:	4b11      	ldr	r3, [pc, #68]	; (62c4 <grid_port_process_outbound_ui+0xc4c>)
    627e:	a893      	add	r0, sp, #588	; 0x24c
    6280:	4798      	blx	r3
					grid_msg_packet_send_everywhere(&response);
    6282:	4b11      	ldr	r3, [pc, #68]	; (62c8 <grid_port_process_outbound_ui+0xc50>)
    6284:	a893      	add	r0, sp, #588	; 0x24c
    6286:	4798      	blx	r3
				current_start = 0;
    6288:	46c8      	mov	r8, r9
    628a:	f7ff ba4c 	b.w	5726 <grid_port_process_outbound_ui+0xae>
    628e:	bf00      	nop
    6290:	20010264 	.word	0x20010264
    6294:	00008ed5 	.word	0x00008ed5
    6298:	00008f09 	.word	0x00008f09
    629c:	000166d8 	.word	0x000166d8
    62a0:	00015299 	.word	0x00015299
    62a4:	00015317 	.word	0x00015317
    62a8:	00008e45 	.word	0x00008e45
    62ac:	00008eb9 	.word	0x00008eb9
    62b0:	0000a8b1 	.word	0x0000a8b1
    62b4:	2000f008 	.word	0x2000f008
    62b8:	0000aaa1 	.word	0x0000aaa1
    62bc:	0000aa55 	.word	0x0000aa55
    62c0:	000166e4 	.word	0x000166e4
    62c4:	00009001 	.word	0x00009001
    62c8:	000090d5 	.word	0x000090d5

000062cc <grid_port_process_outbound_usart>:

uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    62cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    62d0:	8987      	ldrh	r7, [r0, #12]
uint8_t grid_port_process_outbound_usart(struct grid_port* por){
    62d2:	4605      	mov	r5, r0
	if (por->tx_double_buffer_status == 0){ // READY TO SEND MESSAGE, NO TRANSMISSION IS IN PROGRESS
    62d4:	bb1f      	cbnz	r7, 631e <grid_port_process_outbound_usart+0x52>
		
		uint16_t packet_size = grid_buffer_read_size(&por->tx_buffer);
    62d6:	f500 561c 	add.w	r6, r0, #9984	; 0x2700
    62da:	363c      	adds	r6, #60	; 0x3c
    62dc:	4b11      	ldr	r3, [pc, #68]	; (6324 <grid_port_process_outbound_usart+0x58>)
    62de:	4630      	mov	r0, r6
    62e0:	4798      	blx	r3
		
		if (!packet_size){
    62e2:	4604      	mov	r4, r0
    62e4:	b1a0      	cbz	r0, 6310 <grid_port_process_outbound_usart+0x44>
			// NO PACKET IN RX BUFFER
			return 0;
		}else{
			
			// Let's transfer the packet to local memory
			grid_buffer_read_init(&por->tx_buffer);
    62e6:	4b10      	ldr	r3, [pc, #64]	; (6328 <grid_port_process_outbound_usart+0x5c>)
			
			por->tx_double_buffer_status = packet_size;
			
			for (uint16_t i = 0; i<packet_size; i++){
				
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    62e8:	f8df a048 	ldr.w	sl, [pc, #72]	; 6334 <grid_port_process_outbound_usart+0x68>
			grid_buffer_read_init(&por->tx_buffer);
    62ec:	4630      	mov	r0, r6
    62ee:	f105 082c 	add.w	r8, r5, #44	; 0x2c
    62f2:	4798      	blx	r3
			por->tx_double_buffer_status = packet_size;
    62f4:	46c1      	mov	r9, r8
    62f6:	81ac      	strh	r4, [r5, #12]
			for (uint16_t i = 0; i<packet_size; i++){
    62f8:	b2bb      	uxth	r3, r7
    62fa:	429c      	cmp	r4, r3
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    62fc:	4630      	mov	r0, r6
			for (uint16_t i = 0; i<packet_size; i++){
    62fe:	d809      	bhi.n	6314 <grid_port_process_outbound_usart+0x48>
				por->tx_double_buffer[i] = character;
				
			}
		
			// Let's acknowledge the transaction
			grid_buffer_read_acknowledge(&por->tx_buffer);
    6300:	4b0a      	ldr	r3, [pc, #40]	; (632c <grid_port_process_outbound_usart+0x60>)
    6302:	4798      	blx	r3
			
			// Let's send the packet through USART
			io_write(&por->usart->io, por->tx_double_buffer, por->tx_double_buffer_status);		
    6304:	89aa      	ldrh	r2, [r5, #12]
    6306:	6868      	ldr	r0, [r5, #4]
    6308:	4b09      	ldr	r3, [pc, #36]	; (6330 <grid_port_process_outbound_usart+0x64>)
    630a:	4649      	mov	r1, r9
    630c:	4798      	blx	r3
			
			return 1;
    630e:	2001      	movs	r0, #1
		}
		
	}
	
	return 0;
}
    6310:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				uint8_t character = grid_buffer_read_character(&por->tx_buffer);
    6314:	47d0      	blx	sl
				por->tx_double_buffer[i] = character;
    6316:	3701      	adds	r7, #1
    6318:	f808 0b01 	strb.w	r0, [r8], #1
			for (uint16_t i = 0; i<packet_size; i++){
    631c:	e7ec      	b.n	62f8 <grid_port_process_outbound_usart+0x2c>
	return 0;
    631e:	2000      	movs	r0, #0
    6320:	e7f6      	b.n	6310 <grid_port_process_outbound_usart+0x44>
    6322:	bf00      	nop
    6324:	00004ebd 	.word	0x00004ebd
    6328:	00004f13 	.word	0x00004f13
    632c:	00004fa5 	.word	0x00004fa5
    6330:	0000b9fd 	.word	0x0000b9fd
    6334:	00004f7b 	.word	0x00004f7b

00006338 <gpio_get_pin_level>:
 * Reads the level on pins connected to a port
 *
 * \param[in] pin       The pin number for device
 */
static inline bool gpio_get_pin_level(const uint8_t pin)
{
    6338:	b537      	push	{r0, r1, r2, r4, r5, lr}
 */
static inline uint32_t _gpio_get_level(const enum gpio_port port)
{
	uint32_t tmp;

	CRITICAL_SECTION_ENTER();
    633a:	4b0e      	ldr	r3, [pc, #56]	; (6374 <gpio_get_pin_level+0x3c>)
    633c:	4605      	mov	r5, r0
    633e:	a801      	add	r0, sp, #4
    6340:	4798      	blx	r3
	return tmp;
}

static inline hri_port_dir_reg_t hri_port_read_DIR_reg(const void *const hw, uint8_t submodule_index)
{
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    6342:	4a0d      	ldr	r2, [pc, #52]	; (6378 <gpio_get_pin_level+0x40>)
    6344:	096b      	lsrs	r3, r5, #5
    6346:	01d9      	lsls	r1, r3, #7
    6348:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    634c:	5851      	ldr	r1, [r2, r1]
	return tmp;
}

static inline hri_port_in_reg_t hri_port_read_IN_reg(const void *const hw, uint8_t submodule_index)
{
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    634e:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    6350:	691c      	ldr	r4, [r3, #16]
	uint32_t dir_tmp = hri_port_read_DIR_reg(PORT, port);

	tmp = hri_port_read_IN_reg(PORT, port) & ~dir_tmp;
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;

	CRITICAL_SECTION_LEAVE();
    6352:	4b0a      	ldr	r3, [pc, #40]	; (637c <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    6354:	4054      	eors	r4, r2
    6356:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    6358:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    635a:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    635c:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    6360:	4798      	blx	r3
    6362:	2001      	movs	r0, #1
    6364:	fa00 f505 	lsl.w	r5, r0, r5
    6368:	4225      	tst	r5, r4
}
    636a:	bf08      	it	eq
    636c:	2000      	moveq	r0, #0
    636e:	b003      	add	sp, #12
    6370:	bd30      	pop	{r4, r5, pc}
    6372:	bf00      	nop
    6374:	00012485 	.word	0x00012485
    6378:	41008000 	.word	0x41008000
    637c:	00012493 	.word	0x00012493

00006380 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6380:	f000 031f 	and.w	r3, r0, #31
{
    6384:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    6386:	2501      	movs	r5, #1
    6388:	409d      	lsls	r5, r3
	switch (direction) {
    638a:	0940      	lsrs	r0, r0, #5
    638c:	4b0f      	ldr	r3, [pc, #60]	; (63cc <gpio_set_pin_direction+0x4c>)
    638e:	01c0      	lsls	r0, r0, #7
    6390:	2901      	cmp	r1, #1
    6392:	b2ac      	uxth	r4, r5
    6394:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6398:	4403      	add	r3, r0
    639a:	d008      	beq.n	63ae <gpio_set_pin_direction+0x2e>
    639c:	2902      	cmp	r1, #2
    639e:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    63a2:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    63a6:	d00e      	beq.n	63c6 <gpio_set_pin_direction+0x46>
    63a8:	605d      	str	r5, [r3, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    63aa:	629c      	str	r4, [r3, #40]	; 0x28
    63ac:	e009      	b.n	63c2 <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
    63ae:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
    63b2:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
    63b6:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    63ba:	605d      	str	r5, [r3, #4]
    63bc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    63c0:	629c      	str	r4, [r3, #40]	; 0x28
    63c2:	629a      	str	r2, [r3, #40]	; 0x28
}
    63c4:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    63c6:	609d      	str	r5, [r3, #8]
    63c8:	e7ef      	b.n	63aa <gpio_set_pin_direction+0x2a>
    63ca:	bf00      	nop
    63cc:	41008000 	.word	0x41008000

000063d0 <gpio_set_pin_pull_mode>:
 * \brief Set pin pull mode
 */
static inline void _gpio_set_pin_pull_mode(const enum gpio_port port, const uint8_t pin,
                                           const enum gpio_pull_mode pull_mode)
{
	switch (pull_mode) {
    63d0:	f000 021f 	and.w	r2, r0, #31
    63d4:	2901      	cmp	r1, #1
    63d6:	ea4f 1050 	mov.w	r0, r0, lsr #5
    63da:	4b14      	ldr	r3, [pc, #80]	; (642c <gpio_set_pin_pull_mode+0x5c>)
    63dc:	ea4f 10c0 	mov.w	r0, r0, lsl #7
    63e0:	d00a      	beq.n	63f8 <gpio_set_pin_pull_mode+0x28>
    63e2:	2902      	cmp	r1, #2
    63e4:	d014      	beq.n	6410 <gpio_set_pin_pull_mode+0x40>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
    63e6:	4403      	add	r3, r0
    63e8:	4413      	add	r3, r2
    63ea:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
    63ee:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    63f2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
}
    63f6:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    63f8:	4403      	add	r3, r0
	case GPIO_PULL_OFF:
		hri_port_clear_PINCFG_PULLEN_bit(PORT, port, pin);
		break;

	case GPIO_PULL_UP:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    63fa:	4091      	lsls	r1, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    63fc:	441a      	add	r2, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    63fe:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    6400:	f892 0040 	ldrb.w	r0, [r2, #64]	; 0x40
    6404:	f040 0004 	orr.w	r0, r0, #4
    6408:	f882 0040 	strb.w	r0, [r2, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    640c:	6199      	str	r1, [r3, #24]
}
    640e:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6410:	4403      	add	r3, r0
		hri_port_set_PINCFG_PULLEN_bit(PORT, port, pin);
		hri_port_set_OUT_reg(PORT, port, 1U << pin);
		break;

	case GPIO_PULL_DOWN:
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    6412:	2101      	movs	r1, #1
    6414:	4091      	lsls	r1, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    6416:	441a      	add	r2, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    6418:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    641a:	f892 0040 	ldrb.w	r0, [r2, #64]	; 0x40
    641e:	f040 0004 	orr.w	r0, r0, #4
    6422:	f882 0040 	strb.w	r0, [r2, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    6426:	6159      	str	r1, [r3, #20]
}
    6428:	4770      	bx	lr
    642a:	bf00      	nop
    642c:	41008000 	.word	0x41008000

00006430 <grid_d51_init>:
	
}



void grid_d51_init(){
    6430:	b510      	push	{r4, lr}
	
	uint32_t hwid = grid_sys_get_hwcfg();
    6432:	4b09      	ldr	r3, [pc, #36]	; (6458 <grid_d51_init+0x28>)
	
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    6434:	4c09      	ldr	r4, [pc, #36]	; (645c <grid_d51_init+0x2c>)
	uint32_t hwid = grid_sys_get_hwcfg();
    6436:	4798      	blx	r3
    6438:	4601      	mov	r1, r0
	printf("{\"type\":\"HWCFG\", \"data\": \"%d\"}\r\n", hwid);
    643a:	4809      	ldr	r0, [pc, #36]	; (6460 <grid_d51_init+0x30>)
    643c:	47a0      	blx	r4
	
	#ifdef NDEBUG		
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "USER ROW CHECK!");
	grid_d51_verify_user_row();
	#else
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "NO USER ROW CHECK!");
    643e:	4909      	ldr	r1, [pc, #36]	; (6464 <grid_d51_init+0x34>)
    6440:	4809      	ldr	r0, [pc, #36]	; (6468 <grid_d51_init+0x38>)
    6442:	47a0      	blx	r4
	{
	}
	
	#else
	
	GRID_DEBUG_WARNING(GRID_DEBUG_CONTEXT_BOOT, "No Unit Test");
    6444:	4909      	ldr	r1, [pc, #36]	; (646c <grid_d51_init+0x3c>)
    6446:	4808      	ldr	r0, [pc, #32]	; (6468 <grid_d51_init+0x38>)
    6448:	47a0      	blx	r4

	#ifdef HARDWARETEST
	
	#include "grid/grid_hardwaretest.h"

	grid_nvm_init(&grid_nvm_state, &FLASH_0);
    644a:	4b09      	ldr	r3, [pc, #36]	; (6470 <grid_d51_init+0x40>)
    644c:	4909      	ldr	r1, [pc, #36]	; (6474 <grid_d51_init+0x44>)
    644e:	480a      	ldr	r0, [pc, #40]	; (6478 <grid_d51_init+0x48>)
    6450:	4798      	blx	r3

    
	grid_hardwaretest_main();
    6452:	4b0a      	ldr	r3, [pc, #40]	; (647c <grid_d51_init+0x4c>)
    6454:	4798      	blx	r3
	
	
	while (1)
    6456:	e7fe      	b.n	6456 <grid_d51_init+0x26>
    6458:	0000a1fd 	.word	0x0000a1fd
    645c:	00014eb1 	.word	0x00014eb1
    6460:	000166f4 	.word	0x000166f4
    6464:	00016715 	.word	0x00016715
    6468:	000165af 	.word	0x000165af
    646c:	00016728 	.word	0x00016728
    6470:	00009609 	.word	0x00009609
    6474:	2001ccf8 	.word	0x2001ccf8
    6478:	2000fa1c 	.word	0x2000fa1c
    647c:	00007375 	.word	0x00007375

00006480 <grid_d51_boundary_scan>:
	
}



uint8_t grid_d51_boundary_scan(uint32_t* result_bitmap){
    6480:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}


	result_bitmap[0] = 0;
    6484:	2100      	movs	r1, #0
uint8_t grid_d51_boundary_scan(uint32_t* result_bitmap){
    6486:	b0a5      	sub	sp, #148	; 0x94
	result_bitmap[1] = 0;
    6488:	e9c0 1100 	strd	r1, r1, [r0]
	result_bitmap[2] = 0;
	result_bitmap[3] = 0;
    648c:	e9c0 1102 	strd	r1, r1, [r0, #8]



	// set bit high if there was an error
	uint32_t error_bitmap[4] = {0};
    6490:	4ba3      	ldr	r3, [pc, #652]	; (6720 <grid_d51_boundary_scan+0x2a0>)
	pins [31] = PIN_GND;				//GND
	pins [32] = GPIO(GPIO_PORTB, 10);
	pins [33] = GPIO(GPIO_PORTB, 11);
	pins [34] = GPIO(GPIO_PORTB, 12);
	pins [35] = GPIO(GPIO_PORTB, 13);
	pins [36] = GPIO(GPIO_PORTB, 14);
    6492:	4ca4      	ldr	r4, [pc, #656]	; (6724 <grid_d51_boundary_scan+0x2a4>)
	pins [39] = PIN_VDD;				//VDDIO
	pins [40] = GPIO(GPIO_PORTC, 10);
	pins [41] = GPIO(GPIO_PORTC, 11);
	pins [42] = GPIO(GPIO_PORTC, 12);
	pins [43] = GPIO(GPIO_PORTC, 13);
	pins [44] = GPIO(GPIO_PORTC, 14);
    6494:	4da4      	ldr	r5, [pc, #656]	; (6728 <grid_d51_boundary_scan+0x2a8>)
	pins [59] = GPIO(GPIO_PORTC, 19);
	pins [60] = GPIO(GPIO_PORTC, 20);
	pins [61] = GPIO(GPIO_PORTC, 21);
	pins [62] = PIN_GND;				//GND
	pins [63] = PIN_VDD;				//VDDIO
	pins [64] = GPIO(GPIO_PORTB, 16);
    6496:	4fa5      	ldr	r7, [pc, #660]	; (672c <grid_d51_boundary_scan+0x2ac>)
	uint32_t error_bitmap[4] = {0};
    6498:	2210      	movs	r2, #16
uint8_t grid_d51_boundary_scan(uint32_t* result_bitmap){
    649a:	4606      	mov	r6, r0
	uint32_t error_bitmap[4] = {0};
    649c:	a807      	add	r0, sp, #28
    649e:	4798      	blx	r3
	pins [4]  = GPIO(GPIO_PORTC, 1);
    64a0:	4ba3      	ldr	r3, [pc, #652]	; (6730 <grid_d51_boundary_scan+0x2b0>)
    64a2:	4aa4      	ldr	r2, [pc, #656]	; (6734 <grid_d51_boundary_scan+0x2b4>)
	pins [20] = GPIO(GPIO_PORTA, 7);
    64a4:	49a4      	ldr	r1, [pc, #656]	; (6738 <grid_d51_boundary_scan+0x2b8>)
	pins [28] = GPIO(GPIO_PORTA, 10);
    64a6:	48a5      	ldr	r0, [pc, #660]	; (673c <grid_d51_boundary_scan+0x2bc>)

	pins [76] = PIN_GND;				//GND
	pins [77] = PIN_VDD;				//VDDIO
	pins [78] = GPIO(GPIO_PORTB, 22);
	pins [79] = GPIO(GPIO_PORTB, 23);
	pins [80] = GPIO(GPIO_PORTB, 24);
    64a8:	f8df c2c4 	ldr.w	ip, [pc, #708]	; 6770 <grid_d51_boundary_scan+0x2f0>
	pins [87] = GPIO(GPIO_PORTA, 27);
	pins [88] = PIN_RST;				//RESETN
	pins [89] = PIN_CORE;				//VDDCORE
	pins [90] = PIN_GND;				//GND
	pins [91] = PIN_VSW;				//VSW
	pins [92] = PIN_VDD;				//VDDIO
    64ac:	f8df e2c4 	ldr.w	lr, [pc, #708]	; 6774 <grid_d51_boundary_scan+0x2f4>
	pins [4]  = GPIO(GPIO_PORTC, 1);
    64b0:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
	pins [8]  = GPIO(GPIO_PORTA, 3);
    64b4:	4ba2      	ldr	r3, [pc, #648]	; (6740 <grid_d51_boundary_scan+0x2c0>)
    64b6:	930d      	str	r3, [sp, #52]	; 0x34
	pins [12] = PIN_VDD;				//VDDANA
    64b8:	f103 5328 	add.w	r3, r3, #704643072	; 0x2a000000
    64bc:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    64c0:	f203 23fa 	addw	r3, r3, #762	; 0x2fa
    64c4:	930e      	str	r3, [sp, #56]	; 0x38
	pins [20] = GPIO(GPIO_PORTA, 7);
    64c6:	4b9f      	ldr	r3, [pc, #636]	; (6744 <grid_d51_boundary_scan+0x2c4>)
    64c8:	e9cd 130f 	strd	r1, r3, [sp, #60]	; 0x3c
	pins [28] = GPIO(GPIO_PORTA, 10);
    64cc:	4b9e      	ldr	r3, [pc, #632]	; (6748 <grid_d51_boundary_scan+0x2c8>)
    64ce:	e9cd 0311 	strd	r0, r3, [sp, #68]	; 0x44
	pins [36] = GPIO(GPIO_PORTB, 14);
    64d2:	4b9e      	ldr	r3, [pc, #632]	; (674c <grid_d51_boundary_scan+0x2cc>)
    64d4:	e9cd 4313 	strd	r4, r3, [sp, #76]	; 0x4c
	pins [44] = GPIO(GPIO_PORTC, 14);
    64d8:	4b9d      	ldr	r3, [pc, #628]	; (6750 <grid_d51_boundary_scan+0x2d0>)
    64da:	e9cd 5315 	strd	r5, r3, [sp, #84]	; 0x54
	pins [48] = GPIO(GPIO_PORTA, 14);
    64de:	4b9d      	ldr	r3, [pc, #628]	; (6754 <grid_d51_boundary_scan+0x2d4>)
    64e0:	9317      	str	r3, [sp, #92]	; 0x5c
	pins [52] = GPIO(GPIO_PORTA, 16);
    64e2:	f103 53a8 	add.w	r3, r3, #352321536	; 0x15000000
    64e6:	f503 13a0 	add.w	r3, r3, #1310720	; 0x140000
    64ea:	f203 2302 	addw	r3, r3, #514	; 0x202
    64ee:	9318      	str	r3, [sp, #96]	; 0x60
	pins [56] = GPIO(GPIO_PORTC, 16);
    64f0:	f103 3340 	add.w	r3, r3, #1077952576	; 0x40404040
    64f4:	9319      	str	r3, [sp, #100]	; 0x64
	pins [64] = GPIO(GPIO_PORTB, 16);
    64f6:	4b98      	ldr	r3, [pc, #608]	; (6758 <grid_d51_boundary_scan+0x2d8>)
		//pin is real gpio pin
		if (pin_this < SPECIAL_CODES){

			if (!pin_failed){
				// SET TO INPUT, PULLDOWN
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    64f8:	4d98      	ldr	r5, [pc, #608]	; (675c <grid_d51_boundary_scan+0x2dc>)
	pins [64] = GPIO(GPIO_PORTB, 16);
    64fa:	e9cd 731a 	strd	r7, r3, [sp, #104]	; 0x68
	pins [68] = GPIO(GPIO_PORTB, 20);
    64fe:	f103 4361 	add.w	r3, r3, #3774873600	; 0xe1000000
    6502:	f503 0362 	add.w	r3, r3, #14811136	; 0xe20000
    6506:	f203 4304 	addw	r3, r3, #1028	; 0x404
    650a:	931c      	str	r3, [sp, #112]	; 0x70
	pins [72] = GPIO(GPIO_PORTA, 22);
    650c:	f103 6380 	add.w	r3, r3, #67108864	; 0x4000000
    6510:	f503 3378 	add.w	r3, r3, #253952	; 0x3e000
    6514:	f503 73f1 	add.w	r3, r3, #482	; 0x1e2
    6518:	931d      	str	r3, [sp, #116]	; 0x74
	pins [80] = GPIO(GPIO_PORTB, 24);
    651a:	4b91      	ldr	r3, [pc, #580]	; (6760 <grid_d51_boundary_scan+0x2e0>)
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);
    651c:	4f91      	ldr	r7, [pc, #580]	; (6764 <grid_d51_boundary_scan+0x2e4>)
	pins [80] = GPIO(GPIO_PORTB, 24);
    651e:	e9cd c31e 	strd	ip, r3, [sp, #120]	; 0x78
	pins [84] = GPIO(GPIO_PORTC, 26);
    6522:	f103 4342 	add.w	r3, r3, #3254779904	; 0xc2000000
    6526:	f503 2384 	add.w	r3, r3, #270336	; 0x42000
    652a:	f203 2322 	addw	r3, r3, #546	; 0x222
    652e:	9320      	str	r3, [sp, #128]	; 0x80
	pins [92] = PIN_VDD;				//VDDIO
    6530:	4b8d      	ldr	r3, [pc, #564]	; (6768 <grid_d51_boundary_scan+0x2e8>)
    6532:	e9cd e321 	strd	lr, r3, [sp, #132]	; 0x84
	pins [96] = GPIO(GPIO_PORTB, 31);
    6536:	f103 4364 	add.w	r3, r3, #3825205248	; 0xe4000000
    653a:	f503 3300 	add.w	r3, r3, #131072	; 0x20000
    653e:	f503 73a1 	add.w	r3, r3, #322	; 0x142
    6542:	9323      	str	r3, [sp, #140]	; 0x8c
	for (uint8_t i=0; i<100; i++){
    6544:	ab0b      	add	r3, sp, #44	; 0x2c
    6546:	9303      	str	r3, [sp, #12]
	pins [96] = GPIO(GPIO_PORTB, 31);
    6548:	2301      	movs	r3, #1
		uint8_t pin_this = pins[i];
    654a:	9a03      	ldr	r2, [sp, #12]
    654c:	f812 4b01 	ldrb.w	r4, [r2], #1
    6550:	9203      	str	r2, [sp, #12]
		if (pin_this < SPECIAL_CODES){
    6552:	2cef      	cmp	r4, #239	; 0xef
    6554:	d841      	bhi.n	65da <grid_d51_boundary_scan+0x15a>
		uint8_t pin_prev = pins[(i-1+100)%100];
    6556:	2064      	movs	r0, #100	; 0x64
    6558:	f103 0262 	add.w	r2, r3, #98	; 0x62
    655c:	fbb2 f1f0 	udiv	r1, r2, r0
    6560:	fb00 2111 	mls	r1, r0, r1, r2
    6564:	aa24      	add	r2, sp, #144	; 0x90
    6566:	4411      	add	r1, r2
		uint8_t pin_next = pins[(i+1)%100];
    6568:	9301      	str	r3, [sp, #4]
    656a:	fbb3 f2f0 	udiv	r2, r3, r0
    656e:	fb00 3212 	mls	r2, r0, r2, r3
    6572:	ab24      	add	r3, sp, #144	; 0x90
    6574:	441a      	add	r2, r3
		uint8_t pin_prev = pins[(i-1+100)%100];
    6576:	f811 bc64 	ldrb.w	fp, [r1, #-100]
		uint8_t pin_next = pins[(i+1)%100];
    657a:	f812 ac64 	ldrb.w	sl, [r2, #-100]
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    657e:	2101      	movs	r1, #1
    6580:	4620      	mov	r0, r4
    6582:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);
    6584:	2102      	movs	r1, #2
    6586:	4620      	mov	r0, r4
    6588:	47b8      	blx	r7

				// TEST IF pins[i] reads low
				if (gpio_get_pin_level(pin_this) != false){
    658a:	4b78      	ldr	r3, [pc, #480]	; (676c <grid_d51_boundary_scan+0x2ec>)
    658c:	4620      	mov	r0, r4
    658e:	4798      	blx	r3
					pin_failed = true;
				}

				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6590:	2100      	movs	r1, #0
				if (gpio_get_pin_level(pin_this) != false){
    6592:	4681      	mov	r9, r0
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6594:	4620      	mov	r0, r4
    6596:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    6598:	2100      	movs	r1, #0
    659a:	4620      	mov	r0, r4
    659c:	47b8      	blx	r7
			}

			if (!pin_failed){
    659e:	9b01      	ldr	r3, [sp, #4]
    65a0:	f1b9 0f00 	cmp.w	r9, #0
    65a4:	d01f      	beq.n	65e6 <grid_d51_boundary_scan+0x166>
			//RESET THIS PIN TO DEFAULT STATE
		
			if (pin_failed){
				//Sorry, pin failed

				uint8_t error_array_index = (i-1)/25;
    65a6:	2119      	movs	r1, #25
    65a8:	1e9c      	subs	r4, r3, #2
				uint8_t error_bit_index = (i-1)%25;

				error_count++;
				error_bitmap[error_array_index] |= (1<<error_bit_index);
    65aa:	a824      	add	r0, sp, #144	; 0x90
				uint8_t error_array_index = (i-1)/25;
    65ac:	fb94 f2f1 	sdiv	r2, r4, r1
				error_bitmap[error_array_index] |= (1<<error_bit_index);
    65b0:	eb00 0082 	add.w	r0, r0, r2, lsl #2
				uint8_t error_bit_index = (i-1)%25;
    65b4:	fb01 4212 	mls	r2, r1, r2, r4
				error_bitmap[error_array_index] |= (1<<error_bit_index);
    65b8:	b2d2      	uxtb	r2, r2
    65ba:	2101      	movs	r1, #1
    65bc:	fa01 f202 	lsl.w	r2, r1, r2
    65c0:	f850 1c74 	ldr.w	r1, [r0, #-116]
    65c4:	430a      	orrs	r2, r1
    65c6:	f840 2c74 	str.w	r2, [r0, #-116]

				result_bitmap[0] = error_bitmap[0];
    65ca:	9a07      	ldr	r2, [sp, #28]
    65cc:	6032      	str	r2, [r6, #0]
				result_bitmap[1] = error_bitmap[1];
    65ce:	9a08      	ldr	r2, [sp, #32]
    65d0:	6072      	str	r2, [r6, #4]
				result_bitmap[2] = error_bitmap[2];
    65d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    65d4:	60b2      	str	r2, [r6, #8]
				result_bitmap[3] = error_bitmap[3];
    65d6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    65d8:	60f2      	str	r2, [r6, #12]
	for (uint8_t i=0; i<100; i++){
    65da:	3301      	adds	r3, #1
    65dc:	2b65      	cmp	r3, #101	; 0x65
    65de:	d1b4      	bne.n	654a <grid_d51_boundary_scan+0xca>
		}

	}


    65e0:	b025      	add	sp, #148	; 0x94
    65e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    65e6:	2101      	movs	r1, #1
    65e8:	4620      	mov	r0, r4
    65ea:	9302      	str	r3, [sp, #8]
    65ec:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_UP);
    65ee:	2101      	movs	r1, #1
    65f0:	4620      	mov	r0, r4
    65f2:	47b8      	blx	r7
				if (gpio_get_pin_level(pin_this) != true){
    65f4:	4b5d      	ldr	r3, [pc, #372]	; (676c <grid_d51_boundary_scan+0x2ec>)
    65f6:	4620      	mov	r0, r4
    65f8:	4798      	blx	r3
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    65fa:	4649      	mov	r1, r9
				if (gpio_get_pin_level(pin_this) != true){
    65fc:	9001      	str	r0, [sp, #4]
				gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    65fe:	4620      	mov	r0, r4
    6600:	47a8      	blx	r5
				gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    6602:	4620      	mov	r0, r4
    6604:	47b8      	blx	r7
			if (!pin_failed){
    6606:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
    660a:	2a00      	cmp	r2, #0
    660c:	d0cb      	beq.n	65a6 <grid_d51_boundary_scan+0x126>
				if (pin_prev < SPECIAL_CODES){
    660e:	f1bb 0fef 	cmp.w	fp, #239	; 0xef
    6612:	d941      	bls.n	6698 <grid_d51_boundary_scan+0x218>
				if (pin_next < SPECIAL_CODES){
    6614:	f1ba 0fef 	cmp.w	sl, #239	; 0xef
    6618:	d8df      	bhi.n	65da <grid_d51_boundary_scan+0x15a>
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    661a:	2101      	movs	r1, #1
    661c:	4620      	mov	r0, r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    661e:	ea4f 185a 	mov.w	r8, sl, lsr #5
    6622:	9302      	str	r3, [sp, #8]
    6624:	ea4f 18c8 	mov.w	r8, r8, lsl #7
    6628:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);	
    662a:	2102      	movs	r1, #2
    662c:	4620      	mov	r0, r4
    662e:	47b8      	blx	r7
    6630:	f108 4882 	add.w	r8, r8, #1090519040	; 0x41000000
					gpio_set_pin_direction(pin_next, GPIO_DIRECTION_OUT);
    6634:	2102      	movs	r1, #2
    6636:	4650      	mov	r0, sl
    6638:	47a8      	blx	r5
    663a:	f508 4800 	add.w	r8, r8, #32768	; 0x8000
	_gpio_set_level((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), level);
    663e:	2101      	movs	r1, #1
    6640:	f00a 0b1f 	and.w	fp, sl, #31
    6644:	fa01 fb0b 	lsl.w	fp, r1, fp
					if (gpio_get_pin_level(pin_this) != false){
    6648:	4a48      	ldr	r2, [pc, #288]	; (676c <grid_d51_boundary_scan+0x2ec>)
    664a:	f8c8 b018 	str.w	fp, [r8, #24]
    664e:	4620      	mov	r0, r4
    6650:	4790      	blx	r2
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6652:	2101      	movs	r1, #1
					if (gpio_get_pin_level(pin_this) != false){
    6654:	4681      	mov	r9, r0
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6656:	4620      	mov	r0, r4
    6658:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_UP);	
    665a:	2101      	movs	r1, #1
    665c:	4620      	mov	r0, r4
    665e:	47b8      	blx	r7
					gpio_set_pin_direction(pin_next, GPIO_DIRECTION_OUT);
    6660:	2102      	movs	r1, #2
    6662:	4650      	mov	r0, sl
    6664:	47a8      	blx	r5
					if (gpio_get_pin_level(pin_this) != true){
    6666:	4a41      	ldr	r2, [pc, #260]	; (676c <grid_d51_boundary_scan+0x2ec>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    6668:	f8c8 b014 	str.w	fp, [r8, #20]
    666c:	4620      	mov	r0, r4
    666e:	4790      	blx	r2
    6670:	9b01      	ldr	r3, [sp, #4]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6672:	2100      	movs	r1, #0
					if (gpio_get_pin_level(pin_this) != true){
    6674:	2800      	cmp	r0, #0
    6676:	bf08      	it	eq
    6678:	4699      	moveq	r9, r3
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    667a:	4620      	mov	r0, r4
    667c:	47a8      	blx	r5
					gpio_set_pin_direction(pin_next, GPIO_DIRECTION_OFF);
    667e:	2100      	movs	r1, #0
    6680:	4650      	mov	r0, sl
    6682:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    6684:	2100      	movs	r1, #0
    6686:	4620      	mov	r0, r4
    6688:	47b8      	blx	r7
			if (pin_failed){
    668a:	9b02      	ldr	r3, [sp, #8]
    668c:	f8c8 b014 	str.w	fp, [r8, #20]
    6690:	f1b9 0f00 	cmp.w	r9, #0
    6694:	d0a1      	beq.n	65da <grid_d51_boundary_scan+0x15a>
    6696:	e786      	b.n	65a6 <grid_d51_boundary_scan+0x126>
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    6698:	2101      	movs	r1, #1
    669a:	4620      	mov	r0, r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    669c:	ea4f 185b 	mov.w	r8, fp, lsr #5
    66a0:	9305      	str	r3, [sp, #20]
    66a2:	ea4f 18c8 	mov.w	r8, r8, lsl #7
    66a6:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_DOWN);	
    66a8:	2102      	movs	r1, #2
    66aa:	4620      	mov	r0, r4
    66ac:	47b8      	blx	r7
    66ae:	f108 4882 	add.w	r8, r8, #1090519040	; 0x41000000
					gpio_set_pin_direction(pin_prev, GPIO_DIRECTION_OUT);
    66b2:	2102      	movs	r1, #2
    66b4:	4658      	mov	r0, fp
    66b6:	47a8      	blx	r5
    66b8:	f508 4800 	add.w	r8, r8, #32768	; 0x8000
    66bc:	2101      	movs	r1, #1
    66be:	f00b 021f 	and.w	r2, fp, #31
    66c2:	fa01 f202 	lsl.w	r2, r1, r2
    66c6:	f8c8 2018 	str.w	r2, [r8, #24]
					if (gpio_get_pin_level(pin_this) != false){
    66ca:	4b28      	ldr	r3, [pc, #160]	; (676c <grid_d51_boundary_scan+0x2ec>)
    66cc:	9204      	str	r2, [sp, #16]
    66ce:	4620      	mov	r0, r4
    66d0:	4798      	blx	r3
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    66d2:	2101      	movs	r1, #1
					if (gpio_get_pin_level(pin_this) != false){
    66d4:	9002      	str	r0, [sp, #8]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_IN);
    66d6:	4620      	mov	r0, r4
    66d8:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_UP);	
    66da:	2101      	movs	r1, #1
    66dc:	4620      	mov	r0, r4
    66de:	47b8      	blx	r7
					gpio_set_pin_direction(pin_prev, GPIO_DIRECTION_OUT);
    66e0:	2102      	movs	r1, #2
    66e2:	4658      	mov	r0, fp
    66e4:	47a8      	blx	r5
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    66e6:	9a04      	ldr	r2, [sp, #16]
    66e8:	f8c8 2014 	str.w	r2, [r8, #20]
					if (gpio_get_pin_level(pin_this) != true){
    66ec:	4b1f      	ldr	r3, [pc, #124]	; (676c <grid_d51_boundary_scan+0x2ec>)
    66ee:	9204      	str	r2, [sp, #16]
    66f0:	4620      	mov	r0, r4
    66f2:	4798      	blx	r3
    66f4:	e9dd 2301 	ldrd	r2, r3, [sp, #4]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    66f8:	4649      	mov	r1, r9
					if (gpio_get_pin_level(pin_this) != true){
    66fa:	2800      	cmp	r0, #0
    66fc:	bf08      	it	eq
    66fe:	4613      	moveq	r3, r2
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6700:	4620      	mov	r0, r4
					if (gpio_get_pin_level(pin_this) != true){
    6702:	9302      	str	r3, [sp, #8]
					gpio_set_pin_direction(pin_this, GPIO_DIRECTION_OFF);
    6704:	47a8      	blx	r5
					gpio_set_pin_direction(pin_prev, GPIO_DIRECTION_OFF);
    6706:	4658      	mov	r0, fp
    6708:	47a8      	blx	r5
					gpio_set_pin_pull_mode(pin_this, GPIO_PULL_OFF);
    670a:	4620      	mov	r0, r4
    670c:	47b8      	blx	r7
    670e:	9a04      	ldr	r2, [sp, #16]
    6710:	f8c8 2014 	str.w	r2, [r8, #20]
			if (!pin_failed){
    6714:	9a02      	ldr	r2, [sp, #8]
    6716:	9b05      	ldr	r3, [sp, #20]
    6718:	2a00      	cmp	r2, #0
    671a:	f43f af7b 	beq.w	6614 <grid_d51_boundary_scan+0x194>
    671e:	e742      	b.n	65a6 <grid_d51_boundary_scan+0x126>
    6720:	00014d51 	.word	0x00014d51
    6724:	2d2c2b2a 	.word	0x2d2c2b2a
    6728:	4d4c4b4a 	.word	0x4d4c4b4a
    672c:	fdfe5554 	.word	0xfdfe5554
    6730:	02434241 	.word	0x02434241
    6734:	40010023 	.word	0x40010023
    6738:	06050429 	.word	0x06050429
    673c:	0908fdfe 	.word	0x0908fdfe
    6740:	fe252403 	.word	0xfe252403
    6744:	47464507 	.word	0x47464507
    6748:	fefd0b0a 	.word	0xfefd0b0a
    674c:	fdfe2f2e 	.word	0xfdfe2f2e
    6750:	0d0c4f4e 	.word	0x0d0c4f4e
    6754:	fdfe0f0e 	.word	0xfdfe0f0e
    6758:	33323130 	.word	0x33323130
    675c:	00006381 	.word	0x00006381
    6760:	59583938 	.word	0x59583938
    6764:	000063d1 	.word	0x000063d1
    6768:	3e1f1efd 	.word	0x3e1f1efd
    676c:	00006339 	.word	0x00006339
    6770:	3736fdfe 	.word	0x3736fdfe
    6774:	f7fef8fc 	.word	0xf7fef8fc

00006778 <grid_expr_clear_input>:
}


grid_expr_clear_input(struct grid_expr_model* expr){

    expr->input_string_length = 0;
    6778:	2300      	movs	r3, #0
    677a:	f880 30fe 	strb.w	r3, [r0, #254]	; 0xfe

    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    677e:	1d02      	adds	r2, r0, #4
    6780:	30fe      	adds	r0, #254	; 0xfe

        expr->input_string[i] = 0;
    6782:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_INPUT_STRING_MAXLENGTH; i++){
    6786:	4282      	cmp	r2, r0
    6788:	d1fb      	bne.n	6782 <grid_expr_clear_input+0xa>

    }

}
    678a:	4770      	bx	lr

0000678c <grid_expr_clear_output>:

grid_expr_clear_output(struct grid_expr_model* expr){


    expr->output_string_length = 0;
    678c:	2300      	movs	r3, #0
    678e:	f880 31fa 	strb.w	r3, [r0, #506]	; 0x1fa

    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    6792:	f100 02ff 	add.w	r2, r0, #255	; 0xff
    6796:	f200 10f9 	addw	r0, r0, #505	; 0x1f9

        expr->output_string[i] = 0;
    679a:	f802 3b01 	strb.w	r3, [r2], #1
    for (uint32_t i=0; i<GRID_EXPR_OUTPUT_STRING_MAXLENGTH; i++){
    679e:	4282      	cmp	r2, r0
    67a0:	d1fb      	bne.n	679a <grid_expr_clear_output+0xe>

    }

}
    67a2:	4770      	bx	lr

000067a4 <grid_expr_init>:
void grid_expr_init(struct grid_expr_model* expr){
    67a4:	b510      	push	{r4, lr}
    expr->current_event = NULL;
    67a6:	2300      	movs	r3, #0
    67a8:	6003      	str	r3, [r0, #0]
    grid_expr_clear_input(expr);
    67aa:	4b04      	ldr	r3, [pc, #16]	; (67bc <grid_expr_init+0x18>)
void grid_expr_init(struct grid_expr_model* expr){
    67ac:	4601      	mov	r1, r0
    grid_expr_clear_input(expr);
    67ae:	4798      	blx	r3
}
    67b0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_expr_clear_output(expr);
    67b4:	4b02      	ldr	r3, [pc, #8]	; (67c0 <grid_expr_init+0x1c>)
    67b6:	4608      	mov	r0, r1
    67b8:	4718      	bx	r3
    67ba:	bf00      	nop
    67bc:	00006779 	.word	0x00006779
    67c0:	0000678d 	.word	0x0000678d

000067c4 <grid_expr_set_current_event>:



grid_expr_set_current_event(struct grid_expr_model* expr, struct grid_ui_event* eve){

    expr->current_event = eve;
    67c4:	6001      	str	r1, [r0, #0]
}
    67c6:	4770      	bx	lr

000067c8 <get>:
}


char get(char** e)
{
    char ret = **e;
    67c8:	6802      	ldr	r2, [r0, #0]
{
    67ca:	4603      	mov	r3, r0
    char ret = **e;
    67cc:	f812 0b01 	ldrb.w	r0, [r2], #1
    ++*e;
    67d0:	601a      	str	r2, [r3, #0]
    return ret;
}
    67d2:	4770      	bx	lr

000067d4 <number>:

int number(char** e)
{
    67d4:	b530      	push	{r4, r5, lr}
    char ret = **e;
    67d6:	6801      	ldr	r1, [r0, #0]
    67d8:	f811 3b01 	ldrb.w	r3, [r1], #1
    ++*e;
    67dc:	6001      	str	r1, [r0, #0]
{
    67de:	4602      	mov	r2, r0
    int result = get(e) - '0';
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    {
        result = 10*result + get(e) - '0'; // HEX para
    67e0:	250a      	movs	r5, #10
    int result = get(e) - '0';
    67e2:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    return **e;
    67e6:	6811      	ldr	r1, [r2, #0]
    67e8:	780b      	ldrb	r3, [r1, #0]
    while (peek(e) >= '0' && peek(e) <= '9') // HEX para
    67ea:	f1a3 0430 	sub.w	r4, r3, #48	; 0x30
    67ee:	2c09      	cmp	r4, #9
    67f0:	d900      	bls.n	67f4 <number+0x20>
    }
    return result;
}
    67f2:	bd30      	pop	{r4, r5, pc}
    ++*e;
    67f4:	3101      	adds	r1, #1
        result = 10*result + get(e) - '0'; // HEX para
    67f6:	fb05 3300 	mla	r3, r5, r0, r3
    ++*e;
    67fa:	6011      	str	r1, [r2, #0]
        result = 10*result + get(e) - '0'; // HEX para
    67fc:	f1a3 0030 	sub.w	r0, r3, #48	; 0x30
    6800:	e7f1      	b.n	67e6 <number+0x12>
	...

00006804 <expr_level_0>:
            result -= expr_level_2(e);
    return result;
}

int expr_level_0(char ** e) // equality
{
    6804:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_1(e);
    6806:	4e2a      	ldr	r6, [pc, #168]	; (68b0 <expr_level_0+0xac>)
        else if (peeked == '=' && peeked2 == '='){
            get(e); // burn the second character
            result = (result == expr_level_1(e));
        }
        else if (peeked == '!' && peeked2 == '='){
            get(e); // burn the second character
    6808:	4f2a      	ldr	r7, [pc, #168]	; (68b4 <expr_level_0+0xb0>)
{
    680a:	4605      	mov	r5, r0
    int result = expr_level_1(e);
    680c:	47b0      	blx	r6
    680e:	4604      	mov	r4, r0
    return **e;
    6810:	682a      	ldr	r2, [r5, #0]
    6812:	7813      	ldrb	r3, [r2, #0]
    while (     (peek(e) == '>' && peek2(e) != '=') || 
    6814:	f003 01fd 	and.w	r1, r3, #253	; 0xfd
    6818:	293c      	cmp	r1, #60	; 0x3c
    681a:	d004      	beq.n	6826 <expr_level_0+0x22>
                (peek(e) == '<' && peek2(e) != '=') || 
    681c:	2b3d      	cmp	r3, #61	; 0x3d
    681e:	d143      	bne.n	68a8 <expr_level_0+0xa4>
                (peek(e) == '!' && peek2(e) == '=') ||
    6820:	7851      	ldrb	r1, [r2, #1]
    6822:	293d      	cmp	r1, #61	; 0x3d
    6824:	d142      	bne.n	68ac <expr_level_0+0xa8>
    ++*e;
    6826:	1c51      	adds	r1, r2, #1
    6828:	6029      	str	r1, [r5, #0]
        if ((peeked == '>' && peeked2 != '=')){
    682a:	2b3e      	cmp	r3, #62	; 0x3e
    return **e;
    682c:	7852      	ldrb	r2, [r2, #1]
        if ((peeked == '>' && peeked2 != '=')){
    682e:	d108      	bne.n	6842 <expr_level_0+0x3e>
    6830:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result>expr_level_1(e));
    6832:	4628      	mov	r0, r5
        if ((peeked == '>' && peeked2 != '=')){
    6834:	d028      	beq.n	6888 <expr_level_0+0x84>
            result = (result>expr_level_1(e));
    6836:	47b0      	blx	r6
    6838:	42a0      	cmp	r0, r4
    683a:	bfac      	ite	ge
    683c:	2400      	movge	r4, #0
    683e:	2401      	movlt	r4, #1
    6840:	e7e6      	b.n	6810 <expr_level_0+0xc>
        else if (peeked == '<' && peeked2 != '='){
    6842:	2b3c      	cmp	r3, #60	; 0x3c
    6844:	d108      	bne.n	6858 <expr_level_0+0x54>
    6846:	2a3d      	cmp	r2, #61	; 0x3d
            result = (result<expr_level_1(e));
    6848:	4628      	mov	r0, r5
        else if (peeked == '<' && peeked2 != '='){
    684a:	d025      	beq.n	6898 <expr_level_0+0x94>
            result = (result<expr_level_1(e));
    684c:	47b0      	blx	r6
    684e:	42a0      	cmp	r0, r4
    6850:	bfd4      	ite	le
    6852:	2400      	movle	r4, #0
    6854:	2401      	movgt	r4, #1
    6856:	e7db      	b.n	6810 <expr_level_0+0xc>
        else if (peeked == '=' && peeked2 == '='){
    6858:	2b3d      	cmp	r3, #61	; 0x3d
    685a:	d109      	bne.n	6870 <expr_level_0+0x6c>
    685c:	2a3d      	cmp	r2, #61	; 0x3d
    685e:	d1d7      	bne.n	6810 <expr_level_0+0xc>
            get(e); // burn the second character
    6860:	4628      	mov	r0, r5
    6862:	47b8      	blx	r7
            result = (result == expr_level_1(e));
    6864:	4628      	mov	r0, r5
    6866:	47b0      	blx	r6
    6868:	1b03      	subs	r3, r0, r4
    686a:	425c      	negs	r4, r3
    686c:	415c      	adcs	r4, r3
    686e:	e7cf      	b.n	6810 <expr_level_0+0xc>
        else if (peeked == '!' && peeked2 == '='){
    6870:	2b21      	cmp	r3, #33	; 0x21
    6872:	d1cd      	bne.n	6810 <expr_level_0+0xc>
    6874:	2a3d      	cmp	r2, #61	; 0x3d
    6876:	d1cb      	bne.n	6810 <expr_level_0+0xc>
            get(e); // burn the second character
    6878:	4628      	mov	r0, r5
    687a:	47b8      	blx	r7
            result = (result != expr_level_1(e));
    687c:	4628      	mov	r0, r5
    687e:	47b0      	blx	r6
    6880:	1b04      	subs	r4, r0, r4
    6882:	bf18      	it	ne
    6884:	2401      	movne	r4, #1
    6886:	e7c3      	b.n	6810 <expr_level_0+0xc>
        }
        else if (peeked == '>' && peeked2 == '='){
            get(e); // burn the second character
    6888:	47b8      	blx	r7
            result = (result >= expr_level_1(e));
    688a:	4628      	mov	r0, r5
    688c:	47b0      	blx	r6
    688e:	42a0      	cmp	r0, r4
    6890:	bfcc      	ite	gt
    6892:	2400      	movgt	r4, #0
    6894:	2401      	movle	r4, #1
    6896:	e7bb      	b.n	6810 <expr_level_0+0xc>
        }
        else if (peeked == '<' && peeked2 == '='){
            get(e); // burn the second character
    6898:	47b8      	blx	r7
            result = (result <= expr_level_1(e));
    689a:	4628      	mov	r0, r5
    689c:	47b0      	blx	r6
    689e:	42a0      	cmp	r0, r4
    68a0:	bfb4      	ite	lt
    68a2:	2400      	movlt	r4, #0
    68a4:	2401      	movge	r4, #1
    68a6:	e7b3      	b.n	6810 <expr_level_0+0xc>
                (peek(e) == '=' && peek2(e) == '=') ||
    68a8:	2b21      	cmp	r3, #33	; 0x21
    68aa:	d0b9      	beq.n	6820 <expr_level_0+0x1c>
        }
    }
    return result;
}
    68ac:	4620      	mov	r0, r4
    68ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    68b0:	00006971 	.word	0x00006971
    68b4:	000067c9 	.word	0x000067c9

000068b8 <expr_level_3>:
        get(e);
    68b8:	4913      	ldr	r1, [pc, #76]	; (6908 <expr_level_3+0x50>)
{
    68ba:	b570      	push	{r4, r5, r6, lr}
    68bc:	4604      	mov	r4, r0
    68be:	2501      	movs	r5, #1
    return **e;
    68c0:	6823      	ldr	r3, [r4, #0]
    68c2:	781b      	ldrb	r3, [r3, #0]
    if (peek(e) >= '0' && peek(e) <= '9') // HEX para
    68c4:	2b2f      	cmp	r3, #47	; 0x2f
    68c6:	d908      	bls.n	68da <expr_level_3+0x22>
    68c8:	2b39      	cmp	r3, #57	; 0x39
    68ca:	d818      	bhi.n	68fe <expr_level_3+0x46>
        return number(e);
    68cc:	4b0f      	ldr	r3, [pc, #60]	; (690c <expr_level_3+0x54>)
    68ce:	4620      	mov	r0, r4
    68d0:	4798      	blx	r3
    68d2:	4601      	mov	r1, r0
}
    68d4:	fb05 f001 	mul.w	r0, r5, r1
    68d8:	bd70      	pop	{r4, r5, r6, pc}
    else if (peek(e) == '(')
    68da:	2b28      	cmp	r3, #40	; 0x28
    68dc:	d109      	bne.n	68f2 <expr_level_3+0x3a>
        get(e); // '('
    68de:	4e0a      	ldr	r6, [pc, #40]	; (6908 <expr_level_3+0x50>)
    68e0:	4620      	mov	r0, r4
    68e2:	47b0      	blx	r6
        int result = expr_level_0(e);
    68e4:	4b0a      	ldr	r3, [pc, #40]	; (6910 <expr_level_3+0x58>)
    68e6:	4620      	mov	r0, r4
    68e8:	4798      	blx	r3
    68ea:	4601      	mov	r1, r0
        get(e); // ')'
    68ec:	4620      	mov	r0, r4
    68ee:	47b0      	blx	r6
        return result;
    68f0:	e7f0      	b.n	68d4 <expr_level_3+0x1c>
    else if (peek(e) == '-')
    68f2:	2b2d      	cmp	r3, #45	; 0x2d
    68f4:	d103      	bne.n	68fe <expr_level_3+0x46>
        get(e);
    68f6:	4620      	mov	r0, r4
    68f8:	4788      	blx	r1
        return -expr_level_3(e);
    68fa:	426d      	negs	r5, r5
    68fc:	e7e0      	b.n	68c0 <expr_level_3+0x8>
    printf("ERROR in expr_level_3()\n");
    68fe:	4805      	ldr	r0, [pc, #20]	; (6914 <expr_level_3+0x5c>)
    6900:	4b05      	ldr	r3, [pc, #20]	; (6918 <expr_level_3+0x60>)
    6902:	4798      	blx	r3
    return 0; // error
    6904:	2100      	movs	r1, #0
    6906:	e7e5      	b.n	68d4 <expr_level_3+0x1c>
    6908:	000067c9 	.word	0x000067c9
    690c:	000067d5 	.word	0x000067d5
    6910:	00006805 	.word	0x00006805
    6914:	000167ac 	.word	0x000167ac
    6918:	00014fe5 	.word	0x00014fe5

0000691c <expr_level_2>:
{
    691c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int result = expr_level_3(e);
    691e:	4e13      	ldr	r6, [pc, #76]	; (696c <expr_level_2+0x50>)
{
    6920:	4605      	mov	r5, r0
    int result = expr_level_3(e);
    6922:	47b0      	blx	r6
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    6924:	f240 4721 	movw	r7, #1057	; 0x421
    int result = expr_level_3(e);
    6928:	4604      	mov	r4, r0
    return **e;
    692a:	682a      	ldr	r2, [r5, #0]
    692c:	7811      	ldrb	r1, [r2, #0]
    while (peek(e) == '*' || peek(e) == '/' || peek(e) == '%'){
    692e:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
    6932:	b2db      	uxtb	r3, r3
    6934:	2b0a      	cmp	r3, #10
    6936:	d803      	bhi.n	6940 <expr_level_2+0x24>
    6938:	fa27 f303 	lsr.w	r3, r7, r3
    693c:	07db      	lsls	r3, r3, #31
    693e:	d401      	bmi.n	6944 <expr_level_2+0x28>
}
    6940:	4620      	mov	r0, r4
    6942:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ++*e;
    6944:	3201      	adds	r2, #1
        if (peeked == '*'){
    6946:	292a      	cmp	r1, #42	; 0x2a
    ++*e;
    6948:	602a      	str	r2, [r5, #0]
            result *= expr_level_3(e);
    694a:	4628      	mov	r0, r5
        if (peeked == '*'){
    694c:	d102      	bne.n	6954 <expr_level_2+0x38>
            result *= expr_level_3(e);
    694e:	47b0      	blx	r6
    6950:	4344      	muls	r4, r0
    6952:	e7ea      	b.n	692a <expr_level_2+0xe>
        else if (peeked == '%'){
    6954:	2925      	cmp	r1, #37	; 0x25
    6956:	d105      	bne.n	6964 <expr_level_2+0x48>
            result %= expr_level_3(e);
    6958:	47b0      	blx	r6
    695a:	fb94 f3f0 	sdiv	r3, r4, r0
    695e:	fb03 4410 	mls	r4, r3, r0, r4
    6962:	e7e2      	b.n	692a <expr_level_2+0xe>
            result /= expr_level_3(e);
    6964:	47b0      	blx	r6
    6966:	fb94 f4f0 	sdiv	r4, r4, r0
    696a:	e7de      	b.n	692a <expr_level_2+0xe>
    696c:	000068b9 	.word	0x000068b9

00006970 <expr_level_1>:
{
    6970:	b570      	push	{r4, r5, r6, lr}
    int result = expr_level_2(e);
    6972:	4e0b      	ldr	r6, [pc, #44]	; (69a0 <expr_level_1+0x30>)
{
    6974:	4605      	mov	r5, r0
    int result = expr_level_2(e);
    6976:	47b0      	blx	r6
    6978:	4604      	mov	r4, r0
    return **e;
    697a:	682b      	ldr	r3, [r5, #0]
    697c:	781a      	ldrb	r2, [r3, #0]
    while (peek(e) == '+' || peek(e) == '-')
    697e:	2a2b      	cmp	r2, #43	; 0x2b
    6980:	d003      	beq.n	698a <expr_level_1+0x1a>
    6982:	2a2d      	cmp	r2, #45	; 0x2d
    6984:	d001      	beq.n	698a <expr_level_1+0x1a>
}
    6986:	4620      	mov	r0, r4
    6988:	bd70      	pop	{r4, r5, r6, pc}
    ++*e;
    698a:	3301      	adds	r3, #1
        if (get(e) == '+')
    698c:	2a2b      	cmp	r2, #43	; 0x2b
    ++*e;
    698e:	602b      	str	r3, [r5, #0]
            result += expr_level_2(e);
    6990:	4628      	mov	r0, r5
        if (get(e) == '+')
    6992:	d102      	bne.n	699a <expr_level_1+0x2a>
            result += expr_level_2(e);
    6994:	47b0      	blx	r6
    6996:	4404      	add	r4, r0
    6998:	e7ef      	b.n	697a <expr_level_1+0xa>
            result -= expr_level_2(e);
    699a:	47b0      	blx	r6
    699c:	1a24      	subs	r4, r4, r0
    699e:	e7ec      	b.n	697a <expr_level_1+0xa>
    69a0:	0000691d 	.word	0x0000691d

000069a4 <insertTo>:


    return expression_inner(&str);
}

void insertTo(char* start,int length,char* that){
    69a4:	b570      	push	{r4, r5, r6, lr}
    69a6:	b09a      	sub	sp, #104	; 0x68
    69a8:	4604      	mov	r4, r0
    
    char ending[100] = {0};
    69aa:	4b0b      	ldr	r3, [pc, #44]	; (69d8 <insertTo+0x34>)
void insertTo(char* start,int length,char* that){
    69ac:	4615      	mov	r5, r2
    69ae:	460e      	mov	r6, r1
    char ending[100] = {0};
    69b0:	2260      	movs	r2, #96	; 0x60
    69b2:	2100      	movs	r1, #0
    69b4:	a802      	add	r0, sp, #8
    69b6:	9101      	str	r1, [sp, #4]
    69b8:	4798      	blx	r3
    
    //printf("insertTo: Hova: %s Milyen hosszú helyre: %d Mit: %s\n", start, length, that);
    
    sprintf(ending,"%s",start+length);
    69ba:	19a1      	adds	r1, r4, r6
    69bc:	a801      	add	r0, sp, #4
    69be:	4e07      	ldr	r6, [pc, #28]	; (69dc <insertTo+0x38>)
    69c0:	47b0      	blx	r6
    sprintf(start,"%s",that);
    69c2:	4629      	mov	r1, r5
    69c4:	4620      	mov	r0, r4
    69c6:	47b0      	blx	r6
    sprintf(start+strlen(that),"%s",ending);
    69c8:	4b05      	ldr	r3, [pc, #20]	; (69e0 <insertTo+0x3c>)
    69ca:	4628      	mov	r0, r5
    69cc:	4798      	blx	r3
    69ce:	a901      	add	r1, sp, #4
    69d0:	4420      	add	r0, r4
    69d2:	47b0      	blx	r6
}
    69d4:	b01a      	add	sp, #104	; 0x68
    69d6:	bd70      	pop	{r4, r5, r6, pc}
    69d8:	00014d51 	.word	0x00014d51
    69dc:	00015307 	.word	0x00015307
    69e0:	00015317 	.word	0x00015317

000069e4 <brack_len>:
        // START: SUKU
    
    int nyitCount = 0;
    int zarCount = 0;
    
    for(int i=0; i<maxLen; i++){
    69e4:	2300      	movs	r3, #0
int brack_len(char* funcDesc,int maxLen){ //pl.: almafa(6*(2+2))*45
    69e6:	b530      	push	{r4, r5, lr}
    int nyitCount = 0;
    69e8:	461a      	mov	r2, r3
    int zarCount = 0;
    69ea:	461c      	mov	r4, r3
    for(int i=0; i<maxLen; i++){
    69ec:	428b      	cmp	r3, r1
    69ee:	da0c      	bge.n	6a0a <brack_len+0x26>
        
        if (funcDesc[i] == '('){
    69f0:	5cc5      	ldrb	r5, [r0, r3]
    69f2:	2d28      	cmp	r5, #40	; 0x28
    69f4:	f103 0301 	add.w	r3, r3, #1
    69f8:	d101      	bne.n	69fe <brack_len+0x1a>
            
            nyitCount++;
    69fa:	3201      	adds	r2, #1
    69fc:	e7f6      	b.n	69ec <brack_len+0x8>
        }
        else if (funcDesc[i] == ')'){
    69fe:	2d29      	cmp	r5, #41	; 0x29
    6a00:	d1f4      	bne.n	69ec <brack_len+0x8>
            zarCount++;
    6a02:	3401      	adds	r4, #1
            
            if (zarCount == nyitCount){
    6a04:	42a2      	cmp	r2, r4
    6a06:	d1f1      	bne.n	69ec <brack_len+0x8>
                return i+1;
    6a08:	4618      	mov	r0, r3
            }
        }
        
    }
}
    6a0a:	bd30      	pop	{r4, r5, pc}

00006a0c <calcSubFnc>:



void calcSubFnc(char* startposition){
    6a0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

    uint8_t debug_level = 0; 

    char* fName = startposition;
    char* fNameEnd = strstr(fName,"(");
    6a10:	4b82      	ldr	r3, [pc, #520]	; (6c1c <calcSubFnc+0x210>)
void calcSubFnc(char* startposition){
    6a12:	b0ab      	sub	sp, #172	; 0xac
    char* fNameEnd = strstr(fName,"(");
    6a14:	2128      	movs	r1, #40	; 0x28
void calcSubFnc(char* startposition){
    6a16:	4680      	mov	r8, r0
    char* fNameEnd = strstr(fName,"(");
    6a18:	4798      	blx	r3


    if (debug_level) printf("FNC name: ");
    if (debug_level) delay_ms(1);

    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6a1a:	eba0 0208 	sub.w	r2, r0, r8
    char* fNameEnd = strstr(fName,"(");
    6a1e:	4681      	mov	r9, r0
    for(uint8_t i=0; i<fNameEnd-fName; i++){
    6a20:	2300      	movs	r3, #0
    6a22:	9200      	str	r2, [sp, #0]
    6a24:	9900      	ldr	r1, [sp, #0]
    6a26:	b2da      	uxtb	r2, r3
    6a28:	428a      	cmp	r2, r1
    6a2a:	f103 0301 	add.w	r3, r3, #1
    6a2e:	dbf9      	blt.n	6a24 <calcSubFnc+0x18>
    }

    if (debug_level) printf("\r\n");
    if (debug_level) delay_ms(1);
    
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6a30:	4b7b      	ldr	r3, [pc, #492]	; (6c20 <calcSubFnc+0x214>)
    
    if (debug_level) printf("calcSubFnc Maxoffset: %d  ## \r\n", max_offset);
    if (debug_level) delay_ms(5);;
    
    int param_expr_results[10] = {0};
    6a32:	4f7c      	ldr	r7, [pc, #496]	; (6c24 <calcSubFnc+0x218>)
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6a34:	4648      	mov	r0, r9
    6a36:	4798      	blx	r3
    6a38:	4b7b      	ldr	r3, [pc, #492]	; (6c28 <calcSubFnc+0x21c>)
    6a3a:	4601      	mov	r1, r0
    6a3c:	4648      	mov	r0, r9
    6a3e:	4798      	blx	r3
    int param_expr_results[10] = {0};
    6a40:	2228      	movs	r2, #40	; 0x28
    int max_offset = brack_len(fNameEnd,strlen(fNameEnd)) -2;
    6a42:	1e86      	subs	r6, r0, #2
    int param_expr_results[10] = {0};
    6a44:	2100      	movs	r1, #0
    6a46:	a807      	add	r0, sp, #28
    6a48:	47b8      	blx	r7
    char* comma = strstr(start, ",");
    int commaoffset = -1;
    
    
    
    for (int i=0; i<max_offset; i=i){
    6a4a:	2500      	movs	r5, #0
    int param_expr_results_count = 0;
    6a4c:	462c      	mov	r4, r5
    for (int i=0; i<max_offset; i=i){
    6a4e:	42b5      	cmp	r5, r6
    6a50:	da2a      	bge.n	6aa8 <calcSubFnc+0x9c>
    6a52:	eb09 0a05 	add.w	sl, r9, r5
    6a56:	4652      	mov	r2, sl
    6a58:	46ab      	mov	fp, r5
        
        int commaoffset = -1;
        
        for(int j=i; j<max_offset; j++){
            
            if (start[j] == ','){
    6a5a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
    6a5e:	f8cd b004 	str.w	fp, [sp, #4]
    6a62:	292c      	cmp	r1, #44	; 0x2c
    6a64:	f10b 0b01 	add.w	fp, fp, #1
    6a68:	f000 80cc 	beq.w	6c04 <calcSubFnc+0x1f8>
        for(int j=i; j<max_offset; j++){
    6a6c:	455e      	cmp	r6, fp
    6a6e:	dcf4      	bgt.n	6a5a <calcSubFnc+0x4e>
 
        if (commaoffset==-1){
            
           // printf("No more commas! \r\n");
            
            char param_expr[20] = {0};
    6a70:	f04f 0900 	mov.w	r9, #0
    6a74:	4649      	mov	r1, r9
    6a76:	2210      	movs	r2, #16
    6a78:	a812      	add	r0, sp, #72	; 0x48
    6a7a:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
            
            for (int j=0; j<(max_offset-i); j++){
    6a7e:	1b75      	subs	r5, r6, r5
            char param_expr[20] = {0};
    6a80:	47b8      	blx	r7
            for (int j=0; j<(max_offset-i); j++){
    6a82:	4649      	mov	r1, r9
    6a84:	ab11      	add	r3, sp, #68	; 0x44
    6a86:	e003      	b.n	6a90 <calcSubFnc+0x84>
                param_expr[j] = start[i+j];
    6a88:	f81a 2f01 	ldrb.w	r2, [sl, #1]!
    6a8c:	545a      	strb	r2, [r3, r1]
            for (int j=0; j<(max_offset-i); j++){
    6a8e:	3101      	adds	r1, #1
    6a90:	428d      	cmp	r5, r1
    6a92:	dcf9      	bgt.n	6a88 <calcSubFnc+0x7c>
            }
            
            if (debug_level) printf("Parameter: \"%s\", ", param_expr);
            if (debug_level) delay_ms(2);
            
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6a94:	9304      	str	r3, [sp, #16]
    int result = expr_level_0(e);
    6a96:	a804      	add	r0, sp, #16
    6a98:	4b64      	ldr	r3, [pc, #400]	; (6c2c <calcSubFnc+0x220>)
    6a9a:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6a9c:	ab2a      	add	r3, sp, #168	; 0xa8
    6a9e:	eb03 0384 	add.w	r3, r3, r4, lsl #2
            
            
            if (debug_level) printf("Result: \"%d\" \r\n", param_expr_results[param_expr_results_count]);
            if (debug_level) delay_ms(2);
            
            param_expr_results_count++;
    6aa2:	3401      	adds	r4, #1
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6aa4:	f843 0c8c 	str.w	r0, [r3, #-140]
    
    
    // START: CALC BUILTIN


    char justName[10] = {0};
    6aa8:	2300      	movs	r3, #0
    6aaa:	aa04      	add	r2, sp, #16
    6aac:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6ab0:	f8ad 3018 	strh.w	r3, [sp, #24]
    
    for (int i=0; i<9; i++){
    6ab4:	f108 0008 	add.w	r0, r8, #8
    6ab8:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
    6abc:	4693      	mov	fp, r2
        
        if (fName[i] == '('){
    6abe:	f813 1f01 	ldrb.w	r1, [r3, #1]!
    6ac2:	2928      	cmp	r1, #40	; 0x28
    6ac4:	d127      	bne.n	6b16 <calcSubFnc+0x10a>
        }
        
    }

    
    if(strcmp(justName,"abs")==0){
    6ac6:	495a      	ldr	r1, [pc, #360]	; (6c30 <calcSubFnc+0x224>)
    6ac8:	4d5a      	ldr	r5, [pc, #360]	; (6c34 <calcSubFnc+0x228>)
    6aca:	f8df a19c 	ldr.w	sl, [pc, #412]	; 6c68 <calcSubFnc+0x25c>
    6ace:	4658      	mov	r0, fp
    6ad0:	47a8      	blx	r5
    6ad2:	f10d 0944 	add.w	r9, sp, #68	; 0x44
    6ad6:	b318      	cbz	r0, 6b20 <calcSubFnc+0x114>
        resultOfFnc = abs(param_expr_results[0]);
    }
    else if(strcmp(justName,"six")==0){
    6ad8:	4957      	ldr	r1, [pc, #348]	; (6c38 <calcSubFnc+0x22c>)
    6ada:	4658      	mov	r0, fp
    6adc:	47a8      	blx	r5
    6ade:	2800      	cmp	r0, #0
    6ae0:	f000 808e 	beq.w	6c00 <calcSubFnc+0x1f4>
        resultOfFnc = 666666;
    }
    else if(strcmp(justName,"add")==0){
    6ae4:	4955      	ldr	r1, [pc, #340]	; (6c3c <calcSubFnc+0x230>)
    6ae6:	4658      	mov	r0, fp
    6ae8:	47a8      	blx	r5
    6aea:	2800      	cmp	r0, #0
    6aec:	d130      	bne.n	6b50 <calcSubFnc+0x144>
        resultOfFnc = param_expr_results[0] + param_expr_results[1];
    6aee:	e9dd 5307 	ldrd	r5, r3, [sp, #28]
    6af2:	441d      	add	r5, r3
    6af4:	e018      	b.n	6b28 <calcSubFnc+0x11c>
                param_expr[j] = start[i+j];
    6af6:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
    6afa:	5488      	strb	r0, [r1, r2]
            for (int j=0; j<commaoffset-i; j++){
    6afc:	3201      	adds	r2, #1
    6afe:	4295      	cmp	r5, r2
    6b00:	dcf9      	bgt.n	6af6 <calcSubFnc+0xea>
    int result = expr_level_0(e);
    6b02:	4b4a      	ldr	r3, [pc, #296]	; (6c2c <calcSubFnc+0x220>)
    6b04:	9104      	str	r1, [sp, #16]
    6b06:	a804      	add	r0, sp, #16
    6b08:	4798      	blx	r3
            param_expr_results[param_expr_results_count] = expression(param_expr);
    6b0a:	ab07      	add	r3, sp, #28
    6b0c:	465d      	mov	r5, fp
    6b0e:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
            param_expr_results_count++;
    6b12:	3401      	adds	r4, #1
    for (int i=0; i<max_offset; i=i){
    6b14:	e79b      	b.n	6a4e <calcSubFnc+0x42>
    for (int i=0; i<9; i++){
    6b16:	4283      	cmp	r3, r0
            justName[i] = fName[i];
    6b18:	f802 1b01 	strb.w	r1, [r2], #1
    for (int i=0; i<9; i++){
    6b1c:	d1cf      	bne.n	6abe <calcSubFnc+0xb2>
    6b1e:	e7d2      	b.n	6ac6 <calcSubFnc+0xba>
        resultOfFnc = abs(param_expr_results[0]);
    6b20:	9d07      	ldr	r5, [sp, #28]
    6b22:	2d00      	cmp	r5, #0
    6b24:	bfb8      	it	lt
    6b26:	426d      	neglt	r5, r5
    
    //printf("resultOfFnc: %d\n", resultOfFnc);
    

    
    char buff[100] = {0};
    6b28:	2100      	movs	r1, #0
    6b2a:	2260      	movs	r2, #96	; 0x60
    6b2c:	a812      	add	r0, sp, #72	; 0x48
    6b2e:	9111      	str	r1, [sp, #68]	; 0x44
    6b30:	47b8      	blx	r7
    
    sprintf(buff,"(%d)",resultOfFnc); //HEX para, sign para
    6b32:	462a      	mov	r2, r5
    6b34:	4942      	ldr	r1, [pc, #264]	; (6c40 <calcSubFnc+0x234>)
    6b36:	4648      	mov	r0, r9
    6b38:	47d0      	blx	sl
    
    // hova, milyen hosszan, mit
    insertTo(startposition,(fNameEnd-fName)+max_offset+2,buff);
    6b3a:	9b00      	ldr	r3, [sp, #0]
    6b3c:	4433      	add	r3, r6
    6b3e:	4619      	mov	r1, r3
    6b40:	464a      	mov	r2, r9
    6b42:	4b40      	ldr	r3, [pc, #256]	; (6c44 <calcSubFnc+0x238>)
    6b44:	3102      	adds	r1, #2
    6b46:	4640      	mov	r0, r8
    6b48:	4798      	blx	r3
    
        
    //printf(" @@ debug: %s @@\n", startposition);
}
    6b4a:	b02b      	add	sp, #172	; 0xac
    6b4c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    6b50:	493d      	ldr	r1, [pc, #244]	; (6c48 <calcSubFnc+0x23c>)
    6b52:	4658      	mov	r0, fp
    6b54:	47a8      	blx	r5
    6b56:	b120      	cbz	r0, 6b62 <calcSubFnc+0x156>
    6b58:	493c      	ldr	r1, [pc, #240]	; (6c4c <calcSubFnc+0x240>)
    6b5a:	4658      	mov	r0, fp
    6b5c:	47a8      	blx	r5
    6b5e:	2800      	cmp	r0, #0
    6b60:	d13e      	bne.n	6be0 <calcSubFnc+0x1d4>
        char fmt_str[] = "%02x";
    6b62:	4b3b      	ldr	r3, [pc, #236]	; (6c50 <calcSubFnc+0x244>)
        if (param_expr_results_count>1){
    6b64:	2c01      	cmp	r4, #1
        char fmt_str[] = "%02x";
    6b66:	6818      	ldr	r0, [r3, #0]
    6b68:	791b      	ldrb	r3, [r3, #4]
    6b6a:	9002      	str	r0, [sp, #8]
    6b6c:	f88d 300c 	strb.w	r3, [sp, #12]
        if (param_expr_results_count>1){
    6b70:	dd0a      	ble.n	6b88 <calcSubFnc+0x17c>
            if (param_expr_results[param_expr_results_count-1]<=8){
    6b72:	ab2a      	add	r3, sp, #168	; 0xa8
    6b74:	eb03 0384 	add.w	r3, r3, r4, lsl #2
    6b78:	f853 3c90 	ldr.w	r3, [r3, #-144]
    6b7c:	2b08      	cmp	r3, #8
                fmt_str[2] = param_expr_results[param_expr_results_count-1]+'0';
    6b7e:	bfd4      	ite	le
    6b80:	3330      	addle	r3, #48	; 0x30
                fmt_str[2] = 8+'0';
    6b82:	2338      	movgt	r3, #56	; 0x38
    6b84:	f88d 300a 	strb.w	r3, [sp, #10]
        uint8_t temp_array[20] = {0};
    6b88:	2100      	movs	r1, #0
    6b8a:	2210      	movs	r2, #16
    6b8c:	a812      	add	r0, sp, #72	; 0x48
    6b8e:	9111      	str	r1, [sp, #68]	; 0x44
    6b90:	47b8      	blx	r7
        sprintf(temp_array, fmt_str, param_expr_results[0]);
    6b92:	9d07      	ldr	r5, [sp, #28]
    6b94:	a902      	add	r1, sp, #8
    6b96:	462a      	mov	r2, r5
    6b98:	4648      	mov	r0, r9
    6b9a:	47d0      	blx	sl
        if (param_expr_results_count>1){
    6b9c:	2c01      	cmp	r4, #1
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6b9e:	4a2d      	ldr	r2, [pc, #180]	; (6c54 <calcSubFnc+0x248>)
            temp_array_length = param_expr_results[param_expr_results_count-1];
    6ba0:	bfc4      	itt	gt
    6ba2:	ab2a      	addgt	r3, sp, #168	; 0xa8
    6ba4:	eb03 0484 	addgt.w	r4, r3, r4, lsl #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6ba8:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
            temp_array_length = param_expr_results[param_expr_results_count-1];
    6bac:	bfc8      	it	gt
    6bae:	f814 1c90 	ldrbgt.w	r1, [r4, #-144]
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6bb2:	b2d8      	uxtb	r0, r3
    6bb4:	f5c3 73fc 	rsb	r3, r3, #504	; 0x1f8
            temp_array_length = 2; // default print length
    6bb8:	bfd8      	it	le
    6bba:	2102      	movle	r1, #2
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6bbc:	3301      	adds	r3, #1
    6bbe:	1a5b      	subs	r3, r3, r1
    6bc0:	4413      	add	r3, r2
        for (uint8_t i=0; i<temp_array_length; i++){
    6bc2:	2400      	movs	r4, #0
    6bc4:	fa5f fc84 	uxtb.w	ip, r4
    6bc8:	458c      	cmp	ip, r1
    6bca:	d303      	bcc.n	6bd4 <calcSubFnc+0x1c8>
        expr->output_string_length += temp_array_length;
    6bcc:	4401      	add	r1, r0
    6bce:	f882 11fa 	strb.w	r1, [r2, #506]	; 0x1fa
    else if(strcmp(justName,"print")==0 || strcmp(justName,"p")==0 ){
    6bd2:	e7a9      	b.n	6b28 <calcSubFnc+0x11c>
            expr->output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-expr->output_string_length-temp_array_length+i] = temp_array[i];
    6bd4:	f819 c004 	ldrb.w	ip, [r9, r4]
    6bd8:	f803 cb01 	strb.w	ip, [r3], #1
        for (uint8_t i=0; i<temp_array_length; i++){
    6bdc:	3401      	adds	r4, #1
    6bde:	e7f1      	b.n	6bc4 <calcSubFnc+0x1b8>
    else if(strcmp(justName,"if")==0){
    6be0:	491d      	ldr	r1, [pc, #116]	; (6c58 <calcSubFnc+0x24c>)
    6be2:	4658      	mov	r0, fp
    6be4:	47a8      	blx	r5
    6be6:	b928      	cbnz	r0, 6bf4 <calcSubFnc+0x1e8>
        if (param_expr_results[0]){
    6be8:	9b07      	ldr	r3, [sp, #28]
    6bea:	b10b      	cbz	r3, 6bf0 <calcSubFnc+0x1e4>
            resultOfFnc = param_expr_results[1];
    6bec:	9d08      	ldr	r5, [sp, #32]
    6bee:	e79b      	b.n	6b28 <calcSubFnc+0x11c>
            resultOfFnc = param_expr_results[2];
    6bf0:	9d09      	ldr	r5, [sp, #36]	; 0x24
    6bf2:	e799      	b.n	6b28 <calcSubFnc+0x11c>
        printf("Function \"%s\" not found!\n", justName);
    6bf4:	4819      	ldr	r0, [pc, #100]	; (6c5c <calcSubFnc+0x250>)
    6bf6:	4b1a      	ldr	r3, [pc, #104]	; (6c60 <calcSubFnc+0x254>)
    6bf8:	4659      	mov	r1, fp
    6bfa:	4798      	blx	r3
        resultOfFnc = 0;
    6bfc:	2500      	movs	r5, #0
    6bfe:	e793      	b.n	6b28 <calcSubFnc+0x11c>
        resultOfFnc = 666666;
    6c00:	4d18      	ldr	r5, [pc, #96]	; (6c64 <calcSubFnc+0x258>)
    6c02:	e791      	b.n	6b28 <calcSubFnc+0x11c>
            char param_expr[20] = {0};
    6c04:	2300      	movs	r3, #0
    6c06:	4619      	mov	r1, r3
    6c08:	9311      	str	r3, [sp, #68]	; 0x44
    6c0a:	2210      	movs	r2, #16
    6c0c:	4b05      	ldr	r3, [pc, #20]	; (6c24 <calcSubFnc+0x218>)
    6c0e:	a812      	add	r0, sp, #72	; 0x48
    6c10:	4798      	blx	r3
            for (int j=0; j<commaoffset-i; j++){
    6c12:	9b01      	ldr	r3, [sp, #4]
    6c14:	2200      	movs	r2, #0
    6c16:	1b5d      	subs	r5, r3, r5
    6c18:	a911      	add	r1, sp, #68	; 0x44
    6c1a:	e770      	b.n	6afe <calcSubFnc+0xf2>
    6c1c:	000152d9 	.word	0x000152d9
    6c20:	00015317 	.word	0x00015317
    6c24:	00014d51 	.word	0x00014d51
    6c28:	000069e5 	.word	0x000069e5
    6c2c:	00006805 	.word	0x00006805
    6c30:	000167c4 	.word	0x000167c4
    6c34:	000152f3 	.word	0x000152f3
    6c38:	000167c8 	.word	0x000167c8
    6c3c:	000167cc 	.word	0x000167cc
    6c40:	000167f3 	.word	0x000167f3
    6c44:	000069a5 	.word	0x000069a5
    6c48:	000167d0 	.word	0x000167d0
    6c4c:	00017445 	.word	0x00017445
    6c50:	000167f8 	.word	0x000167f8
    6c54:	20013220 	.word	0x20013220
    6c58:	000167d6 	.word	0x000167d6
    6c5c:	000167d9 	.word	0x000167d9
    6c60:	00014eb1 	.word	0x00014eb1
    6c64:	000a2c2a 	.word	0x000a2c2a
    6c68:	00015299 	.word	0x00015299

00006c6c <char_is_valid_name>:


uint8_t char_is_valid_name(uint8_t ch){


    if ((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch == '_')){
    6c6c:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    6c70:	2b09      	cmp	r3, #9
    6c72:	d909      	bls.n	6c88 <char_is_valid_name+0x1c>
    6c74:	f020 0320 	bic.w	r3, r0, #32
    6c78:	3b41      	subs	r3, #65	; 0x41
    6c7a:	2b19      	cmp	r3, #25
    6c7c:	d904      	bls.n	6c88 <char_is_valid_name+0x1c>

                    return 1;
    6c7e:	f1a0 035f 	sub.w	r3, r0, #95	; 0x5f
    6c82:	4258      	negs	r0, r3
    6c84:	4158      	adcs	r0, r3
    6c86:	4770      	bx	lr
    6c88:	2001      	movs	r0, #1
                }
    
    return 0;


}
    6c8a:	4770      	bx	lr

00006c8c <subst_all_variables_starting_from_the_back>:


void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6c8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6c90:	ed2d 8b02 	vpush	{d8}
    uint8_t variable_name_valid = 0;
    

    int izgi = 0;
    int var_end_pos = -1;
    char var_name[10] = {0};
    6c94:	2200      	movs	r2, #0
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6c96:	b0a1      	sub	sp, #132	; 0x84
    char var_name[10] = {0};
    6c98:	e9cd 2201 	strd	r2, r2, [sp, #4]
    6c9c:	f8df a23c 	ldr.w	sl, [pc, #572]	; 6edc <subst_all_variables_starting_from_the_back+0x250>
    6ca0:	f8ad 200c 	strh.w	r2, [sp, #12]
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6ca4:	460d      	mov	r5, r1
    6ca6:	1846      	adds	r6, r0, r1
    int var_end_pos = -1;
    6ca8:	f04f 3bff 	mov.w	fp, #4294967295	; 0xffffffff
    uint8_t variable_name_found = 0;
    6cac:	4611      	mov	r1, r2
    uint8_t function_name_found = 0;
    6cae:	4691      	mov	r9, r2
    
    if (debug_level) printf("Subst Vars\r\n");
    
    // i must be signed int
    for(int i = len; i>=0; i--){
    6cb0:	2d00      	cmp	r5, #0
    6cb2:	da04      	bge.n	6cbe <subst_all_variables_starting_from_the_back+0x32>
    if (debug_level ==2) printf("i%d %d %d %d\r\n",i, function_name_found, variable_name_found, variable_name_valid);
    if (debug_level ==2) delay_ms(5);
        
    }
    
}
    6cb4:	b021      	add	sp, #132	; 0x84
    6cb6:	ecbd 8b02 	vpop	{d8}
    6cba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if (function_name_found){
    6cbe:	ee08 6a10 	vmov	s16, r6
    6cc2:	f816 4901 	ldrb.w	r4, [r6], #-1
    6cc6:	4620      	mov	r0, r4
    6cc8:	47d0      	blx	sl
    6cca:	f1b9 0f00 	cmp.w	r9, #0
    6cce:	d011      	beq.n	6cf4 <subst_all_variables_starting_from_the_back+0x68>
                function_name_found=0;
    6cd0:	f1b0 0900 	subs.w	r9, r0, #0
    6cd4:	bf18      	it	ne
    6cd6:	f04f 0901 	movne.w	r9, #1
        if (variable_name_found){
    6cda:	2900      	cmp	r1, #0
    6cdc:	d144      	bne.n	6d68 <subst_all_variables_starting_from_the_back+0xdc>
                for (int j = 0; j<10; j++){
    6cde:	2300      	movs	r3, #0
    6ce0:	aa01      	add	r2, sp, #4
                var_name[j] = 0;
    6ce2:	4619      	mov	r1, r3
            for (int j = 0; j<10; j++){
    6ce4:	3301      	adds	r3, #1
    6ce6:	2b0a      	cmp	r3, #10
                var_name[j] = 0;
    6ce8:	f802 1b01 	strb.w	r1, [r2], #1
            for (int j = 0; j<10; j++){
    6cec:	d1fa      	bne.n	6ce4 <subst_all_variables_starting_from_the_back+0x58>
            variable_name_valid = 0;
    6cee:	2200      	movs	r2, #0
            variable_name_found = 0;
    6cf0:	4611      	mov	r1, r2
    6cf2:	e04c      	b.n	6d8e <subst_all_variables_starting_from_the_back+0x102>
        else if (variable_name_found == 0){
    6cf4:	2900      	cmp	r1, #0
    6cf6:	d137      	bne.n	6d68 <subst_all_variables_starting_from_the_back+0xdc>
            if  (char_is_valid_name(expr_string[i])){
    6cf8:	2800      	cmp	r0, #0
    6cfa:	d0f0      	beq.n	6cde <subst_all_variables_starting_from_the_back+0x52>
                if (expr_string[i+1] == '('){
    6cfc:	78b3      	ldrb	r3, [r6, #2]
    6cfe:	2b28      	cmp	r3, #40	; 0x28
    6d00:	f000 80cd 	beq.w	6e9e <subst_all_variables_starting_from_the_back+0x212>
                    if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6d04:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
                        variable_name_valid = 1; 
    6d08:	2b09      	cmp	r3, #9
    6d0a:	bf88      	it	hi
    6d0c:	2201      	movhi	r2, #1
void subst_all_variables_starting_from_the_back(char* expr_string, int len){
    6d0e:	46ab      	mov	fp, r5
                var_name[var_end_pos-i] = expr_string[i];
    6d10:	ebab 0305 	sub.w	r3, fp, r5
    6d14:	a920      	add	r1, sp, #128	; 0x80
    6d16:	440b      	add	r3, r1
    6d18:	f803 4c7c 	strb.w	r4, [r3, #-124]
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6d1c:	3c30      	subs	r4, #48	; 0x30
    6d1e:	2c09      	cmp	r4, #9
    6d20:	d924      	bls.n	6d6c <subst_all_variables_starting_from_the_back+0xe0>
                if (i==0){
    6d22:	b125      	cbz	r5, 6d2e <subst_all_variables_starting_from_the_back+0xa2>
                    if (!char_is_valid_name(expr_string[i-1])){
    6d24:	7830      	ldrb	r0, [r6, #0]
    6d26:	47d0      	blx	sl
    6d28:	2800      	cmp	r0, #0
    6d2a:	f040 80b6 	bne.w	6e9a <subst_all_variables_starting_from_the_back+0x20e>
                    int var_name_len = strlen(var_name);
    6d2e:	4b5e      	ldr	r3, [pc, #376]	; (6ea8 <subst_all_variables_starting_from_the_back+0x21c>)
    6d30:	a801      	add	r0, sp, #4
    6d32:	4798      	blx	r3
                    char var_name_good[10] = {0};
    6d34:	2300      	movs	r3, #0
    6d36:	e9cd 3304 	strd	r3, r3, [sp, #16]
    6d3a:	aa01      	add	r2, sp, #4
                    int var_name_len = strlen(var_name);
    6d3c:	4680      	mov	r8, r0
                    char var_name_good[10] = {0};
    6d3e:	4402      	add	r2, r0
    6d40:	f8ad 3018 	strh.w	r3, [sp, #24]
                    for (int j = 0; j<var_name_len; j++){
    6d44:	a904      	add	r1, sp, #16
                        var_name_good[j+1] = 0;
    6d46:	4618      	mov	r0, r3
                    for (int j = 0; j<var_name_len; j++){
    6d48:	4543      	cmp	r3, r8
    6d4a:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
    6d4e:	db20      	blt.n	6d92 <subst_all_variables_starting_from_the_back+0x106>
                    if (var_name_len == 2 || var_name_len == 3){
    6d50:	f1a8 0302 	sub.w	r3, r8, #2
    6d54:	2b01      	cmp	r3, #1
    6d56:	d864      	bhi.n	6e22 <subst_all_variables_starting_from_the_back+0x196>
                        if (var_name_good[0] == 'T'){
    6d58:	f89d 3010 	ldrb.w	r3, [sp, #16]
    6d5c:	2b54      	cmp	r3, #84	; 0x54
    6d5e:	d15e      	bne.n	6e1e <subst_all_variables_starting_from_the_back+0x192>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6d60:	2301      	movs	r3, #1
                            uint8_t index = 0;
    6d62:	2200      	movs	r2, #0
                            uint8_t is_template_var = 1;
    6d64:	4618      	mov	r0, r3
    6d66:	e02d      	b.n	6dc4 <subst_all_variables_starting_from_the_back+0x138>
            if (char_is_valid_name(expr_string[i])){
    6d68:	2800      	cmp	r0, #0
    6d6a:	d1d1      	bne.n	6d10 <subst_all_variables_starting_from_the_back+0x84>
            if (variable_name_valid){
    6d6c:	2a00      	cmp	r2, #0
    6d6e:	d1d8      	bne.n	6d22 <subst_all_variables_starting_from_the_back+0x96>
    6d70:	2401      	movs	r4, #1
            if (!char_is_valid_name(expr_string[i])){
    6d72:	7870      	ldrb	r0, [r6, #1]
    6d74:	47d0      	blx	sl
    6d76:	4601      	mov	r1, r0
    6d78:	2800      	cmp	r0, #0
    6d7a:	f040 8093 	bne.w	6ea4 <subst_all_variables_starting_from_the_back+0x218>
    6d7e:	aa01      	add	r2, sp, #4
                for (int j = 0; j<10; j++){
    6d80:	4603      	mov	r3, r0
    6d82:	3301      	adds	r3, #1
    6d84:	2b0a      	cmp	r3, #10
                    var_name[j] = 0;
    6d86:	f802 0b01 	strb.w	r0, [r2], #1
                for (int j = 0; j<10; j++){
    6d8a:	d1fa      	bne.n	6d82 <subst_all_variables_starting_from_the_back+0xf6>
                variable_name_valid = 0;
    6d8c:	2200      	movs	r2, #0
    for(int i = len; i>=0; i--){
    6d8e:	3d01      	subs	r5, #1
    6d90:	e78e      	b.n	6cb0 <subst_all_variables_starting_from_the_back+0x24>
                        var_name_good[j] = var_name[var_name_len-1-j];
    6d92:	7814      	ldrb	r4, [r2, #0]
    6d94:	700c      	strb	r4, [r1, #0]
                        var_name_good[j+1] = 0;
    6d96:	3301      	adds	r3, #1
    6d98:	f801 0f01 	strb.w	r0, [r1, #1]!
                    for (int j = 0; j<var_name_len; j++){
    6d9c:	e7d4      	b.n	6d48 <subst_all_variables_starting_from_the_back+0xbc>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6d9e:	a920      	add	r1, sp, #128	; 0x80
    6da0:	4419      	add	r1, r3
                            for (uint8_t j = 1; j<var_name_len; j++){
    6da2:	3301      	adds	r3, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6da4:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6da8:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6dac:	2c09      	cmp	r4, #9
                                    index = index*10;
    6dae:	bf9f      	itttt	ls
    6db0:	eb02 0282 	addls.w	r2, r2, r2, lsl #2
    6db4:	eb01 0242 	addls.w	r2, r1, r2, lsl #1
                                    index += var_name_good[j] - '0'; 
    6db8:	3a30      	subls	r2, #48	; 0x30
    6dba:	f002 02ff 	andls.w	r2, r2, #255	; 0xff
                                    is_template_var = 0;
    6dbe:	bf88      	it	hi
    6dc0:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6dc2:	b2db      	uxtb	r3, r3
    6dc4:	4543      	cmp	r3, r8
    6dc6:	dbea      	blt.n	6d9e <subst_all_variables_starting_from_the_back+0x112>
                            if (is_template_var){
    6dc8:	b358      	cbz	r0, 6e22 <subst_all_variables_starting_from_the_back+0x196>
                                variable_value = grid_expr_state.current_event->parent->template_parameter_list[index];
    6dca:	4b38      	ldr	r3, [pc, #224]	; (6eac <subst_all_variables_starting_from_the_back+0x220>)
    6dcc:	681b      	ldr	r3, [r3, #0]
    6dce:	685b      	ldr	r3, [r3, #4]
    6dd0:	eb03 0282 	add.w	r2, r3, r2, lsl #2
    6dd4:	68d4      	ldr	r4, [r2, #12]
                    char buff[100] = {0};
    6dd6:	4b36      	ldr	r3, [pc, #216]	; (6eb0 <subst_all_variables_starting_from_the_back+0x224>)
    6dd8:	2700      	movs	r7, #0
    6dda:	2260      	movs	r2, #96	; 0x60
    6ddc:	4639      	mov	r1, r7
    6dde:	a808      	add	r0, sp, #32
    6de0:	9707      	str	r7, [sp, #28]
    6de2:	4798      	blx	r3
                    sprintf(buff,"%d",variable_value); // HEX para
    6de4:	4933      	ldr	r1, [pc, #204]	; (6eb4 <subst_all_variables_starting_from_the_back+0x228>)
    6de6:	4b34      	ldr	r3, [pc, #208]	; (6eb8 <subst_all_variables_starting_from_the_back+0x22c>)
    6de8:	4622      	mov	r2, r4
    6dea:	a807      	add	r0, sp, #28
    6dec:	4798      	blx	r3
                    insertTo(found,var_name_len,buff);
    6dee:	4b33      	ldr	r3, [pc, #204]	; (6ebc <subst_all_variables_starting_from_the_back+0x230>)
    6df0:	aa07      	add	r2, sp, #28
    6df2:	4641      	mov	r1, r8
    6df4:	ee18 0a10 	vmov	r0, s16
    6df8:	4798      	blx	r3
                    for (int j = 0; j<10; j++){
    6dfa:	ab01      	add	r3, sp, #4
                    insertTo(found,var_name_len,buff);
    6dfc:	461a      	mov	r2, r3
                        var_name[j] = 0;
    6dfe:	4639      	mov	r1, r7
                    for (int j = 0; j<10; j++){
    6e00:	3701      	adds	r7, #1
    6e02:	2f0a      	cmp	r7, #10
                        var_name[j] = 0;
    6e04:	f802 1b01 	strb.w	r1, [r2], #1
                    for (int j = 0; j<10; j++){
    6e08:	d1fa      	bne.n	6e00 <subst_all_variables_starting_from_the_back+0x174>
                    for (int j = 0; j<10; j++){
    6e0a:	2200      	movs	r2, #0
                        var_name[j] = 0;
    6e0c:	4611      	mov	r1, r2
                    for (int j = 0; j<10; j++){
    6e0e:	3201      	adds	r2, #1
    6e10:	2a0a      	cmp	r2, #10
                        var_name[j] = 0;
    6e12:	f803 1b01 	strb.w	r1, [r3], #1
                    for (int j = 0; j<10; j++){
    6e16:	d1fa      	bne.n	6e0e <subst_all_variables_starting_from_the_back+0x182>
                    variable_name_valid = 0;
    6e18:	2200      	movs	r2, #0
    6e1a:	4614      	mov	r4, r2
    6e1c:	e7a9      	b.n	6d72 <subst_all_variables_starting_from_the_back+0xe6>
                        else if (var_name_good[0] == 'Z'){
    6e1e:	2b5a      	cmp	r3, #90	; 0x5a
    6e20:	d01e      	beq.n	6e60 <subst_all_variables_starting_from_the_back+0x1d4>
                    int32_t variable_value = 1;
    6e22:	2401      	movs	r4, #1
    6e24:	e7d7      	b.n	6dd6 <subst_all_variables_starting_from_the_back+0x14a>
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6e26:	a920      	add	r1, sp, #128	; 0x80
    6e28:	4411      	add	r1, r2
                            for (uint8_t j = 1; j<var_name_len; j++){
    6e2a:	3201      	adds	r2, #1
                                if (var_name_good[j] >= '0' && var_name_good[j] <= '9' ){
    6e2c:	f811 1c70 	ldrb.w	r1, [r1, #-112]
    6e30:	f1a1 0430 	sub.w	r4, r1, #48	; 0x30
    6e34:	2c09      	cmp	r4, #9
                                    index = index*10;
    6e36:	bf9f      	itttt	ls
    6e38:	eb03 0383 	addls.w	r3, r3, r3, lsl #2
    6e3c:	eb01 0343 	addls.w	r3, r1, r3, lsl #1
                                    index += var_name_good[j] - '0'; 
    6e40:	3b30      	subls	r3, #48	; 0x30
    6e42:	f003 03ff 	andls.w	r3, r3, #255	; 0xff
                                    is_template_var = 0;
    6e46:	bf88      	it	hi
    6e48:	2000      	movhi	r0, #0
                            for (uint8_t j = 1; j<var_name_len; j++){
    6e4a:	b2d2      	uxtb	r2, r2
    6e4c:	4542      	cmp	r2, r8
    6e4e:	dbea      	blt.n	6e26 <subst_all_variables_starting_from_the_back+0x19a>
                            if (is_template_var){
    6e50:	2800      	cmp	r0, #0
    6e52:	d0e6      	beq.n	6e22 <subst_all_variables_starting_from_the_back+0x196>
                                if (index == 0){
    6e54:	b943      	cbnz	r3, 6e68 <subst_all_variables_starting_from_the_back+0x1dc>
                                    variable_value = grid_sys_get_bank_num(&grid_sys_state);
    6e56:	481a      	ldr	r0, [pc, #104]	; (6ec0 <subst_all_variables_starting_from_the_back+0x234>)
    6e58:	4b1a      	ldr	r3, [pc, #104]	; (6ec4 <subst_all_variables_starting_from_the_back+0x238>)
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6e5a:	4798      	blx	r3
    6e5c:	4604      	mov	r4, r0
    6e5e:	e7ba      	b.n	6dd6 <subst_all_variables_starting_from_the_back+0x14a>
                            for (uint8_t j = 1; j<var_name_len; j++){
    6e60:	2201      	movs	r2, #1
                            uint8_t index = 0;
    6e62:	2300      	movs	r3, #0
                            uint8_t is_template_var = 1;
    6e64:	4610      	mov	r0, r2
    6e66:	e7f1      	b.n	6e4c <subst_all_variables_starting_from_the_back+0x1c0>
                                else if (index == 1){
    6e68:	2b01      	cmp	r3, #1
    6e6a:	d102      	bne.n	6e72 <subst_all_variables_starting_from_the_back+0x1e6>
                                    variable_value = grid_sys_get_bank_red(&grid_sys_state);
    6e6c:	4814      	ldr	r0, [pc, #80]	; (6ec0 <subst_all_variables_starting_from_the_back+0x234>)
    6e6e:	4b16      	ldr	r3, [pc, #88]	; (6ec8 <subst_all_variables_starting_from_the_back+0x23c>)
    6e70:	e7f3      	b.n	6e5a <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 2){
    6e72:	2b02      	cmp	r3, #2
    6e74:	d102      	bne.n	6e7c <subst_all_variables_starting_from_the_back+0x1f0>
                                    variable_value = grid_sys_get_bank_gre(&grid_sys_state);
    6e76:	4812      	ldr	r0, [pc, #72]	; (6ec0 <subst_all_variables_starting_from_the_back+0x234>)
    6e78:	4b14      	ldr	r3, [pc, #80]	; (6ecc <subst_all_variables_starting_from_the_back+0x240>)
    6e7a:	e7ee      	b.n	6e5a <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 3){
    6e7c:	2b03      	cmp	r3, #3
    6e7e:	d102      	bne.n	6e86 <subst_all_variables_starting_from_the_back+0x1fa>
                                    variable_value = grid_sys_get_bank_blu(&grid_sys_state);
    6e80:	480f      	ldr	r0, [pc, #60]	; (6ec0 <subst_all_variables_starting_from_the_back+0x234>)
    6e82:	4b13      	ldr	r3, [pc, #76]	; (6ed0 <subst_all_variables_starting_from_the_back+0x244>)
    6e84:	e7e9      	b.n	6e5a <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 4){
    6e86:	2b04      	cmp	r3, #4
    6e88:	d102      	bne.n	6e90 <subst_all_variables_starting_from_the_back+0x204>
                                    variable_value = grid_sys_get_map_state(&grid_sys_state);
    6e8a:	480d      	ldr	r0, [pc, #52]	; (6ec0 <subst_all_variables_starting_from_the_back+0x234>)
    6e8c:	4b11      	ldr	r3, [pc, #68]	; (6ed4 <subst_all_variables_starting_from_the_back+0x248>)
    6e8e:	e7e4      	b.n	6e5a <subst_all_variables_starting_from_the_back+0x1ce>
                                else if (index == 5){
    6e90:	2b05      	cmp	r3, #5
    6e92:	d1c6      	bne.n	6e22 <subst_all_variables_starting_from_the_back+0x196>
                                    variable_value = grid_sys_get_bank_next(&grid_sys_state);
    6e94:	480a      	ldr	r0, [pc, #40]	; (6ec0 <subst_all_variables_starting_from_the_back+0x234>)
    6e96:	4b10      	ldr	r3, [pc, #64]	; (6ed8 <subst_all_variables_starting_from_the_back+0x24c>)
    6e98:	e7df      	b.n	6e5a <subst_all_variables_starting_from_the_back+0x1ce>
    6e9a:	2201      	movs	r2, #1
    6e9c:	e7bd      	b.n	6e1a <subst_all_variables_starting_from_the_back+0x18e>
                    function_name_found = 1;                    
    6e9e:	f04f 0901 	mov.w	r9, #1
    6ea2:	e71c      	b.n	6cde <subst_all_variables_starting_from_the_back+0x52>
    6ea4:	4621      	mov	r1, r4
    6ea6:	e772      	b.n	6d8e <subst_all_variables_starting_from_the_back+0x102>
    6ea8:	00015317 	.word	0x00015317
    6eac:	20013220 	.word	0x20013220
    6eb0:	00014d51 	.word	0x00014d51
    6eb4:	00016a17 	.word	0x00016a17
    6eb8:	00015299 	.word	0x00015299
    6ebc:	000069a5 	.word	0x000069a5
    6ec0:	2000f008 	.word	0x2000f008
    6ec4:	0000a017 	.word	0x0000a017
    6ec8:	0000a021 	.word	0x0000a021
    6ecc:	0000a027 	.word	0x0000a027
    6ed0:	0000a02d 	.word	0x0000a02d
    6ed4:	0000a033 	.word	0x0000a033
    6ed8:	0000a037 	.word	0x0000a037
    6edc:	00006c6d 	.word	0x00006c6d

00006ee0 <subst_all_functions_starting_from_the_back>:



void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6ee0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

    if (debug_level) printf("Subst Fncs in %s\r\n", expr_string);
    if (debug_level) delay_ms(5);
    
    uint8_t function_name_found = 0;
    uint8_t function_name_valid = 0;
    6ee4:	2200      	movs	r2, #0

            
        }
        else if (function_name_found){
            
            if (char_is_valid_name(expr_string[i])){
    6ee6:	f8df 8068 	ldr.w	r8, [pc, #104]	; 6f50 <subst_all_functions_starting_from_the_back+0x70>
                //printf("izgi=%d, i=%d\n", izgi, i);  
                
            }
            else if (function_name_valid){
                
                calcSubFnc(&expr_string[i+1]);
    6eea:	4f18      	ldr	r7, [pc, #96]	; (6f4c <subst_all_functions_starting_from_the_back+0x6c>)
    6eec:	1844      	adds	r4, r0, r1
void subst_all_functions_starting_from_the_back(char* expr_string, int len){
    6eee:	4605      	mov	r5, r0
    uint8_t function_name_found = 0;
    6ef0:	4611      	mov	r1, r2
    for(int i= len; i>=0; i--){
    6ef2:	ebb4 0a05 	subs.w	sl, r4, r5
    6ef6:	d501      	bpl.n	6efc <subst_all_functions_starting_from_the_back+0x1c>

        if (debug_level) printf("i%d %d %d\r\n",i, function_name_found, function_name_valid);
        if (debug_level) delay_ms(1);
    }
    
}
    6ef8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        if (expr_string[i] == '(' && function_name_valid == 0){
    6efc:	7826      	ldrb	r6, [r4, #0]
    6efe:	2e28      	cmp	r6, #40	; 0x28
    6f00:	d100      	bne.n	6f04 <subst_all_functions_starting_from_the_back+0x24>
    6f02:	b1e2      	cbz	r2, 6f3e <subst_all_functions_starting_from_the_back+0x5e>
        else if (function_name_found){
    6f04:	b1c9      	cbz	r1, 6f3a <subst_all_functions_starting_from_the_back+0x5a>
            if (char_is_valid_name(expr_string[i])){
    6f06:	4630      	mov	r0, r6
    6f08:	47c0      	blx	r8
    6f0a:	4681      	mov	r9, r0
    6f0c:	b158      	cbz	r0, 6f26 <subst_all_functions_starting_from_the_back+0x46>
                if ((expr_string[i] >= '0' && expr_string[i] <= '9')){
    6f0e:	3e30      	subs	r6, #48	; 0x30
    6f10:	2e09      	cmp	r6, #9
    6f12:	d816      	bhi.n	6f42 <subst_all_functions_starting_from_the_back+0x62>
                if (i==0 && function_name_valid){ // start of expr string special case
    6f14:	f1ba 0f00 	cmp.w	sl, #0
    6f18:	d10f      	bne.n	6f3a <subst_all_functions_starting_from_the_back+0x5a>
    6f1a:	b172      	cbz	r2, 6f3a <subst_all_functions_starting_from_the_back+0x5a>
                    calcSubFnc(&expr_string[i]);
    6f1c:	4620      	mov	r0, r4
    6f1e:	47b8      	blx	r7
                    function_name_valid = 0;
    6f20:	2200      	movs	r2, #0
                function_name_found = 0;
    6f22:	4611      	mov	r1, r2
    6f24:	e009      	b.n	6f3a <subst_all_functions_starting_from_the_back+0x5a>
            else if (function_name_valid){
    6f26:	2a00      	cmp	r2, #0
    6f28:	d0fb      	beq.n	6f22 <subst_all_functions_starting_from_the_back+0x42>
                calcSubFnc(&expr_string[i+1]);
    6f2a:	1c60      	adds	r0, r4, #1
    6f2c:	47b8      	blx	r7
                function_name_found = (expr_string[i] == '(');
    6f2e:	7821      	ldrb	r1, [r4, #0]
    6f30:	f1a1 0328 	sub.w	r3, r1, #40	; 0x28
    6f34:	4259      	negs	r1, r3
    6f36:	4159      	adcs	r1, r3
                function_name_valid = 0;
    6f38:	464a      	mov	r2, r9
    for(int i= len; i>=0; i--){
    6f3a:	3c01      	subs	r4, #1
    6f3c:	e7d9      	b.n	6ef2 <subst_all_functions_starting_from_the_back+0x12>
            function_name_found = 1;
    6f3e:	2101      	movs	r1, #1
    6f40:	e7fb      	b.n	6f3a <subst_all_functions_starting_from_the_back+0x5a>
                if (i==0 && function_name_valid){ // start of expr string special case
    6f42:	f1ba 0f00 	cmp.w	sl, #0
    6f46:	d0e9      	beq.n	6f1c <subst_all_functions_starting_from_the_back+0x3c>
                    function_name_valid = 1;
    6f48:	460a      	mov	r2, r1
    6f4a:	e7f6      	b.n	6f3a <subst_all_functions_starting_from_the_back+0x5a>
    6f4c:	00006a0d 	.word	0x00006a0d
    6f50:	00006c6d 	.word	0x00006c6d

00006f54 <grid_expr_evaluate>:
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6f54:	b573      	push	{r0, r1, r4, r5, r6, lr}
    grid_expr_clear_input(expr);
    6f56:	4b12      	ldr	r3, [pc, #72]	; (6fa0 <grid_expr_evaluate+0x4c>)
grid_expr_evaluate(struct grid_expr_model* expr, char* input_str, uint8_t input_length){
    6f58:	4604      	mov	r4, r0
    6f5a:	460e      	mov	r6, r1
    6f5c:	4611      	mov	r1, r2
    grid_expr_clear_input(expr);
    6f5e:	4798      	blx	r3
    grid_expr_clear_output(expr);
    6f60:	4b10      	ldr	r3, [pc, #64]	; (6fa4 <grid_expr_evaluate+0x50>)
    6f62:	4620      	mov	r0, r4
    6f64:	4798      	blx	r3
    for (uint32_t i=0; i<input_length; i++){
    6f66:	1d22      	adds	r2, r4, #4
    6f68:	2300      	movs	r3, #0
    6f6a:	4615      	mov	r5, r2
    6f6c:	4299      	cmp	r1, r3
    6f6e:	d811      	bhi.n	6f94 <grid_expr_evaluate+0x40>
    expr->input_string_length = input_length;
    6f70:	f884 10fe 	strb.w	r1, [r4, #254]	; 0xfe
    subst_all_variables_starting_from_the_back(expr->input_string, expr->input_string_length);    
    6f74:	4b0c      	ldr	r3, [pc, #48]	; (6fa8 <grid_expr_evaluate+0x54>)
    6f76:	4628      	mov	r0, r5
    6f78:	4798      	blx	r3
    subst_all_functions_starting_from_the_back(expr->input_string, expr->input_string_length);
    6f7a:	f894 10fe 	ldrb.w	r1, [r4, #254]	; 0xfe
    6f7e:	4b0b      	ldr	r3, [pc, #44]	; (6fac <grid_expr_evaluate+0x58>)
    6f80:	4628      	mov	r0, r5
    6f82:	4798      	blx	r3
    int result = expr_level_0(e);
    6f84:	4b0a      	ldr	r3, [pc, #40]	; (6fb0 <grid_expr_evaluate+0x5c>)
    6f86:	9501      	str	r5, [sp, #4]
    6f88:	a801      	add	r0, sp, #4
    6f8a:	4798      	blx	r3
    expr->return_value = result;
    6f8c:	f8c4 01fc 	str.w	r0, [r4, #508]	; 0x1fc
}
    6f90:	b002      	add	sp, #8
    6f92:	bd70      	pop	{r4, r5, r6, pc}
        expr->input_string[i] = input_str[i];
    6f94:	5cf0      	ldrb	r0, [r6, r3]
    6f96:	f802 0b01 	strb.w	r0, [r2], #1
    for (uint32_t i=0; i<input_length; i++){
    6f9a:	3301      	adds	r3, #1
    6f9c:	e7e6      	b.n	6f6c <grid_expr_evaluate+0x18>
    6f9e:	bf00      	nop
    6fa0:	00006779 	.word	0x00006779
    6fa4:	0000678d 	.word	0x0000678d
    6fa8:	00006c8d 	.word	0x00006c8d
    6fac:	00006ee1 	.word	0x00006ee1
    6fb0:	00006805 	.word	0x00006805

00006fb4 <_gpio_set_direction.constprop.0>:
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    6fb4:	01c0      	lsls	r0, r0, #7
    6fb6:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    6fba:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    6fbe:	b28b      	uxth	r3, r1
    6fc0:	6081      	str	r1, [r0, #8]
		    PORT, port, PORT_WRCONFIG_HWSEL | PORT_WRCONFIG_WRPINCFG | ((mask & 0xffff0000) >> 16));
    6fc2:	0c09      	lsrs	r1, r1, #16
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | (mask & 0xffff));
    6fc4:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
		hri_port_write_WRCONFIG_reg(
    6fc8:	f041 4140 	orr.w	r1, r1, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    6fcc:	6283      	str	r3, [r0, #40]	; 0x28
    6fce:	6281      	str	r1, [r0, #40]	; 0x28
}
    6fd0:	4770      	bx	lr
	...

00006fd4 <grid_hardwaretest_led_test_init>:
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    6fd4:	4b0f      	ldr	r3, [pc, #60]	; (7014 <grid_hardwaretest_led_test_init+0x40>)
    6fd6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
		
	}

}

void grid_hardwaretest_led_test_init(struct grid_led_model* mod, uint8_t num){
    6fda:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    6fde:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	
	gpio_set_pin_level(UI_PWR_EN, true);
	
	grid_led_lowlevel_init(mod, num);
    6fe2:	4b0d      	ldr	r3, [pc, #52]	; (7018 <grid_hardwaretest_led_test_init+0x44>)
	
	for(uint8_t i=0; i<num; i++){
		
		grid_led_lowlevel_set_color(mod, i, 0, 0, 0);
    6fe4:	f8df 8038 	ldr.w	r8, [pc, #56]	; 7020 <grid_hardwaretest_led_test_init+0x4c>
void grid_hardwaretest_led_test_init(struct grid_led_model* mod, uint8_t num){
    6fe8:	4606      	mov	r6, r0
    6fea:	460d      	mov	r5, r1
	grid_led_lowlevel_init(mod, num);
    6fec:	4798      	blx	r3
	for(uint8_t i=0; i<num; i++){
    6fee:	2400      	movs	r4, #0
		grid_led_lowlevel_set_color(mod, i, 0, 0, 0);
    6ff0:	4627      	mov	r7, r4
	for(uint8_t i=0; i<num; i++){
    6ff2:	42ac      	cmp	r4, r5
    6ff4:	d105      	bne.n	7002 <grid_hardwaretest_led_test_init+0x2e>
		
	}

	grid_led_hardware_transfer_done = 1;
    6ff6:	4b09      	ldr	r3, [pc, #36]	; (701c <grid_hardwaretest_led_test_init+0x48>)
    6ff8:	2201      	movs	r2, #1
    6ffa:	701a      	strb	r2, [r3, #0]
}
    6ffc:	b002      	add	sp, #8
    6ffe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		grid_led_lowlevel_set_color(mod, i, 0, 0, 0);
    7002:	2300      	movs	r3, #0
    7004:	4621      	mov	r1, r4
    7006:	9700      	str	r7, [sp, #0]
    7008:	461a      	mov	r2, r3
    700a:	4630      	mov	r0, r6
    700c:	47c0      	blx	r8
	for(uint8_t i=0; i<num; i++){
    700e:	3401      	adds	r4, #1
    7010:	e7ef      	b.n	6ff2 <grid_hardwaretest_led_test_init+0x1e>
    7012:	bf00      	nop
    7014:	41008000 	.word	0x41008000
    7018:	0000781d 	.word	0x0000781d
    701c:	2000914c 	.word	0x2000914c
    7020:	00007511 	.word	0x00007511

00007024 <grid_hardwaretest_led_test>:


void grid_hardwaretest_led_test(struct grid_led_model* mod, uint32_t loop){
    7024:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
		
		
	for(uint8_t i=0; i<mod->led_number; i++){
	
		grid_led_lowlevel_set_color(mod, i, loop/10%128*(loop/1280%3==0), loop/10%128*(loop/1280%3==1), loop/10%128*(loop/1280%3==2));
    7028:	f44f 63a0 	mov.w	r3, #1280	; 0x500
    702c:	240a      	movs	r4, #10
    702e:	fbb1 f4f4 	udiv	r4, r1, r4
    7032:	fbb1 f1f3 	udiv	r1, r1, r3
    7036:	2303      	movs	r3, #3
    7038:	fbb1 f3f3 	udiv	r3, r1, r3
    703c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    7040:	1ac9      	subs	r1, r1, r3
    7042:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    7046:	f101 33ff 	add.w	r3, r1, #4294967295	; 0xffffffff
    704a:	bf08      	it	eq
    704c:	46a0      	moveq	r8, r4
    704e:	f1a1 0202 	sub.w	r2, r1, #2
    7052:	bf18      	it	ne
    7054:	f04f 0800 	movne.w	r8, #0
    7058:	425f      	negs	r7, r3
    705a:	415f      	adcs	r7, r3
    705c:	4251      	negs	r1, r2
    705e:	4151      	adcs	r1, r2
    7060:	f8df 903c 	ldr.w	r9, [pc, #60]	; 70a0 <grid_hardwaretest_led_test+0x7c>
    7064:	4367      	muls	r7, r4
void grid_hardwaretest_led_test(struct grid_led_model* mod, uint32_t loop){
    7066:	4605      	mov	r5, r0
		grid_led_lowlevel_set_color(mod, i, loop/10%128*(loop/1280%3==0), loop/10%128*(loop/1280%3==1), loop/10%128*(loop/1280%3==2));
    7068:	434c      	muls	r4, r1
	for(uint8_t i=0; i<mod->led_number; i++){
    706a:	2600      	movs	r6, #0
    706c:	786b      	ldrb	r3, [r5, #1]
    706e:	b2f1      	uxtb	r1, r6
    7070:	428b      	cmp	r3, r1
    7072:	d80a      	bhi.n	708a <grid_hardwaretest_led_test+0x66>
		
		
	//grid_led_render_all(mod);
		
		
	while(grid_led_lowlevel_hardware_is_transfer_completed(mod) != 1){
    7074:	4c08      	ldr	r4, [pc, #32]	; (7098 <grid_hardwaretest_led_test+0x74>)
    7076:	4628      	mov	r0, r5
    7078:	47a0      	blx	r4
    707a:	2801      	cmp	r0, #1
    707c:	d1fb      	bne.n	7076 <grid_hardwaretest_led_test+0x52>
			
	}
	grid_led_lowlevel_hardware_start_transfer(mod);
    707e:	4b07      	ldr	r3, [pc, #28]	; (709c <grid_hardwaretest_led_test+0x78>)
    7080:	4628      	mov	r0, r5
	
}
    7082:	b003      	add	sp, #12
    7084:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	grid_led_lowlevel_hardware_start_transfer(mod);
    7088:	4718      	bx	r3
		grid_led_lowlevel_set_color(mod, i, loop/10%128*(loop/1280%3==0), loop/10%128*(loop/1280%3==1), loop/10%128*(loop/1280%3==2));
    708a:	9400      	str	r4, [sp, #0]
    708c:	463b      	mov	r3, r7
    708e:	4642      	mov	r2, r8
    7090:	4628      	mov	r0, r5
    7092:	47c8      	blx	r9
	for(uint8_t i=0; i<mod->led_number; i++){
    7094:	3601      	adds	r6, #1
    7096:	e7e9      	b.n	706c <grid_hardwaretest_led_test+0x48>
    7098:	000079cd 	.word	0x000079cd
    709c:	0000799d 	.word	0x0000799d
    70a0:	00007511 	.word	0x00007511

000070a4 <grid_hardwaretest_led_test_photo>:

void grid_hardwaretest_led_test_photo(struct grid_led_model* mod, uint32_t loop){
    70a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    70a8:	ed2d 8b04 	vpush	{d8-d9}

	uint8_t color_r[4] = {255, 127, 255, 0};
	uint8_t color_g[4] = {0, 255, 127, 127};
    70ac:	4b37      	ldr	r3, [pc, #220]	; (718c <grid_hardwaretest_led_test_photo+0xe8>)
    70ae:	4a38      	ldr	r2, [pc, #224]	; (7190 <grid_hardwaretest_led_test_photo+0xec>)
void grid_hardwaretest_led_test_photo(struct grid_led_model* mod, uint32_t loop){
    70b0:	b087      	sub	sp, #28
	uint8_t color_g[4] = {0, 255, 127, 127};
    70b2:	e9cd 2303 	strd	r2, r3, [sp, #12]
	uint8_t color_b[4] = {127, 127, 0, 255};
    70b6:	4b37      	ldr	r3, [pc, #220]	; (7194 <grid_hardwaretest_led_test_photo+0xf0>)
    70b8:	9305      	str	r3, [sp, #20]
void grid_hardwaretest_led_test_photo(struct grid_led_model* mod, uint32_t loop){
    70ba:	4604      	mov	r4, r0
	
	
	for(uint8_t i=0; i<mod->led_number; i++){
    70bc:	f04f 0a00 	mov.w	sl, #0
    70c0:	7863      	ldrb	r3, [r4, #1]
    70c2:	fa5f f98a 	uxtb.w	r9, sl
    70c6:	454b      	cmp	r3, r9
    70c8:	d80c      	bhi.n	70e4 <grid_hardwaretest_led_test_photo+0x40>
	
	
	//grid_led_render_all(mod);
	
	
	while(grid_led_lowlevel_hardware_is_transfer_completed(mod) != 1){
    70ca:	4d33      	ldr	r5, [pc, #204]	; (7198 <grid_hardwaretest_led_test_photo+0xf4>)
    70cc:	4620      	mov	r0, r4
    70ce:	47a8      	blx	r5
    70d0:	2801      	cmp	r0, #1
    70d2:	d1fb      	bne.n	70cc <grid_hardwaretest_led_test_photo+0x28>
		
	}
	grid_led_lowlevel_hardware_start_transfer(mod);
    70d4:	4b31      	ldr	r3, [pc, #196]	; (719c <grid_hardwaretest_led_test_photo+0xf8>)
    70d6:	4620      	mov	r0, r4
	
}
    70d8:	b007      	add	sp, #28
    70da:	ecbd 8b04 	vpop	{d8-d9}
    70de:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_led_lowlevel_hardware_start_transfer(mod);
    70e2:	4718      	bx	r3
		uint8_t intensity = (rand()%255)*(rand()%255)/256.0/2;
    70e4:	4e2e      	ldr	r6, [pc, #184]	; (71a0 <grid_hardwaretest_led_test_photo+0xfc>)
    70e6:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 71b8 <grid_hardwaretest_led_test_photo+0x114>
    70ea:	47b0      	blx	r6
    70ec:	4605      	mov	r5, r0
    70ee:	47b0      	blx	r6
    70f0:	23ff      	movs	r3, #255	; 0xff
    70f2:	fb95 f2f3 	sdiv	r2, r5, r3
    70f6:	fb90 f3f3 	sdiv	r3, r0, r3
    70fa:	ebc2 2202 	rsb	r2, r2, r2, lsl #8
    70fe:	ebc3 2303 	rsb	r3, r3, r3, lsl #8
    7102:	1aad      	subs	r5, r5, r2
    7104:	1ac0      	subs	r0, r0, r3
    7106:	4e27      	ldr	r6, [pc, #156]	; (71a4 <grid_hardwaretest_led_test_photo+0x100>)
    7108:	4368      	muls	r0, r5
    710a:	47b0      	blx	r6
    710c:	4d26      	ldr	r5, [pc, #152]	; (71a8 <grid_hardwaretest_led_test_photo+0x104>)
    710e:	4b27      	ldr	r3, [pc, #156]	; (71ac <grid_hardwaretest_led_test_photo+0x108>)
    7110:	2200      	movs	r2, #0
    7112:	47a8      	blx	r5
    7114:	4b26      	ldr	r3, [pc, #152]	; (71b0 <grid_hardwaretest_led_test_photo+0x10c>)
    7116:	2200      	movs	r2, #0
    7118:	47a8      	blx	r5
    711a:	47c0      	blx	r8
    711c:	b2c0      	uxtb	r0, r0
    711e:	28fa      	cmp	r0, #250	; 0xfa
    7120:	bf28      	it	cs
    7122:	20fa      	movcs	r0, #250	; 0xfa
		grid_led_lowlevel_set_color(mod, i, intensity/256.0*color_r[group], intensity/256.0*color_g[group], intensity/256.0*color_b[group]);
    7124:	2805      	cmp	r0, #5
    7126:	bf38      	it	cc
    7128:	2005      	movcc	r0, #5
    712a:	47b0      	blx	r6
    712c:	2200      	movs	r2, #0
    712e:	4b1f      	ldr	r3, [pc, #124]	; (71ac <grid_hardwaretest_led_test_photo+0x108>)
    7130:	47a8      	blx	r5
		uint8_t group = (i+4)%4;
    7132:	f009 0703 	and.w	r7, r9, #3
		grid_led_lowlevel_set_color(mod, i, intensity/256.0*color_r[group], intensity/256.0*color_g[group], intensity/256.0*color_b[group]);
    7136:	ab06      	add	r3, sp, #24
    7138:	441f      	add	r7, r3
    713a:	ec41 0b18 	vmov	d8, r0, r1
    713e:	f817 0c08 	ldrb.w	r0, [r7, #-8]
    7142:	47b0      	blx	r6
    7144:	ec53 2b18 	vmov	r2, r3, d8
    7148:	47a8      	blx	r5
    714a:	47c0      	blx	r8
    714c:	fa1f fb80 	uxth.w	fp, r0
    7150:	f817 0c0c 	ldrb.w	r0, [r7, #-12]
    7154:	47b0      	blx	r6
    7156:	ec53 2b18 	vmov	r2, r3, d8
    715a:	47a8      	blx	r5
    715c:	47c0      	blx	r8
    715e:	b283      	uxth	r3, r0
    7160:	f817 0c04 	ldrb.w	r0, [r7, #-4]
    7164:	ee09 3a10 	vmov	s18, r3
    7168:	47b0      	blx	r6
    716a:	ec53 2b18 	vmov	r2, r3, d8
    716e:	47a8      	blx	r5
    7170:	47c0      	blx	r8
    7172:	b280      	uxth	r0, r0
    7174:	9000      	str	r0, [sp, #0]
    7176:	ee19 2a10 	vmov	r2, s18
    717a:	4d0e      	ldr	r5, [pc, #56]	; (71b4 <grid_hardwaretest_led_test_photo+0x110>)
    717c:	465b      	mov	r3, fp
    717e:	4649      	mov	r1, r9
    7180:	4620      	mov	r0, r4
    7182:	47a8      	blx	r5
	for(uint8_t i=0; i<mod->led_number; i++){
    7184:	f10a 0a01 	add.w	sl, sl, #1
    7188:	e79a      	b.n	70c0 <grid_hardwaretest_led_test_photo+0x1c>
    718a:	bf00      	nop
    718c:	7f7fff00 	.word	0x7f7fff00
    7190:	00ff7fff 	.word	0x00ff7fff
    7194:	ff007f7f 	.word	0xff007f7f
    7198:	000079cd 	.word	0x000079cd
    719c:	0000799d 	.word	0x0000799d
    71a0:	00014ff5 	.word	0x00014ff5
    71a4:	000147a5 	.word	0x000147a5
    71a8:	00014879 	.word	0x00014879
    71ac:	3f700000 	.word	0x3f700000
    71b0:	3fe00000 	.word	0x3fe00000
    71b4:	00007511 	.word	0x00007511
    71b8:	00014c9d 	.word	0x00014c9d

000071bc <grid_hardwaretest_port_test>:


void grid_hardwaretest_port_test(uint32_t loop){
    71bc:	b538      	push	{r3, r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
    71be:	f44f 2180 	mov.w	r1, #262144	; 0x40000
    71c2:	4c6a      	ldr	r4, [pc, #424]	; (736c <grid_hardwaretest_port_test+0x1b0>)
    71c4:	4605      	mov	r5, r0
    71c6:	2002      	movs	r0, #2
    71c8:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    71ca:	4a69      	ldr	r2, [pc, #420]	; (7370 <grid_hardwaretest_port_test+0x1b4>)
    71cc:	f892 3152 	ldrb.w	r3, [r2, #338]	; 0x152
	tmp &= ~PORT_PINCFG_PMUXEN;
    71d0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    71d4:	f882 3152 	strb.w	r3, [r2, #338]	; 0x152
    71d8:	2180      	movs	r1, #128	; 0x80
    71da:	2001      	movs	r0, #1
    71dc:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    71de:	f892 30c7 	ldrb.w	r3, [r2, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
    71e2:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    71e6:	f882 30c7 	strb.w	r3, [r2, #199]	; 0xc7
    71ea:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
    71ee:	2002      	movs	r0, #2
    71f0:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    71f2:	f892 315b 	ldrb.w	r3, [r2, #347]	; 0x15b
	tmp &= ~PORT_PINCFG_PMUXEN;
    71f6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    71fa:	f882 315b 	strb.w	r3, [r2, #347]	; 0x15b
    71fe:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    7202:	2002      	movs	r0, #2
    7204:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    7206:	f892 315c 	ldrb.w	r3, [r2, #348]	; 0x15c
	tmp &= ~PORT_PINCFG_PMUXEN;
    720a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    720e:	f882 315c 	strb.w	r3, [r2, #348]	; 0x15c
    7212:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    7216:	2002      	movs	r0, #2
    7218:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    721a:	f892 3151 	ldrb.w	r3, [r2, #337]	; 0x151
	tmp &= ~PORT_PINCFG_PMUXEN;
    721e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    7222:	f882 3151 	strb.w	r3, [r2, #337]	; 0x151
    7226:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    722a:	2002      	movs	r0, #2
    722c:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    722e:	f892 3150 	ldrb.w	r3, [r2, #336]	; 0x150
	tmp &= ~PORT_PINCFG_PMUXEN;
    7232:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    7236:	f882 3150 	strb.w	r3, [r2, #336]	; 0x150
    723a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
    723e:	2002      	movs	r0, #2
    7240:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    7242:	f892 314d 	ldrb.w	r3, [r2, #333]	; 0x14d
	tmp &= ~PORT_PINCFG_PMUXEN;
    7246:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    724a:	f882 314d 	strb.w	r3, [r2, #333]	; 0x14d
    724e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    7252:	2002      	movs	r0, #2
    7254:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    7256:	f892 314c 	ldrb.w	r3, [r2, #332]	; 0x14c
	tmp &= ~PORT_PINCFG_PMUXEN;
    725a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    725e:	f882 314c 	strb.w	r3, [r2, #332]	; 0x14c
    7262:	f44f 7180 	mov.w	r1, #256	; 0x100
    7266:	2001      	movs	r0, #1
    7268:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    726a:	f892 30c8 	ldrb.w	r3, [r2, #200]	; 0xc8
	tmp &= ~PORT_PINCFG_PMUXEN;
    726e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    7272:	f882 30c8 	strb.w	r3, [r2, #200]	; 0xc8
    7276:	2001      	movs	r0, #1
    7278:	f44f 7100 	mov.w	r1, #512	; 0x200
    727c:	47a0      	blx	r4
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
    727e:	f892 30c9 	ldrb.w	r3, [r2, #201]	; 0xc9
	gpio_set_pin_direction(PB09, GPIO_DIRECTION_OUT);
	gpio_set_pin_function(PB09, GPIO_PIN_FUNCTION_OFF);
			

		
	if (loop%1000 == 0){
    7282:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
	tmp &= ~PORT_PINCFG_PMUXEN;
    7286:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
    728a:	f882 30c9 	strb.w	r3, [r2, #201]	; 0xc9
    728e:	fbb5 f3f0 	udiv	r3, r5, r0
    7292:	fb00 5013 	mls	r0, r0, r3, r5
    7296:	bb38      	cbnz	r0, 72e8 <grid_hardwaretest_port_test+0x12c>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7298:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    729c:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72a0:	2380      	movs	r3, #128	; 0x80
    72a2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    72a6:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    72aa:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72ae:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    72b2:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72b6:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    72ba:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72be:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    72c2:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72c6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    72ca:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72ce:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    72d2:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    72d6:	f44f 7380 	mov.w	r3, #256	; 0x100
    72da:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    72de:	f44f 7300 	mov.w	r3, #512	; 0x200
    72e2:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
	}
		

	
	
}
    72e6:	e008      	b.n	72fa <grid_hardwaretest_port_test+0x13e>
	if (loop%1000 == 250){
    72e8:	28fa      	cmp	r0, #250	; 0xfa
    72ea:	d007      	beq.n	72fc <grid_hardwaretest_port_test+0x140>
	if (loop%1000 == 500){
    72ec:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
    72f0:	d02c      	beq.n	734c <grid_hardwaretest_port_test+0x190>
	if (loop%1000 == 750){
    72f2:	f240 23ee 	movw	r3, #750	; 0x2ee
    72f6:	4298      	cmp	r0, r3
    72f8:	d030      	beq.n	735c <grid_hardwaretest_port_test+0x1a0>
}
    72fa:	bd38      	pop	{r3, r4, r5, pc}
    72fc:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    7300:	f8c2 3114 	str.w	r3, [r2, #276]	; 0x114
    7304:	2380      	movs	r3, #128	; 0x80
    7306:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    730a:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
    730e:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    7312:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    7316:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    731a:	f44f 3300 	mov.w	r3, #131072	; 0x20000
    731e:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    7322:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    7326:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    732a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    732e:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    7332:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    7336:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    733a:	f44f 7380 	mov.w	r3, #256	; 0x100
    733e:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    7342:	f44f 7300 	mov.w	r3, #512	; 0x200
    7346:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
	if (loop%1000 == 750){
    734a:	e7d6      	b.n	72fa <grid_hardwaretest_port_test+0x13e>
    734c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    7350:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    7354:	2380      	movs	r3, #128	; 0x80
    7356:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    735a:	e7d6      	b.n	730a <grid_hardwaretest_port_test+0x14e>
    735c:	f44f 2380 	mov.w	r3, #262144	; 0x40000
    7360:	f8c2 3118 	str.w	r3, [r2, #280]	; 0x118
    7364:	2380      	movs	r3, #128	; 0x80
    7366:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
    736a:	e79c      	b.n	72a6 <grid_hardwaretest_port_test+0xea>
    736c:	00006fb5 	.word	0x00006fb5
    7370:	41008000 	.word	0x41008000

00007374 <grid_hardwaretest_main>:
void grid_hardwaretest_main(){
    7374:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	printf("Hardware Test Init");
    7378:	4b51      	ldr	r3, [pc, #324]	; (74c0 <grid_hardwaretest_main+0x14c>)
	flash_erase(grid_nvm_state.flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    737a:	f8df a178 	ldr.w	sl, [pc, #376]	; 74f4 <grid_hardwaretest_main+0x180>
	printf("Hardware Test Init");
    737e:	4851      	ldr	r0, [pc, #324]	; (74c4 <grid_hardwaretest_main+0x150>)
	flash_erase(grid_nvm_state.flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    7380:	4f51      	ldr	r7, [pc, #324]	; (74c8 <grid_hardwaretest_main+0x154>)
void grid_hardwaretest_main(){
    7382:	b089      	sub	sp, #36	; 0x24
	printf("Hardware Test Init");
    7384:	4798      	blx	r3
	grid_hardwaretest_led_test_init(&grid_led_state, 16);
    7386:	4851      	ldr	r0, [pc, #324]	; (74cc <grid_hardwaretest_main+0x158>)
    7388:	4b51      	ldr	r3, [pc, #324]	; (74d0 <grid_hardwaretest_main+0x15c>)
    738a:	2110      	movs	r1, #16
    738c:	4798      	blx	r3
	flash_erase(grid_nvm_state.flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    738e:	f8da 0000 	ldr.w	r0, [sl]
    7392:	2201      	movs	r2, #1
    7394:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
    7398:	47b8      	blx	r7
	uint8_t clear_in_progress = 1;
    739a:	2501      	movs	r5, #1
    739c:	e9cd a703 	strd	sl, r7, [sp, #12]
	uint32_t clear_offset = 0;
    73a0:	2600      	movs	r6, #0
					grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    73a2:	4f4c      	ldr	r7, [pc, #304]	; (74d4 <grid_hardwaretest_main+0x160>)
	uint8_t button_last = 1;
    73a4:	9502      	str	r5, [sp, #8]
	uint8_t mode_changed = 1;
    73a6:	46a9      	mov	r9, r5
	uint8_t testmode = 1;
    73a8:	46a8      	mov	r8, r5
	uint32_t counter = 0;
    73aa:	4634      	mov	r4, r6
		if (clear_in_progress){
    73ac:	2d00      	cmp	r5, #0
    73ae:	d038      	beq.n	7422 <grid_hardwaretest_main+0xae>
			if (clear_offset < clear_max_offset){
    73b0:	f5b6 7f20 	cmp.w	r6, #640	; 0x280
    73b4:	d228      	bcs.n	7408 <grid_hardwaretest_main+0x94>
				flash_erase(grid_nvm_state.flash, GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*clear_offset, 1);
    73b6:	9b03      	ldr	r3, [sp, #12]
    73b8:	f506 6180 	add.w	r1, r6, #1024	; 0x400
    73bc:	6818      	ldr	r0, [r3, #0]
    73be:	9b04      	ldr	r3, [sp, #16]
    73c0:	2201      	movs	r2, #1
    73c2:	0249      	lsls	r1, r1, #9
    73c4:	4798      	blx	r3
				clear_offset++;
    73c6:	3601      	adds	r6, #1
			for(uint8_t i=0; i<grid_led_state.led_number; i++){
    73c8:	f8df a100 	ldr.w	sl, [pc, #256]	; 74cc <grid_hardwaretest_main+0x158>
    73cc:	f04f 0900 	mov.w	r9, #0
				grid_led_lowlevel_set_color(&grid_led_state, i, counter%64, counter%64, counter%64);
    73d0:	f004 033f 	and.w	r3, r4, #63	; 0x3f
			for(uint8_t i=0; i<grid_led_state.led_number; i++){
    73d4:	f89a 2001 	ldrb.w	r2, [sl, #1]
    73d8:	fa5f f189 	uxtb.w	r1, r9
    73dc:	428a      	cmp	r2, r1
    73de:	d815      	bhi.n	740c <grid_hardwaretest_main+0x98>
			while(grid_led_lowlevel_hardware_is_transfer_completed(&grid_led_state) != 1){
    73e0:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 74cc <grid_hardwaretest_main+0x158>
    73e4:	f8df 9110 	ldr.w	r9, [pc, #272]	; 74f8 <grid_hardwaretest_main+0x184>
    73e8:	4650      	mov	r0, sl
    73ea:	47c8      	blx	r9
    73ec:	2801      	cmp	r0, #1
    73ee:	d1fb      	bne.n	73e8 <grid_hardwaretest_main+0x74>
			grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
    73f0:	4836      	ldr	r0, [pc, #216]	; (74cc <grid_hardwaretest_main+0x158>)
    73f2:	4b39      	ldr	r3, [pc, #228]	; (74d8 <grid_hardwaretest_main+0x164>)
    73f4:	4798      	blx	r3
    73f6:	46c1      	mov	r9, r8
		delay_ms(1);
    73f8:	4b38      	ldr	r3, [pc, #224]	; (74dc <grid_hardwaretest_main+0x168>)
    73fa:	2001      	movs	r0, #1
		if (clear_in_progress){
    73fc:	46c8      	mov	r8, r9
		delay_ms(1);
    73fe:	4798      	blx	r3
		counter++;			
    7400:	3401      	adds	r4, #1
		mode_changed = 0;	
    7402:	f04f 0900 	mov.w	r9, #0
		if (clear_in_progress){
    7406:	e7d1      	b.n	73ac <grid_hardwaretest_main+0x38>
				clear_in_progress = 0;
    7408:	2500      	movs	r5, #0
    740a:	e7dd      	b.n	73c8 <grid_hardwaretest_main+0x54>
				grid_led_lowlevel_set_color(&grid_led_state, i, counter%64, counter%64, counter%64);
    740c:	9300      	str	r3, [sp, #0]
    740e:	461a      	mov	r2, r3
    7410:	f8df b0e8 	ldr.w	fp, [pc, #232]	; 74fc <grid_hardwaretest_main+0x188>
    7414:	9305      	str	r3, [sp, #20]
    7416:	4650      	mov	r0, sl
    7418:	47d8      	blx	fp
			for(uint8_t i=0; i<grid_led_state.led_number; i++){
    741a:	f109 0901 	add.w	r9, r9, #1
    741e:	9b05      	ldr	r3, [sp, #20]
    7420:	e7d8      	b.n	73d4 <grid_hardwaretest_main+0x60>
	CRITICAL_SECTION_ENTER();
    7422:	4b2f      	ldr	r3, [pc, #188]	; (74e0 <grid_hardwaretest_main+0x16c>)
    7424:	a807      	add	r0, sp, #28
    7426:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    7428:	4b2e      	ldr	r3, [pc, #184]	; (74e4 <grid_hardwaretest_main+0x170>)
    742a:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    742e:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    7432:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    7436:	ea82 0a03 	eor.w	sl, r2, r3
    743a:	ea0a 0a01 	and.w	sl, sl, r1
    743e:	ea8a 0a02 	eor.w	sl, sl, r2
	CRITICAL_SECTION_LEAVE();
    7442:	4b29      	ldr	r3, [pc, #164]	; (74e8 <grid_hardwaretest_main+0x174>)
    7444:	a807      	add	r0, sp, #28
    7446:	4798      	blx	r3
			if (gpio_get_pin_level(MAP_MODE) == 0){
    7448:	f41a 6f00 	tst.w	sl, #2048	; 0x800
    744c:	d118      	bne.n	7480 <grid_hardwaretest_main+0x10c>
				if (button_last == 1){
    744e:	9b02      	ldr	r3, [sp, #8]
    7450:	b1c3      	cbz	r3, 7484 <grid_hardwaretest_main+0x110>
					button_last=0;
    7452:	9502      	str	r5, [sp, #8]
			if (testmode == 0){
    7454:	f1b8 0f00 	cmp.w	r8, #0
    7458:	d11a      	bne.n	7490 <grid_hardwaretest_main+0x11c>
				grid_hardwaretest_port_test(counter);
    745a:	4b24      	ldr	r3, [pc, #144]	; (74ec <grid_hardwaretest_main+0x178>)
    745c:	4620      	mov	r0, r4
    745e:	4798      	blx	r3
				grid_hardwaretest_led_test(&grid_led_state, counter);	
    7460:	481a      	ldr	r0, [pc, #104]	; (74cc <grid_hardwaretest_main+0x158>)
    7462:	4b23      	ldr	r3, [pc, #140]	; (74f0 <grid_hardwaretest_main+0x17c>)
    7464:	4621      	mov	r1, r4
    7466:	4798      	blx	r3
    7468:	f04f 0901 	mov.w	r9, #1
    746c:	e7c4      	b.n	73f8 <grid_hardwaretest_main+0x84>
						grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    746e:	4621      	mov	r1, r4
    7470:	4640      	mov	r0, r8
    7472:	47b8      	blx	r7
						grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    7474:	4621      	mov	r1, r4
    7476:	4640      	mov	r0, r8
    7478:	47b8      	blx	r7
					for (uint8_t i=0; i<grid_sys_get_hwcfg()/4; i++){
    747a:	e015      	b.n	74a8 <grid_hardwaretest_main+0x134>
    747c:	464d      	mov	r5, r9
    747e:	e7bb      	b.n	73f8 <grid_hardwaretest_main+0x84>
				button_last = 1;
    7480:	2301      	movs	r3, #1
    7482:	9302      	str	r3, [sp, #8]
			if (testmode == 0){
    7484:	f1b8 0f00 	cmp.w	r8, #0
    7488:	d1e7      	bne.n	745a <grid_hardwaretest_main+0xe6>
				if (mode_changed){
    748a:	f1b9 0f00 	cmp.w	r9, #0
    748e:	d0f5      	beq.n	747c <grid_hardwaretest_main+0x108>
					grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    7490:	480e      	ldr	r0, [pc, #56]	; (74cc <grid_hardwaretest_main+0x158>)
					for (uint8_t i=0; i<grid_sys_get_hwcfg()/4; i++){
    7492:	f8df 906c 	ldr.w	r9, [pc, #108]	; 7500 <grid_hardwaretest_main+0x18c>
						grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    7496:	f8df 8034 	ldr.w	r8, [pc, #52]	; 74cc <grid_hardwaretest_main+0x158>
					grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    749a:	4621      	mov	r1, r4
    749c:	47b8      	blx	r7
					grid_hardwaretest_led_test_photo(&grid_led_state, counter);
    749e:	480b      	ldr	r0, [pc, #44]	; (74cc <grid_hardwaretest_main+0x158>)
    74a0:	4621      	mov	r1, r4
    74a2:	47b8      	blx	r7
					for (uint8_t i=0; i<grid_sys_get_hwcfg()/4; i++){
    74a4:	f04f 0a00 	mov.w	sl, #0
    74a8:	47c8      	blx	r9
    74aa:	fa5f fb8a 	uxtb.w	fp, sl
    74ae:	ebbb 0f90 	cmp.w	fp, r0, lsr #2
    74b2:	f10a 0a01 	add.w	sl, sl, #1
    74b6:	d3da      	bcc.n	746e <grid_hardwaretest_main+0xfa>
    74b8:	f04f 0900 	mov.w	r9, #0
    74bc:	e79c      	b.n	73f8 <grid_hardwaretest_main+0x84>
    74be:	bf00      	nop
    74c0:	00014eb1 	.word	0x00014eb1
    74c4:	000167fd 	.word	0x000167fd
    74c8:	0000f7dd 	.word	0x0000f7dd
    74cc:	2001c838 	.word	0x2001c838
    74d0:	00006fd5 	.word	0x00006fd5
    74d4:	000070a5 	.word	0x000070a5
    74d8:	0000799d 	.word	0x0000799d
    74dc:	0000e709 	.word	0x0000e709
    74e0:	00012485 	.word	0x00012485
    74e4:	41008000 	.word	0x41008000
    74e8:	00012493 	.word	0x00012493
    74ec:	000071bd 	.word	0x000071bd
    74f0:	00007025 	.word	0x00007025
    74f4:	2000fa1c 	.word	0x2000fa1c
    74f8:	000079cd 	.word	0x000079cd
    74fc:	00007511 	.word	0x00007511
    7500:	0000a1fd 	.word	0x0000a1fd

00007504 <grid_led_lowlevel_hardware_transfer_complete_cb>:


void grid_led_lowlevel_hardware_transfer_complete_cb(struct _dma_resource *resource){
	

	grid_led_hardware_transfer_done = 1;
    7504:	4b01      	ldr	r3, [pc, #4]	; (750c <grid_led_lowlevel_hardware_transfer_complete_cb+0x8>)
    7506:	2201      	movs	r2, #1
    7508:	701a      	strb	r2, [r3, #0]
	
	
}
    750a:	4770      	bx	lr
    750c:	2000914c 	.word	0x2000914c

00007510 <grid_led_lowlevel_set_color>:
uint8_t grid_led_lowlevel_set_color(struct grid_led_model* mod, uint32_t led_index, uint16_t led_r, uint16_t led_g, uint16_t led_b){
    7510:	b510      	push	{r4, lr}
	if (led_index<mod->led_number){
    7512:	7844      	ldrb	r4, [r0, #1]
    7514:	428c      	cmp	r4, r1
    7516:	d91c      	bls.n	7552 <grid_led_lowlevel_set_color+0x42>
		mod->led_frame_buffer_usable[led_index*3 + 0] = grid_led_color_code[led_g];
    7518:	2bff      	cmp	r3, #255	; 0xff
    751a:	f04f 040c 	mov.w	r4, #12
    751e:	fb04 f101 	mul.w	r1, r4, r1
    7522:	bf28      	it	cs
    7524:	23ff      	movcs	r3, #255	; 0xff
    7526:	4c0c      	ldr	r4, [pc, #48]	; (7558 <grid_led_lowlevel_set_color+0x48>)
    7528:	68c0      	ldr	r0, [r0, #12]
    752a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    752e:	5043      	str	r3, [r0, r1]
		mod->led_frame_buffer_usable[led_index*3 + 1] = grid_led_color_code[led_r];
    7530:	2aff      	cmp	r2, #255	; 0xff
    7532:	bf28      	it	cs
    7534:	22ff      	movcs	r2, #255	; 0xff
    7536:	4401      	add	r1, r0
    7538:	f854 3022 	ldr.w	r3, [r4, r2, lsl #2]
    753c:	604b      	str	r3, [r1, #4]
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    753e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    7542:	2bff      	cmp	r3, #255	; 0xff
    7544:	bf28      	it	cs
    7546:	23ff      	movcs	r3, #255	; 0xff
		return 0;
    7548:	2000      	movs	r0, #0
		mod->led_frame_buffer_usable[led_index*3 + 2] = grid_led_color_code[led_b];
    754a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
    754e:	608b      	str	r3, [r1, #8]
}
    7550:	bd10      	pop	{r4, pc}
		return -1;		
    7552:	20ff      	movs	r0, #255	; 0xff
    7554:	e7fc      	b.n	7550 <grid_led_lowlevel_set_color+0x40>
    7556:	bf00      	nop
    7558:	2000fe60 	.word	0x2000fe60

0000755c <grid_led_hardware_init>:


}


void grid_led_hardware_init(struct grid_led_model* mod){
    755c:	b510      	push	{r4, lr}
	
	spi_m_dma_get_io_descriptor(&GRID_LED, &mod->hardware_io_descriptor);
    755e:	4c06      	ldr	r4, [pc, #24]	; (7578 <grid_led_hardware_init+0x1c>)
    7560:	4b06      	ldr	r3, [pc, #24]	; (757c <grid_led_hardware_init+0x20>)
    7562:	f100 0114 	add.w	r1, r0, #20
    7566:	4620      	mov	r0, r4
    7568:	4798      	blx	r3
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    756a:	4620      	mov	r0, r4
    756c:	4a04      	ldr	r2, [pc, #16]	; (7580 <grid_led_hardware_init+0x24>)
    756e:	4b05      	ldr	r3, [pc, #20]	; (7584 <grid_led_hardware_init+0x28>)
	

		
}
    7570:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_dma_register_callback(&GRID_LED, SPI_M_DMA_CB_TX_DONE, grid_led_lowlevel_hardware_transfer_complete_cb);
    7574:	2100      	movs	r1, #0
    7576:	4718      	bx	r3
    7578:	2001ce54 	.word	0x2001ce54
    757c:	0000c361 	.word	0x0000c361
    7580:	00007505 	.word	0x00007505
    7584:	0000c32d 	.word	0x0000c32d

00007588 <grid_led_get_led_number>:

uint32_t grid_led_get_led_number(struct grid_led_model* mod){

	return mod->led_number;

}
    7588:	7840      	ldrb	r0, [r0, #1]
    758a:	4770      	bx	lr

0000758c <grid_led_tick>:

/** ================== ANIMATION ==================  */


void grid_led_tick(struct grid_led_model* mod){
    758c:	b5f0      	push	{r4, r5, r6, r7, lr}
	

	/** ATOMI - all phase registers must be updated  */
	for (uint8_t j=0; j<mod->led_number; j++){
    758e:	7846      	ldrb	r6, [r0, #1]
    7590:	eb06 0246 	add.w	r2, r6, r6, lsl #1
    7594:	eb06 0282 	add.w	r2, r6, r2, lsl #2
    7598:	2400      	movs	r4, #0
    759a:	270d      	movs	r7, #13
    759c:	b2e3      	uxtb	r3, r4
    759e:	429e      	cmp	r6, r3
    75a0:	d800      	bhi.n	75a4 <grid_led_tick+0x18>
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
		}	
	}
	/** END */
	
}
    75a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
    75a4:	6903      	ldr	r3, [r0, #16]
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    75a6:	2103      	movs	r1, #3
    75a8:	fb07 3304 	mla	r3, r7, r4, r3
    75ac:	7add      	ldrb	r5, [r3, #11]
    75ae:	f893 c00c 	ldrb.w	ip, [r3, #12]
    75b2:	3901      	subs	r1, #1
    75b4:	4465      	add	r5, ip
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    75b6:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
			mod->led_smart_buffer[j+(mod->led_number*layer)].pha += mod->led_smart_buffer[j+(mod->led_number*layer)].fre; //PHASE + = FREQUENCY		
    75ba:	72dd      	strb	r5, [r3, #11]
		for(uint8_t i=0; i<GRID_LED_LAYER_NUMBER; i++){
    75bc:	4413      	add	r3, r2
    75be:	d1f5      	bne.n	75ac <grid_led_tick+0x20>
	for (uint8_t j=0; j<mod->led_number; j++){
    75c0:	3401      	adds	r4, #1
    75c2:	e7eb      	b.n	759c <grid_led_tick+0x10>

000075c4 <grid_led_set_min>:
	grid_led_set_max(mod, num, layer, r, g, b);

}


void grid_led_set_min(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    75c4:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r = r;
    75c6:	7844      	ldrb	r4, [r0, #1]
    75c8:	6900      	ldr	r0, [r0, #16]
    75ca:	fb04 1202 	mla	r2, r4, r2, r1
    75ce:	240d      	movs	r4, #13
    75d0:	4362      	muls	r2, r4
    75d2:	1881      	adds	r1, r0, r2
    75d4:	5483      	strb	r3, [r0, r2]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g = g;
    75d6:	f89d 3008 	ldrb.w	r3, [sp, #8]
    75da:	704b      	strb	r3, [r1, #1]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b = b;	
    75dc:	f89d 300c 	ldrb.w	r3, [sp, #12]
    75e0:	708b      	strb	r3, [r1, #2]
}
    75e2:	bd10      	pop	{r4, pc}

000075e4 <grid_led_set_mid>:

void grid_led_set_mid(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    75e4:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.r = r;
    75e6:	7844      	ldrb	r4, [r0, #1]
    75e8:	fb04 1102 	mla	r1, r4, r2, r1
    75ec:	6902      	ldr	r2, [r0, #16]
    75ee:	200d      	movs	r0, #13
    75f0:	fb00 2201 	mla	r2, r0, r1, r2
    75f4:	70d3      	strb	r3, [r2, #3]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.g = g;
    75f6:	f89d 3008 	ldrb.w	r3, [sp, #8]
    75fa:	7113      	strb	r3, [r2, #4]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_mid.b = b;	
    75fc:	f89d 300c 	ldrb.w	r3, [sp, #12]
    7600:	7153      	strb	r3, [r2, #5]
}
    7602:	bd10      	pop	{r4, pc}

00007604 <grid_led_set_max>:

void grid_led_set_max(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    7604:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r = r;
    7606:	7844      	ldrb	r4, [r0, #1]
    7608:	fb04 1102 	mla	r1, r4, r2, r1
    760c:	6902      	ldr	r2, [r0, #16]
    760e:	200d      	movs	r0, #13
    7610:	fb00 2201 	mla	r2, r0, r1, r2
    7614:	7193      	strb	r3, [r2, #6]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g = g;
    7616:	f89d 3008 	ldrb.w	r3, [sp, #8]
    761a:	71d3      	strb	r3, [r2, #7]
	mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b = b;	
    761c:	f89d 300c 	ldrb.w	r3, [sp, #12]
    7620:	7213      	strb	r3, [r2, #8]
}
    7622:	bd10      	pop	{r4, pc}

00007624 <grid_led_set_color>:
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    7624:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    7628:	f89d 902c 	ldrb.w	r9, [sp, #44]	; 0x2c
    762c:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    7630:	f8df a058 	ldr.w	sl, [pc, #88]	; 768c <grid_led_set_color+0x68>
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    7634:	461c      	mov	r4, r3
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    7636:	2314      	movs	r3, #20
    7638:	fbb9 fcf3 	udiv	ip, r9, r3
    763c:	f8cd c004 	str.w	ip, [sp, #4]
    7640:	fbb8 fcf3 	udiv	ip, r8, r3
    7644:	fbb4 f3f3 	udiv	r3, r4, r3
    7648:	f8cd c000 	str.w	ip, [sp]
void grid_led_set_color(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t r, uint8_t g, uint8_t b){
    764c:	4605      	mov	r5, r0
    764e:	460e      	mov	r6, r1
    7650:	4617      	mov	r7, r2
	grid_led_set_min(mod, num, layer, r/20, g/20, b/20);				
    7652:	47d0      	blx	sl
	grid_led_set_mid(mod, num, layer, r/2, g/2, b/2);
    7654:	ea4f 0359 	mov.w	r3, r9, lsr #1
    7658:	9301      	str	r3, [sp, #4]
    765a:	ea4f 0358 	mov.w	r3, r8, lsr #1
    765e:	9300      	str	r3, [sp, #0]
    7660:	463a      	mov	r2, r7
    7662:	0863      	lsrs	r3, r4, #1
    7664:	4631      	mov	r1, r6
    7666:	4628      	mov	r0, r5
    7668:	f8df a024 	ldr.w	sl, [pc, #36]	; 7690 <grid_led_set_color+0x6c>
    766c:	47d0      	blx	sl
	grid_led_set_max(mod, num, layer, r, g, b);
    766e:	4623      	mov	r3, r4
    7670:	4c05      	ldr	r4, [pc, #20]	; (7688 <grid_led_set_color+0x64>)
    7672:	463a      	mov	r2, r7
    7674:	4631      	mov	r1, r6
    7676:	4628      	mov	r0, r5
    7678:	46a4      	mov	ip, r4
    767a:	e9cd 890a 	strd	r8, r9, [sp, #40]	; 0x28
}
    767e:	b002      	add	sp, #8
    7680:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_led_set_max(mod, num, layer, r, g, b);
    7684:	4760      	bx	ip
    7686:	bf00      	nop
    7688:	00007605 	.word	0x00007605
    768c:	000075c5 	.word	0x000075c5
    7690:	000075e5 	.word	0x000075e5

00007694 <grid_led_set_phase>:

void grid_led_set_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    7694:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].pha = val;
    7696:	7844      	ldrb	r4, [r0, #1]
    7698:	fb04 1102 	mla	r1, r4, r2, r1
    769c:	6902      	ldr	r2, [r0, #16]
    769e:	200d      	movs	r0, #13
    76a0:	fb00 2101 	mla	r1, r0, r1, r2
    76a4:	72cb      	strb	r3, [r1, #11]
}
    76a6:	bd10      	pop	{r4, pc}

000076a8 <grid_led_set_frequency>:
uint8_t grid_led_get_phase(struct grid_led_model* mod, uint8_t num, uint8_t layer){
	
	return mod->led_smart_buffer[num+(mod->led_number*layer)].pha;
}

void grid_led_set_frequency(struct grid_led_model* mod, uint8_t num, uint8_t layer, uint8_t val){
    76a8:	b510      	push	{r4, lr}
	
	mod->led_smart_buffer[num+(mod->led_number*layer)].fre = val;
    76aa:	7844      	ldrb	r4, [r0, #1]
    76ac:	fb04 1102 	mla	r1, r4, r2, r1
    76b0:	6902      	ldr	r2, [r0, #16]
    76b2:	200d      	movs	r0, #13
    76b4:	fb00 2101 	mla	r1, r0, r1, r2
    76b8:	730b      	strb	r3, [r1, #12]
}
    76ba:	bd10      	pop	{r4, pc}

000076bc <grid_led_buffer_init>:
void grid_led_buffer_init(struct grid_led_model* mod, uint32_t length){
    76bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    76c0:	4604      	mov	r4, r0
	mod->led_number = length;
    76c2:	7041      	strb	r1, [r0, #1]
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    76c4:	b2cd      	uxtb	r5, r1
    76c6:	200c      	movs	r0, #12
    76c8:	4368      	muls	r0, r5
    76ca:	3090      	adds	r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    76cc:	4f4c      	ldr	r7, [pc, #304]	; (7800 <grid_led_buffer_init+0x144>)
	mod->led_frame_buffer_size = (GRID_LED_RESET_LENGTH + mod->led_number*3*4);
    76ce:	6060      	str	r0, [r4, #4]
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    76d0:	47b8      	blx	r7
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    76d2:	f100 0390 	add.w	r3, r0, #144	; 0x90
	mod->led_frame_buffer = (uint8_t*) malloc(mod->led_frame_buffer_size * sizeof(uint8_t));
    76d6:	60a0      	str	r0, [r4, #8]
    76d8:	4606      	mov	r6, r0
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    76da:	2027      	movs	r0, #39	; 0x27
	mod->led_frame_buffer_usable = (uint32_t*) &mod->led_frame_buffer[GRID_LED_RESET_LENGTH];
    76dc:	60e3      	str	r3, [r4, #12]
	mod->led_smart_buffer = (struct LED_layer*) malloc(mod->led_number * GRID_LED_LAYER_NUMBER * sizeof(struct LED_layer));
    76de:	4368      	muls	r0, r5
    76e0:	47b8      	blx	r7
    76e2:	6120      	str	r0, [r4, #16]
	if(mod->led_frame_buffer==NULL || mod->led_smart_buffer==NULL){
    76e4:	b106      	cbz	r6, 76e8 <grid_led_buffer_init+0x2c>
    76e6:	b900      	cbnz	r0, 76ea <grid_led_buffer_init+0x2e>
		while(1){
    76e8:	e7fe      	b.n	76e8 <grid_led_buffer_init+0x2c>
    76ea:	2300      	movs	r3, #0
		mod->led_frame_buffer[i] = LED_CODE_R;
    76ec:	4619      	mov	r1, r3
    76ee:	68a2      	ldr	r2, [r4, #8]
    76f0:	54d1      	strb	r1, [r2, r3]
	for (uint8_t i = 0; i<GRID_LED_RESET_LENGTH; i++){
    76f2:	3301      	adds	r3, #1
    76f4:	2b90      	cmp	r3, #144	; 0x90
    76f6:	d1fa      	bne.n	76ee <grid_led_buffer_init+0x32>
	for (uint32_t i = 0; i<mod->led_number; i++){
    76f8:	2500      	movs	r5, #0
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    76fa:	4f42      	ldr	r7, [pc, #264]	; (7804 <grid_led_buffer_init+0x148>)
    76fc:	462e      	mov	r6, r5
	for (uint32_t i = 0; i<mod->led_number; i++){
    76fe:	7863      	ldrb	r3, [r4, #1]
    7700:	429d      	cmp	r5, r3
    7702:	d30c      	bcc.n	771e <grid_led_buffer_init+0x62>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    7704:	4d40      	ldr	r5, [pc, #256]	; (7808 <grid_led_buffer_init+0x14c>)
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    7706:	4e41      	ldr	r6, [pc, #260]	; (780c <grid_led_buffer_init+0x150>)
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    7708:	4f41      	ldr	r7, [pc, #260]	; (7810 <grid_led_buffer_init+0x154>)
    770a:	f04f 0b00 	mov.w	fp, #0
	for(uint8_t i = 0; i<mod->led_number; i++){
    770e:	7863      	ldrb	r3, [r4, #1]
    7710:	fa5f fa8b 	uxtb.w	sl, fp
    7714:	4553      	cmp	r3, sl
    7716:	d80a      	bhi.n	772e <grid_led_buffer_init+0x72>
}
    7718:	b003      	add	sp, #12
    771a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		grid_led_lowlevel_set_color(mod,i,0,0,0);
    771e:	2300      	movs	r3, #0
    7720:	4629      	mov	r1, r5
    7722:	9600      	str	r6, [sp, #0]
    7724:	461a      	mov	r2, r3
    7726:	4620      	mov	r0, r4
    7728:	47b8      	blx	r7
	for (uint32_t i = 0; i<mod->led_number; i++){
    772a:	3501      	adds	r5, #1
    772c:	e7e7      	b.n	76fe <grid_led_buffer_init+0x42>
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x00, 0x00);
    772e:	2300      	movs	r3, #0
    7730:	e9cd 3300 	strd	r3, r3, [sp]
    7734:	2201      	movs	r2, #1
    7736:	4651      	mov	r1, sl
    7738:	4620      	mov	r0, r4
    773a:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0x7F, 0x00);
    773c:	2300      	movs	r3, #0
    773e:	227f      	movs	r2, #127	; 0x7f
    7740:	e9cd 2300 	strd	r2, r3, [sp]
    7744:	4651      	mov	r1, sl
    7746:	2201      	movs	r2, #1
    7748:	4620      	mov	r0, r4
    774a:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_A, 0x00, 0xFF, 0x00);
    774c:	2300      	movs	r3, #0
    774e:	22ff      	movs	r2, #255	; 0xff
    7750:	e9cd 2300 	strd	r2, r3, [sp]
    7754:	4651      	mov	r1, sl
    7756:	2201      	movs	r2, #1
    7758:	4620      	mov	r0, r4
    775a:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    775c:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 7814 <grid_led_buffer_init+0x158>
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    7760:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 7818 <grid_led_buffer_init+0x15c>
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_A, 0);
    7764:	2300      	movs	r3, #0
    7766:	2201      	movs	r2, #1
    7768:	4651      	mov	r1, sl
    776a:	4620      	mov	r0, r4
    776c:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_A, 0);
    776e:	2300      	movs	r3, #0
    7770:	2201      	movs	r2, #1
    7772:	4651      	mov	r1, sl
    7774:	4620      	mov	r0, r4
    7776:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x00, 0x00);
    7778:	2300      	movs	r3, #0
    777a:	e9cd 3300 	strd	r3, r3, [sp]
    777e:	2202      	movs	r2, #2
    7780:	4651      	mov	r1, sl
    7782:	4620      	mov	r0, r4
    7784:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0x7F, 0x00);
    7786:	2300      	movs	r3, #0
    7788:	227f      	movs	r2, #127	; 0x7f
    778a:	e9cd 2300 	strd	r2, r3, [sp]
    778e:	4651      	mov	r1, sl
    7790:	2202      	movs	r2, #2
    7792:	4620      	mov	r0, r4
    7794:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_UI_B, 0x00, 0xFF, 0x00);
    7796:	2300      	movs	r3, #0
    7798:	22ff      	movs	r2, #255	; 0xff
    779a:	e9cd 2300 	strd	r2, r3, [sp]
    779e:	4651      	mov	r1, sl
    77a0:	2202      	movs	r2, #2
    77a2:	4620      	mov	r0, r4
    77a4:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_UI_B, 0);
    77a6:	2300      	movs	r3, #0
    77a8:	2202      	movs	r2, #2
    77aa:	4651      	mov	r1, sl
    77ac:	4620      	mov	r0, r4
    77ae:	47c8      	blx	r9
		grid_led_set_phase(mod,i, GRID_LED_LAYER_UI_B, 0);
    77b0:	2300      	movs	r3, #0
    77b2:	2202      	movs	r2, #2
    77b4:	4651      	mov	r1, sl
    77b6:	4620      	mov	r0, r4
    77b8:	47c0      	blx	r8
		grid_led_set_min(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    77ba:	2300      	movs	r3, #0
    77bc:	461a      	mov	r2, r3
    77be:	e9cd 3300 	strd	r3, r3, [sp]
    77c2:	4651      	mov	r1, sl
    77c4:	4620      	mov	r0, r4
    77c6:	47a8      	blx	r5
		grid_led_set_mid(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    77c8:	2300      	movs	r3, #0
    77ca:	461a      	mov	r2, r3
    77cc:	e9cd 3300 	strd	r3, r3, [sp]
    77d0:	4651      	mov	r1, sl
    77d2:	4620      	mov	r0, r4
    77d4:	47b0      	blx	r6
		grid_led_set_max(mod,i, GRID_LED_LAYER_ALERT, 0x00, 0x00, 0x00);
    77d6:	2300      	movs	r3, #0
    77d8:	461a      	mov	r2, r3
    77da:	e9cd 3300 	strd	r3, r3, [sp]
    77de:	4651      	mov	r1, sl
    77e0:	4620      	mov	r0, r4
    77e2:	47b8      	blx	r7
		grid_led_set_frequency(mod,i, GRID_LED_LAYER_ALERT, 0);
    77e4:	2300      	movs	r3, #0
    77e6:	461a      	mov	r2, r3
    77e8:	4651      	mov	r1, sl
    77ea:	4620      	mov	r0, r4
    77ec:	47c8      	blx	r9
		grid_led_set_phase(mod, i, GRID_LED_LAYER_ALERT, 0);
    77ee:	2300      	movs	r3, #0
    77f0:	461a      	mov	r2, r3
    77f2:	4651      	mov	r1, sl
    77f4:	4620      	mov	r0, r4
    77f6:	47c0      	blx	r8
	for(uint8_t i = 0; i<mod->led_number; i++){
    77f8:	f10b 0b01 	add.w	fp, fp, #1
    77fc:	e787      	b.n	770e <grid_led_buffer_init+0x52>
    77fe:	bf00      	nop
    7800:	00014d25 	.word	0x00014d25
    7804:	00007511 	.word	0x00007511
    7808:	000075c5 	.word	0x000075c5
    780c:	000075e5 	.word	0x000075e5
    7810:	00007605 	.word	0x00007605
    7814:	000076a9 	.word	0x000076a9
    7818:	00007695 	.word	0x00007695

0000781c <grid_led_lowlevel_init>:
uint8_t grid_led_lowlevel_init(struct grid_led_model* mod, uint8_t num){
    781c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    781e:	4e29      	ldr	r6, [pc, #164]	; (78c4 <grid_led_lowlevel_init+0xa8>)
	for(uint16_t i=0; i<256; i++){
    7820:	2300      	movs	r3, #0
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    7822:	f04f 6700 	mov.w	r7, #134217728	; 0x8000000
		temp |= (i/2%2)   ? (LED_CODE_O<<28) : (LED_CODE_Z<<28);
    7826:	f013 0f02 	tst.w	r3, #2
    782a:	bf0c      	ite	eq
    782c:	f04f 4500 	moveq.w	r5, #2147483648	; 0x80000000
    7830:	f04f 4560 	movne.w	r5, #3758096384	; 0xe0000000
		temp |= (i/4%2)   ? (LED_CODE_O<<16) : (LED_CODE_Z<<16);
    7834:	f013 0f04 	tst.w	r3, #4
    7838:	bf0c      	ite	eq
    783a:	f44f 2400 	moveq.w	r4, #524288	; 0x80000
    783e:	f44f 2460 	movne.w	r4, #917504	; 0xe0000
		temp |= (i/8%2)   ? (LED_CODE_O<<20) : (LED_CODE_Z<<20);
    7842:	f013 0f08 	tst.w	r3, #8
    7846:	ea45 0504 	orr.w	r5, r5, r4
    784a:	bf0c      	ite	eq
    784c:	f44f 0400 	moveq.w	r4, #8388608	; 0x800000
    7850:	f44f 0460 	movne.w	r4, #14680064	; 0xe00000
		temp |= (i/16%2)  ? (LED_CODE_O<<8)  : (LED_CODE_Z<<8);
    7854:	f013 0f10 	tst.w	r3, #16
    7858:	ea45 0504 	orr.w	r5, r5, r4
    785c:	bf0c      	ite	eq
    785e:	f44f 6400 	moveq.w	r4, #2048	; 0x800
    7862:	f44f 6460 	movne.w	r4, #3584	; 0xe00
		temp |= (i/32%2)  ? (LED_CODE_O<<12) : (LED_CODE_Z<<12);
    7866:	f013 0f20 	tst.w	r3, #32
    786a:	bf0c      	ite	eq
    786c:	f44f 4200 	moveq.w	r2, #32768	; 0x8000
    7870:	f44f 4260 	movne.w	r2, #57344	; 0xe000
    7874:	432c      	orrs	r4, r5
		temp |= (i/64%2)  ? (LED_CODE_O<<0)  : (LED_CODE_Z<<0);
    7876:	f013 0f40 	tst.w	r3, #64	; 0x40
    787a:	ea44 0402 	orr.w	r4, r4, r2
    787e:	bf0c      	ite	eq
    7880:	2208      	moveq	r2, #8
    7882:	220e      	movne	r2, #14
    7884:	4314      	orrs	r4, r2
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    7886:	09da      	lsrs	r2, r3, #7
    7888:	bf14      	ite	ne
    788a:	22e0      	movne	r2, #224	; 0xe0
    788c:	2280      	moveq	r2, #128	; 0x80
	for(uint16_t i=0; i<256; i++){
    788e:	3301      	adds	r3, #1
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    7890:	4322      	orrs	r2, r4
	for(uint16_t i=0; i<256; i++){
    7892:	b29b      	uxth	r3, r3
		temp |= (i/128%2) ? (LED_CODE_O<<4)  : (LED_CODE_Z<<4);
    7894:	433a      	orrs	r2, r7
	for(uint16_t i=0; i<256; i++){
    7896:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
		grid_led_color_code[i] = temp;
    789a:	f846 2b04 	str.w	r2, [r6], #4
	for(uint16_t i=0; i<256; i++){
    789e:	d108      	bne.n	78b2 <grid_led_lowlevel_init+0x96>
	grid_led_buffer_init(mod, num);		
    78a0:	4b09      	ldr	r3, [pc, #36]	; (78c8 <grid_led_lowlevel_init+0xac>)
    78a2:	9001      	str	r0, [sp, #4]
    78a4:	4798      	blx	r3
	grid_led_hardware_init(mod);
    78a6:	9801      	ldr	r0, [sp, #4]
    78a8:	4b08      	ldr	r3, [pc, #32]	; (78cc <grid_led_lowlevel_init+0xb0>)
    78aa:	4798      	blx	r3
}
    78ac:	2000      	movs	r0, #0
    78ae:	b003      	add	sp, #12
    78b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		temp |= (i/1%2)   ? (LED_CODE_O<<24) : (LED_CODE_Z<<24);
    78b2:	f013 0f01 	tst.w	r3, #1
    78b6:	bf14      	ite	ne
    78b8:	f04f 6760 	movne.w	r7, #234881024	; 0xe000000
    78bc:	f04f 6700 	moveq.w	r7, #134217728	; 0x8000000
    78c0:	e7b1      	b.n	7826 <grid_led_lowlevel_init+0xa>
    78c2:	bf00      	nop
    78c4:	2000fe60 	.word	0x2000fe60
    78c8:	000076bd 	.word	0x000076bd
    78cc:	0000755d 	.word	0x0000755d

000078d0 <grid_led_lowlevel_render>:


void grid_led_lowlevel_render(struct grid_led_model* mod, uint32_t num){
    78d0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    78d4:	7847      	ldrb	r7, [r0, #1]
		uint8_t layer = i;
				
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
		uint8_t min_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.g;
		uint8_t min_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.b;
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    78d6:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 7978 <grid_led_lowlevel_render+0xa8>
    78da:	eb07 0347 	add.w	r3, r7, r7, lsl #1
    78de:	eb07 0783 	add.w	r7, r7, r3, lsl #2
    78e2:	6903      	ldr	r3, [r0, #16]
	uint32_t mix_b = 0;
    78e4:	2500      	movs	r5, #0
    78e6:	240d      	movs	r4, #13
    78e8:	fb04 3401 	mla	r4, r4, r1, r3
		uint8_t min_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_min.r;
    78ec:	2603      	movs	r6, #3
	uint32_t mix_g = 0;
    78ee:	462b      	mov	r3, r5
	uint32_t mix_r = 0;
    78f0:	462a      	mov	r2, r5
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    78f2:	f894 900b 	ldrb.w	r9, [r4, #11]
		uint8_t max_r = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.r;
		uint8_t max_g = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.g;
		uint8_t max_b = mod->led_smart_buffer[num+(mod->led_number*layer)].color_max.b;
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
				
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    78f6:	f894 b003 	ldrb.w	fp, [r4, #3]
		uint8_t min_a = min_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    78fa:	f818 e009 	ldrb.w	lr, [r8, r9]
		uint8_t mid_a = mid_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    78fe:	44c1      	add	r9, r8
    7900:	3e01      	subs	r6, #1
    7902:	f899 a100 	ldrb.w	sl, [r9, #256]	; 0x100
		uint8_t max_a = max_lookup[mod->led_smart_buffer[num+(mod->led_number*layer)].pha];
    7906:	f899 c200 	ldrb.w	ip, [r9, #512]	; 0x200
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    790a:	f894 9000 	ldrb.w	r9, [r4]
    790e:	fb1b fb0a 	smulbb	fp, fp, sl
    7912:	fb09 bb0e 	mla	fp, r9, lr, fp
    7916:	f894 9006 	ldrb.w	r9, [r4, #6]
    791a:	fb09 b90c 	mla	r9, r9, ip, fp
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    791e:	f894 b004 	ldrb.w	fp, [r4, #4]
		mix_r += min_r*min_a + mid_r*mid_a + max_r*max_a;
    7922:	444a      	add	r2, r9
		mix_g += min_g*min_a + mid_g*mid_a + max_g*max_a;
    7924:	f894 9001 	ldrb.w	r9, [r4, #1]
    7928:	fb1b fb0a 	smulbb	fp, fp, sl
    792c:	fb09 bb0e 	mla	fp, r9, lr, fp
    7930:	f894 9007 	ldrb.w	r9, [r4, #7]
    7934:	fb09 b90c 	mla	r9, r9, ip, fp
    7938:	444b      	add	r3, r9
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    793a:	f894 9005 	ldrb.w	r9, [r4, #5]
    793e:	f894 b002 	ldrb.w	fp, [r4, #2]
    7942:	fb19 f90a 	smulbb	r9, r9, sl
    7946:	fb0b 9e0e 	mla	lr, fp, lr, r9
    794a:	f894 9008 	ldrb.w	r9, [r4, #8]
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    794e:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
		mix_b += min_b*min_a + mid_b*mid_a + max_b*max_a;
    7952:	fb09 ec0c 	mla	ip, r9, ip, lr
    7956:	4465      	add	r5, ip
	for (uint8_t i = 0; i<GRID_LED_LAYER_NUMBER; i++){
    7958:	443c      	add	r4, r7
    795a:	d1ca      	bne.n	78f2 <grid_led_lowlevel_render+0x22>

	mix_r = (mix_r)/2/256;
	mix_g = (mix_g)/2/256;
	mix_b = (mix_b)/2/256;
				
	grid_led_lowlevel_set_color(mod, num, mix_r, mix_g, mix_b);
    795c:	f3c5 254f 	ubfx	r5, r5, #9, #16
    7960:	4c04      	ldr	r4, [pc, #16]	; (7974 <grid_led_lowlevel_render+0xa4>)
    7962:	9500      	str	r5, [sp, #0]
    7964:	f3c3 234f 	ubfx	r3, r3, #9, #16
    7968:	f3c2 224f 	ubfx	r2, r2, #9, #16
    796c:	47a0      	blx	r4
	
}
    796e:	b003      	add	sp, #12
    7970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7974:	00007511 	.word	0x00007511
    7978:	20000008 	.word	0x20000008

0000797c <grid_led_lowlevel_render_all>:


void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    797c:	b570      	push	{r4, r5, r6, lr}
	
	for (uint32_t i=0; i<mod->led_number; i++){
		
		grid_led_lowlevel_render(mod, i);
    797e:	4e06      	ldr	r6, [pc, #24]	; (7998 <grid_led_lowlevel_render_all+0x1c>)
void grid_led_lowlevel_render_all(struct grid_led_model* mod){
    7980:	4605      	mov	r5, r0
	for (uint32_t i=0; i<mod->led_number; i++){
    7982:	2400      	movs	r4, #0
    7984:	786b      	ldrb	r3, [r5, #1]
    7986:	42a3      	cmp	r3, r4
    7988:	d800      	bhi.n	798c <grid_led_lowlevel_render_all+0x10>
	}
	
}
    798a:	bd70      	pop	{r4, r5, r6, pc}
		grid_led_lowlevel_render(mod, i);
    798c:	4621      	mov	r1, r4
    798e:	4628      	mov	r0, r5
    7990:	47b0      	blx	r6
	for (uint32_t i=0; i<mod->led_number; i++){
    7992:	3401      	adds	r4, #1
    7994:	e7f6      	b.n	7984 <grid_led_lowlevel_render_all+0x8>
    7996:	bf00      	nop
    7998:	000078d1 	.word	0x000078d1

0000799c <grid_led_lowlevel_hardware_start_transfer>:
			
	}
	
}

void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    799c:	b510      	push	{r4, lr}
	
	// SEND DATA TO LEDs
	grid_led_hardware_transfer_done = 0;
    799e:	4b07      	ldr	r3, [pc, #28]	; (79bc <grid_led_lowlevel_hardware_start_transfer+0x20>)
void grid_led_lowlevel_hardware_start_transfer (struct grid_led_model* mod){
    79a0:	4604      	mov	r4, r0
	grid_led_hardware_transfer_done = 0;
    79a2:	2200      	movs	r2, #0
    79a4:	701a      	strb	r2, [r3, #0]
	spi_m_dma_enable(&GRID_LED);
    79a6:	4806      	ldr	r0, [pc, #24]	; (79c0 <grid_led_lowlevel_hardware_start_transfer+0x24>)
    79a8:	4b06      	ldr	r3, [pc, #24]	; (79c4 <grid_led_lowlevel_hardware_start_transfer+0x28>)
    79aa:	4798      	blx	r3
			
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    79ac:	88a2      	ldrh	r2, [r4, #4]
    79ae:	68a1      	ldr	r1, [r4, #8]
    79b0:	6960      	ldr	r0, [r4, #20]
    79b2:	4b05      	ldr	r3, [pc, #20]	; (79c8 <grid_led_lowlevel_hardware_start_transfer+0x2c>)

}
    79b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	io_write(mod->hardware_io_descriptor, grid_led_lowlevel_get_frame_buffer_pointer(mod), grid_led_lowlevel_get_frame_buffer_size(mod));
    79b8:	4718      	bx	r3
    79ba:	bf00      	nop
    79bc:	2000914c 	.word	0x2000914c
    79c0:	2001ce54 	.word	0x2001ce54
    79c4:	0000c305 	.word	0x0000c305
    79c8:	0000b9fd 	.word	0x0000b9fd

000079cc <grid_led_lowlevel_hardware_is_transfer_completed>:

uint8_t grid_led_lowlevel_hardware_is_transfer_completed(struct grid_led_model* mod){
	

	return grid_led_hardware_transfer_done;
    79cc:	4b01      	ldr	r3, [pc, #4]	; (79d4 <grid_led_lowlevel_hardware_is_transfer_completed+0x8>)
    79ce:	7818      	ldrb	r0, [r3, #0]
	
    79d0:	4770      	bx	lr
    79d2:	bf00      	nop
    79d4:	2000914c 	.word	0x2000914c

000079d8 <grid_module_common_init>:

	
/* ============================== GRID_MODULE_INIT() ================================ */


void grid_module_common_init(void){
    79d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	grid_ui_model_init(&grid_core_state, 1);
    79dc:	4d70      	ldr	r5, [pc, #448]	; (7ba0 <grid_module_common_init+0x1c8>)
    79de:	4b71      	ldr	r3, [pc, #452]	; (7ba4 <grid_module_common_init+0x1cc>)
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
	
		
	if (1){	// INIT CORE_STATE->hearbeat	
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    79e0:	f8df 9240 	ldr.w	r9, [pc, #576]	; 7c24 <grid_module_common_init+0x24c>
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
		payload_length = strlen(payload_template);
    79e4:	f8df 8240 	ldr.w	r8, [pc, #576]	; 7c28 <grid_module_common_init+0x250>
	
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    79e8:	4f6f      	ldr	r7, [pc, #444]	; (7ba8 <grid_module_common_init+0x1d0>)
		uint8_t error = 0;
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    79ea:	f8df a240 	ldr.w	sl, [pc, #576]	; 7c2c <grid_module_common_init+0x254>
void grid_module_common_init(void){
    79ee:	b0a5      	sub	sp, #148	; 0x94
	grid_ui_model_init(&grid_core_state, 1);
    79f0:	4628      	mov	r0, r5
    79f2:	2101      	movs	r1, #1
    79f4:	4798      	blx	r3
	grid_ui_bank_init(&grid_core_state, 0, 1);
    79f6:	4628      	mov	r0, r5
    79f8:	4b6c      	ldr	r3, [pc, #432]	; (7bac <grid_module_common_init+0x1d4>)
    79fa:	2201      	movs	r2, #1
    79fc:	2100      	movs	r1, #0
    79fe:	4798      	blx	r3
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    7a00:	2200      	movs	r2, #0
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7a02:	2400      	movs	r4, #0
	grid_ui_element_init(&grid_core_state.bank_list[0], 0, GRID_UI_ELEMENT_SYSTEM);
    7a04:	6868      	ldr	r0, [r5, #4]
    7a06:	4b6a      	ldr	r3, [pc, #424]	; (7bb0 <grid_module_common_init+0x1d8>)
    7a08:	4611      	mov	r1, r2
    7a0a:	4798      	blx	r3
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7a0c:	227e      	movs	r2, #126	; 0x7e
    7a0e:	4621      	mov	r1, r4
    7a10:	a804      	add	r0, sp, #16
    7a12:	9403      	str	r4, [sp, #12]
    7a14:	47c8      	blx	r9
		sprintf(payload_template, GRID_EVENTSTRING_HEARTBEAT );
    7a16:	4967      	ldr	r1, [pc, #412]	; (7bb4 <grid_module_common_init+0x1dc>)
    7a18:	4b67      	ldr	r3, [pc, #412]	; (7bb8 <grid_module_common_init+0x1e0>)
    7a1a:	a803      	add	r0, sp, #12
    7a1c:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7a1e:	a803      	add	r0, sp, #12
    7a20:	47c0      	blx	r8
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    7a22:	aa03      	add	r2, sp, #12
    7a24:	1816      	adds	r6, r2, r0
    7a26:	2303      	movs	r3, #3
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7a28:	f10d 0b0b 	add.w	fp, sp, #11
		sprintf(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_frame);
    7a2c:	4963      	ldr	r1, [pc, #396]	; (7bbc <grid_module_common_init+0x1e4>)
    7a2e:	9300      	str	r3, [sp, #0]
    7a30:	2202      	movs	r2, #2
    7a32:	2310      	movs	r3, #16
    7a34:	4630      	mov	r0, r6
    7a36:	47b8      	blx	r7
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7a38:	230e      	movs	r3, #14
    7a3a:	2201      	movs	r2, #1
    7a3c:	2104      	movs	r1, #4
	
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    7a3e:	4f60      	ldr	r7, [pc, #384]	; (7bc0 <grid_module_common_init+0x1e8>)
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7a40:	f8cd b000 	str.w	fp, [sp]
    7a44:	4630      	mov	r0, r6
		uint8_t error = 0;
    7a46:	f88d 400b 	strb.w	r4, [sp, #11]
		grid_msg_set_parameter(&payload_template[payload_length], GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code, &error);
    7a4a:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_HWCFG_offset, GRID_CLASS_HEARTBEAT_HWCFG_length, grid_sys_get_hwcfg(), &error);
    7a4c:	47b8      	blx	r7
    7a4e:	2202      	movs	r2, #2
    7a50:	4603      	mov	r3, r0
    7a52:	2105      	movs	r1, #5
    7a54:	4630      	mov	r0, r6
    7a56:	f8cd b000 	str.w	fp, [sp]
    7a5a:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMAJOR_offset, GRID_CLASS_HEARTBEAT_VMAJOR_length , GRID_PROTOCOL_VERSION_MAJOR, &error);
    7a5c:	2301      	movs	r3, #1
    7a5e:	2202      	movs	r2, #2
    7a60:	2107      	movs	r1, #7
    7a62:	4630      	mov	r0, r6
    7a64:	f8cd b000 	str.w	fp, [sp]
    7a68:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VMINOR_offset, GRID_CLASS_HEARTBEAT_VMINOR_length  , GRID_PROTOCOL_VERSION_MINOR, &error);
    7a6a:	2301      	movs	r3, #1
    7a6c:	2202      	movs	r2, #2
    7a6e:	2109      	movs	r1, #9
    7a70:	4630      	mov	r0, r6
    7a72:	f8cd b000 	str.w	fp, [sp]
    7a76:	47d0      	blx	sl
		grid_msg_set_parameter(&payload_template[payload_length], GRID_CLASS_HEARTBEAT_VPATCH_offset, GRID_CLASS_HEARTBEAT_VPATCH_length  , GRID_PROTOCOL_VERSION_PATCH, &error);
    7a78:	2309      	movs	r3, #9
    7a7a:	2202      	movs	r2, #2
    7a7c:	210b      	movs	r1, #11
    7a7e:	4630      	mov	r0, r6
    7a80:	f8cd b000 	str.w	fp, [sp]
    7a84:	47d0      	blx	sl
	
		payload_length = strlen(payload_template);
    7a86:	a803      	add	r0, sp, #12
    7a88:	47c0      	blx	r8
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    7a8a:	686e      	ldr	r6, [r5, #4]
		payload_length = strlen(payload_template);
    7a8c:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_HEARTBEAT, payload_template, payload_length);		
    7a8e:	aa03      	add	r2, sp, #12
    7a90:	68f0      	ldr	r0, [r6, #12]
    7a92:	4e4c      	ldr	r6, [pc, #304]	; (7bc4 <grid_module_common_init+0x1ec>)
    7a94:	210c      	movs	r1, #12
    7a96:	47b0      	blx	r6
		
	}

	if (1){	// INIT CORE_STATE->mapmode press
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7a98:	227e      	movs	r2, #126	; 0x7e
    7a9a:	4621      	mov	r1, r4
    7a9c:	a804      	add	r0, sp, #16
    7a9e:	9403      	str	r4, [sp, #12]
    7aa0:	47c8      	blx	r9
		uint8_t payload_length = 0;
	
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_PRESS GRID_ACTIONSTRING_MAPMODE_PRESS);
    7aa2:	4949      	ldr	r1, [pc, #292]	; (7bc8 <grid_module_common_init+0x1f0>)
    7aa4:	4b44      	ldr	r3, [pc, #272]	; (7bb8 <grid_module_common_init+0x1e0>)
    7aa6:	a803      	add	r0, sp, #12
    7aa8:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7aaa:	a803      	add	r0, sp, #12
    7aac:	47c0      	blx	r8
    7aae:	4603      	mov	r3, r0
	
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_PRESS, payload_template, payload_length);			
    7ab0:	6868      	ldr	r0, [r5, #4]
    7ab2:	aa03      	add	r2, sp, #12
    7ab4:	68c0      	ldr	r0, [r0, #12]
    7ab6:	2107      	movs	r1, #7
    7ab8:	47b0      	blx	r6
		
	}	

	if (1){ // INIT CORE_STATE->mapmode release
			
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7aba:	227e      	movs	r2, #126	; 0x7e
    7abc:	4621      	mov	r1, r4
    7abe:	a804      	add	r0, sp, #16
    7ac0:	9403      	str	r4, [sp, #12]
    7ac2:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_MAPMODE_RELEASE GRID_ACTIONSTRING_MAPMODE_RELEASE);
    7ac4:	4941      	ldr	r1, [pc, #260]	; (7bcc <grid_module_common_init+0x1f4>)
    7ac6:	4b3c      	ldr	r3, [pc, #240]	; (7bb8 <grid_module_common_init+0x1e0>)
    7ac8:	a803      	add	r0, sp, #12
    7aca:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7acc:	a803      	add	r0, sp, #12
    7ace:	47c0      	blx	r8
    7ad0:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_MAPMODE_RELEASE, payload_template, payload_length);
    7ad2:	6868      	ldr	r0, [r5, #4]
    7ad4:	aa03      	add	r2, sp, #12
    7ad6:	68c0      	ldr	r0, [r0, #12]
    7ad8:	2108      	movs	r1, #8
    7ada:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgresponse
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7adc:	227e      	movs	r2, #126	; 0x7e
    7ade:	4621      	mov	r1, r4
    7ae0:	a804      	add	r0, sp, #16
    7ae2:	9403      	str	r4, [sp, #12]
    7ae4:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_RESPONES GRID_ACTIONSTRING_CFG_RESPONSE);
    7ae6:	493a      	ldr	r1, [pc, #232]	; (7bd0 <grid_module_common_init+0x1f8>)
    7ae8:	4b33      	ldr	r3, [pc, #204]	; (7bb8 <grid_module_common_init+0x1e0>)
    7aea:	a803      	add	r0, sp, #12
    7aec:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7aee:	a803      	add	r0, sp, #12
    7af0:	47c0      	blx	r8
    7af2:	4603      	mov	r3, r0
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_RESPONSE, payload_template, payload_length);
    7af4:	6868      	ldr	r0, [r5, #4]
    7af6:	aa03      	add	r2, sp, #12
    7af8:	68c0      	ldr	r0, [r0, #12]
    7afa:	2109      	movs	r1, #9
    7afc:	47b0      	blx	r6
		
	}	
	
	if (1){ // INIT CORE_STATE->cfgrequest
		
		uint8_t payload_template[GRID_UI_ACTION_STRING_maxlength] = {0};
    7afe:	227e      	movs	r2, #126	; 0x7e
    7b00:	4621      	mov	r1, r4
    7b02:	a804      	add	r0, sp, #16
    7b04:	9403      	str	r4, [sp, #12]
    7b06:	47c8      	blx	r9
		uint8_t payload_length = 0;
		
		sprintf(payload_template, GRID_EVENTSTRING_CFG_REQUEST GRID_ACTIONSTRING_CFG_REQUEST);
    7b08:	4932      	ldr	r1, [pc, #200]	; (7bd4 <grid_module_common_init+0x1fc>)
    7b0a:	4b2b      	ldr	r3, [pc, #172]	; (7bb8 <grid_module_common_init+0x1e0>)
    7b0c:	a803      	add	r0, sp, #12
    7b0e:	4798      	blx	r3
		payload_length = strlen(payload_template);
    7b10:	a803      	add	r0, sp, #12
    7b12:	47c0      	blx	r8
		
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7b14:	686c      	ldr	r4, [r5, #4]
		payload_length = strlen(payload_template);
    7b16:	4603      	mov	r3, r0
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7b18:	aa03      	add	r2, sp, #12
    7b1a:	68e0      	ldr	r0, [r4, #12]
	}	
	
	
	//enable pwr!
	
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    7b1c:	4c2e      	ldr	r4, [pc, #184]	; (7bd8 <grid_module_common_init+0x200>)
		grid_ui_event_register_actionstring(&grid_core_state.bank_list[0].element_list[0], GRID_UI_EVENT_CFG_REQUEST, payload_template, payload_length);
    7b1e:	210a      	movs	r1, #10
    7b20:	47b0      	blx	r6
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "UI Power Enable");
    7b22:	492e      	ldr	r1, [pc, #184]	; (7bdc <grid_module_common_init+0x204>)
    7b24:	482e      	ldr	r0, [pc, #184]	; (7be0 <grid_module_common_init+0x208>)
    7b26:	47a0      	blx	r4
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7b28:	4b2e      	ldr	r3, [pc, #184]	; (7be4 <grid_module_common_init+0x20c>)
    7b2a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    7b2e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(UI_PWR_EN, true);

	// ADC SETUP	
	
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    7b32:	47b8      	blx	r7
    7b34:	4625      	mov	r5, r4
    7b36:	b970      	cbnz	r0, 7b56 <grid_module_common_init+0x17e>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PO16");
    7b38:	492b      	ldr	r1, [pc, #172]	; (7be8 <grid_module_common_init+0x210>)
    7b3a:	4829      	ldr	r0, [pc, #164]	; (7be0 <grid_module_common_init+0x208>)
    7b3c:	47a8      	blx	r5
		grid_module_po16_revb_init();
    7b3e:	4b2b      	ldr	r3, [pc, #172]	; (7bec <grid_module_common_init+0x214>)
	}
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
		grid_module_bu16_revb_init();
    7b40:	4798      	blx	r3
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
	}


	grid_sys_init(&grid_sys_state);
    7b42:	4b2b      	ldr	r3, [pc, #172]	; (7bf0 <grid_module_common_init+0x218>)
    7b44:	482b      	ldr	r0, [pc, #172]	; (7bf4 <grid_module_common_init+0x21c>)
    7b46:	4798      	blx	r3


	grid_nvm_init(&grid_nvm_state, &FLASH_0);
    7b48:	492b      	ldr	r1, [pc, #172]	; (7bf8 <grid_module_common_init+0x220>)
    7b4a:	482c      	ldr	r0, [pc, #176]	; (7bfc <grid_module_common_init+0x224>)
    7b4c:	4b2c      	ldr	r3, [pc, #176]	; (7c00 <grid_module_common_init+0x228>)
    7b4e:	4798      	blx	r3
	
		
}
    7b50:	b025      	add	sp, #148	; 0x94
    7b52:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    7b56:	47b8      	blx	r7
    7b58:	2808      	cmp	r0, #8
    7b5a:	d0ed      	beq.n	7b38 <grid_module_common_init+0x160>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    7b5c:	47b8      	blx	r7
    7b5e:	2880      	cmp	r0, #128	; 0x80
    7b60:	d104      	bne.n	7b6c <grid_module_common_init+0x194>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: BU16");
    7b62:	4928      	ldr	r1, [pc, #160]	; (7c04 <grid_module_common_init+0x22c>)
    7b64:	481e      	ldr	r0, [pc, #120]	; (7be0 <grid_module_common_init+0x208>)
    7b66:	47a8      	blx	r5
		grid_module_bu16_revb_init();
    7b68:	4b27      	ldr	r3, [pc, #156]	; (7c08 <grid_module_common_init+0x230>)
    7b6a:	e7e9      	b.n	7b40 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevB || grid_sys_get_hwcfg() == GRID_MODULE_BU16_RevC ){
    7b6c:	47b8      	blx	r7
    7b6e:	2888      	cmp	r0, #136	; 0x88
    7b70:	d0f7      	beq.n	7b62 <grid_module_common_init+0x18a>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_PBF4_RevA){
    7b72:	47b8      	blx	r7
    7b74:	2840      	cmp	r0, #64	; 0x40
    7b76:	d104      	bne.n	7b82 <grid_module_common_init+0x1aa>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: PBF4");					
    7b78:	4924      	ldr	r1, [pc, #144]	; (7c0c <grid_module_common_init+0x234>)
    7b7a:	4819      	ldr	r0, [pc, #100]	; (7be0 <grid_module_common_init+0x208>)
    7b7c:	47a0      	blx	r4
		grid_module_pbf4_reva_init();			
    7b7e:	4b24      	ldr	r3, [pc, #144]	; (7c10 <grid_module_common_init+0x238>)
    7b80:	e7de      	b.n	7b40 <grid_module_common_init+0x168>
	else if (grid_sys_get_hwcfg() == GRID_MODULE_EN16_RevA){
    7b82:	47b8      	blx	r7
    7b84:	28c0      	cmp	r0, #192	; 0xc0
    7b86:	d104      	bne.n	7b92 <grid_module_common_init+0x1ba>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: EN16");
    7b88:	4922      	ldr	r1, [pc, #136]	; (7c14 <grid_module_common_init+0x23c>)
    7b8a:	4815      	ldr	r0, [pc, #84]	; (7be0 <grid_module_common_init+0x208>)
    7b8c:	47a0      	blx	r4
		grid_module_en16_reva_init();	
    7b8e:	4b22      	ldr	r3, [pc, #136]	; (7c18 <grid_module_common_init+0x240>)
    7b90:	e7d6      	b.n	7b40 <grid_module_common_init+0x168>
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Init Module: Unknown Module");
    7b92:	4922      	ldr	r1, [pc, #136]	; (7c1c <grid_module_common_init+0x244>)
    7b94:	4812      	ldr	r0, [pc, #72]	; (7be0 <grid_module_common_init+0x208>)
    7b96:	47a0      	blx	r4
		GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "HWCFG Mismatch");
    7b98:	4921      	ldr	r1, [pc, #132]	; (7c20 <grid_module_common_init+0x248>)
    7b9a:	4811      	ldr	r0, [pc, #68]	; (7be0 <grid_module_common_init+0x208>)
    7b9c:	47a0      	blx	r4
    7b9e:	e7d0      	b.n	7b42 <grid_module_common_init+0x16a>
    7ba0:	2001c7c0 	.word	0x2001c7c0
    7ba4:	0000a381 	.word	0x0000a381
    7ba8:	00015299 	.word	0x00015299
    7bac:	0000a3b5 	.word	0x0000a3b5
    7bb0:	0000ace1 	.word	0x0000ace1
    7bb4:	00016810 	.word	0x00016810
    7bb8:	00015307 	.word	0x00015307
    7bbc:	000166c6 	.word	0x000166c6
    7bc0:	0000a1fd 	.word	0x0000a1fd
    7bc4:	0000a845 	.word	0x0000a845
    7bc8:	00016824 	.word	0x00016824
    7bcc:	0001684a 	.word	0x0001684a
    7bd0:	00016863 	.word	0x00016863
    7bd4:	00016889 	.word	0x00016889
    7bd8:	00014eb1 	.word	0x00014eb1
    7bdc:	000168af 	.word	0x000168af
    7be0:	00016746 	.word	0x00016746
    7be4:	41008000 	.word	0x41008000
    7be8:	000168bf 	.word	0x000168bf
    7bec:	00008cb1 	.word	0x00008cb1
    7bf0:	00009f61 	.word	0x00009f61
    7bf4:	2000f008 	.word	0x2000f008
    7bf8:	2001ccf8 	.word	0x2001ccf8
    7bfc:	2000fa1c 	.word	0x2000fa1c
    7c00:	00009609 	.word	0x00009609
    7c04:	000168d1 	.word	0x000168d1
    7c08:	00007f61 	.word	0x00007f61
    7c0c:	000168e3 	.word	0x000168e3
    7c10:	00008955 	.word	0x00008955
    7c14:	000168f5 	.word	0x000168f5
    7c18:	00008479 	.word	0x00008479
    7c1c:	00016907 	.word	0x00016907
    7c20:	00016923 	.word	0x00016923
    7c24:	00014d51 	.word	0x00014d51
    7c28:	00015317 	.word	0x00015317
    7c2c:	0000a33d 	.word	0x0000a33d

00007c30 <grid_module_bu16_revb_hardware_start_transfer>:

static uint8_t grid_bu16_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_bu16_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};
	
	
void grid_module_bu16_revb_hardware_start_transfer(void){
    7c30:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    7c32:	4c04      	ldr	r4, [pc, #16]	; (7c44 <grid_module_bu16_revb_hardware_start_transfer+0x14>)
    7c34:	4804      	ldr	r0, [pc, #16]	; (7c48 <grid_module_bu16_revb_hardware_start_transfer+0x18>)
    7c36:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    7c38:	4623      	mov	r3, r4
    7c3a:	4804      	ldr	r0, [pc, #16]	; (7c4c <grid_module_bu16_revb_hardware_start_transfer+0x1c>)

}
    7c3c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    7c40:	4718      	bx	r3
    7c42:	bf00      	nop
    7c44:	0000ef71 	.word	0x0000ef71
    7c48:	2001cd84 	.word	0x2001cd84
    7c4c:	2001cf58 	.word	0x2001cf58

00007c50 <grid_module_bu16_revb_hardware_transfer_complete_cb>:

static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7c50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    7c54:	4aa4      	ldr	r2, [pc, #656]	; (7ee8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x298>)
    7c56:	7813      	ldrb	r3, [r2, #0]
static void grid_module_bu16_revb_hardware_transfer_complete_cb(void){
    7c58:	b08b      	sub	sp, #44	; 0x2c
    7c5a:	4614      	mov	r4, r2
	if (grid_module_bu16_revb_hardware_transfer_complete == 0){
    7c5c:	b933      	cbnz	r3, 7c6c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_bu16_revb_hardware_transfer_complete++;
    7c5e:	7813      	ldrb	r3, [r2, #0]
    7c60:	3301      	adds	r3, #1
    7c62:	b2db      	uxtb	r3, r3
    7c64:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_bu16_revb_hardware_transfer_complete = 0;
	grid_module_bu16_revb_hardware_start_transfer();
}
    7c66:	b00b      	add	sp, #44	; 0x2c
    7c68:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7c6c:	4b9f      	ldr	r3, [pc, #636]	; (7eec <grid_module_bu16_revb_hardware_transfer_complete_cb+0x29c>)
    7c6e:	48a0      	ldr	r0, [pc, #640]	; (7ef0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7c70:	4d9f      	ldr	r5, [pc, #636]	; (7ef0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a0>)
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    7c72:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    7c74:	7c6a      	ldrb	r2, [r5, #17]
		bank=0;
    7c76:	28ff      	cmp	r0, #255	; 0xff
    7c78:	bf14      	ite	ne
    7c7a:	4603      	movne	r3, r0
    7c7c:	2300      	moveq	r3, #0
	if (bank_changed){
    7c7e:	b9fa      	cbnz	r2, 7cc0 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x70>
	uint16_t adcresult_0 = 0;
    7c80:	2300      	movs	r3, #0
    7c82:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    7c86:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    7c8a:	7863      	ldrb	r3, [r4, #1]
    7c8c:	4a99      	ldr	r2, [pc, #612]	; (7ef4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a4>)
    7c8e:	3308      	adds	r3, #8
    7c90:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7c92:	7863      	ldrb	r3, [r4, #1]
    7c94:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+8];
    7c96:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7c98:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_bu16_revb_mux++;
    7c9a:	7863      	ldrb	r3, [r4, #1]
    7c9c:	3301      	adds	r3, #1
    7c9e:	b2db      	uxtb	r3, r3
    7ca0:	7063      	strb	r3, [r4, #1]
	grid_module_bu16_revb_mux%=8;
    7ca2:	7863      	ldrb	r3, [r4, #1]
    7ca4:	f003 0307 	and.w	r3, r3, #7
    7ca8:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_bu16_revb_mux/1%2);
    7caa:	7863      	ldrb	r3, [r4, #1]
	if (level) {
    7cac:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_bu16_revb_mux_lookup[grid_module_bu16_revb_mux+0];
    7cb0:	b2f6      	uxtb	r6, r6
    7cb2:	4b91      	ldr	r3, [pc, #580]	; (7ef8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7cb4:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    7cb8:	d141      	bne.n	7d3e <grid_module_bu16_revb_hardware_transfer_complete_cb+0xee>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7cba:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    7cbe:	e040      	b.n	7d42 <grid_module_bu16_revb_hardware_transfer_complete_cb+0xf2>
		grid_sys_state.bank_active_changed = 0;
    7cc0:	f04f 0900 	mov.w	r9, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7cc4:	fa0f fa83 	sxth.w	sl, r3
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7cc8:	f8df 823c 	ldr.w	r8, [pc, #572]	; 7f08 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>
		grid_sys_state.bank_active_changed = 0;
    7ccc:	f885 9011 	strb.w	r9, [r5, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7cd0:	ea4f 1a0a 	mov.w	sl, sl, lsl #4
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    7cd4:	eb04 1703 	add.w	r7, r4, r3, lsl #4
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7cd8:	f8d8 3004 	ldr.w	r3, [r8, #4]
    7cdc:	7bea      	ldrb	r2, [r5, #15]
    7cde:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    7ce2:	fa5f f689 	uxtb.w	r6, r9
    7ce6:	7a5b      	ldrb	r3, [r3, #9]
    7ce8:	42b3      	cmp	r3, r6
    7cea:	d9c9      	bls.n	7c80 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x30>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7cec:	f8d8 2004 	ldr.w	r2, [r8, #4]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7cf0:	f8df b220 	ldr.w	fp, [pc, #544]	; 7f14 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c4>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7cf4:	4452      	add	r2, sl
    7cf6:	2364      	movs	r3, #100	; 0x64
    7cf8:	68d2      	ldr	r2, [r2, #12]
    7cfa:	4373      	muls	r3, r6
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    7cfc:	19b9      	adds	r1, r7, r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    7cfe:	441a      	add	r2, r3
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    7d00:	7888      	ldrb	r0, [r1, #2]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    7d02:	f891 1042 	ldrb.w	r1, [r1, #66]	; 0x42
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_bu16_helper_template_b_tgl2[bank][i];
    7d06:	6190      	str	r0, [r2, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_bu16_helper_template_b_tgl3[bank][i];
    7d08:	61d1      	str	r1, [r2, #28]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7d0a:	f8d8 2004 	ldr.w	r2, [r8, #4]
    7d0e:	7be9      	ldrb	r1, [r5, #15]
    7d10:	eb02 1201 	add.w	r2, r2, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7d14:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7d16:	68d2      	ldr	r2, [r2, #12]
    7d18:	4413      	add	r3, r2
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7d1a:	4632      	mov	r2, r6
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    7d1c:	60de      	str	r6, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    7d1e:	7be9      	ldrb	r1, [r5, #15]
    7d20:	2300      	movs	r3, #0
    7d22:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    7d24:	7be9      	ldrb	r1, [r5, #15]
    7d26:	2304      	movs	r3, #4
    7d28:	4632      	mov	r2, r6
    7d2a:	4640      	mov	r0, r8
    7d2c:	47d8      	blx	fp
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    7d2e:	7be9      	ldrb	r1, [r5, #15]
    7d30:	2305      	movs	r3, #5
    7d32:	4632      	mov	r2, r6
    7d34:	4640      	mov	r0, r8
    7d36:	47d8      	blx	fp
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    7d38:	f109 0901 	add.w	r9, r9, #1
    7d3c:	e7cc      	b.n	7cd8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x88>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7d3e:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_bu16_revb_mux/2%2);
    7d42:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7d44:	f8df 81d0 	ldr.w	r8, [pc, #464]	; 7f18 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c8>
    7d48:	486c      	ldr	r0, [pc, #432]	; (7efc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2ac>)
    7d4a:	f013 0f02 	tst.w	r3, #2
    7d4e:	4b6a      	ldr	r3, [pc, #424]	; (7ef8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7d50:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    7d54:	bf14      	ite	ne
    7d56:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7d5a:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_bu16_revb_mux/4%2);
    7d5e:	7863      	ldrb	r3, [r4, #1]
    7d60:	f013 0f04 	tst.w	r3, #4
    7d64:	4b64      	ldr	r3, [pc, #400]	; (7ef8 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2a8>)
    7d66:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7d6a:	bf14      	ite	ne
    7d6c:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    7d70:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    7d74:	2100      	movs	r1, #0
    7d76:	2302      	movs	r3, #2
    7d78:	aa05      	add	r2, sp, #20
    7d7a:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    7d7c:	2302      	movs	r3, #2
    7d7e:	f10d 0216 	add.w	r2, sp, #22
    7d82:	485f      	ldr	r0, [pc, #380]	; (7f00 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b0>)
    7d84:	2100      	movs	r1, #0
    7d86:	47c0      	blx	r8
	uint8_t result_value[2] = {0};
    7d88:	2300      	movs	r3, #0
    7d8a:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint8_t result_valid[2] = {0};
    7d8e:	f8ad 3010 	strh.w	r3, [sp, #16]
	if (adcresult_0>60000){
    7d92:	f8bd 3014 	ldrh.w	r3, [sp, #20]
	result_index[0] = adc_index_0;
    7d96:	f88d 7008 	strb.w	r7, [sp, #8]
	if (adcresult_0>60000){
    7d9a:	f64e 2260 	movw	r2, #60000	; 0xea60
    7d9e:	4293      	cmp	r3, r2
	result_index[1] = adc_index_1;
    7da0:	f88d 6009 	strb.w	r6, [sp, #9]
	if (adcresult_0>60000){
    7da4:	d978      	bls.n	7e98 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x248>
		result_valid[0] = 1;
    7da6:	2301      	movs	r3, #1
    7da8:	f88d 3010 	strb.w	r3, [sp, #16]
	if (adcresult_1>60000){
    7dac:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    7db0:	f64e 2260 	movw	r2, #60000	; 0xea60
    7db4:	4293      	cmp	r3, r2
    7db6:	d975      	bls.n	7ea4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x254>
		result_value[1] = 0;
    7db8:	2300      	movs	r3, #0
		result_value[1] = 127;
    7dba:	f88d 300d 	strb.w	r3, [sp, #13]
		result_valid[1] = 1;
    7dbe:	2301      	movs	r3, #1
    7dc0:	f88d 3011 	strb.w	r3, [sp, #17]
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    7dc4:	4b4f      	ldr	r3, [pc, #316]	; (7f04 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b4>)
    7dc6:	ae06      	add	r6, sp, #24
    7dc8:	f103 0710 	add.w	r7, r3, #16
    7dcc:	6818      	ldr	r0, [r3, #0]
    7dce:	6859      	ldr	r1, [r3, #4]
    7dd0:	4632      	mov	r2, r6
    7dd2:	c203      	stmia	r2!, {r0, r1}
    7dd4:	3308      	adds	r3, #8
    7dd6:	42bb      	cmp	r3, r7
    7dd8:	4616      	mov	r6, r2
    7dda:	d1f7      	bne.n	7dcc <grid_module_bu16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7ddc:	484a      	ldr	r0, [pc, #296]	; (7f08 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
	uint8_t grid_module_bu16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};	
    7dde:	2300      	movs	r3, #0
    7de0:	f10d 0908 	add.w	r9, sp, #8
    7de4:	f10d 0b0c 	add.w	fp, sp, #12
    7de8:	9301      	str	r3, [sp, #4]
    7dea:	4682      	mov	sl, r0
		uint8_t res_index = result_index[i];
    7dec:	f819 6b01 	ldrb.w	r6, [r9], #1
		uint8_t res_value = result_value[i];
    7df0:	f81b 8b01 	ldrb.w	r8, [fp], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7df4:	6843      	ldr	r3, [r0, #4]
    7df6:	7bea      	ldrb	r2, [r5, #15]
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    7df8:	19a1      	adds	r1, r4, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7dfa:	b2d2      	uxtb	r2, r2
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    7dfc:	f891 c082 	ldrb.w	ip, [r1, #130]	; 0x82
    7e00:	45e0      	cmp	r8, ip
    7e02:	d042      	beq.n	7e8a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
    7e04:	9f01      	ldr	r7, [sp, #4]
		uint8_t res_valid = result_valid[i];
    7e06:	a904      	add	r1, sp, #16
		if (res_value != grid_bu16_helper_template_b_abs[res_index] && res_valid == 1){
    7e08:	5c79      	ldrb	r1, [r7, r1]
    7e0a:	2901      	cmp	r1, #1
    7e0c:	d13d      	bne.n	7e8a <grid_module_bu16_revb_hardware_transfer_complete_cb+0x23a>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;		
    7e0e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    7e12:	2164      	movs	r1, #100	; 0x64
    7e14:	68db      	ldr	r3, [r3, #12]
    7e16:	fb16 f101 	smulbb	r1, r6, r1
    7e1a:	440b      	add	r3, r1
			if (grid_bu16_helper_template_b_abs[res_index] == 0){ // Button Press Event
    7e1c:	f1bc 0f00 	cmp.w	ip, #0
    7e20:	d14d      	bne.n	7ebe <grid_module_bu16_revb_hardware_transfer_complete_cb+0x26e>
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    7e22:	699a      	ldr	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7e24:	f8d3 e01c 	ldr.w	lr, [r3, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    7e28:	2a00      	cmp	r2, #0
    7e2a:	bf0c      	ite	eq
    7e2c:	227f      	moveq	r2, #127	; 0x7f
    7e2e:	2200      	movne	r2, #0
    7e30:	619a      	str	r2, [r3, #24]
				if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    7e32:	f1be 0f00 	cmp.w	lr, #0
    7e36:	d13c      	bne.n	7eb2 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x262>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    7e38:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    7e3c:	f8c3 c01c 	str.w	ip, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7e40:	f895 c00f 	ldrb.w	ip, [r5, #15]
    7e44:	9f01      	ldr	r7, [sp, #4]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e46:	69db      	ldr	r3, [r3, #28]
				grid_bu16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    7e48:	eb04 1c0c 	add.w	ip, r4, ip, lsl #4
    7e4c:	44bc      	add	ip, r7
    7e4e:	f88c 2002 	strb.w	r2, [ip, #2]
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e52:	7bea      	ldrb	r2, [r5, #15]
    7e54:	eb04 1202 	add.w	r2, r4, r2, lsl #4
    7e58:	443a      	add	r2, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e5a:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
				grid_bu16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    7e5e:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
    7e62:	2300      	movs	r3, #0
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7e64:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e68:	441a      	add	r2, r3
    7e6a:	3310      	adds	r3, #16
    7e6c:	68d2      	ldr	r2, [r2, #12]
    7e6e:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e70:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    7e72:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7e76:	d1f5      	bne.n	7e64 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x214>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    7e78:	7be9      	ldrb	r1, [r5, #15]
    7e7a:	2304      	movs	r3, #4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7e7c:	4632      	mov	r2, r6
    7e7e:	4f23      	ldr	r7, [pc, #140]	; (7f0c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2bc>)
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7e80:	4426      	add	r6, r4
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7e82:	47b8      	blx	r7
				grid_bu16_helper_template_b_abs[result_index[i]] = res_value;
    7e84:	4820      	ldr	r0, [pc, #128]	; (7f08 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2b8>)
    7e86:	f886 8082 	strb.w	r8, [r6, #130]	; 0x82
	for (uint8_t i=0; i<2; i++)
    7e8a:	9b01      	ldr	r3, [sp, #4]
    7e8c:	b173      	cbz	r3, 7eac <grid_module_bu16_revb_hardware_transfer_complete_cb+0x25c>
	grid_module_bu16_revb_hardware_transfer_complete = 0;
    7e8e:	2300      	movs	r3, #0
    7e90:	7023      	strb	r3, [r4, #0]
	grid_module_bu16_revb_hardware_start_transfer();
    7e92:	4b1f      	ldr	r3, [pc, #124]	; (7f10 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x2c0>)
    7e94:	4798      	blx	r3
    7e96:	e6e6      	b.n	7c66 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16>
	else if (adcresult_0<200){
    7e98:	2bc7      	cmp	r3, #199	; 0xc7
    7e9a:	d887      	bhi.n	7dac <grid_module_bu16_revb_hardware_transfer_complete_cb+0x15c>
		result_value[0] = 127;
    7e9c:	237f      	movs	r3, #127	; 0x7f
    7e9e:	f88d 300c 	strb.w	r3, [sp, #12]
    7ea2:	e780      	b.n	7da6 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x156>
	else if (adcresult_1<200){
    7ea4:	2bc7      	cmp	r3, #199	; 0xc7
    7ea6:	d88d      	bhi.n	7dc4 <grid_module_bu16_revb_hardware_transfer_complete_cb+0x174>
		result_value[1] = 127;
    7ea8:	237f      	movs	r3, #127	; 0x7f
    7eaa:	e786      	b.n	7dba <grid_module_bu16_revb_hardware_transfer_complete_cb+0x16a>
    7eac:	2301      	movs	r3, #1
    7eae:	9301      	str	r3, [sp, #4]
    7eb0:	e79c      	b.n	7dec <grid_module_bu16_revb_hardware_transfer_complete_cb+0x19c>
				else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    7eb2:	f1be 0f3f 	cmp.w	lr, #63	; 0x3f
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    7eb6:	bf08      	it	eq
    7eb8:	f04f 0c7f 	moveq.w	ip, #127	; 0x7f
    7ebc:	e7be      	b.n	7e3c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x1ec>
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    7ebe:	aa0a      	add	r2, sp, #40	; 0x28
    7ec0:	4432      	add	r2, r6
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    7ec2:	60de      	str	r6, [r3, #12]
				template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_bu16_mux_reversed_lookup[res_index];
    7ec4:	f812 2c10 	ldrb.w	r2, [r2, #-16]
    7ec8:	611a      	str	r2, [r3, #16]
    7eca:	2300      	movs	r3, #0
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7ecc:	469c      	mov	ip, r3
                    template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    7ece:	f8da 2004 	ldr.w	r2, [sl, #4]
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7ed2:	441a      	add	r2, r3
    7ed4:	3310      	adds	r3, #16
    7ed6:	68d2      	ldr	r2, [r2, #12]
    7ed8:	440a      	add	r2, r1
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7eda:	2b40      	cmp	r3, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    7edc:	f8c2 c014 	str.w	ip, [r2, #20]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    7ee0:	d1f5      	bne.n	7ece <grid_module_bu16_revb_hardware_transfer_complete_cb+0x27e>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    7ee2:	7be9      	ldrb	r1, [r5, #15]
    7ee4:	2305      	movs	r3, #5
    7ee6:	e7c9      	b.n	7e7c <grid_module_bu16_revb_hardware_transfer_complete_cb+0x22c>
    7ee8:	200005ec 	.word	0x200005ec
    7eec:	0000a017 	.word	0x0000a017
    7ef0:	2000f008 	.word	0x2000f008
    7ef4:	20000308 	.word	0x20000308
    7ef8:	41008000 	.word	0x41008000
    7efc:	2001cd84 	.word	0x2001cd84
    7f00:	2001cf58 	.word	0x2001cf58
    7f04:	00016932 	.word	0x00016932
    7f08:	2000effc 	.word	0x2000effc
    7f0c:	0000aaa1 	.word	0x0000aaa1
    7f10:	00007c31 	.word	0x00007c31
    7f14:	0000adf5 	.word	0x0000adf5
    7f18:	0000eeb5 	.word	0x0000eeb5

00007f1c <grid_module_bu16_revb_hardware_init>:

void grid_module_bu16_revb_hardware_init(void){
    7f1c:	b570      	push	{r4, r5, r6, lr}
	

	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7f1e:	4c0b      	ldr	r4, [pc, #44]	; (7f4c <grid_module_bu16_revb_hardware_init+0x30>)
    7f20:	4e0b      	ldr	r6, [pc, #44]	; (7f50 <grid_module_bu16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7f22:	4d0c      	ldr	r5, [pc, #48]	; (7f54 <grid_module_bu16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7f24:	4b0c      	ldr	r3, [pc, #48]	; (7f58 <grid_module_bu16_revb_hardware_init+0x3c>)
    7f26:	2200      	movs	r2, #0
    7f28:	4611      	mov	r1, r2
    7f2a:	4620      	mov	r0, r4
    7f2c:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_bu16_revb_hardware_transfer_complete_cb);
    7f2e:	2200      	movs	r2, #0
    7f30:	4b09      	ldr	r3, [pc, #36]	; (7f58 <grid_module_bu16_revb_hardware_init+0x3c>)
    7f32:	4611      	mov	r1, r2
    7f34:	4628      	mov	r0, r5
    7f36:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    7f38:	4620      	mov	r0, r4
    7f3a:	4c08      	ldr	r4, [pc, #32]	; (7f5c <grid_module_bu16_revb_hardware_init+0x40>)
    7f3c:	2100      	movs	r1, #0
    7f3e:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    7f40:	4628      	mov	r0, r5
    7f42:	4623      	mov	r3, r4
    7f44:	2100      	movs	r1, #0

}
    7f46:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    7f4a:	4718      	bx	r3
    7f4c:	2001cd84 	.word	0x2001cd84
    7f50:	0000ee3d 	.word	0x0000ee3d
    7f54:	2001cf58 	.word	0x2001cf58
    7f58:	00007c51 	.word	0x00007c51
    7f5c:	0000edfd 	.word	0x0000edfd

00007f60 <grid_module_bu16_revb_init>:



void grid_module_bu16_revb_init(){
    7f60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

	grid_led_lowlevel_init(&grid_led_state, 16);
    7f64:	4b12      	ldr	r3, [pc, #72]	; (7fb0 <grid_module_bu16_revb_init+0x50>)
    7f66:	4813      	ldr	r0, [pc, #76]	; (7fb4 <grid_module_bu16_revb_init+0x54>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7f68:	4e13      	ldr	r6, [pc, #76]	; (7fb8 <grid_module_bu16_revb_init+0x58>)
    7f6a:	4f14      	ldr	r7, [pc, #80]	; (7fbc <grid_module_bu16_revb_init+0x5c>)
		
		for (uint8_t j=0; j<16; j++){

			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    7f6c:	f8df 805c 	ldr.w	r8, [pc, #92]	; 7fcc <grid_module_bu16_revb_init+0x6c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    7f70:	2110      	movs	r1, #16
    7f72:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    7f74:	4810      	ldr	r0, [pc, #64]	; (7fb8 <grid_module_bu16_revb_init+0x58>)
    7f76:	4b12      	ldr	r3, [pc, #72]	; (7fc0 <grid_module_bu16_revb_init+0x60>)
    7f78:	2104      	movs	r1, #4
    7f7a:	4798      	blx	r3
    7f7c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7f7e:	2210      	movs	r2, #16
    7f80:	b2e1      	uxtb	r1, r4
    7f82:	4630      	mov	r0, r6
    7f84:	47b8      	blx	r7
		for (uint8_t j=0; j<16; j++){
    7f86:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    7f8a:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    7f8c:	6870      	ldr	r0, [r6, #4]
    7f8e:	b2e9      	uxtb	r1, r5
    7f90:	2202      	movs	r2, #2
    7f92:	4448      	add	r0, r9
    7f94:	3501      	adds	r5, #1
    7f96:	47c0      	blx	r8
		for (uint8_t j=0; j<16; j++){
    7f98:	2d10      	cmp	r5, #16
    7f9a:	d1f7      	bne.n	7f8c <grid_module_bu16_revb_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    7f9c:	3401      	adds	r4, #1
    7f9e:	2c04      	cmp	r4, #4
    7fa0:	d1ed      	bne.n	7f7e <grid_module_bu16_revb_init+0x1e>

		}		
		
	}
				
	grid_module_bu16_revb_hardware_init();
    7fa2:	4b08      	ldr	r3, [pc, #32]	; (7fc4 <grid_module_bu16_revb_init+0x64>)
    7fa4:	4798      	blx	r3
	grid_module_bu16_revb_hardware_start_transfer();

};
    7fa6:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_bu16_revb_hardware_start_transfer();
    7faa:	4b07      	ldr	r3, [pc, #28]	; (7fc8 <grid_module_bu16_revb_init+0x68>)
    7fac:	4718      	bx	r3
    7fae:	bf00      	nop
    7fb0:	0000781d 	.word	0x0000781d
    7fb4:	2001c838 	.word	0x2001c838
    7fb8:	2000effc 	.word	0x2000effc
    7fbc:	0000a3b5 	.word	0x0000a3b5
    7fc0:	0000a381 	.word	0x0000a381
    7fc4:	00007f1d 	.word	0x00007f1d
    7fc8:	00007c31 	.word	0x00007c31
    7fcc:	0000ace1 	.word	0x0000ace1

00007fd0 <grid_module_en16_reva_hardware_start_transfer>:





void grid_module_en16_reva_hardware_start_transfer(void){
    7fd0:	b510      	push	{r4, lr}
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    7fd2:	4b08      	ldr	r3, [pc, #32]	; (7ff4 <grid_module_en16_reva_hardware_start_transfer+0x24>)
	

	gpio_set_pin_level(PIN_UI_SPI_CS0, true);

	spi_m_async_enable(&UI_SPI);
    7fd4:	4808      	ldr	r0, [pc, #32]	; (7ff8 <grid_module_en16_reva_hardware_start_transfer+0x28>)

	//io_write(io, UI_SPI_TX_BUFFER, 8);
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7fd6:	4c09      	ldr	r4, [pc, #36]	; (7ffc <grid_module_en16_reva_hardware_start_transfer+0x2c>)
    7fd8:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    7fdc:	619a      	str	r2, [r3, #24]
	spi_m_async_enable(&UI_SPI);
    7fde:	4b08      	ldr	r3, [pc, #32]	; (8000 <grid_module_en16_reva_hardware_start_transfer+0x30>)
    7fe0:	4798      	blx	r3
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7fe2:	4a08      	ldr	r2, [pc, #32]	; (8004 <grid_module_en16_reva_hardware_start_transfer+0x34>)
    7fe4:	4804      	ldr	r0, [pc, #16]	; (7ff8 <grid_module_en16_reva_hardware_start_transfer+0x28>)
    7fe6:	46a4      	mov	ip, r4
    7fe8:	2308      	movs	r3, #8

}
    7fea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_transfer(&UI_SPI, UI_SPI_TX_BUFFER, UI_SPI_RX_BUFFER, 8);
    7fee:	f102 010e 	add.w	r1, r2, #14
    7ff2:	4760      	bx	ip
    7ff4:	41008000 	.word	0x41008000
    7ff8:	2001cc70 	.word	0x2001cc70
    7ffc:	0000fb39 	.word	0x0000fb39
    8000:	0000fa99 	.word	0x0000fa99
    8004:	2000067e 	.word	0x2000067e

00008008 <grid_module_en16_reva_hardware_transfer_complete_cb>:

void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    8008:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    800c:	4ba8      	ldr	r3, [pc, #672]	; (82b0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2a8>)
	
	// Set the shift registers to continuously load data until new transaction is issued
	gpio_set_pin_level(PIN_UI_SPI_CS0, false);


	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    800e:	48a9      	ldr	r0, [pc, #676]	; (82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
	if (bank == 255){
		bank=0;
	}


	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    8010:	4fa8      	ldr	r7, [pc, #672]	; (82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    8012:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    8016:	615a      	str	r2, [r3, #20]
void grid_module_en16_reva_hardware_transfer_complete_cb(void){
    8018:	b089      	sub	sp, #36	; 0x24
	uint8_t bank = grid_sys_get_bank_num(&grid_sys_state);
    801a:	4ba7      	ldr	r3, [pc, #668]	; (82b8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b0>)
    801c:	4798      	blx	r3
	uint8_t bank_changed = grid_sys_state.bank_active_changed;
    801e:	7c7b      	ldrb	r3, [r7, #17]
		bank=0;
    8020:	28ff      	cmp	r0, #255	; 0xff
    8022:	bf14      	ite	ne
    8024:	4606      	movne	r6, r0
    8026:	2600      	moveq	r6, #0
		
	if (bank_changed){
    8028:	2b00      	cmp	r3, #0
    802a:	f040 815f 	bne.w	82ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e4>
		

		uint8_t i = UI_ENCODER_LOOKUP[j];
		

		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    802e:	f8df 82b8 	ldr.w	r8, [pc, #696]	; 82e8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2e0>
				uint8_t controlnumber = i;
 
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 

				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    8032:	0133      	lsls	r3, r6, #4
    8034:	9302      	str	r3, [sp, #8]
    8036:	eb08 1306 	add.w	r3, r8, r6, lsl #4
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    803a:	f04f 0b00 	mov.w	fp, #0
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    803e:	9303      	str	r3, [sp, #12]
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    8040:	f3cb 0346 	ubfx	r3, fp, #1, #7
    8044:	f00b 0201 	and.w	r2, fp, #1
    8048:	f818 3003 	ldrb.w	r3, [r8, r3]
    804c:	0092      	lsls	r2, r2, #2
    804e:	4113      	asrs	r3, r2
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    8050:	eb08 020b 	add.w	r2, r8, fp
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    8054:	b2de      	uxtb	r6, r3
		uint8_t old_value = UI_SPI_RX_BUFFER_LAST[j];
    8056:	f892 015c 	ldrb.w	r0, [r2, #348]	; 0x15c
		uint8_t new_value = (UI_SPI_RX_BUFFER[j/2]>>(4*(j%2)))&0x0F;
    805a:	f003 030f 	and.w	r3, r3, #15
		if (old_value != new_value){
    805e:	4283      	cmp	r3, r0
    8060:	fa5f f18b 	uxtb.w	r1, fp
    8064:	f000 8115 	beq.w	8292 <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
		uint8_t i = UI_ENCODER_LOOKUP[j];
    8068:	4894      	ldr	r0, [pc, #592]	; (82bc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b4>)
            UI_SPI_RX_BUFFER_LAST[j] = new_value;
    806a:	f882 315c 	strb.w	r3, [r2, #348]	; 0x15c
			UI_SPI_DEBUG = j;
    806e:	4a94      	ldr	r2, [pc, #592]	; (82c0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2b8>)
		uint8_t i = UI_ENCODER_LOOKUP[j];
    8070:	f81b 4000 	ldrb.w	r4, [fp, r0]
			UI_SPI_DEBUG = j;
    8074:	7011      	strb	r1, [r2, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    8076:	4d93      	ldr	r5, [pc, #588]	; (82c4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2bc>)
			uint8_t button_value = (new_value&0b00000100)?1:0;
    8078:	f3c3 0280 	ubfx	r2, r3, #2, #1
    807c:	9201      	str	r2, [sp, #4]
            uint8_t phase_a      = (new_value&0b00000010)?1:0;
    807e:	f3c3 0240 	ubfx	r2, r3, #1, #1
    8082:	9200      	str	r2, [sp, #0]
			if (button_value != grid_ui_encoder_array[i].button_value){
    8084:	eb05 1204 	add.w	r2, r5, r4, lsl #4
    8088:	9801      	ldr	r0, [sp, #4]
    808a:	7851      	ldrb	r1, [r2, #1]
    808c:	4281      	cmp	r1, r0
			uint8_t phase_b      = (new_value&0b00000001)?1:0;
    808e:	f006 0601 	and.w	r6, r6, #1
			if (button_value != grid_ui_encoder_array[i].button_value){
    8092:	ea4f 1704 	mov.w	r7, r4, lsl #4
    8096:	d04d      	beq.n	8134 <grid_module_en16_reva_hardware_transfer_complete_cb+0x12c>
				grid_ui_encoder_array[i].button_changed = 1;
    8098:	2101      	movs	r1, #1
				grid_ui_encoder_array[i].button_value = new_value>>2;
    809a:	089b      	lsrs	r3, r3, #2
				grid_ui_encoder_array[i].button_changed = 1;
    809c:	7091      	strb	r1, [r2, #2]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    809e:	f8df a214 	ldr.w	sl, [pc, #532]	; 82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>
				grid_ui_encoder_array[i].button_value = new_value>>2;
    80a2:	7053      	strb	r3, [r2, #1]
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    80a4:	4a88      	ldr	r2, [pc, #544]	; (82c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    80a6:	f8df c230 	ldr.w	ip, [pc, #560]	; 82d8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    80aa:	6852      	ldr	r2, [r2, #4]
    80ac:	f89a 100f 	ldrb.w	r1, [sl, #15]
    80b0:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    80b4:	2164      	movs	r1, #100	; 0x64
    80b6:	68d2      	ldr	r2, [r2, #12]
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    80b8:	f10d 0910 	add.w	r9, sp, #16
				int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;						
    80bc:	fb04 2201 	mla	r2, r4, r1, r2
				uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    80c0:	f8dc 1004 	ldr.w	r1, [ip, #4]
    80c4:	f8dc 0000 	ldr.w	r0, [ip]
    80c8:	46ce      	mov	lr, r9
    80ca:	e8ae 0003 	stmia.w	lr!, {r0, r1}
    80ce:	497f      	ldr	r1, [pc, #508]	; (82cc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    80d0:	f10c 0c08 	add.w	ip, ip, #8
    80d4:	458c      	cmp	ip, r1
    80d6:	46f1      	mov	r9, lr
    80d8:	d1f2      	bne.n	80c0 <grid_module_en16_reva_hardware_transfer_complete_cb+0xb8>
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    80da:	a908      	add	r1, sp, #32
    80dc:	4421      	add	r1, r4
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    80de:	60d4      	str	r4, [r2, #12]
				if (grid_ui_encoder_array[i].button_value == 0){ // Button Press Event
    80e0:	2b00      	cmp	r3, #0
    80e2:	f040 8152 	bne.w	838a <grid_module_en16_reva_hardware_transfer_complete_cb+0x382>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    80e6:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    80ea:	6111      	str	r1, [r2, #16]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    80ec:	6991      	ldr	r1, [r2, #24]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    80ee:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    80f2:	2900      	cmp	r1, #0
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    80f4:	69d1      	ldr	r1, [r2, #28]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;
    80f6:	f8c2 c014 	str.w	ip, [r2, #20]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    80fa:	bf0c      	ite	eq
    80fc:	4660      	moveq	r0, ip
    80fe:	2000      	movne	r0, #0
    8100:	6190      	str	r0, [r2, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    8102:	2900      	cmp	r1, #0
    8104:	f040 813d 	bne.w	8382 <grid_module_en16_reva_hardware_transfer_complete_cb+0x37a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    8108:	233f      	movs	r3, #63	; 0x3f
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    810a:	496a      	ldr	r1, [pc, #424]	; (82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    810c:	61d3      	str	r3, [r2, #28]
					grid_en16_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    810e:	7bcb      	ldrb	r3, [r1, #15]
    8110:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    8114:	4423      	add	r3, r4
    8116:	7718      	strb	r0, [r3, #28]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    8118:	7bcb      	ldrb	r3, [r1, #15]
    811a:	69d2      	ldr	r2, [r2, #28]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    811c:	7bc9      	ldrb	r1, [r1, #15]
					grid_en16_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    811e:	eb08 1303 	add.w	r3, r8, r3, lsl #4
    8122:	4423      	add	r3, r4
    8124:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    8128:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    812a:	4867      	ldr	r0, [pc, #412]	; (82c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    812c:	f8df 91ac 	ldr.w	r9, [pc, #428]	; 82dc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>
    8130:	4622      	mov	r2, r4
    8132:	47c8      	blx	r9
            if (a_now == 1 && b_now == 1){ //detent found
    8134:	9b00      	ldr	r3, [sp, #0]
    8136:	2b00      	cmp	r3, #0
    8138:	f000 8155 	beq.w	83e6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3de>
    813c:	2e00      	cmp	r6, #0
    813e:	f000 8155 	beq.w	83ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
			uint8_t b_prev = grid_ui_encoder_array[i].phase_b_previous;
    8142:	19eb      	adds	r3, r5, r7
                if (b_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    8144:	7b9a      	ldrb	r2, [r3, #14]
    8146:	2a00      	cmp	r2, #0
    8148:	f040 8128 	bne.w	839c <grid_module_en16_reva_hardware_transfer_complete_cb+0x394>
    814c:	7bd9      	ldrb	r1, [r3, #15]
    814e:	2900      	cmp	r1, #0
    8150:	f040 814c 	bne.w	83ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    8154:	2201      	movs	r2, #1
    8156:	73da      	strb	r2, [r3, #15]
                    delta = -1;
    8158:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
			grid_ui_encoder_array[i].phase_a_previous = a_now;
    815c:	442f      	add	r7, r5
    815e:	9b00      	ldr	r3, [sp, #0]
    8160:	737b      	strb	r3, [r7, #13]
			grid_ui_encoder_array[i].phase_b_previous = b_now;
    8162:	73be      	strb	r6, [r7, #14]
			if (delta != 0){
    8164:	f1b9 0f00 	cmp.w	r9, #0
    8168:	f000 8093 	beq.w	8292 <grid_module_en16_reva_hardware_transfer_complete_cb+0x28a>
				uint32_t elapsed_time = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_ui_encoder_array[i].last_real_time);
    816c:	68b9      	ldr	r1, [r7, #8]
    816e:	4851      	ldr	r0, [pc, #324]	; (82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    8170:	4b57      	ldr	r3, [pc, #348]	; (82d0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c8>)
    8172:	4798      	blx	r3
				if (elapsed_ms>25){
    8174:	f5b0 7fd0 	cmp.w	r0, #416	; 0x1a0
    8178:	f080 811b 	bcs.w	83b2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3aa>
                uint32_t elapsed_ms = elapsed_time/RTC1MS;
    817c:	0900      	lsrs	r0, r0, #4
    817e:	2801      	cmp	r0, #1
    8180:	bf38      	it	cc
    8182:	2001      	movcc	r0, #1
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    8184:	4e4b      	ldr	r6, [pc, #300]	; (82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    8186:	4b53      	ldr	r3, [pc, #332]	; (82d4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2cc>)
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    8188:	f240 2771 	movw	r7, #625	; 0x271
    818c:	fb00 7010 	mls	r0, r0, r0, r7
    8190:	2796      	movs	r7, #150	; 0x96
    8192:	fbb0 f7f7 	udiv	r7, r0, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    8196:	4630      	mov	r0, r6
    8198:	4798      	blx	r3
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    819a:	4a4b      	ldr	r2, [pc, #300]	; (82c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    819c:	6852      	ldr	r2, [r2, #4]
    819e:	7bf1      	ldrb	r1, [r6, #15]
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    81a0:	4e4d      	ldr	r6, [pc, #308]	; (82d8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d0>)
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81a2:	eb02 1201 	add.w	r2, r2, r1, lsl #4
				uint8_t velocityfactor = (25*25-elapsed_ms*elapsed_ms)/150 + 1;
    81a6:	3701      	adds	r7, #1
    81a8:	b2ff      	uxtb	r7, r7
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    81aa:	eb05 1504 	add.w	r5, r5, r4, lsl #4
				delta_high = delta * (velocityfactor * 2 - 1);
    81ae:	f04f 3aff 	mov.w	sl, #4294967295	; 0xffffffff
    81b2:	eb0a 0a47 	add.w	sl, sl, r7, lsl #1
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81b6:	68d2      	ldr	r2, [r2, #12]
				grid_ui_encoder_array[i].last_real_time = grid_sys_rtc_get_time(&grid_sys_state);
    81b8:	60a8      	str	r0, [r5, #8]
				delta_high = delta * (velocityfactor * 2 - 1);
    81ba:	fb0a fa09 	mul.w	sl, sl, r9
				delta_low =  delta * velocityfactor;			
    81be:	fb07 f509 	mul.w	r5, r7, r9
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81c2:	2164      	movs	r1, #100	; 0x64
				delta_low =  delta * velocityfactor;			
    81c4:	b2ab      	uxth	r3, r5
				delta_high = delta * (velocityfactor * 2 - 1);
    81c6:	fa1f f78a 	uxth.w	r7, sl
                int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    81ca:	fb04 2201 	mla	r2, r4, r1, r2
                uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    81ce:	f10d 0e10 	add.w	lr, sp, #16
    81d2:	6871      	ldr	r1, [r6, #4]
    81d4:	6830      	ldr	r0, [r6, #0]
    81d6:	46f4      	mov	ip, lr
    81d8:	e8ac 0003 	stmia.w	ip!, {r0, r1}
    81dc:	493b      	ldr	r1, [pc, #236]	; (82cc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c4>)
    81de:	3608      	adds	r6, #8
    81e0:	428e      	cmp	r6, r1
    81e2:	46e6      	mov	lr, ip
    81e4:	d1f5      	bne.n	81d2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x1ca>
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    81e6:	a908      	add	r1, sp, #32
    81e8:	4421      	add	r1, r4
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    81ea:	6214      	str	r4, [r2, #32]
                template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index]; 
    81ec:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    81f0:	6251      	str	r1, [r2, #36]	; 0x24
				uint8_t new_abs_no_velocity_value = grid_en16_helper_template_e_abs[bank][i];
    81f2:	9903      	ldr	r1, [sp, #12]
    81f4:	4421      	add	r1, r4
    81f6:	f891 c09c 	ldrb.w	ip, [r1, #156]	; 0x9c
				uint8_t new_abs_low_velocity_value = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    81fa:	f891 60dc 	ldrb.w	r6, [r1, #220]	; 0xdc
				uint8_t new_abs_high_velocity_value = grid_en16_helper_template_e_abs_high_velocity[bank][i];
    81fe:	f891 011c 	ldrb.w	r0, [r1, #284]	; 0x11c
                
				uint8_t new_rel_no_velocity_value =  template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL];
    8202:	f892 1034 	ldrb.w	r1, [r2, #52]	; 0x34
				
				if (delta != 0){
                    
                    
                    // ABSOLUTE NO VELOCITY						
					if (new_abs_no_velocity_value + delta < 0){
    8206:	44cc      	add	ip, r9
    8208:	f1bc 3fff 	cmp.w	ip, #4294967295	; 0xffffffff
    820c:	f000 80d3 	beq.w	83b6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ae>
						new_abs_no_velocity_value = 0;
					}
					else if (new_abs_no_velocity_value + delta > 127){
    8210:	f1bc 0f7f 	cmp.w	ip, #127	; 0x7f
    8214:	f300 80d2 	bgt.w	83bc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3b4>
						new_abs_no_velocity_value = 127;
					}
					else{
						new_abs_no_velocity_value += delta;
    8218:	fa5f fc8c 	uxtb.w	ip, ip
					}	
                    
                    // ABSOLUTE LOW VELOCITY						
					if (new_abs_low_velocity_value + delta_low < 0){
    821c:	1975      	adds	r5, r6, r5
    821e:	b2db      	uxtb	r3, r3
    8220:	f100 80cf 	bmi.w	83c2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ba>
						new_abs_low_velocity_value = 0;
					}
					else if (new_abs_low_velocity_value + delta_low > 127){
    8224:	2d7f      	cmp	r5, #127	; 0x7f
    8226:	f300 80ce 	bgt.w	83c6 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3be>
						new_abs_low_velocity_value = 127;
					}
					else{
						new_abs_low_velocity_value += delta_low;
    822a:	441e      	add	r6, r3
    822c:	b2f6      	uxtb	r6, r6
					}	
  					
                    // ABSOLUTE HIGH VELOCITY						
					if (new_abs_high_velocity_value + delta_high < 0){
    822e:	eb10 0a0a 	adds.w	sl, r0, sl
    8232:	b2ff      	uxtb	r7, r7
    8234:	f100 80c9 	bmi.w	83ca <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c2>
						new_abs_high_velocity_value = 0;
					}
					else if (new_abs_high_velocity_value + delta_high > 127){
    8238:	f1ba 0f7f 	cmp.w	sl, #127	; 0x7f
    823c:	f300 80c7 	bgt.w	83ce <grid_module_en16_reva_hardware_transfer_complete_cb+0x3c6>
						new_abs_high_velocity_value = 127;
					}
					else{
						new_abs_high_velocity_value += delta_high;
    8240:	4438      	add	r0, r7
    8242:	b2c0      	uxtb	r0, r0
					}	



                    // RELATIVE NO VELOCITY
					if (new_rel_no_velocity_value == 255){
    8244:	29ff      	cmp	r1, #255	; 0xff
    8246:	f040 80c4 	bne.w	83d2 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ca>
						if (delta>0){
							new_rel_no_velocity_value = 65;
						}
						else{
							new_rel_no_velocity_value = 63;
    824a:	f1b9 0f01 	cmp.w	r9, #1
					}
                    
                    // RELATIVE LOW VELOCITY
					if (new_rel_low_velocity_value == 255){
                        
                        new_rel_low_velocity_value = 64 + delta_low;
    824e:	f103 0340 	add.w	r3, r3, #64	; 0x40
							new_rel_no_velocity_value = 63;
    8252:	bf0c      	ite	eq
    8254:	2541      	moveq	r5, #65	; 0x41
    8256:	253f      	movne	r5, #63	; 0x3f
                        new_rel_low_velocity_value = 64 + delta_low;
    8258:	b2db      	uxtb	r3, r3
					}
                    
                    // RELATIVE HIGH VELOCITY
					if (new_rel_high_velocity_value == 255){
				
                        new_rel_high_velocity_value = 64 + delta_high;
    825a:	3740      	adds	r7, #64	; 0x40
	
                    
                    
					
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = new_rel_no_velocity_value;
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = new_rel_low_velocity_value;
    825c:	e9c2 530d 	strd	r5, r3, [r2, #52]	; 0x34
                    
                    
                    
                    
                    
                    if (button_value == 1){
    8260:	9b01      	ldr	r3, [sp, #4]
    8262:	4914      	ldr	r1, [pc, #80]	; (82b4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2ac>)
    8264:	4d1d      	ldr	r5, [pc, #116]	; (82dc <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d4>)
						new_rel_high_velocity_value += delta_high;
    8266:	b2ff      	uxtb	r7, r7
                    template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = new_rel_high_velocity_value;
    8268:	63d7      	str	r7, [r2, #60]	; 0x3c
                    if (button_value == 1){
    826a:	2b00      	cmp	r3, #0
    826c:	f000 80b8 	beq.w	83e0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3d8>
                        
                        // ABS is only updated if nonpush rotation event happened
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    8270:	9b02      	ldr	r3, [sp, #8]
                        
                        // ABS high velocity
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
                        
                        
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    8272:	7bc9      	ldrb	r1, [r1, #15]
                        grid_en16_helper_template_e_abs[bank][i] = new_abs_no_velocity_value;
    8274:	4443      	add	r3, r8
    8276:	4423      	add	r3, r4
    8278:	f883 c09c 	strb.w	ip, [r3, #156]	; 0x9c
                        grid_en16_helper_template_e_abs_low_velocity[bank][i] = new_abs_low_velocity_value;
    827c:	f883 60dc 	strb.w	r6, [r3, #220]	; 0xdc
                        grid_en16_helper_template_e_abs_high_velocity[bank][i] = new_abs_high_velocity_value;
    8280:	f883 011c 	strb.w	r0, [r3, #284]	; 0x11c
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = new_abs_low_velocity_value;
    8284:	e9c2 c60a 	strd	ip, r6, [r2, #40]	; 0x28
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = new_abs_high_velocity_value;
    8288:	6310      	str	r0, [r2, #48]	; 0x30
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);				
    828a:	2301      	movs	r3, #1
                    }
                    else{
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    828c:	480e      	ldr	r0, [pc, #56]	; (82c8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2c0>)
    828e:	4622      	mov	r2, r4
    8290:	47a8      	blx	r5
	for (uint8_t j=0; j<16; j++){
    8292:	f10b 0b01 	add.w	fp, fp, #1
    8296:	f1bb 0f10 	cmp.w	fp, #16
    829a:	f47f aed1 	bne.w	8040 <grid_module_en16_reva_hardware_transfer_complete_cb+0x38>

			
	}
		

	grid_module_en16_reva_hardware_transfer_complete = 0;
    829e:	4b10      	ldr	r3, [pc, #64]	; (82e0 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2d8>)
    82a0:	2200      	movs	r2, #0
    82a2:	701a      	strb	r2, [r3, #0]
	grid_module_en16_reva_hardware_start_transfer();
    82a4:	4b0f      	ldr	r3, [pc, #60]	; (82e4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2dc>)
}
    82a6:	b009      	add	sp, #36	; 0x24
    82a8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_module_en16_reva_hardware_start_transfer();
    82ac:	4718      	bx	r3
    82ae:	bf00      	nop
    82b0:	41008000 	.word	0x41008000
    82b4:	2000f008 	.word	0x2000f008
    82b8:	0000a017 	.word	0x0000a017
    82bc:	20000318 	.word	0x20000318
    82c0:	2000c09d 	.word	0x2000c09d
    82c4:	20019770 	.word	0x20019770
    82c8:	2000effc 	.word	0x2000effc
    82cc:	00016952 	.word	0x00016952
    82d0:	0000a0bd 	.word	0x0000a0bd
    82d4:	0000a0b9 	.word	0x0000a0b9
    82d8:	00016942 	.word	0x00016942
    82dc:	0000aaa1 	.word	0x0000aaa1
    82e0:	2001c854 	.word	0x2001c854
    82e4:	00007fd1 	.word	0x00007fd1
    82e8:	2000067e 	.word	0x2000067e
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    82ec:	b233      	sxth	r3, r6
		grid_sys_state.bank_active_changed = 0;
    82ee:	2400      	movs	r4, #0
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    82f0:	ea4f 1b03 	mov.w	fp, r3, lsl #4
    82f4:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8400 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f8>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    82f8:	f8df a108 	ldr.w	sl, [pc, #264]	; 8404 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3fc>
		grid_sys_state.bank_active_changed = 0;
    82fc:	747c      	strb	r4, [r7, #17]
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    82fe:	465d      	mov	r5, fp
    8300:	f8d8 3004 	ldr.w	r3, [r8, #4]
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8304:	f8df c100 	ldr.w	ip, [pc, #256]	; 8408 <grid_module_en16_reva_hardware_transfer_complete_cb+0x400>
			int32_t* template_parameter_list = grid_ui_state.bank_list[bank].element_list[res_index].template_parameter_list;
    8308:	445b      	add	r3, fp
    830a:	2164      	movs	r1, #100	; 0x64
    830c:	68db      	ldr	r3, [r3, #12]
    830e:	b2e2      	uxtb	r2, r4
    8310:	fb01 3304 	mla	r3, r1, r4, r3
			uint8_t grid_module_en16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8314:	f10d 0e10 	add.w	lr, sp, #16
    8318:	f8dc 1004 	ldr.w	r1, [ip, #4]
    831c:	f8dc 0000 	ldr.w	r0, [ip]
    8320:	46f1      	mov	r9, lr
    8322:	e8a9 0003 	stmia.w	r9!, {r0, r1}
    8326:	4933      	ldr	r1, [pc, #204]	; (83f4 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3ec>)
    8328:	f10c 0c08 	add.w	ip, ip, #8
    832c:	458c      	cmp	ip, r1
    832e:	46ce      	mov	lr, r9
    8330:	d1f2      	bne.n	8318 <grid_module_en16_reva_hardware_transfer_complete_cb+0x310>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    8332:	a904      	add	r1, sp, #16
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    8334:	60dc      	str	r4, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    8336:	5d09      	ldrb	r1, [r1, r4]
    8338:	6119      	str	r1, [r3, #16]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = grid_en16_helper_template_b_tgl2[bank][i];
    833a:	f815 000a 	ldrb.w	r0, [r5, sl]
    833e:	6198      	str	r0, [r3, #24]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    8340:	482d      	ldr	r0, [pc, #180]	; (83f8 <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f0>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8342:	f8df 90c8 	ldr.w	r9, [pc, #200]	; 840c <grid_module_en16_reva_hardware_transfer_complete_cb+0x404>
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = grid_en16_helper_template_b_tgl3[bank][i];
    8346:	5c28      	ldrb	r0, [r5, r0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    8348:	6259      	str	r1, [r3, #36]	; 0x24
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_NUMBER] = res_index;
    834a:	e9c3 0407 	strd	r0, r4, [r3, #28]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    834e:	492b      	ldr	r1, [pc, #172]	; (83fc <grid_module_en16_reva_hardware_transfer_complete_cb+0x3f4>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8350:	9200      	str	r2, [sp, #0]
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS] = grid_en16_helper_template_e_abs[bank][i];
    8352:	5c68      	ldrb	r0, [r5, r1]
    8354:	6298      	str	r0, [r3, #40]	; 0x28
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    8356:	f101 0040 	add.w	r0, r1, #64	; 0x40
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    835a:	3180      	adds	r1, #128	; 0x80
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_LOW] = grid_en16_helper_template_e_abs_low_velocity[bank][i];
    835c:	5c28      	ldrb	r0, [r5, r0]
    835e:	62d8      	str	r0, [r3, #44]	; 0x2c
			template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_ABS_VELOCITY_HIGH] = grid_en16_helper_template_e_abs_high_velocity[bank][i];			
    8360:	5c69      	ldrb	r1, [r5, r1]
    8362:	6319      	str	r1, [r3, #48]	; 0x30
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8364:	4640      	mov	r0, r8
    8366:	7bf9      	ldrb	r1, [r7, #15]
    8368:	2300      	movs	r3, #0
    836a:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    836c:	3401      	adds	r4, #1
    836e:	7bf9      	ldrb	r1, [r7, #15]
    8370:	9a00      	ldr	r2, [sp, #0]
    8372:	2301      	movs	r3, #1
    8374:	4640      	mov	r0, r8
    8376:	47c8      	blx	r9
		for (uint8_t i = 0; i<16; i++)
    8378:	2c10      	cmp	r4, #16
    837a:	f105 0501 	add.w	r5, r5, #1
    837e:	d1bf      	bne.n	8300 <grid_module_en16_reva_hardware_transfer_complete_cb+0x2f8>
    8380:	e655      	b.n	802e <grid_module_en16_reva_hardware_transfer_complete_cb+0x26>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    8382:	293f      	cmp	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    8384:	bf08      	it	eq
    8386:	4663      	moveq	r3, ip
    8388:	e6bf      	b.n	810a <grid_module_en16_reva_hardware_transfer_complete_cb+0x102>
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_en16_mux_reversed_lookup[res_index];
    838a:	f811 3c10 	ldrb.w	r3, [r1, #-16]
    838e:	6113      	str	r3, [r2, #16]
 					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;
    8390:	2300      	movs	r3, #0
    8392:	6153      	str	r3, [r2, #20]
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    8394:	f89a 100f 	ldrb.w	r1, [sl, #15]
    8398:	2305      	movs	r3, #5
    839a:	e6c6      	b.n	812a <grid_module_en16_reva_hardware_transfer_complete_cb+0x122>
                if (a_prev == 0 && grid_ui_encoder_array[i].phase_change_lock == 0){
    839c:	7b5a      	ldrb	r2, [r3, #13]
    839e:	bb2a      	cbnz	r2, 83ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
    83a0:	7bd9      	ldrb	r1, [r3, #15]
    83a2:	b921      	cbnz	r1, 83ae <grid_module_en16_reva_hardware_transfer_complete_cb+0x3a6>
                    grid_ui_encoder_array[i].phase_change_lock = 1;
    83a4:	f04f 0901 	mov.w	r9, #1
    83a8:	f883 900f 	strb.w	r9, [r3, #15]
    83ac:	e6d6      	b.n	815c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
			int16_t delta = 0;
    83ae:	4691      	mov	r9, r2
    83b0:	e6d4      	b.n	815c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
					elapsed_ms = 25;
    83b2:	2019      	movs	r0, #25
    83b4:	e6e6      	b.n	8184 <grid_module_en16_reva_hardware_transfer_complete_cb+0x17c>
						new_abs_no_velocity_value = 0;
    83b6:	f04f 0c00 	mov.w	ip, #0
    83ba:	e72f      	b.n	821c <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_no_velocity_value = 127;
    83bc:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
    83c0:	e72c      	b.n	821c <grid_module_en16_reva_hardware_transfer_complete_cb+0x214>
						new_abs_low_velocity_value = 0;
    83c2:	2600      	movs	r6, #0
    83c4:	e733      	b.n	822e <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_low_velocity_value = 127;
    83c6:	267f      	movs	r6, #127	; 0x7f
    83c8:	e731      	b.n	822e <grid_module_en16_reva_hardware_transfer_complete_cb+0x226>
						new_abs_high_velocity_value = 0;
    83ca:	2000      	movs	r0, #0
    83cc:	e73a      	b.n	8244 <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_abs_high_velocity_value = 127;
    83ce:	207f      	movs	r0, #127	; 0x7f
    83d0:	e738      	b.n	8244 <grid_module_en16_reva_hardware_transfer_complete_cb+0x23c>
						new_rel_no_velocity_value += delta;
    83d2:	4489      	add	r9, r1
						new_rel_low_velocity_value += delta_low;
    83d4:	440b      	add	r3, r1
						new_rel_no_velocity_value += delta;
    83d6:	fa5f f589 	uxtb.w	r5, r9
						new_rel_low_velocity_value += delta_low;
    83da:	b2db      	uxtb	r3, r3
						new_rel_high_velocity_value += delta_high;
    83dc:	440f      	add	r7, r1
    83de:	e73d      	b.n	825c <grid_module_en16_reva_hardware_transfer_complete_cb+0x254>
                        grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_ENCPUSHROT);
    83e0:	7bc9      	ldrb	r1, [r1, #15]
    83e2:	230d      	movs	r3, #13
    83e4:	e752      	b.n	828c <grid_module_en16_reva_hardware_transfer_complete_cb+0x284>
            if (a_now == 0 && b_now == 0){
    83e6:	b90e      	cbnz	r6, 83ec <grid_module_en16_reva_hardware_transfer_complete_cb+0x3e4>
                grid_ui_encoder_array[i].phase_change_lock = 0;
    83e8:	19eb      	adds	r3, r5, r7
    83ea:	73de      	strb	r6, [r3, #15]
			int16_t delta = 0;
    83ec:	f04f 0900 	mov.w	r9, #0
    83f0:	e6b4      	b.n	815c <grid_module_en16_reva_hardware_transfer_complete_cb+0x154>
    83f2:	bf00      	nop
    83f4:	00016952 	.word	0x00016952
    83f8:	200006da 	.word	0x200006da
    83fc:	2000071a 	.word	0x2000071a
    8400:	2000effc 	.word	0x2000effc
    8404:	2000069a 	.word	0x2000069a
    8408:	00016942 	.word	0x00016942
    840c:	0000adf5 	.word	0x0000adf5

00008410 <grid_module_en16_reva_hardware_init>:
    8410:	4b0f      	ldr	r3, [pc, #60]	; (8450 <grid_module_en16_reva_hardware_init+0x40>)
    8412:	f44f 1200 	mov.w	r2, #2097152	; 0x200000

void grid_module_en16_reva_hardware_init(void){
    8416:	b510      	push	{r4, lr}
    8418:	615a      	str	r2, [r3, #20]
	
	
	
	
	
	spi_m_async_set_mode(&UI_SPI, SPI_MODE_3);
    841a:	4c0e      	ldr	r4, [pc, #56]	; (8454 <grid_module_en16_reva_hardware_init+0x44>)
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    841c:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    841e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    8422:	629a      	str	r2, [r3, #40]	; 0x28
    8424:	4a0c      	ldr	r2, [pc, #48]	; (8458 <grid_module_en16_reva_hardware_init+0x48>)
    8426:	629a      	str	r2, [r3, #40]	; 0x28
    8428:	2103      	movs	r1, #3
    842a:	4b0c      	ldr	r3, [pc, #48]	; (845c <grid_module_en16_reva_hardware_init+0x4c>)
    842c:	4620      	mov	r0, r4
    842e:	4798      	blx	r3
	spi_m_async_set_baudrate(&UI_SPI, 1000000); // was 400000 check clock div setting
    8430:	490b      	ldr	r1, [pc, #44]	; (8460 <grid_module_en16_reva_hardware_init+0x50>)
    8432:	4b0c      	ldr	r3, [pc, #48]	; (8464 <grid_module_en16_reva_hardware_init+0x54>)
    8434:	4620      	mov	r0, r4
    8436:	4798      	blx	r3
	
	spi_m_async_get_io_descriptor(&UI_SPI, &grid_module_en16_reva_hardware_io);
    8438:	490b      	ldr	r1, [pc, #44]	; (8468 <grid_module_en16_reva_hardware_init+0x58>)
    843a:	4b0c      	ldr	r3, [pc, #48]	; (846c <grid_module_en16_reva_hardware_init+0x5c>)
    843c:	4620      	mov	r0, r4
    843e:	4798      	blx	r3


	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    8440:	4620      	mov	r0, r4
    8442:	4a0b      	ldr	r2, [pc, #44]	; (8470 <grid_module_en16_reva_hardware_init+0x60>)
    8444:	4b0b      	ldr	r3, [pc, #44]	; (8474 <grid_module_en16_reva_hardware_init+0x64>)


}
    8446:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	spi_m_async_register_callback(&UI_SPI, SPI_M_ASYNC_CB_XFER, grid_module_en16_reva_hardware_transfer_complete_cb);
    844a:	2100      	movs	r1, #0
    844c:	4718      	bx	r3
    844e:	bf00      	nop
    8450:	41008000 	.word	0x41008000
    8454:	2001cc70 	.word	0x2001cc70
    8458:	c0000020 	.word	0xc0000020
    845c:	0000fafd 	.word	0x0000fafd
    8460:	000f4240 	.word	0x000f4240
    8464:	0000fac1 	.word	0x0000fac1
    8468:	2000c0a0 	.word	0x2000c0a0
    846c:	0000fbe1 	.word	0x0000fbe1
    8470:	00008009 	.word	0x00008009
    8474:	0000fb9d 	.word	0x0000fb9d

00008478 <grid_module_en16_reva_init>:

void grid_module_en16_reva_init(){
    8478:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	grid_led_lowlevel_init(&grid_led_state, 16);
    847c:	4b1d      	ldr	r3, [pc, #116]	; (84f4 <grid_module_en16_reva_init+0x7c>)
    847e:	481e      	ldr	r0, [pc, #120]	; (84f8 <grid_module_en16_reva_init+0x80>)

	
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
	{
		
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    8480:	4e1e      	ldr	r6, [pc, #120]	; (84fc <grid_module_en16_reva_init+0x84>)
    8482:	4f1f      	ldr	r7, [pc, #124]	; (8500 <grid_module_en16_reva_init+0x88>)
		
		for(uint8_t j=0; j<16; j++){
		
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    8484:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8514 <grid_module_en16_reva_init+0x9c>
	grid_led_lowlevel_init(&grid_led_state, 16);
    8488:	2110      	movs	r1, #16
    848a:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);	
    848c:	481b      	ldr	r0, [pc, #108]	; (84fc <grid_module_en16_reva_init+0x84>)
    848e:	4b1d      	ldr	r3, [pc, #116]	; (8504 <grid_module_en16_reva_init+0x8c>)
    8490:	2104      	movs	r1, #4
    8492:	4798      	blx	r3
    8494:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    8496:	2210      	movs	r2, #16
    8498:	b2e1      	uxtb	r1, r4
    849a:	4630      	mov	r0, r6
    849c:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    849e:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);	
    84a2:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_ENCODER);	
    84a4:	6870      	ldr	r0, [r6, #4]
    84a6:	b2e9      	uxtb	r1, r5
    84a8:	2203      	movs	r2, #3
    84aa:	4448      	add	r0, r9
    84ac:	3501      	adds	r5, #1
    84ae:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    84b0:	2d10      	cmp	r5, #16
    84b2:	d1f7      	bne.n	84a4 <grid_module_en16_reva_init+0x2c>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++)
    84b4:	3401      	adds	r4, #1
    84b6:	2c04      	cmp	r4, #4
    84b8:	d1ed      	bne.n	8496 <grid_module_en16_reva_init+0x1e>
    84ba:	2200      	movs	r2, #0
    84bc:	4b12      	ldr	r3, [pc, #72]	; (8508 <grid_module_en16_reva_init+0x90>)
	// initialize local encoder helper struct
	for (uint8_t j = 0; j<16; j++)
	{
		grid_ui_encoder_array[j].controller_number = j;
		
		grid_ui_encoder_array[j].button_value = 1;
    84be:	2001      	movs	r0, #1
		grid_ui_encoder_array[j].button_changed = 0; 
    84c0:	4611      	mov	r1, r2
		grid_ui_encoder_array[j].rotation_value = 0;
		grid_ui_encoder_array[j].rotation_changed = 1;
		grid_ui_encoder_array[j].rotation_direction = 0;
		grid_ui_encoder_array[j].last_real_time = -1;
    84c2:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
		grid_ui_encoder_array[j].controller_number = j;
    84c6:	701a      	strb	r2, [r3, #0]
		grid_ui_encoder_array[j].button_value = 1;
    84c8:	3201      	adds	r2, #1
	for (uint8_t j = 0; j<16; j++)
    84ca:	2a10      	cmp	r2, #16
		grid_ui_encoder_array[j].button_value = 1;
    84cc:	7058      	strb	r0, [r3, #1]
		grid_ui_encoder_array[j].button_changed = 0; 
    84ce:	7099      	strb	r1, [r3, #2]
		grid_ui_encoder_array[j].rotation_value = 0;
    84d0:	70d9      	strb	r1, [r3, #3]
		grid_ui_encoder_array[j].rotation_changed = 1;
    84d2:	7118      	strb	r0, [r3, #4]
		grid_ui_encoder_array[j].rotation_direction = 0;
    84d4:	7159      	strb	r1, [r3, #5]
		grid_ui_encoder_array[j].last_real_time = -1;
    84d6:	609c      	str	r4, [r3, #8]
		grid_ui_encoder_array[j].velocity = 0;
    84d8:	7319      	strb	r1, [r3, #12]
		grid_ui_encoder_array[j].phase_a_previous = 1;
    84da:	7358      	strb	r0, [r3, #13]
		grid_ui_encoder_array[j].phase_b_previous = 1;	
    84dc:	7398      	strb	r0, [r3, #14]
        
        grid_ui_encoder_array[j].phase_change_lock = 0;
    84de:	73d9      	strb	r1, [r3, #15]
	for (uint8_t j = 0; j<16; j++)
    84e0:	f103 0310 	add.w	r3, r3, #16
    84e4:	d1ef      	bne.n	84c6 <grid_module_en16_reva_init+0x4e>
		
	}
	
	
	grid_module_en16_reva_hardware_init();
    84e6:	4b09      	ldr	r3, [pc, #36]	; (850c <grid_module_en16_reva_init+0x94>)
    84e8:	4798      	blx	r3
	
	
	grid_module_en16_reva_hardware_start_transfer();
	
}
    84ea:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_en16_reva_hardware_start_transfer();
    84ee:	4b08      	ldr	r3, [pc, #32]	; (8510 <grid_module_en16_reva_init+0x98>)
    84f0:	4718      	bx	r3
    84f2:	bf00      	nop
    84f4:	0000781d 	.word	0x0000781d
    84f8:	2001c838 	.word	0x2001c838
    84fc:	2000effc 	.word	0x2000effc
    8500:	0000a3b5 	.word	0x0000a3b5
    8504:	0000a381 	.word	0x0000a381
    8508:	20019770 	.word	0x20019770
    850c:	00008411 	.word	0x00008411
    8510:	00007fd1 	.word	0x00007fd1
    8514:	0000ace1 	.word	0x0000ace1

00008518 <grid_module_pbf4_reva_hardware_start_transfer>:
static uint8_t grid_pbf4_helper_template_b_abs[16] = {0};
	
static uint8_t grid_pbf4_helper_template_b_tgl2[GRID_SYS_BANK_MAXNUMBER][16] = {0};
static uint8_t grid_pbf4_helper_template_b_tgl3[GRID_SYS_BANK_MAXNUMBER][16] = {0};

void grid_module_pbf4_reva_hardware_start_transfer(void){
    8518:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    851a:	4c04      	ldr	r4, [pc, #16]	; (852c <grid_module_pbf4_reva_hardware_start_transfer+0x14>)
    851c:	4804      	ldr	r0, [pc, #16]	; (8530 <grid_module_pbf4_reva_hardware_start_transfer+0x18>)
    851e:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    8520:	4623      	mov	r3, r4
    8522:	4804      	ldr	r0, [pc, #16]	; (8534 <grid_module_pbf4_reva_hardware_start_transfer+0x1c>)
	
}
    8524:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    8528:	4718      	bx	r3
    852a:	bf00      	nop
    852c:	0000ef71 	.word	0x0000ef71
    8530:	2001cd84 	.word	0x2001cd84
    8534:	2001cf58 	.word	0x2001cf58

00008538 <grid_module_pbf4_reva_hardware_transfer_complete_cb>:

void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    8538:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    853c:	4aa8      	ldr	r2, [pc, #672]	; (87e0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    853e:	7813      	ldrb	r3, [r2, #0]
void grid_module_pbf4_reva_hardware_transfer_complete_cb(void){
    8540:	b08b      	sub	sp, #44	; 0x2c
	if (grid_module_pbf4_reva_hardware_transfer_complete == 0){
    8542:	b933      	cbnz	r3, 8552 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a>
		grid_module_pbf4_reva_hardware_transfer_complete++;
    8544:	7813      	ldrb	r3, [r2, #0]
    8546:	3301      	adds	r3, #1
    8548:	b2db      	uxtb	r3, r3
    854a:	7013      	strb	r3, [r2, #0]
	
	
	
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
	grid_module_pbf4_reva_hardware_start_transfer();
}
    854c:	b00b      	add	sp, #44	; 0x2c
    854e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    8552:	4ba4      	ldr	r3, [pc, #656]	; (87e4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ac>)
    8554:	7c5a      	ldrb	r2, [r3, #17]
    8556:	469a      	mov	sl, r3
    8558:	bb02      	cbnz	r2, 859c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x64>
	uint16_t adcresult_0 = 0;
    855a:	2300      	movs	r3, #0
    855c:	f8ad 3014 	strh.w	r3, [sp, #20]
	uint16_t adcresult_1 = 0;
    8560:	f8ad 3016 	strh.w	r3, [sp, #22]
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    8564:	4ba0      	ldr	r3, [pc, #640]	; (87e8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b0>)
    8566:	49a1      	ldr	r1, [pc, #644]	; (87ec <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b4>)
    8568:	781a      	ldrb	r2, [r3, #0]
    856a:	3208      	adds	r2, #8
    856c:	5c8d      	ldrb	r5, [r1, r2]
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    856e:	781a      	ldrb	r2, [r3, #0]
    8570:	b2d2      	uxtb	r2, r2
	uint8_t adc_index_0 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+8];
    8572:	b2ed      	uxtb	r5, r5
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    8574:	5c8c      	ldrb	r4, [r1, r2]
	grid_module_pbf4_reva_mux++;
    8576:	781a      	ldrb	r2, [r3, #0]
    8578:	3201      	adds	r2, #1
    857a:	b2d2      	uxtb	r2, r2
    857c:	701a      	strb	r2, [r3, #0]
	grid_module_pbf4_reva_mux%=8;
    857e:	781a      	ldrb	r2, [r3, #0]
    8580:	f002 0207 	and.w	r2, r2, #7
    8584:	701a      	strb	r2, [r3, #0]
	gpio_set_pin_level(MUX_A, grid_module_pbf4_reva_mux/1%2);
    8586:	781a      	ldrb	r2, [r3, #0]
    8588:	f012 0f01 	tst.w	r2, #1
	uint8_t adc_index_1 = grid_module_pbf4_reva_mux_lookup[grid_module_pbf4_reva_mux+0];
    858c:	b2e4      	uxtb	r4, r4
    858e:	4a98      	ldr	r2, [pc, #608]	; (87f0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    8590:	f44f 2100 	mov.w	r1, #524288	; 0x80000
    8594:	d133      	bne.n	85fe <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xc6>
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8596:	f8c2 1114 	str.w	r1, [r2, #276]	; 0x114
}
    859a:	e032      	b.n	8602 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0xca>
		grid_sys_state.bank_active_changed = 0;
    859c:	2500      	movs	r5, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    859e:	4c95      	ldr	r4, [pc, #596]	; (87f4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>)
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    85a0:	4e95      	ldr	r6, [pc, #596]	; (87f8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c0>)
		grid_sys_state.bank_active_changed = 0;
    85a2:	745d      	strb	r5, [r3, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    85a4:	2764      	movs	r7, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    85a6:	6863      	ldr	r3, [r4, #4]
    85a8:	f89a 100f 	ldrb.w	r1, [sl, #15]
    85ac:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    85b0:	b2ea      	uxtb	r2, r5
    85b2:	7a5b      	ldrb	r3, [r3, #9]
    85b4:	4293      	cmp	r3, r2
    85b6:	d9d0      	bls.n	855a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    85b8:	6863      	ldr	r3, [r4, #4]
    85ba:	f89a 100f 	ldrb.w	r1, [sl, #15]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    85be:	9201      	str	r2, [sp, #4]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    85c0:	eb03 1301 	add.w	r3, r3, r1, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    85c4:	4620      	mov	r0, r4
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = i;
    85c6:	68db      	ldr	r3, [r3, #12]
    85c8:	fb07 3302 	mla	r3, r7, r2, r3
    85cc:	3501      	adds	r5, #1
    85ce:	60da      	str	r2, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    85d0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    85d4:	2300      	movs	r3, #0
    85d6:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    85d8:	f89a 100f 	ldrb.w	r1, [sl, #15]
    85dc:	9a01      	ldr	r2, [sp, #4]
    85de:	2301      	movs	r3, #1
    85e0:	4620      	mov	r0, r4
    85e2:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DP);
    85e4:	f89a 100f 	ldrb.w	r1, [sl, #15]
    85e8:	9a01      	ldr	r2, [sp, #4]
    85ea:	2304      	movs	r3, #4
    85ec:	4620      	mov	r0, r4
    85ee:	47b0      	blx	r6
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_DR);
    85f0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    85f4:	9a01      	ldr	r2, [sp, #4]
    85f6:	2305      	movs	r3, #5
    85f8:	4620      	mov	r0, r4
    85fa:	47b0      	blx	r6
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    85fc:	e7d3      	b.n	85a6 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x6e>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    85fe:	f8c2 1118 	str.w	r1, [r2, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_pbf4_reva_mux/2%2);
    8602:	781a      	ldrb	r2, [r3, #0]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8604:	4e7d      	ldr	r6, [pc, #500]	; (87fc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c4>)
    8606:	487e      	ldr	r0, [pc, #504]	; (8800 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2c8>)
	uint32_t input_0 = adcresult_0*1.03;
    8608:	f8df b210 	ldr.w	fp, [pc, #528]	; 881c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e4>
    860c:	f8df 9210 	ldr.w	r9, [pc, #528]	; 8820 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e8>
    8610:	f012 0f02 	tst.w	r2, #2
    8614:	4a76      	ldr	r2, [pc, #472]	; (87f0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    8616:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
    861a:	bf14      	ite	ne
    861c:	f8c2 1118 	strne.w	r1, [r2, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8620:	f8c2 1114 	streq.w	r1, [r2, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_pbf4_reva_mux/4%2);
    8624:	781b      	ldrb	r3, [r3, #0]
    8626:	f013 0f04 	tst.w	r3, #4
    862a:	4b71      	ldr	r3, [pc, #452]	; (87f0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2b8>)
    862c:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8630:	bf14      	ite	ne
    8632:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8636:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    863a:	2100      	movs	r1, #0
    863c:	2302      	movs	r3, #2
    863e:	aa05      	add	r2, sp, #20
    8640:	47b0      	blx	r6
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    8642:	2302      	movs	r3, #2
    8644:	f10d 0216 	add.w	r2, sp, #22
    8648:	2100      	movs	r1, #0
    864a:	486e      	ldr	r0, [pc, #440]	; (8804 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2cc>)
    864c:	47b0      	blx	r6
	uint32_t input_0 = adcresult_0*1.03;
    864e:	f8bd 0014 	ldrh.w	r0, [sp, #20]
    8652:	4e6d      	ldr	r6, [pc, #436]	; (8808 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d0>)
    8654:	47d8      	blx	fp
    8656:	a360      	add	r3, pc, #384	; (adr r3, 87d8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    8658:	e9d3 2300 	ldrd	r2, r3, [r3]
    865c:	47b0      	blx	r6
    865e:	47c8      	blx	r9
    8660:	f64f 77ff 	movw	r7, #65535	; 0xffff
    8664:	42b8      	cmp	r0, r7
    8666:	4680      	mov	r8, r0
    8668:	bf28      	it	cs
    866a:	46b8      	movcs	r8, r7
    866c:	9001      	str	r0, [sp, #4]
	adcresult_0 = input_0;
    866e:	f8ad 8014 	strh.w	r8, [sp, #20]
	uint32_t input_1 = adcresult_1*1.03;
    8672:	f8bd 0016 	ldrh.w	r0, [sp, #22]
    8676:	47d8      	blx	fp
    8678:	a357      	add	r3, pc, #348	; (adr r3, 87d8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a0>)
    867a:	e9d3 2300 	ldrd	r2, r3, [r3]
    867e:	47b0      	blx	r6
    8680:	47c8      	blx	r9
	adcresult_1 = input_1;
    8682:	42b8      	cmp	r0, r7
    8684:	4603      	mov	r3, r0
    8686:	bf28      	it	cs
    8688:	463b      	movcs	r3, r7
    868a:	f8ad 3016 	strh.w	r3, [sp, #22]
	if (adc_index_1 == 8 || adc_index_1 == 9){
    868e:	f1a4 0308 	sub.w	r3, r4, #8
    8692:	2b01      	cmp	r3, #1
    8694:	d972      	bls.n	877c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
	else if (adc_index_0 > 13){ // BUTTON
    8696:	2d0d      	cmp	r5, #13
    8698:	f8df 9188 	ldr.w	r9, [pc, #392]	; 8824 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2ec>
    869c:	f240 80c4 	bls.w	8828 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2f0>
		uint8_t result_value[2] = {0};
    86a0:	2300      	movs	r3, #0
		if (adcresult_0>60000){
    86a2:	9a01      	ldr	r2, [sp, #4]
		uint8_t result_value[2] = {0};
    86a4:	f8ad 300c 	strh.w	r3, [sp, #12]
		uint8_t result_valid[2] = {0};
    86a8:	f8ad 3010 	strh.w	r3, [sp, #16]
		if (adcresult_0>60000){
    86ac:	f64e 2360 	movw	r3, #60000	; 0xea60
		result_index[0] = adc_index_0-4;
    86b0:	3d04      	subs	r5, #4
		result_index[1] = adc_index_1-4;
    86b2:	3c04      	subs	r4, #4
		if (adcresult_0>60000){
    86b4:	429a      	cmp	r2, r3
		result_index[0] = adc_index_0-4;
    86b6:	f88d 5008 	strb.w	r5, [sp, #8]
		result_index[1] = adc_index_1-4;
    86ba:	f88d 4009 	strb.w	r4, [sp, #9]
		if (adcresult_0>60000){
    86be:	d963      	bls.n	8788 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x250>
			result_valid[0] = 1;
    86c0:	2301      	movs	r3, #1
    86c2:	f88d 3010 	strb.w	r3, [sp, #16]
		if (adcresult_1>60000){
    86c6:	f64e 2360 	movw	r3, #60000	; 0xea60
    86ca:	4298      	cmp	r0, r3
    86cc:	d963      	bls.n	8796 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x25e>
			result_value[1] = 0;
    86ce:	2300      	movs	r3, #0
			result_value[1] = 127;
    86d0:	f88d 300d 	strb.w	r3, [sp, #13]
			result_valid[1] = 1;
    86d4:	2301      	movs	r3, #1
    86d6:	f88d 3011 	strb.w	r3, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    86da:	4b4c      	ldr	r3, [pc, #304]	; (880c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d4>)
    86dc:	ac06      	add	r4, sp, #24
    86de:	6818      	ldr	r0, [r3, #0]
    86e0:	6859      	ldr	r1, [r3, #4]
    86e2:	4622      	mov	r2, r4
    86e4:	c203      	stmia	r2!, {r0, r1}
    86e6:	3308      	adds	r3, #8
    86e8:	454b      	cmp	r3, r9
    86ea:	4614      	mov	r4, r2
    86ec:	d1f7      	bne.n	86de <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a6>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    86ee:	f8df b104 	ldr.w	fp, [pc, #260]	; 87f4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2bc>
    86f2:	ab03      	add	r3, sp, #12
    86f4:	f10d 0808 	add.w	r8, sp, #8
    86f8:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    86fa:	2400      	movs	r4, #0
    86fc:	46d9      	mov	r9, fp
			uint8_t res_value = result_value[i];
    86fe:	9b01      	ldr	r3, [sp, #4]
			uint8_t res_index = result_index[i];
    8700:	f818 7b01 	ldrb.w	r7, [r8], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    8704:	4a42      	ldr	r2, [pc, #264]	; (8810 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
			uint8_t res_value = result_value[i];
    8706:	f813 6b01 	ldrb.w	r6, [r3], #1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    870a:	5dd2      	ldrb	r2, [r2, r7]
			uint8_t res_value = result_value[i];
    870c:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    870e:	f8db 3004 	ldr.w	r3, [fp, #4]
    8712:	f89a 100f 	ldrb.w	r1, [sl, #15]
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    8716:	4296      	cmp	r6, r2
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8718:	b2c9      	uxtb	r1, r1
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    871a:	d02e      	beq.n	877a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			uint8_t res_valid = result_valid[i];
    871c:	a804      	add	r0, sp, #16
			if (res_value != grid_pbf4_helper_template_b_abs[res_index] && res_valid == 1){
    871e:	5c20      	ldrb	r0, [r4, r0]
    8720:	2801      	cmp	r0, #1
    8722:	d12a      	bne.n	877a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x242>
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8724:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    8728:	2064      	movs	r0, #100	; 0x64
    872a:	68db      	ldr	r3, [r3, #12]
    872c:	fb17 f000 	smulbb	r0, r7, r0
    8730:	4403      	add	r3, r0
				if (grid_pbf4_helper_template_b_abs[res_index] == 0){ // Button Press Event
    8732:	2a00      	cmp	r2, #0
    8734:	d13b      	bne.n	87ae <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x276>
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] == 0){
    8736:	6999      	ldr	r1, [r3, #24]
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2] = 0;
    8738:	2900      	cmp	r1, #0
    873a:	bf0c      	ite	eq
    873c:	217f      	moveq	r1, #127	; 0x7f
    873e:	2100      	movne	r1, #0
    8740:	6199      	str	r1, [r3, #24]
					if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 0){
    8742:	69d9      	ldr	r1, [r3, #28]
    8744:	bb69      	cbnz	r1, 87a2 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x26a>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 63;
    8746:	213f      	movs	r1, #63	; 0x3f
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    8748:	61d9      	str	r1, [r3, #28]
					grid_pbf4_helper_template_b_tgl2[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL2];
    874a:	f89a 300f 	ldrb.w	r3, [sl, #15]
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    874e:	f89a 300f 	ldrb.w	r3, [sl, #15]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    8752:	227f      	movs	r2, #127	; 0x7f
					grid_pbf4_helper_template_b_tgl3[grid_sys_state.bank_activebank_number][i] = template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3];
    8754:	2300      	movs	r3, #0
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8756:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    875a:	4419      	add	r1, r3
    875c:	3310      	adds	r3, #16
    875e:	68c9      	ldr	r1, [r1, #12]
    8760:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8762:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 127;      
    8764:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8766:	d1f6      	bne.n	8756 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x21e>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DP);
    8768:	f89a 100f 	ldrb.w	r1, [sl, #15]
    876c:	2304      	movs	r3, #4
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    876e:	4d29      	ldr	r5, [pc, #164]	; (8814 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2dc>)
    8770:	463a      	mov	r2, r7
    8772:	4658      	mov	r0, fp
    8774:	47a8      	blx	r5
					grid_pbf4_helper_template_b_abs[result_index[i]] = res_value;
    8776:	4b26      	ldr	r3, [pc, #152]	; (8810 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2d8>)
    8778:	55de      	strb	r6, [r3, r7]
		for (uint8_t i=0; i<2; i++)
    877a:	b184      	cbz	r4, 879e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x266>
	grid_module_pbf4_reva_hardware_transfer_complete = 0;
    877c:	4a18      	ldr	r2, [pc, #96]	; (87e0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2a8>)
    877e:	2300      	movs	r3, #0
    8780:	7013      	strb	r3, [r2, #0]
	grid_module_pbf4_reva_hardware_start_transfer();
    8782:	4b25      	ldr	r3, [pc, #148]	; (8818 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x2e0>)
    8784:	4798      	blx	r3
    8786:	e6e1      	b.n	854c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x14>
		else if (adcresult_0<200){
    8788:	9b01      	ldr	r3, [sp, #4]
    878a:	2bc7      	cmp	r3, #199	; 0xc7
    878c:	d89b      	bhi.n	86c6 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x18e>
			result_value[0] = 127;
    878e:	237f      	movs	r3, #127	; 0x7f
    8790:	f88d 300c 	strb.w	r3, [sp, #12]
    8794:	e794      	b.n	86c0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x188>
		else if (adcresult_1<200){
    8796:	28c7      	cmp	r0, #199	; 0xc7
    8798:	d89f      	bhi.n	86da <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1a2>
			result_value[1] = 127;
    879a:	237f      	movs	r3, #127	; 0x7f
    879c:	e798      	b.n	86d0 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x198>
    879e:	2401      	movs	r4, #1
    87a0:	e7ad      	b.n	86fe <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x1c6>
					else if (template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] == 63){
    87a2:	293f      	cmp	r1, #63	; 0x3f
    87a4:	d101      	bne.n	87aa <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x272>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 127;
    87a6:	217f      	movs	r1, #127	; 0x7f
    87a8:	e7ce      	b.n	8748 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x210>
						template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_TGL3] = 0;
    87aa:	61da      	str	r2, [r3, #28]
    87ac:	e7cd      	b.n	874a <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x212>
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    87ae:	aa0a      	add	r2, sp, #40	; 0x28
    87b0:	19d1      	adds	r1, r2, r7
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER] = res_index;
    87b2:	60df      	str	r7, [r3, #12]
					template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    87b4:	f811 1c10 	ldrb.w	r1, [r1, #-16]
    87b8:	6119      	str	r1, [r3, #16]
    87ba:	2300      	movs	r3, #0
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    87bc:	461a      	mov	r2, r3
                        template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    87be:	f8d9 1004 	ldr.w	r1, [r9, #4]
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    87c2:	4419      	add	r1, r3
    87c4:	3310      	adds	r3, #16
    87c6:	68c9      	ldr	r1, [r1, #12]
    87c8:	4401      	add	r1, r0
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    87ca:	2b40      	cmp	r3, #64	; 0x40
                        template_parameter_list[GRID_TEMPLATE_B_PARAMETER_CONTROLLER_ABS] = 0;      
    87cc:	614a      	str	r2, [r1, #20]
                    for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    87ce:	d1f6      	bne.n	87be <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x286>
					grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_DR);
    87d0:	f89a 100f 	ldrb.w	r1, [sl, #15]
    87d4:	2305      	movs	r3, #5
    87d6:	e7ca      	b.n	876e <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x236>
    87d8:	47ae147b 	.word	0x47ae147b
    87dc:	3ff07ae1 	.word	0x3ff07ae1
    87e0:	2000c0ac 	.word	0x2000c0ac
    87e4:	2000f008 	.word	0x2000f008
    87e8:	2001c7c8 	.word	0x2001c7c8
    87ec:	20000329 	.word	0x20000329
    87f0:	41008000 	.word	0x41008000
    87f4:	2000effc 	.word	0x2000effc
    87f8:	0000adf5 	.word	0x0000adf5
    87fc:	0000eeb5 	.word	0x0000eeb5
    8800:	2001cd84 	.word	0x2001cd84
    8804:	2001cf58 	.word	0x2001cf58
    8808:	00014879 	.word	0x00014879
    880c:	00016952 	.word	0x00016952
    8810:	200007eb 	.word	0x200007eb
    8814:	0000aaa1 	.word	0x0000aaa1
    8818:	00008519 	.word	0x00008519
    881c:	000147a5 	.word	0x000147a5
    8820:	00014c9d 	.word	0x00014c9d
    8824:	00016962 	.word	0x00016962
		if (adc_index_1 == 0 || adc_index_1 == 1){
    8828:	2c01      	cmp	r4, #1
    882a:	4e33      	ldr	r6, [pc, #204]	; (88f8 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c0>)
    882c:	d85e      	bhi.n	88ec <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3b4>
			grid_ain_add_sample(adc_index_0, (1<<16)-1-adcresult_0);
    882e:	ea88 0107 	eor.w	r1, r8, r7
    8832:	4628      	mov	r0, r5
    8834:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, (1<<16)-1-adcresult_1);
    8836:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    883a:	1a79      	subs	r1, r7, r1
			grid_ain_add_sample(adc_index_1, adcresult_1);
    883c:	4620      	mov	r0, r4
    883e:	47b0      	blx	r6
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8840:	4a2e      	ldr	r2, [pc, #184]	; (88fc <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c4>)
		result_index[0] = adc_index_0;
    8842:	f88d 5010 	strb.w	r5, [sp, #16]
		result_index[1] = adc_index_1;
    8846:	f88d 4011 	strb.w	r4, [sp, #17]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    884a:	ab06      	add	r3, sp, #24
    884c:	6810      	ldr	r0, [r2, #0]
    884e:	6851      	ldr	r1, [r2, #4]
    8850:	461c      	mov	r4, r3
    8852:	c403      	stmia	r4!, {r0, r1}
    8854:	3208      	adds	r2, #8
    8856:	454a      	cmp	r2, r9
    8858:	4623      	mov	r3, r4
    885a:	d1f7      	bne.n	884c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x314>
		for (uint8_t i=0; i<2; i++)
    885c:	ab04      	add	r3, sp, #16
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    885e:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 8908 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>
    8862:	9301      	str	r3, [sp, #4]
		uint8_t grid_module_pbf4_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8864:	f04f 0902 	mov.w	r9, #2
			uint8_t res_index = result_index[i];
    8868:	9b01      	ldr	r3, [sp, #4]
    886a:	f813 4b01 	ldrb.w	r4, [r3], #1
    886e:	9301      	str	r3, [sp, #4]
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8870:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8874:	f89a 200f 	ldrb.w	r2, [sl, #15]
    8878:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			if (grid_ain_get_changed(res_index)){
    887c:	4620      	mov	r0, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    887e:	68dd      	ldr	r5, [r3, #12]
			if (grid_ain_get_changed(res_index)){
    8880:	4b1f      	ldr	r3, [pc, #124]	; (8900 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3c8>)
    8882:	4798      	blx	r3
    8884:	b358      	cbz	r0, 88de <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3a6>
				uint8_t res_value = grid_ain_get_average(res_index, 7);
    8886:	4e1f      	ldr	r6, [pc, #124]	; (8904 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3cc>)
    8888:	2107      	movs	r1, #7
    888a:	4620      	mov	r0, r4
    888c:	47b0      	blx	r6
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    888e:	2764      	movs	r7, #100	; 0x64
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    8890:	ab0a      	add	r3, sp, #40	; 0x28
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8892:	fb14 f707 	smulbb	r7, r4, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    8896:	4423      	add	r3, r4
			int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8898:	443d      	add	r5, r7
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    889a:	f813 3c10 	ldrb.w	r3, [r3, #-16]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    889e:	60ec      	str	r4, [r5, #12]
				template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_pbf4_mux_reversed_lookup[res_index];
    88a0:	612b      	str	r3, [r5, #16]
    88a2:	2500      	movs	r5, #0
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    88a4:	4b18      	ldr	r3, [pc, #96]	; (8908 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d0>)
    88a6:	685a      	ldr	r2, [r3, #4]
    88a8:	442a      	add	r2, r5
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    88aa:	2107      	movs	r1, #7
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    88ac:	68d2      	ldr	r2, [r2, #12]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    88ae:	4620      	mov	r0, r4
                	template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    88b0:	eb02 0b07 	add.w	fp, r2, r7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    88b4:	47b0      	blx	r6
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    88b6:	2107      	movs	r1, #7
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    88b8:	f8cb 0014 	str.w	r0, [fp, #20]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    88bc:	4620      	mov	r0, r4
    88be:	47b0      	blx	r6
    88c0:	3510      	adds	r5, #16
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    88c2:	2300      	movs	r3, #0
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    88c4:	2d40      	cmp	r5, #64	; 0x40
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    88c6:	f8cb 0018 	str.w	r0, [fp, #24]
                    template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    88ca:	f8cb 301c 	str.w	r3, [fp, #28]
                for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    88ce:	d1e9      	bne.n	88a4 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x36c>
				grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);
    88d0:	4622      	mov	r2, r4
    88d2:	f89a 100f 	ldrb.w	r1, [sl, #15]
    88d6:	4c0d      	ldr	r4, [pc, #52]	; (890c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x3d4>)
    88d8:	2301      	movs	r3, #1
    88da:	4640      	mov	r0, r8
    88dc:	47a0      	blx	r4
		for (uint8_t i=0; i<2; i++)
    88de:	f1b9 0f01 	cmp.w	r9, #1
    88e2:	f43f af4b 	beq.w	877c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x244>
    88e6:	f04f 0901 	mov.w	r9, #1
    88ea:	e7bd      	b.n	8868 <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x330>
			grid_ain_add_sample(adc_index_0, adcresult_0);
    88ec:	4641      	mov	r1, r8
    88ee:	4628      	mov	r0, r5
    88f0:	47b0      	blx	r6
			grid_ain_add_sample(adc_index_1, adcresult_1);
    88f2:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    88f6:	e7a1      	b.n	883c <grid_module_pbf4_reva_hardware_transfer_complete_cb+0x304>
    88f8:	000045e9 	.word	0x000045e9
    88fc:	00016952 	.word	0x00016952
    8900:	000046b1 	.word	0x000046b1
    8904:	000046c1 	.word	0x000046c1
    8908:	2000effc 	.word	0x2000effc
    890c:	0000aaa1 	.word	0x0000aaa1

00008910 <grid_module_pbf4_reva_hardware_init>:

void grid_module_pbf4_reva_hardware_init(void){
    8910:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8912:	4c0b      	ldr	r4, [pc, #44]	; (8940 <grid_module_pbf4_reva_hardware_init+0x30>)
    8914:	4e0b      	ldr	r6, [pc, #44]	; (8944 <grid_module_pbf4_reva_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8916:	4d0c      	ldr	r5, [pc, #48]	; (8948 <grid_module_pbf4_reva_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8918:	4b0c      	ldr	r3, [pc, #48]	; (894c <grid_module_pbf4_reva_hardware_init+0x3c>)
    891a:	2200      	movs	r2, #0
    891c:	4611      	mov	r1, r2
    891e:	4620      	mov	r0, r4
    8920:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_pbf4_reva_hardware_transfer_complete_cb);
    8922:	2200      	movs	r2, #0
    8924:	4b09      	ldr	r3, [pc, #36]	; (894c <grid_module_pbf4_reva_hardware_init+0x3c>)
    8926:	4611      	mov	r1, r2
    8928:	4628      	mov	r0, r5
    892a:	47b0      	blx	r6
	
	adc_async_enable_channel(&ADC_0, 0);
    892c:	4620      	mov	r0, r4
    892e:	4c08      	ldr	r4, [pc, #32]	; (8950 <grid_module_pbf4_reva_hardware_init+0x40>)
    8930:	2100      	movs	r1, #0
    8932:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8934:	4628      	mov	r0, r5
    8936:	4623      	mov	r3, r4
    8938:	2100      	movs	r1, #0

}
    893a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    893e:	4718      	bx	r3
    8940:	2001cd84 	.word	0x2001cd84
    8944:	0000ee3d 	.word	0x0000ee3d
    8948:	2001cf58 	.word	0x2001cf58
    894c:	00008539 	.word	0x00008539
    8950:	0000edfd 	.word	0x0000edfd

00008954 <grid_module_pbf4_reva_init>:




void grid_module_pbf4_reva_init(){
    8954:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    8958:	220e      	movs	r2, #14
    895a:	4c16      	ldr	r4, [pc, #88]	; (89b4 <grid_module_pbf4_reva_init+0x60>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);

	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
		
		grid_ui_bank_init(&grid_ui_state, i, 12);
    895c:	4e16      	ldr	r6, [pc, #88]	; (89b8 <grid_module_pbf4_reva_init+0x64>)
    895e:	f8df 9074 	ldr.w	r9, [pc, #116]	; 89d4 <grid_module_pbf4_reva_init+0x80>
    8962:	4f16      	ldr	r7, [pc, #88]	; (89bc <grid_module_pbf4_reva_init+0x68>)
	grid_ain_init(16, 5, 14, 7);
    8964:	2307      	movs	r3, #7
    8966:	2105      	movs	r1, #5
    8968:	2010      	movs	r0, #16
    896a:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 12);	
    896c:	4b14      	ldr	r3, [pc, #80]	; (89c0 <grid_module_pbf4_reva_init+0x6c>)
    896e:	4815      	ldr	r0, [pc, #84]	; (89c4 <grid_module_pbf4_reva_init+0x70>)
    8970:	210c      	movs	r1, #12
    8972:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    8974:	4810      	ldr	r0, [pc, #64]	; (89b8 <grid_module_pbf4_reva_init+0x64>)
    8976:	4b14      	ldr	r3, [pc, #80]	; (89c8 <grid_module_pbf4_reva_init+0x74>)
    8978:	2104      	movs	r1, #4
    897a:	4798      	blx	r3
    897c:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 12);
    897e:	220c      	movs	r2, #12
    8980:	b2e1      	uxtb	r1, r4
    8982:	4630      	mov	r0, r6
    8984:	47c8      	blx	r9
		
		for(uint8_t j=0; j<12; j++){
    8986:	ea4f 1804 	mov.w	r8, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 12);
    898a:	2500      	movs	r5, #0
			
				
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    898c:	6870      	ldr	r0, [r6, #4]
			if (j<8){ // PORENTIOMETERS & FADERS -> MIDI Control Change
    898e:	2d07      	cmp	r5, #7
    8990:	b2e9      	uxtb	r1, r5
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8992:	bf94      	ite	ls
    8994:	2201      	movls	r2, #1
			
			}
			else{ // BUTTONS -> MIDI Note On/Off
				
				grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_BUTTON);
    8996:	2202      	movhi	r2, #2
    8998:	4440      	add	r0, r8
    899a:	3501      	adds	r5, #1
    899c:	47b8      	blx	r7
		for(uint8_t j=0; j<12; j++){
    899e:	2d0c      	cmp	r5, #12
    89a0:	d1f4      	bne.n	898c <grid_module_pbf4_reva_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    89a2:	3401      	adds	r4, #1
    89a4:	2c04      	cmp	r4, #4
    89a6:	d1ea      	bne.n	897e <grid_module_pbf4_reva_init+0x2a>
			}
			
		}	
	}
			
	grid_module_pbf4_reva_hardware_init();
    89a8:	4b08      	ldr	r3, [pc, #32]	; (89cc <grid_module_pbf4_reva_init+0x78>)
    89aa:	4798      	blx	r3
	grid_module_pbf4_reva_hardware_start_transfer();
	
    89ac:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_pbf4_reva_hardware_start_transfer();
    89b0:	4b07      	ldr	r3, [pc, #28]	; (89d0 <grid_module_pbf4_reva_init+0x7c>)
    89b2:	4718      	bx	r3
    89b4:	000045a5 	.word	0x000045a5
    89b8:	2000effc 	.word	0x2000effc
    89bc:	0000ace1 	.word	0x0000ace1
    89c0:	0000781d 	.word	0x0000781d
    89c4:	2001c838 	.word	0x2001c838
    89c8:	0000a381 	.word	0x0000a381
    89cc:	00008911 	.word	0x00008911
    89d0:	00008519 	.word	0x00008519
    89d4:	0000a3b5 	.word	0x0000a3b5

000089d8 <grid_module_po16_revb_hardware_start_transfer>:

volatile uint8_t grid_module_po16_revb_hardware_transfer_complete = 0;
volatile uint8_t grid_module_po16_revb_mux =0;
volatile uint8_t grid_module_po16_revb_mux_lookup[16] = {0, 1, 4, 5, 8, 9, 12, 13, 2, 3, 6, 7, 10, 11, 14, 15};

void grid_module_po16_revb_hardware_start_transfer(void){
    89d8:	b510      	push	{r4, lr}
	
	adc_async_start_conversion(&ADC_0);
    89da:	4c04      	ldr	r4, [pc, #16]	; (89ec <grid_module_po16_revb_hardware_start_transfer+0x14>)
    89dc:	4804      	ldr	r0, [pc, #16]	; (89f0 <grid_module_po16_revb_hardware_start_transfer+0x18>)
    89de:	47a0      	blx	r4
	adc_async_start_conversion(&ADC_1);
    89e0:	4623      	mov	r3, r4
    89e2:	4804      	ldr	r0, [pc, #16]	; (89f4 <grid_module_po16_revb_hardware_start_transfer+0x1c>)
	
}
    89e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	adc_async_start_conversion(&ADC_1);
    89e8:	4718      	bx	r3
    89ea:	bf00      	nop
    89ec:	0000ef71 	.word	0x0000ef71
    89f0:	2001cd84 	.word	0x2001cd84
    89f4:	2001cf58 	.word	0x2001cf58

000089f8 <grid_module_po16_revb_hardware_transfer_complete_cb>:

static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    89f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    89fc:	4a88      	ldr	r2, [pc, #544]	; (8c20 <grid_module_po16_revb_hardware_transfer_complete_cb+0x228>)
    89fe:	7813      	ldrb	r3, [r2, #0]
static void grid_module_po16_revb_hardware_transfer_complete_cb(void){
    8a00:	b089      	sub	sp, #36	; 0x24
    8a02:	4614      	mov	r4, r2
	if (grid_module_po16_revb_hardware_transfer_complete == 0){
    8a04:	b933      	cbnz	r3, 8a14 <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c>
		grid_module_po16_revb_hardware_transfer_complete++;
    8a06:	7813      	ldrb	r3, [r2, #0]
    8a08:	3301      	adds	r3, #1
    8a0a:	b2db      	uxtb	r3, r3
    8a0c:	7013      	strb	r3, [r2, #0]
	}
	
	
	grid_module_po16_revb_hardware_transfer_complete = 0;
	grid_module_po16_revb_hardware_start_transfer();
}
    8a0e:	b009      	add	sp, #36	; 0x24
    8a10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (grid_sys_state.bank_active_changed){
    8a14:	4d83      	ldr	r5, [pc, #524]	; (8c24 <grid_module_po16_revb_hardware_transfer_complete_cb+0x22c>)
    8a16:	7c6b      	ldrb	r3, [r5, #17]
    8a18:	b9fb      	cbnz	r3, 8a5a <grid_module_po16_revb_hardware_transfer_complete_cb+0x62>
	uint16_t adcresult_0 = 0;
    8a1a:	2300      	movs	r3, #0
    8a1c:	f8ad 300c 	strh.w	r3, [sp, #12]
	uint16_t adcresult_1 = 0;
    8a20:	f8ad 300e 	strh.w	r3, [sp, #14]
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    8a24:	7863      	ldrb	r3, [r4, #1]
    8a26:	4a80      	ldr	r2, [pc, #512]	; (8c28 <grid_module_po16_revb_hardware_transfer_complete_cb+0x230>)
    8a28:	3308      	adds	r3, #8
    8a2a:	5cd7      	ldrb	r7, [r2, r3]
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    8a2c:	7863      	ldrb	r3, [r4, #1]
    8a2e:	b2db      	uxtb	r3, r3
	uint8_t adc_index_0 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+8];
    8a30:	b2ff      	uxtb	r7, r7
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    8a32:	5cd6      	ldrb	r6, [r2, r3]
	grid_module_po16_revb_mux++;
    8a34:	7863      	ldrb	r3, [r4, #1]
    8a36:	3301      	adds	r3, #1
    8a38:	b2db      	uxtb	r3, r3
    8a3a:	7063      	strb	r3, [r4, #1]
	grid_module_po16_revb_mux%=8;
    8a3c:	7863      	ldrb	r3, [r4, #1]
    8a3e:	f003 0307 	and.w	r3, r3, #7
    8a42:	7063      	strb	r3, [r4, #1]
	gpio_set_pin_level(MUX_A, grid_module_po16_revb_mux/1%2);
    8a44:	7863      	ldrb	r3, [r4, #1]
    8a46:	f013 0f01 	tst.w	r3, #1
	uint8_t adc_index_1 = grid_module_po16_revb_mux_lookup[grid_module_po16_revb_mux+0];
    8a4a:	b2f6      	uxtb	r6, r6
    8a4c:	4b77      	ldr	r3, [pc, #476]	; (8c2c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    8a4e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    8a52:	d128      	bne.n	8aa6 <grid_module_po16_revb_hardware_transfer_complete_cb+0xae>
    8a54:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
    8a58:	e027      	b.n	8aaa <grid_module_po16_revb_hardware_transfer_complete_cb+0xb2>
		grid_sys_state.bank_active_changed = 0;
    8a5a:	2600      	movs	r6, #0
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8a5c:	f8df 81e4 	ldr.w	r8, [pc, #484]	; 8c44 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8a60:	f8df 91f0 	ldr.w	r9, [pc, #496]	; 8c54 <grid_module_po16_revb_hardware_transfer_complete_cb+0x25c>
		grid_sys_state.bank_active_changed = 0;
    8a64:	746e      	strb	r6, [r5, #17]
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8a66:	f04f 0a64 	mov.w	sl, #100	; 0x64
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8a6a:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8a6e:	7bea      	ldrb	r2, [r5, #15]
    8a70:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    8a74:	b2f7      	uxtb	r7, r6
    8a76:	7a5b      	ldrb	r3, [r3, #9]
    8a78:	42bb      	cmp	r3, r7
    8a7a:	d9ce      	bls.n	8a1a <grid_module_po16_revb_hardware_transfer_complete_cb+0x22>
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8a7c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8a80:	7bea      	ldrb	r2, [r5, #15]
    8a82:	eb03 1302 	add.w	r3, r3, r2, lsl #4
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8a86:	4640      	mov	r0, r8
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8a88:	68db      	ldr	r3, [r3, #12]
    8a8a:	fb0a 3307 	mla	r3, sl, r7, r3
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8a8e:	463a      	mov	r2, r7
			grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[i].template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = i;
    8a90:	60df      	str	r7, [r3, #12]
			grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_INIT);
    8a92:	7be9      	ldrb	r1, [r5, #15]
    8a94:	2300      	movs	r3, #0
    8a96:	47c8      	blx	r9
            grid_ui_smart_trigger_local(&grid_ui_state, grid_sys_state.bank_activebank_number, i, GRID_UI_EVENT_AVC7);
    8a98:	7be9      	ldrb	r1, [r5, #15]
    8a9a:	2301      	movs	r3, #1
    8a9c:	463a      	mov	r2, r7
    8a9e:	4640      	mov	r0, r8
    8aa0:	47c8      	blx	r9
		for (uint8_t i=0; i<grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list_length; i++){
    8aa2:	3601      	adds	r6, #1
    8aa4:	e7e1      	b.n	8a6a <grid_module_po16_revb_hardware_transfer_complete_cb+0x72>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8aa6:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	gpio_set_pin_level(MUX_B, grid_module_po16_revb_mux/2%2);
    8aaa:	7863      	ldrb	r3, [r4, #1]
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8aac:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 8c58 <grid_module_po16_revb_hardware_transfer_complete_cb+0x260>
    8ab0:	485f      	ldr	r0, [pc, #380]	; (8c30 <grid_module_po16_revb_hardware_transfer_complete_cb+0x238>)
	uint32_t input_0 = adcresult_0*1.03;	
    8ab2:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 8c5c <grid_module_po16_revb_hardware_transfer_complete_cb+0x264>
    8ab6:	f8df a1a8 	ldr.w	sl, [pc, #424]	; 8c60 <grid_module_po16_revb_hardware_transfer_complete_cb+0x268>
    8aba:	f8df 91a8 	ldr.w	r9, [pc, #424]	; 8c64 <grid_module_po16_revb_hardware_transfer_complete_cb+0x26c>
    8abe:	f013 0f02 	tst.w	r3, #2
    8ac2:	4b5a      	ldr	r3, [pc, #360]	; (8c2c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    8ac4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    8ac8:	bf14      	ite	ne
    8aca:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8ace:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	gpio_set_pin_level(MUX_C, grid_module_po16_revb_mux/4%2);
    8ad2:	7863      	ldrb	r3, [r4, #1]
    8ad4:	f013 0f04 	tst.w	r3, #4
    8ad8:	4b54      	ldr	r3, [pc, #336]	; (8c2c <grid_module_po16_revb_hardware_transfer_complete_cb+0x234>)
    8ada:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    8ade:	bf14      	ite	ne
    8ae0:	f8c3 2118 	strne.w	r2, [r3, #280]	; 0x118
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    8ae4:	f8c3 2114 	streq.w	r2, [r3, #276]	; 0x114
	adc_async_read_channel(&ADC_0, 0, &adcresult_0, 2);
    8ae8:	2100      	movs	r1, #0
    8aea:	2302      	movs	r3, #2
    8aec:	aa03      	add	r2, sp, #12
    8aee:	47c0      	blx	r8
	adc_async_read_channel(&ADC_1, 0, &adcresult_1, 2);
    8af0:	2302      	movs	r3, #2
    8af2:	f10d 020e 	add.w	r2, sp, #14
    8af6:	2100      	movs	r1, #0
    8af8:	484e      	ldr	r0, [pc, #312]	; (8c34 <grid_module_po16_revb_hardware_transfer_complete_cb+0x23c>)
    8afa:	47c0      	blx	r8
	uint32_t input_0 = adcresult_0*1.03;	
    8afc:	f8bd 000c 	ldrh.w	r0, [sp, #12]
    8b00:	47d8      	blx	fp
    8b02:	a345      	add	r3, pc, #276	; (adr r3, 8c18 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    8b04:	e9d3 2300 	ldrd	r2, r3, [r3]
    8b08:	47d0      	blx	sl
    8b0a:	47c8      	blx	r9
	adcresult_0 = input_0;
    8b0c:	f64f 78ff 	movw	r8, #65535	; 0xffff
    8b10:	4540      	cmp	r0, r8
    8b12:	bf28      	it	cs
    8b14:	4640      	movcs	r0, r8
    8b16:	f8ad 000c 	strh.w	r0, [sp, #12]
	uint32_t input_1 = adcresult_1*1.03;	
    8b1a:	f8bd 000e 	ldrh.w	r0, [sp, #14]
    8b1e:	47d8      	blx	fp
    8b20:	a33d      	add	r3, pc, #244	; (adr r3, 8c18 <grid_module_po16_revb_hardware_transfer_complete_cb+0x220>)
    8b22:	e9d3 2300 	ldrd	r2, r3, [r3]
    8b26:	47d0      	blx	sl
    8b28:	47c8      	blx	r9
	adcresult_1 = input_1;
    8b2a:	4540      	cmp	r0, r8
    8b2c:	bf28      	it	cs
    8b2e:	4640      	movcs	r0, r8
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    8b30:	4b41      	ldr	r3, [pc, #260]	; (8c38 <grid_module_po16_revb_hardware_transfer_complete_cb+0x240>)
	adcresult_1 = input_1;
    8b32:	f8ad 000e 	strh.w	r0, [sp, #14]
	if (grid_sys_get_hwcfg() == GRID_MODULE_PO16_RevC){
    8b36:	4798      	blx	r3
    8b38:	2808      	cmp	r0, #8
    8b3a:	d109      	bne.n	8b50 <grid_module_po16_revb_hardware_transfer_complete_cb+0x158>
		adcresult_0	= 65535 - adcresult_0;
    8b3c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    8b40:	43db      	mvns	r3, r3
    8b42:	f8ad 300c 	strh.w	r3, [sp, #12]
		adcresult_1 = 65535 - adcresult_1;
    8b46:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    8b4a:	43db      	mvns	r3, r3
    8b4c:	f8ad 300e 	strh.w	r3, [sp, #14]
	grid_ain_add_sample(adc_index_0, adcresult_0);
    8b50:	f8bd 100c 	ldrh.w	r1, [sp, #12]
    8b54:	f8df 8110 	ldr.w	r8, [pc, #272]	; 8c68 <grid_module_po16_revb_hardware_transfer_complete_cb+0x270>
    8b58:	4638      	mov	r0, r7
    8b5a:	47c0      	blx	r8
	grid_ain_add_sample(adc_index_1, adcresult_1);
    8b5c:	4630      	mov	r0, r6
    8b5e:	f8bd 100e 	ldrh.w	r1, [sp, #14]
    8b62:	47c0      	blx	r8
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8b64:	4b35      	ldr	r3, [pc, #212]	; (8c3c <grid_module_po16_revb_hardware_transfer_complete_cb+0x244>)
	result_index[0] = adc_index_0;
    8b66:	f88d 7008 	strb.w	r7, [sp, #8]
	result_index[1] = adc_index_1;
    8b6a:	f88d 6009 	strb.w	r6, [sp, #9]
	uint8_t grid_module_po16_mux_reversed_lookup[16] =   {12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3};
    8b6e:	f103 0710 	add.w	r7, r3, #16
    8b72:	ae04      	add	r6, sp, #16
    8b74:	6818      	ldr	r0, [r3, #0]
    8b76:	6859      	ldr	r1, [r3, #4]
    8b78:	4632      	mov	r2, r6
    8b7a:	c203      	stmia	r2!, {r0, r1}
    8b7c:	3308      	adds	r3, #8
    8b7e:	42bb      	cmp	r3, r7
    8b80:	4616      	mov	r6, r2
    8b82:	d1f7      	bne.n	8b74 <grid_module_po16_revb_hardware_transfer_complete_cb+0x17c>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8b84:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 8c44 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>
    8b88:	f10d 0a08 	add.w	sl, sp, #8
	for (uint8_t i=0; i<2; i++)
    8b8c:	f04f 0900 	mov.w	r9, #0
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8b90:	f8d8 3004 	ldr.w	r3, [r8, #4]
    8b94:	7bea      	ldrb	r2, [r5, #15]
		uint8_t res_index = result_index[i];
    8b96:	f81a 6b01 	ldrb.w	r6, [sl], #1
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8b9a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
		if (grid_ain_get_changed(res_index)){
    8b9e:	4630      	mov	r0, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8ba0:	68df      	ldr	r7, [r3, #12]
		if (grid_ain_get_changed(res_index)){
    8ba2:	4b27      	ldr	r3, [pc, #156]	; (8c40 <grid_module_po16_revb_hardware_transfer_complete_cb+0x248>)
    8ba4:	4798      	blx	r3
    8ba6:	b350      	cbz	r0, 8bfe <grid_module_po16_revb_hardware_transfer_complete_cb+0x206>
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8ba8:	2264      	movs	r2, #100	; 0x64
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8baa:	a908      	add	r1, sp, #32
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8bac:	fb16 f202 	smulbb	r2, r6, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8bb0:	4431      	add	r1, r6
		int32_t* template_parameter_list = grid_ui_state.bank_list[grid_sys_state.bank_activebank_number].element_list[res_index].template_parameter_list;
    8bb2:	18bb      	adds	r3, r7, r2
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8bb4:	f811 1c10 	ldrb.w	r1, [r1, #-16]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER] = res_index;
    8bb8:	60de      	str	r6, [r3, #12]
			template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_NUMBER_REVERSED] = grid_module_po16_mux_reversed_lookup[res_index];
    8bba:	6119      	str	r1, [r3, #16]
    8bbc:	2700      	movs	r7, #0
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8bbe:	4b21      	ldr	r3, [pc, #132]	; (8c44 <grid_module_po16_revb_hardware_transfer_complete_cb+0x24c>)
    8bc0:	9201      	str	r2, [sp, #4]
    8bc2:	685b      	ldr	r3, [r3, #4]
    8bc4:	443b      	add	r3, r7
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8bc6:	2107      	movs	r1, #7
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8bc8:	68db      	ldr	r3, [r3, #12]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8bca:	4630      	mov	r0, r6
                template_parameter_list = grid_ui_state.bank_list[j].element_list[res_index].template_parameter_list;
    8bcc:	eb03 0b02 	add.w	fp, r3, r2
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8bd0:	4b1d      	ldr	r3, [pc, #116]	; (8c48 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
    8bd2:	4798      	blx	r3
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8bd4:	4b1c      	ldr	r3, [pc, #112]	; (8c48 <grid_module_po16_revb_hardware_transfer_complete_cb+0x250>)
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS] = grid_ain_get_average(res_index, 7);
    8bd6:	f8cb 0014 	str.w	r0, [fp, #20]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8bda:	2107      	movs	r1, #7
    8bdc:	4630      	mov	r0, r6
    8bde:	4798      	blx	r3
    8be0:	3710      	adds	r7, #16
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    8be2:	2300      	movs	r3, #0
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8be4:	2f40      	cmp	r7, #64	; 0x40
    8be6:	9a01      	ldr	r2, [sp, #4]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14U] = grid_ain_get_average(res_index, 7);
    8be8:	f8cb 0018 	str.w	r0, [fp, #24]
                template_parameter_list[GRID_TEMPLATE_P_PARAMETER_CONTROLLER_ABS14L] = 0;          
    8bec:	f8cb 301c 	str.w	r3, [fp, #28]
            for (uint8_t j=0; j<GRID_SYS_BANK_MAXNUMBER; j++){
    8bf0:	d1e5      	bne.n	8bbe <grid_module_po16_revb_hardware_transfer_complete_cb+0x1c6>
			grid_ui_smart_trigger(&grid_ui_state, grid_sys_state.bank_activebank_number, res_index, GRID_UI_EVENT_AVC7);		
    8bf2:	4632      	mov	r2, r6
    8bf4:	7be9      	ldrb	r1, [r5, #15]
    8bf6:	4e15      	ldr	r6, [pc, #84]	; (8c4c <grid_module_po16_revb_hardware_transfer_complete_cb+0x254>)
    8bf8:	2301      	movs	r3, #1
    8bfa:	4640      	mov	r0, r8
    8bfc:	47b0      	blx	r6
	for (uint8_t i=0; i<2; i++)
    8bfe:	f1b9 0f00 	cmp.w	r9, #0
    8c02:	d004      	beq.n	8c0e <grid_module_po16_revb_hardware_transfer_complete_cb+0x216>
	grid_module_po16_revb_hardware_transfer_complete = 0;
    8c04:	2300      	movs	r3, #0
    8c06:	7023      	strb	r3, [r4, #0]
	grid_module_po16_revb_hardware_start_transfer();
    8c08:	4b11      	ldr	r3, [pc, #68]	; (8c50 <grid_module_po16_revb_hardware_transfer_complete_cb+0x258>)
    8c0a:	4798      	blx	r3
    8c0c:	e6ff      	b.n	8a0e <grid_module_po16_revb_hardware_transfer_complete_cb+0x16>
    8c0e:	f04f 0901 	mov.w	r9, #1
    8c12:	e7bd      	b.n	8b90 <grid_module_po16_revb_hardware_transfer_complete_cb+0x198>
    8c14:	f3af 8000 	nop.w
    8c18:	47ae147b 	.word	0x47ae147b
    8c1c:	3ff07ae1 	.word	0x3ff07ae1
    8c20:	200007fd 	.word	0x200007fd
    8c24:	2000f008 	.word	0x2000f008
    8c28:	20000339 	.word	0x20000339
    8c2c:	41008000 	.word	0x41008000
    8c30:	2001cd84 	.word	0x2001cd84
    8c34:	2001cf58 	.word	0x2001cf58
    8c38:	0000a1fd 	.word	0x0000a1fd
    8c3c:	00016962 	.word	0x00016962
    8c40:	000046b1 	.word	0x000046b1
    8c44:	2000effc 	.word	0x2000effc
    8c48:	000046c1 	.word	0x000046c1
    8c4c:	0000aaa1 	.word	0x0000aaa1
    8c50:	000089d9 	.word	0x000089d9
    8c54:	0000adf5 	.word	0x0000adf5
    8c58:	0000eeb5 	.word	0x0000eeb5
    8c5c:	000147a5 	.word	0x000147a5
    8c60:	00014879 	.word	0x00014879
    8c64:	00014c9d 	.word	0x00014c9d
    8c68:	000045e9 	.word	0x000045e9

00008c6c <grid_module_po16_revb_hardware_init>:

void grid_module_po16_revb_hardware_init(void){
    8c6c:	b570      	push	{r4, r5, r6, lr}
	
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8c6e:	4c0b      	ldr	r4, [pc, #44]	; (8c9c <grid_module_po16_revb_hardware_init+0x30>)
    8c70:	4e0b      	ldr	r6, [pc, #44]	; (8ca0 <grid_module_po16_revb_hardware_init+0x34>)
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8c72:	4d0c      	ldr	r5, [pc, #48]	; (8ca4 <grid_module_po16_revb_hardware_init+0x38>)
	adc_async_register_callback(&ADC_0, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8c74:	4b0c      	ldr	r3, [pc, #48]	; (8ca8 <grid_module_po16_revb_hardware_init+0x3c>)
    8c76:	2200      	movs	r2, #0
    8c78:	4611      	mov	r1, r2
    8c7a:	4620      	mov	r0, r4
    8c7c:	47b0      	blx	r6
	adc_async_register_callback(&ADC_1, 0, ADC_ASYNC_CONVERT_CB, grid_module_po16_revb_hardware_transfer_complete_cb);
    8c7e:	2200      	movs	r2, #0
    8c80:	4b09      	ldr	r3, [pc, #36]	; (8ca8 <grid_module_po16_revb_hardware_init+0x3c>)
    8c82:	4611      	mov	r1, r2
    8c84:	4628      	mov	r0, r5
    8c86:	47b0      	blx	r6
		
	adc_async_enable_channel(&ADC_0, 0);
    8c88:	4620      	mov	r0, r4
    8c8a:	4c08      	ldr	r4, [pc, #32]	; (8cac <grid_module_po16_revb_hardware_init+0x40>)
    8c8c:	2100      	movs	r1, #0
    8c8e:	47a0      	blx	r4
	adc_async_enable_channel(&ADC_1, 0);
    8c90:	4628      	mov	r0, r5
    8c92:	4623      	mov	r3, r4
    8c94:	2100      	movs	r1, #0

}
    8c96:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	adc_async_enable_channel(&ADC_1, 0);
    8c9a:	4718      	bx	r3
    8c9c:	2001cd84 	.word	0x2001cd84
    8ca0:	0000ee3d 	.word	0x0000ee3d
    8ca4:	2001cf58 	.word	0x2001cf58
    8ca8:	000089f9 	.word	0x000089f9
    8cac:	0000edfd 	.word	0x0000edfd

00008cb0 <grid_module_po16_revb_init>:




void grid_module_po16_revb_init(){
    8cb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	// 16 pot, depth of 5, 14bit internal, 7bit result;
	grid_ain_init(16, 5, 14, 7);
    8cb4:	220e      	movs	r2, #14
    8cb6:	4c15      	ldr	r4, [pc, #84]	; (8d0c <grid_module_po16_revb_init+0x5c>)
	
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
		
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8cb8:	4e15      	ldr	r6, [pc, #84]	; (8d10 <grid_module_po16_revb_init+0x60>)
    8cba:	4f16      	ldr	r7, [pc, #88]	; (8d14 <grid_module_po16_revb_init+0x64>)
		
		for(uint8_t j=0; j<16; j++){
			
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8cbc:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8d2c <grid_module_po16_revb_init+0x7c>
	grid_ain_init(16, 5, 14, 7);
    8cc0:	2307      	movs	r3, #7
    8cc2:	2105      	movs	r1, #5
    8cc4:	2010      	movs	r0, #16
    8cc6:	47a0      	blx	r4
	grid_led_lowlevel_init(&grid_led_state, 16);
    8cc8:	4b13      	ldr	r3, [pc, #76]	; (8d18 <grid_module_po16_revb_init+0x68>)
    8cca:	4814      	ldr	r0, [pc, #80]	; (8d1c <grid_module_po16_revb_init+0x6c>)
    8ccc:	2110      	movs	r1, #16
    8cce:	4798      	blx	r3
	grid_ui_model_init(&grid_ui_state, GRID_SYS_BANK_MAXNUMBER);
    8cd0:	480f      	ldr	r0, [pc, #60]	; (8d10 <grid_module_po16_revb_init+0x60>)
    8cd2:	4b13      	ldr	r3, [pc, #76]	; (8d20 <grid_module_po16_revb_init+0x70>)
    8cd4:	2104      	movs	r1, #4
    8cd6:	4798      	blx	r3
    8cd8:	2400      	movs	r4, #0
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8cda:	2210      	movs	r2, #16
    8cdc:	b2e1      	uxtb	r1, r4
    8cde:	4630      	mov	r0, r6
    8ce0:	47b8      	blx	r7
		for(uint8_t j=0; j<16; j++){
    8ce2:	ea4f 1904 	mov.w	r9, r4, lsl #4
		grid_ui_bank_init(&grid_ui_state, i, 16);
    8ce6:	2500      	movs	r5, #0
			grid_ui_element_init(&grid_ui_state.bank_list[i], j, GRID_UI_ELEMENT_POTENTIOMETER);
    8ce8:	6870      	ldr	r0, [r6, #4]
    8cea:	b2e9      	uxtb	r1, r5
    8cec:	2201      	movs	r2, #1
    8cee:	4448      	add	r0, r9
    8cf0:	3501      	adds	r5, #1
    8cf2:	47c0      	blx	r8
		for(uint8_t j=0; j<16; j++){
    8cf4:	2d10      	cmp	r5, #16
    8cf6:	d1f7      	bne.n	8ce8 <grid_module_po16_revb_init+0x38>
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){	
    8cf8:	3401      	adds	r4, #1
    8cfa:	2c04      	cmp	r4, #4
    8cfc:	d1ed      	bne.n	8cda <grid_module_po16_revb_init+0x2a>

		}
	}
	
	grid_module_po16_revb_hardware_init();
    8cfe:	4b09      	ldr	r3, [pc, #36]	; (8d24 <grid_module_po16_revb_init+0x74>)
    8d00:	4798      	blx	r3
	grid_module_po16_revb_hardware_start_transfer();
	
    8d02:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	grid_module_po16_revb_hardware_start_transfer();
    8d06:	4b08      	ldr	r3, [pc, #32]	; (8d28 <grid_module_po16_revb_init+0x78>)
    8d08:	4718      	bx	r3
    8d0a:	bf00      	nop
    8d0c:	000045a5 	.word	0x000045a5
    8d10:	2000effc 	.word	0x2000effc
    8d14:	0000a3b5 	.word	0x0000a3b5
    8d18:	0000781d 	.word	0x0000781d
    8d1c:	2001c838 	.word	0x2001c838
    8d20:	0000a381 	.word	0x0000a381
    8d24:	00008c6d 	.word	0x00008c6d
    8d28:	000089d9 	.word	0x000089d9
    8d2c:	0000ace1 	.word	0x0000ace1

00008d30 <grid_msg_header_set_len>:

#include "grid_msg.h"


// ======================= GRID MSG LEN ======================//
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    8d30:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8d32:	2200      	movs	r2, #0
    8d34:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    8d38:	f10d 020f 	add.w	r2, sp, #15
    8d3c:	9200      	str	r2, [sp, #0]
    8d3e:	2202      	movs	r2, #2
void	grid_msg_header_set_len(struct grid_msg* msg, uint8_t len){
    8d40:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, len, &error);
    8d42:	4c02      	ldr	r4, [pc, #8]	; (8d4c <grid_msg_header_set_len+0x1c>)
    8d44:	4611      	mov	r1, r2
    8d46:	47a0      	blx	r4
	
}
    8d48:	b004      	add	sp, #16
    8d4a:	bd10      	pop	{r4, pc}
    8d4c:	0000a33d 	.word	0x0000a33d

00008d50 <grid_msg_header_set_id>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_LEN_offset, GRID_BRC_LEN_length, &error);
}

// ======================= GRID MSG ID ======================//
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    8d50:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8d52:	2200      	movs	r2, #0
    8d54:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    8d58:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_id(struct grid_msg* msg, uint8_t id){
    8d5c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, id, &error);
    8d5e:	9200      	str	r2, [sp, #0]
    8d60:	4c02      	ldr	r4, [pc, #8]	; (8d6c <grid_msg_header_set_id+0x1c>)
    8d62:	2202      	movs	r2, #2
    8d64:	2104      	movs	r1, #4
    8d66:	47a0      	blx	r4
	
}
    8d68:	b004      	add	sp, #16
    8d6a:	bd10      	pop	{r4, pc}
    8d6c:	0000a33d 	.word	0x0000a33d

00008d70 <grid_msg_header_set_dx>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ID_offset, GRID_BRC_ID_length, &error);
}

// ======================= GRID MSG DX ======================//
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8d70:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8d72:	2200      	movs	r2, #0
    8d74:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8d78:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dx(struct grid_msg* msg, uint8_t dx){
    8d7c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, dx, &error);
    8d7e:	9200      	str	r2, [sp, #0]
    8d80:	4c02      	ldr	r4, [pc, #8]	; (8d8c <grid_msg_header_set_dx+0x1c>)
    8d82:	2202      	movs	r2, #2
    8d84:	2106      	movs	r1, #6
    8d86:	47a0      	blx	r4
	
}
    8d88:	b004      	add	sp, #16
    8d8a:	bd10      	pop	{r4, pc}
    8d8c:	0000a33d 	.word	0x0000a33d

00008d90 <grid_msg_header_get_dx>:


uint8_t grid_msg_header_get_dx(struct grid_msg* msg){
    8d90:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    8d92:	2300      	movs	r3, #0
    8d94:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DX_offset, GRID_BRC_DX_length, &error);
    8d98:	4c04      	ldr	r4, [pc, #16]	; (8dac <grid_msg_header_get_dx+0x1c>)
    8d9a:	f10d 0307 	add.w	r3, sp, #7
    8d9e:	2202      	movs	r2, #2
    8da0:	2106      	movs	r1, #6
    8da2:	47a0      	blx	r4
}
    8da4:	b2c0      	uxtb	r0, r0
    8da6:	b002      	add	sp, #8
    8da8:	bd10      	pop	{r4, pc}
    8daa:	bf00      	nop
    8dac:	0000a325 	.word	0x0000a325

00008db0 <grid_msg_header_set_dy>:

// ======================= GRID MSG DY ======================//
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    8db0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8db2:	2200      	movs	r2, #0
    8db4:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    8db8:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_dy(struct grid_msg* msg, uint8_t dy){
    8dbc:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, dy, &error);
    8dbe:	9200      	str	r2, [sp, #0]
    8dc0:	4c02      	ldr	r4, [pc, #8]	; (8dcc <grid_msg_header_set_dy+0x1c>)
    8dc2:	2202      	movs	r2, #2
    8dc4:	2108      	movs	r1, #8
    8dc6:	47a0      	blx	r4
	
}
    8dc8:	b004      	add	sp, #16
    8dca:	bd10      	pop	{r4, pc}
    8dcc:	0000a33d 	.word	0x0000a33d

00008dd0 <grid_msg_header_get_dy>:


uint8_t grid_msg_header_get_dy(struct grid_msg* msg){
    8dd0:	b513      	push	{r0, r1, r4, lr}
	
	uint8_t error = 0;
    8dd2:	2300      	movs	r3, #0
    8dd4:	f88d 3007 	strb.w	r3, [sp, #7]
	return grid_msg_get_parameter(msg->header, GRID_BRC_DY_offset, GRID_BRC_DY_length, &error);
    8dd8:	4c04      	ldr	r4, [pc, #16]	; (8dec <grid_msg_header_get_dy+0x1c>)
    8dda:	f10d 0307 	add.w	r3, sp, #7
    8dde:	2202      	movs	r2, #2
    8de0:	2108      	movs	r1, #8
    8de2:	47a0      	blx	r4
}
    8de4:	b2c0      	uxtb	r0, r0
    8de6:	b002      	add	sp, #8
    8de8:	bd10      	pop	{r4, pc}
    8dea:	bf00      	nop
    8dec:	0000a325 	.word	0x0000a325

00008df0 <grid_msg_header_set_rot>:

// ======================= GRID MSG ROT ======================//
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    8df0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8df2:	2200      	movs	r2, #0
    8df4:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    8df8:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_rot(struct grid_msg* msg, uint8_t rot){
    8dfc:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, rot, &error);
    8dfe:	9200      	str	r2, [sp, #0]
    8e00:	4c02      	ldr	r4, [pc, #8]	; (8e0c <grid_msg_header_set_rot+0x1c>)
    8e02:	2202      	movs	r2, #2
    8e04:	210c      	movs	r1, #12
    8e06:	47a0      	blx	r4
	
}
    8e08:	b004      	add	sp, #16
    8e0a:	bd10      	pop	{r4, pc}
    8e0c:	0000a33d 	.word	0x0000a33d

00008e10 <grid_msg_header_set_age>:
	uint8_t error = 0;
	return grid_msg_get_parameter(msg->header, GRID_BRC_ROT_offset, GRID_BRC_ROT_length, &error);
}

// ======================= GRID MSG AGE ======================//
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    8e10:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	
	uint8_t error = 0;
    8e12:	2200      	movs	r2, #0
    8e14:	f88d 200f 	strb.w	r2, [sp, #15]
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    8e18:	f10d 020f 	add.w	r2, sp, #15
void	grid_msg_header_set_age(struct grid_msg* msg, uint8_t age){
    8e1c:	460b      	mov	r3, r1
	grid_msg_set_parameter(msg->header, GRID_BRC_AGE_offset, GRID_BRC_AGE_length, age, &error);
    8e1e:	9200      	str	r2, [sp, #0]
    8e20:	4c02      	ldr	r4, [pc, #8]	; (8e2c <grid_msg_header_set_age+0x1c>)
    8e22:	2202      	movs	r2, #2
    8e24:	210a      	movs	r1, #10
    8e26:	47a0      	blx	r4
	
}
    8e28:	b004      	add	sp, #16
    8e2a:	bd10      	pop	{r4, pc}
    8e2c:	0000a33d 	.word	0x0000a33d

00008e30 <grid_msg_packet_get_length>:
}

// ======================= MSG GET PACKET LENGTH ======================//
uint32_t grid_msg_packet_get_length(struct grid_msg* msg){
	
	return (msg->header_length + msg->body_length + msg->footer_length);
    8e30:	e9d0 3264 	ldrd	r3, r2, [r0, #400]	; 0x190
    8e34:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    8e38:	4413      	add	r3, r2
}
    8e3a:	4418      	add	r0, r3
    8e3c:	4770      	bx	lr

00008e3e <grid_msg_body_get_length>:

// ======================= MSG GET BODY LENGTH ======================//
uint32_t grid_msg_body_get_length(struct grid_msg* msg){
	
	return (msg->body_length);
}
    8e3e:	f8d0 0194 	ldr.w	r0, [r0, #404]	; 0x194
    8e42:	4770      	bx	lr

00008e44 <grid_msg_body_append_text>:
	
	return (msg->footer_length);
}


void	grid_msg_body_append_text(struct grid_msg* msg, uint8_t* str, uint32_t len){
    8e44:	b570      	push	{r4, r5, r6, lr}
    8e46:	f8d0 5194 	ldr.w	r5, [r0, #404]	; 0x194

	
	for(uint32_t i=0; i<len; i++){
    8e4a:	2300      	movs	r3, #0
    8e4c:	4293      	cmp	r3, r2
    8e4e:	d103      	bne.n	8e58 <grid_msg_body_append_text+0x14>
		
		msg->body[msg->body_length + i] = str[i];
	}
	
	msg->body_length += len;
    8e50:	442b      	add	r3, r5
    8e52:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    8e56:	bd70      	pop	{r4, r5, r6, pc}
		msg->body[msg->body_length + i] = str[i];
    8e58:	18c4      	adds	r4, r0, r3
    8e5a:	442c      	add	r4, r5
    8e5c:	5cce      	ldrb	r6, [r1, r3]
    8e5e:	7526      	strb	r6, [r4, #20]
	for(uint32_t i=0; i<len; i++){
    8e60:	3301      	adds	r3, #1
    8e62:	e7f3      	b.n	8e4c <grid_msg_body_append_text+0x8>

00008e64 <grid_msg_body_append_text_escaped>:

void	grid_msg_body_append_text_escaped(struct grid_msg* msg, uint8_t* str, uint32_t len){
    8e64:	b5f0      	push	{r4, r5, r6, r7, lr}
    8e66:	f8d0 6194 	ldr.w	r6, [r0, #404]	; 0x194
	
	for(uint32_t i=0; i<len; i++){
    8e6a:	2400      	movs	r4, #0
		
		if (str[i] == GRID_CONST_STX){
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
		}
		else if (str[i] == GRID_CONST_ETX){
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    8e6c:	2783      	movs	r7, #131	; 0x83
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8e6e:	f04f 0c82 	mov.w	ip, #130	; 0x82
	for(uint32_t i=0; i<len; i++){
    8e72:	4294      	cmp	r4, r2
    8e74:	eb04 0306 	add.w	r3, r4, r6
    8e78:	d102      	bne.n	8e80 <grid_msg_body_append_text_escaped+0x1c>
			msg->body[msg->body_length + i] = str[i];
		}
		
	}
	
	msg->body_length += len;
    8e7a:	f8c0 3194 	str.w	r3, [r0, #404]	; 0x194

}
    8e7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (str[i] == GRID_CONST_STX){
    8e80:	5d0d      	ldrb	r5, [r1, r4]
    8e82:	2d02      	cmp	r5, #2
    8e84:	4403      	add	r3, r0
    8e86:	d103      	bne.n	8e90 <grid_msg_body_append_text_escaped+0x2c>
			msg->body[msg->body_length + i] = GRID_CONST_STX+128;
    8e88:	f883 c014 	strb.w	ip, [r3, #20]
	for(uint32_t i=0; i<len; i++){
    8e8c:	3401      	adds	r4, #1
    8e8e:	e7f0      	b.n	8e72 <grid_msg_body_append_text_escaped+0xe>
		else if (str[i] == GRID_CONST_ETX){
    8e90:	2d03      	cmp	r5, #3
			msg->body[msg->body_length + i] = GRID_CONST_ETX+128;
    8e92:	bf0c      	ite	eq
    8e94:	751f      	strbeq	r7, [r3, #20]
			msg->body[msg->body_length + i] = str[i];
    8e96:	751d      	strbne	r5, [r3, #20]
    8e98:	e7f8      	b.n	8e8c <grid_msg_body_append_text_escaped+0x28>
	...

00008e9c <grid_msg_text_get_parameter>:


uint32_t grid_msg_text_get_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length){
    8e9c:	b420      	push	{r5}
	
	uint8_t error;
	
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    8e9e:	f101 0514 	add.w	r5, r1, #20
    8ea2:	4415      	add	r5, r2
    8ea4:	4619      	mov	r1, r3
    8ea6:	4428      	add	r0, r5
    8ea8:	4b02      	ldr	r3, [pc, #8]	; (8eb4 <grid_msg_text_get_parameter+0x18>)
	
}
    8eaa:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_read_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, error);
    8eae:	2200      	movs	r2, #0
    8eb0:	4718      	bx	r3
    8eb2:	bf00      	nop
    8eb4:	0000a171 	.word	0x0000a171

00008eb8 <grid_msg_text_set_parameter>:

void grid_msg_text_set_parameter(struct grid_msg* msg, uint32_t text_start_offset, uint8_t parameter_offset, uint8_t parameter_length, uint32_t value){
    8eb8:	b420      	push	{r5}
	
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    8eba:	f101 0514 	add.w	r5, r1, #20
    8ebe:	4415      	add	r5, r2
    8ec0:	4619      	mov	r1, r3
    8ec2:	9a01      	ldr	r2, [sp, #4]
    8ec4:	4b02      	ldr	r3, [pc, #8]	; (8ed0 <grid_msg_text_set_parameter+0x18>)
    8ec6:	4428      	add	r0, r5
	
}
    8ec8:	f85d 5b04 	ldr.w	r5, [sp], #4
	return grid_sys_write_hex_string_value(&msg->body[text_start_offset + parameter_offset], parameter_length, value);
    8ecc:	4718      	bx	r3
    8ece:	bf00      	nop
    8ed0:	0000a199 	.word	0x0000a199

00008ed4 <grid_msg_init>:


// ======================= GRID MSG INIT ======================//
void	grid_msg_init(struct grid_msg* msg){
	
	msg->header_length = 0;
    8ed4:	2300      	movs	r3, #0
	msg->body_length = 0;
    8ed6:	e9c0 3364 	strd	r3, r3, [r0, #400]	; 0x190
	msg->footer_length = 0;
    8eda:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
	
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    8ede:	1e42      	subs	r2, r0, #1
    8ee0:	f100 0113 	add.w	r1, r0, #19
	{
		msg->header[i] = 0;
    8ee4:	f802 3f01 	strb.w	r3, [r2, #1]!
	for (uint32_t i=0; i<GRID_MSG_HEADER_maxlength; i++)
    8ee8:	4291      	cmp	r1, r2
    8eea:	d1fb      	bne.n	8ee4 <grid_msg_init+0x10>
    8eec:	f100 0214 	add.w	r2, r0, #20
    8ef0:	f200 118b 	addw	r1, r0, #395	; 0x18b
	}
	
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
	{
		msg->body[i] = 0;
    8ef4:	2300      	movs	r3, #0
    8ef6:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_MSG_BODY_maxlength; i++)
    8efa:	428a      	cmp	r2, r1
    8efc:	d1fb      	bne.n	8ef6 <grid_msg_init+0x22>
	}
	
	for (uint32_t i=0; i<GRID_MSG_FOOTER_maxlength; i++)
	{
		msg->footer[i] = 0;
    8efe:	f880 318b 	strb.w	r3, [r0, #395]	; 0x18b
    8f02:	f8c0 318c 	str.w	r3, [r0, #396]	; 0x18c
	}
	
		
}
    8f06:	4770      	bx	lr

00008f08 <grid_msg_init_header>:

// ======================= MSG INIT HEADER======================//

void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    8f08:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    8f0c:	461e      	mov	r6, r3
	
    
    uint8_t age = grid_sys_state.sessionid;
    8f0e:	4b13      	ldr	r3, [pc, #76]	; (8f5c <grid_msg_init_header+0x54>)
    
	sprintf(msg->header, GRID_BRC_frame);
    8f10:	f8df 9064 	ldr.w	r9, [pc, #100]	; 8f78 <grid_msg_init_header+0x70>
    uint8_t age = grid_sys_state.sessionid;
    8f14:	795d      	ldrb	r5, [r3, #5]
	sprintf(msg->header, GRID_BRC_frame);
    8f16:	2317      	movs	r3, #23
void	grid_msg_init_header(struct grid_msg* msg, uint8_t dx, uint8_t dy, uint8_t rot){
    8f18:	4604      	mov	r4, r0
    8f1a:	4688      	mov	r8, r1
    8f1c:	4617      	mov	r7, r2
	sprintf(msg->header, GRID_BRC_frame);
    8f1e:	4910      	ldr	r1, [pc, #64]	; (8f60 <grid_msg_init_header+0x58>)
    8f20:	9300      	str	r3, [sp, #0]
    8f22:	2201      	movs	r2, #1
    8f24:	230f      	movs	r3, #15
    8f26:	47c8      	blx	r9
	msg->header_length = strlen(msg->header);
    8f28:	4b0e      	ldr	r3, [pc, #56]	; (8f64 <grid_msg_init_header+0x5c>)
    8f2a:	4620      	mov	r0, r4
    8f2c:	4798      	blx	r3
	
	grid_msg_header_set_dx(msg, dx);
    8f2e:	4641      	mov	r1, r8
	msg->header_length = strlen(msg->header);
    8f30:	f8c4 0190 	str.w	r0, [r4, #400]	; 0x190
	grid_msg_header_set_dx(msg, dx);
    8f34:	4b0c      	ldr	r3, [pc, #48]	; (8f68 <grid_msg_init_header+0x60>)
    8f36:	4620      	mov	r0, r4
    8f38:	4798      	blx	r3
	grid_msg_header_set_dy(msg, dy);
    8f3a:	4639      	mov	r1, r7
    8f3c:	4620      	mov	r0, r4
    8f3e:	4b0b      	ldr	r3, [pc, #44]	; (8f6c <grid_msg_init_header+0x64>)
    8f40:	4798      	blx	r3
	grid_msg_header_set_rot(msg, rot);
    8f42:	4631      	mov	r1, r6
    8f44:	4620      	mov	r0, r4
    8f46:	4b0a      	ldr	r3, [pc, #40]	; (8f70 <grid_msg_init_header+0x68>)
    8f48:	4798      	blx	r3
    uint8_t age = grid_sys_state.sessionid;
    8f4a:	b2ed      	uxtb	r5, r5
	grid_msg_header_set_age(msg, age);
    8f4c:	4b09      	ldr	r3, [pc, #36]	; (8f74 <grid_msg_init_header+0x6c>)
    8f4e:	4629      	mov	r1, r5
    8f50:	4620      	mov	r0, r4
	
	
}
    8f52:	b003      	add	sp, #12
    8f54:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
	grid_msg_header_set_age(msg, age);
    8f58:	4718      	bx	r3
    8f5a:	bf00      	nop
    8f5c:	2000f008 	.word	0x2000f008
    8f60:	00016972 	.word	0x00016972
    8f64:	00015317 	.word	0x00015317
    8f68:	00008d71 	.word	0x00008d71
    8f6c:	00008db1 	.word	0x00008db1
    8f70:	00008df1 	.word	0x00008df1
    8f74:	00008e11 	.word	0x00008e11
    8f78:	00015299 	.word	0x00015299

00008f7c <grid_msg_packet_receive_char>:

// ======================= MSG RECEIVE CHAR ======================//
void	grid_msg_packet_receive_char(struct grid_msg* msg, uint8_t nextchar){
	
	if (msg->body_length == 0){
    8f7c:	f8d0 2194 	ldr.w	r2, [r0, #404]	; 0x194
    8f80:	b96a      	cbnz	r2, 8f9e <grid_msg_packet_receive_char+0x22>
		
		if (nextchar != GRID_CONST_EOB){
    8f82:	2917      	cmp	r1, #23
			msg->header[msg->header_length] = nextchar;
    8f84:	bf15      	itete	ne
    8f86:	f8d0 3190 	ldrne.w	r3, [r0, #400]	; 0x190
			msg->header_length++;
		}
		else{
			msg->body[msg->body_length] = nextchar;
    8f8a:	7501      	strbeq	r1, [r0, #20]
			msg->header[msg->header_length] = nextchar;
    8f8c:	54c1      	strbne	r1, [r0, r3]
			msg->body_length++;
    8f8e:	2301      	moveq	r3, #1
			msg->header_length++;
    8f90:	bf1a      	itte	ne
    8f92:	3301      	addne	r3, #1
    8f94:	f8c0 3190 	strne.w	r3, [r0, #400]	; 0x190
			msg->body_length++;
    8f98:	f8c0 3194 	streq.w	r3, [r0, #404]	; 0x194
    8f9c:	4770      	bx	lr
			
		}
		
	}
	else if(msg->footer_length == 0){
    8f9e:	f8d0 3198 	ldr.w	r3, [r0, #408]	; 0x198
    8fa2:	b96b      	cbnz	r3, 8fc0 <grid_msg_packet_receive_char+0x44>
		
		if (nextchar != GRID_CONST_EOT){
    8fa4:	2904      	cmp	r1, #4
    8fa6:	d005      	beq.n	8fb4 <grid_msg_packet_receive_char+0x38>
			msg->body[msg->body_length] = nextchar;
    8fa8:	1883      	adds	r3, r0, r2
			msg->body_length++;
    8faa:	3201      	adds	r2, #1
			msg->body[msg->body_length] = nextchar;
    8fac:	7519      	strb	r1, [r3, #20]
			msg->body_length++;
    8fae:	f8c0 2194 	str.w	r2, [r0, #404]	; 0x194
    8fb2:	4770      	bx	lr
		}
		else{
			msg->footer[msg->footer_length] = nextchar;
    8fb4:	f880 118b 	strb.w	r1, [r0, #395]	; 0x18b
			msg->footer_length++;
    8fb8:	2301      	movs	r3, #1
		
	}
	else{
		
		msg->footer[msg->footer_length] = nextchar;
		msg->footer_length++;
    8fba:	f8c0 3198 	str.w	r3, [r0, #408]	; 0x198
		
	}
	
}
    8fbe:	4770      	bx	lr
		msg->footer[msg->footer_length] = nextchar;
    8fc0:	18c2      	adds	r2, r0, r3
		msg->footer_length++;
    8fc2:	3301      	adds	r3, #1
		msg->footer[msg->footer_length] = nextchar;
    8fc4:	f882 118b 	strb.w	r1, [r2, #395]	; 0x18b
		msg->footer_length++;
    8fc8:	e7f7      	b.n	8fba <grid_msg_packet_receive_char+0x3e>

00008fca <grid_msg_packet_send_char>:

// ======================= GRID MSG SEND CHAR ======================//

uint8_t	grid_msg_packet_send_char(struct grid_msg* msg, uint32_t charindex){
	
	if (charindex < msg->header_length){
    8fca:	f8d0 2190 	ldr.w	r2, [r0, #400]	; 0x190
    8fce:	428a      	cmp	r2, r1
    8fd0:	d901      	bls.n	8fd6 <grid_msg_packet_send_char+0xc>
		
		return msg->header[charindex];
    8fd2:	5c40      	ldrb	r0, [r0, r1]
    8fd4:	4770      	bx	lr
	}
	else if (charindex < msg->body_length + msg->header_length){
    8fd6:	f8d0 3194 	ldr.w	r3, [r0, #404]	; 0x194
    8fda:	4413      	add	r3, r2
    8fdc:	428b      	cmp	r3, r1
    8fde:	d903      	bls.n	8fe8 <grid_msg_packet_send_char+0x1e>
	
		return msg->body[charindex - msg->header_length];
    8fe0:	1a89      	subs	r1, r1, r2
    8fe2:	4408      	add	r0, r1
    8fe4:	7d00      	ldrb	r0, [r0, #20]
    8fe6:	4770      	bx	lr
	}
	else if (charindex < msg->footer_length + msg->body_length + msg->header_length){
    8fe8:	f8d0 2198 	ldr.w	r2, [r0, #408]	; 0x198
    8fec:	441a      	add	r2, r3
    8fee:	428a      	cmp	r2, r1
	
		return msg->footer[charindex - msg->header_length - msg->body_length];
    8ff0:	bf83      	ittte	hi
    8ff2:	1ac9      	subhi	r1, r1, r3
    8ff4:	1840      	addhi	r0, r0, r1
    8ff6:	f890 018b 	ldrbhi.w	r0, [r0, #395]	; 0x18b
	}
	else{
		// OVERRUN
		return -1;
    8ffa:	20ff      	movls	r0, #255	; 0xff
	}
	
	
}
    8ffc:	4770      	bx	lr
	...

00009000 <grid_msg_packet_close>:



uint8_t	grid_msg_packet_close(struct grid_msg* msg){
    9000:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    9002:	4604      	mov	r4, r0
	
	
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    9004:	f8d0 0198 	ldr.w	r0, [r0, #408]	; 0x198
    9008:	492b      	ldr	r1, [pc, #172]	; (90b8 <grid_msg_packet_close+0xb8>)
    900a:	4d2c      	ldr	r5, [pc, #176]	; (90bc <grid_msg_packet_close+0xbc>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    900c:	4e2c      	ldr	r6, [pc, #176]	; (90c0 <grid_msg_packet_close+0xc0>)
	sprintf(&msg->footer[msg->footer_length], "%c", GRID_CONST_EOT);
    900e:	f200 108b 	addw	r0, r0, #395	; 0x18b
    9012:	2204      	movs	r2, #4
    9014:	4420      	add	r0, r4
    9016:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    9018:	f8d4 7198 	ldr.w	r7, [r4, #408]	; 0x198
    901c:	f207 108b 	addw	r0, r7, #395	; 0x18b
    9020:	4420      	add	r0, r4
    9022:	47b0      	blx	r6
	
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    9024:	e9d4 3164 	ldrd	r3, r1, [r4, #400]	; 0x190
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    9028:	4438      	add	r0, r7
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    902a:	440b      	add	r3, r1
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    902c:	4f25      	ldr	r7, [pc, #148]	; (90c4 <grid_msg_packet_close+0xc4>)
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    902e:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	grid_msg_header_set_len(msg, msg->header_length + msg->body_length + msg->footer_length);
    9032:	1819      	adds	r1, r3, r0
    9034:	b2c9      	uxtb	r1, r1
    9036:	4b24      	ldr	r3, [pc, #144]	; (90c8 <grid_msg_packet_close+0xc8>)
    9038:	4620      	mov	r0, r4
    903a:	4798      	blx	r3
	grid_msg_header_set_id(msg, grid_sys_state.next_broadcast_message_id);	
    903c:	f897 10ad 	ldrb.w	r1, [r7, #173]	; 0xad
    9040:	4b22      	ldr	r3, [pc, #136]	; (90cc <grid_msg_packet_close+0xcc>)
    9042:	4620      	mov	r0, r4
    9044:	4798      	blx	r3
	
	grid_sys_state.next_broadcast_message_id++;
    9046:	f897 30ad 	ldrb.w	r3, [r7, #173]	; 0xad
    904a:	3301      	adds	r3, #1
    904c:	b2db      	uxtb	r3, r3
    904e:	f887 30ad 	strb.w	r3, [r7, #173]	; 0xad
	
	
	uint8_t checksum = 0;
	
	for (uint32_t i=0; i<msg->header_length; i++){
    9052:	f8d4 3190 	ldr.w	r3, [r4, #400]	; 0x190
    9056:	4621      	mov	r1, r4
    9058:	4423      	add	r3, r4
	uint8_t checksum = 0;
    905a:	2200      	movs	r2, #0
	for (uint32_t i=0; i<msg->header_length; i++){
    905c:	4299      	cmp	r1, r3
    905e:	d11f      	bne.n	90a0 <grid_msg_packet_close+0xa0>
    9060:	f8d4 3194 	ldr.w	r3, [r4, #404]	; 0x194
    9064:	4423      	add	r3, r4
    9066:	f104 0114 	add.w	r1, r4, #20
    906a:	3314      	adds	r3, #20
		checksum ^= msg->header[i];
	}
		
	for (uint32_t i=0; i<msg->body_length; i++){
    906c:	4299      	cmp	r1, r3
    906e:	d11b      	bne.n	90a8 <grid_msg_packet_close+0xa8>
		checksum ^= msg->body[i];
	}
		
	for (uint32_t i=0; i<msg->footer_length; i++){
    9070:	f8d4 0198 	ldr.w	r0, [r4, #408]	; 0x198
    9074:	1823      	adds	r3, r4, r0
    9076:	f204 118b 	addw	r1, r4, #395	; 0x18b
    907a:	f203 138b 	addw	r3, r3, #395	; 0x18b
    907e:	4299      	cmp	r1, r3
    9080:	d116      	bne.n	90b0 <grid_msg_packet_close+0xb0>
		checksum ^= msg->footer[i];
	}
	
	sprintf(&msg->footer[msg->footer_length], "%02x\n", checksum);
    9082:	f200 108b 	addw	r0, r0, #395	; 0x18b
    9086:	4912      	ldr	r1, [pc, #72]	; (90d0 <grid_msg_packet_close+0xd0>)
    9088:	4420      	add	r0, r4
    908a:	47a8      	blx	r5
	msg->footer_length += strlen(&msg->footer[msg->footer_length]);
    908c:	f8d4 5198 	ldr.w	r5, [r4, #408]	; 0x198
    9090:	f205 108b 	addw	r0, r5, #395	; 0x18b
    9094:	4420      	add	r0, r4
    9096:	47b0      	blx	r6
    9098:	4428      	add	r0, r5
    909a:	f8c4 0198 	str.w	r0, [r4, #408]	; 0x198
	
	
}
    909e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		checksum ^= msg->header[i];
    90a0:	f811 0b01 	ldrb.w	r0, [r1], #1
    90a4:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->header_length; i++){
    90a6:	e7d9      	b.n	905c <grid_msg_packet_close+0x5c>
		checksum ^= msg->body[i];
    90a8:	f811 0b01 	ldrb.w	r0, [r1], #1
    90ac:	4042      	eors	r2, r0
	for (uint32_t i=0; i<msg->body_length; i++){
    90ae:	e7dd      	b.n	906c <grid_msg_packet_close+0x6c>
		checksum ^= msg->footer[i];
    90b0:	f811 7b01 	ldrb.w	r7, [r1], #1
    90b4:	407a      	eors	r2, r7
	for (uint32_t i=0; i<msg->footer_length; i++){
    90b6:	e7e2      	b.n	907e <grid_msg_packet_close+0x7e>
    90b8:	000166c3 	.word	0x000166c3
    90bc:	00015299 	.word	0x00015299
    90c0:	00015317 	.word	0x00015317
    90c4:	2000f008 	.word	0x2000f008
    90c8:	00008d31 	.word	0x00008d31
    90cc:	00008d51 	.word	0x00008d51
    90d0:	00017353 	.word	0x00017353

000090d4 <grid_msg_packet_send_everywhere>:

uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    90d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	
	uint32_t message_length = grid_msg_packet_get_length(msg);
    90d8:	4b0f      	ldr	r3, [pc, #60]	; (9118 <grid_msg_packet_send_everywhere+0x44>)
uint8_t	grid_msg_packet_send_everywhere(struct grid_msg* msg){
    90da:	4606      	mov	r6, r0
	uint32_t message_length = grid_msg_packet_get_length(msg);
    90dc:	4798      	blx	r3
	
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    90de:	4b0f      	ldr	r3, [pc, #60]	; (911c <grid_msg_packet_send_everywhere+0x48>)
	uint32_t message_length = grid_msg_packet_get_length(msg);
    90e0:	4604      	mov	r4, r0
	if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, message_length)){
    90e2:	b281      	uxth	r1, r0
    90e4:	480e      	ldr	r0, [pc, #56]	; (9120 <grid_msg_packet_send_everywhere+0x4c>)
    90e6:	4798      	blx	r3
    90e8:	b978      	cbnz	r0, 910a <grid_msg_packet_send_everywhere+0x36>
		
		return 0;
	}
	
	
}
    90ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    90ee:	4629      	mov	r1, r5
    90f0:	4630      	mov	r0, r6
    90f2:	47b8      	blx	r7
    90f4:	4601      	mov	r1, r0
    90f6:	4640      	mov	r0, r8
    90f8:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    90fa:	3501      	adds	r5, #1
    90fc:	42a5      	cmp	r5, r4
    90fe:	d1f6      	bne.n	90ee <grid_msg_packet_send_everywhere+0x1a>
		grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    9100:	4807      	ldr	r0, [pc, #28]	; (9120 <grid_msg_packet_send_everywhere+0x4c>)
    9102:	4b08      	ldr	r3, [pc, #32]	; (9124 <grid_msg_packet_send_everywhere+0x50>)
    9104:	4798      	blx	r3
		return 1;
    9106:	2001      	movs	r0, #1
    9108:	e7ef      	b.n	90ea <grid_msg_packet_send_everywhere+0x16>
			grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(msg, i));
    910a:	4f07      	ldr	r7, [pc, #28]	; (9128 <grid_msg_packet_send_everywhere+0x54>)
    910c:	f8df 8010 	ldr.w	r8, [pc, #16]	; 9120 <grid_msg_packet_send_everywhere+0x4c>
    9110:	f8df 9018 	ldr.w	r9, [pc, #24]	; 912c <grid_msg_packet_send_everywhere+0x58>
		for(uint32_t i = 0; i<message_length; i++){
    9114:	2500      	movs	r5, #0
    9116:	e7f1      	b.n	90fc <grid_msg_packet_send_everywhere+0x28>
    9118:	00008e31 	.word	0x00008e31
    911c:	000047f1 	.word	0x000047f1
    9120:	2000ebe4 	.word	0x2000ebe4
    9124:	0000484d 	.word	0x0000484d
    9128:	00008fcb 	.word	0x00008fcb
    912c:	0000482d 	.word	0x0000482d

00009130 <grid_nvm_ui_bulk_read_init>:
}


void grid_nvm_ui_bulk_read_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->read_bulk_page_index = 0;
    9130:	2300      	movs	r3, #0
    9132:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 1;
    9136:	2301      	movs	r3, #1
    9138:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
			
}
    913c:	4770      	bx	lr

0000913e <grid_nvm_ui_bulk_read_is_in_progress>:

uint8_t grid_nvm_ui_bulk_read_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->read_bulk_status;
	
}
    913e:	f890 0428 	ldrb.w	r0, [r0, #1064]	; 0x428
    9142:	4770      	bx	lr

00009144 <grid_nvm_ui_bulk_read_next>:

void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    9144:	b5f0      	push	{r4, r5, r6, r7, lr}
    9146:	4604      	mov	r4, r0
    9148:	b0ed      	sub	sp, #436	; 0x1b4
	
	if (nvm->read_bulk_status == 1){
    914a:	f894 3428 	ldrb.w	r3, [r4, #1064]	; 0x428
    914e:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_read_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    9150:	4608      	mov	r0, r1
	if (nvm->read_bulk_status == 1){
    9152:	d12f      	bne.n	91b4 <grid_nvm_ui_bulk_read_next+0x70>
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    9154:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    9156:	f8d4 2424 	ldr.w	r2, [r4, #1060]	; 0x424
    915a:	23a0      	movs	r3, #160	; 0xa0
    915c:	fbb2 f3f3 	udiv	r3, r2, r3
    9160:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    9164:	4299      	cmp	r1, r3
    9166:	d91c      	bls.n	91a2 <grid_nvm_ui_bulk_read_next+0x5e>
			
			if (element < ui->bank_list[bank].element_list_length){
    9168:	6845      	ldr	r5, [r0, #4]
    916a:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    916e:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    9170:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->read_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    9172:	fbb2 f1f7 	udiv	r1, r2, r7
    9176:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    917a:	42b5      	cmp	r5, r6
    917c:	d911      	bls.n	91a2 <grid_nvm_ui_bulk_read_next+0x5e>
		uint8_t event   = nvm->read_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    917e:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    9182:	68da      	ldr	r2, [r3, #12]
    9184:	2364      	movs	r3, #100	; 0x64
    9186:	fb06 2303 	mla	r3, r6, r3, r2
    918a:	b2ca      	uxtb	r2, r1
    918c:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    9190:	4295      	cmp	r5, r2
    9192:	d906      	bls.n	91a2 <grid_nvm_ui_bulk_read_next+0x5e>
					// Valid memory location
					
					int status = grid_ui_nvm_load_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);
    9194:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    9196:	22bc      	movs	r2, #188	; 0xbc
    9198:	fb02 3201 	mla	r2, r2, r1, r3
    919c:	4b1f      	ldr	r3, [pc, #124]	; (921c <grid_nvm_ui_bulk_read_next+0xd8>)
    919e:	4621      	mov	r1, r4
    91a0:	4798      	blx	r3
			}
	
		}
		
		
		if (nvm->read_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    91a2:	f8d4 3424 	ldr.w	r3, [r4, #1060]	; 0x424
    91a6:	f240 227e 	movw	r2, #638	; 0x27e
    91aa:	4293      	cmp	r3, r2
    91ac:	d804      	bhi.n	91b8 <grid_nvm_ui_bulk_read_next+0x74>
			
			nvm->read_bulk_page_index++;
    91ae:	3301      	adds	r3, #1
    91b0:	f8c4 3424 	str.w	r3, [r4, #1060]	; 0x424
	}
	
	
	
	
}
    91b4:	b06d      	add	sp, #436	; 0x1b4
    91b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
			nvm->read_bulk_page_index = 0;
    91b8:	2500      	movs	r5, #0
    91ba:	f8c4 5424 	str.w	r5, [r4, #1060]	; 0x424
			nvm->read_bulk_status = 0;
    91be:	f884 5428 	strb.w	r5, [r4, #1064]	; 0x428
			grid_msg_init(&response);
    91c2:	a805      	add	r0, sp, #20
    91c4:	4b16      	ldr	r3, [pc, #88]	; (9220 <grid_nvm_ui_bulk_read_next+0xdc>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91c6:	4c17      	ldr	r4, [pc, #92]	; (9224 <grid_nvm_ui_bulk_read_next+0xe0>)
			grid_msg_init(&response);
    91c8:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    91ca:	227f      	movs	r2, #127	; 0x7f
    91cc:	462b      	mov	r3, r5
    91ce:	4611      	mov	r1, r2
    91d0:	a805      	add	r0, sp, #20
    91d2:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    91d4:	2303      	movs	r3, #3
    91d6:	4914      	ldr	r1, [pc, #80]	; (9228 <grid_nvm_ui_bulk_read_next+0xe4>)
    91d8:	9300      	str	r3, [sp, #0]
    91da:	2202      	movs	r2, #2
    91dc:	4c13      	ldr	r4, [pc, #76]	; (922c <grid_nvm_ui_bulk_read_next+0xe8>)
			uint8_t response_payload[10] = {0};
    91de:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    91e2:	2371      	movs	r3, #113	; 0x71
    91e4:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    91e6:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALLOAD_frame);
    91ea:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    91ec:	4b10      	ldr	r3, [pc, #64]	; (9230 <grid_nvm_ui_bulk_read_next+0xec>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    91ee:	4c11      	ldr	r4, [pc, #68]	; (9234 <grid_nvm_ui_bulk_read_next+0xf0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    91f0:	a802      	add	r0, sp, #8
    91f2:	4798      	blx	r3
    91f4:	a902      	add	r1, sp, #8
    91f6:	4602      	mov	r2, r0
    91f8:	4b0f      	ldr	r3, [pc, #60]	; (9238 <grid_nvm_ui_bulk_read_next+0xf4>)
    91fa:	a805      	add	r0, sp, #20
    91fc:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    91fe:	230a      	movs	r3, #10
    9200:	9300      	str	r3, [sp, #0]
    9202:	2204      	movs	r2, #4
    9204:	4629      	mov	r1, r5
    9206:	a805      	add	r0, sp, #20
    9208:	2301      	movs	r3, #1
    920a:	47a0      	blx	r4
			grid_msg_packet_close(&response);
    920c:	4b0b      	ldr	r3, [pc, #44]	; (923c <grid_nvm_ui_bulk_read_next+0xf8>)
    920e:	a805      	add	r0, sp, #20
    9210:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    9212:	4b0b      	ldr	r3, [pc, #44]	; (9240 <grid_nvm_ui_bulk_read_next+0xfc>)
    9214:	a805      	add	r0, sp, #20
    9216:	4798      	blx	r3
}
    9218:	e7cc      	b.n	91b4 <grid_nvm_ui_bulk_read_next+0x70>
    921a:	bf00      	nop
    921c:	0000a7a5 	.word	0x0000a7a5
    9220:	00008ed5 	.word	0x00008ed5
    9224:	00008f09 	.word	0x00008f09
    9228:	00016985 	.word	0x00016985
    922c:	00015299 	.word	0x00015299
    9230:	00015317 	.word	0x00015317
    9234:	00008eb9 	.word	0x00008eb9
    9238:	00008e45 	.word	0x00008e45
    923c:	00009001 	.word	0x00009001
    9240:	000090d5 	.word	0x000090d5

00009244 <grid_nvm_ui_bulk_store_init>:


void grid_nvm_ui_bulk_store_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->store_bulk_page_index = 0;
    9244:	2300      	movs	r3, #0
    9246:	f8c0 3434 	str.w	r3, [r0, #1076]	; 0x434
	nvm->store_bulk_status = 1;
    924a:	2301      	movs	r3, #1
    924c:	f880 3438 	strb.w	r3, [r0, #1080]	; 0x438
	
}
    9250:	4770      	bx	lr

00009252 <grid_nvm_ui_bulk_store_is_in_progress>:

uint8_t grid_nvm_ui_bulk_store_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->store_bulk_status;
	
}
    9252:	f890 0438 	ldrb.w	r0, [r0, #1080]	; 0x438
    9256:	4770      	bx	lr

00009258 <grid_nvm_ui_bulk_store_next>:

// DO THIS!!
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    9258:	b5f0      	push	{r4, r5, r6, r7, lr}
     
    // START: NEW
    
    
	if (nvm->store_bulk_status == 1){
    925a:	f890 3438 	ldrb.w	r3, [r0, #1080]	; 0x438
    925e:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_store_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    9260:	b0ed      	sub	sp, #436	; 0x1b4
    9262:	4604      	mov	r4, r0
    9264:	460d      	mov	r5, r1
	if (nvm->store_bulk_status == 1){
    9266:	d168      	bne.n	933a <grid_nvm_ui_bulk_store_next+0xe2>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];

                        if (eve->cfg_changed_flag == 1){


                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    9268:	4f53      	ldr	r7, [pc, #332]	; (93b8 <grid_nvm_ui_bulk_store_next+0x160>)
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    926a:	26a0      	movs	r6, #160	; 0xa0
            if (bank < ui->bank_list_length){
    926c:	786a      	ldrb	r2, [r5, #1]
            uint8_t bank    = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    926e:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    9272:	fbb3 f1f6 	udiv	r1, r3, r6
    9276:	f001 0003 	and.w	r0, r1, #3
            if (bank < ui->bank_list_length){
    927a:	4282      	cmp	r2, r0
    927c:	d95f      	bls.n	933e <grid_nvm_ui_bulk_store_next+0xe6>
                if (element < ui->bank_list[bank].element_list_length){
    927e:	6869      	ldr	r1, [r5, #4]
    9280:	eb01 1100 	add.w	r1, r1, r0, lsl #4
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    9284:	f04f 0e0a 	mov.w	lr, #10
                if (element < ui->bank_list[bank].element_list_length){
    9288:	7a48      	ldrb	r0, [r1, #9]
            uint8_t element = (nvm->store_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    928a:	fbb3 f2fe 	udiv	r2, r3, lr
    928e:	f002 0c0f 	and.w	ip, r2, #15
                if (element < ui->bank_list[bank].element_list_length){
    9292:	4560      	cmp	r0, ip
    9294:	d953      	bls.n	933e <grid_nvm_ui_bulk_store_next+0xe6>
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    9296:	68c9      	ldr	r1, [r1, #12]
            uint8_t event   = nvm->store_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    9298:	fb0e 3212 	mls	r2, lr, r2, r3
                    if (event < ui->bank_list[bank].element_list[element].event_list_length){
    929c:	2364      	movs	r3, #100	; 0x64
    929e:	fb0c 1303 	mla	r3, ip, r3, r1
    92a2:	b2d1      	uxtb	r1, r2
    92a4:	f893 005c 	ldrb.w	r0, [r3, #92]	; 0x5c
    92a8:	4288      	cmp	r0, r1
    92aa:	d948      	bls.n	933e <grid_nvm_ui_bulk_store_next+0xe6>
                        struct grid_ui_event* eve = &ui->bank_list[bank].element_list[element].event_list[event];
    92ac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    92ae:	21bc      	movs	r1, #188	; 0xbc
    92b0:	fb01 3202 	mla	r2, r1, r2, r3
                        if (eve->cfg_changed_flag == 1){
    92b4:	f892 30b6 	ldrb.w	r3, [r2, #182]	; 0xb6
    92b8:	2b01      	cmp	r3, #1
    92ba:	d140      	bne.n	933e <grid_nvm_ui_bulk_store_next+0xe6>
                            if (grid_ui_nvm_store_event_configuration(ui, nvm, eve)){
    92bc:	4621      	mov	r1, r4
    92be:	4628      	mov	r0, r5
    92c0:	47b8      	blx	r7
    92c2:	3800      	subs	r0, #0
    92c4:	bf18      	it	ne
    92c6:	2001      	movne	r0, #1

            }
            
            

            if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    92c8:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    92cc:	f240 227e 	movw	r2, #638	; 0x27e
    92d0:	4293      	cmp	r3, r2
    92d2:	d804      	bhi.n	92de <grid_nvm_ui_bulk_store_next+0x86>



                nvm->store_bulk_page_index++;       
    92d4:	3301      	adds	r3, #1
    92d6:	f8c4 3434 	str.w	r3, [r4, #1076]	; 0x434
        while (something_was_stored == 0){
    92da:	2800      	cmp	r0, #0
    92dc:	d0c6      	beq.n	926c <grid_nvm_ui_bulk_store_next+0x14>
		

		
		
		
		if (nvm->store_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    92de:	f8d4 3434 	ldr.w	r3, [r4, #1076]	; 0x434
    92e2:	4e36      	ldr	r6, [pc, #216]	; (93bc <grid_nvm_ui_bulk_store_next+0x164>)
    92e4:	f240 227e 	movw	r2, #638	; 0x27e
    92e8:	4293      	cmp	r3, r2
    92ea:	d82a      	bhi.n	9342 <grid_nvm_ui_bulk_store_next+0xea>
			
            
            uint8_t intensity = abs(nvm->store_bulk_page_index%100 - 50)/1.5 + 40;
    92ec:	2264      	movs	r2, #100	; 0x64
    92ee:	fbb3 f0f2 	udiv	r0, r3, r2
    92f2:	fb02 3010 	mls	r0, r2, r0, r3
    92f6:	3832      	subs	r0, #50	; 0x32
    92f8:	2800      	cmp	r0, #0
    92fa:	bfb8      	it	lt
    92fc:	4240      	neglt	r0, r0
    92fe:	4f30      	ldr	r7, [pc, #192]	; (93c0 <grid_nvm_ui_bulk_store_next+0x168>)
    9300:	4c30      	ldr	r4, [pc, #192]	; (93c4 <grid_nvm_ui_bulk_store_next+0x16c>)
    9302:	4d31      	ldr	r5, [pc, #196]	; (93c8 <grid_nvm_ui_bulk_store_next+0x170>)
    9304:	47b8      	blx	r7
    9306:	4b31      	ldr	r3, [pc, #196]	; (93cc <grid_nvm_ui_bulk_store_next+0x174>)
    9308:	2200      	movs	r2, #0
    930a:	47a0      	blx	r4
    930c:	4b30      	ldr	r3, [pc, #192]	; (93d0 <grid_nvm_ui_bulk_store_next+0x178>)
    930e:	4c31      	ldr	r4, [pc, #196]	; (93d4 <grid_nvm_ui_bulk_store_next+0x17c>)
    9310:	2200      	movs	r2, #0
    9312:	47a0      	blx	r4
    9314:	47a8      	blx	r5
    9316:	b2c4      	uxtb	r4, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, 0, intensity*0.75, intensity, 1, 1000);
    9318:	4620      	mov	r0, r4
    931a:	47b8      	blx	r7
    931c:	4b2e      	ldr	r3, [pc, #184]	; (93d8 <grid_nvm_ui_bulk_store_next+0x180>)
    931e:	4f2f      	ldr	r7, [pc, #188]	; (93dc <grid_nvm_ui_bulk_store_next+0x184>)
    9320:	2200      	movs	r2, #0
    9322:	47b8      	blx	r7
    9324:	47a8      	blx	r5
    9326:	2301      	movs	r3, #1
    9328:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    932c:	e9cd 3200 	strd	r3, r2, [sp]
    9330:	2100      	movs	r1, #0
    9332:	b2c2      	uxtb	r2, r0
    9334:	4623      	mov	r3, r4
    9336:	482a      	ldr	r0, [pc, #168]	; (93e0 <grid_nvm_ui_bulk_store_next+0x188>)
    9338:	47b0      	blx	r6
	}
	
	
	
	
}
    933a:	b06d      	add	sp, #436	; 0x1b4
    933c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    933e:	2000      	movs	r0, #0
    9340:	e7c2      	b.n	92c8 <grid_nvm_ui_bulk_store_next+0x70>
			nvm->store_bulk_page_index = 0;
    9342:	2500      	movs	r5, #0
    9344:	f8c4 5434 	str.w	r5, [r4, #1076]	; 0x434
			nvm->store_bulk_status = 0;
    9348:	f884 5438 	strb.w	r5, [r4, #1080]	; 0x438
			grid_msg_init(&response);
    934c:	a805      	add	r0, sp, #20
    934e:	4b25      	ldr	r3, [pc, #148]	; (93e4 <grid_nvm_ui_bulk_store_next+0x18c>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9350:	4c25      	ldr	r4, [pc, #148]	; (93e8 <grid_nvm_ui_bulk_store_next+0x190>)
			grid_msg_init(&response);
    9352:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9354:	227f      	movs	r2, #127	; 0x7f
    9356:	462b      	mov	r3, r5
    9358:	4611      	mov	r1, r2
    935a:	a805      	add	r0, sp, #20
    935c:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    935e:	2303      	movs	r3, #3
    9360:	4922      	ldr	r1, [pc, #136]	; (93ec <grid_nvm_ui_bulk_store_next+0x194>)
    9362:	9300      	str	r3, [sp, #0]
    9364:	2202      	movs	r2, #2
    9366:	4c22      	ldr	r4, [pc, #136]	; (93f0 <grid_nvm_ui_bulk_store_next+0x198>)
			uint8_t response_payload[10] = {0};
    9368:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    936c:	2370      	movs	r3, #112	; 0x70
    936e:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    9370:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALSTORE_frame);
    9374:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9376:	4b1f      	ldr	r3, [pc, #124]	; (93f4 <grid_nvm_ui_bulk_store_next+0x19c>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9378:	4c1f      	ldr	r4, [pc, #124]	; (93f8 <grid_nvm_ui_bulk_store_next+0x1a0>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    937a:	a802      	add	r0, sp, #8
    937c:	4798      	blx	r3
    937e:	a902      	add	r1, sp, #8
    9380:	4602      	mov	r2, r0
    9382:	4b1e      	ldr	r3, [pc, #120]	; (93fc <grid_nvm_ui_bulk_store_next+0x1a4>)
    9384:	a805      	add	r0, sp, #20
    9386:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9388:	230a      	movs	r3, #10
    938a:	9300      	str	r3, [sp, #0]
    938c:	4629      	mov	r1, r5
    938e:	a805      	add	r0, sp, #20
    9390:	2301      	movs	r3, #1
    9392:	2204      	movs	r2, #4
    9394:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    9396:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    939a:	e9cd 5300 	strd	r5, r3, [sp]
    939e:	22ff      	movs	r2, #255	; 0xff
    93a0:	462b      	mov	r3, r5
    93a2:	4629      	mov	r1, r5
    93a4:	480e      	ldr	r0, [pc, #56]	; (93e0 <grid_nvm_ui_bulk_store_next+0x188>)
    93a6:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    93a8:	4b15      	ldr	r3, [pc, #84]	; (9400 <grid_nvm_ui_bulk_store_next+0x1a8>)
    93aa:	a805      	add	r0, sp, #20
    93ac:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    93ae:	4b15      	ldr	r3, [pc, #84]	; (9404 <grid_nvm_ui_bulk_store_next+0x1ac>)
    93b0:	a805      	add	r0, sp, #20
    93b2:	4798      	blx	r3
}
    93b4:	e7c1      	b.n	933a <grid_nvm_ui_bulk_store_next+0xe2>
    93b6:	bf00      	nop
    93b8:	0000a609 	.word	0x0000a609
    93bc:	0000a123 	.word	0x0000a123
    93c0:	000147a5 	.word	0x000147a5
    93c4:	00014acd 	.word	0x00014acd
    93c8:	00014c9d 	.word	0x00014c9d
    93cc:	3ff80000 	.word	0x3ff80000
    93d0:	40440000 	.word	0x40440000
    93d4:	0001450d 	.word	0x0001450d
    93d8:	3fe80000 	.word	0x3fe80000
    93dc:	00014879 	.word	0x00014879
    93e0:	2000f008 	.word	0x2000f008
    93e4:	00008ed5 	.word	0x00008ed5
    93e8:	00008f09 	.word	0x00008f09
    93ec:	00016985 	.word	0x00016985
    93f0:	00015299 	.word	0x00015299
    93f4:	00015317 	.word	0x00015317
    93f8:	00008eb9 	.word	0x00008eb9
    93fc:	00008e45 	.word	0x00008e45
    9400:	00009001 	.word	0x00009001
    9404:	000090d5 	.word	0x000090d5

00009408 <grid_nvm_ui_bulk_clear_init>:



void grid_nvm_ui_bulk_clear_init(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	nvm->clear_bulk_page_index = 0;
    9408:	2300      	movs	r3, #0
    940a:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 1;
    940e:	2301      	movs	r3, #1
    9410:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	
}
    9414:	4770      	bx	lr

00009416 <grid_nvm_ui_bulk_clear_is_in_progress>:

uint8_t grid_nvm_ui_bulk_clear_is_in_progress(struct grid_nvm_model* nvm, struct grid_ui_model* ui){

	return nvm->clear_bulk_status;
	
}
    9416:	f890 0430 	ldrb.w	r0, [r0, #1072]	; 0x430
    941a:	4770      	bx	lr

0000941c <grid_nvm_ui_bulk_clear_next>:


void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    941c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    9420:	4604      	mov	r4, r0
    9422:	b0ec      	sub	sp, #432	; 0x1b0
	
	if (nvm->clear_bulk_status == 1){
    9424:	f894 3430 	ldrb.w	r3, [r4, #1072]	; 0x430
    9428:	2b01      	cmp	r3, #1
void grid_nvm_ui_bulk_clear_next(struct grid_nvm_model* nvm, struct grid_ui_model* ui){
    942a:	4608      	mov	r0, r1
	if (nvm->clear_bulk_status == 1){
    942c:	d15b      	bne.n	94e6 <grid_nvm_ui_bulk_clear_next+0xca>
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
		
		
		if (bank < ui->bank_list_length){
    942e:	7849      	ldrb	r1, [r1, #1]
		uint8_t bank    = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount/GRID_NVM_STRATEGY_ELEMENT_maxcount)%GRID_NVM_STRATEGY_BANK_maxcount;
    9430:	f8d4 242c 	ldr.w	r2, [r4, #1068]	; 0x42c
    9434:	23a0      	movs	r3, #160	; 0xa0
    9436:	fbb2 f3f3 	udiv	r3, r2, r3
    943a:	f003 0303 	and.w	r3, r3, #3
		if (bank < ui->bank_list_length){
    943e:	4299      	cmp	r1, r3
    9440:	d91c      	bls.n	947c <grid_nvm_ui_bulk_clear_next+0x60>
			
			if (element < ui->bank_list[bank].element_list_length){
    9442:	6845      	ldr	r5, [r0, #4]
    9444:	eb05 1303 	add.w	r3, r5, r3, lsl #4
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    9448:	270a      	movs	r7, #10
			if (element < ui->bank_list[bank].element_list_length){
    944a:	7a5d      	ldrb	r5, [r3, #9]
		uint8_t element = (nvm->clear_bulk_page_index/GRID_NVM_STRATEGY_EVENT_maxcount)%GRID_NVM_STRATEGY_ELEMENT_maxcount;
    944c:	fbb2 f1f7 	udiv	r1, r2, r7
    9450:	f001 060f 	and.w	r6, r1, #15
			if (element < ui->bank_list[bank].element_list_length){
    9454:	42b5      	cmp	r5, r6
    9456:	d911      	bls.n	947c <grid_nvm_ui_bulk_clear_next+0x60>
		uint8_t event   = nvm->clear_bulk_page_index%GRID_NVM_STRATEGY_EVENT_maxcount;
    9458:	fb07 2111 	mls	r1, r7, r1, r2
				
				if (event < ui->bank_list[bank].element_list[element].event_list_length){
    945c:	68da      	ldr	r2, [r3, #12]
    945e:	2364      	movs	r3, #100	; 0x64
    9460:	fb06 2303 	mla	r3, r6, r3, r2
    9464:	b2ca      	uxtb	r2, r1
    9466:	f893 505c 	ldrb.w	r5, [r3, #92]	; 0x5c
    946a:	4295      	cmp	r5, r2
    946c:	d906      	bls.n	947c <grid_nvm_ui_bulk_clear_next+0x60>
					// Valid memory location
					
					grid_ui_nvm_clear_event_configuration(ui, nvm, &ui->bank_list[bank].element_list[element].event_list[event]);		
    946e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    9470:	22bc      	movs	r2, #188	; 0xbc
    9472:	fb02 3201 	mla	r2, r2, r1, r3
    9476:	4b3c      	ldr	r3, [pc, #240]	; (9568 <grid_nvm_ui_bulk_clear_next+0x14c>)
    9478:	4621      	mov	r1, r4
    947a:	4798      	blx	r3
	
		}
		
		
		
		if (nvm->clear_bulk_page_index < GRID_NVM_STRATEGY_EVENT_maxcount*GRID_NVM_STRATEGY_ELEMENT_maxcount*GRID_NVM_STRATEGY_BANK_maxcount-1){ // multiply with bankcount
    947c:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    9480:	4e3a      	ldr	r6, [pc, #232]	; (956c <grid_nvm_ui_bulk_clear_next+0x150>)
    9482:	f240 227e 	movw	r2, #638	; 0x27e
    9486:	4293      	cmp	r3, r2
    9488:	d830      	bhi.n	94ec <grid_nvm_ui_bulk_clear_next+0xd0>
			
            
            uint8_t intensity = abs(nvm->clear_bulk_page_index%100 - 50)/1.5 + 40;
    948a:	2264      	movs	r2, #100	; 0x64
    948c:	fbb3 f0f2 	udiv	r0, r3, r2
    9490:	fb02 3010 	mls	r0, r2, r0, r3
    9494:	3832      	subs	r0, #50	; 0x32
    9496:	2800      	cmp	r0, #0
    9498:	bfb8      	it	lt
    949a:	4240      	neglt	r0, r0
    949c:	f8df 8118 	ldr.w	r8, [pc, #280]	; 95b8 <grid_nvm_ui_bulk_clear_next+0x19c>
    94a0:	4d33      	ldr	r5, [pc, #204]	; (9570 <grid_nvm_ui_bulk_clear_next+0x154>)
    94a2:	4f34      	ldr	r7, [pc, #208]	; (9574 <grid_nvm_ui_bulk_clear_next+0x158>)
    94a4:	47c0      	blx	r8
    94a6:	4b34      	ldr	r3, [pc, #208]	; (9578 <grid_nvm_ui_bulk_clear_next+0x15c>)
    94a8:	2200      	movs	r2, #0
    94aa:	47a8      	blx	r5
    94ac:	4b33      	ldr	r3, [pc, #204]	; (957c <grid_nvm_ui_bulk_clear_next+0x160>)
    94ae:	4d34      	ldr	r5, [pc, #208]	; (9580 <grid_nvm_ui_bulk_clear_next+0x164>)
    94b0:	2200      	movs	r2, #0
    94b2:	47a8      	blx	r5
    94b4:	47b8      	blx	r7
    94b6:	b2c5      	uxtb	r5, r0
  
            grid_sys_alert_set_alert(&grid_sys_state, intensity, intensity*0.75, 0, 1, 1000);
    94b8:	4628      	mov	r0, r5
    94ba:	47c0      	blx	r8
    94bc:	4b31      	ldr	r3, [pc, #196]	; (9584 <grid_nvm_ui_bulk_clear_next+0x168>)
    94be:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 95bc <grid_nvm_ui_bulk_clear_next+0x1a0>
    94c2:	2200      	movs	r2, #0
    94c4:	47c0      	blx	r8
    94c6:	47b8      	blx	r7
    94c8:	2301      	movs	r3, #1
    94ca:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    94ce:	e9cd 3200 	strd	r3, r2, [sp]
    94d2:	4629      	mov	r1, r5
    94d4:	2300      	movs	r3, #0
    94d6:	b2c2      	uxtb	r2, r0
    94d8:	482b      	ldr	r0, [pc, #172]	; (9588 <grid_nvm_ui_bulk_clear_next+0x16c>)
    94da:	47b0      	blx	r6


            
            nvm->clear_bulk_page_index++;
    94dc:	f8d4 342c 	ldr.w	r3, [r4, #1068]	; 0x42c
    94e0:	3301      	adds	r3, #1
    94e2:	f8c4 342c 	str.w	r3, [r4, #1068]	; 0x42c
	}
	
	
	
	
}
    94e6:	b06c      	add	sp, #432	; 0x1b0
    94e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			nvm->clear_bulk_page_index = 0;
    94ec:	2500      	movs	r5, #0
    94ee:	f8c4 542c 	str.w	r5, [r4, #1068]	; 0x42c
			nvm->clear_bulk_status = 0;
    94f2:	f884 5430 	strb.w	r5, [r4, #1072]	; 0x430
			grid_msg_init(&response);
    94f6:	a805      	add	r0, sp, #20
    94f8:	4b24      	ldr	r3, [pc, #144]	; (958c <grid_nvm_ui_bulk_clear_next+0x170>)
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    94fa:	4c25      	ldr	r4, [pc, #148]	; (9590 <grid_nvm_ui_bulk_clear_next+0x174>)
			grid_msg_init(&response);
    94fc:	4798      	blx	r3
			grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    94fe:	227f      	movs	r2, #127	; 0x7f
    9500:	462b      	mov	r3, r5
    9502:	4611      	mov	r1, r2
    9504:	a805      	add	r0, sp, #20
    9506:	47a0      	blx	r4
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    9508:	2303      	movs	r3, #3
    950a:	4922      	ldr	r1, [pc, #136]	; (9594 <grid_nvm_ui_bulk_clear_next+0x178>)
    950c:	9300      	str	r3, [sp, #0]
    950e:	2202      	movs	r2, #2
    9510:	4c21      	ldr	r4, [pc, #132]	; (9598 <grid_nvm_ui_bulk_clear_next+0x17c>)
			uint8_t response_payload[10] = {0};
    9512:	f8ad 5010 	strh.w	r5, [sp, #16]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    9516:	2372      	movs	r3, #114	; 0x72
    9518:	a802      	add	r0, sp, #8
			uint8_t response_payload[10] = {0};
    951a:	e9cd 5502 	strd	r5, r5, [sp, #8]
			sprintf(response_payload, GRID_CLASS_LOCALCLEAR_frame);
    951e:	47a0      	blx	r4
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9520:	4b1e      	ldr	r3, [pc, #120]	; (959c <grid_nvm_ui_bulk_clear_next+0x180>)
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9522:	4c1f      	ldr	r4, [pc, #124]	; (95a0 <grid_nvm_ui_bulk_clear_next+0x184>)
			grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9524:	a802      	add	r0, sp, #8
    9526:	4798      	blx	r3
    9528:	a902      	add	r1, sp, #8
    952a:	4602      	mov	r2, r0
    952c:	4b1d      	ldr	r3, [pc, #116]	; (95a4 <grid_nvm_ui_bulk_clear_next+0x188>)
    952e:	a805      	add	r0, sp, #20
    9530:	4798      	blx	r3
				grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9532:	230a      	movs	r3, #10
    9534:	9300      	str	r3, [sp, #0]
    9536:	4629      	mov	r1, r5
    9538:	a805      	add	r0, sp, #20
    953a:	2301      	movs	r3, #1
    953c:	2204      	movs	r2, #4
    953e:	47a0      	blx	r4
                grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 1000);
    9540:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    9544:	22ff      	movs	r2, #255	; 0xff
    9546:	4629      	mov	r1, r5
    9548:	e9cd 5300 	strd	r5, r3, [sp]
    954c:	480e      	ldr	r0, [pc, #56]	; (9588 <grid_nvm_ui_bulk_clear_next+0x16c>)
    954e:	462b      	mov	r3, r5
    9550:	47b0      	blx	r6
			grid_msg_packet_close(&response);
    9552:	4b15      	ldr	r3, [pc, #84]	; (95a8 <grid_nvm_ui_bulk_clear_next+0x18c>)
    9554:	a805      	add	r0, sp, #20
    9556:	4798      	blx	r3
			grid_msg_packet_send_everywhere(&response);
    9558:	4b14      	ldr	r3, [pc, #80]	; (95ac <grid_nvm_ui_bulk_clear_next+0x190>)
    955a:	a805      	add	r0, sp, #20
    955c:	4798      	blx	r3
            grid_ui_reinit_local(&grid_ui_state);
    955e:	4814      	ldr	r0, [pc, #80]	; (95b0 <grid_nvm_ui_bulk_clear_next+0x194>)
    9560:	4b14      	ldr	r3, [pc, #80]	; (95b4 <grid_nvm_ui_bulk_clear_next+0x198>)
    9562:	4798      	blx	r3
}
    9564:	e7bf      	b.n	94e6 <grid_nvm_ui_bulk_clear_next+0xca>
    9566:	bf00      	nop
    9568:	0000a81d 	.word	0x0000a81d
    956c:	0000a123 	.word	0x0000a123
    9570:	00014acd 	.word	0x00014acd
    9574:	00014c9d 	.word	0x00014c9d
    9578:	3ff80000 	.word	0x3ff80000
    957c:	40440000 	.word	0x40440000
    9580:	0001450d 	.word	0x0001450d
    9584:	3fe80000 	.word	0x3fe80000
    9588:	2000f008 	.word	0x2000f008
    958c:	00008ed5 	.word	0x00008ed5
    9590:	00008f09 	.word	0x00008f09
    9594:	00016985 	.word	0x00016985
    9598:	00015299 	.word	0x00015299
    959c:	00015317 	.word	0x00015317
    95a0:	00008eb9 	.word	0x00008eb9
    95a4:	00008e45 	.word	0x00008e45
    95a8:	00009001 	.word	0x00009001
    95ac:	000090d5 	.word	0x000090d5
    95b0:	2000effc 	.word	0x2000effc
    95b4:	0000ae29 	.word	0x0000ae29
    95b8:	000147a5 	.word	0x000147a5
    95bc:	00014879 	.word	0x00014879

000095c0 <grid_nvm_clear_read_buffer>:



void grid_nvm_clear_read_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    95c0:	f100 0309 	add.w	r3, r0, #9
    95c4:	f200 2209 	addw	r2, r0, #521	; 0x209
		
		mod->read_buffer[i] = 255;
    95c8:	21ff      	movs	r1, #255	; 0xff
    95ca:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    95ce:	4293      	cmp	r3, r2
    95d0:	d1fb      	bne.n	95ca <grid_nvm_clear_read_buffer+0xa>
		
	}

	mod->read_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    95d2:	2302      	movs	r3, #2
    95d4:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	mod->read_buffer_length = 0;
    95d8:	2300      	movs	r3, #0
    95da:	f8c0 320c 	str.w	r3, [r0, #524]	; 0x20c
	
}
    95de:	4770      	bx	lr

000095e0 <grid_nvm_clear_write_buffer>:

void grid_nvm_clear_write_buffer(struct grid_nvm_model* mod){
	
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    95e0:	f500 7306 	add.w	r3, r0, #536	; 0x218
    95e4:	f500 6283 	add.w	r2, r0, #1048	; 0x418
		
		mod->write_buffer[i] = 255;
    95e8:	21ff      	movs	r1, #255	; 0xff
    95ea:	f803 1b01 	strb.w	r1, [r3], #1
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    95ee:	4293      	cmp	r3, r2
    95f0:	d1fb      	bne.n	95ea <grid_nvm_clear_write_buffer+0xa>
		
	}
	
	mod->write_buffer_status = GRID_NVM_BUFFER_STATUS_EMPTY;
    95f2:	2302      	movs	r3, #2
    95f4:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	mod->write_buffer_length = 0;
    95f8:	2300      	movs	r3, #0
    95fa:	f8c0 3418 	str.w	r3, [r0, #1048]	; 0x418
	mod->write_target_address = -1;
    95fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    9602:	f8c0 3420 	str.w	r3, [r0, #1056]	; 0x420
}
    9606:	4770      	bx	lr

00009608 <grid_nvm_init>:
void grid_nvm_init(struct grid_nvm_model* nvm, struct flash_descriptor* flash_instance){
    9608:	b510      	push	{r4, lr}
	nvm->bank_settings_page_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    960a:	f44f 23fe 	mov.w	r3, #520192	; 0x7f000
	nvm->flash = flash_instance;
    960e:	e9c0 1300 	strd	r1, r3, [r0]
	nvm->status = 1;
    9612:	2301      	movs	r3, #1
    9614:	7203      	strb	r3, [r0, #8]
	nvm->read_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    9616:	2300      	movs	r3, #0
    9618:	f880 3210 	strb.w	r3, [r0, #528]	; 0x210
	nvm->write_buffer_status = GRID_NVM_BUFFER_STATUS_UNINITIALIZED;
    961c:	f880 341c 	strb.w	r3, [r0, #1052]	; 0x41c
	nvm->read_bulk_page_index = 0;
    9620:	f8c0 3424 	str.w	r3, [r0, #1060]	; 0x424
	nvm->read_bulk_status = 0;
    9624:	f880 3428 	strb.w	r3, [r0, #1064]	; 0x428
	nvm->clear_bulk_page_index = 0;
    9628:	f8c0 342c 	str.w	r3, [r0, #1068]	; 0x42c
	nvm->clear_bulk_status = 0;	
    962c:	f880 3430 	strb.w	r3, [r0, #1072]	; 0x430
	nvm->write_bulk_page_index = 0;
    9630:	f8c0 343c 	str.w	r3, [r0, #1084]	; 0x43c
	nvm->write_bulk_status = 0;
    9634:	f880 3440 	strb.w	r3, [r0, #1088]	; 0x440
	grid_nvm_clear_read_buffer(nvm);
    9638:	4b02      	ldr	r3, [pc, #8]	; (9644 <grid_nvm_init+0x3c>)
    963a:	4798      	blx	r3
}
    963c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_nvm_clear_write_buffer(nvm);
    9640:	4b01      	ldr	r3, [pc, #4]	; (9648 <grid_nvm_init+0x40>)
    9642:	4718      	bx	r3
    9644:	000095c1 	.word	0x000095c1
    9648:	000095e1 	.word	0x000095e1

0000964c <grid_nvm_calculate_event_page_offset>:


uint32_t grid_nvm_calculate_event_page_offset(struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    964c:	b510      	push	{r4, lr}
	
	
	
	uint8_t bank_number		= eve->parent->parent->index;
    964e:	684a      	ldr	r2, [r1, #4]
    9650:	6853      	ldr	r3, [r2, #4]
	uint8_t element_number	= eve->parent->index;
	uint8_t event_number	= eve->index;

	return GRID_NVM_STRATEGY_BANK_size * bank_number + GRID_NVM_STRATEGY_ELEMENT_size * element_number + GRID_NVM_STRATEGY_EVENT_size * event_number;
    9652:	7a1c      	ldrb	r4, [r3, #8]
    9654:	7a13      	ldrb	r3, [r2, #8]
    9656:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    965a:	20a0      	movs	r0, #160	; 0xa0
    965c:	005b      	lsls	r3, r3, #1
    965e:	fb10 3304 	smlabb	r3, r0, r4, r3
    9662:	7a08      	ldrb	r0, [r1, #8]
	
    9664:	4418      	add	r0, r3
    9666:	bd10      	pop	{r4, pc}

00009668 <_gpio_set_pin_pull_mode.constprop.0>:
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    9668:	01c0      	lsls	r0, r0, #7
    966a:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
    966e:	f500 4000 	add.w	r0, r0, #32768	; 0x8000
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
    9672:	2301      	movs	r3, #1
    9674:	408b      	lsls	r3, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    9676:	4401      	add	r1, r0
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    9678:	6043      	str	r3, [r0, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
    967a:	f891 2040 	ldrb.w	r2, [r1, #64]	; 0x40
    967e:	f042 0204 	orr.w	r2, r2, #4
    9682:	f881 2040 	strb.w	r2, [r1, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    9686:	6183      	str	r3, [r0, #24]

	default:
		ASSERT(false);
		break;
	}
}
    9688:	4770      	bx	lr

0000968a <grid_task_enter_task>:
 * Author : SUKU WC
*/

#include "grid_sys.h"

enum grid_task grid_task_enter_task(struct grid_task_model* mod, enum grid_task next_task){
    968a:	4603      	mov	r3, r0
	
	
	enum grid_task previous_task = mod->current_task;
    968c:	7840      	ldrb	r0, [r0, #1]
	mod->current_task = next_task;
    968e:	7059      	strb	r1, [r3, #1]
	return previous_task;
	
}
    9690:	4770      	bx	lr

00009692 <grid_task_timer_tick>:
	
}

void grid_task_timer_tick(struct grid_task_model* mod){
	
	mod->timer[mod->current_task]++;
    9692:	7843      	ldrb	r3, [r0, #1]
    9694:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    9698:	6843      	ldr	r3, [r0, #4]
    969a:	3301      	adds	r3, #1
    969c:	6043      	str	r3, [r0, #4]
	
}
    969e:	4770      	bx	lr

000096a0 <grid_sys_nvm_store_configuration>:
}




void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    96a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    96a4:	f2ad 4dec 	subw	sp, sp, #1260	; 0x4ec

	struct grid_msg message;
	
	grid_msg_init(&message);
    96a8:	4b6a      	ldr	r3, [pc, #424]	; (9854 <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    96aa:	4c6b      	ldr	r4, [pc, #428]	; (9858 <grid_sys_nvm_store_configuration+0x1b8>)
	for(uint8_t i=0; i<4; i++){
		
		// BANK ENABLED	
		offset = grid_msg_body_get_length(&message);
			
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    96ac:	f8df a1d0 	ldr.w	sl, [pc, #464]	; 9880 <grid_sys_nvm_store_configuration+0x1e0>
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    96b0:	4606      	mov	r6, r0
	grid_msg_init(&message);
    96b2:	a86c      	add	r0, sp, #432	; 0x1b0
void grid_sys_nvm_store_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    96b4:	460f      	mov	r7, r1
	grid_msg_init(&message);
    96b6:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    96b8:	22ff      	movs	r2, #255	; 0xff
    96ba:	4611      	mov	r1, r2
    96bc:	2300      	movs	r3, #0
    96be:	a86c      	add	r0, sp, #432	; 0x1b0
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    96c0:	2500      	movs	r5, #0
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    96c2:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    96c4:	4b65      	ldr	r3, [pc, #404]	; (985c <grid_sys_nvm_store_configuration+0x1bc>)
    96c6:	9508      	str	r5, [sp, #32]
    96c8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    96cc:	4629      	mov	r1, r5
    96ce:	a809      	add	r0, sp, #36	; 0x24
    96d0:	4798      	blx	r3
	for(uint8_t i=0; i<4; i++){
    96d2:	3613      	adds	r6, #19
		offset = grid_msg_body_get_length(&message);
    96d4:	4b62      	ldr	r3, [pc, #392]	; (9860 <grid_sys_nvm_store_configuration+0x1c0>)
		payload_length = strlen(payload);
    96d6:	f8df b1b4 	ldr.w	fp, [pc, #436]	; 988c <grid_sys_nvm_store_configuration+0x1ec>
			
		grid_msg_body_append_text(&message, payload, payload_length);
    96da:	f8df 91b4 	ldr.w	r9, [pc, #436]	; 9890 <grid_sys_nvm_store_configuration+0x1f0>
			
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    96de:	4c61      	ldr	r4, [pc, #388]	; (9864 <grid_sys_nvm_store_configuration+0x1c4>)
		offset = grid_msg_body_get_length(&message);
    96e0:	a86c      	add	r0, sp, #432	; 0x1b0
    96e2:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    96e4:	2203      	movs	r2, #3
		offset = grid_msg_body_get_length(&message);
    96e6:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    96e8:	2331      	movs	r3, #49	; 0x31
    96ea:	495f      	ldr	r1, [pc, #380]	; (9868 <grid_sys_nvm_store_configuration+0x1c8>)
    96ec:	9200      	str	r2, [sp, #0]
    96ee:	a808      	add	r0, sp, #32
    96f0:	2202      	movs	r2, #2
    96f2:	47d0      	blx	sl
		payload_length = strlen(payload);
    96f4:	a808      	add	r0, sp, #32
    96f6:	47d8      	blx	fp
		grid_msg_body_append_text(&message, payload, payload_length);
    96f8:	a908      	add	r1, sp, #32
    96fa:	b2c2      	uxtb	r2, r0
    96fc:	a86c      	add	r0, sp, #432	; 0x1b0
    96fe:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    9700:	220e      	movs	r2, #14
    9702:	4641      	mov	r1, r8
    9704:	9200      	str	r2, [sp, #0]
    9706:	2301      	movs	r3, #1
    9708:	2204      	movs	r2, #4
    970a:	a86c      	add	r0, sp, #432	; 0x1b0
    970c:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    970e:	4641      	mov	r1, r8
    9710:	9500      	str	r5, [sp, #0]
    9712:	2302      	movs	r3, #2
    9714:	2205      	movs	r2, #5
    9716:	a86c      	add	r0, sp, #432	; 0x1b0
    9718:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);		
    971a:	f816 3b01 	ldrb.w	r3, [r6], #1
    971e:	9300      	str	r3, [sp, #0]
    9720:	4641      	mov	r1, r8
    9722:	2207      	movs	r2, #7
    9724:	2302      	movs	r3, #2
    9726:	a86c      	add	r0, sp, #432	; 0x1b0
    9728:	47a0      	blx	r4
			
		// BANK COLOR	
		offset = grid_msg_body_get_length(&message);
    972a:	4b4d      	ldr	r3, [pc, #308]	; (9860 <grid_sys_nvm_store_configuration+0x1c0>)
    972c:	a86c      	add	r0, sp, #432	; 0x1b0
    972e:	4798      	blx	r3
		
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    9730:	2303      	movs	r3, #3
		offset = grid_msg_body_get_length(&message);
    9732:	4680      	mov	r8, r0
		sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    9734:	494d      	ldr	r1, [pc, #308]	; (986c <grid_sys_nvm_store_configuration+0x1cc>)
    9736:	9300      	str	r3, [sp, #0]
    9738:	2202      	movs	r2, #2
    973a:	2332      	movs	r3, #50	; 0x32
    973c:	a808      	add	r0, sp, #32
    973e:	47d0      	blx	sl
		payload_length = strlen(payload);
    9740:	a808      	add	r0, sp, #32
    9742:	47d8      	blx	fp
		
		grid_msg_body_append_text(&message, payload, payload_length);
    9744:	a908      	add	r1, sp, #32
    9746:	b2c2      	uxtb	r2, r0
    9748:	a86c      	add	r0, sp, #432	; 0x1b0
    974a:	47c8      	blx	r9

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    974c:	230e      	movs	r3, #14
    974e:	4641      	mov	r1, r8
    9750:	9300      	str	r3, [sp, #0]
    9752:	2204      	movs	r2, #4
    9754:	2301      	movs	r3, #1
    9756:	a86c      	add	r0, sp, #432	; 0x1b0
    9758:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    975a:	4641      	mov	r1, r8
    975c:	9500      	str	r5, [sp, #0]
    975e:	2302      	movs	r3, #2
    9760:	2205      	movs	r2, #5
    9762:	a86c      	add	r0, sp, #432	; 0x1b0
    9764:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    9766:	78f3      	ldrb	r3, [r6, #3]
    9768:	9300      	str	r3, [sp, #0]
    976a:	4641      	mov	r1, r8
    976c:	2302      	movs	r3, #2
    976e:	2207      	movs	r2, #7
    9770:	a86c      	add	r0, sp, #432	; 0x1b0
    9772:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    9774:	79f3      	ldrb	r3, [r6, #7]
    9776:	9300      	str	r3, [sp, #0]
    9778:	4641      	mov	r1, r8
    977a:	2302      	movs	r3, #2
    977c:	2209      	movs	r2, #9
    977e:	a86c      	add	r0, sp, #432	; 0x1b0
    9780:	47a0      	blx	r4
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    9782:	7af3      	ldrb	r3, [r6, #11]
    9784:	9300      	str	r3, [sp, #0]
    9786:	4641      	mov	r1, r8
    9788:	2302      	movs	r3, #2
    978a:	220b      	movs	r2, #11
    978c:	a86c      	add	r0, sp, #432	; 0x1b0
    978e:	3501      	adds	r5, #1
    9790:	47a0      	blx	r4
	for(uint8_t i=0; i<4; i++){
    9792:	2d04      	cmp	r5, #4
    9794:	46d8      	mov	r8, fp
    9796:	d19d      	bne.n	96d4 <grid_sys_nvm_store_configuration+0x34>
		
		
	}
	
	grid_msg_packet_close(&message);
    9798:	4e35      	ldr	r6, [pc, #212]	; (9870 <grid_sys_nvm_store_configuration+0x1d0>)

	grid_nvm_clear_write_buffer(nvm);
	
	uint8_t acknowledge = 0;
	
	if (grid_msg_packet_get_length(&message)){
    979a:	4d36      	ldr	r5, [pc, #216]	; (9874 <grid_sys_nvm_store_configuration+0x1d4>)
	grid_msg_packet_close(&message);
    979c:	a86c      	add	r0, sp, #432	; 0x1b0
    979e:	47b0      	blx	r6
	grid_nvm_clear_write_buffer(nvm);
    97a0:	4b35      	ldr	r3, [pc, #212]	; (9878 <grid_sys_nvm_store_configuration+0x1d8>)
    97a2:	4638      	mov	r0, r7
    97a4:	4798      	blx	r3
	if (grid_msg_packet_get_length(&message)){
    97a6:	a86c      	add	r0, sp, #432	; 0x1b0
    97a8:	47a8      	blx	r5
    97aa:	9602      	str	r6, [sp, #8]
    97ac:	2800      	cmp	r0, #0
    97ae:	d04c      	beq.n	984a <grid_sys_nvm_store_configuration+0x1aa>

		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    97b0:	a86c      	add	r0, sp, #432	; 0x1b0
    97b2:	47a8      	blx	r5
    97b4:	f507 7a06 	add.w	sl, r7, #536	; 0x218
		
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
			
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    97b8:	f8df b0d8 	ldr.w	fp, [pc, #216]	; 9894 <grid_sys_nvm_store_configuration+0x1f4>
		nvm->write_buffer_length = grid_msg_packet_get_length(&message);
    97bc:	f8c7 0418 	str.w	r0, [r7, #1048]	; 0x418
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    97c0:	2500      	movs	r5, #0
    97c2:	4652      	mov	r2, sl
    97c4:	f8d7 3418 	ldr.w	r3, [r7, #1048]	; 0x418
    97c8:	42ab      	cmp	r3, r5
    97ca:	d835      	bhi.n	9838 <grid_sys_nvm_store_configuration+0x198>
		}
		
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    97cc:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    97d0:	4d2a      	ldr	r5, [pc, #168]	; (987c <grid_sys_nvm_store_configuration+0x1dc>)
    97d2:	6838      	ldr	r0, [r7, #0]
		nvm->write_target_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    97d4:	f8c7 1420 	str.w	r1, [r7, #1056]	; 0x420
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, nvm->write_buffer_length);
    97d8:	47a8      	blx	r5
		
		acknowledge = 1;
    97da:	2501      	movs	r5, #1

	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    97dc:	4b1d      	ldr	r3, [pc, #116]	; (9854 <grid_sys_nvm_store_configuration+0x1b4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    97de:	4f1e      	ldr	r7, [pc, #120]	; (9858 <grid_sys_nvm_store_configuration+0x1b8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    97e0:	4e27      	ldr	r6, [pc, #156]	; (9880 <grid_sys_nvm_store_configuration+0x1e0>)
	grid_msg_init(&response);
    97e2:	a8d3      	add	r0, sp, #844	; 0x34c
    97e4:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    97e6:	227f      	movs	r2, #127	; 0x7f
    97e8:	4611      	mov	r1, r2
    97ea:	2300      	movs	r3, #0
    97ec:	a8d3      	add	r0, sp, #844	; 0x34c
    97ee:	47b8      	blx	r7
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    97f0:	2303      	movs	r3, #3
    97f2:	4924      	ldr	r1, [pc, #144]	; (9884 <grid_sys_nvm_store_configuration+0x1e4>)
    97f4:	9300      	str	r3, [sp, #0]
    97f6:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    97f8:	2700      	movs	r7, #0
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    97fa:	2360      	movs	r3, #96	; 0x60
    97fc:	a805      	add	r0, sp, #20
	uint8_t response_payload[10] = {0};
    97fe:	e9cd 7705 	strd	r7, r7, [sp, #20]
    9802:	f8ad 701c 	strh.w	r7, [sp, #28]
	sprintf(response_payload, GRID_CLASS_GLOBALSTORE_frame);	
    9806:	47b0      	blx	r6

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9808:	a805      	add	r0, sp, #20
    980a:	47c0      	blx	r8
    980c:	a905      	add	r1, sp, #20
    980e:	4602      	mov	r2, r0
    9810:	a8d3      	add	r0, sp, #844	; 0x34c
    9812:	47c8      	blx	r9
	
	if (acknowledge == 1){
    9814:	b1dd      	cbz	r5, 984e <grid_sys_nvm_store_configuration+0x1ae>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);	
    9816:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    9818:	2204      	movs	r2, #4
    981a:	4639      	mov	r1, r7
    981c:	9300      	str	r3, [sp, #0]
    981e:	a8d3      	add	r0, sp, #844	; 0x34c
    9820:	2301      	movs	r3, #1
    9822:	47a0      	blx	r4
	}

	
	grid_msg_packet_close(&response);
    9824:	9b02      	ldr	r3, [sp, #8]
    9826:	a8d3      	add	r0, sp, #844	; 0x34c
    9828:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    982a:	4b17      	ldr	r3, [pc, #92]	; (9888 <grid_sys_nvm_store_configuration+0x1e8>)
    982c:	a8d3      	add	r0, sp, #844	; 0x34c
    982e:	4798      	blx	r3
		
	
}
    9830:	f20d 4dec 	addw	sp, sp, #1260	; 0x4ec
    9834:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9838:	4629      	mov	r1, r5
    983a:	a86c      	add	r0, sp, #432	; 0x1b0
    983c:	9203      	str	r2, [sp, #12]
    983e:	47d8      	blx	fp
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    9840:	3501      	adds	r5, #1
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    9842:	f80a 0b01 	strb.w	r0, [sl], #1
		for(uint32_t i = 0; i<nvm->write_buffer_length; i++){
    9846:	9a03      	ldr	r2, [sp, #12]
    9848:	e7bc      	b.n	97c4 <grid_sys_nvm_store_configuration+0x124>
	uint8_t acknowledge = 0;
    984a:	4605      	mov	r5, r0
    984c:	e7c6      	b.n	97dc <grid_sys_nvm_store_configuration+0x13c>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);	
    984e:	230b      	movs	r3, #11
    9850:	e7e2      	b.n	9818 <grid_sys_nvm_store_configuration+0x178>
    9852:	bf00      	nop
    9854:	00008ed5 	.word	0x00008ed5
    9858:	00008f09 	.word	0x00008f09
    985c:	00014d51 	.word	0x00014d51
    9860:	00008e3f 	.word	0x00008e3f
    9864:	00008eb9 	.word	0x00008eb9
    9868:	0001698f 	.word	0x0001698f
    986c:	000166c6 	.word	0x000166c6
    9870:	00009001 	.word	0x00009001
    9874:	00008e31 	.word	0x00008e31
    9878:	000095e1 	.word	0x000095e1
    987c:	0000f75d 	.word	0x0000f75d
    9880:	00015299 	.word	0x00015299
    9884:	00016985 	.word	0x00016985
    9888:	000090d5 	.word	0x000090d5
    988c:	00015317 	.word	0x00015317
    9890:	00008e45 	.word	0x00008e45
    9894:	00008fcb 	.word	0x00008fcb

00009898 <grid_sys_recall_configuration>:


void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    9898:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    989c:	f5ad 7d51 	sub.w	sp, sp, #836	; 0x344

	struct grid_msg message;
	
	grid_msg_init(&message);
    98a0:	4b48      	ldr	r3, [pc, #288]	; (99c4 <grid_sys_recall_configuration+0x12c>)
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    98a2:	4c49      	ldr	r4, [pc, #292]	; (99c8 <grid_sys_recall_configuration+0x130>)
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    98a4:	4605      	mov	r5, r0
	grid_msg_init(&message);
    98a6:	a869      	add	r0, sp, #420	; 0x1a4
void grid_sys_recall_configuration(struct grid_sys_model* sys, uint8_t bank){
    98a8:	468a      	mov	sl, r1
	grid_msg_init(&message);
    98aa:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    98ac:	227f      	movs	r2, #127	; 0x7f
    98ae:	4611      	mov	r1, r2
    98b0:	2300      	movs	r3, #0
    98b2:	a869      	add	r0, sp, #420	; 0x1a4
    98b4:	47a0      	blx	r4


	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    98b6:	2400      	movs	r4, #0
    98b8:	4b44      	ldr	r3, [pc, #272]	; (99cc <grid_sys_recall_configuration+0x134>)
    98ba:	9405      	str	r4, [sp, #20]
    98bc:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    98c0:	4621      	mov	r1, r4
    98c2:	a806      	add	r0, sp, #24
    98c4:	4798      	blx	r3
	uint8_t payload_length = 0;
	uint32_t offset = 0;
	
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    98c6:	3513      	adds	r5, #19
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    98c8:	9403      	str	r4, [sp, #12]
		
		if (bank > GRID_SYS_BANK_MAXNUMBER || bank == i){
    98ca:	f1ba 0f04 	cmp.w	sl, #4
    98ce:	d803      	bhi.n	98d8 <grid_sys_recall_configuration+0x40>
    98d0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    98d4:	459a      	cmp	sl, r3
    98d6:	d164      	bne.n	99a2 <grid_sys_recall_configuration+0x10a>
			
			// BANK ENABLED
			offset = grid_msg_body_get_length(&message);
    98d8:	4b3d      	ldr	r3, [pc, #244]	; (99d0 <grid_sys_recall_configuration+0x138>)
		
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    98da:	4e3e      	ldr	r6, [pc, #248]	; (99d4 <grid_sys_recall_configuration+0x13c>)
			payload_length = strlen(payload);
		
			grid_msg_body_append_text(&message, payload, payload_length);
    98dc:	f8df 9110 	ldr.w	r9, [pc, #272]	; 99f0 <grid_sys_recall_configuration+0x158>
			offset = grid_msg_body_get_length(&message);
    98e0:	a869      	add	r0, sp, #420	; 0x1a4
    98e2:	4798      	blx	r3
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    98e4:	f04f 0b03 	mov.w	fp, #3
			offset = grid_msg_body_get_length(&message);
    98e8:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    98ea:	2331      	movs	r3, #49	; 0x31
    98ec:	493a      	ldr	r1, [pc, #232]	; (99d8 <grid_sys_recall_configuration+0x140>)
    98ee:	f8cd b000 	str.w	fp, [sp]
    98f2:	2202      	movs	r2, #2
    98f4:	a805      	add	r0, sp, #20
    98f6:	47b0      	blx	r6
			payload_length = strlen(payload);
    98f8:	4a38      	ldr	r2, [pc, #224]	; (99dc <grid_sys_recall_configuration+0x144>)
    98fa:	a805      	add	r0, sp, #20
    98fc:	4790      	blx	r2
		
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    98fe:	f04f 080d 	mov.w	r8, #13
			grid_msg_body_append_text(&message, payload, payload_length);
    9902:	b2c2      	uxtb	r2, r0
    9904:	a905      	add	r1, sp, #20
    9906:	a869      	add	r0, sp, #420	; 0x1a4
    9908:	47c8      	blx	r9
			sprintf(payload, GRID_CLASS_BANKENABLED_frame);
    990a:	4634      	mov	r4, r6
			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    990c:	4639      	mov	r1, r7
    990e:	4e34      	ldr	r6, [pc, #208]	; (99e0 <grid_sys_recall_configuration+0x148>)
    9910:	f8cd 8000 	str.w	r8, [sp]
    9914:	2301      	movs	r3, #1
    9916:	2204      	movs	r2, #4
    9918:	a869      	add	r0, sp, #420	; 0x1a4
    991a:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_BANKNUMBER_offset, GRID_CLASS_BANKENABLED_BANKNUMBER_length, i);
    991c:	9b03      	ldr	r3, [sp, #12]
    991e:	9300      	str	r3, [sp, #0]
    9920:	4639      	mov	r1, r7
    9922:	2302      	movs	r3, #2
    9924:	2205      	movs	r2, #5
    9926:	a869      	add	r0, sp, #420	; 0x1a4
    9928:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKENABLED_ISENABLED_offset, GRID_CLASS_BANKENABLED_ISENABLED_length, sys->bank_enabled[i]);
    992a:	782b      	ldrb	r3, [r5, #0]
    992c:	9300      	str	r3, [sp, #0]
    992e:	4639      	mov	r1, r7
    9930:	2207      	movs	r2, #7
    9932:	2302      	movs	r3, #2
    9934:	a869      	add	r0, sp, #420	; 0x1a4
    9936:	47b0      	blx	r6
		
			// BANK COLOR
			offset = grid_msg_body_get_length(&message);
    9938:	4b25      	ldr	r3, [pc, #148]	; (99d0 <grid_sys_recall_configuration+0x138>)
    993a:	a869      	add	r0, sp, #420	; 0x1a4
    993c:	4798      	blx	r3
		
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    993e:	2332      	movs	r3, #50	; 0x32
			offset = grid_msg_body_get_length(&message);
    9940:	4607      	mov	r7, r0
			sprintf(payload, GRID_CLASS_BANKCOLOR_frame);
    9942:	4928      	ldr	r1, [pc, #160]	; (99e4 <grid_sys_recall_configuration+0x14c>)
    9944:	f8cd b000 	str.w	fp, [sp]
    9948:	2202      	movs	r2, #2
    994a:	a805      	add	r0, sp, #20
    994c:	47a0      	blx	r4
			payload_length = strlen(payload);
    994e:	4a23      	ldr	r2, [pc, #140]	; (99dc <grid_sys_recall_configuration+0x144>)
    9950:	a805      	add	r0, sp, #20
    9952:	4790      	blx	r2
		
			grid_msg_body_append_text(&message, payload, payload_length);
    9954:	a905      	add	r1, sp, #20
    9956:	b2c2      	uxtb	r2, r0
    9958:	a869      	add	r0, sp, #420	; 0x1a4
    995a:	47c8      	blx	r9

			grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    995c:	2301      	movs	r3, #1
    995e:	2204      	movs	r2, #4
    9960:	4639      	mov	r1, r7
    9962:	a869      	add	r0, sp, #420	; 0x1a4
    9964:	f8cd 8000 	str.w	r8, [sp]
    9968:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_NUM_offset, GRID_CLASS_BANKCOLOR_NUM_length, i);
    996a:	9b03      	ldr	r3, [sp, #12]
    996c:	9300      	str	r3, [sp, #0]
    996e:	2205      	movs	r2, #5
    9970:	2302      	movs	r3, #2
    9972:	4639      	mov	r1, r7
    9974:	a869      	add	r0, sp, #420	; 0x1a4
    9976:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_RED_offset, GRID_CLASS_BANKCOLOR_RED_length, sys->bank_color_r[i]);
    9978:	792b      	ldrb	r3, [r5, #4]
    997a:	9300      	str	r3, [sp, #0]
    997c:	2207      	movs	r2, #7
    997e:	2302      	movs	r3, #2
    9980:	4639      	mov	r1, r7
    9982:	a869      	add	r0, sp, #420	; 0x1a4
    9984:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_GRE_offset, GRID_CLASS_BANKCOLOR_GRE_length, sys->bank_color_g[i]);
    9986:	7a2b      	ldrb	r3, [r5, #8]
    9988:	9300      	str	r3, [sp, #0]
    998a:	2209      	movs	r2, #9
    998c:	2302      	movs	r3, #2
    998e:	4639      	mov	r1, r7
    9990:	a869      	add	r0, sp, #420	; 0x1a4
    9992:	47b0      	blx	r6
			grid_msg_text_set_parameter(&message, offset, GRID_CLASS_BANKCOLOR_BLU_offset, GRID_CLASS_BANKCOLOR_BLU_length, sys->bank_color_b[i]);
    9994:	7b2b      	ldrb	r3, [r5, #12]
    9996:	9300      	str	r3, [sp, #0]
    9998:	220b      	movs	r2, #11
    999a:	2302      	movs	r3, #2
    999c:	4639      	mov	r1, r7
    999e:	a869      	add	r0, sp, #420	; 0x1a4
    99a0:	47b0      	blx	r6
	for(uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    99a2:	9b03      	ldr	r3, [sp, #12]
    99a4:	3301      	adds	r3, #1
    99a6:	2b04      	cmp	r3, #4
    99a8:	9303      	str	r3, [sp, #12]
    99aa:	f105 0501 	add.w	r5, r5, #1
    99ae:	d18c      	bne.n	98ca <grid_sys_recall_configuration+0x32>
		}

		
	}
	
	grid_msg_packet_close(&message);
    99b0:	4b0d      	ldr	r3, [pc, #52]	; (99e8 <grid_sys_recall_configuration+0x150>)
    99b2:	a869      	add	r0, sp, #420	; 0x1a4
    99b4:	4798      	blx	r3

	grid_msg_packet_send_everywhere(&message);
    99b6:	4b0d      	ldr	r3, [pc, #52]	; (99ec <grid_sys_recall_configuration+0x154>)
    99b8:	a869      	add	r0, sp, #420	; 0x1a4
    99ba:	4798      	blx	r3
// 	
// 	grid_msg_packet_close(&response);
// 	grid_msg_packet_send_everywhere(&response);
	
	
}
    99bc:	f50d 7d51 	add.w	sp, sp, #836	; 0x344
    99c0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    99c4:	00008ed5 	.word	0x00008ed5
    99c8:	00008f09 	.word	0x00008f09
    99cc:	00014d51 	.word	0x00014d51
    99d0:	00008e3f 	.word	0x00008e3f
    99d4:	00015299 	.word	0x00015299
    99d8:	0001698f 	.word	0x0001698f
    99dc:	00015317 	.word	0x00015317
    99e0:	00008eb9 	.word	0x00008eb9
    99e4:	000166c6 	.word	0x000166c6
    99e8:	00009001 	.word	0x00009001
    99ec:	000090d5 	.word	0x000090d5
    99f0:	00008e45 	.word	0x00008e45

000099f4 <grid_sys_nvm_load_configuration>:


void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    99f4:	b5f0      	push	{r4, r5, r6, r7, lr}
    99f6:	f5ad 7d6d 	sub.w	sp, sp, #948	; 0x3b4
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    99fa:	2400      	movs	r4, #0
void grid_sys_nvm_load_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    99fc:	460e      	mov	r6, r1
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
    99fe:	4b2f      	ldr	r3, [pc, #188]	; (9abc <grid_sys_nvm_load_configuration+0xc8>)
    9a00:	946c      	str	r4, [sp, #432]	; 0x1b0
    9a02:	f44f 72fe 	mov.w	r2, #508	; 0x1fc
    9a06:	4621      	mov	r1, r4
    9a08:	a86d      	add	r0, sp, #436	; 0x1b4
    9a0a:	4798      	blx	r3
    9a0c:	ad6c      	add	r5, sp, #432	; 0x1b0
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    9a0e:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
    9a12:	f8c6 1214 	str.w	r1, [r6, #532]	; 0x214
	
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    9a16:	6830      	ldr	r0, [r6, #0]
    9a18:	4e29      	ldr	r6, [pc, #164]	; (9ac0 <grid_sys_nvm_load_configuration+0xcc>)
    9a1a:	f44f 7300 	mov.w	r3, #512	; 0x200
    9a1e:	462a      	mov	r2, r5
    9a20:	47b0      	blx	r6
			}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9a22:	4a28      	ldr	r2, [pc, #160]	; (9ac4 <grid_sys_nvm_load_configuration+0xd0>)
	flash_read(nvm->flash, nvm->read_source_address, temp, GRID_NVM_PAGE_SIZE);
    9a24:	4621      	mov	r1, r4
	uint8_t acknowledge = 0;	
    9a26:	4626      	mov	r6, r4
	uint8_t copydone = 0;
    9a28:	4623      	mov	r3, r4
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9a2a:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    9a2e:	1c4c      	adds	r4, r1, #1
    9a30:	b943      	cbnz	r3, 9a44 <grid_sys_nvm_load_configuration+0x50>
			if (temp[i] == '\n'){ // END OF PACKET, copy newline character
    9a32:	5c68      	ldrb	r0, [r5, r1]
    9a34:	280a      	cmp	r0, #10
    9a36:	d139      	bne.n	9aac <grid_sys_nvm_load_configuration+0xb8>
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9a38:	4411      	add	r1, r2
    9a3a:	55c8      	strb	r0, [r1, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    9a3c:	6214      	str	r4, [r2, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    9a3e:	6293      	str	r3, [r2, #40]	; 0x28
				acknowledge = 1;
    9a40:	2301      	movs	r3, #1
				copydone = 1;
    9a42:	461e      	mov	r6, r3
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){		
    9a44:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    9a48:	4621      	mov	r1, r4
    9a4a:	d1f0      	bne.n	9a2e <grid_sys_nvm_load_configuration+0x3a>
	
	
	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
	
	grid_msg_init(&response);
    9a4c:	4b1e      	ldr	r3, [pc, #120]	; (9ac8 <grid_sys_nvm_load_configuration+0xd4>)
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9a4e:	4c1f      	ldr	r4, [pc, #124]	; (9acc <grid_sys_nvm_load_configuration+0xd8>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9a50:	4d1f      	ldr	r5, [pc, #124]	; (9ad0 <grid_sys_nvm_load_configuration+0xdc>)
	grid_msg_init(&response);
    9a52:	a805      	add	r0, sp, #20
    9a54:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9a56:	227f      	movs	r2, #127	; 0x7f
    9a58:	4611      	mov	r1, r2
    9a5a:	2300      	movs	r3, #0
    9a5c:	a805      	add	r0, sp, #20
    9a5e:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9a60:	2303      	movs	r3, #3
    9a62:	491c      	ldr	r1, [pc, #112]	; (9ad4 <grid_sys_nvm_load_configuration+0xe0>)
    9a64:	9300      	str	r3, [sp, #0]
    9a66:	2202      	movs	r2, #2
	uint8_t response_payload[10] = {0};
    9a68:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9a6a:	2361      	movs	r3, #97	; 0x61
    9a6c:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    9a6e:	e9cd 4402 	strd	r4, r4, [sp, #8]
    9a72:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALLOAD_frame);
    9a76:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9a78:	4b17      	ldr	r3, [pc, #92]	; (9ad8 <grid_sys_nvm_load_configuration+0xe4>)
    9a7a:	4d18      	ldr	r5, [pc, #96]	; (9adc <grid_sys_nvm_load_configuration+0xe8>)
    9a7c:	a802      	add	r0, sp, #8
    9a7e:	4798      	blx	r3
    9a80:	4b17      	ldr	r3, [pc, #92]	; (9ae0 <grid_sys_nvm_load_configuration+0xec>)
    9a82:	4602      	mov	r2, r0
    9a84:	a902      	add	r1, sp, #8
    9a86:	a805      	add	r0, sp, #20
    9a88:	4798      	blx	r3
	
	if (acknowledge == 1){
    9a8a:	b1ae      	cbz	r6, 9ab8 <grid_sys_nvm_load_configuration+0xc4>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9a8c:	230a      	movs	r3, #10
	}
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9a8e:	2204      	movs	r2, #4
    9a90:	4621      	mov	r1, r4
    9a92:	9300      	str	r3, [sp, #0]
    9a94:	a805      	add	r0, sp, #20
    9a96:	2301      	movs	r3, #1
    9a98:	47a8      	blx	r5
	}

	
	grid_msg_packet_close(&response);
    9a9a:	4b12      	ldr	r3, [pc, #72]	; (9ae4 <grid_sys_nvm_load_configuration+0xf0>)
    9a9c:	a805      	add	r0, sp, #20
    9a9e:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9aa0:	4b11      	ldr	r3, [pc, #68]	; (9ae8 <grid_sys_nvm_load_configuration+0xf4>)
    9aa2:	a805      	add	r0, sp, #20
    9aa4:	4798      	blx	r3
	
}
    9aa6:	f50d 7d6d 	add.w	sp, sp, #948	; 0x3b4
    9aaa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			else if (temp[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    9aac:	28ff      	cmp	r0, #255	; 0xff
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9aae:	bf16      	itet	ne
    9ab0:	1889      	addne	r1, r1, r2
				copydone = 1;
    9ab2:	2301      	moveq	r3, #1
				GRID_PORT_U.rx_double_buffer[i] = temp[i];
    9ab4:	55c8      	strbne	r0, [r1, r7]
    9ab6:	e7c5      	b.n	9a44 <grid_sys_nvm_load_configuration+0x50>
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    9ab8:	230b      	movs	r3, #11
    9aba:	e7e8      	b.n	9a8e <grid_sys_nvm_load_configuration+0x9a>
    9abc:	00014d51 	.word	0x00014d51
    9ac0:	0000f6f1 	.word	0x0000f6f1
    9ac4:	2000c0b0 	.word	0x2000c0b0
    9ac8:	00008ed5 	.word	0x00008ed5
    9acc:	00008f09 	.word	0x00008f09
    9ad0:	00015299 	.word	0x00015299
    9ad4:	00016985 	.word	0x00016985
    9ad8:	00015317 	.word	0x00015317
    9adc:	00008eb9 	.word	0x00008eb9
    9ae0:	00008e45 	.word	0x00008e45
    9ae4:	00009001 	.word	0x00009001
    9ae8:	000090d5 	.word	0x000090d5

00009aec <grid_sys_nvm_clear_configuration>:

void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9aec:	b530      	push	{r4, r5, lr}
    9aee:	460b      	mov	r3, r1
	
	uint8_t temp[GRID_NVM_PAGE_SIZE] = {0};
	uint16_t length = 0;
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    9af0:	f44f 21fe 	mov.w	r1, #520192	; 0x7f000
void grid_sys_nvm_clear_configuration(struct grid_sys_model* sys, struct grid_nvm_model* nvm){
    9af4:	b0ed      	sub	sp, #436	; 0x1b4
	nvm->read_source_address = GRID_NVM_GLOBAL_BASE_ADDRESS;
    9af6:	f8c3 1214 	str.w	r1, [r3, #532]	; 0x214
	
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    9afa:	2201      	movs	r2, #1
    9afc:	6818      	ldr	r0, [r3, #0]
    9afe:	4b18      	ldr	r3, [pc, #96]	; (9b60 <grid_sys_nvm_clear_configuration+0x74>)

	// Generate ACKNOWLEDGE RESPONSE
	struct grid_msg response;
		
	grid_msg_init(&response);
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b00:	4c18      	ldr	r4, [pc, #96]	; (9b64 <grid_sys_nvm_clear_configuration+0x78>)

	uint8_t response_payload[10] = {0};
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    9b02:	4d19      	ldr	r5, [pc, #100]	; (9b68 <grid_sys_nvm_clear_configuration+0x7c>)
	flash_erase(nvm->flash, GRID_NVM_GLOBAL_BASE_ADDRESS, 1);
    9b04:	4798      	blx	r3
	grid_msg_init(&response);
    9b06:	a805      	add	r0, sp, #20
    9b08:	4b18      	ldr	r3, [pc, #96]	; (9b6c <grid_sys_nvm_clear_configuration+0x80>)
    9b0a:	4798      	blx	r3
	grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b0c:	227f      	movs	r2, #127	; 0x7f
    9b0e:	4611      	mov	r1, r2
    9b10:	a805      	add	r0, sp, #20
    9b12:	2300      	movs	r3, #0
    9b14:	47a0      	blx	r4
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    9b16:	2303      	movs	r3, #3
	uint8_t response_payload[10] = {0};
    9b18:	2400      	movs	r4, #0
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    9b1a:	4915      	ldr	r1, [pc, #84]	; (9b70 <grid_sys_nvm_clear_configuration+0x84>)
    9b1c:	9300      	str	r3, [sp, #0]
    9b1e:	2202      	movs	r2, #2
    9b20:	2362      	movs	r3, #98	; 0x62
    9b22:	a802      	add	r0, sp, #8
	uint8_t response_payload[10] = {0};
    9b24:	e9cd 4402 	strd	r4, r4, [sp, #8]
    9b28:	f8ad 4010 	strh.w	r4, [sp, #16]
	sprintf(response_payload, GRID_CLASS_GLOBALCLEAR_frame);
    9b2c:	47a8      	blx	r5

	grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    9b2e:	4b11      	ldr	r3, [pc, #68]	; (9b74 <grid_sys_nvm_clear_configuration+0x88>)
    9b30:	a802      	add	r0, sp, #8
    9b32:	4798      	blx	r3
    9b34:	a902      	add	r1, sp, #8
    9b36:	4602      	mov	r2, r0
    9b38:	4b0f      	ldr	r3, [pc, #60]	; (9b78 <grid_sys_nvm_clear_configuration+0x8c>)
    9b3a:	a805      	add	r0, sp, #20
    9b3c:	4798      	blx	r3
		
	if (acknowledge == 1){
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_ACKNOWLEDGE_code);
    9b3e:	230a      	movs	r3, #10
    9b40:	4621      	mov	r1, r4
    9b42:	2204      	movs	r2, #4
    9b44:	9300      	str	r3, [sp, #0]
    9b46:	a805      	add	r0, sp, #20
    9b48:	4c0c      	ldr	r4, [pc, #48]	; (9b7c <grid_sys_nvm_clear_configuration+0x90>)
    9b4a:	2301      	movs	r3, #1
    9b4c:	47a0      	blx	r4
	else{
		grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
	}

		
	grid_msg_packet_close(&response);
    9b4e:	4b0c      	ldr	r3, [pc, #48]	; (9b80 <grid_sys_nvm_clear_configuration+0x94>)
    9b50:	a805      	add	r0, sp, #20
    9b52:	4798      	blx	r3
	grid_msg_packet_send_everywhere(&response);
    9b54:	4b0b      	ldr	r3, [pc, #44]	; (9b84 <grid_sys_nvm_clear_configuration+0x98>)
    9b56:	a805      	add	r0, sp, #20
    9b58:	4798      	blx	r3
	
	
}
    9b5a:	b06d      	add	sp, #436	; 0x1b4
    9b5c:	bd30      	pop	{r4, r5, pc}
    9b5e:	bf00      	nop
    9b60:	0000f7dd 	.word	0x0000f7dd
    9b64:	00008f09 	.word	0x00008f09
    9b68:	00015299 	.word	0x00015299
    9b6c:	00008ed5 	.word	0x00008ed5
    9b70:	00016985 	.word	0x00016985
    9b74:	00015317 	.word	0x00015317
    9b78:	00008e45 	.word	0x00008e45
    9b7c:	00008eb9 	.word	0x00008eb9
    9b80:	00009001 	.word	0x00009001
    9b84:	000090d5 	.word	0x000090d5

00009b88 <grid_debug_print_text>:



void grid_debug_print_text(uint8_t* debug_string){
    9b88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	
	uint32_t debug_string_length = strlen(debug_string);
    9b8c:	f8df a0e0 	ldr.w	sl, [pc, #224]	; 9c70 <grid_debug_print_text+0xe8>
	
	struct grid_msg message;
	
	grid_msg_init(&message);
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9b90:	4c2b      	ldr	r4, [pc, #172]	; (9c40 <grid_debug_print_text+0xb8>)
	
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
	uint32_t offset = 0;
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    9b92:	4e2c      	ldr	r6, [pc, #176]	; (9c44 <grid_debug_print_text+0xbc>)
	offset += strlen(&payload[offset]);
		
	sprintf(&payload[offset], "# ");
    9b94:	4f2c      	ldr	r7, [pc, #176]	; (9c48 <grid_debug_print_text+0xc0>)
void grid_debug_print_text(uint8_t* debug_string){
    9b96:	f5ad 7d4c 	sub.w	sp, sp, #816	; 0x330
    9b9a:	4681      	mov	r9, r0
	uint32_t debug_string_length = strlen(debug_string);
    9b9c:	47d0      	blx	sl
	grid_msg_init(&message);
    9b9e:	4b2b      	ldr	r3, [pc, #172]	; (9c4c <grid_debug_print_text+0xc4>)
	uint32_t debug_string_length = strlen(debug_string);
    9ba0:	4680      	mov	r8, r0
	grid_msg_init(&message);
    9ba2:	a865      	add	r0, sp, #404	; 0x194
    9ba4:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    9ba6:	227f      	movs	r2, #127	; 0x7f
    9ba8:	4611      	mov	r1, r2
    9baa:	2300      	movs	r3, #0
    9bac:	a865      	add	r0, sp, #404	; 0x194
    9bae:	47a0      	blx	r4
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    9bb0:	2400      	movs	r4, #0
    9bb2:	4621      	mov	r1, r4
    9bb4:	4b26      	ldr	r3, [pc, #152]	; (9c50 <grid_debug_print_text+0xc8>)
    9bb6:	9401      	str	r4, [sp, #4]
    9bb8:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    9bbc:	a802      	add	r0, sp, #8
    9bbe:	4798      	blx	r3
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_start);
    9bc0:	2202      	movs	r2, #2
    9bc2:	4924      	ldr	r1, [pc, #144]	; (9c54 <grid_debug_print_text+0xcc>)
    9bc4:	2320      	movs	r3, #32
    9bc6:	a801      	add	r0, sp, #4
    9bc8:	47b0      	blx	r6
	offset += strlen(&payload[offset]);
    9bca:	a801      	add	r0, sp, #4
    9bcc:	47d0      	blx	sl
	sprintf(&payload[offset], "# ");
    9bce:	ab01      	add	r3, sp, #4
    9bd0:	4403      	add	r3, r0
    9bd2:	4921      	ldr	r1, [pc, #132]	; (9c58 <grid_debug_print_text+0xd0>)
	offset += strlen(&payload[offset]);
    9bd4:	4605      	mov	r5, r0
	sprintf(&payload[offset], "# ");
    9bd6:	4618      	mov	r0, r3
    9bd8:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    9bda:	47d0      	blx	sl
    9bdc:	ab01      	add	r3, sp, #4
    9bde:	4405      	add	r5, r0

	for(uint32_t i=0; i<debug_string_length; i++){
    9be0:	1958      	adds	r0, r3, r5
    9be2:	4621      	mov	r1, r4
    9be4:	4603      	mov	r3, r0
    9be6:	4654      	mov	r4, sl
    9be8:	4541      	cmp	r1, r8
    9bea:	d006      	beq.n	9bfa <grid_debug_print_text+0x72>
		
		payload[offset+i] = debug_string[i];
    9bec:	f819 2001 	ldrb.w	r2, [r9, r1]
    9bf0:	f803 2b01 	strb.w	r2, [r3], #1
		
		if (offset + i > GRID_PARAMETER_PACKET_marign)
    9bf4:	194a      	adds	r2, r1, r5
    9bf6:	2ac8      	cmp	r2, #200	; 0xc8
    9bf8:	d91f      	bls.n	9c3a <grid_debug_print_text+0xb2>
		{
			break;
		}
	}
	offset += strlen(&payload[offset]);
    9bfa:	47a0      	blx	r4
	
	
	sprintf(&payload[offset], " #");
    9bfc:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    9bfe:	4405      	add	r5, r0
	sprintf(&payload[offset], " #");
    9c00:	442b      	add	r3, r5
    9c02:	4916      	ldr	r1, [pc, #88]	; (9c5c <grid_debug_print_text+0xd4>)
    9c04:	4618      	mov	r0, r3
    9c06:	47b8      	blx	r7
	offset += strlen(&payload[offset]);
    9c08:	47a0      	blx	r4
	
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    9c0a:	ab01      	add	r3, sp, #4
	offset += strlen(&payload[offset]);
    9c0c:	4405      	add	r5, r0
	sprintf(&payload[offset], GRID_CLASS_DEBUGTEXT_frame_end);
    9c0e:	195f      	adds	r7, r3, r5
    9c10:	4913      	ldr	r1, [pc, #76]	; (9c60 <grid_debug_print_text+0xd8>)
    9c12:	2203      	movs	r2, #3
    9c14:	4638      	mov	r0, r7
    9c16:	47b0      	blx	r6
	offset += strlen(&payload[offset]);	
    9c18:	4638      	mov	r0, r7
    9c1a:	47a0      	blx	r4
	
	grid_msg_body_append_text(&message, payload, offset);
    9c1c:	a901      	add	r1, sp, #4
    9c1e:	1942      	adds	r2, r0, r5
    9c20:	4b10      	ldr	r3, [pc, #64]	; (9c64 <grid_debug_print_text+0xdc>)
    9c22:	a865      	add	r0, sp, #404	; 0x194
    9c24:	4798      	blx	r3
	grid_msg_packet_close(&message);
    9c26:	4b10      	ldr	r3, [pc, #64]	; (9c68 <grid_debug_print_text+0xe0>)
    9c28:	a865      	add	r0, sp, #404	; 0x194
    9c2a:	4798      	blx	r3
	
	grid_msg_packet_send_everywhere(&message);
    9c2c:	4b0f      	ldr	r3, [pc, #60]	; (9c6c <grid_debug_print_text+0xe4>)
    9c2e:	a865      	add	r0, sp, #404	; 0x194
    9c30:	4798      	blx	r3
	

	
	
}
    9c32:	f50d 7d4c 	add.w	sp, sp, #816	; 0x330
    9c36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	for(uint32_t i=0; i<debug_string_length; i++){
    9c3a:	3101      	adds	r1, #1
    9c3c:	e7d4      	b.n	9be8 <grid_debug_print_text+0x60>
    9c3e:	bf00      	nop
    9c40:	00008f09 	.word	0x00008f09
    9c44:	00015299 	.word	0x00015299
    9c48:	00015307 	.word	0x00015307
    9c4c:	00008ed5 	.word	0x00008ed5
    9c50:	00014d51 	.word	0x00014d51
    9c54:	0001699d 	.word	0x0001699d
    9c58:	000169a5 	.word	0x000169a5
    9c5c:	000169a8 	.word	0x000169a8
    9c60:	000166c3 	.word	0x000166c3
    9c64:	00008e45 	.word	0x00008e45
    9c68:	00009001 	.word	0x00009001
    9c6c:	000090d5 	.word	0x000090d5
    9c70:	00015317 	.word	0x00015317

00009c74 <tx_cb_USART_GRID>:
static void tx_cb_USART_GRID_W(const struct usart_async_descriptor *const descr)
{
	tx_cb_USART_GRID(&GRID_PORT_W);
}

void tx_cb_USART_GRID(struct grid_port* const por){
    9c74:	b530      	push	{r4, r5, lr}
	
	
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    9c76:	f06f 052b 	mvn.w	r5, #43	; 0x2b
    9c7a:	8984      	ldrh	r4, [r0, #12]
    9c7c:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    9c80:	1a2d      	subs	r5, r5, r0
    9c82:	2200      	movs	r2, #0
    9c84:	18e9      	adds	r1, r5, r3
    9c86:	428c      	cmp	r4, r1
    9c88:	d801      	bhi.n	9c8e <tx_cb_USART_GRID+0x1a>
		por->tx_double_buffer[i] = 0;
	}
	por->tx_double_buffer_status = 0;	
    9c8a:	8182      	strh	r2, [r0, #12]
}
    9c8c:	bd30      	pop	{r4, r5, pc}
		por->tx_double_buffer[i] = 0;
    9c8e:	f803 2b01 	strb.w	r2, [r3], #1
	for(uint32_t i=0; i<por->tx_double_buffer_status; i++){
    9c92:	e7f7      	b.n	9c84 <tx_cb_USART_GRID+0x10>

00009c94 <tx_cb_USART_GRID_W>:
	tx_cb_USART_GRID(&GRID_PORT_W);
    9c94:	4801      	ldr	r0, [pc, #4]	; (9c9c <tx_cb_USART_GRID_W+0x8>)
    9c96:	4b02      	ldr	r3, [pc, #8]	; (9ca0 <tx_cb_USART_GRID_W+0xc>)
    9c98:	4718      	bx	r3
    9c9a:	bf00      	nop
    9c9c:	200102d4 	.word	0x200102d4
    9ca0:	00009c75 	.word	0x00009c75

00009ca4 <tx_cb_USART_GRID_S>:
	tx_cb_USART_GRID(&GRID_PORT_S);
    9ca4:	4801      	ldr	r0, [pc, #4]	; (9cac <tx_cb_USART_GRID_S+0x8>)
    9ca6:	4b02      	ldr	r3, [pc, #8]	; (9cb0 <tx_cb_USART_GRID_S+0xc>)
    9ca8:	4718      	bx	r3
    9caa:	bf00      	nop
    9cac:	200138d4 	.word	0x200138d4
    9cb0:	00009c75 	.word	0x00009c75

00009cb4 <tx_cb_USART_GRID_E>:
	tx_cb_USART_GRID(&GRID_PORT_E);
    9cb4:	4801      	ldr	r0, [pc, #4]	; (9cbc <tx_cb_USART_GRID_E+0x8>)
    9cb6:	4b02      	ldr	r3, [pc, #8]	; (9cc0 <tx_cb_USART_GRID_E+0xc>)
    9cb8:	4718      	bx	r3
    9cba:	bf00      	nop
    9cbc:	20019870 	.word	0x20019870
    9cc0:	00009c75 	.word	0x00009c75

00009cc4 <tx_cb_USART_GRID_N>:
	tx_cb_USART_GRID(&GRID_PORT_N);
    9cc4:	4801      	ldr	r0, [pc, #4]	; (9ccc <tx_cb_USART_GRID_N+0x8>)
    9cc6:	4b02      	ldr	r3, [pc, #8]	; (9cd0 <tx_cb_USART_GRID_N+0xc>)
    9cc8:	4718      	bx	r3
    9cca:	bf00      	nop
    9ccc:	20009150 	.word	0x20009150
    9cd0:	00009c75 	.word	0x00009c75

00009cd4 <err_cb_USART_GRID>:
	err_cb_USART_GRID(&GRID_PORT_W);
}


void err_cb_USART_GRID(struct grid_port* const por){
	por->usart_error_flag = 1;	
    9cd4:	2301      	movs	r3, #1
    9cd6:	7603      	strb	r3, [r0, #24]
	
	usart_async_disable(por->usart);
    9cd8:	6840      	ldr	r0, [r0, #4]
    9cda:	4b01      	ldr	r3, [pc, #4]	; (9ce0 <err_cb_USART_GRID+0xc>)
    9cdc:	4718      	bx	r3
    9cde:	bf00      	nop
    9ce0:	0001115d 	.word	0x0001115d

00009ce4 <err_cb_USART_GRID_W>:
	err_cb_USART_GRID(&GRID_PORT_W);
    9ce4:	4801      	ldr	r0, [pc, #4]	; (9cec <err_cb_USART_GRID_W+0x8>)
    9ce6:	4b02      	ldr	r3, [pc, #8]	; (9cf0 <err_cb_USART_GRID_W+0xc>)
    9ce8:	4718      	bx	r3
    9cea:	bf00      	nop
    9cec:	200102d4 	.word	0x200102d4
    9cf0:	00009cd5 	.word	0x00009cd5

00009cf4 <err_cb_USART_GRID_S>:
	err_cb_USART_GRID(&GRID_PORT_S);
    9cf4:	4801      	ldr	r0, [pc, #4]	; (9cfc <err_cb_USART_GRID_S+0x8>)
    9cf6:	4b02      	ldr	r3, [pc, #8]	; (9d00 <err_cb_USART_GRID_S+0xc>)
    9cf8:	4718      	bx	r3
    9cfa:	bf00      	nop
    9cfc:	200138d4 	.word	0x200138d4
    9d00:	00009cd5 	.word	0x00009cd5

00009d04 <err_cb_USART_GRID_E>:
	err_cb_USART_GRID(&GRID_PORT_E);
    9d04:	4801      	ldr	r0, [pc, #4]	; (9d0c <err_cb_USART_GRID_E+0x8>)
    9d06:	4b02      	ldr	r3, [pc, #8]	; (9d10 <err_cb_USART_GRID_E+0xc>)
    9d08:	4718      	bx	r3
    9d0a:	bf00      	nop
    9d0c:	20019870 	.word	0x20019870
    9d10:	00009cd5 	.word	0x00009cd5

00009d14 <err_cb_USART_GRID_N>:
	err_cb_USART_GRID(&GRID_PORT_N);
    9d14:	4801      	ldr	r0, [pc, #4]	; (9d1c <err_cb_USART_GRID_N+0x8>)
    9d16:	4b02      	ldr	r3, [pc, #8]	; (9d20 <err_cb_USART_GRID_N+0xc>)
    9d18:	4718      	bx	r3
    9d1a:	bf00      	nop
    9d1c:	20009150 	.word	0x20009150
    9d20:	00009cd5 	.word	0x00009cd5

00009d24 <grid_sys_port_reset_dma>:
#define DMA_SOUTH_RX_CHANNEL	2
#define DMA_WEST_RX_CHANNEL		3

void grid_sys_port_reset_dma(struct grid_port* por){
	
	hri_dmac_clear_CHCTRLA_ENABLE_bit(DMAC, por->dma_channel);
    9d24:	7a80      	ldrb	r0, [r0, #10]
}

static inline void hri_dmac_clear_CHCTRLA_ENABLE_bit(const void *const hw, uint8_t submodule_index)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg &= ~DMAC_CHCTRLA_ENABLE;
    9d26:	0103      	lsls	r3, r0, #4
    9d28:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    9d2c:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
	_dma_enable_transaction(por->dma_channel, false);
    9d30:	2100      	movs	r1, #0
    9d32:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    9d34:	f022 0202 	bic.w	r2, r2, #2
    9d38:	641a      	str	r2, [r3, #64]	; 0x40
    9d3a:	4b01      	ldr	r3, [pc, #4]	; (9d40 <grid_sys_port_reset_dma+0x1c>)
    9d3c:	4718      	bx	r3
    9d3e:	bf00      	nop
    9d40:	0000ebc1 	.word	0x0000ebc1

00009d44 <dma_transfer_complete_n_cb>:
	grid_sys_port_reset_dma(por);
    9d44:	4801      	ldr	r0, [pc, #4]	; (9d4c <dma_transfer_complete_n_cb+0x8>)
    9d46:	4b02      	ldr	r3, [pc, #8]	; (9d50 <dma_transfer_complete_n_cb+0xc>)
    9d48:	4718      	bx	r3
    9d4a:	bf00      	nop
    9d4c:	20009150 	.word	0x20009150
    9d50:	00009d25 	.word	0x00009d25

00009d54 <dma_transfer_complete_e_cb>:
    9d54:	4801      	ldr	r0, [pc, #4]	; (9d5c <dma_transfer_complete_e_cb+0x8>)
    9d56:	4b02      	ldr	r3, [pc, #8]	; (9d60 <dma_transfer_complete_e_cb+0xc>)
    9d58:	4718      	bx	r3
    9d5a:	bf00      	nop
    9d5c:	20019870 	.word	0x20019870
    9d60:	00009d25 	.word	0x00009d25

00009d64 <dma_transfer_complete_s_cb>:
    9d64:	4801      	ldr	r0, [pc, #4]	; (9d6c <dma_transfer_complete_s_cb+0x8>)
    9d66:	4b02      	ldr	r3, [pc, #8]	; (9d70 <dma_transfer_complete_s_cb+0xc>)
    9d68:	4718      	bx	r3
    9d6a:	bf00      	nop
    9d6c:	200138d4 	.word	0x200138d4
    9d70:	00009d25 	.word	0x00009d25

00009d74 <dma_transfer_complete_w_cb>:
    9d74:	4801      	ldr	r0, [pc, #4]	; (9d7c <dma_transfer_complete_w_cb+0x8>)
    9d76:	4b02      	ldr	r3, [pc, #8]	; (9d80 <dma_transfer_complete_w_cb+0xc>)
    9d78:	4718      	bx	r3
    9d7a:	bf00      	nop
    9d7c:	200102d4 	.word	0x200102d4
    9d80:	00009d25 	.word	0x00009d25

00009d84 <grid_sys_uart_init>:

}


void grid_sys_uart_init(){
    9d84:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_gpio_set_pin_pull_mode((enum gpio_port)GPIO_PORT(pin), pin & 0x1F, pull_mode);
    9d88:	211c      	movs	r1, #28
    9d8a:	4c2c      	ldr	r4, [pc, #176]	; (9e3c <grid_sys_uart_init+0xb8>)
	gpio_set_pin_pull_mode(PC28, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC16, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PC12, GPIO_PULL_UP);
	gpio_set_pin_pull_mode(PB09, GPIO_PULL_UP);
	
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    9d8c:	f8df 80f8 	ldr.w	r8, [pc, #248]	; 9e88 <grid_sys_uart_init+0x104>
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9d90:	4f2b      	ldr	r7, [pc, #172]	; (9e40 <grid_sys_uart_init+0xbc>)
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    9d92:	4e2c      	ldr	r6, [pc, #176]	; (9e44 <grid_sys_uart_init+0xc0>)
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    9d94:	4d2c      	ldr	r5, [pc, #176]	; (9e48 <grid_sys_uart_init+0xc4>)
			
	// Set parity for grid uart communication
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    9d96:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 9e8c <grid_sys_uart_init+0x108>
    9d9a:	2002      	movs	r0, #2
    9d9c:	47a0      	blx	r4
    9d9e:	2110      	movs	r1, #16
    9da0:	2002      	movs	r0, #2
    9da2:	47a0      	blx	r4
    9da4:	210c      	movs	r1, #12
    9da6:	2002      	movs	r0, #2
    9da8:	47a0      	blx	r4
    9daa:	2109      	movs	r1, #9
    9dac:	2001      	movs	r0, #1
    9dae:	47a0      	blx	r4
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_N);
    9db0:	4c26      	ldr	r4, [pc, #152]	; (9e4c <grid_sys_uart_init+0xc8>)
    9db2:	4a27      	ldr	r2, [pc, #156]	; (9e50 <grid_sys_uart_init+0xcc>)
    9db4:	2101      	movs	r1, #1
    9db6:	4640      	mov	r0, r8
    9db8:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_E);
    9dba:	4a26      	ldr	r2, [pc, #152]	; (9e54 <grid_sys_uart_init+0xd0>)
    9dbc:	2101      	movs	r1, #1
    9dbe:	4638      	mov	r0, r7
    9dc0:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_TXC_CB, tx_cb_USART_GRID_S);
    9dc2:	4a25      	ldr	r2, [pc, #148]	; (9e58 <grid_sys_uart_init+0xd4>)
    9dc4:	2101      	movs	r1, #1
    9dc6:	4630      	mov	r0, r6
    9dc8:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST,  USART_ASYNC_TXC_CB, tx_cb_USART_GRID_W);
    9dca:	4a24      	ldr	r2, [pc, #144]	; (9e5c <grid_sys_uart_init+0xd8>)
    9dcc:	2101      	movs	r1, #1
    9dce:	4628      	mov	r0, r5
    9dd0:	47a0      	blx	r4
	usart_async_set_parity(&USART_NORTH, USART_PARITY_ODD);
    9dd2:	2101      	movs	r1, #1
    9dd4:	4640      	mov	r0, r8
    9dd6:	47c8      	blx	r9
	usart_async_set_parity(&USART_EAST, USART_PARITY_ODD);	
    9dd8:	2101      	movs	r1, #1
    9dda:	4638      	mov	r0, r7
    9ddc:	47c8      	blx	r9
	usart_async_set_parity(&USART_SOUTH, USART_PARITY_ODD);
    9dde:	2101      	movs	r1, #1
    9de0:	4630      	mov	r0, r6
    9de2:	47c8      	blx	r9
	usart_async_set_parity(&USART_WEST, USART_PARITY_ODD);
    9de4:	2101      	movs	r1, #1
    9de6:	4628      	mov	r0, r5
    9de8:	47c8      	blx	r9
	
	// Set callback function for parity error
	usart_async_register_callback(&USART_NORTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_N);
    9dea:	4a1d      	ldr	r2, [pc, #116]	; (9e60 <grid_sys_uart_init+0xdc>)
    9dec:	2102      	movs	r1, #2
    9dee:	4640      	mov	r0, r8
    9df0:	47a0      	blx	r4
	usart_async_register_callback(&USART_EAST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_E);
    9df2:	4a1c      	ldr	r2, [pc, #112]	; (9e64 <grid_sys_uart_init+0xe0>)
    9df4:	2102      	movs	r1, #2
    9df6:	4638      	mov	r0, r7
    9df8:	47a0      	blx	r4
	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_S);
    9dfa:	4a1b      	ldr	r2, [pc, #108]	; (9e68 <grid_sys_uart_init+0xe4>)
    9dfc:	2102      	movs	r1, #2
    9dfe:	4630      	mov	r0, r6
    9e00:	47a0      	blx	r4
	usart_async_register_callback(&USART_WEST, USART_ASYNC_ERROR_CB, err_cb_USART_GRID_W);
    9e02:	4a1a      	ldr	r2, [pc, #104]	; (9e6c <grid_sys_uart_init+0xe8>)
    9e04:	2102      	movs	r1, #2
    9e06:	4628      	mov	r0, r5
    9e08:	47a0      	blx	r4
// 	usart_async_register_callback(&USART_EAST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_E);
// 	usart_async_register_callback(&USART_SOUTH, USART_ASYNC_RXC_CB, rx_cb_USART_GRID_S);
// 	usart_async_register_callback(&USART_WEST,  USART_ASYNC_RXC_CB, rx_cb_USART_GRID_W);

	
	usart_async_get_io_descriptor(&USART_NORTH, &grid_sys_north_io);
    9e0a:	4c19      	ldr	r4, [pc, #100]	; (9e70 <grid_sys_uart_init+0xec>)
    9e0c:	4919      	ldr	r1, [pc, #100]	; (9e74 <grid_sys_uart_init+0xf0>)
    9e0e:	4640      	mov	r0, r8
    9e10:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_EAST,  &grid_sys_east_io);
    9e12:	4919      	ldr	r1, [pc, #100]	; (9e78 <grid_sys_uart_init+0xf4>)
    9e14:	4638      	mov	r0, r7
    9e16:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_SOUTH, &grid_sys_south_io);
    9e18:	4918      	ldr	r1, [pc, #96]	; (9e7c <grid_sys_uart_init+0xf8>)
    9e1a:	4630      	mov	r0, r6
    9e1c:	47a0      	blx	r4
	usart_async_get_io_descriptor(&USART_WEST,  &grid_sys_west_io);
    9e1e:	4918      	ldr	r1, [pc, #96]	; (9e80 <grid_sys_uart_init+0xfc>)
    9e20:	4628      	mov	r0, r5
    9e22:	47a0      	blx	r4
	
	
	usart_async_enable(&USART_NORTH);
    9e24:	4c17      	ldr	r4, [pc, #92]	; (9e84 <grid_sys_uart_init+0x100>)
    9e26:	4640      	mov	r0, r8
    9e28:	47a0      	blx	r4
	usart_async_enable(&USART_EAST);
    9e2a:	4638      	mov	r0, r7
    9e2c:	47a0      	blx	r4
	usart_async_enable(&USART_SOUTH);
    9e2e:	4630      	mov	r0, r6
    9e30:	47a0      	blx	r4
	usart_async_enable(&USART_WEST);
    9e32:	4628      	mov	r0, r5
    9e34:	4623      	mov	r3, r4




}
    9e36:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	usart_async_enable(&USART_WEST);
    9e3a:	4718      	bx	r3
    9e3c:	00009669 	.word	0x00009669
    9e40:	2001cdb0 	.word	0x2001cdb0
    9e44:	2001cf08 	.word	0x2001cf08
    9e48:	2001ceb8 	.word	0x2001ceb8
    9e4c:	000111ad 	.word	0x000111ad
    9e50:	00009cc5 	.word	0x00009cc5
    9e54:	00009cb5 	.word	0x00009cb5
    9e58:	00009ca5 	.word	0x00009ca5
    9e5c:	00009c95 	.word	0x00009c95
    9e60:	00009d15 	.word	0x00009d15
    9e64:	00009d05 	.word	0x00009d05
    9e68:	00009cf5 	.word	0x00009cf5
    9e6c:	00009ce5 	.word	0x00009ce5
    9e70:	00011189 	.word	0x00011189
    9e74:	2000f004 	.word	0x2000f004
    9e78:	200138d0 	.word	0x200138d0
    9e7c:	20016820 	.word	0x20016820
    9e80:	2001c850 	.word	0x2001c850
    9e84:	00011131 	.word	0x00011131
    9e88:	2001ce04 	.word	0x2001ce04
    9e8c:	0001120d 	.word	0x0001120d

00009e90 <grid_sys_dma_rx_init_one>:



void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9e90:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
	
	uint8_t dma_rx_channel = por->dma_channel;
	
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9e92:	6843      	ldr	r3, [r0, #4]
	uint8_t dma_rx_channel = por->dma_channel;
    9e94:	7a84      	ldrb	r4, [r0, #10]
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9e96:	460f      	mov	r7, r1
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9e98:	6a19      	ldr	r1, [r3, #32]
    9e9a:	4b10      	ldr	r3, [pc, #64]	; (9edc <grid_sys_dma_rx_init_one+0x4c>)
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9e9c:	4605      	mov	r5, r0
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9e9e:	3128      	adds	r1, #40	; 0x28
    9ea0:	4620      	mov	r0, r4
void grid_sys_dma_rx_init_one(struct grid_port* por, uint32_t buffer_length, void* transfer_done_cb() ){
    9ea2:	4616      	mov	r6, r2
	_dma_set_source_address(dma_rx_channel, (uint32_t) & (((Sercom *)((*por->usart).device.hw))->USART.DATA.reg));
    9ea4:	4798      	blx	r3
	_dma_set_destination_address(dma_rx_channel, (uint32_t *)por->rx_double_buffer);
    9ea6:	f505 519d 	add.w	r1, r5, #5024	; 0x13a0
    9eaa:	4b0d      	ldr	r3, [pc, #52]	; (9ee0 <grid_sys_dma_rx_init_one+0x50>)
    9eac:	3114      	adds	r1, #20
    9eae:	4620      	mov	r0, r4
    9eb0:	4798      	blx	r3
	_dma_set_data_amount(dma_rx_channel, (uint32_t)buffer_length);
    9eb2:	4639      	mov	r1, r7
    9eb4:	4b0b      	ldr	r3, [pc, #44]	; (9ee4 <grid_sys_dma_rx_init_one+0x54>)
    9eb6:	4620      	mov	r0, r4
    9eb8:	4798      	blx	r3
	
	struct _dma_resource *resource_rx;
	_dma_get_channel_resource(&resource_rx, dma_rx_channel);
    9eba:	4621      	mov	r1, r4
    9ebc:	4b0a      	ldr	r3, [pc, #40]	; (9ee8 <grid_sys_dma_rx_init_one+0x58>)
    9ebe:	a801      	add	r0, sp, #4
    9ec0:	4798      	blx	r3
	
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    9ec2:	9b01      	ldr	r3, [sp, #4]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    9ec4:	2201      	movs	r2, #1
	resource_rx->dma_cb.transfer_done = transfer_done_cb;
    9ec6:	601e      	str	r6, [r3, #0]
	_dma_set_irq_state(dma_rx_channel, DMA_TRANSFER_COMPLETE_CB, true);
    9ec8:	4620      	mov	r0, r4
    9eca:	4b08      	ldr	r3, [pc, #32]	; (9eec <grid_sys_dma_rx_init_one+0x5c>)
    9ecc:	2100      	movs	r1, #0
    9ece:	4798      	blx	r3
	
	//resource_rx->dma_cb.error         = function_cb;
	_dma_enable_transaction(dma_rx_channel, false);
    9ed0:	4b07      	ldr	r3, [pc, #28]	; (9ef0 <grid_sys_dma_rx_init_one+0x60>)
    9ed2:	2100      	movs	r1, #0
    9ed4:	4620      	mov	r0, r4
    9ed6:	4798      	blx	r3
	

}
    9ed8:	b003      	add	sp, #12
    9eda:	bdf0      	pop	{r4, r5, r6, r7, pc}
    9edc:	0000eb51 	.word	0x0000eb51
    9ee0:	0000eb41 	.word	0x0000eb41
    9ee4:	0000eb7d 	.word	0x0000eb7d
    9ee8:	0000ebfd 	.word	0x0000ebfd
    9eec:	0000eb19 	.word	0x0000eb19
    9ef0:	0000ebc1 	.word	0x0000ebc1

00009ef4 <grid_sys_dma_rx_init>:

void grid_sys_dma_rx_init(){
    9ef4:	b510      	push	{r4, lr}
	
	grid_sys_dma_rx_init_one(&GRID_PORT_N, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_n_cb);
    9ef6:	4a10      	ldr	r2, [pc, #64]	; (9f38 <grid_sys_dma_rx_init+0x44>)
    9ef8:	4c10      	ldr	r4, [pc, #64]	; (9f3c <grid_sys_dma_rx_init+0x48>)
    9efa:	4811      	ldr	r0, [pc, #68]	; (9f40 <grid_sys_dma_rx_init+0x4c>)
    9efc:	f241 3188 	movw	r1, #5000	; 0x1388
    9f00:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_E, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_e_cb);
    9f02:	4a10      	ldr	r2, [pc, #64]	; (9f44 <grid_sys_dma_rx_init+0x50>)
    9f04:	4810      	ldr	r0, [pc, #64]	; (9f48 <grid_sys_dma_rx_init+0x54>)
    9f06:	f241 3188 	movw	r1, #5000	; 0x1388
    9f0a:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_S, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_s_cb);
    9f0c:	4a0f      	ldr	r2, [pc, #60]	; (9f4c <grid_sys_dma_rx_init+0x58>)
    9f0e:	4810      	ldr	r0, [pc, #64]	; (9f50 <grid_sys_dma_rx_init+0x5c>)
    9f10:	f241 3188 	movw	r1, #5000	; 0x1388
    9f14:	47a0      	blx	r4
	grid_sys_dma_rx_init_one(&GRID_PORT_W, GRID_DOUBLE_BUFFER_RX_SIZE, dma_transfer_complete_w_cb);
    9f16:	4a0f      	ldr	r2, [pc, #60]	; (9f54 <grid_sys_dma_rx_init+0x60>)
    9f18:	480f      	ldr	r0, [pc, #60]	; (9f58 <grid_sys_dma_rx_init+0x64>)
    9f1a:	f241 3188 	movw	r1, #5000	; 0x1388
    9f1e:	47a0      	blx	r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    9f20:	4b0e      	ldr	r3, [pc, #56]	; (9f5c <grid_sys_dma_rx_init+0x68>)
    9f22:	2200      	movs	r2, #0
    9f24:	f883 231f 	strb.w	r2, [r3, #799]	; 0x31f
    9f28:	f883 2320 	strb.w	r2, [r3, #800]	; 0x320
    9f2c:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
    9f30:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
	NVIC_SetPriority(DMAC_0_IRQn, 0);
	NVIC_SetPriority(DMAC_1_IRQn, 0);
	NVIC_SetPriority(DMAC_2_IRQn, 0);
	NVIC_SetPriority(DMAC_3_IRQn, 0);
	
}
    9f34:	bd10      	pop	{r4, pc}
    9f36:	bf00      	nop
    9f38:	00009d45 	.word	0x00009d45
    9f3c:	00009e91 	.word	0x00009e91
    9f40:	20009150 	.word	0x20009150
    9f44:	00009d55 	.word	0x00009d55
    9f48:	20019870 	.word	0x20019870
    9f4c:	00009d65 	.word	0x00009d65
    9f50:	200138d4 	.word	0x200138d4
    9f54:	00009d75 	.word	0x00009d75
    9f58:	200102d4 	.word	0x200102d4
    9f5c:	e000e100 	.word	0xe000e100

00009f60 <grid_sys_init>:
	return tmp;
}

static inline hri_rstc_rcause_reg_t hri_rstc_read_RCAUSE_reg(const void *const hw)
{
	return ((Rstc *)hw)->RCAUSE.reg;
    9f60:	4b16      	ldr	r3, [pc, #88]	; (9fbc <grid_sys_init+0x5c>)

void grid_sys_init(struct grid_sys_model* mod){
    9f62:	b570      	push	{r4, r5, r6, lr}
    9f64:	781b      	ldrb	r3, [r3, #0]
	
	mod->uptime = 0;
	mod->reset_cause = hri_rstc_read_RCAUSE_reg(RSTC);
    9f66:	7103      	strb	r3, [r0, #4]
	mod->uptime = 0;
    9f68:	2500      	movs	r5, #0
void grid_sys_init(struct grid_sys_model* mod){
    9f6a:	4604      	mov	r4, r0
	mod->uptime = 0;
    9f6c:	6005      	str	r5, [r0, #0]
	
    
	mod->sessionid = rand_sync_read8(&RAND_0);
    9f6e:	4b14      	ldr	r3, [pc, #80]	; (9fc0 <grid_sys_init+0x60>)
    9f70:	4814      	ldr	r0, [pc, #80]	; (9fc4 <grid_sys_init+0x64>)
    9f72:	4798      	blx	r3
	mod->bank_color_r[3] = 100;
	mod->bank_color_g[3] = 0;
	mod->bank_color_b[3] = 200;
	
	mod->bank_enabled[0] = 1;
	mod->bank_enabled[1] = 1;
    9f74:	4a14      	ldr	r2, [pc, #80]	; (9fc8 <grid_sys_init+0x68>)
    9f76:	4b15      	ldr	r3, [pc, #84]	; (9fcc <grid_sys_init+0x6c>)
	mod->bank_color_g[1] = 100;
    9f78:	4915      	ldr	r1, [pc, #84]	; (9fd0 <grid_sys_init+0x70>)
	mod->sessionid = rand_sync_read8(&RAND_0);
    9f7a:	7160      	strb	r0, [r4, #5]
	mod->bank_enabled[1] = 1;
    9f7c:	e9c4 2304 	strd	r2, r3, [r4, #16]
	mod->bank_color_g[1] = 100;
    9f80:	4b14      	ldr	r3, [pc, #80]	; (9fd4 <grid_sys_init+0x74>)
	mod->bank_setting_changed_flag = 0;
	
	mod->bank_init_flag = 0;


	mod->bank_activebank_number = 0;
    9f82:	73e5      	strb	r5, [r4, #15]
	mod->bank_color_g[1] = 100;
    9f84:	e9c4 1306 	strd	r1, r3, [r4, #24]
	mod->bank_color_b[1] = 0;
    9f88:	f44f 5348 	mov.w	r3, #12800	; 0x3200
    9f8c:	8423      	strh	r3, [r4, #32]
	mod->bank_color_b[3] = 200;
    9f8e:	23c8      	movs	r3, #200	; 0xc8
    9f90:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
	if (banknumber == 255){
			
		//mod->bank_activebank_number = 0;
		mod->bank_activebank_valid = 0;
		
		mod->bank_active_changed = 1;
    9f94:	4b10      	ldr	r3, [pc, #64]	; (9fd8 <grid_sys_init+0x78>)
	mod->bank_activebank_color_r = 0;
    9f96:	6265      	str	r5, [r4, #36]	; 0x24
		mod->bank_active_changed = 1;
    9f98:	2201      	movs	r2, #1
    9f9a:	745a      	strb	r2, [r3, #17]
				
		mod->bank_activebank_color_r = 127;
    9f9c:	f647 727f 	movw	r2, #32639	; 0x7f7f
		mod->bank_activebank_valid = 0;
    9fa0:	f883 5023 	strb.w	r5, [r3, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    9fa4:	849a      	strh	r2, [r3, #36]	; 0x24
		mod->bank_activebank_color_g = 127;
		mod->bank_activebank_color_b = 127;
    9fa6:	227f      	movs	r2, #127	; 0x7f
    9fa8:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	grid_port_init_all();
    9fac:	4b0b      	ldr	r3, [pc, #44]	; (9fdc <grid_sys_init+0x7c>)
    9fae:	4798      	blx	r3
	grid_sys_uart_init();
    9fb0:	4b0b      	ldr	r3, [pc, #44]	; (9fe0 <grid_sys_init+0x80>)
    9fb2:	4798      	blx	r3
}
    9fb4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	grid_sys_dma_rx_init();
    9fb8:	4b0a      	ldr	r3, [pc, #40]	; (9fe4 <grid_sys_init+0x84>)
    9fba:	4718      	bx	r3
    9fbc:	40000c00 	.word	0x40000c00
    9fc0:	0000f131 	.word	0x0000f131
    9fc4:	2001cd7c 	.word	0x2001cd7c
    9fc8:	01000001 	.word	0x01000001
    9fcc:	00010101 	.word	0x00010101
    9fd0:	646432c8 	.word	0x646432c8
    9fd4:	c800c864 	.word	0xc800c864
    9fd8:	2000f008 	.word	0x2000f008
    9fdc:	0000511d 	.word	0x0000511d
    9fe0:	00009d85 	.word	0x00009d85
    9fe4:	00009ef5 	.word	0x00009ef5

00009fe8 <grid_sys_bank_enable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9fe8:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 1;
    9fea:	bf9e      	ittt	ls
    9fec:	1809      	addls	r1, r1, r0
    9fee:	2301      	movls	r3, #1
    9ff0:	74cb      	strbls	r3, [r1, #19]
}
    9ff2:	4770      	bx	lr

00009ff4 <grid_sys_bank_disable>:
	if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    9ff4:	2903      	cmp	r1, #3
		mod->bank_enabled[banknumber] = 0;
    9ff6:	bf9e      	ittt	ls
    9ff8:	1809      	addls	r1, r1, r0
    9ffa:	2300      	movls	r3, #0
    9ffc:	74cb      	strbls	r3, [r1, #19]
}
    9ffe:	4770      	bx	lr

0000a000 <grid_sys_bank_set_color>:
	if (banknumber>GRID_SYS_BANK_MAXNUMBER){
    a000:	2904      	cmp	r1, #4
    a002:	d901      	bls.n	a008 <grid_sys_bank_set_color+0x8>
		return false;
    a004:	2000      	movs	r0, #0
    a006:	4770      	bx	lr
	mod->bank_color_r[banknumber] = ((rgb&0x00FF0000)>>16);
    a008:	4401      	add	r1, r0
    a00a:	0c13      	lsrs	r3, r2, #16
    a00c:	75cb      	strb	r3, [r1, #23]
	mod->bank_color_g[banknumber] = ((rgb&0x0000FF00)>>8);
    a00e:	0a13      	lsrs	r3, r2, #8
    a010:	76cb      	strb	r3, [r1, #27]
	mod->bank_color_b[banknumber] = ((rgb&0x000000FF)>>0);
    a012:	77ca      	strb	r2, [r1, #31]
}
    a014:	4770      	bx	lr

0000a016 <grid_sys_get_bank_num>:
}
    a016:	7bc0      	ldrb	r0, [r0, #15]
    a018:	4770      	bx	lr

0000a01a <grid_sys_get_bank_valid>:
}
    a01a:	f890 0023 	ldrb.w	r0, [r0, #35]	; 0x23
    a01e:	4770      	bx	lr

0000a020 <grid_sys_get_bank_red>:
}
    a020:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
    a024:	4770      	bx	lr

0000a026 <grid_sys_get_bank_gre>:
}
    a026:	f890 0025 	ldrb.w	r0, [r0, #37]	; 0x25
    a02a:	4770      	bx	lr

0000a02c <grid_sys_get_bank_blu>:
}
    a02c:	f890 0026 	ldrb.w	r0, [r0, #38]	; 0x26
    a030:	4770      	bx	lr

0000a032 <grid_sys_get_map_state>:
}
    a032:	7c00      	ldrb	r0, [r0, #16]
    a034:	4770      	bx	lr

0000a036 <grid_sys_get_bank_next>:
uint8_t grid_sys_get_bank_next(struct grid_sys_model* mod){
    a036:	b530      	push	{r4, r5, lr}
    a038:	4602      	mov	r2, r0
	return mod->bank_activebank_number;
    a03a:	7bc0      	ldrb	r0, [r0, #15]
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    a03c:	1c43      	adds	r3, r0, #1
    a03e:	1d44      	adds	r4, r0, #5
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    a040:	f003 0103 	and.w	r1, r3, #3
		if (mod->bank_enabled[bank_check] == 1){
    a044:	1855      	adds	r5, r2, r1
    a046:	7ced      	ldrb	r5, [r5, #19]
    a048:	2d01      	cmp	r5, #1
    a04a:	d003      	beq.n	a054 <grid_sys_get_bank_next+0x1e>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    a04c:	3301      	adds	r3, #1
    a04e:	42a3      	cmp	r3, r4
    a050:	d1f6      	bne.n	a040 <grid_sys_get_bank_next+0xa>
}
    a052:	bd30      	pop	{r4, r5, pc}
		uint8_t bank_check = (current_active+i+1)%GRID_SYS_BANK_MAXNUMBER;
    a054:	b2c8      	uxtb	r0, r1
    a056:	e7fc      	b.n	a052 <grid_sys_get_bank_next+0x1c>

0000a058 <grid_sys_get_bank_number_of_first_valid>:
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    a058:	f100 0213 	add.w	r2, r0, #19
uint8_t grid_sys_get_bank_number_of_first_valid(struct grid_sys_model* mod){
    a05c:	2300      	movs	r3, #0
		if (mod->bank_enabled[i] == 1){
    a05e:	f812 1b01 	ldrb.w	r1, [r2], #1
    a062:	2901      	cmp	r1, #1
    a064:	b2d8      	uxtb	r0, r3
    a066:	d003      	beq.n	a070 <grid_sys_get_bank_number_of_first_valid+0x18>
	for (uint8_t i=0; i<GRID_SYS_BANK_MAXNUMBER; i++){
    a068:	3301      	adds	r3, #1
    a06a:	2b04      	cmp	r3, #4
    a06c:	d1f7      	bne.n	a05e <grid_sys_get_bank_number_of_first_valid+0x6>
	return 255;
    a06e:	20ff      	movs	r0, #255	; 0xff
}
    a070:	4770      	bx	lr

0000a072 <grid_sys_set_bank>:
	if (banknumber == 255){
    a072:	29ff      	cmp	r1, #255	; 0xff
    a074:	d10b      	bne.n	a08e <grid_sys_set_bank+0x1c>
		mod->bank_active_changed = 1;
    a076:	2301      	movs	r3, #1
    a078:	7443      	strb	r3, [r0, #17]
		mod->bank_activebank_valid = 0;
    a07a:	2300      	movs	r3, #0
    a07c:	f880 3023 	strb.w	r3, [r0, #35]	; 0x23
		mod->bank_activebank_color_r = 127;
    a080:	f647 737f 	movw	r3, #32639	; 0x7f7f
    a084:	8483      	strh	r3, [r0, #36]	; 0x24
		mod->bank_activebank_color_b = 127;
    a086:	237f      	movs	r3, #127	; 0x7f
			
			mod->bank_active_changed = 1;
			
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    a088:	f880 3026 	strb.w	r3, [r0, #38]	; 0x26
		//grid_debug_print_text("Invalid Bank Number");	
				
	}

	
}
    a08c:	4770      	bx	lr
	else if (banknumber<GRID_SYS_BANK_MAXNUMBER){
    a08e:	2903      	cmp	r1, #3
    a090:	d8fc      	bhi.n	a08c <grid_sys_set_bank+0x1a>
		mod->bank_init_flag = 1;
    a092:	2301      	movs	r3, #1
    a094:	f880 3027 	strb.w	r3, [r0, #39]	; 0x27
		if (mod->bank_enabled[banknumber] == 1){
    a098:	1843      	adds	r3, r0, r1
    a09a:	7cda      	ldrb	r2, [r3, #19]
    a09c:	2a01      	cmp	r2, #1
    a09e:	d1f5      	bne.n	a08c <grid_sys_set_bank+0x1a>
			mod->bank_activebank_number = banknumber;
    a0a0:	73c1      	strb	r1, [r0, #15]
			mod->bank_activebank_valid = 1;
    a0a2:	f880 2023 	strb.w	r2, [r0, #35]	; 0x23
			mod->bank_active_changed = 1;
    a0a6:	7442      	strb	r2, [r0, #17]
			mod->bank_activebank_color_r = mod->bank_color_r[mod->bank_activebank_number];
    a0a8:	7dda      	ldrb	r2, [r3, #23]
    a0aa:	f880 2024 	strb.w	r2, [r0, #36]	; 0x24
			mod->bank_activebank_color_g = mod->bank_color_g[mod->bank_activebank_number];
    a0ae:	7eda      	ldrb	r2, [r3, #27]
    a0b0:	f880 2025 	strb.w	r2, [r0, #37]	; 0x25
			mod->bank_activebank_color_b = mod->bank_color_b[mod->bank_activebank_number];	
    a0b4:	7fdb      	ldrb	r3, [r3, #31]
    a0b6:	e7e7      	b.n	a088 <grid_sys_set_bank+0x16>

0000a0b8 <grid_sys_rtc_get_time>:

// REALTIME

uint32_t grid_sys_rtc_get_time(struct grid_sys_model* mod){
	return mod->realtime;
}
    a0b8:	6a80      	ldr	r0, [r0, #40]	; 0x28
    a0ba:	4770      	bx	lr

0000a0bc <grid_sys_rtc_get_elapsed_time>:
	mod->realtime = tvalue;
}

uint32_t grid_sys_rtc_get_elapsed_time(struct grid_sys_model* mod, uint32_t t_old){
	
	return mod->realtime-t_old;
    a0bc:	6a80      	ldr	r0, [r0, #40]	; 0x28
	
	

}
    a0be:	1a40      	subs	r0, r0, r1
    a0c0:	4770      	bx	lr

0000a0c2 <grid_sys_rtc_tick_time>:

void grid_sys_rtc_tick_time(struct grid_sys_model* mod){
	
	mod->realtime++;
    a0c2:	6a83      	ldr	r3, [r0, #40]	; 0x28
    a0c4:	3301      	adds	r3, #1
    a0c6:	6283      	str	r3, [r0, #40]	; 0x28
	if (mod->uptime != -1){
    a0c8:	6803      	ldr	r3, [r0, #0]
    a0ca:	1c5a      	adds	r2, r3, #1
		mod->uptime++;
    a0cc:	bf1c      	itt	ne
    a0ce:	3301      	addne	r3, #1
    a0d0:	6003      	strne	r3, [r0, #0]
	}
	
}
    a0d2:	4770      	bx	lr

0000a0d4 <grid_sys_alert_read_color_changed_flag>:

uint8_t grid_sys_alert_read_color_changed_flag(struct grid_sys_model* mod){
		
	return mod->alert_color_changed;
	
}
    a0d4:	7b80      	ldrb	r0, [r0, #14]
    a0d6:	4770      	bx	lr

0000a0d8 <grid_sys_alert_clear_color_changed_flag>:
	
}

void grid_sys_alert_clear_color_changed_flag(struct grid_sys_model* mod){
	
	mod->alert_color_changed = 0;
    a0d8:	2300      	movs	r3, #0
    a0da:	7383      	strb	r3, [r0, #14]
	
}
    a0dc:	4770      	bx	lr

0000a0de <grid_sys_alert_get_color_intensity>:

uint8_t grid_sys_alert_get_color_intensity(struct grid_sys_model* mod){
	
	if (mod->alert_style == 0){ // TRIANGLE
    a0de:	7b03      	ldrb	r3, [r0, #12]
    a0e0:	b963      	cbnz	r3, a0fc <grid_sys_alert_get_color_intensity+0x1e>
		
		return (250-abs(mod->alert_state/2-250))/2;
    a0e2:	8940      	ldrh	r0, [r0, #10]
    a0e4:	0840      	lsrs	r0, r0, #1
    a0e6:	38fa      	subs	r0, #250	; 0xfa
    a0e8:	2800      	cmp	r0, #0
    a0ea:	bfb8      	it	lt
    a0ec:	4240      	neglt	r0, r0
    a0ee:	f1c0 00fa 	rsb	r0, r0, #250	; 0xfa
    a0f2:	eb00 70d0 	add.w	r0, r0, r0, lsr #31
    a0f6:	f3c0 0047 	ubfx	r0, r0, #1, #8
    a0fa:	4770      	bx	lr
	}
	else if (mod->alert_style == 1){ // SQUARE
    a0fc:	2b01      	cmp	r3, #1
    a0fe:	d107      	bne.n	a110 <grid_sys_alert_get_color_intensity+0x32>
		
		return 255*(mod->alert_state/250%2);
    a100:	8940      	ldrh	r0, [r0, #10]
    a102:	23fa      	movs	r3, #250	; 0xfa
    a104:	fbb0 f0f3 	udiv	r0, r0, r3
    a108:	f340 0000 	sbfx	r0, r0, #0, #1
    a10c:	b2c0      	uxtb	r0, r0
    a10e:	4770      	bx	lr
	}
	else if (mod->alert_style == 2){ // CONST
    a110:	2b02      	cmp	r3, #2
    a112:	d105      	bne.n	a120 <grid_sys_alert_get_color_intensity+0x42>
		
		return 255*(mod->alert_state>100);
    a114:	8940      	ldrh	r0, [r0, #10]
    a116:	2864      	cmp	r0, #100	; 0x64
    a118:	bf8c      	ite	hi
    a11a:	20ff      	movhi	r0, #255	; 0xff
    a11c:	2000      	movls	r0, #0
    a11e:	4770      	bx	lr
	}
	
	
}
    a120:	4770      	bx	lr

0000a122 <grid_sys_alert_set_alert>:
	mod->alert_color_green = green;
	mod->alert_color_blue = blue;
		
}

void grid_sys_alert_set_alert(struct grid_sys_model* mod, uint8_t red, uint8_t green, uint8_t blue, uint8_t style, uint16_t duration){
    a122:	b510      	push	{r4, lr}
	mod->alert_color_blue = blue;
    a124:	7203      	strb	r3, [r0, #8]
	
	grid_sys_alert_set_color(mod, red, green, blue);

	
	mod->alert_state = duration;
    a126:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    a12a:	8143      	strh	r3, [r0, #10]
	mod->alert_color_changed = 1;
    a12c:	2401      	movs	r4, #1
	mod->alert_style = style;
    a12e:	f89d 3008 	ldrb.w	r3, [sp, #8]
	mod->alert_color_changed = 1;
    a132:	7384      	strb	r4, [r0, #14]
	mod->alert_color_red = red;
    a134:	7181      	strb	r1, [r0, #6]
	mod->alert_color_green = green;
    a136:	71c2      	strb	r2, [r0, #7]
	mod->alert_style = style;
    a138:	7303      	strb	r3, [r0, #12]
	
}
    a13a:	bd10      	pop	{r4, pc}

0000a13c <grid_sys_alert_get_color_r>:

uint8_t grid_sys_alert_get_color_r(struct grid_sys_model* mod){
	
	return mod->alert_color_red;
}
    a13c:	7980      	ldrb	r0, [r0, #6]
    a13e:	4770      	bx	lr

0000a140 <grid_sys_alert_get_color_g>:

uint8_t grid_sys_alert_get_color_g(struct grid_sys_model* mod){
	
	return mod->alert_color_green;
}
    a140:	79c0      	ldrb	r0, [r0, #7]
    a142:	4770      	bx	lr

0000a144 <grid_sys_alert_get_color_b>:

uint8_t grid_sys_alert_get_color_b(struct grid_sys_model* mod){
	
	return mod->alert_color_blue;
}
    a144:	7a00      	ldrb	r0, [r0, #8]
    a146:	4770      	bx	lr

0000a148 <grid_sys_read_hex_char_value>:

uint8_t grid_sys_read_hex_char_value(uint8_t ascii, uint8_t* error_flag){
		
	uint8_t result = 0;
	
	if (ascii>47 && ascii<58){
    a148:	f1a0 0330 	sub.w	r3, r0, #48	; 0x30
    a14c:	b2db      	uxtb	r3, r3
    a14e:	2b09      	cmp	r3, #9
    a150:	d905      	bls.n	a15e <grid_sys_read_hex_char_value+0x16>
		result = ascii-48;
	}
	else if(ascii>96 && ascii<103){
    a152:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
    a156:	2b05      	cmp	r3, #5
    a158:	d803      	bhi.n	a162 <grid_sys_read_hex_char_value+0x1a>
		result = ascii - 97 + 10;
    a15a:	3857      	subs	r0, #87	; 0x57
    a15c:	b2c3      	uxtb	r3, r0
			*error_flag = ascii;
		}
	}
	
	return result;	
}
    a15e:	4618      	mov	r0, r3
    a160:	4770      	bx	lr
		if (error_flag != NULL){
    a162:	b111      	cbz	r1, a16a <grid_sys_read_hex_char_value+0x22>
			*error_flag = ascii;
    a164:	7008      	strb	r0, [r1, #0]
	uint8_t result = 0;
    a166:	2300      	movs	r3, #0
    a168:	e7f9      	b.n	a15e <grid_sys_read_hex_char_value+0x16>
    a16a:	460b      	mov	r3, r1
    a16c:	e7f7      	b.n	a15e <grid_sys_read_hex_char_value+0x16>
	...

0000a170 <grid_sys_read_hex_string_value>:

uint32_t grid_sys_read_hex_string_value(uint8_t* start_location, uint8_t length, uint8_t* error_flag){
    a170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	
	uint32_t result  = 0;
	
	for(uint8_t i=0; i<length; i++){
		
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    a172:	4f08      	ldr	r7, [pc, #32]	; (a194 <grid_sys_read_hex_string_value+0x24>)
    a174:	1e45      	subs	r5, r0, #1
    a176:	008c      	lsls	r4, r1, #2
	uint32_t result  = 0;
    a178:	2600      	movs	r6, #0
	for(uint8_t i=0; i<length; i++){
    a17a:	3c04      	subs	r4, #4
    a17c:	1d23      	adds	r3, r4, #4
    a17e:	d101      	bne.n	a184 <grid_sys_read_hex_string_value+0x14>

		
	}

	return result;
}
    a180:	4630      	mov	r0, r6
    a182:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		result += grid_sys_read_hex_char_value(start_location[i], error_flag) << (length-i-1)*4;
    a184:	f815 0f01 	ldrb.w	r0, [r5, #1]!
    a188:	4611      	mov	r1, r2
    a18a:	47b8      	blx	r7
    a18c:	40a0      	lsls	r0, r4
    a18e:	4406      	add	r6, r0
	for(uint8_t i=0; i<length; i++){
    a190:	e7f3      	b.n	a17a <grid_sys_read_hex_string_value+0xa>
    a192:	bf00      	nop
    a194:	0000a149 	.word	0x0000a149

0000a198 <grid_sys_write_hex_string_value>:

void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    a198:	b530      	push	{r4, r5, lr}
    a19a:	b085      	sub	sp, #20
	
	uint8_t str[10];
	
	sprintf(str, "%08x", value);
    a19c:	4b0a      	ldr	r3, [pc, #40]	; (a1c8 <grid_sys_write_hex_string_value+0x30>)
void grid_sys_write_hex_string_value(uint8_t* start_location, uint8_t size, uint32_t value){
    a19e:	460c      	mov	r4, r1
    a1a0:	4605      	mov	r5, r0
	sprintf(str, "%08x", value);
    a1a2:	490a      	ldr	r1, [pc, #40]	; (a1cc <grid_sys_write_hex_string_value+0x34>)
    a1a4:	a801      	add	r0, sp, #4
    a1a6:	4798      	blx	r3
		
	for(uint8_t i=0; i<size; i++){	
    a1a8:	aa01      	add	r2, sp, #4
    a1aa:	f1c4 0308 	rsb	r3, r4, #8
    a1ae:	4413      	add	r3, r2
    a1b0:	2200      	movs	r2, #0
    a1b2:	b2d1      	uxtb	r1, r2
    a1b4:	428c      	cmp	r4, r1
    a1b6:	d801      	bhi.n	a1bc <grid_sys_write_hex_string_value+0x24>
		start_location[i] = str[8-size+i];	
	}

}
    a1b8:	b005      	add	sp, #20
    a1ba:	bd30      	pop	{r4, r5, pc}
		start_location[i] = str[8-size+i];	
    a1bc:	f813 1b01 	ldrb.w	r1, [r3], #1
    a1c0:	54a9      	strb	r1, [r5, r2]
	for(uint8_t i=0; i<size; i++){	
    a1c2:	3201      	adds	r2, #1
    a1c4:	e7f5      	b.n	a1b2 <grid_sys_write_hex_string_value+0x1a>
    a1c6:	bf00      	nop
    a1c8:	00015299 	.word	0x00015299
    a1cc:	000169ab 	.word	0x000169ab

0000a1d0 <grid_sys_get_id>:



uint32_t grid_sys_get_id(uint32_t* return_array){
			
	return_array[0] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_0);
    a1d0:	4b06      	ldr	r3, [pc, #24]	; (a1ec <grid_sys_get_id+0x1c>)
    a1d2:	681b      	ldr	r3, [r3, #0]
    a1d4:	6003      	str	r3, [r0, #0]
	return_array[1] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_1);
    a1d6:	4b06      	ldr	r3, [pc, #24]	; (a1f0 <grid_sys_get_id+0x20>)
    a1d8:	681b      	ldr	r3, [r3, #0]
    a1da:	6043      	str	r3, [r0, #4]
	return_array[2] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_2);
    a1dc:	4b05      	ldr	r3, [pc, #20]	; (a1f4 <grid_sys_get_id+0x24>)
    a1de:	681b      	ldr	r3, [r3, #0]
    a1e0:	6083      	str	r3, [r0, #8]
	return_array[3] = *(uint32_t*)(GRID_SYS_UNIQUE_ID_ADDRESS_3);
    a1e2:	4b05      	ldr	r3, [pc, #20]	; (a1f8 <grid_sys_get_id+0x28>)
    a1e4:	681b      	ldr	r3, [r3, #0]
    a1e6:	60c3      	str	r3, [r0, #12]
	
	return 1;
	
}
    a1e8:	2001      	movs	r0, #1
    a1ea:	4770      	bx	lr
    a1ec:	008061fc 	.word	0x008061fc
    a1f0:	00806010 	.word	0x00806010
    a1f4:	00806014 	.word	0x00806014
    a1f8:	00806018 	.word	0x00806018

0000a1fc <grid_sys_get_hwcfg>:

uint32_t grid_sys_get_hwcfg(){
    a1fc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	
	// Read the register for the first time, then later just return the saved value

	if (grid_sys_hwfcg == -1){
    a200:	4e30      	ldr	r6, [pc, #192]	; (a2c4 <grid_sys_get_hwcfg+0xc8>)
    a202:	6833      	ldr	r3, [r6, #0]
    a204:	3301      	adds	r3, #1
    a206:	d158      	bne.n	a2ba <grid_sys_get_hwcfg+0xbe>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    a208:	4c2f      	ldr	r4, [pc, #188]	; (a2c8 <grid_sys_get_hwcfg+0xcc>)
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    a20a:	4b30      	ldr	r3, [pc, #192]	; (a2cc <grid_sys_get_hwcfg+0xd0>)
		gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
		gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
			
		// LOAD DATA
		gpio_set_pin_level(HWCFG_SHIFT, 0);
		delay_ms(1);
    a20c:	4f30      	ldr	r7, [pc, #192]	; (a2d0 <grid_sys_get_hwcfg+0xd4>)
	CRITICAL_SECTION_ENTER();
    a20e:	f8df 90cc 	ldr.w	r9, [pc, #204]	; a2dc <grid_sys_get_hwcfg+0xe0>
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    a212:	f44f 5500 	mov.w	r5, #8192	; 0x2000
    a216:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
    a21a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    a21e:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    a222:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    a226:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
    a22a:	f8c4 2088 	str.w	r2, [r4, #136]	; 0x88
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    a22e:	f04f 2240 	mov.w	r2, #1073758208	; 0x40004000
    a232:	f8c4 20a8 	str.w	r2, [r4, #168]	; 0xa8
    a236:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
    a23a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    a23e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
    a242:	4b24      	ldr	r3, [pc, #144]	; (a2d4 <grid_sys_get_hwcfg+0xd8>)
    a244:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    a248:	f1a3 2380 	sub.w	r3, r3, #2147516416	; 0x80008000
    a24c:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
    a250:	2001      	movs	r0, #1
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    a252:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    a256:	47b8      	blx	r7
    a258:	f04f 0a00 	mov.w	sl, #0
			
			
			
		uint8_t hwcfg_value = 0;
    a25c:	46d3      	mov	fp, sl
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    a25e:	46a8      	mov	r8, r5
			
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
				
			// SHIFT DATA
			gpio_set_pin_level(HWCFG_SHIFT, 1); //This outputs the first value to HWCFG_DATA
			delay_ms(1);
    a260:	2001      	movs	r0, #1
    a262:	f8c4 8098 	str.w	r8, [r4, #152]	; 0x98
    a266:	47b8      	blx	r7
    a268:	a801      	add	r0, sp, #4
    a26a:	47c8      	blx	r9
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    a26c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    a270:	f8d4 30a0 	ldr.w	r3, [r4, #160]	; 0xa0
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    a274:	f8d4 5090 	ldr.w	r5, [r4, #144]	; 0x90
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    a278:	405d      	eors	r5, r3
    a27a:	4015      	ands	r5, r2
    a27c:	405d      	eors	r5, r3
	CRITICAL_SECTION_LEAVE();
    a27e:	a801      	add	r0, sp, #4
    a280:	4b15      	ldr	r3, [pc, #84]	; (a2d8 <grid_sys_get_hwcfg+0xdc>)
    a282:	4798      	blx	r3
				
				
			if(gpio_get_pin_level(HWCFG_DATA)){
    a284:	042b      	lsls	r3, r5, #16
					
				hwcfg_value |= (1<<i);
    a286:	bf41      	itttt	mi
    a288:	2301      	movmi	r3, #1
    a28a:	fa03 f30a 	lslmi.w	r3, r3, sl
    a28e:	ea43 0b0b 	orrmi.w	fp, r3, fp
    a292:	fa5f fb8b 	uxtbmi.w	fp, fp
				}else{
					
					
			}
				
			if(i!=7){
    a296:	f1ba 0f07 	cmp.w	sl, #7
    a29a:	d007      	beq.n	a2ac <grid_sys_get_hwcfg+0xb0>
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
    a29c:	f44f 4580 	mov.w	r5, #16384	; 0x4000
    a2a0:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98
					
				// Clock rise
				gpio_set_pin_level(HWCFG_CLOCK, 1);
					
				delay_ms(1);
    a2a4:	2001      	movs	r0, #1
    a2a6:	47b8      	blx	r7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
    a2a8:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
		for(uint8_t i = 0; i<8; i++){ // now we need to shift in the remaining 7 values
    a2ac:	f10a 0a01 	add.w	sl, sl, #1
    a2b0:	f1ba 0f08 	cmp.w	sl, #8
    a2b4:	d1d4      	bne.n	a260 <grid_sys_get_hwcfg+0x64>
				gpio_set_pin_level(HWCFG_CLOCK, 0);
			}
							
		}
		
		grid_sys_hwfcg = hwcfg_value;
    a2b6:	f8c6 b000 	str.w	fp, [r6]
	}

	
	return grid_sys_hwfcg;

}
    a2ba:	6830      	ldr	r0, [r6, #0]
    a2bc:	b003      	add	sp, #12
    a2be:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a2c2:	bf00      	nop
    a2c4:	2000034c 	.word	0x2000034c
    a2c8:	41008000 	.word	0x41008000
    a2cc:	40002000 	.word	0x40002000
    a2d0:	0000e709 	.word	0x0000e709
    a2d4:	40028000 	.word	0x40028000
    a2d8:	00012493 	.word	0x00012493
    a2dc:	00012485 	.word	0x00012485

0000a2e0 <grid_msg_calculate_checksum_of_packet_string>:
	grid_sys_ping(&GRID_PORT_S);
	grid_sys_ping(&GRID_PORT_W);
	
}

uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    a2e0:	b510      	push	{r4, lr}
	
	uint8_t checksum = 0;
	for (uint32_t i=0; i<length-3; i++){
    a2e2:	2300      	movs	r3, #0
uint8_t grid_msg_calculate_checksum_of_packet_string(uint8_t* str, uint32_t length){
    a2e4:	4602      	mov	r2, r0
	for (uint32_t i=0; i<length-3; i++){
    a2e6:	3903      	subs	r1, #3
	uint8_t checksum = 0;
    a2e8:	4618      	mov	r0, r3
	for (uint32_t i=0; i<length-3; i++){
    a2ea:	4299      	cmp	r1, r3
    a2ec:	d800      	bhi.n	a2f0 <grid_msg_calculate_checksum_of_packet_string+0x10>
		checksum ^= str[i];
	}
	
	return checksum;
	
}
    a2ee:	bd10      	pop	{r4, pc}
		checksum ^= str[i];
    a2f0:	5cd4      	ldrb	r4, [r2, r3]
	for (uint32_t i=0; i<length-3; i++){
    a2f2:	3301      	adds	r3, #1
		checksum ^= str[i];
    a2f4:	4060      	eors	r0, r4
	for (uint32_t i=0; i<length-3; i++){
    a2f6:	e7f8      	b.n	a2ea <grid_msg_calculate_checksum_of_packet_string+0xa>

0000a2f8 <grid_msg_checksum_read>:
	return checksum;
	
}


uint8_t grid_msg_checksum_read(uint8_t* str, uint32_t length){
    a2f8:	b507      	push	{r0, r1, r2, lr}
	uint8_t error_flag;
	return grid_sys_read_hex_string_value(&str[length-3], 2, &error_flag);
    a2fa:	1ecb      	subs	r3, r1, #3
    a2fc:	f10d 0207 	add.w	r2, sp, #7
    a300:	2102      	movs	r1, #2
    a302:	4418      	add	r0, r3
    a304:	4b02      	ldr	r3, [pc, #8]	; (a310 <grid_msg_checksum_read+0x18>)
    a306:	4798      	blx	r3
}
    a308:	b2c0      	uxtb	r0, r0
    a30a:	b003      	add	sp, #12
    a30c:	f85d fb04 	ldr.w	pc, [sp], #4
    a310:	0000a171 	.word	0x0000a171

0000a314 <grid_msg_checksum_write>:
// 	sprintf(checksum_string, "%02x", checksum);
// 
// 	message[length-3] = checksum_string[0];
// 	message[length-2] = checksum_string[1];
	
	grid_sys_write_hex_string_value(&message[length-3], 2, checksum);
    a314:	1ecb      	subs	r3, r1, #3
    a316:	4418      	add	r0, r3
    a318:	2102      	movs	r1, #2
    a31a:	4b01      	ldr	r3, [pc, #4]	; (a320 <grid_msg_checksum_write+0xc>)
    a31c:	4718      	bx	r3
    a31e:	bf00      	nop
    a320:	0000a199 	.word	0x0000a199

0000a324 <grid_msg_get_parameter>:
}


// MESSAGE PARAMETER FUNCTIONS

uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    a324:	b410      	push	{r4}
    a326:	460c      	mov	r4, r1
		
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    a328:	4420      	add	r0, r4
uint32_t grid_msg_get_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint8_t* error){
    a32a:	4611      	mov	r1, r2
}
    a32c:	f85d 4b04 	ldr.w	r4, [sp], #4
	return grid_sys_read_hex_string_value(&message[offset], length, error);	
    a330:	461a      	mov	r2, r3
    a332:	4b01      	ldr	r3, [pc, #4]	; (a338 <grid_msg_get_parameter+0x14>)
    a334:	4718      	bx	r3
    a336:	bf00      	nop
    a338:	0000a171 	.word	0x0000a171

0000a33c <grid_msg_set_parameter>:

uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    a33c:	b510      	push	{r4, lr}
    a33e:	460c      	mov	r4, r1
	
	grid_sys_write_hex_string_value(&message[offset], length, value);
    a340:	4420      	add	r0, r4
uint32_t grid_msg_set_parameter(uint8_t* message, uint8_t offset, uint8_t length, uint32_t value, uint8_t* error){
    a342:	4611      	mov	r1, r2
	grid_sys_write_hex_string_value(&message[offset], length, value);
    a344:	461a      	mov	r2, r3
    a346:	4b01      	ldr	r3, [pc, #4]	; (a34c <grid_msg_set_parameter+0x10>)
    a348:	4798      	blx	r3
	
}
    a34a:	bd10      	pop	{r4, pc}
    a34c:	0000a199 	.word	0x0000a199

0000a350 <grid_msg_find_recent>:

uint8_t grid_msg_find_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
    //uint32_t fingerprint = updated_id*256*256*256 + updated_dx*256*256 + updated_dy*256 + updated_age;
    
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    a350:	f100 032c 	add.w	r3, r0, #44	; 0x2c
    a354:	30ac      	adds	r0, #172	; 0xac
		
		if (model->recent_messages[i%GRID_SYS_RECENT_MESSAGES_LENGTH] == fingerprint){
    a356:	f853 2b04 	ldr.w	r2, [r3], #4
    a35a:	428a      	cmp	r2, r1
    a35c:	d003      	beq.n	a366 <grid_msg_find_recent+0x16>
	for(GRID_SYS_RECENT_MESSAGES_INDEX_T i = 0; i<GRID_SYS_RECENT_MESSAGES_LENGTH; i++){
    a35e:	4283      	cmp	r3, r0
    a360:	d1f9      	bne.n	a356 <grid_msg_find_recent+0x6>
			
		}
		
	}
	
	return 0;
    a362:	2000      	movs	r0, #0
    a364:	4770      	bx	lr
			return 1;
    a366:	2001      	movs	r0, #1
}
    a368:	4770      	bx	lr

0000a36a <grid_msg_push_recent>:

void grid_msg_push_recent(struct grid_sys_model* model, uint32_t fingerprint){
	
	model->recent_messages_index+=1;
    a36a:	f890 30ac 	ldrb.w	r3, [r0, #172]	; 0xac
    a36e:	3301      	adds	r3, #1
	model->recent_messages_index%=GRID_SYS_RECENT_MESSAGES_LENGTH;
    a370:	f003 031f 	and.w	r3, r3, #31
    a374:	f880 30ac 	strb.w	r3, [r0, #172]	; 0xac
	
	model->recent_messages[model->recent_messages_index] = fingerprint;
    a378:	eb00 0083 	add.w	r0, r0, r3, lsl #2
    a37c:	62c1      	str	r1, [r0, #44]	; 0x2c
	
}
    a37e:	4770      	bx	lr

0000a380 <grid_ui_model_init>:
	}
	
}


void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    a380:	b538      	push	{r3, r4, r5, lr}
	
	mod->status = GRID_UI_STATUS_INITIALIZED;
    a382:	2301      	movs	r3, #1
    a384:	7003      	strb	r3, [r0, #0]
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    a386:	4605      	mov	r5, r0
	
	mod->bank_list_length = bank_list_length;	
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    a388:	4b09      	ldr	r3, [pc, #36]	; (a3b0 <grid_ui_model_init+0x30>)
	mod->bank_list_length = bank_list_length;	
    a38a:	7041      	strb	r1, [r0, #1]
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    a38c:	0108      	lsls	r0, r1, #4
void grid_ui_model_init(struct grid_ui_model* mod, uint8_t bank_list_length){
    a38e:	460c      	mov	r4, r1
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    a390:	4798      	blx	r3
	
	for(uint8_t i=0; i<bank_list_length; i++){
    a392:	2300      	movs	r3, #0
	mod->bank_list = malloc(mod->bank_list_length*sizeof(struct grid_ui_bank));
    a394:	6068      	str	r0, [r5, #4]
		
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    a396:	461a      	mov	r2, r3
	for(uint8_t i=0; i<bank_list_length; i++){
    a398:	b2d9      	uxtb	r1, r3
    a39a:	428c      	cmp	r4, r1
    a39c:	f100 0010 	add.w	r0, r0, #16
    a3a0:	d800      	bhi.n	a3a4 <grid_ui_model_init+0x24>
		mod->bank_list[i].element_list_length = 0;
		
	}
	
}
    a3a2:	bd38      	pop	{r3, r4, r5, pc}
		mod->bank_list[i].status = GRID_UI_STATUS_UNDEFINED;		
    a3a4:	f800 2c10 	strb.w	r2, [r0, #-16]
		mod->bank_list[i].element_list_length = 0;
    a3a8:	f800 2c07 	strb.w	r2, [r0, #-7]
	for(uint8_t i=0; i<bank_list_length; i++){
    a3ac:	3301      	adds	r3, #1
    a3ae:	e7f3      	b.n	a398 <grid_ui_model_init+0x18>
    a3b0:	00014d25 	.word	0x00014d25

0000a3b4 <grid_ui_bank_init>:

void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    a3b4:	b538      	push	{r3, r4, r5, lr}
	
	struct grid_ui_bank* bank = &parent->bank_list[index];
    a3b6:	6843      	ldr	r3, [r0, #4]
    a3b8:	eb03 1501 	add.w	r5, r3, r1, lsl #4
void grid_ui_bank_init(struct grid_ui_model* parent, uint8_t index, uint8_t element_list_length){
    a3bc:	4614      	mov	r4, r2
	struct grid_ui_bank* bank = &parent->bank_list[index];
    a3be:	010a      	lsls	r2, r1, #4
	bank->parent = parent;
    a3c0:	6068      	str	r0, [r5, #4]
	bank->index = index;
    a3c2:	7229      	strb	r1, [r5, #8]
	
	
	bank->status = GRID_UI_STATUS_INITIALIZED;
	
	bank->element_list_length = element_list_length;
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    a3c4:	2064      	movs	r0, #100	; 0x64
	bank->status = GRID_UI_STATUS_INITIALIZED;
    a3c6:	2101      	movs	r1, #1
    a3c8:	5499      	strb	r1, [r3, r2]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    a3ca:	4360      	muls	r0, r4
    a3cc:	4b08      	ldr	r3, [pc, #32]	; (a3f0 <grid_ui_bank_init+0x3c>)
	bank->element_list_length = element_list_length;
    a3ce:	726c      	strb	r4, [r5, #9]
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    a3d0:	4798      	blx	r3
	
	for(uint8_t i=0; i<element_list_length; i++){
    a3d2:	2300      	movs	r3, #0
	bank->element_list = malloc(bank->element_list_length*sizeof(struct grid_ui_element));
    a3d4:	60e8      	str	r0, [r5, #12]
		
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    a3d6:	461a      	mov	r2, r3
	for(uint8_t i=0; i<element_list_length; i++){
    a3d8:	b2d9      	uxtb	r1, r3
    a3da:	428c      	cmp	r4, r1
    a3dc:	f100 0064 	add.w	r0, r0, #100	; 0x64
    a3e0:	d800      	bhi.n	a3e4 <grid_ui_bank_init+0x30>
		bank->element_list[i].event_list_length = 0;
		
	}
	
}
    a3e2:	bd38      	pop	{r3, r4, r5, pc}
		bank->element_list[i].status = GRID_UI_STATUS_UNDEFINED;
    a3e4:	f800 2c64 	strb.w	r2, [r0, #-100]
		bank->element_list[i].event_list_length = 0;
    a3e8:	f800 2c08 	strb.w	r2, [r0, #-8]
	for(uint8_t i=0; i<element_list_length; i++){
    a3ec:	3301      	adds	r3, #1
    a3ee:	e7f3      	b.n	a3d8 <grid_ui_bank_init+0x24>
    a3f0:	00014d25 	.word	0x00014d25

0000a3f4 <grid_ui_nvm_store_all_configuration>:
	
}



void grid_ui_nvm_store_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    a3f4:	460b      	mov	r3, r1
	
    grid_nvm_ui_bulk_store_init(nvm, ui);
    a3f6:	4601      	mov	r1, r0
    a3f8:	4618      	mov	r0, r3
    a3fa:	4b01      	ldr	r3, [pc, #4]	; (a400 <grid_ui_nvm_store_all_configuration+0xc>)
    a3fc:	4718      	bx	r3
    a3fe:	bf00      	nop
    a400:	00009245 	.word	0x00009245

0000a404 <grid_ui_nvm_load_all_configuration>:

}

void grid_ui_nvm_load_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    a404:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_read_init(nvm, ui);
    a406:	4601      	mov	r1, r0
    a408:	4618      	mov	r0, r3
    a40a:	4b01      	ldr	r3, [pc, #4]	; (a410 <grid_ui_nvm_load_all_configuration+0xc>)
    a40c:	4718      	bx	r3
    a40e:	bf00      	nop
    a410:	00009131 	.word	0x00009131

0000a414 <grid_ui_nvm_clear_all_configuration>:

		
	
}

void grid_ui_nvm_clear_all_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm){
    a414:	460b      	mov	r3, r1
	
	grid_nvm_ui_bulk_clear_init(nvm, ui);
    a416:	4601      	mov	r1, r0
    a418:	4618      	mov	r0, r3
    a41a:	4b01      	ldr	r3, [pc, #4]	; (a420 <grid_ui_nvm_clear_all_configuration+0xc>)
    a41c:	4718      	bx	r3
    a41e:	bf00      	nop
    a420:	00009409 	.word	0x00009409

0000a424 <grid_ui_recall_event_configuration>:

}


uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    a424:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a428:	4698      	mov	r8, r3
	
	struct grid_ui_element* ele = NULL;
	struct grid_ui_event* eve = NULL;
	uint8_t event_index = 255;
	
	if (bank < ui->bank_list_length){
    a42a:	7843      	ldrb	r3, [r0, #1]
    a42c:	428b      	cmp	r3, r1
uint8_t grid_ui_recall_event_configuration(struct grid_ui_model* ui, uint8_t bank, uint8_t element, enum grid_ui_event_t event_type){
    a42e:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
    a432:	460e      	mov	r6, r1
    a434:	4615      	mov	r5, r2
	if (bank < ui->bank_list_length){
    a436:	f240 8082 	bls.w	a53e <grid_ui_recall_event_configuration+0x11a>
		
		if (element < ui->bank_list[bank].element_list_length){
    a43a:	6843      	ldr	r3, [r0, #4]
    a43c:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    a440:	7a5a      	ldrb	r2, [r3, #9]
    a442:	42aa      	cmp	r2, r5
    a444:	d97b      	bls.n	a53e <grid_ui_recall_event_configuration+0x11a>
			
			ele = &ui->bank_list[bank].element_list[element];
    a446:	68da      	ldr	r2, [r3, #12]
    a448:	2364      	movs	r3, #100	; 0x64
    a44a:	fb05 2303 	mla	r3, r5, r3, r2
			
			for(uint8_t i=0; i<ele->event_list_length; i++){
    a44e:	2200      	movs	r2, #0
    a450:	f893 c05c 	ldrb.w	ip, [r3, #92]	; 0x5c
	uint8_t event_index = 255;
    a454:	20ff      	movs	r0, #255	; 0xff
	struct grid_ui_event* eve = NULL;
    a456:	4614      	mov	r4, r2
				if (ele->event_list[i].type == event_type){
    a458:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    a45c:	b2d7      	uxtb	r7, r2
			for(uint8_t i=0; i<ele->event_list_length; i++){
    a45e:	45bc      	cmp	ip, r7
    a460:	d862      	bhi.n	a528 <grid_ui_recall_event_configuration+0x104>
		
		
	}
	
	
	if (event_index != 255){ // OK
    a462:	28ff      	cmp	r0, #255	; 0xff
    a464:	d06b      	beq.n	a53e <grid_ui_recall_event_configuration+0x11a>
		
		struct grid_msg message;

		grid_msg_init(&message);
    a466:	4b5b      	ldr	r3, [pc, #364]	; (a5d4 <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a468:	4d5b      	ldr	r5, [pc, #364]	; (a5d8 <grid_ui_recall_event_configuration+0x1b4>)
		uint32_t offset = 0;



		// BANK ENABLED
		offset = grid_msg_body_get_length(&message);
    a46a:	f8df a190 	ldr.w	sl, [pc, #400]	; a5fc <grid_ui_recall_event_configuration+0x1d8>

		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a46e:	f8df 9190 	ldr.w	r9, [pc, #400]	; a600 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    a472:	f8df 8190 	ldr.w	r8, [pc, #400]	; a604 <grid_ui_recall_event_configuration+0x1e0>

		grid_msg_body_append_text(&message, payload, payload_length);
    a476:	4f59      	ldr	r7, [pc, #356]	; (a5dc <grid_ui_recall_event_configuration+0x1b8>)

		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    a478:	4e59      	ldr	r6, [pc, #356]	; (a5e0 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    a47a:	a867      	add	r0, sp, #412	; 0x19c
    a47c:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a47e:	227f      	movs	r2, #127	; 0x7f
    a480:	4611      	mov	r1, r2
    a482:	2300      	movs	r3, #0
    a484:	a867      	add	r0, sp, #412	; 0x19c
    a486:	47a8      	blx	r5
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    a488:	2100      	movs	r1, #0
    a48a:	4b56      	ldr	r3, [pc, #344]	; (a5e4 <grid_ui_recall_event_configuration+0x1c0>)
    a48c:	9103      	str	r1, [sp, #12]
    a48e:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a492:	a804      	add	r0, sp, #16
    a494:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    a496:	a867      	add	r0, sp, #412	; 0x19c
    a498:	47d0      	blx	sl
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a49a:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    a49c:	4605      	mov	r5, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a49e:	4952      	ldr	r1, [pc, #328]	; (a5e8 <grid_ui_recall_event_configuration+0x1c4>)
    a4a0:	2202      	movs	r2, #2
    a4a2:	a803      	add	r0, sp, #12
    a4a4:	47c8      	blx	r9
		payload_length = strlen(payload);
    a4a6:	a803      	add	r0, sp, #12
    a4a8:	47c0      	blx	r8
		grid_msg_body_append_text(&message, payload, payload_length);
    a4aa:	a903      	add	r1, sp, #12
    a4ac:	b2c2      	uxtb	r2, r0
    a4ae:	a867      	add	r0, sp, #412	; 0x19c
    a4b0:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    a4b2:	230d      	movs	r3, #13
    a4b4:	9300      	str	r3, [sp, #0]
    a4b6:	2204      	movs	r2, #4
    a4b8:	2301      	movs	r3, #1
    a4ba:	4629      	mov	r1, r5
    a4bc:	a867      	add	r0, sp, #412	; 0x19c
    a4be:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    a4c0:	6863      	ldr	r3, [r4, #4]
    a4c2:	685b      	ldr	r3, [r3, #4]
    a4c4:	7a1b      	ldrb	r3, [r3, #8]
    a4c6:	9300      	str	r3, [sp, #0]
    a4c8:	2205      	movs	r2, #5
    a4ca:	2302      	movs	r3, #2
    a4cc:	4629      	mov	r1, r5
    a4ce:	a867      	add	r0, sp, #412	; 0x19c
    a4d0:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    a4d2:	6863      	ldr	r3, [r4, #4]
    a4d4:	7a1b      	ldrb	r3, [r3, #8]
    a4d6:	9300      	str	r3, [sp, #0]
    a4d8:	2207      	movs	r2, #7
    a4da:	2302      	movs	r3, #2
    a4dc:	4629      	mov	r1, r5
    a4de:	a867      	add	r0, sp, #412	; 0x19c
    a4e0:	47b0      	blx	r6
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    a4e2:	7aa3      	ldrb	r3, [r4, #10]
    a4e4:	9300      	str	r3, [sp, #0]
    a4e6:	2209      	movs	r2, #9
    a4e8:	2302      	movs	r3, #2
    a4ea:	4629      	mov	r1, r5
    a4ec:	a867      	add	r0, sp, #412	; 0x19c
    a4ee:	47b0      	blx	r6

		offset = grid_msg_body_get_length(&message);
    a4f0:	a867      	add	r0, sp, #412	; 0x19c
    a4f2:	47d0      	blx	sl
		grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    a4f4:	4b3d      	ldr	r3, [pc, #244]	; (a5ec <grid_ui_recall_event_configuration+0x1c8>)
    a4f6:	6b22      	ldr	r2, [r4, #48]	; 0x30
    a4f8:	f104 0134 	add.w	r1, r4, #52	; 0x34
    a4fc:	a867      	add	r0, sp, #412	; 0x19c
    a4fe:	4798      	blx	r3





		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    a500:	493b      	ldr	r1, [pc, #236]	; (a5f0 <grid_ui_recall_event_configuration+0x1cc>)
    a502:	2203      	movs	r2, #3
    a504:	a803      	add	r0, sp, #12
    a506:	47c8      	blx	r9
		payload_length = strlen(payload);
    a508:	a803      	add	r0, sp, #12
    a50a:	47c0      	blx	r8

		grid_msg_body_append_text(&message, payload, payload_length);
    a50c:	a903      	add	r1, sp, #12
    a50e:	b2c2      	uxtb	r2, r0
    a510:	a867      	add	r0, sp, #412	; 0x19c
    a512:	47b8      	blx	r7
		payload_length = strlen(payload);

		grid_msg_body_append_text(&message, payload, payload_length);


		grid_msg_packet_close(&message);
    a514:	4b37      	ldr	r3, [pc, #220]	; (a5f4 <grid_ui_recall_event_configuration+0x1d0>)
    a516:	a867      	add	r0, sp, #412	; 0x19c
    a518:	4798      	blx	r3
		grid_msg_packet_send_everywhere(&message);		
    a51a:	4b37      	ldr	r3, [pc, #220]	; (a5f8 <grid_ui_recall_event_configuration+0x1d4>)
    a51c:	a867      	add	r0, sp, #412	; 0x19c
    a51e:	4798      	blx	r3
		
		
	}

	
}
    a520:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    a524:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (ele->event_list[i].type == event_type){
    a528:	6e19      	ldr	r1, [r3, #96]	; 0x60
    a52a:	fb0e 1102 	mla	r1, lr, r2, r1
    a52e:	3201      	adds	r2, #1
    a530:	f891 900a 	ldrb.w	r9, [r1, #10]
    a534:	45c1      	cmp	r9, r8
    a536:	bf04      	itt	eq
    a538:	4638      	moveq	r0, r7
    a53a:	460c      	moveq	r4, r1
			for(uint8_t i=0; i<ele->event_list_length; i++){
    a53c:	e78e      	b.n	a45c <grid_ui_recall_event_configuration+0x38>
		grid_msg_init(&message);
    a53e:	a867      	add	r0, sp, #412	; 0x19c
    a540:	4b24      	ldr	r3, [pc, #144]	; (a5d4 <grid_ui_recall_event_configuration+0x1b0>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a542:	4c25      	ldr	r4, [pc, #148]	; (a5d8 <grid_ui_recall_event_configuration+0x1b4>)
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a544:	f8df b0b8 	ldr.w	fp, [pc, #184]	; a600 <grid_ui_recall_event_configuration+0x1dc>
		payload_length = strlen(payload);
    a548:	f8df a0b8 	ldr.w	sl, [pc, #184]	; a604 <grid_ui_recall_event_configuration+0x1e0>
		grid_msg_body_append_text(&message, payload, payload_length);
    a54c:	f8df 908c 	ldr.w	r9, [pc, #140]	; a5dc <grid_ui_recall_event_configuration+0x1b8>
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    a550:	4f23      	ldr	r7, [pc, #140]	; (a5e0 <grid_ui_recall_event_configuration+0x1bc>)
		grid_msg_init(&message);
    a552:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a554:	227f      	movs	r2, #127	; 0x7f
    a556:	4611      	mov	r1, r2
    a558:	a867      	add	r0, sp, #412	; 0x19c
    a55a:	2300      	movs	r3, #0
    a55c:	47a0      	blx	r4
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    a55e:	2100      	movs	r1, #0
    a560:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a564:	4b1f      	ldr	r3, [pc, #124]	; (a5e4 <grid_ui_recall_event_configuration+0x1c0>)
    a566:	9103      	str	r1, [sp, #12]
    a568:	a804      	add	r0, sp, #16
    a56a:	4798      	blx	r3
		offset = grid_msg_body_get_length(&message);
    a56c:	4b23      	ldr	r3, [pc, #140]	; (a5fc <grid_ui_recall_event_configuration+0x1d8>)
    a56e:	a867      	add	r0, sp, #412	; 0x19c
    a570:	4798      	blx	r3
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a572:	2380      	movs	r3, #128	; 0x80
		offset = grid_msg_body_get_length(&message);
    a574:	4604      	mov	r4, r0
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a576:	491c      	ldr	r1, [pc, #112]	; (a5e8 <grid_ui_recall_event_configuration+0x1c4>)
    a578:	2202      	movs	r2, #2
    a57a:	a803      	add	r0, sp, #12
    a57c:	47d8      	blx	fp
		payload_length = strlen(payload);
    a57e:	a803      	add	r0, sp, #12
    a580:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    a582:	a903      	add	r1, sp, #12
    a584:	b2c2      	uxtb	r2, r0
    a586:	a867      	add	r0, sp, #412	; 0x19c
    a588:	47c8      	blx	r9
		grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_NACKNOWLEDGE_code);
    a58a:	230b      	movs	r3, #11
    a58c:	9300      	str	r3, [sp, #0]
    a58e:	4621      	mov	r1, r4
    a590:	a867      	add	r0, sp, #412	; 0x19c
    a592:	2301      	movs	r3, #1
    a594:	2204      	movs	r2, #4
    a596:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, bank);
    a598:	4621      	mov	r1, r4
    a59a:	a867      	add	r0, sp, #412	; 0x19c
    a59c:	9600      	str	r6, [sp, #0]
    a59e:	2302      	movs	r3, #2
    a5a0:	2205      	movs	r2, #5
    a5a2:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, element);
    a5a4:	4621      	mov	r1, r4
    a5a6:	a867      	add	r0, sp, #412	; 0x19c
    a5a8:	9500      	str	r5, [sp, #0]
    a5aa:	2302      	movs	r3, #2
    a5ac:	2207      	movs	r2, #7
    a5ae:	47b8      	blx	r7
		grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, event_type);
    a5b0:	2302      	movs	r3, #2
    a5b2:	4621      	mov	r1, r4
    a5b4:	a867      	add	r0, sp, #412	; 0x19c
    a5b6:	f8cd 8000 	str.w	r8, [sp]
    a5ba:	2209      	movs	r2, #9
    a5bc:	47b8      	blx	r7
		sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    a5be:	490c      	ldr	r1, [pc, #48]	; (a5f0 <grid_ui_recall_event_configuration+0x1cc>)
    a5c0:	2203      	movs	r2, #3
    a5c2:	a803      	add	r0, sp, #12
    a5c4:	47d8      	blx	fp
		payload_length = strlen(payload);
    a5c6:	a803      	add	r0, sp, #12
    a5c8:	47d0      	blx	sl
		grid_msg_body_append_text(&message, payload, payload_length);
    a5ca:	a903      	add	r1, sp, #12
    a5cc:	b2c2      	uxtb	r2, r0
    a5ce:	a867      	add	r0, sp, #412	; 0x19c
    a5d0:	47c8      	blx	r9
    a5d2:	e79f      	b.n	a514 <grid_ui_recall_event_configuration+0xf0>
    a5d4:	00008ed5 	.word	0x00008ed5
    a5d8:	00008f09 	.word	0x00008f09
    a5dc:	00008e45 	.word	0x00008e45
    a5e0:	00008eb9 	.word	0x00008eb9
    a5e4:	00014d51 	.word	0x00014d51
    a5e8:	00016a53 	.word	0x00016a53
    a5ec:	00008e65 	.word	0x00008e65
    a5f0:	000166c3 	.word	0x000166c3
    a5f4:	00009001 	.word	0x00009001
    a5f8:	000090d5 	.word	0x000090d5
    a5fc:	00008e3f 	.word	0x00008e3f
    a600:	00015299 	.word	0x00015299
    a604:	00015317 	.word	0x00015317

0000a608 <grid_ui_nvm_store_event_configuration>:



uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a608:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a60c:	f5ad 7d4f 	sub.w	sp, sp, #828	; 0x33c
	

	struct grid_msg message;

	grid_msg_init(&message);
    a610:	4b52      	ldr	r3, [pc, #328]	; (a75c <grid_ui_nvm_store_event_configuration+0x154>)
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a612:	4e53      	ldr	r6, [pc, #332]	; (a760 <grid_ui_nvm_store_event_configuration+0x158>)
	uint32_t offset = 0;



	// BANK ENABLED
	offset = grid_msg_body_get_length(&message);
    a614:	f8df b178 	ldr.w	fp, [pc, #376]	; a790 <grid_ui_nvm_store_event_configuration+0x188>

	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a618:	f8df a178 	ldr.w	sl, [pc, #376]	; a794 <grid_ui_nvm_store_event_configuration+0x18c>
	payload_length = strlen(payload);

	grid_msg_body_append_text(&message, payload, payload_length);
    a61c:	f8df 9178 	ldr.w	r9, [pc, #376]	; a798 <grid_ui_nvm_store_event_configuration+0x190>

	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    a620:	f8df 8178 	ldr.w	r8, [pc, #376]	; a79c <grid_ui_nvm_store_event_configuration+0x194>
	grid_msg_init(&message);
    a624:	a867      	add	r0, sp, #412	; 0x19c
uint8_t grid_ui_nvm_store_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a626:	4614      	mov	r4, r2
    a628:	460d      	mov	r5, r1
	grid_msg_init(&message);
    a62a:	4798      	blx	r3
	grid_msg_init_header(&message, GRID_SYS_LOCAL_POSITION, GRID_SYS_LOCAL_POSITION, GRID_SYS_DEFAULT_ROTATION);
    a62c:	22ff      	movs	r2, #255	; 0xff
    a62e:	4611      	mov	r1, r2
    a630:	2300      	movs	r3, #0
    a632:	a867      	add	r0, sp, #412	; 0x19c
    a634:	47b0      	blx	r6
	uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};
    a636:	2600      	movs	r6, #0
    a638:	4b4a      	ldr	r3, [pc, #296]	; (a764 <grid_ui_nvm_store_event_configuration+0x15c>)
    a63a:	9603      	str	r6, [sp, #12]
    a63c:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    a640:	4631      	mov	r1, r6
    a642:	a804      	add	r0, sp, #16
    a644:	4798      	blx	r3
	offset = grid_msg_body_get_length(&message);
    a646:	a867      	add	r0, sp, #412	; 0x19c
    a648:	47d8      	blx	fp
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a64a:	4947      	ldr	r1, [pc, #284]	; (a768 <grid_ui_nvm_store_event_configuration+0x160>)
	offset = grid_msg_body_get_length(&message);
    a64c:	4607      	mov	r7, r0
	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_start);
    a64e:	2202      	movs	r2, #2
    a650:	2380      	movs	r3, #128	; 0x80
    a652:	a803      	add	r0, sp, #12
    a654:	47d0      	blx	sl
	payload_length = strlen(payload);
    a656:	4b45      	ldr	r3, [pc, #276]	; (a76c <grid_ui_nvm_store_event_configuration+0x164>)
    a658:	a803      	add	r0, sp, #12
    a65a:	4798      	blx	r3
	grid_msg_body_append_text(&message, payload, payload_length);
    a65c:	a903      	add	r1, sp, #12
    a65e:	b2c2      	uxtb	r2, r0
    a660:	a867      	add	r0, sp, #412	; 0x19c
    a662:	47c8      	blx	r9
	grid_msg_text_set_parameter(&message, offset, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_EXECUTE_code);
    a664:	230e      	movs	r3, #14
    a666:	4639      	mov	r1, r7
    a668:	9300      	str	r3, [sp, #0]
    a66a:	2204      	movs	r2, #4
    a66c:	2301      	movs	r3, #1
    a66e:	a867      	add	r0, sp, #412	; 0x19c
    a670:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_offset, GRID_CLASS_CONFIGURATION_BANKNUMBER_length, eve->parent->parent->index);
    a672:	6863      	ldr	r3, [r4, #4]
    a674:	685b      	ldr	r3, [r3, #4]
    a676:	7a1b      	ldrb	r3, [r3, #8]
    a678:	9300      	str	r3, [sp, #0]
    a67a:	4639      	mov	r1, r7
    a67c:	2302      	movs	r3, #2
    a67e:	2205      	movs	r2, #5
    a680:	a867      	add	r0, sp, #412	; 0x19c
    a682:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_offset, GRID_CLASS_CONFIGURATION_ELEMENTNUMBER_length, eve->parent->index);
    a684:	6863      	ldr	r3, [r4, #4]
    a686:	7a1b      	ldrb	r3, [r3, #8]
    a688:	9300      	str	r3, [sp, #0]
    a68a:	4639      	mov	r1, r7
    a68c:	2302      	movs	r3, #2
    a68e:	2207      	movs	r2, #7
    a690:	a867      	add	r0, sp, #412	; 0x19c
    a692:	47c0      	blx	r8
	grid_msg_text_set_parameter(&message, offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_offset, GRID_CLASS_CONFIGURATION_EVENTTYPE_length, eve->type);
    a694:	7aa3      	ldrb	r3, [r4, #10]
    a696:	9300      	str	r3, [sp, #0]
    a698:	4639      	mov	r1, r7
    a69a:	2302      	movs	r3, #2
    a69c:	2209      	movs	r2, #9
    a69e:	a867      	add	r0, sp, #412	; 0x19c
    a6a0:	47c0      	blx	r8

	offset = grid_msg_body_get_length(&message);
    a6a2:	a867      	add	r0, sp, #412	; 0x19c
    a6a4:	47d8      	blx	fp
	grid_msg_body_append_text_escaped(&message, eve->action_string, eve->action_string_length);
    a6a6:	4b32      	ldr	r3, [pc, #200]	; (a770 <grid_ui_nvm_store_event_configuration+0x168>)
    a6a8:	6b22      	ldr	r2, [r4, #48]	; 0x30
    a6aa:	f104 0134 	add.w	r1, r4, #52	; 0x34
    a6ae:	a867      	add	r0, sp, #412	; 0x19c
    a6b0:	4798      	blx	r3





	sprintf(payload, GRID_CLASS_CONFIGURATION_frame_end);
    a6b2:	4930      	ldr	r1, [pc, #192]	; (a774 <grid_ui_nvm_store_event_configuration+0x16c>)
    a6b4:	2203      	movs	r2, #3
    a6b6:	a803      	add	r0, sp, #12
    a6b8:	47d0      	blx	sl
	payload_length = strlen(payload);
    a6ba:	4b2c      	ldr	r3, [pc, #176]	; (a76c <grid_ui_nvm_store_event_configuration+0x164>)
    a6bc:	a803      	add	r0, sp, #12
    a6be:	4798      	blx	r3

	grid_msg_body_append_text(&message, payload, payload_length);
    a6c0:	a903      	add	r1, sp, #12
    a6c2:	b2c2      	uxtb	r2, r0
    a6c4:	a867      	add	r0, sp, #412	; 0x19c
    a6c6:	47c8      	blx	r9


	grid_msg_packet_close(&message);
    a6c8:	4b2b      	ldr	r3, [pc, #172]	; (a778 <grid_ui_nvm_store_event_configuration+0x170>)
    a6ca:	a867      	add	r0, sp, #412	; 0x19c
    a6cc:	4798      	blx	r3

	grid_nvm_clear_write_buffer(nvm);
    a6ce:	4b2b      	ldr	r3, [pc, #172]	; (a77c <grid_ui_nvm_store_event_configuration+0x174>)
    a6d0:	4628      	mov	r0, r5
    a6d2:	4798      	blx	r3

	uint32_t message_length = grid_msg_packet_get_length(&message);
    a6d4:	4b2a      	ldr	r3, [pc, #168]	; (a780 <grid_ui_nvm_store_event_configuration+0x178>)
    a6d6:	a867      	add	r0, sp, #412	; 0x19c
    a6d8:	4798      	blx	r3

	if (message_length){
    a6da:	4607      	mov	r7, r0
    a6dc:	b970      	cbnz	r0, a6fc <grid_ui_nvm_store_event_configuration+0xf4>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
		}

	}

	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    a6de:	4621      	mov	r1, r4
    a6e0:	4b28      	ldr	r3, [pc, #160]	; (a784 <grid_ui_nvm_store_event_configuration+0x17c>)
    a6e2:	4628      	mov	r0, r5
    a6e4:	4798      	blx	r3
	nvm->write_target_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;
    a6e6:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    a6ea:	0241      	lsls	r1, r0, #9
    a6ec:	f8c5 1420 	str.w	r1, [r5, #1056]	; 0x420
	int status = 0;
	
	
	uint8_t debugtext[200] = {0};

	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    a6f0:	f894 60b7 	ldrb.w	r6, [r4, #183]	; 0xb7
    a6f4:	2e01      	cmp	r6, #1
    a6f6:	d010      	beq.n	a71a <grid_ui_nvm_store_event_configuration+0x112>
	int status = 0;
    a6f8:	2000      	movs	r0, #0
    a6fa:	e019      	b.n	a730 <grid_ui_nvm_store_event_configuration+0x128>
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    a6fc:	f8df 90a0 	ldr.w	r9, [pc, #160]	; a7a0 <grid_ui_nvm_store_event_configuration+0x198>
		nvm->write_buffer_length = message_length;
    a700:	f8c5 0418 	str.w	r0, [r5, #1048]	; 0x418
		for(uint32_t i = 0; i<message_length; i++){
    a704:	f505 7806 	add.w	r8, r5, #536	; 0x218
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    a708:	4631      	mov	r1, r6
    a70a:	a867      	add	r0, sp, #412	; 0x19c
    a70c:	47c8      	blx	r9
		for(uint32_t i = 0; i<message_length; i++){
    a70e:	3601      	adds	r6, #1
    a710:	42b7      	cmp	r7, r6
			nvm->write_buffer[i] = grid_msg_packet_send_char(&message, i);
    a712:	f808 0b01 	strb.w	r0, [r8], #1
		for(uint32_t i = 0; i<message_length; i++){
    a716:	d1f7      	bne.n	a708 <grid_ui_nvm_store_event_configuration+0x100>
    a718:	e7e1      	b.n	a6de <grid_ui_nvm_store_event_configuration+0xd6>
	if (eve->cfg_default_flag == 1 && eve->cfg_flashempty_flag == 0){
    a71a:	f894 30b8 	ldrb.w	r3, [r4, #184]	; 0xb8
    a71e:	2b00      	cmp	r3, #0
    a720:	d1ea      	bne.n	a6f8 <grid_ui_nvm_store_event_configuration+0xf0>
		
		//sprintf(debugtext, "Cfg: Default B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);
		flash_erase(nvm->flash, nvm->write_target_address, 1);
    a722:	6828      	ldr	r0, [r5, #0]
    a724:	4b18      	ldr	r3, [pc, #96]	; (a788 <grid_ui_nvm_store_event_configuration+0x180>)
    a726:	4632      	mov	r2, r6
    a728:	4798      	blx	r3
		eve->cfg_flashempty_flag = 1;
    a72a:	f884 60b8 	strb.w	r6, [r4, #184]	; 0xb8
		status = 1;
    a72e:	4630      	mov	r0, r6
	}
	
	
	if (eve->cfg_default_flag == 0 && eve->cfg_changed_flag == 1){
    a730:	f8b4 60b6 	ldrh.w	r6, [r4, #182]	; 0xb6
    a734:	2e01      	cmp	r6, #1
    a736:	d109      	bne.n	a74c <grid_ui_nvm_store_event_configuration+0x144>
		
		//sprintf(debugtext, "Cfg: Store B:%d E:%d Ev:%d => Page: %d Status: %d", eve->parent->parent->index, eve->parent->index, eve->index, event_page_offset, status);		
		flash_write(nvm->flash, nvm->write_target_address, nvm->write_buffer, GRID_NVM_PAGE_SIZE);
    a738:	f8d5 1420 	ldr.w	r1, [r5, #1056]	; 0x420
    a73c:	6828      	ldr	r0, [r5, #0]
    a73e:	f505 7206 	add.w	r2, r5, #536	; 0x218
    a742:	f44f 7300 	mov.w	r3, #512	; 0x200
    a746:	4d11      	ldr	r5, [pc, #68]	; (a78c <grid_ui_nvm_store_event_configuration+0x184>)
    a748:	47a8      	blx	r5
		status = 1;
    a74a:	4630      	mov	r0, r6
	}


	//grid_debug_print_text(debugtext);

	eve->cfg_changed_flag = 0;
    a74c:	2300      	movs	r3, #0
    a74e:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	
	return status;
	
}
    a752:	f50d 7d4f 	add.w	sp, sp, #828	; 0x33c
    a756:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a75a:	bf00      	nop
    a75c:	00008ed5 	.word	0x00008ed5
    a760:	00008f09 	.word	0x00008f09
    a764:	00014d51 	.word	0x00014d51
    a768:	00016a53 	.word	0x00016a53
    a76c:	00015317 	.word	0x00015317
    a770:	00008e65 	.word	0x00008e65
    a774:	000166c3 	.word	0x000166c3
    a778:	00009001 	.word	0x00009001
    a77c:	000095e1 	.word	0x000095e1
    a780:	00008e31 	.word	0x00008e31
    a784:	0000964d 	.word	0x0000964d
    a788:	0000f7dd 	.word	0x0000f7dd
    a78c:	0000f75d 	.word	0x0000f75d
    a790:	00008e3f 	.word	0x00008e3f
    a794:	00015299 	.word	0x00015299
    a798:	00008e45 	.word	0x00008e45
    a79c:	00008eb9 	.word	0x00008eb9
    a7a0:	00008fcb 	.word	0x00008fcb

0000a7a4 <grid_ui_nvm_load_event_configuration>:



uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a7a4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	
		
	grid_nvm_clear_read_buffer(nvm);
    a7a6:	4b19      	ldr	r3, [pc, #100]	; (a80c <grid_ui_nvm_load_event_configuration+0x68>)
uint8_t grid_ui_nvm_load_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a7a8:	9201      	str	r2, [sp, #4]
    a7aa:	460c      	mov	r4, r1
	grid_nvm_clear_read_buffer(nvm);
    a7ac:	4608      	mov	r0, r1
    a7ae:	4798      	blx	r3
	
	uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);	
    a7b0:	9901      	ldr	r1, [sp, #4]
    a7b2:	4b17      	ldr	r3, [pc, #92]	; (a810 <grid_ui_nvm_load_event_configuration+0x6c>)
    a7b4:	4620      	mov	r0, r4
    a7b6:	4798      	blx	r3
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    a7b8:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    a7bc:	0241      	lsls	r1, r0, #9
	

	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    a7be:	f104 0609 	add.w	r6, r4, #9
	nvm->read_source_address = GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset;	
    a7c2:	f8c4 1214 	str.w	r1, [r4, #532]	; 0x214
	int status = flash_read(nvm->flash, nvm->read_source_address, nvm->read_buffer, GRID_NVM_PAGE_SIZE);	
    a7c6:	6820      	ldr	r0, [r4, #0]
    a7c8:	4c12      	ldr	r4, [pc, #72]	; (a814 <grid_ui_nvm_load_event_configuration+0x70>)
    a7ca:	f44f 7300 	mov.w	r3, #512	; 0x200
    a7ce:	4632      	mov	r2, r6
    a7d0:	47a0      	blx	r4
    a7d2:	2300      	movs	r3, #0
			}
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
				copydone = 1;
			}
			else{ // NORMAL CHARACTER, can be copied
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a7d4:	4c10      	ldr	r4, [pc, #64]	; (a818 <grid_ui_nvm_load_event_configuration+0x74>)
	uint8_t cfgfound = 0;
    a7d6:	4618      	mov	r0, r3
	uint8_t copydone = 0;
    a7d8:	4619      	mov	r1, r3
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a7da:	f241 37b4 	movw	r7, #5044	; 0x13b4
		if (copydone == 0){
    a7de:	1c5a      	adds	r2, r3, #1
    a7e0:	b971      	cbnz	r1, a800 <grid_ui_nvm_load_event_configuration+0x5c>
			if (nvm->read_buffer[i] == '\n'){ // END OF PACKET, copy newline character
    a7e2:	5cf5      	ldrb	r5, [r6, r3]
    a7e4:	2d0a      	cmp	r5, #10
    a7e6:	d106      	bne.n	a7f6 <grid_ui_nvm_load_event_configuration+0x52>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a7e8:	4423      	add	r3, r4
				cfgfound=2;
    a7ea:	2002      	movs	r0, #2
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a7ec:	55dd      	strb	r5, [r3, r7]
				GRID_PORT_U.rx_double_buffer_status = i+1;
    a7ee:	6222      	str	r2, [r4, #32]
				GRID_PORT_U.rx_double_buffer_read_start_index = 0;
    a7f0:	62a1      	str	r1, [r4, #40]	; 0x28
				copydone = 1;
    a7f2:	2101      	movs	r1, #1
    a7f4:	e004      	b.n	a800 <grid_ui_nvm_load_event_configuration+0x5c>
			else if (nvm->read_buffer[i] == 255){ // UNPROGRAMMED MEMORY, lets get out of here
    a7f6:	2dff      	cmp	r5, #255	; 0xff
    a7f8:	d0fb      	beq.n	a7f2 <grid_ui_nvm_load_event_configuration+0x4e>
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a7fa:	4423      	add	r3, r4
				
				cfgfound=1;
    a7fc:	2001      	movs	r0, #1
				GRID_PORT_U.rx_double_buffer[i] = nvm->read_buffer[i];
    a7fe:	55dd      	strb	r5, [r3, r7]
	for (uint16_t i=0; i<GRID_NVM_PAGE_SIZE; i++){
    a800:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    a804:	4613      	mov	r3, r2
    a806:	d1ea      	bne.n	a7de <grid_ui_nvm_load_event_configuration+0x3a>
	}
	
	return cfgfound;
	
	
}
    a808:	b003      	add	sp, #12
    a80a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    a80c:	000095c1 	.word	0x000095c1
    a810:	0000964d 	.word	0x0000964d
    a814:	0000f6f1 	.word	0x0000f6f1
    a818:	2000c0b0 	.word	0x2000c0b0

0000a81c <grid_ui_nvm_clear_event_configuration>:
uint8_t grid_ui_nvm_clear_event_configuration(struct grid_ui_model* ui, struct grid_nvm_model* nvm, struct grid_ui_event* eve){
    a81c:	b510      	push	{r4, lr}
    a81e:	460c      	mov	r4, r1
		
		uint32_t event_page_offset = grid_nvm_calculate_event_page_offset(nvm, eve);
    a820:	4b06      	ldr	r3, [pc, #24]	; (a83c <grid_ui_nvm_clear_event_configuration+0x20>)
    a822:	4611      	mov	r1, r2
    a824:	4620      	mov	r0, r4
    a826:	4798      	blx	r3
		
		

		flash_erase(nvm->flash, GRID_NVM_LOCAL_BASE_ADDRESS + GRID_NVM_PAGE_OFFSET*event_page_offset, 1);
    a828:	f500 6080 	add.w	r0, r0, #1024	; 0x400
    a82c:	0241      	lsls	r1, r0, #9
    a82e:	4b04      	ldr	r3, [pc, #16]	; (a840 <grid_ui_nvm_clear_event_configuration+0x24>)
    a830:	6820      	ldr	r0, [r4, #0]
    a832:	2201      	movs	r2, #1
    a834:	4798      	blx	r3

		
		
		return 1;
		
}
    a836:	2001      	movs	r0, #1
    a838:	bd10      	pop	{r4, pc}
    a83a:	bf00      	nop
    a83c:	0000964d 	.word	0x0000964d
    a840:	0000f7dd 	.word	0x0000f7dd

0000a844 <grid_ui_event_register_actionstring>:
	ele->event_list[event_index].cfg_default_flag = 1;	
	
}


void grid_ui_event_register_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* action_string, uint32_t action_string_length){
    a844:	b5f0      	push	{r4, r5, r6, r7, lr}
		
	uint8_t event_index = 255;
	
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a846:	f890 c05c 	ldrb.w	ip, [r0, #92]	; 0x5c
    a84a:	2500      	movs	r5, #0
	uint8_t event_index = 255;
    a84c:	24ff      	movs	r4, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a84e:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
    a852:	b2ef      	uxtb	r7, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a854:	45bc      	cmp	ip, r7
    a856:	d819      	bhi.n	a88c <grid_ui_event_register_actionstring+0x48>
			event_index = i;
		}
	}
	
	if (event_index == 255){
    a858:	2cff      	cmp	r4, #255	; 0xff
    a85a:	d016      	beq.n	a88a <grid_ui_event_register_actionstring+0x46>
	
	
	
	// Clear Action String
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
		ele->event_list[event_index].action_string[i] = 0;
    a85c:	21bc      	movs	r1, #188	; 0xbc
    a85e:	fb14 f401 	smulbb	r4, r4, r1
    a862:	6e01      	ldr	r1, [r0, #96]	; 0x60
    a864:	4421      	add	r1, r4
    a866:	f101 0434 	add.w	r4, r1, #52	; 0x34
    a86a:	f101 06b6 	add.w	r6, r1, #182	; 0xb6
    a86e:	4620      	mov	r0, r4
    a870:	2500      	movs	r5, #0
    a872:	f800 5b01 	strb.w	r5, [r0], #1
	for(uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    a876:	4286      	cmp	r6, r0
    a878:	d1fb      	bne.n	a872 <grid_ui_event_register_actionstring+0x2e>
	}
	ele->event_list[event_index].action_string_length = 0;
    a87a:	630d      	str	r5, [r1, #48]	; 0x30
	

	uint8_t escaped_characters = 0;
	
	for (uint32_t i=0; i<action_string_length; i++){
    a87c:	2000      	movs	r0, #0
    a87e:	4298      	cmp	r0, r3
    a880:	d10d      	bne.n	a89e <grid_ui_event_register_actionstring+0x5a>
	}
	

	ele->event_list[event_index].action_string_length = action_string_length;
	
	ele->event_list[event_index].cfg_changed_flag = 1;
    a882:	2301      	movs	r3, #1
	ele->event_list[event_index].action_string_length = action_string_length;
    a884:	6308      	str	r0, [r1, #48]	; 0x30
	ele->event_list[event_index].cfg_changed_flag = 1;
    a886:	f881 30b6 	strb.w	r3, [r1, #182]	; 0xb6
	
	
}
    a88a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a88c:	6e06      	ldr	r6, [r0, #96]	; 0x60
    a88e:	fb0e 6605 	mla	r6, lr, r5, r6
    a892:	3501      	adds	r5, #1
    a894:	7ab6      	ldrb	r6, [r6, #10]
    a896:	428e      	cmp	r6, r1
    a898:	bf08      	it	eq
    a89a:	463c      	moveq	r4, r7
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a89c:	e7d9      	b.n	a852 <grid_ui_event_register_actionstring+0xe>
		if (ele->event_list[event_index].action_string[i] > 127){
    a89e:	5616      	ldrsb	r6, [r2, r0]
		ele->event_list[event_index].action_string[i] = action_string[i];
    a8a0:	5c15      	ldrb	r5, [r2, r0]
		if (ele->event_list[event_index].action_string[i] > 127){
    a8a2:	2e00      	cmp	r6, #0
			ele->event_list[event_index].action_string[i] -= 128;
    a8a4:	bfb8      	it	lt
    a8a6:	3d80      	sublt	r5, #128	; 0x80
    a8a8:	7025      	strb	r5, [r4, #0]
	for (uint32_t i=0; i<action_string_length; i++){
    a8aa:	3001      	adds	r0, #1
    a8ac:	3401      	adds	r4, #1
    a8ae:	e7e6      	b.n	a87e <grid_ui_event_register_actionstring+0x3a>

0000a8b0 <grid_ui_event_generate_actionstring>:
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a8b0:	b5f0      	push	{r4, r5, r6, r7, lr}
    a8b2:	4605      	mov	r5, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a8b4:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
void grid_ui_event_generate_actionstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    a8b8:	b0a3      	sub	sp, #140	; 0x8c
    a8ba:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a8bc:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    a8be:	26ff      	movs	r6, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    a8c0:	27bc      	movs	r7, #188	; 0xbc
    a8c2:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a8c4:	4288      	cmp	r0, r1
    a8c6:	d82a      	bhi.n	a91e <grid_ui_event_generate_actionstring+0x6e>
	if (event_index == 255){
    a8c8:	2eff      	cmp	r6, #255	; 0xff
    a8ca:	d026      	beq.n	a91a <grid_ui_event_generate_actionstring+0x6a>
	uint8_t action_string[GRID_UI_ACTION_STRING_maxlength] = {0};
    a8cc:	4b35      	ldr	r3, [pc, #212]	; (a9a4 <grid_ui_event_generate_actionstring+0xf4>)
    a8ce:	2100      	movs	r1, #0
    a8d0:	227e      	movs	r2, #126	; 0x7e
    a8d2:	a802      	add	r0, sp, #8
    a8d4:	9101      	str	r1, [sp, #4]
    a8d6:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    a8d8:	7a6b      	ldrb	r3, [r5, #9]
    a8da:	2b02      	cmp	r3, #2
    a8dc:	d12c      	bne.n	a938 <grid_ui_event_generate_actionstring+0x88>
		switch(event_type){
    a8de:	2c04      	cmp	r4, #4
    a8e0:	d026      	beq.n	a930 <grid_ui_event_generate_actionstring+0x80>
    a8e2:	2c05      	cmp	r4, #5
    a8e4:	d026      	beq.n	a934 <grid_ui_event_generate_actionstring+0x84>
    a8e6:	b91c      	cbnz	r4, a8f0 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_INIT:	sprintf(action_string, GRID_ACTIONSTRING_INIT_BUT);		break;
    a8e8:	492f      	ldr	r1, [pc, #188]	; (a9a8 <grid_ui_event_generate_actionstring+0xf8>)
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a8ea:	4b30      	ldr	r3, [pc, #192]	; (a9ac <grid_ui_event_generate_actionstring+0xfc>)
    a8ec:	a801      	add	r0, sp, #4
    a8ee:	4798      	blx	r3
	if (strlen(action_string)){
    a8f0:	f89d 3004 	ldrb.w	r3, [sp, #4]
    a8f4:	b143      	cbz	r3, a908 <grid_ui_event_generate_actionstring+0x58>
		grid_ui_event_register_actionstring(ele, event_type, action_string, strlen(action_string));
    a8f6:	4b2e      	ldr	r3, [pc, #184]	; (a9b0 <grid_ui_event_generate_actionstring+0x100>)
    a8f8:	a801      	add	r0, sp, #4
    a8fa:	4798      	blx	r3
    a8fc:	4621      	mov	r1, r4
    a8fe:	4603      	mov	r3, r0
    a900:	4c2c      	ldr	r4, [pc, #176]	; (a9b4 <grid_ui_event_generate_actionstring+0x104>)
    a902:	aa01      	add	r2, sp, #4
    a904:	4628      	mov	r0, r5
    a906:	47a0      	blx	r4
	ele->event_list[event_index].cfg_changed_flag = 0;
    a908:	23bc      	movs	r3, #188	; 0xbc
    a90a:	fb16 f603 	smulbb	r6, r6, r3
    a90e:	6e2b      	ldr	r3, [r5, #96]	; 0x60
    a910:	441e      	add	r6, r3
    a912:	f44f 7380 	mov.w	r3, #256	; 0x100
    a916:	f8a6 30b6 	strh.w	r3, [r6, #182]	; 0xb6
}
    a91a:	b023      	add	sp, #140	; 0x8c
    a91c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    a91e:	6e2a      	ldr	r2, [r5, #96]	; 0x60
    a920:	fb07 2203 	mla	r2, r7, r3, r2
    a924:	3301      	adds	r3, #1
    a926:	7a92      	ldrb	r2, [r2, #10]
    a928:	42a2      	cmp	r2, r4
    a92a:	bf08      	it	eq
    a92c:	460e      	moveq	r6, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    a92e:	e7c8      	b.n	a8c2 <grid_ui_event_generate_actionstring+0x12>
			case GRID_UI_EVENT_DP:		sprintf(action_string, GRID_ACTIONSTRING_DP_BUT);		break;
    a930:	4921      	ldr	r1, [pc, #132]	; (a9b8 <grid_ui_event_generate_actionstring+0x108>)
    a932:	e7da      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:		sprintf(action_string, GRID_ACTIONSTRING_DR_BUT);		break;
    a934:	4921      	ldr	r1, [pc, #132]	; (a9bc <grid_ui_event_generate_actionstring+0x10c>)
    a936:	e7d8      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    a938:	2b01      	cmp	r3, #1
    a93a:	d105      	bne.n	a948 <grid_ui_event_generate_actionstring+0x98>
		switch(event_type){
    a93c:	2c00      	cmp	r4, #0
    a93e:	d0d3      	beq.n	a8e8 <grid_ui_event_generate_actionstring+0x38>
    a940:	2c01      	cmp	r4, #1
    a942:	d1d5      	bne.n	a8f0 <grid_ui_event_generate_actionstring+0x40>
			case GRID_UI_EVENT_AVC7:	sprintf(action_string, GRID_ACTIONSTRING_AVC7_POT);		break;
    a944:	491e      	ldr	r1, [pc, #120]	; (a9c0 <grid_ui_event_generate_actionstring+0x110>)
    a946:	e7d0      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    a948:	2b03      	cmp	r3, #3
    a94a:	d1d1      	bne.n	a8f0 <grid_ui_event_generate_actionstring+0x40>
		switch(event_type){
    a94c:	2c0d      	cmp	r4, #13
    a94e:	d8cf      	bhi.n	a8f0 <grid_ui_event_generate_actionstring+0x40>
    a950:	a301      	add	r3, pc, #4	; (adr r3, a958 <grid_ui_event_generate_actionstring+0xa8>)
    a952:	f853 f024 	ldr.w	pc, [r3, r4, lsl #2]
    a956:	bf00      	nop
    a958:	0000a991 	.word	0x0000a991
    a95c:	0000a995 	.word	0x0000a995
    a960:	0000a8f1 	.word	0x0000a8f1
    a964:	0000a8f1 	.word	0x0000a8f1
    a968:	0000a99d 	.word	0x0000a99d
    a96c:	0000a9a1 	.word	0x0000a9a1
    a970:	0000a8f1 	.word	0x0000a8f1
    a974:	0000a8f1 	.word	0x0000a8f1
    a978:	0000a8f1 	.word	0x0000a8f1
    a97c:	0000a8f1 	.word	0x0000a8f1
    a980:	0000a8f1 	.word	0x0000a8f1
    a984:	0000a8f1 	.word	0x0000a8f1
    a988:	0000a8f1 	.word	0x0000a8f1
    a98c:	0000a999 	.word	0x0000a999
			case GRID_UI_EVENT_INIT:        sprintf(action_string, GRID_ACTIONSTRING_INIT_ENC);	break;
    a990:	490c      	ldr	r1, [pc, #48]	; (a9c4 <grid_ui_event_generate_actionstring+0x114>)
    a992:	e7aa      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_AVC7:        sprintf(action_string, GRID_ACTIONSTRING_AVC7_ENC);	break;
    a994:	490c      	ldr	r1, [pc, #48]	; (a9c8 <grid_ui_event_generate_actionstring+0x118>)
    a996:	e7a8      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_ENCPUSHROT:	sprintf(action_string, GRID_ACTIONSTRING_PUSHROT_ENC);	break;
    a998:	490c      	ldr	r1, [pc, #48]	; (a9cc <grid_ui_event_generate_actionstring+0x11c>)
    a99a:	e7a6      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DP:          sprintf(action_string, GRID_ACTIONSTRING_DP_ENC);	break;
    a99c:	490c      	ldr	r1, [pc, #48]	; (a9d0 <grid_ui_event_generate_actionstring+0x120>)
    a99e:	e7a4      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
			case GRID_UI_EVENT_DR:          sprintf(action_string, GRID_ACTIONSTRING_DR_ENC);	break;
    a9a0:	490c      	ldr	r1, [pc, #48]	; (a9d4 <grid_ui_event_generate_actionstring+0x124>)
    a9a2:	e7a2      	b.n	a8ea <grid_ui_event_generate_actionstring+0x3a>
    a9a4:	00014d51 	.word	0x00014d51
    a9a8:	00016a61 	.word	0x00016a61
    a9ac:	00015307 	.word	0x00015307
    a9b0:	00015317 	.word	0x00015317
    a9b4:	0000a845 	.word	0x0000a845
    a9b8:	00016a86 	.word	0x00016a86
    a9bc:	00016ab5 	.word	0x00016ab5
    a9c0:	00016ae4 	.word	0x00016ae4
    a9c4:	00016b13 	.word	0x00016b13
    a9c8:	00016b5c 	.word	0x00016b5c
    a9cc:	00016bc6 	.word	0x00016bc6
    a9d0:	00016bf5 	.word	0x00016bf5
    a9d4:	00016c24 	.word	0x00016c24

0000a9d8 <grid_ui_reinit>:
void grid_ui_reinit(struct grid_ui_model* ui){
    a9d8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a9dc:	4606      	mov	r6, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    a9de:	2700      	movs	r7, #0
    a9e0:	7873      	ldrb	r3, [r6, #1]
    a9e2:	b2fc      	uxtb	r4, r7
    a9e4:	42a3      	cmp	r3, r4
    a9e6:	d805      	bhi.n	a9f4 <grid_ui_reinit+0x1c>
	grid_sys_state.bank_active_changed = 1;
    a9e8:	4b18      	ldr	r3, [pc, #96]	; (aa4c <grid_ui_reinit+0x74>)
    a9ea:	2201      	movs	r2, #1
    a9ec:	745a      	strb	r2, [r3, #17]
}
    a9ee:	b003      	add	sp, #12
    a9f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a9f4:	6873      	ldr	r3, [r6, #4]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    a9f6:	f04f 0800 	mov.w	r8, #0
		struct grid_ui_bank* bank = &ui->bank_list[i];
    a9fa:	eb03 1404 	add.w	r4, r3, r4, lsl #4
			struct grid_ui_element* ele = &bank->element_list[j];
    a9fe:	f04f 0b64 	mov.w	fp, #100	; 0x64
		for (uint8_t j=0; j<bank->element_list_length; j++){
    aa02:	7a63      	ldrb	r3, [r4, #9]
    aa04:	fa5f f088 	uxtb.w	r0, r8
    aa08:	4283      	cmp	r3, r0
    aa0a:	d801      	bhi.n	aa10 <grid_ui_reinit+0x38>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    aa0c:	3701      	adds	r7, #1
    aa0e:	e7e7      	b.n	a9e0 <grid_ui_reinit+0x8>
			struct grid_ui_element* ele = &bank->element_list[j];
    aa10:	68e3      	ldr	r3, [r4, #12]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    aa12:	f04f 0900 	mov.w	r9, #0
			struct grid_ui_element* ele = &bank->element_list[j];
    aa16:	fb0b 3000 	mla	r0, fp, r0, r3
				struct grid_ui_event* eve = &ele->event_list[k];
    aa1a:	f04f 0abc 	mov.w	sl, #188	; 0xbc
			for (uint8_t k=0; k<ele->event_list_length; k++){
    aa1e:	f890 105c 	ldrb.w	r1, [r0, #92]	; 0x5c
    aa22:	fa5f f589 	uxtb.w	r5, r9
    aa26:	42a9      	cmp	r1, r5
    aa28:	d802      	bhi.n	aa30 <grid_ui_reinit+0x58>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    aa2a:	f108 0801 	add.w	r8, r8, #1
    aa2e:	e7e8      	b.n	aa02 <grid_ui_reinit+0x2a>
				struct grid_ui_event* eve = &ele->event_list[k];
    aa30:	6e01      	ldr	r1, [r0, #96]	; 0x60
				grid_ui_event_generate_actionstring(ele, eve->type);
    aa32:	4b07      	ldr	r3, [pc, #28]	; (aa50 <grid_ui_reinit+0x78>)
    aa34:	9001      	str	r0, [sp, #4]
				struct grid_ui_event* eve = &ele->event_list[k];
    aa36:	fb0a 1505 	mla	r5, sl, r5, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    aa3a:	f109 0901 	add.w	r9, r9, #1
    aa3e:	7aa9      	ldrb	r1, [r5, #10]
    aa40:	4798      	blx	r3
}


void grid_ui_event_reset(struct grid_ui_event* eve){
	
	eve->trigger = GRID_UI_STATUS_READY;
    aa42:	2204      	movs	r2, #4
    aa44:	9801      	ldr	r0, [sp, #4]
    aa46:	726a      	strb	r2, [r5, #9]
			for (uint8_t k=0; k<ele->event_list_length; k++){
    aa48:	e7e9      	b.n	aa1e <grid_ui_reinit+0x46>
    aa4a:	bf00      	nop
    aa4c:	2000f008 	.word	0x2000f008
    aa50:	0000a8b1 	.word	0x0000a8b1

0000aa54 <grid_ui_event_find>:
uint8_t grid_ui_event_find(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    aa54:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    aa56:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
    aa5a:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    aa5c:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    aa5e:	27bc      	movs	r7, #188	; 0xbc
    aa60:	b2dd      	uxtb	r5, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    aa62:	42ae      	cmp	r6, r5
    aa64:	d801      	bhi.n	aa6a <grid_ui_event_find+0x16>
}
    aa66:	4610      	mov	r0, r2
    aa68:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    aa6a:	6e04      	ldr	r4, [r0, #96]	; 0x60
    aa6c:	fb07 4403 	mla	r4, r7, r3, r4
    aa70:	3301      	adds	r3, #1
    aa72:	7aa4      	ldrb	r4, [r4, #10]
    aa74:	428c      	cmp	r4, r1
    aa76:	bf08      	it	eq
    aa78:	462a      	moveq	r2, r5
	for(uint8_t i=0; i<ele->event_list_length; i++){
    aa7a:	e7f1      	b.n	aa60 <grid_ui_event_find+0xc>

0000aa7c <grid_ui_event_trigger>:
	if (event_index == 255){
    aa7c:	29ff      	cmp	r1, #255	; 0xff
    aa7e:	d005      	beq.n	aa8c <grid_ui_event_trigger+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED;
    aa80:	6e02      	ldr	r2, [r0, #96]	; 0x60
    aa82:	23bc      	movs	r3, #188	; 0xbc
    aa84:	fb01 2103 	mla	r1, r1, r3, r2
    aa88:	2305      	movs	r3, #5
    aa8a:	724b      	strb	r3, [r1, #9]
}
    aa8c:	4770      	bx	lr

0000aa8e <grid_ui_event_trigger_local>:
	if (event_index == 255){
    aa8e:	29ff      	cmp	r1, #255	; 0xff
    aa90:	d005      	beq.n	aa9e <grid_ui_event_trigger_local+0x10>
	eve->trigger = GRID_UI_STATUS_TRIGGERED_LOCAL;
    aa92:	6e02      	ldr	r2, [r0, #96]	; 0x60
    aa94:	23bc      	movs	r3, #188	; 0xbc
    aa96:	fb01 2103 	mla	r1, r1, r3, r2
    aa9a:	2306      	movs	r3, #6
    aa9c:	724b      	strb	r3, [r1, #9]
}
    aa9e:	4770      	bx	lr

0000aaa0 <grid_ui_smart_trigger>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    aaa0:	6840      	ldr	r0, [r0, #4]
    aaa2:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    aaa6:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    aaa8:	68c4      	ldr	r4, [r0, #12]
    aaaa:	2064      	movs	r0, #100	; 0x64
    aaac:	fb02 4400 	mla	r4, r2, r0, r4
    aab0:	4619      	mov	r1, r3
    aab2:	4620      	mov	r0, r4
    aab4:	4b05      	ldr	r3, [pc, #20]	; (aacc <grid_ui_smart_trigger+0x2c>)
    aab6:	4798      	blx	r3
	if (event_index == 255){
    aab8:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    aaba:	4601      	mov	r1, r0
	if (event_index == 255){
    aabc:	d004      	beq.n	aac8 <grid_ui_smart_trigger+0x28>
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    aabe:	4620      	mov	r0, r4
    aac0:	4b03      	ldr	r3, [pc, #12]	; (aad0 <grid_ui_smart_trigger+0x30>)
}
    aac2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_ui_event_trigger(&mod->bank_list[bank].element_list[element], event_index);
    aac6:	4718      	bx	r3
}
    aac8:	bd10      	pop	{r4, pc}
    aaca:	bf00      	nop
    aacc:	0000aa55 	.word	0x0000aa55
    aad0:	0000aa7d 	.word	0x0000aa7d

0000aad4 <grid_ui_event_register_eventstring>:
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    aad4:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aad8:	4604      	mov	r4, r0
	grid_debug_print_text("Register Action");
    aada:	4e28      	ldr	r6, [pc, #160]	; (ab7c <grid_ui_event_register_eventstring+0xa8>)
    aadc:	4828      	ldr	r0, [pc, #160]	; (ab80 <grid_ui_event_register_eventstring+0xac>)
void grid_ui_event_register_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type, uint8_t* event_string, uint32_t event_string_length){
    aade:	4699      	mov	r9, r3
    aae0:	4688      	mov	r8, r1
    aae2:	4692      	mov	sl, r2
	grid_debug_print_text("Register Action");
    aae4:	47b0      	blx	r6
	for(uint8_t i=0; i<ele->event_list_length; i++){
    aae6:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
    aaea:	46b3      	mov	fp, r6
    aaec:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    aaee:	25ff      	movs	r5, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    aaf0:	26bc      	movs	r6, #188	; 0xbc
    aaf2:	b2d9      	uxtb	r1, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    aaf4:	4288      	cmp	r0, r1
    aaf6:	d807      	bhi.n	ab08 <grid_ui_event_register_eventstring+0x34>
	if (event_index == 255){
    aaf8:	2dff      	cmp	r5, #255	; 0xff
    aafa:	d10e      	bne.n	ab1a <grid_ui_event_register_eventstring+0x46>
		grid_debug_print_text("Event Not Found");
    aafc:	4821      	ldr	r0, [pc, #132]	; (ab84 <grid_ui_event_register_eventstring+0xb0>)
    aafe:	465b      	mov	r3, fp
}
    ab00:	b001      	add	sp, #4
    ab02:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		grid_debug_print_text("Event Not Found");
    ab06:	4718      	bx	r3
		if (ele->event_list[i].type == event_type){
    ab08:	6e22      	ldr	r2, [r4, #96]	; 0x60
    ab0a:	fb06 2203 	mla	r2, r6, r3, r2
    ab0e:	3301      	adds	r3, #1
    ab10:	7a92      	ldrb	r2, [r2, #10]
    ab12:	4542      	cmp	r2, r8
    ab14:	bf08      	it	eq
    ab16:	460d      	moveq	r5, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    ab18:	e7eb      	b.n	aaf2 <grid_ui_event_register_eventstring+0x1e>
		ele->event_list[event_index].event_string[i] = 0;
    ab1a:	23bc      	movs	r3, #188	; 0xbc
    ab1c:	fb15 f503 	smulbb	r5, r5, r3
    ab20:	6e23      	ldr	r3, [r4, #96]	; 0x60
    ab22:	442b      	add	r3, r5
    ab24:	f103 0210 	add.w	r2, r3, #16
    ab28:	f103 002e 	add.w	r0, r3, #46	; 0x2e
    ab2c:	2100      	movs	r1, #0
    ab2e:	f802 1b01 	strb.w	r1, [r2], #1
	for(uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    ab32:	4282      	cmp	r2, r0
    ab34:	d1fb      	bne.n	ab2e <grid_ui_event_register_eventstring+0x5a>
			grid_debug_print_text(" Escaped Char Found ");
    ab36:	4814      	ldr	r0, [pc, #80]	; (ab88 <grid_ui_event_register_eventstring+0xb4>)
	ele->event_list[event_index].event_string_length = 0;
    ab38:	60d9      	str	r1, [r3, #12]
	for (uint32_t i=0; i<event_string_length; i++){
    ab3a:	2600      	movs	r6, #0
    ab3c:	6e27      	ldr	r7, [r4, #96]	; 0x60
    ab3e:	454e      	cmp	r6, r9
    ab40:	442f      	add	r7, r5
    ab42:	d10b      	bne.n	ab5c <grid_ui_event_register_eventstring+0x88>
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    ab44:	6860      	ldr	r0, [r4, #4]
	ele->event_list[event_index].event_string_length = event_string_length;
    ab46:	60fe      	str	r6, [r7, #12]
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    ab48:	7a22      	ldrb	r2, [r4, #8]
    ab4a:	4c10      	ldr	r4, [pc, #64]	; (ab8c <grid_ui_event_register_eventstring+0xb8>)
    ab4c:	7a01      	ldrb	r1, [r0, #8]
    ab4e:	6840      	ldr	r0, [r0, #4]
    ab50:	4643      	mov	r3, r8
    ab52:	46a4      	mov	ip, r4
}
    ab54:	b001      	add	sp, #4
    ab56:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_ui_smart_trigger(ele->parent->parent, ele->parent->index, ele->index, event_type);
    ab5a:	4760      	bx	ip
		ele->event_list[event_index].event_string[i] = event_string[i];
    ab5c:	f81a 3006 	ldrb.w	r3, [sl, r6]
    ab60:	4437      	add	r7, r6
    ab62:	743b      	strb	r3, [r7, #16]
		if (ele->event_list[event_index].event_string[i] > 127){
    ab64:	061b      	lsls	r3, r3, #24
    ab66:	d507      	bpl.n	ab78 <grid_ui_event_register_eventstring+0xa4>
			grid_debug_print_text(" Escaped Char Found ");
    ab68:	47d8      	blx	fp
			ele->event_list[event_index].event_string[i] -= 128;
    ab6a:	6e23      	ldr	r3, [r4, #96]	; 0x60
    ab6c:	4806      	ldr	r0, [pc, #24]	; (ab88 <grid_ui_event_register_eventstring+0xb4>)
    ab6e:	442b      	add	r3, r5
    ab70:	4433      	add	r3, r6
    ab72:	7c1a      	ldrb	r2, [r3, #16]
    ab74:	3a80      	subs	r2, #128	; 0x80
    ab76:	741a      	strb	r2, [r3, #16]
	for (uint32_t i=0; i<event_string_length; i++){
    ab78:	3601      	adds	r6, #1
    ab7a:	e7df      	b.n	ab3c <grid_ui_event_register_eventstring+0x68>
    ab7c:	00009b89 	.word	0x00009b89
    ab80:	00016c53 	.word	0x00016c53
    ab84:	00016c63 	.word	0x00016c63
    ab88:	00016c73 	.word	0x00016c73
    ab8c:	0000aaa1 	.word	0x0000aaa1

0000ab90 <grid_ui_event_generate_eventstring>:
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    ab90:	b5f0      	push	{r4, r5, r6, r7, lr}
	for(uint8_t i=0; i<ele->event_list_length; i++){
    ab92:	f890 605c 	ldrb.w	r6, [r0, #92]	; 0x5c
void grid_ui_event_generate_eventstring(struct grid_ui_element* ele, enum grid_ui_event_t event_type){
    ab96:	b089      	sub	sp, #36	; 0x24
    ab98:	4605      	mov	r5, r0
    ab9a:	460c      	mov	r4, r1
	for(uint8_t i=0; i<ele->event_list_length; i++){
    ab9c:	2300      	movs	r3, #0
	uint8_t event_index = 255;
    ab9e:	22ff      	movs	r2, #255	; 0xff
		if (ele->event_list[i].type == event_type){
    aba0:	27bc      	movs	r7, #188	; 0xbc
    aba2:	b2d8      	uxtb	r0, r3
	for(uint8_t i=0; i<ele->event_list_length; i++){
    aba4:	4286      	cmp	r6, r0
    aba6:	d81a      	bhi.n	abde <grid_ui_event_generate_eventstring+0x4e>
	if (event_index == 255){
    aba8:	2aff      	cmp	r2, #255	; 0xff
    abaa:	d016      	beq.n	abda <grid_ui_event_generate_eventstring+0x4a>
	uint8_t event_string[GRID_UI_EVENT_STRING_maxlength] = {0};	
    abac:	4b27      	ldr	r3, [pc, #156]	; (ac4c <grid_ui_event_generate_eventstring+0xbc>)
    abae:	2100      	movs	r1, #0
    abb0:	221a      	movs	r2, #26
    abb2:	a801      	add	r0, sp, #4
    abb4:	9100      	str	r1, [sp, #0]
    abb6:	4798      	blx	r3
	if (ele->type == GRID_UI_ELEMENT_BUTTON){
    abb8:	7a6b      	ldrb	r3, [r5, #9]
    abba:	2b02      	cmp	r3, #2
    abbc:	d132      	bne.n	ac24 <grid_ui_event_generate_eventstring+0x94>
		if (event_type == GRID_UI_EVENT_INIT){
    abbe:	b9bc      	cbnz	r4, abf0 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_INIT_BUT); // !!
    abc0:	4923      	ldr	r1, [pc, #140]	; (ac50 <grid_ui_event_generate_eventstring+0xc0>)
    abc2:	4b24      	ldr	r3, [pc, #144]	; (ac54 <grid_ui_event_generate_eventstring+0xc4>)
    abc4:	4668      	mov	r0, sp
    abc6:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    abc8:	4b23      	ldr	r3, [pc, #140]	; (ac58 <grid_ui_event_generate_eventstring+0xc8>)
    abca:	4668      	mov	r0, sp
    abcc:	4798      	blx	r3
    abce:	466a      	mov	r2, sp
    abd0:	4603      	mov	r3, r0
    abd2:	2100      	movs	r1, #0
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    abd4:	4c21      	ldr	r4, [pc, #132]	; (ac5c <grid_ui_event_generate_eventstring+0xcc>)
    abd6:	4628      	mov	r0, r5
    abd8:	47a0      	blx	r4
}
    abda:	b009      	add	sp, #36	; 0x24
    abdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (ele->event_list[i].type == event_type){
    abde:	6e29      	ldr	r1, [r5, #96]	; 0x60
    abe0:	fb07 1103 	mla	r1, r7, r3, r1
    abe4:	3301      	adds	r3, #1
    abe6:	7a89      	ldrb	r1, [r1, #10]
    abe8:	42a1      	cmp	r1, r4
    abea:	bf08      	it	eq
    abec:	4602      	moveq	r2, r0
	for(uint8_t i=0; i<ele->event_list_length; i++){
    abee:	e7d8      	b.n	aba2 <grid_ui_event_generate_eventstring+0x12>
		else if (event_type == GRID_UI_EVENT_DP){
    abf0:	2c04      	cmp	r4, #4
    abf2:	d10a      	bne.n	ac0a <grid_ui_event_generate_eventstring+0x7a>
			sprintf(event_string, GRID_EVENTSTRING_DP_BUT); // !!
    abf4:	491a      	ldr	r1, [pc, #104]	; (ac60 <grid_ui_event_generate_eventstring+0xd0>)
    abf6:	4b17      	ldr	r3, [pc, #92]	; (ac54 <grid_ui_event_generate_eventstring+0xc4>)
    abf8:	4668      	mov	r0, sp
    abfa:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    abfc:	4b16      	ldr	r3, [pc, #88]	; (ac58 <grid_ui_event_generate_eventstring+0xc8>)
    abfe:	4668      	mov	r0, sp
    ac00:	4798      	blx	r3
    ac02:	466a      	mov	r2, sp
    ac04:	4603      	mov	r3, r0
    ac06:	2104      	movs	r1, #4
    ac08:	e7e4      	b.n	abd4 <grid_ui_event_generate_eventstring+0x44>
		else if (event_type == GRID_UI_EVENT_DR){
    ac0a:	2c05      	cmp	r4, #5
    ac0c:	d1e5      	bne.n	abda <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_DR_BUT); // !!
    ac0e:	4915      	ldr	r1, [pc, #84]	; (ac64 <grid_ui_event_generate_eventstring+0xd4>)
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    ac10:	4b10      	ldr	r3, [pc, #64]	; (ac54 <grid_ui_event_generate_eventstring+0xc4>)
    ac12:	4668      	mov	r0, sp
    ac14:	4798      	blx	r3
			grid_ui_event_register_eventstring(ele, event_type, event_string, strlen(event_string));
    ac16:	4b10      	ldr	r3, [pc, #64]	; (ac58 <grid_ui_event_generate_eventstring+0xc8>)
    ac18:	4668      	mov	r0, sp
    ac1a:	4798      	blx	r3
    ac1c:	466a      	mov	r2, sp
    ac1e:	4603      	mov	r3, r0
    ac20:	4621      	mov	r1, r4
    ac22:	e7d7      	b.n	abd4 <grid_ui_event_generate_eventstring+0x44>
	else if (ele->type == GRID_UI_ELEMENT_POTENTIOMETER){
    ac24:	2b01      	cmp	r3, #1
    ac26:	d105      	bne.n	ac34 <grid_ui_event_generate_eventstring+0xa4>
		if (event_type == GRID_UI_EVENT_INIT){
    ac28:	2c00      	cmp	r4, #0
    ac2a:	d0c9      	beq.n	abc0 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    ac2c:	2c01      	cmp	r4, #1
    ac2e:	d1d4      	bne.n	abda <grid_ui_event_generate_eventstring+0x4a>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_POT); // !!
    ac30:	490d      	ldr	r1, [pc, #52]	; (ac68 <grid_ui_event_generate_eventstring+0xd8>)
    ac32:	e7ed      	b.n	ac10 <grid_ui_event_generate_eventstring+0x80>
	else if (ele->type == GRID_UI_ELEMENT_ENCODER){
    ac34:	2b03      	cmp	r3, #3
    ac36:	d1d0      	bne.n	abda <grid_ui_event_generate_eventstring+0x4a>
		if (event_type == GRID_UI_EVENT_INIT){
    ac38:	2c00      	cmp	r4, #0
    ac3a:	d0c1      	beq.n	abc0 <grid_ui_event_generate_eventstring+0x30>
		else if (event_type == GRID_UI_EVENT_AVC7){
    ac3c:	2c01      	cmp	r4, #1
    ac3e:	d101      	bne.n	ac44 <grid_ui_event_generate_eventstring+0xb4>
			sprintf(event_string, GRID_EVENTSTRING_AVC7_ENC); // !!
    ac40:	490a      	ldr	r1, [pc, #40]	; (ac6c <grid_ui_event_generate_eventstring+0xdc>)
    ac42:	e7e5      	b.n	ac10 <grid_ui_event_generate_eventstring+0x80>
		else if (event_type == GRID_UI_EVENT_ENCPUSHROT){
    ac44:	2c0d      	cmp	r4, #13
    ac46:	d1d3      	bne.n	abf0 <grid_ui_event_generate_eventstring+0x60>
			sprintf(event_string, GRID_EVENTSTRING_PUSHROT_ENC); // !!
    ac48:	4909      	ldr	r1, [pc, #36]	; (ac70 <grid_ui_event_generate_eventstring+0xe0>)
    ac4a:	e7e1      	b.n	ac10 <grid_ui_event_generate_eventstring+0x80>
    ac4c:	00014d51 	.word	0x00014d51
    ac50:	00016c88 	.word	0x00016c88
    ac54:	00015307 	.word	0x00015307
    ac58:	00015317 	.word	0x00015317
    ac5c:	0000aad5 	.word	0x0000aad5
    ac60:	00016ca1 	.word	0x00016ca1
    ac64:	00016cbf 	.word	0x00016cbf
    ac68:	00016cdd 	.word	0x00016cdd
    ac6c:	00016cfb 	.word	0x00016cfb
    ac70:	00016d19 	.word	0x00016d19

0000ac74 <grid_ui_event_init>:
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    ac74:	b570      	push	{r4, r5, r6, lr}
	struct grid_ui_event* eve = &parent->event_list[index];
    ac76:	6e06      	ldr	r6, [r0, #96]	; 0x60
void grid_ui_event_init(struct grid_ui_element* parent, uint8_t index, enum grid_ui_event_t event_type){
    ac78:	4615      	mov	r5, r2
	struct grid_ui_event* eve = &parent->event_list[index];
    ac7a:	22bc      	movs	r2, #188	; 0xbc
    ac7c:	fb11 f202 	smulbb	r2, r1, r2
    ac80:	18b4      	adds	r4, r6, r2
	eve->cfg_changed_flag = 0;
    ac82:	2300      	movs	r3, #0
	eve->index = index;
    ac84:	7221      	strb	r1, [r4, #8]
	eve->status = GRID_UI_STATUS_READY;
    ac86:	2104      	movs	r1, #4
	eve->parent = parent;
    ac88:	6060      	str	r0, [r4, #4]
	eve->cfg_changed_flag = 0;
    ac8a:	f884 30b6 	strb.w	r3, [r4, #182]	; 0xb6
	eve->type   = event_type;	
    ac8e:	72a5      	strb	r5, [r4, #10]
	eve->status = GRID_UI_STATUS_READY;
    ac90:	54b1      	strb	r1, [r6, r2]
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    ac92:	f104 0210 	add.w	r2, r4, #16
    ac96:	f104 012e 	add.w	r1, r4, #46	; 0x2e
		eve->event_string[i] = 0;
    ac9a:	f802 3b01 	strb.w	r3, [r2], #1
	for (uint32_t i=0; i<GRID_UI_EVENT_STRING_maxlength; i++){
    ac9e:	428a      	cmp	r2, r1
    aca0:	d1fb      	bne.n	ac9a <grid_ui_event_init+0x26>
	eve->event_string_length = 0;
    aca2:	60e3      	str	r3, [r4, #12]
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    aca4:	f104 01b6 	add.w	r1, r4, #182	; 0xb6
    aca8:	f104 0334 	add.w	r3, r4, #52	; 0x34
		eve->action_string[i] = 0;
    acac:	2200      	movs	r2, #0
    acae:	f803 2b01 	strb.w	r2, [r3], #1
	for (uint32_t i=0; i<GRID_UI_ACTION_STRING_maxlength; i++){
    acb2:	4299      	cmp	r1, r3
    acb4:	d1fb      	bne.n	acae <grid_ui_event_init+0x3a>
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    acb6:	4b08      	ldr	r3, [pc, #32]	; (acd8 <grid_ui_event_init+0x64>)
	eve->action_string_length = 0;
    acb8:	6322      	str	r2, [r4, #48]	; 0x30
	grid_ui_event_generate_eventstring(eve->parent, event_type);
    acba:	4629      	mov	r1, r5
    acbc:	4798      	blx	r3
	grid_ui_event_generate_actionstring(eve->parent, event_type);	
    acbe:	4b07      	ldr	r3, [pc, #28]	; (acdc <grid_ui_event_init+0x68>)
    acc0:	6860      	ldr	r0, [r4, #4]
    acc2:	4629      	mov	r1, r5
    acc4:	4798      	blx	r3
	eve->cfg_changed_flag = 0;
    acc6:	f44f 7380 	mov.w	r3, #256	; 0x100
    acca:	f8a4 30b6 	strh.w	r3, [r4, #182]	; 0xb6
	eve->cfg_flashempty_flag = 1;
    acce:	2301      	movs	r3, #1
    acd0:	f884 30b8 	strb.w	r3, [r4, #184]	; 0xb8
}
    acd4:	bd70      	pop	{r4, r5, r6, pc}
    acd6:	bf00      	nop
    acd8:	0000ab91 	.word	0x0000ab91
    acdc:	0000a8b1 	.word	0x0000a8b1

0000ace0 <grid_ui_element_init>:
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    ace0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct grid_ui_element* ele = &parent->element_list[index];
    ace4:	2364      	movs	r3, #100	; 0x64
void grid_ui_element_init(struct grid_ui_bank* parent, uint8_t index, enum grid_ui_element_t element_type){
    ace6:	4615      	mov	r5, r2
	struct grid_ui_element* ele = &parent->element_list[index];
    ace8:	68c2      	ldr	r2, [r0, #12]
    acea:	fb11 f303 	smulbb	r3, r1, r3
    acee:	18d4      	adds	r4, r2, r3
	ele->index = index;
    acf0:	7221      	strb	r1, [r4, #8]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    acf2:	2101      	movs	r1, #1
	ele->parent = parent;
    acf4:	6060      	str	r0, [r4, #4]
	ele->status = GRID_UI_STATUS_INITIALIZED;
    acf6:	54d1      	strb	r1, [r2, r3]
	ele->type = element_type;
    acf8:	7265      	strb	r5, [r4, #9]
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    acfa:	f104 030c 	add.w	r3, r4, #12
    acfe:	f104 025c 	add.w	r2, r4, #92	; 0x5c
		ele->template_parameter_list[i] = 0;
    ad02:	2100      	movs	r1, #0
    ad04:	f843 1b04 	str.w	r1, [r3], #4
	for(uint8_t i=0; i<GRID_TEMPLATE_UI_PARAMETER_LIST_LENGTH; i++){
    ad08:	429a      	cmp	r2, r3
    ad0a:	d1fb      	bne.n	ad04 <grid_ui_element_init+0x24>
	if (element_type == GRID_UI_ELEMENT_SYSTEM){
    ad0c:	bb1d      	cbnz	r5, ad56 <grid_ui_element_init+0x76>
		ele->event_list_length = 6;
    ad0e:	2306      	movs	r3, #6
    ad10:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad14:	f44f 608d 	mov.w	r0, #1128	; 0x468
    ad18:	4b34      	ldr	r3, [pc, #208]	; (adec <grid_ui_element_init+0x10c>)
    ad1a:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad1c:	462a      	mov	r2, r5
    ad1e:	4629      	mov	r1, r5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad20:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad22:	4d33      	ldr	r5, [pc, #204]	; (adf0 <grid_ui_element_init+0x110>)
    ad24:	4620      	mov	r0, r4
    ad26:	47a8      	blx	r5
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_HEARTBEAT); // Heartbeat
    ad28:	220c      	movs	r2, #12
    ad2a:	2101      	movs	r1, #1
    ad2c:	4620      	mov	r0, r4
    ad2e:	47a8      	blx	r5
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_MAPMODE_PRESS); // Mapmode press
    ad30:	2207      	movs	r2, #7
    ad32:	2102      	movs	r1, #2
    ad34:	4620      	mov	r0, r4
    ad36:	47a8      	blx	r5
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_MAPMODE_RELEASE); // Mapmode release
    ad38:	2208      	movs	r2, #8
    ad3a:	2103      	movs	r1, #3
    ad3c:	4620      	mov	r0, r4
    ad3e:	47a8      	blx	r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_CFG_RESPONSE); //
    ad40:	2209      	movs	r2, #9
    ad42:	2104      	movs	r1, #4
    ad44:	4620      	mov	r0, r4
    ad46:	47a8      	blx	r5
		grid_ui_event_init(ele, 5, GRID_UI_EVENT_CFG_REQUEST); //
    ad48:	220a      	movs	r2, #10
    ad4a:	2105      	movs	r1, #5
    ad4c:	4620      	mov	r0, r4
    ad4e:	462b      	mov	r3, r5
}
    ad50:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    ad54:	4718      	bx	r3
	else if (element_type == GRID_UI_ELEMENT_POTENTIOMETER){
    ad56:	2d01      	cmp	r5, #1
    ad58:	d111      	bne.n	ad7e <grid_ui_element_init+0x9e>
		ele->event_list_length = 2;
    ad5a:	2302      	movs	r3, #2
    ad5c:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad60:	f44f 70bc 	mov.w	r0, #376	; 0x178
    ad64:	4b21      	ldr	r3, [pc, #132]	; (adec <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad66:	4e22      	ldr	r6, [pc, #136]	; (adf0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad68:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad6a:	2200      	movs	r2, #0
    ad6c:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad6e:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad70:	4620      	mov	r0, r4
    ad72:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    ad74:	462a      	mov	r2, r5
    ad76:	4629      	mov	r1, r5
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    ad78:	4620      	mov	r0, r4
    ad7a:	4633      	mov	r3, r6
    ad7c:	e7e8      	b.n	ad50 <grid_ui_element_init+0x70>
	else if (element_type == GRID_UI_ELEMENT_BUTTON){
    ad7e:	2d02      	cmp	r5, #2
    ad80:	d113      	bne.n	adaa <grid_ui_element_init+0xca>
		ele->event_list_length = 3;
    ad82:	2303      	movs	r3, #3
    ad84:	f884 305c 	strb.w	r3, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad88:	f44f 700d 	mov.w	r0, #564	; 0x234
    ad8c:	4b17      	ldr	r3, [pc, #92]	; (adec <grid_ui_element_init+0x10c>)
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad8e:	4e18      	ldr	r6, [pc, #96]	; (adf0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad90:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad92:	2200      	movs	r2, #0
    ad94:	4611      	mov	r1, r2
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    ad96:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    ad98:	4620      	mov	r0, r4
    ad9a:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    ad9c:	2204      	movs	r2, #4
    ad9e:	2101      	movs	r1, #1
    ada0:	4620      	mov	r0, r4
    ada2:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    ada4:	2205      	movs	r2, #5
    ada6:	4629      	mov	r1, r5
    ada8:	e7e6      	b.n	ad78 <grid_ui_element_init+0x98>
	else if (element_type == GRID_UI_ELEMENT_ENCODER){
    adaa:	2d03      	cmp	r5, #3
    adac:	d11b      	bne.n	ade6 <grid_ui_element_init+0x106>
		ele->event_list_length = 5;
    adae:	2705      	movs	r7, #5
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    adb0:	4b0e      	ldr	r3, [pc, #56]	; (adec <grid_ui_element_init+0x10c>)
		ele->event_list_length = 5;
    adb2:	f884 705c 	strb.w	r7, [r4, #92]	; 0x5c
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    adb6:	f44f 706b 	mov.w	r0, #940	; 0x3ac
    adba:	4798      	blx	r3
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    adbc:	2200      	movs	r2, #0
    adbe:	4e0c      	ldr	r6, [pc, #48]	; (adf0 <grid_ui_element_init+0x110>)
		ele->event_list = malloc(ele->event_list_length*sizeof(struct grid_ui_event));
    adc0:	6620      	str	r0, [r4, #96]	; 0x60
		grid_ui_event_init(ele, 0, GRID_UI_EVENT_INIT); // Element Initialization Event
    adc2:	4611      	mov	r1, r2
    adc4:	4620      	mov	r0, r4
    adc6:	47b0      	blx	r6
		grid_ui_event_init(ele, 1, GRID_UI_EVENT_DP);	// Press
    adc8:	2204      	movs	r2, #4
    adca:	2101      	movs	r1, #1
    adcc:	4620      	mov	r0, r4
    adce:	47b0      	blx	r6
		grid_ui_event_init(ele, 2, GRID_UI_EVENT_DR);	// Release
    add0:	463a      	mov	r2, r7
    add2:	2102      	movs	r1, #2
    add4:	4620      	mov	r0, r4
    add6:	47b0      	blx	r6
		grid_ui_event_init(ele, 3, GRID_UI_EVENT_AVC7); // Absolute Value Change (7bit)
    add8:	2201      	movs	r2, #1
    adda:	4629      	mov	r1, r5
    addc:	4620      	mov	r0, r4
    adde:	47b0      	blx	r6
		grid_ui_event_init(ele, 4, GRID_UI_EVENT_ENCPUSHROT); // Absolute Value Change (7bit)
    ade0:	220d      	movs	r2, #13
    ade2:	2104      	movs	r1, #4
    ade4:	e7c8      	b.n	ad78 <grid_ui_element_init+0x98>
}
    ade6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    adea:	bf00      	nop
    adec:	00014d25 	.word	0x00014d25
    adf0:	0000ac75 	.word	0x0000ac75

0000adf4 <grid_ui_smart_trigger_local>:
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    adf4:	6840      	ldr	r0, [r0, #4]
    adf6:	eb00 1001 	add.w	r0, r0, r1, lsl #4
void grid_ui_smart_trigger_local(struct grid_ui_model* mod, uint8_t bank, uint8_t element, enum grid_ui_event_t event){
    adfa:	b510      	push	{r4, lr}
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    adfc:	68c4      	ldr	r4, [r0, #12]
    adfe:	2064      	movs	r0, #100	; 0x64
    ae00:	fb02 4400 	mla	r4, r2, r0, r4
    ae04:	4619      	mov	r1, r3
    ae06:	4620      	mov	r0, r4
    ae08:	4b05      	ldr	r3, [pc, #20]	; (ae20 <grid_ui_smart_trigger_local+0x2c>)
    ae0a:	4798      	blx	r3
	if (event_index == 255){
    ae0c:	28ff      	cmp	r0, #255	; 0xff
	uint8_t event_index = grid_ui_event_find(&mod->bank_list[bank].element_list[element], event);
    ae0e:	4601      	mov	r1, r0
	if (event_index == 255){
    ae10:	d004      	beq.n	ae1c <grid_ui_smart_trigger_local+0x28>
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    ae12:	4620      	mov	r0, r4
    ae14:	4b03      	ldr	r3, [pc, #12]	; (ae24 <grid_ui_smart_trigger_local+0x30>)
}
    ae16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    grid_ui_event_trigger_local(&mod->bank_list[bank].element_list[element], event_index);
    ae1a:	4718      	bx	r3
}
    ae1c:	bd10      	pop	{r4, pc}
    ae1e:	bf00      	nop
    ae20:	0000aa55 	.word	0x0000aa55
    ae24:	0000aa8f 	.word	0x0000aa8f

0000ae28 <grid_ui_reinit_local>:
void grid_ui_reinit_local(struct grid_ui_model* ui){
    ae28:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ae2c:	4604      	mov	r4, r0
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    ae2e:	f04f 0800 	mov.w	r8, #0
    ae32:	7863      	ldrb	r3, [r4, #1]
    ae34:	fa5f f788 	uxtb.w	r7, r8
    ae38:	42bb      	cmp	r3, r7
    ae3a:	d805      	bhi.n	ae48 <grid_ui_reinit_local+0x20>
	grid_sys_state.bank_active_changed = 1;
    ae3c:	4b1c      	ldr	r3, [pc, #112]	; (aeb0 <grid_ui_reinit_local+0x88>)
    ae3e:	2201      	movs	r2, #1
    ae40:	745a      	strb	r2, [r3, #17]
}
    ae42:	b003      	add	sp, #12
    ae44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		struct grid_ui_bank* bank = &ui->bank_list[i];
    ae48:	6866      	ldr	r6, [r4, #4]
    ae4a:	eb06 1307 	add.w	r3, r6, r7, lsl #4
    ae4e:	9300      	str	r3, [sp, #0]
		for (uint8_t j=0; j<bank->element_list_length; j++){
    ae50:	f04f 0900 	mov.w	r9, #0
    ae54:	9b00      	ldr	r3, [sp, #0]
    ae56:	7a5b      	ldrb	r3, [r3, #9]
    ae58:	fa5f fb89 	uxtb.w	fp, r9
    ae5c:	455b      	cmp	r3, fp
    ae5e:	d802      	bhi.n	ae66 <grid_ui_reinit_local+0x3e>
	for(uint8_t i = 0; i<ui->bank_list_length; i++){
    ae60:	f108 0801 	add.w	r8, r8, #1
    ae64:	e7e5      	b.n	ae32 <grid_ui_reinit_local+0xa>
			struct grid_ui_element* ele = &bank->element_list[j];
    ae66:	9b00      	ldr	r3, [sp, #0]
    ae68:	68db      	ldr	r3, [r3, #12]
    ae6a:	2564      	movs	r5, #100	; 0x64
    ae6c:	fb05 350b 	mla	r5, r5, fp, r3
			for (uint8_t k=0; k<ele->event_list_length; k++){
    ae70:	f04f 0a00 	mov.w	sl, #0
    ae74:	f895 105c 	ldrb.w	r1, [r5, #92]	; 0x5c
    ae78:	fa5f f38a 	uxtb.w	r3, sl
    ae7c:	4299      	cmp	r1, r3
    ae7e:	d802      	bhi.n	ae86 <grid_ui_reinit_local+0x5e>
		for (uint8_t j=0; j<bank->element_list_length; j++){
    ae80:	f109 0901 	add.w	r9, r9, #1
    ae84:	e7e6      	b.n	ae54 <grid_ui_reinit_local+0x2c>
				struct grid_ui_event* eve = &ele->event_list[k];
    ae86:	6e29      	ldr	r1, [r5, #96]	; 0x60
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    ae88:	4e0a      	ldr	r6, [pc, #40]	; (aeb4 <grid_ui_reinit_local+0x8c>)
				struct grid_ui_event* eve = &ele->event_list[k];
    ae8a:	22bc      	movs	r2, #188	; 0xbc
    ae8c:	fb02 1303 	mla	r3, r2, r3, r1
				grid_ui_event_generate_actionstring(ele, eve->type);
    ae90:	9301      	str	r3, [sp, #4]
    ae92:	7a99      	ldrb	r1, [r3, #10]
    ae94:	4b08      	ldr	r3, [pc, #32]	; (aeb8 <grid_ui_reinit_local+0x90>)
    ae96:	4628      	mov	r0, r5
    ae98:	4798      	blx	r3
	eve->trigger = GRID_UI_STATUS_READY;
    ae9a:	9b01      	ldr	r3, [sp, #4]
    ae9c:	2104      	movs	r1, #4
    ae9e:	7259      	strb	r1, [r3, #9]
                grid_ui_smart_trigger_local(ui, i, j, eve->type);
    aea0:	465a      	mov	r2, fp
    aea2:	7a9b      	ldrb	r3, [r3, #10]
    aea4:	4639      	mov	r1, r7
    aea6:	4620      	mov	r0, r4
    aea8:	47b0      	blx	r6
			for (uint8_t k=0; k<ele->event_list_length; k++){
    aeaa:	f10a 0a01 	add.w	sl, sl, #1
    aeae:	e7e1      	b.n	ae74 <grid_ui_reinit_local+0x4c>
    aeb0:	2000f008 	.word	0x2000f008
    aeb4:	0000adf5 	.word	0x0000adf5
    aeb8:	0000a8b1 	.word	0x0000a8b1

0000aebc <grid_ui_event_render_action>:
		return 0;
	}
			
}

uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    aebc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    aec0:	f5ad 7d03 	sub.w	sp, sp, #524	; 0x20c
    aec4:	4606      	mov	r6, r0

	
	uint8_t temp[500] = {0};
    aec6:	ac05      	add	r4, sp, #20
    aec8:	4b74      	ldr	r3, [pc, #464]	; (b09c <grid_ui_event_render_action+0x1e0>)
uint32_t grid_ui_event_render_action(struct grid_ui_event* eve, uint8_t* target_string){
    aeca:	9102      	str	r1, [sp, #8]
	uint8_t temp[500] = {0};
    aecc:	f44f 72f8 	mov.w	r2, #496	; 0x1f0
    aed0:	2100      	movs	r1, #0
    aed2:	a806      	add	r0, sp, #24
    aed4:	6021      	str	r1, [r4, #0]
    aed6:	4798      	blx	r3

	uint32_t i=0;
	
	// copy event string
	for(true; i<eve->event_string_length; i++){
    aed8:	68f3      	ldr	r3, [r6, #12]
    aeda:	18f1      	adds	r1, r6, r3
    aedc:	f106 0210 	add.w	r2, r6, #16
    aee0:	4620      	mov	r0, r4
    aee2:	3110      	adds	r1, #16
    aee4:	4291      	cmp	r1, r2
    aee6:	d11e      	bne.n	af26 <grid_ui_event_render_action+0x6a>
		temp[i] = eve->event_string[i];
	
	}

	// copy action string
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    aee8:	6b32      	ldr	r2, [r6, #48]	; 0x30
    aeea:	f106 0134 	add.w	r1, r6, #52	; 0x34
    aeee:	441a      	add	r2, r3
    aef0:	429a      	cmp	r2, r3
    aef2:	d81d      	bhi.n	af30 <grid_ui_event_render_action+0x74>


	uint32_t total_substituted_length = 0;

	uint8_t condition_state = 0;
	uint8_t condition_istrue = 0;
    aef4:	2700      	movs	r7, #0
	uint8_t condition_state = 0;
    aef6:	9701      	str	r7, [sp, #4]
	uint32_t total_substituted_length = 0;
    aef8:	463d      	mov	r5, r7
	uint32_t block_start = 0;
    aefa:	9700      	str	r7, [sp, #0]


	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    aefc:	463c      	mov	r4, r7
    aefe:	68f0      	ldr	r0, [r6, #12]
    af00:	6b33      	ldr	r3, [r6, #48]	; 0x30
    af02:	4418      	add	r0, r3
    af04:	42a0      	cmp	r0, r4
    af06:	d818      	bhi.n	af3a <grid_ui_event_render_action+0x7e>

	}
	
	
	// RESET ENCODER RELATIVE TEMPLATE PARAMETER VALUES
	if(eve->parent->type == GRID_UI_ELEMENT_ENCODER){	
    af08:	6873      	ldr	r3, [r6, #4]
    af0a:	7a5a      	ldrb	r2, [r3, #9]
    af0c:	2a03      	cmp	r2, #3
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL] = 255;	
    af0e:	bf08      	it	eq
    af10:	22ff      	moveq	r2, #255	; 0xff
    }
	
	
	return eve->event_string_length + eve->action_string_length - total_substituted_length;
		
}
    af12:	eba0 0005 	sub.w	r0, r0, r5
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_LOW] = 255;	
    af16:	bf04      	itt	eq
    af18:	e9c3 220d 	strdeq	r2, r2, [r3, #52]	; 0x34
		eve->parent->template_parameter_list[GRID_TEMPLATE_B_PARAMETER_LIST_LENGTH + GRID_TEMPLATE_E_PARAMETER_CONTROLLER_REL_VELOCITY_HIGH] = 255;	
    af1c:	63da      	streq	r2, [r3, #60]	; 0x3c
}
    af1e:	f50d 7d03 	add.w	sp, sp, #524	; 0x20c
    af22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		temp[i] = eve->event_string[i];
    af26:	f812 5b01 	ldrb.w	r5, [r2], #1
    af2a:	f800 5b01 	strb.w	r5, [r0], #1
	for(true; i<eve->event_string_length; i++){
    af2e:	e7d9      	b.n	aee4 <grid_ui_event_render_action+0x28>
		temp[i] = eve->action_string[i - eve->event_string_length];
    af30:	f811 0b01 	ldrb.w	r0, [r1], #1
    af34:	54e0      	strb	r0, [r4, r3]
	for(true; i<(eve->event_string_length + eve->action_string_length); i++){
    af36:	3301      	adds	r3, #1
    af38:	e7da      	b.n	aef0 <grid_ui_event_render_action+0x34>
		target_string[i-total_substituted_length] = temp[i];
    af3a:	f10d 0914 	add.w	r9, sp, #20
    af3e:	9a02      	ldr	r2, [sp, #8]
    af40:	f819 3004 	ldrb.w	r3, [r9, r4]
    af44:	eba4 0805 	sub.w	r8, r4, r5
		if (temp[i] == '{'){
    af48:	2b7b      	cmp	r3, #123	; 0x7b
		target_string[i-total_substituted_length] = temp[i];
    af4a:	f802 3008 	strb.w	r3, [r2, r8]
		if (temp[i] == '{'){
    af4e:	f000 80a2 	beq.w	b096 <grid_ui_event_render_action+0x1da>
		else if (temp[i] == '}'){
    af52:	2b7d      	cmp	r3, #125	; 0x7d
    af54:	f104 0a01 	add.w	sl, r4, #1
    af58:	d145      	bne.n	afe6 <grid_ui_event_render_action+0x12a>
			if (block_length){
    af5a:	9b00      	ldr	r3, [sp, #0]
    af5c:	ebba 0b03 	subs.w	fp, sl, r3
    af60:	d030      	beq.n	afc4 <grid_ui_event_render_action+0x108>
				grid_expr_set_current_event(&grid_expr_state, eve);
    af62:	4b4f      	ldr	r3, [pc, #316]	; (b0a0 <grid_ui_event_render_action+0x1e4>)
    af64:	484f      	ldr	r0, [pc, #316]	; (b0a4 <grid_ui_event_render_action+0x1e8>)
    af66:	4631      	mov	r1, r6
    af68:	4798      	blx	r3
				grid_expr_evaluate(&grid_expr_state, &temp[block_start+1], block_length-2); // -2 to not include {
    af6a:	9b00      	ldr	r3, [sp, #0]
    af6c:	484d      	ldr	r0, [pc, #308]	; (b0a4 <grid_ui_event_render_action+0x1e8>)
    af6e:	3301      	adds	r3, #1
    af70:	f1ab 0202 	sub.w	r2, fp, #2
    af74:	eb09 0103 	add.w	r1, r9, r3
    af78:	b2d2      	uxtb	r2, r2
    af7a:	f8df 9134 	ldr.w	r9, [pc, #308]	; b0b0 <grid_ui_event_render_action+0x1f4>
    af7e:	9303      	str	r3, [sp, #12]
    af80:	47c8      	blx	r9
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    af82:	9b03      	ldr	r3, [sp, #12]
				for (uint8_t j = 0; j<block_length; j++){
    af84:	2100      	movs	r1, #0
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    af86:	eb08 0003 	add.w	r0, r8, r3
    af8a:	eba0 0e0a 	sub.w	lr, r0, sl
    af8e:	468c      	mov	ip, r1
				for (uint8_t j = 0; j<block_length; j++){
    af90:	b2ca      	uxtb	r2, r1
    af92:	4593      	cmp	fp, r2
    af94:	f101 0101 	add.w	r1, r1, #1
    af98:	d816      	bhi.n	afc8 <grid_ui_event_render_action+0x10c>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    af9a:	4498      	add	r8, r3
    af9c:	9b02      	ldr	r3, [sp, #8]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    af9e:	4a41      	ldr	r2, [pc, #260]	; (b0a4 <grid_ui_event_render_action+0x1e8>)
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    afa0:	eba8 0a0a 	sub.w	sl, r8, sl
    afa4:	2000      	movs	r0, #0
    afa6:	449a      	add	sl, r3
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    afa8:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
    afac:	b2c1      	uxtb	r1, r0
    afae:	428b      	cmp	r3, r1
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    afb0:	f892 31fa 	ldrb.w	r3, [r2, #506]	; 0x1fa
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    afb4:	d80d      	bhi.n	afd2 <grid_ui_event_render_action+0x116>
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    afb6:	1aed      	subs	r5, r5, r3
				if (condition_state == 1){
    afb8:	9b01      	ldr	r3, [sp, #4]
				total_substituted_length += block_length - grid_expr_state.output_string_length;
    afba:	445d      	add	r5, fp
				if (condition_state == 1){
    afbc:	b113      	cbz	r3, afc4 <grid_ui_event_render_action+0x108>
					condition_istrue = grid_expr_state.return_value;
    afbe:	f8d2 71fc 	ldr.w	r7, [r2, #508]	; 0x1fc
    afc2:	b2ff      	uxtb	r7, r7
	for(i=0; i<(eve->event_string_length + eve->action_string_length) ; i++){
    afc4:	3401      	adds	r4, #1
    afc6:	e79a      	b.n	aefe <grid_ui_event_render_action+0x42>
					target_string[i-total_substituted_length-block_length+1+j] = 0;	
    afc8:	9802      	ldr	r0, [sp, #8]
    afca:	4402      	add	r2, r0
    afcc:	f802 c00e 	strb.w	ip, [r2, lr]
				for (uint8_t j = 0; j<block_length; j++){
    afd0:	e7de      	b.n	af90 <grid_ui_event_render_action+0xd4>
					target_string[i-total_substituted_length-block_length+j + 1] = grid_expr_state.output_string[GRID_EXPR_OUTPUT_STRING_MAXLENGTH-grid_expr_state.output_string_length+j];
    afd2:	f1c3 03fa 	rsb	r3, r3, #250	; 0xfa
    afd6:	440b      	add	r3, r1
    afd8:	4413      	add	r3, r2
    afda:	3001      	adds	r0, #1
    afdc:	f893 30ff 	ldrb.w	r3, [r3, #255]	; 0xff
    afe0:	f80a 3001 	strb.w	r3, [sl, r1]
				for (uint8_t j = 0; j<grid_expr_state.output_string_length; j++){
    afe4:	e7e0      	b.n	afa8 <grid_ui_event_render_action+0xec>
		else if(temp[i] == '#'){
    afe6:	2b23      	cmp	r3, #35	; 0x23
    afe8:	d1ec      	bne.n	afc4 <grid_ui_event_render_action+0x108>
			if (temp[i+1] == 'I' && temp[i+2] == 'F' ){
    afea:	f819 300a 	ldrb.w	r3, [r9, sl]
    afee:	2b49      	cmp	r3, #73	; 0x49
    aff0:	d109      	bne.n	b006 <grid_ui_event_render_action+0x14a>
    aff2:	1ca3      	adds	r3, r4, #2
    aff4:	f819 2003 	ldrb.w	r2, [r9, r3]
    aff8:	2a46      	cmp	r2, #70	; 0x46
    affa:	d1e3      	bne.n	afc4 <grid_ui_event_render_action+0x108>
				i+=2;
    affc:	461c      	mov	r4, r3
				condition_state = 1;
    affe:	2301      	movs	r3, #1
				total_substituted_length += 3;
    b000:	3503      	adds	r5, #3
				condition_state = 1;
    b002:	9301      	str	r3, [sp, #4]
    b004:	e7de      	b.n	afc4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'T' && temp[i+2] == 'H' ){
    b006:	2b54      	cmp	r3, #84	; 0x54
    b008:	d121      	bne.n	b04e <grid_ui_event_render_action+0x192>
    b00a:	1ca3      	adds	r3, r4, #2
    b00c:	f819 2003 	ldrb.w	r2, [r9, r3]
    b010:	2a48      	cmp	r2, #72	; 0x48
    b012:	d1d7      	bne.n	afc4 <grid_ui_event_render_action+0x108>
				if (!condition_istrue){
    b014:	bbaf      	cbnz	r7, b082 <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    b016:	f04f 0801 	mov.w	r8, #1
    b01a:	e009      	b.n	b030 <grid_ui_event_render_action+0x174>
						else if(j==(eve->event_string_length + eve->action_string_length)-i-1){
    b01c:	3b01      	subs	r3, #1
    b01e:	4543      	cmp	r3, r8
    b020:	d102      	bne.n	b028 <grid_ui_event_render_action+0x16c>
							printf("Syntax Error!\r\n");
    b022:	4821      	ldr	r0, [pc, #132]	; (b0a8 <grid_ui_event_render_action+0x1ec>)
    b024:	4b21      	ldr	r3, [pc, #132]	; (b0ac <grid_ui_event_render_action+0x1f0>)
    b026:	4798      	blx	r3
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    b028:	f108 0801 	add.w	r8, r8, #1
    b02c:	fa5f f888 	uxtb.w	r8, r8
    b030:	68f3      	ldr	r3, [r6, #12]
    b032:	6b32      	ldr	r2, [r6, #48]	; 0x30
    b034:	4413      	add	r3, r2
    b036:	1b1b      	subs	r3, r3, r4
    b038:	4598      	cmp	r8, r3
    b03a:	d2c3      	bcs.n	afc4 <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    b03c:	eb08 0204 	add.w	r2, r8, r4
    b040:	f819 1002 	ldrb.w	r1, [r9, r2]
    b044:	2923      	cmp	r1, #35	; 0x23
    b046:	d1e9      	bne.n	b01c <grid_ui_event_render_action+0x160>
							total_substituted_length += j;
    b048:	4445      	add	r5, r8
							i+=j-1;
    b04a:	1e54      	subs	r4, r2, #1
							break;
    b04c:	e7ba      	b.n	afc4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'L' ){
    b04e:	2b45      	cmp	r3, #69	; 0x45
    b050:	d1b8      	bne.n	afc4 <grid_ui_event_render_action+0x108>
    b052:	1ca3      	adds	r3, r4, #2
    b054:	f819 2003 	ldrb.w	r2, [r9, r3]
    b058:	2a4c      	cmp	r2, #76	; 0x4c
    b05a:	d115      	bne.n	b088 <grid_ui_event_render_action+0x1cc>
				if (condition_istrue){
    b05c:	b18f      	cbz	r7, b082 <grid_ui_event_render_action+0x1c6>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    b05e:	6b32      	ldr	r2, [r6, #48]	; 0x30
    b060:	68f3      	ldr	r3, [r6, #12]
    b062:	4413      	add	r3, r2
    b064:	1b1a      	subs	r2, r3, r4
    b066:	2301      	movs	r3, #1
    b068:	4293      	cmp	r3, r2
    b06a:	d2ab      	bcs.n	afc4 <grid_ui_event_render_action+0x108>
						if (temp[i+j] == '#'){
    b06c:	1919      	adds	r1, r3, r4
    b06e:	f819 0001 	ldrb.w	r0, [r9, r1]
    b072:	2823      	cmp	r0, #35	; 0x23
    b074:	d102      	bne.n	b07c <grid_ui_event_render_action+0x1c0>
							total_substituted_length += j;
    b076:	441d      	add	r5, r3
							i+=j-1;
    b078:	1e4c      	subs	r4, r1, #1
							break;
    b07a:	e7a3      	b.n	afc4 <grid_ui_event_render_action+0x108>
					for(uint8_t j=1; j<(eve->event_string_length + eve->action_string_length)-i; j++){
    b07c:	3301      	adds	r3, #1
    b07e:	b2db      	uxtb	r3, r3
    b080:	e7f2      	b.n	b068 <grid_ui_event_render_action+0x1ac>
					total_substituted_length += 3;
    b082:	3503      	adds	r5, #3
					i+=2;
    b084:	461c      	mov	r4, r3
    b086:	e79d      	b.n	afc4 <grid_ui_event_render_action+0x108>
			}else if (temp[i+1] == 'E' && temp[i+2] == 'N' ){
    b088:	2a4e      	cmp	r2, #78	; 0x4e
    b08a:	d19b      	bne.n	afc4 <grid_ui_event_render_action+0x108>
				condition_istrue = 0;
    b08c:	2700      	movs	r7, #0
				total_substituted_length += 3;
    b08e:	3503      	adds	r5, #3
				i+=2;
    b090:	461c      	mov	r4, r3
				condition_state = 0;
    b092:	9701      	str	r7, [sp, #4]
    b094:	e796      	b.n	afc4 <grid_ui_event_render_action+0x108>
    b096:	9400      	str	r4, [sp, #0]
    b098:	e794      	b.n	afc4 <grid_ui_event_render_action+0x108>
    b09a:	bf00      	nop
    b09c:	00014d51 	.word	0x00014d51
    b0a0:	000067c5 	.word	0x000067c5
    b0a4:	20013220 	.word	0x20013220
    b0a8:	00016d37 	.word	0x00016d37
    b0ac:	00014fe5 	.word	0x00014fe5
    b0b0:	00006f55 	.word	0x00006f55

0000b0b4 <grid_port_process_ui>:
void grid_port_process_ui(struct grid_port* por){
    b0b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    b0b8:	4fb1      	ldr	r7, [pc, #708]	; (b380 <grid_port_process_ui+0x2cc>)
void grid_port_process_ui(struct grid_port* por){
    b0ba:	f5ad 7d57 	sub.w	sp, sp, #860	; 0x35c
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    b0be:	2100      	movs	r1, #0
void grid_port_process_ui(struct grid_port* por){
    b0c0:	9001      	str	r0, [sp, #4]
	uint8_t message_local_action_available = 0;
    b0c2:	4688      	mov	r8, r1
	uint8_t message_broadcast_action_available = 0;
    b0c4:	460d      	mov	r5, r1
    b0c6:	46ba      	mov	sl, r7
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    b0c8:	f04f 0c64 	mov.w	ip, #100	; 0x64
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b0cc:	f04f 0ebc 	mov.w	lr, #188	; 0xbc
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    b0d0:	787a      	ldrb	r2, [r7, #1]
    b0d2:	b2cb      	uxtb	r3, r1
    b0d4:	429a      	cmp	r2, r3
    b0d6:	d95e      	bls.n	b196 <grid_port_process_ui+0xe2>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    b0d8:	011b      	lsls	r3, r3, #4
    b0da:	2400      	movs	r4, #0
    b0dc:	e02e      	b.n	b13c <grid_port_process_ui+0x88>
				if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b0de:	f8da 9004 	ldr.w	r9, [sl, #4]
    b0e2:	4499      	add	r9, r3
    b0e4:	fb0e f000 	mul.w	r0, lr, r0
    b0e8:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b0ec:	4491      	add	r9, r2
    b0ee:	3601      	adds	r6, #1
    b0f0:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    b0f4:	4481      	add	r9, r0
    b0f6:	f899 9009 	ldrb.w	r9, [r9, #9]
    b0fa:	f1b9 0f05 	cmp.w	r9, #5
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b0fe:	f8da 9004 	ldr.w	r9, [sl, #4]
    b102:	4499      	add	r9, r3
					message_broadcast_action_available++;
    b104:	bf08      	it	eq
    b106:	3501      	addeq	r5, #1
				if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b108:	f8d9 900c 	ldr.w	r9, [r9, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    b10c:	4491      	add	r9, r2
					message_broadcast_action_available++;
    b10e:	bf08      	it	eq
    b110:	b2ed      	uxtbeq	r5, r5
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    b112:	f8d9 9060 	ldr.w	r9, [r9, #96]	; 0x60
    b116:	4448      	add	r0, r9
    b118:	7a40      	ldrb	r0, [r0, #9]
    b11a:	2806      	cmp	r0, #6
                    message_local_action_available++;
    b11c:	bf04      	itt	eq
    b11e:	f108 0801 	addeq.w	r8, r8, #1
    b122:	fa5f f888 	uxtbeq.w	r8, r8
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    b126:	f8da 0004 	ldr.w	r0, [sl, #4]
    b12a:	4418      	add	r0, r3
    b12c:	68c0      	ldr	r0, [r0, #12]
    b12e:	4410      	add	r0, r2
    b130:	f890 905c 	ldrb.w	r9, [r0, #92]	; 0x5c
    b134:	b2f0      	uxtb	r0, r6
    b136:	4581      	cmp	r9, r0
    b138:	d8d1      	bhi.n	b0de <grid_port_process_ui+0x2a>
		for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    b13a:	3401      	adds	r4, #1
    b13c:	f8da 2004 	ldr.w	r2, [sl, #4]
    b140:	441a      	add	r2, r3
    b142:	7a50      	ldrb	r0, [r2, #9]
    b144:	b2e2      	uxtb	r2, r4
    b146:	4290      	cmp	r0, r2
    b148:	d903      	bls.n	b152 <grid_port_process_ui+0x9e>
			for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    b14a:	fb0c f202 	mul.w	r2, ip, r2
    b14e:	2600      	movs	r6, #0
    b150:	e7e9      	b.n	b126 <grid_port_process_ui+0x72>
	for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    b152:	3101      	adds	r1, #1
    b154:	e7bc      	b.n	b0d0 <grid_port_process_ui+0x1c>
			if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    b156:	6870      	ldr	r0, [r6, #4]
    b158:	68c0      	ldr	r0, [r0, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b15a:	eb00 0e03 	add.w	lr, r0, r3
    b15e:	3201      	adds	r2, #1
    b160:	f8de 0060 	ldr.w	r0, [lr, #96]	; 0x60
    b164:	fb0c 0009 	mla	r0, ip, r9, r0
    b168:	7a40      	ldrb	r0, [r0, #9]
    b16a:	2805      	cmp	r0, #5
				message_broadcast_action_available++;
    b16c:	bf04      	itt	eq
    b16e:	3501      	addeq	r5, #1
    b170:	b2ed      	uxtbeq	r5, r5
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    b172:	6870      	ldr	r0, [r6, #4]
    b174:	68c0      	ldr	r0, [r0, #12]
    b176:	4418      	add	r0, r3
    b178:	fa5f f982 	uxtb.w	r9, r2
    b17c:	f890 005c 	ldrb.w	r0, [r0, #92]	; 0x5c
    b180:	4548      	cmp	r0, r9
    b182:	d8e8      	bhi.n	b156 <grid_port_process_ui+0xa2>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    b184:	3101      	adds	r1, #1
    b186:	6863      	ldr	r3, [r4, #4]
    b188:	7a5a      	ldrb	r2, [r3, #9]
    b18a:	b2cb      	uxtb	r3, r1
    b18c:	429a      	cmp	r2, r3
    b18e:	d909      	bls.n	b1a4 <grid_port_process_ui+0xf0>
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    b190:	437b      	muls	r3, r7
    b192:	2200      	movs	r2, #0
    b194:	e7ed      	b.n	b172 <grid_port_process_ui+0xbe>
	for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    b196:	4c7b      	ldr	r4, [pc, #492]	; (b384 <grid_port_process_ui+0x2d0>)
    b198:	2100      	movs	r1, #0
    b19a:	4626      	mov	r6, r4
		for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    b19c:	2764      	movs	r7, #100	; 0x64
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b19e:	f04f 0cbc 	mov.w	ip, #188	; 0xbc
    b1a2:	e7f0      	b.n	b186 <grid_port_process_ui+0xd2>
	struct grid_port* port[4] = {&GRID_PORT_N, &GRID_PORT_E, &GRID_PORT_S, &GRID_PORT_W};
    b1a4:	4b78      	ldr	r3, [pc, #480]	; (b388 <grid_port_process_ui+0x2d4>)
    b1a6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    b1a8:	ae07      	add	r6, sp, #28
    b1aa:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
    b1ae:	2404      	movs	r4, #4
		if (port[k]->ping_flag == 1){
    b1b0:	f856 7b04 	ldr.w	r7, [r6], #4
    b1b4:	f642 7348 	movw	r3, #12104	; 0x2f48
    b1b8:	5cfb      	ldrb	r3, [r7, r3]
    b1ba:	2b01      	cmp	r3, #1
    b1bc:	d11f      	bne.n	b1fe <grid_port_process_ui+0x14a>
			if (grid_buffer_write_init(&port[k]->tx_buffer, port[k]->ping_packet_length)){
    b1be:	f642 7347 	movw	r3, #12103	; 0x2f47
    b1c2:	f507 591c 	add.w	r9, r7, #9984	; 0x2700
    b1c6:	f109 093c 	add.w	r9, r9, #60	; 0x3c
    b1ca:	18fa      	adds	r2, r7, r3
    b1cc:	5cf9      	ldrb	r1, [r7, r3]
    b1ce:	4b6f      	ldr	r3, [pc, #444]	; (b38c <grid_port_process_ui+0x2d8>)
    b1d0:	9202      	str	r2, [sp, #8]
    b1d2:	4648      	mov	r0, r9
    b1d4:	4798      	blx	r3
    b1d6:	b170      	cbz	r0, b1f6 <grid_port_process_ui+0x142>
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    b1d8:	4b6d      	ldr	r3, [pc, #436]	; (b390 <grid_port_process_ui+0x2dc>)
    b1da:	f507 5b3c 	add.w	fp, r7, #12032	; 0x2f00
    b1de:	f10b 0b33 	add.w	fp, fp, #51	; 0x33
    b1e2:	1bdb      	subs	r3, r3, r7
    b1e4:	9a02      	ldr	r2, [sp, #8]
    b1e6:	7811      	ldrb	r1, [r2, #0]
    b1e8:	eb03 020b 	add.w	r2, r3, fp
    b1ec:	4291      	cmp	r1, r2
    b1ee:	d826      	bhi.n	b23e <grid_port_process_ui+0x18a>
				grid_buffer_write_acknowledge(&port[k]->tx_buffer);
    b1f0:	4b68      	ldr	r3, [pc, #416]	; (b394 <grid_port_process_ui+0x2e0>)
    b1f2:	4648      	mov	r0, r9
    b1f4:	4798      	blx	r3
			port[k]->ping_flag = 0;
    b1f6:	f642 7248 	movw	r2, #12104	; 0x2f48
    b1fa:	2300      	movs	r3, #0
    b1fc:	54bb      	strb	r3, [r7, r2]
	for (uint8_t k = 0; k<4; k++){
    b1fe:	3c01      	subs	r4, #1
    b200:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
    b204:	d1d4      	bne.n	b1b0 <grid_port_process_ui+0xfc>
	if (message_local_action_available){
    b206:	f1b8 0f00 	cmp.w	r8, #0
    b20a:	d07e      	beq.n	b30a <grid_port_process_ui+0x256>
		grid_msg_init(&message);
    b20c:	4b62      	ldr	r3, [pc, #392]	; (b398 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b20e:	4e63      	ldr	r6, [pc, #396]	; (b39c <grid_port_process_ui+0x2e8>)
		grid_msg_init(&message);
    b210:	a86f      	add	r0, sp, #444	; 0x1bc
    b212:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b214:	227f      	movs	r2, #127	; 0x7f
    b216:	4611      	mov	r1, r2
    b218:	4623      	mov	r3, r4
    b21a:	a86f      	add	r0, sp, #444	; 0x1bc
    b21c:	47b0      	blx	r6
		uint8_t payload[GRID_PARAMETER_PACKET_maxlength] = {0};				
    b21e:	4b60      	ldr	r3, [pc, #384]	; (b3a0 <grid_port_process_ui+0x2ec>)
    b220:	940b      	str	r4, [sp, #44]	; 0x2c
    b222:	f44f 72c6 	mov.w	r2, #396	; 0x18c
    b226:	4621      	mov	r1, r4
    b228:	a80c      	add	r0, sp, #48	; 0x30
    b22a:	4798      	blx	r3
		uint32_t offset=0;
    b22c:	46a0      	mov	r8, r4
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    b22e:	f89a 3001 	ldrb.w	r3, [sl, #1]
    b232:	b2e6      	uxtb	r6, r4
    b234:	42b3      	cmp	r3, r6
    b236:	d956      	bls.n	b2e6 <grid_port_process_ui+0x232>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    b238:	0136      	lsls	r6, r6, #4
    b23a:	2300      	movs	r3, #0
    b23c:	e043      	b.n	b2c6 <grid_port_process_ui+0x212>
    b23e:	9303      	str	r3, [sp, #12]
					grid_buffer_write_character(&port[k]->tx_buffer, port[k]->ping_packet[i]);
    b240:	f81b 1b01 	ldrb.w	r1, [fp], #1
    b244:	4b57      	ldr	r3, [pc, #348]	; (b3a4 <grid_port_process_ui+0x2f0>)
    b246:	4648      	mov	r0, r9
    b248:	4798      	blx	r3
    b24a:	9b03      	ldr	r3, [sp, #12]
				for(uint32_t i = 0; i<port[k]->ping_packet_length; i++){
    b24c:	e7ca      	b.n	b1e4 <grid_port_process_ui+0x130>
					if (offset>GRID_PARAMETER_PACKET_marign){
    b24e:	f1b8 0fc8 	cmp.w	r8, #200	; 0xc8
    b252:	d829      	bhi.n	b2a8 <grid_port_process_ui+0x1f4>
						CRITICAL_SECTION_ENTER()
    b254:	4b54      	ldr	r3, [pc, #336]	; (b3a8 <grid_port_process_ui+0x2f4>)
    b256:	a805      	add	r0, sp, #20
    b258:	4798      	blx	r3
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b25a:	f8da 3004 	ldr.w	r3, [sl, #4]
    b25e:	4433      	add	r3, r6
    b260:	22bc      	movs	r2, #188	; 0xbc
    b262:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    b264:	443b      	add	r3, r7
						if (grid_ui_event_istriggered_local(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b266:	fb02 fb0b 	mul.w	fp, r2, fp
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED_LOCAL){
    b26a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b26c:	445b      	add	r3, fp
    b26e:	7a5b      	ldrb	r3, [r3, #9]
    b270:	2b06      	cmp	r3, #6
    b272:	d116      	bne.n	b2a2 <grid_port_process_ui+0x1ee>
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    b274:	f8da 3004 	ldr.w	r3, [sl, #4]
    b278:	4433      	add	r3, r6
    b27a:	68db      	ldr	r3, [r3, #12]
    b27c:	443b      	add	r3, r7
    b27e:	6e18      	ldr	r0, [r3, #96]	; 0x60
    b280:	ab0b      	add	r3, sp, #44	; 0x2c
    b282:	eb03 0108 	add.w	r1, r3, r8
    b286:	4458      	add	r0, fp
    b288:	4b48      	ldr	r3, [pc, #288]	; (b3ac <grid_port_process_ui+0x2f8>)
    b28a:	4798      	blx	r3
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    b28c:	f8da 3004 	ldr.w	r3, [sl, #4]
    b290:	4433      	add	r3, r6
                            offset += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &payload[offset]);
    b292:	4480      	add	r8, r0
                            grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    b294:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    b296:	443b      	add	r3, r7
    b298:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b29a:	449b      	add	fp, r3
    b29c:	2304      	movs	r3, #4
    b29e:	f88b 3009 	strb.w	r3, [fp, #9]
						CRITICAL_SECTION_LEAVE()
    b2a2:	4b43      	ldr	r3, [pc, #268]	; (b3b0 <grid_port_process_ui+0x2fc>)
    b2a4:	a805      	add	r0, sp, #20
    b2a6:	4798      	blx	r3
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    b2a8:	f109 0901 	add.w	r9, r9, #1
    b2ac:	f8da 3004 	ldr.w	r3, [sl, #4]
    b2b0:	4433      	add	r3, r6
    b2b2:	fa5f fb89 	uxtb.w	fp, r9
    b2b6:	68db      	ldr	r3, [r3, #12]
    b2b8:	443b      	add	r3, r7
    b2ba:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    b2be:	455b      	cmp	r3, fp
    b2c0:	d8c5      	bhi.n	b24e <grid_port_process_ui+0x19a>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    b2c2:	9b02      	ldr	r3, [sp, #8]
    b2c4:	3301      	adds	r3, #1
    b2c6:	9302      	str	r3, [sp, #8]
    b2c8:	f8da 3004 	ldr.w	r3, [sl, #4]
    b2cc:	4433      	add	r3, r6
    b2ce:	7a5a      	ldrb	r2, [r3, #9]
    b2d0:	f89d 3008 	ldrb.w	r3, [sp, #8]
    b2d4:	429a      	cmp	r2, r3
    b2d6:	d904      	bls.n	b2e2 <grid_port_process_ui+0x22e>
                for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){
    b2d8:	2764      	movs	r7, #100	; 0x64
    b2da:	435f      	muls	r7, r3
    b2dc:	f04f 0900 	mov.w	r9, #0
    b2e0:	e7e4      	b.n	b2ac <grid_port_process_ui+0x1f8>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++)
    b2e2:	3401      	adds	r4, #1
    b2e4:	e7a3      	b.n	b22e <grid_port_process_ui+0x17a>
		grid_msg_body_append_text(&message, payload, offset);
    b2e6:	a90b      	add	r1, sp, #44	; 0x2c
    b2e8:	4642      	mov	r2, r8
    b2ea:	4b32      	ldr	r3, [pc, #200]	; (b3b4 <grid_port_process_ui+0x300>)
    b2ec:	a86f      	add	r0, sp, #444	; 0x1bc
    b2ee:	4798      	blx	r3
		grid_msg_packet_close(&message);
    b2f0:	4b31      	ldr	r3, [pc, #196]	; (b3b8 <grid_port_process_ui+0x304>)
    b2f2:	a86f      	add	r0, sp, #444	; 0x1bc
    b2f4:	4798      	blx	r3
		uint32_t message_length = grid_msg_packet_get_length(&message);
    b2f6:	4b31      	ldr	r3, [pc, #196]	; (b3bc <grid_port_process_ui+0x308>)
    b2f8:	a86f      	add	r0, sp, #444	; 0x1bc
    b2fa:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    b2fc:	4b23      	ldr	r3, [pc, #140]	; (b38c <grid_port_process_ui+0x2d8>)
		uint32_t message_length = grid_msg_packet_get_length(&message);
    b2fe:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.tx_buffer, message_length)){
    b300:	b281      	uxth	r1, r0
    b302:	482f      	ldr	r0, [pc, #188]	; (b3c0 <grid_port_process_ui+0x30c>)
    b304:	4798      	blx	r3
    b306:	2800      	cmp	r0, #0
    b308:	d132      	bne.n	b370 <grid_port_process_ui+0x2bc>
	if (por->cooldown > 0){
    b30a:	9b01      	ldr	r3, [sp, #4]
    b30c:	681b      	ldr	r3, [r3, #0]
    b30e:	b12b      	cbz	r3, b31c <grid_port_process_ui+0x268>
		por->cooldown--;
    b310:	3b01      	subs	r3, #1
    b312:	9a01      	ldr	r2, [sp, #4]
	if (por->cooldown > 10){
    b314:	2b0a      	cmp	r3, #10
		por->cooldown--;
    b316:	6013      	str	r3, [r2, #0]
	if (por->cooldown > 10){
    b318:	f200 80fc 	bhi.w	b514 <grid_port_process_ui+0x460>
	if (message_broadcast_action_available){
    b31c:	2d00      	cmp	r5, #0
    b31e:	f000 80f9 	beq.w	b514 <grid_port_process_ui+0x460>
		grid_msg_init(&message);
    b322:	4b1d      	ldr	r3, [pc, #116]	; (b398 <grid_port_process_ui+0x2e4>)
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b324:	4c1d      	ldr	r4, [pc, #116]	; (b39c <grid_port_process_ui+0x2e8>)
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    b326:	f8df 805c 	ldr.w	r8, [pc, #92]	; b384 <grid_port_process_ui+0x2d0>
		grid_msg_init(&message);
    b32a:	a86f      	add	r0, sp, #444	; 0x1bc
    b32c:	4798      	blx	r3
		grid_msg_init_header(&message, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b32e:	227f      	movs	r2, #127	; 0x7f
    b330:	2300      	movs	r3, #0
    b332:	4611      	mov	r1, r2
    b334:	a86f      	add	r0, sp, #444	; 0x1bc
    b336:	47a0      	blx	r4
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    b338:	2700      	movs	r7, #0
    b33a:	4645      	mov	r5, r8
    b33c:	f8d8 3004 	ldr.w	r3, [r8, #4]
    b340:	7a5a      	ldrb	r2, [r3, #9]
    b342:	b2fb      	uxtb	r3, r7
    b344:	429a      	cmp	r2, r3
    b346:	f240 80d2 	bls.w	b4ee <grid_port_process_ui+0x43a>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    b34a:	2464      	movs	r4, #100	; 0x64
					CRITICAL_SECTION_LEAVE()
    b34c:	f8df b060 	ldr.w	fp, [pc, #96]	; b3b0 <grid_port_process_ui+0x2fc>
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    b350:	435c      	muls	r4, r3
    b352:	2600      	movs	r6, #0
    b354:	e067      	b.n	b426 <grid_port_process_ui+0x372>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    b356:	4631      	mov	r1, r6
    b358:	a86f      	add	r0, sp, #444	; 0x1bc
    b35a:	47b8      	blx	r7
    b35c:	4601      	mov	r1, r0
    b35e:	4640      	mov	r0, r8
    b360:	47c8      	blx	r9
			for(uint32_t i = 0; i<message_length; i++){
    b362:	3601      	adds	r6, #1
    b364:	42a6      	cmp	r6, r4
    b366:	d1f6      	bne.n	b356 <grid_port_process_ui+0x2a2>
			grid_buffer_write_acknowledge(&GRID_PORT_U.tx_buffer);
    b368:	4b0a      	ldr	r3, [pc, #40]	; (b394 <grid_port_process_ui+0x2e0>)
    b36a:	4815      	ldr	r0, [pc, #84]	; (b3c0 <grid_port_process_ui+0x30c>)
    b36c:	4798      	blx	r3
		}
    b36e:	e7cc      	b.n	b30a <grid_port_process_ui+0x256>
				grid_buffer_write_character(&GRID_PORT_U.tx_buffer, grid_msg_packet_send_char(&message, i));
    b370:	4f14      	ldr	r7, [pc, #80]	; (b3c4 <grid_port_process_ui+0x310>)
    b372:	f8df 804c 	ldr.w	r8, [pc, #76]	; b3c0 <grid_port_process_ui+0x30c>
    b376:	f8df 902c 	ldr.w	r9, [pc, #44]	; b3a4 <grid_port_process_ui+0x2f0>
			for(uint32_t i = 0; i<message_length; i++){
    b37a:	2600      	movs	r6, #0
    b37c:	e7f2      	b.n	b364 <grid_port_process_ui+0x2b0>
    b37e:	bf00      	nop
    b380:	2000effc 	.word	0x2000effc
    b384:	2001c7c0 	.word	0x2001c7c0
    b388:	00016d48 	.word	0x00016d48
    b38c:	000047f1 	.word	0x000047f1
    b390:	ffffd0cd 	.word	0xffffd0cd
    b394:	0000484d 	.word	0x0000484d
    b398:	00008ed5 	.word	0x00008ed5
    b39c:	00008f09 	.word	0x00008f09
    b3a0:	00014d51 	.word	0x00014d51
    b3a4:	0000482d 	.word	0x0000482d
    b3a8:	00012485 	.word	0x00012485
    b3ac:	0000aebd 	.word	0x0000aebd
    b3b0:	00012493 	.word	0x00012493
    b3b4:	00008e45 	.word	0x00008e45
    b3b8:	00009001 	.word	0x00009001
    b3bc:	00008e31 	.word	0x00008e31
    b3c0:	2000e7ec 	.word	0x2000e7ec
    b3c4:	00008fcb 	.word	0x00008fcb
				if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    b3c8:	4b5e      	ldr	r3, [pc, #376]	; (b544 <grid_port_process_ui+0x490>)
    b3ca:	a86f      	add	r0, sp, #444	; 0x1bc
    b3cc:	4798      	blx	r3
    b3ce:	28c8      	cmp	r0, #200	; 0xc8
    b3d0:	d828      	bhi.n	b424 <grid_port_process_ui+0x370>
					CRITICAL_SECTION_ENTER()
    b3d2:	4b5d      	ldr	r3, [pc, #372]	; (b548 <grid_port_process_ui+0x494>)
    b3d4:	a806      	add	r0, sp, #24
    b3d6:	4798      	blx	r3
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    b3d8:	686b      	ldr	r3, [r5, #4]
    b3da:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b3dc:	4423      	add	r3, r4
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    b3de:	22bc      	movs	r2, #188	; 0xbc
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b3e0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
					if (grid_ui_event_istriggered(&grid_core_state.bank_list[0].element_list[i].event_list[j])){
    b3e2:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b3e6:	444b      	add	r3, r9
    b3e8:	7a5b      	ldrb	r3, [r3, #9]
    b3ea:	2b05      	cmp	r3, #5
    b3ec:	d118      	bne.n	b420 <grid_port_process_ui+0x36c>
						uint32_t offset = grid_msg_body_get_length(&message); 
    b3ee:	4b57      	ldr	r3, [pc, #348]	; (b54c <grid_port_process_ui+0x498>)
    b3f0:	a86f      	add	r0, sp, #444	; 0x1bc
    b3f2:	4798      	blx	r3
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    b3f4:	686b      	ldr	r3, [r5, #4]
    b3f6:	68db      	ldr	r3, [r3, #12]
    b3f8:	4423      	add	r3, r4
    b3fa:	3014      	adds	r0, #20
    b3fc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b3fe:	aa6f      	add	r2, sp, #444	; 0x1bc
    b400:	1811      	adds	r1, r2, r0
    b402:	eb03 0009 	add.w	r0, r3, r9
    b406:	4b52      	ldr	r3, [pc, #328]	; (b550 <grid_port_process_ui+0x49c>)
    b408:	4798      	blx	r3
    b40a:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    b40c:	4418      	add	r0, r3
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    b40e:	686b      	ldr	r3, [r5, #4]
						message.body_length += grid_ui_event_render_action(&grid_core_state.bank_list[0].element_list[i].event_list[j], &message.body[offset]);
    b410:	90d4      	str	r0, [sp, #848]	; 0x350
						grid_ui_event_reset(&grid_core_state.bank_list[0].element_list[i].event_list[j]);
    b412:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    b414:	4423      	add	r3, r4
    b416:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b418:	4499      	add	r9, r3
    b41a:	2304      	movs	r3, #4
    b41c:	f889 3009 	strb.w	r3, [r9, #9]
					CRITICAL_SECTION_LEAVE()
    b420:	a806      	add	r0, sp, #24
    b422:	47d8      	blx	fp
			for (uint8_t j=0; j<grid_core_state.bank_list[0].element_list[i].event_list_length; j++){
    b424:	3601      	adds	r6, #1
    b426:	686b      	ldr	r3, [r5, #4]
    b428:	68db      	ldr	r3, [r3, #12]
    b42a:	4423      	add	r3, r4
    b42c:	fa5f f986 	uxtb.w	r9, r6
    b430:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    b434:	454b      	cmp	r3, r9
    b436:	d8c7      	bhi.n	b3c8 <grid_port_process_ui+0x314>
		for (uint8_t i=0; i<grid_core_state.bank_list[0].element_list_length; i++){
    b438:	3701      	adds	r7, #1
    b43a:	e77f      	b.n	b33c <grid_port_process_ui+0x288>
					if (grid_msg_packet_get_length(&message)>GRID_PARAMETER_PACKET_marign){
    b43c:	4b41      	ldr	r3, [pc, #260]	; (b544 <grid_port_process_ui+0x490>)
    b43e:	a86f      	add	r0, sp, #444	; 0x1bc
    b440:	4798      	blx	r3
    b442:	28c8      	cmp	r0, #200	; 0xc8
    b444:	d82e      	bhi.n	b4a4 <grid_port_process_ui+0x3f0>
						CRITICAL_SECTION_ENTER()
    b446:	4b40      	ldr	r3, [pc, #256]	; (b548 <grid_port_process_ui+0x494>)
    b448:	a80b      	add	r0, sp, #44	; 0x2c
    b44a:	4798      	blx	r3
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b44c:	f8da 3004 	ldr.w	r3, [sl, #4]
    b450:	4423      	add	r3, r4
    b452:	22bc      	movs	r2, #188	; 0xbc
    b454:	68db      	ldr	r3, [r3, #12]
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b456:	442b      	add	r3, r5
						if (grid_ui_event_istriggered(&grid_ui_state.bank_list[i].element_list[j].event_list[k])){
    b458:	fb02 f909 	mul.w	r9, r2, r9
	if (eve->trigger == GRID_UI_STATUS_TRIGGERED){
    b45c:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b45e:	444b      	add	r3, r9
    b460:	7a5b      	ldrb	r3, [r3, #9]
    b462:	2b05      	cmp	r3, #5
    b464:	d11c      	bne.n	b4a0 <grid_port_process_ui+0x3ec>
							uint32_t offset = grid_msg_body_get_length(&message); 
    b466:	4b39      	ldr	r3, [pc, #228]	; (b54c <grid_port_process_ui+0x498>)
    b468:	a86f      	add	r0, sp, #444	; 0x1bc
    b46a:	4798      	blx	r3
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    b46c:	f8da 3004 	ldr.w	r3, [sl, #4]
    b470:	4423      	add	r3, r4
    b472:	3014      	adds	r0, #20
    b474:	68db      	ldr	r3, [r3, #12]
    b476:	442b      	add	r3, r5
    b478:	aa6f      	add	r2, sp, #444	; 0x1bc
    b47a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b47c:	1811      	adds	r1, r2, r0
    b47e:	eb03 0009 	add.w	r0, r3, r9
    b482:	4b33      	ldr	r3, [pc, #204]	; (b550 <grid_port_process_ui+0x49c>)
    b484:	4798      	blx	r3
    b486:	9bd4      	ldr	r3, [sp, #848]	; 0x350
    b488:	4418      	add	r0, r3
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    b48a:	f8da 3004 	ldr.w	r3, [sl, #4]
							message.body_length += grid_ui_event_render_action(&grid_ui_state.bank_list[i].element_list[j].event_list[k], &message.body[offset]);
    b48e:	90d4      	str	r0, [sp, #848]	; 0x350
							grid_ui_event_reset(&grid_ui_state.bank_list[i].element_list[j].event_list[k]);
    b490:	4423      	add	r3, r4
    b492:	68db      	ldr	r3, [r3, #12]
	eve->trigger = GRID_UI_STATUS_READY;
    b494:	442b      	add	r3, r5
    b496:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    b498:	4499      	add	r9, r3
    b49a:	2304      	movs	r3, #4
    b49c:	f889 3009 	strb.w	r3, [r9, #9]
						CRITICAL_SECTION_LEAVE()
    b4a0:	a80b      	add	r0, sp, #44	; 0x2c
    b4a2:	47d8      	blx	fp
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    b4a4:	f108 0801 	add.w	r8, r8, #1
    b4a8:	f8da 3004 	ldr.w	r3, [sl, #4]
    b4ac:	4423      	add	r3, r4
    b4ae:	fa5f f988 	uxtb.w	r9, r8
    b4b2:	68db      	ldr	r3, [r3, #12]
    b4b4:	442b      	add	r3, r5
    b4b6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
    b4ba:	454b      	cmp	r3, r9
    b4bc:	d8be      	bhi.n	b43c <grid_port_process_ui+0x388>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    b4be:	3601      	adds	r6, #1
    b4c0:	f8da 3004 	ldr.w	r3, [sl, #4]
    b4c4:	4423      	add	r3, r4
    b4c6:	7a5a      	ldrb	r2, [r3, #9]
    b4c8:	b2f3      	uxtb	r3, r6
    b4ca:	429a      	cmp	r2, r3
    b4cc:	d906      	bls.n	b4dc <grid_port_process_ui+0x428>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    b4ce:	2564      	movs	r5, #100	; 0x64
						CRITICAL_SECTION_LEAVE()
    b4d0:	f8df b094 	ldr.w	fp, [pc, #148]	; b568 <grid_port_process_ui+0x4b4>
				for (uint8_t k=0; k<grid_ui_state.bank_list[i].element_list[j].event_list_length; k++){ //j=1 because init is local
    b4d4:	435d      	muls	r5, r3
    b4d6:	f04f 0800 	mov.w	r8, #0
    b4da:	e7e5      	b.n	b4a8 <grid_port_process_ui+0x3f4>
		for (uint8_t i=0; i<grid_ui_state.bank_list_length; i++){
    b4dc:	3701      	adds	r7, #1
    b4de:	f89a 3001 	ldrb.w	r3, [sl, #1]
    b4e2:	b2fc      	uxtb	r4, r7
    b4e4:	42a3      	cmp	r3, r4
    b4e6:	d904      	bls.n	b4f2 <grid_port_process_ui+0x43e>
			for (uint8_t j=0; j<grid_ui_state.bank_list[i].element_list_length; j++){
    b4e8:	0124      	lsls	r4, r4, #4
    b4ea:	2600      	movs	r6, #0
    b4ec:	e7e8      	b.n	b4c0 <grid_port_process_ui+0x40c>
    b4ee:	2700      	movs	r7, #0
    b4f0:	e7f5      	b.n	b4de <grid_port_process_ui+0x42a>
		por->cooldown += 10;
    b4f2:	9b01      	ldr	r3, [sp, #4]
    b4f4:	9a01      	ldr	r2, [sp, #4]
    b4f6:	681b      	ldr	r3, [r3, #0]
    b4f8:	330a      	adds	r3, #10
    b4fa:	6013      	str	r3, [r2, #0]
		grid_msg_packet_close(&message);
    b4fc:	a86f      	add	r0, sp, #444	; 0x1bc
    b4fe:	4b15      	ldr	r3, [pc, #84]	; (b554 <grid_port_process_ui+0x4a0>)
    b500:	4798      	blx	r3
		uint32_t length = grid_msg_packet_get_length(&message);
    b502:	4b10      	ldr	r3, [pc, #64]	; (b544 <grid_port_process_ui+0x490>)
    b504:	a86f      	add	r0, sp, #444	; 0x1bc
    b506:	4798      	blx	r3
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    b508:	4b13      	ldr	r3, [pc, #76]	; (b558 <grid_port_process_ui+0x4a4>)
		uint32_t length = grid_msg_packet_get_length(&message);
    b50a:	4604      	mov	r4, r0
		if (grid_buffer_write_init(&GRID_PORT_U.rx_buffer, length)){
    b50c:	b281      	uxth	r1, r0
    b50e:	4813      	ldr	r0, [pc, #76]	; (b55c <grid_port_process_ui+0x4a8>)
    b510:	4798      	blx	r3
    b512:	b988      	cbnz	r0, b538 <grid_port_process_ui+0x484>
}
    b514:	f50d 7d57 	add.w	sp, sp, #860	; 0x35c
    b518:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    b51c:	a86f      	add	r0, sp, #444	; 0x1bc
    b51e:	47b0      	blx	r6
    b520:	4601      	mov	r1, r0
    b522:	4638      	mov	r0, r7
    b524:	47c0      	blx	r8
			for(uint16_t i = 0; i<length; i++){
    b526:	b2a9      	uxth	r1, r5
    b528:	428c      	cmp	r4, r1
    b52a:	f105 0501 	add.w	r5, r5, #1
    b52e:	d8f5      	bhi.n	b51c <grid_port_process_ui+0x468>
			grid_buffer_write_acknowledge(&GRID_PORT_U.rx_buffer);
    b530:	4b0b      	ldr	r3, [pc, #44]	; (b560 <grid_port_process_ui+0x4ac>)
    b532:	480a      	ldr	r0, [pc, #40]	; (b55c <grid_port_process_ui+0x4a8>)
    b534:	4798      	blx	r3
		}
    b536:	e7ed      	b.n	b514 <grid_port_process_ui+0x460>
				grid_buffer_write_character(&GRID_PORT_U.rx_buffer, grid_msg_packet_send_char(&message, i));
    b538:	4e0a      	ldr	r6, [pc, #40]	; (b564 <grid_port_process_ui+0x4b0>)
    b53a:	4f08      	ldr	r7, [pc, #32]	; (b55c <grid_port_process_ui+0x4a8>)
    b53c:	f8df 802c 	ldr.w	r8, [pc, #44]	; b56c <grid_port_process_ui+0x4b8>
    b540:	2500      	movs	r5, #0
    b542:	e7f0      	b.n	b526 <grid_port_process_ui+0x472>
    b544:	00008e31 	.word	0x00008e31
    b548:	00012485 	.word	0x00012485
    b54c:	00008e3f 	.word	0x00008e3f
    b550:	0000aebd 	.word	0x0000aebd
    b554:	00009001 	.word	0x00009001
    b558:	000047f1 	.word	0x000047f1
    b55c:	2000ebe4 	.word	0x2000ebe4
    b560:	0000484d 	.word	0x0000484d
    b564:	00008fcb 	.word	0x00008fcb
    b568:	00012493 	.word	0x00012493
    b56c:	0000482d 	.word	0x0000482d

0000b570 <grid_usb_serial_bulkout_cb>:
	//grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	
	//cdcdf_acm_write(cdcdf_demo_buf, count); /* Echo data */
	return false;                           /* No error. */
}
    b570:	2000      	movs	r0, #0
    b572:	4770      	bx	lr

0000b574 <grid_usb_serial_statechange_cb>:

//	cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS); /* Another read */
	return false;                                                                                 /* No error. */
}
static bool grid_usb_serial_statechange_cb(usb_cdc_control_signal_t state)
{
    b574:	b513      	push	{r0, r1, r4, lr}
	
	//grid_sys_alert_set_alert(&grid_sys_state, 0,255,255,2,300);
	
	if (state.rs232.DTR || 1) {
		/* After connection the R/W callbacks can be registered */
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    b576:	4c06      	ldr	r4, [pc, #24]	; (b590 <grid_usb_serial_statechange_cb+0x1c>)
{
    b578:	f8ad 0004 	strh.w	r0, [sp, #4]
		cdcdf_acm_register_callback(CDCDF_ACM_CB_READ, (FUNC_PTR)grid_usb_serial_bulkout_cb);
    b57c:	4905      	ldr	r1, [pc, #20]	; (b594 <grid_usb_serial_statechange_cb+0x20>)
    b57e:	2000      	movs	r0, #0
    b580:	47a0      	blx	r4
		cdcdf_acm_register_callback(CDCDF_ACM_CB_WRITE, (FUNC_PTR)grid_usb_serial_bulkin_cb);
    b582:	4905      	ldr	r1, [pc, #20]	; (b598 <grid_usb_serial_statechange_cb+0x24>)
    b584:	2001      	movs	r0, #1
    b586:	47a0      	blx	r4
		/* Start Rx */
		//cdcdf_acm_read((uint8_t *)cdcdf_demo_buf, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);
	}
	return false; /* No error. */
}
    b588:	2000      	movs	r0, #0
    b58a:	b002      	add	sp, #8
    b58c:	bd10      	pop	{r4, pc}
    b58e:	bf00      	nop
    b590:	0000c6dd 	.word	0x0000c6dd
    b594:	0000b571 	.word	0x0000b571
    b598:	0000b5ed 	.word	0x0000b5ed

0000b59c <grid_usb_midi_bulkin_cb>:

	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
	return false;
}
static bool grid_usb_midi_bulkin_cb(const uint8_t ep, const enum usb_xfer_code rc, const uint32_t count)
{
    b59c:	b513      	push	{r0, r1, r4, lr}

	grid_sys_alert_set_alert(&grid_sys_state, 255,0,255,2,300);
    b59e:	2302      	movs	r3, #2
    b5a0:	f44f 7296 	mov.w	r2, #300	; 0x12c
    b5a4:	e9cd 3200 	strd	r3, r2, [sp]
    b5a8:	23ff      	movs	r3, #255	; 0xff
    b5aa:	4804      	ldr	r0, [pc, #16]	; (b5bc <grid_usb_midi_bulkin_cb+0x20>)
    b5ac:	4c04      	ldr	r4, [pc, #16]	; (b5c0 <grid_usb_midi_bulkin_cb+0x24>)
    b5ae:	2200      	movs	r2, #0
    b5b0:	4619      	mov	r1, r3
    b5b2:	47a0      	blx	r4
	return false;
}
    b5b4:	2000      	movs	r0, #0
    b5b6:	b002      	add	sp, #8
    b5b8:	bd10      	pop	{r4, pc}
    b5ba:	bf00      	nop
    b5bc:	2000f008 	.word	0x2000f008
    b5c0:	0000a123 	.word	0x0000a123

0000b5c4 <grid_usb_midi_bulkout_cb>:
{
    b5c4:	b513      	push	{r0, r1, r4, lr}
	grid_sys_alert_set_alert(&grid_sys_state, 255,255,0,2,300);
    b5c6:	2302      	movs	r3, #2
    b5c8:	f44f 7296 	mov.w	r2, #300	; 0x12c
    b5cc:	e9cd 3200 	strd	r3, r2, [sp]
    b5d0:	22ff      	movs	r2, #255	; 0xff
    b5d2:	4804      	ldr	r0, [pc, #16]	; (b5e4 <grid_usb_midi_bulkout_cb+0x20>)
    b5d4:	4c04      	ldr	r4, [pc, #16]	; (b5e8 <grid_usb_midi_bulkout_cb+0x24>)
    b5d6:	2300      	movs	r3, #0
    b5d8:	4611      	mov	r1, r2
    b5da:	47a0      	blx	r4
}
    b5dc:	2000      	movs	r0, #0
    b5de:	b002      	add	sp, #8
    b5e0:	bd10      	pop	{r4, pc}
    b5e2:	bf00      	nop
    b5e4:	2000f008 	.word	0x2000f008
    b5e8:	0000a123 	.word	0x0000a123

0000b5ec <grid_usb_serial_bulkin_cb>:
    b5ec:	2000      	movs	r0, #0
    b5ee:	4770      	bx	lr

0000b5f0 <grid_usb_serial_init>:
	cdcdf_acm_register_callback(CDCDF_ACM_CB_STATE_C, (FUNC_PTR)grid_usb_serial_statechange_cb);
    b5f0:	4901      	ldr	r1, [pc, #4]	; (b5f8 <grid_usb_serial_init+0x8>)
    b5f2:	4b02      	ldr	r3, [pc, #8]	; (b5fc <grid_usb_serial_init+0xc>)
    b5f4:	2003      	movs	r0, #3
    b5f6:	4718      	bx	r3
    b5f8:	0000b575 	.word	0x0000b575
    b5fc:	0000c6dd 	.word	0x0000c6dd

0000b600 <grid_keyboard_cleanup>:
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
	
	uint8_t changed_flag = 0;
	
	// Remove all inactive (released) keys
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b600:	2300      	movs	r3, #0
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    b602:	b5f0      	push	{r4, r5, r6, r7, lr}
			
			changed_flag = 1;
			
			kb->key_list[i].ismodifier = 0;
			kb->key_list[i].ispressed = 0;
			kb->key_list[i].keycode = 255;	
    b604:	f04f 0cff 	mov.w	ip, #255	; 0xff
uint8_t grid_keyboard_cleanup(struct grid_keyboard_model* kb){
    b608:	4604      	mov	r4, r0
			// Pop item, move each remaining after this forvard one index
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
				
				kb->key_list[j-1] = kb->key_list[j];
				
				kb->key_list[j].ismodifier = 0;
    b60a:	469e      	mov	lr, r3
	uint8_t changed_flag = 0;
    b60c:	4618      	mov	r0, r3
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b60e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
    b612:	429d      	cmp	r5, r3
    b614:	d800      	bhi.n	b618 <grid_keyboard_cleanup+0x18>
		// USB SEND
	}
	
	return changed_flag;
	
}
    b616:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (kb->key_list[i].ispressed == false){
    b618:	eb04 01c3 	add.w	r1, r4, r3, lsl #3
    b61c:	7d8f      	ldrb	r7, [r1, #22]
    b61e:	b98f      	cbnz	r7, b644 <grid_keyboard_cleanup+0x44>
    b620:	1c5a      	adds	r2, r3, #1
    b622:	b2d6      	uxtb	r6, r2
			kb->key_list[i].ismodifier = 0;
    b624:	754f      	strb	r7, [r1, #21]
			kb->key_list[i].ispressed = 0;
    b626:	758f      	strb	r7, [r1, #22]
			kb->key_list[i].keycode = 255;	
    b628:	f881 c014 	strb.w	ip, [r1, #20]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b62c:	eb04 02c6 	add.w	r2, r4, r6, lsl #3
    b630:	42b5      	cmp	r5, r6
    b632:	f102 0208 	add.w	r2, r2, #8
    b636:	d108      	bne.n	b64a <grid_keyboard_cleanup+0x4a>
			kb->key_active_count--;
    b638:	3d01      	subs	r5, #1
			i--; // Retest this index, because it now points to a new item
    b63a:	3b01      	subs	r3, #1
			kb->key_active_count--;
    b63c:	f884 5044 	strb.w	r5, [r4, #68]	; 0x44
			i--; // Retest this index, because it now points to a new item
    b640:	b2db      	uxtb	r3, r3
			changed_flag = 1;
    b642:	2001      	movs	r0, #1
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b644:	3301      	adds	r3, #1
    b646:	b2db      	uxtb	r3, r3
    b648:	e7e1      	b.n	b60e <grid_keyboard_cleanup+0xe>
				kb->key_list[j-1] = kb->key_list[j];
    b64a:	e9d2 0103 	ldrd	r0, r1, [r2, #12]
    b64e:	1d17      	adds	r7, r2, #4
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b650:	3601      	adds	r6, #1
				kb->key_list[j-1] = kb->key_list[j];
    b652:	e887 0003 	stmia.w	r7, {r0, r1}
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b656:	b2f6      	uxtb	r6, r6
				kb->key_list[j].ismodifier = 0;
    b658:	f882 e00d 	strb.w	lr, [r2, #13]
				kb->key_list[j].ispressed = 0;
    b65c:	f882 e00e 	strb.w	lr, [r2, #14]
				kb->key_list[j].keycode = 255;
    b660:	f882 c00c 	strb.w	ip, [r2, #12]
			for (uint8_t j=i+1; j<kb->key_active_count; j++){
    b664:	e7e4      	b.n	b630 <grid_keyboard_cleanup+0x30>
	...

0000b668 <grid_keyboard_keychange>:


uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    b668:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    b66c:	4604      	mov	r4, r0
	uint8_t item_index = 255;
	uint8_t remove_flag = 0;
	uint8_t changed_flag = 0;
	

	grid_keyboard_cleanup(kb);
    b66e:	f8df 814c 	ldr.w	r8, [pc, #332]	; b7bc <grid_keyboard_keychange+0x154>
uint8_t grid_keyboard_keychange(struct grid_keyboard_model* kb, struct grid_keyboard_event_desc* key){
    b672:	b0ec      	sub	sp, #432	; 0x1b0
    b674:	460d      	mov	r5, r1
	grid_keyboard_cleanup(kb);
    b676:	47c0      	blx	r8
	

	for(uint8_t i=0; i<kb->key_active_count; i++){
    b678:	2200      	movs	r2, #0
    b67a:	f894 c044 	ldrb.w	ip, [r4, #68]	; 0x44
    b67e:	4626      	mov	r6, r4
    b680:	4623      	mov	r3, r4
	uint8_t changed_flag = 0;
    b682:	4691      	mov	r9, r2
	uint8_t item_index = 255;
    b684:	27ff      	movs	r7, #255	; 0xff
				if (key->ispressed == true){
					// OK nothing to do here
				}
				else{
					// Release the damn key
					kb->key_list[i].ispressed = false;
    b686:	4696      	mov	lr, r2
    b688:	b2d1      	uxtb	r1, r2
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b68a:	458c      	cmp	ip, r1
    b68c:	d82e      	bhi.n	b6ec <grid_keyboard_keychange+0x84>
		}
		
	}
	
	
	uint8_t print_happened = grid_keyboard_cleanup(kb);
    b68e:	4620      	mov	r0, r4
    b690:	47c0      	blx	r8
	
	
	if (item_index == 255){
    b692:	2fff      	cmp	r7, #255	; 0xff
    b694:	d143      	bne.n	b71e <grid_keyboard_keychange+0xb6>
		
		// item not in list
		
		if (kb->key_active_count< GRID_KEYBOARD_KEY_maxcount){
    b696:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    b69a:	2b05      	cmp	r3, #5
    b69c:	d83f      	bhi.n	b71e <grid_keyboard_keychange+0xb6>
			
			if (key->ispressed == true){
    b69e:	78aa      	ldrb	r2, [r5, #2]
    b6a0:	2a01      	cmp	r2, #1
    b6a2:	d13c      	bne.n	b71e <grid_keyboard_keychange+0xb6>
				
				kb->key_list[kb->key_active_count] = *key;
    b6a4:	e895 0003 	ldmia.w	r5, {r0, r1}
    b6a8:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
    b6ac:	3214      	adds	r2, #20
				kb->key_active_count++;
    b6ae:	3301      	adds	r3, #1
				kb->key_list[kb->key_active_count] = *key;
    b6b0:	e882 0003 	stmia.w	r2, {r0, r1}
				kb->key_active_count++;
    b6b4:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		}
		
	}
	
	
	if (changed_flag == 1){
    b6b8:	f104 0112 	add.w	r1, r4, #18
	uint8_t item_index = 255;
    b6bc:	4623      	mov	r3, r4
//		}
			
		
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
		
			kb->hid_key_array[i].b_modifier = kb->key_list[i].ismodifier;
    b6be:	7d72      	ldrb	r2, [r6, #21]
    b6c0:	3a00      	subs	r2, #0
    b6c2:	bf18      	it	ne
    b6c4:	2201      	movne	r2, #1
    b6c6:	705a      	strb	r2, [r3, #1]
			kb->hid_key_array[i].key_id = kb->key_list[i].keycode;
    b6c8:	7d32      	ldrb	r2, [r6, #20]
    b6ca:	701a      	strb	r2, [r3, #0]
			kb->hid_key_array[i].state = kb->key_list[i].ispressed;
    b6cc:	7db2      	ldrb	r2, [r6, #22]
    b6ce:	709a      	strb	r2, [r3, #2]
		for(uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++){
    b6d0:	3303      	adds	r3, #3
    b6d2:	428b      	cmp	r3, r1
    b6d4:	f106 0608 	add.w	r6, r6, #8
    b6d8:	d1f1      	bne.n	b6be <grid_keyboard_keychange+0x56>
		
		}
        
        
        if (kb->isenabled){
    b6da:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    b6de:	b325      	cbz	r5, b72a <grid_keyboard_keychange+0xc2>
            
            
    		hiddf_keyboard_keys_state_change(kb->hid_key_array, kb->key_active_count);    
    b6e0:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
    b6e4:	4b2b      	ldr	r3, [pc, #172]	; (b794 <grid_keyboard_keychange+0x12c>)
    b6e6:	4620      	mov	r0, r4
    b6e8:	4798      	blx	r3
    b6ea:	e01b      	b.n	b724 <grid_keyboard_keychange+0xbc>
		if (kb->key_list[i].keycode == key->keycode && kb->key_list[i].ismodifier == key->ismodifier){
    b6ec:	f893 a014 	ldrb.w	sl, [r3, #20]
    b6f0:	7828      	ldrb	r0, [r5, #0]
    b6f2:	4582      	cmp	sl, r0
    b6f4:	d111      	bne.n	b71a <grid_keyboard_keychange+0xb2>
    b6f6:	f893 a015 	ldrb.w	sl, [r3, #21]
    b6fa:	7868      	ldrb	r0, [r5, #1]
    b6fc:	4582      	cmp	sl, r0
    b6fe:	d10c      	bne.n	b71a <grid_keyboard_keychange+0xb2>
			if (kb->key_list[i].ispressed == true){
    b700:	7d98      	ldrb	r0, [r3, #22]
    b702:	2801      	cmp	r0, #1
    b704:	d105      	bne.n	b712 <grid_keyboard_keychange+0xaa>
				if (key->ispressed == true){
    b706:	78af      	ldrb	r7, [r5, #2]
    b708:	2f01      	cmp	r7, #1
    b70a:	d002      	beq.n	b712 <grid_keyboard_keychange+0xaa>
					kb->key_list[i].ispressed = false;
    b70c:	f883 e016 	strb.w	lr, [r3, #22]
					changed_flag = 1;
    b710:	4681      	mov	r9, r0
	for(uint8_t i=0; i<kb->key_active_count; i++){
    b712:	3201      	adds	r2, #1
    b714:	3308      	adds	r3, #8
	uint8_t item_index = 255;
    b716:	460f      	mov	r7, r1
    b718:	e7b6      	b.n	b688 <grid_keyboard_keychange+0x20>
    b71a:	4639      	mov	r1, r7
    b71c:	e7f9      	b.n	b712 <grid_keyboard_keychange+0xaa>
	if (changed_flag == 1){
    b71e:	f1b9 0f00 	cmp.w	r9, #0
    b722:	d1c9      	bne.n	b6b8 <grid_keyboard_keychange+0x50>
		
		
		// USB SEND
	}
	
}
    b724:	b06c      	add	sp, #432	; 0x1b0
    b726:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            grid_msg_init(&response);
    b72a:	a805      	add	r0, sp, #20
    b72c:	4b1a      	ldr	r3, [pc, #104]	; (b798 <grid_keyboard_keychange+0x130>)
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b72e:	4e1b      	ldr	r6, [pc, #108]	; (b79c <grid_keyboard_keychange+0x134>)
            grid_msg_init(&response);
    b730:	4798      	blx	r3
            grid_msg_init_header(&response, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_POSITION, GRID_SYS_DEFAULT_ROTATION);
    b732:	227f      	movs	r2, #127	; 0x7f
    b734:	462b      	mov	r3, r5
    b736:	4611      	mov	r1, r2
    b738:	a805      	add	r0, sp, #20
    b73a:	47b0      	blx	r6
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    b73c:	2303      	movs	r3, #3
    b73e:	4918      	ldr	r1, [pc, #96]	; (b7a0 <grid_keyboard_keychange+0x138>)
    b740:	9300      	str	r3, [sp, #0]
    b742:	2202      	movs	r2, #2
    b744:	4e17      	ldr	r6, [pc, #92]	; (b7a4 <grid_keyboard_keychange+0x13c>)
            uint8_t response_payload[10] = {0};
    b746:	f8ad 5010 	strh.w	r5, [sp, #16]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    b74a:	2392      	movs	r3, #146	; 0x92
    b74c:	a802      	add	r0, sp, #8
            uint8_t response_payload[10] = {0};
    b74e:	e9cd 5502 	strd	r5, r5, [sp, #8]
            sprintf(response_payload, GRID_CLASS_HIDKEYSTATUS_frame);
    b752:	47b0      	blx	r6
            grid_msg_body_append_text(&response, response_payload, strlen(response_payload));
    b754:	4b14      	ldr	r3, [pc, #80]	; (b7a8 <grid_keyboard_keychange+0x140>)
    b756:	a802      	add	r0, sp, #8
    b758:	4798      	blx	r3
    b75a:	a902      	add	r1, sp, #8
    b75c:	4602      	mov	r2, r0
    b75e:	4b13      	ldr	r3, [pc, #76]	; (b7ac <grid_keyboard_keychange+0x144>)
    b760:	a805      	add	r0, sp, #20
    b762:	4798      	blx	r3
            grid_msg_text_set_parameter(&response, 0, GRID_CLASS_HIDKEYSTATUS_ISENABLED_offset, GRID_CLASS_HIDKEYSTATUS_ISENABLED_length, kb->isenabled);
    b764:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    b768:	9300      	str	r3, [sp, #0]
    b76a:	4c11      	ldr	r4, [pc, #68]	; (b7b0 <grid_keyboard_keychange+0x148>)
    b76c:	4629      	mov	r1, r5
    b76e:	a805      	add	r0, sp, #20
    b770:	2302      	movs	r3, #2
    b772:	2205      	movs	r2, #5
    b774:	47a0      	blx	r4
            grid_msg_text_set_parameter(&response, 0, GRID_INSTR_offset, GRID_INSTR_length, GRID_INSTR_REPORT_code);
    b776:	230d      	movs	r3, #13
    b778:	9300      	str	r3, [sp, #0]
    b77a:	2204      	movs	r2, #4
    b77c:	4629      	mov	r1, r5
    b77e:	a805      	add	r0, sp, #20
    b780:	2301      	movs	r3, #1
    b782:	47a0      	blx	r4
            grid_msg_packet_close(&response);
    b784:	4b0b      	ldr	r3, [pc, #44]	; (b7b4 <grid_keyboard_keychange+0x14c>)
    b786:	a805      	add	r0, sp, #20
    b788:	4798      	blx	r3
            grid_msg_packet_send_everywhere(&response);
    b78a:	4b0b      	ldr	r3, [pc, #44]	; (b7b8 <grid_keyboard_keychange+0x150>)
    b78c:	a805      	add	r0, sp, #20
    b78e:	4798      	blx	r3
    b790:	e7c8      	b.n	b724 <grid_keyboard_keychange+0xbc>
    b792:	bf00      	nop
    b794:	0000f3fd 	.word	0x0000f3fd
    b798:	00008ed5 	.word	0x00008ed5
    b79c:	00008f09 	.word	0x00008f09
    b7a0:	000166d8 	.word	0x000166d8
    b7a4:	00015299 	.word	0x00015299
    b7a8:	00015317 	.word	0x00015317
    b7ac:	00008e45 	.word	0x00008e45
    b7b0:	00008eb9 	.word	0x00008eb9
    b7b4:	00009001 	.word	0x00009001
    b7b8:	000090d5 	.word	0x000090d5
    b7bc:	0000b601 	.word	0x0000b601

0000b7c0 <grid_midi_buffer_init>:



void grid_midi_buffer_init(struct grid_midi_event_desc* buf, uint16_t length){
    b7c0:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    b7c2:	2300      	movs	r3, #0
	{
		buf[i].byte0 = 0;
    b7c4:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    b7c6:	b29c      	uxth	r4, r3
    b7c8:	42a1      	cmp	r1, r4
    b7ca:	f100 0004 	add.w	r0, r0, #4
    b7ce:	d800      	bhi.n	b7d2 <grid_midi_buffer_init+0x12>
		buf[i].byte1 = 0;
		buf[i].byte2 = 0;
		buf[i].byte3 = 0;
	}
	
}
    b7d0:	bd10      	pop	{r4, pc}
		buf[i].byte0 = 0;
    b7d2:	f800 2c04 	strb.w	r2, [r0, #-4]
		buf[i].byte1 = 0;
    b7d6:	f800 2c03 	strb.w	r2, [r0, #-3]
		buf[i].byte2 = 0;
    b7da:	f800 2c02 	strb.w	r2, [r0, #-2]
		buf[i].byte3 = 0;
    b7de:	f800 2c01 	strb.w	r2, [r0, #-1]
	for (uint16_t i=0; i<length; i++)
    b7e2:	3301      	adds	r3, #1
    b7e4:	e7ef      	b.n	b7c6 <grid_midi_buffer_init+0x6>
	...

0000b7e8 <grid_usb_midi_init>:
	grid_midi_tx_write_index = 0;
    b7e8:	4b0a      	ldr	r3, [pc, #40]	; (b814 <grid_usb_midi_init+0x2c>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    b7ea:	480b      	ldr	r0, [pc, #44]	; (b818 <grid_usb_midi_init+0x30>)
{
    b7ec:	b510      	push	{r4, lr}
	grid_midi_tx_write_index = 0;
    b7ee:	2400      	movs	r4, #0
    b7f0:	801c      	strh	r4, [r3, #0]
	grid_midi_tx_read_index = 0;
    b7f2:	4b0a      	ldr	r3, [pc, #40]	; (b81c <grid_usb_midi_init+0x34>)
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    b7f4:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_midi_tx_read_index = 0;
    b7f8:	801c      	strh	r4, [r3, #0]
	grid_midi_buffer_init(grid_midi_tx_buffer, GRID_MIDI_TX_BUFFER_length);
    b7fa:	4b09      	ldr	r3, [pc, #36]	; (b820 <grid_usb_midi_init+0x38>)
    b7fc:	4798      	blx	r3
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_READ, (FUNC_PTR)grid_usb_midi_bulkout_cb);
    b7fe:	4620      	mov	r0, r4
    b800:	4c08      	ldr	r4, [pc, #32]	; (b824 <grid_usb_midi_init+0x3c>)
    b802:	4909      	ldr	r1, [pc, #36]	; (b828 <grid_usb_midi_init+0x40>)
    b804:	47a0      	blx	r4
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    b806:	4623      	mov	r3, r4
    b808:	4908      	ldr	r1, [pc, #32]	; (b82c <grid_usb_midi_init+0x44>)
}
    b80a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	audiodf_midi_register_callback(AUDIODF_MIDI_CB_WRITE, (FUNC_PTR)grid_usb_midi_bulkin_cb);
    b80e:	2001      	movs	r0, #1
    b810:	4718      	bx	r3
    b812:	bf00      	nop
    b814:	2000c0a4 	.word	0x2000c0a4
    b818:	20013420 	.word	0x20013420
    b81c:	20010260 	.word	0x20010260
    b820:	0000b7c1 	.word	0x0000b7c1
    b824:	0000453d 	.word	0x0000453d
    b828:	0000b5c5 	.word	0x0000b5c5
    b82c:	0000b59d 	.word	0x0000b59d

0000b830 <grid_midi_tx_push>:

uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){


	grid_midi_tx_buffer[grid_midi_tx_write_index] = midi_event;
    b830:	4907      	ldr	r1, [pc, #28]	; (b850 <grid_midi_tx_push+0x20>)
    b832:	4a08      	ldr	r2, [pc, #32]	; (b854 <grid_midi_tx_push+0x24>)
    b834:	880b      	ldrh	r3, [r1, #0]
    b836:	f842 0023 	str.w	r0, [r2, r3, lsl #2]

	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    b83a:	f44f 7096 	mov.w	r0, #300	; 0x12c
    b83e:	3301      	adds	r3, #1
uint8_t grid_midi_tx_push(struct grid_midi_event_desc midi_event){
    b840:	b082      	sub	sp, #8
	grid_midi_tx_write_index = (grid_midi_tx_write_index+1)%GRID_MIDI_TX_BUFFER_length;
    b842:	fbb3 f2f0 	udiv	r2, r3, r0
    b846:	fb00 3312 	mls	r3, r0, r2, r3
    b84a:	800b      	strh	r3, [r1, #0]




}
    b84c:	b002      	add	sp, #8
    b84e:	4770      	bx	lr
    b850:	2000c0a4 	.word	0x2000c0a4
    b854:	20013420 	.word	0x20013420

0000b858 <grid_midi_tx_pop>:

uint8_t grid_midi_tx_pop(){
    b858:	b538      	push	{r3, r4, r5, lr}

	if (grid_midi_tx_read_index != grid_midi_tx_write_index){
    b85a:	4c0f      	ldr	r4, [pc, #60]	; (b898 <grid_midi_tx_pop+0x40>)
    b85c:	4b0f      	ldr	r3, [pc, #60]	; (b89c <grid_midi_tx_pop+0x44>)
    b85e:	8822      	ldrh	r2, [r4, #0]
    b860:	881b      	ldrh	r3, [r3, #0]
    b862:	429a      	cmp	r2, r3
    b864:	d017      	beq.n	b896 <grid_midi_tx_pop+0x3e>
		
		if (audiodf_midi_write_status() != USB_BUSY){
    b866:	4b0e      	ldr	r3, [pc, #56]	; (b8a0 <grid_midi_tx_pop+0x48>)
    b868:	4798      	blx	r3
    b86a:	2801      	cmp	r0, #1
    b86c:	d013      	beq.n	b896 <grid_midi_tx_pop+0x3e>

			uint8_t byte0 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte0;
    b86e:	8825      	ldrh	r5, [r4, #0]
			uint8_t byte1 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte1;
			uint8_t byte2 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte2;
			uint8_t byte3 = grid_midi_tx_buffer[grid_midi_tx_read_index].byte3;
    b870:	480c      	ldr	r0, [pc, #48]	; (b8a4 <grid_midi_tx_pop+0x4c>)
    b872:	eb00 0185 	add.w	r1, r0, r5, lsl #2
			
			audiodf_midi_write(byte0, byte1, byte2, byte3);
    b876:	f810 0025 	ldrb.w	r0, [r0, r5, lsl #2]
    b87a:	78cb      	ldrb	r3, [r1, #3]
    b87c:	788a      	ldrb	r2, [r1, #2]
    b87e:	4d0a      	ldr	r5, [pc, #40]	; (b8a8 <grid_midi_tx_pop+0x50>)
    b880:	7849      	ldrb	r1, [r1, #1]
    b882:	47a8      	blx	r5

			grid_midi_tx_read_index = (grid_midi_tx_read_index+1)%GRID_MIDI_TX_BUFFER_length;
    b884:	8823      	ldrh	r3, [r4, #0]
    b886:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b88a:	3301      	adds	r3, #1
    b88c:	fbb3 f2f1 	udiv	r2, r3, r1
    b890:	fb01 3312 	mls	r3, r1, r2, r3
    b894:	8023      	strh	r3, [r4, #0]

		}
		
	}

}
    b896:	bd38      	pop	{r3, r4, r5, pc}
    b898:	20010260 	.word	0x20010260
    b89c:	2000c0a4 	.word	0x2000c0a4
    b8a0:	00004501 	.word	0x00004501
    b8a4:	20013420 	.word	0x20013420
    b8a8:	000044d9 	.word	0x000044d9

0000b8ac <grid_keyboard_buffer_init>:


void grid_keyboard_buffer_init(struct grid_keyboard_event_desc* buf, uint16_t length){
    b8ac:	b510      	push	{r4, lr}
	
	
	for (uint16_t i=0; i<length; i++)
    b8ae:	2300      	movs	r3, #0
	{
		buf[i].ismodifier = 0;
    b8b0:	461a      	mov	r2, r3
	for (uint16_t i=0; i<length; i++)
    b8b2:	b29c      	uxth	r4, r3
    b8b4:	42a1      	cmp	r1, r4
    b8b6:	f100 0008 	add.w	r0, r0, #8
    b8ba:	d800      	bhi.n	b8be <grid_keyboard_buffer_init+0x12>
		buf[i].keycode = 0;
		buf[i].ispressed = 0;
		buf[i].delay = 0;
	}
	
}
    b8bc:	bd10      	pop	{r4, pc}
		buf[i].ismodifier = 0;
    b8be:	f800 2c07 	strb.w	r2, [r0, #-7]
		buf[i].keycode = 0;
    b8c2:	f800 2c08 	strb.w	r2, [r0, #-8]
		buf[i].ispressed = 0;
    b8c6:	f800 2c06 	strb.w	r2, [r0, #-6]
		buf[i].delay = 0;
    b8ca:	f840 2c04 	str.w	r2, [r0, #-4]
	for (uint16_t i=0; i<length; i++)
    b8ce:	3301      	adds	r3, #1
    b8d0:	e7ef      	b.n	b8b2 <grid_keyboard_buffer_init+0x6>
	...

0000b8d4 <grid_keyboard_init>:
void grid_keyboard_init(struct grid_keyboard_model* kb){
    b8d4:	b570      	push	{r4, r5, r6, lr}
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b8d6:	4b13      	ldr	r3, [pc, #76]	; (b924 <grid_keyboard_init+0x50>)
void grid_keyboard_init(struct grid_keyboard_model* kb){
    b8d8:	4605      	mov	r5, r0
    grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b8da:	4813      	ldr	r0, [pc, #76]	; (b928 <grid_keyboard_init+0x54>)
    b8dc:	4798      	blx	r3
    b8de:	4b13      	ldr	r3, [pc, #76]	; (b92c <grid_keyboard_init+0x58>)
    b8e0:	6018      	str	r0, [r3, #0]
    grid_keyboard_tx_write_index = 0;
    b8e2:	4b13      	ldr	r3, [pc, #76]	; (b930 <grid_keyboard_init+0x5c>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b8e4:	4813      	ldr	r0, [pc, #76]	; (b934 <grid_keyboard_init+0x60>)
    grid_keyboard_tx_write_index = 0;
    b8e6:	2400      	movs	r4, #0
    b8e8:	801c      	strh	r4, [r3, #0]
	grid_keyboard_tx_read_index = 0;
    b8ea:	4b13      	ldr	r3, [pc, #76]	; (b938 <grid_keyboard_init+0x64>)
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b8ec:	f44f 7196 	mov.w	r1, #300	; 0x12c
	grid_keyboard_tx_read_index = 0;
    b8f0:	801c      	strh	r4, [r3, #0]
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b8f2:	4b12      	ldr	r3, [pc, #72]	; (b93c <grid_keyboard_init+0x68>)
    b8f4:	4798      	blx	r3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b8f6:	f105 0612 	add.w	r6, r5, #18
    b8fa:	462a      	mov	r2, r5
	grid_keyboard_buffer_init(grid_keyboard_tx_buffer, GRID_KEYBOARD_TX_BUFFER_length);
    b8fc:	4629      	mov	r1, r5
		kb->hid_key_array[i].b_modifier = false;
    b8fe:	4623      	mov	r3, r4
		kb->hid_key_array[i].key_id = 255;
    b900:	20ff      	movs	r0, #255	; 0xff
		kb->hid_key_array[i].b_modifier = false;
    b902:	7053      	strb	r3, [r2, #1]
		kb->hid_key_array[i].key_id = 255;
    b904:	7010      	strb	r0, [r2, #0]
		kb->hid_key_array[i].state = HID_KB_KEY_UP;
    b906:	7093      	strb	r3, [r2, #2]
		kb->key_list[i].ismodifier = 0;
    b908:	3203      	adds	r2, #3
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b90a:	42b2      	cmp	r2, r6
		kb->key_list[i].ismodifier = 0;
    b90c:	754b      	strb	r3, [r1, #21]
		kb->key_list[i].ispressed = 0;
    b90e:	758b      	strb	r3, [r1, #22]
		kb->key_list[i].keycode = 255;
    b910:	7508      	strb	r0, [r1, #20]
	for (uint8_t i=0; i<GRID_KEYBOARD_KEY_maxcount; i++)
    b912:	f101 0108 	add.w	r1, r1, #8
    b916:	d1f4      	bne.n	b902 <grid_keyboard_init+0x2e>
	kb->key_active_count = 0;
    b918:	f44f 7380 	mov.w	r3, #256	; 0x100
    b91c:	f8a5 3044 	strh.w	r3, [r5, #68]	; 0x44
}
    b920:	bd70      	pop	{r4, r5, r6, pc}
    b922:	bf00      	nop
    b924:	0000a0b9 	.word	0x0000a0b9
    b928:	2000f008 	.word	0x2000f008
    b92c:	2001c7cc 	.word	0x2001c7cc
    b930:	2000f0b8 	.word	0x2000f0b8
    b934:	2000f0bc 	.word	0x2000f0bc
    b938:	200102ac 	.word	0x200102ac
    b93c:	0000b8ad 	.word	0x0000b8ad

0000b940 <grid_keyboard_tx_push>:

uint8_t grid_keyboard_tx_push(struct grid_keyboard_event_desc keyboard_event){
    b940:	b537      	push	{r0, r1, r2, r4, r5, lr}
    b942:	466c      	mov	r4, sp
    b944:	e884 0003 	stmia.w	r4, {r0, r1}


	grid_keyboard_tx_buffer[grid_keyboard_tx_write_index] = keyboard_event;
    b948:	4d09      	ldr	r5, [pc, #36]	; (b970 <grid_keyboard_tx_push+0x30>)
    b94a:	4a0a      	ldr	r2, [pc, #40]	; (b974 <grid_keyboard_tx_push+0x34>)
    b94c:	882b      	ldrh	r3, [r5, #0]
    b94e:	e894 0003 	ldmia.w	r4, {r0, r1}
    b952:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
    b956:	e882 0003 	stmia.w	r2, {r0, r1}

	grid_keyboard_tx_write_index = (grid_keyboard_tx_write_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b95a:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b95e:	3301      	adds	r3, #1
    b960:	fbb3 f2f1 	udiv	r2, r3, r1
    b964:	fb01 3312 	mls	r3, r1, r2, r3
    b968:	802b      	strh	r3, [r5, #0]



}
    b96a:	b003      	add	sp, #12
    b96c:	bd30      	pop	{r4, r5, pc}
    b96e:	bf00      	nop
    b970:	2000f0b8 	.word	0x2000f0b8
    b974:	2000f0bc 	.word	0x2000f0bc

0000b978 <grid_keyboard_tx_pop>:

uint8_t grid_keyboard_tx_pop(){
    b978:	b573      	push	{r0, r1, r4, r5, r6, lr}

	if (grid_keyboard_tx_read_index != grid_keyboard_tx_write_index){
    b97a:	4b17      	ldr	r3, [pc, #92]	; (b9d8 <grid_keyboard_tx_pop+0x60>)
    b97c:	4c17      	ldr	r4, [pc, #92]	; (b9dc <grid_keyboard_tx_pop+0x64>)
    b97e:	881b      	ldrh	r3, [r3, #0]
    b980:	8822      	ldrh	r2, [r4, #0]
    b982:	429a      	cmp	r2, r3
    b984:	d026      	beq.n	b9d4 <grid_keyboard_tx_pop+0x5c>
		
        
        
        uint32_t elapsed = grid_sys_rtc_get_elapsed_time(&grid_sys_state, grid_keyboard_tx_rtc_lasttimestamp);
    b986:	4d16      	ldr	r5, [pc, #88]	; (b9e0 <grid_keyboard_tx_pop+0x68>)
    b988:	4b16      	ldr	r3, [pc, #88]	; (b9e4 <grid_keyboard_tx_pop+0x6c>)
    b98a:	6829      	ldr	r1, [r5, #0]
    b98c:	4816      	ldr	r0, [pc, #88]	; (b9e8 <grid_keyboard_tx_pop+0x70>)
    b98e:	4798      	blx	r3
        
        
		if (elapsed > grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].delay*RTC1MS){
    b990:	8822      	ldrh	r2, [r4, #0]
    b992:	4b16      	ldr	r3, [pc, #88]	; (b9ec <grid_keyboard_tx_pop+0x74>)
    b994:	eb03 01c2 	add.w	r1, r3, r2, lsl #3
    b998:	684e      	ldr	r6, [r1, #4]
    b99a:	ebb0 1f06 	cmp.w	r0, r6, lsl #4
    b99e:	d919      	bls.n	b9d4 <grid_keyboard_tx_pop+0x5c>
            
            struct grid_keyboard_event_desc key;
            
            key.ismodifier = grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ismodifier;
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b9a0:	f833 3032 	ldrh.w	r3, [r3, r2, lsl #3]
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b9a4:	7889      	ldrb	r1, [r1, #2]
            key.keycode =    grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].keycode;
    b9a6:	f8ad 3000 	strh.w	r3, [sp]
            key.delay = 0;
    b9aa:	2300      	movs	r3, #0
            key.ispressed =  grid_keyboard_tx_buffer[grid_keyboard_tx_read_index].ispressed;
    b9ac:	f88d 1002 	strb.w	r1, [sp, #2]
            key.delay = 0;
    b9b0:	9301      	str	r3, [sp, #4]
            
                  
            //grid_sys_alert_set_alert(&grid_sys_state, 255, 255, 255, 0, 50);
            
            grid_keyboard_keychange(&grid_keyboard_state, &key);
    b9b2:	4669      	mov	r1, sp
    b9b4:	4b0e      	ldr	r3, [pc, #56]	; (b9f0 <grid_keyboard_tx_pop+0x78>)
    b9b6:	480f      	ldr	r0, [pc, #60]	; (b9f4 <grid_keyboard_tx_pop+0x7c>)
    b9b8:	4798      	blx	r3

			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b9ba:	8823      	ldrh	r3, [r4, #0]
            
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b9bc:	480a      	ldr	r0, [pc, #40]	; (b9e8 <grid_keyboard_tx_pop+0x70>)
			grid_keyboard_tx_read_index = (grid_keyboard_tx_read_index+1)%GRID_KEYBOARD_TX_BUFFER_length;
    b9be:	f44f 7196 	mov.w	r1, #300	; 0x12c
    b9c2:	3301      	adds	r3, #1
    b9c4:	fbb3 f2f1 	udiv	r2, r3, r1
    b9c8:	fb01 3312 	mls	r3, r1, r2, r3
    b9cc:	8023      	strh	r3, [r4, #0]
            grid_keyboard_tx_rtc_lasttimestamp = grid_sys_rtc_get_time(&grid_sys_state);
    b9ce:	4b0a      	ldr	r3, [pc, #40]	; (b9f8 <grid_keyboard_tx_pop+0x80>)
    b9d0:	4798      	blx	r3
    b9d2:	6028      	str	r0, [r5, #0]

		}
		
	}

}
    b9d4:	b002      	add	sp, #8
    b9d6:	bd70      	pop	{r4, r5, r6, pc}
    b9d8:	2000f0b8 	.word	0x2000f0b8
    b9dc:	200102ac 	.word	0x200102ac
    b9e0:	2001c7cc 	.word	0x2001c7cc
    b9e4:	0000a0bd 	.word	0x0000a0bd
    b9e8:	2000f008 	.word	0x2000f008
    b9ec:	2000f0bc 	.word	0x2000f0bc
    b9f0:	0000b669 	.word	0x0000b669
    b9f4:	20010264 	.word	0x20010264
    b9f8:	0000a0b9 	.word	0x0000a0b9

0000b9fc <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    b9fc:	b570      	push	{r4, r5, r6, lr}
    b9fe:	460d      	mov	r5, r1
    ba00:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    ba02:	4604      	mov	r4, r0
    ba04:	b110      	cbz	r0, ba0c <io_write+0x10>
    ba06:	1e08      	subs	r0, r1, #0
    ba08:	bf18      	it	ne
    ba0a:	2001      	movne	r0, #1
    ba0c:	4905      	ldr	r1, [pc, #20]	; (ba24 <io_write+0x28>)
    ba0e:	4b06      	ldr	r3, [pc, #24]	; (ba28 <io_write+0x2c>)
    ba10:	2234      	movs	r2, #52	; 0x34
    ba12:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
    ba14:	6823      	ldr	r3, [r4, #0]
    ba16:	4632      	mov	r2, r6
    ba18:	4629      	mov	r1, r5
    ba1a:	4620      	mov	r0, r4
}
    ba1c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->write(io_descr, buf, length);
    ba20:	4718      	bx	r3
    ba22:	bf00      	nop
    ba24:	00016d58 	.word	0x00016d58
    ba28:	0000e9b9 	.word	0x0000e9b9

0000ba2c <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    ba2c:	b570      	push	{r4, r5, r6, lr}
    ba2e:	460d      	mov	r5, r1
    ba30:	4616      	mov	r6, r2
	ASSERT(io_descr && buf);
    ba32:	4604      	mov	r4, r0
    ba34:	b110      	cbz	r0, ba3c <io_read+0x10>
    ba36:	1e08      	subs	r0, r1, #0
    ba38:	bf18      	it	ne
    ba3a:	2001      	movne	r0, #1
    ba3c:	4905      	ldr	r1, [pc, #20]	; (ba54 <io_read+0x28>)
    ba3e:	4b06      	ldr	r3, [pc, #24]	; (ba58 <io_read+0x2c>)
    ba40:	223d      	movs	r2, #61	; 0x3d
    ba42:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
    ba44:	6863      	ldr	r3, [r4, #4]
    ba46:	4632      	mov	r2, r6
    ba48:	4629      	mov	r1, r5
    ba4a:	4620      	mov	r0, r4
}
    ba4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return io_descr->read(io_descr, buf, length);
    ba50:	4718      	bx	r3
    ba52:	bf00      	nop
    ba54:	00016d58 	.word	0x00016d58
    ba58:	0000e9b9 	.word	0x0000e9b9

0000ba5c <vListInitialise>:
void vListInitialise(List_t *const pxList)
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = (ListItem_t *)&(
    ba5c:	f100 0308 	add.w	r3, r0, #8
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    ba60:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = (ListItem_t *)&(pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as
    ba64:	e9c0 2302 	strd	r2, r3, [r0, #8]
	pxList->pxIndex = (ListItem_t *)&(
    ba68:	6043      	str	r3, [r0, #4]
	                                                                the list end to save RAM.  This is checked and
	                                                                valid. */
	pxList->xListEnd.pxPrevious = (ListItem_t *)&(
    ba6a:	6103      	str	r3, [r0, #16]
	    pxList->xListEnd); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is
	                          checked and valid. */

	pxList->uxNumberOfItems = (UBaseType_t)0U;
    ba6c:	2300      	movs	r3, #0
    ba6e:	6003      	str	r3, [r0, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE(pxList);
	listSET_LIST_INTEGRITY_CHECK_2_VALUE(pxList);
}
    ba70:	4770      	bx	lr

0000ba72 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem(ListItem_t *const pxItem)
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    ba72:	2300      	movs	r3, #0
    ba74:	6103      	str	r3, [r0, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE(pxItem);
}
    ba76:	4770      	bx	lr

0000ba78 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd(List_t *const pxList, ListItem_t *const pxNewListItem)
{
	ListItem_t *const pxIndex = pxList->pxIndex;
    ba78:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY(pxNewListItem);

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext     = pxIndex;
    ba7a:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    ba7c:	689a      	ldr	r2, [r3, #8]
    ba7e:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    ba80:	689a      	ldr	r2, [r3, #8]
    ba82:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious         = pxNewListItem;
    ba84:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    ba86:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    ba88:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    ba8a:	3301      	adds	r3, #1
    ba8c:	6003      	str	r3, [r0, #0]
}
    ba8e:	4770      	bx	lr

0000ba90 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert(List_t *const pxList, ListItem_t *const pxNewListItem)
{
    ba90:	b530      	push	{r4, r5, lr}
	ListItem_t *     pxIterator;
	const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    ba92:	680c      	ldr	r4, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if (xValueOfInsertion == portMAX_DELAY) {
    ba94:	1c63      	adds	r3, r4, #1
    ba96:	d10a      	bne.n	baae <vListInsert+0x1e>
		pxIterator = pxList->xListEnd.pxPrevious;
    ba98:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext             = pxIterator->pxNext;
    ba9a:	685a      	ldr	r2, [r3, #4]
    ba9c:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    ba9e:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious         = pxIterator;
    baa0:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext                = pxNewListItem;
    baa2:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = (void *)pxList;

	(pxList->uxNumberOfItems)++;
    baa4:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = (void *)pxList;
    baa6:	6108      	str	r0, [r1, #16]
	(pxList->uxNumberOfItems)++;
    baa8:	3301      	adds	r3, #1
    baaa:	6003      	str	r3, [r0, #0]
}
    baac:	bd30      	pop	{r4, r5, pc}
		for (pxIterator = (ListItem_t *)&(pxList->xListEnd); pxIterator->pxNext->xItemValue <= xValueOfInsertion;
    baae:	f100 0208 	add.w	r2, r0, #8
    bab2:	4613      	mov	r3, r2
    bab4:	6852      	ldr	r2, [r2, #4]
    bab6:	6815      	ldr	r5, [r2, #0]
    bab8:	42a5      	cmp	r5, r4
    baba:	d9fa      	bls.n	bab2 <vListInsert+0x22>
    babc:	e7ed      	b.n	ba9a <vListInsert+0xa>

0000babe <uxListRemove>:
{
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    babe:	e9d0 1201 	ldrd	r1, r2, [r0, #4]
	List_t *const pxList = (List_t *)pxItemToRemove->pvContainer;
    bac2:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    bac4:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    bac6:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if (pxList->pxIndex == pxItemToRemove) {
    bac8:	6859      	ldr	r1, [r3, #4]
    baca:	4281      	cmp	r1, r0
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    bacc:	bf08      	it	eq
    bace:	605a      	streq	r2, [r3, #4]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    bad0:	2200      	movs	r2, #0
    bad2:	6102      	str	r2, [r0, #16]
	(pxList->uxNumberOfItems)--;
    bad4:	681a      	ldr	r2, [r3, #0]
    bad6:	3a01      	subs	r2, #1
    bad8:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
    bada:	6818      	ldr	r0, [r3, #0]
}
    badc:	4770      	bx	lr
	...

0000bae0 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(" ldr r0, =0xE000ED08 	\n" /* Use the NVIC offset register to locate the stack. */
    bae0:	4808      	ldr	r0, [pc, #32]	; (bb04 <prvPortStartFirstTask+0x24>)
    bae2:	6800      	ldr	r0, [r0, #0]
    bae4:	6800      	ldr	r0, [r0, #0]
    bae6:	f380 8808 	msr	MSP, r0
    baea:	f04f 0000 	mov.w	r0, #0
    baee:	f380 8814 	msr	CONTROL, r0
    baf2:	b662      	cpsie	i
    baf4:	b661      	cpsie	f
    baf6:	f3bf 8f4f 	dsb	sy
    bafa:	f3bf 8f6f 	isb	sy
    bafe:	df00      	svc	0
    bb00:	bf00      	nop
	               " cpsie f				\n"
	               " dsb					\n"
	               " isb					\n"
	               " svc 0					\n" /* System call to start first task. */
	               " nop					\n");
}
    bb02:	0000      	.short	0x0000
    bb04:	e000ed08 	.word	0xe000ed08

0000bb08 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP(void)
{
	__asm volatile("	ldr.w r0, =0xE000ED88		\n" /* The FPU enable bits are in the CPACR. */
    bb08:	f8df 000c 	ldr.w	r0, [pc, #12]	; bb18 <vPortEnableVFP+0x10>
    bb0c:	6801      	ldr	r1, [r0, #0]
    bb0e:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
    bb12:	6001      	str	r1, [r0, #0]
    bb14:	4770      	bx	lr
	               "	ldr r1, [r0]				\n"
	               "								\n"
	               "	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
	               "	str r1, [r0]				\n"
	               "	bx r14						");
}
    bb16:	0000      	.short	0x0000
    bb18:	e000ed88 	.word	0xe000ed88

0000bb1c <prvTaskExitError>:
{
    bb1c:	b082      	sub	sp, #8
	volatile uint32_t ulDummy = 0;
    bb1e:	2300      	movs	r3, #0
    bb20:	9301      	str	r3, [sp, #4]
	configASSERT(uxCriticalNesting == ~0UL);
    bb22:	4b0d      	ldr	r3, [pc, #52]	; (bb58 <prvTaskExitError+0x3c>)
    bb24:	681b      	ldr	r3, [r3, #0]
    bb26:	3301      	adds	r3, #1
    bb28:	d008      	beq.n	bb3c <prvTaskExitError+0x20>

portFORCE_INLINE static void vPortRaiseBASEPRI(void)
{
	uint32_t ulNewBASEPRI;

	__asm volatile("	mov %0, %1												\n"
    bb2a:	f04f 0380 	mov.w	r3, #128	; 0x80
    bb2e:	f383 8811 	msr	BASEPRI, r3
    bb32:	f3bf 8f6f 	isb	sy
    bb36:	f3bf 8f4f 	dsb	sy
    bb3a:	e7fe      	b.n	bb3a <prvTaskExitError+0x1e>
    bb3c:	f04f 0380 	mov.w	r3, #128	; 0x80
    bb40:	f383 8811 	msr	BASEPRI, r3
    bb44:	f3bf 8f6f 	isb	sy
    bb48:	f3bf 8f4f 	dsb	sy
	while (ulDummy == 0) {
    bb4c:	9b01      	ldr	r3, [sp, #4]
    bb4e:	2b00      	cmp	r3, #0
    bb50:	d0fc      	beq.n	bb4c <prvTaskExitError+0x30>
}
    bb52:	b002      	add	sp, #8
    bb54:	4770      	bx	lr
    bb56:	bf00      	nop
    bb58:	20000350 	.word	0x20000350

0000bb5c <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR; /* xPSR */
    bb5c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    bb60:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = (StackType_t)portTASK_RETURN_ADDRESS; /* LR */
    bb64:	4b07      	ldr	r3, [pc, #28]	; (bb84 <pxPortInitialiseStack+0x28>)
    bb66:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    bb6a:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    bb6e:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ((StackType_t)pxCode) & portSTART_ADDRESS_MASK; /* PC */
    bb72:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = (StackType_t)pvParameters; /* R0 */
    bb76:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
    bb7a:	f840 3c24 	str.w	r3, [r0, #-36]
}
    bb7e:	3844      	subs	r0, #68	; 0x44
    bb80:	4770      	bx	lr
    bb82:	bf00      	nop
    bb84:	0000bb1d 	.word	0x0000bb1d
	...

0000bb90 <SVCall_Handler>:
	__asm volatile("	ldr	r3, pxCurrentTCBConst2		\n" /* Restore the context. */
    bb90:	4b07      	ldr	r3, [pc, #28]	; (bbb0 <pxCurrentTCBConst2>)
    bb92:	6819      	ldr	r1, [r3, #0]
    bb94:	6808      	ldr	r0, [r1, #0]
    bb96:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bb9a:	f380 8809 	msr	PSP, r0
    bb9e:	f3bf 8f6f 	isb	sy
    bba2:	f04f 0000 	mov.w	r0, #0
    bba6:	f380 8811 	msr	BASEPRI, r0
    bbaa:	4770      	bx	lr
    bbac:	f3af 8000 	nop.w

0000bbb0 <pxCurrentTCBConst2>:
    bbb0:	200090ac 	.word	0x200090ac

0000bbb4 <vPortEnterCritical>:
    bbb4:	f04f 0380 	mov.w	r3, #128	; 0x80
    bbb8:	f383 8811 	msr	BASEPRI, r3
    bbbc:	f3bf 8f6f 	isb	sy
    bbc0:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
    bbc4:	4a0a      	ldr	r2, [pc, #40]	; (bbf0 <vPortEnterCritical+0x3c>)
    bbc6:	6813      	ldr	r3, [r2, #0]
    bbc8:	3301      	adds	r3, #1
	if (uxCriticalNesting == 1) {
    bbca:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
    bbcc:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 1) {
    bbce:	d10d      	bne.n	bbec <vPortEnterCritical+0x38>
		configASSERT((portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK) == 0);
    bbd0:	4b08      	ldr	r3, [pc, #32]	; (bbf4 <vPortEnterCritical+0x40>)
    bbd2:	681b      	ldr	r3, [r3, #0]
    bbd4:	f013 0fff 	tst.w	r3, #255	; 0xff
    bbd8:	d008      	beq.n	bbec <vPortEnterCritical+0x38>
    bbda:	f04f 0380 	mov.w	r3, #128	; 0x80
    bbde:	f383 8811 	msr	BASEPRI, r3
    bbe2:	f3bf 8f6f 	isb	sy
    bbe6:	f3bf 8f4f 	dsb	sy
    bbea:	e7fe      	b.n	bbea <vPortEnterCritical+0x36>
}
    bbec:	4770      	bx	lr
    bbee:	bf00      	nop
    bbf0:	20000350 	.word	0x20000350
    bbf4:	e000ed04 	.word	0xe000ed04

0000bbf8 <vPortExitCritical>:
	configASSERT(uxCriticalNesting);
    bbf8:	4a08      	ldr	r2, [pc, #32]	; (bc1c <vPortExitCritical+0x24>)
    bbfa:	6813      	ldr	r3, [r2, #0]
    bbfc:	b943      	cbnz	r3, bc10 <vPortExitCritical+0x18>
    bbfe:	f04f 0380 	mov.w	r3, #128	; 0x80
    bc02:	f383 8811 	msr	BASEPRI, r3
    bc06:	f3bf 8f6f 	isb	sy
    bc0a:	f3bf 8f4f 	dsb	sy
    bc0e:	e7fe      	b.n	bc0e <vPortExitCritical+0x16>
	uxCriticalNesting--;
    bc10:	3b01      	subs	r3, #1
    bc12:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
    bc14:	b90b      	cbnz	r3, bc1a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI(uint32_t ulNewMaskValue)
{
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    bc16:	f383 8811 	msr	BASEPRI, r3
}
    bc1a:	4770      	bx	lr
    bc1c:	20000350 	.word	0x20000350

0000bc20 <PendSV_Handler>:
	__asm volatile(
    bc20:	f3ef 8009 	mrs	r0, PSP
    bc24:	f3bf 8f6f 	isb	sy
    bc28:	4b15      	ldr	r3, [pc, #84]	; (bc80 <pxCurrentTCBConst>)
    bc2a:	681a      	ldr	r2, [r3, #0]
    bc2c:	f01e 0f10 	tst.w	lr, #16
    bc30:	bf08      	it	eq
    bc32:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
    bc36:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bc3a:	6010      	str	r0, [r2, #0]
    bc3c:	e92d 0009 	stmdb	sp!, {r0, r3}
    bc40:	f04f 0080 	mov.w	r0, #128	; 0x80
    bc44:	f380 8811 	msr	BASEPRI, r0
    bc48:	f3bf 8f4f 	dsb	sy
    bc4c:	f3bf 8f6f 	isb	sy
    bc50:	f007 fc00 	bl	13454 <vTaskSwitchContext>
    bc54:	f04f 0000 	mov.w	r0, #0
    bc58:	f380 8811 	msr	BASEPRI, r0
    bc5c:	bc09      	pop	{r0, r3}
    bc5e:	6819      	ldr	r1, [r3, #0]
    bc60:	6808      	ldr	r0, [r1, #0]
    bc62:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    bc66:	f01e 0f10 	tst.w	lr, #16
    bc6a:	bf08      	it	eq
    bc6c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
    bc70:	f380 8809 	msr	PSP, r0
    bc74:	f3bf 8f6f 	isb	sy
    bc78:	4770      	bx	lr
    bc7a:	bf00      	nop
    bc7c:	f3af 8000 	nop.w

0000bc80 <pxCurrentTCBConst>:
    bc80:	200090ac 	.word	0x200090ac

0000bc84 <SysTick_Handler>:
{
    bc84:	b508      	push	{r3, lr}
	__asm volatile("	mov %0, %1												\n"
    bc86:	f04f 0380 	mov.w	r3, #128	; 0x80
    bc8a:	f383 8811 	msr	BASEPRI, r3
    bc8e:	f3bf 8f6f 	isb	sy
    bc92:	f3bf 8f4f 	dsb	sy
		if (xTaskIncrementTick() != pdFALSE) {
    bc96:	4b05      	ldr	r3, [pc, #20]	; (bcac <SysTick_Handler+0x28>)
    bc98:	4798      	blx	r3
    bc9a:	b118      	cbz	r0, bca4 <SysTick_Handler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
    bc9c:	4b04      	ldr	r3, [pc, #16]	; (bcb0 <SysTick_Handler+0x2c>)
    bc9e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    bca2:	601a      	str	r2, [r3, #0]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    bca4:	2300      	movs	r3, #0
    bca6:	f383 8811 	msr	BASEPRI, r3
}
    bcaa:	bd08      	pop	{r3, pc}
    bcac:	00013205 	.word	0x00013205
    bcb0:	e000ed04 	.word	0xe000ed04

0000bcb4 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    bcb4:	4b05      	ldr	r3, [pc, #20]	; (bccc <vPortSetupTimerInterrupt+0x18>)
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    bcb6:	4906      	ldr	r1, [pc, #24]	; (bcd0 <vPortSetupTimerInterrupt+0x1c>)
	portNVIC_SYSTICK_CTRL_REG          = 0UL;
    bcb8:	2200      	movs	r2, #0
    bcba:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
    bcbc:	600a      	str	r2, [r1, #0]
	portNVIC_SYSTICK_LOAD_REG = (configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ) - 1UL;
    bcbe:	4a05      	ldr	r2, [pc, #20]	; (bcd4 <vPortSetupTimerInterrupt+0x20>)
    bcc0:	f645 51bf 	movw	r1, #23999	; 0x5dbf
    bcc4:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = (portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT);
    bcc6:	2207      	movs	r2, #7
    bcc8:	601a      	str	r2, [r3, #0]
}
    bcca:	4770      	bx	lr
    bccc:	e000e010 	.word	0xe000e010
    bcd0:	e000e018 	.word	0xe000e018
    bcd4:	e000e014 	.word	0xe000e014

0000bcd8 <xPortStartScheduler>:
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    bcd8:	4b37      	ldr	r3, [pc, #220]	; (bdb8 <xPortStartScheduler+0xe0>)
    bcda:	4a38      	ldr	r2, [pc, #224]	; (bdbc <xPortStartScheduler+0xe4>)
{
    bcdc:	b513      	push	{r0, r1, r4, lr}
	configASSERT(portCPUID != portCORTEX_M7_r0p1_ID);
    bcde:	6819      	ldr	r1, [r3, #0]
    bce0:	4291      	cmp	r1, r2
    bce2:	d108      	bne.n	bcf6 <xPortStartScheduler+0x1e>
	__asm volatile("	mov %0, %1												\n"
    bce4:	f04f 0380 	mov.w	r3, #128	; 0x80
    bce8:	f383 8811 	msr	BASEPRI, r3
    bcec:	f3bf 8f6f 	isb	sy
    bcf0:	f3bf 8f4f 	dsb	sy
    bcf4:	e7fe      	b.n	bcf4 <xPortStartScheduler+0x1c>
	configASSERT(portCPUID != portCORTEX_M7_r0p0_ID);
    bcf6:	681a      	ldr	r2, [r3, #0]
    bcf8:	4b31      	ldr	r3, [pc, #196]	; (bdc0 <xPortStartScheduler+0xe8>)
    bcfa:	429a      	cmp	r2, r3
    bcfc:	d108      	bne.n	bd10 <xPortStartScheduler+0x38>
    bcfe:	f04f 0380 	mov.w	r3, #128	; 0x80
    bd02:	f383 8811 	msr	BASEPRI, r3
    bd06:	f3bf 8f6f 	isb	sy
    bd0a:	f3bf 8f4f 	dsb	sy
    bd0e:	e7fe      	b.n	bd0e <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
    bd10:	4b2c      	ldr	r3, [pc, #176]	; (bdc4 <xPortStartScheduler+0xec>)
    bd12:	781a      	ldrb	r2, [r3, #0]
    bd14:	b2d2      	uxtb	r2, r2
    bd16:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
    bd18:	22ff      	movs	r2, #255	; 0xff
    bd1a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    bd1c:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    bd1e:	4a2a      	ldr	r2, [pc, #168]	; (bdc8 <xPortStartScheduler+0xf0>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
    bd20:	b2db      	uxtb	r3, r3
    bd22:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
    bd26:	f89d 3003 	ldrb.w	r3, [sp, #3]
    bd2a:	f003 0380 	and.w	r3, r3, #128	; 0x80
    bd2e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
    bd30:	2307      	movs	r3, #7
    bd32:	6053      	str	r3, [r2, #4]
		while ((ucMaxPriorityValue & portTOP_BIT_OF_BYTE) == portTOP_BIT_OF_BYTE) {
    bd34:	2100      	movs	r1, #0
    bd36:	f89d 0003 	ldrb.w	r0, [sp, #3]
    bd3a:	0600      	lsls	r0, r0, #24
    bd3c:	f103 34ff 	add.w	r4, r3, #4294967295	; 0xffffffff
    bd40:	d40c      	bmi.n	bd5c <xPortStartScheduler+0x84>
    bd42:	b111      	cbz	r1, bd4a <xPortStartScheduler+0x72>
			configASSERT((portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue) == configPRIO_BITS);
    bd44:	2b04      	cmp	r3, #4
    bd46:	6053      	str	r3, [r2, #4]
    bd48:	d011      	beq.n	bd6e <xPortStartScheduler+0x96>
    bd4a:	f04f 0380 	mov.w	r3, #128	; 0x80
    bd4e:	f383 8811 	msr	BASEPRI, r3
    bd52:	f3bf 8f6f 	isb	sy
    bd56:	f3bf 8f4f 	dsb	sy
    bd5a:	e7fe      	b.n	bd5a <xPortStartScheduler+0x82>
			ucMaxPriorityValue <<= (uint8_t)0x01;
    bd5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    bd60:	005b      	lsls	r3, r3, #1
    bd62:	b2db      	uxtb	r3, r3
    bd64:	f88d 3003 	strb.w	r3, [sp, #3]
    bd68:	2101      	movs	r1, #1
    bd6a:	4623      	mov	r3, r4
    bd6c:	e7e3      	b.n	bd36 <xPortStartScheduler+0x5e>
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
    bd6e:	f44f 6380 	mov.w	r3, #1024	; 0x400
    bd72:	6053      	str	r3, [r2, #4]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
    bd74:	9b01      	ldr	r3, [sp, #4]
    bd76:	4a13      	ldr	r2, [pc, #76]	; (bdc4 <xPortStartScheduler+0xec>)
    bd78:	b2db      	uxtb	r3, r3
    bd7a:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
    bd7c:	4b13      	ldr	r3, [pc, #76]	; (bdcc <xPortStartScheduler+0xf4>)
    bd7e:	681a      	ldr	r2, [r3, #0]
    bd80:	f442 0260 	orr.w	r2, r2, #14680064	; 0xe00000
    bd84:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
    bd86:	681a      	ldr	r2, [r3, #0]
    bd88:	f042 4260 	orr.w	r2, r2, #3758096384	; 0xe0000000
    bd8c:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
    bd8e:	4b10      	ldr	r3, [pc, #64]	; (bdd0 <xPortStartScheduler+0xf8>)
    bd90:	4798      	blx	r3
	uxCriticalNesting = 0;
    bd92:	4b10      	ldr	r3, [pc, #64]	; (bdd4 <xPortStartScheduler+0xfc>)
    bd94:	2400      	movs	r4, #0
    bd96:	601c      	str	r4, [r3, #0]
	vPortEnableVFP();
    bd98:	4b0f      	ldr	r3, [pc, #60]	; (bdd8 <xPortStartScheduler+0x100>)
    bd9a:	4798      	blx	r3
	*(portFPCCR) |= portASPEN_AND_LSPEN_BITS;
    bd9c:	4a0f      	ldr	r2, [pc, #60]	; (bddc <xPortStartScheduler+0x104>)
    bd9e:	6813      	ldr	r3, [r2, #0]
    bda0:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
    bda4:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
    bda6:	4b0e      	ldr	r3, [pc, #56]	; (bde0 <xPortStartScheduler+0x108>)
    bda8:	4798      	blx	r3
	vTaskSwitchContext();
    bdaa:	4b0e      	ldr	r3, [pc, #56]	; (bde4 <xPortStartScheduler+0x10c>)
    bdac:	4798      	blx	r3
	prvTaskExitError();
    bdae:	4b0e      	ldr	r3, [pc, #56]	; (bde8 <xPortStartScheduler+0x110>)
    bdb0:	4798      	blx	r3
}
    bdb2:	4620      	mov	r0, r4
    bdb4:	b002      	add	sp, #8
    bdb6:	bd10      	pop	{r4, pc}
    bdb8:	e000ed00 	.word	0xe000ed00
    bdbc:	410fc271 	.word	0x410fc271
    bdc0:	410fc270 	.word	0x410fc270
    bdc4:	e000e400 	.word	0xe000e400
    bdc8:	20000800 	.word	0x20000800
    bdcc:	e000ed20 	.word	0xe000ed20
    bdd0:	0000bcb5 	.word	0x0000bcb5
    bdd4:	20000350 	.word	0x20000350
    bdd8:	0000bb09 	.word	0x0000bb09
    bddc:	e000ef34 	.word	0xe000ef34
    bde0:	0000bae1 	.word	0x0000bae1
    bde4:	00013455 	.word	0x00013455
    bde8:	0000bb1d 	.word	0x0000bb1d

0000bdec <vPortValidateInterruptPriority>:
{
	uint32_t ulCurrentInterrupt;
	uint8_t  ucCurrentPriority;

	/* Obtain the number of the currently executing interrupt. */
	__asm volatile("mrs %0, ipsr" : "=r"(ulCurrentInterrupt)::"memory");
    bdec:	f3ef 8305 	mrs	r3, IPSR

	/* Is the interrupt number a user defined interrupt? */
	if (ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER) {
    bdf0:	2b0f      	cmp	r3, #15
    bdf2:	4a10      	ldr	r2, [pc, #64]	; (be34 <vPortValidateInterruptPriority+0x48>)
    bdf4:	d90d      	bls.n	be12 <vPortValidateInterruptPriority+0x26>
		/* Look up the interrupt's priority. */
		ucCurrentPriority = pcInterruptPriorityRegisters[ulCurrentInterrupt];
    bdf6:	4910      	ldr	r1, [pc, #64]	; (be38 <vPortValidateInterruptPriority+0x4c>)
    bdf8:	5c5b      	ldrb	r3, [r3, r1]
		interrupt entry is as fast and simple as possible.

		The following links provide detailed information:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html
		http://www.freertos.org/FAQHelp.html */
		configASSERT(ucCurrentPriority >= ucMaxSysCallPriority);
    bdfa:	7811      	ldrb	r1, [r2, #0]
    bdfc:	4299      	cmp	r1, r3
    bdfe:	d908      	bls.n	be12 <vPortValidateInterruptPriority+0x26>
    be00:	f04f 0380 	mov.w	r3, #128	; 0x80
    be04:	f383 8811 	msr	BASEPRI, r3
    be08:	f3bf 8f6f 	isb	sy
    be0c:	f3bf 8f4f 	dsb	sy
    be10:	e7fe      	b.n	be10 <vPortValidateInterruptPriority+0x24>
	configuration then the correct setting can be achieved on all Cortex-M
	devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
	scheduler.  Note however that some vendor specific peripheral libraries
	assume a non-zero priority group setting, in which cases using a value
	of zero will result in unpredictable behaviour. */
	configASSERT((portAIRCR_REG & portPRIORITY_GROUP_MASK) <= ulMaxPRIGROUPValue);
    be12:	4b0a      	ldr	r3, [pc, #40]	; (be3c <vPortValidateInterruptPriority+0x50>)
    be14:	6852      	ldr	r2, [r2, #4]
    be16:	681b      	ldr	r3, [r3, #0]
    be18:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    be1c:	4293      	cmp	r3, r2
    be1e:	d908      	bls.n	be32 <vPortValidateInterruptPriority+0x46>
    be20:	f04f 0380 	mov.w	r3, #128	; 0x80
    be24:	f383 8811 	msr	BASEPRI, r3
    be28:	f3bf 8f6f 	isb	sy
    be2c:	f3bf 8f4f 	dsb	sy
    be30:	e7fe      	b.n	be30 <vPortValidateInterruptPriority+0x44>
}
    be32:	4770      	bx	lr
    be34:	20000800 	.word	0x20000800
    be38:	e000e3f0 	.word	0xe000e3f0
    be3c:	e000ed0c 	.word	0xe000ed0c

0000be40 <i2c_m_async_write>:

/**
 * \brief Async version of I2C I/O write
 */
static int32_t i2c_m_async_write(struct io_descriptor *const io, const uint8_t *buf, const uint16_t n)
{
    be40:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct i2c_m_async_desc *i2c = CONTAINER_OF(io, struct i2c_m_async_desc, io);
	struct _i2c_m_msg        msg;
	int32_t                  ret;

	msg.addr   = i2c->slave_addr;
    be42:	8a83      	ldrh	r3, [r0, #20]
    be44:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.len    = n;
	msg.flags  = I2C_M_STOP;
    be48:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    be4c:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = (uint8_t *)buf;
    be50:	9103      	str	r1, [sp, #12]

	/* start transfer then return */
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    be52:	4b05      	ldr	r3, [pc, #20]	; (be68 <i2c_m_async_write+0x28>)
	msg.len    = n;
    be54:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    be56:	a901      	add	r1, sp, #4
    be58:	3828      	subs	r0, #40	; 0x28
{
    be5a:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    be5c:	4798      	blx	r3
		/* error occurred */
		return ret;
	}

	return (int32_t)n;
}
    be5e:	2800      	cmp	r0, #0
    be60:	bf08      	it	eq
    be62:	4620      	moveq	r0, r4
    be64:	b004      	add	sp, #16
    be66:	bd10      	pop	{r4, pc}
    be68:	00011ae5 	.word	0x00011ae5

0000be6c <i2c_m_async_read>:
{
    be6c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	msg.addr   = i2c->slave_addr;
    be6e:	8a83      	ldrh	r3, [r0, #20]
    be70:	f8ad 3004 	strh.w	r3, [sp, #4]
	msg.flags  = I2C_M_STOP | I2C_M_RD;
    be74:	f248 0301 	movw	r3, #32769	; 0x8001
    be78:	f8ad 3006 	strh.w	r3, [sp, #6]
	msg.buffer = buf;
    be7c:	9103      	str	r1, [sp, #12]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    be7e:	4b05      	ldr	r3, [pc, #20]	; (be94 <i2c_m_async_read+0x28>)
	msg.len    = n;
    be80:	9202      	str	r2, [sp, #8]
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    be82:	a901      	add	r1, sp, #4
    be84:	3828      	subs	r0, #40	; 0x28
{
    be86:	4614      	mov	r4, r2
	ret = _i2c_m_async_transfer(&i2c->device, &msg);
    be88:	4798      	blx	r3
}
    be8a:	2800      	cmp	r0, #0
    be8c:	bf08      	it	eq
    be8e:	4620      	moveq	r0, r4
    be90:	b004      	add	sp, #16
    be92:	bd10      	pop	{r4, pc}
    be94:	00011ae5 	.word	0x00011ae5

0000be98 <i2c_tx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    be98:	8842      	ldrh	r2, [r0, #2]
    be9a:	05d2      	lsls	r2, r2, #23
    be9c:	d402      	bmi.n	bea4 <i2c_tx_complete+0xc>
		if (i2c->i2c_cb.tx_complete) {
    be9e:	6b43      	ldr	r3, [r0, #52]	; 0x34
    bea0:	b103      	cbz	r3, bea4 <i2c_tx_complete+0xc>
			i2c->i2c_cb.tx_complete(i2c);
    bea2:	4718      	bx	r3
}
    bea4:	4770      	bx	lr

0000bea6 <i2c_rx_complete>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    bea6:	8842      	ldrh	r2, [r0, #2]
    bea8:	05d2      	lsls	r2, r2, #23
    beaa:	d402      	bmi.n	beb2 <i2c_rx_complete+0xc>
		if (i2c->i2c_cb.rx_complete) {
    beac:	6b83      	ldr	r3, [r0, #56]	; 0x38
    beae:	b103      	cbz	r3, beb2 <i2c_rx_complete+0xc>
			i2c->i2c_cb.rx_complete(i2c);
    beb0:	4718      	bx	r3
}
    beb2:	4770      	bx	lr

0000beb4 <i2c_error>:
	if (!(i2c_dev->service.msg.flags & I2C_M_BUSY)) {
    beb4:	8842      	ldrh	r2, [r0, #2]
    beb6:	05d2      	lsls	r2, r2, #23
    beb8:	d402      	bmi.n	bec0 <i2c_error+0xc>
		if (i2c->i2c_cb.error) {
    beba:	6b03      	ldr	r3, [r0, #48]	; 0x30
    bebc:	b103      	cbz	r3, bec0 <i2c_error+0xc>
			i2c->i2c_cb.error(i2c, error);
    bebe:	4718      	bx	r3
}
    bec0:	4770      	bx	lr
	...

0000bec4 <i2c_m_async_init>:

/**
 * \brief Async version of i2c initialize
 */
int32_t i2c_m_async_init(struct i2c_m_async_desc *const i2c, void *const hw)
{
    bec4:	b570      	push	{r4, r5, r6, lr}
	int32_t init_status;
	ASSERT(i2c);
    bec6:	4604      	mov	r4, r0
    bec8:	3800      	subs	r0, #0
{
    beca:	460d      	mov	r5, r1
	ASSERT(i2c);
    becc:	bf18      	it	ne
    bece:	2001      	movne	r0, #1
    bed0:	490e      	ldr	r1, [pc, #56]	; (bf0c <i2c_m_async_init+0x48>)
    bed2:	4b0f      	ldr	r3, [pc, #60]	; (bf10 <i2c_m_async_init+0x4c>)
    bed4:	2289      	movs	r2, #137	; 0x89
    bed6:	4798      	blx	r3

	init_status = _i2c_m_async_init(&i2c->device, hw);
    bed8:	4629      	mov	r1, r5
    beda:	4b0e      	ldr	r3, [pc, #56]	; (bf14 <i2c_m_async_init+0x50>)
    bedc:	4620      	mov	r0, r4
    bede:	4798      	blx	r3
	if (init_status) {
    bee0:	4605      	mov	r5, r0
    bee2:	b980      	cbnz	r0, bf06 <i2c_m_async_init+0x42>
		return init_status;
	}
	/* Init I/O */
	i2c->io.read  = i2c_m_async_read;
    bee4:	4b0c      	ldr	r3, [pc, #48]	; (bf18 <i2c_m_async_init+0x54>)
    bee6:	62e3      	str	r3, [r4, #44]	; 0x2c
	i2c->io.write = i2c_m_async_write;
    bee8:	4b0c      	ldr	r3, [pc, #48]	; (bf1c <i2c_m_async_init+0x58>)

	/* Init callbacks */
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    beea:	4a0d      	ldr	r2, [pc, #52]	; (bf20 <i2c_m_async_init+0x5c>)
    beec:	4e0d      	ldr	r6, [pc, #52]	; (bf24 <i2c_m_async_init+0x60>)
	i2c->io.write = i2c_m_async_write;
    beee:	62a3      	str	r3, [r4, #40]	; 0x28
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_TX_COMPLETE, (FUNC_PTR)i2c_tx_complete);
    bef0:	2101      	movs	r1, #1
    bef2:	4620      	mov	r0, r4
    bef4:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_RX_COMPLETE, (FUNC_PTR)i2c_rx_complete);
    bef6:	4a0c      	ldr	r2, [pc, #48]	; (bf28 <i2c_m_async_init+0x64>)
    bef8:	2102      	movs	r1, #2
    befa:	4620      	mov	r0, r4
    befc:	47b0      	blx	r6
	_i2c_m_async_register_callback(&i2c->device, I2C_M_ASYNC_DEVICE_ERROR, (FUNC_PTR)i2c_error);
    befe:	4a0b      	ldr	r2, [pc, #44]	; (bf2c <i2c_m_async_init+0x68>)
    bf00:	4629      	mov	r1, r5
    bf02:	4620      	mov	r0, r4
    bf04:	47b0      	blx	r6

	return ERR_NONE;
}
    bf06:	4628      	mov	r0, r5
    bf08:	bd70      	pop	{r4, r5, r6, pc}
    bf0a:	bf00      	nop
    bf0c:	00016d6c 	.word	0x00016d6c
    bf10:	0000e9b9 	.word	0x0000e9b9
    bf14:	00011a69 	.word	0x00011a69
    bf18:	0000be6d 	.word	0x0000be6d
    bf1c:	0000be41 	.word	0x0000be41
    bf20:	0000be99 	.word	0x0000be99
    bf24:	00011bed 	.word	0x00011bed
    bf28:	0000bea7 	.word	0x0000bea7
    bf2c:	0000beb5 	.word	0x0000beb5

0000bf30 <prvInsertBlockIntoFreeList>:
	BlockLink_t *pxIterator;
	uint8_t *    puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    bf30:	4b0f      	ldr	r3, [pc, #60]	; (bf70 <prvInsertBlockIntoFreeList+0x40>)
{
    bf32:	b530      	push	{r4, r5, lr}
    bf34:	461d      	mov	r5, r3
	for (pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert;
    bf36:	461a      	mov	r2, r3
    bf38:	681b      	ldr	r3, [r3, #0]
    bf3a:	4283      	cmp	r3, r0
    bf3c:	d3fb      	bcc.n	bf36 <prvInsertBlockIntoFreeList+0x6>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = (uint8_t *)pxIterator;
	if ((puc + pxIterator->xBlockSize) == (uint8_t *)pxBlockToInsert) {
    bf3e:	6854      	ldr	r4, [r2, #4]
    bf40:	1911      	adds	r1, r2, r4
    bf42:	4288      	cmp	r0, r1
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    bf44:	bf01      	itttt	eq
    bf46:	6841      	ldreq	r1, [r0, #4]
    bf48:	4610      	moveq	r0, r2
    bf4a:	1909      	addeq	r1, r1, r4
    bf4c:	6051      	streq	r1, [r2, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = (uint8_t *)pxBlockToInsert;
	if ((puc + pxBlockToInsert->xBlockSize) == (uint8_t *)pxIterator->pxNextFreeBlock) {
    bf4e:	6844      	ldr	r4, [r0, #4]
    bf50:	1901      	adds	r1, r0, r4
    bf52:	428b      	cmp	r3, r1
    bf54:	d106      	bne.n	bf64 <prvInsertBlockIntoFreeList+0x34>
		if (pxIterator->pxNextFreeBlock != pxEnd) {
    bf56:	68a9      	ldr	r1, [r5, #8]
    bf58:	428b      	cmp	r3, r1
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    bf5a:	bf1f      	itttt	ne
    bf5c:	6859      	ldrne	r1, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    bf5e:	681b      	ldrne	r3, [r3, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    bf60:	1909      	addne	r1, r1, r4
    bf62:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if (pxIterator != pxBlockToInsert) {
    bf64:	4290      	cmp	r0, r2
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    bf66:	6003      	str	r3, [r0, #0]
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    bf68:	bf18      	it	ne
    bf6a:	6010      	strne	r0, [r2, #0]
	} else {
		mtCOVERAGE_TEST_MARKER();
	}
}
    bf6c:	bd30      	pop	{r4, r5, pc}
    bf6e:	bf00      	nop
    bf70:	20000808 	.word	0x20000808

0000bf74 <pvPortMalloc>:
{
    bf74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		if (pxEnd == NULL) {
    bf78:	4d39      	ldr	r5, [pc, #228]	; (c060 <pvPortMalloc+0xec>)
	vTaskSuspendAll();
    bf7a:	4b3a      	ldr	r3, [pc, #232]	; (c064 <pvPortMalloc+0xf0>)
{
    bf7c:	4604      	mov	r4, r0
	vTaskSuspendAll();
    bf7e:	4798      	blx	r3
		if (pxEnd == NULL) {
    bf80:	68ab      	ldr	r3, [r5, #8]
    bf82:	b9bb      	cbnz	r3, bfb4 <pvPortMalloc+0x40>
	uxAddress = (size_t)ucHeap;
    bf84:	4a38      	ldr	r2, [pc, #224]	; (c068 <pvPortMalloc+0xf4>)
	uxAddress -= xHeapStructSize;
    bf86:	4b39      	ldr	r3, [pc, #228]	; (c06c <pvPortMalloc+0xf8>)
	if ((uxAddress & portBYTE_ALIGNMENT_MASK) != 0) {
    bf88:	0756      	lsls	r6, r2, #29
		uxAddress += (portBYTE_ALIGNMENT - 1);
    bf8a:	bf18      	it	ne
    bf8c:	3207      	addne	r2, #7
	uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    bf8e:	f023 0307 	bic.w	r3, r3, #7
		uxAddress &= ~((size_t)portBYTE_ALIGNMENT_MASK);
    bf92:	bf18      	it	ne
    bf94:	f022 0207 	bicne.w	r2, r2, #7
	xStart.xBlockSize      = (size_t)0;
    bf98:	2100      	movs	r1, #0
    bf9a:	6069      	str	r1, [r5, #4]
	xStart.pxNextFreeBlock = (void *)pucAlignedHeap;
    bf9c:	602a      	str	r2, [r5, #0]
	pxEnd->pxNextFreeBlock = NULL;
    bf9e:	e9c3 1100 	strd	r1, r1, [r3]
	pxFirstFreeBlock->xBlockSize      = uxAddress - (size_t)pxFirstFreeBlock;
    bfa2:	1a99      	subs	r1, r3, r2
	xFreeBytesRemaining            = pxFirstFreeBlock->xBlockSize;
    bfa4:	e9c5 1103 	strd	r1, r1, [r5, #12]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    bfa8:	e9c2 3100 	strd	r3, r1, [r2]
	pxEnd                  = (void *)uxAddress;
    bfac:	60ab      	str	r3, [r5, #8]
	xBlockAllocatedBit = ((size_t)1) << ((sizeof(size_t) * heapBITS_PER_BYTE) - 1);
    bfae:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    bfb2:	616b      	str	r3, [r5, #20]
		if ((xWantedSize & xBlockAllocatedBit) == 0) {
    bfb4:	f8d5 8014 	ldr.w	r8, [r5, #20]
    bfb8:	ea18 0f04 	tst.w	r8, r4
    bfbc:	d14b      	bne.n	c056 <pvPortMalloc+0xe2>
			if (xWantedSize > 0) {
    bfbe:	2c00      	cmp	r4, #0
    bfc0:	d03c      	beq.n	c03c <pvPortMalloc+0xc8>
				xWantedSize += xHeapStructSize;
    bfc2:	f104 0308 	add.w	r3, r4, #8
				if ((xWantedSize & portBYTE_ALIGNMENT_MASK) != 0x00) {
    bfc6:	0760      	lsls	r0, r4, #29
					xWantedSize += (portBYTE_ALIGNMENT - (xWantedSize & portBYTE_ALIGNMENT_MASK));
    bfc8:	bf1c      	itt	ne
    bfca:	f023 0307 	bicne.w	r3, r3, #7
    bfce:	3308      	addne	r3, #8
			if ((xWantedSize > 0) && (xWantedSize <= xFreeBytesRemaining)) {
    bfd0:	2b00      	cmp	r3, #0
    bfd2:	d040      	beq.n	c056 <pvPortMalloc+0xe2>
    bfd4:	692f      	ldr	r7, [r5, #16]
    bfd6:	429f      	cmp	r7, r3
    bfd8:	d33d      	bcc.n	c056 <pvPortMalloc+0xe2>
				pxBlock         = xStart.pxNextFreeBlock;
    bfda:	682e      	ldr	r6, [r5, #0]
				pxPreviousBlock = &xStart;
    bfdc:	4820      	ldr	r0, [pc, #128]	; (c060 <pvPortMalloc+0xec>)
				while ((pxBlock->xBlockSize < xWantedSize) && (pxBlock->pxNextFreeBlock != NULL)) {
    bfde:	6872      	ldr	r2, [r6, #4]
    bfe0:	429a      	cmp	r2, r3
    bfe2:	d201      	bcs.n	bfe8 <pvPortMalloc+0x74>
    bfe4:	6831      	ldr	r1, [r6, #0]
    bfe6:	b9a1      	cbnz	r1, c012 <pvPortMalloc+0x9e>
				if (pxBlock != pxEnd) {
    bfe8:	68a9      	ldr	r1, [r5, #8]
    bfea:	42b1      	cmp	r1, r6
    bfec:	d033      	beq.n	c056 <pvPortMalloc+0xe2>
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    bfee:	1ad2      	subs	r2, r2, r3
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    bff0:	6831      	ldr	r1, [r6, #0]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    bff2:	6804      	ldr	r4, [r0, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    bff4:	6001      	str	r1, [r0, #0]
					if ((pxBlock->xBlockSize - xWantedSize) > heapMINIMUM_BLOCK_SIZE) {
    bff6:	2a10      	cmp	r2, #16
    bff8:	d912      	bls.n	c020 <pvPortMalloc+0xac>
						pxNewBlockLink = (void *)(((uint8_t *)pxBlock) + xWantedSize);
    bffa:	18f0      	adds	r0, r6, r3
						configASSERT((((size_t)pxNewBlockLink) & portBYTE_ALIGNMENT_MASK) == 0);
    bffc:	0741      	lsls	r1, r0, #29
    bffe:	d00b      	beq.n	c018 <pvPortMalloc+0xa4>
    c000:	f04f 0380 	mov.w	r3, #128	; 0x80
    c004:	f383 8811 	msr	BASEPRI, r3
    c008:	f3bf 8f6f 	isb	sy
    c00c:	f3bf 8f4f 	dsb	sy
    c010:	e7fe      	b.n	c010 <pvPortMalloc+0x9c>
    c012:	4630      	mov	r0, r6
    c014:	460e      	mov	r6, r1
    c016:	e7e2      	b.n	bfde <pvPortMalloc+0x6a>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    c018:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize        = xWantedSize;
    c01a:	6073      	str	r3, [r6, #4]
						prvInsertBlockIntoFreeList(pxNewBlockLink);
    c01c:	4b14      	ldr	r3, [pc, #80]	; (c070 <pvPortMalloc+0xfc>)
    c01e:	4798      	blx	r3
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    c020:	6873      	ldr	r3, [r6, #4]
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    c022:	68e9      	ldr	r1, [r5, #12]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    c024:	1aff      	subs	r7, r7, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    c026:	ea48 0303 	orr.w	r3, r8, r3
					if (xFreeBytesRemaining < xMinimumEverFreeBytesRemaining) {
    c02a:	428f      	cmp	r7, r1
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    c02c:	6073      	str	r3, [r6, #4]
					pxBlock->pxNextFreeBlock = NULL;
    c02e:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
    c032:	612f      	str	r7, [r5, #16]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    c034:	bf38      	it	cc
    c036:	60ef      	strcc	r7, [r5, #12]
					pvReturn = (void *)(((uint8_t *)pxPreviousBlock->pxNextFreeBlock) + xHeapStructSize);
    c038:	3408      	adds	r4, #8
					pxBlock->pxNextFreeBlock = NULL;
    c03a:	6033      	str	r3, [r6, #0]
	(void)xTaskResumeAll();
    c03c:	4b0d      	ldr	r3, [pc, #52]	; (c074 <pvPortMalloc+0x100>)
    c03e:	4798      	blx	r3
	configASSERT((((size_t)pvReturn) & (size_t)portBYTE_ALIGNMENT_MASK) == 0);
    c040:	0763      	lsls	r3, r4, #29
    c042:	d00a      	beq.n	c05a <pvPortMalloc+0xe6>
    c044:	f04f 0380 	mov.w	r3, #128	; 0x80
    c048:	f383 8811 	msr	BASEPRI, r3
    c04c:	f3bf 8f6f 	isb	sy
    c050:	f3bf 8f4f 	dsb	sy
    c054:	e7fe      	b.n	c054 <pvPortMalloc+0xe0>
	void *       pvReturn = NULL;
    c056:	2400      	movs	r4, #0
    c058:	e7f0      	b.n	c03c <pvPortMalloc+0xc8>
}
    c05a:	4620      	mov	r0, r4
    c05c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    c060:	20000808 	.word	0x20000808
    c064:	000131c1 	.word	0x000131c1
    c068:	20000820 	.word	0x20000820
    c06c:	20008518 	.word	0x20008518
    c070:	0000bf31 	.word	0x0000bf31
    c074:	00013309 	.word	0x00013309

0000c078 <vPortFree>:
{
    c078:	b570      	push	{r4, r5, r6, lr}
	if (pv != NULL) {
    c07a:	4604      	mov	r4, r0
    c07c:	b368      	cbz	r0, c0da <vPortFree+0x62>
		configASSERT((pxLink->xBlockSize & xBlockAllocatedBit) != 0);
    c07e:	4d17      	ldr	r5, [pc, #92]	; (c0dc <vPortFree+0x64>)
    c080:	f850 3c04 	ldr.w	r3, [r0, #-4]
    c084:	696a      	ldr	r2, [r5, #20]
    c086:	4213      	tst	r3, r2
    c088:	d108      	bne.n	c09c <vPortFree+0x24>
    c08a:	f04f 0380 	mov.w	r3, #128	; 0x80
    c08e:	f383 8811 	msr	BASEPRI, r3
    c092:	f3bf 8f6f 	isb	sy
    c096:	f3bf 8f4f 	dsb	sy
    c09a:	e7fe      	b.n	c09a <vPortFree+0x22>
		configASSERT(pxLink->pxNextFreeBlock == NULL);
    c09c:	f850 1c08 	ldr.w	r1, [r0, #-8]
    c0a0:	b141      	cbz	r1, c0b4 <vPortFree+0x3c>
    c0a2:	f04f 0380 	mov.w	r3, #128	; 0x80
    c0a6:	f383 8811 	msr	BASEPRI, r3
    c0aa:	f3bf 8f6f 	isb	sy
    c0ae:	f3bf 8f4f 	dsb	sy
    c0b2:	e7fe      	b.n	c0b2 <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    c0b4:	ea23 0302 	bic.w	r3, r3, r2
    c0b8:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
    c0bc:	4b08      	ldr	r3, [pc, #32]	; (c0e0 <vPortFree+0x68>)
    c0be:	4798      	blx	r3
					xFreeBytesRemaining += pxLink->xBlockSize;
    c0c0:	692a      	ldr	r2, [r5, #16]
    c0c2:	f854 3c04 	ldr.w	r3, [r4, #-4]
    c0c6:	4413      	add	r3, r2
    c0c8:	612b      	str	r3, [r5, #16]
					prvInsertBlockIntoFreeList(((BlockLink_t *)pxLink));
    c0ca:	f1a4 0008 	sub.w	r0, r4, #8
    c0ce:	4b05      	ldr	r3, [pc, #20]	; (c0e4 <vPortFree+0x6c>)
    c0d0:	4798      	blx	r3
}
    c0d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				(void)xTaskResumeAll();
    c0d6:	4b04      	ldr	r3, [pc, #16]	; (c0e8 <vPortFree+0x70>)
    c0d8:	4718      	bx	r3
}
    c0da:	bd70      	pop	{r4, r5, r6, pc}
    c0dc:	20000808 	.word	0x20000808
    c0e0:	000131c1 	.word	0x000131c1
    c0e4:	0000bf31 	.word	0x0000bf31
    c0e8:	00013309 	.word	0x00013309

0000c0ec <_wdt_init>:

/**
 * \brief WDT initialization function
 */
int32_t _wdt_init(struct wdt_dev *const dev)
{
    c0ec:	b510      	push	{r4, lr}
	/* Sanity check arguments */
	ASSERT(dev && dev->hw);
    c0ee:	4604      	mov	r4, r0
    c0f0:	b118      	cbz	r0, c0fa <_wdt_init+0xe>
    c0f2:	6800      	ldr	r0, [r0, #0]
    c0f4:	3800      	subs	r0, #0
    c0f6:	bf18      	it	ne
    c0f8:	2001      	movne	r0, #1
    c0fa:	4b12      	ldr	r3, [pc, #72]	; (c144 <_wdt_init+0x58>)
    c0fc:	4912      	ldr	r1, [pc, #72]	; (c148 <_wdt_init+0x5c>)
    c0fe:	2250      	movs	r2, #80	; 0x50
    c100:	4798      	blx	r3

	if (hri_wdt_get_CTRLA_ALWAYSON_bit(dev->hw) || hri_wdt_get_CTRLA_ENABLE_bit(dev->hw)) {
    c102:	6823      	ldr	r3, [r4, #0]
typedef uint8_t  hri_wdt_intenset_reg_t;
typedef uint8_t  hri_wdt_intflag_reg_t;

static inline void hri_wdt_wait_for_sync(const void *const hw, hri_wdt_syncbusy_reg_t reg)
{
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    c104:	689a      	ldr	r2, [r3, #8]
    c106:	f012 0f0e 	tst.w	r2, #14
    c10a:	d1fb      	bne.n	c104 <_wdt_init+0x18>

static inline bool hri_wdt_get_CTRLA_ALWAYSON_bit(const void *const hw)
{
	uint8_t tmp;
	hri_wdt_wait_for_sync(hw, WDT_SYNCBUSY_ENABLE | WDT_SYNCBUSY_WEN | WDT_SYNCBUSY_ALWAYSON);
	tmp = ((Wdt *)hw)->CTRLA.reg;
    c10c:	781a      	ldrb	r2, [r3, #0]
    c10e:	09d2      	lsrs	r2, r2, #7
    c110:	d115      	bne.n	c13e <_wdt_init+0x52>
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    c112:	689a      	ldr	r2, [r3, #8]
    c114:	f012 0f0e 	tst.w	r2, #14
    c118:	d1fb      	bne.n	c112 <_wdt_init+0x26>
	tmp = ((Wdt *)hw)->CTRLA.reg;
    c11a:	781a      	ldrb	r2, [r3, #0]
    c11c:	0792      	lsls	r2, r2, #30
    c11e:	d40e      	bmi.n	c13e <_wdt_init+0x52>
	((Wdt *)hw)->CTRLA.reg &= ~WDT_CTRLA_WEN;
    c120:	781a      	ldrb	r2, [r3, #0]
    c122:	f002 02fb 	and.w	r2, r2, #251	; 0xfb
    c126:	701a      	strb	r2, [r3, #0]
	while (((Wdt *)hw)->SYNCBUSY.reg & reg) {
    c128:	6898      	ldr	r0, [r3, #8]
    c12a:	f010 000e 	ands.w	r0, r0, #14
    c12e:	d1fb      	bne.n	c128 <_wdt_init+0x3c>

static inline void hri_wdt_write_CONFIG_PER_bf(const void *const hw, hri_wdt_config_reg_t data)
{
	uint8_t tmp;
	WDT_CRITICAL_SECTION_ENTER();
	tmp = ((Wdt *)hw)->CONFIG.reg;
    c130:	785a      	ldrb	r2, [r3, #1]
	tmp &= ~WDT_CONFIG_PER_Msk;
    c132:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
	tmp |= WDT_CONFIG_PER(data);
    c136:	f042 020b 	orr.w	r2, r2, #11
	((Wdt *)hw)->CONFIG.reg = tmp;
    c13a:	705a      	strb	r2, [r3, #1]

		hri_wdt_write_CONFIG_PER_bf(dev->hw, CONF_WDT_PER);
	}

	return ERR_NONE;
}
    c13c:	bd10      	pop	{r4, pc}
		return ERR_DENIED;
    c13e:	f06f 0010 	mvn.w	r0, #16
    c142:	e7fb      	b.n	c13c <_wdt_init+0x50>
    c144:	0000e9b9 	.word	0x0000e9b9
    c148:	00016d89 	.word	0x00016d89

0000c14c <usb_find_desc>:
#define _param_error_check(cond) ASSERT(cond)
#define _desc_len_check() ASSERT(usb_desc_len(desc) >= 2)
#endif

uint8_t *usb_find_desc(uint8_t *desc, uint8_t *eof, uint8_t type)
{
    c14c:	b510      	push	{r4, lr}
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    c14e:	4288      	cmp	r0, r1
    c150:	d301      	bcc.n	c156 <usb_find_desc+0xa>
		_desc_len_check();
    c152:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    c154:	bd10      	pop	{r4, pc}
		_desc_len_check();
    c156:	7803      	ldrb	r3, [r0, #0]
    c158:	2b01      	cmp	r3, #1
    c15a:	d9fa      	bls.n	c152 <usb_find_desc+0x6>
		if (type == usb_desc_type(desc)) {
    c15c:	7844      	ldrb	r4, [r0, #1]
    c15e:	4294      	cmp	r4, r2
    c160:	d0f8      	beq.n	c154 <usb_find_desc+0x8>
    c162:	4418      	add	r0, r3
    c164:	e7f3      	b.n	c14e <usb_find_desc+0x2>

0000c166 <usb_find_ep_desc>:

uint8_t *usb_find_ep_desc(uint8_t *desc, uint8_t *eof)
{
	_param_error_check(desc && eof && (desc < eof));

	while (desc < eof) {
    c166:	4288      	cmp	r0, r1
    c168:	d301      	bcc.n	c16e <usb_find_ep_desc+0x8>
		_desc_len_check();
    c16a:	2000      	movs	r0, #0
			return desc;
		}
		desc = usb_desc_next(desc);
	}
	return NULL;
}
    c16c:	4770      	bx	lr
		_desc_len_check();
    c16e:	7803      	ldrb	r3, [r0, #0]
    c170:	2b01      	cmp	r3, #1
    c172:	d9fa      	bls.n	c16a <usb_find_ep_desc+0x4>
	return desc[1];
    c174:	7842      	ldrb	r2, [r0, #1]
		if (USB_DT_INTERFACE == usb_desc_type(desc)) {
    c176:	2a04      	cmp	r2, #4
    c178:	d0f7      	beq.n	c16a <usb_find_ep_desc+0x4>
		if (USB_DT_ENDPOINT == usb_desc_type(desc)) {
    c17a:	2a05      	cmp	r2, #5
    c17c:	d0f6      	beq.n	c16c <usb_find_ep_desc+0x6>
	return (desc + usb_desc_len(desc));
    c17e:	4418      	add	r0, r3
    c180:	e7f1      	b.n	c166 <usb_find_ep_desc>
	...

0000c184 <usb_find_cfg_desc>:

uint8_t *usb_find_cfg_desc(uint8_t *desc, uint8_t *eof, uint8_t cfg_value)
{
    c184:	b538      	push	{r3, r4, r5, lr}
    c186:	4615      	mov	r5, r2
	_param_error_check(desc && eof && (desc < eof));

	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    c188:	4b0c      	ldr	r3, [pc, #48]	; (c1bc <usb_find_cfg_desc+0x38>)
    c18a:	2202      	movs	r2, #2
{
    c18c:	460c      	mov	r4, r1
	desc = usb_find_desc(desc, eof, USB_DT_CONFIG);
    c18e:	4798      	blx	r3
	if (!desc) {
    c190:	b978      	cbnz	r0, c1b2 <usb_find_cfg_desc+0x2e>
			return desc;
		}
		desc = usb_cfg_desc_next(desc);
	}
	return NULL;
}
    c192:	bd38      	pop	{r3, r4, r5, pc}
		_desc_len_check();
    c194:	7803      	ldrb	r3, [r0, #0]
    c196:	2b01      	cmp	r3, #1
    c198:	d90d      	bls.n	c1b6 <usb_find_cfg_desc+0x32>
		if (desc[1] != USB_DT_CONFIG) {
    c19a:	7843      	ldrb	r3, [r0, #1]
    c19c:	2b02      	cmp	r3, #2
    c19e:	d10a      	bne.n	c1b6 <usb_find_cfg_desc+0x32>
		if (desc[5] == cfg_value) {
    c1a0:	7943      	ldrb	r3, [r0, #5]
    c1a2:	42ab      	cmp	r3, r5
    c1a4:	d0f5      	beq.n	c192 <usb_find_cfg_desc+0xe>
	return (ptr[0] + (ptr[1] << 8));
    c1a6:	78c2      	ldrb	r2, [r0, #3]
    c1a8:	7883      	ldrb	r3, [r0, #2]
    c1aa:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 *  \param[in] cfg_desc Byte pointer to the descriptor start address
 *  \return Byte pointer to descriptor after configuration end
 */
static inline uint8_t *usb_cfg_desc_next(uint8_t *cfg_desc)
{
	return (cfg_desc + usb_cfg_desc_total_len(cfg_desc));
    c1ae:	fa10 f083 	uxtah	r0, r0, r3
	while (desc < eof) {
    c1b2:	42a0      	cmp	r0, r4
    c1b4:	d3ee      	bcc.n	c194 <usb_find_cfg_desc+0x10>
		return NULL;
    c1b6:	2000      	movs	r0, #0
    c1b8:	e7eb      	b.n	c192 <usb_find_cfg_desc+0xe>
    c1ba:	bf00      	nop
    c1bc:	0000c14d 	.word	0x0000c14d

0000c1c0 <usb_find_str_desc>:
	}
	return NULL;
}

uint8_t *usb_find_str_desc(uint8_t *desc, uint8_t *eof, uint8_t str_index)
{
    c1c0:	b570      	push	{r4, r5, r6, lr}
	uint8_t i;

	_param_error_check(desc && eof && (desc < eof));

	for (i = 0; desc < eof;) {
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    c1c2:	4e09      	ldr	r6, [pc, #36]	; (c1e8 <usb_find_str_desc+0x28>)
{
    c1c4:	4615      	mov	r5, r2
	for (i = 0; desc < eof;) {
    c1c6:	2400      	movs	r4, #0
    c1c8:	4288      	cmp	r0, r1
    c1ca:	d301      	bcc.n	c1d0 <usb_find_str_desc+0x10>
				return desc;
			}
			i++;
			desc = usb_desc_next(desc);
		} else {
			return NULL;
    c1cc:	2000      	movs	r0, #0
		}
	}
	return NULL;
}
    c1ce:	bd70      	pop	{r4, r5, r6, pc}
		desc = usb_find_desc(desc, eof, USB_DT_STRING);
    c1d0:	2203      	movs	r2, #3
    c1d2:	47b0      	blx	r6
		if (desc) {
    c1d4:	2800      	cmp	r0, #0
    c1d6:	d0fa      	beq.n	c1ce <usb_find_str_desc+0xe>
			_desc_len_check();
    c1d8:	7803      	ldrb	r3, [r0, #0]
    c1da:	2b01      	cmp	r3, #1
    c1dc:	d9f6      	bls.n	c1cc <usb_find_str_desc+0xc>
			if (i == str_index) {
    c1de:	42ac      	cmp	r4, r5
    c1e0:	d0f5      	beq.n	c1ce <usb_find_str_desc+0xe>
	return (desc + usb_desc_len(desc));
    c1e2:	4418      	add	r0, r3
    c1e4:	3401      	adds	r4, #1
    c1e6:	e7ef      	b.n	c1c8 <usb_find_str_desc+0x8>
    c1e8:	0000c14d 	.word	0x0000c14d

0000c1ec <stdio_io_init>:

/** IO descriptor for STDIO access. */
static struct io_descriptor *stdio_io = NULL;

void stdio_io_init(struct io_descriptor *io)
{
    c1ec:	b570      	push	{r4, r5, r6, lr}
#if defined(__GNUC__)
	/* Specify that stdout and stdin should not be buffered. */
	setbuf(stdout, NULL);
    c1ee:	4e07      	ldr	r6, [pc, #28]	; (c20c <stdio_io_init+0x20>)
    c1f0:	4d07      	ldr	r5, [pc, #28]	; (c210 <stdio_io_init+0x24>)
    c1f2:	6833      	ldr	r3, [r6, #0]
{
    c1f4:	4604      	mov	r4, r0
	setbuf(stdout, NULL);
    c1f6:	2100      	movs	r1, #0
    c1f8:	6898      	ldr	r0, [r3, #8]
    c1fa:	47a8      	blx	r5
	setbuf(stdin, NULL);
    c1fc:	6833      	ldr	r3, [r6, #0]
    c1fe:	2100      	movs	r1, #0
    c200:	6858      	ldr	r0, [r3, #4]
    c202:	47a8      	blx	r5
	 * and AVR GCC library:
	 * - printf() emits one character at a time.
	 * - getchar() requests only 1 byte to exit.
	 */
#endif
	stdio_io = io;
    c204:	4b03      	ldr	r3, [pc, #12]	; (c214 <stdio_io_init+0x28>)
    c206:	601c      	str	r4, [r3, #0]
}
    c208:	bd70      	pop	{r4, r5, r6, pc}
    c20a:	bf00      	nop
    c20c:	2000054c 	.word	0x2000054c
    c210:	00015095 	.word	0x00015095
    c214:	20008520 	.word	0x20008520

0000c218 <stdio_io_read>:
	stdio_io = io;
}

int32_t stdio_io_read(uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    c218:	4a04      	ldr	r2, [pc, #16]	; (c22c <stdio_io_read+0x14>)
{
    c21a:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    c21c:	6810      	ldr	r0, [r2, #0]
    c21e:	b118      	cbz	r0, c228 <stdio_io_read+0x10>
		return 0;
	}
	return io_read(stdio_io, buf, len);
    c220:	b28a      	uxth	r2, r1
    c222:	4619      	mov	r1, r3
    c224:	4b02      	ldr	r3, [pc, #8]	; (c230 <stdio_io_read+0x18>)
    c226:	4718      	bx	r3
}
    c228:	4770      	bx	lr
    c22a:	bf00      	nop
    c22c:	20008520 	.word	0x20008520
    c230:	0000ba2d 	.word	0x0000ba2d

0000c234 <stdio_io_write>:

int32_t stdio_io_write(const uint8_t *buf, const int32_t len)
{
	if (stdio_io == NULL) {
    c234:	4a04      	ldr	r2, [pc, #16]	; (c248 <stdio_io_write+0x14>)
{
    c236:	4603      	mov	r3, r0
	if (stdio_io == NULL) {
    c238:	6810      	ldr	r0, [r2, #0]
    c23a:	b118      	cbz	r0, c244 <stdio_io_write+0x10>
		return 0;
	}
	return io_write(stdio_io, buf, len);
    c23c:	b28a      	uxth	r2, r1
    c23e:	4619      	mov	r1, r3
    c240:	4b02      	ldr	r3, [pc, #8]	; (c24c <stdio_io_write+0x18>)
    c242:	4718      	bx	r3
}
    c244:	4770      	bx	lr
    c246:	bf00      	nop
    c248:	20008520 	.word	0x20008520
    c24c:	0000b9fd 	.word	0x0000b9fd

0000c250 <_spi_m_dma_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_dma_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    c250:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    c252:	4604      	mov	r4, r0
    c254:	3800      	subs	r0, #0
{
    c256:	460d      	mov	r5, r1
    c258:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    c25a:	bf18      	it	ne
    c25c:	2001      	movne	r0, #1
    c25e:	4907      	ldr	r1, [pc, #28]	; (c27c <_spi_m_dma_io_write+0x2c>)
    c260:	4e07      	ldr	r6, [pc, #28]	; (c280 <_spi_m_dma_io_write+0x30>)
    c262:	2298      	movs	r2, #152	; 0x98
    c264:	47b0      	blx	r6

	struct spi_m_dma_descriptor *spi = CONTAINER_OF(io, struct spi_m_dma_descriptor, io);
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    c266:	f1a4 001c 	sub.w	r0, r4, #28
    c26a:	4c06      	ldr	r4, [pc, #24]	; (c284 <_spi_m_dma_io_write+0x34>)
    c26c:	9b01      	ldr	r3, [sp, #4]
    c26e:	2200      	movs	r2, #0
    c270:	4629      	mov	r1, r5
    c272:	46a4      	mov	ip, r4
}
    c274:	b002      	add	sp, #8
    c276:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, buf, NULL, length);
    c27a:	4760      	bx	ip
    c27c:	00016d9e 	.word	0x00016d9e
    c280:	0000e9b9 	.word	0x0000e9b9
    c284:	00012271 	.word	0x00012271

0000c288 <_spi_m_dma_io_read>:
{
    c288:	b573      	push	{r0, r1, r4, r5, r6, lr}
	ASSERT(io);
    c28a:	4604      	mov	r4, r0
    c28c:	3800      	subs	r0, #0
{
    c28e:	460d      	mov	r5, r1
    c290:	9201      	str	r2, [sp, #4]
	ASSERT(io);
    c292:	bf18      	it	ne
    c294:	2001      	movne	r0, #1
    c296:	4907      	ldr	r1, [pc, #28]	; (c2b4 <_spi_m_dma_io_read+0x2c>)
    c298:	4e07      	ldr	r6, [pc, #28]	; (c2b8 <_spi_m_dma_io_read+0x30>)
    c29a:	2281      	movs	r2, #129	; 0x81
    c29c:	47b0      	blx	r6
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    c29e:	f1a4 001c 	sub.w	r0, r4, #28
    c2a2:	4c06      	ldr	r4, [pc, #24]	; (c2bc <_spi_m_dma_io_read+0x34>)
    c2a4:	9b01      	ldr	r3, [sp, #4]
    c2a6:	462a      	mov	r2, r5
    c2a8:	2100      	movs	r1, #0
    c2aa:	46a4      	mov	ip, r4
}
    c2ac:	b002      	add	sp, #8
    c2ae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_dma_transfer(&spi->dev, NULL, buf, length);
    c2b2:	4760      	bx	ip
    c2b4:	00016d9e 	.word	0x00016d9e
    c2b8:	0000e9b9 	.word	0x0000e9b9
    c2bc:	00012271 	.word	0x00012271

0000c2c0 <spi_m_dma_init>:
{
    c2c0:	b538      	push	{r3, r4, r5, lr}
    c2c2:	460d      	mov	r5, r1
	ASSERT(spi && hw);
    c2c4:	4604      	mov	r4, r0
    c2c6:	b110      	cbz	r0, c2ce <spi_m_dma_init+0xe>
    c2c8:	1e08      	subs	r0, r1, #0
    c2ca:	bf18      	it	ne
    c2cc:	2001      	movne	r0, #1
    c2ce:	4908      	ldr	r1, [pc, #32]	; (c2f0 <spi_m_dma_init+0x30>)
    c2d0:	4b08      	ldr	r3, [pc, #32]	; (c2f4 <spi_m_dma_init+0x34>)
    c2d2:	223b      	movs	r2, #59	; 0x3b
    c2d4:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    c2d6:	4620      	mov	r0, r4
	rc            = _spi_m_dma_init(&spi->dev, hw);
    c2d8:	4b07      	ldr	r3, [pc, #28]	; (c2f8 <spi_m_dma_init+0x38>)
	spi->dev.prvt = (void *)hw;
    c2da:	f840 5f04 	str.w	r5, [r0, #4]!
	rc            = _spi_m_dma_init(&spi->dev, hw);
    c2de:	4629      	mov	r1, r5
    c2e0:	4798      	blx	r3
	if (rc) {
    c2e2:	b918      	cbnz	r0, c2ec <spi_m_dma_init+0x2c>
	spi->io.read  = _spi_m_dma_io_read;
    c2e4:	4b05      	ldr	r3, [pc, #20]	; (c2fc <spi_m_dma_init+0x3c>)
    c2e6:	6263      	str	r3, [r4, #36]	; 0x24
	spi->io.write = _spi_m_dma_io_write;
    c2e8:	4b05      	ldr	r3, [pc, #20]	; (c300 <spi_m_dma_init+0x40>)
    c2ea:	6223      	str	r3, [r4, #32]
}
    c2ec:	bd38      	pop	{r3, r4, r5, pc}
    c2ee:	bf00      	nop
    c2f0:	00016d9e 	.word	0x00016d9e
    c2f4:	0000e9b9 	.word	0x0000e9b9
    c2f8:	000120e9 	.word	0x000120e9
    c2fc:	0000c289 	.word	0x0000c289
    c300:	0000c251 	.word	0x0000c251

0000c304 <spi_m_dma_enable>:
{
    c304:	b510      	push	{r4, lr}
	ASSERT(spi);
    c306:	4604      	mov	r4, r0
    c308:	3800      	subs	r0, #0
    c30a:	4b05      	ldr	r3, [pc, #20]	; (c320 <spi_m_dma_enable+0x1c>)
    c30c:	4905      	ldr	r1, [pc, #20]	; (c324 <spi_m_dma_enable+0x20>)
    c30e:	bf18      	it	ne
    c310:	2001      	movne	r0, #1
    c312:	2251      	movs	r2, #81	; 0x51
    c314:	4798      	blx	r3
	_spi_m_dma_enable(&spi->dev);
    c316:	1d20      	adds	r0, r4, #4
    c318:	4b03      	ldr	r3, [pc, #12]	; (c328 <spi_m_dma_enable+0x24>)
}
    c31a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_dma_enable(&spi->dev);
    c31e:	4718      	bx	r3
    c320:	0000e9b9 	.word	0x0000e9b9
    c324:	00016d9e 	.word	0x00016d9e
    c328:	000121ad 	.word	0x000121ad

0000c32c <spi_m_dma_register_callback>:
	return _spi_m_dma_transfer(&spi->dev, txbuf, rxbuf, length);
}

void spi_m_dma_register_callback(struct spi_m_dma_descriptor *spi, const enum spi_m_dma_cb_type type,
                                 spi_m_dma_cb_t func)
{
    c32c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    c32e:	4604      	mov	r4, r0
    c330:	3800      	subs	r0, #0
{
    c332:	460d      	mov	r5, r1
    c334:	4616      	mov	r6, r2
	ASSERT(spi);
    c336:	4907      	ldr	r1, [pc, #28]	; (c354 <spi_m_dma_register_callback+0x28>)
    c338:	4b07      	ldr	r3, [pc, #28]	; (c358 <spi_m_dma_register_callback+0x2c>)
    c33a:	f04f 02a8 	mov.w	r2, #168	; 0xa8
    c33e:	bf18      	it	ne
    c340:	2001      	movne	r0, #1
    c342:	4798      	blx	r3
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    c344:	4632      	mov	r2, r6
    c346:	4629      	mov	r1, r5
    c348:	1d20      	adds	r0, r4, #4
    c34a:	4b04      	ldr	r3, [pc, #16]	; (c35c <spi_m_dma_register_callback+0x30>)
}
    c34c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	_spi_m_dma_register_callback(&spi->dev, (enum _spi_dma_dev_cb_type)type, func);
    c350:	4718      	bx	r3
    c352:	bf00      	nop
    c354:	00016d9e 	.word	0x00016d9e
    c358:	0000e9b9 	.word	0x0000e9b9
    c35c:	000121dd 	.word	0x000121dd

0000c360 <spi_m_dma_get_io_descriptor>:

int32_t spi_m_dma_get_io_descriptor(struct spi_m_dma_descriptor *const spi, struct io_descriptor **io)
{
    c360:	b538      	push	{r3, r4, r5, lr}
    c362:	460d      	mov	r5, r1
	ASSERT(spi && io);
    c364:	4604      	mov	r4, r0
    c366:	b110      	cbz	r0, c36e <spi_m_dma_get_io_descriptor+0xe>
    c368:	1e08      	subs	r0, r1, #0
    c36a:	bf18      	it	ne
    c36c:	2001      	movne	r0, #1
    c36e:	4904      	ldr	r1, [pc, #16]	; (c380 <spi_m_dma_get_io_descriptor+0x20>)
    c370:	4b04      	ldr	r3, [pc, #16]	; (c384 <spi_m_dma_get_io_descriptor+0x24>)
    c372:	22ae      	movs	r2, #174	; 0xae
	*io = &spi->io;
    c374:	3420      	adds	r4, #32
	ASSERT(spi && io);
    c376:	4798      	blx	r3
	*io = &spi->io;
    c378:	602c      	str	r4, [r5, #0]

	return 0;
}
    c37a:	2000      	movs	r0, #0
    c37c:	bd38      	pop	{r3, r4, r5, pc}
    c37e:	bf00      	nop
    c380:	00016d9e 	.word	0x00016d9e
    c384:	0000e9b9 	.word	0x0000e9b9

0000c388 <_write>:

int __attribute__((weak)) _write(int file, char *ptr, int len)
{
	int n = 0;

	if ((file != 1) && (file != 2) && (file != 3)) {
    c388:	3801      	subs	r0, #1
    c38a:	2802      	cmp	r0, #2
{
    c38c:	b508      	push	{r3, lr}
    c38e:	460b      	mov	r3, r1
    c390:	4611      	mov	r1, r2
	if ((file != 1) && (file != 2) && (file != 3)) {
    c392:	d805      	bhi.n	c3a0 <_write+0x18>
		return -1;
	}

	n = stdio_io_write((const uint8_t *)ptr, len);
    c394:	4618      	mov	r0, r3
    c396:	4b04      	ldr	r3, [pc, #16]	; (c3a8 <_write+0x20>)
    c398:	4798      	blx	r3
	if (n < 0) {
    c39a:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    c39e:	bd08      	pop	{r3, pc}
		return -1;
    c3a0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c3a4:	e7fb      	b.n	c39e <_write+0x16>
    c3a6:	bf00      	nop
    c3a8:	0000c235 	.word	0x0000c235

0000c3ac <_event_system_init>:

/**
 * \brief Initialize event system
 */
int32_t _event_system_init(void)
{
    c3ac:	b510      	push	{r4, lr}
    c3ae:	4a13      	ldr	r2, [pc, #76]	; (c3fc <_event_system_init+0x50>)
}

static inline void hri_evsys_write_USER_reg(const void *const hw, uint8_t index, hri_evsys_user_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->USER[index].reg = data;
    c3b0:	4913      	ldr	r1, [pc, #76]	; (c400 <_event_system_init+0x54>)
    c3b2:	2300      	movs	r3, #0
    c3b4:	f103 0048 	add.w	r0, r3, #72	; 0x48
    c3b8:	3301      	adds	r3, #1
	uint8_t i;
	/* configure user multiplexers */
	for (i = 0; i < EVSYS_USERS; i++) {
		hri_evsys_write_USER_reg(EVSYS, i, user_mux_confs[i]);
    c3ba:	f812 4b01 	ldrb.w	r4, [r2], #1
    c3be:	f841 4020 	str.w	r4, [r1, r0, lsl #2]
	for (i = 0; i < EVSYS_USERS; i++) {
    c3c2:	2b43      	cmp	r3, #67	; 0x43
    c3c4:	d1f6      	bne.n	c3b4 <_event_system_init+0x8>
    c3c6:	480f      	ldr	r0, [pc, #60]	; (c404 <_event_system_init+0x58>)
    c3c8:	2100      	movs	r1, #0
    c3ca:	f100 0440 	add.w	r4, r0, #64	; 0x40
	}

	/* configure channels */
	for (i = 0; i < EVSYS_CHANNELS; i++) {
		hri_evsys_write_CHANNEL_reg(EVSYS, i, channel_confs[i]);
    c3ce:	00ca      	lsls	r2, r1, #3
    c3d0:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    c3d4:	f502 4260 	add.w	r2, r2, #57344	; 0xe000
    c3d8:	f830 3b02 	ldrh.w	r3, [r0], #2

static inline void hri_evsys_write_CHANNEL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_evsys_channel_reg_t data)
{
	EVSYS_CRITICAL_SECTION_ENTER();
	((Evsys *)hw)->Channel[submodule_index].CHANNEL.reg = data;
    c3dc:	6213      	str	r3, [r2, #32]
		hri_evsys_write_CHINTEN_reg(EVSYS, i, interrupt_cfg[i]);
    c3de:	f854 3b04 	ldr.w	r3, [r4], #4
    c3e2:	b2db      	uxtb	r3, r3
	((Evsys *)hw)->Channel[submodule_index].CHINTENSET.reg = data;
    c3e4:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25
	((Evsys *)hw)->Channel[submodule_index].CHINTENCLR.reg = ~data;
    c3e8:	3101      	adds	r1, #1
    c3ea:	43db      	mvns	r3, r3
    c3ec:	b2db      	uxtb	r3, r3
	for (i = 0; i < EVSYS_CHANNELS; i++) {
    c3ee:	2920      	cmp	r1, #32
    c3f0:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    c3f4:	d1eb      	bne.n	c3ce <_event_system_init+0x22>
	}

	return ERR_NONE;
}
    c3f6:	2000      	movs	r0, #0
    c3f8:	bd10      	pop	{r4, pc}
    c3fa:	bf00      	nop
    c3fc:	00016dbc 	.word	0x00016dbc
    c400:	4100e000 	.word	0x4100e000
    c404:	00016e00 	.word	0x00016e00

0000c408 <_irq_set>:
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c408:	0943      	lsrs	r3, r0, #5
    c40a:	2201      	movs	r2, #1
    c40c:	f000 001f 	and.w	r0, r0, #31
    c410:	fa02 f000 	lsl.w	r0, r2, r0
    c414:	3340      	adds	r3, #64	; 0x40
    c416:	4a02      	ldr	r2, [pc, #8]	; (c420 <_irq_set+0x18>)
    c418:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
 * \brief Set the given IRQ
 */
void _irq_set(uint8_t n)
{
	NVIC_SetPendingIRQ((IRQn_Type)n);
}
    c41c:	4770      	bx	lr
    c41e:	bf00      	nop
    c420:	e000e100 	.word	0xe000e100

0000c424 <_get_cycles_for_ms>:
 * \brief Retrieve the amount of cycles to delay for the given amount of ms
 */
uint32_t _get_cycles_for_ms(const uint16_t ms)
{
	return _get_cycles_for_ms_internal(ms, CONF_CPU_FREQUENCY, CPU_FREQ_POWER);
}
    c424:	4b01      	ldr	r3, [pc, #4]	; (c42c <_get_cycles_for_ms+0x8>)
    c426:	4358      	muls	r0, r3
    c428:	4770      	bx	lr
    c42a:	bf00      	nop
    c42c:	0001d4c0 	.word	0x0001d4c0

0000c430 <cdcdf_acm_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t cdcdf_acm_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    c430:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    c434:	4615      	mov	r5, r2
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    c436:	780a      	ldrb	r2, [r1, #0]
    c438:	f3c2 1341 	ubfx	r3, r2, #5, #2
    c43c:	2b01      	cmp	r3, #1
{
    c43e:	4606      	mov	r6, r0
    c440:	460c      	mov	r4, r1
	if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    c442:	d155      	bne.n	c4f0 <cdcdf_acm_req+0xc0>
		return ERR_NOT_FOUND;
	}
	if ((req->wIndex == _cdcdf_acm_funcd.func_iface[0]) || (req->wIndex == _cdcdf_acm_funcd.func_iface[1])) {
    c444:	4b2d      	ldr	r3, [pc, #180]	; (c4fc <cdcdf_acm_req+0xcc>)
    c446:	8889      	ldrh	r1, [r1, #4]
    c448:	7818      	ldrb	r0, [r3, #0]
    c44a:	4288      	cmp	r0, r1
    c44c:	4698      	mov	r8, r3
    c44e:	d002      	beq.n	c456 <cdcdf_acm_req+0x26>
    c450:	785b      	ldrb	r3, [r3, #1]
    c452:	428b      	cmp	r3, r1
    c454:	d14c      	bne.n	c4f0 <cdcdf_acm_req+0xc0>
		if (req->bmRequestType & USB_EP_DIR_IN) {
    c456:	0613      	lsls	r3, r2, #24
    c458:	88e7      	ldrh	r7, [r4, #6]
    c45a:	d50f      	bpl.n	c47c <cdcdf_acm_req+0x4c>
	if (USB_DATA_STAGE == stage) {
    c45c:	2d01      	cmp	r5, #1
    c45e:	d033      	beq.n	c4c8 <cdcdf_acm_req+0x98>
	switch (req->bRequest) {
    c460:	7863      	ldrb	r3, [r4, #1]
    c462:	2b21      	cmp	r3, #33	; 0x21
    c464:	d112      	bne.n	c48c <cdcdf_acm_req+0x5c>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    c466:	2f07      	cmp	r7, #7
    c468:	d145      	bne.n	c4f6 <cdcdf_acm_req+0xc6>
		return usbdc_xfer(ep, (uint8_t *)&usbd_cdc_line_coding, len, false);
    c46a:	4925      	ldr	r1, [pc, #148]	; (c500 <cdcdf_acm_req+0xd0>)
    c46c:	2300      	movs	r3, #0
    c46e:	463a      	mov	r2, r7
			return usbdc_xfer(ep, ctrl_buf, len, false);
    c470:	4c24      	ldr	r4, [pc, #144]	; (c504 <cdcdf_acm_req+0xd4>)
    c472:	4630      	mov	r0, r6
    c474:	47a0      	blx	r4
			return cdcdf_acm_set_req(ep, req, stage);
		}
	} else {
		return ERR_NOT_FOUND;
	}
}
    c476:	b002      	add	sp, #8
    c478:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    c47c:	4b22      	ldr	r3, [pc, #136]	; (c508 <cdcdf_acm_req+0xd8>)
    c47e:	4798      	blx	r3
	switch (req->bRequest) {
    c480:	7863      	ldrb	r3, [r4, #1]
    c482:	2b20      	cmp	r3, #32
	uint8_t *                  ctrl_buf = usbdc_get_ctrl_buffer();
    c484:	4601      	mov	r1, r0
	switch (req->bRequest) {
    c486:	d004      	beq.n	c492 <cdcdf_acm_req+0x62>
    c488:	2b22      	cmp	r3, #34	; 0x22
    c48a:	d024      	beq.n	c4d6 <cdcdf_acm_req+0xa6>
		return ERR_INVALID_ARG;
    c48c:	f06f 000c 	mvn.w	r0, #12
    c490:	e7f1      	b.n	c476 <cdcdf_acm_req+0x46>
		if (sizeof(struct usb_cdc_line_coding) != len) {
    c492:	2f07      	cmp	r7, #7
    c494:	d12f      	bne.n	c4f6 <cdcdf_acm_req+0xc6>
		if (USB_SETUP_STAGE == stage) {
    c496:	b915      	cbnz	r5, c49e <cdcdf_acm_req+0x6e>
			return usbdc_xfer(ep, ctrl_buf, len, false);
    c498:	462b      	mov	r3, r5
    c49a:	463a      	mov	r2, r7
    c49c:	e7e8      	b.n	c470 <cdcdf_acm_req+0x40>
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    c49e:	6800      	ldr	r0, [r0, #0]
    c4a0:	9000      	str	r0, [sp, #0]
    c4a2:	798b      	ldrb	r3, [r1, #6]
    c4a4:	888a      	ldrh	r2, [r1, #4]
    c4a6:	f88d 3006 	strb.w	r3, [sp, #6]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    c4aa:	f8d8 3010 	ldr.w	r3, [r8, #16]
			memcpy(&line_coding_tmp, ctrl_buf, sizeof(struct usb_cdc_line_coding));
    c4ae:	f8ad 2004 	strh.w	r2, [sp, #4]
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    c4b2:	b95b      	cbnz	r3, c4cc <cdcdf_acm_req+0x9c>
				usbd_cdc_line_coding = line_coding_tmp;
    c4b4:	4b12      	ldr	r3, [pc, #72]	; (c500 <cdcdf_acm_req+0xd0>)
    c4b6:	9800      	ldr	r0, [sp, #0]
    c4b8:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    c4bc:	f89d 2006 	ldrb.w	r2, [sp, #6]
    c4c0:	f8c8 0006 	str.w	r0, [r8, #6]
    c4c4:	8099      	strh	r1, [r3, #4]
    c4c6:	719a      	strb	r2, [r3, #6]
		return ERR_NONE;
    c4c8:	2000      	movs	r0, #0
    c4ca:	e7d4      	b.n	c476 <cdcdf_acm_req+0x46>
			if ((NULL == cdcdf_acm_set_line_coding) || (true == cdcdf_acm_set_line_coding(&line_coding_tmp))) {
    c4cc:	4668      	mov	r0, sp
    c4ce:	4798      	blx	r3
    c4d0:	2800      	cmp	r0, #0
    c4d2:	d1ef      	bne.n	c4b4 <cdcdf_acm_req+0x84>
    c4d4:	e7f8      	b.n	c4c8 <cdcdf_acm_req+0x98>
		usbdc_xfer(0, NULL, 0, 0);
    c4d6:	2300      	movs	r3, #0
    c4d8:	461a      	mov	r2, r3
    c4da:	4619      	mov	r1, r3
    c4dc:	4618      	mov	r0, r3
    c4de:	4d09      	ldr	r5, [pc, #36]	; (c504 <cdcdf_acm_req+0xd4>)
    c4e0:	47a8      	blx	r5
		if (NULL != cdcdf_acm_notify_state) {
    c4e2:	f8d8 3014 	ldr.w	r3, [r8, #20]
    c4e6:	2b00      	cmp	r3, #0
    c4e8:	d0ee      	beq.n	c4c8 <cdcdf_acm_req+0x98>
			cdcdf_acm_notify_state(req->wValue);
    c4ea:	8860      	ldrh	r0, [r4, #2]
    c4ec:	4798      	blx	r3
    c4ee:	e7eb      	b.n	c4c8 <cdcdf_acm_req+0x98>
		return ERR_NOT_FOUND;
    c4f0:	f06f 0009 	mvn.w	r0, #9
    c4f4:	e7bf      	b.n	c476 <cdcdf_acm_req+0x46>
			return ERR_INVALID_DATA;
    c4f6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c4fa:	e7bc      	b.n	c476 <cdcdf_acm_req+0x46>
    c4fc:	20008524 	.word	0x20008524
    c500:	2000852a 	.word	0x2000852a
    c504:	00013c9d 	.word	0x00013c9d
    c508:	000140c9 	.word	0x000140c9

0000c50c <cdcdf_acm_ctrl>:
	switch (ctrl) {
    c50c:	2901      	cmp	r1, #1
{
    c50e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c512:	4615      	mov	r5, r2
	switch (ctrl) {
    c514:	d04f      	beq.n	c5b6 <cdcdf_acm_ctrl+0xaa>
    c516:	2902      	cmp	r1, #2
    c518:	d076      	beq.n	c608 <cdcdf_acm_ctrl+0xfc>
    c51a:	2900      	cmp	r1, #0
    c51c:	d177      	bne.n	c60e <cdcdf_acm_ctrl+0x102>
		return cdcdf_acm_enable(drv, (struct usbd_descriptors *)param);
    c51e:	6887      	ldr	r7, [r0, #8]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    c520:	f8df 8114 	ldr.w	r8, [pc, #276]	; c638 <cdcdf_acm_ctrl+0x12c>
	ifc = desc->sod;
    c524:	6810      	ldr	r0, [r2, #0]
	for (i = 0; i < 2; i++) {
    c526:	1e7e      	subs	r6, r7, #1
		if (NULL == ifc) {
    c528:	b928      	cbnz	r0, c536 <cdcdf_acm_ctrl+0x2a>
			return ERR_NOT_FOUND;
    c52a:	f06f 0009 	mvn.w	r0, #9
}
    c52e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c532:	464e      	mov	r6, r9
    c534:	e7f8      	b.n	c528 <cdcdf_acm_ctrl+0x1c>
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    c536:	7943      	ldrb	r3, [r0, #5]
		ifc_desc.bInterfaceNumber = ifc[2];
    c538:	7882      	ldrb	r2, [r0, #2]
		if ((CDC_CLASS_COMM == ifc_desc.bInterfaceClass) || (CDC_CLASS_DATA == ifc_desc.bInterfaceClass)) {
    c53a:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    c53e:	2b02      	cmp	r3, #2
    c540:	d1f3      	bne.n	c52a <cdcdf_acm_ctrl+0x1e>
			if (func_data->func_iface[i] == ifc_desc.bInterfaceNumber) { // Initialized
    c542:	7873      	ldrb	r3, [r6, #1]
    c544:	429a      	cmp	r2, r3
    c546:	d065      	beq.n	c614 <cdcdf_acm_ctrl+0x108>
			} else if (func_data->func_iface[i] != 0xFF) { // Occupied
    c548:	2bff      	cmp	r3, #255	; 0xff
    c54a:	d166      	bne.n	c61a <cdcdf_acm_ctrl+0x10e>
				func_data->func_iface[i] = ifc_desc.bInterfaceNumber;
    c54c:	7072      	strb	r2, [r6, #1]
		ep = usb_find_desc(ifc, desc->eod, USB_DT_ENDPOINT);
    c54e:	6869      	ldr	r1, [r5, #4]
    c550:	f8df a0e8 	ldr.w	sl, [pc, #232]	; c63c <cdcdf_acm_ctrl+0x130>
    c554:	2205      	movs	r2, #5
    c556:	47c0      	blx	r8
    c558:	f106 0901 	add.w	r9, r6, #1
    c55c:	4604      	mov	r4, r0
		while (NULL != ep) {
    c55e:	b964      	cbnz	r4, c57a <cdcdf_acm_ctrl+0x6e>
		ifc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_INTERFACE);
    c560:	682b      	ldr	r3, [r5, #0]
    c562:	6869      	ldr	r1, [r5, #4]
    c564:	7818      	ldrb	r0, [r3, #0]
    c566:	2204      	movs	r2, #4
    c568:	4418      	add	r0, r3
    c56a:	47c0      	blx	r8
	for (i = 0; i < 2; i++) {
    c56c:	42be      	cmp	r6, r7
    c56e:	d1e0      	bne.n	c532 <cdcdf_acm_ctrl+0x26>
	_cdcdf_acm_funcd.enabled = true;
    c570:	4b2d      	ldr	r3, [pc, #180]	; (c628 <cdcdf_acm_ctrl+0x11c>)
    c572:	2201      	movs	r2, #1
    c574:	715a      	strb	r2, [r3, #5]
	return ERR_NONE;
    c576:	4620      	mov	r0, r4
    c578:	e7d9      	b.n	c52e <cdcdf_acm_ctrl+0x22>
	return (ptr[0] + (ptr[1] << 8));
    c57a:	7961      	ldrb	r1, [r4, #5]
    c57c:	7922      	ldrb	r2, [r4, #4]
			ep_desc.bEndpointAddress = ep[2];
    c57e:	f894 b002 	ldrb.w	fp, [r4, #2]
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    c582:	4b2a      	ldr	r3, [pc, #168]	; (c62c <cdcdf_acm_ctrl+0x120>)
    c584:	eb02 2201 	add.w	r2, r2, r1, lsl #8
    c588:	b292      	uxth	r2, r2
    c58a:	78e1      	ldrb	r1, [r4, #3]
    c58c:	4658      	mov	r0, fp
    c58e:	4798      	blx	r3
    c590:	2800      	cmp	r0, #0
    c592:	d145      	bne.n	c620 <cdcdf_acm_ctrl+0x114>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    c594:	f01b 0f80 	tst.w	fp, #128	; 0x80
				func_data->func_ep_in[i] = ep_desc.bEndpointAddress;
    c598:	bf14      	ite	ne
    c59a:	f889 b002 	strbne.w	fp, [r9, #2]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    c59e:	f887 b004 	strbeq.w	fp, [r7, #4]
				usb_d_ep_enable(func_data->func_ep_out);
    c5a2:	4658      	mov	r0, fp
    c5a4:	47d0      	blx	sl
			desc->sod = ep;
    c5a6:	602c      	str	r4, [r5, #0]
	return (desc + usb_desc_len(desc));
    c5a8:	7820      	ldrb	r0, [r4, #0]
			ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    c5aa:	6869      	ldr	r1, [r5, #4]
    c5ac:	4b20      	ldr	r3, [pc, #128]	; (c630 <cdcdf_acm_ctrl+0x124>)
    c5ae:	4420      	add	r0, r4
    c5b0:	4798      	blx	r3
    c5b2:	4604      	mov	r4, r0
    c5b4:	e7d3      	b.n	c55e <cdcdf_acm_ctrl+0x52>
		return cdcdf_acm_disable(drv, (struct usbd_descriptors *)param);
    c5b6:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    c5b8:	b12a      	cbz	r2, c5c6 <cdcdf_acm_ctrl+0xba>
		ifc_desc.bInterfaceClass = desc->sod[5];
    c5ba:	6813      	ldr	r3, [r2, #0]
		if ((ifc_desc.bInterfaceClass != CDC_CLASS_COMM) && (ifc_desc.bInterfaceClass != CDC_CLASS_DATA)) {
    c5bc:	795b      	ldrb	r3, [r3, #5]
    c5be:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
    c5c2:	2b02      	cmp	r3, #2
    c5c4:	d1b1      	bne.n	c52a <cdcdf_acm_ctrl+0x1e>
		if (func_data->func_iface[i] == 0xFF) {
    c5c6:	7823      	ldrb	r3, [r4, #0]
    c5c8:	2bff      	cmp	r3, #255	; 0xff
    c5ca:	d007      	beq.n	c5dc <cdcdf_acm_ctrl+0xd0>
			if (func_data->func_ep_in[i] != 0xFF) {
    c5cc:	78a0      	ldrb	r0, [r4, #2]
			func_data->func_iface[i] = 0xFF;
    c5ce:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    c5d0:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    c5d2:	7025      	strb	r5, [r4, #0]
			if (func_data->func_ep_in[i] != 0xFF) {
    c5d4:	d002      	beq.n	c5dc <cdcdf_acm_ctrl+0xd0>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    c5d6:	4b17      	ldr	r3, [pc, #92]	; (c634 <cdcdf_acm_ctrl+0x128>)
    c5d8:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    c5da:	70a5      	strb	r5, [r4, #2]
		if (func_data->func_iface[i] == 0xFF) {
    c5dc:	7863      	ldrb	r3, [r4, #1]
    c5de:	2bff      	cmp	r3, #255	; 0xff
    c5e0:	d007      	beq.n	c5f2 <cdcdf_acm_ctrl+0xe6>
			if (func_data->func_ep_in[i] != 0xFF) {
    c5e2:	78e0      	ldrb	r0, [r4, #3]
			func_data->func_iface[i] = 0xFF;
    c5e4:	25ff      	movs	r5, #255	; 0xff
			if (func_data->func_ep_in[i] != 0xFF) {
    c5e6:	42a8      	cmp	r0, r5
			func_data->func_iface[i] = 0xFF;
    c5e8:	7065      	strb	r5, [r4, #1]
			if (func_data->func_ep_in[i] != 0xFF) {
    c5ea:	d002      	beq.n	c5f2 <cdcdf_acm_ctrl+0xe6>
				usb_d_ep_deinit(func_data->func_ep_in[i]);
    c5ec:	4b11      	ldr	r3, [pc, #68]	; (c634 <cdcdf_acm_ctrl+0x128>)
    c5ee:	4798      	blx	r3
				func_data->func_ep_in[i] = 0xFF;
    c5f0:	70e5      	strb	r5, [r4, #3]
	if (func_data->func_ep_out != 0xFF) {
    c5f2:	7920      	ldrb	r0, [r4, #4]
    c5f4:	28ff      	cmp	r0, #255	; 0xff
    c5f6:	d003      	beq.n	c600 <cdcdf_acm_ctrl+0xf4>
		usb_d_ep_deinit(func_data->func_ep_out);
    c5f8:	4b0e      	ldr	r3, [pc, #56]	; (c634 <cdcdf_acm_ctrl+0x128>)
    c5fa:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    c5fc:	23ff      	movs	r3, #255	; 0xff
    c5fe:	7123      	strb	r3, [r4, #4]
	_cdcdf_acm_funcd.enabled = false;
    c600:	4b09      	ldr	r3, [pc, #36]	; (c628 <cdcdf_acm_ctrl+0x11c>)
    c602:	2000      	movs	r0, #0
    c604:	7158      	strb	r0, [r3, #5]
	return ERR_NONE;
    c606:	e792      	b.n	c52e <cdcdf_acm_ctrl+0x22>
		return ERR_UNSUPPORTED_OP;
    c608:	f06f 001a 	mvn.w	r0, #26
    c60c:	e78f      	b.n	c52e <cdcdf_acm_ctrl+0x22>
	switch (ctrl) {
    c60e:	f06f 000c 	mvn.w	r0, #12
    c612:	e78c      	b.n	c52e <cdcdf_acm_ctrl+0x22>
				return ERR_ALREADY_INITIALIZED;
    c614:	f06f 0011 	mvn.w	r0, #17
    c618:	e789      	b.n	c52e <cdcdf_acm_ctrl+0x22>
				return ERR_NO_RESOURCE;
    c61a:	f06f 001b 	mvn.w	r0, #27
    c61e:	e786      	b.n	c52e <cdcdf_acm_ctrl+0x22>
				return ERR_NOT_INITIALIZED;
    c620:	f06f 0013 	mvn.w	r0, #19
    c624:	e783      	b.n	c52e <cdcdf_acm_ctrl+0x22>
    c626:	bf00      	nop
    c628:	20008524 	.word	0x20008524
    c62c:	0000fe9d 	.word	0x0000fe9d
    c630:	0000c167 	.word	0x0000c167
    c634:	0000ff01 	.word	0x0000ff01
    c638:	0000c14d 	.word	0x0000c14d
    c63c:	0000ff2d 	.word	0x0000ff2d

0000c640 <cdcdf_acm_init>:

/**
 * \brief Initialize the USB CDC ACM Function Driver
 */
int32_t cdcdf_acm_init(void)
{
    c640:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    c642:	4b0a      	ldr	r3, [pc, #40]	; (c66c <cdcdf_acm_init+0x2c>)
    c644:	4798      	blx	r3
    c646:	2801      	cmp	r0, #1
    c648:	d80c      	bhi.n	c664 <cdcdf_acm_init+0x24>
		return ERR_DENIED;
	}

	_cdcdf_acm.ctrl      = cdcdf_acm_ctrl;
    c64a:	4809      	ldr	r0, [pc, #36]	; (c670 <cdcdf_acm_init+0x30>)
    c64c:	4b09      	ldr	r3, [pc, #36]	; (c674 <cdcdf_acm_init+0x34>)
	_cdcdf_acm.func_data = &_cdcdf_acm_funcd;
    c64e:	e9c0 3007 	strd	r3, r0, [r0, #28]

	usbdc_register_function(&_cdcdf_acm);
    c652:	4b09      	ldr	r3, [pc, #36]	; (c678 <cdcdf_acm_init+0x38>)
    c654:	3018      	adds	r0, #24
    c656:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &cdcdf_acm_req_h);
    c658:	2001      	movs	r0, #1
    c65a:	4908      	ldr	r1, [pc, #32]	; (c67c <cdcdf_acm_init+0x3c>)
    c65c:	4b08      	ldr	r3, [pc, #32]	; (c680 <cdcdf_acm_init+0x40>)
    c65e:	4798      	blx	r3
	return ERR_NONE;
    c660:	2000      	movs	r0, #0
}
    c662:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    c664:	f06f 0010 	mvn.w	r0, #16
    c668:	e7fb      	b.n	c662 <cdcdf_acm_init+0x22>
    c66a:	bf00      	nop
    c66c:	000140d5 	.word	0x000140d5
    c670:	20008524 	.word	0x20008524
    c674:	0000c50d 	.word	0x0000c50d
    c678:	0001407d 	.word	0x0001407d
    c67c:	20000354 	.word	0x20000354
    c680:	00013ff5 	.word	0x00013ff5

0000c684 <cdcdf_acm_read>:

/**
 * \brief USB CDC ACM Function Read Data
 */
int32_t cdcdf_acm_read(uint8_t *buf, uint32_t size)
{
    c684:	b410      	push	{r4}
/**
 * \brief Check whether CDC ACM Function is enabled
 */
bool cdcdf_acm_is_enabled(void)
{
	return _cdcdf_acm_funcd.enabled;
    c686:	4c08      	ldr	r4, [pc, #32]	; (c6a8 <cdcdf_acm_read+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    c688:	7963      	ldrb	r3, [r4, #5]
{
    c68a:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    c68c:	b13b      	cbz	r3, c69e <cdcdf_acm_read+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    c68e:	4601      	mov	r1, r0
    c690:	7920      	ldrb	r0, [r4, #4]
    c692:	4c06      	ldr	r4, [pc, #24]	; (c6ac <cdcdf_acm_read+0x28>)
    c694:	2300      	movs	r3, #0
    c696:	46a4      	mov	ip, r4
}
    c698:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_out, buf, size, false);
    c69c:	4760      	bx	ip
}
    c69e:	f06f 0010 	mvn.w	r0, #16
    c6a2:	f85d 4b04 	ldr.w	r4, [sp], #4
    c6a6:	4770      	bx	lr
    c6a8:	20008524 	.word	0x20008524
    c6ac:	00013c9d 	.word	0x00013c9d

0000c6b0 <cdcdf_acm_write>:
{
    c6b0:	b410      	push	{r4}
	return _cdcdf_acm_funcd.enabled;
    c6b2:	4c08      	ldr	r4, [pc, #32]	; (c6d4 <cdcdf_acm_write+0x24>)
	if (!cdcdf_acm_is_enabled()) {
    c6b4:	7963      	ldrb	r3, [r4, #5]
{
    c6b6:	460a      	mov	r2, r1
	if (!cdcdf_acm_is_enabled()) {
    c6b8:	b13b      	cbz	r3, c6ca <cdcdf_acm_write+0x1a>
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    c6ba:	4601      	mov	r1, r0
    c6bc:	78e0      	ldrb	r0, [r4, #3]
    c6be:	4c06      	ldr	r4, [pc, #24]	; (c6d8 <cdcdf_acm_write+0x28>)
    c6c0:	2301      	movs	r3, #1
    c6c2:	46a4      	mov	ip, r4
}
    c6c4:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], buf, size, true);
    c6c8:	4760      	bx	ip
}
    c6ca:	f06f 0010 	mvn.w	r0, #16
    c6ce:	f85d 4b04 	ldr.w	r4, [sp], #4
    c6d2:	4770      	bx	lr
    c6d4:	20008524 	.word	0x20008524
    c6d8:	00013c9d 	.word	0x00013c9d

0000c6dc <cdcdf_acm_register_callback>:
{
    c6dc:	b508      	push	{r3, lr}
    c6de:	460a      	mov	r2, r1
    c6e0:	2803      	cmp	r0, #3
    c6e2:	d814      	bhi.n	c70e <cdcdf_acm_register_callback+0x32>
    c6e4:	e8df f000 	tbb	[pc, r0]
    c6e8:	100d0902 	.word	0x100d0902
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_out, USB_D_EP_CB_XFER, func);
    c6ec:	4b09      	ldr	r3, [pc, #36]	; (c714 <cdcdf_acm_register_callback+0x38>)
    c6ee:	7918      	ldrb	r0, [r3, #4]
    c6f0:	2102      	movs	r1, #2
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    c6f2:	4b09      	ldr	r3, [pc, #36]	; (c718 <cdcdf_acm_register_callback+0x3c>)
    c6f4:	4798      	blx	r3
	return ERR_NONE;
    c6f6:	2000      	movs	r0, #0
}
    c6f8:	bd08      	pop	{r3, pc}
		usb_d_ep_register_callback(_cdcdf_acm_funcd.func_ep_in[CDCDF_ACM_DATA_EP_INDEX], USB_D_EP_CB_XFER, func);
    c6fa:	4b06      	ldr	r3, [pc, #24]	; (c714 <cdcdf_acm_register_callback+0x38>)
    c6fc:	2102      	movs	r1, #2
    c6fe:	78d8      	ldrb	r0, [r3, #3]
    c700:	e7f7      	b.n	c6f2 <cdcdf_acm_register_callback+0x16>
		cdcdf_acm_set_line_coding = (cdcdf_acm_set_line_coding_t)func;
    c702:	4b04      	ldr	r3, [pc, #16]	; (c714 <cdcdf_acm_register_callback+0x38>)
    c704:	6119      	str	r1, [r3, #16]
		break;
    c706:	e7f6      	b.n	c6f6 <cdcdf_acm_register_callback+0x1a>
		cdcdf_acm_notify_state = (cdcdf_acm_notify_state_t)func;
    c708:	4b02      	ldr	r3, [pc, #8]	; (c714 <cdcdf_acm_register_callback+0x38>)
    c70a:	6159      	str	r1, [r3, #20]
    c70c:	e7f3      	b.n	c6f6 <cdcdf_acm_register_callback+0x1a>
	return ERR_NONE;
    c70e:	f06f 000c 	mvn.w	r0, #12
    c712:	e7f1      	b.n	c6f8 <cdcdf_acm_register_callback+0x1c>
    c714:	20008524 	.word	0x20008524
    c718:	00010115 	.word	0x00010115

0000c71c <_sbrk>:
extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *       prev_heap;

	if (heap == NULL) {
    c71c:	4b04      	ldr	r3, [pc, #16]	; (c730 <_sbrk+0x14>)
    c71e:	6819      	ldr	r1, [r3, #0]
{
    c720:	4602      	mov	r2, r0
	if (heap == NULL) {
    c722:	b909      	cbnz	r1, c728 <_sbrk+0xc>
		heap = (unsigned char *)&_end;
    c724:	4903      	ldr	r1, [pc, #12]	; (c734 <_sbrk+0x18>)
    c726:	6019      	str	r1, [r3, #0]
	}
	prev_heap = heap;
    c728:	6818      	ldr	r0, [r3, #0]

	heap += incr;
    c72a:	4402      	add	r2, r0
    c72c:	601a      	str	r2, [r3, #0]

	return (caddr_t)prev_heap;
}
    c72e:	4770      	bx	lr
    c730:	20008548 	.word	0x20008548
    c734:	2002cfe8 	.word	0x2002cfe8

0000c738 <_close>:
 */
extern int _close(int file)
{
	(void)file;
	return -1;
}
    c738:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c73c:	4770      	bx	lr

0000c73e <_fstat>:
 * \brief Replacement of C library of _fstat
 */
extern int _fstat(int file, struct stat *st)
{
	(void)file;
	st->st_mode = S_IFCHR;
    c73e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    c742:	604b      	str	r3, [r1, #4]

	return 0;
}
    c744:	2000      	movs	r0, #0
    c746:	4770      	bx	lr

0000c748 <_isatty>:
 */
extern int _isatty(int file)
{
	(void)file;
	return 1;
}
    c748:	2001      	movs	r0, #1
    c74a:	4770      	bx	lr

0000c74c <_lseek>:
 */
extern int _lseek(int file, int ptr, int dir)
{
	(void)file, (void)ptr, (void)dir;
	return 0;
}
    c74c:	2000      	movs	r0, #0
    c74e:	4770      	bx	lr

0000c750 <_exit>:

/**
 * \brief Replacement of C library of _exit
 */
extern void _exit(int status)
{
    c750:	b508      	push	{r3, lr}
    c752:	4601      	mov	r1, r0
	printf("Exiting with status %d.\n", status);
    c754:	4b01      	ldr	r3, [pc, #4]	; (c75c <_exit+0xc>)
    c756:	4802      	ldr	r0, [pc, #8]	; (c760 <_exit+0x10>)
    c758:	4798      	blx	r3

	for (;;)
    c75a:	e7fe      	b.n	c75a <_exit+0xa>
    c75c:	00014eb1 	.word	0x00014eb1
    c760:	00016ec0 	.word	0x00016ec0

0000c764 <_kill>:
 */
extern void _kill(int pid, int sig)
{
	(void)pid, (void)sig;
	return;
}
    c764:	4770      	bx	lr

0000c766 <_getpid>:
 * \brief Replacement of C library of _getpid
 */
extern int _getpid(void)
{
	return -1;
}
    c766:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    c76a:	4770      	bx	lr

0000c76c <_qspi_dma_rx_complete>:
 *  \brief Callback for RX
 *  \param[in, out] dev Pointer to the DMA resource.
 */
static void _qspi_dma_rx_complete(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;
    c76c:	6883      	ldr	r3, [r0, #8]
}

static inline void hri_qspi_write_CTRLA_reg(const void *const hw, hri_qspi_ctrla_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLA.reg = data;
    c76e:	4903      	ldr	r1, [pc, #12]	; (c77c <_qspi_dma_rx_complete+0x10>)

	_qspi_end_transfer(dev->prvt);
    c770:	681a      	ldr	r2, [r3, #0]

	if (dev->cb.xfer_done) {
    c772:	685b      	ldr	r3, [r3, #4]
    c774:	6011      	str	r1, [r2, #0]
    c776:	b103      	cbz	r3, c77a <_qspi_dma_rx_complete+0xe>
		dev->cb.xfer_done(resource);
    c778:	4718      	bx	r3
	}
}
    c77a:	4770      	bx	lr
    c77c:	01000002 	.word	0x01000002

0000c780 <_qspi_dma_tx_complete>:
    c780:	4b00      	ldr	r3, [pc, #0]	; (c784 <_qspi_dma_tx_complete+0x4>)
    c782:	4718      	bx	r3
    c784:	0000c76d 	.word	0x0000c76d

0000c788 <_qspi_dma_error_occured>:
 */
static void _qspi_dma_error_occured(struct _dma_resource *resource)
{
	struct _qspi_dma_dev *dev = (struct _qspi_dma_dev *)resource->back;

	if (dev->cb.error) {
    c788:	6883      	ldr	r3, [r0, #8]
    c78a:	689b      	ldr	r3, [r3, #8]
    c78c:	b103      	cbz	r3, c790 <_qspi_dma_error_occured+0x8>
		dev->cb.error(resource);
    c78e:	4718      	bx	r3
	}
}
    c790:	4770      	bx	lr
	...

0000c794 <_qspi_dma_init>:

int32_t _qspi_dma_init(struct _qspi_dma_dev *dev, void *const hw)
{
    c794:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    c796:	460d      	mov	r5, r1
	ASSERT(dev && hw);
    c798:	4604      	mov	r4, r0
    c79a:	b110      	cbz	r0, c7a2 <_qspi_dma_init+0xe>
    c79c:	1e08      	subs	r0, r1, #0
    c79e:	bf18      	it	ne
    c7a0:	2001      	movne	r0, #1
	dev->prvt = hw;
    c7a2:	4626      	mov	r6, r4
	ASSERT(dev && hw);
    c7a4:	22cb      	movs	r2, #203	; 0xcb
    c7a6:	490f      	ldr	r1, [pc, #60]	; (c7e4 <_qspi_dma_init+0x50>)
    c7a8:	4b0f      	ldr	r3, [pc, #60]	; (c7e8 <_qspi_dma_init+0x54>)
	hri_qspi_write_BAUD_reg(hw,
	                        CONF_QSPI_CPOL << QSPI_BAUD_CPOL_Pos | CONF_QSPI_CPHA << QSPI_BAUD_CPHA_Pos
	                            | QSPI_BAUD_BAUD(CONF_QSPI_BAUD_RATE) | QSPI_BAUD_DLYBS(CONF_QSPI_DLYBS));

	/* Initialize DMA rx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    c7aa:	4f10      	ldr	r7, [pc, #64]	; (c7ec <_qspi_dma_init+0x58>)
	ASSERT(dev && hw);
    c7ac:	4798      	blx	r3
    c7ae:	2301      	movs	r3, #1
	dev->prvt = hw;
    c7b0:	f846 5b0c 	str.w	r5, [r6], #12
    c7b4:	602b      	str	r3, [r5, #0]
}

static inline void hri_qspi_write_CTRLB_reg(const void *const hw, hri_qspi_ctrlb_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->CTRLB.reg = data;
    c7b6:	4b0e      	ldr	r3, [pc, #56]	; (c7f0 <_qspi_dma_init+0x5c>)
    c7b8:	606b      	str	r3, [r5, #4]
}

static inline void hri_qspi_write_BAUD_reg(const void *const hw, hri_qspi_baud_reg_t data)
{
	QSPI_CRITICAL_SECTION_ENTER();
	((Qspi *)hw)->BAUD.reg = data;
    c7ba:	4b0e      	ldr	r3, [pc, #56]	; (c7f4 <_qspi_dma_init+0x60>)
    c7bc:	60ab      	str	r3, [r5, #8]
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_RX_CHANNEL);
    c7be:	211f      	movs	r1, #31
    c7c0:	4630      	mov	r0, r6
    c7c2:	47b8      	blx	r7
	dev->resource->back                 = dev;
    c7c4:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    c7c6:	4a0c      	ldr	r2, [pc, #48]	; (c7f8 <_qspi_dma_init+0x64>)
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    c7c8:	4d0c      	ldr	r5, [pc, #48]	; (c7fc <_qspi_dma_init+0x68>)
	dev->resource->back                 = dev;
    c7ca:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.transfer_done = _qspi_dma_rx_complete;
    c7cc:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    c7ce:	605d      	str	r5, [r3, #4]
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, CONF_QSPI_DMA_TX_CHANNEL);
    c7d0:	211e      	movs	r1, #30
    c7d2:	4630      	mov	r0, r6
    c7d4:	47b8      	blx	r7
	dev->resource->back                 = dev;
    c7d6:	68e3      	ldr	r3, [r4, #12]
	dev->resource->dma_cb.transfer_done = _qspi_dma_tx_complete;
    c7d8:	4a09      	ldr	r2, [pc, #36]	; (c800 <_qspi_dma_init+0x6c>)
	dev->resource->back                 = dev;
    c7da:	609c      	str	r4, [r3, #8]
	dev->resource->dma_cb.error         = _qspi_dma_error_occured;
    c7dc:	e9c3 2500 	strd	r2, r5, [r3]

	return ERR_NONE;
}
    c7e0:	2000      	movs	r0, #0
    c7e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    c7e4:	00016ed9 	.word	0x00016ed9
    c7e8:	0000e9b9 	.word	0x0000e9b9
    c7ec:	0000ebfd 	.word	0x0000ebfd
    c7f0:	06000011 	.word	0x06000011
    c7f4:	00243b00 	.word	0x00243b00
    c7f8:	0000c76d 	.word	0x0000c76d
    c7fc:	0000c789 	.word	0x0000c789
    c800:	0000c781 	.word	0x0000c781

0000c804 <_flash_program>:
 * \param[in]  buffer        Pointer to buffer where the data to
 *                           write is stored
 * \param[in] size           The size of data to write to a page
 */
static void _flash_program(void *const hw, const uint32_t dst_addr, const uint8_t *buffer, const uint16_t size)
{
    c804:	b570      	push	{r4, r5, r6, lr}
	uint32_t *ptr_read    = (uint32_t *)buffer;
	uint32_t  nvm_address = dst_addr / 4;
    c806:	088d      	lsrs	r5, r1, #2
	return ((Nvmctrl *)hw)->PARAM.reg;
}

static inline bool hri_nvmctrl_get_STATUS_READY_bit(const void *const hw)
{
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c808:	8a44      	ldrh	r4, [r0, #18]
	uint16_t  i;

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c80a:	07e6      	lsls	r6, r4, #31
    c80c:	d5fc      	bpl.n	c808 <_flash_program+0x4>
}

static inline void hri_nvmctrl_write_CTRLB_reg(const void *const hw, hri_nvmctrl_ctrlb_reg_t data)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c80e:	f24a 5415 	movw	r4, #42261	; 0xa515
    c812:	8084      	strh	r4, [r0, #4]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c814:	8a44      	ldrh	r4, [r0, #18]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_PBC | NVMCTRL_CTRLB_CMDEX_KEY);

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c816:	07e4      	lsls	r4, r4, #31
    c818:	d5fc      	bpl.n	c814 <_flash_program+0x10>
    c81a:	00ad      	lsls	r5, r5, #2
    c81c:	2400      	movs	r4, #0
		/* Wait until this module isn't busy */
	}

	/* Writes to the page buffer must be 32 bits, perform manual copy
	 * to ensure alignment */
	for (i = 0; i < size; i += 4) {
    c81e:	b2a6      	uxth	r6, r4
    c820:	429e      	cmp	r6, r3
    c822:	d307      	bcc.n	c834 <_flash_program+0x30>
    c824:	8a43      	ldrh	r3, [r0, #18]
		NVM_MEMORY[nvm_address++] = *ptr_read;
		ptr_read++;
	}

	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c826:	07db      	lsls	r3, r3, #31
    c828:	d5fc      	bpl.n	c824 <_flash_program+0x20>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c82a:	f24a 5303 	movw	r3, #42243	; 0xa503
	((Nvmctrl *)hw)->ADDR.reg = data;
    c82e:	6141      	str	r1, [r0, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c830:	8083      	strh	r3, [r0, #4]
		/* Wait until this module isn't busy */
	}

	hri_nvmctrl_write_ADDR_reg(hw, dst_addr);
	hri_nvmctrl_write_CTRLB_reg(hw, NVMCTRL_CTRLB_CMD_WP | NVMCTRL_CTRLB_CMDEX_KEY);
}
    c832:	bd70      	pop	{r4, r5, r6, pc}
		NVM_MEMORY[nvm_address++] = *ptr_read;
    c834:	5916      	ldr	r6, [r2, r4]
    c836:	5166      	str	r6, [r4, r5]
	for (i = 0; i < size; i += 4) {
    c838:	3404      	adds	r4, #4
    c83a:	e7f0      	b.n	c81e <_flash_program+0x1a>

0000c83c <_flash_init>:
{
    c83c:	b538      	push	{r3, r4, r5, lr}
    c83e:	460d      	mov	r5, r1
	ASSERT(device && (hw == NVMCTRL));
    c840:	4604      	mov	r4, r0
    c842:	b118      	cbz	r0, c84c <_flash_init+0x10>
    c844:	4814      	ldr	r0, [pc, #80]	; (c898 <_flash_init+0x5c>)
    c846:	1a0b      	subs	r3, r1, r0
    c848:	4258      	negs	r0, r3
    c84a:	4158      	adcs	r0, r3
    c84c:	4913      	ldr	r1, [pc, #76]	; (c89c <_flash_init+0x60>)
    c84e:	4b14      	ldr	r3, [pc, #80]	; (c8a0 <_flash_init+0x64>)
    c850:	224b      	movs	r2, #75	; 0x4b
    c852:	4798      	blx	r3
	return ((Nvmctrl *)hw)->CTRLA.reg;
    c854:	882b      	ldrh	r3, [r5, #0]
	device->hw = hw;
    c856:	6125      	str	r5, [r4, #16]
	hri_nvmctrl_write_CTRLA_reg(hw, ctrla);
    c858:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
    c85c:	049b      	lsls	r3, r3, #18
    c85e:	0c9b      	lsrs	r3, r3, #18
	((Nvmctrl *)hw)->CTRLA.reg = data;
    c860:	802b      	strh	r3, [r5, #0]
	_nvm_dev = device;
    c862:	4b10      	ldr	r3, [pc, #64]	; (c8a4 <_flash_init+0x68>)
    c864:	601c      	str	r4, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c866:	4b10      	ldr	r3, [pc, #64]	; (c8a8 <_flash_init+0x6c>)
    c868:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
    c86c:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
    c870:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    c874:	f3bf 8f6f 	isb	sy
    c878:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    c87c:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    c880:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    c884:	f3bf 8f6f 	isb	sy
}
    c888:	2000      	movs	r0, #0
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c88a:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
    c88e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    c892:	6019      	str	r1, [r3, #0]
    c894:	601a      	str	r2, [r3, #0]
    c896:	bd38      	pop	{r3, r4, r5, pc}
    c898:	41004000 	.word	0x41004000
    c89c:	00016ef0 	.word	0x00016ef0
    c8a0:	0000e9b9 	.word	0x0000e9b9
    c8a4:	2000854c 	.word	0x2000854c
    c8a8:	e000e100 	.word	0xe000e100

0000c8ac <_flash_get_page_size>:
}
    c8ac:	f44f 7000 	mov.w	r0, #512	; 0x200
    c8b0:	4770      	bx	lr

0000c8b2 <_flash_get_total_pages>:
	return (uint32_t)hri_nvmctrl_read_PARAM_NVMP_bf(device->hw);
    c8b2:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->PARAM.reg & NVMCTRL_PARAM_NVMP_Msk) >> NVMCTRL_PARAM_NVMP_Pos;
    c8b4:	6898      	ldr	r0, [r3, #8]
}
    c8b6:	b280      	uxth	r0, r0
    c8b8:	4770      	bx	lr

0000c8ba <_flash_read>:
{
    c8ba:	b510      	push	{r4, lr}
	while (!hri_nvmctrl_get_STATUS_READY_bit(device->hw)) {
    c8bc:	6904      	ldr	r4, [r0, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    c8be:	8a60      	ldrh	r0, [r4, #18]
    c8c0:	07c0      	lsls	r0, r0, #31
    c8c2:	d5fc      	bpl.n	c8be <_flash_read+0x4>
	for (i = 0; i < length; i++) {
    c8c4:	2000      	movs	r0, #0
    c8c6:	e002      	b.n	c8ce <_flash_read+0x14>
		buffer[i] = nvm_addr[src_addr + i];
    c8c8:	5c44      	ldrb	r4, [r0, r1]
    c8ca:	5414      	strb	r4, [r2, r0]
	for (i = 0; i < length; i++) {
    c8cc:	3001      	adds	r0, #1
    c8ce:	4298      	cmp	r0, r3
    c8d0:	d1fa      	bne.n	c8c8 <_flash_read+0xe>
}
    c8d2:	bd10      	pop	{r4, pc}

0000c8d4 <_flash_write>:
{
    c8d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c8d8:	f5ad 5d00 	sub.w	sp, sp, #8192	; 0x2000
    c8dc:	b083      	sub	sp, #12
    c8de:	4606      	mov	r6, r0
    c8e0:	460c      	mov	r4, r1
    c8e2:	4617      	mov	r7, r2
    c8e4:	9301      	str	r3, [sp, #4]
		block_start_addr = wr_start_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c8e6:	f424 59ff 	bic.w	r9, r4, #8160	; 0x1fe0
    c8ea:	f029 091f 	bic.w	r9, r9, #31
		block_end_addr   = block_start_addr + NVMCTRL_BLOCK_SIZE - 1;
    c8ee:	f509 5aff 	add.w	sl, r9, #8160	; 0x1fe0
    c8f2:	f10a 0a1f 	add.w	sl, sl, #31
    c8f6:	f04f 0800 	mov.w	r8, #0
			_flash_read(device, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    c8fa:	aa02      	add	r2, sp, #8
    c8fc:	4442      	add	r2, r8
    c8fe:	eb09 0108 	add.w	r1, r9, r8
    c902:	4d24      	ldr	r5, [pc, #144]	; (c994 <_flash_write+0xc0>)
    c904:	f44f 7300 	mov.w	r3, #512	; 0x200
    c908:	4630      	mov	r0, r6
    c90a:	f508 7800 	add.w	r8, r8, #512	; 0x200
    c90e:	47a8      	blx	r5
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    c910:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    c914:	d1f1      	bne.n	c8fa <_flash_write+0x26>
		j = (wr_start_addr - block_start_addr) / NVMCTRL_PAGE_SIZE;
    c916:	eba4 0309 	sub.w	r3, r4, r9
    c91a:	0a5a      	lsrs	r2, r3, #9
		k = wr_start_addr - block_start_addr - j * NVMCTRL_PAGE_SIZE;
    c91c:	4639      	mov	r1, r7
    c91e:	f3c3 0308 	ubfx	r3, r3, #0, #9
		while ((wr_start_addr <= block_end_addr) && (length > 0)) {
    c922:	4554      	cmp	r4, sl
    c924:	460f      	mov	r7, r1
    c926:	d801      	bhi.n	c92c <_flash_write+0x58>
    c928:	9801      	ldr	r0, [sp, #4]
    c92a:	bb18      	cbnz	r0, c974 <_flash_write+0xa0>
		_flash_erase_block(device->hw, block_start_addr);
    c92c:	6933      	ldr	r3, [r6, #16]
    c92e:	8a5a      	ldrh	r2, [r3, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    c930:	07d2      	lsls	r2, r2, #31
    c932:	d5fc      	bpl.n	c92e <_flash_write+0x5a>
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c934:	f24a 5201 	movw	r2, #42241	; 0xa501
			_flash_program(device->hw, block_start_addr + i * NVMCTRL_PAGE_SIZE, tmp_buffer[i], NVMCTRL_PAGE_SIZE);
    c938:	f8df b05c 	ldr.w	fp, [pc, #92]	; c998 <_flash_write+0xc4>
	((Nvmctrl *)hw)->ADDR.reg = data;
    c93c:	f8c3 9014 	str.w	r9, [r3, #20]
	((Nvmctrl *)hw)->CTRLB.reg = data;
    c940:	f04f 0800 	mov.w	r8, #0
    c944:	809a      	strh	r2, [r3, #4]
    c946:	aa02      	add	r2, sp, #8
    c948:	4442      	add	r2, r8
    c94a:	eb09 0108 	add.w	r1, r9, r8
    c94e:	6930      	ldr	r0, [r6, #16]
    c950:	f44f 7300 	mov.w	r3, #512	; 0x200
    c954:	f508 7800 	add.w	r8, r8, #512	; 0x200
    c958:	47d8      	blx	fp
		for (i = 0; i < NVMCTRL_BLOCK_PAGES; i++) {
    c95a:	f5b8 5f00 	cmp.w	r8, #8192	; 0x2000
    c95e:	d1f2      	bne.n	c946 <_flash_write+0x72>
	} while (block_end_addr < (wr_start_addr + length - 1));
    c960:	9b01      	ldr	r3, [sp, #4]
    c962:	4423      	add	r3, r4
    c964:	3b01      	subs	r3, #1
    c966:	4553      	cmp	r3, sl
    c968:	d8bd      	bhi.n	c8e6 <_flash_write+0x12>
}
    c96a:	f50d 5d00 	add.w	sp, sp, #8192	; 0x2000
    c96e:	b003      	add	sp, #12
    c970:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tmp_buffer[j][k] = *buffer;
    c974:	a802      	add	r0, sp, #8
    c976:	eb00 2042 	add.w	r0, r0, r2, lsl #9
    c97a:	783f      	ldrb	r7, [r7, #0]
    c97c:	54c7      	strb	r7, [r0, r3]
			k                = (k + 1) % NVMCTRL_PAGE_SIZE;
    c97e:	3301      	adds	r3, #1
    c980:	f3c3 0308 	ubfx	r3, r3, #0, #9
			if (0 == k) {
    c984:	3101      	adds	r1, #1
    c986:	b903      	cbnz	r3, c98a <_flash_write+0xb6>
				j++;
    c988:	3201      	adds	r2, #1
			length--;
    c98a:	9801      	ldr	r0, [sp, #4]
    c98c:	3801      	subs	r0, #1
			wr_start_addr++;
    c98e:	3401      	adds	r4, #1
			length--;
    c990:	9001      	str	r0, [sp, #4]
    c992:	e7c6      	b.n	c922 <_flash_write+0x4e>
    c994:	0000c8bb 	.word	0x0000c8bb
    c998:	0000c805 	.word	0x0000c805

0000c99c <_flash_erase>:
{
    c99c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c9a0:	f421 54ff 	bic.w	r4, r1, #8160	; 0x1fe0
{
    c9a4:	f5ad 7d01 	sub.w	sp, sp, #516	; 0x204
    c9a8:	460e      	mov	r6, r1
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c9aa:	4b25      	ldr	r3, [pc, #148]	; (ca40 <_flash_erase+0xa4>)
{
    c9ac:	4607      	mov	r7, r0
    c9ae:	4615      	mov	r5, r2
	block_start_addr = dst_addr & ~(NVMCTRL_BLOCK_SIZE - 1);
    c9b0:	f024 041f 	bic.w	r4, r4, #31
	memset(tmp_buffer, 0xFF, NVMCTRL_PAGE_SIZE);
    c9b4:	f44f 7200 	mov.w	r2, #512	; 0x200
    c9b8:	21ff      	movs	r1, #255	; 0xff
    c9ba:	4668      	mov	r0, sp
    c9bc:	4798      	blx	r3
	if (dst_addr != block_start_addr) {
    c9be:	42a6      	cmp	r6, r4
    c9c0:	d11e      	bne.n	ca00 <_flash_erase+0x64>
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    c9c2:	4622      	mov	r2, r4
    c9c4:	462b      	mov	r3, r5
    c9c6:	f24a 5001 	movw	r0, #42241	; 0xa501
	while (page_nums >= NVMCTRL_BLOCK_PAGES) {
    c9ca:	2b0f      	cmp	r3, #15
    c9cc:	d82e      	bhi.n	ca2c <_flash_erase+0x90>
    c9ce:	0929      	lsrs	r1, r5, #4
    c9d0:	f06f 020f 	mvn.w	r2, #15
    c9d4:	fb02 5501 	mla	r5, r2, r1, r5
    c9d8:	eb04 3441 	add.w	r4, r4, r1, lsl #13
	if (page_nums != 0) {
    c9dc:	b165      	cbz	r5, c9f8 <_flash_erase+0x5c>
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c9de:	4e19      	ldr	r6, [pc, #100]	; (ca44 <_flash_erase+0xa8>)
    c9e0:	eb04 2545 	add.w	r5, r4, r5, lsl #9
    c9e4:	4621      	mov	r1, r4
    c9e6:	f44f 7300 	mov.w	r3, #512	; 0x200
    c9ea:	466a      	mov	r2, sp
    c9ec:	4638      	mov	r0, r7
			block_start_addr += NVMCTRL_PAGE_SIZE;
    c9ee:	f504 7400 	add.w	r4, r4, #512	; 0x200
			_flash_write(device, block_start_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    c9f2:	47b0      	blx	r6
		for (i = 0; i < page_nums; i++) {
    c9f4:	42a5      	cmp	r5, r4
    c9f6:	d1f5      	bne.n	c9e4 <_flash_erase+0x48>
}
    c9f8:	f50d 7d01 	add.w	sp, sp, #516	; 0x204
    c9fc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    ca00:	f504 5800 	add.w	r8, r4, #8192	; 0x2000
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    ca04:	f506 59f0 	add.w	r9, r6, #7680	; 0x1e00
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    ca08:	4634      	mov	r4, r6
			_flash_write(device, dst_addr, tmp_buffer, NVMCTRL_PAGE_SIZE);
    ca0a:	4e0e      	ldr	r6, [pc, #56]	; (ca44 <_flash_erase+0xa8>)
    ca0c:	f44f 7300 	mov.w	r3, #512	; 0x200
    ca10:	466a      	mov	r2, sp
    ca12:	4621      	mov	r1, r4
    ca14:	4638      	mov	r0, r7
    ca16:	47b0      	blx	r6
			if (--page_nums == 0) {
    ca18:	3d01      	subs	r5, #1
    ca1a:	d0ed      	beq.n	c9f8 <_flash_erase+0x5c>
			dst_addr += NVMCTRL_PAGE_SIZE;
    ca1c:	f504 7400 	add.w	r4, r4, #512	; 0x200
			if (dst_addr == block_start_addr) {
    ca20:	45a0      	cmp	r8, r4
    ca22:	d0ce      	beq.n	c9c2 <_flash_erase+0x26>
		for (i = 0; i < NVMCTRL_BLOCK_PAGES - 1; i++) {
    ca24:	45a1      	cmp	r9, r4
    ca26:	d1f1      	bne.n	ca0c <_flash_erase+0x70>
    ca28:	4644      	mov	r4, r8
    ca2a:	e7ca      	b.n	c9c2 <_flash_erase+0x26>
		_flash_erase_block(device->hw, block_start_addr);
    ca2c:	6939      	ldr	r1, [r7, #16]
	return (((Nvmctrl *)hw)->STATUS.reg & NVMCTRL_STATUS_READY) >> NVMCTRL_STATUS_READY_Pos;
    ca2e:	8a4e      	ldrh	r6, [r1, #18]
	while (!hri_nvmctrl_get_STATUS_READY_bit(hw)) {
    ca30:	07f6      	lsls	r6, r6, #31
    ca32:	d5fc      	bpl.n	ca2e <_flash_erase+0x92>
	((Nvmctrl *)hw)->ADDR.reg = data;
    ca34:	614a      	str	r2, [r1, #20]
		page_nums -= NVMCTRL_BLOCK_PAGES;
    ca36:	3b10      	subs	r3, #16
	((Nvmctrl *)hw)->CTRLB.reg = data;
    ca38:	8088      	strh	r0, [r1, #4]
		block_start_addr += NVMCTRL_BLOCK_SIZE;
    ca3a:	f502 5200 	add.w	r2, r2, #8192	; 0x2000
		page_nums -= NVMCTRL_BLOCK_PAGES;
    ca3e:	e7c4      	b.n	c9ca <_flash_erase+0x2e>
    ca40:	00014d51 	.word	0x00014d51
    ca44:	0000c8d5 	.word	0x0000c8d5

0000ca48 <_flash_is_locked>:
	return !(hri_nvmctrl_get_RUNLOCK_reg(device->hw, 1 << region_id));
    ca48:	6903      	ldr	r3, [r0, #16]
    ca4a:	f3c1 31cf 	ubfx	r1, r1, #15, #16
	tmp = ((Nvmctrl *)hw)->RUNLOCK.reg;
    ca4e:	699a      	ldr	r2, [r3, #24]
    ca50:	2301      	movs	r3, #1
    ca52:	fa03 f101 	lsl.w	r1, r3, r1
    ca56:	4211      	tst	r1, r2
}
    ca58:	bf0c      	ite	eq
    ca5a:	4618      	moveq	r0, r3
    ca5c:	2000      	movne	r0, #0
    ca5e:	4770      	bx	lr

0000ca60 <NVMCTRL_0_Handler>:
/**
 * \internal NVM 0 interrupt handler
 */
void NVMCTRL_0_Handler(void)
{
	_nvm_interrupt_handler(_nvm_dev);
    ca60:	4b09      	ldr	r3, [pc, #36]	; (ca88 <NVMCTRL_0_Handler+0x28>)
    ca62:	6818      	ldr	r0, [r3, #0]
	void *const hw = device->hw;
    ca64:	6903      	ldr	r3, [r0, #16]
	return (((Nvmctrl *)hw)->INTFLAG.reg & NVMCTRL_INTFLAG_DONE) >> NVMCTRL_INTFLAG_DONE_Pos;
    ca66:	8a1a      	ldrh	r2, [r3, #16]
	if (hri_nvmctrl_get_INTFLAG_DONE_bit(hw)) {
    ca68:	07d2      	lsls	r2, r2, #31
    ca6a:	d504      	bpl.n	ca76 <NVMCTRL_0_Handler+0x16>
	((Nvmctrl *)hw)->INTFLAG.reg = NVMCTRL_INTFLAG_DONE;
    ca6c:	2201      	movs	r2, #1
    ca6e:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.ready_cb) {
    ca70:	6803      	ldr	r3, [r0, #0]
		if (NULL != device->flash_cb.error_cb) {
    ca72:	b143      	cbz	r3, ca86 <NVMCTRL_0_Handler+0x26>
			device->flash_cb.error_cb(device);
    ca74:	4718      	bx	r3
	return ((Nvmctrl *)hw)->INTFLAG.reg;
    ca76:	8a1a      	ldrh	r2, [r3, #16]
    ca78:	b292      	uxth	r2, r2
	} else if (hri_nvmctrl_read_INTFLAG_reg(hw) && ~NVMCTRL_INTFLAG_ERR) {
    ca7a:	b122      	cbz	r2, ca86 <NVMCTRL_0_Handler+0x26>
	((Nvmctrl *)hw)->INTFLAG.reg = mask;
    ca7c:	f240 225e 	movw	r2, #606	; 0x25e
    ca80:	821a      	strh	r2, [r3, #16]
		if (NULL != device->flash_cb.error_cb) {
    ca82:	6843      	ldr	r3, [r0, #4]
    ca84:	e7f5      	b.n	ca72 <NVMCTRL_0_Handler+0x12>
}
    ca86:	4770      	bx	lr
    ca88:	2000854c 	.word	0x2000854c

0000ca8c <NVMCTRL_1_Handler>:
    ca8c:	4b00      	ldr	r3, [pc, #0]	; (ca90 <NVMCTRL_1_Handler+0x4>)
    ca8e:	4718      	bx	r3
    ca90:	0000ca61 	.word	0x0000ca61

0000ca94 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty(const Queue_t *pxQueue)
{
    ca94:	b510      	push	{r4, lr}
    ca96:	4604      	mov	r4, r0
	BaseType_t xReturn;

	taskENTER_CRITICAL();
    ca98:	4b04      	ldr	r3, [pc, #16]	; (caac <prvIsQueueEmpty+0x18>)
    ca9a:	4798      	blx	r3
	{
		if (pxQueue->uxMessagesWaiting == (UBaseType_t)0) {
    ca9c:	6ba4      	ldr	r4, [r4, #56]	; 0x38
			xReturn = pdTRUE;
		} else {
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    ca9e:	4b04      	ldr	r3, [pc, #16]	; (cab0 <prvIsQueueEmpty+0x1c>)
    caa0:	4798      	blx	r3

	return xReturn;
}
    caa2:	fab4 f084 	clz	r0, r4
    caa6:	0940      	lsrs	r0, r0, #5
    caa8:	bd10      	pop	{r4, pc}
    caaa:	bf00      	nop
    caac:	0000bbb5 	.word	0x0000bbb5
    cab0:	0000bbf9 	.word	0x0000bbf9

0000cab4 <prvCopyDataToQueue>:
{
    cab4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    cab6:	4615      	mov	r5, r2
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    cab8:	6c02      	ldr	r2, [r0, #64]	; 0x40
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    caba:	6b86      	ldr	r6, [r0, #56]	; 0x38
{
    cabc:	4604      	mov	r4, r0
	if (pxQueue->uxItemSize == (UBaseType_t)0) {
    cabe:	b952      	cbnz	r2, cad6 <prvCopyDataToQueue+0x22>
			if (pxQueue->uxQueueType == queueQUEUE_IS_MUTEX) {
    cac0:	6807      	ldr	r7, [r0, #0]
    cac2:	bb3f      	cbnz	r7, cb14 <prvCopyDataToQueue+0x60>
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    cac4:	6840      	ldr	r0, [r0, #4]
    cac6:	4b15      	ldr	r3, [pc, #84]	; (cb1c <prvCopyDataToQueue+0x68>)
    cac8:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
    caca:	6067      	str	r7, [r4, #4]
				xReturn                = xTaskPriorityDisinherit((void *)pxQueue->pxMutexHolder);
    cacc:	4605      	mov	r5, r0
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + (UBaseType_t)1;
    cace:	3601      	adds	r6, #1
    cad0:	63a6      	str	r6, [r4, #56]	; 0x38
}
    cad2:	4628      	mov	r0, r5
    cad4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (xPosition == queueSEND_TO_BACK) {
    cad6:	4b12      	ldr	r3, [pc, #72]	; (cb20 <prvCopyDataToQueue+0x6c>)
    cad8:	b95d      	cbnz	r5, caf2 <prvCopyDataToQueue+0x3e>
		(void)memcpy((void *)pxQueue->pcWriteTo,
    cada:	6880      	ldr	r0, [r0, #8]
    cadc:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    cade:	68a3      	ldr	r3, [r4, #8]
    cae0:	6c22      	ldr	r2, [r4, #64]	; 0x40
    cae2:	4413      	add	r3, r2
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    cae4:	6862      	ldr	r2, [r4, #4]
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    cae6:	60a3      	str	r3, [r4, #8]
		if (pxQueue->pcWriteTo >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as comparison of pointers is
    cae8:	4293      	cmp	r3, r2
    caea:	d3f0      	bcc.n	cace <prvCopyDataToQueue+0x1a>
			pxQueue->pcWriteTo = pxQueue->pcHead;
    caec:	6823      	ldr	r3, [r4, #0]
    caee:	60a3      	str	r3, [r4, #8]
    caf0:	e7ed      	b.n	cace <prvCopyDataToQueue+0x1a>
		(void)memcpy((void *)pxQueue->u.pcReadFrom,
    caf2:	68c0      	ldr	r0, [r0, #12]
    caf4:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    caf6:	6c22      	ldr	r2, [r4, #64]	; 0x40
    caf8:	68e3      	ldr	r3, [r4, #12]
    cafa:	4251      	negs	r1, r2
    cafc:	1a9b      	subs	r3, r3, r2
		if (pxQueue->u.pcReadFrom
    cafe:	6822      	ldr	r2, [r4, #0]
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
    cb00:	60e3      	str	r3, [r4, #12]
		if (pxQueue->u.pcReadFrom
    cb02:	4293      	cmp	r3, r2
			pxQueue->u.pcReadFrom = (pxQueue->pcTail - pxQueue->uxItemSize);
    cb04:	bf3e      	ittt	cc
    cb06:	6863      	ldrcc	r3, [r4, #4]
    cb08:	185b      	addcc	r3, r3, r1
    cb0a:	60e3      	strcc	r3, [r4, #12]
		if (xPosition == queueOVERWRITE) {
    cb0c:	2d02      	cmp	r5, #2
    cb0e:	d101      	bne.n	cb14 <prvCopyDataToQueue+0x60>
			if (uxMessagesWaiting > (UBaseType_t)0) {
    cb10:	b116      	cbz	r6, cb18 <prvCopyDataToQueue+0x64>
				--uxMessagesWaiting;
    cb12:	3e01      	subs	r6, #1
	BaseType_t  xReturn = pdFALSE;
    cb14:	2500      	movs	r5, #0
    cb16:	e7da      	b.n	cace <prvCopyDataToQueue+0x1a>
    cb18:	4635      	mov	r5, r6
    cb1a:	e7d8      	b.n	cace <prvCopyDataToQueue+0x1a>
    cb1c:	000136ad 	.word	0x000136ad
    cb20:	00014d35 	.word	0x00014d35

0000cb24 <prvCopyDataFromQueue>:
{
    cb24:	4603      	mov	r3, r0
    cb26:	b410      	push	{r4}
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    cb28:	6c1a      	ldr	r2, [r3, #64]	; 0x40
{
    cb2a:	4608      	mov	r0, r1
	if (pxQueue->uxItemSize != (UBaseType_t)0) {
    cb2c:	b16a      	cbz	r2, cb4a <prvCopyDataFromQueue+0x26>
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    cb2e:	68dc      	ldr	r4, [r3, #12]
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    cb30:	6859      	ldr	r1, [r3, #4]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    cb32:	4414      	add	r4, r2
		if (pxQueue->u.pcReadFrom >= pxQueue->pcTail) /*lint !e946 MISRA exception justified as use of the relational
    cb34:	428c      	cmp	r4, r1
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    cb36:	bf28      	it	cs
    cb38:	6819      	ldrcs	r1, [r3, #0]
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    cb3a:	60dc      	str	r4, [r3, #12]
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    cb3c:	bf28      	it	cs
    cb3e:	60d9      	strcs	r1, [r3, #12]
		(void)memcpy((void *)pvBuffer,
    cb40:	68d9      	ldr	r1, [r3, #12]
}
    cb42:	f85d 4b04 	ldr.w	r4, [sp], #4
		(void)memcpy((void *)pvBuffer,
    cb46:	4b02      	ldr	r3, [pc, #8]	; (cb50 <prvCopyDataFromQueue+0x2c>)
    cb48:	4718      	bx	r3
}
    cb4a:	f85d 4b04 	ldr.w	r4, [sp], #4
    cb4e:	4770      	bx	lr
    cb50:	00014d35 	.word	0x00014d35

0000cb54 <prvNotifyQueueSetContainer.part.0>:
    cb54:	f04f 0380 	mov.w	r3, #128	; 0x80
    cb58:	f383 8811 	msr	BASEPRI, r3
    cb5c:	f3bf 8f6f 	isb	sy
    cb60:	f3bf 8f4f 	dsb	sy
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
	BaseType_t xReturn             = pdFALSE;

	/* This function must be called form a critical section. */

	configASSERT(pxQueueSetContainer);
    cb64:	e7fe      	b.n	cb64 <prvNotifyQueueSetContainer.part.0+0x10>
	...

0000cb68 <prvNotifyQueueSetContainer>:
{
    cb68:	b573      	push	{r0, r1, r4, r5, r6, lr}
	Queue_t *  pxQueueSetContainer = pxQueue->pxQueueSetContainer;
    cb6a:	6c84      	ldr	r4, [r0, #72]	; 0x48
{
    cb6c:	9001      	str	r0, [sp, #4]
    cb6e:	460a      	mov	r2, r1
	configASSERT(pxQueueSetContainer);
    cb70:	b90c      	cbnz	r4, cb76 <prvNotifyQueueSetContainer+0xe>
    cb72:	4b17      	ldr	r3, [pc, #92]	; (cbd0 <prvNotifyQueueSetContainer+0x68>)
    cb74:	4798      	blx	r3
	configASSERT(pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength);
    cb76:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    cb78:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cb7a:	4299      	cmp	r1, r3
    cb7c:	d308      	bcc.n	cb90 <prvNotifyQueueSetContainer+0x28>
    cb7e:	f04f 0380 	mov.w	r3, #128	; 0x80
    cb82:	f383 8811 	msr	BASEPRI, r3
    cb86:	f3bf 8f6f 	isb	sy
    cb8a:	f3bf 8f4f 	dsb	sy
    cb8e:	e7fe      	b.n	cb8e <prvNotifyQueueSetContainer+0x26>

	if (pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength) {
    cb90:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    cb92:	428b      	cmp	r3, r1
    cb94:	d91a      	bls.n	cbcc <prvNotifyQueueSetContainer+0x64>
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    cb96:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45

		traceQUEUE_SEND(pxQueueSetContainer);

		/* The data copied is the handle of the queue that contains data. */
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    cb9a:	4b0e      	ldr	r3, [pc, #56]	; (cbd4 <prvNotifyQueueSetContainer+0x6c>)
    cb9c:	a901      	add	r1, sp, #4
    cb9e:	4620      	mov	r0, r4
    cba0:	4798      	blx	r3
		const int8_t cTxLock = pxQueueSetContainer->cTxLock;
    cba2:	b26d      	sxtb	r5, r5

		if (cTxLock == queueUNLOCKED) {
    cba4:	1c6b      	adds	r3, r5, #1
		xReturn = prvCopyDataToQueue(pxQueueSetContainer, &pxQueue, xCopyPosition);
    cba6:	4606      	mov	r6, r0
		if (cTxLock == queueUNLOCKED) {
    cba8:	d10b      	bne.n	cbc2 <prvNotifyQueueSetContainer+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueueSetContainer->xTasksWaitingToReceive)) == pdFALSE) {
    cbaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cbac:	b133      	cbz	r3, cbbc <prvNotifyQueueSetContainer+0x54>
				if (xTaskRemoveFromEventList(&(pxQueueSetContainer->xTasksWaitingToReceive)) != pdFALSE) {
    cbae:	4b0a      	ldr	r3, [pc, #40]	; (cbd8 <prvNotifyQueueSetContainer+0x70>)
    cbb0:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cbb4:	4798      	blx	r3
					/* The task waiting has a higher priority. */
					xReturn = pdTRUE;
    cbb6:	2800      	cmp	r0, #0
    cbb8:	bf18      	it	ne
    cbba:	2601      	movne	r6, #1
	} else {
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    cbbc:	4630      	mov	r0, r6
    cbbe:	b002      	add	sp, #8
    cbc0:	bd70      	pop	{r4, r5, r6, pc}
			pxQueueSetContainer->cTxLock = (int8_t)(cTxLock + 1);
    cbc2:	3501      	adds	r5, #1
    cbc4:	b26d      	sxtb	r5, r5
    cbc6:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    cbca:	e7f7      	b.n	cbbc <prvNotifyQueueSetContainer+0x54>
	BaseType_t xReturn             = pdFALSE;
    cbcc:	2600      	movs	r6, #0
	return xReturn;
    cbce:	e7f5      	b.n	cbbc <prvNotifyQueueSetContainer+0x54>
    cbd0:	0000cb55 	.word	0x0000cb55
    cbd4:	0000cab5 	.word	0x0000cab5
    cbd8:	00013565 	.word	0x00013565

0000cbdc <prvUnlockQueue>:
{
    cbdc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    cbe0:	4604      	mov	r4, r0
	taskENTER_CRITICAL();
    cbe2:	4f1f      	ldr	r7, [pc, #124]	; (cc60 <prvUnlockQueue+0x84>)
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    cbe4:	4e1f      	ldr	r6, [pc, #124]	; (cc64 <prvUnlockQueue+0x88>)
						vTaskMissedYield();
    cbe6:	f8df 8084 	ldr.w	r8, [pc, #132]	; cc6c <prvUnlockQueue+0x90>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    cbea:	f8df 9084 	ldr.w	r9, [pc, #132]	; cc70 <prvUnlockQueue+0x94>
	taskENTER_CRITICAL();
    cbee:	47b8      	blx	r7
		int8_t cTxLock = pxQueue->cTxLock;
    cbf0:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
    cbf4:	b26d      	sxtb	r5, r5
		while (cTxLock > queueLOCKED_UNMODIFIED) {
    cbf6:	2d00      	cmp	r5, #0
    cbf8:	dc17      	bgt.n	cc2a <prvUnlockQueue+0x4e>
		pxQueue->cTxLock = queueUNLOCKED;
    cbfa:	23ff      	movs	r3, #255	; 0xff
    cbfc:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	taskEXIT_CRITICAL();
    cc00:	4e19      	ldr	r6, [pc, #100]	; (cc68 <prvUnlockQueue+0x8c>)
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    cc02:	f8df 8060 	ldr.w	r8, [pc, #96]	; cc64 <prvUnlockQueue+0x88>
					vTaskMissedYield();
    cc06:	f8df 9064 	ldr.w	r9, [pc, #100]	; cc6c <prvUnlockQueue+0x90>
	taskEXIT_CRITICAL();
    cc0a:	47b0      	blx	r6
	taskENTER_CRITICAL();
    cc0c:	47b8      	blx	r7
		int8_t cRxLock = pxQueue->cRxLock;
    cc0e:	f894 5044 	ldrb.w	r5, [r4, #68]	; 0x44
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    cc12:	f104 0710 	add.w	r7, r4, #16
		int8_t cRxLock = pxQueue->cRxLock;
    cc16:	b26d      	sxtb	r5, r5
		while (cRxLock > queueLOCKED_UNMODIFIED) {
    cc18:	2d00      	cmp	r5, #0
    cc1a:	dc17      	bgt.n	cc4c <prvUnlockQueue+0x70>
		pxQueue->cRxLock = queueUNLOCKED;
    cc1c:	23ff      	movs	r3, #255	; 0xff
    cc1e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();
    cc22:	4633      	mov	r3, r6
}
    cc24:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	taskEXIT_CRITICAL();
    cc28:	4718      	bx	r3
				if (pxQueue->pxQueueSetContainer != NULL) {
    cc2a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    cc2c:	b13b      	cbz	r3, cc3e <prvUnlockQueue+0x62>
					if (prvNotifyQueueSetContainer(pxQueue, queueSEND_TO_BACK) != pdFALSE) {
    cc2e:	2100      	movs	r1, #0
    cc30:	4620      	mov	r0, r4
    cc32:	47c8      	blx	r9
    cc34:	b100      	cbz	r0, cc38 <prvUnlockQueue+0x5c>
						vTaskMissedYield();
    cc36:	47c0      	blx	r8
			--cTxLock;
    cc38:	3d01      	subs	r5, #1
    cc3a:	b26d      	sxtb	r5, r5
    cc3c:	e7db      	b.n	cbf6 <prvUnlockQueue+0x1a>
					if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    cc3e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cc40:	2b00      	cmp	r3, #0
    cc42:	d0da      	beq.n	cbfa <prvUnlockQueue+0x1e>
						if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    cc44:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cc48:	47b0      	blx	r6
    cc4a:	e7f3      	b.n	cc34 <prvUnlockQueue+0x58>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    cc4c:	6923      	ldr	r3, [r4, #16]
    cc4e:	2b00      	cmp	r3, #0
    cc50:	d0e4      	beq.n	cc1c <prvUnlockQueue+0x40>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    cc52:	4638      	mov	r0, r7
    cc54:	47c0      	blx	r8
    cc56:	b100      	cbz	r0, cc5a <prvUnlockQueue+0x7e>
					vTaskMissedYield();
    cc58:	47c8      	blx	r9
				--cRxLock;
    cc5a:	3d01      	subs	r5, #1
    cc5c:	b26d      	sxtb	r5, r5
    cc5e:	e7db      	b.n	cc18 <prvUnlockQueue+0x3c>
    cc60:	0000bbb5 	.word	0x0000bbb5
    cc64:	00013565 	.word	0x00013565
    cc68:	0000bbf9 	.word	0x0000bbf9
    cc6c:	0001367d 	.word	0x0001367d
    cc70:	0000cb69 	.word	0x0000cb69

0000cc74 <xQueueGenericReset>:
{
    cc74:	b538      	push	{r3, r4, r5, lr}
    cc76:	460d      	mov	r5, r1
	configASSERT(pxQueue);
    cc78:	4604      	mov	r4, r0
    cc7a:	b908      	cbnz	r0, cc80 <xQueueGenericReset+0xc>
    cc7c:	4b18      	ldr	r3, [pc, #96]	; (cce0 <xQueueGenericReset+0x6c>)
    cc7e:	4798      	blx	r3
	taskENTER_CRITICAL();
    cc80:	4b18      	ldr	r3, [pc, #96]	; (cce4 <xQueueGenericReset+0x70>)
    cc82:	4798      	blx	r3
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    cc84:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    cc88:	6822      	ldr	r2, [r4, #0]
		pxQueue->pcWriteTo         = pxQueue->pcHead;
    cc8a:	60a2      	str	r2, [r4, #8]
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    cc8c:	434b      	muls	r3, r1
    cc8e:	18d0      	adds	r0, r2, r3
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    cc90:	1a5b      	subs	r3, r3, r1
    cc92:	4413      	add	r3, r2
		pxQueue->pcTail            = pxQueue->pcHead + (pxQueue->uxLength * pxQueue->uxItemSize);
    cc94:	6060      	str	r0, [r4, #4]
		pxQueue->u.pcReadFrom      = pxQueue->pcHead + ((pxQueue->uxLength - (UBaseType_t)1U) * pxQueue->uxItemSize);
    cc96:	60e3      	str	r3, [r4, #12]
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    cc98:	2000      	movs	r0, #0
		pxQueue->cRxLock           = queueUNLOCKED;
    cc9a:	23ff      	movs	r3, #255	; 0xff
		pxQueue->uxMessagesWaiting = (UBaseType_t)0U;
    cc9c:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->cRxLock           = queueUNLOCKED;
    cc9e:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock           = queueUNLOCKED;
    cca2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if (xNewQueue == pdFALSE) {
    cca6:	b995      	cbnz	r5, ccce <xQueueGenericReset+0x5a>
			if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    cca8:	6923      	ldr	r3, [r4, #16]
    ccaa:	b163      	cbz	r3, ccc6 <xQueueGenericReset+0x52>
				if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    ccac:	4b0e      	ldr	r3, [pc, #56]	; (cce8 <xQueueGenericReset+0x74>)
    ccae:	f104 0010 	add.w	r0, r4, #16
    ccb2:	4798      	blx	r3
    ccb4:	b138      	cbz	r0, ccc6 <xQueueGenericReset+0x52>
					queueYIELD_IF_USING_PREEMPTION();
    ccb6:	4b0d      	ldr	r3, [pc, #52]	; (ccec <xQueueGenericReset+0x78>)
    ccb8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ccbc:	601a      	str	r2, [r3, #0]
    ccbe:	f3bf 8f4f 	dsb	sy
    ccc2:	f3bf 8f6f 	isb	sy
	taskEXIT_CRITICAL();
    ccc6:	4b0a      	ldr	r3, [pc, #40]	; (ccf0 <xQueueGenericReset+0x7c>)
    ccc8:	4798      	blx	r3
}
    ccca:	2001      	movs	r0, #1
    cccc:	bd38      	pop	{r3, r4, r5, pc}
			vListInitialise(&(pxQueue->xTasksWaitingToSend));
    ccce:	f104 0010 	add.w	r0, r4, #16
    ccd2:	4d08      	ldr	r5, [pc, #32]	; (ccf4 <xQueueGenericReset+0x80>)
    ccd4:	47a8      	blx	r5
			vListInitialise(&(pxQueue->xTasksWaitingToReceive));
    ccd6:	f104 0024 	add.w	r0, r4, #36	; 0x24
    ccda:	47a8      	blx	r5
    ccdc:	e7f3      	b.n	ccc6 <xQueueGenericReset+0x52>
    ccde:	bf00      	nop
    cce0:	0000cb55 	.word	0x0000cb55
    cce4:	0000bbb5 	.word	0x0000bbb5
    cce8:	00013565 	.word	0x00013565
    ccec:	e000ed04 	.word	0xe000ed04
    ccf0:	0000bbf9 	.word	0x0000bbf9
    ccf4:	0000ba5d 	.word	0x0000ba5d

0000ccf8 <xQueueGenericCreate>:
{
    ccf8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ccfa:	460d      	mov	r5, r1
    ccfc:	4617      	mov	r7, r2
	configASSERT(uxQueueLength > (UBaseType_t)0);
    ccfe:	4606      	mov	r6, r0
    cd00:	b940      	cbnz	r0, cd14 <xQueueGenericCreate+0x1c>
    cd02:	f04f 0380 	mov.w	r3, #128	; 0x80
    cd06:	f383 8811 	msr	BASEPRI, r3
    cd0a:	f3bf 8f6f 	isb	sy
    cd0e:	f3bf 8f4f 	dsb	sy
    cd12:	e7fe      	b.n	cd12 <xQueueGenericCreate+0x1a>
		xQueueSizeInBytes = (size_t)(
    cd14:	4348      	muls	r0, r1
	pxNewQueue = (Queue_t *)pvPortMalloc(sizeof(Queue_t) + xQueueSizeInBytes);
    cd16:	4b0b      	ldr	r3, [pc, #44]	; (cd44 <xQueueGenericCreate+0x4c>)
    cd18:	3054      	adds	r0, #84	; 0x54
    cd1a:	4798      	blx	r3
	if (pxNewQueue != NULL) {
    cd1c:	4604      	mov	r4, r0
    cd1e:	b168      	cbz	r0, cd3c <xQueueGenericCreate+0x44>
	if (uxItemSize == (UBaseType_t)0) {
    cd20:	b175      	cbz	r5, cd40 <xQueueGenericCreate+0x48>
		pucQueueStorage = ((uint8_t *)pxNewQueue) + sizeof(Queue_t);
    cd22:	f100 0354 	add.w	r3, r0, #84	; 0x54
		pxNewQueue->pcHead = (int8_t *)pucQueueStorage;
    cd26:	6023      	str	r3, [r4, #0]
	pxNewQueue->uxItemSize = uxItemSize;
    cd28:	e9c4 650f 	strd	r6, r5, [r4, #60]	; 0x3c
	(void)xQueueGenericReset(pxNewQueue, pdTRUE);
    cd2c:	4b06      	ldr	r3, [pc, #24]	; (cd48 <xQueueGenericCreate+0x50>)
    cd2e:	2101      	movs	r1, #1
    cd30:	4620      	mov	r0, r4
    cd32:	4798      	blx	r3
		pxNewQueue->pxQueueSetContainer = NULL;
    cd34:	2300      	movs	r3, #0
		pxNewQueue->ucQueueType = ucQueueType;
    cd36:	f884 7050 	strb.w	r7, [r4, #80]	; 0x50
		pxNewQueue->pxQueueSetContainer = NULL;
    cd3a:	64a3      	str	r3, [r4, #72]	; 0x48
}
    cd3c:	4620      	mov	r0, r4
    cd3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cd40:	4603      	mov	r3, r0
    cd42:	e7f0      	b.n	cd26 <xQueueGenericCreate+0x2e>
    cd44:	0000bf75 	.word	0x0000bf75
    cd48:	0000cc75 	.word	0x0000cc75

0000cd4c <xQueueGenericSend>:
{
    cd4c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cd50:	b085      	sub	sp, #20
    cd52:	460e      	mov	r6, r1
    cd54:	9201      	str	r2, [sp, #4]
    cd56:	461c      	mov	r4, r3
	configASSERT(pxQueue);
    cd58:	4683      	mov	fp, r0
    cd5a:	b940      	cbnz	r0, cd6e <xQueueGenericSend+0x22>
    cd5c:	f04f 0380 	mov.w	r3, #128	; 0x80
    cd60:	f383 8811 	msr	BASEPRI, r3
    cd64:	f3bf 8f6f 	isb	sy
    cd68:	f3bf 8f4f 	dsb	sy
    cd6c:	e7fe      	b.n	cd6c <xQueueGenericSend+0x20>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    cd6e:	b951      	cbnz	r1, cd86 <xQueueGenericSend+0x3a>
    cd70:	6c02      	ldr	r2, [r0, #64]	; 0x40
    cd72:	b142      	cbz	r2, cd86 <xQueueGenericSend+0x3a>
    cd74:	f04f 0380 	mov.w	r3, #128	; 0x80
    cd78:	f383 8811 	msr	BASEPRI, r3
    cd7c:	f3bf 8f6f 	isb	sy
    cd80:	f3bf 8f4f 	dsb	sy
    cd84:	e7fe      	b.n	cd84 <xQueueGenericSend+0x38>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    cd86:	2c02      	cmp	r4, #2
    cd88:	d10c      	bne.n	cda4 <xQueueGenericSend+0x58>
    cd8a:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    cd8e:	2a01      	cmp	r2, #1
    cd90:	d008      	beq.n	cda4 <xQueueGenericSend+0x58>
    cd92:	f04f 0380 	mov.w	r3, #128	; 0x80
    cd96:	f383 8811 	msr	BASEPRI, r3
    cd9a:	f3bf 8f6f 	isb	sy
    cd9e:	f3bf 8f4f 	dsb	sy
    cda2:	e7fe      	b.n	cda2 <xQueueGenericSend+0x56>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    cda4:	4a47      	ldr	r2, [pc, #284]	; (cec4 <xQueueGenericSend+0x178>)
    cda6:	4790      	blx	r2
    cda8:	4680      	mov	r8, r0
    cdaa:	b950      	cbnz	r0, cdc2 <xQueueGenericSend+0x76>
    cdac:	9a01      	ldr	r2, [sp, #4]
    cdae:	b152      	cbz	r2, cdc6 <xQueueGenericSend+0x7a>
    cdb0:	f04f 0380 	mov.w	r3, #128	; 0x80
    cdb4:	f383 8811 	msr	BASEPRI, r3
    cdb8:	f3bf 8f6f 	isb	sy
    cdbc:	f3bf 8f4f 	dsb	sy
    cdc0:	e7fe      	b.n	cdc0 <xQueueGenericSend+0x74>
    cdc2:	f04f 0800 	mov.w	r8, #0
		taskENTER_CRITICAL();
    cdc6:	f8df 9128 	ldr.w	r9, [pc, #296]	; cef0 <xQueueGenericSend+0x1a4>
    cdca:	46ca      	mov	sl, r9
    cdcc:	e042      	b.n	ce54 <xQueueGenericSend+0x108>
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    cdce:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
    cdd2:	2a00      	cmp	r2, #0
    cdd4:	d055      	beq.n	ce82 <xQueueGenericSend+0x136>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    cdd6:	4b3c      	ldr	r3, [pc, #240]	; (cec8 <xQueueGenericSend+0x17c>)
    cdd8:	f10b 0024 	add.w	r0, fp, #36	; 0x24
    cddc:	4798      	blx	r3
    cdde:	e050      	b.n	ce82 <xQueueGenericSend+0x136>
				if (xTicksToWait == (TickType_t)0) {
    cde0:	9f01      	ldr	r7, [sp, #4]
    cde2:	b917      	cbnz	r7, cdea <xQueueGenericSend+0x9e>
					taskEXIT_CRITICAL();
    cde4:	47a8      	blx	r5
			return errQUEUE_FULL;
    cde6:	2000      	movs	r0, #0
    cde8:	e056      	b.n	ce98 <xQueueGenericSend+0x14c>
				} else if (xEntryTimeSet == pdFALSE) {
    cdea:	f1b8 0f00 	cmp.w	r8, #0
    cdee:	d102      	bne.n	cdf6 <xQueueGenericSend+0xaa>
					vTaskInternalSetTimeOutState(&xTimeOut);
    cdf0:	4a36      	ldr	r2, [pc, #216]	; (cecc <xQueueGenericSend+0x180>)
    cdf2:	a802      	add	r0, sp, #8
    cdf4:	4790      	blx	r2
		taskEXIT_CRITICAL();
    cdf6:	47a8      	blx	r5
		vTaskSuspendAll();
    cdf8:	4a35      	ldr	r2, [pc, #212]	; (ced0 <xQueueGenericSend+0x184>)
    cdfa:	f8df 80f8 	ldr.w	r8, [pc, #248]	; cef4 <xQueueGenericSend+0x1a8>
    cdfe:	4f35      	ldr	r7, [pc, #212]	; (ced4 <xQueueGenericSend+0x188>)
    ce00:	4790      	blx	r2
		prvLockQueue(pxQueue);
    ce02:	47d0      	blx	sl
    ce04:	f89b 2044 	ldrb.w	r2, [fp, #68]	; 0x44
    ce08:	2aff      	cmp	r2, #255	; 0xff
    ce0a:	bf04      	itt	eq
    ce0c:	2200      	moveq	r2, #0
    ce0e:	f88b 2044 	strbeq.w	r2, [fp, #68]	; 0x44
    ce12:	f89b 2045 	ldrb.w	r2, [fp, #69]	; 0x45
    ce16:	2aff      	cmp	r2, #255	; 0xff
    ce18:	bf04      	itt	eq
    ce1a:	2200      	moveq	r2, #0
    ce1c:	f88b 2045 	strbeq.w	r2, [fp, #69]	; 0x45
    ce20:	47a8      	blx	r5
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    ce22:	4a2d      	ldr	r2, [pc, #180]	; (ced8 <xQueueGenericSend+0x18c>)
    ce24:	a901      	add	r1, sp, #4
    ce26:	a802      	add	r0, sp, #8
    ce28:	4790      	blx	r2
    ce2a:	2800      	cmp	r0, #0
    ce2c:	d145      	bne.n	ceba <xQueueGenericSend+0x16e>
	taskENTER_CRITICAL();
    ce2e:	47d0      	blx	sl
		if (pxQueue->uxMessagesWaiting == pxQueue->uxLength) {
    ce30:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    ce34:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    ce38:	4291      	cmp	r1, r2
    ce3a:	d130      	bne.n	ce9e <xQueueGenericSend+0x152>
	taskEXIT_CRITICAL();
    ce3c:	47a8      	blx	r5
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToSend), xTicksToWait);
    ce3e:	9901      	ldr	r1, [sp, #4]
    ce40:	4a26      	ldr	r2, [pc, #152]	; (cedc <xQueueGenericSend+0x190>)
    ce42:	f10b 0010 	add.w	r0, fp, #16
    ce46:	4790      	blx	r2
				prvUnlockQueue(pxQueue);
    ce48:	4658      	mov	r0, fp
    ce4a:	47c0      	blx	r8
				if (xTaskResumeAll() == pdFALSE) {
    ce4c:	47b8      	blx	r7
    ce4e:	b358      	cbz	r0, cea8 <xQueueGenericSend+0x15c>
    ce50:	f04f 0801 	mov.w	r8, #1
		taskENTER_CRITICAL();
    ce54:	47c8      	blx	r9
			if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    ce56:	f8db 1038 	ldr.w	r1, [fp, #56]	; 0x38
    ce5a:	f8db 203c 	ldr.w	r2, [fp, #60]	; 0x3c
    ce5e:	4d20      	ldr	r5, [pc, #128]	; (cee0 <xQueueGenericSend+0x194>)
    ce60:	4291      	cmp	r1, r2
    ce62:	d301      	bcc.n	ce68 <xQueueGenericSend+0x11c>
    ce64:	2c02      	cmp	r4, #2
    ce66:	d1bb      	bne.n	cde0 <xQueueGenericSend+0x94>
				xYieldRequired = prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    ce68:	4622      	mov	r2, r4
    ce6a:	4631      	mov	r1, r6
    ce6c:	4658      	mov	r0, fp
    ce6e:	4e1d      	ldr	r6, [pc, #116]	; (cee4 <xQueueGenericSend+0x198>)
    ce70:	47b0      	blx	r6
					if (pxQueue->pxQueueSetContainer != NULL) {
    ce72:	f8db 2048 	ldr.w	r2, [fp, #72]	; 0x48
    ce76:	2a00      	cmp	r2, #0
    ce78:	d0a9      	beq.n	cdce <xQueueGenericSend+0x82>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    ce7a:	4b1b      	ldr	r3, [pc, #108]	; (cee8 <xQueueGenericSend+0x19c>)
    ce7c:	4621      	mov	r1, r4
    ce7e:	4658      	mov	r0, fp
    ce80:	4798      	blx	r3
						} else if (xYieldRequired != pdFALSE) {
    ce82:	b138      	cbz	r0, ce94 <xQueueGenericSend+0x148>
							queueYIELD_IF_USING_PREEMPTION();
    ce84:	4b19      	ldr	r3, [pc, #100]	; (ceec <xQueueGenericSend+0x1a0>)
    ce86:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ce8a:	601a      	str	r2, [r3, #0]
    ce8c:	f3bf 8f4f 	dsb	sy
    ce90:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    ce94:	47a8      	blx	r5
				return pdPASS;
    ce96:	2001      	movs	r0, #1
}
    ce98:	b005      	add	sp, #20
    ce9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	taskEXIT_CRITICAL();
    ce9e:	47a8      	blx	r5
				prvUnlockQueue(pxQueue);
    cea0:	4658      	mov	r0, fp
    cea2:	47c0      	blx	r8
				(void)xTaskResumeAll();
    cea4:	47b8      	blx	r7
    cea6:	e7d3      	b.n	ce50 <xQueueGenericSend+0x104>
					portYIELD_WITHIN_API();
    cea8:	4b10      	ldr	r3, [pc, #64]	; (ceec <xQueueGenericSend+0x1a0>)
    ceaa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    ceae:	601a      	str	r2, [r3, #0]
    ceb0:	f3bf 8f4f 	dsb	sy
    ceb4:	f3bf 8f6f 	isb	sy
    ceb8:	e7ca      	b.n	ce50 <xQueueGenericSend+0x104>
			prvUnlockQueue(pxQueue);
    ceba:	4658      	mov	r0, fp
    cebc:	47c0      	blx	r8
			(void)xTaskResumeAll();
    cebe:	47b8      	blx	r7
    cec0:	e791      	b.n	cde6 <xQueueGenericSend+0x9a>
    cec2:	bf00      	nop
    cec4:	0001368d 	.word	0x0001368d
    cec8:	00013565 	.word	0x00013565
    cecc:	000135e5 	.word	0x000135e5
    ced0:	000131c1 	.word	0x000131c1
    ced4:	00013309 	.word	0x00013309
    ced8:	000135f9 	.word	0x000135f9
    cedc:	000134e1 	.word	0x000134e1
    cee0:	0000bbf9 	.word	0x0000bbf9
    cee4:	0000cab5 	.word	0x0000cab5
    cee8:	0000cb69 	.word	0x0000cb69
    ceec:	e000ed04 	.word	0xe000ed04
    cef0:	0000bbb5 	.word	0x0000bbb5
    cef4:	0000cbdd 	.word	0x0000cbdd

0000cef8 <xQueueGenericSendFromISR>:
{
    cef8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    cefc:	4689      	mov	r9, r1
    cefe:	4690      	mov	r8, r2
    cf00:	461f      	mov	r7, r3
	configASSERT(pxQueue);
    cf02:	4604      	mov	r4, r0
    cf04:	b940      	cbnz	r0, cf18 <xQueueGenericSendFromISR+0x20>
    cf06:	f04f 0380 	mov.w	r3, #128	; 0x80
    cf0a:	f383 8811 	msr	BASEPRI, r3
    cf0e:	f3bf 8f6f 	isb	sy
    cf12:	f3bf 8f4f 	dsb	sy
    cf16:	e7fe      	b.n	cf16 <xQueueGenericSendFromISR+0x1e>
	configASSERT(!((pvItemToQueue == NULL) && (pxQueue->uxItemSize != (UBaseType_t)0U)));
    cf18:	b951      	cbnz	r1, cf30 <xQueueGenericSendFromISR+0x38>
    cf1a:	6c03      	ldr	r3, [r0, #64]	; 0x40
    cf1c:	b143      	cbz	r3, cf30 <xQueueGenericSendFromISR+0x38>
    cf1e:	f04f 0380 	mov.w	r3, #128	; 0x80
    cf22:	f383 8811 	msr	BASEPRI, r3
    cf26:	f3bf 8f6f 	isb	sy
    cf2a:	f3bf 8f4f 	dsb	sy
    cf2e:	e7fe      	b.n	cf2e <xQueueGenericSendFromISR+0x36>
	configASSERT(!((xCopyPosition == queueOVERWRITE) && (pxQueue->uxLength != 1)));
    cf30:	2f02      	cmp	r7, #2
    cf32:	d10b      	bne.n	cf4c <xQueueGenericSendFromISR+0x54>
    cf34:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cf36:	2b01      	cmp	r3, #1
    cf38:	d008      	beq.n	cf4c <xQueueGenericSendFromISR+0x54>
    cf3a:	f04f 0380 	mov.w	r3, #128	; 0x80
    cf3e:	f383 8811 	msr	BASEPRI, r3
    cf42:	f3bf 8f6f 	isb	sy
    cf46:	f3bf 8f4f 	dsb	sy
    cf4a:	e7fe      	b.n	cf4a <xQueueGenericSendFromISR+0x52>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
    cf4c:	4b1e      	ldr	r3, [pc, #120]	; (cfc8 <xQueueGenericSendFromISR+0xd0>)
    cf4e:	4798      	blx	r3
	__asm volatile("	mrs %0, basepri											\n"
    cf50:	f3ef 8611 	mrs	r6, BASEPRI
    cf54:	f04f 0380 	mov.w	r3, #128	; 0x80
    cf58:	f383 8811 	msr	BASEPRI, r3
    cf5c:	f3bf 8f6f 	isb	sy
    cf60:	f3bf 8f4f 	dsb	sy
		if ((pxQueue->uxMessagesWaiting < pxQueue->uxLength) || (xCopyPosition == queueOVERWRITE)) {
    cf64:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    cf66:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    cf68:	429a      	cmp	r2, r3
    cf6a:	d301      	bcc.n	cf70 <xQueueGenericSendFromISR+0x78>
    cf6c:	2f02      	cmp	r7, #2
    cf6e:	d129      	bne.n	cfc4 <xQueueGenericSendFromISR+0xcc>
			const int8_t cTxLock = pxQueue->cTxLock;
    cf70:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    cf74:	4b15      	ldr	r3, [pc, #84]	; (cfcc <xQueueGenericSendFromISR+0xd4>)
			const int8_t cTxLock = pxQueue->cTxLock;
    cf76:	b26d      	sxtb	r5, r5
			(void)prvCopyDataToQueue(pxQueue, pvItemToQueue, xCopyPosition);
    cf78:	463a      	mov	r2, r7
    cf7a:	4649      	mov	r1, r9
    cf7c:	4620      	mov	r0, r4
    cf7e:	4798      	blx	r3
			if (cTxLock == queueUNLOCKED) {
    cf80:	1c6b      	adds	r3, r5, #1
    cf82:	d11a      	bne.n	cfba <xQueueGenericSendFromISR+0xc2>
					if (pxQueue->pxQueueSetContainer != NULL) {
    cf84:	6ca3      	ldr	r3, [r4, #72]	; 0x48
    cf86:	b183      	cbz	r3, cfaa <xQueueGenericSendFromISR+0xb2>
						if (prvNotifyQueueSetContainer(pxQueue, xCopyPosition) != pdFALSE) {
    cf88:	4b11      	ldr	r3, [pc, #68]	; (cfd0 <xQueueGenericSendFromISR+0xd8>)
    cf8a:	4639      	mov	r1, r7
    cf8c:	4620      	mov	r0, r4
    cf8e:	4798      	blx	r3
    cf90:	b908      	cbnz	r0, cf96 <xQueueGenericSendFromISR+0x9e>
			xReturn = pdPASS;
    cf92:	2001      	movs	r0, #1
    cf94:	e005      	b.n	cfa2 <xQueueGenericSendFromISR+0xaa>
							if (pxHigherPriorityTaskWoken != NULL) {
    cf96:	f1b8 0f00 	cmp.w	r8, #0
    cf9a:	d0fa      	beq.n	cf92 <xQueueGenericSendFromISR+0x9a>
								*pxHigherPriorityTaskWoken = pdTRUE;
    cf9c:	2001      	movs	r0, #1
    cf9e:	f8c8 0000 	str.w	r0, [r8]
	__asm volatile("	msr basepri, %0	" ::"r"(ulNewMaskValue) : "memory");
    cfa2:	f386 8811 	msr	BASEPRI, r6
}
    cfa6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToReceive)) == pdFALSE) {
    cfaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    cfac:	2b00      	cmp	r3, #0
    cfae:	d0f0      	beq.n	cf92 <xQueueGenericSendFromISR+0x9a>
							if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToReceive)) != pdFALSE) {
    cfb0:	4b08      	ldr	r3, [pc, #32]	; (cfd4 <xQueueGenericSendFromISR+0xdc>)
    cfb2:	f104 0024 	add.w	r0, r4, #36	; 0x24
    cfb6:	4798      	blx	r3
    cfb8:	e7ea      	b.n	cf90 <xQueueGenericSendFromISR+0x98>
				pxQueue->cTxLock = (int8_t)(cTxLock + 1);
    cfba:	3501      	adds	r5, #1
    cfbc:	b26d      	sxtb	r5, r5
    cfbe:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
    cfc2:	e7e6      	b.n	cf92 <xQueueGenericSendFromISR+0x9a>
			xReturn = errQUEUE_FULL;
    cfc4:	2000      	movs	r0, #0
    cfc6:	e7ec      	b.n	cfa2 <xQueueGenericSendFromISR+0xaa>
    cfc8:	0000bded 	.word	0x0000bded
    cfcc:	0000cab5 	.word	0x0000cab5
    cfd0:	0000cb69 	.word	0x0000cb69
    cfd4:	00013565 	.word	0x00013565

0000cfd8 <xQueueReceive>:
{
    cfd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    cfdc:	b085      	sub	sp, #20
    cfde:	460f      	mov	r7, r1
    cfe0:	9201      	str	r2, [sp, #4]
	configASSERT((pxQueue));
    cfe2:	4604      	mov	r4, r0
    cfe4:	b940      	cbnz	r0, cff8 <xQueueReceive+0x20>
	__asm volatile("	mov %0, %1												\n"
    cfe6:	f04f 0380 	mov.w	r3, #128	; 0x80
    cfea:	f383 8811 	msr	BASEPRI, r3
    cfee:	f3bf 8f6f 	isb	sy
    cff2:	f3bf 8f4f 	dsb	sy
    cff6:	e7fe      	b.n	cff6 <xQueueReceive+0x1e>
	configASSERT(!(((pvBuffer) == NULL) && ((pxQueue)->uxItemSize != (UBaseType_t)0U)));
    cff8:	b951      	cbnz	r1, d010 <xQueueReceive+0x38>
    cffa:	6c03      	ldr	r3, [r0, #64]	; 0x40
    cffc:	b143      	cbz	r3, d010 <xQueueReceive+0x38>
    cffe:	f04f 0380 	mov.w	r3, #128	; 0x80
    d002:	f383 8811 	msr	BASEPRI, r3
    d006:	f3bf 8f6f 	isb	sy
    d00a:	f3bf 8f4f 	dsb	sy
    d00e:	e7fe      	b.n	d00e <xQueueReceive+0x36>
		configASSERT(!((xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED) && (xTicksToWait != 0)));
    d010:	4b3e      	ldr	r3, [pc, #248]	; (d10c <xQueueReceive+0x134>)
    d012:	4798      	blx	r3
    d014:	4606      	mov	r6, r0
    d016:	b950      	cbnz	r0, d02e <xQueueReceive+0x56>
    d018:	9b01      	ldr	r3, [sp, #4]
    d01a:	b14b      	cbz	r3, d030 <xQueueReceive+0x58>
    d01c:	f04f 0380 	mov.w	r3, #128	; 0x80
    d020:	f383 8811 	msr	BASEPRI, r3
    d024:	f3bf 8f6f 	isb	sy
    d028:	f3bf 8f4f 	dsb	sy
    d02c:	e7fe      	b.n	d02c <xQueueReceive+0x54>
    d02e:	2600      	movs	r6, #0
		taskENTER_CRITICAL();
    d030:	f8df 9100 	ldr.w	r9, [pc, #256]	; d134 <xQueueReceive+0x15c>
					portYIELD_WITHIN_API();
    d034:	f8df b0f8 	ldr.w	fp, [pc, #248]	; d130 <xQueueReceive+0x158>
    d038:	46ca      	mov	sl, r9
    d03a:	e03b      	b.n	d0b4 <xQueueReceive+0xdc>
				if (xTicksToWait == (TickType_t)0) {
    d03c:	9d01      	ldr	r5, [sp, #4]
    d03e:	b915      	cbnz	r5, d046 <xQueueReceive+0x6e>
					taskEXIT_CRITICAL();
    d040:	47c0      	blx	r8
				return errQUEUE_EMPTY;
    d042:	2000      	movs	r0, #0
    d044:	e053      	b.n	d0ee <xQueueReceive+0x116>
				} else if (xEntryTimeSet == pdFALSE) {
    d046:	b916      	cbnz	r6, d04e <xQueueReceive+0x76>
					vTaskInternalSetTimeOutState(&xTimeOut);
    d048:	4b31      	ldr	r3, [pc, #196]	; (d110 <xQueueReceive+0x138>)
    d04a:	a802      	add	r0, sp, #8
    d04c:	4798      	blx	r3
		taskEXIT_CRITICAL();
    d04e:	47c0      	blx	r8
		vTaskSuspendAll();
    d050:	4b30      	ldr	r3, [pc, #192]	; (d114 <xQueueReceive+0x13c>)
    d052:	4e31      	ldr	r6, [pc, #196]	; (d118 <xQueueReceive+0x140>)
    d054:	4d31      	ldr	r5, [pc, #196]	; (d11c <xQueueReceive+0x144>)
    d056:	4798      	blx	r3
		prvLockQueue(pxQueue);
    d058:	47d0      	blx	sl
    d05a:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    d05e:	2bff      	cmp	r3, #255	; 0xff
    d060:	bf04      	itt	eq
    d062:	2300      	moveq	r3, #0
    d064:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    d068:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d06c:	2bff      	cmp	r3, #255	; 0xff
    d06e:	bf04      	itt	eq
    d070:	2300      	moveq	r3, #0
    d072:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    d076:	47c0      	blx	r8
		if (xTaskCheckForTimeOut(&xTimeOut, &xTicksToWait) == pdFALSE) {
    d078:	4b29      	ldr	r3, [pc, #164]	; (d120 <xQueueReceive+0x148>)
    d07a:	f8df 80bc 	ldr.w	r8, [pc, #188]	; d138 <xQueueReceive+0x160>
    d07e:	a901      	add	r1, sp, #4
    d080:	a802      	add	r0, sp, #8
    d082:	4798      	blx	r3
    d084:	2800      	cmp	r0, #0
    d086:	d139      	bne.n	d0fc <xQueueReceive+0x124>
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    d088:	4620      	mov	r0, r4
    d08a:	47c0      	blx	r8
    d08c:	2800      	cmp	r0, #0
    d08e:	d031      	beq.n	d0f4 <xQueueReceive+0x11c>
				vTaskPlaceOnEventList(&(pxQueue->xTasksWaitingToReceive), xTicksToWait);
    d090:	9901      	ldr	r1, [sp, #4]
    d092:	4b24      	ldr	r3, [pc, #144]	; (d124 <xQueueReceive+0x14c>)
    d094:	f104 0024 	add.w	r0, r4, #36	; 0x24
    d098:	4798      	blx	r3
				prvUnlockQueue(pxQueue);
    d09a:	4620      	mov	r0, r4
    d09c:	47b0      	blx	r6
				if (xTaskResumeAll() == pdFALSE) {
    d09e:	47a8      	blx	r5
    d0a0:	b938      	cbnz	r0, d0b2 <xQueueReceive+0xda>
					portYIELD_WITHIN_API();
    d0a2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    d0a6:	f8cb 3000 	str.w	r3, [fp]
    d0aa:	f3bf 8f4f 	dsb	sy
    d0ae:	f3bf 8f6f 	isb	sy
    d0b2:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
    d0b4:	47c8      	blx	r9
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    d0b6:	6ba5      	ldr	r5, [r4, #56]	; 0x38
			if (uxMessagesWaiting > (UBaseType_t)0) {
    d0b8:	f8df 8080 	ldr.w	r8, [pc, #128]	; d13c <xQueueReceive+0x164>
    d0bc:	2d00      	cmp	r5, #0
    d0be:	d0bd      	beq.n	d03c <xQueueReceive+0x64>
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    d0c0:	4b19      	ldr	r3, [pc, #100]	; (d128 <xQueueReceive+0x150>)
    d0c2:	4639      	mov	r1, r7
    d0c4:	4620      	mov	r0, r4
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    d0c6:	3d01      	subs	r5, #1
				prvCopyDataFromQueue(pxQueue, pvBuffer);
    d0c8:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - (UBaseType_t)1;
    d0ca:	63a5      	str	r5, [r4, #56]	; 0x38
				if (listLIST_IS_EMPTY(&(pxQueue->xTasksWaitingToSend)) == pdFALSE) {
    d0cc:	6923      	ldr	r3, [r4, #16]
    d0ce:	b163      	cbz	r3, d0ea <xQueueReceive+0x112>
					if (xTaskRemoveFromEventList(&(pxQueue->xTasksWaitingToSend)) != pdFALSE) {
    d0d0:	4b16      	ldr	r3, [pc, #88]	; (d12c <xQueueReceive+0x154>)
    d0d2:	f104 0010 	add.w	r0, r4, #16
    d0d6:	4798      	blx	r3
    d0d8:	b138      	cbz	r0, d0ea <xQueueReceive+0x112>
						queueYIELD_IF_USING_PREEMPTION();
    d0da:	4b15      	ldr	r3, [pc, #84]	; (d130 <xQueueReceive+0x158>)
    d0dc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    d0e0:	601a      	str	r2, [r3, #0]
    d0e2:	f3bf 8f4f 	dsb	sy
    d0e6:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
    d0ea:	47c0      	blx	r8
				return pdPASS;
    d0ec:	2001      	movs	r0, #1
}
    d0ee:	b005      	add	sp, #20
    d0f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				prvUnlockQueue(pxQueue);
    d0f4:	4620      	mov	r0, r4
    d0f6:	47b0      	blx	r6
				(void)xTaskResumeAll();
    d0f8:	47a8      	blx	r5
    d0fa:	e7da      	b.n	d0b2 <xQueueReceive+0xda>
			prvUnlockQueue(pxQueue);
    d0fc:	4620      	mov	r0, r4
    d0fe:	47b0      	blx	r6
			(void)xTaskResumeAll();
    d100:	47a8      	blx	r5
			if (prvIsQueueEmpty(pxQueue) != pdFALSE) {
    d102:	4620      	mov	r0, r4
    d104:	47c0      	blx	r8
    d106:	2800      	cmp	r0, #0
    d108:	d0d3      	beq.n	d0b2 <xQueueReceive+0xda>
    d10a:	e79a      	b.n	d042 <xQueueReceive+0x6a>
    d10c:	0001368d 	.word	0x0001368d
    d110:	000135e5 	.word	0x000135e5
    d114:	000131c1 	.word	0x000131c1
    d118:	0000cbdd 	.word	0x0000cbdd
    d11c:	00013309 	.word	0x00013309
    d120:	000135f9 	.word	0x000135f9
    d124:	000134e1 	.word	0x000134e1
    d128:	0000cb25 	.word	0x0000cb25
    d12c:	00013565 	.word	0x00013565
    d130:	e000ed04 	.word	0xe000ed04
    d134:	0000bbb5 	.word	0x0000bbb5
    d138:	0000ca95 	.word	0x0000ca95
    d13c:	0000bbf9 	.word	0x0000bbf9

0000d140 <vQueueWaitForMessageRestricted>:
{
    d140:	b570      	push	{r4, r5, r6, lr}
    d142:	4604      	mov	r4, r0
	prvLockQueue(pxQueue);
    d144:	4b10      	ldr	r3, [pc, #64]	; (d188 <vQueueWaitForMessageRestricted+0x48>)
{
    d146:	460d      	mov	r5, r1
    d148:	4616      	mov	r6, r2
	prvLockQueue(pxQueue);
    d14a:	4798      	blx	r3
    d14c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
    d150:	2bff      	cmp	r3, #255	; 0xff
    d152:	bf04      	itt	eq
    d154:	2300      	moveq	r3, #0
    d156:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
    d15a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
    d15e:	2bff      	cmp	r3, #255	; 0xff
    d160:	bf04      	itt	eq
    d162:	2300      	moveq	r3, #0
    d164:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
    d168:	4b08      	ldr	r3, [pc, #32]	; (d18c <vQueueWaitForMessageRestricted+0x4c>)
    d16a:	4798      	blx	r3
	if (pxQueue->uxMessagesWaiting == (UBaseType_t)0U) {
    d16c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    d16e:	b92b      	cbnz	r3, d17c <vQueueWaitForMessageRestricted+0x3c>
		vTaskPlaceOnEventListRestricted(&(pxQueue->xTasksWaitingToReceive), xTicksToWait, xWaitIndefinitely);
    d170:	4b07      	ldr	r3, [pc, #28]	; (d190 <vQueueWaitForMessageRestricted+0x50>)
    d172:	4632      	mov	r2, r6
    d174:	4629      	mov	r1, r5
    d176:	f104 0024 	add.w	r0, r4, #36	; 0x24
    d17a:	4798      	blx	r3
	prvUnlockQueue(pxQueue);
    d17c:	4620      	mov	r0, r4
    d17e:	4b05      	ldr	r3, [pc, #20]	; (d194 <vQueueWaitForMessageRestricted+0x54>)
}
    d180:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvUnlockQueue(pxQueue);
    d184:	4718      	bx	r3
    d186:	bf00      	nop
    d188:	0000bbb5 	.word	0x0000bbb5
    d18c:	0000bbf9 	.word	0x0000bbf9
    d190:	0001351d 	.word	0x0001351d
    d194:	0000cbdd 	.word	0x0000cbdd

0000d198 <gpio_get_pin_level>:
{
    d198:	b537      	push	{r0, r1, r2, r4, r5, lr}
	CRITICAL_SECTION_ENTER();
    d19a:	4b0e      	ldr	r3, [pc, #56]	; (d1d4 <gpio_get_pin_level+0x3c>)
    d19c:	4605      	mov	r5, r0
    d19e:	a801      	add	r0, sp, #4
    d1a0:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
    d1a2:	4a0d      	ldr	r2, [pc, #52]	; (d1d8 <gpio_get_pin_level+0x40>)
    d1a4:	096b      	lsrs	r3, r5, #5
    d1a6:	01d9      	lsls	r1, r3, #7
    d1a8:	eb02 13c3 	add.w	r3, r2, r3, lsl #7
    d1ac:	5851      	ldr	r1, [r2, r1]
	return ((Port *)hw)->Group[submodule_index].IN.reg;
    d1ae:	6a1a      	ldr	r2, [r3, #32]
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
    d1b0:	691c      	ldr	r4, [r3, #16]
	CRITICAL_SECTION_LEAVE();
    d1b2:	4b0a      	ldr	r3, [pc, #40]	; (d1dc <gpio_get_pin_level+0x44>)
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    d1b4:	4054      	eors	r4, r2
    d1b6:	400c      	ands	r4, r1
	CRITICAL_SECTION_LEAVE();
    d1b8:	a801      	add	r0, sp, #4
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
    d1ba:	4054      	eors	r4, r2
	return (bool)(_gpio_get_level((enum gpio_port)GPIO_PORT(pin)) & (0x01U << GPIO_PIN(pin)));
    d1bc:	f005 051f 	and.w	r5, r5, #31
	CRITICAL_SECTION_LEAVE();
    d1c0:	4798      	blx	r3
    d1c2:	2001      	movs	r0, #1
    d1c4:	fa00 f505 	lsl.w	r5, r0, r5
    d1c8:	4225      	tst	r5, r4
}
    d1ca:	bf08      	it	eq
    d1cc:	2000      	moveq	r0, #0
    d1ce:	b003      	add	sp, #12
    d1d0:	bd30      	pop	{r4, r5, pc}
    d1d2:	bf00      	nop
    d1d4:	00012485 	.word	0x00012485
    d1d8:	41008000 	.word	0x41008000
    d1dc:	00012493 	.word	0x00012493

0000d1e0 <hiddf_demo_sof_event>:
#endif /* CONF_USB_COMPOSITE_CDC_ECHO_DEMO */

#if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO
static uint32_t pin_btn1, pin_btn2, pin_btn3;
static void     hiddf_demo_sof_event(void)
{
    d1e0:	b570      	push	{r4, r5, r6, lr}
        {HID_CAPS_LOCK, false, HID_KB_KEY_UP},
    };
	uint8_t b_btn_state;
#endif

	if (interval++ > 10) {
    d1e2:	4a15      	ldr	r2, [pc, #84]	; (d238 <hiddf_demo_sof_event+0x58>)
    d1e4:	7913      	ldrb	r3, [r2, #4]
    d1e6:	2b0a      	cmp	r3, #10
    d1e8:	4614      	mov	r4, r2
    d1ea:	d802      	bhi.n	d1f2 <hiddf_demo_sof_event+0x12>
    d1ec:	3301      	adds	r3, #1
    d1ee:	7113      	strb	r3, [r2, #4]
#endif
	}
	(void)pin_btn1;
	(void)pin_btn2;
	(void)pin_btn3;
}
    d1f0:	bd70      	pop	{r4, r5, r6, pc}
		interval = 0;
    d1f2:	2300      	movs	r3, #0
		if (!gpio_get_pin_level(pin_btn1)) {
    d1f4:	7a10      	ldrb	r0, [r2, #8]
    d1f6:	4d11      	ldr	r5, [pc, #68]	; (d23c <hiddf_demo_sof_event+0x5c>)
		interval = 0;
    d1f8:	7113      	strb	r3, [r2, #4]
		if (!gpio_get_pin_level(pin_btn1)) {
    d1fa:	47a8      	blx	r5
    d1fc:	b920      	cbnz	r0, d208 <hiddf_demo_sof_event+0x28>
			hiddf_mouse_move(-5, HID_MOUSE_X_AXIS_MV);
    d1fe:	4b10      	ldr	r3, [pc, #64]	; (d240 <hiddf_demo_sof_event+0x60>)
    d200:	2101      	movs	r1, #1
    d202:	f06f 0004 	mvn.w	r0, #4
    d206:	4798      	blx	r3
		if (!gpio_get_pin_level(pin_btn3)) {
    d208:	7b20      	ldrb	r0, [r4, #12]
    d20a:	47a8      	blx	r5
    d20c:	b918      	cbnz	r0, d216 <hiddf_demo_sof_event+0x36>
			hiddf_mouse_move(5, HID_MOUSE_X_AXIS_MV);
    d20e:	4b0c      	ldr	r3, [pc, #48]	; (d240 <hiddf_demo_sof_event+0x60>)
    d210:	2101      	movs	r1, #1
    d212:	2005      	movs	r0, #5
    d214:	4798      	blx	r3
		if (b_btn_last_state != (b_btn_state = !gpio_get_pin_level(pin_btn2))) {
    d216:	7c20      	ldrb	r0, [r4, #16]
    d218:	47a8      	blx	r5
    d21a:	7d22      	ldrb	r2, [r4, #20]
    d21c:	f080 0001 	eor.w	r0, r0, #1
    d220:	b2c3      	uxtb	r3, r0
    d222:	429a      	cmp	r2, r3
    d224:	d0e4      	beq.n	d1f0 <hiddf_demo_sof_event+0x10>
			b_btn_last_state = b_btn_state;
    d226:	4807      	ldr	r0, [pc, #28]	; (d244 <hiddf_demo_sof_event+0x64>)
    d228:	7523      	strb	r3, [r4, #20]
			if (1 == b_btn_last_state) {
    d22a:	7083      	strb	r3, [r0, #2]
}
    d22c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			hiddf_keyboard_keys_state_change(key_array, 1);
    d230:	4b05      	ldr	r3, [pc, #20]	; (d248 <hiddf_demo_sof_event+0x68>)
    d232:	2101      	movs	r1, #1
    d234:	4718      	bx	r3
    d236:	bf00      	nop
    d238:	20008550 	.word	0x20008550
    d23c:	0000d199 	.word	0x0000d199
    d240:	0000e971 	.word	0x0000e971
    d244:	2000035c 	.word	0x2000035c
    d248:	0000f3fd 	.word	0x0000f3fd

0000d24c <composite_device_init>:
	usbdc_register_handler(USBDC_HDL_SOF, &hiddf_demo_sof_event_h);
}
#endif /* #if CONF_USB_COMPOSITE_HID_MOUSE_DEMO || CONF_USB_COMPOSITE_HID_KEYBOARD_DEMO */

void composite_device_init(void)
{
    d24c:	b510      	push	{r4, lr}
	/* usb stack init */
	usbdc_init(ctrl_buffer);
    d24e:	4b05      	ldr	r3, [pc, #20]	; (d264 <composite_device_init+0x18>)
    d250:	4805      	ldr	r0, [pc, #20]	; (d268 <composite_device_init+0x1c>)
    d252:	4798      	blx	r3

	/* usbdc_register_funcion inside */
#if CONF_USB_COMPOSITE_CDC_ACM_EN
	cdcdf_acm_init();
    d254:	4b05      	ldr	r3, [pc, #20]	; (d26c <composite_device_init+0x20>)
    d256:	4798      	blx	r3
#endif
#if CONF_USB_COMPOSITE_HID_MOUSE_EN
	hiddf_mouse_init();
    d258:	4b05      	ldr	r3, [pc, #20]	; (d270 <composite_device_init+0x24>)
    d25a:	4798      	blx	r3
	hiddf_keyboard_init();
#endif
#if CONF_USB_COMPOSITE_MSC_EN
	mscdf_init(CONF_USB_MSC_MAX_LUN);
#endif
}
    d25c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hiddf_keyboard_init();
    d260:	4b04      	ldr	r3, [pc, #16]	; (d274 <composite_device_init+0x28>)
    d262:	4718      	bx	r3
    d264:	00014021 	.word	0x00014021
    d268:	20008565 	.word	0x20008565
    d26c:	0000c641 	.word	0x0000c641
    d270:	0000e92d 	.word	0x0000e92d
    d274:	0000f3b9 	.word	0x0000f3b9

0000d278 <composite_device_start>:

void composite_device_start(void)
{
    d278:	b510      	push	{r4, lr}
	usbdc_start(multi_desc);
    d27a:	4b03      	ldr	r3, [pc, #12]	; (d288 <composite_device_start+0x10>)
    d27c:	4803      	ldr	r0, [pc, #12]	; (d28c <composite_device_start+0x14>)
    d27e:	4798      	blx	r3
	usbdc_attach();
}
    d280:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	usbdc_attach();
    d284:	4b02      	ldr	r3, [pc, #8]	; (d290 <composite_device_start+0x18>)
    d286:	4718      	bx	r3
    d288:	0001408d 	.word	0x0001408d
    d28c:	20000368 	.word	0x20000368
    d290:	000140c1 	.word	0x000140c1

0000d294 <usb_init>:
}

void usb_init(void)
{

	composite_device_init();
    d294:	4b00      	ldr	r3, [pc, #0]	; (d298 <usb_init+0x4>)
    d296:	4718      	bx	r3
    d298:	0000d24d 	.word	0x0000d24d

0000d29c <timer_add_timer_task>:
 * \param[in] head The pointer to the head of timer task list
 * \param[in] task The pointer to task to add
 * \param[in] time Current timer time
 */
static void timer_add_timer_task(struct list_descriptor *list, struct timer_task *const new_task, const uint32_t time)
{
    d29c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    d29e:	6805      	ldr	r5, [r0, #0]

	if (!head) {
    d2a0:	b91d      	cbnz	r5, d2aa <timer_add_timer_task+0xe>
		list_insert_as_head(list, new_task);
    d2a2:	4b0f      	ldr	r3, [pc, #60]	; (d2e0 <timer_add_timer_task+0x44>)
	if (it == head) {
		list_insert_as_head(list, new_task);
	} else {
		list_insert_after(prev, new_task);
	}
}
    d2a4:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		list_insert_after(prev, new_task);
    d2a8:	4718      	bx	r3
		if (time_left >= new_task->interval)
    d2aa:	f8d1 c008 	ldr.w	ip, [r1, #8]
    d2ae:	462c      	mov	r4, r5
	struct timer_task *it, *prev = NULL, *head = (struct timer_task *)list_get_head(list);
    d2b0:	2600      	movs	r6, #0
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    d2b2:	f1c2 0e01 	rsb	lr, r2, #1
		if (it->time_label <= time) {
    d2b6:	e9d4 3701 	ldrd	r3, r7, [r4, #4]
    d2ba:	4293      	cmp	r3, r2
			time_left = it->interval - (time - it->time_label);
    d2bc:	bf95      	itete	ls
    d2be:	19db      	addls	r3, r3, r7
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    d2c0:	4473      	addhi	r3, lr
			time_left = it->interval - (time - it->time_label);
    d2c2:	1a9b      	subls	r3, r3, r2
			time_left = it->interval - (0xFFFFFFFF - it->time_label) - time;
    d2c4:	19db      	addhi	r3, r3, r7
		if (time_left >= new_task->interval)
    d2c6:	459c      	cmp	ip, r3
    d2c8:	d907      	bls.n	d2da <timer_add_timer_task+0x3e>
 * \return A pointer to the next list element or NULL if there is not next
 * element
 */
static inline void *list_get_next_element(const void *const element)
{
	return element ? ((struct list_element *)element)->next : NULL;
    d2ca:	6823      	ldr	r3, [r4, #0]
	for (it = head; it; it = (struct timer_task *)list_get_next_element(it)) {
    d2cc:	4626      	mov	r6, r4
    d2ce:	b913      	cbnz	r3, d2d6 <timer_add_timer_task+0x3a>
		list_insert_after(prev, new_task);
    d2d0:	4b04      	ldr	r3, [pc, #16]	; (d2e4 <timer_add_timer_task+0x48>)
    d2d2:	4630      	mov	r0, r6
    d2d4:	e7e6      	b.n	d2a4 <timer_add_timer_task+0x8>
    d2d6:	461c      	mov	r4, r3
    d2d8:	e7ed      	b.n	d2b6 <timer_add_timer_task+0x1a>
	if (it == head) {
    d2da:	42a5      	cmp	r5, r4
    d2dc:	d0e1      	beq.n	d2a2 <timer_add_timer_task+0x6>
    d2de:	e7f7      	b.n	d2d0 <timer_add_timer_task+0x34>
    d2e0:	00010171 	.word	0x00010171
    d2e4:	0001019d 	.word	0x0001019d

0000d2e8 <timer_process_counted>:

/**
 * \internal Process interrupts
 */
static void timer_process_counted(struct _timer_device *device)
{
    d2e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct timer_descriptor *timer = CONTAINER_OF(device, struct timer_descriptor, device);
	struct timer_task *      it    = (struct timer_task *)list_get_head(&timer->tasks);
	uint32_t                 time  = ++timer->time;
    d2ec:	e9d0 6504 	ldrd	r6, r5, [r0, #16]

	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    d2f0:	7e03      	ldrb	r3, [r0, #24]
	uint32_t                 time  = ++timer->time;
    d2f2:	3601      	adds	r6, #1
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    d2f4:	07da      	lsls	r2, r3, #31
{
    d2f6:	4604      	mov	r4, r0
	uint32_t                 time  = ++timer->time;
    d2f8:	6106      	str	r6, [r0, #16]
	if ((timer->flags & TIMER_FLAG_QUEUE_IS_TAKEN) || (timer->flags & TIMER_FLAG_INTERRUPT_TRIGERRED)) {
    d2fa:	d41f      	bmi.n	d33c <timer_process_counted+0x54>
    d2fc:	7e03      	ldrb	r3, [r0, #24]
    d2fe:	079b      	lsls	r3, r3, #30
    d300:	d41c      	bmi.n	d33c <timer_process_counted+0x54>
	}

	while (it && ((time - it->time_label) >= it->interval)) {
		struct timer_task *tmp = it;

		list_remove_head(&timer->tasks);
    d302:	f8df 8044 	ldr.w	r8, [pc, #68]	; d348 <timer_process_counted+0x60>
		if (TIMER_TASK_REPEAT == tmp->mode) {
			tmp->time_label = time;
			timer_add_timer_task(&timer->tasks, tmp, time);
    d306:	f8df 9044 	ldr.w	r9, [pc, #68]	; d34c <timer_process_counted+0x64>
		list_remove_head(&timer->tasks);
    d30a:	f100 0714 	add.w	r7, r0, #20
	while (it && ((time - it->time_label) >= it->interval)) {
    d30e:	b1cd      	cbz	r5, d344 <timer_process_counted+0x5c>
    d310:	686b      	ldr	r3, [r5, #4]
    d312:	68aa      	ldr	r2, [r5, #8]
    d314:	1af3      	subs	r3, r6, r3
    d316:	4293      	cmp	r3, r2
    d318:	d314      	bcc.n	d344 <timer_process_counted+0x5c>
		list_remove_head(&timer->tasks);
    d31a:	4638      	mov	r0, r7
    d31c:	47c0      	blx	r8
		if (TIMER_TASK_REPEAT == tmp->mode) {
    d31e:	7c2b      	ldrb	r3, [r5, #16]
    d320:	2b01      	cmp	r3, #1
    d322:	d104      	bne.n	d32e <timer_process_counted+0x46>
			tmp->time_label = time;
    d324:	606e      	str	r6, [r5, #4]
			timer_add_timer_task(&timer->tasks, tmp, time);
    d326:	4632      	mov	r2, r6
    d328:	4629      	mov	r1, r5
    d32a:	4638      	mov	r0, r7
    d32c:	47c8      	blx	r9
		}
		it = (struct timer_task *)list_get_head(&timer->tasks);
    d32e:	f8d4 a014 	ldr.w	sl, [r4, #20]

		tmp->cb(tmp);
    d332:	68eb      	ldr	r3, [r5, #12]
    d334:	4628      	mov	r0, r5
    d336:	4798      	blx	r3
		it = (struct timer_task *)list_get_head(&timer->tasks);
    d338:	4655      	mov	r5, sl
    d33a:	e7e8      	b.n	d30e <timer_process_counted+0x26>
		timer->flags |= TIMER_FLAG_INTERRUPT_TRIGERRED;
    d33c:	7e23      	ldrb	r3, [r4, #24]
    d33e:	f043 0302 	orr.w	r3, r3, #2
    d342:	7623      	strb	r3, [r4, #24]
	}
}
    d344:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    d348:	000101e5 	.word	0x000101e5
    d34c:	0000d29d 	.word	0x0000d29d

0000d350 <timer_init>:
{
    d350:	b570      	push	{r4, r5, r6, lr}
    d352:	460d      	mov	r5, r1
    d354:	4616      	mov	r6, r2
	ASSERT(descr && hw && func);
    d356:	4604      	mov	r4, r0
    d358:	b118      	cbz	r0, d362 <timer_init+0x12>
    d35a:	b189      	cbz	r1, d380 <timer_init+0x30>
    d35c:	1e10      	subs	r0, r2, #0
    d35e:	bf18      	it	ne
    d360:	2001      	movne	r0, #1
    d362:	223b      	movs	r2, #59	; 0x3b
    d364:	4907      	ldr	r1, [pc, #28]	; (d384 <timer_init+0x34>)
    d366:	4b08      	ldr	r3, [pc, #32]	; (d388 <timer_init+0x38>)
    d368:	4798      	blx	r3
	descr->func = func;
    d36a:	4620      	mov	r0, r4
	descr->func->init(&descr->device, hw);
    d36c:	6833      	ldr	r3, [r6, #0]
	descr->func = func;
    d36e:	f840 6b04 	str.w	r6, [r0], #4
	descr->func->init(&descr->device, hw);
    d372:	4629      	mov	r1, r5
    d374:	4798      	blx	r3
	descr->device.timer_cb.period_expired = timer_process_counted;
    d376:	4b05      	ldr	r3, [pc, #20]	; (d38c <timer_init+0x3c>)
    d378:	6063      	str	r3, [r4, #4]
	descr->time                           = 0;
    d37a:	2000      	movs	r0, #0
    d37c:	6160      	str	r0, [r4, #20]
}
    d37e:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && hw && func);
    d380:	4608      	mov	r0, r1
    d382:	e7ee      	b.n	d362 <timer_init+0x12>
    d384:	00016f0d 	.word	0x00016f0d
    d388:	0000e9b9 	.word	0x0000e9b9
    d38c:	0000d2e9 	.word	0x0000d2e9

0000d390 <timer_start>:
{
    d390:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr && descr->func);
    d392:	4605      	mov	r5, r0
    d394:	b118      	cbz	r0, d39e <timer_start+0xe>
    d396:	6800      	ldr	r0, [r0, #0]
    d398:	3800      	subs	r0, #0
    d39a:	bf18      	it	ne
    d39c:	2001      	movne	r0, #1
	if (descr->func->is_timer_started(&descr->device)) {
    d39e:	462e      	mov	r6, r5
	ASSERT(descr && descr->func);
    d3a0:	4909      	ldr	r1, [pc, #36]	; (d3c8 <timer_start+0x38>)
    d3a2:	4b0a      	ldr	r3, [pc, #40]	; (d3cc <timer_start+0x3c>)
    d3a4:	2254      	movs	r2, #84	; 0x54
    d3a6:	4798      	blx	r3
	if (descr->func->is_timer_started(&descr->device)) {
    d3a8:	f856 3b04 	ldr.w	r3, [r6], #4
    d3ac:	699b      	ldr	r3, [r3, #24]
    d3ae:	4630      	mov	r0, r6
    d3b0:	4798      	blx	r3
    d3b2:	4604      	mov	r4, r0
    d3b4:	b928      	cbnz	r0, d3c2 <timer_start+0x32>
	descr->func->start_timer(&descr->device);
    d3b6:	682b      	ldr	r3, [r5, #0]
    d3b8:	4630      	mov	r0, r6
    d3ba:	689b      	ldr	r3, [r3, #8]
    d3bc:	4798      	blx	r3
	return ERR_NONE;
    d3be:	4620      	mov	r0, r4
}
    d3c0:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_DENIED;
    d3c2:	f06f 0010 	mvn.w	r0, #16
    d3c6:	e7fb      	b.n	d3c0 <timer_start+0x30>
    d3c8:	00016f0d 	.word	0x00016f0d
    d3cc:	0000e9b9 	.word	0x0000e9b9

0000d3d0 <timer_add_task>:
{
    d3d0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    d3d4:	460d      	mov	r5, r1
	ASSERT(descr && task && descr->func);
    d3d6:	4604      	mov	r4, r0
    d3d8:	b120      	cbz	r0, d3e4 <timer_add_task+0x14>
    d3da:	b309      	cbz	r1, d420 <timer_add_task+0x50>
    d3dc:	6800      	ldr	r0, [r0, #0]
    d3de:	3800      	subs	r0, #0
    d3e0:	bf18      	it	ne
    d3e2:	2001      	movne	r0, #1
    d3e4:	4920      	ldr	r1, [pc, #128]	; (d468 <timer_add_task+0x98>)
    d3e6:	f8df 8094 	ldr.w	r8, [pc, #148]	; d47c <timer_add_task+0xac>
    d3ea:	227b      	movs	r2, #123	; 0x7b
    d3ec:	47c0      	blx	r8
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    d3ee:	7f23      	ldrb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    d3f0:	f104 0718 	add.w	r7, r4, #24
	descr->flags |= TIMER_FLAG_QUEUE_IS_TAKEN;
    d3f4:	f043 0301 	orr.w	r3, r3, #1
    d3f8:	7723      	strb	r3, [r4, #28]
	if (is_list_element(&descr->tasks, task)) {
    d3fa:	4629      	mov	r1, r5
    d3fc:	4b1b      	ldr	r3, [pc, #108]	; (d46c <timer_add_task+0x9c>)
    d3fe:	4638      	mov	r0, r7
    d400:	4798      	blx	r3
    d402:	4606      	mov	r6, r0
    d404:	b170      	cbz	r0, d424 <timer_add_task+0x54>
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    d406:	7f23      	ldrb	r3, [r4, #28]
		ASSERT(false);
    d408:	4917      	ldr	r1, [pc, #92]	; (d468 <timer_add_task+0x98>)
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    d40a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
		ASSERT(false);
    d40e:	2000      	movs	r0, #0
		descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    d410:	7723      	strb	r3, [r4, #28]
		ASSERT(false);
    d412:	2280      	movs	r2, #128	; 0x80
    d414:	47c0      	blx	r8
		return ERR_ALREADY_INITIALIZED;
    d416:	f06f 0011 	mvn.w	r0, #17
}
    d41a:	b002      	add	sp, #8
    d41c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(descr && task && descr->func);
    d420:	4608      	mov	r0, r1
    d422:	e7df      	b.n	d3e4 <timer_add_task+0x14>
	task->time_label = descr->time;
    d424:	6962      	ldr	r2, [r4, #20]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    d426:	4b12      	ldr	r3, [pc, #72]	; (d470 <timer_add_task+0xa0>)
	task->time_label = descr->time;
    d428:	606a      	str	r2, [r5, #4]
	timer_add_timer_task(&descr->tasks, task, descr->time);
    d42a:	4629      	mov	r1, r5
    d42c:	4638      	mov	r0, r7
    d42e:	4798      	blx	r3
	descr->flags &= ~TIMER_FLAG_QUEUE_IS_TAKEN;
    d430:	7f23      	ldrb	r3, [r4, #28]
    d432:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
    d436:	7723      	strb	r3, [r4, #28]
	if (descr->flags & TIMER_FLAG_INTERRUPT_TRIGERRED) {
    d438:	7f23      	ldrb	r3, [r4, #28]
    d43a:	f013 0302 	ands.w	r3, r3, #2
    d43e:	d010      	beq.n	d462 <timer_add_task+0x92>
		CRITICAL_SECTION_ENTER()
    d440:	4b0c      	ldr	r3, [pc, #48]	; (d474 <timer_add_task+0xa4>)
    d442:	a801      	add	r0, sp, #4
    d444:	4798      	blx	r3
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    d446:	7f23      	ldrb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    d448:	4620      	mov	r0, r4
		descr->flags &= ~TIMER_FLAG_INTERRUPT_TRIGERRED;
    d44a:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
    d44e:	7723      	strb	r3, [r4, #28]
		descr->func->set_timer_irq(&descr->device);
    d450:	f850 3b04 	ldr.w	r3, [r0], #4
    d454:	69db      	ldr	r3, [r3, #28]
    d456:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
    d458:	a801      	add	r0, sp, #4
    d45a:	4b07      	ldr	r3, [pc, #28]	; (d478 <timer_add_task+0xa8>)
    d45c:	4798      	blx	r3
	return ERR_NONE;
    d45e:	4630      	mov	r0, r6
    d460:	e7db      	b.n	d41a <timer_add_task+0x4a>
    d462:	4618      	mov	r0, r3
    d464:	e7d9      	b.n	d41a <timer_add_task+0x4a>
    d466:	bf00      	nop
    d468:	00016f0d 	.word	0x00016f0d
    d46c:	00010161 	.word	0x00010161
    d470:	0000d29d 	.word	0x0000d29d
    d474:	00012485 	.word	0x00012485
    d478:	00012493 	.word	0x00012493
    d47c:	0000e9b9 	.word	0x0000e9b9

0000d480 <_dummy_func_no_return>:
static bool _dummy_func_no_return(uint32_t unused0, uint32_t unused1)
{
	(void)unused0;
	(void)unused1;
	return false;
}
    d480:	2000      	movs	r0, #0
    d482:	4770      	bx	lr

0000d484 <_usb_d_dev_wait_dfll_rdy>:
}

static inline bool hri_oscctrl_get_DFLLCTRLB_MODE_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    d484:	4b07      	ldr	r3, [pc, #28]	; (d4a4 <_usb_d_dev_wait_dfll_rdy+0x20>)
    d486:	f893 2020 	ldrb.w	r2, [r3, #32]
/**
 * \brief Wait DFLL clock to be ready
 */
static inline void _usb_d_dev_wait_dfll_rdy(void)
{
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(OSCCTRL)) {
    d48a:	07d1      	lsls	r1, r2, #31
    d48c:	d506      	bpl.n	d49c <_usb_d_dev_wait_dfll_rdy+0x18>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    d48e:	691a      	ldr	r2, [r3, #16]
	tmp &= mask;
    d490:	f402 6210 	and.w	r2, r2, #2304	; 0x900
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
    d494:	f5b2 6f10 	cmp.w	r2, #2304	; 0x900
    d498:	d1f9      	bne.n	d48e <_usb_d_dev_wait_dfll_rdy+0xa>
    d49a:	4770      	bx	lr
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    d49c:	691a      	ldr	r2, [r3, #16]
		       != (OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC))
			;
	} else {
		while (hri_oscctrl_get_STATUS_reg(OSCCTRL, OSCCTRL_STATUS_DFLLRDY) != OSCCTRL_STATUS_DFLLRDY)
    d49e:	05d2      	lsls	r2, r2, #23
    d4a0:	d5fc      	bpl.n	d49c <_usb_d_dev_wait_dfll_rdy+0x18>
			;
	}
}
    d4a2:	4770      	bx	lr
    d4a4:	40001000 	.word	0x40001000

0000d4a8 <_usb_d_dev_ept>:
 * \param[in] epn Endpoint number.
 * \param[in] dir Endpoint direction.
 */
static inline struct _usb_d_dev_ep *_usb_d_dev_ept(uint8_t epn, bool dir)
{
	uint8_t ep_index = (epn == 0) ? 0 : (dir ? (epn + CONF_USB_D_MAX_EP_N) : epn);
    d4a8:	b110      	cbz	r0, d4b0 <_usb_d_dev_ept+0x8>
    d4aa:	b109      	cbz	r1, d4b0 <_usb_d_dev_ept+0x8>
    d4ac:	3005      	adds	r0, #5
    d4ae:	b2c0      	uxtb	r0, r0
	return &dev_inst.ep[ep_index];
    d4b0:	2314      	movs	r3, #20
    d4b2:	fb00 3003 	mla	r0, r0, r3, r3
}
    d4b6:	4b01      	ldr	r3, [pc, #4]	; (d4bc <_usb_d_dev_ept+0x14>)
    d4b8:	4418      	add	r0, r3
    d4ba:	4770      	bx	lr
    d4bc:	200085a8 	.word	0x200085a8

0000d4c0 <_usb_d_dev_handle_setup>:
/**
 * \brief Handles setup received interrupt
 * \param[in] ept Pointer to endpoint information.
 */
static void _usb_d_dev_handle_setup(struct _usb_d_dev_ep *ept)
{
    d4c0:	b430      	push	{r4, r5}
	uint8_t epn     = USB_EP_GET_N(ept->ep);
	bool    is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d4c2:	7cc1      	ldrb	r1, [r0, #19]
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    d4c4:	7c85      	ldrb	r5, [r0, #18]

	if (!is_ctrl) {
    d4c6:	f001 0307 	and.w	r3, r1, #7
	uint8_t epn     = USB_EP_GET_N(ept->ep);
    d4ca:	f005 020f 	and.w	r2, r5, #15
	if (!is_ctrl) {
    d4ce:	2b01      	cmp	r3, #1
    d4d0:	ea4f 1442 	mov.w	r4, r2, lsl #5
    d4d4:	f102 0308 	add.w	r3, r2, #8
    d4d8:	d00a      	beq.n	d4f0 <_usb_d_dev_handle_setup+0x30>
}

static inline void hri_usbendpoint_clear_EPINTFLAG_reg(const void *const hw, uint8_t submodule_index,
                                                       hri_usbendpoint_epintflag_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d4da:	015a      	lsls	r2, r3, #5
    d4dc:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	}
}

static inline void hri_usbendpoint_clear_EPINTEN_RXSTP_bit(const void *const hw, uint8_t submodule_index)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    d4e0:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d4e4:	2110      	movs	r1, #16
    d4e6:	71d1      	strb	r1, [r2, #7]
	_usbd_ep_clear_bank_status(epn, 1);
	_usbd_ep_int_ack(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	_usbd_ep_int_dis(epn, USB_D_BANK0_INT_FLAGS | USB_D_BANK1_INT_FLAGS);
	/* Invoke callback. */
	dev_inst.ep_callbacks.setup(ept->ep);
}
    d4e8:	bc30      	pop	{r4, r5}
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = USB_DEVICE_EPINTENSET_RXSTP;
    d4ea:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
    d4ee:	4770      	bx	lr
	if (_usb_d_dev_ep_is_busy(ept)) {
    d4f0:	f011 0f40 	tst.w	r1, #64	; 0x40
    d4f4:	d00b      	beq.n	d50e <_usb_d_dev_handle_setup+0x4e>
		ept->flags.bits.is_busy = 0;
    d4f6:	0152      	lsls	r2, r2, #5
    d4f8:	f36f 1186 	bfc	r1, #6, #1
    d4fc:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d500:	74c1      	strb	r1, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d502:	2180      	movs	r1, #128	; 0x80
    d504:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d508:	2140      	movs	r1, #64	; 0x40
    d50a:	f882 1105 	strb.w	r1, [r2, #261]	; 0x105
	ept->flags.bits.is_stalled = 0;
    d50e:	7cc2      	ldrb	r2, [r0, #19]
    d510:	f36f 02c3 	bfc	r2, #3, #1
    d514:	74c2      	strb	r2, [r0, #19]
	bank->STATUS_BK.reg     = 0;
    d516:	4a0a      	ldr	r2, [pc, #40]	; (d540 <_usb_d_dev_handle_setup+0x80>)
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d518:	015b      	lsls	r3, r3, #5
    d51a:	1911      	adds	r1, r2, r4
    d51c:	2000      	movs	r0, #0
    d51e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d522:	f881 023a 	strb.w	r0, [r1, #570]	; 0x23a
    d526:	f881 024a 	strb.w	r0, [r1, #586]	; 0x24a
    d52a:	216f      	movs	r1, #111	; 0x6f
    d52c:	71d9      	strb	r1, [r3, #7]
}

static inline void hri_usbendpoint_clear_EPINTEN_reg(const void *const hw, uint8_t submodule_index,
                                                     hri_usbendpoint_epintenset_reg_t mask)
{
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d52e:	f104 4382 	add.w	r3, r4, #1090519040	; 0x41000000
	dev_inst.ep_callbacks.setup(ept->ep);
    d532:	4628      	mov	r0, r5
    d534:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
}
    d538:	bc30      	pop	{r4, r5}
	dev_inst.ep_callbacks.setup(ept->ep);
    d53a:	6893      	ldr	r3, [r2, #8]
    d53c:	4718      	bx	r3
    d53e:	bf00      	nop
    d540:	200085a8 	.word	0x200085a8

0000d544 <_usb_d_dev_handle_stall>:
 * \brief Handles stall sent interrupt
 * \param[in] ept Pointer to endpoint information.
 * \param[in] bank_n Bank number.
 */
static void _usb_d_dev_handle_stall(struct _usb_d_dev_ep *ept, const uint8_t bank_n)
{
    d544:	b410      	push	{r4}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d546:	7c84      	ldrb	r4, [r0, #18]
	/* Clear interrupt enable. Leave status there for status check. */
	_usbd_ep_int_stall_en(epn, bank_n, false);
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    d548:	6882      	ldr	r2, [r0, #8]
		_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << bank_n);
    d54a:	2320      	movs	r3, #32
    d54c:	fa03 f101 	lsl.w	r1, r3, r1
    d550:	f004 030f 	and.w	r3, r4, #15
    d554:	015b      	lsls	r3, r3, #5
    d556:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    d55a:	b2c9      	uxtb	r1, r1
    d55c:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    d560:	4b03      	ldr	r3, [pc, #12]	; (d570 <_usb_d_dev_handle_stall+0x2c>)
    d562:	4620      	mov	r0, r4
    d564:	691b      	ldr	r3, [r3, #16]
}
    d566:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, USB_TRANS_STALL, ept->trans_count);
    d56a:	2101      	movs	r1, #1
    d56c:	4718      	bx	r3
    d56e:	bf00      	nop
    d570:	200085a8 	.word	0x200085a8

0000d574 <_usb_d_dev_trans_done>:
 *  \brief Finish the transaction and invoke callback
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_done(struct _usb_d_dev_ep *ept, const int32_t code)
{
    d574:	b410      	push	{r4}
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    d576:	7c84      	ldrb	r4, [r0, #18]
    d578:	2cff      	cmp	r4, #255	; 0xff
    d57a:	d00c      	beq.n	d596 <_usb_d_dev_trans_done+0x22>
    d57c:	7cc3      	ldrb	r3, [r0, #19]
    d57e:	065a      	lsls	r2, r3, #25
    d580:	d509      	bpl.n	d596 <_usb_d_dev_trans_done+0x22>
		return;
	}
	ept->flags.bits.is_busy = 0;
    d582:	f36f 1386 	bfc	r3, #6, #1
    d586:	74c3      	strb	r3, [r0, #19]
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    d588:	4b04      	ldr	r3, [pc, #16]	; (d59c <_usb_d_dev_trans_done+0x28>)
    d58a:	6882      	ldr	r2, [r0, #8]
    d58c:	691b      	ldr	r3, [r3, #16]
    d58e:	4620      	mov	r0, r4
}
    d590:	f85d 4b04 	ldr.w	r4, [sp], #4
	dev_inst.ep_callbacks.done(ept->ep, code, ept->trans_count);
    d594:	4718      	bx	r3
}
    d596:	f85d 4b04 	ldr.w	r4, [sp], #4
    d59a:	4770      	bx	lr
    d59c:	200085a8 	.word	0x200085a8

0000d5a0 <_usb_d_dev_trans_stop>:
 * \param[in, out] ept Pointer to endpoint information.
 * \param[in] dir Endpoint direction.
 * \param[in] code Information code passed.
 */
static void _usb_d_dev_trans_stop(struct _usb_d_dev_ep *ept, bool dir, const int32_t code)
{
    d5a0:	b477      	push	{r0, r1, r2, r4, r5, r6}
	uint8_t epn = USB_EP_GET_N(ept->ep);
    d5a2:	7c83      	ldrb	r3, [r0, #18]
{
    d5a4:	460d      	mov	r5, r1
	;
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    d5a6:	2bff      	cmp	r3, #255	; 0xff
{
    d5a8:	4611      	mov	r1, r2
	const uint8_t intflags[2] = {USB_D_BANK0_INT_FLAGS, USB_D_BANK1_INT_FLAGS};
    d5aa:	f644 2225 	movw	r2, #18981	; 0x4a25
    d5ae:	f8ad 2004 	strh.w	r2, [sp, #4]
	if (!(_usb_d_dev_ep_is_used(ept) && _usb_d_dev_ep_is_busy(ept))) {
    d5b2:	d020      	beq.n	d5f6 <_usb_d_dev_trans_stop+0x56>
    d5b4:	7cc2      	ldrb	r2, [r0, #19]
    d5b6:	0652      	lsls	r2, r2, #25
    d5b8:	d51d      	bpl.n	d5f6 <_usb_d_dev_trans_stop+0x56>
		return;
	}
	/* Stop transfer */
	if (dir) {
    d5ba:	f003 030f 	and.w	r3, r3, #15
    d5be:	f103 0408 	add.w	r4, r3, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d5c2:	0162      	lsls	r2, r4, #5
    d5c4:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d5c8:	b195      	cbz	r5, d5f0 <_usb_d_dev_trans_stop+0x50>
    d5ca:	2680      	movs	r6, #128	; 0x80
    d5cc:	7116      	strb	r6, [r2, #4]
		_usbd_ep_set_in_rdy(epn, 1, false);
	} else {
		/* NAK OUT */
		_usbd_ep_set_out_rdy(epn, 0, false);
	}
	_usbd_ep_int_ack(epn, intflags[dir]);
    d5ce:	aa02      	add	r2, sp, #8
    d5d0:	4415      	add	r5, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d5d2:	0164      	lsls	r4, r4, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d5d4:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d5d6:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d5da:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d5de:	f815 2c04 	ldrb.w	r2, [r5, #-4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d5e2:	71e2      	strb	r2, [r4, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d5e4:	f883 2108 	strb.w	r2, [r3, #264]	; 0x108
	_usbd_ep_int_dis(epn, intflags[dir]);
	_usb_d_dev_trans_done(ept, code);
    d5e8:	4b04      	ldr	r3, [pc, #16]	; (d5fc <_usb_d_dev_trans_stop+0x5c>)
}
    d5ea:	b003      	add	sp, #12
    d5ec:	bc70      	pop	{r4, r5, r6}
	_usb_d_dev_trans_done(ept, code);
    d5ee:	4718      	bx	r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d5f0:	2640      	movs	r6, #64	; 0x40
    d5f2:	7156      	strb	r6, [r2, #5]
}
    d5f4:	e7eb      	b.n	d5ce <_usb_d_dev_trans_stop+0x2e>
}
    d5f6:	b003      	add	sp, #12
    d5f8:	bc70      	pop	{r4, r5, r6}
    d5fa:	4770      	bx	lr
    d5fc:	0000d575 	.word	0x0000d575

0000d600 <_usb_d_dev_handle_trfail>:
{
    d600:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint8_t            epn     = USB_EP_GET_N(ept->ep);
    d602:	7c83      	ldrb	r3, [r0, #18]
    d604:	f003 0c0f 	and.w	ip, r3, #15
	const uint8_t      fail[2] = {USB_DEVICE_EPINTFLAG_TRFAIL0, USB_DEVICE_EPINTFLAG_TRFAIL1};
    d608:	f640 0204 	movw	r2, #2052	; 0x804
    d60c:	4663      	mov	r3, ip
    d60e:	f8ad 2004 	strh.w	r2, [sp, #4]
	UsbDeviceDescBank *bank    = prvt_inst.desc_table[epn].DeviceDescBank;
    d612:	015a      	lsls	r2, r3, #5
	uint8_t            eptype
    d614:	f10c 0308 	add.w	r3, ip, #8
    d618:	460c      	mov	r4, r1

static inline hri_usbendpoint_epcfg_reg_t hri_usbendpoint_read_EPCFG_EPTYPE1_bf(const void *const hw,
                                                                                uint8_t           submodule_index)
{
	uint8_t tmp;
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    d61a:	0159      	lsls	r1, r3, #5
    d61c:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
    d620:	780f      	ldrb	r7, [r1, #0]
    d622:	b334      	cbz	r4, d672 <_usb_d_dev_handle_trfail+0x72>
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE1_Msk) >> USB_DEVICE_EPCFG_EPTYPE1_Pos;
    d624:	f3c7 1702 	ubfx	r7, r7, #4, #3
	st.reg = bank[bank_n].STATUS_BK.reg;
    d628:	4e2c      	ldr	r6, [pc, #176]	; (d6dc <_usb_d_dev_handle_trfail+0xdc>)
    d62a:	eb02 1204 	add.w	r2, r2, r4, lsl #4
    d62e:	4416      	add	r6, r2
    d630:	aa02      	add	r2, sp, #8
    d632:	4422      	add	r2, r4
    d634:	7ab5      	ldrb	r5, [r6, #10]
    d636:	f812 ec04 	ldrb.w	lr, [r2, #-4]
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    d63a:	2f02      	cmp	r7, #2
	st.reg = bank[bank_n].STATUS_BK.reg;
    d63c:	b2ed      	uxtb	r5, r5
	if ((eptype == USB_D_EPTYPE_ISOCH) && st.bit.CRCERR) {
    d63e:	ea4f 124c 	mov.w	r2, ip, lsl #5
    d642:	d119      	bne.n	d678 <_usb_d_dev_handle_trfail+0x78>
    d644:	07e9      	lsls	r1, r5, #31
    d646:	d517      	bpl.n	d678 <_usb_d_dev_handle_trfail+0x78>
		bank[bank_n].STATUS_BK.bit.CRCERR = 0;
    d648:	7ab1      	ldrb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d64a:	015b      	lsls	r3, r3, #5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d64c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d650:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d654:	f36f 0100 	bfc	r1, #0, #1
    d658:	72b1      	strb	r1, [r6, #10]
    d65a:	f883 e007 	strb.w	lr, [r3, #7]
		_usb_d_dev_trans_stop(ept, bank_n, USB_TRANS_ERROR);
    d65e:	f004 0101 	and.w	r1, r4, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d662:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    d666:	2204      	movs	r2, #4
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    d668:	4b1d      	ldr	r3, [pc, #116]	; (d6e0 <_usb_d_dev_handle_trfail+0xe0>)
}
    d66a:	b003      	add	sp, #12
    d66c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    d670:	4718      	bx	r3
	tmp = (tmp & USB_DEVICE_EPCFG_EPTYPE0_Msk) >> USB_DEVICE_EPCFG_EPTYPE0_Pos;
    d672:	f007 0707 	and.w	r7, r7, #7
	return tmp;
    d676:	e7d7      	b.n	d628 <_usb_d_dev_handle_trfail+0x28>
	} else if (st.bit.ERRORFLOW) {
    d678:	f015 0502 	ands.w	r5, r5, #2
    d67c:	d01b      	beq.n	d6b6 <_usb_d_dev_handle_trfail+0xb6>
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    d67e:	7ab1      	ldrb	r1, [r6, #10]
	bool                      is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d680:	7cc5      	ldrb	r5, [r0, #19]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d682:	015b      	lsls	r3, r3, #5
    d684:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		bank[bank_n].STATUS_BK.bit.ERRORFLOW = 0;
    d688:	f36f 0141 	bfc	r1, #1, #1
    d68c:	72b1      	strb	r1, [r6, #10]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d68e:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d692:	f883 e007 	strb.w	lr, [r3, #7]
		if (is_ctrl && _usb_d_dev_ep_is_busy(ept)) {
    d696:	f005 0307 	and.w	r3, r5, #7
    d69a:	2b01      	cmp	r3, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d69c:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
    d6a0:	d119      	bne.n	d6d6 <_usb_d_dev_handle_trfail+0xd6>
    d6a2:	066b      	lsls	r3, r5, #25
    d6a4:	d517      	bpl.n	d6d6 <_usb_d_dev_handle_trfail+0xd6>
			if (bank_n != _usb_d_dev_ep_is_in(ept)) {
    d6a6:	7cc3      	ldrb	r3, [r0, #19]
    d6a8:	ebb4 1fd3 	cmp.w	r4, r3, lsr #7
    d6ac:	ea4f 11d3 	mov.w	r1, r3, lsr #7
    d6b0:	d011      	beq.n	d6d6 <_usb_d_dev_handle_trfail+0xd6>
				_usb_d_dev_trans_stop(ept, _usb_d_dev_ep_is_in(ept), USB_TRANS_DONE);
    d6b2:	2200      	movs	r2, #0
    d6b4:	e7d8      	b.n	d668 <_usb_d_dev_handle_trfail+0x68>
	bank->STATUS_BK.reg     = 0;
    d6b6:	490b      	ldr	r1, [pc, #44]	; (d6e4 <_usb_d_dev_handle_trfail+0xe4>)
    d6b8:	eb04 044c 	add.w	r4, r4, ip, lsl #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d6bc:	015b      	lsls	r3, r3, #5
    d6be:	eb01 1404 	add.w	r4, r1, r4, lsl #4
    d6c2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d6c6:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    d6ca:	f884 523a 	strb.w	r5, [r4, #570]	; 0x23a
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d6ce:	f883 e007 	strb.w	lr, [r3, #7]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d6d2:	f882 e108 	strb.w	lr, [r2, #264]	; 0x108
}
    d6d6:	b003      	add	sp, #12
    d6d8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    d6da:	bf00      	nop
    d6dc:	200087d8 	.word	0x200087d8
    d6e0:	0000d5a1 	.word	0x0000d5a1
    d6e4:	200085a8 	.word	0x200085a8

0000d6e8 <_usb_d_dev_reset_epts>:
{
    d6e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    d6ec:	4c0a      	ldr	r4, [pc, #40]	; (d718 <_usb_d_dev_reset_epts+0x30>)
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    d6ee:	4f0b      	ldr	r7, [pc, #44]	; (d71c <_usb_d_dev_reset_epts+0x34>)
{
    d6f0:	2501      	movs	r5, #1
		dev_inst.ep[i].ep       = 0xFF;
    d6f2:	26ff      	movs	r6, #255	; 0xff
		_usb_d_dev_trans_done(&dev_inst.ep[i], USB_TRANS_RESET);
    d6f4:	2103      	movs	r1, #3
    d6f6:	4620      	mov	r0, r4
    d6f8:	3501      	adds	r5, #1
    d6fa:	47b8      	blx	r7
		dev_inst.ep[i].flags.u8 = 0;
    d6fc:	2100      	movs	r1, #0
	for (i = 0; i < USB_D_N_EP; i++) {
    d6fe:	2d1c      	cmp	r5, #28
		dev_inst.ep[i].ep       = 0xFF;
    d700:	74a6      	strb	r6, [r4, #18]
		dev_inst.ep[i].flags.u8 = 0;
    d702:	74e1      	strb	r1, [r4, #19]
	for (i = 0; i < USB_D_N_EP; i++) {
    d704:	f104 0414 	add.w	r4, r4, #20
    d708:	d1f4      	bne.n	d6f4 <_usb_d_dev_reset_epts+0xc>
}
    d70a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memset(prvt_inst.desc_table, 0, sizeof(UsbDeviceDescriptor) * (CONF_USB_D_MAX_EP_N + 1));
    d70e:	4804      	ldr	r0, [pc, #16]	; (d720 <_usb_d_dev_reset_epts+0x38>)
    d710:	4b04      	ldr	r3, [pc, #16]	; (d724 <_usb_d_dev_reset_epts+0x3c>)
    d712:	22c0      	movs	r2, #192	; 0xc0
    d714:	4718      	bx	r3
    d716:	bf00      	nop
    d718:	200085bc 	.word	0x200085bc
    d71c:	0000d575 	.word	0x0000d575
    d720:	200087d8 	.word	0x200087d8
    d724:	00014d51 	.word	0x00014d51

0000d728 <_usb_d_dev_in_next>:
{
    d728:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    d72c:	4604      	mov	r4, r0
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    d72e:	7c80      	ldrb	r0, [r0, #18]
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d730:	4688      	mov	r8, r1
	uint8_t            epn         = USB_EP_GET_N(ept->ep);
    d732:	f000 070f 	and.w	r7, r0, #15
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d736:	2900      	cmp	r1, #0
    d738:	d05b      	beq.n	d7f2 <_usb_d_dev_in_next+0xca>
	UsbDeviceDescBank *bank        = &prvt_inst.desc_table[epn].DeviceDescBank[0];
    d73a:	4b4d      	ldr	r3, [pc, #308]	; (d870 <_usb_d_dev_in_next+0x148>)
    d73c:	eb03 1347 	add.w	r3, r3, r7, lsl #5
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d740:	695e      	ldr	r6, [r3, #20]
    d742:	f3c6 060d 	ubfx	r6, r6, #0, #14
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    d746:	8a22      	ldrh	r2, [r4, #16]
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    d748:	f894 e013 	ldrb.w	lr, [r4, #19]
	uint16_t           last_pkt = trans_count & ((ept->size == 1023) ? ept->size : (ept->size - 1));
    d74c:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d750:	429a      	cmp	r2, r3
    d752:	bf1a      	itte	ne
    d754:	f102 3cff 	addne.w	ip, r2, #4294967295	; 0xffffffff
    d758:	fa0f fc8c 	sxthne.w	ip, ip
    d75c:	4694      	moveq	ip, r2
	bool               is_ctrl  = _usb_d_dev_ep_is_ctrl(ept);
    d75e:	f00e 0907 	and.w	r9, lr, #7
	if (isr) {
    d762:	f1b8 0f00 	cmp.w	r8, #0
    d766:	d005      	beq.n	d774 <_usb_d_dev_in_next+0x4c>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d768:	017b      	lsls	r3, r7, #5
    d76a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d76e:	2102      	movs	r1, #2
    d770:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	ept->trans_count += trans_count;
    d774:	68a1      	ldr	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    d776:	6863      	ldr	r3, [r4, #4]
	ept->trans_count += trans_count;
    d778:	4431      	add	r1, r6
	if (ept->trans_count < ept->trans_size) {
    d77a:	4299      	cmp	r1, r3
	ept->trans_count += trans_count;
    d77c:	60a1      	str	r1, [r4, #8]
	if (ept->trans_count < ept->trans_size) {
    d77e:	ea4f 1547 	mov.w	r5, r7, lsl #5
    d782:	d242      	bcs.n	d80a <_usb_d_dev_in_next+0xe2>
		trans_next = ept->trans_size - ept->trans_count;
    d784:	1a5b      	subs	r3, r3, r1
    d786:	b29e      	uxth	r6, r3
		if (ept->flags.bits.use_cache) {
    d788:	6823      	ldr	r3, [r4, #0]
    d78a:	f8df a0f0 	ldr.w	sl, [pc, #240]	; d87c <_usb_d_dev_in_next+0x154>
    d78e:	f01e 0f20 	tst.w	lr, #32
    d792:	4419      	add	r1, r3
    d794:	d02f      	beq.n	d7f6 <_usb_d_dev_in_next+0xce>
			if (trans_next > ept->size) {
    d796:	4296      	cmp	r6, r2
    d798:	bf28      	it	cs
    d79a:	4616      	movcs	r6, r2
			memcpy(ept->cache, &ept->trans_buf[ept->trans_count], trans_next);
    d79c:	4b35      	ldr	r3, [pc, #212]	; (d874 <_usb_d_dev_in_next+0x14c>)
    d79e:	68e0      	ldr	r0, [r4, #12]
    d7a0:	4632      	mov	r2, r6
    d7a2:	4798      	blx	r3
	bank->ADDR.reg          = addr;
    d7a4:	eb0a 0305 	add.w	r3, sl, r5
			_usbd_ep_set_buf(epn, 1, (uint32_t)ept->cache);
    d7a8:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    d7aa:	f8c3 2240 	str.w	r2, [r3, #576]	; 0x240
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    d7ae:	eb0a 0205 	add.w	r2, sl, r5
    d7b2:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    d7b6:	f366 030d 	bfi	r3, r6, #0, #14
    d7ba:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    d7be:	f8d2 3244 	ldr.w	r3, [r2, #580]	; 0x244
    d7c2:	f36f 339b 	bfc	r3, #14, #14
    d7c6:	f8c2 3244 	str.w	r3, [r2, #580]	; 0x244
	if (!isr) {
    d7ca:	f1b8 0f00 	cmp.w	r8, #0
    d7ce:	d108      	bne.n	d7e2 <_usb_d_dev_in_next+0xba>
			inten = USB_D_BANK1_INT_FLAGS;
    d7d0:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d7d4:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d7d8:	bf0c      	ite	eq
    d7da:	234e      	moveq	r3, #78	; 0x4e
    d7dc:	234a      	movne	r3, #74	; 0x4a
    d7de:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    d7e2:	017b      	lsls	r3, r7, #5
    d7e4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d7e8:	2280      	movs	r2, #128	; 0x80
    d7ea:	f883 2105 	strb.w	r2, [r3, #261]	; 0x105
}
    d7ee:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	uint16_t           trans_count = isr ? bank[1].PCKSIZE.bit.BYTE_COUNT : 0;
    d7f2:	460e      	mov	r6, r1
    d7f4:	e7a7      	b.n	d746 <_usb_d_dev_in_next+0x1e>
	bank->ADDR.reg          = addr;
    d7f6:	eb0a 0305 	add.w	r3, sl, r5
    d7fa:	f5b6 5f00 	cmp.w	r6, #8192	; 0x2000
    d7fe:	bf28      	it	cs
    d800:	f44f 5600 	movcs.w	r6, #8192	; 0x2000
    d804:	f8c3 1240 	str.w	r1, [r3, #576]	; 0x240
}
    d808:	e7d1      	b.n	d7ae <_usb_d_dev_in_next+0x86>
	} else if (ept->flags.bits.need_zlp) {
    d80a:	f01e 0f10 	tst.w	lr, #16
    d80e:	d00e      	beq.n	d82e <_usb_d_dev_in_next+0x106>
		ept->flags.bits.need_zlp = 0;
    d810:	7ce3      	ldrb	r3, [r4, #19]
    d812:	f36f 1304 	bfc	r3, #4, #1
    d816:	74e3      	strb	r3, [r4, #19]
	bank->PCKSIZE.bit.BYTE_COUNT = size;
    d818:	4b17      	ldr	r3, [pc, #92]	; (d878 <_usb_d_dev_in_next+0x150>)
    d81a:	442b      	add	r3, r5
    d81c:	685a      	ldr	r2, [r3, #4]
    d81e:	f36f 020d 	bfc	r2, #0, #14
    d822:	605a      	str	r2, [r3, #4]
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = count;
    d824:	685a      	ldr	r2, [r3, #4]
    d826:	f36f 329b 	bfc	r2, #14, #14
    d82a:	605a      	str	r2, [r3, #4]
		goto _in_tx_exec;
    d82c:	e7cd      	b.n	d7ca <_usb_d_dev_in_next+0xa2>
	if (is_ctrl) {
    d82e:	f1b9 0f01 	cmp.w	r9, #1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d832:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
	if (last_pkt == ept->size) {
    d836:	ea0c 0c06 	and.w	ip, ip, r6
    d83a:	bf0c      	ite	eq
    d83c:	234b      	moveq	r3, #75	; 0x4b
    d83e:	234a      	movne	r3, #74	; 0x4a
    d840:	4562      	cmp	r2, ip
    d842:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
    d846:	d10c      	bne.n	d862 <_usb_d_dev_in_next+0x13a>
		ept->flags.bits.is_busy = 0;
    d848:	7ce3      	ldrb	r3, [r4, #19]
    d84a:	f36f 1386 	bfc	r3, #6, #1
    d84e:	74e3      	strb	r3, [r4, #19]
		if (dev_inst.ep_callbacks.more(ept->ep, ept->trans_count)) {
    d850:	4b0a      	ldr	r3, [pc, #40]	; (d87c <_usb_d_dev_in_next+0x154>)
    d852:	68db      	ldr	r3, [r3, #12]
    d854:	4798      	blx	r3
    d856:	2800      	cmp	r0, #0
    d858:	d1c9      	bne.n	d7ee <_usb_d_dev_in_next+0xc6>
		ept->flags.bits.is_busy = 1;
    d85a:	7ce3      	ldrb	r3, [r4, #19]
    d85c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    d860:	74e3      	strb	r3, [r4, #19]
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d862:	4620      	mov	r0, r4
    d864:	4b06      	ldr	r3, [pc, #24]	; (d880 <_usb_d_dev_in_next+0x158>)
}
    d866:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d86a:	2100      	movs	r1, #0
    d86c:	4718      	bx	r3
    d86e:	bf00      	nop
    d870:	200087d8 	.word	0x200087d8
    d874:	00014d35 	.word	0x00014d35
    d878:	200087e8 	.word	0x200087e8
    d87c:	200085a8 	.word	0x200085a8
    d880:	0000d575 	.word	0x0000d575

0000d884 <_usb_d_dev_out_next>:
{
    d884:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t            epn        = USB_EP_GET_N(ept->ep);
    d888:	7c86      	ldrb	r6, [r0, #18]
    d88a:	f006 060f 	and.w	r6, r6, #15
{
    d88e:	4604      	mov	r4, r0
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d890:	460f      	mov	r7, r1
    d892:	0175      	lsls	r5, r6, #5
    d894:	2900      	cmp	r1, #0
    d896:	d060      	beq.n	d95a <_usb_d_dev_out_next+0xd6>
    d898:	4b5d      	ldr	r3, [pc, #372]	; (da10 <_usb_d_dev_out_next+0x18c>)
    d89a:	442b      	add	r3, r5
    d89c:	685a      	ldr	r2, [r3, #4]
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d89e:	685b      	ldr	r3, [r3, #4]
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d8a0:	f3c2 3a8d 	ubfx	sl, r2, #14, #14
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d8a4:	f3c3 090d 	ubfx	r9, r3, #0, #14
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d8a8:	f8b4 8010 	ldrh.w	r8, [r4, #16]
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d8ac:	7ce2      	ldrb	r2, [r4, #19]
	uint16_t           size_mask  = (ept->size == 1023) ? 1023 : (ept->size - 1);
    d8ae:	f240 33ff 	movw	r3, #1023	; 0x3ff
    d8b2:	4598      	cmp	r8, r3
    d8b4:	bf1c      	itt	ne
    d8b6:	f108 38ff 	addne.w	r8, r8, #4294967295	; 0xffffffff
    d8ba:	fa1f f888 	uxthne.w	r8, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d8be:	f002 0307 	and.w	r3, r2, #7
	uint16_t           last_pkt   = last_trans & size_mask;
    d8c2:	ea09 0b08 	and.w	fp, r9, r8
	bool               is_ctrl = _usb_d_dev_ep_is_ctrl(ept);
    d8c6:	9301      	str	r3, [sp, #4]
	if (isr) {
    d8c8:	b12f      	cbz	r7, d8d6 <_usb_d_dev_out_next+0x52>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    d8ca:	0173      	lsls	r3, r6, #5
    d8cc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    d8d0:	2101      	movs	r1, #1
    d8d2:	f883 1107 	strb.w	r1, [r3, #263]	; 0x107
	if (ept->flags.bits.use_cache && ept->trans_size) {
    d8d6:	0690      	lsls	r0, r2, #26
    d8d8:	d50c      	bpl.n	d8f4 <_usb_d_dev_out_next+0x70>
    d8da:	6862      	ldr	r2, [r4, #4]
    d8dc:	b152      	cbz	r2, d8f4 <_usb_d_dev_out_next+0x70>
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    d8de:	68a0      	ldr	r0, [r4, #8]
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    d8e0:	6823      	ldr	r3, [r4, #0]
    d8e2:	68e1      	ldr	r1, [r4, #12]
		uint16_t buf_remain = ept->trans_size - ept->trans_count;
    d8e4:	1a12      	subs	r2, r2, r0
		memcpy(&ept->trans_buf[ept->trans_count], ept->cache, (buf_remain > last_pkt) ? last_pkt : buf_remain);
    d8e6:	b292      	uxth	r2, r2
    d8e8:	455a      	cmp	r2, fp
    d8ea:	4418      	add	r0, r3
    d8ec:	bf28      	it	cs
    d8ee:	465a      	movcs	r2, fp
    d8f0:	4b48      	ldr	r3, [pc, #288]	; (da14 <_usb_d_dev_out_next+0x190>)
    d8f2:	4798      	blx	r3
	if (ept->trans_size == 0 && ept->flags.bits.need_zlp) {
    d8f4:	6863      	ldr	r3, [r4, #4]
    d8f6:	2b00      	cmp	r3, #0
    d8f8:	d132      	bne.n	d960 <_usb_d_dev_out_next+0xdc>
    d8fa:	7ce2      	ldrb	r2, [r4, #19]
    d8fc:	06d1      	lsls	r1, r2, #27
    d8fe:	d52f      	bpl.n	d960 <_usb_d_dev_out_next+0xdc>
	bank->ADDR.reg          = addr;
    d900:	4845      	ldr	r0, [pc, #276]	; (da18 <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d902:	68e1      	ldr	r1, [r4, #12]
		ept->flags.bits.need_zlp  = 0;
    d904:	f022 0230 	bic.w	r2, r2, #48	; 0x30
	bank->ADDR.reg          = addr;
    d908:	4428      	add	r0, r5
		ept->flags.bits.need_zlp  = 0;
    d90a:	f042 0220 	orr.w	r2, r2, #32
    d90e:	74e2      	strb	r2, [r4, #19]
	bank->ADDR.reg          = addr;
    d910:	f500 720c 	add.w	r2, r0, #560	; 0x230
    d914:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d918:	6851      	ldr	r1, [r2, #4]
    d91a:	8a20      	ldrh	r0, [r4, #16]
    d91c:	f360 319b 	bfi	r1, r0, #14, #14
    d920:	6051      	str	r1, [r2, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d922:	6851      	ldr	r1, [r2, #4]
    d924:	f363 010d 	bfi	r1, r3, #0, #14
    d928:	6051      	str	r1, [r2, #4]
	if (!isr) {
    d92a:	b96f      	cbnz	r7, d948 <_usb_d_dev_out_next+0xc4>
		if (is_ctrl) {
    d92c:	9b01      	ldr	r3, [sp, #4]
    d92e:	2b01      	cmp	r3, #1
	bank->STATUS_BK.reg     = 0;
    d930:	bf04      	itt	eq
    d932:	4b39      	ldreq	r3, [pc, #228]	; (da18 <_usb_d_dev_out_next+0x194>)
    d934:	195b      	addeq	r3, r3, r5
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    d936:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d93a:	bf0a      	itet	eq
    d93c:	f883 724a 	strbeq.w	r7, [r3, #586]	; 0x24a
			inten = USB_D_BANK0_INT_FLAGS;
    d940:	2325      	movne	r3, #37	; 0x25
			inten = USB_D_BANK0_INT_FLAGS | USB_DEVICE_EPINTFLAG_TRFAIL1;
    d942:	232d      	moveq	r3, #45	; 0x2d
    d944:	f885 3109 	strb.w	r3, [r5, #265]	; 0x109
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    d948:	0176      	lsls	r6, r6, #5
    d94a:	f106 4682 	add.w	r6, r6, #1090519040	; 0x41000000
    d94e:	2340      	movs	r3, #64	; 0x40
    d950:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
}
    d954:	b003      	add	sp, #12
    d956:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint16_t           trans_size = isr ? bank->PCKSIZE.bit.MULTI_PACKET_SIZE : 0;
    d95a:	468a      	mov	sl, r1
	uint16_t           last_trans = isr ? bank->PCKSIZE.bit.BYTE_COUNT : 0;
    d95c:	4689      	mov	r9, r1
    d95e:	e7a3      	b.n	d8a8 <_usb_d_dev_out_next+0x24>
	} else if (isr && last_pkt < ept->size) {
    d960:	68a1      	ldr	r1, [r4, #8]
    d962:	b1ef      	cbz	r7, d9a0 <_usb_d_dev_out_next+0x11c>
    d964:	8a22      	ldrh	r2, [r4, #16]
    d966:	455a      	cmp	r2, fp
    d968:	d91a      	bls.n	d9a0 <_usb_d_dev_out_next+0x11c>
		ept->flags.bits.need_zlp = 0;
    d96a:	7ce3      	ldrb	r3, [r4, #19]
		ept->trans_count += last_trans;
    d96c:	4449      	add	r1, r9
		ept->flags.bits.need_zlp = 0;
    d96e:	f36f 1304 	bfc	r3, #4, #1
    d972:	74e3      	strb	r3, [r4, #19]
		ept->trans_count += last_trans;
    d974:	60a1      	str	r1, [r4, #8]
	if (is_ctrl) {
    d976:	9b01      	ldr	r3, [sp, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    d978:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    d97c:	2b01      	cmp	r3, #1
    d97e:	bf0c      	ite	eq
    d980:	232d      	moveq	r3, #45	; 0x2d
    d982:	2325      	movne	r3, #37	; 0x25
    d984:	f885 3108 	strb.w	r3, [r5, #264]	; 0x108
	if (0 == epn) {
    d988:	b91e      	cbnz	r6, d992 <_usb_d_dev_out_next+0x10e>
	bank->ADDR.reg          = addr;
    d98a:	4b23      	ldr	r3, [pc, #140]	; (da18 <_usb_d_dev_out_next+0x194>)
		_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d98c:	68e2      	ldr	r2, [r4, #12]
	bank->ADDR.reg          = addr;
    d98e:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d992:	4b22      	ldr	r3, [pc, #136]	; (da1c <_usb_d_dev_out_next+0x198>)
    d994:	2100      	movs	r1, #0
    d996:	4620      	mov	r0, r4
}
    d998:	b003      	add	sp, #12
    d99a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_usb_d_dev_trans_done(ept, USB_TRANS_DONE);
    d99e:	4718      	bx	r3
		ept->trans_count += trans_size;
    d9a0:	4451      	add	r1, sl
		if (ept->trans_count < ept->trans_size) {
    d9a2:	428b      	cmp	r3, r1
		ept->trans_count += trans_size;
    d9a4:	60a1      	str	r1, [r4, #8]
		if (ept->trans_count < ept->trans_size) {
    d9a6:	d9e6      	bls.n	d976 <_usb_d_dev_out_next+0xf2>
			if (ept->flags.bits.use_cache) {
    d9a8:	7ce0      	ldrb	r0, [r4, #19]
    d9aa:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    d9ae:	4a1a      	ldr	r2, [pc, #104]	; (da18 <_usb_d_dev_out_next+0x194>)
			trans_next = ept->trans_size - ept->trans_count;
    d9b0:	1a5b      	subs	r3, r3, r1
			if (ept->flags.bits.use_cache) {
    d9b2:	f010 0f20 	tst.w	r0, #32
			trans_next = ept->trans_size - ept->trans_count;
    d9b6:	b29b      	uxth	r3, r3
			if (ept->flags.bits.use_cache) {
    d9b8:	d014      	beq.n	d9e4 <_usb_d_dev_out_next+0x160>
	bank->ADDR.reg          = addr;
    d9ba:	1951      	adds	r1, r2, r5
				_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    d9bc:	68e0      	ldr	r0, [r4, #12]
	bank->ADDR.reg          = addr;
    d9be:	f8c1 0230 	str.w	r0, [r1, #560]	; 0x230
    d9c2:	4563      	cmp	r3, ip
    d9c4:	bf28      	it	cs
    d9c6:	4663      	movcs	r3, ip
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    d9c8:	442a      	add	r2, r5
    d9ca:	f8d2 1234 	ldr.w	r1, [r2, #564]	; 0x234
    d9ce:	f363 319b 	bfi	r1, r3, #14, #14
    d9d2:	f8c2 1234 	str.w	r1, [r2, #564]	; 0x234
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    d9d6:	f8d2 3234 	ldr.w	r3, [r2, #564]	; 0x234
    d9da:	f36f 030d 	bfc	r3, #0, #14
    d9de:	f8c2 3234 	str.w	r3, [r2, #564]	; 0x234
			goto _out_rx_exec;
    d9e2:	e7a2      	b.n	d92a <_usb_d_dev_out_next+0xa6>
				if (trans_next > ept->size) {
    d9e4:	4563      	cmp	r3, ip
    d9e6:	d90a      	bls.n	d9fe <_usb_d_dev_out_next+0x17a>
					if (trans_next > USB_D_DEV_TRANS_MAX) {
    d9e8:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
    d9ec:	d80c      	bhi.n	da08 <_usb_d_dev_out_next+0x184>
						trans_next -= trans_next & size_mask;
    d9ee:	ea23 0308 	bic.w	r3, r3, r8
				_usbd_ep_set_buf(epn, 0, (uint32_t)&ept->trans_buf[ept->trans_count]);
    d9f2:	6820      	ldr	r0, [r4, #0]
    d9f4:	4401      	add	r1, r0
	bank->ADDR.reg          = addr;
    d9f6:	1950      	adds	r0, r2, r5
    d9f8:	f8c0 1230 	str.w	r1, [r0, #560]	; 0x230
}
    d9fc:	e7e4      	b.n	d9c8 <_usb_d_dev_out_next+0x144>
				} else if (trans_next < ept->size) {
    d9fe:	d2f8      	bcs.n	d9f2 <_usb_d_dev_out_next+0x16e>
					ept->flags.bits.use_cache = 1;
    da00:	f040 0020 	orr.w	r0, r0, #32
    da04:	74e0      	strb	r0, [r4, #19]
    da06:	e7f4      	b.n	d9f2 <_usb_d_dev_out_next+0x16e>
						trans_next = USB_D_DEV_TRANS_MAX;
    da08:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    da0c:	e7f1      	b.n	d9f2 <_usb_d_dev_out_next+0x16e>
    da0e:	bf00      	nop
    da10:	200087d8 	.word	0x200087d8
    da14:	00014d35 	.word	0x00014d35
    da18:	200085a8 	.word	0x200085a8
    da1c:	0000d575 	.word	0x0000d575

0000da20 <_usb_d_dev_handler>:
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    da20:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
{
    da24:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t epint = hw->DEVICE.EPINTSMRY.reg;
    da28:	8c1f      	ldrh	r7, [r3, #32]
    da2a:	4d69      	ldr	r5, [pc, #420]	; (dbd0 <_usb_d_dev_handler+0x1b0>)
    da2c:	b2bf      	uxth	r7, r7
	if (0 == epint) {
    da2e:	2f00      	cmp	r7, #0
    da30:	d163      	bne.n	dafa <_usb_d_dev_handler+0xda>
	return tmp;
}

static inline hri_usbdevice_intflag_reg_t hri_usbdevice_read_INTFLAG_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTFLAG.reg;
    da32:	8b99      	ldrh	r1, [r3, #28]
	return tmp;
}

static inline hri_usbdevice_intenset_reg_t hri_usbdevice_read_INTEN_reg(const void *const hw)
{
	return ((Usb *)hw)->DEVICE.INTENSET.reg;
    da34:	8b1a      	ldrh	r2, [r3, #24]
    da36:	b292      	uxth	r2, r2
	flags &= hri_usbdevice_read_INTEN_reg(USB);
    da38:	400a      	ands	r2, r1
	if (flags & USB_DEVICE_INTFLAG_SOF) {
    da3a:	f012 0004 	ands.w	r0, r2, #4
    da3e:	d005      	beq.n	da4c <_usb_d_dev_handler+0x2c>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    da40:	2204      	movs	r2, #4
    da42:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.sof();
    da44:	682b      	ldr	r3, [r5, #0]
}
    da46:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.sof();
    da4a:	4718      	bx	r3
	if (flags & USB_DEVICE_INTFLAG_LPMSUSP) {
    da4c:	f412 7100 	ands.w	r1, r2, #512	; 0x200
    da50:	d01f      	beq.n	da92 <_usb_d_dev_handler+0x72>
    da52:	f240 2201 	movw	r2, #513	; 0x201
    da56:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = ~data;
}

static inline void hri_usbdevice_clear_INTEN_reg(const void *const hw, hri_usbdevice_intenset_reg_t mask)
{
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    da58:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    da5a:	2270      	movs	r2, #112	; 0x70
    da5c:	831a      	strh	r2, [r3, #24]
    da5e:	4603      	mov	r3, r0
		if (bank->EXTREG.bit.SUBPID == 0x3) {
    da60:	eb05 1243 	add.w	r2, r5, r3, lsl #5
    da64:	f502 700e 	add.w	r0, r2, #568	; 0x238
    da68:	f8b2 2238 	ldrh.w	r2, [r2, #568]	; 0x238
    da6c:	f002 020f 	and.w	r2, r2, #15
    da70:	2a03      	cmp	r2, #3
    da72:	d109      	bne.n	da88 <_usb_d_dev_handler+0x68>
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    da74:	8801      	ldrh	r1, [r0, #0]
			bank->EXTREG.reg = 0;
    da76:	2300      	movs	r3, #0
			lpm_variable = bank->EXTREG.bit.VARIABLE;
    da78:	f3c1 110a 	ubfx	r1, r1, #4, #11
			bank->EXTREG.reg = 0;
    da7c:	8003      	strh	r3, [r0, #0]
	dev_inst.callbacks.event(USB_EV_LPM_SUSPEND, lpm_variable);
    da7e:	686b      	ldr	r3, [r5, #4]
    da80:	2003      	movs	r0, #3
}
    da82:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    da86:	4718      	bx	r3
	for (i = 0; i < CONF_USB_D_MAX_EP_N; i++) {
    da88:	3301      	adds	r3, #1
    da8a:	2b05      	cmp	r3, #5
    da8c:	d1e8      	bne.n	da60 <_usb_d_dev_handler+0x40>
	uint32_t lpm_variable = 0;
    da8e:	2100      	movs	r1, #0
    da90:	e7f5      	b.n	da7e <_usb_d_dev_handler+0x5e>
	} else if (flags & USB_DEVICE_INTFLAG_RAMACER) {
    da92:	f012 0080 	ands.w	r0, r2, #128	; 0x80
    da96:	d004      	beq.n	daa2 <_usb_d_dev_handler+0x82>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    da98:	2280      	movs	r2, #128	; 0x80
    da9a:	839a      	strh	r2, [r3, #28]
	dev_inst.callbacks.event(USB_EV_ERROR, 0);
    da9c:	2005      	movs	r0, #5
    da9e:	686b      	ldr	r3, [r5, #4]
    daa0:	e7ef      	b.n	da82 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_D_WAKEUP_INT_FLAGS) {
    daa2:	f012 0470 	ands.w	r4, r2, #112	; 0x70
    daa6:	d00b      	beq.n	dac0 <_usb_d_dev_handler+0xa0>
    daa8:	2270      	movs	r2, #112	; 0x70
    daaa:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    daac:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    daae:	f240 2201 	movw	r2, #513	; 0x201
    dab2:	831a      	strh	r2, [r3, #24]
		_usb_d_dev_wait_dfll_rdy();
    dab4:	4b47      	ldr	r3, [pc, #284]	; (dbd4 <_usb_d_dev_handler+0x1b4>)
    dab6:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_WAKEUP, 0);
    dab8:	686b      	ldr	r3, [r5, #4]
    daba:	4601      	mov	r1, r0
    dabc:	2002      	movs	r0, #2
    dabe:	e7e0      	b.n	da82 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_EORST) {
    dac0:	f012 0108 	ands.w	r1, r2, #8
    dac4:	d00e      	beq.n	dae4 <_usb_d_dev_handler+0xc4>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    dac6:	2208      	movs	r2, #8
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    dac8:	f883 4100 	strb.w	r4, [r3, #256]	; 0x100
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    dacc:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    dace:	2270      	movs	r2, #112	; 0x70
    dad0:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    dad2:	f240 2201 	movw	r2, #513	; 0x201
    dad6:	831a      	strh	r2, [r3, #24]
	_usb_d_dev_reset_epts();
    dad8:	4b3f      	ldr	r3, [pc, #252]	; (dbd8 <_usb_d_dev_handler+0x1b8>)
    dada:	4798      	blx	r3
	dev_inst.callbacks.event(USB_EV_RESET, 0);
    dadc:	686b      	ldr	r3, [r5, #4]
    dade:	4621      	mov	r1, r4
    dae0:	2001      	movs	r0, #1
    dae2:	e7ce      	b.n	da82 <_usb_d_dev_handler+0x62>
	} else if (flags & USB_DEVICE_INTFLAG_SUSPEND) {
    dae4:	07d0      	lsls	r0, r2, #31
    dae6:	d508      	bpl.n	dafa <_usb_d_dev_handler+0xda>
	((Usb *)hw)->DEVICE.INTFLAG.reg = mask;
    dae8:	f240 2201 	movw	r2, #513	; 0x201
    daec:	839a      	strh	r2, [r3, #28]
	((Usb *)hw)->DEVICE.INTENCLR.reg = mask;
    daee:	829a      	strh	r2, [r3, #20]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    daf0:	2270      	movs	r2, #112	; 0x70
    daf2:	831a      	strh	r2, [r3, #24]
	dev_inst.callbacks.event(USB_EV_SUSPEND, 0);
    daf4:	2004      	movs	r0, #4
    daf6:	686b      	ldr	r3, [r5, #4]
    daf8:	e7c3      	b.n	da82 <_usb_d_dev_handler+0x62>
    dafa:	4c35      	ldr	r4, [pc, #212]	; (dbd0 <_usb_d_dev_handler+0x1b0>)
			_usb_d_dev_handle_setup(ept);
    dafc:	f8df 90e4 	ldr.w	r9, [pc, #228]	; dbe4 <_usb_d_dev_handler+0x1c4>
			_usb_d_dev_handle_trfail(ept, 1);
    db00:	f8df 80e4 	ldr.w	r8, [pc, #228]	; dbe8 <_usb_d_dev_handler+0x1c8>
		_usb_d_dev_out_next(ept, true);
    db04:	f8df a0e4 	ldr.w	sl, [pc, #228]	; dbec <_usb_d_dev_handler+0x1cc>
	uint32_t lpm_variable = 0;
    db08:	2600      	movs	r6, #0
		if (ept->ep == 0xFF) {
    db0a:	f894 2026 	ldrb.w	r2, [r4, #38]	; 0x26
    db0e:	2aff      	cmp	r2, #255	; 0xff
    db10:	f104 0414 	add.w	r4, r4, #20
    db14:	d029      	beq.n	db6a <_usb_d_dev_handler+0x14a>
	if (!(epint & (1u << epn))) {
    db16:	f002 020f 	and.w	r2, r2, #15
    db1a:	2101      	movs	r1, #1
    db1c:	fa01 f302 	lsl.w	r3, r1, r2
    db20:	423b      	tst	r3, r7
    db22:	d022      	beq.n	db6a <_usb_d_dev_handler+0x14a>
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    db24:	0153      	lsls	r3, r2, #5
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    db26:	0152      	lsls	r2, r2, #5
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    db28:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    db2c:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
	flags = hw->DEVICE.DeviceEndpoint[epn].EPINTFLAG.reg;
    db30:	f893 0107 	ldrb.w	r0, [r3, #263]	; 0x107
	mask  = hw->DEVICE.DeviceEndpoint[epn].EPINTENSET.reg;
    db34:	f892 3109 	ldrb.w	r3, [r2, #265]	; 0x109
	if (flags) {
    db38:	4003      	ands	r3, r0
    db3a:	d016      	beq.n	db6a <_usb_d_dev_handler+0x14a>
		if ((ept->flags.bits.eptype == 0x1) && !_usb_d_dev_ep_is_busy(ept)) {
    db3c:	2214      	movs	r2, #20
    db3e:	fb02 5206 	mla	r2, r2, r6, r5
    db42:	f892 2027 	ldrb.w	r2, [r2, #39]	; 0x27
    db46:	f002 0047 	and.w	r0, r2, #71	; 0x47
    db4a:	4288      	cmp	r0, r1
    db4c:	d112      	bne.n	db74 <_usb_d_dev_handler+0x154>
	if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    db4e:	06da      	lsls	r2, r3, #27
    db50:	d502      	bpl.n	db58 <_usb_d_dev_handler+0x138>
			_usb_d_dev_handle_setup(ept);
    db52:	4620      	mov	r0, r4
    db54:	47c8      	blx	r9
    db56:	e008      	b.n	db6a <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    db58:	f013 0140 	ands.w	r1, r3, #64	; 0x40
    db5c:	d003      	beq.n	db66 <_usb_d_dev_handler+0x146>
		_usb_d_dev_handle_stall(ept, 1);
    db5e:	4601      	mov	r1, r0
		_usb_d_dev_handle_stall(ept, 0);
    db60:	4b1e      	ldr	r3, [pc, #120]	; (dbdc <_usb_d_dev_handler+0x1bc>)
    db62:	4620      	mov	r0, r4
    db64:	e013      	b.n	db8e <_usb_d_dev_handler+0x16e>
	} else if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    db66:	069b      	lsls	r3, r3, #26
    db68:	d4fa      	bmi.n	db60 <_usb_d_dev_handler+0x140>
	for (i = 0; i < USB_D_N_EP; i++) {
    db6a:	3601      	adds	r6, #1
    db6c:	2e1b      	cmp	r6, #27
    db6e:	d1cc      	bne.n	db0a <_usb_d_dev_handler+0xea>
}
    db70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		} else if (_usb_d_dev_ep_is_in(ept)) {
    db74:	0610      	lsls	r0, r2, #24
    db76:	d514      	bpl.n	dba2 <_usb_d_dev_handler+0x182>
	if (flags & USB_DEVICE_EPINTFLAG_STALL1) {
    db78:	0658      	lsls	r0, r3, #25
    db7a:	d4f1      	bmi.n	db60 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    db7c:	0718      	lsls	r0, r3, #28
    db7e:	d502      	bpl.n	db86 <_usb_d_dev_handler+0x166>
			_usb_d_dev_handle_trfail(ept, 1);
    db80:	4620      	mov	r0, r4
    db82:	47c0      	blx	r8
    db84:	e7f1      	b.n	db6a <_usb_d_dev_handler+0x14a>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT1) {
    db86:	0798      	lsls	r0, r3, #30
    db88:	d503      	bpl.n	db92 <_usb_d_dev_handler+0x172>
		_usb_d_dev_in_next(ept, true);
    db8a:	4b15      	ldr	r3, [pc, #84]	; (dbe0 <_usb_d_dev_handler+0x1c0>)
    db8c:	4620      	mov	r0, r4
		_usb_d_dev_handle_stall(ept, 0);
    db8e:	4798      	blx	r3
    db90:	e7eb      	b.n	db6a <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    db92:	f002 0207 	and.w	r2, r2, #7
    db96:	2a01      	cmp	r2, #1
    db98:	d1e7      	bne.n	db6a <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    db9a:	075a      	lsls	r2, r3, #29
    db9c:	d515      	bpl.n	dbca <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 0);
    db9e:	2100      	movs	r1, #0
    dba0:	e7ee      	b.n	db80 <_usb_d_dev_handler+0x160>
	if (flags & USB_DEVICE_EPINTFLAG_STALL0) {
    dba2:	f013 0020 	ands.w	r0, r3, #32
    dba6:	d001      	beq.n	dbac <_usb_d_dev_handler+0x18c>
		_usb_d_dev_handle_stall(ept, 0);
    dba8:	2100      	movs	r1, #0
    dbaa:	e7d9      	b.n	db60 <_usb_d_dev_handler+0x140>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRFAIL0) {
    dbac:	0758      	lsls	r0, r3, #29
    dbae:	d4f6      	bmi.n	db9e <_usb_d_dev_handler+0x17e>
	} else if (flags & USB_DEVICE_EPINTFLAG_TRCPT0) {
    dbb0:	07d8      	lsls	r0, r3, #31
    dbb2:	d502      	bpl.n	dbba <_usb_d_dev_handler+0x19a>
		_usb_d_dev_out_next(ept, true);
    dbb4:	4620      	mov	r0, r4
    dbb6:	47d0      	blx	sl
    dbb8:	e7d7      	b.n	db6a <_usb_d_dev_handler+0x14a>
	} else if (_usb_d_dev_ep_is_ctrl(ept)) {
    dbba:	f002 0207 	and.w	r2, r2, #7
    dbbe:	2a01      	cmp	r2, #1
    dbc0:	d1d3      	bne.n	db6a <_usb_d_dev_handler+0x14a>
		if (flags & USB_DEVICE_EPINTFLAG_TRFAIL1) {
    dbc2:	071a      	lsls	r2, r3, #28
    dbc4:	d501      	bpl.n	dbca <_usb_d_dev_handler+0x1aa>
			_usb_d_dev_handle_trfail(ept, 1);
    dbc6:	2101      	movs	r1, #1
    dbc8:	e7da      	b.n	db80 <_usb_d_dev_handler+0x160>
		} else if (flags & USB_DEVICE_EPINTFLAG_RXSTP) {
    dbca:	06db      	lsls	r3, r3, #27
    dbcc:	d5cd      	bpl.n	db6a <_usb_d_dev_handler+0x14a>
    dbce:	e7c0      	b.n	db52 <_usb_d_dev_handler+0x132>
    dbd0:	200085a8 	.word	0x200085a8
    dbd4:	0000d485 	.word	0x0000d485
    dbd8:	0000d6e9 	.word	0x0000d6e9
    dbdc:	0000d545 	.word	0x0000d545
    dbe0:	0000d729 	.word	0x0000d729
    dbe4:	0000d4c1 	.word	0x0000d4c1
    dbe8:	0000d601 	.word	0x0000d601
    dbec:	0000d885 	.word	0x0000d885

0000dbf0 <_usbd_ep_pcksize_size>:
	        : ((n > 256) ? 6 : ((n > 128) ? 5 : ((n > 64) ? 4 : ((n > 32) ? 3 : ((n > 16) ? 2 : ((n > 8) ? 1 : 0)))))));
    dbf0:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    dbf4:	d80f      	bhi.n	dc16 <_usbd_ep_pcksize_size+0x26>
    dbf6:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
    dbfa:	d80e      	bhi.n	dc1a <_usbd_ep_pcksize_size+0x2a>
    dbfc:	2880      	cmp	r0, #128	; 0x80
    dbfe:	d80e      	bhi.n	dc1e <_usbd_ep_pcksize_size+0x2e>
    dc00:	2840      	cmp	r0, #64	; 0x40
    dc02:	d80e      	bhi.n	dc22 <_usbd_ep_pcksize_size+0x32>
    dc04:	2820      	cmp	r0, #32
    dc06:	d80e      	bhi.n	dc26 <_usbd_ep_pcksize_size+0x36>
    dc08:	2810      	cmp	r0, #16
    dc0a:	d80e      	bhi.n	dc2a <_usbd_ep_pcksize_size+0x3a>
    dc0c:	2808      	cmp	r0, #8
    dc0e:	bf94      	ite	ls
    dc10:	2000      	movls	r0, #0
    dc12:	2001      	movhi	r0, #1
    dc14:	4770      	bx	lr
    dc16:	2007      	movs	r0, #7
    dc18:	4770      	bx	lr
    dc1a:	2006      	movs	r0, #6
    dc1c:	4770      	bx	lr
    dc1e:	2005      	movs	r0, #5
    dc20:	4770      	bx	lr
    dc22:	2004      	movs	r0, #4
    dc24:	4770      	bx	lr
    dc26:	2003      	movs	r0, #3
    dc28:	4770      	bx	lr
    dc2a:	2002      	movs	r0, #2
}
    dc2c:	4770      	bx	lr
	...

0000dc30 <_usb_d_dev_init>:
{
    dc30:	b508      	push	{r3, lr}
	return ((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg;
    dc32:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    dc36:	789a      	ldrb	r2, [r3, #2]
	if (!hri_usbdevice_is_syncing(hw, USB_SYNCBUSY_SWRST)) {
    dc38:	07d0      	lsls	r0, r2, #31
    dc3a:	d41a      	bmi.n	dc72 <_usb_d_dev_init+0x42>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    dc3c:	789a      	ldrb	r2, [r3, #2]
    dc3e:	0791      	lsls	r1, r2, #30
    dc40:	d1fc      	bne.n	dc3c <_usb_d_dev_init+0xc>

static inline hri_usb_ctrla_reg_t hri_usb_get_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_usb_wait_for_sync(hw, USB_SYNCBUSY_MASK);
	tmp = ((Usb *)hw)->HOST.CTRLA.reg;
    dc42:	781a      	ldrb	r2, [r3, #0]
		if (hri_usbdevice_get_CTRLA_reg(hw, USB_CTRLA_ENABLE)) {
    dc44:	0792      	lsls	r2, r2, #30
    dc46:	d50d      	bpl.n	dc64 <_usb_d_dev_init+0x34>
	((Usb *)hw)->HOST.CTRLA.reg &= ~USB_CTRLA_ENABLE;
    dc48:	781a      	ldrb	r2, [r3, #0]
    dc4a:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
    dc4e:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    dc50:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    dc54:	7893      	ldrb	r3, [r2, #2]
    dc56:	0798      	lsls	r0, r3, #30
    dc58:	d1fc      	bne.n	dc54 <_usb_d_dev_init+0x24>
    dc5a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    dc5e:	7893      	ldrb	r3, [r2, #2]
    dc60:	0799      	lsls	r1, r3, #30
    dc62:	d4fc      	bmi.n	dc5e <_usb_d_dev_init+0x2e>
}

static inline void hri_usb_write_CTRLA_reg(const void *const hw, hri_usb_ctrla_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.CTRLA.reg = data;
    dc64:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    dc68:	2201      	movs	r2, #1
    dc6a:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    dc6c:	789a      	ldrb	r2, [r3, #2]
    dc6e:	0792      	lsls	r2, r2, #30
    dc70:	d1fc      	bne.n	dc6c <_usb_d_dev_init+0x3c>
    dc72:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    dc76:	7893      	ldrb	r3, [r2, #2]
    dc78:	07db      	lsls	r3, r3, #31
    dc7a:	d4fc      	bmi.n	dc76 <_usb_d_dev_init+0x46>
	dev_inst.callbacks.sof   = (_usb_d_dev_sof_cb_t)_dummy_func_no_return;
    dc7c:	4a1e      	ldr	r2, [pc, #120]	; (dcf8 <_usb_d_dev_init+0xc8>)
    dc7e:	4b1f      	ldr	r3, [pc, #124]	; (dcfc <_usb_d_dev_init+0xcc>)
	dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)_dummy_func_no_return;
    dc80:	e9c3 2200 	strd	r2, r2, [r3]
	dev_inst.ep_callbacks.more  = (_usb_d_dev_ep_cb_more_t)_dummy_func_no_return;
    dc84:	e9c3 2202 	strd	r2, r2, [r3, #8]
	dev_inst.ep_callbacks.done  = (_usb_d_dev_ep_cb_done_t)_dummy_func_no_return;
    dc88:	611a      	str	r2, [r3, #16]
	_usb_d_dev_reset_epts();
    dc8a:	4b1d      	ldr	r3, [pc, #116]	; (dd00 <_usb_d_dev_init+0xd0>)
    dc8c:	4798      	blx	r3
	    = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRANSN_POS / 32)) >> (NVM_USB_PAD_TRANSN_POS % 32))
    dc8e:	4b1d      	ldr	r3, [pc, #116]	; (dd04 <_usb_d_dev_init+0xd4>)
    dc90:	681a      	ldr	r2, [r3, #0]
	uint32_t pad_transp
    dc92:	f3c2 1344 	ubfx	r3, r2, #5, #5
	uint32_t pad_trim = (*((uint32_t *)(NVMCTRL_SW0) + (NVM_USB_PAD_TRIM_POS / 32)) >> (NVM_USB_PAD_TRIM_POS % 32))
    dc96:	f3c2 2182 	ubfx	r1, r2, #10, #3
	if (pad_transn == 0 || pad_transn == 0x1F) {
    dc9a:	f012 021f 	ands.w	r2, r2, #31
    dc9e:	d025      	beq.n	dcec <_usb_d_dev_init+0xbc>
		pad_transn = 9;
    dca0:	2a1f      	cmp	r2, #31
    dca2:	bf08      	it	eq
    dca4:	2209      	moveq	r2, #9
	if (pad_transp == 0 || pad_transp == 0x1F) {
    dca6:	b31b      	cbz	r3, dcf0 <_usb_d_dev_init+0xc0>
		pad_transp = 25;
    dca8:	2b1f      	cmp	r3, #31
    dcaa:	bf08      	it	eq
    dcac:	2319      	moveq	r3, #25
	if (pad_trim == 0 || pad_trim == 0x7) {
    dcae:	b309      	cbz	r1, dcf4 <_usb_d_dev_init+0xc4>
		pad_trim = 6;
    dcb0:	2907      	cmp	r1, #7
    dcb2:	bf08      	it	eq
    dcb4:	2106      	moveq	r1, #6
	hw->DEVICE.PADCAL.reg = USB_PADCAL_TRANSN(pad_transn) | USB_PADCAL_TRANSP(pad_transp) | USB_PADCAL_TRIM(pad_trim);
    dcb6:	ea43 1382 	orr.w	r3, r3, r2, lsl #6
    dcba:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
    dcbe:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    dcc2:	b29b      	uxth	r3, r3
    dcc4:	8513      	strh	r3, [r2, #40]	; 0x28
	hw->DEVICE.QOSCTRL.bit.CQOS = 3;
    dcc6:	78d3      	ldrb	r3, [r2, #3]
    dcc8:	f043 0303 	orr.w	r3, r3, #3
    dccc:	70d3      	strb	r3, [r2, #3]
	hw->DEVICE.QOSCTRL.bit.DQOS = 3;
    dcce:	78d3      	ldrb	r3, [r2, #3]
    dcd0:	f043 030c 	orr.w	r3, r3, #12
    dcd4:	70d3      	strb	r3, [r2, #3]
	((Usb *)hw)->HOST.CTRLA.reg = data;
    dcd6:	2304      	movs	r3, #4
    dcd8:	7013      	strb	r3, [r2, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    dcda:	7890      	ldrb	r0, [r2, #2]
    dcdc:	f010 0003 	ands.w	r0, r0, #3
    dce0:	d1fb      	bne.n	dcda <_usb_d_dev_init+0xaa>
	hri_usbdevice_write_DESCADD_reg(hw, (uint32_t)prvt_inst.desc_table);
    dce2:	4b09      	ldr	r3, [pc, #36]	; (dd08 <_usb_d_dev_init+0xd8>)
}

static inline void hri_usb_write_DESCADD_reg(const void *const hw, hri_usb_descadd_reg_t data)
{
	USB_CRITICAL_SECTION_ENTER();
	((Usb *)hw)->HOST.DESCADD.reg = data;
    dce4:	6253      	str	r3, [r2, #36]	; 0x24
	((Usb *)hw)->DEVICE.CTRLB.reg = data;
    dce6:	2301      	movs	r3, #1
    dce8:	8113      	strh	r3, [r2, #8]
}
    dcea:	bd08      	pop	{r3, pc}
		pad_transn = 9;
    dcec:	2209      	movs	r2, #9
    dcee:	e7da      	b.n	dca6 <_usb_d_dev_init+0x76>
		pad_transp = 25;
    dcf0:	2319      	movs	r3, #25
    dcf2:	e7dc      	b.n	dcae <_usb_d_dev_init+0x7e>
		pad_trim = 6;
    dcf4:	2106      	movs	r1, #6
    dcf6:	e7de      	b.n	dcb6 <_usb_d_dev_init+0x86>
    dcf8:	0000d481 	.word	0x0000d481
    dcfc:	200085a8 	.word	0x200085a8
    dd00:	0000d6e9 	.word	0x0000d6e9
    dd04:	00800084 	.word	0x00800084
    dd08:	200087d8 	.word	0x200087d8

0000dd0c <_usb_d_dev_enable>:
	tmp = ((Usb *)hw)->HOST.SYNCBUSY.reg;
    dd0c:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    dd10:	789a      	ldrb	r2, [r3, #2]
	if (hri_usbdevice_get_SYNCBUSY_reg(hw, (USB_SYNCBUSY_ENABLE | USB_SYNCBUSY_SWRST))) {
    dd12:	0792      	lsls	r2, r2, #30
    dd14:	d122      	bne.n	dd5c <_usb_d_dev_enable+0x50>
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    dd16:	789a      	ldrb	r2, [r3, #2]
    dd18:	0790      	lsls	r0, r2, #30
    dd1a:	d1fc      	bne.n	dd16 <_usb_d_dev_enable+0xa>
	return ((Usb *)hw)->HOST.CTRLA.reg;
    dd1c:	7819      	ldrb	r1, [r3, #0]
    dd1e:	b2ca      	uxtb	r2, r1
	if ((ctrla & USB_CTRLA_ENABLE) == 0) {
    dd20:	0789      	lsls	r1, r1, #30
    dd22:	d407      	bmi.n	dd34 <_usb_d_dev_enable+0x28>
		hri_usbdevice_write_CTRLA_reg(hw, ctrla | USB_CTRLA_ENABLE);
    dd24:	f042 0202 	orr.w	r2, r2, #2
	((Usb *)hw)->HOST.CTRLA.reg = data;
    dd28:	701a      	strb	r2, [r3, #0]
	while (((Usb *)hw)->DEVICE.SYNCBUSY.reg & reg) {
    dd2a:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    dd2e:	7893      	ldrb	r3, [r2, #2]
    dd30:	079b      	lsls	r3, r3, #30
    dd32:	d1fc      	bne.n	dd2e <_usb_d_dev_enable+0x22>
    dd34:	4b0b      	ldr	r3, [pc, #44]	; (dd64 <_usb_d_dev_enable+0x58>)
    dd36:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    dd3a:	609a      	str	r2, [r3, #8]
    dd3c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    dd40:	609a      	str	r2, [r3, #8]
    dd42:	f44f 2280 	mov.w	r2, #262144	; 0x40000
    dd46:	609a      	str	r2, [r3, #8]
    dd48:	f44f 2200 	mov.w	r2, #524288	; 0x80000
    dd4c:	609a      	str	r2, [r3, #8]
	((Usb *)hw)->DEVICE.INTENSET.reg = mask;
    dd4e:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    dd52:	f240 228d 	movw	r2, #653	; 0x28d
    dd56:	831a      	strh	r2, [r3, #24]
	return ERR_NONE;
    dd58:	2000      	movs	r0, #0
    dd5a:	4770      	bx	lr
		return -USB_ERR_DENIED;
    dd5c:	f06f 0010 	mvn.w	r0, #16
}
    dd60:	4770      	bx	lr
    dd62:	bf00      	nop
    dd64:	e000e100 	.word	0xe000e100

0000dd68 <_usb_d_dev_attach>:
	((Usb *)hw)->DEVICE.CTRLB.reg &= ~USB_DEVICE_CTRLB_DETACH;
    dd68:	f04f 4282 	mov.w	r2, #1090519040	; 0x41000000
    dd6c:	8913      	ldrh	r3, [r2, #8]
    dd6e:	f023 0301 	bic.w	r3, r3, #1
    dd72:	041b      	lsls	r3, r3, #16
    dd74:	0c1b      	lsrs	r3, r3, #16
    dd76:	8113      	strh	r3, [r2, #8]
}
    dd78:	4770      	bx	lr

0000dd7a <_usb_d_dev_set_address>:
	((Usb *)hw)->DEVICE.DADD.reg = data;
    dd7a:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
	hri_usbdevice_write_DADD_reg(USB, USB_DEVICE_DADD_ADDEN | USB_DEVICE_DADD_DADD(addr));
    dd7e:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    dd82:	7298      	strb	r0, [r3, #10]
}
    dd84:	4770      	bx	lr

0000dd86 <_usb_d_dev_get_frame_n>:
	return (((Usb *)hw)->DEVICE.FNUM.reg & USB_DEVICE_FNUM_FNUM_Msk) >> USB_DEVICE_FNUM_FNUM_Pos;
    dd86:	f04f 4382 	mov.w	r3, #1090519040	; 0x41000000
    dd8a:	8a18      	ldrh	r0, [r3, #16]
}
    dd8c:	f3c0 00ca 	ubfx	r0, r0, #3, #11
    dd90:	4770      	bx	lr
	...

0000dd94 <_usb_d_dev_ep_init>:
{
    dd94:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    dd98:	f000 040f 	and.w	r4, r0, #15
{
    dd9c:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    dd9e:	f8df 90b0 	ldr.w	r9, [pc, #176]	; de50 <_usb_d_dev_ep_init+0xbc>
    dda2:	09c1      	lsrs	r1, r0, #7
{
    dda4:	4607      	mov	r7, r0
    dda6:	fa4f f880 	sxtb.w	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    ddaa:	4620      	mov	r0, r4
    ddac:	47c8      	blx	r9
	if (epn > CONF_USB_D_MAX_EP_N) {
    ddae:	2c05      	cmp	r4, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    ddb0:	4606      	mov	r6, r0
	uint8_t                        ep_type = attr & USB_EP_XTYPE_MASK;
    ddb2:	f005 0503 	and.w	r5, r5, #3
	if (epn > CONF_USB_D_MAX_EP_N) {
    ddb6:	d83f      	bhi.n	de38 <_usb_d_dev_ep_init+0xa4>
	if (ept->ep != 0xFF) {
    ddb8:	7c83      	ldrb	r3, [r0, #18]
    ddba:	2bff      	cmp	r3, #255	; 0xff
    ddbc:	d13f      	bne.n	de3e <_usb_d_dev_ep_init+0xaa>
	if (ep_type == USB_EP_XTYPE_CTRL) {
    ddbe:	b985      	cbnz	r5, dde2 <_usb_d_dev_ep_init+0x4e>
		struct _usb_d_dev_ep *ept_in = _usb_d_dev_ept(epn, !dir);
    ddc0:	ea6f 0108 	mvn.w	r1, r8
    ddc4:	0fc9      	lsrs	r1, r1, #31
    ddc6:	4620      	mov	r0, r4
    ddc8:	47c8      	blx	r9
		if (ept_in->ep != 0xFF) {
    ddca:	7c83      	ldrb	r3, [r0, #18]
    ddcc:	2bff      	cmp	r3, #255	; 0xff
    ddce:	d136      	bne.n	de3e <_usb_d_dev_ep_init+0xaa>
		if (pcfg->cache == NULL) {
    ddd0:	230c      	movs	r3, #12
    ddd2:	491e      	ldr	r1, [pc, #120]	; (de4c <_usb_d_dev_ep_init+0xb8>)
    ddd4:	4363      	muls	r3, r4
    ddd6:	58cb      	ldr	r3, [r1, r3]
    ddd8:	2b00      	cmp	r3, #0
    ddda:	d133      	bne.n	de44 <_usb_d_dev_ep_init+0xb0>
			return -USB_ERR_FUNC;
    dddc:	f06f 0012 	mvn.w	r0, #18
    dde0:	e018      	b.n	de14 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    dde2:	f1b8 0f00 	cmp.w	r8, #0
    dde6:	da17      	bge.n	de18 <_usb_d_dev_ep_init+0x84>
    dde8:	4918      	ldr	r1, [pc, #96]	; (de4c <_usb_d_dev_ep_init+0xb8>)
    ddea:	230c      	movs	r3, #12
    ddec:	fb03 1304 	mla	r3, r3, r4, r1
    ddf0:	6859      	ldr	r1, [r3, #4]
    ddf2:	b9e9      	cbnz	r1, de30 <_usb_d_dev_ep_init+0x9c>
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    ddf4:	4915      	ldr	r1, [pc, #84]	; (de4c <_usb_d_dev_ep_init+0xb8>)
	ept->size     = max_pkt_siz;
    ddf6:	8232      	strh	r2, [r6, #16]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    ddf8:	230c      	movs	r3, #12
    ddfa:	435c      	muls	r4, r3
    ddfc:	190b      	adds	r3, r1, r4
    ddfe:	5909      	ldr	r1, [r1, r4]
    de00:	685b      	ldr	r3, [r3, #4]
	ept->ep       = ep;
    de02:	74b7      	strb	r7, [r6, #18]
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    de04:	ea13 0328 	ands.w	r3, r3, r8, asr #32
    de08:	bf38      	it	cc
    de0a:	460b      	movcc	r3, r1
	ept->flags.u8 = (ep_type + 1);
    de0c:	3501      	adds	r5, #1
	ept->cache    = (uint8_t *)(dir ? pcfg->i_cache : pcfg->cache);
    de0e:	60f3      	str	r3, [r6, #12]
	ept->flags.u8 = (ep_type + 1);
    de10:	74f5      	strb	r5, [r6, #19]
	return USB_OK;
    de12:	2000      	movs	r0, #0
}
    de14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    de18:	230c      	movs	r3, #12
    de1a:	490c      	ldr	r1, [pc, #48]	; (de4c <_usb_d_dev_ep_init+0xb8>)
    de1c:	4363      	muls	r3, r4
    de1e:	58cb      	ldr	r3, [r1, r3]
    de20:	2b00      	cmp	r3, #0
    de22:	d0e7      	beq.n	ddf4 <_usb_d_dev_ep_init+0x60>
    de24:	4909      	ldr	r1, [pc, #36]	; (de4c <_usb_d_dev_ep_init+0xb8>)
    de26:	230c      	movs	r3, #12
    de28:	fb03 1304 	mla	r3, r3, r4, r1
    de2c:	891b      	ldrh	r3, [r3, #8]
    de2e:	e000      	b.n	de32 <_usb_d_dev_ep_init+0x9e>
    de30:	895b      	ldrh	r3, [r3, #10]
    de32:	429a      	cmp	r2, r3
    de34:	ddde      	ble.n	ddf4 <_usb_d_dev_ep_init+0x60>
    de36:	e7d1      	b.n	dddc <_usb_d_dev_ep_init+0x48>
		return -USB_ERR_PARAM;
    de38:	f06f 0011 	mvn.w	r0, #17
    de3c:	e7ea      	b.n	de14 <_usb_d_dev_ep_init+0x80>
		return -USB_ERR_REDO;
    de3e:	f06f 0013 	mvn.w	r0, #19
    de42:	e7e7      	b.n	de14 <_usb_d_dev_ep_init+0x80>
	if ((dir ? pcfg->i_cache : pcfg->cache) && ((dir ? pcfg->i_size : pcfg->size) < max_pkt_siz)) {
    de44:	f1b8 0f00 	cmp.w	r8, #0
    de48:	daec      	bge.n	de24 <_usb_d_dev_ep_init+0x90>
    de4a:	e7cd      	b.n	dde8 <_usb_d_dev_ep_init+0x54>
    de4c:	00016f24 	.word	0x00016f24
    de50:	0000d4a9 	.word	0x0000d4a9

0000de54 <_usb_d_dev_ep_deinit>:
{
    de54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    de56:	f000 050f 	and.w	r5, r0, #15
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    de5a:	2d05      	cmp	r5, #5
{
    de5c:	4604      	mov	r4, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    de5e:	d818      	bhi.n	de92 <_usb_d_dev_ep_deinit+0x3e>
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    de60:	4b17      	ldr	r3, [pc, #92]	; (dec0 <_usb_d_dev_ep_deinit+0x6c>)
	bool                  dir = USB_EP_GET_DIR(ep);
    de62:	09c1      	lsrs	r1, r0, #7
    de64:	b247      	sxtb	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    de66:	4628      	mov	r0, r5
    de68:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    de6a:	7c83      	ldrb	r3, [r0, #18]
    de6c:	2bff      	cmp	r3, #255	; 0xff
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    de6e:	4606      	mov	r6, r0
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    de70:	d00f      	beq.n	de92 <_usb_d_dev_ep_deinit+0x3e>
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_RESET);
    de72:	4b14      	ldr	r3, [pc, #80]	; (dec4 <_usb_d_dev_ep_deinit+0x70>)
    de74:	2203      	movs	r2, #3
    de76:	4798      	blx	r3
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    de78:	7cf3      	ldrb	r3, [r6, #19]
    de7a:	f003 0307 	and.w	r3, r3, #7
    de7e:	2b01      	cmp	r3, #1
    de80:	d108      	bne.n	de94 <_usb_d_dev_ep_deinit+0x40>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg = 0;
    de82:	0164      	lsls	r4, r4, #5
    de84:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    de88:	2300      	movs	r3, #0
    de8a:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
	ept->ep       = 0xFF;
    de8e:	23ff      	movs	r3, #255	; 0xff
    de90:	8273      	strh	r3, [r6, #18]
}
    de92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	} else if (USB_EP_GET_DIR(ep)) {
    de94:	2f00      	cmp	r7, #0
    de96:	da09      	bge.n	deac <_usb_d_dev_ep_deinit+0x58>
		hw->DEVICE.DeviceEndpoint[USB_EP_GET_N(ep)].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE1_Msk;
    de98:	016b      	lsls	r3, r5, #5
    de9a:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    de9e:	f893 2100 	ldrb.w	r2, [r3, #256]	; 0x100
    dea2:	f002 028f 	and.w	r2, r2, #143	; 0x8f
    dea6:	f883 2100 	strb.w	r2, [r3, #256]	; 0x100
    deaa:	e7f0      	b.n	de8e <_usb_d_dev_ep_deinit+0x3a>
		hw->DEVICE.DeviceEndpoint[ep].EPCFG.reg &= ~USB_DEVICE_EPCFG_EPTYPE0_Msk;
    deac:	0164      	lsls	r4, r4, #5
    deae:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
    deb2:	f894 3100 	ldrb.w	r3, [r4, #256]	; 0x100
    deb6:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
    deba:	f884 3100 	strb.w	r3, [r4, #256]	; 0x100
    debe:	e7e6      	b.n	de8e <_usb_d_dev_ep_deinit+0x3a>
    dec0:	0000d4a9 	.word	0x0000d4a9
    dec4:	0000d5a1 	.word	0x0000d5a1

0000dec8 <_usb_d_dev_ep_enable>:
{
    dec8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint8_t               epn   = USB_EP_GET_N(ep);
    decc:	f000 050f 	and.w	r5, r0, #15
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    ded0:	09c1      	lsrs	r1, r0, #7
    ded2:	4b55      	ldr	r3, [pc, #340]	; (e028 <_usb_d_dev_ep_enable+0x160>)
    ded4:	fa4f f980 	sxtb.w	r9, r0
    ded8:	4628      	mov	r0, r5
    deda:	4798      	blx	r3
    dedc:	ea4f 1c45 	mov.w	ip, r5, lsl #5
    dee0:	f10c 4682 	add.w	r6, ip, #1090519040	; 0x41000000
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    dee4:	2d05      	cmp	r5, #5
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    dee6:	f896 1100 	ldrb.w	r1, [r6, #256]	; 0x100
	struct _usb_d_dev_ep *ept   = _usb_d_dev_ept(epn, dir);
    deea:	4607      	mov	r7, r0
    deec:	b2c8      	uxtb	r0, r1
	if (epn > CONF_USB_D_MAX_EP_N || !_usb_d_dev_ep_is_used(ept)) {
    deee:	f200 8094 	bhi.w	e01a <_usb_d_dev_ep_enable+0x152>
    def2:	7cba      	ldrb	r2, [r7, #18]
    def4:	2aff      	cmp	r2, #255	; 0xff
    def6:	f000 8090 	beq.w	e01a <_usb_d_dev_ep_enable+0x152>
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    defa:	7cf9      	ldrb	r1, [r7, #19]
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    defc:	4c4b      	ldr	r4, [pc, #300]	; (e02c <_usb_d_dev_ep_enable+0x164>)
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    defe:	f001 0307 	and.w	r3, r1, #7
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    df02:	f504 780c 	add.w	r8, r4, #560	; 0x230
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    df06:	2b01      	cmp	r3, #1
	bank = prvt_inst.desc_table[epn].DeviceDescBank;
    df08:	44e0      	add	r8, ip
	if (ept->flags.bits.eptype == USB_D_EPTYPE_CTRL) {
    df0a:	d147      	bne.n	df9c <_usb_d_dev_ep_enable+0xd4>
		if (epcfg & (USB_DEVICE_EPCFG_EPTYPE1_Msk | USB_DEVICE_EPCFG_EPTYPE0_Msk)) {
    df0c:	f010 0377 	ands.w	r3, r0, #119	; 0x77
    df10:	f040 8086 	bne.w	e020 <_usb_d_dev_ep_enable+0x158>
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    df14:	f8b7 9010 	ldrh.w	r9, [r7, #16]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    df18:	2111      	movs	r1, #17
    df1a:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    df1e:	4648      	mov	r0, r9
    df20:	4943      	ldr	r1, [pc, #268]	; (e030 <_usb_d_dev_ep_enable+0x168>)
    df22:	4788      	blx	r1
    df24:	0700      	lsls	r0, r0, #28
    df26:	f000 41e0 	and.w	r1, r0, #1879048192	; 0x70000000
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    df2a:	4842      	ldr	r0, [pc, #264]	; (e034 <_usb_d_dev_ep_enable+0x16c>)
    df2c:	ea00 3089 	and.w	r0, r0, r9, lsl #14
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    df30:	f3c9 090d 	ubfx	r9, r9, #0, #14
	bank->STATUS_BK.reg     = 0;
    df34:	eb04 1545 	add.w	r5, r4, r5, lsl #5
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    df38:	4308      	orrs	r0, r1
	uint8_t epn = USB_EP_GET_N(ept->ep);
    df3a:	f002 020f 	and.w	r2, r2, #15
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    df3e:	ea49 0101 	orr.w	r1, r9, r1
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    df42:	f8c8 0004 	str.w	r0, [r8, #4]
	bank->ADDR.reg          = addr;
    df46:	eb04 1442 	add.w	r4, r4, r2, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    df4a:	f8c8 1014 	str.w	r1, [r8, #20]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    df4e:	f04f 0c40 	mov.w	ip, #64	; 0x40
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    df52:	2180      	movs	r1, #128	; 0x80
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    df54:	f886 c105 	strb.w	ip, [r6, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    df58:	f886 1104 	strb.w	r1, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    df5c:	f885 323a 	strb.w	r3, [r5, #570]	; 0x23a
    df60:	f885 324a 	strb.w	r3, [r5, #586]	; 0x24a
	_usbd_ep_set_buf(epn, 0, (uint32_t)ept->cache);
    df64:	68fd      	ldr	r5, [r7, #12]
	bank->ADDR.reg          = addr;
    df66:	f8c4 5230 	str.w	r5, [r4, #560]	; 0x230
    df6a:	f504 710c 	add.w	r1, r4, #560	; 0x230
	bank->PCKSIZE.bit.MULTI_PACKET_SIZE = size;
    df6e:	f8d4 4234 	ldr.w	r4, [r4, #564]	; 0x234
    df72:	f369 349b 	bfi	r4, r9, #14, #14
    df76:	604c      	str	r4, [r1, #4]
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    df78:	684c      	ldr	r4, [r1, #4]
	bank->ADDR.reg          = addr;
    df7a:	0150      	lsls	r0, r2, #5
	bank->PCKSIZE.bit.BYTE_COUNT = count;
    df7c:	f100 4282 	add.w	r2, r0, #1090519040	; 0x41000000
    df80:	f363 040d 	bfi	r4, r3, #0, #14
    df84:	604c      	str	r4, [r1, #4]
    df86:	21b0      	movs	r1, #176	; 0xb0
    df88:	f882 1104 	strb.w	r1, [r2, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    df8c:	2110      	movs	r1, #16
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    df8e:	f882 c105 	strb.w	ip, [r2, #261]	; 0x105
	return USB_OK;
    df92:	4618      	mov	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    df94:	f882 1109 	strb.w	r1, [r2, #265]	; 0x109
}
    df98:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if (dir) {
    df9c:	f1b9 0f00 	cmp.w	r9, #0
    dfa0:	da1e      	bge.n	dfe0 <_usb_d_dev_ep_enable+0x118>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE1_Msk) {
    dfa2:	f010 0270 	ands.w	r2, r0, #112	; 0x70
    dfa6:	d13b      	bne.n	e020 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    dfa8:	f3c1 0102 	ubfx	r1, r1, #0, #3
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    dfac:	8a3b      	ldrh	r3, [r7, #16]
		epcfg |= USB_DEVICE_EPCFG_EPTYPE1(ept->flags.bits.eptype);
    dfae:	ea40 1101 	orr.w	r1, r0, r1, lsl #4
    dfb2:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    dfb4:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    dfb8:	4618      	mov	r0, r3
    dfba:	491d      	ldr	r1, [pc, #116]	; (e030 <_usb_d_dev_ep_enable+0x168>)
    dfbc:	4788      	blx	r1
    dfbe:	0700      	lsls	r0, r0, #28
    dfc0:	f3c3 030d 	ubfx	r3, r3, #0, #14
    dfc4:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
	bank->STATUS_BK.reg     = 0;
    dfc8:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		    = USB_DEVICE_PCKSIZE_BYTE_COUNT(ept->size) | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    dfcc:	4318      	orrs	r0, r3
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    dfce:	2380      	movs	r3, #128	; 0x80
    dfd0:	f8c8 0014 	str.w	r0, [r8, #20]
    dfd4:	f886 3104 	strb.w	r3, [r6, #260]	; 0x104
	bank->STATUS_BK.reg     = 0;
    dfd8:	f884 224a 	strb.w	r2, [r4, #586]	; 0x24a
	return USB_OK;
    dfdc:	4610      	mov	r0, r2
}
    dfde:	e7db      	b.n	df98 <_usb_d_dev_ep_enable+0xd0>
		if (epcfg & USB_DEVICE_EPCFG_EPTYPE0_Msk) {
    dfe0:	f010 0207 	ands.w	r2, r0, #7
    dfe4:	d11c      	bne.n	e020 <_usb_d_dev_ep_enable+0x158>
		epcfg |= USB_DEVICE_EPCFG_EPTYPE0(ept->flags.bits.eptype);
    dfe6:	f001 0107 	and.w	r1, r1, #7
    dfea:	4301      	orrs	r1, r0
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg = data;
    dfec:	f886 1100 	strb.w	r1, [r6, #256]	; 0x100
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    dff0:	8a39      	ldrh	r1, [r7, #16]
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    dff2:	4b0f      	ldr	r3, [pc, #60]	; (e030 <_usb_d_dev_ep_enable+0x168>)
    dff4:	4608      	mov	r0, r1
    dff6:	4798      	blx	r3
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    dff8:	4b0e      	ldr	r3, [pc, #56]	; (e034 <_usb_d_dev_ep_enable+0x16c>)
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    dffa:	0700      	lsls	r0, r0, #28
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    dffc:	ea03 3381 	and.w	r3, r3, r1, lsl #14
		                      | USB_DEVICE_PCKSIZE_SIZE(_usbd_ep_pcksize_size(ept->size));
    e000:	f000 40e0 	and.w	r0, r0, #1879048192	; 0x70000000
    e004:	4303      	orrs	r3, r0
	bank->STATUS_BK.reg     = 0;
    e006:	eb04 1445 	add.w	r4, r4, r5, lsl #5
		bank[0].PCKSIZE.reg = USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE(ept->size)
    e00a:	f8c8 3004 	str.w	r3, [r8, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSSET.reg = mask;
    e00e:	2340      	movs	r3, #64	; 0x40
    e010:	f886 3105 	strb.w	r3, [r6, #261]	; 0x105
	bank->STATUS_BK.reg     = 0;
    e014:	f884 223a 	strb.w	r2, [r4, #570]	; 0x23a
    e018:	e7e0      	b.n	dfdc <_usb_d_dev_ep_enable+0x114>
		return -USB_ERR_PARAM;
    e01a:	f06f 0011 	mvn.w	r0, #17
    e01e:	e7bb      	b.n	df98 <_usb_d_dev_ep_enable+0xd0>
			return -USB_ERR_REDO;
    e020:	f06f 0013 	mvn.w	r0, #19
    e024:	e7b8      	b.n	df98 <_usb_d_dev_ep_enable+0xd0>
    e026:	bf00      	nop
    e028:	0000d4a9 	.word	0x0000d4a9
    e02c:	200085a8 	.word	0x200085a8
    e030:	0000dbf1 	.word	0x0000dbf1
    e034:	0fffc000 	.word	0x0fffc000

0000e038 <_usb_d_dev_ep_stall>:
{
    e038:	b538      	push	{r3, r4, r5, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    e03a:	f000 020f 	and.w	r2, r0, #15
	bool                  dir = USB_EP_GET_DIR(ep);
    e03e:	09c4      	lsrs	r4, r0, #7
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e040:	4b2f      	ldr	r3, [pc, #188]	; (e100 <_usb_d_dev_ep_stall+0xc8>)
{
    e042:	460d      	mov	r5, r1
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e044:	4610      	mov	r0, r2
    e046:	4621      	mov	r1, r4
    e048:	4798      	blx	r3
	if (epn > CONF_USB_D_MAX_EP_N) {
    e04a:	2a05      	cmp	r2, #5
    e04c:	d855      	bhi.n	e0fa <_usb_d_dev_ep_stall+0xc2>
	if (USB_EP_STALL_SET == ctrl) {
    e04e:	7c83      	ldrb	r3, [r0, #18]
    e050:	2210      	movs	r2, #16
    e052:	2d01      	cmp	r5, #1
    e054:	f003 030f 	and.w	r3, r3, #15
    e058:	fa02 f204 	lsl.w	r2, r2, r4
    e05c:	d113      	bne.n	e086 <_usb_d_dev_ep_stall+0x4e>
    e05e:	0159      	lsls	r1, r3, #5
    e060:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
		hri_usbendpoint_set_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    e064:	b2d2      	uxtb	r2, r2
    e066:	f881 2105 	strb.w	r2, [r1, #261]	; 0x105
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENSET.reg = mask;
    e06a:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_en(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    e06c:	2120      	movs	r1, #32
    e06e:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    e072:	40a1      	lsls	r1, r4
	hri_usbendpoint_set_EPINTEN_reg(USB, epn, flags);
    e074:	b2c9      	uxtb	r1, r1
    e076:	f883 1109 	strb.w	r1, [r3, #265]	; 0x109
	ept->flags.bits.is_stalled = 1;
    e07a:	7cc3      	ldrb	r3, [r0, #19]
    e07c:	f043 0308 	orr.w	r3, r3, #8
    e080:	74c3      	strb	r3, [r0, #19]
		rc = _usb_d_dev_ep_stall_clr(ept, dir);
    e082:	2000      	movs	r0, #0
}
    e084:	bd38      	pop	{r3, r4, r5, pc}
	} else if (USB_EP_STALL_CLR == ctrl) {
    e086:	bb6d      	cbnz	r5, e0e4 <_usb_d_dev_ep_stall+0xac>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    e088:	015d      	lsls	r5, r3, #5
    e08a:	f105 4582 	add.w	r5, r5, #1090519040	; 0x41000000
    e08e:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
	if (!is_stalled) {
    e092:	4211      	tst	r1, r2
    e094:	d0f5      	beq.n	e082 <_usb_d_dev_ep_stall+0x4a>
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    e096:	b2d2      	uxtb	r2, r2
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    e098:	f885 2104 	strb.w	r2, [r5, #260]	; 0x104
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTENCLR.reg = mask;
    e09c:	015b      	lsls	r3, r3, #5
	_usbd_ep_int_dis(epn, USB_DEVICE_EPINTFLAG_STALL0 << dir);
    e09e:	2220      	movs	r2, #32
    e0a0:	40a2      	lsls	r2, r4
    e0a2:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
	hri_usbendpoint_clear_EPINTEN_reg(USB, epn, flags);
    e0a6:	b2d1      	uxtb	r1, r2
    e0a8:	f883 1108 	strb.w	r1, [r3, #264]	; 0x108
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    e0ac:	f895 3107 	ldrb.w	r3, [r5, #263]	; 0x107
	if (_usbd_ep_is_stall_sent(epn, dir)) {
    e0b0:	4213      	tst	r3, r2
    e0b2:	d006      	beq.n	e0c2 <_usb_d_dev_ep_stall+0x8a>
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    e0b4:	f885 1107 	strb.w	r1, [r5, #263]	; 0x107
		hri_usbendpoint_clear_EPSTATUS_reg(USB, epn, (USB_DEVICE_EPSTATUS_DTGLOUT << bank_n));
    e0b8:	2101      	movs	r1, #1
    e0ba:	40a1      	lsls	r1, r4
    e0bc:	b2c9      	uxtb	r1, r1
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUSCLR.reg = mask;
    e0be:	f885 1104 	strb.w	r1, [r5, #260]	; 0x104
	if (_usb_d_dev_ep_is_ctrl(ept)) {
    e0c2:	7cc2      	ldrb	r2, [r0, #19]
    e0c4:	f002 0307 	and.w	r3, r2, #7
    e0c8:	2b01      	cmp	r3, #1
    e0ca:	d108      	bne.n	e0de <_usb_d_dev_ep_stall+0xa6>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPSTATUS.reg;
    e0cc:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		if ((hri_usbendpoint_read_EPSTATUS_reg(USB, epn) & USB_DEVICE_EPSTATUS_STALLRQ_Msk) == 0) {
    e0d0:	f013 0330 	ands.w	r3, r3, #48	; 0x30
    e0d4:	d1d5      	bne.n	e082 <_usb_d_dev_ep_stall+0x4a>
			ept->flags.bits.is_stalled = 0;
    e0d6:	f363 02c3 	bfi	r2, r3, #3, #1
		ept->flags.bits.is_stalled = 0;
    e0da:	74c2      	strb	r2, [r0, #19]
    e0dc:	e7d1      	b.n	e082 <_usb_d_dev_ep_stall+0x4a>
    e0de:	f36f 02c3 	bfc	r2, #3, #1
    e0e2:	e7fa      	b.n	e0da <_usb_d_dev_ep_stall+0xa2>
    e0e4:	015b      	lsls	r3, r3, #5
    e0e6:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
    e0ea:	f503 7380 	add.w	r3, r3, #256	; 0x100
    e0ee:	799b      	ldrb	r3, [r3, #6]
	return (hri_usbendpoint_read_EPSTATUS_reg(hw, epn) & (USB_DEVICE_EPSTATUS_STALLRQ0 << bank_n));
    e0f0:	4213      	tst	r3, r2
    e0f2:	bf14      	ite	ne
    e0f4:	2001      	movne	r0, #1
    e0f6:	2000      	moveq	r0, #0
    e0f8:	e7c4      	b.n	e084 <_usb_d_dev_ep_stall+0x4c>
		return -USB_ERR_PARAM;
    e0fa:	f06f 0011 	mvn.w	r0, #17
    e0fe:	e7c1      	b.n	e084 <_usb_d_dev_ep_stall+0x4c>
    e100:	0000d4a9 	.word	0x0000d4a9

0000e104 <_usb_d_dev_ep_read_req>:

int32_t _usb_d_dev_ep_read_req(const uint8_t ep, uint8_t *req_buf)
{
    e104:	b570      	push	{r4, r5, r6, lr}
	uint8_t            epn   = USB_EP_GET_N(ep);
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    e106:	4b13      	ldr	r3, [pc, #76]	; (e154 <_usb_d_dev_ep_read_req+0x50>)
	uint8_t            epn   = USB_EP_GET_N(ep);
    e108:	f000 060f 	and.w	r6, r0, #15
	UsbDeviceDescBank *bank  = prvt_inst.desc_table[epn].DeviceDescBank;
    e10c:	0172      	lsls	r2, r6, #5
    e10e:	eb03 1046 	add.w	r0, r3, r6, lsl #5
	uint32_t           addr  = bank[0].ADDR.reg;
    e112:	589d      	ldr	r5, [r3, r2]
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    e114:	6844      	ldr	r4, [r0, #4]

	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    e116:	2e05      	cmp	r6, #5
	uint16_t           bytes = bank[0].PCKSIZE.bit.BYTE_COUNT;
    e118:	f3c4 040d 	ubfx	r4, r4, #0, #14
	if (epn > CONF_USB_D_MAX_EP_N || !req_buf) {
    e11c:	d814      	bhi.n	e148 <_usb_d_dev_ep_read_req+0x44>
    e11e:	b199      	cbz	r1, e148 <_usb_d_dev_ep_read_req+0x44>
	return ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPCFG.reg;
    e120:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
    e124:	f892 3100 	ldrb.w	r3, [r2, #256]	; 0x100
		return -USB_ERR_PARAM;
	}
	if (!_usbd_ep_is_ctrl(epn)) {
    e128:	2b11      	cmp	r3, #17
    e12a:	d110      	bne.n	e14e <_usb_d_dev_ep_read_req+0x4a>
	tmp = ((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg;
    e12c:	f892 3107 	ldrb.w	r3, [r2, #263]	; 0x107
		return -USB_ERR_FUNC;
	}
	if (!_usbd_ep_is_setup(epn)) {
    e130:	f013 0010 	ands.w	r0, r3, #16
    e134:	d007      	beq.n	e146 <_usb_d_dev_ep_read_req+0x42>
		return ERR_NONE;
	}
	memcpy(req_buf, (void *)addr, 8);
    e136:	682b      	ldr	r3, [r5, #0]
    e138:	600b      	str	r3, [r1, #0]
    e13a:	686b      	ldr	r3, [r5, #4]
    e13c:	604b      	str	r3, [r1, #4]
	((UsbDevice *)hw)->DeviceEndpoint[submodule_index].EPINTFLAG.reg = mask;
    e13e:	2310      	movs	r3, #16
    e140:	f882 3107 	strb.w	r3, [r2, #263]	; 0x107
	_usbd_ep_ack_setup(epn);

	return bytes;
    e144:	4620      	mov	r0, r4
}
    e146:	bd70      	pop	{r4, r5, r6, pc}
		return -USB_ERR_PARAM;
    e148:	f06f 0011 	mvn.w	r0, #17
    e14c:	e7fb      	b.n	e146 <_usb_d_dev_ep_read_req+0x42>
		return -USB_ERR_FUNC;
    e14e:	f06f 0012 	mvn.w	r0, #18
    e152:	e7f8      	b.n	e146 <_usb_d_dev_ep_read_req+0x42>
    e154:	200087d8 	.word	0x200087d8

0000e158 <_usb_d_dev_ep_trans>:

int32_t _usb_d_dev_ep_trans(const struct usb_d_transfer *trans)
{
    e158:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    e15c:	f890 9008 	ldrb.w	r9, [r0, #8]
	bool                  dir = USB_EP_GET_DIR(trans->ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e160:	4b39      	ldr	r3, [pc, #228]	; (e248 <_usb_d_dev_ep_trans+0xf0>)
	uint8_t               epn = USB_EP_GET_N(trans->ep);
    e162:	f009 050f 	and.w	r5, r9, #15
	bool                  dir = USB_EP_GET_DIR(trans->ep);
    e166:	fa4f f789 	sxtb.w	r7, r9
    e16a:	ea4f 19d9 	mov.w	r9, r9, lsr #7
{
    e16e:	4680      	mov	r8, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e170:	4649      	mov	r1, r9
    e172:	4628      	mov	r0, r5
    e174:	4798      	blx	r3

	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    e176:	8a02      	ldrh	r2, [r0, #16]
	bool     size_n_aligned = (trans->size & size_mask);
    e178:	f8d8 1004 	ldr.w	r1, [r8, #4]
	uint16_t size_mask      = (ept->size == 1023) ? 1023 : (ept->size - 1);
    e17c:	f240 33ff 	movw	r3, #1023	; 0x3ff
    e180:	429a      	cmp	r2, r3
    e182:	bf1a      	itte	ne
    e184:	f102 33ff 	addne.w	r3, r2, #4294967295	; 0xffffffff
    e188:	b29b      	uxthne	r3, r3
    e18a:	4613      	moveq	r3, r2

	bool use_cache = false;

	volatile hal_atomic_t flags;

	if (epn > CONF_USB_D_MAX_EP_N) {
    e18c:	2d05      	cmp	r5, #5
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e18e:	4604      	mov	r4, r0
	bool     size_n_aligned = (trans->size & size_mask);
    e190:	ea03 0601 	and.w	r6, r3, r1
	if (epn > CONF_USB_D_MAX_EP_N) {
    e194:	d828      	bhi.n	e1e8 <_usb_d_dev_ep_trans+0x90>
	 * 1. Buffer not in RAM (cache all).
	 * 2. IN/OUT with unaligned buffer (cache all).
	 * 3. OUT with unaligned packet size (cache last packet).
	 * 4. OUT size < 8 (sub-case for 3).
	 */
	if (!_usb_is_addr4dma(trans->buf, trans->size) || (!_usb_is_aligned(trans->buf))
    e196:	f8d8 5000 	ldr.w	r5, [r8]
    e19a:	f1b5 5f00 	cmp.w	r5, #536870912	; 0x20000000
    e19e:	d30a      	bcc.n	e1b6 <_usb_d_dev_ep_trans+0x5e>
    e1a0:	4b2a      	ldr	r3, [pc, #168]	; (e24c <_usb_d_dev_ep_trans+0xf4>)
    e1a2:	1948      	adds	r0, r1, r5
    e1a4:	4298      	cmp	r0, r3
    e1a6:	d206      	bcs.n	e1b6 <_usb_d_dev_ep_trans+0x5e>
    e1a8:	f015 0503 	ands.w	r5, r5, #3
    e1ac:	d103      	bne.n	e1b6 <_usb_d_dev_ep_trans+0x5e>
	    || (!dir && (trans->size < ept->size))) {
    e1ae:	2f00      	cmp	r7, #0
    e1b0:	db05      	blt.n	e1be <_usb_d_dev_ep_trans+0x66>
    e1b2:	4291      	cmp	r1, r2
    e1b4:	d214      	bcs.n	e1e0 <_usb_d_dev_ep_trans+0x88>
		if (!ept->cache) {
    e1b6:	68e3      	ldr	r3, [r4, #12]
    e1b8:	2b00      	cmp	r3, #0
    e1ba:	d03f      	beq.n	e23c <_usb_d_dev_ep_trans+0xe4>
			return -USB_ERR_FUNC;
		}
		/* Use cache all the time. */
		use_cache = true;
    e1bc:	2501      	movs	r5, #1
		}
		/* Set 'use_cache' on last packet. */
	}

	/* Check halt */
	if (ept->flags.bits.is_stalled) {
    e1be:	7ce3      	ldrb	r3, [r4, #19]
    e1c0:	071b      	lsls	r3, r3, #28
    e1c2:	d43e      	bmi.n	e242 <_usb_d_dev_ep_trans+0xea>
		return USB_HALTED;
	}

	/* Try to start transactions. */

	atomic_enter_critical(&flags);
    e1c4:	4b22      	ldr	r3, [pc, #136]	; (e250 <_usb_d_dev_ep_trans+0xf8>)
    e1c6:	a801      	add	r0, sp, #4
    e1c8:	4798      	blx	r3
	if (_usb_d_dev_ep_is_busy(ept)) {
    e1ca:	7ce3      	ldrb	r3, [r4, #19]
    e1cc:	4a21      	ldr	r2, [pc, #132]	; (e254 <_usb_d_dev_ep_trans+0xfc>)
    e1ce:	f013 0a40 	ands.w	sl, r3, #64	; 0x40
    e1d2:	d00e      	beq.n	e1f2 <_usb_d_dev_ep_trans+0x9a>
		atomic_leave_critical(&flags);
    e1d4:	a801      	add	r0, sp, #4
    e1d6:	4790      	blx	r2
		return USB_BUSY;
    e1d8:	2001      	movs	r0, #1
	} else {
		_usb_d_dev_out_next(ept, false);
	}

	return ERR_NONE;
}
    e1da:	b002      	add	sp, #8
    e1dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (!dir && size_n_aligned) {
    e1e0:	b12e      	cbz	r6, e1ee <_usb_d_dev_ep_trans+0x96>
		if (!ept->cache) {
    e1e2:	68e3      	ldr	r3, [r4, #12]
    e1e4:	2b00      	cmp	r3, #0
    e1e6:	d1ea      	bne.n	e1be <_usb_d_dev_ep_trans+0x66>
		return -USB_ERR_PARAM;
    e1e8:	f06f 0011 	mvn.w	r0, #17
    e1ec:	e7f5      	b.n	e1da <_usb_d_dev_ep_trans+0x82>
	bool use_cache = false;
    e1ee:	4635      	mov	r5, r6
    e1f0:	e7e5      	b.n	e1be <_usb_d_dev_ep_trans+0x66>
	ept->flags.bits.is_busy = 1;
    e1f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    e1f6:	74e3      	strb	r3, [r4, #19]
	atomic_leave_critical(&flags);
    e1f8:	a801      	add	r0, sp, #4
    e1fa:	4790      	blx	r2
	ept->trans_buf   = trans->buf;
    e1fc:	f8d8 3000 	ldr.w	r3, [r8]
    e200:	6023      	str	r3, [r4, #0]
	ept->trans_size  = trans->size;
    e202:	f8d8 3004 	ldr.w	r3, [r8, #4]
	ept->trans_count = 0;
    e206:	e9c4 3a01 	strd	r3, sl, [r4, #4]
	ept->flags.bits.dir       = dir;
    e20a:	7ce3      	ldrb	r3, [r4, #19]
    e20c:	f369 13c7 	bfi	r3, r9, #7, #1
	ept->flags.bits.use_cache = use_cache;
    e210:	f365 1345 	bfi	r3, r5, #5, #1
    e214:	74e3      	strb	r3, [r4, #19]
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    e216:	f898 3009 	ldrb.w	r3, [r8, #9]
    e21a:	b113      	cbz	r3, e222 <_usb_d_dev_ep_trans+0xca>
    e21c:	fab6 f386 	clz	r3, r6
    e220:	095b      	lsrs	r3, r3, #5
    e222:	7ce2      	ldrb	r2, [r4, #19]
	if (dir) {
    e224:	2f00      	cmp	r7, #0
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    e226:	f363 1204 	bfi	r2, r3, #4, #1
		_usb_d_dev_in_next(ept, false);
    e22a:	4620      	mov	r0, r4
    e22c:	bfb4      	ite	lt
    e22e:	4b0a      	ldrlt	r3, [pc, #40]	; (e258 <_usb_d_dev_ep_trans+0x100>)
		_usb_d_dev_out_next(ept, false);
    e230:	4b0a      	ldrge	r3, [pc, #40]	; (e25c <_usb_d_dev_ep_trans+0x104>)
	ept->flags.bits.need_zlp  = (trans->zlp && (!size_n_aligned));
    e232:	74e2      	strb	r2, [r4, #19]
		_usb_d_dev_in_next(ept, false);
    e234:	2100      	movs	r1, #0
		_usb_d_dev_out_next(ept, false);
    e236:	4798      	blx	r3
	return ERR_NONE;
    e238:	2000      	movs	r0, #0
    e23a:	e7ce      	b.n	e1da <_usb_d_dev_ep_trans+0x82>
			return -USB_ERR_FUNC;
    e23c:	f06f 0012 	mvn.w	r0, #18
    e240:	e7cb      	b.n	e1da <_usb_d_dev_ep_trans+0x82>
		return USB_HALTED;
    e242:	2002      	movs	r0, #2
    e244:	e7c9      	b.n	e1da <_usb_d_dev_ep_trans+0x82>
    e246:	bf00      	nop
    e248:	0000d4a9 	.word	0x0000d4a9
    e24c:	20042000 	.word	0x20042000
    e250:	00012485 	.word	0x00012485
    e254:	00012493 	.word	0x00012493
    e258:	0000d729 	.word	0x0000d729
    e25c:	0000d885 	.word	0x0000d885

0000e260 <_usb_d_dev_ep_get_status>:
	}
	_usb_d_dev_trans_stop(ept, dir, USB_TRANS_ABORT);
}

int32_t _usb_d_dev_ep_get_status(const uint8_t ep, struct usb_d_trans_status *stat)
{
    e260:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint8_t               epn = USB_EP_GET_N(ep);
    e262:	f000 040f 	and.w	r4, r0, #15
{
    e266:	460a      	mov	r2, r1
	bool                  dir = USB_EP_GET_DIR(ep);
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e268:	4b19      	ldr	r3, [pc, #100]	; (e2d0 <_usb_d_dev_ep_get_status+0x70>)
    e26a:	09c1      	lsrs	r1, r0, #7
{
    e26c:	4607      	mov	r7, r0
	struct _usb_d_dev_ep *ept = _usb_d_dev_ept(epn, dir);
    e26e:	4620      	mov	r0, r4
    e270:	4798      	blx	r3
	bool                  busy, stall;

	if (epn > CONF_USB_D_MAX_EP_N) {
    e272:	2c05      	cmp	r4, #5
    e274:	d82a      	bhi.n	e2cc <_usb_d_dev_ep_get_status+0x6c>
		return USB_ERR_PARAM;
	}
	busy  = ept->flags.bits.is_busy;
    e276:	7cc5      	ldrb	r5, [r0, #19]
    e278:	f3c5 1180 	ubfx	r1, r5, #6, #1
	stall = ept->flags.bits.is_stalled;
    e27c:	f3c5 06c0 	ubfx	r6, r5, #3, #1
	if (stat) {
    e280:	b1fa      	cbz	r2, e2c2 <_usb_d_dev_ep_get_status+0x62>
		stat->stall = stall;
    e282:	7a53      	ldrb	r3, [r2, #9]
		stat->busy  = busy;
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    e284:	0164      	lsls	r4, r4, #5
		stat->stall = stall;
    e286:	f366 1304 	bfi	r3, r6, #4, #1
		stat->busy  = busy;
    e28a:	f361 0382 	bfi	r3, r1, #2, #1
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    e28e:	f104 4482 	add.w	r4, r4, #1090519040	; 0x41000000
		stat->busy  = busy;
    e292:	7253      	strb	r3, [r2, #9]
		stat->setup = USB->DEVICE.DeviceEndpoint[epn].EPINTFLAG.bit.RXSTP;
    e294:	f894 3107 	ldrb.w	r3, [r4, #263]	; 0x107
    e298:	f3c3 1400 	ubfx	r4, r3, #4, #1
		stat->dir   = ept->flags.bits.dir;
		stat->size  = ept->trans_size;
    e29c:	6843      	ldr	r3, [r0, #4]
    e29e:	6013      	str	r3, [r2, #0]
		stat->count = ept->trans_count;
    e2a0:	6883      	ldr	r3, [r0, #8]
		stat->ep    = ep;
    e2a2:	7217      	strb	r7, [r2, #8]
		stat->count = ept->trans_count;
    e2a4:	6053      	str	r3, [r2, #4]
		stat->xtype = ept->flags.bits.eptype - 1;
    e2a6:	7cc3      	ldrb	r3, [r0, #19]
    e2a8:	7a50      	ldrb	r0, [r2, #9]
    e2aa:	3303      	adds	r3, #3
    e2ac:	f003 0303 	and.w	r3, r3, #3
		stat->dir   = ept->flags.bits.dir;
    e2b0:	09ed      	lsrs	r5, r5, #7
		stat->xtype = ept->flags.bits.eptype - 1;
    e2b2:	ea43 03c4 	orr.w	r3, r3, r4, lsl #3
    e2b6:	ea43 1345 	orr.w	r3, r3, r5, lsl #5
    e2ba:	f020 002b 	bic.w	r0, r0, #43	; 0x2b
    e2be:	4303      	orrs	r3, r0
    e2c0:	7253      	strb	r3, [r2, #9]
		return USB_ERR_PARAM;
    e2c2:	2e00      	cmp	r6, #0
    e2c4:	bf0c      	ite	eq
    e2c6:	4608      	moveq	r0, r1
    e2c8:	2002      	movne	r0, #2
	}
	if (busy) {
		return USB_BUSY;
	}
	return USB_OK;
}
    e2ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return USB_ERR_PARAM;
    e2cc:	2012      	movs	r0, #18
    e2ce:	e7fc      	b.n	e2ca <_usb_d_dev_ep_get_status+0x6a>
    e2d0:	0000d4a9 	.word	0x0000d4a9

0000e2d4 <_usb_d_dev_register_callback>:

void _usb_d_dev_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    e2d4:	4b06      	ldr	r3, [pc, #24]	; (e2f0 <_usb_d_dev_register_callback+0x1c>)
    e2d6:	2900      	cmp	r1, #0
    e2d8:	bf08      	it	eq
    e2da:	4619      	moveq	r1, r3
	if (type == USB_D_CB_EVENT) {
    e2dc:	2801      	cmp	r0, #1
    e2de:	d102      	bne.n	e2e6 <_usb_d_dev_register_callback+0x12>
		dev_inst.callbacks.event = (_usb_d_dev_event_cb_t)f;
    e2e0:	4b04      	ldr	r3, [pc, #16]	; (e2f4 <_usb_d_dev_register_callback+0x20>)
    e2e2:	6059      	str	r1, [r3, #4]
    e2e4:	4770      	bx	lr
	} else if (type == USB_D_CB_SOF) {
    e2e6:	b908      	cbnz	r0, e2ec <_usb_d_dev_register_callback+0x18>
		dev_inst.callbacks.sof = (_usb_d_dev_sof_cb_t)f;
    e2e8:	4b02      	ldr	r3, [pc, #8]	; (e2f4 <_usb_d_dev_register_callback+0x20>)
    e2ea:	6019      	str	r1, [r3, #0]
	}
}
    e2ec:	4770      	bx	lr
    e2ee:	bf00      	nop
    e2f0:	0000d481 	.word	0x0000d481
    e2f4:	200085a8 	.word	0x200085a8

0000e2f8 <_usb_d_dev_register_ep_callback>:

void _usb_d_dev_register_ep_callback(const enum usb_d_dev_ep_cb_type type, const FUNC_PTR func)
{
	FUNC_PTR f = (func == NULL) ? (FUNC_PTR)_dummy_func_no_return : (FUNC_PTR)func;
    e2f8:	4b08      	ldr	r3, [pc, #32]	; (e31c <_usb_d_dev_register_ep_callback+0x24>)
    e2fa:	2900      	cmp	r1, #0
    e2fc:	bf08      	it	eq
    e2fe:	4619      	moveq	r1, r3
	if (type == USB_D_DEV_EP_CB_SETUP) {
    e300:	b910      	cbnz	r0, e308 <_usb_d_dev_register_ep_callback+0x10>
		dev_inst.ep_callbacks.setup = (_usb_d_dev_ep_cb_setup_t)f;
    e302:	4b07      	ldr	r3, [pc, #28]	; (e320 <_usb_d_dev_register_ep_callback+0x28>)
    e304:	6099      	str	r1, [r3, #8]
    e306:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_MORE) {
    e308:	2801      	cmp	r0, #1
    e30a:	d102      	bne.n	e312 <_usb_d_dev_register_ep_callback+0x1a>
		dev_inst.ep_callbacks.more = (_usb_d_dev_ep_cb_more_t)f;
    e30c:	4b04      	ldr	r3, [pc, #16]	; (e320 <_usb_d_dev_register_ep_callback+0x28>)
    e30e:	60d9      	str	r1, [r3, #12]
    e310:	4770      	bx	lr
	} else if (type == USB_D_DEV_EP_CB_DONE) {
    e312:	2802      	cmp	r0, #2
		dev_inst.ep_callbacks.done = (_usb_d_dev_ep_cb_done_t)f;
    e314:	bf04      	itt	eq
    e316:	4b02      	ldreq	r3, [pc, #8]	; (e320 <_usb_d_dev_register_ep_callback+0x28>)
    e318:	6119      	streq	r1, [r3, #16]
	}
}
    e31a:	4770      	bx	lr
    e31c:	0000d481 	.word	0x0000d481
    e320:	200085a8 	.word	0x200085a8

0000e324 <USB_0_Handler>:
 * \brief USB interrupt handler
 */
void USB_0_Handler(void)
{

	_usb_d_dev_handler();
    e324:	4b00      	ldr	r3, [pc, #0]	; (e328 <USB_0_Handler+0x4>)
    e326:	4718      	bx	r3
    e328:	0000da21 	.word	0x0000da21

0000e32c <USB_1_Handler>:
    e32c:	4b00      	ldr	r3, [pc, #0]	; (e330 <USB_1_Handler+0x4>)
    e32e:	4718      	bx	r3
    e330:	0000da21 	.word	0x0000da21

0000e334 <USB_2_Handler>:
    e334:	4b00      	ldr	r3, [pc, #0]	; (e338 <USB_2_Handler+0x4>)
    e336:	4718      	bx	r3
    e338:	0000da21 	.word	0x0000da21

0000e33c <USB_3_Handler>:
    e33c:	4b00      	ldr	r3, [pc, #0]	; (e340 <USB_3_Handler+0x4>)
    e33e:	4718      	bx	r3
    e340:	0000da21 	.word	0x0000da21

0000e344 <_read>:
#include <stdio.h>

int __attribute__((weak)) _read(int file, char *ptr, int len); /* Remove GCC compiler warning */

int __attribute__((weak)) _read(int file, char *ptr, int len)
{
    e344:	b508      	push	{r3, lr}
    e346:	4603      	mov	r3, r0
    e348:	4608      	mov	r0, r1
    e34a:	4611      	mov	r1, r2
	int n = 0;

	if (file != 0) {
    e34c:	b923      	cbnz	r3, e358 <_read+0x14>
		return -1;
	}

	n = stdio_io_read((uint8_t *)ptr, len);
    e34e:	4b04      	ldr	r3, [pc, #16]	; (e360 <_read+0x1c>)
    e350:	4798      	blx	r3
	if (n < 0) {
    e352:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
		return -1;
	}

	return n;
}
    e356:	bd08      	pop	{r3, pc}
		return -1;
    e358:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    e35c:	e7fb      	b.n	e356 <_read+0x12>
    e35e:	bf00      	nop
    e360:	0000c219 	.word	0x0000c219

0000e364 <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue(void)
{
    e364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
	{
		if (xTimerQueue == NULL) {
    e368:	4c0c      	ldr	r4, [pc, #48]	; (e39c <prvCheckForValidListAndQueue+0x38>)
	taskENTER_CRITICAL();
    e36a:	4b0d      	ldr	r3, [pc, #52]	; (e3a0 <prvCheckForValidListAndQueue+0x3c>)
    e36c:	4798      	blx	r3
		if (xTimerQueue == NULL) {
    e36e:	6825      	ldr	r5, [r4, #0]
    e370:	b985      	cbnz	r5, e394 <prvCheckForValidListAndQueue+0x30>
			vListInitialise(&xActiveTimerList1);
    e372:	1d27      	adds	r7, r4, #4
    e374:	f8df 8034 	ldr.w	r8, [pc, #52]	; e3ac <prvCheckForValidListAndQueue+0x48>
    e378:	4638      	mov	r0, r7
			vListInitialise(&xActiveTimerList2);
    e37a:	f104 0618 	add.w	r6, r4, #24
			vListInitialise(&xActiveTimerList1);
    e37e:	47c0      	blx	r8
			vListInitialise(&xActiveTimerList2);
    e380:	4630      	mov	r0, r6
    e382:	47c0      	blx	r8
				                                 &(ucStaticTimerQueueStorage[0]),
				                                 &xStaticTimerQueue);
			}
#else
			{
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    e384:	4b07      	ldr	r3, [pc, #28]	; (e3a4 <prvCheckForValidListAndQueue+0x40>)
    e386:	462a      	mov	r2, r5
    e388:	210c      	movs	r1, #12
    e38a:	2002      	movs	r0, #2
			pxOverflowTimerList = &xActiveTimerList2;
    e38c:	e9c4 760b 	strd	r7, r6, [r4, #44]	; 0x2c
				xTimerQueue = xQueueCreate((UBaseType_t)configTIMER_QUEUE_LENGTH, sizeof(DaemonTaskMessage_t));
    e390:	4798      	blx	r3
    e392:	6020      	str	r0, [r4, #0]
		} else {
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
}
    e394:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	taskEXIT_CRITICAL();
    e398:	4b03      	ldr	r3, [pc, #12]	; (e3a8 <prvCheckForValidListAndQueue+0x44>)
    e39a:	4718      	bx	r3
    e39c:	20008968 	.word	0x20008968
    e3a0:	0000bbb5 	.word	0x0000bbb5
    e3a4:	0000ccf9 	.word	0x0000ccf9
    e3a8:	0000bbf9 	.word	0x0000bbf9
    e3ac:	0000ba5d 	.word	0x0000ba5d

0000e3b0 <prvInsertTimerInActiveList>:
	if (xNextExpiryTime <= xTimeNow) {
    e3b0:	4291      	cmp	r1, r2
{
    e3b2:	b508      	push	{r3, lr}
	listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xNextExpiryTime);
    e3b4:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    e3b6:	6100      	str	r0, [r0, #16]
	if (xNextExpiryTime <= xTimeNow) {
    e3b8:	d80a      	bhi.n	e3d0 <prvInsertTimerInActiveList+0x20>
		if (((TickType_t)(xTimeNow - xCommandTime))
    e3ba:	1ad2      	subs	r2, r2, r3
    e3bc:	6983      	ldr	r3, [r0, #24]
    e3be:	429a      	cmp	r2, r3
    e3c0:	d20e      	bcs.n	e3e0 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxOverflowTimerList, &(pxTimer->xTimerListItem));
    e3c2:	4b08      	ldr	r3, [pc, #32]	; (e3e4 <prvInsertTimerInActiveList+0x34>)
    e3c4:	1d01      	adds	r1, r0, #4
    e3c6:	6b18      	ldr	r0, [r3, #48]	; 0x30
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    e3c8:	4b07      	ldr	r3, [pc, #28]	; (e3e8 <prvInsertTimerInActiveList+0x38>)
    e3ca:	4798      	blx	r3
	BaseType_t xProcessTimerNow = pdFALSE;
    e3cc:	2000      	movs	r0, #0
}
    e3ce:	bd08      	pop	{r3, pc}
		if ((xTimeNow < xCommandTime) && (xNextExpiryTime >= xCommandTime)) {
    e3d0:	429a      	cmp	r2, r3
    e3d2:	d201      	bcs.n	e3d8 <prvInsertTimerInActiveList+0x28>
    e3d4:	4299      	cmp	r1, r3
    e3d6:	d203      	bcs.n	e3e0 <prvInsertTimerInActiveList+0x30>
			vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    e3d8:	4b02      	ldr	r3, [pc, #8]	; (e3e4 <prvInsertTimerInActiveList+0x34>)
    e3da:	1d01      	adds	r1, r0, #4
    e3dc:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
    e3de:	e7f3      	b.n	e3c8 <prvInsertTimerInActiveList+0x18>
			xProcessTimerNow = pdTRUE;
    e3e0:	2001      	movs	r0, #1
	return xProcessTimerNow;
    e3e2:	e7f4      	b.n	e3ce <prvInsertTimerInActiveList+0x1e>
    e3e4:	20008968 	.word	0x20008968
    e3e8:	0000ba91 	.word	0x0000ba91

0000e3ec <xTimerCreateTimerTask>:
	prvCheckForValidListAndQueue();
    e3ec:	4b0e      	ldr	r3, [pc, #56]	; (e428 <xTimerCreateTimerTask+0x3c>)
{
    e3ee:	b513      	push	{r0, r1, r4, lr}
	prvCheckForValidListAndQueue();
    e3f0:	4798      	blx	r3
	if (xTimerQueue != NULL) {
    e3f2:	4b0e      	ldr	r3, [pc, #56]	; (e42c <xTimerCreateTimerTask+0x40>)
    e3f4:	681a      	ldr	r2, [r3, #0]
    e3f6:	b942      	cbnz	r2, e40a <xTimerCreateTimerTask+0x1e>
    e3f8:	f04f 0380 	mov.w	r3, #128	; 0x80
    e3fc:	f383 8811 	msr	BASEPRI, r3
    e400:	f3bf 8f6f 	isb	sy
    e404:	f3bf 8f4f 	dsb	sy
	configASSERT(xReturn);
    e408:	e7fe      	b.n	e408 <xTimerCreateTimerTask+0x1c>
			xReturn = xTaskCreate(prvTimerTask,
    e40a:	3334      	adds	r3, #52	; 0x34
    e40c:	9301      	str	r3, [sp, #4]
    e40e:	2302      	movs	r3, #2
    e410:	9300      	str	r3, [sp, #0]
    e412:	4907      	ldr	r1, [pc, #28]	; (e430 <xTimerCreateTimerTask+0x44>)
    e414:	4807      	ldr	r0, [pc, #28]	; (e434 <xTimerCreateTimerTask+0x48>)
    e416:	4c08      	ldr	r4, [pc, #32]	; (e438 <xTimerCreateTimerTask+0x4c>)
    e418:	2300      	movs	r3, #0
    e41a:	2240      	movs	r2, #64	; 0x40
    e41c:	47a0      	blx	r4
	configASSERT(xReturn);
    e41e:	2800      	cmp	r0, #0
    e420:	d0ea      	beq.n	e3f8 <xTimerCreateTimerTask+0xc>
}
    e422:	b002      	add	sp, #8
    e424:	bd10      	pop	{r4, pc}
    e426:	bf00      	nop
    e428:	0000e365 	.word	0x0000e365
    e42c:	20008968 	.word	0x20008968
    e430:	00016f6c 	.word	0x00016f6c
    e434:	0000e51d 	.word	0x0000e51d
    e438:	00012f99 	.word	0x00012f99

0000e43c <xTimerGenericCommand>:
{
    e43c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    e43e:	4616      	mov	r6, r2
	configASSERT(xTimer);
    e440:	4604      	mov	r4, r0
{
    e442:	461a      	mov	r2, r3
	configASSERT(xTimer);
    e444:	b940      	cbnz	r0, e458 <xTimerGenericCommand+0x1c>
    e446:	f04f 0380 	mov.w	r3, #128	; 0x80
    e44a:	f383 8811 	msr	BASEPRI, r3
    e44e:	f3bf 8f6f 	isb	sy
    e452:	f3bf 8f4f 	dsb	sy
    e456:	e7fe      	b.n	e456 <xTimerGenericCommand+0x1a>
	if (xTimerQueue != NULL) {
    e458:	4d0d      	ldr	r5, [pc, #52]	; (e490 <xTimerGenericCommand+0x54>)
    e45a:	6828      	ldr	r0, [r5, #0]
    e45c:	b188      	cbz	r0, e482 <xTimerGenericCommand+0x46>
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    e45e:	2905      	cmp	r1, #5
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    e460:	e9cd 1601 	strd	r1, r6, [sp, #4]
		xMessage.u.xTimerParameters.pxTimer       = (Timer_t *)xTimer;
    e464:	9403      	str	r4, [sp, #12]
		if (xCommandID < tmrFIRST_FROM_ISR_COMMAND) {
    e466:	dc0e      	bgt.n	e486 <xTimerGenericCommand+0x4a>
			if (xTaskGetSchedulerState() == taskSCHEDULER_RUNNING) {
    e468:	4b0a      	ldr	r3, [pc, #40]	; (e494 <xTimerGenericCommand+0x58>)
    e46a:	4c0b      	ldr	r4, [pc, #44]	; (e498 <xTimerGenericCommand+0x5c>)
    e46c:	4798      	blx	r3
    e46e:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, xTicksToWait);
    e470:	f04f 0300 	mov.w	r3, #0
    e474:	bf08      	it	eq
    e476:	9a08      	ldreq	r2, [sp, #32]
				xReturn = xQueueSendToBack(xTimerQueue, &xMessage, tmrNO_DELAY);
    e478:	6828      	ldr	r0, [r5, #0]
    e47a:	bf18      	it	ne
    e47c:	461a      	movne	r2, r3
    e47e:	a901      	add	r1, sp, #4
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    e480:	47a0      	blx	r4
}
    e482:	b004      	add	sp, #16
    e484:	bd70      	pop	{r4, r5, r6, pc}
			xReturn = xQueueSendToBackFromISR(xTimerQueue, &xMessage, pxHigherPriorityTaskWoken);
    e486:	4c05      	ldr	r4, [pc, #20]	; (e49c <xTimerGenericCommand+0x60>)
    e488:	2300      	movs	r3, #0
    e48a:	a901      	add	r1, sp, #4
    e48c:	e7f8      	b.n	e480 <xTimerGenericCommand+0x44>
    e48e:	bf00      	nop
    e490:	20008968 	.word	0x20008968
    e494:	0001368d 	.word	0x0001368d
    e498:	0000cd4d 	.word	0x0000cd4d
    e49c:	0000cef9 	.word	0x0000cef9

0000e4a0 <prvSwitchTimerLists>:
{
    e4a0:	b5f0      	push	{r4, r5, r6, r7, lr}
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    e4a2:	4d1a      	ldr	r5, [pc, #104]	; (e50c <prvSwitchTimerLists+0x6c>)
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    e4a4:	4f1a      	ldr	r7, [pc, #104]	; (e510 <prvSwitchTimerLists+0x70>)
{
    e4a6:	b085      	sub	sp, #20
	while (listLIST_IS_EMPTY(pxCurrentTimerList) == pdFALSE) {
    e4a8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    e4aa:	681a      	ldr	r2, [r3, #0]
    e4ac:	b922      	cbnz	r2, e4b8 <prvSwitchTimerLists+0x18>
	pxCurrentTimerList  = pxOverflowTimerList;
    e4ae:	6b2a      	ldr	r2, [r5, #48]	; 0x30
	pxOverflowTimerList = pxTemp;
    e4b0:	e9c5 230b 	strd	r2, r3, [r5, #44]	; 0x2c
}
    e4b4:	b005      	add	sp, #20
    e4b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    e4b8:	68db      	ldr	r3, [r3, #12]
		pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    e4ba:	68dc      	ldr	r4, [r3, #12]
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    e4bc:	681e      	ldr	r6, [r3, #0]
		(void)uxListRemove(&(pxTimer->xTimerListItem));
    e4be:	1d21      	adds	r1, r4, #4
    e4c0:	4608      	mov	r0, r1
    e4c2:	9103      	str	r1, [sp, #12]
    e4c4:	47b8      	blx	r7
		pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    e4c6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e4c8:	4620      	mov	r0, r4
    e4ca:	4798      	blx	r3
		if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    e4cc:	69e3      	ldr	r3, [r4, #28]
    e4ce:	9903      	ldr	r1, [sp, #12]
    e4d0:	2b01      	cmp	r3, #1
    e4d2:	d1e9      	bne.n	e4a8 <prvSwitchTimerLists+0x8>
			xReloadTime = (xNextExpireTime + pxTimer->xTimerPeriodInTicks);
    e4d4:	69a3      	ldr	r3, [r4, #24]
    e4d6:	4433      	add	r3, r6
			if (xReloadTime > xNextExpireTime) {
    e4d8:	429e      	cmp	r6, r3
    e4da:	d205      	bcs.n	e4e8 <prvSwitchTimerLists+0x48>
				listSET_LIST_ITEM_VALUE(&(pxTimer->xTimerListItem), xReloadTime);
    e4dc:	6063      	str	r3, [r4, #4]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    e4de:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
    e4e0:	4b0c      	ldr	r3, [pc, #48]	; (e514 <prvSwitchTimerLists+0x74>)
				listSET_LIST_ITEM_OWNER(&(pxTimer->xTimerListItem), pxTimer);
    e4e2:	6124      	str	r4, [r4, #16]
				vListInsert(pxCurrentTimerList, &(pxTimer->xTimerListItem));
    e4e4:	4798      	blx	r3
    e4e6:	e7df      	b.n	e4a8 <prvSwitchTimerLists+0x8>
				    = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    e4e8:	2300      	movs	r3, #0
    e4ea:	4620      	mov	r0, r4
    e4ec:	9300      	str	r3, [sp, #0]
    e4ee:	4c0a      	ldr	r4, [pc, #40]	; (e518 <prvSwitchTimerLists+0x78>)
    e4f0:	4632      	mov	r2, r6
    e4f2:	4619      	mov	r1, r3
    e4f4:	47a0      	blx	r4
				configASSERT(xResult);
    e4f6:	2800      	cmp	r0, #0
    e4f8:	d1d6      	bne.n	e4a8 <prvSwitchTimerLists+0x8>
    e4fa:	f04f 0380 	mov.w	r3, #128	; 0x80
    e4fe:	f383 8811 	msr	BASEPRI, r3
    e502:	f3bf 8f6f 	isb	sy
    e506:	f3bf 8f4f 	dsb	sy
    e50a:	e7fe      	b.n	e50a <prvSwitchTimerLists+0x6a>
    e50c:	20008968 	.word	0x20008968
    e510:	0000babf 	.word	0x0000babf
    e514:	0000ba91 	.word	0x0000ba91
    e518:	0000e43d 	.word	0x0000e43d

0000e51c <prvTimerTask>:
{
    e51c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    e520:	f8df 81c8 	ldr.w	r8, [pc, #456]	; e6ec <prvTimerTask+0x1d0>
{
    e524:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY(pxCurrentTimerList);
    e526:	4c68      	ldr	r4, [pc, #416]	; (e6c8 <prvTimerTask+0x1ac>)
    e528:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e52a:	f8d3 b000 	ldr.w	fp, [r3]
	if (*pxListWasEmpty == pdFALSE) {
    e52e:	4627      	mov	r7, r4
    e530:	f1bb 0f00 	cmp.w	fp, #0
    e534:	d044      	beq.n	e5c0 <prvTimerTask+0xa4>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxCurrentTimerList);
    e536:	68db      	ldr	r3, [r3, #12]
    e538:	f8d3 9000 	ldr.w	r9, [r3]
	vTaskSuspendAll();
    e53c:	4b63      	ldr	r3, [pc, #396]	; (e6cc <prvTimerTask+0x1b0>)
	xTimeNow = xTaskGetTickCount();
    e53e:	4e64      	ldr	r6, [pc, #400]	; (e6d0 <prvTimerTask+0x1b4>)
    e540:	f8df a1ac 	ldr.w	sl, [pc, #428]	; e6f0 <prvTimerTask+0x1d4>
	vTaskSuspendAll();
    e544:	4798      	blx	r3
	xTimeNow = xTaskGetTickCount();
    e546:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    e548:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    e54a:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    e54c:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    e54e:	d239      	bcs.n	e5c4 <prvTimerTask+0xa8>
		prvSwitchTimerLists();
    e550:	4b60      	ldr	r3, [pc, #384]	; (e6d4 <prvTimerTask+0x1b8>)
    e552:	4798      	blx	r3
	xLastTime = xTimeNow;
    e554:	63a5      	str	r5, [r4, #56]	; 0x38
			(void)xTaskResumeAll();
    e556:	47d0      	blx	sl
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    e558:	f8df 9198 	ldr.w	r9, [pc, #408]	; e6f4 <prvTimerTask+0x1d8>
		prvSwitchTimerLists();
    e55c:	f8df a174 	ldr.w	sl, [pc, #372]	; e6d4 <prvTimerTask+0x1b8>
	while (xQueueReceive(xTimerQueue, &xMessage, tmrNO_DELAY)
    e560:	6838      	ldr	r0, [r7, #0]
    e562:	2200      	movs	r2, #0
    e564:	a903      	add	r1, sp, #12
    e566:	47c8      	blx	r9
    e568:	2800      	cmp	r0, #0
    e56a:	d0dc      	beq.n	e526 <prvTimerTask+0xa>
		if (xMessage.xMessageID >= (BaseType_t)0) {
    e56c:	9b03      	ldr	r3, [sp, #12]
    e56e:	2b00      	cmp	r3, #0
    e570:	dbf6      	blt.n	e560 <prvTimerTask+0x44>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    e572:	9c05      	ldr	r4, [sp, #20]
			if (listIS_CONTAINED_WITHIN(NULL, &(pxTimer->xTimerListItem))
    e574:	6963      	ldr	r3, [r4, #20]
    e576:	b10b      	cbz	r3, e57c <prvTimerTask+0x60>
				(void)uxListRemove(&(pxTimer->xTimerListItem));
    e578:	1d20      	adds	r0, r4, #4
    e57a:	47c0      	blx	r8
	xTimeNow = xTaskGetTickCount();
    e57c:	47b0      	blx	r6
	if (xTimeNow < xLastTime) {
    e57e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    e580:	4298      	cmp	r0, r3
	xTimeNow = xTaskGetTickCount();
    e582:	4605      	mov	r5, r0
	if (xTimeNow < xLastTime) {
    e584:	d200      	bcs.n	e588 <prvTimerTask+0x6c>
		prvSwitchTimerLists();
    e586:	47d0      	blx	sl
	xLastTime = xTimeNow;
    e588:	9b03      	ldr	r3, [sp, #12]
    e58a:	63bd      	str	r5, [r7, #56]	; 0x38
			switch (xMessage.xMessageID) {
    e58c:	2b09      	cmp	r3, #9
    e58e:	d8e7      	bhi.n	e560 <prvTimerTask+0x44>
    e590:	a201      	add	r2, pc, #4	; (adr r2, e598 <prvTimerTask+0x7c>)
    e592:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    e596:	bf00      	nop
    e598:	0000e64d 	.word	0x0000e64d
    e59c:	0000e64d 	.word	0x0000e64d
    e5a0:	0000e64d 	.word	0x0000e64d
    e5a4:	0000e561 	.word	0x0000e561
    e5a8:	0000e699 	.word	0x0000e699
    e5ac:	0000e6bf 	.word	0x0000e6bf
    e5b0:	0000e64d 	.word	0x0000e64d
    e5b4:	0000e64d 	.word	0x0000e64d
    e5b8:	0000e561 	.word	0x0000e561
    e5bc:	0000e699 	.word	0x0000e699
		xNextExpireTime = (TickType_t)0U;
    e5c0:	46d9      	mov	r9, fp
    e5c2:	e7bb      	b.n	e53c <prvTimerTask+0x20>
	xLastTime = xTimeNow;
    e5c4:	63a0      	str	r0, [r4, #56]	; 0x38
			if ((xListWasEmpty == pdFALSE) && (xNextExpireTime <= xTimeNow)) {
    e5c6:	f1bb 0f00 	cmp.w	fp, #0
    e5ca:	d027      	beq.n	e61c <prvTimerTask+0x100>
    e5cc:	4581      	cmp	r9, r0
    e5ce:	d83b      	bhi.n	e648 <prvTimerTask+0x12c>
				(void)xTaskResumeAll();
    e5d0:	47d0      	blx	sl
	Timer_t *const pxTimer = (Timer_t *)listGET_OWNER_OF_HEAD_ENTRY(pxCurrentTimerList);
    e5d2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    e5d4:	68db      	ldr	r3, [r3, #12]
    e5d6:	68dc      	ldr	r4, [r3, #12]
	(void)uxListRemove(&(pxTimer->xTimerListItem));
    e5d8:	1d20      	adds	r0, r4, #4
    e5da:	47c0      	blx	r8
	if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    e5dc:	69e3      	ldr	r3, [r4, #28]
    e5de:	2b01      	cmp	r3, #1
    e5e0:	d118      	bne.n	e614 <prvTimerTask+0xf8>
		if (prvInsertTimerInActiveList(
    e5e2:	69a1      	ldr	r1, [r4, #24]
    e5e4:	462a      	mov	r2, r5
    e5e6:	464b      	mov	r3, r9
    e5e8:	4d3b      	ldr	r5, [pc, #236]	; (e6d8 <prvTimerTask+0x1bc>)
    e5ea:	4449      	add	r1, r9
    e5ec:	4620      	mov	r0, r4
    e5ee:	47a8      	blx	r5
    e5f0:	b180      	cbz	r0, e614 <prvTimerTask+0xf8>
			xResult = xTimerGenericCommand(pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY);
    e5f2:	2300      	movs	r3, #0
    e5f4:	4d39      	ldr	r5, [pc, #228]	; (e6dc <prvTimerTask+0x1c0>)
    e5f6:	9300      	str	r3, [sp, #0]
    e5f8:	464a      	mov	r2, r9
    e5fa:	4619      	mov	r1, r3
    e5fc:	4620      	mov	r0, r4
    e5fe:	47a8      	blx	r5
			configASSERT(xResult);
    e600:	b940      	cbnz	r0, e614 <prvTimerTask+0xf8>
    e602:	f04f 0380 	mov.w	r3, #128	; 0x80
    e606:	f383 8811 	msr	BASEPRI, r3
    e60a:	f3bf 8f6f 	isb	sy
    e60e:	f3bf 8f4f 	dsb	sy
    e612:	e7fe      	b.n	e612 <prvTimerTask+0xf6>
	pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    e614:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e616:	4620      	mov	r0, r4
    e618:	4798      	blx	r3
}
    e61a:	e79d      	b.n	e558 <prvTimerTask+0x3c>
					xListWasEmpty = listLIST_IS_EMPTY(pxOverflowTimerList);
    e61c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    e61e:	681a      	ldr	r2, [r3, #0]
    e620:	fab2 f282 	clz	r2, r2
    e624:	0952      	lsrs	r2, r2, #5
				vQueueWaitForMessageRestricted(xTimerQueue, (xNextExpireTime - xTimeNow), xListWasEmpty);
    e626:	6820      	ldr	r0, [r4, #0]
    e628:	4b2d      	ldr	r3, [pc, #180]	; (e6e0 <prvTimerTask+0x1c4>)
    e62a:	eba9 0105 	sub.w	r1, r9, r5
    e62e:	4798      	blx	r3
				if (xTaskResumeAll() == pdFALSE) {
    e630:	47d0      	blx	sl
    e632:	2800      	cmp	r0, #0
    e634:	d190      	bne.n	e558 <prvTimerTask+0x3c>
					portYIELD_WITHIN_API();
    e636:	4b2b      	ldr	r3, [pc, #172]	; (e6e4 <prvTimerTask+0x1c8>)
    e638:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    e63c:	601a      	str	r2, [r3, #0]
    e63e:	f3bf 8f4f 	dsb	sy
    e642:	f3bf 8f6f 	isb	sy
    e646:	e787      	b.n	e558 <prvTimerTask+0x3c>
    e648:	2200      	movs	r2, #0
    e64a:	e7ec      	b.n	e626 <prvTimerTask+0x10a>
				if (prvInsertTimerInActiveList(pxTimer,
    e64c:	69a1      	ldr	r1, [r4, #24]
    e64e:	9b04      	ldr	r3, [sp, #16]
    e650:	462a      	mov	r2, r5
    e652:	4419      	add	r1, r3
    e654:	4d20      	ldr	r5, [pc, #128]	; (e6d8 <prvTimerTask+0x1bc>)
    e656:	4620      	mov	r0, r4
    e658:	47a8      	blx	r5
    e65a:	2800      	cmp	r0, #0
    e65c:	f43f af7e 	beq.w	e55c <prvTimerTask+0x40>
					pxTimer->pxCallbackFunction((TimerHandle_t)pxTimer);
    e660:	6a63      	ldr	r3, [r4, #36]	; 0x24
    e662:	4620      	mov	r0, r4
    e664:	4798      	blx	r3
					if (pxTimer->uxAutoReload == (UBaseType_t)pdTRUE) {
    e666:	69e3      	ldr	r3, [r4, #28]
    e668:	2b01      	cmp	r3, #1
    e66a:	f47f af77 	bne.w	e55c <prvTimerTask+0x40>
						xResult = xTimerGenericCommand(pxTimer,
    e66e:	69a2      	ldr	r2, [r4, #24]
    e670:	9904      	ldr	r1, [sp, #16]
    e672:	2300      	movs	r3, #0
    e674:	440a      	add	r2, r1
    e676:	4620      	mov	r0, r4
    e678:	9300      	str	r3, [sp, #0]
    e67a:	4c18      	ldr	r4, [pc, #96]	; (e6dc <prvTimerTask+0x1c0>)
    e67c:	4619      	mov	r1, r3
    e67e:	47a0      	blx	r4
						configASSERT(xResult);
    e680:	2800      	cmp	r0, #0
    e682:	f47f af6b 	bne.w	e55c <prvTimerTask+0x40>
    e686:	f04f 0380 	mov.w	r3, #128	; 0x80
    e68a:	f383 8811 	msr	BASEPRI, r3
    e68e:	f3bf 8f6f 	isb	sy
    e692:	f3bf 8f4f 	dsb	sy
    e696:	e7fe      	b.n	e696 <prvTimerTask+0x17a>
				pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    e698:	9904      	ldr	r1, [sp, #16]
    e69a:	61a1      	str	r1, [r4, #24]
				configASSERT((pxTimer->xTimerPeriodInTicks > 0));
    e69c:	b941      	cbnz	r1, e6b0 <prvTimerTask+0x194>
    e69e:	f04f 0380 	mov.w	r3, #128	; 0x80
    e6a2:	f383 8811 	msr	BASEPRI, r3
    e6a6:	f3bf 8f6f 	isb	sy
    e6aa:	f3bf 8f4f 	dsb	sy
    e6ae:	e7fe      	b.n	e6ae <prvTimerTask+0x192>
				(void)prvInsertTimerInActiveList(
    e6b0:	462b      	mov	r3, r5
    e6b2:	462a      	mov	r2, r5
    e6b4:	4429      	add	r1, r5
    e6b6:	4620      	mov	r0, r4
    e6b8:	4c07      	ldr	r4, [pc, #28]	; (e6d8 <prvTimerTask+0x1bc>)
    e6ba:	47a0      	blx	r4
				break;
    e6bc:	e74e      	b.n	e55c <prvTimerTask+0x40>
				vPortFree(pxTimer);
    e6be:	4b0a      	ldr	r3, [pc, #40]	; (e6e8 <prvTimerTask+0x1cc>)
    e6c0:	4620      	mov	r0, r4
    e6c2:	4798      	blx	r3
			break;
    e6c4:	e74a      	b.n	e55c <prvTimerTask+0x40>
    e6c6:	bf00      	nop
    e6c8:	20008968 	.word	0x20008968
    e6cc:	000131c1 	.word	0x000131c1
    e6d0:	000131d5 	.word	0x000131d5
    e6d4:	0000e4a1 	.word	0x0000e4a1
    e6d8:	0000e3b1 	.word	0x0000e3b1
    e6dc:	0000e43d 	.word	0x0000e43d
    e6e0:	0000d141 	.word	0x0000d141
    e6e4:	e000ed04 	.word	0xe000ed04
    e6e8:	0000c079 	.word	0x0000c079
    e6ec:	0000babf 	.word	0x0000babf
    e6f0:	00013309 	.word	0x00013309
    e6f4:	0000cfd9 	.word	0x0000cfd9

0000e6f8 <delay_init>:
/**
 * \brief Initialize Delay driver
 */
void delay_init(void *const hw)
{
	_delay_init(hardware = hw);
    e6f8:	4b01      	ldr	r3, [pc, #4]	; (e700 <delay_init+0x8>)
    e6fa:	6018      	str	r0, [r3, #0]
    e6fc:	4b01      	ldr	r3, [pc, #4]	; (e704 <delay_init+0xc>)
    e6fe:	4718      	bx	r3
    e700:	200089a4 	.word	0x200089a4
    e704:	000144ad 	.word	0x000144ad

0000e708 <delay_ms>:
/**
 * \brief Perform delay in ms
 */
void delay_ms(const uint16_t ms)
{
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    e708:	4b05      	ldr	r3, [pc, #20]	; (e720 <delay_ms+0x18>)
{
    e70a:	b510      	push	{r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    e70c:	681c      	ldr	r4, [r3, #0]
    e70e:	4b05      	ldr	r3, [pc, #20]	; (e724 <delay_ms+0x1c>)
    e710:	4798      	blx	r3
    e712:	4b05      	ldr	r3, [pc, #20]	; (e728 <delay_ms+0x20>)
    e714:	4601      	mov	r1, r0
    e716:	4620      	mov	r0, r4
}
    e718:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_delay_cycles(hardware, _get_cycles_for_ms(ms));
    e71c:	4718      	bx	r3
    e71e:	bf00      	nop
    e720:	200089a4 	.word	0x200089a4
    e724:	0000c425 	.word	0x0000c425
    e728:	000144c1 	.word	0x000144c1

0000e72c <_init_chip>:
	((Nvmctrl *)hw)->CTRLA.reg |= NVMCTRL_CTRLA_RWS(mask);
    e72c:	4a0e      	ldr	r2, [pc, #56]	; (e768 <_init_chip+0x3c>)
    e72e:	8813      	ldrh	r3, [r2, #0]
    e730:	b29b      	uxth	r3, r3
    e732:	f443 63a0 	orr.w	r3, r3, #1280	; 0x500

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
    e736:	b510      	push	{r4, lr}
    e738:	8013      	strh	r3, [r2, #0]
	hri_nvmctrl_set_CTRLA_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
    e73a:	4b0c      	ldr	r3, [pc, #48]	; (e76c <_init_chip+0x40>)
	_oscctrl_init_sources();
	_mclk_init();
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    e73c:	4c0c      	ldr	r4, [pc, #48]	; (e770 <_init_chip+0x44>)
	_osc32kctrl_init_sources();
    e73e:	4798      	blx	r3
	_oscctrl_init_sources();
    e740:	4b0c      	ldr	r3, [pc, #48]	; (e774 <_init_chip+0x48>)
    e742:	4798      	blx	r3
	_mclk_init();
    e744:	4b0c      	ldr	r3, [pc, #48]	; (e778 <_init_chip+0x4c>)
    e746:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
    e748:	2004      	movs	r0, #4
    e74a:	47a0      	blx	r4
#endif
	_oscctrl_init_referenced_generators();
    e74c:	4b0b      	ldr	r3, [pc, #44]	; (e77c <_init_chip+0x50>)
    e74e:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
    e750:	f640 70fb 	movw	r0, #4091	; 0xffb
    e754:	47a0      	blx	r4
}

static inline void hri_mclk_set_AHBMASK_DMAC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_DMAC;
    e756:	4a0a      	ldr	r2, [pc, #40]	; (e780 <_init_chip+0x54>)
    e758:	6913      	ldr	r3, [r2, #16]
    e75a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    e75e:	6113      	str	r3, [r2, #16]
#endif

#if CONF_CMCC_ENABLE
	cache_init();
#endif
}
    e760:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_dma_init();
    e764:	4b07      	ldr	r3, [pc, #28]	; (e784 <_init_chip+0x58>)
    e766:	4718      	bx	r3
    e768:	41004000 	.word	0x41004000
    e76c:	000101f1 	.word	0x000101f1
    e770:	0000f5f1 	.word	0x0000f5f1
    e774:	0000ef99 	.word	0x0000ef99
    e778:	0000f5d1 	.word	0x0000f5d1
    e77c:	0000ef9d 	.word	0x0000ef9d
    e780:	40000800 	.word	0x40000800
    e784:	0000ea0d 	.word	0x0000ea0d

0000e788 <RAMECC_Handler>:
	return tmp;
}

static inline hri_ramecc_intflag_reg_t hri_ramecc_read_INTFLAG_reg(const void *const hw)
{
	return ((Ramecc *)hw)->INTFLAG.reg;
    e788:	4a0b      	ldr	r2, [pc, #44]	; (e7b8 <RAMECC_Handler+0x30>)
    e78a:	7893      	ldrb	r3, [r2, #2]

/**
 * \internal RAMECC interrupt handler
 */
void RAMECC_Handler(void)
{
    e78c:	b082      	sub	sp, #8
    e78e:	b2db      	uxtb	r3, r3
	struct _ramecc_device *dev      = (struct _ramecc_device *)&device;
	volatile uint32_t      int_mask = hri_ramecc_read_INTFLAG_reg(RAMECC);
    e790:	9301      	str	r3, [sp, #4]

	if (int_mask & RAMECC_INTFLAG_DUALE && dev->ramecc_cb.dual_bit_err) {
    e792:	9b01      	ldr	r3, [sp, #4]
    e794:	0799      	lsls	r1, r3, #30
    e796:	d505      	bpl.n	e7a4 <RAMECC_Handler+0x1c>
    e798:	4b08      	ldr	r3, [pc, #32]	; (e7bc <RAMECC_Handler+0x34>)
    e79a:	681b      	ldr	r3, [r3, #0]
    e79c:	b113      	cbz	r3, e7a4 <RAMECC_Handler+0x1c>
	return tmp;
}

static inline hri_ramecc_erraddr_reg_t hri_ramecc_read_ERRADDR_reg(const void *const hw)
{
	return ((Ramecc *)hw)->ERRADDR.reg;
    e79e:	6850      	ldr	r0, [r2, #4]
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
	} else {
		return;
	}
}
    e7a0:	b002      	add	sp, #8
		dev->ramecc_cb.single_bit_err((uint32_t)hri_ramecc_read_ERRADDR_reg(RAMECC));
    e7a2:	4718      	bx	r3
	} else if (int_mask & RAMECC_INTFLAG_SINGLEE && dev->ramecc_cb.single_bit_err) {
    e7a4:	9b01      	ldr	r3, [sp, #4]
    e7a6:	07db      	lsls	r3, r3, #31
    e7a8:	d504      	bpl.n	e7b4 <RAMECC_Handler+0x2c>
    e7aa:	4b04      	ldr	r3, [pc, #16]	; (e7bc <RAMECC_Handler+0x34>)
    e7ac:	685b      	ldr	r3, [r3, #4]
    e7ae:	b10b      	cbz	r3, e7b4 <RAMECC_Handler+0x2c>
    e7b0:	4a01      	ldr	r2, [pc, #4]	; (e7b8 <RAMECC_Handler+0x30>)
    e7b2:	e7f4      	b.n	e79e <RAMECC_Handler+0x16>
}
    e7b4:	b002      	add	sp, #8
    e7b6:	4770      	bx	lr
    e7b8:	41020000 	.word	0x41020000
    e7bc:	2001c858 	.word	0x2001c858

0000e7c0 <hid_mouse_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_mouse_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    e7c0:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_mouse_funcd.func_iface)) {
    e7c2:	780a      	ldrb	r2, [r1, #0]
    e7c4:	2a81      	cmp	r2, #129	; 0x81
    e7c6:	d11c      	bne.n	e802 <hid_mouse_req+0x42>
    e7c8:	784b      	ldrb	r3, [r1, #1]
    e7ca:	2b06      	cmp	r3, #6
    e7cc:	d131      	bne.n	e832 <hid_mouse_req+0x72>
    e7ce:	4a1a      	ldr	r2, [pc, #104]	; (e838 <hid_mouse_req+0x78>)
    e7d0:	888c      	ldrh	r4, [r1, #4]
    e7d2:	7a13      	ldrb	r3, [r2, #8]
    e7d4:	429c      	cmp	r4, r3
    e7d6:	d12c      	bne.n	e832 <hid_mouse_req+0x72>
	switch (req->wValue >> 8) {
    e7d8:	884b      	ldrh	r3, [r1, #2]
    e7da:	0a1b      	lsrs	r3, r3, #8
    e7dc:	2b21      	cmp	r3, #33	; 0x21
    e7de:	d005      	beq.n	e7ec <hid_mouse_req+0x2c>
    e7e0:	2b22      	cmp	r3, #34	; 0x22
    e7e2:	d00a      	beq.n	e7fa <hid_mouse_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
			switch (req->bRequest) {
    e7e4:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    e7e8:	bc30      	pop	{r4, r5}
    e7ea:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_mouse_funcd.hid_desc, _hiddf_mouse_funcd.hid_desc[0], false);
    e7ec:	6811      	ldr	r1, [r2, #0]
    e7ee:	780a      	ldrb	r2, [r1, #0]
    e7f0:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    e7f2:	4c12      	ldr	r4, [pc, #72]	; (e83c <hid_mouse_req+0x7c>)
    e7f4:	46a4      	mov	ip, r4
}
    e7f6:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    e7f8:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)mouse_report_desc, MOUSE_REPORT_DESC_LEN, false);
    e7fa:	4911      	ldr	r1, [pc, #68]	; (e840 <hid_mouse_req+0x80>)
    e7fc:	2300      	movs	r3, #0
    e7fe:	2234      	movs	r2, #52	; 0x34
    e800:	e7f7      	b.n	e7f2 <hid_mouse_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    e802:	f3c2 1241 	ubfx	r2, r2, #5, #2
    e806:	2a01      	cmp	r2, #1
    e808:	d113      	bne.n	e832 <hid_mouse_req+0x72>
		if (req->wIndex == _hiddf_mouse_funcd.func_iface) {
    e80a:	4c0b      	ldr	r4, [pc, #44]	; (e838 <hid_mouse_req+0x78>)
    e80c:	888d      	ldrh	r5, [r1, #4]
    e80e:	7a23      	ldrb	r3, [r4, #8]
    e810:	429d      	cmp	r5, r3
    e812:	d10e      	bne.n	e832 <hid_mouse_req+0x72>
			switch (req->bRequest) {
    e814:	784b      	ldrb	r3, [r1, #1]
    e816:	2b03      	cmp	r3, #3
    e818:	d007      	beq.n	e82a <hid_mouse_req+0x6a>
    e81a:	2b0b      	cmp	r3, #11
    e81c:	d1e2      	bne.n	e7e4 <hid_mouse_req+0x24>
				_hiddf_mouse_funcd.protocol = req->wValue;
    e81e:	884b      	ldrh	r3, [r1, #2]
    e820:	72a3      	strb	r3, [r4, #10]
				return usbdc_xfer(ep, NULL, 0, 0);
    e822:	2300      	movs	r3, #0
    e824:	461a      	mov	r2, r3
    e826:	4619      	mov	r1, r3
    e828:	e7e3      	b.n	e7f2 <hid_mouse_req+0x32>
				return usbdc_xfer(ep, &_hiddf_mouse_funcd.protocol, 1, 0);
    e82a:	2300      	movs	r3, #0
    e82c:	f104 010a 	add.w	r1, r4, #10
    e830:	e7df      	b.n	e7f2 <hid_mouse_req+0x32>
			return ERR_NOT_FOUND;
    e832:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    e836:	e7d7      	b.n	e7e8 <hid_mouse_req+0x28>
    e838:	200089a8 	.word	0x200089a8
    e83c:	00013c9d 	.word	0x00013c9d
    e840:	00016f74 	.word	0x00016f74

0000e844 <hid_mouse_ctrl>:
	switch (ctrl) {
    e844:	2901      	cmp	r1, #1
{
    e846:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e848:	4614      	mov	r4, r2
	switch (ctrl) {
    e84a:	d03b      	beq.n	e8c4 <hid_mouse_ctrl+0x80>
    e84c:	2902      	cmp	r1, #2
    e84e:	d04f      	beq.n	e8f0 <hid_mouse_ctrl+0xac>
    e850:	2900      	cmp	r1, #0
    e852:	d150      	bne.n	e8f6 <hid_mouse_ctrl+0xb2>
	ifc = desc->sod;
    e854:	6813      	ldr	r3, [r2, #0]
		return hid_mouse_enable(drv, (struct usbd_descriptors *)param);
    e856:	6886      	ldr	r6, [r0, #8]
	if (NULL == ifc) {
    e858:	b91b      	cbnz	r3, e862 <hid_mouse_ctrl+0x1e>
		return ERR_NOT_FOUND;
    e85a:	f06f 0409 	mvn.w	r4, #9
}
    e85e:	4620      	mov	r0, r4
    e860:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e862:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    e864:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    e866:	2903      	cmp	r1, #3
    e868:	d1f7      	bne.n	e85a <hid_mouse_ctrl+0x16>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    e86a:	7a31      	ldrb	r1, [r6, #8]
    e86c:	428a      	cmp	r2, r1
    e86e:	d045      	beq.n	e8fc <hid_mouse_ctrl+0xb8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    e870:	29ff      	cmp	r1, #255	; 0xff
    e872:	d146      	bne.n	e902 <hid_mouse_ctrl+0xbe>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    e874:	7232      	strb	r2, [r6, #8]
    e876:	7818      	ldrb	r0, [r3, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e878:	6861      	ldr	r1, [r4, #4]
    e87a:	4f26      	ldr	r7, [pc, #152]	; (e914 <hid_mouse_ctrl+0xd0>)
    e87c:	2221      	movs	r2, #33	; 0x21
    e87e:	4418      	add	r0, r3
    e880:	4b25      	ldr	r3, [pc, #148]	; (e918 <hid_mouse_ctrl+0xd4>)
    e882:	4798      	blx	r3
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e884:	6823      	ldr	r3, [r4, #0]
	_hiddf_mouse_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    e886:	6038      	str	r0, [r7, #0]
    e888:	7818      	ldrb	r0, [r3, #0]
	ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    e88a:	6861      	ldr	r1, [r4, #4]
    e88c:	4418      	add	r0, r3
    e88e:	4b23      	ldr	r3, [pc, #140]	; (e91c <hid_mouse_ctrl+0xd8>)
    e890:	4798      	blx	r3
	desc->sod = ep;
    e892:	6020      	str	r0, [r4, #0]
	if (NULL != ep) {
    e894:	2800      	cmp	r0, #0
    e896:	d0e0      	beq.n	e85a <hid_mouse_ctrl+0x16>
	return (ptr[0] + (ptr[1] << 8));
    e898:	7943      	ldrb	r3, [r0, #5]
    e89a:	7902      	ldrb	r2, [r0, #4]
		ep_desc.bEndpointAddress = ep[2];
    e89c:	7885      	ldrb	r5, [r0, #2]
		if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    e89e:	78c1      	ldrb	r1, [r0, #3]
    e8a0:	eb02 2203 	add.w	r2, r2, r3, lsl #8
    e8a4:	b292      	uxth	r2, r2
    e8a6:	4b1e      	ldr	r3, [pc, #120]	; (e920 <hid_mouse_ctrl+0xdc>)
    e8a8:	4628      	mov	r0, r5
    e8aa:	4798      	blx	r3
    e8ac:	4604      	mov	r4, r0
    e8ae:	bb58      	cbnz	r0, e908 <hid_mouse_ctrl+0xc4>
		if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    e8b0:	062b      	lsls	r3, r5, #24
    e8b2:	d52c      	bpl.n	e90e <hid_mouse_ctrl+0xca>
			usb_d_ep_enable(func_data->func_ep_in);
    e8b4:	4b1b      	ldr	r3, [pc, #108]	; (e924 <hid_mouse_ctrl+0xe0>)
			func_data->func_ep_in = ep_desc.bEndpointAddress;
    e8b6:	7275      	strb	r5, [r6, #9]
			usb_d_ep_enable(func_data->func_ep_in);
    e8b8:	4628      	mov	r0, r5
    e8ba:	4798      	blx	r3
	_hiddf_mouse_funcd.protocol = 1;
    e8bc:	f240 1301 	movw	r3, #257	; 0x101
    e8c0:	817b      	strh	r3, [r7, #10]
	return ERR_NONE;
    e8c2:	e7cc      	b.n	e85e <hid_mouse_ctrl+0x1a>
		return hid_mouse_disable(drv, (struct usbd_descriptors *)param);
    e8c4:	6885      	ldr	r5, [r0, #8]
	if (desc) {
    e8c6:	b11a      	cbz	r2, e8d0 <hid_mouse_ctrl+0x8c>
		ifc_desc.bInterfaceClass = desc->sod[5];
    e8c8:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    e8ca:	795b      	ldrb	r3, [r3, #5]
    e8cc:	2b03      	cmp	r3, #3
    e8ce:	d1c4      	bne.n	e85a <hid_mouse_ctrl+0x16>
	if (func_data->func_iface != 0xFF) {
    e8d0:	7a2b      	ldrb	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    e8d2:	7a68      	ldrb	r0, [r5, #9]
	if (func_data->func_iface != 0xFF) {
    e8d4:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    e8d6:	bf1c      	itt	ne
    e8d8:	23ff      	movne	r3, #255	; 0xff
    e8da:	722b      	strbne	r3, [r5, #8]
	if (func_data->func_ep_in != 0xFF) {
    e8dc:	28ff      	cmp	r0, #255	; 0xff
    e8de:	d003      	beq.n	e8e8 <hid_mouse_ctrl+0xa4>
		usb_d_ep_deinit(func_data->func_ep_in);
    e8e0:	4b11      	ldr	r3, [pc, #68]	; (e928 <hid_mouse_ctrl+0xe4>)
    e8e2:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    e8e4:	23ff      	movs	r3, #255	; 0xff
    e8e6:	726b      	strb	r3, [r5, #9]
	_hiddf_mouse_funcd.enabled = false;
    e8e8:	4b0a      	ldr	r3, [pc, #40]	; (e914 <hid_mouse_ctrl+0xd0>)
    e8ea:	2400      	movs	r4, #0
    e8ec:	72dc      	strb	r4, [r3, #11]
	return ERR_NONE;
    e8ee:	e7b6      	b.n	e85e <hid_mouse_ctrl+0x1a>
		return ERR_UNSUPPORTED_OP;
    e8f0:	f06f 041a 	mvn.w	r4, #26
    e8f4:	e7b3      	b.n	e85e <hid_mouse_ctrl+0x1a>
	switch (ctrl) {
    e8f6:	f06f 040c 	mvn.w	r4, #12
    e8fa:	e7b0      	b.n	e85e <hid_mouse_ctrl+0x1a>
			return ERR_ALREADY_INITIALIZED;
    e8fc:	f06f 0411 	mvn.w	r4, #17
    e900:	e7ad      	b.n	e85e <hid_mouse_ctrl+0x1a>
			return ERR_NO_RESOURCE;
    e902:	f06f 041b 	mvn.w	r4, #27
    e906:	e7aa      	b.n	e85e <hid_mouse_ctrl+0x1a>
			return ERR_NOT_INITIALIZED;
    e908:	f06f 0413 	mvn.w	r4, #19
    e90c:	e7a7      	b.n	e85e <hid_mouse_ctrl+0x1a>
			return ERR_INVALID_DATA;
    e90e:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    e912:	e7a4      	b.n	e85e <hid_mouse_ctrl+0x1a>
    e914:	200089a8 	.word	0x200089a8
    e918:	0000c14d 	.word	0x0000c14d
    e91c:	0000c167 	.word	0x0000c167
    e920:	0000fe9d 	.word	0x0000fe9d
    e924:	0000ff2d 	.word	0x0000ff2d
    e928:	0000ff01 	.word	0x0000ff01

0000e92c <hiddf_mouse_init>:

/**
 * \brief Initialize the USB HID Mouse Function Driver
 */
int32_t hiddf_mouse_init(void)
{
    e92c:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    e92e:	4b0a      	ldr	r3, [pc, #40]	; (e958 <hiddf_mouse_init+0x2c>)
    e930:	4798      	blx	r3
    e932:	2801      	cmp	r0, #1
    e934:	d80c      	bhi.n	e950 <hiddf_mouse_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_mouse.ctrl      = hid_mouse_ctrl;
    e936:	4809      	ldr	r0, [pc, #36]	; (e95c <hiddf_mouse_init+0x30>)
    e938:	4b09      	ldr	r3, [pc, #36]	; (e960 <hiddf_mouse_init+0x34>)
	_hiddf_mouse.func_data = &_hiddf_mouse_funcd;
    e93a:	e9c0 3004 	strd	r3, r0, [r0, #16]

	usbdc_register_function(&_hiddf_mouse);
    e93e:	4b09      	ldr	r3, [pc, #36]	; (e964 <hiddf_mouse_init+0x38>)
    e940:	300c      	adds	r0, #12
    e942:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_mouse_req_h);
    e944:	2001      	movs	r0, #1
    e946:	4908      	ldr	r1, [pc, #32]	; (e968 <hiddf_mouse_init+0x3c>)
    e948:	4b08      	ldr	r3, [pc, #32]	; (e96c <hiddf_mouse_init+0x40>)
    e94a:	4798      	blx	r3
	return ERR_NONE;
    e94c:	2000      	movs	r0, #0
}
    e94e:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    e950:	f06f 0010 	mvn.w	r0, #16
    e954:	e7fb      	b.n	e94e <hiddf_mouse_init+0x22>
    e956:	bf00      	nop
    e958:	000140d5 	.word	0x000140d5
    e95c:	200089a8 	.word	0x200089a8
    e960:	0000e845 	.word	0x0000e845
    e964:	0001407d 	.word	0x0001407d
    e968:	200004fc 	.word	0x200004fc
    e96c:	00013ff5 	.word	0x00013ff5

0000e970 <hiddf_mouse_move>:
 * \param pos     Signed value to move
 * \param type    HID mouse class pointer move type
 * \return Operation status.
 */
int32_t hiddf_mouse_move(int8_t pos, enum hiddf_mouse_move_type type)
{
    e970:	b410      	push	{r4}

	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    e972:	4c0e      	ldr	r4, [pc, #56]	; (e9ac <hiddf_mouse_move+0x3c>)
    e974:	2300      	movs	r3, #0

	if (type == HID_MOUSE_X_AXIS_MV) {
    e976:	2901      	cmp	r1, #1
	_hiddf_mouse_funcd.mouse_report.u32 = 0;
    e978:	6063      	str	r3, [r4, #4]
	if (type == HID_MOUSE_X_AXIS_MV) {
    e97a:	d109      	bne.n	e990 <hiddf_mouse_move+0x20>
		_hiddf_mouse_funcd.mouse_report.bytes.x_axis_var = pos;
    e97c:	7160      	strb	r0, [r4, #5]
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
	} else {
		return ERR_INVALID_ARG;
	}

	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e97e:	7a60      	ldrb	r0, [r4, #9]
    e980:	4c0b      	ldr	r4, [pc, #44]	; (e9b0 <hiddf_mouse_move+0x40>)
    e982:	490c      	ldr	r1, [pc, #48]	; (e9b4 <hiddf_mouse_move+0x44>)
    e984:	46a4      	mov	ip, r4
    e986:	2300      	movs	r3, #0
}
    e988:	f85d 4b04 	ldr.w	r4, [sp], #4
	return usbdc_xfer(_hiddf_mouse_funcd.func_ep_in, &_hiddf_mouse_funcd.mouse_report.bytes.button_state, 4, false);
    e98c:	2204      	movs	r2, #4
    e98e:	4760      	bx	ip
	} else if (type == HID_MOUSE_Y_AXIS_MV) {
    e990:	2902      	cmp	r1, #2
    e992:	d101      	bne.n	e998 <hiddf_mouse_move+0x28>
		_hiddf_mouse_funcd.mouse_report.bytes.y_axis_var = pos;
    e994:	71a0      	strb	r0, [r4, #6]
    e996:	e7f2      	b.n	e97e <hiddf_mouse_move+0xe>
	} else if (type == HID_MOUSE_SCROLL_MV) {
    e998:	2903      	cmp	r1, #3
    e99a:	d101      	bne.n	e9a0 <hiddf_mouse_move+0x30>
		_hiddf_mouse_funcd.mouse_report.bytes.scroll_var = pos;
    e99c:	71e0      	strb	r0, [r4, #7]
    e99e:	e7ee      	b.n	e97e <hiddf_mouse_move+0xe>
}
    e9a0:	f06f 000c 	mvn.w	r0, #12
    e9a4:	f85d 4b04 	ldr.w	r4, [sp], #4
    e9a8:	4770      	bx	lr
    e9aa:	bf00      	nop
    e9ac:	200089a8 	.word	0x200089a8
    e9b0:	00013c9d 	.word	0x00013c9d
    e9b4:	200089ac 	.word	0x200089ac

0000e9b8 <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
    e9b8:	b900      	cbnz	r0, e9bc <assert+0x4>
		__asm("BKPT #0");
    e9ba:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
    e9bc:	4770      	bx	lr
	...

0000e9c0 <_dmac_handler>:
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e9c0:	4b10      	ldr	r3, [pc, #64]	; (ea04 <_dmac_handler+0x44>)
    e9c2:	8c1a      	ldrh	r2, [r3, #32]
}
/**
 * \internal DMAC interrupt handler
 */
static void _dmac_handler(void)
{
    e9c4:	b430      	push	{r4, r5}
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e9c6:	8c1d      	ldrh	r5, [r3, #32]
	uint8_t               channel      = hri_dmac_get_INTPEND_reg(DMAC, DMAC_INTPEND_ID_Msk);
	struct _dma_resource *tmp_resource = &_resources[channel];
    e9c8:	4c0f      	ldr	r4, [pc, #60]	; (ea08 <_dmac_handler+0x48>)
	tmp &= mask;
    e9ca:	f002 021f 	and.w	r2, r2, #31
    e9ce:	210c      	movs	r1, #12
    e9d0:	4351      	muls	r1, r2

	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e9d2:	05ed      	lsls	r5, r5, #23
	struct _dma_resource *tmp_resource = &_resources[channel];
    e9d4:	eb04 0001 	add.w	r0, r4, r1
	if (hri_dmac_get_INTPEND_TERR_bit(DMAC)) {
    e9d8:	d507      	bpl.n	e9ea <_dmac_handler+0x2a>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TERR;
    e9da:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e9de:	2201      	movs	r2, #1
    e9e0:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		hri_dmac_clear_CHINTFLAG_TERR_bit(DMAC, channel);
		tmp_resource->dma_cb.error(tmp_resource);
    e9e4:	6843      	ldr	r3, [r0, #4]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
		hri_dmac_clear_CHINTFLAG_TCMPL_bit(DMAC, channel);
		tmp_resource->dma_cb.transfer_done(tmp_resource);
	}
}
    e9e6:	bc30      	pop	{r4, r5}
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e9e8:	4718      	bx	r3
	tmp = ((Dmac *)hw)->INTPEND.reg;
    e9ea:	8c1d      	ldrh	r5, [r3, #32]
	} else if (hri_dmac_get_INTPEND_TCMPL_bit(DMAC)) {
    e9ec:	05ad      	lsls	r5, r5, #22
    e9ee:	d506      	bpl.n	e9fe <_dmac_handler+0x3e>
	((Dmac *)hw)->Channel[submodule_index].CHINTFLAG.reg = DMAC_CHINTFLAG_TCMPL;
    e9f0:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    e9f4:	2202      	movs	r2, #2
    e9f6:	f883 204e 	strb.w	r2, [r3, #78]	; 0x4e
		tmp_resource->dma_cb.transfer_done(tmp_resource);
    e9fa:	5863      	ldr	r3, [r4, r1]
    e9fc:	e7f3      	b.n	e9e6 <_dmac_handler+0x26>
}
    e9fe:	bc30      	pop	{r4, r5}
    ea00:	4770      	bx	lr
    ea02:	bf00      	nop
    ea04:	4100a000 	.word	0x4100a000
    ea08:	200089c0 	.word	0x200089c0

0000ea0c <_dma_init>:
	((Dmac *)hw)->CTRL.reg &= ~DMAC_CTRL_DMAENABLE;
    ea0c:	4b3d      	ldr	r3, [pc, #244]	; (eb04 <_dma_init+0xf8>)
    ea0e:	881a      	ldrh	r2, [r3, #0]
    ea10:	f022 0202 	bic.w	r2, r2, #2
    ea14:	0412      	lsls	r2, r2, #16
    ea16:	0c12      	lsrs	r2, r2, #16
{
    ea18:	b570      	push	{r4, r5, r6, lr}
    ea1a:	801a      	strh	r2, [r3, #0]
	((Dmac *)hw)->CRCCTRL.reg &= ~mask;
    ea1c:	885a      	ldrh	r2, [r3, #2]
    ea1e:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
    ea22:	0412      	lsls	r2, r2, #16
    ea24:	0c12      	lsrs	r2, r2, #16
    ea26:	805a      	strh	r2, [r3, #2]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_SWRST;
    ea28:	881a      	ldrh	r2, [r3, #0]
    ea2a:	b292      	uxth	r2, r2
    ea2c:	f042 0201 	orr.w	r2, r2, #1
    ea30:	801a      	strh	r2, [r3, #0]
	tmp = ((Dmac *)hw)->CTRL.reg;
    ea32:	881a      	ldrh	r2, [r3, #0]
	while (hri_dmac_get_CTRL_SWRST_bit(DMAC))
    ea34:	f012 0201 	ands.w	r2, r2, #1
    ea38:	d1fb      	bne.n	ea32 <_dma_init+0x26>
	((Dmac *)hw)->CTRL.reg = data;
    ea3a:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    ea3e:	8019      	strh	r1, [r3, #0]
	tmp = ((Dmac *)hw)->DBGCTRL.reg;
    ea40:	7b59      	ldrb	r1, [r3, #13]
	hri_dmac_write_BASEADDR_reg(DMAC, (uint32_t)_descriptor_section);
    ea42:	4831      	ldr	r0, [pc, #196]	; (eb08 <_dma_init+0xfc>)
	tmp &= ~DMAC_DBGCTRL_DBGRUN;
    ea44:	f001 01fe 	and.w	r1, r1, #254	; 0xfe
	tmp |= value << DMAC_DBGCTRL_DBGRUN_Pos;
    ea48:	f041 0101 	orr.w	r1, r1, #1
	((Dmac *)hw)->DBGCTRL.reg = tmp;
    ea4c:	7359      	strb	r1, [r3, #13]
	hri_dmac_write_WRBADDR_reg(DMAC, (uint32_t)_write_back_section);
    ea4e:	492f      	ldr	r1, [pc, #188]	; (eb0c <_dma_init+0x100>)
	((Dmac *)hw)->PRICTRL0.reg = data;
    ea50:	615a      	str	r2, [r3, #20]
	((Dmac *)hw)->BASEADDR.reg = data;
    ea52:	6358      	str	r0, [r3, #52]	; 0x34
	((Dmac *)hw)->WRBADDR.reg = data;
    ea54:	6399      	str	r1, [r3, #56]	; 0x38
    ea56:	4613      	mov	r3, r2
    ea58:	492d      	ldr	r1, [pc, #180]	; (eb10 <_dma_init+0x104>)
    ea5a:	4602      	mov	r2, r0
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    ea5c:	461d      	mov	r5, r3
		hri_dmac_write_CHCTRLA_reg(DMAC, i, _cfgs[i].ctrla);
    ea5e:	011c      	lsls	r4, r3, #4
    ea60:	f104 4082 	add.w	r0, r4, #1090519040	; 0x41000000
    ea64:	f500 4020 	add.w	r0, r0, #40960	; 0xa000
    ea68:	680e      	ldr	r6, [r1, #0]

static inline void hri_dmac_write_CHCTRLA_reg(const void *const hw, uint8_t submodule_index,
                                              hri_dmac_chctrla_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg = data;
    ea6a:	6406      	str	r6, [r0, #64]	; 0x40
		hri_dmac_write_CHPRILVL_reg(DMAC, i, _cfgs[i].prilvl);
    ea6c:	790e      	ldrb	r6, [r1, #4]

static inline void hri_dmac_write_CHPRILVL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chprilvl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHPRILVL.reg = data;
    ea6e:	f880 6045 	strb.w	r6, [r0, #69]	; 0x45
		hri_dmac_write_CHEVCTRL_reg(DMAC, i, _cfgs[i].evctrl);
    ea72:	794e      	ldrb	r6, [r1, #5]

static inline void hri_dmac_write_CHEVCTRL_reg(const void *const hw, uint8_t submodule_index,
                                               hri_dmac_chevctrl_reg_t data)
{
	DMAC_CRITICAL_SECTION_ENTER();
	((Dmac *)hw)->Channel[submodule_index].CHEVCTRL.reg = data;
    ea74:	f880 6046 	strb.w	r6, [r0, #70]	; 0x46
		hri_dmacdescriptor_write_BTCTRL_reg(&_descriptor_section[i], _cfgs[i].btctrl);
    ea78:	3301      	adds	r3, #1
	((DmacDescriptor *)hw)->BTCTRL.reg = data;
    ea7a:	1910      	adds	r0, r2, r4
    ea7c:	88ce      	ldrh	r6, [r1, #6]
    ea7e:	5316      	strh	r6, [r2, r4]
	for (i = 0; i < DMAC_CH_NUM; i++) {
    ea80:	2b20      	cmp	r3, #32
	((DmacDescriptor *)hw)->DESCADDR.reg = data;
    ea82:	60c5      	str	r5, [r0, #12]
    ea84:	f101 0108 	add.w	r1, r1, #8
    ea88:	d1e9      	bne.n	ea5e <_dma_init+0x52>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    ea8a:	4b22      	ldr	r3, [pc, #136]	; (eb14 <_dma_init+0x108>)
    ea8c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    ea90:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
    ea94:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    ea98:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    ea9c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eaa0:	601a      	str	r2, [r3, #0]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eaa2:	2201      	movs	r2, #1
    eaa4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    eaa8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    eaac:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eab0:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eab4:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eab6:	2202      	movs	r2, #2
    eab8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    eabc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    eac0:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eac4:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eac8:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eaca:	2204      	movs	r2, #4
    eacc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    ead0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    ead4:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    ead8:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eadc:	605a      	str	r2, [r3, #4]
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eade:	2208      	movs	r2, #8
    eae0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
    eae4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    eae8:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eaec:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    eaf0:	605a      	str	r2, [r3, #4]
	((Dmac *)hw)->CTRL.reg |= DMAC_CTRL_DMAENABLE;
    eaf2:	4a04      	ldr	r2, [pc, #16]	; (eb04 <_dma_init+0xf8>)
    eaf4:	8813      	ldrh	r3, [r2, #0]
    eaf6:	b29b      	uxth	r3, r3
    eaf8:	f043 0302 	orr.w	r3, r3, #2
    eafc:	8013      	strh	r3, [r2, #0]
}
    eafe:	2000      	movs	r0, #0
    eb00:	bd70      	pop	{r4, r5, r6, pc}
    eb02:	bf00      	nop
    eb04:	4100a000 	.word	0x4100a000
    eb08:	2001c870 	.word	0x2001c870
    eb0c:	2001ca70 	.word	0x2001ca70
    eb10:	00016fa8 	.word	0x00016fa8
    eb14:	e000e100 	.word	0xe000e100

0000eb18 <_dma_set_irq_state>:
	if (DMA_TRANSFER_COMPLETE_CB == type) {
    eb18:	b939      	cbnz	r1, eb2a <_dma_set_irq_state+0x12>
	if (value == 0x0) {
    eb1a:	4b08      	ldr	r3, [pc, #32]	; (eb3c <_dma_set_irq_state+0x24>)
    eb1c:	0100      	lsls	r0, r0, #4
    eb1e:	2102      	movs	r1, #2
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    eb20:	4418      	add	r0, r3
	if (value == 0x0) {
    eb22:	b93a      	cbnz	r2, eb34 <_dma_set_irq_state+0x1c>
		((Dmac *)hw)->Channel[submodule_index].CHINTENCLR.reg = DMAC_CHINTENSET_TERR;
    eb24:	f880 104c 	strb.w	r1, [r0, #76]	; 0x4c
    eb28:	4770      	bx	lr
	} else if (DMA_TRANSFER_ERROR_CB == type) {
    eb2a:	2901      	cmp	r1, #1
    eb2c:	d104      	bne.n	eb38 <_dma_set_irq_state+0x20>
	if (value == 0x0) {
    eb2e:	4b03      	ldr	r3, [pc, #12]	; (eb3c <_dma_set_irq_state+0x24>)
    eb30:	0100      	lsls	r0, r0, #4
    eb32:	e7f5      	b.n	eb20 <_dma_set_irq_state+0x8>
		((Dmac *)hw)->Channel[submodule_index].CHINTENSET.reg = DMAC_CHINTENSET_TERR;
    eb34:	f880 104d 	strb.w	r1, [r0, #77]	; 0x4d
}
    eb38:	4770      	bx	lr
    eb3a:	bf00      	nop
    eb3c:	4100a000 	.word	0x4100a000

0000eb40 <_dma_set_destination_address>:
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    eb40:	4b02      	ldr	r3, [pc, #8]	; (eb4c <_dma_set_destination_address+0xc>)
    eb42:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    eb46:	6081      	str	r1, [r0, #8]
}
    eb48:	2000      	movs	r0, #0
    eb4a:	4770      	bx	lr
    eb4c:	2001c870 	.word	0x2001c870

0000eb50 <_dma_set_source_address>:
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    eb50:	4b02      	ldr	r3, [pc, #8]	; (eb5c <_dma_set_source_address+0xc>)
    eb52:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    eb56:	6041      	str	r1, [r0, #4]
}
    eb58:	2000      	movs	r0, #0
    eb5a:	4770      	bx	lr
    eb5c:	2001c870 	.word	0x2001c870

0000eb60 <_dma_srcinc_enable>:
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    eb60:	4a05      	ldr	r2, [pc, #20]	; (eb78 <_dma_srcinc_enable+0x18>)
    eb62:	0100      	lsls	r0, r0, #4
    eb64:	5a13      	ldrh	r3, [r2, r0]
    eb66:	b29b      	uxth	r3, r3
	tmp &= ~DMAC_BTCTRL_SRCINC;
    eb68:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
	tmp |= value << DMAC_BTCTRL_SRCINC_Pos;
    eb6c:	ea43 2181 	orr.w	r1, r3, r1, lsl #10
    eb70:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->BTCTRL.reg = tmp;
    eb72:	5211      	strh	r1, [r2, r0]
}
    eb74:	2000      	movs	r0, #0
    eb76:	4770      	bx	lr
    eb78:	2001c870 	.word	0x2001c870

0000eb7c <_dma_set_data_amount>:
	return ((DmacDescriptor *)hw)->DSTADDR.reg;
    eb7c:	4b0f      	ldr	r3, [pc, #60]	; (ebbc <_dma_set_data_amount+0x40>)
{
    eb7e:	b570      	push	{r4, r5, r6, lr}
    eb80:	0104      	lsls	r4, r0, #4
    eb82:	eb03 1000 	add.w	r0, r3, r0, lsl #4
    eb86:	6886      	ldr	r6, [r0, #8]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    eb88:	5b1a      	ldrh	r2, [r3, r4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    eb8a:	5b1d      	ldrh	r5, [r3, r4]
	tmp = (tmp & DMAC_BTCTRL_BEATSIZE_Msk) >> DMAC_BTCTRL_BEATSIZE_Pos;
    eb8c:	f3c2 2201 	ubfx	r2, r2, #8, #2
	if (hri_dmacdescriptor_get_BTCTRL_DSTINC_bit(&_descriptor_section[channel])) {
    eb90:	052d      	lsls	r5, r5, #20
		hri_dmacdescriptor_write_DSTADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    eb92:	bf42      	ittt	mi
    eb94:	fa01 f502 	lslmi.w	r5, r1, r2
    eb98:	19ad      	addmi	r5, r5, r6
	((DmacDescriptor *)hw)->DSTADDR.reg = data;
    eb9a:	6085      	strmi	r5, [r0, #8]
	return ((DmacDescriptor *)hw)->SRCADDR.reg;
    eb9c:	1918      	adds	r0, r3, r4
    eb9e:	6845      	ldr	r5, [r0, #4]
	tmp = ((DmacDescriptor *)hw)->BTCTRL.reg;
    eba0:	5b1e      	ldrh	r6, [r3, r4]
	if (hri_dmacdescriptor_get_BTCTRL_SRCINC_bit(&_descriptor_section[channel])) {
    eba2:	0576      	lsls	r6, r6, #21
		hri_dmacdescriptor_write_SRCADDR_reg(&_descriptor_section[channel], address + amount * (1 << beat_size));
    eba4:	bf48      	it	mi
    eba6:	fa01 f202 	lslmi.w	r2, r1, r2
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    ebaa:	4423      	add	r3, r4
    ebac:	bf48      	it	mi
    ebae:	1952      	addmi	r2, r2, r5
	hri_dmacdescriptor_write_BTCNT_reg(&_descriptor_section[channel], amount);
    ebb0:	b289      	uxth	r1, r1
	((DmacDescriptor *)hw)->SRCADDR.reg = data;
    ebb2:	bf48      	it	mi
    ebb4:	6042      	strmi	r2, [r0, #4]
	((DmacDescriptor *)hw)->BTCNT.reg = data;
    ebb6:	8059      	strh	r1, [r3, #2]
}
    ebb8:	2000      	movs	r0, #0
    ebba:	bd70      	pop	{r4, r5, r6, pc}
    ebbc:	2001c870 	.word	0x2001c870

0000ebc0 <_dma_enable_transaction>:
	((DmacDescriptor *)hw)->BTCTRL.reg |= DMAC_BTCTRL_VALID;
    ebc0:	0102      	lsls	r2, r0, #4
{
    ebc2:	b510      	push	{r4, lr}
    ebc4:	4c0b      	ldr	r4, [pc, #44]	; (ebf4 <_dma_enable_transaction+0x34>)
    ebc6:	5aa3      	ldrh	r3, [r4, r2]
    ebc8:	b29b      	uxth	r3, r3
    ebca:	f043 0301 	orr.w	r3, r3, #1
    ebce:	52a3      	strh	r3, [r4, r2]
	((Dmac *)hw)->Channel[submodule_index].CHCTRLA.reg |= DMAC_CHCTRLA_ENABLE;
    ebd0:	f102 4382 	add.w	r3, r2, #1090519040	; 0x41000000
    ebd4:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
    ebd8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
    ebda:	f042 0202 	orr.w	r2, r2, #2
    ebde:	641a      	str	r2, [r3, #64]	; 0x40
	if (software_trigger) {
    ebe0:	b131      	cbz	r1, ebf0 <_dma_enable_transaction+0x30>
	((Dmac *)hw)->SWTRIGCTRL.reg |= mask;
    ebe2:	4a05      	ldr	r2, [pc, #20]	; (ebf8 <_dma_enable_transaction+0x38>)
		hri_dmac_set_SWTRIGCTRL_reg(DMAC, 1 << channel);
    ebe4:	2301      	movs	r3, #1
    ebe6:	6911      	ldr	r1, [r2, #16]
    ebe8:	fa03 f000 	lsl.w	r0, r3, r0
    ebec:	4308      	orrs	r0, r1
    ebee:	6110      	str	r0, [r2, #16]
}
    ebf0:	2000      	movs	r0, #0
    ebf2:	bd10      	pop	{r4, pc}
    ebf4:	2001c870 	.word	0x2001c870
    ebf8:	4100a000 	.word	0x4100a000

0000ebfc <_dma_get_channel_resource>:
	*resource = &_resources[channel];
    ebfc:	4b03      	ldr	r3, [pc, #12]	; (ec0c <_dma_get_channel_resource+0x10>)
    ebfe:	eb01 0141 	add.w	r1, r1, r1, lsl #1
    ec02:	eb03 0181 	add.w	r1, r3, r1, lsl #2
    ec06:	6001      	str	r1, [r0, #0]
}
    ec08:	2000      	movs	r0, #0
    ec0a:	4770      	bx	lr
    ec0c:	200089c0 	.word	0x200089c0

0000ec10 <DMAC_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void DMAC_0_Handler(void)
{
	_dmac_handler();
    ec10:	4b00      	ldr	r3, [pc, #0]	; (ec14 <DMAC_0_Handler+0x4>)
    ec12:	4718      	bx	r3
    ec14:	0000e9c1 	.word	0x0000e9c1

0000ec18 <DMAC_1_Handler>:
    ec18:	4b00      	ldr	r3, [pc, #0]	; (ec1c <DMAC_1_Handler+0x4>)
    ec1a:	4718      	bx	r3
    ec1c:	0000e9c1 	.word	0x0000e9c1

0000ec20 <DMAC_2_Handler>:
    ec20:	4b00      	ldr	r3, [pc, #0]	; (ec24 <DMAC_2_Handler+0x4>)
    ec22:	4718      	bx	r3
    ec24:	0000e9c1 	.word	0x0000e9c1

0000ec28 <DMAC_3_Handler>:
    ec28:	4b00      	ldr	r3, [pc, #0]	; (ec2c <DMAC_3_Handler+0x4>)
    ec2a:	4718      	bx	r3
    ec2c:	0000e9c1 	.word	0x0000e9c1

0000ec30 <DMAC_4_Handler>:
    ec30:	4b00      	ldr	r3, [pc, #0]	; (ec34 <DMAC_4_Handler+0x4>)
    ec32:	4718      	bx	r3
    ec34:	0000e9c1 	.word	0x0000e9c1

0000ec38 <adc_async_window_threshold_reached>:

static void adc_async_window_threshold_reached(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.monitor) {
    ec38:	6983      	ldr	r3, [r0, #24]
    ec3a:	b103      	cbz	r3, ec3e <adc_async_window_threshold_reached+0x6>
		descr->adc_async_cb.monitor(descr, channel);
    ec3c:	4718      	bx	r3
	}
}
    ec3e:	4770      	bx	lr

0000ec40 <adc_async_error_occured>:

static void adc_async_error_occured(struct _adc_async_device *device, const uint8_t channel)
{
	struct adc_async_descriptor *const descr = CONTAINER_OF(device, struct adc_async_descriptor, device);

	if (descr->adc_async_cb.error) {
    ec40:	69c3      	ldr	r3, [r0, #28]
    ec42:	b103      	cbz	r3, ec46 <adc_async_error_occured+0x6>
		descr->adc_async_cb.error(descr, channel);
    ec44:	4718      	bx	r3
	}
}
    ec46:	4770      	bx	lr

0000ec48 <adc_async_channel_conversion_done>:
{
    ec48:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	uint8_t                              index    = descr->channel_map[channel];
    ec4c:	6a03      	ldr	r3, [r0, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    ec4e:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
    ec52:	5c5c      	ldrb	r4, [r3, r1]
	ringbuffer_put(&descr_ch->convert, data);
    ec54:	f8df a054 	ldr.w	sl, [pc, #84]	; ecac <adc_async_channel_conversion_done+0x64>
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    ec58:	eb04 0444 	add.w	r4, r4, r4, lsl #1
    ec5c:	ea4f 09c4 	mov.w	r9, r4, lsl #3
    ec60:	eb08 04c4 	add.w	r4, r8, r4, lsl #3
	ringbuffer_put(&descr_ch->convert, data);
    ec64:	f104 0b04 	add.w	fp, r4, #4
{
    ec68:	4605      	mov	r5, r0
    ec6a:	460e      	mov	r6, r1
	ringbuffer_put(&descr_ch->convert, data);
    ec6c:	4658      	mov	r0, fp
    ec6e:	b2d1      	uxtb	r1, r2
{
    ec70:	4617      	mov	r7, r2
	ringbuffer_put(&descr_ch->convert, data);
    ec72:	47d0      	blx	sl
	if (1 < _adc_async_get_data_size(&descr->device)) {
    ec74:	4b0c      	ldr	r3, [pc, #48]	; (eca8 <adc_async_channel_conversion_done+0x60>)
    ec76:	4628      	mov	r0, r5
    ec78:	4798      	blx	r3
    ec7a:	2801      	cmp	r0, #1
    ec7c:	d905      	bls.n	ec8a <adc_async_channel_conversion_done+0x42>
		ringbuffer_put(&descr_ch->convert, data >> 8);
    ec7e:	0a39      	lsrs	r1, r7, #8
    ec80:	4658      	mov	r0, fp
    ec82:	47d0      	blx	sl
		++descr_ch->bytes_in_buffer;
    ec84:	8aa3      	ldrh	r3, [r4, #20]
    ec86:	3301      	adds	r3, #1
    ec88:	82a3      	strh	r3, [r4, #20]
	++descr_ch->bytes_in_buffer;
    ec8a:	8aa3      	ldrh	r3, [r4, #20]
    ec8c:	3301      	adds	r3, #1
    ec8e:	82a3      	strh	r3, [r4, #20]
	if (descr_ch->adc_async_ch_cb.convert_done) {
    ec90:	f858 3009 	ldr.w	r3, [r8, r9]
    ec94:	b12b      	cbz	r3, eca2 <adc_async_channel_conversion_done+0x5a>
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    ec96:	4631      	mov	r1, r6
    ec98:	4628      	mov	r0, r5
}
    ec9a:	b001      	add	sp, #4
    ec9c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		descr_ch->adc_async_ch_cb.convert_done(descr, channel);
    eca0:	4718      	bx	r3
}
    eca2:	b001      	add	sp, #4
    eca4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    eca8:	00013a1d 	.word	0x00013a1d
    ecac:	0001241d 	.word	0x0001241d

0000ecb0 <adc_async_init>:
{
    ecb0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    ecb4:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    ecb8:	f89d 8020 	ldrb.w	r8, [sp, #32]
    ecbc:	460e      	mov	r6, r1
    ecbe:	4615      	mov	r5, r2
    ecc0:	461f      	mov	r7, r3
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    ecc2:	4604      	mov	r4, r0
    ecc4:	b150      	cbz	r0, ecdc <adc_async_init+0x2c>
    ecc6:	2900      	cmp	r1, #0
    ecc8:	d032      	beq.n	ed30 <adc_async_init+0x80>
    ecca:	2a00      	cmp	r2, #0
    eccc:	d032      	beq.n	ed34 <adc_async_init+0x84>
    ecce:	f1b8 0f00 	cmp.w	r8, #0
    ecd2:	d031      	beq.n	ed38 <adc_async_init+0x88>
    ecd4:	f1b9 0000 	subs.w	r0, r9, #0
    ecd8:	bf18      	it	ne
    ecda:	2001      	movne	r0, #1
    ecdc:	4917      	ldr	r1, [pc, #92]	; (ed3c <adc_async_init+0x8c>)
    ecde:	f8df a070 	ldr.w	sl, [pc, #112]	; ed50 <adc_async_init+0xa0>
    ece2:	223f      	movs	r2, #63	; 0x3f
    ece4:	47d0      	blx	sl
	ASSERT(channel_amount <= (channel_max + 1));
    ece6:	1c78      	adds	r0, r7, #1
    ece8:	4580      	cmp	r8, r0
    ecea:	4914      	ldr	r1, [pc, #80]	; (ed3c <adc_async_init+0x8c>)
    ecec:	f04f 0240 	mov.w	r2, #64	; 0x40
    ecf0:	bfcc      	ite	gt
    ecf2:	2000      	movgt	r0, #0
    ecf4:	2001      	movle	r0, #1
    ecf6:	47d0      	blx	sl
	device = &descr->device;
    ecf8:	2300      	movs	r3, #0
		channel_map[i] = 0xFF;
    ecfa:	21ff      	movs	r1, #255	; 0xff
    ecfc:	b2da      	uxtb	r2, r3
    ecfe:	3301      	adds	r3, #1
    ed00:	54a9      	strb	r1, [r5, r2]
	for (uint8_t i = 0; i <= channel_max; i++) {
    ed02:	b2da      	uxtb	r2, r3
    ed04:	4297      	cmp	r7, r2
    ed06:	d2f9      	bcs.n	ecfc <adc_async_init+0x4c>
	init_status           = _adc_async_init(device, hw);
    ed08:	4b0d      	ldr	r3, [pc, #52]	; (ed40 <adc_async_init+0x90>)
	descr->channel_map    = channel_map;
    ed0a:	6225      	str	r5, [r4, #32]
	descr->channel_max    = channel_max;
    ed0c:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	descr->channel_amount = channel_amount;
    ed10:	f884 8025 	strb.w	r8, [r4, #37]	; 0x25
	descr->descr_ch       = descr_ch;
    ed14:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	init_status           = _adc_async_init(device, hw);
    ed18:	4631      	mov	r1, r6
    ed1a:	4620      	mov	r0, r4
    ed1c:	4798      	blx	r3
	if (init_status) {
    ed1e:	b928      	cbnz	r0, ed2c <adc_async_init+0x7c>
	device->adc_async_ch_cb.convert_done = adc_async_channel_conversion_done;
    ed20:	4b08      	ldr	r3, [pc, #32]	; (ed44 <adc_async_init+0x94>)
    ed22:	60a3      	str	r3, [r4, #8]
	device->adc_async_cb.window_cb       = adc_async_window_threshold_reached;
    ed24:	4b08      	ldr	r3, [pc, #32]	; (ed48 <adc_async_init+0x98>)
    ed26:	6023      	str	r3, [r4, #0]
	device->adc_async_cb.error_cb        = adc_async_error_occured;
    ed28:	4b08      	ldr	r3, [pc, #32]	; (ed4c <adc_async_init+0x9c>)
    ed2a:	6063      	str	r3, [r4, #4]
}
    ed2c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && hw && channel_map && channel_amount && descr_ch);
    ed30:	4608      	mov	r0, r1
    ed32:	e7d3      	b.n	ecdc <adc_async_init+0x2c>
    ed34:	4610      	mov	r0, r2
    ed36:	e7d1      	b.n	ecdc <adc_async_init+0x2c>
    ed38:	4640      	mov	r0, r8
    ed3a:	e7cf      	b.n	ecdc <adc_async_init+0x2c>
    ed3c:	000170a8 	.word	0x000170a8
    ed40:	00013945 	.word	0x00013945
    ed44:	0000ec49 	.word	0x0000ec49
    ed48:	0000ec39 	.word	0x0000ec39
    ed4c:	0000ec41 	.word	0x0000ec41
    ed50:	0000e9b9 	.word	0x0000e9b9

0000ed54 <adc_async_register_channel_buffer>:
{
    ed54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    ed58:	460e      	mov	r6, r1
    ed5a:	4617      	mov	r7, r2
    ed5c:	4698      	mov	r8, r3
	ASSERT(descr && convert_buffer && convert_buffer_length);
    ed5e:	4604      	mov	r4, r0
    ed60:	b118      	cbz	r0, ed6a <adc_async_register_channel_buffer+0x16>
    ed62:	b1c2      	cbz	r2, ed96 <adc_async_register_channel_buffer+0x42>
    ed64:	1e18      	subs	r0, r3, #0
    ed66:	bf18      	it	ne
    ed68:	2001      	movne	r0, #1
    ed6a:	4921      	ldr	r1, [pc, #132]	; (edf0 <adc_async_register_channel_buffer+0x9c>)
    ed6c:	4d21      	ldr	r5, [pc, #132]	; (edf4 <adc_async_register_channel_buffer+0xa0>)
    ed6e:	2266      	movs	r2, #102	; 0x66
    ed70:	47a8      	blx	r5
	ASSERT(descr->channel_max >= channel);
    ed72:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    ed76:	491e      	ldr	r1, [pc, #120]	; (edf0 <adc_async_register_channel_buffer+0x9c>)
    ed78:	42b0      	cmp	r0, r6
    ed7a:	f04f 0267 	mov.w	r2, #103	; 0x67
    ed7e:	bf34      	ite	cc
    ed80:	2000      	movcc	r0, #0
    ed82:	2001      	movcs	r0, #1
    ed84:	47a8      	blx	r5
	if (descr->channel_map[channel] != 0xFF) {
    ed86:	6a23      	ldr	r3, [r4, #32]
    ed88:	5d9a      	ldrb	r2, [r3, r6]
    ed8a:	2aff      	cmp	r2, #255	; 0xff
    ed8c:	d005      	beq.n	ed9a <adc_async_register_channel_buffer+0x46>
		return ERR_INVALID_ARG;
    ed8e:	f06f 000c 	mvn.w	r0, #12
}
    ed92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && convert_buffer && convert_buffer_length);
    ed96:	4610      	mov	r0, r2
    ed98:	e7e7      	b.n	ed6a <adc_async_register_channel_buffer+0x16>
	for (i = 0; i <= descr->channel_max; i++) {
    ed9a:	2200      	movs	r2, #0
    ed9c:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	uint8_t i, index = 0;
    eda0:	4615      	mov	r5, r2
		if (descr->channel_map[i] != 0xFF) {
    eda2:	b2d1      	uxtb	r1, r2
    eda4:	3201      	adds	r2, #1
    eda6:	5c59      	ldrb	r1, [r3, r1]
    eda8:	29ff      	cmp	r1, #255	; 0xff
			index++;
    edaa:	bf18      	it	ne
    edac:	3501      	addne	r5, #1
	for (i = 0; i <= descr->channel_max; i++) {
    edae:	b2d1      	uxtb	r1, r2
			index++;
    edb0:	bf18      	it	ne
    edb2:	b2ed      	uxtbne	r5, r5
	for (i = 0; i <= descr->channel_max; i++) {
    edb4:	4288      	cmp	r0, r1
    edb6:	d2f4      	bcs.n	eda2 <adc_async_register_channel_buffer+0x4e>
	if (index > descr->channel_amount) {
    edb8:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
    edbc:	42ab      	cmp	r3, r5
    edbe:	d313      	bcc.n	ede8 <adc_async_register_channel_buffer+0x94>
	if (ERR_NONE != ringbuffer_init(&descr->descr_ch[index].convert, convert_buffer, convert_buffer_length)) {
    edc0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
    edc2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
    edc6:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
    edca:	ea4f 09c3 	mov.w	r9, r3, lsl #3
    edce:	4642      	mov	r2, r8
    edd0:	4b09      	ldr	r3, [pc, #36]	; (edf8 <adc_async_register_channel_buffer+0xa4>)
    edd2:	4639      	mov	r1, r7
    edd4:	3004      	adds	r0, #4
    edd6:	4798      	blx	r3
    edd8:	2800      	cmp	r0, #0
    edda:	d1d8      	bne.n	ed8e <adc_async_register_channel_buffer+0x3a>
	descr->channel_map[channel]            = index;
    eddc:	6a23      	ldr	r3, [r4, #32]
    edde:	559d      	strb	r5, [r3, r6]
	descr->descr_ch[index].bytes_in_buffer = 0;
    ede0:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    ede2:	444b      	add	r3, r9
    ede4:	8298      	strh	r0, [r3, #20]
	return ERR_NONE;
    ede6:	e7d4      	b.n	ed92 <adc_async_register_channel_buffer+0x3e>
		return ERR_NO_RESOURCE;
    ede8:	f06f 001b 	mvn.w	r0, #27
    edec:	e7d1      	b.n	ed92 <adc_async_register_channel_buffer+0x3e>
    edee:	bf00      	nop
    edf0:	000170a8 	.word	0x000170a8
    edf4:	0000e9b9 	.word	0x0000e9b9
    edf8:	000123a1 	.word	0x000123a1

0000edfc <adc_async_enable_channel>:
{
    edfc:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
    edfe:	4604      	mov	r4, r0
    ee00:	3800      	subs	r0, #0
{
    ee02:	460d      	mov	r5, r1
	ASSERT(descr);
    ee04:	bf18      	it	ne
    ee06:	2001      	movne	r0, #1
    ee08:	4e09      	ldr	r6, [pc, #36]	; (ee30 <adc_async_enable_channel+0x34>)
    ee0a:	490a      	ldr	r1, [pc, #40]	; (ee34 <adc_async_enable_channel+0x38>)
    ee0c:	2283      	movs	r2, #131	; 0x83
    ee0e:	47b0      	blx	r6
	ASSERT(descr->channel_max >= channel);
    ee10:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    ee14:	4907      	ldr	r1, [pc, #28]	; (ee34 <adc_async_enable_channel+0x38>)
    ee16:	42a8      	cmp	r0, r5
    ee18:	bf34      	ite	cc
    ee1a:	2000      	movcc	r0, #0
    ee1c:	2001      	movcs	r0, #1
    ee1e:	2284      	movs	r2, #132	; 0x84
    ee20:	47b0      	blx	r6
	_adc_async_enable_channel(&descr->device, channel);
    ee22:	4620      	mov	r0, r4
    ee24:	4b04      	ldr	r3, [pc, #16]	; (ee38 <adc_async_enable_channel+0x3c>)
    ee26:	4629      	mov	r1, r5
    ee28:	4798      	blx	r3
}
    ee2a:	2000      	movs	r0, #0
    ee2c:	bd70      	pop	{r4, r5, r6, pc}
    ee2e:	bf00      	nop
    ee30:	0000e9b9 	.word	0x0000e9b9
    ee34:	000170a8 	.word	0x000170a8
    ee38:	00013a11 	.word	0x00013a11

0000ee3c <adc_async_register_callback>:
{
    ee3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(descr);
    ee40:	4604      	mov	r4, r0
    ee42:	3800      	subs	r0, #0
    ee44:	bf18      	it	ne
    ee46:	2001      	movne	r0, #1
    ee48:	f8df 8064 	ldr.w	r8, [pc, #100]	; eeb0 <adc_async_register_callback+0x74>
{
    ee4c:	460f      	mov	r7, r1
    ee4e:	4615      	mov	r5, r2
	ASSERT(descr);
    ee50:	4915      	ldr	r1, [pc, #84]	; (eea8 <adc_async_register_callback+0x6c>)
    ee52:	229c      	movs	r2, #156	; 0x9c
{
    ee54:	461e      	mov	r6, r3
	ASSERT(descr);
    ee56:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    ee58:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    ee5c:	4912      	ldr	r1, [pc, #72]	; (eea8 <adc_async_register_callback+0x6c>)
    ee5e:	42b8      	cmp	r0, r7
    ee60:	bf34      	ite	cc
    ee62:	2000      	movcc	r0, #0
    ee64:	2001      	movcs	r0, #1
    ee66:	229d      	movs	r2, #157	; 0x9d
    ee68:	47c0      	blx	r8
	switch (type) {
    ee6a:	2d01      	cmp	r5, #1
    ee6c:	d014      	beq.n	ee98 <adc_async_register_callback+0x5c>
    ee6e:	2d02      	cmp	r5, #2
    ee70:	d014      	beq.n	ee9c <adc_async_register_callback+0x60>
    ee72:	b9ad      	cbnz	r5, eea0 <adc_async_register_callback+0x64>
	uint8_t index = descr->channel_map[channel];
    ee74:	6a23      	ldr	r3, [r4, #32]
		descr->descr_ch[index].adc_async_ch_cb.convert_done = cb;
    ee76:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    ee78:	5ddb      	ldrb	r3, [r3, r7]
    ee7a:	eb03 0343 	add.w	r3, r3, r3, lsl #1
    ee7e:	f842 6033 	str.w	r6, [r2, r3, lsl #3]
	_adc_async_set_irq_state(&descr->device, channel, (enum _adc_async_callback_type)type, cb != NULL);
    ee82:	1e33      	subs	r3, r6, #0
    ee84:	4620      	mov	r0, r4
    ee86:	bf18      	it	ne
    ee88:	2301      	movne	r3, #1
    ee8a:	4c08      	ldr	r4, [pc, #32]	; (eeac <adc_async_register_callback+0x70>)
    ee8c:	462a      	mov	r2, r5
    ee8e:	4639      	mov	r1, r7
    ee90:	47a0      	blx	r4
	return ERR_NONE;
    ee92:	2000      	movs	r0, #0
}
    ee94:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		descr->adc_async_cb.monitor = cb;
    ee98:	61a6      	str	r6, [r4, #24]
		break;
    ee9a:	e7f2      	b.n	ee82 <adc_async_register_callback+0x46>
		descr->adc_async_cb.error = cb;
    ee9c:	61e6      	str	r6, [r4, #28]
		break;
    ee9e:	e7f0      	b.n	ee82 <adc_async_register_callback+0x46>
	switch (type) {
    eea0:	f06f 000c 	mvn.w	r0, #12
    eea4:	e7f6      	b.n	ee94 <adc_async_register_callback+0x58>
    eea6:	bf00      	nop
    eea8:	000170a8 	.word	0x000170a8
    eeac:	00013a49 	.word	0x00013a49
    eeb0:	0000e9b9 	.word	0x0000e9b9

0000eeb4 <adc_async_read_channel>:
{
    eeb4:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    eeb8:	460e      	mov	r6, r1
    eeba:	4617      	mov	r7, r2
    eebc:	461d      	mov	r5, r3
	ASSERT(descr && buffer && length);
    eebe:	4604      	mov	r4, r0
    eec0:	b120      	cbz	r0, eecc <adc_async_read_channel+0x18>
    eec2:	2a00      	cmp	r2, #0
    eec4:	d03f      	beq.n	ef46 <adc_async_read_channel+0x92>
    eec6:	1e18      	subs	r0, r3, #0
    eec8:	bf18      	it	ne
    eeca:	2001      	movne	r0, #1
    eecc:	f8df 8098 	ldr.w	r8, [pc, #152]	; ef68 <adc_async_read_channel+0xb4>
    eed0:	4920      	ldr	r1, [pc, #128]	; (ef54 <adc_async_read_channel+0xa0>)
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    eed2:	f8df a098 	ldr.w	sl, [pc, #152]	; ef6c <adc_async_read_channel+0xb8>
	ASSERT(descr && buffer && length);
    eed6:	22bc      	movs	r2, #188	; 0xbc
    eed8:	47c0      	blx	r8
	ASSERT(descr->channel_max >= channel);
    eeda:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
    eede:	491d      	ldr	r1, [pc, #116]	; (ef54 <adc_async_read_channel+0xa0>)
    eee0:	42b0      	cmp	r0, r6
    eee2:	bf34      	ite	cc
    eee4:	2000      	movcc	r0, #0
    eee6:	2001      	movcs	r0, #1
    eee8:	22bd      	movs	r2, #189	; 0xbd
    eeea:	47c0      	blx	r8
	data_size = _adc_async_get_data_size(&descr->device);
    eeec:	4b1a      	ldr	r3, [pc, #104]	; (ef58 <adc_async_read_channel+0xa4>)
    eeee:	4620      	mov	r0, r4
    eef0:	4798      	blx	r3
	ASSERT(!(length % data_size));
    eef2:	fbb5 f3f0 	udiv	r3, r5, r0
    eef6:	fb03 5010 	mls	r0, r3, r0, r5
    eefa:	fab0 f080 	clz	r0, r0
    eefe:	4915      	ldr	r1, [pc, #84]	; (ef54 <adc_async_read_channel+0xa0>)
    ef00:	22bf      	movs	r2, #191	; 0xbf
    ef02:	0940      	lsrs	r0, r0, #5
    ef04:	47c0      	blx	r8
	index                                         = descr->channel_map[channel];
    ef06:	6a23      	ldr	r3, [r4, #32]
	struct adc_async_channel_descriptor *descr_ch = &descr->descr_ch[index];
    ef08:	5d9e      	ldrb	r6, [r3, r6]
    ef0a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    ef0c:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    ef10:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
	CRITICAL_SECTION_ENTER()
    ef14:	a801      	add	r0, sp, #4
    ef16:	4b11      	ldr	r3, [pc, #68]	; (ef5c <adc_async_read_channel+0xa8>)
	num = ringbuffer_num(&descr_ch->convert);
    ef18:	f106 0904 	add.w	r9, r6, #4
	CRITICAL_SECTION_ENTER()
    ef1c:	4798      	blx	r3
	num = ringbuffer_num(&descr_ch->convert);
    ef1e:	4b10      	ldr	r3, [pc, #64]	; (ef60 <adc_async_read_channel+0xac>)
    ef20:	4648      	mov	r0, r9
    ef22:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
    ef24:	4b0f      	ldr	r3, [pc, #60]	; (ef64 <adc_async_read_channel+0xb0>)
	num = ringbuffer_num(&descr_ch->convert);
    ef26:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
    ef28:	a801      	add	r0, sp, #4
    ef2a:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
    ef2c:	2400      	movs	r4, #0
    ef2e:	45a0      	cmp	r8, r4
    ef30:	b2a2      	uxth	r2, r4
    ef32:	d001      	beq.n	ef38 <adc_async_read_channel+0x84>
    ef34:	42a5      	cmp	r5, r4
    ef36:	d108      	bne.n	ef4a <adc_async_read_channel+0x96>
	descr_ch->bytes_in_buffer -= was_read;
    ef38:	8ab3      	ldrh	r3, [r6, #20]
}
    ef3a:	4620      	mov	r0, r4
	descr_ch->bytes_in_buffer -= was_read;
    ef3c:	1a9b      	subs	r3, r3, r2
    ef3e:	82b3      	strh	r3, [r6, #20]
}
    ef40:	b002      	add	sp, #8
    ef42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	ASSERT(descr && buffer && length);
    ef46:	4610      	mov	r0, r2
    ef48:	e7c0      	b.n	eecc <adc_async_read_channel+0x18>
		ringbuffer_get(&descr_ch->convert, &buffer[was_read++]);
    ef4a:	1939      	adds	r1, r7, r4
    ef4c:	4648      	mov	r0, r9
    ef4e:	47d0      	blx	sl
    ef50:	3401      	adds	r4, #1
    ef52:	e7ec      	b.n	ef2e <adc_async_read_channel+0x7a>
    ef54:	000170a8 	.word	0x000170a8
    ef58:	00013a1d 	.word	0x00013a1d
    ef5c:	00012485 	.word	0x00012485
    ef60:	00012461 	.word	0x00012461
    ef64:	00012493 	.word	0x00012493
    ef68:	0000e9b9 	.word	0x0000e9b9
    ef6c:	000123dd 	.word	0x000123dd

0000ef70 <adc_async_start_conversion>:
{
    ef70:	b510      	push	{r4, lr}
	ASSERT(descr);
    ef72:	4604      	mov	r4, r0
    ef74:	3800      	subs	r0, #0
    ef76:	bf18      	it	ne
    ef78:	2001      	movne	r0, #1
    ef7a:	4904      	ldr	r1, [pc, #16]	; (ef8c <adc_async_start_conversion+0x1c>)
    ef7c:	4b04      	ldr	r3, [pc, #16]	; (ef90 <adc_async_start_conversion+0x20>)
    ef7e:	22d6      	movs	r2, #214	; 0xd6
    ef80:	4798      	blx	r3
	_adc_async_convert(&descr->device);
    ef82:	4620      	mov	r0, r4
    ef84:	4b03      	ldr	r3, [pc, #12]	; (ef94 <adc_async_start_conversion+0x24>)
    ef86:	4798      	blx	r3
}
    ef88:	2000      	movs	r0, #0
    ef8a:	bd10      	pop	{r4, pc}
    ef8c:	000170a8 	.word	0x000170a8
    ef90:	0000e9b9 	.word	0x0000e9b9
    ef94:	00013a31 	.word	0x00013a31

0000ef98 <_oscctrl_init_sources>:
	hri_oscctrl_set_XOSCCTRL_ONDEMAND_bit(hw, 1);
#endif
#endif

	(void)hw;
}
    ef98:	4770      	bx	lr
	...

0000ef9c <_oscctrl_init_referenced_generators>:

static inline void hri_gclk_write_GENCTRL_SRC_bf(const void *const hw, uint8_t index, hri_gclk_genctrl_reg_t data)
{
	uint32_t tmp;
	GCLK_CRITICAL_SECTION_ENTER();
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    ef9c:	4b3b      	ldr	r3, [pc, #236]	; (f08c <_oscctrl_init_referenced_generators+0xf0>)
    ef9e:	6a1a      	ldr	r2, [r3, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    efa0:	f022 020f 	bic.w	r2, r2, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    efa4:	f042 0204 	orr.w	r2, r2, #4
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    efa8:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    efaa:	f643 72fd 	movw	r2, #16381	; 0x3ffd
    efae:	6859      	ldr	r1, [r3, #4]
    efb0:	4211      	tst	r1, r2
    efb2:	d1fc      	bne.n	efae <_oscctrl_init_referenced_generators+0x12>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    efb4:	685a      	ldr	r2, [r3, #4]
{
	void *hw = (void *)OSCCTRL;

#if CONF_DFLL_CONFIG == 1
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, GCLK_GENCTRL_SRC_OSCULP32K);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    efb6:	0750      	lsls	r0, r2, #29
    efb8:	f3c2 0180 	ubfx	r1, r2, #2, #1
    efbc:	d4fa      	bmi.n	efb4 <_oscctrl_init_referenced_generators+0x18>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    efbe:	4b34      	ldr	r3, [pc, #208]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
}

static inline void hri_oscctrl_write_DFLLMUL_reg(const void *const hw, hri_oscctrl_dfllmul_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    efc0:	4a34      	ldr	r2, [pc, #208]	; (f094 <_oscctrl_init_referenced_generators+0xf8>)
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    efc2:	7719      	strb	r1, [r3, #28]
	((Oscctrl *)hw)->DFLLMUL.reg = data;
    efc4:	629a      	str	r2, [r3, #40]	; 0x28
}

static inline bool hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(const void *const hw)
{
	uint8_t tmp;
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    efc6:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
#endif

	hri_oscctrl_write_DFLLMUL_reg(hw,
	                              OSCCTRL_DFLLMUL_CSTEP(CONF_DFLL_CSTEP) | OSCCTRL_DFLLMUL_FSTEP(CONF_DFLL_FSTEP)
	                                  | OSCCTRL_DFLLMUL_MUL(CONF_DFLL_MUL));
	while (hri_oscctrl_get_DFLLSYNC_DFLLMUL_bit(hw))
    efca:	f3c2 1100 	ubfx	r1, r2, #4, #1
    efce:	06d2      	lsls	r2, r2, #27
    efd0:	d4f9      	bmi.n	efc6 <_oscctrl_init_referenced_generators+0x2a>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    efd2:	f883 1020 	strb.w	r1, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    efd6:	4b2e      	ldr	r3, [pc, #184]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
    efd8:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	hri_oscctrl_write_DFLLCTRLB_reg(hw, 0);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    efdc:	0750      	lsls	r0, r2, #29
    efde:	d4fb      	bmi.n	efd8 <_oscctrl_init_referenced_generators+0x3c>
	((Oscctrl *)hw)->DFLLCTRLA.reg = data;
    efe0:	2202      	movs	r2, #2
    efe2:	771a      	strb	r2, [r3, #28]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    efe4:	4b2a      	ldr	r3, [pc, #168]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
    efe6:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
		;

	tmp = (CONF_DFLL_RUNSTDBY << OSCCTRL_DFLLCTRLA_RUNSTDBY_Pos) | OSCCTRL_DFLLCTRLA_ENABLE;
	hri_oscctrl_write_DFLLCTRLA_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_ENABLE_bit(hw))
    efea:	0791      	lsls	r1, r2, #30
    efec:	d4fb      	bmi.n	efe6 <_oscctrl_init_referenced_generators+0x4a>
	return ((Oscctrl *)hw)->DFLLVAL.reg;
    efee:	6a5a      	ldr	r2, [r3, #36]	; 0x24
	((Oscctrl *)hw)->DFLLVAL.reg = data;
    eff0:	625a      	str	r2, [r3, #36]	; 0x24
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    eff2:	4b27      	ldr	r3, [pc, #156]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
    eff4:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c

#if CONF_DFLL_OVERWRITE_CALIBRATION == 1
	hri_oscctrl_write_DFLLVAL_reg(hw, OSCCTRL_DFLLVAL_COARSE(CONF_DFLL_COARSE) | OSCCTRL_DFLLVAL_FINE(CONF_DFLL_FINE));
#endif
	hri_oscctrl_write_DFLLVAL_reg(hw, hri_oscctrl_read_DFLLVAL_reg(hw));
	while (hri_oscctrl_get_DFLLSYNC_DFLLVAL_bit(hw))
    eff8:	0712      	lsls	r2, r2, #28
    effa:	d4fb      	bmi.n	eff4 <_oscctrl_init_referenced_generators+0x58>
	((Oscctrl *)hw)->DFLLCTRLB.reg = data;
    effc:	2288      	movs	r2, #136	; 0x88
    effe:	f883 2020 	strb.w	r2, [r3, #32]
	tmp = ((Oscctrl *)hw)->DFLLSYNC.reg;
    f002:	4a23      	ldr	r2, [pc, #140]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
    f004:	4613      	mov	r3, r2
    f006:	f892 102c 	ldrb.w	r1, [r2, #44]	; 0x2c
	tmp = (CONF_DFLL_WAITLOCK << OSCCTRL_DFLLCTRLB_WAITLOCK_Pos) | (CONF_DFLL_BPLCKC << OSCCTRL_DFLLCTRLB_BPLCKC_Pos)
	      | (CONF_DFLL_QLDIS << OSCCTRL_DFLLCTRLB_QLDIS_Pos) | (CONF_DFLL_CCDIS << OSCCTRL_DFLLCTRLB_CCDIS_Pos)
	      | (CONF_DFLL_USBCRM << OSCCTRL_DFLLCTRLB_USBCRM_Pos) | (CONF_DFLL_LLAW << OSCCTRL_DFLLCTRLB_LLAW_Pos)
	      | (CONF_DFLL_STABLE << OSCCTRL_DFLLCTRLB_STABLE_Pos) | (CONF_DFLL_MODE << OSCCTRL_DFLLCTRLB_MODE_Pos) | 0;
	hri_oscctrl_write_DFLLCTRLB_reg(hw, tmp);
	while (hri_oscctrl_get_DFLLSYNC_DFLLCTRLB_bit(hw))
    f00a:	0748      	lsls	r0, r1, #29
    f00c:	d4fb      	bmi.n	f006 <_oscctrl_init_referenced_generators+0x6a>
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
    f00e:	491f      	ldr	r1, [pc, #124]	; (f08c <_oscctrl_init_referenced_generators+0xf0>)
    f010:	2042      	movs	r0, #66	; 0x42
    f012:	f8c1 0088 	str.w	r0, [r1, #136]	; 0x88
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLRATIO.reg = data;
    f016:	2127      	movs	r1, #39	; 0x27
    f018:	6491      	str	r1, [r2, #72]	; 0x48
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    f01a:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    f01c:	f012 0f06 	tst.w	r2, #6
    f020:	d1fb      	bne.n	f01a <_oscctrl_init_referenced_generators+0x7e>
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLB.reg = data;
    f022:	f44f 6200 	mov.w	r2, #2048	; 0x800
    f026:	64da      	str	r2, [r3, #76]	; 0x4c
	((Oscctrl *)hw)->Dpll[submodule_index].DPLLCTRLA.reg = data;
    f028:	2202      	movs	r2, #2
    f02a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	while (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSYNCBUSY.reg & reg) {
    f02e:	4b18      	ldr	r3, [pc, #96]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
    f030:	461a      	mov	r2, r3
    f032:	6d19      	ldr	r1, [r3, #80]	; 0x50
    f034:	0789      	lsls	r1, r1, #30
    f036:	d4fc      	bmi.n	f032 <_oscctrl_init_referenced_generators+0x96>
	tmp = ((Oscctrl *)hw)->DFLLCTRLB.reg;
    f038:	f893 3020 	ldrb.w	r3, [r3, #32]
	                                (CONF_FDPLL1_RUNSTDBY << OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos)
	                                    | (CONF_FDPLL1_ENABLE << OSCCTRL_DPLLCTRLA_ENABLE_Pos));
#endif

#if CONF_DFLL_CONFIG == 1
	if (hri_oscctrl_get_DFLLCTRLB_MODE_bit(hw)) {
    f03c:	07db      	lsls	r3, r3, #31
    f03e:	d521      	bpl.n	f084 <_oscctrl_init_referenced_generators+0xe8>
	tmp = ((Oscctrl *)hw)->STATUS.reg;
    f040:	6913      	ldr	r3, [r2, #16]
	tmp &= mask;
    f042:	f403 6310 	and.w	r3, r3, #2304	; 0x900
		hri_oscctrl_status_reg_t status_mask = OSCCTRL_STATUS_DFLLRDY | OSCCTRL_STATUS_DFLLLCKC;

		while (hri_oscctrl_get_STATUS_reg(hw, status_mask) != status_mask)
    f046:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    f04a:	d1f9      	bne.n	f040 <_oscctrl_init_referenced_generators+0xa4>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_LOCK)
    f04c:	4b10      	ldr	r3, [pc, #64]	; (f090 <_oscctrl_init_referenced_generators+0xf4>)
    f04e:	6d5a      	ldr	r2, [r3, #84]	; 0x54
#endif
#endif

#if CONF_FDPLL1_CONFIG == 1
#if CONF_FDPLL1_ENABLE == 1
	while (!(hri_oscctrl_get_DPLLSTATUS_LOCK_bit(hw, 1) || hri_oscctrl_get_DPLLSTATUS_CLKRDY_bit(hw, 1)))
    f050:	07d1      	lsls	r1, r2, #31
    f052:	d402      	bmi.n	f05a <_oscctrl_init_referenced_generators+0xbe>
	return (((Oscctrl *)hw)->Dpll[submodule_index].DPLLSTATUS.reg & OSCCTRL_DPLLSTATUS_CLKRDY)
    f054:	6d5a      	ldr	r2, [r3, #84]	; 0x54
    f056:	0792      	lsls	r2, r2, #30
    f058:	d5f9      	bpl.n	f04e <_oscctrl_init_referenced_generators+0xb2>
	return ((Gclk *)hw)->SYNCBUSY.reg;
    f05a:	4a0c      	ldr	r2, [pc, #48]	; (f08c <_oscctrl_init_referenced_generators+0xf0>)
    f05c:	4611      	mov	r1, r2
    f05e:	6853      	ldr	r3, [r2, #4]
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw, 1);
#endif
#endif

#if CONF_DFLL_CONFIG == 1
	while (hri_gclk_read_SYNCBUSY_reg(GCLK))
    f060:	2b00      	cmp	r3, #0
    f062:	d1fc      	bne.n	f05e <_oscctrl_init_referenced_generators+0xc2>
	tmp = ((Gclk *)hw)->GENCTRL[index].reg;
    f064:	6a13      	ldr	r3, [r2, #32]
	tmp &= ~GCLK_GENCTRL_SRC_Msk;
    f066:	f023 030f 	bic.w	r3, r3, #15
	tmp |= GCLK_GENCTRL_SRC(data);
    f06a:	f043 0308 	orr.w	r3, r3, #8
	((Gclk *)hw)->GENCTRL[index].reg = tmp;
    f06e:	6213      	str	r3, [r2, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    f070:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    f074:	684a      	ldr	r2, [r1, #4]
    f076:	421a      	tst	r2, r3
    f078:	d1fc      	bne.n	f074 <_oscctrl_init_referenced_generators+0xd8>
	return (((Gclk *)hw)->SYNCBUSY.reg & GCLK_SYNCBUSY_GENCTRL0) >> GCLK_SYNCBUSY_GENCTRL0_Pos;
    f07a:	4a04      	ldr	r2, [pc, #16]	; (f08c <_oscctrl_init_referenced_generators+0xf0>)
    f07c:	6853      	ldr	r3, [r2, #4]
		;
	hri_gclk_write_GENCTRL_SRC_bf(GCLK, 0, CONF_GCLK_GEN_0_SOURCE);
	while (hri_gclk_get_SYNCBUSY_GENCTRL0_bit(GCLK))
    f07e:	075b      	lsls	r3, r3, #29
    f080:	d4fc      	bmi.n	f07c <_oscctrl_init_referenced_generators+0xe0>
		;
#endif
	(void)hw;
}
    f082:	4770      	bx	lr
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_DFLLRDY) >> OSCCTRL_STATUS_DFLLRDY_Pos;
    f084:	6913      	ldr	r3, [r2, #16]
		while (!hri_oscctrl_get_STATUS_DFLLRDY_bit(hw))
    f086:	05d8      	lsls	r0, r3, #23
    f088:	d5fc      	bpl.n	f084 <_oscctrl_init_referenced_generators+0xe8>
    f08a:	e7df      	b.n	f04c <_oscctrl_init_referenced_generators+0xb0>
    f08c:	40001c00 	.word	0x40001c00
    f090:	40001000 	.word	0x40001000
    f094:	04010000 	.word	0x04010000

0000f098 <_rand_sync_read_data>:

/**
 * \brief Read data bits
 */
static uint32_t _rand_sync_read_data(const struct _rand_sync_dev *dev, const uint8_t n_bits)
{
    f098:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    f09c:	f890 8004 	ldrb.w	r8, [r0, #4]
    f0a0:	f8df 9034 	ldr.w	r9, [pc, #52]	; f0d8 <_rand_sync_read_data+0x40>
{
    f0a4:	4605      	mov	r5, r0
    f0a6:	460f      	mov	r7, r1
	uint8_t r_bits = (dev->n_bits < 1) ? 32 : dev->n_bits;
    f0a8:	f1b8 0f00 	cmp.w	r8, #0
    f0ac:	d00f      	beq.n	f0ce <_rand_sync_read_data+0x36>
	if (r_bits < n_bits) {
    f0ae:	4588      	cmp	r8, r1
    f0b0:	d20d      	bcs.n	f0ce <_rand_sync_read_data+0x36>
		uint8_t  i;
		uint32_t d = 0;
    f0b2:	2600      	movs	r6, #0
		/* Join read bits */
		for (i = 0; i < n_bits; i += r_bits) {
    f0b4:	4634      	mov	r4, r6
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    f0b6:	4628      	mov	r0, r5
    f0b8:	47c8      	blx	r9
    f0ba:	40a0      	lsls	r0, r4
		for (i = 0; i < n_bits; i += r_bits) {
    f0bc:	4444      	add	r4, r8
    f0be:	b2e4      	uxtb	r4, r4
    f0c0:	42a7      	cmp	r7, r4
			d |= (uint32_t)(_rand_sync_read_one(dev) << i);
    f0c2:	ea46 0600 	orr.w	r6, r6, r0
		for (i = 0; i < n_bits; i += r_bits) {
    f0c6:	d8f6      	bhi.n	f0b6 <_rand_sync_read_data+0x1e>
		}
		return d;
	} else {
		return _rand_sync_read_one(dev);
	}
}
    f0c8:	4630      	mov	r0, r6
    f0ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return _rand_sync_read_one(dev);
    f0ce:	4628      	mov	r0, r5
    f0d0:	464b      	mov	r3, r9
}
    f0d2:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		return _rand_sync_read_one(dev);
    f0d6:	4718      	bx	r3
    f0d8:	0000f1dd 	.word	0x0000f1dd

0000f0dc <rand_sync_init>:
{
    f0dc:	b570      	push	{r4, r5, r6, lr}
	ASSERT(desc);
    f0de:	4604      	mov	r4, r0
    f0e0:	3800      	subs	r0, #0
{
    f0e2:	460d      	mov	r5, r1
	ASSERT(desc);
    f0e4:	4b05      	ldr	r3, [pc, #20]	; (f0fc <rand_sync_init+0x20>)
    f0e6:	4906      	ldr	r1, [pc, #24]	; (f100 <rand_sync_init+0x24>)
    f0e8:	bf18      	it	ne
    f0ea:	2001      	movne	r0, #1
    f0ec:	2229      	movs	r2, #41	; 0x29
    f0ee:	4798      	blx	r3
	return _rand_sync_init(&desc->dev, hw);
    f0f0:	4629      	mov	r1, r5
    f0f2:	4620      	mov	r0, r4
    f0f4:	4b03      	ldr	r3, [pc, #12]	; (f104 <rand_sync_init+0x28>)
}
    f0f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _rand_sync_init(&desc->dev, hw);
    f0fa:	4718      	bx	r3
    f0fc:	0000e9b9 	.word	0x0000e9b9
    f100:	000170c3 	.word	0x000170c3
    f104:	0000f15d 	.word	0x0000f15d

0000f108 <rand_sync_enable>:
{
    f108:	b510      	push	{r4, lr}
	ASSERT(desc);
    f10a:	4604      	mov	r4, r0
    f10c:	3800      	subs	r0, #0
    f10e:	4b05      	ldr	r3, [pc, #20]	; (f124 <rand_sync_enable+0x1c>)
    f110:	4905      	ldr	r1, [pc, #20]	; (f128 <rand_sync_enable+0x20>)
    f112:	bf18      	it	ne
    f114:	2001      	movne	r0, #1
    f116:	2236      	movs	r2, #54	; 0x36
    f118:	4798      	blx	r3
	return _rand_sync_enable(&desc->dev);
    f11a:	4620      	mov	r0, r4
    f11c:	4b03      	ldr	r3, [pc, #12]	; (f12c <rand_sync_enable+0x24>)
}
    f11e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _rand_sync_enable(&desc->dev);
    f122:	4718      	bx	r3
    f124:	0000e9b9 	.word	0x0000e9b9
    f128:	000170c3 	.word	0x000170c3
    f12c:	0000f1a5 	.word	0x0000f1a5

0000f130 <rand_sync_read8>:

uint8_t rand_sync_read8(const struct rand_sync_desc *const desc)
{
    f130:	b510      	push	{r4, lr}
	ASSERT(desc);
    f132:	4604      	mov	r4, r0
    f134:	3800      	subs	r0, #0
    f136:	bf18      	it	ne
    f138:	2001      	movne	r0, #1
    f13a:	225b      	movs	r2, #91	; 0x5b
    f13c:	4904      	ldr	r1, [pc, #16]	; (f150 <rand_sync_read8+0x20>)
    f13e:	4b05      	ldr	r3, [pc, #20]	; (f154 <rand_sync_read8+0x24>)
    f140:	4798      	blx	r3
	return (uint8_t)_rand_sync_read_data(&desc->dev, 8);
    f142:	4b05      	ldr	r3, [pc, #20]	; (f158 <rand_sync_read8+0x28>)
    f144:	2108      	movs	r1, #8
    f146:	4620      	mov	r0, r4
    f148:	4798      	blx	r3
}
    f14a:	b2c0      	uxtb	r0, r0
    f14c:	bd10      	pop	{r4, pc}
    f14e:	bf00      	nop
    f150:	000170c3 	.word	0x000170c3
    f154:	0000e9b9 	.word	0x0000e9b9
    f158:	0000f099 	.word	0x0000f099

0000f15c <_rand_sync_init>:
	}
	return ERR_NONE;
}

int32_t _rand_sync_init(struct _rand_sync_dev *const dev, void *const hw)
{
    f15c:	b538      	push	{r3, r4, r5, lr}
    f15e:	460c      	mov	r4, r1
	int32_t rc;

	ASSERT(dev && hw);
    f160:	4605      	mov	r5, r0
    f162:	b110      	cbz	r0, f16a <_rand_sync_init+0xe>
    f164:	1e08      	subs	r0, r1, #0
    f166:	bf18      	it	ne
    f168:	2001      	movne	r0, #1
    f16a:	4b0c      	ldr	r3, [pc, #48]	; (f19c <_rand_sync_init+0x40>)
    f16c:	490c      	ldr	r1, [pc, #48]	; (f1a0 <_rand_sync_init+0x44>)
    f16e:	223d      	movs	r2, #61	; 0x3d
    f170:	4798      	blx	r3
}

static inline hri_trng_ctrla_reg_t hri_trng_get_CTRLA_reg(const void *const hw, hri_trng_ctrla_reg_t mask)
{
	uint8_t tmp;
	tmp = ((Trng *)hw)->CTRLA.reg;
    f172:	7823      	ldrb	r3, [r4, #0]
	if (hri_trng_get_CTRLA_reg(hw, TRNG_CTRLA_ENABLE)) {
    f174:	f013 0302 	ands.w	r3, r3, #2
    f178:	d10c      	bne.n	f194 <_rand_sync_init+0x38>
	((Trng *)hw)->CTRLA.reg &= ~TRNG_CTRLA_RUNSTDBY;
    f17a:	7822      	ldrb	r2, [r4, #0]
    f17c:	f002 02bf 	and.w	r2, r2, #191	; 0xbf
    f180:	7022      	strb	r2, [r4, #0]
}

static inline void hri_trng_clear_EVCTRL_DATARDYEO_bit(const void *const hw)
{
	TRNG_CRITICAL_SECTION_ENTER();
	((Trng *)hw)->EVCTRL.reg &= ~TRNG_EVCTRL_DATARDYEO;
    f182:	7922      	ldrb	r2, [r4, #4]
    f184:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    f188:	7122      	strb	r2, [r4, #4]

	rc = _trng_init(hw);
	if (rc == ERR_NONE) {
		dev->prvt   = hw;
		dev->n_bits = 32;
    f18a:	2220      	movs	r2, #32
		dev->prvt   = hw;
    f18c:	602c      	str	r4, [r5, #0]
		dev->n_bits = 32;
    f18e:	712a      	strb	r2, [r5, #4]
	return ERR_NONE;
    f190:	4618      	mov	r0, r3
	}
	return rc;
}
    f192:	bd38      	pop	{r3, r4, r5, pc}
		return ERR_DENIED;
    f194:	f06f 0010 	mvn.w	r0, #16
	return rc;
    f198:	e7fb      	b.n	f192 <_rand_sync_init+0x36>
    f19a:	bf00      	nop
    f19c:	0000e9b9 	.word	0x0000e9b9
    f1a0:	000170de 	.word	0x000170de

0000f1a4 <_rand_sync_enable>:
{
	_rand_sync_disable(dev);
}

int32_t _rand_sync_enable(struct _rand_sync_dev *const dev)
{
    f1a4:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    f1a6:	4604      	mov	r4, r0
    f1a8:	3800      	subs	r0, #0
    f1aa:	bf18      	it	ne
    f1ac:	2001      	movne	r0, #1
    f1ae:	4d09      	ldr	r5, [pc, #36]	; (f1d4 <_rand_sync_enable+0x30>)
    f1b0:	4909      	ldr	r1, [pc, #36]	; (f1d8 <_rand_sync_enable+0x34>)
    f1b2:	224e      	movs	r2, #78	; 0x4e
    f1b4:	47a8      	blx	r5
	ASSERT(dev->prvt);
    f1b6:	6820      	ldr	r0, [r4, #0]
    f1b8:	4907      	ldr	r1, [pc, #28]	; (f1d8 <_rand_sync_enable+0x34>)
    f1ba:	3800      	subs	r0, #0
    f1bc:	bf18      	it	ne
    f1be:	2001      	movne	r0, #1
    f1c0:	224f      	movs	r2, #79	; 0x4f
    f1c2:	47a8      	blx	r5

	hri_trng_set_CTRLA_ENABLE_bit(dev->prvt);
    f1c4:	6822      	ldr	r2, [r4, #0]
	((Trng *)hw)->CTRLA.reg |= TRNG_CTRLA_ENABLE;
    f1c6:	7813      	ldrb	r3, [r2, #0]
    f1c8:	f043 0302 	orr.w	r3, r3, #2
    f1cc:	7013      	strb	r3, [r2, #0]
	return ERR_NONE;
}
    f1ce:	2000      	movs	r0, #0
    f1d0:	bd38      	pop	{r3, r4, r5, pc}
    f1d2:	bf00      	nop
    f1d4:	0000e9b9 	.word	0x0000e9b9
    f1d8:	000170de 	.word	0x000170de

0000f1dc <_rand_sync_read_one>:
	(void)seed;
	return ERR_UNSUPPORTED_OP;
}

uint32_t _rand_sync_read_one(const struct _rand_sync_dev *const dev)
{
    f1dc:	b538      	push	{r3, r4, r5, lr}
	ASSERT(dev);
    f1de:	4604      	mov	r4, r0
    f1e0:	3800      	subs	r0, #0
    f1e2:	4d0d      	ldr	r5, [pc, #52]	; (f218 <_rand_sync_read_one+0x3c>)
    f1e4:	490d      	ldr	r1, [pc, #52]	; (f21c <_rand_sync_read_one+0x40>)
    f1e6:	bf18      	it	ne
    f1e8:	2001      	movne	r0, #1
    f1ea:	2266      	movs	r2, #102	; 0x66
    f1ec:	47a8      	blx	r5
	ASSERT(dev->prvt);
    f1ee:	6820      	ldr	r0, [r4, #0]
    f1f0:	490a      	ldr	r1, [pc, #40]	; (f21c <_rand_sync_read_one+0x40>)
    f1f2:	3800      	subs	r0, #0
    f1f4:	bf18      	it	ne
    f1f6:	2001      	movne	r0, #1
    f1f8:	2267      	movs	r2, #103	; 0x67
    f1fa:	47a8      	blx	r5
	ASSERT(hri_trng_get_CTRLA_reg(dev->prvt, TRNG_CTRLA_ENABLE));
    f1fc:	6823      	ldr	r3, [r4, #0]
    f1fe:	4907      	ldr	r1, [pc, #28]	; (f21c <_rand_sync_read_one+0x40>)
	tmp = ((Trng *)hw)->CTRLA.reg;
    f200:	7818      	ldrb	r0, [r3, #0]
    f202:	2268      	movs	r2, #104	; 0x68
    f204:	f3c0 0040 	ubfx	r0, r0, #1, #1
    f208:	47a8      	blx	r5

	while (!hri_trng_get_INTFLAG_reg(dev->prvt, TRNG_INTFLAG_DATARDY)) {
    f20a:	6823      	ldr	r3, [r4, #0]
	tmp = ((Trng *)hw)->INTFLAG.reg;
    f20c:	7a9a      	ldrb	r2, [r3, #10]
    f20e:	07d2      	lsls	r2, r2, #31
    f210:	d5fc      	bpl.n	f20c <_rand_sync_read_one+0x30>
	return ((Trng *)hw)->DATA.reg;
    f212:	6a18      	ldr	r0, [r3, #32]
		/* Wait until data ready. */
	}
	return hri_trng_read_DATA_reg(dev->prvt);
}
    f214:	bd38      	pop	{r3, r4, r5, pc}
    f216:	bf00      	nop
    f218:	0000e9b9 	.word	0x0000e9b9
    f21c:	000170de 	.word	0x000170de

0000f220 <hid_keyboard_req>:
 * \param[in] ep Endpoint address.
 * \param[in] req Pointer to the request.
 * \return Operation status.
 */
static int32_t hid_keyboard_req(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
    f220:	b430      	push	{r4, r5}
	if ((0x81 == req->bmRequestType) && (0x06 == req->bRequest) && (req->wIndex == _hiddf_keyboard_funcd.func_iface)) {
    f222:	780a      	ldrb	r2, [r1, #0]
    f224:	2a81      	cmp	r2, #129	; 0x81
    f226:	d11c      	bne.n	f262 <hid_keyboard_req+0x42>
    f228:	784b      	ldrb	r3, [r1, #1]
    f22a:	2b06      	cmp	r3, #6
    f22c:	d131      	bne.n	f292 <hid_keyboard_req+0x72>
    f22e:	4a1a      	ldr	r2, [pc, #104]	; (f298 <hid_keyboard_req+0x78>)
    f230:	888c      	ldrh	r4, [r1, #4]
    f232:	7b13      	ldrb	r3, [r2, #12]
    f234:	429c      	cmp	r4, r3
    f236:	d12c      	bne.n	f292 <hid_keyboard_req+0x72>
	switch (req->wValue >> 8) {
    f238:	884b      	ldrh	r3, [r1, #2]
    f23a:	0a1b      	lsrs	r3, r3, #8
    f23c:	2b21      	cmp	r3, #33	; 0x21
    f23e:	d005      	beq.n	f24c <hid_keyboard_req+0x2c>
    f240:	2b22      	cmp	r3, #34	; 0x22
    f242:	d00a      	beq.n	f25a <hid_keyboard_req+0x3a>
	} else {
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
			return ERR_NOT_FOUND;
		}
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
			switch (req->bRequest) {
    f244:	f06f 000c 	mvn.w	r0, #12
		} else {
			return ERR_NOT_FOUND;
		}
	}
	(void)stage;
}
    f248:	bc30      	pop	{r4, r5}
    f24a:	4770      	bx	lr
		return usbdc_xfer(ep, _hiddf_keyboard_funcd.hid_desc, _hiddf_keyboard_funcd.hid_desc[0], false);
    f24c:	6811      	ldr	r1, [r2, #0]
    f24e:	780a      	ldrb	r2, [r1, #0]
    f250:	2300      	movs	r3, #0
				return usbdc_xfer(ep, NULL, 0, 0);
    f252:	4c12      	ldr	r4, [pc, #72]	; (f29c <hid_keyboard_req+0x7c>)
    f254:	46a4      	mov	ip, r4
}
    f256:	bc30      	pop	{r4, r5}
				return usbdc_xfer(ep, NULL, 0, 0);
    f258:	4760      	bx	ip
		return usbdc_xfer(ep, (uint8_t *)keyboard_report_desc, KEYBOARD_REPORT_DESC_LEN, false);
    f25a:	4911      	ldr	r1, [pc, #68]	; (f2a0 <hid_keyboard_req+0x80>)
    f25c:	2300      	movs	r3, #0
    f25e:	223b      	movs	r2, #59	; 0x3b
    f260:	e7f7      	b.n	f252 <hid_keyboard_req+0x32>
		if (0x01 != ((req->bmRequestType >> 5) & 0x03)) { // class request
    f262:	f3c2 1241 	ubfx	r2, r2, #5, #2
    f266:	2a01      	cmp	r2, #1
    f268:	d113      	bne.n	f292 <hid_keyboard_req+0x72>
		if (req->wIndex == _hiddf_keyboard_funcd.func_iface) {
    f26a:	4c0b      	ldr	r4, [pc, #44]	; (f298 <hid_keyboard_req+0x78>)
    f26c:	888d      	ldrh	r5, [r1, #4]
    f26e:	7b23      	ldrb	r3, [r4, #12]
    f270:	429d      	cmp	r5, r3
    f272:	d10e      	bne.n	f292 <hid_keyboard_req+0x72>
			switch (req->bRequest) {
    f274:	784b      	ldrb	r3, [r1, #1]
    f276:	2b03      	cmp	r3, #3
    f278:	d007      	beq.n	f28a <hid_keyboard_req+0x6a>
    f27a:	2b0b      	cmp	r3, #11
    f27c:	d1e2      	bne.n	f244 <hid_keyboard_req+0x24>
				_hiddf_keyboard_funcd.protocol = req->wValue;
    f27e:	884b      	ldrh	r3, [r1, #2]
    f280:	73e3      	strb	r3, [r4, #15]
				return usbdc_xfer(ep, NULL, 0, 0);
    f282:	2300      	movs	r3, #0
    f284:	461a      	mov	r2, r3
    f286:	4619      	mov	r1, r3
    f288:	e7e3      	b.n	f252 <hid_keyboard_req+0x32>
				return usbdc_xfer(ep, &_hiddf_keyboard_funcd.protocol, 1, 0);
    f28a:	2300      	movs	r3, #0
    f28c:	f104 010f 	add.w	r1, r4, #15
    f290:	e7df      	b.n	f252 <hid_keyboard_req+0x32>
			return ERR_NOT_FOUND;
    f292:	f06f 0009 	mvn.w	r0, #9
	(void)stage;
    f296:	e7d7      	b.n	f248 <hid_keyboard_req+0x28>
    f298:	20008b40 	.word	0x20008b40
    f29c:	00013c9d 	.word	0x00013c9d
    f2a0:	000170f5 	.word	0x000170f5

0000f2a4 <hid_keyboard_ctrl>:
	switch (ctrl) {
    f2a4:	2901      	cmp	r1, #1
{
    f2a6:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f2aa:	4615      	mov	r5, r2
	switch (ctrl) {
    f2ac:	d04b      	beq.n	f346 <hid_keyboard_ctrl+0xa2>
    f2ae:	2902      	cmp	r1, #2
    f2b0:	d066      	beq.n	f380 <hid_keyboard_ctrl+0xdc>
    f2b2:	2900      	cmp	r1, #0
    f2b4:	d167      	bne.n	f386 <hid_keyboard_ctrl+0xe2>
	ifc = desc->sod;
    f2b6:	6813      	ldr	r3, [r2, #0]
		return hid_keyboard_enable(drv, (struct usbd_descriptors *)param);
    f2b8:	f8d0 8008 	ldr.w	r8, [r0, #8]
	if (NULL == ifc) {
    f2bc:	b923      	cbnz	r3, f2c8 <hid_keyboard_ctrl+0x24>
		return ERR_NOT_FOUND;
    f2be:	f06f 0409 	mvn.w	r4, #9
}
    f2c2:	4620      	mov	r0, r4
    f2c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    f2c8:	7959      	ldrb	r1, [r3, #5]
	ifc_desc.bInterfaceNumber = ifc[2];
    f2ca:	789a      	ldrb	r2, [r3, #2]
	if (HID_CLASS == ifc_desc.bInterfaceClass) {
    f2cc:	2903      	cmp	r1, #3
    f2ce:	d1f6      	bne.n	f2be <hid_keyboard_ctrl+0x1a>
		if (func_data->func_iface == ifc_desc.bInterfaceNumber) { // Initialized
    f2d0:	f898 100c 	ldrb.w	r1, [r8, #12]
    f2d4:	428a      	cmp	r2, r1
    f2d6:	d059      	beq.n	f38c <hid_keyboard_ctrl+0xe8>
		} else if (func_data->func_iface != 0xFF) { // Occupied
    f2d8:	29ff      	cmp	r1, #255	; 0xff
    f2da:	d15a      	bne.n	f392 <hid_keyboard_ctrl+0xee>
			func_data->func_iface = ifc_desc.bInterfaceNumber;
    f2dc:	f888 200c 	strb.w	r2, [r8, #12]
	return (desc + usb_desc_len(desc));
    f2e0:	7818      	ldrb	r0, [r3, #0]
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    f2e2:	6869      	ldr	r1, [r5, #4]
    f2e4:	4e2e      	ldr	r6, [pc, #184]	; (f3a0 <hid_keyboard_ctrl+0xfc>)
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    f2e6:	f8df b0c8 	ldr.w	fp, [pc, #200]	; f3b0 <hid_keyboard_ctrl+0x10c>
    f2ea:	f8df 90c8 	ldr.w	r9, [pc, #200]	; f3b4 <hid_keyboard_ctrl+0x110>
	_hiddf_keyboard_funcd.hid_desc = usb_find_desc(usb_desc_next(desc->sod), desc->eod, USB_DT_HID);
    f2ee:	4418      	add	r0, r3
    f2f0:	2221      	movs	r2, #33	; 0x21
    f2f2:	4b2c      	ldr	r3, [pc, #176]	; (f3a4 <hid_keyboard_ctrl+0x100>)
    f2f4:	4798      	blx	r3
    f2f6:	2702      	movs	r7, #2
    f2f8:	6030      	str	r0, [r6, #0]
		ep        = usb_find_ep_desc(usb_desc_next(desc->sod), desc->eod);
    f2fa:	682b      	ldr	r3, [r5, #0]
    f2fc:	6869      	ldr	r1, [r5, #4]
    f2fe:	7818      	ldrb	r0, [r3, #0]
    f300:	4418      	add	r0, r3
    f302:	4b29      	ldr	r3, [pc, #164]	; (f3a8 <hid_keyboard_ctrl+0x104>)
    f304:	4798      	blx	r3
		desc->sod = ep;
    f306:	6028      	str	r0, [r5, #0]
		if (NULL != ep) {
    f308:	2800      	cmp	r0, #0
    f30a:	d0d8      	beq.n	f2be <hid_keyboard_ctrl+0x1a>
	return (ptr[0] + (ptr[1] << 8));
    f30c:	7941      	ldrb	r1, [r0, #5]
    f30e:	7902      	ldrb	r2, [r0, #4]
			ep_desc.bEndpointAddress = ep[2];
    f310:	f890 a002 	ldrb.w	sl, [r0, #2]
    f314:	eb02 2201 	add.w	r2, r2, r1, lsl #8
			if (usb_d_ep_init(ep_desc.bEndpointAddress, ep_desc.bmAttributes, ep_desc.wMaxPacketSize)) {
    f318:	b292      	uxth	r2, r2
    f31a:	78c1      	ldrb	r1, [r0, #3]
    f31c:	4650      	mov	r0, sl
    f31e:	47d8      	blx	fp
    f320:	4604      	mov	r4, r0
    f322:	2800      	cmp	r0, #0
    f324:	d138      	bne.n	f398 <hid_keyboard_ctrl+0xf4>
			if (ep_desc.bEndpointAddress & USB_EP_DIR_IN) {
    f326:	f01a 0f80 	tst.w	sl, #128	; 0x80
				func_data->func_ep_in = ep_desc.bEndpointAddress;
    f32a:	bf14      	ite	ne
    f32c:	f888 a00d 	strbne.w	sl, [r8, #13]
				func_data->func_ep_out = ep_desc.bEndpointAddress;
    f330:	f888 a00e 	strbeq.w	sl, [r8, #14]
				usb_d_ep_enable(func_data->func_ep_out);
    f334:	4650      	mov	r0, sl
    f336:	47c8      	blx	r9
	for (i = 0; i < 2; i++) {
    f338:	2f01      	cmp	r7, #1
    f33a:	d102      	bne.n	f342 <hid_keyboard_ctrl+0x9e>
	_hiddf_keyboard_funcd.protocol = 1;
    f33c:	73f7      	strb	r7, [r6, #15]
	_hiddf_keyboard_funcd.enabled  = true;
    f33e:	7437      	strb	r7, [r6, #16]
	return ERR_NONE;
    f340:	e7bf      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
    f342:	2701      	movs	r7, #1
    f344:	e7d9      	b.n	f2fa <hid_keyboard_ctrl+0x56>
		return hid_keyboard_disable(drv, (struct usbd_descriptors *)param);
    f346:	6884      	ldr	r4, [r0, #8]
	if (desc) {
    f348:	b11a      	cbz	r2, f352 <hid_keyboard_ctrl+0xae>
		ifc_desc.bInterfaceClass = desc->sod[5];
    f34a:	6813      	ldr	r3, [r2, #0]
		if (ifc_desc.bInterfaceClass != HID_CLASS) {
    f34c:	795b      	ldrb	r3, [r3, #5]
    f34e:	2b03      	cmp	r3, #3
    f350:	d1b5      	bne.n	f2be <hid_keyboard_ctrl+0x1a>
	if (func_data->func_iface != 0xFF) {
    f352:	7b23      	ldrb	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    f354:	7b60      	ldrb	r0, [r4, #13]
	if (func_data->func_iface != 0xFF) {
    f356:	2bff      	cmp	r3, #255	; 0xff
		func_data->func_iface = 0xFF;
    f358:	bf1c      	itt	ne
    f35a:	23ff      	movne	r3, #255	; 0xff
    f35c:	7323      	strbne	r3, [r4, #12]
	if (func_data->func_ep_in != 0xFF) {
    f35e:	28ff      	cmp	r0, #255	; 0xff
    f360:	d003      	beq.n	f36a <hid_keyboard_ctrl+0xc6>
		usb_d_ep_deinit(func_data->func_ep_in);
    f362:	4b12      	ldr	r3, [pc, #72]	; (f3ac <hid_keyboard_ctrl+0x108>)
    f364:	4798      	blx	r3
		func_data->func_ep_in = 0xFF;
    f366:	23ff      	movs	r3, #255	; 0xff
    f368:	7363      	strb	r3, [r4, #13]
	if (func_data->func_ep_out != 0xFF) {
    f36a:	7ba0      	ldrb	r0, [r4, #14]
    f36c:	28ff      	cmp	r0, #255	; 0xff
    f36e:	d003      	beq.n	f378 <hid_keyboard_ctrl+0xd4>
		usb_d_ep_deinit(func_data->func_ep_out);
    f370:	4b0e      	ldr	r3, [pc, #56]	; (f3ac <hid_keyboard_ctrl+0x108>)
    f372:	4798      	blx	r3
		func_data->func_ep_out = 0xFF;
    f374:	23ff      	movs	r3, #255	; 0xff
    f376:	73a3      	strb	r3, [r4, #14]
	_hiddf_keyboard_funcd.enabled = false;
    f378:	4b09      	ldr	r3, [pc, #36]	; (f3a0 <hid_keyboard_ctrl+0xfc>)
    f37a:	2400      	movs	r4, #0
    f37c:	741c      	strb	r4, [r3, #16]
	return ERR_NONE;
    f37e:	e7a0      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
		return ERR_UNSUPPORTED_OP;
    f380:	f06f 041a 	mvn.w	r4, #26
    f384:	e79d      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
	switch (ctrl) {
    f386:	f06f 040c 	mvn.w	r4, #12
    f38a:	e79a      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
			return ERR_ALREADY_INITIALIZED;
    f38c:	f06f 0411 	mvn.w	r4, #17
    f390:	e797      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
			return ERR_NO_RESOURCE;
    f392:	f06f 041b 	mvn.w	r4, #27
    f396:	e794      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
				return ERR_NOT_INITIALIZED;
    f398:	f06f 0413 	mvn.w	r4, #19
    f39c:	e791      	b.n	f2c2 <hid_keyboard_ctrl+0x1e>
    f39e:	bf00      	nop
    f3a0:	20008b40 	.word	0x20008b40
    f3a4:	0000c14d 	.word	0x0000c14d
    f3a8:	0000c167 	.word	0x0000c167
    f3ac:	0000ff01 	.word	0x0000ff01
    f3b0:	0000fe9d 	.word	0x0000fe9d
    f3b4:	0000ff2d 	.word	0x0000ff2d

0000f3b8 <hiddf_keyboard_init>:

/**
 * \brief Initialize the USB HID Keyboard Function Driver
 */
int32_t hiddf_keyboard_init(void)
{
    f3b8:	b508      	push	{r3, lr}
	if (usbdc_get_state() > USBD_S_POWER) {
    f3ba:	4b0a      	ldr	r3, [pc, #40]	; (f3e4 <hiddf_keyboard_init+0x2c>)
    f3bc:	4798      	blx	r3
    f3be:	2801      	cmp	r0, #1
    f3c0:	d80c      	bhi.n	f3dc <hiddf_keyboard_init+0x24>
		return ERR_DENIED;
	}

	_hiddf_keyboard.ctrl      = hid_keyboard_ctrl;
    f3c2:	4809      	ldr	r0, [pc, #36]	; (f3e8 <hiddf_keyboard_init+0x30>)
    f3c4:	4b09      	ldr	r3, [pc, #36]	; (f3ec <hiddf_keyboard_init+0x34>)
	_hiddf_keyboard.func_data = &_hiddf_keyboard_funcd;
    f3c6:	e9c0 3006 	strd	r3, r0, [r0, #24]

	usbdc_register_function(&_hiddf_keyboard);
    f3ca:	4b09      	ldr	r3, [pc, #36]	; (f3f0 <hiddf_keyboard_init+0x38>)
    f3cc:	3014      	adds	r0, #20
    f3ce:	4798      	blx	r3
	usbdc_register_handler(USBDC_HDL_REQ, &hid_keyboard_req_h);
    f3d0:	2001      	movs	r0, #1
    f3d2:	4908      	ldr	r1, [pc, #32]	; (f3f4 <hiddf_keyboard_init+0x3c>)
    f3d4:	4b08      	ldr	r3, [pc, #32]	; (f3f8 <hiddf_keyboard_init+0x40>)
    f3d6:	4798      	blx	r3
	return ERR_NONE;
    f3d8:	2000      	movs	r0, #0
}
    f3da:	bd08      	pop	{r3, pc}
		return ERR_DENIED;
    f3dc:	f06f 0010 	mvn.w	r0, #16
    f3e0:	e7fb      	b.n	f3da <hiddf_keyboard_init+0x22>
    f3e2:	bf00      	nop
    f3e4:	000140d5 	.word	0x000140d5
    f3e8:	20008b40 	.word	0x20008b40
    f3ec:	0000f2a5 	.word	0x0000f2a5
    f3f0:	0001407d 	.word	0x0001407d
    f3f4:	20000504 	.word	0x20000504
    f3f8:	00013ff5 	.word	0x00013ff5

0000f3fc <hiddf_keyboard_keys_state_change>:
 * \param keys_desc[]  keys_descriptor array for state changing
 * \param keys_count   total keys amount for state changing
 * \return Operation status.
 */
int32_t hiddf_keyboard_keys_state_change(struct hiddf_kb_key_descriptors keys_desc[], uint8_t keys_count)
{
    f3fc:	b470      	push	{r4, r5, r6}
	return _hiddf_keyboard_funcd.enabled;
    f3fe:	4c20      	ldr	r4, [pc, #128]	; (f480 <hiddf_keyboard_keys_state_change+0x84>)
	uint8_t i, j;
	uint8_t modifier_keys, regular_keys;

	if (!hiddf_keyboard_is_enabled()) {
    f400:	7c23      	ldrb	r3, [r4, #16]
    f402:	2b00      	cmp	r3, #0
    f404:	d037      	beq.n	f476 <hiddf_keyboard_keys_state_change+0x7a>
		return ERR_DENIED;
	}

	memset(_hiddf_keyboard_funcd.kb_report, 0x00, 8);
    f406:	2300      	movs	r3, #0
    f408:	e9c4 3301 	strd	r3, r3, [r4, #4]
	modifier_keys = 0;
    f40c:	461a      	mov	r2, r3

	for (i = 0; i < keys_count; i++) {
		if (true == keys_desc[i].b_modifier) {
    f40e:	1c46      	adds	r6, r0, #1
	for (i = 0; i < keys_count; i++) {
    f410:	b2dd      	uxtb	r5, r3
    f412:	42a9      	cmp	r1, r5
    f414:	d814      	bhi.n	f440 <hiddf_keyboard_keys_state_change+0x44>
			modifier_keys++;
		}
	}

	regular_keys = keys_count - modifier_keys;
    f416:	1a8a      	subs	r2, r1, r2

	if (regular_keys > 6) {
    f418:	b2d2      	uxtb	r2, r2
    f41a:	2a06      	cmp	r2, #6
    f41c:	d818      	bhi.n	f450 <hiddf_keyboard_keys_state_change+0x54>
    f41e:	2500      	movs	r5, #0
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
	} else {
		i = 2;
    f420:	2302      	movs	r3, #2
		for (j = 0; j < keys_count; j++) {
    f422:	b2ea      	uxtb	r2, r5
    f424:	4291      	cmp	r1, r2
    f426:	d919      	bls.n	f45c <hiddf_keyboard_keys_state_change+0x60>
			if (HID_KB_KEY_DOWN == keys_desc[j].state) {
    f428:	7882      	ldrb	r2, [r0, #2]
    f42a:	2a01      	cmp	r2, #1
    f42c:	d105      	bne.n	f43a <hiddf_keyboard_keys_state_change+0x3e>
				if (true == keys_desc[j].b_modifier) {
    f42e:	7846      	ldrb	r6, [r0, #1]
    f430:	7802      	ldrb	r2, [r0, #0]
    f432:	b1de      	cbz	r6, f46c <hiddf_keyboard_keys_state_change+0x70>
					_hiddf_keyboard_funcd.kb_report[0] |= keys_desc[j].key_id;
    f434:	7926      	ldrb	r6, [r4, #4]
    f436:	4332      	orrs	r2, r6
    f438:	7122      	strb	r2, [r4, #4]
		for (j = 0; j < keys_count; j++) {
    f43a:	3501      	adds	r5, #1
    f43c:	3003      	adds	r0, #3
    f43e:	e7f0      	b.n	f422 <hiddf_keyboard_keys_state_change+0x26>
		if (true == keys_desc[i].b_modifier) {
    f440:	eb03 0543 	add.w	r5, r3, r3, lsl #1
    f444:	5d75      	ldrb	r5, [r6, r5]
    f446:	b10d      	cbz	r5, f44c <hiddf_keyboard_keys_state_change+0x50>
			modifier_keys++;
    f448:	3201      	adds	r2, #1
    f44a:	b2d2      	uxtb	r2, r2
	for (i = 0; i < keys_count; i++) {
    f44c:	3301      	adds	r3, #1
    f44e:	e7df      	b.n	f410 <hiddf_keyboard_keys_state_change+0x14>
		memset(&_hiddf_keyboard_funcd.kb_report[2], 0xFF, 6);
    f450:	4a0c      	ldr	r2, [pc, #48]	; (f484 <hiddf_keyboard_keys_state_change+0x88>)
    f452:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    f456:	f8c4 3006 	str.w	r3, [r4, #6]
    f45a:	8093      	strh	r3, [r2, #4]
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
				}
			}
		}
	}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    f45c:	7b60      	ldrb	r0, [r4, #13]
    f45e:	4c0a      	ldr	r4, [pc, #40]	; (f488 <hiddf_keyboard_keys_state_change+0x8c>)
    f460:	490a      	ldr	r1, [pc, #40]	; (f48c <hiddf_keyboard_keys_state_change+0x90>)
    f462:	46a4      	mov	ip, r4
    f464:	2300      	movs	r3, #0
}
    f466:	bc70      	pop	{r4, r5, r6}
	return usbdc_xfer(_hiddf_keyboard_funcd.func_ep_in, &_hiddf_keyboard_funcd.kb_report[0], 8, false);
    f468:	2208      	movs	r2, #8
    f46a:	4760      	bx	ip
					_hiddf_keyboard_funcd.kb_report[i++] = keys_desc[j].key_id;
    f46c:	1c5e      	adds	r6, r3, #1
    f46e:	4423      	add	r3, r4
    f470:	711a      	strb	r2, [r3, #4]
    f472:	b2f3      	uxtb	r3, r6
    f474:	e7e1      	b.n	f43a <hiddf_keyboard_keys_state_change+0x3e>
}
    f476:	f06f 0010 	mvn.w	r0, #16
    f47a:	bc70      	pop	{r4, r5, r6}
    f47c:	4770      	bx	lr
    f47e:	bf00      	nop
    f480:	20008b40 	.word	0x20008b40
    f484:	20008b46 	.word	0x20008b46
    f488:	00013c9d 	.word	0x00013c9d
    f48c:	20008b44 	.word	0x20008b44

0000f490 <usart_sync_write>:
 * \param[in] length The number of bytes to write
 *
 * \return The number of bytes written.
 */
static int32_t usart_sync_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
    f490:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f494:	460e      	mov	r6, r1
    f496:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    f498:	4604      	mov	r4, r0
    f49a:	b118      	cbz	r0, f4a4 <usart_sync_write+0x14>
    f49c:	b329      	cbz	r1, f4ea <usart_sync_write+0x5a>
    f49e:	1e10      	subs	r0, r2, #0
    f4a0:	bf18      	it	ne
    f4a2:	2001      	movne	r0, #1
    f4a4:	4912      	ldr	r1, [pc, #72]	; (f4f0 <usart_sync_write+0x60>)
    f4a6:	4b13      	ldr	r3, [pc, #76]	; (f4f4 <usart_sync_write+0x64>)
	while (!_usart_sync_is_ready_to_send(&descr->device))
    f4a8:	4f13      	ldr	r7, [pc, #76]	; (f4f8 <usart_sync_write+0x68>)
	ASSERT(io_descr && buf && length);
    f4aa:	22f1      	movs	r2, #241	; 0xf1
    f4ac:	4798      	blx	r3
	while (!_usart_sync_is_ready_to_send(&descr->device))
    f4ae:	3408      	adds	r4, #8
    f4b0:	46b9      	mov	r9, r7
    f4b2:	4620      	mov	r0, r4
    f4b4:	47b8      	blx	r7
    f4b6:	2800      	cmp	r0, #0
    f4b8:	d0fb      	beq.n	f4b2 <usart_sync_write+0x22>
		;
	do {
		_usart_sync_write_byte(&descr->device, buf[offset]);
    f4ba:	f8df 8044 	ldr.w	r8, [pc, #68]	; f500 <usart_sync_write+0x70>
	uint32_t                      offset = 0;
    f4be:	2700      	movs	r7, #0
		_usart_sync_write_byte(&descr->device, buf[offset]);
    f4c0:	5df1      	ldrb	r1, [r6, r7]
    f4c2:	4620      	mov	r0, r4
    f4c4:	47c0      	blx	r8
		while (!_usart_sync_is_ready_to_send(&descr->device))
    f4c6:	4620      	mov	r0, r4
    f4c8:	47c8      	blx	r9
    f4ca:	2800      	cmp	r0, #0
    f4cc:	d0fb      	beq.n	f4c6 <usart_sync_write+0x36>
			;
	} while (++offset < length);
    f4ce:	3701      	adds	r7, #1
    f4d0:	42bd      	cmp	r5, r7
    f4d2:	d8f5      	bhi.n	f4c0 <usart_sync_write+0x30>
    f4d4:	2d00      	cmp	r5, #0
	while (!_usart_sync_is_transmit_done(&descr->device))
    f4d6:	4e09      	ldr	r6, [pc, #36]	; (f4fc <usart_sync_write+0x6c>)
    f4d8:	bf08      	it	eq
    f4da:	2501      	moveq	r5, #1
    f4dc:	4620      	mov	r0, r4
    f4de:	47b0      	blx	r6
    f4e0:	2800      	cmp	r0, #0
    f4e2:	d0fb      	beq.n	f4dc <usart_sync_write+0x4c>
		;
	return (int32_t)offset;
}
    f4e4:	4628      	mov	r0, r5
    f4e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    f4ea:	4608      	mov	r0, r1
    f4ec:	e7da      	b.n	f4a4 <usart_sync_write+0x14>
    f4ee:	bf00      	nop
    f4f0:	00017130 	.word	0x00017130
    f4f4:	0000e9b9 	.word	0x0000e9b9
    f4f8:	000119e5 	.word	0x000119e5
    f4fc:	000119ef 	.word	0x000119ef
    f500:	000119d1 	.word	0x000119d1

0000f504 <usart_sync_read>:
 * \param[in] length The size of a buffer
 *
 * \return The number of bytes read.
 */
static int32_t usart_sync_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
    f504:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f508:	460e      	mov	r6, r1
    f50a:	4615      	mov	r5, r2
	uint32_t                      offset = 0;
	struct usart_sync_descriptor *descr  = CONTAINER_OF(io_descr, struct usart_sync_descriptor, io);

	ASSERT(io_descr && buf && length);
    f50c:	4604      	mov	r4, r0
    f50e:	b118      	cbz	r0, f518 <usart_sync_read+0x14>
    f510:	b1e9      	cbz	r1, f54e <usart_sync_read+0x4a>
    f512:	1e10      	subs	r0, r2, #0
    f514:	bf18      	it	ne
    f516:	2001      	movne	r0, #1
    f518:	490e      	ldr	r1, [pc, #56]	; (f554 <usart_sync_read+0x50>)
    f51a:	4b0f      	ldr	r3, [pc, #60]	; (f558 <usart_sync_read+0x54>)
	do {
		while (!_usart_sync_is_byte_received(&descr->device))
    f51c:	f8df 903c 	ldr.w	r9, [pc, #60]	; f55c <usart_sync_read+0x58>
			;
		buf[offset] = _usart_sync_read_byte(&descr->device);
    f520:	f8df 803c 	ldr.w	r8, [pc, #60]	; f560 <usart_sync_read+0x5c>
	ASSERT(io_descr && buf && length);
    f524:	f44f 7286 	mov.w	r2, #268	; 0x10c
    f528:	4798      	blx	r3
	uint32_t                      offset = 0;
    f52a:	2700      	movs	r7, #0
		while (!_usart_sync_is_byte_received(&descr->device))
    f52c:	3408      	adds	r4, #8
    f52e:	4620      	mov	r0, r4
    f530:	47c8      	blx	r9
    f532:	2800      	cmp	r0, #0
    f534:	d0fb      	beq.n	f52e <usart_sync_read+0x2a>
		buf[offset] = _usart_sync_read_byte(&descr->device);
    f536:	4620      	mov	r0, r4
    f538:	47c0      	blx	r8
    f53a:	55f0      	strb	r0, [r6, r7]
	} while (++offset < length);
    f53c:	3701      	adds	r7, #1
    f53e:	42bd      	cmp	r5, r7
    f540:	d8f5      	bhi.n	f52e <usart_sync_read+0x2a>

	return (int32_t)offset;
    f542:	2d00      	cmp	r5, #0
}
    f544:	bf14      	ite	ne
    f546:	4628      	movne	r0, r5
    f548:	2001      	moveq	r0, #1
    f54a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(io_descr && buf && length);
    f54e:	4608      	mov	r0, r1
    f550:	e7e2      	b.n	f518 <usart_sync_read+0x14>
    f552:	bf00      	nop
    f554:	00017130 	.word	0x00017130
    f558:	0000e9b9 	.word	0x0000e9b9
    f55c:	000119f9 	.word	0x000119f9
    f560:	000119dd 	.word	0x000119dd

0000f564 <usart_sync_init>:
{
    f564:	b538      	push	{r3, r4, r5, lr}
    f566:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    f568:	4604      	mov	r4, r0
    f56a:	b110      	cbz	r0, f572 <usart_sync_init+0xe>
    f56c:	1e08      	subs	r0, r1, #0
    f56e:	bf18      	it	ne
    f570:	2001      	movne	r0, #1
    f572:	4907      	ldr	r1, [pc, #28]	; (f590 <usart_sync_init+0x2c>)
    f574:	4b07      	ldr	r3, [pc, #28]	; (f594 <usart_sync_init+0x30>)
    f576:	2234      	movs	r2, #52	; 0x34
    f578:	4798      	blx	r3
	init_status = _usart_sync_init(&descr->device, hw);
    f57a:	4b07      	ldr	r3, [pc, #28]	; (f598 <usart_sync_init+0x34>)
    f57c:	4629      	mov	r1, r5
    f57e:	f104 0008 	add.w	r0, r4, #8
    f582:	4798      	blx	r3
	if (init_status) {
    f584:	b918      	cbnz	r0, f58e <usart_sync_init+0x2a>
	descr->io.read  = usart_sync_read;
    f586:	4b05      	ldr	r3, [pc, #20]	; (f59c <usart_sync_init+0x38>)
    f588:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_sync_write;
    f58a:	4b05      	ldr	r3, [pc, #20]	; (f5a0 <usart_sync_init+0x3c>)
    f58c:	6023      	str	r3, [r4, #0]
}
    f58e:	bd38      	pop	{r3, r4, r5, pc}
    f590:	00017130 	.word	0x00017130
    f594:	0000e9b9 	.word	0x0000e9b9
    f598:	000118ed 	.word	0x000118ed
    f59c:	0000f505 	.word	0x0000f505
    f5a0:	0000f491 	.word	0x0000f491

0000f5a4 <usart_sync_enable>:
{
    f5a4:	b510      	push	{r4, lr}
	ASSERT(descr);
    f5a6:	4604      	mov	r4, r0
    f5a8:	3800      	subs	r0, #0
    f5aa:	bf18      	it	ne
    f5ac:	2001      	movne	r0, #1
    f5ae:	4905      	ldr	r1, [pc, #20]	; (f5c4 <usart_sync_enable+0x20>)
    f5b0:	4b05      	ldr	r3, [pc, #20]	; (f5c8 <usart_sync_enable+0x24>)
    f5b2:	2253      	movs	r2, #83	; 0x53
    f5b4:	4798      	blx	r3
	_usart_sync_enable(&descr->device);
    f5b6:	f104 0008 	add.w	r0, r4, #8
    f5ba:	4b04      	ldr	r3, [pc, #16]	; (f5cc <usart_sync_enable+0x28>)
    f5bc:	4798      	blx	r3
}
    f5be:	2000      	movs	r0, #0
    f5c0:	bd10      	pop	{r4, pc}
    f5c2:	bf00      	nop
    f5c4:	00017130 	.word	0x00017130
    f5c8:	0000e9b9 	.word	0x0000e9b9
    f5cc:	00011991 	.word	0x00011991

0000f5d0 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
    f5d0:	4b01      	ldr	r3, [pc, #4]	; (f5d8 <_mclk_init+0x8>)
    f5d2:	2201      	movs	r2, #1
    f5d4:	715a      	strb	r2, [r3, #5]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_DIV(CONF_MCLK_CPUDIV));
}
    f5d6:	4770      	bx	lr
    f5d8:	40000800 	.word	0x40000800

0000f5dc <hri_gclk_wait_for_sync.constprop.0>:
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
    f5dc:	4903      	ldr	r1, [pc, #12]	; (f5ec <hri_gclk_wait_for_sync.constprop.0+0x10>)
    f5de:	f643 73fd 	movw	r3, #16381	; 0x3ffd
    f5e2:	684a      	ldr	r2, [r1, #4]
    f5e4:	421a      	tst	r2, r3
    f5e6:	d1fc      	bne.n	f5e2 <hri_gclk_wait_for_sync.constprop.0+0x6>
}
    f5e8:	4770      	bx	lr
    f5ea:	bf00      	nop
    f5ec:	40001c00 	.word	0x40001c00

0000f5f0 <_gclk_init_generators_by_fref>:
	        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
#endif
}

void _gclk_init_generators_by_fref(uint32_t bm)
{
    f5f0:	b510      	push	{r4, lr}

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
    f5f2:	07c4      	lsls	r4, r0, #31
    f5f4:	d504      	bpl.n	f600 <_gclk_init_generators_by_fref+0x10>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f5f6:	4b0e      	ldr	r3, [pc, #56]	; (f630 <_gclk_init_generators_by_fref+0x40>)
    f5f8:	4a0e      	ldr	r2, [pc, #56]	; (f634 <_gclk_init_generators_by_fref+0x44>)
    f5fa:	621a      	str	r2, [r3, #32]
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f5fc:	4b0e      	ldr	r3, [pc, #56]	; (f638 <_gclk_init_generators_by_fref+0x48>)
    f5fe:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_0_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_0_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_1_CONFIG == 1
	if (bm & (1ul << 1)) {
    f600:	0781      	lsls	r1, r0, #30
    f602:	d504      	bpl.n	f60e <_gclk_init_generators_by_fref+0x1e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f604:	4b0a      	ldr	r3, [pc, #40]	; (f630 <_gclk_init_generators_by_fref+0x40>)
    f606:	4a0d      	ldr	r2, [pc, #52]	; (f63c <_gclk_init_generators_by_fref+0x4c>)
    f608:	625a      	str	r2, [r3, #36]	; 0x24
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f60a:	4b0b      	ldr	r3, [pc, #44]	; (f638 <_gclk_init_generators_by_fref+0x48>)
    f60c:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_1_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_1_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_2_CONFIG == 1
	if (bm & (1ul << 2)) {
    f60e:	0742      	lsls	r2, r0, #29
    f610:	d504      	bpl.n	f61c <_gclk_init_generators_by_fref+0x2c>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f612:	4b07      	ldr	r3, [pc, #28]	; (f630 <_gclk_init_generators_by_fref+0x40>)
    f614:	4a0a      	ldr	r2, [pc, #40]	; (f640 <_gclk_init_generators_by_fref+0x50>)
    f616:	629a      	str	r2, [r3, #40]	; 0x28
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f618:	4b07      	ldr	r3, [pc, #28]	; (f638 <_gclk_init_generators_by_fref+0x48>)
    f61a:	4798      	blx	r3
		        | (CONF_GCLK_GENERATOR_2_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_2_SOURCE);
	}
#endif

#if CONF_GCLK_GENERATOR_3_CONFIG == 1
	if (bm & (1ul << 3)) {
    f61c:	0703      	lsls	r3, r0, #28
    f61e:	d506      	bpl.n	f62e <_gclk_init_generators_by_fref+0x3e>
	((Gclk *)hw)->GENCTRL[index].reg = data;
    f620:	4b03      	ldr	r3, [pc, #12]	; (f630 <_gclk_init_generators_by_fref+0x40>)
    f622:	4a08      	ldr	r2, [pc, #32]	; (f644 <_gclk_init_generators_by_fref+0x54>)
    f624:	62da      	str	r2, [r3, #44]	; 0x2c
		        | (CONF_GCLK_GEN_11_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_11_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_11_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_11_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_11_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_11_SOURCE);
	}
#endif
}
    f626:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_gclk_wait_for_sync(hw, GCLK_SYNCBUSY_MASK);
    f62a:	4b03      	ldr	r3, [pc, #12]	; (f638 <_gclk_init_generators_by_fref+0x48>)
    f62c:	4718      	bx	r3
    f62e:	bd10      	pop	{r4, pc}
    f630:	40001c00 	.word	0x40001c00
    f634:	00010108 	.word	0x00010108
    f638:	0000f5dd 	.word	0x0000f5dd
    f63c:	00010106 	.word	0x00010106
    f640:	00100106 	.word	0x00100106
    f644:	00010104 	.word	0x00010104

0000f648 <stdio_redirect_init>:
	/* Print welcome message */
	printf("\r\nHello ATMEL World!\r\n");
}

void stdio_redirect_init(void)
{
    f648:	b510      	push	{r4, lr}

	usart_sync_enable(&GRID_AUX);
    f64a:	4c04      	ldr	r4, [pc, #16]	; (f65c <stdio_redirect_init+0x14>)
    f64c:	4b04      	ldr	r3, [pc, #16]	; (f660 <stdio_redirect_init+0x18>)
    f64e:	4620      	mov	r0, r4
    f650:	4798      	blx	r3
	stdio_io_init(&GRID_AUX.io);
    f652:	4620      	mov	r0, r4
    f654:	4b03      	ldr	r3, [pc, #12]	; (f664 <stdio_redirect_init+0x1c>)
}
    f656:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_io_init(&GRID_AUX.io);
    f65a:	4718      	bx	r3
    f65c:	2001cd70 	.word	0x2001cd70
    f660:	0000f5a5 	.word	0x0000f5a5
    f664:	0000c1ed 	.word	0x0000c1ed

0000f668 <flash_ready>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_ready(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_ready) {
    f668:	6943      	ldr	r3, [r0, #20]
    f66a:	b103      	cbz	r3, f66e <flash_ready+0x6>
		descr->callbacks.cb_ready(descr);
    f66c:	4718      	bx	r3
	}
}
    f66e:	4770      	bx	lr

0000f670 <flash_error>:
 * \param[in] device The pointer to flash device structure
 */
static void flash_error(struct _flash_device *device)
{
	struct flash_descriptor *const descr = CONTAINER_OF(device, struct flash_descriptor, dev);
	if (descr->callbacks.cb_error) {
    f670:	6983      	ldr	r3, [r0, #24]
    f672:	b103      	cbz	r3, f676 <flash_error+0x6>
		descr->callbacks.cb_error(descr);
    f674:	4718      	bx	r3
	}
}
    f676:	4770      	bx	lr

0000f678 <flash_is_address_aligned>:
{
    f678:	b538      	push	{r3, r4, r5, lr}
	ASSERT(flash);
    f67a:	4604      	mov	r4, r0
    f67c:	3800      	subs	r0, #0
    f67e:	bf18      	it	ne
    f680:	2001      	movne	r0, #1
{
    f682:	460d      	mov	r5, r1
	ASSERT(flash);
    f684:	f240 1217 	movw	r2, #279	; 0x117
    f688:	4906      	ldr	r1, [pc, #24]	; (f6a4 <flash_is_address_aligned+0x2c>)
    f68a:	4b07      	ldr	r3, [pc, #28]	; (f6a8 <flash_is_address_aligned+0x30>)
    f68c:	4798      	blx	r3
	uint32_t page_size = _flash_get_page_size(&flash->dev);
    f68e:	4b07      	ldr	r3, [pc, #28]	; (f6ac <flash_is_address_aligned+0x34>)
    f690:	4620      	mov	r0, r4
    f692:	4798      	blx	r3
	if (flash_addr & (page_size - 1)) {
    f694:	3801      	subs	r0, #1
    f696:	4228      	tst	r0, r5
}
    f698:	bf14      	ite	ne
    f69a:	f06f 000d 	mvnne.w	r0, #13
    f69e:	2000      	moveq	r0, #0
    f6a0:	bd38      	pop	{r3, r4, r5, pc}
    f6a2:	bf00      	nop
    f6a4:	0001714c 	.word	0x0001714c
    f6a8:	0000e9b9 	.word	0x0000e9b9
    f6ac:	0000c8ad 	.word	0x0000c8ad

0000f6b0 <flash_init>:
{
    f6b0:	b538      	push	{r3, r4, r5, lr}
    f6b2:	460d      	mov	r5, r1
	ASSERT(flash && hw);
    f6b4:	4604      	mov	r4, r0
    f6b6:	b110      	cbz	r0, f6be <flash_init+0xe>
    f6b8:	1e08      	subs	r0, r1, #0
    f6ba:	bf18      	it	ne
    f6bc:	2001      	movne	r0, #1
    f6be:	4907      	ldr	r1, [pc, #28]	; (f6dc <flash_init+0x2c>)
    f6c0:	4b07      	ldr	r3, [pc, #28]	; (f6e0 <flash_init+0x30>)
    f6c2:	2238      	movs	r2, #56	; 0x38
    f6c4:	4798      	blx	r3
	rc = _flash_init(&flash->dev, hw);
    f6c6:	4b07      	ldr	r3, [pc, #28]	; (f6e4 <flash_init+0x34>)
    f6c8:	4629      	mov	r1, r5
    f6ca:	4620      	mov	r0, r4
    f6cc:	4798      	blx	r3
	if (rc) {
    f6ce:	b918      	cbnz	r0, f6d8 <flash_init+0x28>
	flash->dev.flash_cb.ready_cb = flash_ready;
    f6d0:	4b05      	ldr	r3, [pc, #20]	; (f6e8 <flash_init+0x38>)
    f6d2:	6023      	str	r3, [r4, #0]
	flash->dev.flash_cb.error_cb = flash_error;
    f6d4:	4b05      	ldr	r3, [pc, #20]	; (f6ec <flash_init+0x3c>)
    f6d6:	6063      	str	r3, [r4, #4]
}
    f6d8:	bd38      	pop	{r3, r4, r5, pc}
    f6da:	bf00      	nop
    f6dc:	0001714c 	.word	0x0001714c
    f6e0:	0000e9b9 	.word	0x0000e9b9
    f6e4:	0000c83d 	.word	0x0000c83d
    f6e8:	0000f669 	.word	0x0000f669
    f6ec:	0000f671 	.word	0x0000f671

0000f6f0 <flash_read>:
{
    f6f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f6f4:	460d      	mov	r5, r1
    f6f6:	4616      	mov	r6, r2
    f6f8:	461f      	mov	r7, r3
	ASSERT(flash && buffer && length);
    f6fa:	4604      	mov	r4, r0
    f6fc:	b118      	cbz	r0, f706 <flash_read+0x16>
    f6fe:	b1ea      	cbz	r2, f73c <flash_read+0x4c>
    f700:	1e18      	subs	r0, r3, #0
    f702:	bf18      	it	ne
    f704:	2001      	movne	r0, #1
    f706:	4910      	ldr	r1, [pc, #64]	; (f748 <flash_read+0x58>)
    f708:	4b10      	ldr	r3, [pc, #64]	; (f74c <flash_read+0x5c>)
    f70a:	2256      	movs	r2, #86	; 0x56
    f70c:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f70e:	4b10      	ldr	r3, [pc, #64]	; (f750 <flash_read+0x60>)
    f710:	4620      	mov	r0, r4
    f712:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f714:	4b0f      	ldr	r3, [pc, #60]	; (f754 <flash_read+0x64>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f716:	4680      	mov	r8, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f718:	4620      	mov	r0, r4
    f71a:	4798      	blx	r3
	if ((src_addr > page_size * total_pages) || (src_addr + length > page_size * total_pages)) {
    f71c:	fb00 f008 	mul.w	r0, r0, r8
    f720:	42a8      	cmp	r0, r5
    f722:	d30d      	bcc.n	f740 <flash_read+0x50>
    f724:	197b      	adds	r3, r7, r5
    f726:	4298      	cmp	r0, r3
    f728:	d30a      	bcc.n	f740 <flash_read+0x50>
	_flash_read(&flash->dev, src_addr, buffer, length);
    f72a:	4620      	mov	r0, r4
    f72c:	463b      	mov	r3, r7
    f72e:	4c0a      	ldr	r4, [pc, #40]	; (f758 <flash_read+0x68>)
    f730:	4632      	mov	r2, r6
    f732:	4629      	mov	r1, r5
    f734:	47a0      	blx	r4
	return ERR_NONE;
    f736:	2000      	movs	r0, #0
}
    f738:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    f73c:	4610      	mov	r0, r2
    f73e:	e7e2      	b.n	f706 <flash_read+0x16>
		return ERR_BAD_ADDRESS;
    f740:	f06f 000d 	mvn.w	r0, #13
    f744:	e7f8      	b.n	f738 <flash_read+0x48>
    f746:	bf00      	nop
    f748:	0001714c 	.word	0x0001714c
    f74c:	0000e9b9 	.word	0x0000e9b9
    f750:	0000c8ad 	.word	0x0000c8ad
    f754:	0000c8b3 	.word	0x0000c8b3
    f758:	0000c8bb 	.word	0x0000c8bb

0000f75c <flash_write>:
{
    f75c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f760:	460e      	mov	r6, r1
    f762:	4617      	mov	r7, r2
    f764:	4698      	mov	r8, r3
	ASSERT(flash && buffer && length);
    f766:	4605      	mov	r5, r0
    f768:	b118      	cbz	r0, f772 <flash_write+0x16>
    f76a:	b31a      	cbz	r2, f7b4 <flash_write+0x58>
    f76c:	1e18      	subs	r0, r3, #0
    f76e:	bf18      	it	ne
    f770:	2001      	movne	r0, #1
    f772:	4914      	ldr	r1, [pc, #80]	; (f7c4 <flash_write+0x68>)
    f774:	4b14      	ldr	r3, [pc, #80]	; (f7c8 <flash_write+0x6c>)
    f776:	226a      	movs	r2, #106	; 0x6a
    f778:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f77a:	4b14      	ldr	r3, [pc, #80]	; (f7cc <flash_write+0x70>)
    f77c:	4628      	mov	r0, r5
    f77e:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f780:	4b13      	ldr	r3, [pc, #76]	; (f7d0 <flash_write+0x74>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f782:	4604      	mov	r4, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f784:	4628      	mov	r0, r5
    f786:	4798      	blx	r3
	if ((dst_addr > page_size * total_pages) || (dst_addr + length > page_size * total_pages)) {
    f788:	4360      	muls	r0, r4
    f78a:	42b0      	cmp	r0, r6
    f78c:	d314      	bcc.n	f7b8 <flash_write+0x5c>
    f78e:	eb08 0306 	add.w	r3, r8, r6
    f792:	4298      	cmp	r0, r3
    f794:	d310      	bcc.n	f7b8 <flash_write+0x5c>
	if (_flash_is_locked(&flash->dev, dst_addr)) {
    f796:	4b0f      	ldr	r3, [pc, #60]	; (f7d4 <flash_write+0x78>)
    f798:	4631      	mov	r1, r6
    f79a:	4628      	mov	r0, r5
    f79c:	4798      	blx	r3
    f79e:	4604      	mov	r4, r0
    f7a0:	b968      	cbnz	r0, f7be <flash_write+0x62>
	_flash_write(&flash->dev, dst_addr, buffer, length);
    f7a2:	4628      	mov	r0, r5
    f7a4:	4643      	mov	r3, r8
    f7a6:	4d0c      	ldr	r5, [pc, #48]	; (f7d8 <flash_write+0x7c>)
    f7a8:	463a      	mov	r2, r7
    f7aa:	4631      	mov	r1, r6
    f7ac:	47a8      	blx	r5
	return ERR_NONE;
    f7ae:	4620      	mov	r0, r4
}
    f7b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(flash && buffer && length);
    f7b4:	4610      	mov	r0, r2
    f7b6:	e7dc      	b.n	f772 <flash_write+0x16>
		return ERR_BAD_ADDRESS;
    f7b8:	f06f 000d 	mvn.w	r0, #13
    f7bc:	e7f8      	b.n	f7b0 <flash_write+0x54>
		return ERR_DENIED;
    f7be:	f06f 0010 	mvn.w	r0, #16
    f7c2:	e7f5      	b.n	f7b0 <flash_write+0x54>
    f7c4:	0001714c 	.word	0x0001714c
    f7c8:	0000e9b9 	.word	0x0000e9b9
    f7cc:	0000c8ad 	.word	0x0000c8ad
    f7d0:	0000c8b3 	.word	0x0000c8b3
    f7d4:	0000ca49 	.word	0x0000ca49
    f7d8:	0000c8d5 	.word	0x0000c8d5

0000f7dc <flash_erase>:
{
    f7dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    f7e0:	4688      	mov	r8, r1
    f7e2:	4617      	mov	r7, r2
	ASSERT(flash && page_nums);
    f7e4:	4604      	mov	r4, r0
    f7e6:	b110      	cbz	r0, f7ee <flash_erase+0x12>
    f7e8:	1e10      	subs	r0, r2, #0
    f7ea:	bf18      	it	ne
    f7ec:	2001      	movne	r0, #1
    f7ee:	4912      	ldr	r1, [pc, #72]	; (f838 <flash_erase+0x5c>)
    f7f0:	4b12      	ldr	r3, [pc, #72]	; (f83c <flash_erase+0x60>)
    f7f2:	229a      	movs	r2, #154	; 0x9a
    f7f4:	4798      	blx	r3
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f7f6:	4b12      	ldr	r3, [pc, #72]	; (f840 <flash_erase+0x64>)
    f7f8:	4620      	mov	r0, r4
    f7fa:	4798      	blx	r3
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f7fc:	4b11      	ldr	r3, [pc, #68]	; (f844 <flash_erase+0x68>)
	uint32_t page_size   = _flash_get_page_size(&flash->dev);
    f7fe:	4605      	mov	r5, r0
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f800:	4620      	mov	r0, r4
    f802:	4798      	blx	r3
	rc = flash_is_address_aligned(flash, dst_addr);
    f804:	4b10      	ldr	r3, [pc, #64]	; (f848 <flash_erase+0x6c>)
	uint32_t total_pages = _flash_get_total_pages(&flash->dev);
    f806:	4681      	mov	r9, r0
	rc = flash_is_address_aligned(flash, dst_addr);
    f808:	4641      	mov	r1, r8
    f80a:	4620      	mov	r0, r4
    f80c:	4798      	blx	r3
	if (rc) {
    f80e:	4606      	mov	r6, r0
    f810:	b958      	cbnz	r0, f82a <flash_erase+0x4e>
	if ((page_nums > total_pages) || (dst_addr / page_size + page_nums > total_pages)) {
    f812:	454f      	cmp	r7, r9
    f814:	d80c      	bhi.n	f830 <flash_erase+0x54>
    f816:	fbb8 f5f5 	udiv	r5, r8, r5
    f81a:	443d      	add	r5, r7
    f81c:	454d      	cmp	r5, r9
    f81e:	d807      	bhi.n	f830 <flash_erase+0x54>
	_flash_erase(&flash->dev, dst_addr, page_nums);
    f820:	4b0a      	ldr	r3, [pc, #40]	; (f84c <flash_erase+0x70>)
    f822:	463a      	mov	r2, r7
    f824:	4641      	mov	r1, r8
    f826:	4620      	mov	r0, r4
    f828:	4798      	blx	r3
}
    f82a:	4630      	mov	r0, r6
    f82c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return ERR_INVALID_ARG;
    f830:	f06f 060c 	mvn.w	r6, #12
    f834:	e7f9      	b.n	f82a <flash_erase+0x4e>
    f836:	bf00      	nop
    f838:	0001714c 	.word	0x0001714c
    f83c:	0000e9b9 	.word	0x0000e9b9
    f840:	0000c8ad 	.word	0x0000c8ad
    f844:	0000c8b3 	.word	0x0000c8b3
    f848:	0000f679 	.word	0x0000f679
    f84c:	0000c99d 	.word	0x0000c99d

0000f850 <_spi_m_async_io_write>:
 *  \return ERR_NONE on success, or an error code on failure.
 *  \retval ERR_NONE Success, transfer started.
 *  \retval ERR_BUSY Busy.
 */
static int32_t _spi_m_async_io_write(struct io_descriptor *io, const uint8_t *const buf, const uint16_t length)
{
    f850:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(io);
    f852:	4604      	mov	r4, r0
    f854:	3800      	subs	r0, #0
    f856:	bf18      	it	ne
    f858:	2001      	movne	r0, #1
{
    f85a:	460f      	mov	r7, r1
    f85c:	4616      	mov	r6, r2
	ASSERT(io);
    f85e:	4909      	ldr	r1, [pc, #36]	; (f884 <_spi_m_async_io_write+0x34>)
    f860:	4b09      	ldr	r3, [pc, #36]	; (f888 <_spi_m_async_io_write+0x38>)
    f862:	f240 1227 	movw	r2, #295	; 0x127
    f866:	4798      	blx	r3
	struct spi_m_async_descriptor *spi = CONTAINER_OF(io, struct spi_m_async_descriptor, io);

	spi->xfer.rxbuf = NULL;
    f868:	2500      	movs	r5, #0
	spi->xfer.txbuf = (uint8_t *)buf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f86a:	2310      	movs	r3, #16
    f86c:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = (uint8_t *)buf;
    f86e:	e9c4 7505 	strd	r7, r5, [r4, #20]
	spi->xfercnt    = 0;
    f872:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_tx(&spi->dev, true);
    f876:	4b05      	ldr	r3, [pc, #20]	; (f88c <_spi_m_async_io_write+0x3c>)
    f878:	2101      	movs	r1, #1
    f87a:	f1a4 0020 	sub.w	r0, r4, #32
    f87e:	4798      	blx	r3

	return ERR_NONE;
}
    f880:	4628      	mov	r0, r5
    f882:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f884:	00017163 	.word	0x00017163
    f888:	0000e9b9 	.word	0x0000e9b9
    f88c:	00011f99 	.word	0x00011f99

0000f890 <_spi_m_async_io_read>:
{
    f890:	b570      	push	{r4, r5, r6, lr}
	ASSERT(io);
    f892:	4604      	mov	r4, r0
    f894:	3800      	subs	r0, #0
    f896:	bf18      	it	ne
    f898:	2001      	movne	r0, #1
{
    f89a:	460d      	mov	r5, r1
    f89c:	4616      	mov	r6, r2
	ASSERT(io);
    f89e:	490c      	ldr	r1, [pc, #48]	; (f8d0 <_spi_m_async_io_read+0x40>)
    f8a0:	4b0c      	ldr	r3, [pc, #48]	; (f8d4 <_spi_m_async_io_read+0x44>)
    f8a2:	f240 1205 	movw	r2, #261	; 0x105
    f8a6:	4798      	blx	r3
	spi->xfer.rxbuf = buf;
    f8a8:	61a5      	str	r5, [r4, #24]
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f8aa:	2310      	movs	r3, #16
	spi->xfer.txbuf = NULL;
    f8ac:	2500      	movs	r5, #0
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    f8ae:	7223      	strb	r3, [r4, #8]
	spi->xfer.txbuf = NULL;
    f8b0:	6165      	str	r5, [r4, #20]
	spi->xfercnt    = 0;
    f8b2:	e9c4 6507 	strd	r6, r5, [r4, #28]
	_spi_m_async_enable_rx(&spi->dev, true);
    f8b6:	3c20      	subs	r4, #32
    f8b8:	4b07      	ldr	r3, [pc, #28]	; (f8d8 <_spi_m_async_io_read+0x48>)
    f8ba:	2101      	movs	r1, #1
    f8bc:	4620      	mov	r0, r4
    f8be:	4798      	blx	r3
	_spi_m_async_write_one(&spi->dev, SPI_DUMMY_CHAR);
    f8c0:	4b06      	ldr	r3, [pc, #24]	; (f8dc <_spi_m_async_io_read+0x4c>)
    f8c2:	f240 11ff 	movw	r1, #511	; 0x1ff
    f8c6:	4620      	mov	r0, r4
    f8c8:	4798      	blx	r3
}
    f8ca:	4628      	mov	r0, r5
    f8cc:	bd70      	pop	{r4, r5, r6, pc}
    f8ce:	bf00      	nop
    f8d0:	00017163 	.word	0x00017163
    f8d4:	0000e9b9 	.word	0x0000e9b9
    f8d8:	00011fc5 	.word	0x00011fc5
    f8dc:	00012031 	.word	0x00012031

0000f8e0 <_spi_dev_error>:
{
    f8e0:	b570      	push	{r4, r5, r6, lr}
	_spi_m_async_enable_tx(dev, false);
    f8e2:	4b0c      	ldr	r3, [pc, #48]	; (f914 <_spi_dev_error+0x34>)
{
    f8e4:	4604      	mov	r4, r0
    f8e6:	460d      	mov	r5, r1
	_spi_m_async_enable_tx(dev, false);
    f8e8:	2100      	movs	r1, #0
    f8ea:	4798      	blx	r3
	_spi_m_async_enable_rx(dev, false);
    f8ec:	4b0a      	ldr	r3, [pc, #40]	; (f918 <_spi_dev_error+0x38>)
    f8ee:	2100      	movs	r1, #0
    f8f0:	4620      	mov	r0, r4
    f8f2:	4798      	blx	r3
	_spi_m_async_enable_tx_complete(dev, false);
    f8f4:	4b09      	ldr	r3, [pc, #36]	; (f91c <_spi_dev_error+0x3c>)
    f8f6:	2100      	movs	r1, #0
    f8f8:	4620      	mov	r0, r4
    f8fa:	4798      	blx	r3
	spi->stat = 0;
    f8fc:	2300      	movs	r3, #0
    f8fe:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	if (spi->callbacks.cb_error) {
    f902:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f904:	b123      	cbz	r3, f910 <_spi_dev_error+0x30>
		spi->callbacks.cb_error(spi, status);
    f906:	4629      	mov	r1, r5
    f908:	1f20      	subs	r0, r4, #4
}
    f90a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		spi->callbacks.cb_error(spi, status);
    f90e:	4718      	bx	r3
}
    f910:	bd70      	pop	{r4, r5, r6, pc}
    f912:	bf00      	nop
    f914:	00011f99 	.word	0x00011f99
    f918:	00011fc5 	.word	0x00011fc5
    f91c:	00011ffd 	.word	0x00011ffd

0000f920 <_spi_dev_complete>:
	if (spi->xfercnt >= spi->xfer.size) {
    f920:	e9d0 320f 	ldrd	r3, r2, [r0, #60]	; 0x3c
    f924:	429a      	cmp	r2, r3
{
    f926:	b510      	push	{r4, lr}
    f928:	4604      	mov	r4, r0
	if (spi->xfercnt >= spi->xfer.size) {
    f92a:	d30b      	bcc.n	f944 <_spi_dev_complete+0x24>
		_spi_m_async_enable_tx_complete(dev, false);
    f92c:	4b06      	ldr	r3, [pc, #24]	; (f948 <_spi_dev_complete+0x28>)
    f92e:	2100      	movs	r1, #0
    f930:	4798      	blx	r3
		spi->stat = 0;
    f932:	2300      	movs	r3, #0
    f934:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f938:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f93a:	b11b      	cbz	r3, f944 <_spi_dev_complete+0x24>
			spi->callbacks.cb_xfer(spi);
    f93c:	1f20      	subs	r0, r4, #4
}
    f93e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			spi->callbacks.cb_xfer(spi);
    f942:	4718      	bx	r3
}
    f944:	bd10      	pop	{r4, pc}
    f946:	bf00      	nop
    f948:	00011ffd 	.word	0x00011ffd

0000f94c <_spi_dev_rx>:
{
    f94c:	b570      	push	{r4, r5, r6, lr}
	if (spi->xfer.rxbuf) {
    f94e:	6b85      	ldr	r5, [r0, #56]	; 0x38
    f950:	4b1c      	ldr	r3, [pc, #112]	; (f9c4 <_spi_dev_rx+0x78>)
{
    f952:	4604      	mov	r4, r0
	if (spi->xfer.rxbuf) {
    f954:	b305      	cbz	r5, f998 <_spi_dev_rx+0x4c>
		if (!(dev->char_size > 1)) {
    f956:	7902      	ldrb	r2, [r0, #4]
    f958:	2a01      	cmp	r2, #1
    f95a:	d816      	bhi.n	f98a <_spi_dev_rx+0x3e>
			spi->xfer.rxbuf[spi->xfercnt++] = (uint8_t)_spi_m_async_read_one(dev);
    f95c:	4798      	blx	r3
    f95e:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f960:	6ba2      	ldr	r2, [r4, #56]	; 0x38
    f962:	1c59      	adds	r1, r3, #1
    f964:	6421      	str	r1, [r4, #64]	; 0x40
    f966:	54d0      	strb	r0, [r2, r3]
	if (spi->xfercnt < spi->xfer.size) {
    f968:	e9d4 310f 	ldrd	r3, r1, [r4, #60]	; 0x3c
    f96c:	4299      	cmp	r1, r3
    f96e:	d21a      	bcs.n	f9a6 <_spi_dev_rx+0x5a>
		if (spi->xfer.txbuf) {
    f970:	6b62      	ldr	r2, [r4, #52]	; 0x34
    f972:	4b15      	ldr	r3, [pc, #84]	; (f9c8 <_spi_dev_rx+0x7c>)
    f974:	b1aa      	cbz	r2, f9a2 <_spi_dev_rx+0x56>
			if (!(dev->char_size > 1)) {
    f976:	7920      	ldrb	r0, [r4, #4]
    f978:	2801      	cmp	r0, #1
				_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt]);
    f97a:	bf94      	ite	ls
    f97c:	5c51      	ldrbls	r1, [r2, r1]
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f97e:	f832 1011 	ldrhhi.w	r1, [r2, r1, lsl #1]
    f982:	4620      	mov	r0, r4
}
    f984:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
				_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt]);
    f988:	4718      	bx	r3
			((uint16_t *)spi->xfer.rxbuf)[spi->xfercnt++] = (uint16_t)_spi_m_async_read_one(dev);
    f98a:	6c06      	ldr	r6, [r0, #64]	; 0x40
    f98c:	1c72      	adds	r2, r6, #1
    f98e:	6402      	str	r2, [r0, #64]	; 0x40
    f990:	4798      	blx	r3
    f992:	f825 0016 	strh.w	r0, [r5, r6, lsl #1]
    f996:	e7e7      	b.n	f968 <_spi_dev_rx+0x1c>
		_spi_m_async_read_one(dev);
    f998:	4798      	blx	r3
		spi->xfercnt++;
    f99a:	6c23      	ldr	r3, [r4, #64]	; 0x40
    f99c:	3301      	adds	r3, #1
    f99e:	6423      	str	r3, [r4, #64]	; 0x40
    f9a0:	e7e2      	b.n	f968 <_spi_dev_rx+0x1c>
			_spi_m_async_write_one(dev, dev->dummy_byte);
    f9a2:	88e1      	ldrh	r1, [r4, #6]
    f9a4:	e7ed      	b.n	f982 <_spi_dev_rx+0x36>
		_spi_m_async_enable_rx(dev, false);
    f9a6:	4b09      	ldr	r3, [pc, #36]	; (f9cc <_spi_dev_rx+0x80>)
    f9a8:	2100      	movs	r1, #0
    f9aa:	4620      	mov	r0, r4
    f9ac:	4798      	blx	r3
		spi->stat = 0;
    f9ae:	2300      	movs	r3, #0
    f9b0:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
		if (spi->callbacks.cb_xfer) {
    f9b4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    f9b6:	b11b      	cbz	r3, f9c0 <_spi_dev_rx+0x74>
			spi->callbacks.cb_xfer(spi);
    f9b8:	1f20      	subs	r0, r4, #4
}
    f9ba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			spi->callbacks.cb_xfer(spi);
    f9be:	4718      	bx	r3
}
    f9c0:	bd70      	pop	{r4, r5, r6, pc}
    f9c2:	bf00      	nop
    f9c4:	0001205d 	.word	0x0001205d
    f9c8:	00012031 	.word	0x00012031
    f9cc:	00011fc5 	.word	0x00011fc5

0000f9d0 <_spi_dev_tx>:
{
    f9d0:	b570      	push	{r4, r5, r6, lr}
    f9d2:	6c03      	ldr	r3, [r0, #64]	; 0x40
	if (!(dev->char_size > 1)) {
    f9d4:	7902      	ldrb	r2, [r0, #4]
    f9d6:	6b41      	ldr	r1, [r0, #52]	; 0x34
    f9d8:	1c5d      	adds	r5, r3, #1
    f9da:	2a01      	cmp	r2, #1
		_spi_m_async_write_one(dev, spi->xfer.txbuf[spi->xfercnt++]);
    f9dc:	6405      	str	r5, [r0, #64]	; 0x40
    f9de:	bf94      	ite	ls
    f9e0:	5cc9      	ldrbls	r1, [r1, r3]
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f9e2:	f831 1013 	ldrhhi.w	r1, [r1, r3, lsl #1]
    f9e6:	4a09      	ldr	r2, [pc, #36]	; (fa0c <_spi_dev_tx+0x3c>)
{
    f9e8:	4604      	mov	r4, r0
		_spi_m_async_write_one(dev, ((uint16_t *)spi->xfer.txbuf)[spi->xfercnt++]);
    f9ea:	4790      	blx	r2
	if (spi->xfercnt == spi->xfer.size) {
    f9ec:	e9d4 320f 	ldrd	r3, r2, [r4, #60]	; 0x3c
    f9f0:	429a      	cmp	r2, r3
    f9f2:	d109      	bne.n	fa08 <_spi_dev_tx+0x38>
		_spi_m_async_enable_tx(dev, false);
    f9f4:	4b06      	ldr	r3, [pc, #24]	; (fa10 <_spi_dev_tx+0x40>)
    f9f6:	2100      	movs	r1, #0
    f9f8:	4620      	mov	r0, r4
    f9fa:	4798      	blx	r3
		_spi_m_async_enable_tx_complete(dev, true);
    f9fc:	4620      	mov	r0, r4
    f9fe:	4b05      	ldr	r3, [pc, #20]	; (fa14 <_spi_dev_tx+0x44>)
}
    fa00:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_enable_tx_complete(dev, true);
    fa04:	2101      	movs	r1, #1
    fa06:	4718      	bx	r3
}
    fa08:	bd70      	pop	{r4, r5, r6, pc}
    fa0a:	bf00      	nop
    fa0c:	00012031 	.word	0x00012031
    fa10:	00011f99 	.word	0x00011f99
    fa14:	00011ffd 	.word	0x00011ffd

0000fa18 <spi_m_async_init>:
{
    fa18:	b570      	push	{r4, r5, r6, lr}
    fa1a:	460e      	mov	r6, r1
	ASSERT(spi && hw);
    fa1c:	4604      	mov	r4, r0
    fa1e:	b110      	cbz	r0, fa26 <spi_m_async_init+0xe>
    fa20:	1e08      	subs	r0, r1, #0
    fa22:	bf18      	it	ne
    fa24:	2001      	movne	r0, #1
	spi->dev.prvt = (void *)hw;
    fa26:	4625      	mov	r5, r4
	ASSERT(spi && hw);
    fa28:	4911      	ldr	r1, [pc, #68]	; (fa70 <spi_m_async_init+0x58>)
    fa2a:	4b12      	ldr	r3, [pc, #72]	; (fa74 <spi_m_async_init+0x5c>)
    fa2c:	22a5      	movs	r2, #165	; 0xa5
    fa2e:	4798      	blx	r3
	spi->dev.prvt = (void *)hw;
    fa30:	f845 6f04 	str.w	r6, [r5, #4]!
	rc            = _spi_m_async_init(&spi->dev, hw);
    fa34:	4b10      	ldr	r3, [pc, #64]	; (fa78 <spi_m_async_init+0x60>)
    fa36:	4631      	mov	r1, r6
    fa38:	4628      	mov	r0, r5
    fa3a:	4798      	blx	r3
	if (rc >= 0) {
    fa3c:	2800      	cmp	r0, #0
    fa3e:	db15      	blt.n	fa6c <spi_m_async_init+0x54>
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_TX, (FUNC_PTR)_spi_dev_tx);
    fa40:	4e0e      	ldr	r6, [pc, #56]	; (fa7c <spi_m_async_init+0x64>)
    fa42:	4a0f      	ldr	r2, [pc, #60]	; (fa80 <spi_m_async_init+0x68>)
    fa44:	2100      	movs	r1, #0
    fa46:	4628      	mov	r0, r5
    fa48:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_RX, (FUNC_PTR)_spi_dev_rx);
    fa4a:	4a0e      	ldr	r2, [pc, #56]	; (fa84 <spi_m_async_init+0x6c>)
    fa4c:	2101      	movs	r1, #1
    fa4e:	4628      	mov	r0, r5
    fa50:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_COMPLETE, (FUNC_PTR)_spi_dev_complete);
    fa52:	4a0d      	ldr	r2, [pc, #52]	; (fa88 <spi_m_async_init+0x70>)
    fa54:	2102      	movs	r1, #2
    fa56:	4628      	mov	r0, r5
    fa58:	47b0      	blx	r6
		_spi_m_async_register_callback(&spi->dev, SPI_DEV_CB_ERROR, (FUNC_PTR)_spi_dev_error);
    fa5a:	4a0c      	ldr	r2, [pc, #48]	; (fa8c <spi_m_async_init+0x74>)
    fa5c:	2103      	movs	r1, #3
    fa5e:	4628      	mov	r0, r5
    fa60:	47b0      	blx	r6
	spi->io.read  = _spi_m_async_io_read;
    fa62:	4b0b      	ldr	r3, [pc, #44]	; (fa90 <spi_m_async_init+0x78>)
    fa64:	62a3      	str	r3, [r4, #40]	; 0x28
	spi->io.write = _spi_m_async_io_write;
    fa66:	4b0b      	ldr	r3, [pc, #44]	; (fa94 <spi_m_async_init+0x7c>)
    fa68:	6263      	str	r3, [r4, #36]	; 0x24
	return ERR_NONE;
    fa6a:	2000      	movs	r0, #0
}
    fa6c:	bd70      	pop	{r4, r5, r6, pc}
    fa6e:	bf00      	nop
    fa70:	00017163 	.word	0x00017163
    fa74:	0000e9b9 	.word	0x0000e9b9
    fa78:	00011ea5 	.word	0x00011ea5
    fa7c:	00012085 	.word	0x00012085
    fa80:	0000f9d1 	.word	0x0000f9d1
    fa84:	0000f94d 	.word	0x0000f94d
    fa88:	0000f921 	.word	0x0000f921
    fa8c:	0000f8e1 	.word	0x0000f8e1
    fa90:	0000f891 	.word	0x0000f891
    fa94:	0000f851 	.word	0x0000f851

0000fa98 <spi_m_async_enable>:
{
    fa98:	b510      	push	{r4, lr}
	ASSERT(spi);
    fa9a:	4604      	mov	r4, r0
    fa9c:	3800      	subs	r0, #0
    fa9e:	4b05      	ldr	r3, [pc, #20]	; (fab4 <spi_m_async_enable+0x1c>)
    faa0:	4905      	ldr	r1, [pc, #20]	; (fab8 <spi_m_async_enable+0x20>)
    faa2:	bf18      	it	ne
    faa4:	2001      	movne	r0, #1
    faa6:	22c1      	movs	r2, #193	; 0xc1
    faa8:	4798      	blx	r3
	_spi_m_async_enable(&spi->dev);
    faaa:	1d20      	adds	r0, r4, #4
    faac:	4b03      	ldr	r3, [pc, #12]	; (fabc <spi_m_async_enable+0x24>)
}
    faae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_spi_m_async_enable(&spi->dev);
    fab2:	4718      	bx	r3
    fab4:	0000e9b9 	.word	0x0000e9b9
    fab8:	00017163 	.word	0x00017163
    fabc:	00011efd 	.word	0x00011efd

0000fac0 <spi_m_async_set_baudrate>:
{
    fac0:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    fac2:	4604      	mov	r4, r0
    fac4:	3800      	subs	r0, #0
    fac6:	4b0a      	ldr	r3, [pc, #40]	; (faf0 <spi_m_async_set_baudrate+0x30>)
    fac8:	bf18      	it	ne
    faca:	2001      	movne	r0, #1
{
    facc:	460d      	mov	r5, r1
	ASSERT(spi);
    face:	22cf      	movs	r2, #207	; 0xcf
    fad0:	4908      	ldr	r1, [pc, #32]	; (faf4 <spi_m_async_set_baudrate+0x34>)
    fad2:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    fad4:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    fad8:	06db      	lsls	r3, r3, #27
    fada:	d405      	bmi.n	fae8 <spi_m_async_set_baudrate+0x28>
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    fadc:	4629      	mov	r1, r5
    fade:	1d20      	adds	r0, r4, #4
    fae0:	4b05      	ldr	r3, [pc, #20]	; (faf8 <spi_m_async_set_baudrate+0x38>)
}
    fae2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_baudrate(&spi->dev, baud_val);
    fae6:	4718      	bx	r3
}
    fae8:	f06f 0003 	mvn.w	r0, #3
    faec:	bd70      	pop	{r4, r5, r6, pc}
    faee:	bf00      	nop
    faf0:	0000e9b9 	.word	0x0000e9b9
    faf4:	00017163 	.word	0x00017163
    faf8:	00011f61 	.word	0x00011f61

0000fafc <spi_m_async_set_mode>:
{
    fafc:	b570      	push	{r4, r5, r6, lr}
	ASSERT(spi);
    fafe:	4604      	mov	r4, r0
    fb00:	3800      	subs	r0, #0
    fb02:	4b0a      	ldr	r3, [pc, #40]	; (fb2c <spi_m_async_set_mode+0x30>)
    fb04:	bf18      	it	ne
    fb06:	2001      	movne	r0, #1
{
    fb08:	460d      	mov	r5, r1
	ASSERT(spi);
    fb0a:	22d9      	movs	r2, #217	; 0xd9
    fb0c:	4908      	ldr	r1, [pc, #32]	; (fb30 <spi_m_async_set_mode+0x34>)
    fb0e:	4798      	blx	r3
	if (spi->stat & SPI_M_ASYNC_STATUS_BUSY) {
    fb10:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
    fb14:	06db      	lsls	r3, r3, #27
    fb16:	d405      	bmi.n	fb24 <spi_m_async_set_mode+0x28>
	return _spi_m_async_set_mode(&spi->dev, mode);
    fb18:	4629      	mov	r1, r5
    fb1a:	1d20      	adds	r0, r4, #4
    fb1c:	4b05      	ldr	r3, [pc, #20]	; (fb34 <spi_m_async_set_mode+0x38>)
}
    fb1e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_m_async_set_mode(&spi->dev, mode);
    fb22:	4718      	bx	r3
}
    fb24:	f06f 0003 	mvn.w	r0, #3
    fb28:	bd70      	pop	{r4, r5, r6, pc}
    fb2a:	bf00      	nop
    fb2c:	0000e9b9 	.word	0x0000e9b9
    fb30:	00017163 	.word	0x00017163
    fb34:	00011f2d 	.word	0x00011f2d

0000fb38 <spi_m_async_transfer>:

int32_t spi_m_async_transfer(struct spi_m_async_descriptor *spi, uint8_t const *txbuf, uint8_t *const rxbuf,
                             const uint16_t length)
{
    fb38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ASSERT(spi);
    fb3a:	4604      	mov	r4, r0
    fb3c:	3800      	subs	r0, #0
{
    fb3e:	461e      	mov	r6, r3
	ASSERT(spi);
    fb40:	bf18      	it	ne
    fb42:	2001      	movne	r0, #1
    fb44:	4b11      	ldr	r3, [pc, #68]	; (fb8c <spi_m_async_transfer+0x54>)
{
    fb46:	460d      	mov	r5, r1
    fb48:	4617      	mov	r7, r2
	ASSERT(spi);
    fb4a:	4911      	ldr	r1, [pc, #68]	; (fb90 <spi_m_async_transfer+0x58>)
    fb4c:	f44f 729c 	mov.w	r2, #312	; 0x138
    fb50:	4798      	blx	r3

	/* Fill transfer descriptor */
	spi->xfer.rxbuf = (uint8_t *)rxbuf;
	spi->xfer.txbuf = (uint8_t *)txbuf;
	spi->xfer.size  = length;
	spi->xfercnt    = 0;
    fb52:	2300      	movs	r3, #0
	spi->xfer.size  = length;
    fb54:	6426      	str	r6, [r4, #64]	; 0x40
	spi->xfercnt    = 0;
    fb56:	6463      	str	r3, [r4, #68]	; 0x44

	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
	_spi_m_async_enable_rx(&spi->dev, true);
    fb58:	1d26      	adds	r6, r4, #4
	spi->stat = SPI_M_ASYNC_STATUS_BUSY;
    fb5a:	2310      	movs	r3, #16
    fb5c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
	spi->xfer.txbuf = (uint8_t *)txbuf;
    fb60:	e9c4 570e 	strd	r5, r7, [r4, #56]	; 0x38
	_spi_m_async_enable_rx(&spi->dev, true);
    fb64:	4b0b      	ldr	r3, [pc, #44]	; (fb94 <spi_m_async_transfer+0x5c>)
    fb66:	2101      	movs	r1, #1
    fb68:	4630      	mov	r0, r6
    fb6a:	4798      	blx	r3
	if (txbuf) {
    fb6c:	4b0a      	ldr	r3, [pc, #40]	; (fb98 <spi_m_async_transfer+0x60>)
    fb6e:	b155      	cbz	r5, fb86 <spi_m_async_transfer+0x4e>
		if (!(spi->dev.char_size > 1)) {
    fb70:	7a21      	ldrb	r1, [r4, #8]
    fb72:	6c62      	ldr	r2, [r4, #68]	; 0x44
    fb74:	2901      	cmp	r1, #1
			_spi_m_async_write_one(&spi->dev, txbuf[spi->xfercnt]);
    fb76:	bf94      	ite	ls
    fb78:	5ca9      	ldrbls	r1, [r5, r2]
		} else {
			_spi_m_async_write_one(&spi->dev, ((uint16_t *)txbuf)[spi->xfercnt]);
    fb7a:	f835 1012 	ldrhhi.w	r1, [r5, r2, lsl #1]
		}
	} else {
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    fb7e:	4630      	mov	r0, r6
    fb80:	4798      	blx	r3
	}

	return ERR_NONE;
}
    fb82:	2000      	movs	r0, #0
    fb84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		_spi_m_async_write_one(&spi->dev, spi->dev.dummy_byte);
    fb86:	8961      	ldrh	r1, [r4, #10]
    fb88:	e7f9      	b.n	fb7e <spi_m_async_transfer+0x46>
    fb8a:	bf00      	nop
    fb8c:	0000e9b9 	.word	0x0000e9b9
    fb90:	00017163 	.word	0x00017163
    fb94:	00011fc5 	.word	0x00011fc5
    fb98:	00012031 	.word	0x00012031

0000fb9c <spi_m_async_register_callback>:
	return ERR_NONE;
}

void spi_m_async_register_callback(struct spi_m_async_descriptor *spi, const enum spi_m_async_cb_type type,
                                   FUNC_PTR func)
{
    fb9c:	b570      	push	{r4, r5, r6, lr}
    fb9e:	460e      	mov	r6, r1
    fba0:	4615      	mov	r5, r2
	ASSERT(spi && (type < SPI_M_ASYNC_CB_N));
    fba2:	4604      	mov	r4, r0
    fba4:	b118      	cbz	r0, fbae <spi_m_async_register_callback+0x12>
    fba6:	2901      	cmp	r1, #1
    fba8:	bf8c      	ite	hi
    fbaa:	2000      	movhi	r0, #0
    fbac:	2001      	movls	r0, #1
    fbae:	4909      	ldr	r1, [pc, #36]	; (fbd4 <spi_m_async_register_callback+0x38>)
    fbb0:	4b09      	ldr	r3, [pc, #36]	; (fbd8 <spi_m_async_register_callback+0x3c>)
    fbb2:	f240 1263 	movw	r2, #355	; 0x163
    fbb6:	4798      	blx	r3

	if (SPI_M_ASYNC_CB_XFER == type) {
    fbb8:	b90e      	cbnz	r6, fbbe <spi_m_async_register_callback+0x22>
		spi->callbacks.cb_xfer = (spi_m_async_cb_xfer_t)func;
    fbba:	6325      	str	r5, [r4, #48]	; 0x30
	} else {
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
	}
}
    fbbc:	bd70      	pop	{r4, r5, r6, pc}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    fbbe:	1e2a      	subs	r2, r5, #0
		spi->callbacks.cb_error = (spi_m_async_cb_error_t)func;
    fbc0:	6365      	str	r5, [r4, #52]	; 0x34
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    fbc2:	f104 0004 	add.w	r0, r4, #4
    fbc6:	4b05      	ldr	r3, [pc, #20]	; (fbdc <spi_m_async_register_callback+0x40>)
}
    fbc8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_spi_m_async_set_irq_state(&spi->dev, SPI_DEV_CB_ERROR, NULL != func);
    fbcc:	bf18      	it	ne
    fbce:	2201      	movne	r2, #1
    fbd0:	2103      	movs	r1, #3
    fbd2:	4718      	bx	r3
    fbd4:	00017163 	.word	0x00017163
    fbd8:	0000e9b9 	.word	0x0000e9b9
    fbdc:	000120b5 	.word	0x000120b5

0000fbe0 <spi_m_async_get_io_descriptor>:

int32_t spi_m_async_get_io_descriptor(struct spi_m_async_descriptor *const spi, struct io_descriptor **io)
{
    fbe0:	b538      	push	{r3, r4, r5, lr}
    fbe2:	460d      	mov	r5, r1
	ASSERT(spi && io);
    fbe4:	4604      	mov	r4, r0
    fbe6:	b110      	cbz	r0, fbee <spi_m_async_get_io_descriptor+0xe>
    fbe8:	1e08      	subs	r0, r1, #0
    fbea:	bf18      	it	ne
    fbec:	2001      	movne	r0, #1
    fbee:	4904      	ldr	r1, [pc, #16]	; (fc00 <spi_m_async_get_io_descriptor+0x20>)
    fbf0:	4b04      	ldr	r3, [pc, #16]	; (fc04 <spi_m_async_get_io_descriptor+0x24>)
    fbf2:	f240 126f 	movw	r2, #367	; 0x16f
	*io = &spi->io;
    fbf6:	3424      	adds	r4, #36	; 0x24
	ASSERT(spi && io);
    fbf8:	4798      	blx	r3
	*io = &spi->io;
    fbfa:	602c      	str	r4, [r5, #0]
	return 0;
}
    fbfc:	2000      	movs	r0, #0
    fbfe:	bd38      	pop	{r3, r4, r5, pc}
    fc00:	00017163 	.word	0x00017163
    fc04:	0000e9b9 	.word	0x0000e9b9

0000fc08 <crc_sync_init>:

/**
 * \brief Initialize CRC.
 */
int32_t crc_sync_init(struct crc_sync_descriptor *const descr, void *const hw)
{
    fc08:	b570      	push	{r4, r5, r6, lr}
    fc0a:	460d      	mov	r5, r1
	ASSERT(descr && hw);
    fc0c:	4604      	mov	r4, r0
    fc0e:	b110      	cbz	r0, fc16 <crc_sync_init+0xe>
    fc10:	1e08      	subs	r0, r1, #0
    fc12:	bf18      	it	ne
    fc14:	2001      	movne	r0, #1
    fc16:	4905      	ldr	r1, [pc, #20]	; (fc2c <crc_sync_init+0x24>)
    fc18:	4b05      	ldr	r3, [pc, #20]	; (fc30 <crc_sync_init+0x28>)
    fc1a:	222b      	movs	r2, #43	; 0x2b
    fc1c:	4798      	blx	r3

	return _crc_sync_init(&descr->dev, hw);
    fc1e:	4629      	mov	r1, r5
    fc20:	4620      	mov	r0, r4
    fc22:	4b04      	ldr	r3, [pc, #16]	; (fc34 <crc_sync_init+0x2c>)
}
    fc24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _crc_sync_init(&descr->dev, hw);
    fc28:	4718      	bx	r3
    fc2a:	bf00      	nop
    fc2c:	00017180 	.word	0x00017180
    fc30:	0000e9b9 	.word	0x0000e9b9
    fc34:	000144f9 	.word	0x000144f9

0000fc38 <_usb_d_find_ep>:
 * \retval <0 Not found (endpoint is not initialized).
 */
static int8_t _usb_d_find_ep(const uint8_t ep)
{
	int8_t i;
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    fc38:	4a0a      	ldr	r2, [pc, #40]	; (fc64 <_usb_d_find_ep+0x2c>)
{
    fc3a:	b570      	push	{r4, r5, r6, lr}
    fc3c:	2300      	movs	r3, #0
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
			return i;
		}
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    fc3e:	f000 050f 	and.w	r5, r0, #15
		if (usb_d_inst.ep[i].xfer.hdr.ep == ep) {
    fc42:	7854      	ldrb	r4, [r2, #1]
    fc44:	4284      	cmp	r4, r0
    fc46:	b259      	sxtb	r1, r3
    fc48:	d00a      	beq.n	fc60 <_usb_d_find_ep+0x28>
		if (usb_d_inst.ep[i].xfer.hdr.type == USB_EP_XTYPE_CTRL
    fc4a:	7816      	ldrb	r6, [r2, #0]
    fc4c:	b90e      	cbnz	r6, fc52 <_usb_d_find_ep+0x1a>
		    && (ep & USB_EP_N_MASK) == usb_d_inst.ep[i].xfer.hdr.ep) {
    fc4e:	42ac      	cmp	r4, r5
    fc50:	d006      	beq.n	fc60 <_usb_d_find_ep+0x28>
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    fc52:	3301      	adds	r3, #1
    fc54:	2b0d      	cmp	r3, #13
    fc56:	f102 0220 	add.w	r2, r2, #32
    fc5a:	d1f2      	bne.n	fc42 <_usb_d_find_ep+0xa>
			return i;
		}
	}
	return -1;
    fc5c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
}
    fc60:	4608      	mov	r0, r1
    fc62:	bd70      	pop	{r4, r5, r6, pc}
    fc64:	20008b60 	.word	0x20008b60

0000fc68 <usb_d_dummy_cb_false>:
{
	(void)unused0;
	(void)unused1;
	(void)unused2;
	return false;
}
    fc68:	2000      	movs	r0, #0
    fc6a:	4770      	bx	lr

0000fc6c <usb_d_cb_trans_more>:
 * \brief Callback invoked when request more data
 * \param[in] ep Endpoint number with transfer direction on bit 8.
 * \param[in] transfered Number of bytes transfered.
 */
static bool usb_d_cb_trans_more(const uint8_t ep, const uint32_t transfered)
{
    fc6c:	b513      	push	{r0, r1, r4, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    fc6e:	4b0a      	ldr	r3, [pc, #40]	; (fc98 <usb_d_cb_trans_more+0x2c>)
{
    fc70:	9101      	str	r1, [sp, #4]
    fc72:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    fc74:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ept->xfer.hdr.state == USB_EP_S_X_DATA) {
    fc76:	4b09      	ldr	r3, [pc, #36]	; (fc9c <usb_d_cb_trans_more+0x30>)
    fc78:	9901      	ldr	r1, [sp, #4]
    fc7a:	eb03 1340 	add.w	r3, r3, r0, lsl #5
    fc7e:	789a      	ldrb	r2, [r3, #2]
    fc80:	2a03      	cmp	r2, #3
    fc82:	d105      	bne.n	fc90 <usb_d_cb_trans_more+0x24>
		return ept->callbacks.more(ep, transfered);
    fc84:	699b      	ldr	r3, [r3, #24]
    fc86:	4620      	mov	r0, r4
	}
	return false;
}
    fc88:	b002      	add	sp, #8
    fc8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		return ept->callbacks.more(ep, transfered);
    fc8e:	4718      	bx	r3
}
    fc90:	2000      	movs	r0, #0
    fc92:	b002      	add	sp, #8
    fc94:	bd10      	pop	{r4, pc}
    fc96:	bf00      	nop
    fc98:	0000fc39 	.word	0x0000fc39
    fc9c:	20008b60 	.word	0x20008b60

0000fca0 <_usb_d_cb_trans_done>:

/**
 * Callback when USB transactions are finished.
 */
static void _usb_d_cb_trans_done(const uint8_t ep, const int32_t code, const uint32_t transferred)
{
    fca0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    fca4:	4b37      	ldr	r3, [pc, #220]	; (fd84 <_usb_d_cb_trans_done+0xe4>)
    fca6:	4c38      	ldr	r4, [pc, #224]	; (fd88 <_usb_d_cb_trans_done+0xe8>)
{
    fca8:	b085      	sub	sp, #20
    fcaa:	4680      	mov	r8, r0
    fcac:	460f      	mov	r7, r1
    fcae:	4691      	mov	r9, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    fcb0:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];

	if (code == USB_TRANS_DONE) {
    fcb2:	0146      	lsls	r6, r0, #5
    fcb4:	2f00      	cmp	r7, #0
    fcb6:	d143      	bne.n	fd40 <_usb_d_cb_trans_done+0xa0>
		ept->xfer.hdr.status = USB_XFER_DONE;
    fcb8:	19a5      	adds	r5, r4, r6
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    fcba:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_DONE;
    fcbc:	70ef      	strb	r7, [r5, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    fcbe:	2900      	cmp	r1, #0
    fcc0:	d135      	bne.n	fd2e <_usb_d_cb_trans_done+0x8e>
	if (state == USB_EP_S_X_DATA) {
    fcc2:	2320      	movs	r3, #32
    fcc4:	220c      	movs	r2, #12
    fcc6:	fb13 2000 	smlabb	r0, r3, r0, r2
    fcca:	78ab      	ldrb	r3, [r5, #2]
    fccc:	2b03      	cmp	r3, #3
    fcce:	eb04 0200 	add.w	r2, r4, r0
    fcd2:	69eb      	ldr	r3, [r5, #28]
    fcd4:	7868      	ldrb	r0, [r5, #1]
    fcd6:	d126      	bne.n	fd26 <_usb_d_cb_trans_done+0x86>
		bool err = ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DATA, ept->xfer.req);
    fcd8:	2101      	movs	r1, #1
    fcda:	f995 400c 	ldrsb.w	r4, [r5, #12]
    fcde:	4798      	blx	r3
		if (err) {
    fce0:	786b      	ldrb	r3, [r5, #1]
    fce2:	b168      	cbz	r0, fd00 <_usb_d_cb_trans_done+0x60>
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    fce4:	2c00      	cmp	r4, #0
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    fce6:	f240 2205 	movw	r2, #517	; 0x205
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    fcea:	bfb4      	ite	lt
    fcec:	4618      	movlt	r0, r3
    fcee:	f043 0080 	orrge.w	r0, r3, #128	; 0x80
			ept->xfer.hdr.state  = USB_EP_S_HALTED;
    fcf2:	806a      	strh	r2, [r5, #2]
			_usb_d_dev_ep_stall(req_dir ? ept->xfer.hdr.ep : (ept->xfer.hdr.ep | USB_EP_DIR), USB_EP_STALL_SET);
    fcf4:	4b25      	ldr	r3, [pc, #148]	; (fd8c <_usb_d_cb_trans_done+0xec>)
    fcf6:	2101      	movs	r1, #1
    fcf8:	4798      	blx	r3
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
		ept->xfer.hdr.status = USB_XFER_ERROR;
	}

	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
}
    fcfa:	b005      	add	sp, #20
    fcfc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	struct usb_d_transfer trans
    fd00:	2c00      	cmp	r4, #0
    fd02:	bfac      	ite	ge
    fd04:	f043 0380 	orrge.w	r3, r3, #128	; 0x80
    fd08:	f003 030f 	andlt.w	r3, r3, #15
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    fd0c:	2204      	movs	r2, #4
	struct usb_d_transfer trans
    fd0e:	f88d 300c 	strb.w	r3, [sp, #12]
    fd12:	2301      	movs	r3, #1
    fd14:	e9cd 0001 	strd	r0, r0, [sp, #4]
    fd18:	f88d 300d 	strb.w	r3, [sp, #13]
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
    fd1c:	70aa      	strb	r2, [r5, #2]
	return _usb_d_dev_ep_trans(&trans);
    fd1e:	4b1c      	ldr	r3, [pc, #112]	; (fd90 <_usb_d_cb_trans_done+0xf0>)
    fd20:	a801      	add	r0, sp, #4
    fd22:	4798      	blx	r3
    fd24:	e7e9      	b.n	fcfa <_usb_d_cb_trans_done+0x5a>
		ept->callbacks.xfer(ept->xfer.hdr.ep, USB_XFER_DONE, ept->xfer.req);
    fd26:	4798      	blx	r3
		ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    fd28:	2302      	movs	r3, #2
    fd2a:	70ab      	strb	r3, [r5, #2]
    fd2c:	e7e5      	b.n	fcfa <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    fd2e:	2301      	movs	r3, #1
    fd30:	70ab      	strb	r3, [r5, #2]
	ept->callbacks.xfer(ep, (enum usb_xfer_code)ept->xfer.hdr.status, (void *)transferred);
    fd32:	4434      	add	r4, r6
    fd34:	464a      	mov	r2, r9
    fd36:	69e3      	ldr	r3, [r4, #28]
    fd38:	78e1      	ldrb	r1, [r4, #3]
    fd3a:	4640      	mov	r0, r8
    fd3c:	4798      	blx	r3
    fd3e:	e7dc      	b.n	fcfa <_usb_d_cb_trans_done+0x5a>
	} else if (code == USB_TRANS_STALL) {
    fd40:	2f01      	cmp	r7, #1
		ept->xfer.hdr.status = USB_XFER_HALT;
    fd42:	eb04 0306 	add.w	r3, r4, r6
	} else if (code == USB_TRANS_STALL) {
    fd46:	d10b      	bne.n	fd60 <_usb_d_cb_trans_done+0xc0>
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    fd48:	5da1      	ldrb	r1, [r4, r6]
		ept->xfer.hdr.status = USB_XFER_HALT;
    fd4a:	2202      	movs	r2, #2
    fd4c:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    fd4e:	b921      	cbnz	r1, fd5a <_usb_d_cb_trans_done+0xba>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    fd50:	709a      	strb	r2, [r3, #2]
			_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    fd52:	4640      	mov	r0, r8
    fd54:	4b0d      	ldr	r3, [pc, #52]	; (fd8c <_usb_d_cb_trans_done+0xec>)
    fd56:	4798      	blx	r3
    fd58:	e7eb      	b.n	fd32 <_usb_d_cb_trans_done+0x92>
			ept->xfer.hdr.state = USB_EP_S_HALTED;
    fd5a:	2205      	movs	r2, #5
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    fd5c:	709a      	strb	r2, [r3, #2]
    fd5e:	e7e8      	b.n	fd32 <_usb_d_cb_trans_done+0x92>
	} else if (code == USB_TRANS_ABORT) {
    fd60:	2f02      	cmp	r7, #2
    fd62:	d107      	bne.n	fd74 <_usb_d_cb_trans_done+0xd4>
		ept->xfer.hdr.status = USB_XFER_ABORT;
    fd64:	2204      	movs	r2, #4
    fd66:	70da      	strb	r2, [r3, #3]
		if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    fd68:	5da2      	ldrb	r2, [r4, r6]
    fd6a:	b90a      	cbnz	r2, fd70 <_usb_d_cb_trans_done+0xd0>
			ept->xfer.hdr.state = USB_EP_S_X_SETUP;
    fd6c:	709f      	strb	r7, [r3, #2]
			return;
    fd6e:	e7c4      	b.n	fcfa <_usb_d_cb_trans_done+0x5a>
		ept->xfer.hdr.state = USB_EP_S_IDLE;
    fd70:	2201      	movs	r2, #1
    fd72:	e7f3      	b.n	fd5c <_usb_d_cb_trans_done+0xbc>
	} else if (code == USB_TRANS_RESET) {
    fd74:	2f03      	cmp	r7, #3
		ept->xfer.hdr.state  = USB_EP_S_DISABLED;
    fd76:	bf0c      	ite	eq
    fd78:	f44f 62a0 	moveq.w	r2, #1280	; 0x500
		ept->xfer.hdr.state  = USB_EP_S_ERROR;
    fd7c:	f240 6206 	movwne	r2, #1542	; 0x606
    fd80:	805a      	strh	r2, [r3, #2]
    fd82:	e7d6      	b.n	fd32 <_usb_d_cb_trans_done+0x92>
    fd84:	0000fc39 	.word	0x0000fc39
    fd88:	20008b60 	.word	0x20008b60
    fd8c:	0000e039 	.word	0x0000e039
    fd90:	0000e159 	.word	0x0000e159

0000fd94 <usb_d_cb_trans_setup>:
{
    fd94:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    fd98:	4b18      	ldr	r3, [pc, #96]	; (fdfc <usb_d_cb_trans_setup+0x68>)
	uint8_t *        req      = ept->xfer.req;
    fd9a:	4f19      	ldr	r7, [pc, #100]	; (fe00 <usb_d_cb_trans_setup+0x6c>)
    fd9c:	4d19      	ldr	r5, [pc, #100]	; (fe04 <usb_d_cb_trans_setup+0x70>)
{
    fd9e:	4604      	mov	r4, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    fda0:	4798      	blx	r3
	uint8_t *        req      = ept->xfer.req;
    fda2:	f04f 0820 	mov.w	r8, #32
    fda6:	230c      	movs	r3, #12
    fda8:	fb18 3800 	smlabb	r8, r8, r0, r3
    fdac:	44b8      	add	r8, r7
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    fdae:	4b16      	ldr	r3, [pc, #88]	; (fe08 <usb_d_cb_trans_setup+0x74>)
	int8_t           ep_index = _usb_d_find_ep(ep);
    fdb0:	4606      	mov	r6, r0
	uint8_t n = _usb_d_dev_ep_read_req(ep, req);
    fdb2:	4641      	mov	r1, r8
    fdb4:	4620      	mov	r0, r4
    fdb6:	4798      	blx	r3
	if (n != 8) {
    fdb8:	b2c0      	uxtb	r0, r0
    fdba:	2808      	cmp	r0, #8
    fdbc:	f044 0980 	orr.w	r9, r4, #128	; 0x80
    fdc0:	d008      	beq.n	fdd4 <usb_d_cb_trans_setup+0x40>
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    fdc2:	2101      	movs	r1, #1
    fdc4:	4620      	mov	r0, r4
    fdc6:	47a8      	blx	r5
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    fdc8:	4648      	mov	r0, r9
    fdca:	462b      	mov	r3, r5
    fdcc:	2101      	movs	r1, #1
}
    fdce:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
		_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_SET);
    fdd2:	4718      	bx	r3
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    fdd4:	eb07 1646 	add.w	r6, r7, r6, lsl #5
	_usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
    fdd8:	2100      	movs	r1, #0
    fdda:	4620      	mov	r0, r4
    fddc:	47a8      	blx	r5
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    fdde:	2701      	movs	r7, #1
	_usb_d_dev_ep_stall(ep | USB_EP_DIR, USB_EP_STALL_CLR);
    fde0:	2100      	movs	r1, #0
    fde2:	4648      	mov	r0, r9
    fde4:	47a8      	blx	r5
	if (!ept->callbacks.req(ep, req)) {
    fde6:	6973      	ldr	r3, [r6, #20]
	ept->xfer.hdr.state = USB_EP_S_IDLE;
    fde8:	70b7      	strb	r7, [r6, #2]
	if (!ept->callbacks.req(ep, req)) {
    fdea:	4641      	mov	r1, r8
    fdec:	4620      	mov	r0, r4
    fdee:	4798      	blx	r3
    fdf0:	b910      	cbnz	r0, fdf8 <usb_d_cb_trans_setup+0x64>
		ept->xfer.hdr.state = USB_EP_S_HALTED;
    fdf2:	2305      	movs	r3, #5
    fdf4:	70b3      	strb	r3, [r6, #2]
		_usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
    fdf6:	e7e4      	b.n	fdc2 <usb_d_cb_trans_setup+0x2e>
}
    fdf8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    fdfc:	0000fc39 	.word	0x0000fc39
    fe00:	20008b60 	.word	0x20008b60
    fe04:	0000e039 	.word	0x0000e039
    fe08:	0000e105 	.word	0x0000e105

0000fe0c <usb_d_init>:

int32_t usb_d_init(void)
{
    fe0c:	b510      	push	{r4, lr}
	int32_t rc = _usb_d_dev_init();
    fe0e:	4b11      	ldr	r3, [pc, #68]	; (fe54 <usb_d_init+0x48>)
    fe10:	4798      	blx	r3
	uint8_t i;
	if (rc < 0) {
    fe12:	2800      	cmp	r0, #0
    fe14:	db1d      	blt.n	fe52 <usb_d_init+0x46>
		return rc;
	}
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    fe16:	4b10      	ldr	r3, [pc, #64]	; (fe58 <usb_d_init+0x4c>)
    fe18:	4810      	ldr	r0, [pc, #64]	; (fe5c <usb_d_init+0x50>)
    fe1a:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
    fe1e:	2100      	movs	r1, #0
    fe20:	4798      	blx	r3
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    fe22:	4b0e      	ldr	r3, [pc, #56]	; (fe5c <usb_d_init+0x50>)
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
		usb_d_inst.ep[i].callbacks.req  = (usb_d_ep_cb_setup_t)usb_d_dummy_cb_false;
    fe24:	490e      	ldr	r1, [pc, #56]	; (fe60 <usb_d_init+0x54>)
	memset(usb_d_inst.ep, 0x00, sizeof(struct usb_d_ep) * CONF_USB_D_NUM_EP_SP);
    fe26:	2200      	movs	r2, #0
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    fe28:	20ff      	movs	r0, #255	; 0xff
    fe2a:	3201      	adds	r2, #1
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    fe2c:	2a0d      	cmp	r2, #13
		usb_d_inst.ep[i].callbacks.more = (usb_d_ep_cb_more_t)usb_d_dummy_cb_false;
    fe2e:	e9c3 1105 	strd	r1, r1, [r3, #20]
		usb_d_inst.ep[i].xfer.hdr.ep    = 0xFF;
    fe32:	7058      	strb	r0, [r3, #1]
		usb_d_inst.ep[i].callbacks.xfer = (usb_d_ep_cb_xfer_t)usb_d_dummy_cb_false;
    fe34:	61d9      	str	r1, [r3, #28]
	for (i = 0; i < CONF_USB_D_NUM_EP_SP; i++) {
    fe36:	f103 0320 	add.w	r3, r3, #32
    fe3a:	d1f6      	bne.n	fe2a <usb_d_init+0x1e>
	}
	/* Handles device driver endpoint callbacks to build transfer. */
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_SETUP, (FUNC_PTR)usb_d_cb_trans_setup);
    fe3c:	4c09      	ldr	r4, [pc, #36]	; (fe64 <usb_d_init+0x58>)
    fe3e:	490a      	ldr	r1, [pc, #40]	; (fe68 <usb_d_init+0x5c>)
    fe40:	2000      	movs	r0, #0
    fe42:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_MORE, (FUNC_PTR)usb_d_cb_trans_more);
    fe44:	4909      	ldr	r1, [pc, #36]	; (fe6c <usb_d_init+0x60>)
    fe46:	2001      	movs	r0, #1
    fe48:	47a0      	blx	r4
	_usb_d_dev_register_ep_callback(USB_D_DEV_EP_CB_DONE, (FUNC_PTR)_usb_d_cb_trans_done);
    fe4a:	2002      	movs	r0, #2
    fe4c:	4908      	ldr	r1, [pc, #32]	; (fe70 <usb_d_init+0x64>)
    fe4e:	47a0      	blx	r4
	return ERR_NONE;
    fe50:	2000      	movs	r0, #0
}
    fe52:	bd10      	pop	{r4, pc}
    fe54:	0000dc31 	.word	0x0000dc31
    fe58:	00014d51 	.word	0x00014d51
    fe5c:	20008b60 	.word	0x20008b60
    fe60:	0000fc69 	.word	0x0000fc69
    fe64:	0000e2f9 	.word	0x0000e2f9
    fe68:	0000fd95 	.word	0x0000fd95
    fe6c:	0000fc6d 	.word	0x0000fc6d
    fe70:	0000fca1 	.word	0x0000fca1

0000fe74 <usb_d_register_callback>:
}

void usb_d_register_callback(const enum usb_d_cb_type type, const FUNC_PTR func)
{
	/* Directly uses device driver callback. */
	_usb_d_dev_register_callback(type, func);
    fe74:	4b00      	ldr	r3, [pc, #0]	; (fe78 <usb_d_register_callback+0x4>)
    fe76:	4718      	bx	r3
    fe78:	0000e2d5 	.word	0x0000e2d5

0000fe7c <usb_d_enable>:
}

int32_t usb_d_enable(void)
{
	return _usb_d_dev_enable();
    fe7c:	4b00      	ldr	r3, [pc, #0]	; (fe80 <usb_d_enable+0x4>)
    fe7e:	4718      	bx	r3
    fe80:	0000dd0d 	.word	0x0000dd0d

0000fe84 <usb_d_attach>:
	_usb_d_dev_disable();
}

void usb_d_attach(void)
{
	_usb_d_dev_attach();
    fe84:	4b00      	ldr	r3, [pc, #0]	; (fe88 <usb_d_attach+0x4>)
    fe86:	4718      	bx	r3
    fe88:	0000dd69 	.word	0x0000dd69

0000fe8c <usb_d_get_frame_num>:
	return _usb_d_dev_get_speed();
}

uint16_t usb_d_get_frame_num(void)
{
	return _usb_d_dev_get_frame_n();
    fe8c:	4b00      	ldr	r3, [pc, #0]	; (fe90 <usb_d_get_frame_num+0x4>)
    fe8e:	4718      	bx	r3
    fe90:	0000dd87 	.word	0x0000dd87

0000fe94 <usb_d_set_address>:
	return _usb_d_dev_get_uframe_n();
}

void usb_d_set_address(const uint8_t addr)
{
	_usb_d_dev_set_address(addr);
    fe94:	4b00      	ldr	r3, [pc, #0]	; (fe98 <usb_d_set_address+0x4>)
    fe96:	4718      	bx	r3
    fe98:	0000dd7b 	.word	0x0000dd7b

0000fe9c <usb_d_ep_init>:
{
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
}

int32_t usb_d_ep_init(const uint8_t ep, const uint8_t attr, const uint16_t max_pkt_size)
{
    fe9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int32_t          rc;
	int8_t           ep_index = _usb_d_find_ep(ep);
    fe9e:	4c11      	ldr	r4, [pc, #68]	; (fee4 <usb_d_ep_init+0x48>)
{
    fea0:	4606      	mov	r6, r0
    fea2:	460d      	mov	r5, r1
    fea4:	4617      	mov	r7, r2
	int8_t           ep_index = _usb_d_find_ep(ep);
    fea6:	47a0      	blx	r4
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index >= 0) {
    fea8:	2800      	cmp	r0, #0
    feaa:	da14      	bge.n	fed6 <usb_d_ep_init+0x3a>
		return -USB_ERR_REDO;
	} else {
		ep_index = _usb_d_find_ep(0xFF);
    feac:	20ff      	movs	r0, #255	; 0xff
    feae:	47a0      	blx	r4
		if (ep_index < 0) {
    feb0:	1e04      	subs	r4, r0, #0
    feb2:	db13      	blt.n	fedc <usb_d_ep_init+0x40>
			return -USB_ERR_ALLOC_FAIL;
		}
		ept = &usb_d_inst.ep[ep_index];
	}
	rc = _usb_d_dev_ep_init(ep, attr, max_pkt_size);
    feb4:	4b0c      	ldr	r3, [pc, #48]	; (fee8 <usb_d_ep_init+0x4c>)
    feb6:	463a      	mov	r2, r7
    feb8:	4629      	mov	r1, r5
    feba:	4630      	mov	r0, r6
    febc:	4798      	blx	r3
	if (rc < 0) {
    febe:	2800      	cmp	r0, #0
    fec0:	db08      	blt.n	fed4 <usb_d_ep_init+0x38>
		return rc;
	}
	ept->xfer.hdr.ep   = ep;
    fec2:	4b0a      	ldr	r3, [pc, #40]	; (feec <usb_d_ep_init+0x50>)
    fec4:	0162      	lsls	r2, r4, #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    fec6:	f005 0503 	and.w	r5, r5, #3
	ept->xfer.hdr.ep   = ep;
    feca:	eb03 1444 	add.w	r4, r3, r4, lsl #5
	ept->xfer.hdr.type = attr & USB_EP_XTYPE_MASK;
    fece:	549d      	strb	r5, [r3, r2]
	ept->xfer.hdr.ep   = ep;
    fed0:	7066      	strb	r6, [r4, #1]
	return ERR_NONE;
    fed2:	2000      	movs	r0, #0
}
    fed4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -USB_ERR_REDO;
    fed6:	f06f 0013 	mvn.w	r0, #19
    feda:	e7fb      	b.n	fed4 <usb_d_ep_init+0x38>
			return -USB_ERR_ALLOC_FAIL;
    fedc:	f06f 0014 	mvn.w	r0, #20
    fee0:	e7f8      	b.n	fed4 <usb_d_ep_init+0x38>
    fee2:	bf00      	nop
    fee4:	0000fc39 	.word	0x0000fc39
    fee8:	0000dd95 	.word	0x0000dd95
    feec:	20008b60 	.word	0x20008b60

0000fef0 <usb_d_ep0_init>:
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    fef0:	2100      	movs	r1, #0
{
    fef2:	4602      	mov	r2, r0
	return usb_d_ep_init(0, USB_EP_XTYPE_CTRL, max_pkt_size);
    fef4:	4b01      	ldr	r3, [pc, #4]	; (fefc <usb_d_ep0_init+0xc>)
    fef6:	4608      	mov	r0, r1
    fef8:	4718      	bx	r3
    fefa:	bf00      	nop
    fefc:	0000fe9d 	.word	0x0000fe9d

0000ff00 <usb_d_ep_deinit>:

void usb_d_ep_deinit(const uint8_t ep)
{
    ff00:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    ff02:	4b07      	ldr	r3, [pc, #28]	; (ff20 <usb_d_ep_deinit+0x20>)
{
    ff04:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    ff06:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	if (ep_index < 0) {
    ff08:	1e04      	subs	r4, r0, #0
    ff0a:	db07      	blt.n	ff1c <usb_d_ep_deinit+0x1c>
		return;
	}
	_usb_d_dev_ep_deinit(ep);
    ff0c:	4b05      	ldr	r3, [pc, #20]	; (ff24 <usb_d_ep_deinit+0x24>)
    ff0e:	4628      	mov	r0, r5
    ff10:	4798      	blx	r3
	ept->xfer.hdr.ep = 0xFF;
    ff12:	4805      	ldr	r0, [pc, #20]	; (ff28 <usb_d_ep_deinit+0x28>)
    ff14:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    ff18:	23ff      	movs	r3, #255	; 0xff
    ff1a:	7043      	strb	r3, [r0, #1]
}
    ff1c:	bd38      	pop	{r3, r4, r5, pc}
    ff1e:	bf00      	nop
    ff20:	0000fc39 	.word	0x0000fc39
    ff24:	0000de55 	.word	0x0000de55
    ff28:	20008b60 	.word	0x20008b60

0000ff2c <usb_d_ep_enable>:

int32_t usb_d_ep_enable(const uint8_t ep)
{
    ff2c:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
    ff2e:	4b0c      	ldr	r3, [pc, #48]	; (ff60 <usb_d_ep_enable+0x34>)
{
    ff30:	4605      	mov	r5, r0
	int8_t           ep_index = _usb_d_find_ep(ep);
    ff32:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	int32_t          rc;
	if (ep_index < 0) {
    ff34:	1e03      	subs	r3, r0, #0
    ff36:	db10      	blt.n	ff5a <usb_d_ep_enable+0x2e>
		return -USB_ERR_PARAM;
	}
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    ff38:	015b      	lsls	r3, r3, #5
    ff3a:	4c0a      	ldr	r4, [pc, #40]	; (ff64 <usb_d_ep_enable+0x38>)
    ff3c:	5ce2      	ldrb	r2, [r4, r3]
    ff3e:	441c      	add	r4, r3
    ff40:	2a00      	cmp	r2, #0
    ff42:	bf0c      	ite	eq
    ff44:	2202      	moveq	r2, #2
    ff46:	2201      	movne	r2, #1
	rc                  = _usb_d_dev_ep_enable(ep);
    ff48:	4b07      	ldr	r3, [pc, #28]	; (ff68 <usb_d_ep_enable+0x3c>)
	ept->xfer.hdr.state = (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) ? USB_EP_S_X_SETUP : USB_EP_S_IDLE;
    ff4a:	70a2      	strb	r2, [r4, #2]
	rc                  = _usb_d_dev_ep_enable(ep);
    ff4c:	4628      	mov	r0, r5
    ff4e:	4798      	blx	r3
	if (rc < 0) {
    ff50:	2800      	cmp	r0, #0
    ff52:	da01      	bge.n	ff58 <usb_d_ep_enable+0x2c>
		ept->xfer.hdr.state = USB_EP_S_DISABLED;
    ff54:	2300      	movs	r3, #0
    ff56:	70a3      	strb	r3, [r4, #2]
	}
	return rc;
}
    ff58:	bd38      	pop	{r3, r4, r5, pc}
		return -USB_ERR_PARAM;
    ff5a:	f06f 0011 	mvn.w	r0, #17
    ff5e:	e7fb      	b.n	ff58 <usb_d_ep_enable+0x2c>
    ff60:	0000fc39 	.word	0x0000fc39
    ff64:	20008b60 	.word	0x20008b60
    ff68:	0000dec9 	.word	0x0000dec9

0000ff6c <usb_d_ep_transfer>:
	}
	return usb_d_inst.ep[ep_index].xfer.req;
}

int32_t usb_d_ep_transfer(const struct usb_d_transfer *xfer)
{
    ff6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    ff70:	f890 8008 	ldrb.w	r8, [r0, #8]
    ff74:	4b31      	ldr	r3, [pc, #196]	; (1003c <STACK_SIZE+0x3c>)
{
    ff76:	4605      	mov	r5, r0
    ff78:	b087      	sub	sp, #28
	int8_t                ep_index = _usb_d_find_ep(xfer->ep);
    ff7a:	4640      	mov	r0, r8
    ff7c:	4798      	blx	r3
	uint32_t              len = xfer->size;
	int32_t               rc;
	volatile uint8_t      state;
	volatile hal_atomic_t flags;

	if (ep_index < 0) {
    ff7e:	1e04      	subs	r4, r0, #0
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    ff80:	7a6f      	ldrb	r7, [r5, #9]
	uint32_t              len = xfer->size;
    ff82:	686e      	ldr	r6, [r5, #4]
	if (ep_index < 0) {
    ff84:	db55      	blt.n	10032 <STACK_SIZE+0x32>
		return -USB_ERR_PARAM;
	}

	atomic_enter_critical(&flags);
	state = ept->xfer.hdr.state;
    ff86:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 10050 <STACK_SIZE+0x50>
	atomic_enter_critical(&flags);
    ff8a:	4b2d      	ldr	r3, [pc, #180]	; (10040 <STACK_SIZE+0x40>)
	state = ept->xfer.hdr.state;
    ff8c:	ea4f 1b44 	mov.w	fp, r4, lsl #5
    ff90:	eb0a 1444 	add.w	r4, sl, r4, lsl #5
	atomic_enter_critical(&flags);
    ff94:	a802      	add	r0, sp, #8
    ff96:	4798      	blx	r3
	state = ept->xfer.hdr.state;
    ff98:	78a3      	ldrb	r3, [r4, #2]
    ff9a:	f88d 3007 	strb.w	r3, [sp, #7]
	if (state == USB_EP_S_IDLE) {
    ff9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ffa2:	2b01      	cmp	r3, #1
    ffa4:	fa5f f983 	uxtb.w	r9, r3
    ffa8:	4b26      	ldr	r3, [pc, #152]	; (10044 <STACK_SIZE+0x44>)
    ffaa:	d11a      	bne.n	ffe2 <usb_d_ep_transfer+0x76>
		ept->xfer.hdr.state = USB_EP_S_X_DATA;
    ffac:	2203      	movs	r2, #3
    ffae:	70a2      	strb	r2, [r4, #2]
		atomic_leave_critical(&flags);
    ffb0:	a802      	add	r0, sp, #8
    ffb2:	4798      	blx	r3
		default: /* USB_EP_S_X_xxxx  */
			return USB_BUSY;
		}
	}

	if (ept->xfer.hdr.type == USB_EP_XTYPE_CTRL) {
    ffb4:	f81a 300b 	ldrb.w	r3, [sl, fp]
    ffb8:	b1fb      	cbz	r3, fffa <usb_d_ep_transfer+0x8e>
	bool                  dir = USB_EP_GET_DIR(xfer->ep), zlp = xfer->zlp;
    ffba:	1e3b      	subs	r3, r7, #0
    ffbc:	ea4f 12d8 	mov.w	r2, r8, lsr #7
    ffc0:	bf18      	it	ne
    ffc2:	2301      	movne	r3, #1
	struct usb_d_transfer trans
    ffc4:	6828      	ldr	r0, [r5, #0]
				zlp = false;
			}
		}
	}

	rc = _usb_d_trans(xfer->ep, dir, xfer->buf, len, zlp);
    ffc6:	7a29      	ldrb	r1, [r5, #8]
	struct usb_d_transfer trans
    ffc8:	e9cd 0603 	strd	r0, r6, [sp, #12]
    ffcc:	b372      	cbz	r2, 1002c <STACK_SIZE+0x2c>
    ffce:	f041 0280 	orr.w	r2, r1, #128	; 0x80
    ffd2:	f88d 3015 	strb.w	r3, [sp, #21]
	return _usb_d_dev_ep_trans(&trans);
    ffd6:	a803      	add	r0, sp, #12
    ffd8:	4b1b      	ldr	r3, [pc, #108]	; (10048 <STACK_SIZE+0x48>)
	struct usb_d_transfer trans
    ffda:	f88d 2014 	strb.w	r2, [sp, #20]
	return _usb_d_dev_ep_trans(&trans);
    ffde:	4798      	blx	r3
	return rc;
    ffe0:	e008      	b.n	fff4 <usb_d_ep_transfer+0x88>
		atomic_leave_critical(&flags);
    ffe2:	a802      	add	r0, sp, #8
    ffe4:	4798      	blx	r3
		switch (state) {
    ffe6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ffea:	2b06      	cmp	r3, #6
    ffec:	b2da      	uxtb	r2, r3
    ffee:	d823      	bhi.n	10038 <STACK_SIZE+0x38>
    fff0:	4b16      	ldr	r3, [pc, #88]	; (1004c <STACK_SIZE+0x4c>)
    fff2:	5698      	ldrsb	r0, [r3, r2]
}
    fff4:	b007      	add	sp, #28
    fff6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uint16_t req_len = USB_GET_wLength(ept->xfer.req);
    fffa:	7ce1      	ldrb	r1, [r4, #19]
    fffc:	7ca2      	ldrb	r2, [r4, #18]
    fffe:	eb02 2201 	add.w	r2, r2, r1, lsl #8
   10002:	b292      	uxth	r2, r2
		if (req_len == 0) {
   10004:	b92a      	cbnz	r2, 10012 <STACK_SIZE+0x12>
			ept->xfer.hdr.state = USB_EP_S_X_STATUS;
   10006:	2304      	movs	r3, #4
   10008:	70a3      	strb	r3, [r4, #2]
			len                 = 0;
   1000a:	4616      	mov	r6, r2
			zlp                 = true;
   1000c:	464b      	mov	r3, r9
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
   1000e:	461a      	mov	r2, r3
   10010:	e7d8      	b.n	ffc4 <usb_d_ep_transfer+0x58>
			if (dir) {
   10012:	f994 100c 	ldrsb.w	r1, [r4, #12]
   10016:	4296      	cmp	r6, r2
   10018:	bf28      	it	cs
   1001a:	4616      	movcs	r6, r2
   1001c:	2900      	cmp	r1, #0
   1001e:	daf6      	bge.n	1000e <STACK_SIZE+0xe>
				zlp = (req_len > len);
   10020:	42b2      	cmp	r2, r6
   10022:	bf94      	ite	ls
   10024:	2300      	movls	r3, #0
   10026:	2301      	movhi	r3, #1
			dir = (USB_GET_bmRequestType(ept->xfer.req) & USB_REQ_TYPE_IN);
   10028:	464a      	mov	r2, r9
   1002a:	e7cb      	b.n	ffc4 <usb_d_ep_transfer+0x58>
	struct usb_d_transfer trans
   1002c:	f001 020f 	and.w	r2, r1, #15
   10030:	e7cf      	b.n	ffd2 <usb_d_ep_transfer+0x66>
		return -USB_ERR_PARAM;
   10032:	f06f 0011 	mvn.w	r0, #17
   10036:	e7dd      	b.n	fff4 <usb_d_ep_transfer+0x88>
		switch (state) {
   10038:	2001      	movs	r0, #1
   1003a:	e7db      	b.n	fff4 <usb_d_ep_transfer+0x88>
   1003c:	0000fc39 	.word	0x0000fc39
   10040:	00012485 	.word	0x00012485
   10044:	00012493 	.word	0x00012493
   10048:	0000e159 	.word	0x0000e159
   1004c:	0001719a 	.word	0x0001719a
   10050:	20008b60 	.word	0x20008b60

00010054 <usb_d_ep_get_status>:
	ept->xfer.hdr.state  = USB_EP_S_IDLE;
	ept->xfer.hdr.status = USB_XFER_ABORT;
}

int32_t usb_d_ep_get_status(const uint8_t ep, struct usb_d_ep_status *stat)
{
   10054:	b5f0      	push	{r4, r5, r6, r7, lr}
	int8_t                    ep_index = _usb_d_find_ep(ep);
   10056:	4b12      	ldr	r3, [pc, #72]	; (100a0 <usb_d_ep_get_status+0x4c>)
	struct usb_d_ep *         ept      = &usb_d_inst.ep[ep_index];
	struct usb_d_trans_status tmp;
	uint8_t                   state = ept->xfer.hdr.state;
   10058:	4d12      	ldr	r5, [pc, #72]	; (100a4 <usb_d_ep_get_status+0x50>)
{
   1005a:	b085      	sub	sp, #20
   1005c:	4606      	mov	r6, r0
   1005e:	460c      	mov	r4, r1
	int8_t                    ep_index = _usb_d_find_ep(ep);
   10060:	4798      	blx	r3
	uint8_t                   state = ept->xfer.hdr.state;
   10062:	eb05 1540 	add.w	r5, r5, r0, lsl #5
	if (ep_index < 0) {
   10066:	2800      	cmp	r0, #0
	uint8_t                   state = ept->xfer.hdr.state;
   10068:	78af      	ldrb	r7, [r5, #2]
	if (ep_index < 0) {
   1006a:	db14      	blt.n	10096 <usb_d_ep_get_status+0x42>
		return -USB_ERR_PARAM;
	}
	if (stat) {
   1006c:	b15c      	cbz	r4, 10086 <usb_d_ep_get_status+0x32>
		/* Check transaction status if transferring data. */
		_usb_d_dev_ep_get_status(ep, &tmp);
   1006e:	4b0e      	ldr	r3, [pc, #56]	; (100a8 <usb_d_ep_get_status+0x54>)
   10070:	a901      	add	r1, sp, #4
   10072:	4630      	mov	r0, r6
   10074:	4798      	blx	r3
		stat->ep    = ep;
   10076:	7026      	strb	r6, [r4, #0]
		stat->state = state;
   10078:	70e7      	strb	r7, [r4, #3]
		stat->code  = ept->xfer.hdr.status;
   1007a:	78eb      	ldrb	r3, [r5, #3]
   1007c:	7063      	strb	r3, [r4, #1]
		stat->count = tmp.count;
   1007e:	9b02      	ldr	r3, [sp, #8]
   10080:	6063      	str	r3, [r4, #4]
		stat->size  = tmp.size;
   10082:	9b01      	ldr	r3, [sp, #4]
   10084:	60a3      	str	r3, [r4, #8]
	}
	switch (state) {
   10086:	2f06      	cmp	r7, #6
   10088:	d808      	bhi.n	1009c <usb_d_ep_get_status+0x48>
   1008a:	4b08      	ldr	r3, [pc, #32]	; (100ac <usb_d_ep_get_status+0x58>)
   1008c:	443b      	add	r3, r7
   1008e:	f993 0007 	ldrsb.w	r0, [r3, #7]
		return -USB_ERR_FUNC;
	default:
		/* Busy */
		return USB_BUSY;
	}
}
   10092:	b005      	add	sp, #20
   10094:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -USB_ERR_PARAM;
   10096:	f06f 0011 	mvn.w	r0, #17
   1009a:	e7fa      	b.n	10092 <usb_d_ep_get_status+0x3e>
   1009c:	2001      	movs	r0, #1
   1009e:	e7f8      	b.n	10092 <usb_d_ep_get_status+0x3e>
   100a0:	0000fc39 	.word	0x0000fc39
   100a4:	20008b60 	.word	0x20008b60
   100a8:	0000e261 	.word	0x0000e261
   100ac:	0001719a 	.word	0x0001719a

000100b0 <usb_d_ep_halt>:
	}
	return ERR_NONE;
}

int32_t usb_d_ep_halt(const uint8_t ep, const enum usb_ep_halt_ctrl ctrl)
{
   100b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   100b4:	4605      	mov	r5, r0
	if (ctrl == USB_EP_HALT_CLR) {
   100b6:	460c      	mov	r4, r1
   100b8:	b9d9      	cbnz	r1, 100f2 <usb_d_ep_halt+0x42>
	int8_t           ep_index = _usb_d_find_ep(ep);
   100ba:	4b13      	ldr	r3, [pc, #76]	; (10108 <usb_d_ep_halt+0x58>)
   100bc:	4798      	blx	r3
	if (ep_index < 0) {
   100be:	1e06      	subs	r6, r0, #0
   100c0:	db1e      	blt.n	10100 <usb_d_ep_halt+0x50>
	if (_usb_d_dev_ep_stall(ep, USB_EP_STALL_GET)) {
   100c2:	4f12      	ldr	r7, [pc, #72]	; (1010c <usb_d_ep_halt+0x5c>)
   100c4:	2102      	movs	r1, #2
   100c6:	4628      	mov	r0, r5
   100c8:	47b8      	blx	r7
   100ca:	b180      	cbz	r0, 100ee <usb_d_ep_halt+0x3e>
		rc = _usb_d_dev_ep_stall(ep, USB_EP_STALL_CLR);
   100cc:	4621      	mov	r1, r4
   100ce:	4628      	mov	r0, r5
   100d0:	47b8      	blx	r7
		if (rc < 0) {
   100d2:	2800      	cmp	r0, #0
   100d4:	db0b      	blt.n	100ee <usb_d_ep_halt+0x3e>
		ept->xfer.hdr.state  = USB_EP_S_IDLE;
   100d6:	480e      	ldr	r0, [pc, #56]	; (10110 <usb_d_ep_halt+0x60>)
   100d8:	eb00 1046 	add.w	r0, r0, r6, lsl #5
   100dc:	f240 3301 	movw	r3, #769	; 0x301
   100e0:	8043      	strh	r3, [r0, #2]
		ept->callbacks.xfer(ep, USB_XFER_UNHALT, NULL);
   100e2:	4622      	mov	r2, r4
   100e4:	69c3      	ldr	r3, [r0, #28]
   100e6:	2103      	movs	r1, #3
   100e8:	4628      	mov	r0, r5
   100ea:	4798      	blx	r3
	return ERR_NONE;
   100ec:	4620      	mov	r0, r4
	} else if (ctrl == USB_EP_HALT_SET) {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_SET);
	} else {
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
	}
}
   100ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ctrl == USB_EP_HALT_SET) {
   100f2:	2901      	cmp	r1, #1
}
   100f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   100f8:	4b04      	ldr	r3, [pc, #16]	; (1010c <usb_d_ep_halt+0x5c>)
		return _usb_d_dev_ep_stall(ep, USB_EP_STALL_GET);
   100fa:	bf18      	it	ne
   100fc:	2102      	movne	r1, #2
   100fe:	4718      	bx	r3
		return -USB_ERR_PARAM;
   10100:	f06f 0011 	mvn.w	r0, #17
   10104:	e7f3      	b.n	100ee <usb_d_ep_halt+0x3e>
   10106:	bf00      	nop
   10108:	0000fc39 	.word	0x0000fc39
   1010c:	0000e039 	.word	0x0000e039
   10110:	20008b60 	.word	0x20008b60

00010114 <usb_d_ep_register_callback>:

void usb_d_ep_register_callback(const uint8_t ep, const enum usb_d_ep_cb_type type, const FUNC_PTR func)
{
   10114:	b538      	push	{r3, r4, r5, lr}
	int8_t           ep_index = _usb_d_find_ep(ep);
   10116:	4b0f      	ldr	r3, [pc, #60]	; (10154 <usb_d_ep_register_callback+0x40>)
{
   10118:	4614      	mov	r4, r2
   1011a:	460d      	mov	r5, r1
	int8_t           ep_index = _usb_d_find_ep(ep);
   1011c:	4798      	blx	r3
	struct usb_d_ep *ept      = &usb_d_inst.ep[ep_index];
	FUNC_PTR         f        = func ? (FUNC_PTR)func : (FUNC_PTR)usb_d_dummy_cb_false;
   1011e:	4b0e      	ldr	r3, [pc, #56]	; (10158 <usb_d_ep_register_callback+0x44>)
   10120:	2c00      	cmp	r4, #0
   10122:	bf08      	it	eq
   10124:	461c      	moveq	r4, r3
	if (ep_index < 0) {
   10126:	2800      	cmp	r0, #0
   10128:	db08      	blt.n	1013c <usb_d_ep_register_callback+0x28>
		return;
	}
	switch (type) {
   1012a:	2d01      	cmp	r5, #1
   1012c:	d007      	beq.n	1013e <usb_d_ep_register_callback+0x2a>
   1012e:	2d02      	cmp	r5, #2
   10130:	d00a      	beq.n	10148 <usb_d_ep_register_callback+0x34>
   10132:	b91d      	cbnz	r5, 1013c <usb_d_ep_register_callback+0x28>
	case USB_D_EP_CB_SETUP:
		ept->callbacks.req = (usb_d_ep_cb_setup_t)f;
   10134:	4b09      	ldr	r3, [pc, #36]	; (1015c <usb_d_ep_register_callback+0x48>)
   10136:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   1013a:	6144      	str	r4, [r0, #20]
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
		break;
	default:
		break;
	}
}
   1013c:	bd38      	pop	{r3, r4, r5, pc}
		ept->callbacks.more = (usb_d_ep_cb_more_t)f;
   1013e:	4b07      	ldr	r3, [pc, #28]	; (1015c <usb_d_ep_register_callback+0x48>)
   10140:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   10144:	6184      	str	r4, [r0, #24]
		break;
   10146:	e7f9      	b.n	1013c <usb_d_ep_register_callback+0x28>
		ept->callbacks.xfer = (usb_d_ep_cb_xfer_t)f;
   10148:	4b04      	ldr	r3, [pc, #16]	; (1015c <usb_d_ep_register_callback+0x48>)
   1014a:	eb03 1040 	add.w	r0, r3, r0, lsl #5
   1014e:	61c4      	str	r4, [r0, #28]
		break;
   10150:	e7f4      	b.n	1013c <usb_d_ep_register_callback+0x28>
   10152:	bf00      	nop
   10154:	0000fc39 	.word	0x0000fc39
   10158:	0000fc69 	.word	0x0000fc69
   1015c:	20008b60 	.word	0x20008b60

00010160 <is_list_element>:
 * \brief Check whether element belongs to list
 */
bool is_list_element(const struct list_descriptor *const list, const void *const element)
{
	struct list_element *it;
	for (it = list->head; it; it = it->next) {
   10160:	6800      	ldr	r0, [r0, #0]
   10162:	b900      	cbnz	r0, 10166 <is_list_element+0x6>
   10164:	4770      	bx	lr
		if (it == element) {
   10166:	4288      	cmp	r0, r1
   10168:	d1fa      	bne.n	10160 <is_list_element>
			return true;
   1016a:	2001      	movs	r0, #1
		}
	}

	return false;
}
   1016c:	4770      	bx	lr
	...

00010170 <list_insert_as_head>:

/**
 * \brief Insert an element as list head
 */
void list_insert_as_head(struct list_descriptor *const list, void *const element)
{
   10170:	b538      	push	{r3, r4, r5, lr}
	ASSERT(!is_list_element(list, element));
   10172:	4b07      	ldr	r3, [pc, #28]	; (10190 <list_insert_as_head+0x20>)
{
   10174:	460d      	mov	r5, r1
   10176:	4604      	mov	r4, r0
	ASSERT(!is_list_element(list, element));
   10178:	4798      	blx	r3
   1017a:	f080 0001 	eor.w	r0, r0, #1
   1017e:	4b05      	ldr	r3, [pc, #20]	; (10194 <list_insert_as_head+0x24>)
   10180:	4905      	ldr	r1, [pc, #20]	; (10198 <list_insert_as_head+0x28>)
   10182:	2239      	movs	r2, #57	; 0x39
   10184:	b2c0      	uxtb	r0, r0
   10186:	4798      	blx	r3

	((struct list_element *)element)->next = list->head;
   10188:	6823      	ldr	r3, [r4, #0]
   1018a:	602b      	str	r3, [r5, #0]
	list->head                             = (struct list_element *)element;
   1018c:	6025      	str	r5, [r4, #0]
}
   1018e:	bd38      	pop	{r3, r4, r5, pc}
   10190:	00010161 	.word	0x00010161
   10194:	0000e9b9 	.word	0x0000e9b9
   10198:	000171a8 	.word	0x000171a8

0001019c <list_insert_after>:
/**
 * \brief Insert an element after the given list element
 */
void list_insert_after(void *const after, void *const element)
{
	((struct list_element *)element)->next = ((struct list_element *)after)->next;
   1019c:	6803      	ldr	r3, [r0, #0]
   1019e:	600b      	str	r3, [r1, #0]
	((struct list_element *)after)->next   = (struct list_element *)element;
   101a0:	6001      	str	r1, [r0, #0]
}
   101a2:	4770      	bx	lr

000101a4 <list_insert_at_end>:

/**
 * \brief Insert an element at list end
 */
void list_insert_at_end(struct list_descriptor *const list, void *const element)
{
   101a4:	b570      	push	{r4, r5, r6, lr}
	struct list_element *it = list->head;

	ASSERT(!is_list_element(list, element));
   101a6:	4b0c      	ldr	r3, [pc, #48]	; (101d8 <list_insert_at_end+0x34>)
	struct list_element *it = list->head;
   101a8:	6805      	ldr	r5, [r0, #0]
{
   101aa:	4606      	mov	r6, r0
   101ac:	460c      	mov	r4, r1
	ASSERT(!is_list_element(list, element));
   101ae:	4798      	blx	r3
   101b0:	f080 0001 	eor.w	r0, r0, #1
   101b4:	4b09      	ldr	r3, [pc, #36]	; (101dc <list_insert_at_end+0x38>)
   101b6:	490a      	ldr	r1, [pc, #40]	; (101e0 <list_insert_at_end+0x3c>)
   101b8:	224f      	movs	r2, #79	; 0x4f
   101ba:	b2c0      	uxtb	r0, r0
   101bc:	4798      	blx	r3

	if (!list->head) {
   101be:	6833      	ldr	r3, [r6, #0]
   101c0:	b913      	cbnz	r3, 101c8 <list_insert_at_end+0x24>
		list->head                             = (struct list_element *)element;
   101c2:	6034      	str	r4, [r6, #0]
		((struct list_element *)element)->next = NULL;
   101c4:	6023      	str	r3, [r4, #0]
	while (it->next) {
		it = it->next;
	}
	it->next                               = (struct list_element *)element;
	((struct list_element *)element)->next = NULL;
}
   101c6:	bd70      	pop	{r4, r5, r6, pc}
	while (it->next) {
   101c8:	462b      	mov	r3, r5
   101ca:	682d      	ldr	r5, [r5, #0]
   101cc:	2d00      	cmp	r5, #0
   101ce:	d1fb      	bne.n	101c8 <list_insert_at_end+0x24>
	it->next                               = (struct list_element *)element;
   101d0:	601c      	str	r4, [r3, #0]
	((struct list_element *)element)->next = NULL;
   101d2:	6025      	str	r5, [r4, #0]
   101d4:	e7f7      	b.n	101c6 <list_insert_at_end+0x22>
   101d6:	bf00      	nop
   101d8:	00010161 	.word	0x00010161
   101dc:	0000e9b9 	.word	0x0000e9b9
   101e0:	000171a8 	.word	0x000171a8

000101e4 <list_remove_head>:
/**
 * \brief Removes list head
 */
void *list_remove_head(struct list_descriptor *const list)
{
	if (list->head) {
   101e4:	6803      	ldr	r3, [r0, #0]
   101e6:	b10b      	cbz	r3, 101ec <list_remove_head+0x8>
		struct list_element *tmp = list->head;

		list->head = list->head->next;
   101e8:	681a      	ldr	r2, [r3, #0]
   101ea:	6002      	str	r2, [r0, #0]
		return (void *)tmp;
	}

	return NULL;
}
   101ec:	4618      	mov	r0, r3
   101ee:	4770      	bx	lr

000101f0 <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
   101f0:	4b03      	ldr	r3, [pc, #12]	; (10200 <_osc32kctrl_init_sources+0x10>)
   101f2:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSCULP32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSCULP32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
   101f4:	f402 527c 	and.w	r2, r2, #16128	; 0x3f00
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
   101f8:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
   101fa:	2201      	movs	r2, #1
   101fc:	741a      	strb	r2, [r3, #16]
#endif
#endif

	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
   101fe:	4770      	bx	lr
   10200:	40001400 	.word	0x40001400

00010204 <hri_rtcmode0_wait_for_sync>:
typedef uint8_t  hri_rtcalarm_mask_reg_t;
typedef uint8_t  hri_rtcmode2_mask_reg_t;

static inline void hri_rtcmode0_wait_for_sync(const void *const hw, hri_rtcmode0_syncbusy_reg_t reg)
{
	while (((Rtc *)hw)->MODE0.SYNCBUSY.reg & reg) {
   10204:	6903      	ldr	r3, [r0, #16]
   10206:	420b      	tst	r3, r1
   10208:	d1fc      	bne.n	10204 <hri_rtcmode0_wait_for_sync>
	};
}
   1020a:	4770      	bx	lr

0001020c <_rtc_timer_set_period>:
/**
 * \brief Set timer period
 */
void _rtc_timer_set_period(struct _timer_device *const dev, const uint32_t clock_cycles)
{
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, clock_cycles);
   1020c:	68c0      	ldr	r0, [r0, #12]

static inline void hri_rtcmode0_write_COMP_reg(const void *const hw, uint8_t index, hri_rtcmode0_comp_reg_t data)
{
	RTC_CRITICAL_SECTION_ENTER();
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
   1020e:	4b02      	ldr	r3, [pc, #8]	; (10218 <_rtc_timer_set_period+0xc>)
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
   10210:	6201      	str	r1, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
   10212:	2160      	movs	r1, #96	; 0x60
   10214:	4718      	bx	r3
   10216:	bf00      	nop
   10218:	00010205 	.word	0x00010205

0001021c <_rtc_timer_get_period>:

/**
 * \brief Retrieve timer period
 */
uint32_t _rtc_timer_get_period(const struct _timer_device *const dev)
{
   1021c:	b508      	push	{r3, lr}
	return hri_rtcmode0_read_COMP_reg(dev->hw, 0);
   1021e:	68c0      	ldr	r0, [r0, #12]
	RTC_CRITICAL_SECTION_LEAVE();
}

static inline hri_rtcmode0_comp_reg_t hri_rtcmode0_read_COMP_reg(const void *const hw, uint8_t index)
{
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
   10220:	4b02      	ldr	r3, [pc, #8]	; (1022c <_rtc_timer_get_period+0x10>)
   10222:	2160      	movs	r1, #96	; 0x60
   10224:	4798      	blx	r3
	return ((Rtc *)hw)->MODE0.COMP[index].reg;
   10226:	6a00      	ldr	r0, [r0, #32]
}
   10228:	bd08      	pop	{r3, pc}
   1022a:	bf00      	nop
   1022c:	00010205 	.word	0x00010205

00010230 <_rtc_timer_is_started>:

/**
 * \brief Check if timer is running
 */
bool _rtc_timer_is_started(const struct _timer_device *const dev)
{
   10230:	b508      	push	{r3, lr}
	return hri_rtcmode0_get_CTRLA_ENABLE_bit(dev->hw);
   10232:	68c0      	ldr	r0, [r0, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   10234:	4b03      	ldr	r3, [pc, #12]	; (10244 <_rtc_timer_is_started+0x14>)
   10236:	f248 0103 	movw	r1, #32771	; 0x8003
   1023a:	4798      	blx	r3
	tmp = ((Rtc *)hw)->MODE0.CTRLA.reg;
   1023c:	8800      	ldrh	r0, [r0, #0]
}
   1023e:	f3c0 0040 	ubfx	r0, r0, #1, #1
   10242:	bd08      	pop	{r3, pc}
   10244:	00010205 	.word	0x00010205

00010248 <_rtc_timer_set_irq>:
 * \brief Set timer IRQ
 */
void _rtc_timer_set_irq(struct _timer_device *const dev)
{
	(void)dev;
}
   10248:	4770      	bx	lr
	...

0001024c <_rtc_timer_stop>:
{
   1024c:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
   1024e:	4604      	mov	r4, r0
   10250:	b118      	cbz	r0, 1025a <_rtc_timer_stop+0xe>
   10252:	68c0      	ldr	r0, [r0, #12]
   10254:	3800      	subs	r0, #0
   10256:	bf18      	it	ne
   10258:	2001      	movne	r0, #1
   1025a:	4908      	ldr	r1, [pc, #32]	; (1027c <_rtc_timer_stop+0x30>)
   1025c:	4b08      	ldr	r3, [pc, #32]	; (10280 <_rtc_timer_stop+0x34>)
   1025e:	226b      	movs	r2, #107	; 0x6b
   10260:	4798      	blx	r3
	hri_rtcmode0_clear_CTRLA_ENABLE_bit(dev->hw);
   10262:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg &= ~RTC_MODE0_CTRLA_ENABLE;
   10264:	8803      	ldrh	r3, [r0, #0]
   10266:	f023 0302 	bic.w	r3, r3, #2
   1026a:	041b      	lsls	r3, r3, #16
   1026c:	0c1b      	lsrs	r3, r3, #16
   1026e:	8003      	strh	r3, [r0, #0]
}
   10270:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   10274:	4b03      	ldr	r3, [pc, #12]	; (10284 <_rtc_timer_stop+0x38>)
   10276:	f248 0103 	movw	r1, #32771	; 0x8003
   1027a:	4718      	bx	r3
   1027c:	000171c6 	.word	0x000171c6
   10280:	0000e9b9 	.word	0x0000e9b9
   10284:	00010205 	.word	0x00010205

00010288 <_rtc_timer_start>:
{
   10288:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
   1028a:	4604      	mov	r4, r0
   1028c:	b118      	cbz	r0, 10296 <_rtc_timer_start+0xe>
   1028e:	68c0      	ldr	r0, [r0, #12]
   10290:	3800      	subs	r0, #0
   10292:	bf18      	it	ne
   10294:	2001      	movne	r0, #1
   10296:	490e      	ldr	r1, [pc, #56]	; (102d0 <_rtc_timer_start+0x48>)
   10298:	4b0e      	ldr	r3, [pc, #56]	; (102d4 <_rtc_timer_start+0x4c>)
   1029a:	225e      	movs	r2, #94	; 0x5e
   1029c:	4798      	blx	r3
   1029e:	4b0e      	ldr	r3, [pc, #56]	; (102d8 <_rtc_timer_start+0x50>)
	hri_rtcmode0_write_COUNT_reg(dev->hw, 0);
   102a0:	68e0      	ldr	r0, [r4, #12]
   102a2:	f44f 6200 	mov.w	r2, #2048	; 0x800
   102a6:	601a      	str	r2, [r3, #0]
	((Rtc *)hw)->MODE0.COUNT.reg = data;
   102a8:	2300      	movs	r3, #0
   102aa:	6183      	str	r3, [r0, #24]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COUNT);
   102ac:	4a0b      	ldr	r2, [pc, #44]	; (102dc <_rtc_timer_start+0x54>)
   102ae:	2108      	movs	r1, #8
   102b0:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_COUNT);
   102b2:	68e0      	ldr	r0, [r4, #12]
   102b4:	2108      	movs	r1, #8
   102b6:	4790      	blx	r2
	hri_rtcmode0_set_CTRLA_ENABLE_bit(dev->hw);
   102b8:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg |= RTC_MODE0_CTRLA_ENABLE;
   102ba:	8803      	ldrh	r3, [r0, #0]
   102bc:	b29b      	uxth	r3, r3
   102be:	f043 0302 	orr.w	r3, r3, #2
}
   102c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   102c6:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   102c8:	f248 0103 	movw	r1, #32771	; 0x8003
   102cc:	4710      	bx	r2
   102ce:	bf00      	nop
   102d0:	000171c6 	.word	0x000171c6
   102d4:	0000e9b9 	.word	0x0000e9b9
   102d8:	e000e100 	.word	0xe000e100
   102dc:	00010205 	.word	0x00010205

000102e0 <_rtc_timer_deinit>:
{
   102e0:	b510      	push	{r4, lr}
	ASSERT(dev && dev->hw);
   102e2:	4604      	mov	r4, r0
   102e4:	b118      	cbz	r0, 102ee <_rtc_timer_deinit+0xe>
   102e6:	68c0      	ldr	r0, [r0, #12]
   102e8:	3800      	subs	r0, #0
   102ea:	bf18      	it	ne
   102ec:	2001      	movne	r0, #1
   102ee:	490b      	ldr	r1, [pc, #44]	; (1031c <_rtc_timer_deinit+0x3c>)
   102f0:	4b0b      	ldr	r3, [pc, #44]	; (10320 <_rtc_timer_deinit+0x40>)
   102f2:	2252      	movs	r2, #82	; 0x52
   102f4:	4798      	blx	r3
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   102f6:	4b0b      	ldr	r3, [pc, #44]	; (10324 <_rtc_timer_deinit+0x44>)
   102f8:	f44f 6200 	mov.w	r2, #2048	; 0x800
   102fc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  __ASM volatile ("dsb 0xF":::"memory");
   10300:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   10304:	f3bf 8f6f 	isb	sy
	hri_rtcmode0_write_CTRLA_reg(dev->hw, RTC_MODE0_CTRLA_SWRST);
   10308:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
   1030a:	2301      	movs	r3, #1
   1030c:	8003      	strh	r3, [r0, #0]
}
   1030e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   10312:	4b05      	ldr	r3, [pc, #20]	; (10328 <_rtc_timer_deinit+0x48>)
   10314:	f248 0103 	movw	r1, #32771	; 0x8003
   10318:	4718      	bx	r3
   1031a:	bf00      	nop
   1031c:	000171c6 	.word	0x000171c6
   10320:	0000e9b9 	.word	0x0000e9b9
   10324:	e000e100 	.word	0xe000e100
   10328:	00010205 	.word	0x00010205

0001032c <_rtc_timer_init>:
{
   1032c:	b570      	push	{r4, r5, r6, lr}
	ASSERT(dev);
   1032e:	4604      	mov	r4, r0
{
   10330:	460d      	mov	r5, r1
	ASSERT(dev);
   10332:	3800      	subs	r0, #0
   10334:	bf18      	it	ne
   10336:	2001      	movne	r0, #1
   10338:	4b10      	ldr	r3, [pc, #64]	; (1037c <_rtc_timer_init+0x50>)
   1033a:	4911      	ldr	r1, [pc, #68]	; (10380 <_rtc_timer_init+0x54>)
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
   1033c:	2601      	movs	r6, #1
   1033e:	2230      	movs	r2, #48	; 0x30
   10340:	4798      	blx	r3
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   10342:	4a10      	ldr	r2, [pc, #64]	; (10384 <_rtc_timer_init+0x58>)
	dev->hw = hw;
   10344:	60e5      	str	r5, [r4, #12]
   10346:	4628      	mov	r0, r5
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
   10348:	802e      	strh	r6, [r5, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   1034a:	f248 0103 	movw	r1, #32771	; 0x8003
   1034e:	4790      	blx	r2
	hri_rtcmode0_wait_for_sync(dev->hw, RTC_MODE0_SYNCBUSY_SWRST);
   10350:	68e0      	ldr	r0, [r4, #12]
   10352:	4631      	mov	r1, r6
   10354:	4790      	blx	r2
	    dev->hw, RTC_MODE0_CTRLA_PRESCALER(CONF_RTC_PRESCALER) | RTC_MODE0_CTRLA_COUNTSYNC | RTC_MODE0_CTRLA_MATCHCLR);
   10356:	68e0      	ldr	r0, [r4, #12]
	((Rtc *)hw)->MODE0.CTRLA.reg = data;
   10358:	f248 0380 	movw	r3, #32896	; 0x8080
   1035c:	8003      	strh	r3, [r0, #0]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_SWRST | RTC_MODE0_SYNCBUSY_ENABLE | RTC_MODE0_SYNCBUSY_COUNTSYNC);
   1035e:	f248 0103 	movw	r1, #32771	; 0x8003
   10362:	4790      	blx	r2
	hri_rtcmode0_write_COMP_reg(dev->hw, 0, CONF_RTC_COMP_VAL);
   10364:	68e0      	ldr	r0, [r4, #12]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
   10366:	2160      	movs	r1, #96	; 0x60
	((Rtc *)hw)->MODE0.COMP[index].reg = data;
   10368:	6206      	str	r6, [r0, #32]
	hri_rtcmode0_wait_for_sync(hw, RTC_MODE0_SYNCBUSY_COMP0 | RTC_MODE0_SYNCBUSY_COMP1);
   1036a:	4790      	blx	r2
	hri_rtcmode0_set_INTEN_CMP0_bit(dev->hw);
   1036c:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTENSET.reg = RTC_MODE0_INTENSET_CMP0;
   1036e:	f44f 7280 	mov.w	r2, #256	; 0x100
   10372:	815a      	strh	r2, [r3, #10]
	_rtc_dev = dev;
   10374:	4b04      	ldr	r3, [pc, #16]	; (10388 <_rtc_timer_init+0x5c>)
}
   10376:	2000      	movs	r0, #0
	_rtc_dev = dev;
   10378:	601c      	str	r4, [r3, #0]
}
   1037a:	bd70      	pop	{r4, r5, r6, pc}
   1037c:	0000e9b9 	.word	0x0000e9b9
   10380:	000171c6 	.word	0x000171c6
   10384:	00010205 	.word	0x00010205
   10388:	20008d00 	.word	0x20008d00

0001038c <_rtc_get_timer>:
 * \brief Retrieve timer helper functions
 */
struct _timer_hpl_interface *_rtc_get_timer(void)
{
	return &_rtc_timer_functions;
}
   1038c:	4800      	ldr	r0, [pc, #0]	; (10390 <_rtc_get_timer+0x4>)
   1038e:	4770      	bx	lr
   10390:	2000050c 	.word	0x2000050c

00010394 <RTC_Handler>:
/**
 * \brief Rtc interrupt handler
 */
void RTC_Handler(void)
{
	_rtc_timer_interrupt_handler(_rtc_dev);
   10394:	4b07      	ldr	r3, [pc, #28]	; (103b4 <RTC_Handler+0x20>)
{
   10396:	b510      	push	{r4, lr}
	_rtc_timer_interrupt_handler(_rtc_dev);
   10398:	681c      	ldr	r4, [r3, #0]
	uint16_t flag = hri_rtcmode0_read_INTFLAG_reg(dev->hw);
   1039a:	68e3      	ldr	r3, [r4, #12]
	return ((Rtc *)hw)->MODE0.INTFLAG.reg;
   1039c:	899b      	ldrh	r3, [r3, #12]
	if (flag & RTC_MODE0_INTFLAG_CMP0) {
   1039e:	05db      	lsls	r3, r3, #23
   103a0:	d507      	bpl.n	103b2 <RTC_Handler+0x1e>
		if (dev->timer_cb.period_expired) {
   103a2:	6823      	ldr	r3, [r4, #0]
   103a4:	b10b      	cbz	r3, 103aa <RTC_Handler+0x16>
			dev->timer_cb.period_expired(dev);
   103a6:	4620      	mov	r0, r4
   103a8:	4798      	blx	r3
		hri_rtcmode0_clear_interrupt_CMP0_bit(dev->hw);
   103aa:	68e3      	ldr	r3, [r4, #12]
	((Rtc *)hw)->MODE0.INTFLAG.reg = RTC_MODE0_INTFLAG_CMP0;
   103ac:	f44f 7280 	mov.w	r2, #256	; 0x100
   103b0:	819a      	strh	r2, [r3, #12]
}
   103b2:	bd10      	pop	{r4, pc}
   103b4:	20008d00 	.word	0x20008d00

000103b8 <_gpio_set_pin_function>:

/**
 * \brief Set gpio pin function
 */
static inline void _gpio_set_pin_function(const uint32_t gpio, const uint32_t function)
{
   103b8:	b530      	push	{r4, r5, lr}
	uint8_t port = GPIO_PORT(gpio);
	uint8_t pin  = GPIO_PIN(gpio);

	if (function == GPIO_PIN_FUNCTION_OFF) {
   103ba:	1c4b      	adds	r3, r1, #1
	uint8_t pin  = GPIO_PIN(gpio);
   103bc:	b2c5      	uxtb	r5, r0
   103be:	4b18      	ldr	r3, [pc, #96]	; (10420 <_gpio_set_pin_function+0x68>)
   103c0:	f000 041f 	and.w	r4, r0, #31
	uint8_t port = GPIO_PORT(gpio);
   103c4:	ea4f 1050 	mov.w	r0, r0, lsr #5
   103c8:	ea4f 10c0 	mov.w	r0, r0, lsl #7
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103cc:	4403      	add	r3, r0
	if (function == GPIO_PIN_FUNCTION_OFF) {
   103ce:	d107      	bne.n	103e0 <_gpio_set_pin_function+0x28>
   103d0:	4423      	add	r3, r4
   103d2:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
   103d6:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103da:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
		} else {
			// Even numbered pin
			hri_port_write_PMUX_PMUXE_bf(PORT, port, pin >> 1, function & 0xffff);
		}
	}
}
   103de:	bd30      	pop	{r4, r5, pc}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   103e0:	1918      	adds	r0, r3, r4
   103e2:	eb03 0354 	add.w	r3, r3, r4, lsr #1
   103e6:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
	tmp &= ~PORT_PINCFG_PMUXEN;
   103ea:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
   103ee:	f042 0201 	orr.w	r2, r2, #1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   103f2:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
   103f6:	f893 2030 	ldrb.w	r2, [r3, #48]	; 0x30
		if (pin & 1) {
   103fa:	f015 0f01 	tst.w	r5, #1
   103fe:	b2c9      	uxtb	r1, r1
	tmp &= ~PORT_PMUX_PMUXO_Msk;
   10400:	bf19      	ittee	ne
   10402:	f002 020f 	andne.w	r2, r2, #15
	tmp |= PORT_PMUX_PMUXO(data);
   10406:	ea42 1101 	orrne.w	r1, r2, r1, lsl #4
	tmp |= PORT_PMUX_PMUXE(data);
   1040a:	f001 010f 	andeq.w	r1, r1, #15
	tmp &= ~PORT_PMUX_PMUXE_Msk;
   1040e:	f002 02f0 	andeq.w	r2, r2, #240	; 0xf0
	tmp |= PORT_PMUX_PMUXO(data);
   10412:	bf14      	ite	ne
   10414:	b2c9      	uxtbne	r1, r1
	tmp |= PORT_PMUX_PMUXE(data);
   10416:	4311      	orreq	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
   10418:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
}
   1041c:	e7df      	b.n	103de <_gpio_set_pin_function+0x26>
   1041e:	bf00      	nop
   10420:	41008000 	.word	0x41008000

00010424 <gpio_set_pin_direction>:
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
   10424:	f000 031f 	and.w	r3, r0, #31
{
   10428:	b530      	push	{r4, r5, lr}
	_gpio_set_direction((enum gpio_port)GPIO_PORT(pin), 1U << GPIO_PIN(pin), direction);
   1042a:	2501      	movs	r5, #1
   1042c:	409d      	lsls	r5, r3
	switch (direction) {
   1042e:	0940      	lsrs	r0, r0, #5
   10430:	4b0f      	ldr	r3, [pc, #60]	; (10470 <gpio_set_pin_direction+0x4c>)
   10432:	01c0      	lsls	r0, r0, #7
   10434:	2901      	cmp	r1, #1
   10436:	b2ac      	uxth	r4, r5
   10438:	ea4f 4215 	mov.w	r2, r5, lsr #16
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
   1043c:	4403      	add	r3, r0
   1043e:	d008      	beq.n	10452 <gpio_set_pin_direction+0x2e>
   10440:	2902      	cmp	r1, #2
   10442:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
   10446:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
   1044a:	d00e      	beq.n	1046a <gpio_set_pin_direction+0x46>
   1044c:	605d      	str	r5, [r3, #4]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
   1044e:	629c      	str	r4, [r3, #40]	; 0x28
   10450:	e009      	b.n	10466 <gpio_set_pin_direction+0x42>
		hri_port_write_WRCONFIG_reg(PORT, port, PORT_WRCONFIG_WRPINCFG | PORT_WRCONFIG_INEN | (mask & 0xffff));
   10452:	f044 4480 	orr.w	r4, r4, #1073741824	; 0x40000000
   10456:	f444 3400 	orr.w	r4, r4, #131072	; 0x20000
		hri_port_write_WRCONFIG_reg(PORT,
   1045a:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
   1045e:	605d      	str	r5, [r3, #4]
   10460:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
   10464:	629c      	str	r4, [r3, #40]	; 0x28
   10466:	629a      	str	r2, [r3, #40]	; 0x28
}
   10468:	bd30      	pop	{r4, r5, pc}
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
   1046a:	609d      	str	r5, [r3, #8]
   1046c:	e7ef      	b.n	1044e <gpio_set_pin_direction+0x2a>
   1046e:	bf00      	nop
   10470:	41008000 	.word	0x41008000

00010474 <gpio_set_pin_pull_mode>:
	switch (pull_mode) {
   10474:	0942      	lsrs	r2, r0, #5
   10476:	2901      	cmp	r1, #1
   10478:	4b0d      	ldr	r3, [pc, #52]	; (104b0 <gpio_set_pin_pull_mode+0x3c>)
   1047a:	f000 001f 	and.w	r0, r0, #31
   1047e:	ea4f 12c2 	mov.w	r2, r2, lsl #7
   10482:	d008      	beq.n	10496 <gpio_set_pin_pull_mode+0x22>
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg &= ~PORT_PINCFG_PULLEN;
   10484:	4413      	add	r3, r2
   10486:	4418      	add	r0, r3
   10488:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
   1048c:	f003 03fb 	and.w	r3, r3, #251	; 0xfb
   10490:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
}
   10494:	4770      	bx	lr
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
   10496:	4413      	add	r3, r2
		hri_port_clear_DIR_reg(PORT, port, 1U << pin);
   10498:	4081      	lsls	r1, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
   1049a:	4418      	add	r0, r3
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
   1049c:	6059      	str	r1, [r3, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
   1049e:	f890 2040 	ldrb.w	r2, [r0, #64]	; 0x40
   104a2:	f042 0204 	orr.w	r2, r2, #4
   104a6:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
   104aa:	6199      	str	r1, [r3, #24]
}
   104ac:	4770      	bx	lr
   104ae:	bf00      	nop
   104b0:	41008000 	.word	0x41008000

000104b4 <ADC_0_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC0;
   104b4:	4a14      	ldr	r2, [pc, #80]	; (10508 <ADC_0_init+0x54>)
 */
void ADC_0_init(void)
{
	hri_mclk_set_APBDMASK_ADC0_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC0_GCLK_ID, CONF_GCLK_ADC0_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
   104b6:	4915      	ldr	r1, [pc, #84]	; (1050c <ADC_0_init+0x58>)
   104b8:	6a13      	ldr	r3, [r2, #32]
{
   104ba:	b5f0      	push	{r4, r5, r6, r7, lr}
   104bc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   104c0:	6213      	str	r3, [r2, #32]
	((Gclk *)hw)->PCHCTRL[index].reg = data;
   104c2:	4b13      	ldr	r3, [pc, #76]	; (10510 <ADC_0_init+0x5c>)
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
   104c4:	4e13      	ldr	r6, [pc, #76]	; (10514 <ADC_0_init+0x60>)
   104c6:	4d14      	ldr	r5, [pc, #80]	; (10518 <ADC_0_init+0x64>)
   104c8:	4f14      	ldr	r7, [pc, #80]	; (1051c <ADC_0_init+0x68>)
{
   104ca:	b085      	sub	sp, #20
   104cc:	2241      	movs	r2, #65	; 0x41
   104ce:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	adc_async_init(&ADC_0, ADC0, ADC_0_map, ADC_0_CH_MAX, ADC_0_CH_AMOUNT, &ADC_0_ch[0], (void *)NULL);
   104d2:	4b13      	ldr	r3, [pc, #76]	; (10520 <ADC_0_init+0x6c>)
   104d4:	9301      	str	r3, [sp, #4]
   104d6:	2400      	movs	r4, #0
   104d8:	2301      	movs	r3, #1
   104da:	9300      	str	r3, [sp, #0]
   104dc:	4632      	mov	r2, r6
   104de:	4623      	mov	r3, r4
   104e0:	9402      	str	r4, [sp, #8]
   104e2:	4628      	mov	r0, r5
   104e4:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_0, 0, ADC_0_buffer, ADC_0_BUFFER_SIZE);
   104e6:	1c72      	adds	r2, r6, #1
   104e8:	4621      	mov	r1, r4
   104ea:	2310      	movs	r3, #16
   104ec:	4628      	mov	r0, r5
   104ee:	4d0d      	ldr	r5, [pc, #52]	; (10524 <ADC_0_init+0x70>)
   104f0:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PA07, GPIO_DIRECTION_OFF);
   104f2:	4621      	mov	r1, r4
   104f4:	4b0c      	ldr	r3, [pc, #48]	; (10528 <ADC_0_init+0x74>)
   104f6:	2007      	movs	r0, #7
   104f8:	4798      	blx	r3
	_gpio_set_pin_function(pin, function);
   104fa:	490c      	ldr	r1, [pc, #48]	; (1052c <ADC_0_init+0x78>)
   104fc:	4b0c      	ldr	r3, [pc, #48]	; (10530 <ADC_0_init+0x7c>)
   104fe:	2007      	movs	r0, #7

	gpio_set_pin_function(PA07, PINMUX_PA07B_ADC0_AIN7);
}
   10500:	b005      	add	sp, #20
   10502:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   10506:	4718      	bx	r3
   10508:	40000800 	.word	0x40000800
   1050c:	43001c00 	.word	0x43001c00
   10510:	40001c00 	.word	0x40001c00
   10514:	20008d04 	.word	0x20008d04
   10518:	2001cd84 	.word	0x2001cd84
   1051c:	0000ecb1 	.word	0x0000ecb1
   10520:	2001ce80 	.word	0x2001ce80
   10524:	0000ed55 	.word	0x0000ed55
   10528:	00010425 	.word	0x00010425
   1052c:	00070001 	.word	0x00070001
   10530:	000103b9 	.word	0x000103b9

00010534 <ADC_1_init>:
}

static inline void hri_mclk_set_APBDMASK_ADC1_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_ADC1;
   10534:	4a15      	ldr	r2, [pc, #84]	; (1058c <ADC_1_init+0x58>)
 */
void ADC_1_init(void)
{
	hri_mclk_set_APBDMASK_ADC1_bit(MCLK);
	hri_gclk_write_PCHCTRL_reg(GCLK, ADC1_GCLK_ID, CONF_GCLK_ADC1_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
   10536:	4916      	ldr	r1, [pc, #88]	; (10590 <ADC_1_init+0x5c>)
   10538:	6a13      	ldr	r3, [r2, #32]
{
   1053a:	b5f0      	push	{r4, r5, r6, r7, lr}
   1053c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10540:	6213      	str	r3, [r2, #32]
   10542:	4b14      	ldr	r3, [pc, #80]	; (10594 <ADC_1_init+0x60>)
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
   10544:	4e14      	ldr	r6, [pc, #80]	; (10598 <ADC_1_init+0x64>)
   10546:	4d15      	ldr	r5, [pc, #84]	; (1059c <ADC_1_init+0x68>)
   10548:	4f15      	ldr	r7, [pc, #84]	; (105a0 <ADC_1_init+0x6c>)
{
   1054a:	b085      	sub	sp, #20
   1054c:	2241      	movs	r2, #65	; 0x41
   1054e:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
	adc_async_init(&ADC_1, ADC1, ADC_1_map, ADC_1_CH_MAX, ADC_1_CH_AMOUNT, &ADC_1_ch[0], (void *)NULL);
   10552:	4b14      	ldr	r3, [pc, #80]	; (105a4 <ADC_1_init+0x70>)
   10554:	9301      	str	r3, [sp, #4]
   10556:	2400      	movs	r4, #0
   10558:	2301      	movs	r3, #1
   1055a:	9300      	str	r3, [sp, #0]
   1055c:	f106 0211 	add.w	r2, r6, #17
   10560:	4623      	mov	r3, r4
   10562:	9402      	str	r4, [sp, #8]
   10564:	4628      	mov	r0, r5
   10566:	47b8      	blx	r7
	adc_async_register_channel_buffer(&ADC_1, 0, ADC_1_buffer, ADC_1_BUFFER_SIZE);
   10568:	f106 0212 	add.w	r2, r6, #18
   1056c:	4621      	mov	r1, r4
   1056e:	2310      	movs	r3, #16
   10570:	4628      	mov	r0, r5
   10572:	4d0d      	ldr	r5, [pc, #52]	; (105a8 <ADC_1_init+0x74>)
   10574:	47a8      	blx	r5

	// Disable digital pin circuitry
	gpio_set_pin_direction(PC02, GPIO_DIRECTION_OFF);
   10576:	4621      	mov	r1, r4
   10578:	4b0c      	ldr	r3, [pc, #48]	; (105ac <ADC_1_init+0x78>)
   1057a:	2042      	movs	r0, #66	; 0x42
   1057c:	4798      	blx	r3
   1057e:	490c      	ldr	r1, [pc, #48]	; (105b0 <ADC_1_init+0x7c>)
   10580:	4b0c      	ldr	r3, [pc, #48]	; (105b4 <ADC_1_init+0x80>)
   10582:	2042      	movs	r0, #66	; 0x42

	gpio_set_pin_function(PC02, PINMUX_PC02B_ADC1_AIN4);
}
   10584:	b005      	add	sp, #20
   10586:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
   1058a:	4718      	bx	r3
   1058c:	40000800 	.word	0x40000800
   10590:	43002000 	.word	0x43002000
   10594:	40001c00 	.word	0x40001c00
   10598:	20008d04 	.word	0x20008d04
   1059c:	2001cf58 	.word	0x2001cf58
   105a0:	0000ecb1 	.word	0x0000ecb1
   105a4:	2001cd18 	.word	0x2001cd18
   105a8:	0000ed55 	.word	0x0000ed55
   105ac:	00010425 	.word	0x00010425
   105b0:	00420001 	.word	0x00420001
   105b4:	000103b9 	.word	0x000103b9

000105b8 <CRC_0_init>:
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_DSU;
   105b8:	4a04      	ldr	r2, [pc, #16]	; (105cc <CRC_0_init+0x14>)
 * Enables CRC peripheral, clocks and initializes CRC driver
 */
void CRC_0_init(void)
{
	hri_mclk_set_APBBMASK_DSU_bit(MCLK);
	crc_sync_init(&CRC_0, DSU);
   105ba:	4905      	ldr	r1, [pc, #20]	; (105d0 <CRC_0_init+0x18>)
   105bc:	6993      	ldr	r3, [r2, #24]
   105be:	4805      	ldr	r0, [pc, #20]	; (105d4 <CRC_0_init+0x1c>)
   105c0:	f043 0302 	orr.w	r3, r3, #2
   105c4:	6193      	str	r3, [r2, #24]
   105c6:	4b04      	ldr	r3, [pc, #16]	; (105d8 <CRC_0_init+0x20>)
   105c8:	4718      	bx	r3
   105ca:	bf00      	nop
   105cc:	40000800 	.word	0x40000800
   105d0:	41002000 	.word	0x41002000
   105d4:	2001cd14 	.word	0x2001cd14
   105d8:	0000fc09 	.word	0x0000fc09

000105dc <EVENT_SYSTEM_0_init>:
   105dc:	4b08      	ldr	r3, [pc, #32]	; (10600 <EVENT_SYSTEM_0_init+0x24>)
   105de:	2240      	movs	r2, #64	; 0x40
   105e0:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
   105e4:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
   105e8:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
   105ec:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_EVSYS;
   105f0:	4a04      	ldr	r2, [pc, #16]	; (10604 <EVENT_SYSTEM_0_init+0x28>)
   105f2:	6993      	ldr	r3, [r2, #24]
   105f4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   105f8:	6193      	str	r3, [r2, #24]
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_2, CONF_GCLK_EVSYS_CHANNEL_2_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, EVSYS_GCLK_ID_3, CONF_GCLK_EVSYS_CHANNEL_3_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_EVSYS_bit(MCLK);

	event_system_init();
   105fa:	4b03      	ldr	r3, [pc, #12]	; (10608 <EVENT_SYSTEM_0_init+0x2c>)
   105fc:	4718      	bx	r3
   105fe:	bf00      	nop
   10600:	40001c00 	.word	0x40001c00
   10604:	40000800 	.word	0x40000800
   10608:	00013739 	.word	0x00013739

0001060c <FLASH_0_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_NVMCTRL;
   1060c:	4a02      	ldr	r2, [pc, #8]	; (10618 <FLASH_0_CLOCK_init+0xc>)
   1060e:	6913      	ldr	r3, [r2, #16]
   10610:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   10614:	6113      	str	r3, [r2, #16]

void FLASH_0_CLOCK_init(void)
{

	hri_mclk_set_AHBMASK_NVMCTRL_bit(MCLK);
}
   10616:	4770      	bx	lr
   10618:	40000800 	.word	0x40000800

0001061c <FLASH_0_init>:

void FLASH_0_init(void)
{
   1061c:	b510      	push	{r4, lr}
	FLASH_0_CLOCK_init();
   1061e:	4b04      	ldr	r3, [pc, #16]	; (10630 <FLASH_0_init+0x14>)
   10620:	4798      	blx	r3
	flash_init(&FLASH_0, NVMCTRL);
}
   10622:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	flash_init(&FLASH_0, NVMCTRL);
   10626:	4903      	ldr	r1, [pc, #12]	; (10634 <FLASH_0_init+0x18>)
   10628:	4803      	ldr	r0, [pc, #12]	; (10638 <FLASH_0_init+0x1c>)
   1062a:	4b04      	ldr	r3, [pc, #16]	; (1063c <FLASH_0_init+0x20>)
   1062c:	4718      	bx	r3
   1062e:	bf00      	nop
   10630:	0001060d 	.word	0x0001060d
   10634:	41004000 	.word	0x41004000
   10638:	2001ccf8 	.word	0x2001ccf8
   1063c:	0000f6b1 	.word	0x0000f6b1

00010640 <QSPI_INSTANCE_PORT_init>:

void QSPI_INSTANCE_PORT_init(void)
{
   10640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	// Set pin direction to input
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
   10644:	2101      	movs	r1, #1
   10646:	4e24      	ldr	r6, [pc, #144]	; (106d8 <QSPI_INSTANCE_PORT_init+0x98>)

	gpio_set_pin_pull_mode(PB11,
   10648:	4d24      	ldr	r5, [pc, #144]	; (106dc <QSPI_INSTANCE_PORT_init+0x9c>)
   1064a:	4c25      	ldr	r4, [pc, #148]	; (106e0 <QSPI_INSTANCE_PORT_init+0xa0>)
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   1064c:	4f25      	ldr	r7, [pc, #148]	; (106e4 <QSPI_INSTANCE_PORT_init+0xa4>)
	gpio_set_pin_direction(PB11, GPIO_DIRECTION_IN);
   1064e:	202b      	movs	r0, #43	; 0x2b
   10650:	47b0      	blx	r6
	gpio_set_pin_pull_mode(PB11,
   10652:	2100      	movs	r1, #0
   10654:	202b      	movs	r0, #43	; 0x2b
   10656:	47a8      	blx	r5
   10658:	4923      	ldr	r1, [pc, #140]	; (106e8 <QSPI_INSTANCE_PORT_init+0xa8>)
   1065a:	202b      	movs	r0, #43	; 0x2b
   1065c:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB11, PINMUX_PB11H_QSPI_CS);

	gpio_set_pin_direction(PA08,
   1065e:	2102      	movs	r1, #2
   10660:	2008      	movs	r0, #8
   10662:	47b0      	blx	r6
   10664:	f44f 7380 	mov.w	r3, #256	; 0x100
   10668:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA08,
   1066a:	2100      	movs	r1, #0
   1066c:	2008      	movs	r0, #8
   1066e:	47a8      	blx	r5
   10670:	491e      	ldr	r1, [pc, #120]	; (106ec <QSPI_INSTANCE_PORT_init+0xac>)
   10672:	2008      	movs	r0, #8
   10674:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA08H_QSPI_DATA0);

	gpio_set_pin_direction(PA09,
   10676:	2102      	movs	r1, #2
   10678:	2009      	movs	r0, #9
   1067a:	47b0      	blx	r6
   1067c:	f44f 7300 	mov.w	r3, #512	; 0x200
   10680:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA09,
   10682:	2100      	movs	r1, #0
   10684:	2009      	movs	r0, #9
   10686:	47a8      	blx	r5
   10688:	4919      	ldr	r1, [pc, #100]	; (106f0 <QSPI_INSTANCE_PORT_init+0xb0>)
   1068a:	2009      	movs	r0, #9
   1068c:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA09H_QSPI_DATA1);

	gpio_set_pin_direction(PA10,
   1068e:	2102      	movs	r1, #2
   10690:	200a      	movs	r0, #10
   10692:	47b0      	blx	r6
   10694:	f44f 6380 	mov.w	r3, #1024	; 0x400
   10698:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA10,
   1069a:	2100      	movs	r1, #0
   1069c:	200a      	movs	r0, #10
   1069e:	47a8      	blx	r5
   106a0:	4914      	ldr	r1, [pc, #80]	; (106f4 <QSPI_INSTANCE_PORT_init+0xb4>)
   106a2:	200a      	movs	r0, #10
   106a4:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA10H_QSPI_DATA2);

	gpio_set_pin_direction(PA11,
   106a6:	2102      	movs	r1, #2
   106a8:	200b      	movs	r0, #11
   106aa:	47b0      	blx	r6
   106ac:	f44f 6300 	mov.w	r3, #2048	; 0x800
   106b0:	617b      	str	r3, [r7, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA11,
   106b2:	2100      	movs	r1, #0
   106b4:	200b      	movs	r0, #11
   106b6:	47a8      	blx	r5
   106b8:	490f      	ldr	r1, [pc, #60]	; (106f8 <QSPI_INSTANCE_PORT_init+0xb8>)
   106ba:	200b      	movs	r0, #11
   106bc:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA11H_QSPI_DATA3);

	// Set pin direction to input
	gpio_set_pin_direction(PB10, GPIO_DIRECTION_IN);
   106be:	2101      	movs	r1, #1
   106c0:	202a      	movs	r0, #42	; 0x2a
   106c2:	47b0      	blx	r6

	gpio_set_pin_pull_mode(PB10,
   106c4:	2100      	movs	r1, #0
   106c6:	202a      	movs	r0, #42	; 0x2a
   106c8:	47a8      	blx	r5
   106ca:	4623      	mov	r3, r4
   106cc:	490b      	ldr	r1, [pc, #44]	; (106fc <QSPI_INSTANCE_PORT_init+0xbc>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PB10, PINMUX_PB10H_QSPI_SCK);
}
   106ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   106d2:	202a      	movs	r0, #42	; 0x2a
   106d4:	4718      	bx	r3
   106d6:	bf00      	nop
   106d8:	00010425 	.word	0x00010425
   106dc:	00010475 	.word	0x00010475
   106e0:	000103b9 	.word	0x000103b9
   106e4:	41008000 	.word	0x41008000
   106e8:	002b0007 	.word	0x002b0007
   106ec:	00080007 	.word	0x00080007
   106f0:	00090007 	.word	0x00090007
   106f4:	000a0007 	.word	0x000a0007
   106f8:	000b0007 	.word	0x000b0007
   106fc:	002a0007 	.word	0x002a0007

00010700 <QSPI_INSTANCE_CLOCK_init>:
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI;
   10700:	4b06      	ldr	r3, [pc, #24]	; (1071c <QSPI_INSTANCE_CLOCK_init+0x1c>)
   10702:	691a      	ldr	r2, [r3, #16]
   10704:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   10708:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_QSPI_2X;
   1070a:	691a      	ldr	r2, [r3, #16]
   1070c:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
   10710:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_QSPI;
   10712:	69da      	ldr	r2, [r3, #28]
   10714:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
   10718:	61da      	str	r2, [r3, #28]
void QSPI_INSTANCE_CLOCK_init(void)
{
	hri_mclk_set_AHBMASK_QSPI_bit(MCLK);
	hri_mclk_set_AHBMASK_QSPI_2X_bit(MCLK);
	hri_mclk_set_APBCMASK_QSPI_bit(MCLK);
}
   1071a:	4770      	bx	lr
   1071c:	40000800 	.word	0x40000800

00010720 <QSPI_INSTANCE_init>:

void QSPI_INSTANCE_init(void)
{
   10720:	b510      	push	{r4, lr}
	QSPI_INSTANCE_CLOCK_init();
   10722:	4b05      	ldr	r3, [pc, #20]	; (10738 <QSPI_INSTANCE_init+0x18>)
   10724:	4798      	blx	r3
	qspi_dma_init(&QSPI_INSTANCE, QSPI);
   10726:	4b05      	ldr	r3, [pc, #20]	; (1073c <QSPI_INSTANCE_init+0x1c>)
   10728:	4905      	ldr	r1, [pc, #20]	; (10740 <QSPI_INSTANCE_init+0x20>)
   1072a:	4806      	ldr	r0, [pc, #24]	; (10744 <QSPI_INSTANCE_init+0x24>)
   1072c:	4798      	blx	r3
	QSPI_INSTANCE_PORT_init();
}
   1072e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	QSPI_INSTANCE_PORT_init();
   10732:	4b05      	ldr	r3, [pc, #20]	; (10748 <QSPI_INSTANCE_init+0x28>)
   10734:	4718      	bx	r3
   10736:	bf00      	nop
   10738:	00010701 	.word	0x00010701
   1073c:	00012ea5 	.word	0x00012ea5
   10740:	42003400 	.word	0x42003400
   10744:	2001cfc4 	.word	0x2001cfc4
   10748:	00010641 	.word	0x00010641

0001074c <USART_EAST_CLOCK_init>:
   1074c:	4b06      	ldr	r3, [pc, #24]	; (10768 <USART_EAST_CLOCK_init+0x1c>)
   1074e:	2241      	movs	r2, #65	; 0x41
   10750:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
   10754:	2242      	movs	r2, #66	; 0x42
   10756:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM0;
   1075a:	4a04      	ldr	r2, [pc, #16]	; (1076c <USART_EAST_CLOCK_init+0x20>)
   1075c:	6953      	ldr	r3, [r2, #20]
   1075e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
   10762:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM0_bit(MCLK);
}
   10764:	4770      	bx	lr
   10766:	bf00      	nop
   10768:	40001c00 	.word	0x40001c00
   1076c:	40000800 	.word	0x40000800

00010770 <USART_EAST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_EAST_PORT_init()
{
   10770:	b510      	push	{r4, lr}
   10772:	4c05      	ldr	r4, [pc, #20]	; (10788 <USART_EAST_PORT_init+0x18>)
   10774:	4905      	ldr	r1, [pc, #20]	; (1078c <USART_EAST_PORT_init+0x1c>)
   10776:	2051      	movs	r0, #81	; 0x51
   10778:	47a0      	blx	r4
   1077a:	4623      	mov	r3, r4
   1077c:	4904      	ldr	r1, [pc, #16]	; (10790 <USART_EAST_PORT_init+0x20>)

	gpio_set_pin_function(PC17, PINMUX_PC17D_SERCOM0_PAD0);

	gpio_set_pin_function(PC16, PINMUX_PC16D_SERCOM0_PAD1);
}
   1077e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10782:	2050      	movs	r0, #80	; 0x50
   10784:	4718      	bx	r3
   10786:	bf00      	nop
   10788:	000103b9 	.word	0x000103b9
   1078c:	00510003 	.word	0x00510003
   10790:	00500003 	.word	0x00500003

00010794 <USART_EAST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_EAST_init(void)
{
   10794:	b513      	push	{r0, r1, r4, lr}
	USART_EAST_CLOCK_init();
   10796:	4b07      	ldr	r3, [pc, #28]	; (107b4 <USART_EAST_init+0x20>)
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
   10798:	4c07      	ldr	r4, [pc, #28]	; (107b8 <USART_EAST_init+0x24>)
	USART_EAST_CLOCK_init();
   1079a:	4798      	blx	r3
	usart_async_init(&USART_EAST, SERCOM0, USART_EAST_buffer, USART_EAST_BUFFER_SIZE, (void *)NULL);
   1079c:	2300      	movs	r3, #0
   1079e:	9300      	str	r3, [sp, #0]
   107a0:	4a06      	ldr	r2, [pc, #24]	; (107bc <USART_EAST_init+0x28>)
   107a2:	4907      	ldr	r1, [pc, #28]	; (107c0 <USART_EAST_init+0x2c>)
   107a4:	4807      	ldr	r0, [pc, #28]	; (107c4 <USART_EAST_init+0x30>)
   107a6:	2310      	movs	r3, #16
   107a8:	47a0      	blx	r4
	USART_EAST_PORT_init();
   107aa:	4b07      	ldr	r3, [pc, #28]	; (107c8 <USART_EAST_init+0x34>)
}
   107ac:	b002      	add	sp, #8
   107ae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_EAST_PORT_init();
   107b2:	4718      	bx	r3
   107b4:	0001074d 	.word	0x0001074d
   107b8:	000110a9 	.word	0x000110a9
   107bc:	20008d26 	.word	0x20008d26
   107c0:	40003000 	.word	0x40003000
   107c4:	2001cdb0 	.word	0x2001cdb0
   107c8:	00010771 	.word	0x00010771

000107cc <USART_NORTH_CLOCK_init>:
   107cc:	4b06      	ldr	r3, [pc, #24]	; (107e8 <USART_NORTH_CLOCK_init+0x1c>)
   107ce:	2241      	movs	r2, #65	; 0x41
   107d0:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
   107d4:	2242      	movs	r2, #66	; 0x42
   107d6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_SERCOM1;
   107da:	4a04      	ldr	r2, [pc, #16]	; (107ec <USART_NORTH_CLOCK_init+0x20>)
   107dc:	6953      	ldr	r3, [r2, #20]
   107de:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   107e2:	6153      	str	r3, [r2, #20]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_CORE, CONF_GCLK_SERCOM1_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM1_GCLK_ID_SLOW, CONF_GCLK_SERCOM1_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBAMASK_SERCOM1_bit(MCLK);
}
   107e4:	4770      	bx	lr
   107e6:	bf00      	nop
   107e8:	40001c00 	.word	0x40001c00
   107ec:	40000800 	.word	0x40000800

000107f0 <USART_NORTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_NORTH_PORT_init()
{
   107f0:	b510      	push	{r4, lr}
   107f2:	4c05      	ldr	r4, [pc, #20]	; (10808 <USART_NORTH_PORT_init+0x18>)
   107f4:	4905      	ldr	r1, [pc, #20]	; (1080c <USART_NORTH_PORT_init+0x1c>)
   107f6:	205b      	movs	r0, #91	; 0x5b
   107f8:	47a0      	blx	r4
   107fa:	4623      	mov	r3, r4
   107fc:	4904      	ldr	r1, [pc, #16]	; (10810 <USART_NORTH_PORT_init+0x20>)

	gpio_set_pin_function(PC27, PINMUX_PC27C_SERCOM1_PAD0);

	gpio_set_pin_function(PC28, PINMUX_PC28C_SERCOM1_PAD1);
}
   107fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10802:	205c      	movs	r0, #92	; 0x5c
   10804:	4718      	bx	r3
   10806:	bf00      	nop
   10808:	000103b9 	.word	0x000103b9
   1080c:	005b0002 	.word	0x005b0002
   10810:	005c0002 	.word	0x005c0002

00010814 <USART_NORTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_NORTH_init(void)
{
   10814:	b513      	push	{r0, r1, r4, lr}
	USART_NORTH_CLOCK_init();
   10816:	4b07      	ldr	r3, [pc, #28]	; (10834 <USART_NORTH_init+0x20>)
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
   10818:	4c07      	ldr	r4, [pc, #28]	; (10838 <USART_NORTH_init+0x24>)
	USART_NORTH_CLOCK_init();
   1081a:	4798      	blx	r3
	usart_async_init(&USART_NORTH, SERCOM1, USART_NORTH_buffer, USART_NORTH_BUFFER_SIZE, (void *)NULL);
   1081c:	2300      	movs	r3, #0
   1081e:	9300      	str	r3, [sp, #0]
   10820:	4a06      	ldr	r2, [pc, #24]	; (1083c <USART_NORTH_init+0x28>)
   10822:	4907      	ldr	r1, [pc, #28]	; (10840 <USART_NORTH_init+0x2c>)
   10824:	4807      	ldr	r0, [pc, #28]	; (10844 <USART_NORTH_init+0x30>)
   10826:	2310      	movs	r3, #16
   10828:	47a0      	blx	r4
	USART_NORTH_PORT_init();
   1082a:	4b07      	ldr	r3, [pc, #28]	; (10848 <USART_NORTH_init+0x34>)
}
   1082c:	b002      	add	sp, #8
   1082e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_NORTH_PORT_init();
   10832:	4718      	bx	r3
   10834:	000107cd 	.word	0x000107cd
   10838:	000110a9 	.word	0x000110a9
   1083c:	20008d36 	.word	0x20008d36
   10840:	40003400 	.word	0x40003400
   10844:	2001ce04 	.word	0x2001ce04
   10848:	000107f1 	.word	0x000107f1

0001084c <GRID_AUX_PORT_init>:

void GRID_AUX_PORT_init(void)
{
   1084c:	b510      	push	{r4, lr}
   1084e:	4c05      	ldr	r4, [pc, #20]	; (10864 <GRID_AUX_PORT_init+0x18>)
   10850:	4905      	ldr	r1, [pc, #20]	; (10868 <GRID_AUX_PORT_init+0x1c>)
   10852:	2039      	movs	r0, #57	; 0x39
   10854:	47a0      	blx	r4
   10856:	4623      	mov	r3, r4
   10858:	4904      	ldr	r1, [pc, #16]	; (1086c <GRID_AUX_PORT_init+0x20>)

	gpio_set_pin_function(PB25, PINMUX_PB25D_SERCOM2_PAD0);

	gpio_set_pin_function(PB24, PINMUX_PB24D_SERCOM2_PAD1);
}
   1085a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1085e:	2038      	movs	r0, #56	; 0x38
   10860:	4718      	bx	r3
   10862:	bf00      	nop
   10864:	000103b9 	.word	0x000103b9
   10868:	00390003 	.word	0x00390003
   1086c:	00380003 	.word	0x00380003

00010870 <GRID_AUX_CLOCK_init>:
   10870:	4b06      	ldr	r3, [pc, #24]	; (1088c <GRID_AUX_CLOCK_init+0x1c>)
   10872:	2241      	movs	r2, #65	; 0x41
   10874:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
   10878:	2242      	movs	r2, #66	; 0x42
   1087a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM2;
   1087e:	4a04      	ldr	r2, [pc, #16]	; (10890 <GRID_AUX_CLOCK_init+0x20>)
   10880:	6993      	ldr	r3, [r2, #24]
   10882:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   10886:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_CORE, CONF_GCLK_SERCOM2_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM2_GCLK_ID_SLOW, CONF_GCLK_SERCOM2_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM2_bit(MCLK);
}
   10888:	4770      	bx	lr
   1088a:	bf00      	nop
   1088c:	40001c00 	.word	0x40001c00
   10890:	40000800 	.word	0x40000800

00010894 <GRID_AUX_init>:

void GRID_AUX_init(void)
{
   10894:	b510      	push	{r4, lr}
	GRID_AUX_CLOCK_init();
   10896:	4b05      	ldr	r3, [pc, #20]	; (108ac <GRID_AUX_init+0x18>)
   10898:	4798      	blx	r3
	usart_sync_init(&GRID_AUX, SERCOM2, (void *)NULL);
   1089a:	4b05      	ldr	r3, [pc, #20]	; (108b0 <GRID_AUX_init+0x1c>)
   1089c:	4905      	ldr	r1, [pc, #20]	; (108b4 <GRID_AUX_init+0x20>)
   1089e:	4806      	ldr	r0, [pc, #24]	; (108b8 <GRID_AUX_init+0x24>)
   108a0:	2200      	movs	r2, #0
   108a2:	4798      	blx	r3
	GRID_AUX_PORT_init();
}
   108a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_AUX_PORT_init();
   108a8:	4b04      	ldr	r3, [pc, #16]	; (108bc <GRID_AUX_init+0x28>)
   108aa:	4718      	bx	r3
   108ac:	00010871 	.word	0x00010871
   108b0:	0000f565 	.word	0x0000f565
   108b4:	41012000 	.word	0x41012000
   108b8:	2001cd70 	.word	0x2001cd70
   108bc:	0001084d 	.word	0x0001084d

000108c0 <UI_SPI_PORT_init>:

void UI_SPI_PORT_init(void)
{
   108c0:	b570      	push	{r4, r5, r6, lr}
   108c2:	4e12      	ldr	r6, [pc, #72]	; (1090c <UI_SPI_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB20, GPIO_DIRECTION_OUT);
   108c4:	4d12      	ldr	r5, [pc, #72]	; (10910 <UI_SPI_PORT_init+0x50>)
   108c6:	4c13      	ldr	r4, [pc, #76]	; (10914 <UI_SPI_PORT_init+0x54>)
   108c8:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   108cc:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   108d0:	2102      	movs	r1, #2
   108d2:	2034      	movs	r0, #52	; 0x34
   108d4:	47a8      	blx	r5
   108d6:	4910      	ldr	r1, [pc, #64]	; (10918 <UI_SPI_PORT_init+0x58>)
   108d8:	2034      	movs	r0, #52	; 0x34
   108da:	47a0      	blx	r4
   108dc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
   108e0:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB21, GPIO_DIRECTION_OUT);
   108e4:	2102      	movs	r1, #2
   108e6:	2035      	movs	r0, #53	; 0x35
   108e8:	47a8      	blx	r5
   108ea:	490c      	ldr	r1, [pc, #48]	; (1091c <UI_SPI_PORT_init+0x5c>)
   108ec:	2035      	movs	r0, #53	; 0x35
   108ee:	47a0      	blx	r4

	gpio_set_pin_function(PB21, PINMUX_PB21C_SERCOM3_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA20, GPIO_DIRECTION_IN);
   108f0:	2101      	movs	r1, #1
   108f2:	2014      	movs	r0, #20
   108f4:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA20,
   108f6:	4b0a      	ldr	r3, [pc, #40]	; (10920 <UI_SPI_PORT_init+0x60>)
   108f8:	2100      	movs	r1, #0
   108fa:	2014      	movs	r0, #20
   108fc:	4798      	blx	r3
   108fe:	4623      	mov	r3, r4
   10900:	4908      	ldr	r1, [pc, #32]	; (10924 <UI_SPI_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA20, PINMUX_PA20D_SERCOM3_PAD2);
}
   10902:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10906:	2014      	movs	r0, #20
   10908:	4718      	bx	r3
   1090a:	bf00      	nop
   1090c:	41008000 	.word	0x41008000
   10910:	00010425 	.word	0x00010425
   10914:	000103b9 	.word	0x000103b9
   10918:	00340002 	.word	0x00340002
   1091c:	00350002 	.word	0x00350002
   10920:	00010475 	.word	0x00010475
   10924:	00140003 	.word	0x00140003

00010928 <UI_SPI_CLOCK_init>:
   10928:	4b06      	ldr	r3, [pc, #24]	; (10944 <UI_SPI_CLOCK_init+0x1c>)
   1092a:	2241      	movs	r2, #65	; 0x41
   1092c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
   10930:	2243      	movs	r2, #67	; 0x43
   10932:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_SERCOM3;
   10936:	4a04      	ldr	r2, [pc, #16]	; (10948 <UI_SPI_CLOCK_init+0x20>)
   10938:	6993      	ldr	r3, [r2, #24]
   1093a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   1093e:	6193      	str	r3, [r2, #24]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_CORE, CONF_GCLK_SERCOM3_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM3_GCLK_ID_SLOW, CONF_GCLK_SERCOM3_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBBMASK_SERCOM3_bit(MCLK);
}
   10940:	4770      	bx	lr
   10942:	bf00      	nop
   10944:	40001c00 	.word	0x40001c00
   10948:	40000800 	.word	0x40000800

0001094c <UI_SPI_init>:

void UI_SPI_init(void)
{
   1094c:	b510      	push	{r4, lr}
	UI_SPI_CLOCK_init();
   1094e:	4b05      	ldr	r3, [pc, #20]	; (10964 <UI_SPI_init+0x18>)
   10950:	4798      	blx	r3
	spi_m_async_init(&UI_SPI, SERCOM3);
   10952:	4b05      	ldr	r3, [pc, #20]	; (10968 <UI_SPI_init+0x1c>)
   10954:	4905      	ldr	r1, [pc, #20]	; (1096c <UI_SPI_init+0x20>)
   10956:	4806      	ldr	r0, [pc, #24]	; (10970 <UI_SPI_init+0x24>)
   10958:	4798      	blx	r3
	UI_SPI_PORT_init();
}
   1095a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	UI_SPI_PORT_init();
   1095e:	4b05      	ldr	r3, [pc, #20]	; (10974 <UI_SPI_init+0x28>)
   10960:	4718      	bx	r3
   10962:	bf00      	nop
   10964:	00010929 	.word	0x00010929
   10968:	0000fa19 	.word	0x0000fa19
   1096c:	41014000 	.word	0x41014000
   10970:	2001cc70 	.word	0x2001cc70
   10974:	000108c1 	.word	0x000108c1

00010978 <USART_WEST_CLOCK_init>:
   10978:	4b06      	ldr	r3, [pc, #24]	; (10994 <USART_WEST_CLOCK_init+0x1c>)
   1097a:	2241      	movs	r2, #65	; 0x41
   1097c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
   10980:	2242      	movs	r2, #66	; 0x42
   10982:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM4;
   10986:	4a04      	ldr	r2, [pc, #16]	; (10998 <USART_WEST_CLOCK_init+0x20>)
   10988:	6a13      	ldr	r3, [r2, #32]
   1098a:	f043 0301 	orr.w	r3, r3, #1
   1098e:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_CORE, CONF_GCLK_SERCOM4_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM4_GCLK_ID_SLOW, CONF_GCLK_SERCOM4_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM4_bit(MCLK);
}
   10990:	4770      	bx	lr
   10992:	bf00      	nop
   10994:	40001c00 	.word	0x40001c00
   10998:	40000800 	.word	0x40000800

0001099c <USART_WEST_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_WEST_PORT_init()
{
   1099c:	b510      	push	{r4, lr}
   1099e:	4c05      	ldr	r4, [pc, #20]	; (109b4 <USART_WEST_PORT_init+0x18>)
   109a0:	4905      	ldr	r1, [pc, #20]	; (109b8 <USART_WEST_PORT_init+0x1c>)
   109a2:	2028      	movs	r0, #40	; 0x28
   109a4:	47a0      	blx	r4
   109a6:	4623      	mov	r3, r4
   109a8:	4904      	ldr	r1, [pc, #16]	; (109bc <USART_WEST_PORT_init+0x20>)

	gpio_set_pin_function(PB08, PINMUX_PB08D_SERCOM4_PAD0);

	gpio_set_pin_function(PB09, PINMUX_PB09D_SERCOM4_PAD1);
}
   109aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   109ae:	2029      	movs	r0, #41	; 0x29
   109b0:	4718      	bx	r3
   109b2:	bf00      	nop
   109b4:	000103b9 	.word	0x000103b9
   109b8:	00280003 	.word	0x00280003
   109bc:	00290003 	.word	0x00290003

000109c0 <USART_WEST_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_WEST_init(void)
{
   109c0:	b513      	push	{r0, r1, r4, lr}
	USART_WEST_CLOCK_init();
   109c2:	4b08      	ldr	r3, [pc, #32]	; (109e4 <USART_WEST_init+0x24>)
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   109c4:	4c08      	ldr	r4, [pc, #32]	; (109e8 <USART_WEST_init+0x28>)
	USART_WEST_CLOCK_init();
   109c6:	4798      	blx	r3
	usart_async_init(&USART_WEST, SERCOM4, USART_WEST_buffer, USART_WEST_BUFFER_SIZE, (void *)NULL);
   109c8:	2300      	movs	r3, #0
   109ca:	9300      	str	r3, [sp, #0]
   109cc:	4a07      	ldr	r2, [pc, #28]	; (109ec <USART_WEST_init+0x2c>)
   109ce:	4808      	ldr	r0, [pc, #32]	; (109f0 <USART_WEST_init+0x30>)
   109d0:	2310      	movs	r3, #16
   109d2:	f04f 4186 	mov.w	r1, #1124073472	; 0x43000000
   109d6:	47a0      	blx	r4
	USART_WEST_PORT_init();
   109d8:	4b06      	ldr	r3, [pc, #24]	; (109f4 <USART_WEST_init+0x34>)
}
   109da:	b002      	add	sp, #8
   109dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_WEST_PORT_init();
   109e0:	4718      	bx	r3
   109e2:	bf00      	nop
   109e4:	00010979 	.word	0x00010979
   109e8:	000110a9 	.word	0x000110a9
   109ec:	20008d46 	.word	0x20008d46
   109f0:	2001ceb8 	.word	0x2001ceb8
   109f4:	0001099d 	.word	0x0001099d

000109f8 <SYS_I2C_PORT_init>:

void SYS_I2C_PORT_init(void)
{
   109f8:	b570      	push	{r4, r5, r6, lr}

	gpio_set_pin_pull_mode(PA23,
   109fa:	2100      	movs	r1, #0
   109fc:	4d07      	ldr	r5, [pc, #28]	; (10a1c <SYS_I2C_PORT_init+0x24>)
   109fe:	4c08      	ldr	r4, [pc, #32]	; (10a20 <SYS_I2C_PORT_init+0x28>)
   10a00:	2017      	movs	r0, #23
   10a02:	47a8      	blx	r5
   10a04:	4907      	ldr	r1, [pc, #28]	; (10a24 <SYS_I2C_PORT_init+0x2c>)
   10a06:	2017      	movs	r0, #23
   10a08:	47a0      	blx	r4
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA23, PINMUX_PA23D_SERCOM5_PAD0);

	gpio_set_pin_pull_mode(PA22,
   10a0a:	2100      	movs	r1, #0
   10a0c:	2016      	movs	r0, #22
   10a0e:	47a8      	blx	r5
   10a10:	4623      	mov	r3, r4
   10a12:	4905      	ldr	r1, [pc, #20]	; (10a28 <SYS_I2C_PORT_init+0x30>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA22, PINMUX_PA22D_SERCOM5_PAD1);
}
   10a14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10a18:	2016      	movs	r0, #22
   10a1a:	4718      	bx	r3
   10a1c:	00010475 	.word	0x00010475
   10a20:	000103b9 	.word	0x000103b9
   10a24:	00170003 	.word	0x00170003
   10a28:	00160003 	.word	0x00160003

00010a2c <SYS_I2C_CLOCK_init>:
   10a2c:	4b06      	ldr	r3, [pc, #24]	; (10a48 <SYS_I2C_CLOCK_init+0x1c>)
   10a2e:	2241      	movs	r2, #65	; 0x41
   10a30:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
   10a34:	2242      	movs	r2, #66	; 0x42
   10a36:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM5;
   10a3a:	4a04      	ldr	r2, [pc, #16]	; (10a4c <SYS_I2C_CLOCK_init+0x20>)
   10a3c:	6a13      	ldr	r3, [r2, #32]
   10a3e:	f043 0302 	orr.w	r3, r3, #2
   10a42:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_CORE, CONF_GCLK_SERCOM5_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM5_GCLK_ID_SLOW, CONF_GCLK_SERCOM5_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM5_bit(MCLK);
}
   10a44:	4770      	bx	lr
   10a46:	bf00      	nop
   10a48:	40001c00 	.word	0x40001c00
   10a4c:	40000800 	.word	0x40000800

00010a50 <SYS_I2C_init>:

void SYS_I2C_init(void)
{
   10a50:	b510      	push	{r4, lr}
	SYS_I2C_CLOCK_init();
   10a52:	4b05      	ldr	r3, [pc, #20]	; (10a68 <SYS_I2C_init+0x18>)
   10a54:	4798      	blx	r3
	i2c_m_async_init(&SYS_I2C, SERCOM5);
   10a56:	4b05      	ldr	r3, [pc, #20]	; (10a6c <SYS_I2C_init+0x1c>)
   10a58:	4905      	ldr	r1, [pc, #20]	; (10a70 <SYS_I2C_init+0x20>)
   10a5a:	4806      	ldr	r0, [pc, #24]	; (10a74 <SYS_I2C_init+0x24>)
   10a5c:	4798      	blx	r3
	SYS_I2C_PORT_init();
}
   10a5e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	SYS_I2C_PORT_init();
   10a62:	4b05      	ldr	r3, [pc, #20]	; (10a78 <SYS_I2C_init+0x28>)
   10a64:	4718      	bx	r3
   10a66:	bf00      	nop
   10a68:	00010a2d 	.word	0x00010a2d
   10a6c:	0000bec5 	.word	0x0000bec5
   10a70:	43000400 	.word	0x43000400
   10a74:	2001cd30 	.word	0x2001cd30
   10a78:	000109f9 	.word	0x000109f9

00010a7c <USART_SOUTH_CLOCK_init>:
   10a7c:	4b06      	ldr	r3, [pc, #24]	; (10a98 <USART_SOUTH_CLOCK_init+0x1c>)
   10a7e:	2241      	movs	r2, #65	; 0x41
   10a80:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
   10a84:	2242      	movs	r2, #66	; 0x42
   10a86:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM6;
   10a8a:	4a04      	ldr	r2, [pc, #16]	; (10a9c <USART_SOUTH_CLOCK_init+0x20>)
   10a8c:	6a13      	ldr	r3, [r2, #32]
   10a8e:	f043 0304 	orr.w	r3, r3, #4
   10a92:	6213      	str	r3, [r2, #32]

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_CORE, CONF_GCLK_SERCOM6_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM6_GCLK_ID_SLOW, CONF_GCLK_SERCOM6_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM6_bit(MCLK);
}
   10a94:	4770      	bx	lr
   10a96:	bf00      	nop
   10a98:	40001c00 	.word	0x40001c00
   10a9c:	40000800 	.word	0x40000800

00010aa0 <USART_SOUTH_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_SOUTH_PORT_init()
{
   10aa0:	b510      	push	{r4, lr}
   10aa2:	4c05      	ldr	r4, [pc, #20]	; (10ab8 <USART_SOUTH_PORT_init+0x18>)
   10aa4:	4905      	ldr	r1, [pc, #20]	; (10abc <USART_SOUTH_PORT_init+0x1c>)
   10aa6:	204d      	movs	r0, #77	; 0x4d
   10aa8:	47a0      	blx	r4
   10aaa:	4623      	mov	r3, r4
   10aac:	4904      	ldr	r1, [pc, #16]	; (10ac0 <USART_SOUTH_PORT_init+0x20>)

	gpio_set_pin_function(PC13, PINMUX_PC13D_SERCOM6_PAD0);

	gpio_set_pin_function(PC12, PINMUX_PC12D_SERCOM6_PAD1);
}
   10aae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   10ab2:	204c      	movs	r0, #76	; 0x4c
   10ab4:	4718      	bx	r3
   10ab6:	bf00      	nop
   10ab8:	000103b9 	.word	0x000103b9
   10abc:	004d0003 	.word	0x004d0003
   10ac0:	004c0003 	.word	0x004c0003

00010ac4 <USART_SOUTH_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_SOUTH_init(void)
{
   10ac4:	b513      	push	{r0, r1, r4, lr}
	USART_SOUTH_CLOCK_init();
   10ac6:	4b07      	ldr	r3, [pc, #28]	; (10ae4 <USART_SOUTH_init+0x20>)
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   10ac8:	4c07      	ldr	r4, [pc, #28]	; (10ae8 <USART_SOUTH_init+0x24>)
	USART_SOUTH_CLOCK_init();
   10aca:	4798      	blx	r3
	usart_async_init(&USART_SOUTH, SERCOM6, USART_SOUTH_buffer, USART_SOUTH_BUFFER_SIZE, (void *)NULL);
   10acc:	2300      	movs	r3, #0
   10ace:	9300      	str	r3, [sp, #0]
   10ad0:	4a06      	ldr	r2, [pc, #24]	; (10aec <USART_SOUTH_init+0x28>)
   10ad2:	4907      	ldr	r1, [pc, #28]	; (10af0 <USART_SOUTH_init+0x2c>)
   10ad4:	4807      	ldr	r0, [pc, #28]	; (10af4 <USART_SOUTH_init+0x30>)
   10ad6:	2310      	movs	r3, #16
   10ad8:	47a0      	blx	r4
	USART_SOUTH_PORT_init();
   10ada:	4b07      	ldr	r3, [pc, #28]	; (10af8 <USART_SOUTH_init+0x34>)
}
   10adc:	b002      	add	sp, #8
   10ade:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USART_SOUTH_PORT_init();
   10ae2:	4718      	bx	r3
   10ae4:	00010a7d 	.word	0x00010a7d
   10ae8:	000110a9 	.word	0x000110a9
   10aec:	20008d56 	.word	0x20008d56
   10af0:	43000800 	.word	0x43000800
   10af4:	2001cf08 	.word	0x2001cf08
   10af8:	00010aa1 	.word	0x00010aa1

00010afc <GRID_LED_PORT_init>:

void GRID_LED_PORT_init(void)
{
   10afc:	b570      	push	{r4, r5, r6, lr}
   10afe:	4e12      	ldr	r6, [pc, #72]	; (10b48 <GRID_LED_PORT_init+0x4c>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB30, GPIO_DIRECTION_OUT);
   10b00:	4d12      	ldr	r5, [pc, #72]	; (10b4c <GRID_LED_PORT_init+0x50>)
   10b02:	4c13      	ldr	r4, [pc, #76]	; (10b50 <GRID_LED_PORT_init+0x54>)
   10b04:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
   10b08:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
   10b0c:	2102      	movs	r1, #2
   10b0e:	203e      	movs	r0, #62	; 0x3e
   10b10:	47a8      	blx	r5
   10b12:	4910      	ldr	r1, [pc, #64]	; (10b54 <GRID_LED_PORT_init+0x58>)
   10b14:	203e      	movs	r0, #62	; 0x3e
   10b16:	47a0      	blx	r4
   10b18:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
   10b1c:	f8c6 3094 	str.w	r3, [r6, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(PB31, GPIO_DIRECTION_OUT);
   10b20:	2102      	movs	r1, #2
   10b22:	203f      	movs	r0, #63	; 0x3f
   10b24:	47a8      	blx	r5
   10b26:	490c      	ldr	r1, [pc, #48]	; (10b58 <GRID_LED_PORT_init+0x5c>)
   10b28:	203f      	movs	r0, #63	; 0x3f
   10b2a:	47a0      	blx	r4

	gpio_set_pin_function(PB31, PINMUX_PB31C_SERCOM7_PAD1);

	// Set pin direction to input
	gpio_set_pin_direction(PA30, GPIO_DIRECTION_IN);
   10b2c:	2101      	movs	r1, #1
   10b2e:	201e      	movs	r0, #30
   10b30:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PA30,
   10b32:	4b0a      	ldr	r3, [pc, #40]	; (10b5c <GRID_LED_PORT_init+0x60>)
   10b34:	2100      	movs	r1, #0
   10b36:	201e      	movs	r0, #30
   10b38:	4798      	blx	r3
   10b3a:	4623      	mov	r3, r4
   10b3c:	4908      	ldr	r1, [pc, #32]	; (10b60 <GRID_LED_PORT_init+0x64>)
	                       // <GPIO_PULL_UP"> Pull-up
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_OFF);

	gpio_set_pin_function(PA30, PINMUX_PA30C_SERCOM7_PAD2);
}
   10b3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   10b42:	201e      	movs	r0, #30
   10b44:	4718      	bx	r3
   10b46:	bf00      	nop
   10b48:	41008000 	.word	0x41008000
   10b4c:	00010425 	.word	0x00010425
   10b50:	000103b9 	.word	0x000103b9
   10b54:	003e0002 	.word	0x003e0002
   10b58:	003f0002 	.word	0x003f0002
   10b5c:	00010475 	.word	0x00010475
   10b60:	001e0002 	.word	0x001e0002

00010b64 <GRID_LED_CLOCK_init>:
   10b64:	4b06      	ldr	r3, [pc, #24]	; (10b80 <GRID_LED_CLOCK_init+0x1c>)
   10b66:	2241      	movs	r2, #65	; 0x41
   10b68:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
   10b6c:	2242      	movs	r2, #66	; 0x42
   10b6e:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	((Mclk *)hw)->APBDMASK.reg |= MCLK_APBDMASK_SERCOM7;
   10b72:	4a04      	ldr	r2, [pc, #16]	; (10b84 <GRID_LED_CLOCK_init+0x20>)
   10b74:	6a13      	ldr	r3, [r2, #32]
   10b76:	f043 0308 	orr.w	r3, r3, #8
   10b7a:	6213      	str	r3, [r2, #32]
{
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_CORE, CONF_GCLK_SERCOM7_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM7_GCLK_ID_SLOW, CONF_GCLK_SERCOM7_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));

	hri_mclk_set_APBDMASK_SERCOM7_bit(MCLK);
}
   10b7c:	4770      	bx	lr
   10b7e:	bf00      	nop
   10b80:	40001c00 	.word	0x40001c00
   10b84:	40000800 	.word	0x40000800

00010b88 <GRID_LED_init>:

void GRID_LED_init(void)
{
   10b88:	b510      	push	{r4, lr}
	GRID_LED_CLOCK_init();
   10b8a:	4b05      	ldr	r3, [pc, #20]	; (10ba0 <GRID_LED_init+0x18>)
   10b8c:	4798      	blx	r3
	spi_m_dma_init(&GRID_LED, SERCOM7);
   10b8e:	4b05      	ldr	r3, [pc, #20]	; (10ba4 <GRID_LED_init+0x1c>)
   10b90:	4905      	ldr	r1, [pc, #20]	; (10ba8 <GRID_LED_init+0x20>)
   10b92:	4806      	ldr	r0, [pc, #24]	; (10bac <GRID_LED_init+0x24>)
   10b94:	4798      	blx	r3
	GRID_LED_PORT_init();
}
   10b96:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	GRID_LED_PORT_init();
   10b9a:	4b05      	ldr	r3, [pc, #20]	; (10bb0 <GRID_LED_init+0x28>)
   10b9c:	4718      	bx	r3
   10b9e:	bf00      	nop
   10ba0:	00010b65 	.word	0x00010b65
   10ba4:	0000c2c1 	.word	0x0000c2c1
   10ba8:	43000c00 	.word	0x43000c00
   10bac:	2001ce54 	.word	0x2001ce54
   10bb0:	00010afd 	.word	0x00010afd

00010bb4 <delay_driver_init>:

void delay_driver_init(void)
{
	delay_init(SysTick);
   10bb4:	4801      	ldr	r0, [pc, #4]	; (10bbc <delay_driver_init+0x8>)
   10bb6:	4b02      	ldr	r3, [pc, #8]	; (10bc0 <delay_driver_init+0xc>)
   10bb8:	4718      	bx	r3
   10bba:	bf00      	nop
   10bbc:	e000e010 	.word	0xe000e010
   10bc0:	0000e6f9 	.word	0x0000e6f9

00010bc4 <RAND_0_CLOCK_init>:
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_TRNG;
   10bc4:	4a02      	ldr	r2, [pc, #8]	; (10bd0 <RAND_0_CLOCK_init+0xc>)
   10bc6:	69d3      	ldr	r3, [r2, #28]
   10bc8:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
   10bcc:	61d3      	str	r3, [r2, #28]
}

void RAND_0_CLOCK_init(void)
{
	hri_mclk_set_APBCMASK_TRNG_bit(MCLK);
}
   10bce:	4770      	bx	lr
   10bd0:	40000800 	.word	0x40000800

00010bd4 <RAND_0_init>:

void RAND_0_init(void)
{
   10bd4:	b510      	push	{r4, lr}
	RAND_0_CLOCK_init();
   10bd6:	4b04      	ldr	r3, [pc, #16]	; (10be8 <RAND_0_init+0x14>)
   10bd8:	4798      	blx	r3
	rand_sync_init(&RAND_0, TRNG);
}
   10bda:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	rand_sync_init(&RAND_0, TRNG);
   10bde:	4903      	ldr	r1, [pc, #12]	; (10bec <RAND_0_init+0x18>)
   10be0:	4803      	ldr	r0, [pc, #12]	; (10bf0 <RAND_0_init+0x1c>)
   10be2:	4b04      	ldr	r3, [pc, #16]	; (10bf4 <RAND_0_init+0x20>)
   10be4:	4718      	bx	r3
   10be6:	bf00      	nop
   10be8:	00010bc5 	.word	0x00010bc5
   10bec:	42002800 	.word	0x42002800
   10bf0:	2001cd7c 	.word	0x2001cd7c
   10bf4:	0000f0dd 	.word	0x0000f0dd

00010bf8 <USB_DEVICE_INSTANCE_PORT_init>:

void USB_DEVICE_INSTANCE_PORT_init(void)
{
   10bf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	gpio_set_pin_direction(PA24,
   10bfc:	2102      	movs	r1, #2
   10bfe:	4f0f      	ldr	r7, [pc, #60]	; (10c3c <USB_DEVICE_INSTANCE_PORT_init+0x44>)
   10c00:	4e0f      	ldr	r6, [pc, #60]	; (10c40 <USB_DEVICE_INSTANCE_PORT_init+0x48>)
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA24,
   10c02:	4d10      	ldr	r5, [pc, #64]	; (10c44 <USB_DEVICE_INSTANCE_PORT_init+0x4c>)
   10c04:	4c10      	ldr	r4, [pc, #64]	; (10c48 <USB_DEVICE_INSTANCE_PORT_init+0x50>)
	gpio_set_pin_direction(PA24,
   10c06:	2018      	movs	r0, #24
   10c08:	47b8      	blx	r7
   10c0a:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   10c0e:	6173      	str	r3, [r6, #20]
	gpio_set_pin_pull_mode(PA24,
   10c10:	2100      	movs	r1, #0
   10c12:	2018      	movs	r0, #24
   10c14:	47a8      	blx	r5
   10c16:	490d      	ldr	r1, [pc, #52]	; (10c4c <USB_DEVICE_INSTANCE_PORT_init+0x54>)
   10c18:	2018      	movs	r0, #24
   10c1a:	47a0      	blx	r4
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA24H_USB_DM);

	gpio_set_pin_direction(PA25,
   10c1c:	2102      	movs	r1, #2
   10c1e:	2019      	movs	r0, #25
   10c20:	47b8      	blx	r7
   10c22:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   10c26:	6173      	str	r3, [r6, #20]
	                   // <id> pad_initial_level
	                   // <false"> Low
	                   // <true"> High
	                   false);

	gpio_set_pin_pull_mode(PA25,
   10c28:	2100      	movs	r1, #0
   10c2a:	2019      	movs	r0, #25
   10c2c:	47a8      	blx	r5
   10c2e:	4623      	mov	r3, r4
   10c30:	4907      	ldr	r1, [pc, #28]	; (10c50 <USB_DEVICE_INSTANCE_PORT_init+0x58>)
	                      // <GPIO_PIN_FUNCTION_K"> K
	                      // <GPIO_PIN_FUNCTION_L"> L
	                      // <GPIO_PIN_FUNCTION_M"> M
	                      // <GPIO_PIN_FUNCTION_N"> N
	                      PINMUX_PA25H_USB_DP);
}
   10c32:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   10c36:	2019      	movs	r0, #25
   10c38:	4718      	bx	r3
   10c3a:	bf00      	nop
   10c3c:	00010425 	.word	0x00010425
   10c40:	41008000 	.word	0x41008000
   10c44:	00010475 	.word	0x00010475
   10c48:	000103b9 	.word	0x000103b9
   10c4c:	00180007 	.word	0x00180007
   10c50:	00190007 	.word	0x00190007

00010c54 <USB_DEVICE_INSTANCE_CLOCK_init>:
   10c54:	4b07      	ldr	r3, [pc, #28]	; (10c74 <USB_DEVICE_INSTANCE_CLOCK_init+0x20>)
   10c56:	2241      	movs	r2, #65	; 0x41
   10c58:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
	((Mclk *)hw)->AHBMASK.reg |= MCLK_AHBMASK_USB;
   10c5c:	f5a3 53a0 	sub.w	r3, r3, #5120	; 0x1400
   10c60:	691a      	ldr	r2, [r3, #16]
   10c62:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
   10c66:	611a      	str	r2, [r3, #16]
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_USB;
   10c68:	699a      	ldr	r2, [r3, #24]
   10c6a:	f042 0201 	orr.w	r2, r2, #1
   10c6e:	619a      	str	r2, [r3, #24]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, USB_GCLK_ID, CONF_GCLK_USB_SRC | GCLK_PCHCTRL_CHEN);
	hri_mclk_set_AHBMASK_USB_bit(MCLK);
	hri_mclk_set_APBBMASK_USB_bit(MCLK);
}
   10c70:	4770      	bx	lr
   10c72:	bf00      	nop
   10c74:	40001c00 	.word	0x40001c00

00010c78 <USB_DEVICE_INSTANCE_init>:

void USB_DEVICE_INSTANCE_init(void)
{
   10c78:	b510      	push	{r4, lr}
	USB_DEVICE_INSTANCE_CLOCK_init();
   10c7a:	4b04      	ldr	r3, [pc, #16]	; (10c8c <USB_DEVICE_INSTANCE_init+0x14>)
   10c7c:	4798      	blx	r3
	usb_d_init();
   10c7e:	4b04      	ldr	r3, [pc, #16]	; (10c90 <USB_DEVICE_INSTANCE_init+0x18>)
   10c80:	4798      	blx	r3
	USB_DEVICE_INSTANCE_PORT_init();
}
   10c82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	USB_DEVICE_INSTANCE_PORT_init();
   10c86:	4b03      	ldr	r3, [pc, #12]	; (10c94 <USB_DEVICE_INSTANCE_init+0x1c>)
   10c88:	4718      	bx	r3
   10c8a:	bf00      	nop
   10c8c:	00010c55 	.word	0x00010c55
   10c90:	0000fe0d 	.word	0x0000fe0d
   10c94:	00010bf9 	.word	0x00010bf9

00010c98 <WDT_0_CLOCK_init>:
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_WDT;
   10c98:	4a02      	ldr	r2, [pc, #8]	; (10ca4 <WDT_0_CLOCK_init+0xc>)
   10c9a:	6953      	ldr	r3, [r2, #20]
   10c9c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   10ca0:	6153      	str	r3, [r2, #20]

void WDT_0_CLOCK_init(void)
{
	hri_mclk_set_APBAMASK_WDT_bit(MCLK);
}
   10ca2:	4770      	bx	lr
   10ca4:	40000800 	.word	0x40000800

00010ca8 <WDT_0_init>:

void WDT_0_init(void)
{
   10ca8:	b510      	push	{r4, lr}
	WDT_0_CLOCK_init();
   10caa:	4b07      	ldr	r3, [pc, #28]	; (10cc8 <WDT_0_init+0x20>)
   10cac:	4798      	blx	r3
 * \retval 0 Completed sucessfully.
 * \retval -1 Always on or enabled, don't need init again.
 */
static inline int32_t wdt_init(struct wdt_descriptor *const wdt, const void *hw)
{
	ASSERT(wdt && hw);
   10cae:	4b07      	ldr	r3, [pc, #28]	; (10ccc <WDT_0_init+0x24>)
   10cb0:	4907      	ldr	r1, [pc, #28]	; (10cd0 <WDT_0_init+0x28>)
   10cb2:	2001      	movs	r0, #1
   10cb4:	2248      	movs	r2, #72	; 0x48
   10cb6:	4798      	blx	r3

	wdt->dev.hw = (void *)hw;
   10cb8:	4806      	ldr	r0, [pc, #24]	; (10cd4 <WDT_0_init+0x2c>)
   10cba:	4b07      	ldr	r3, [pc, #28]	; (10cd8 <WDT_0_init+0x30>)
   10cbc:	6003      	str	r3, [r0, #0]
	wdt_init(&WDT_0, WDT);
}
   10cbe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

	return _wdt_init(&wdt->dev);
   10cc2:	4b06      	ldr	r3, [pc, #24]	; (10cdc <WDT_0_init+0x34>)
   10cc4:	4718      	bx	r3
   10cc6:	bf00      	nop
   10cc8:	00010c99 	.word	0x00010c99
   10ccc:	0000e9b9 	.word	0x0000e9b9
   10cd0:	000171db 	.word	0x000171db
   10cd4:	2001ce00 	.word	0x2001ce00
   10cd8:	40002000 	.word	0x40002000
   10cdc:	0000c0ed 	.word	0x0000c0ed

00010ce0 <system_init>:

void system_init(void)
{
   10ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
   10ce4:	4b7c      	ldr	r3, [pc, #496]	; (10ed8 <system_init+0x1f8>)
   10ce6:	4c7d      	ldr	r4, [pc, #500]	; (10edc <system_init+0x1fc>)
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   10ce8:	4d7d      	ldr	r5, [pc, #500]	; (10ee0 <system_init+0x200>)
	// GPIO on PA21

	// Set pin direction to input
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);

	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   10cea:	4e7e      	ldr	r6, [pc, #504]	; (10ee4 <system_init+0x204>)
   10cec:	4798      	blx	r3
   10cee:	2320      	movs	r3, #32
   10cf0:	6163      	str	r3, [r4, #20]
	gpio_set_pin_direction(LED0, GPIO_DIRECTION_OUT);
   10cf2:	2102      	movs	r1, #2
   10cf4:	2005      	movs	r0, #5
   10cf6:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10cf8:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
	tmp &= ~PORT_PINCFG_PMUXEN;
   10cfc:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d00:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
	gpio_set_pin_direction(PIN_UI_SPI_CS0, GPIO_DIRECTION_IN);
   10d04:	2101      	movs	r1, #1
   10d06:	2015      	movs	r0, #21
   10d08:	47a8      	blx	r5
	gpio_set_pin_pull_mode(PIN_UI_SPI_CS0,
   10d0a:	2100      	movs	r1, #0
   10d0c:	2015      	movs	r0, #21
   10d0e:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10d10:	f894 3055 	ldrb.w	r3, [r4, #85]	; 0x55
	tmp &= ~PORT_PINCFG_PMUXEN;
   10d14:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d18:	f884 3055 	strb.w	r3, [r4, #85]	; 0x55
	gpio_set_pin_function(PIN_UI_SPI_CS0, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB07

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_2, GPIO_DIRECTION_IN);
   10d1c:	2101      	movs	r1, #1
   10d1e:	2027      	movs	r0, #39	; 0x27
   10d20:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_2,
   10d22:	2100      	movs	r1, #0
   10d24:	2027      	movs	r0, #39	; 0x27
   10d26:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10d28:	f894 30c7 	ldrb.w	r3, [r4, #199]	; 0xc7
	tmp &= ~PORT_PINCFG_PMUXEN;
   10d2c:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d30:	f884 30c7 	strb.w	r3, [r4, #199]	; 0xc7
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10d34:	f44f 5300 	mov.w	r3, #8192	; 0x2000
   10d38:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_SHIFT, GPIO_DIRECTION_OUT);
   10d3c:	2102      	movs	r1, #2
   10d3e:	202d      	movs	r0, #45	; 0x2d
   10d40:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10d42:	f894 30cd 	ldrb.w	r3, [r4, #205]	; 0xcd
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10d46:	f44f 4780 	mov.w	r7, #16384	; 0x4000
	tmp &= ~PORT_PINCFG_PMUXEN;
   10d4a:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d4e:	f884 30cd 	strb.w	r3, [r4, #205]	; 0xcd
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(HWCFG_CLOCK, GPIO_DIRECTION_OUT);
   10d52:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10d54:	f8c4 7094 	str.w	r7, [r4, #148]	; 0x94
   10d58:	202e      	movs	r0, #46	; 0x2e
   10d5a:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10d5c:	f894 30ce 	ldrb.w	r3, [r4, #206]	; 0xce
	tmp &= ~PORT_PINCFG_PMUXEN;
   10d60:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d64:	f884 30ce 	strb.w	r3, [r4, #206]	; 0xce
	gpio_set_pin_function(HWCFG_CLOCK, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PB15

	// Set pin direction to input
	gpio_set_pin_direction(HWCFG_DATA, GPIO_DIRECTION_IN);
   10d68:	2101      	movs	r1, #1
   10d6a:	202f      	movs	r0, #47	; 0x2f
   10d6c:	47a8      	blx	r5

	gpio_set_pin_pull_mode(HWCFG_DATA,
   10d6e:	2100      	movs	r1, #0
   10d70:	202f      	movs	r0, #47	; 0x2f
   10d72:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10d74:	f894 30cf 	ldrb.w	r3, [r4, #207]	; 0xcf
	tmp &= ~PORT_PINCFG_PMUXEN;
   10d78:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d7c:	f884 30cf 	strb.w	r3, [r4, #207]	; 0xcf
	gpio_set_pin_function(HWCFG_DATA, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC11

	// Set pin direction to input
	gpio_set_pin_direction(MAP_MODE, GPIO_DIRECTION_IN);
   10d80:	2101      	movs	r1, #1
   10d82:	204b      	movs	r0, #75	; 0x4b
   10d84:	47a8      	blx	r5

	gpio_set_pin_pull_mode(MAP_MODE,
   10d86:	2101      	movs	r1, #1
   10d88:	204b      	movs	r0, #75	; 0x4b
   10d8a:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10d8c:	f894 314b 	ldrb.w	r3, [r4, #331]	; 0x14b
	tmp &= ~PORT_PINCFG_PMUXEN;
   10d90:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10d94:	f884 314b 	strb.w	r3, [r4, #331]	; 0x14b
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(UI_PWR_EN, GPIO_DIRECTION_OUT);
   10d98:	2102      	movs	r1, #2
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10d9a:	f8c4 7114 	str.w	r7, [r4, #276]	; 0x114
   10d9e:	204e      	movs	r0, #78	; 0x4e
   10da0:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10da2:	f894 314e 	ldrb.w	r3, [r4, #334]	; 0x14e
	tmp &= ~PORT_PINCFG_PMUXEN;
   10da6:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10daa:	f884 314e 	strb.w	r3, [r4, #334]	; 0x14e
	gpio_set_pin_function(UI_PWR_EN, GPIO_PIN_FUNCTION_OFF);

	// GPIO on PC18

	// Set pin direction to input
	gpio_set_pin_direction(PIN_GRID_SYNC_1, GPIO_DIRECTION_IN);
   10dae:	2101      	movs	r1, #1
   10db0:	2052      	movs	r0, #82	; 0x52
   10db2:	47a8      	blx	r5

	gpio_set_pin_pull_mode(PIN_GRID_SYNC_1,
   10db4:	2100      	movs	r1, #0
   10db6:	2052      	movs	r0, #82	; 0x52
   10db8:	47b0      	blx	r6
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10dba:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   10dbe:	4e4a      	ldr	r6, [pc, #296]	; (10ee8 <system_init+0x208>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10dc0:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10dc4:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10dc8:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   10dcc:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_A, GPIO_DIRECTION_OUT);
   10dd0:	2102      	movs	r1, #2
   10dd2:	2053      	movs	r0, #83	; 0x53
   10dd4:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10dd6:	f894 3153 	ldrb.w	r3, [r4, #339]	; 0x153
	tmp &= ~PORT_PINCFG_PMUXEN;
   10dda:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10dde:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10de2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
   10de6:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_B, GPIO_DIRECTION_OUT);
   10dea:	2102      	movs	r1, #2
   10dec:	2054      	movs	r0, #84	; 0x54
   10dee:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10df0:	f894 3154 	ldrb.w	r3, [r4, #340]	; 0x154
	tmp &= ~PORT_PINCFG_PMUXEN;
   10df4:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10df8:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
	((Port *)hw)->Group[submodule_index].OUTCLR.reg = mask;
   10dfc:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
	                   // <false"> Low
	                   // <true"> High
	                   false);

	// Set pin direction to output
	gpio_set_pin_direction(MUX_C, GPIO_DIRECTION_OUT);
   10e00:	2102      	movs	r1, #2
   10e02:	2055      	movs	r0, #85	; 0x55
   10e04:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
   10e08:	47a8      	blx	r5
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
   10e0a:	f894 3155 	ldrb.w	r3, [r4, #341]	; 0x155
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   10e0e:	4d37      	ldr	r5, [pc, #220]	; (10eec <system_init+0x20c>)
	tmp &= ~PORT_PINCFG_PMUXEN;
   10e10:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
   10e14:	f884 3155 	strb.w	r3, [r4, #341]	; 0x155

	gpio_set_pin_function(MUX_C, GPIO_PIN_FUNCTION_OFF);

	ADC_0_init();
   10e18:	4b35      	ldr	r3, [pc, #212]	; (10ef0 <system_init+0x210>)
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_RTC;
   10e1a:	4c36      	ldr	r4, [pc, #216]	; (10ef4 <system_init+0x214>)
   10e1c:	4798      	blx	r3
	ADC_1_init();
   10e1e:	4b36      	ldr	r3, [pc, #216]	; (10ef8 <system_init+0x218>)
   10e20:	4798      	blx	r3

	CRC_0_init();
   10e22:	4b36      	ldr	r3, [pc, #216]	; (10efc <system_init+0x21c>)
   10e24:	4798      	blx	r3

	EVENT_SYSTEM_0_init();
   10e26:	4b36      	ldr	r3, [pc, #216]	; (10f00 <system_init+0x220>)
   10e28:	4798      	blx	r3

	FLASH_0_init();
   10e2a:	4b36      	ldr	r3, [pc, #216]	; (10f04 <system_init+0x224>)
   10e2c:	4798      	blx	r3

	QSPI_INSTANCE_init();
   10e2e:	4b36      	ldr	r3, [pc, #216]	; (10f08 <system_init+0x228>)
   10e30:	4798      	blx	r3
   10e32:	6963      	ldr	r3, [r4, #20]
   10e34:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   10e38:	6163      	str	r3, [r4, #20]
	timer_init(&RTC_Scheduler, RTC, _rtc_get_timer());
   10e3a:	4b34      	ldr	r3, [pc, #208]	; (10f0c <system_init+0x22c>)
   10e3c:	4798      	blx	r3
   10e3e:	4934      	ldr	r1, [pc, #208]	; (10f10 <system_init+0x230>)
   10e40:	4602      	mov	r2, r0
   10e42:	4834      	ldr	r0, [pc, #208]	; (10f14 <system_init+0x234>)
   10e44:	47a8      	blx	r5

	RTC_Scheduler_init();
	USART_EAST_init();
   10e46:	4b34      	ldr	r3, [pc, #208]	; (10f18 <system_init+0x238>)
   10e48:	4798      	blx	r3
	USART_NORTH_init();
   10e4a:	4b34      	ldr	r3, [pc, #208]	; (10f1c <system_init+0x23c>)
   10e4c:	4798      	blx	r3

	GRID_AUX_init();
   10e4e:	4b34      	ldr	r3, [pc, #208]	; (10f20 <system_init+0x240>)
   10e50:	4798      	blx	r3

	UI_SPI_init();
   10e52:	4b34      	ldr	r3, [pc, #208]	; (10f24 <system_init+0x244>)
   10e54:	4798      	blx	r3
	USART_WEST_init();
   10e56:	4b34      	ldr	r3, [pc, #208]	; (10f28 <system_init+0x248>)
   10e58:	4798      	blx	r3

	SYS_I2C_init();
   10e5a:	4b34      	ldr	r3, [pc, #208]	; (10f2c <system_init+0x24c>)
   10e5c:	4798      	blx	r3
	USART_SOUTH_init();
   10e5e:	4b34      	ldr	r3, [pc, #208]	; (10f30 <system_init+0x250>)
   10e60:	4798      	blx	r3

	GRID_LED_init();
   10e62:	4b34      	ldr	r3, [pc, #208]	; (10f34 <system_init+0x254>)
   10e64:	4798      	blx	r3

	delay_driver_init();
   10e66:	4b34      	ldr	r3, [pc, #208]	; (10f38 <system_init+0x258>)
   10e68:	4798      	blx	r3
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC0;
   10e6a:	6963      	ldr	r3, [r4, #20]
   10e6c:	433b      	orrs	r3, r7
   10e6e:	4f33      	ldr	r7, [pc, #204]	; (10f3c <system_init+0x25c>)
   10e70:	6163      	str	r3, [r4, #20]
   10e72:	f04f 0840 	mov.w	r8, #64	; 0x40
   10e76:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_0, TC0, _tc_get_timer());
   10e7a:	47b0      	blx	r6
   10e7c:	4930      	ldr	r1, [pc, #192]	; (10f40 <system_init+0x260>)
   10e7e:	4602      	mov	r2, r0
   10e80:	4830      	ldr	r0, [pc, #192]	; (10f44 <system_init+0x264>)
   10e82:	47a8      	blx	r5
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_TC1;
   10e84:	6963      	ldr	r3, [r4, #20]
   10e86:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   10e8a:	6163      	str	r3, [r4, #20]
   10e8c:	f8c7 80a4 	str.w	r8, [r7, #164]	; 0xa4
	timer_init(&TIMER_1, TC1, _tc_get_timer());
   10e90:	47b0      	blx	r6
   10e92:	492d      	ldr	r1, [pc, #180]	; (10f48 <system_init+0x268>)
   10e94:	4602      	mov	r2, r0
   10e96:	482d      	ldr	r0, [pc, #180]	; (10f4c <system_init+0x26c>)
   10e98:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC2;
   10e9a:	69a3      	ldr	r3, [r4, #24]
   10e9c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   10ea0:	61a3      	str	r3, [r4, #24]
   10ea2:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_2, TC2, _tc_get_timer());
   10ea6:	47b0      	blx	r6
   10ea8:	4929      	ldr	r1, [pc, #164]	; (10f50 <system_init+0x270>)
   10eaa:	4602      	mov	r2, r0
   10eac:	4829      	ldr	r0, [pc, #164]	; (10f54 <system_init+0x274>)
   10eae:	47a8      	blx	r5
	((Mclk *)hw)->APBBMASK.reg |= MCLK_APBBMASK_TC3;
   10eb0:	69a3      	ldr	r3, [r4, #24]
   10eb2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   10eb6:	61a3      	str	r3, [r4, #24]
   10eb8:	f8c7 80e8 	str.w	r8, [r7, #232]	; 0xe8
	timer_init(&TIMER_3, TC3, _tc_get_timer());
   10ebc:	47b0      	blx	r6
   10ebe:	4926      	ldr	r1, [pc, #152]	; (10f58 <system_init+0x278>)
   10ec0:	4602      	mov	r2, r0
   10ec2:	4826      	ldr	r0, [pc, #152]	; (10f5c <system_init+0x27c>)
   10ec4:	47a8      	blx	r5

	TIMER_0_init();
	TIMER_1_init();
	TIMER_2_init();
	TIMER_3_init();
	RAND_0_init();
   10ec6:	4b26      	ldr	r3, [pc, #152]	; (10f60 <system_init+0x280>)
   10ec8:	4798      	blx	r3

	USB_DEVICE_INSTANCE_init();
   10eca:	4b26      	ldr	r3, [pc, #152]	; (10f64 <system_init+0x284>)
   10ecc:	4798      	blx	r3

	WDT_0_init();
}
   10ece:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	WDT_0_init();
   10ed2:	4b25      	ldr	r3, [pc, #148]	; (10f68 <system_init+0x288>)
   10ed4:	4718      	bx	r3
   10ed6:	bf00      	nop
   10ed8:	0000e72d 	.word	0x0000e72d
   10edc:	41008000 	.word	0x41008000
   10ee0:	00010425 	.word	0x00010425
   10ee4:	00010475 	.word	0x00010475
   10ee8:	00014465 	.word	0x00014465
   10eec:	0000d351 	.word	0x0000d351
   10ef0:	000104b5 	.word	0x000104b5
   10ef4:	40000800 	.word	0x40000800
   10ef8:	00010535 	.word	0x00010535
   10efc:	000105b9 	.word	0x000105b9
   10f00:	000105dd 	.word	0x000105dd
   10f04:	0001061d 	.word	0x0001061d
   10f08:	00010721 	.word	0x00010721
   10f0c:	0001038d 	.word	0x0001038d
   10f10:	40002400 	.word	0x40002400
   10f14:	2001ccb8 	.word	0x2001ccb8
   10f18:	00010795 	.word	0x00010795
   10f1c:	00010815 	.word	0x00010815
   10f20:	00010895 	.word	0x00010895
   10f24:	0001094d 	.word	0x0001094d
   10f28:	000109c1 	.word	0x000109c1
   10f2c:	00010a51 	.word	0x00010a51
   10f30:	00010ac5 	.word	0x00010ac5
   10f34:	00010b89 	.word	0x00010b89
   10f38:	00010bb5 	.word	0x00010bb5
   10f3c:	40001c00 	.word	0x40001c00
   10f40:	40003800 	.word	0x40003800
   10f44:	2001cfa4 	.word	0x2001cfa4
   10f48:	40003c00 	.word	0x40003c00
   10f4c:	2001ce98 	.word	0x2001ce98
   10f50:	4101a000 	.word	0x4101a000
   10f54:	2001ccd8 	.word	0x2001ccd8
   10f58:	4101c000 	.word	0x4101c000
   10f5c:	2001cf84 	.word	0x2001cf84
   10f60:	00010bd5 	.word	0x00010bd5
   10f64:	00010c79 	.word	0x00010c79
   10f68:	00010ca9 	.word	0x00010ca9

00010f6c <usart_transmission_complete>:
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   10f6c:	2300      	movs	r3, #0
   10f6e:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.tx_done) {
   10f70:	69c3      	ldr	r3, [r0, #28]
   10f72:	b10b      	cbz	r3, 10f78 <usart_transmission_complete+0xc>
		descr->usart_cb.tx_done(descr);
   10f74:	3808      	subs	r0, #8
   10f76:	4718      	bx	r3
	}
}
   10f78:	4770      	bx	lr

00010f7a <usart_error>:
 */
static void usart_error(struct _usart_async_device *device)
{
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);

	descr->stat = 0;
   10f7a:	2300      	movs	r3, #0
   10f7c:	6283      	str	r3, [r0, #40]	; 0x28
	if (descr->usart_cb.error) {
   10f7e:	6a43      	ldr	r3, [r0, #36]	; 0x24
   10f80:	b10b      	cbz	r3, 10f86 <usart_error+0xc>
		descr->usart_cb.error(descr);
   10f82:	3808      	subs	r0, #8
   10f84:	4718      	bx	r3
	}
}
   10f86:	4770      	bx	lr

00010f88 <usart_fill_rx_buffer>:
{
   10f88:	b570      	push	{r4, r5, r6, lr}
   10f8a:	4604      	mov	r4, r0
	ringbuffer_put(&descr->rx, data);
   10f8c:	4b05      	ldr	r3, [pc, #20]	; (10fa4 <usart_fill_rx_buffer+0x1c>)
   10f8e:	f1a0 0508 	sub.w	r5, r0, #8
   10f92:	302c      	adds	r0, #44	; 0x2c
   10f94:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
   10f96:	6a23      	ldr	r3, [r4, #32]
   10f98:	b11b      	cbz	r3, 10fa2 <usart_fill_rx_buffer+0x1a>
		descr->usart_cb.rx_done(descr);
   10f9a:	4628      	mov	r0, r5
}
   10f9c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		descr->usart_cb.rx_done(descr);
   10fa0:	4718      	bx	r3
}
   10fa2:	bd70      	pop	{r4, r5, r6, pc}
   10fa4:	0001241d 	.word	0x0001241d

00010fa8 <usart_async_write>:
{
   10fa8:	b570      	push	{r4, r5, r6, lr}
   10faa:	460e      	mov	r6, r1
   10fac:	4615      	mov	r5, r2
	ASSERT(descr && buf && length);
   10fae:	4604      	mov	r4, r0
   10fb0:	b118      	cbz	r0, 10fba <usart_async_write+0x12>
   10fb2:	b1d9      	cbz	r1, 10fec <usart_async_write+0x44>
   10fb4:	1e10      	subs	r0, r2, #0
   10fb6:	bf18      	it	ne
   10fb8:	2001      	movne	r0, #1
   10fba:	4b0f      	ldr	r3, [pc, #60]	; (10ff8 <usart_async_write+0x50>)
   10fbc:	490f      	ldr	r1, [pc, #60]	; (10ffc <usart_async_write+0x54>)
   10fbe:	f240 123b 	movw	r2, #315	; 0x13b
   10fc2:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
   10fc4:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
   10fc8:	f8b4 304c 	ldrh.w	r3, [r4, #76]	; 0x4c
   10fcc:	429a      	cmp	r2, r3
   10fce:	d10f      	bne.n	10ff0 <usart_async_write+0x48>
	descr->tx_por           = 0;
   10fd0:	2300      	movs	r3, #0
   10fd2:	f8a4 3044 	strh.w	r3, [r4, #68]	; 0x44
	descr->stat             = USART_ASYNC_STATUS_BUSY;
   10fd6:	2301      	movs	r3, #1
   10fd8:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
   10fda:	f104 0008 	add.w	r0, r4, #8
   10fde:	4b08      	ldr	r3, [pc, #32]	; (11000 <usart_async_write+0x58>)
	descr->tx_buffer        = (uint8_t *)buf;
   10fe0:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
   10fe2:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
	_usart_async_enable_byte_sent_irq(&descr->device);
   10fe6:	4798      	blx	r3
	return (int32_t)length;
   10fe8:	4628      	mov	r0, r5
}
   10fea:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
   10fec:	4608      	mov	r0, r1
   10fee:	e7e4      	b.n	10fba <usart_async_write+0x12>
		return ERR_NO_RESOURCE;
   10ff0:	f06f 001b 	mvn.w	r0, #27
   10ff4:	e7f9      	b.n	10fea <usart_async_write+0x42>
   10ff6:	bf00      	nop
   10ff8:	0000e9b9 	.word	0x0000e9b9
   10ffc:	000171f4 	.word	0x000171f4
   11000:	00011a03 	.word	0x00011a03

00011004 <usart_process_byte_sent>:
	if (descr->tx_por != descr->tx_buffer_length) {
   11004:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
   11006:	f8b0 2044 	ldrh.w	r2, [r0, #68]	; 0x44
   1100a:	429a      	cmp	r2, r3
{
   1100c:	b510      	push	{r4, lr}
   1100e:	4604      	mov	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
   11010:	d00a      	beq.n	11028 <usart_process_byte_sent+0x24>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
   11012:	6c02      	ldr	r2, [r0, #64]	; 0x40
   11014:	1c59      	adds	r1, r3, #1
   11016:	8781      	strh	r1, [r0, #60]	; 0x3c
   11018:	5cd1      	ldrb	r1, [r2, r3]
   1101a:	4b04      	ldr	r3, [pc, #16]	; (1102c <usart_process_byte_sent+0x28>)
   1101c:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
   1101e:	4b04      	ldr	r3, [pc, #16]	; (11030 <usart_process_byte_sent+0x2c>)
   11020:	4620      	mov	r0, r4
}
   11022:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_usart_async_enable_tx_done_irq(&descr->device);
   11026:	4718      	bx	r3
   11028:	4b02      	ldr	r3, [pc, #8]	; (11034 <usart_process_byte_sent+0x30>)
   1102a:	e7fa      	b.n	11022 <usart_process_byte_sent+0x1e>
   1102c:	000119d7 	.word	0x000119d7
   11030:	00011a03 	.word	0x00011a03
   11034:	00011a0b 	.word	0x00011a0b

00011038 <usart_async_read>:
{
   11038:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   1103c:	460e      	mov	r6, r1
   1103e:	4617      	mov	r7, r2
	ASSERT(descr && buf && length);
   11040:	4604      	mov	r4, r0
   11042:	b118      	cbz	r0, 1104c <usart_async_read+0x14>
   11044:	b1e9      	cbz	r1, 11082 <usart_async_read+0x4a>
   11046:	1e10      	subs	r0, r2, #0
   11048:	bf18      	it	ne
   1104a:	2001      	movne	r0, #1
   1104c:	4910      	ldr	r1, [pc, #64]	; (11090 <usart_async_read+0x58>)
   1104e:	4b11      	ldr	r3, [pc, #68]	; (11094 <usart_async_read+0x5c>)
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   11050:	f8df 9050 	ldr.w	r9, [pc, #80]	; 110a4 <usart_async_read+0x6c>
	ASSERT(descr && buf && length);
   11054:	f44f 72ac 	mov.w	r2, #344	; 0x158
   11058:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   1105a:	3434      	adds	r4, #52	; 0x34
	CRITICAL_SECTION_ENTER()
   1105c:	4b0e      	ldr	r3, [pc, #56]	; (11098 <usart_async_read+0x60>)
   1105e:	a801      	add	r0, sp, #4
   11060:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
   11062:	4b0e      	ldr	r3, [pc, #56]	; (1109c <usart_async_read+0x64>)
   11064:	4620      	mov	r0, r4
   11066:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
   11068:	4b0d      	ldr	r3, [pc, #52]	; (110a0 <usart_async_read+0x68>)
	num = ringbuffer_num(&descr->rx);
   1106a:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
   1106c:	a801      	add	r0, sp, #4
   1106e:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
   11070:	2500      	movs	r5, #0
   11072:	45a8      	cmp	r8, r5
   11074:	d001      	beq.n	1107a <usart_async_read+0x42>
   11076:	42bd      	cmp	r5, r7
   11078:	d105      	bne.n	11086 <usart_async_read+0x4e>
}
   1107a:	4628      	mov	r0, r5
   1107c:	b003      	add	sp, #12
   1107e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	ASSERT(descr && buf && length);
   11082:	4608      	mov	r0, r1
   11084:	e7e2      	b.n	1104c <usart_async_read+0x14>
		ringbuffer_get(&descr->rx, &buf[was_read++]);
   11086:	1971      	adds	r1, r6, r5
   11088:	4620      	mov	r0, r4
   1108a:	47c8      	blx	r9
   1108c:	3501      	adds	r5, #1
   1108e:	e7f0      	b.n	11072 <usart_async_read+0x3a>
   11090:	000171f4 	.word	0x000171f4
   11094:	0000e9b9 	.word	0x0000e9b9
   11098:	00012485 	.word	0x00012485
   1109c:	00012461 	.word	0x00012461
   110a0:	00012493 	.word	0x00012493
   110a4:	000123dd 	.word	0x000123dd

000110a8 <usart_async_init>:
{
   110a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   110aa:	460d      	mov	r5, r1
   110ac:	4616      	mov	r6, r2
   110ae:	461f      	mov	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   110b0:	4604      	mov	r4, r0
   110b2:	b120      	cbz	r0, 110be <usart_async_init+0x16>
   110b4:	b309      	cbz	r1, 110fa <usart_async_init+0x52>
   110b6:	b312      	cbz	r2, 110fe <usart_async_init+0x56>
   110b8:	1e18      	subs	r0, r3, #0
   110ba:	bf18      	it	ne
   110bc:	2001      	movne	r0, #1
   110be:	4912      	ldr	r1, [pc, #72]	; (11108 <usart_async_init+0x60>)
   110c0:	4b12      	ldr	r3, [pc, #72]	; (1110c <usart_async_init+0x64>)
   110c2:	223a      	movs	r2, #58	; 0x3a
   110c4:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
   110c6:	4b12      	ldr	r3, [pc, #72]	; (11110 <usart_async_init+0x68>)
   110c8:	463a      	mov	r2, r7
   110ca:	4631      	mov	r1, r6
   110cc:	f104 0034 	add.w	r0, r4, #52	; 0x34
   110d0:	4798      	blx	r3
   110d2:	b9b0      	cbnz	r0, 11102 <usart_async_init+0x5a>
	init_status = _usart_async_init(&descr->device, hw);
   110d4:	4b0f      	ldr	r3, [pc, #60]	; (11114 <usart_async_init+0x6c>)
   110d6:	4629      	mov	r1, r5
   110d8:	f104 0008 	add.w	r0, r4, #8
   110dc:	4798      	blx	r3
	if (init_status) {
   110de:	b958      	cbnz	r0, 110f8 <usart_async_init+0x50>
	descr->io.read  = usart_async_read;
   110e0:	4b0d      	ldr	r3, [pc, #52]	; (11118 <usart_async_init+0x70>)
   110e2:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
   110e4:	4b0d      	ldr	r3, [pc, #52]	; (1111c <usart_async_init+0x74>)
   110e6:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
   110e8:	4b0d      	ldr	r3, [pc, #52]	; (11120 <usart_async_init+0x78>)
   110ea:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
   110ec:	4b0d      	ldr	r3, [pc, #52]	; (11124 <usart_async_init+0x7c>)
   110ee:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
   110f0:	4b0d      	ldr	r3, [pc, #52]	; (11128 <usart_async_init+0x80>)
   110f2:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
   110f4:	4b0d      	ldr	r3, [pc, #52]	; (1112c <usart_async_init+0x84>)
   110f6:	6163      	str	r3, [r4, #20]
}
   110f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
   110fa:	4608      	mov	r0, r1
   110fc:	e7df      	b.n	110be <usart_async_init+0x16>
   110fe:	4610      	mov	r0, r2
   11100:	e7dd      	b.n	110be <usart_async_init+0x16>
		return ERR_INVALID_ARG;
   11102:	f06f 000c 	mvn.w	r0, #12
   11106:	e7f7      	b.n	110f8 <usart_async_init+0x50>
   11108:	000171f4 	.word	0x000171f4
   1110c:	0000e9b9 	.word	0x0000e9b9
   11110:	000123a1 	.word	0x000123a1
   11114:	00011919 	.word	0x00011919
   11118:	00011039 	.word	0x00011039
   1111c:	00010fa9 	.word	0x00010fa9
   11120:	00011005 	.word	0x00011005
   11124:	00010f89 	.word	0x00010f89
   11128:	00010f6d 	.word	0x00010f6d
   1112c:	00010f7b 	.word	0x00010f7b

00011130 <usart_async_enable>:
{
   11130:	b510      	push	{r4, lr}
	ASSERT(descr);
   11132:	4604      	mov	r4, r0
   11134:	3800      	subs	r0, #0
   11136:	bf18      	it	ne
   11138:	2001      	movne	r0, #1
   1113a:	4905      	ldr	r1, [pc, #20]	; (11150 <usart_async_enable+0x20>)
   1113c:	4b05      	ldr	r3, [pc, #20]	; (11154 <usart_async_enable+0x24>)
   1113e:	2261      	movs	r2, #97	; 0x61
   11140:	4798      	blx	r3
	_usart_async_enable(&descr->device);
   11142:	f104 0008 	add.w	r0, r4, #8
   11146:	4b04      	ldr	r3, [pc, #16]	; (11158 <usart_async_enable+0x28>)
   11148:	4798      	blx	r3
}
   1114a:	2000      	movs	r0, #0
   1114c:	bd10      	pop	{r4, pc}
   1114e:	bf00      	nop
   11150:	000171f4 	.word	0x000171f4
   11154:	0000e9b9 	.word	0x0000e9b9
   11158:	000119a5 	.word	0x000119a5

0001115c <usart_async_disable>:
{
   1115c:	b510      	push	{r4, lr}
	ASSERT(descr);
   1115e:	4604      	mov	r4, r0
   11160:	3800      	subs	r0, #0
   11162:	bf18      	it	ne
   11164:	2001      	movne	r0, #1
   11166:	4905      	ldr	r1, [pc, #20]	; (1117c <usart_async_disable+0x20>)
   11168:	4b05      	ldr	r3, [pc, #20]	; (11180 <usart_async_disable+0x24>)
   1116a:	226c      	movs	r2, #108	; 0x6c
   1116c:	4798      	blx	r3
	_usart_async_disable(&descr->device);
   1116e:	f104 0008 	add.w	r0, r4, #8
   11172:	4b04      	ldr	r3, [pc, #16]	; (11184 <usart_async_disable+0x28>)
   11174:	4798      	blx	r3
}
   11176:	2000      	movs	r0, #0
   11178:	bd10      	pop	{r4, pc}
   1117a:	bf00      	nop
   1117c:	000171f4 	.word	0x000171f4
   11180:	0000e9b9 	.word	0x0000e9b9
   11184:	000119b9 	.word	0x000119b9

00011188 <usart_async_get_io_descriptor>:
{
   11188:	b538      	push	{r3, r4, r5, lr}
   1118a:	460d      	mov	r5, r1
	ASSERT(descr && io);
   1118c:	4604      	mov	r4, r0
   1118e:	b110      	cbz	r0, 11196 <usart_async_get_io_descriptor+0xe>
   11190:	1e08      	subs	r0, r1, #0
   11192:	bf18      	it	ne
   11194:	2001      	movne	r0, #1
   11196:	4903      	ldr	r1, [pc, #12]	; (111a4 <usart_async_get_io_descriptor+0x1c>)
   11198:	4b03      	ldr	r3, [pc, #12]	; (111a8 <usart_async_get_io_descriptor+0x20>)
   1119a:	2277      	movs	r2, #119	; 0x77
   1119c:	4798      	blx	r3
	*io = &descr->io;
   1119e:	602c      	str	r4, [r5, #0]
}
   111a0:	2000      	movs	r0, #0
   111a2:	bd38      	pop	{r3, r4, r5, pc}
   111a4:	000171f4 	.word	0x000171f4
   111a8:	0000e9b9 	.word	0x0000e9b9

000111ac <usart_async_register_callback>:
{
   111ac:	b570      	push	{r4, r5, r6, lr}
	ASSERT(descr);
   111ae:	4605      	mov	r5, r0
   111b0:	3800      	subs	r0, #0
{
   111b2:	460c      	mov	r4, r1
	ASSERT(descr);
   111b4:	bf18      	it	ne
   111b6:	2001      	movne	r0, #1
   111b8:	4911      	ldr	r1, [pc, #68]	; (11200 <usart_async_register_callback+0x54>)
   111ba:	4b12      	ldr	r3, [pc, #72]	; (11204 <usart_async_register_callback+0x58>)
{
   111bc:	4616      	mov	r6, r2
	ASSERT(descr);
   111be:	2283      	movs	r2, #131	; 0x83
   111c0:	4798      	blx	r3
	switch (type) {
   111c2:	2c01      	cmp	r4, #1
   111c4:	d00d      	beq.n	111e2 <usart_async_register_callback+0x36>
   111c6:	2c02      	cmp	r4, #2
   111c8:	d011      	beq.n	111ee <usart_async_register_callback+0x42>
   111ca:	b9b4      	cbnz	r4, 111fa <usart_async_register_callback+0x4e>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   111cc:	1e32      	subs	r2, r6, #0
		descr->usart_cb.rx_done = cb;
   111ce:	62ae      	str	r6, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
   111d0:	bf18      	it	ne
   111d2:	2201      	movne	r2, #1
   111d4:	2101      	movs	r1, #1
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   111d6:	f105 0008 	add.w	r0, r5, #8
   111da:	4b0b      	ldr	r3, [pc, #44]	; (11208 <usart_async_register_callback+0x5c>)
   111dc:	4798      	blx	r3
	return ERR_NONE;
   111de:	2000      	movs	r0, #0
}
   111e0:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   111e2:	1e32      	subs	r2, r6, #0
		descr->usart_cb.tx_done = cb;
   111e4:	626e      	str	r6, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
   111e6:	bf18      	it	ne
   111e8:	2201      	movne	r2, #1
   111ea:	2102      	movs	r1, #2
   111ec:	e7f3      	b.n	111d6 <usart_async_register_callback+0x2a>
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   111ee:	1e32      	subs	r2, r6, #0
		descr->usart_cb.error = cb;
   111f0:	62ee      	str	r6, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
   111f2:	bf18      	it	ne
   111f4:	2201      	movne	r2, #1
   111f6:	2103      	movs	r1, #3
   111f8:	e7ed      	b.n	111d6 <usart_async_register_callback+0x2a>
	switch (type) {
   111fa:	f06f 000c 	mvn.w	r0, #12
   111fe:	e7ef      	b.n	111e0 <usart_async_register_callback+0x34>
   11200:	000171f4 	.word	0x000171f4
   11204:	0000e9b9 	.word	0x0000e9b9
   11208:	00011a15 	.word	0x00011a15

0001120c <usart_async_set_parity>:
{
   1120c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(descr);
   1120e:	4604      	mov	r4, r0
   11210:	3800      	subs	r0, #0
   11212:	bf18      	it	ne
   11214:	2001      	movne	r0, #1
{
   11216:	460d      	mov	r5, r1
	ASSERT(descr);
   11218:	22cb      	movs	r2, #203	; 0xcb
   1121a:	4905      	ldr	r1, [pc, #20]	; (11230 <usart_async_set_parity+0x24>)
   1121c:	4b05      	ldr	r3, [pc, #20]	; (11234 <usart_async_set_parity+0x28>)
   1121e:	4798      	blx	r3
	_usart_async_set_parity(&descr->device, parity);
   11220:	f104 0008 	add.w	r0, r4, #8
   11224:	4b04      	ldr	r3, [pc, #16]	; (11238 <usart_async_set_parity+0x2c>)
   11226:	4629      	mov	r1, r5
   11228:	4798      	blx	r3
}
   1122a:	2000      	movs	r0, #0
   1122c:	bd38      	pop	{r3, r4, r5, pc}
   1122e:	bf00      	nop
   11230:	000171f4 	.word	0x000171f4
   11234:	0000e9b9 	.word	0x0000e9b9
   11238:	000119c5 	.word	0x000119c5

0001123c <hri_sercomi2cm_wait_for_sync>:
typedef uint8_t  hri_sercomusart_rxerrcnt_reg_t;
typedef uint8_t  hri_sercomusart_rxpl_reg_t;

static inline void hri_sercomi2cm_wait_for_sync(const void *const hw, hri_sercomi2cm_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg) {
   1123c:	69c3      	ldr	r3, [r0, #28]
   1123e:	420b      	tst	r3, r1
   11240:	d1fc      	bne.n	1123c <hri_sercomi2cm_wait_for_sync>
	};
}
   11242:	4770      	bx	lr

00011244 <hri_sercomspi_wait_for_sync>:
	return ((Sercom *)hw)->I2CS.SYNCBUSY.reg & reg;
}

static inline void hri_sercomspi_wait_for_sync(const void *const hw, hri_sercomspi_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->SPI.SYNCBUSY.reg & reg) {
   11244:	69c3      	ldr	r3, [r0, #28]
   11246:	420b      	tst	r3, r1
   11248:	d1fc      	bne.n	11244 <hri_sercomspi_wait_for_sync>
	};
}
   1124a:	4770      	bx	lr

0001124c <hri_sercomusart_wait_for_sync>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
}

static inline void hri_sercomusart_wait_for_sync(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
   1124c:	69c3      	ldr	r3, [r0, #28]
   1124e:	420b      	tst	r3, r1
   11250:	d1fc      	bne.n	1124c <hri_sercomusart_wait_for_sync>
	};
}
   11252:	4770      	bx	lr

00011254 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomi2cm_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   11254:	6802      	ldr	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   11256:	4b03      	ldr	r3, [pc, #12]	; (11264 <hri_sercomi2cm_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->I2CM.CTRLA.reg &= ~SERCOM_I2CM_CTRLA_ENABLE;
   11258:	f022 0202 	bic.w	r2, r2, #2
   1125c:	6002      	str	r2, [r0, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   1125e:	2103      	movs	r1, #3
   11260:	4718      	bx	r3
   11262:	bf00      	nop
   11264:	0001123d 	.word	0x0001123d

00011268 <hri_sercomspi_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomspi_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   11268:	6802      	ldr	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1126a:	4b03      	ldr	r3, [pc, #12]	; (11278 <hri_sercomspi_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->SPI.CTRLA.reg &= ~SERCOM_SPI_CTRLA_ENABLE;
   1126c:	f022 0202 	bic.w	r2, r2, #2
   11270:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11272:	2103      	movs	r1, #3
   11274:	4718      	bx	r3
   11276:	bf00      	nop
   11278:	00011245 	.word	0x00011245

0001127c <hri_sercomusart_get_CTRLA_ENABLE_bit>:
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline bool hri_sercomusart_get_CTRLA_ENABLE_bit(const void *const hw)
{
   1127c:	b508      	push	{r3, lr}
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1127e:	2103      	movs	r1, #3
   11280:	4b02      	ldr	r3, [pc, #8]	; (1128c <hri_sercomusart_get_CTRLA_ENABLE_bit+0x10>)
   11282:	4798      	blx	r3
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   11284:	6800      	ldr	r0, [r0, #0]
	tmp = (tmp & SERCOM_USART_CTRLA_ENABLE) >> SERCOM_USART_CTRLA_ENABLE_Pos;
	return (bool)tmp;
}
   11286:	f3c0 0040 	ubfx	r0, r0, #1, #1
   1128a:	bd08      	pop	{r3, pc}
   1128c:	0001124d 	.word	0x0001124d

00011290 <hri_sercomusart_write_CTRLA_ENABLE_bit>:

static inline void hri_sercomusart_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
	uint32_t tmp;
	SERCOM_CRITICAL_SECTION_ENTER();
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   11290:	6803      	ldr	r3, [r0, #0]
	tmp &= ~SERCOM_USART_CTRLA_ENABLE;
   11292:	f023 0302 	bic.w	r3, r3, #2
	tmp |= value << SERCOM_USART_CTRLA_ENABLE_Pos;
   11296:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
	((Sercom *)hw)->USART.CTRLA.reg = tmp;
   1129a:	6001      	str	r1, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1129c:	4b01      	ldr	r3, [pc, #4]	; (112a4 <hri_sercomusart_write_CTRLA_ENABLE_bit+0x14>)
   1129e:	2103      	movs	r1, #3
   112a0:	4718      	bx	r3
   112a2:	bf00      	nop
   112a4:	0001124d 	.word	0x0001124d

000112a8 <hri_sercomusart_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_sercomusart_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   112a8:	6802      	ldr	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   112aa:	4b03      	ldr	r3, [pc, #12]	; (112b8 <hri_sercomusart_clear_CTRLA_ENABLE_bit+0x10>)
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
   112ac:	f022 0202 	bic.w	r2, r2, #2
   112b0:	6002      	str	r2, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   112b2:	2103      	movs	r1, #3
   112b4:	4718      	bx	r3
   112b6:	bf00      	nop
   112b8:	0001124d 	.word	0x0001124d

000112bc <_sercom_get_hardware_index>:

/**
 * \brief Retrieve ordinal number of the given sercom hardware instance
 */
static uint8_t _sercom_get_hardware_index(const void *const hw)
{
   112bc:	b570      	push	{r4, r5, r6, lr}
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   112be:	4d0c      	ldr	r5, [pc, #48]	; (112f0 <_sercom_get_hardware_index+0x34>)
{
   112c0:	4606      	mov	r6, r0
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   112c2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   112c4:	b088      	sub	sp, #32
	Sercom *const sercom_modules[] = SERCOM_INSTS;
   112c6:	466c      	mov	r4, sp
   112c8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   112ca:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   112ce:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	/* Find index for SERCOM instance. */
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   112d2:	466a      	mov	r2, sp
   112d4:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)sercom_modules[i]) {
   112d6:	f852 1b04 	ldr.w	r1, [r2], #4
   112da:	42b1      	cmp	r1, r6
   112dc:	d102      	bne.n	112e4 <_sercom_get_hardware_index+0x28>
			return i;
   112de:	b2d8      	uxtb	r0, r3
		}
	}
	return 0;
}
   112e0:	b008      	add	sp, #32
   112e2:	bd70      	pop	{r4, r5, r6, pc}
	for (uint32_t i = 0; i < SERCOM_INST_NUM; i++) {
   112e4:	3301      	adds	r3, #1
   112e6:	2b08      	cmp	r3, #8
   112e8:	d1f5      	bne.n	112d6 <_sercom_get_hardware_index+0x1a>
	return 0;
   112ea:	2000      	movs	r0, #0
   112ec:	e7f8      	b.n	112e0 <_sercom_get_hardware_index+0x24>
   112ee:	bf00      	nop
   112f0:	0001722c 	.word	0x0001722c

000112f4 <_sercom_usart_interrupt_handler>:
 * \internal Sercom interrupt handler
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _sercom_usart_interrupt_handler(struct _usart_async_device *device)
{
   112f4:	b510      	push	{r4, lr}
	void *hw = device->hw;
   112f6:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   112f8:	7e22      	ldrb	r2, [r4, #24]

	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   112fa:	07d1      	lsls	r1, r2, #31
{
   112fc:	4603      	mov	r3, r0
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
   112fe:	d508      	bpl.n	11312 <_sercom_usart_interrupt_handler+0x1e>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
   11300:	7da2      	ldrb	r2, [r4, #22]
   11302:	07d2      	lsls	r2, r2, #31
   11304:	d505      	bpl.n	11312 <_sercom_usart_interrupt_handler+0x1e>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   11306:	2201      	movs	r2, #1
   11308:	7522      	strb	r2, [r4, #20]
		hri_sercomusart_clear_INTEN_DRE_bit(hw);
		device->usart_cb.tx_byte_sent(device);
   1130a:	6803      	ldr	r3, [r0, #0]
		hri_sercomusart_clear_interrupt_ERROR_bit(hw);
		device->usart_cb.error_cb(device);
		status = hri_sercomusart_read_STATUS_reg(hw);
		hri_sercomusart_clear_STATUS_reg(hw, status);
	}
}
   1130c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_byte_sent(device);
   11310:	4718      	bx	r3
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   11312:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
   11314:	0790      	lsls	r0, r2, #30
   11316:	d509      	bpl.n	1132c <_sercom_usart_interrupt_handler+0x38>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
   11318:	7da2      	ldrb	r2, [r4, #22]
   1131a:	0791      	lsls	r1, r2, #30
   1131c:	d506      	bpl.n	1132c <_sercom_usart_interrupt_handler+0x38>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
   1131e:	2202      	movs	r2, #2
   11320:	7522      	strb	r2, [r4, #20]
		device->usart_cb.tx_done_cb(device);
   11322:	4618      	mov	r0, r3
}
   11324:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.tx_done_cb(device);
   11328:	689a      	ldr	r2, [r3, #8]
   1132a:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   1132c:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
   1132e:	0752      	lsls	r2, r2, #29
   11330:	d50d      	bpl.n	1134e <_sercom_usart_interrupt_handler+0x5a>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
   11332:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
   11334:	f002 0237 	and.w	r2, r2, #55	; 0x37
   11338:	b112      	cbz	r2, 11340 <_sercom_usart_interrupt_handler+0x4c>
	((Sercom *)hw)->USART.STATUS.reg = mask;
   1133a:	23ff      	movs	r3, #255	; 0xff
   1133c:	8363      	strh	r3, [r4, #26]
}
   1133e:	bd10      	pop	{r4, pc}
	return ((Sercom *)hw)->USART.DATA.reg;
   11340:	6aa1      	ldr	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   11342:	685a      	ldr	r2, [r3, #4]
}
   11344:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
   11348:	b2c9      	uxtb	r1, r1
   1134a:	4618      	mov	r0, r3
   1134c:	4710      	bx	r2
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
   1134e:	7e22      	ldrb	r2, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
   11350:	09d2      	lsrs	r2, r2, #7
   11352:	d0f4      	beq.n	1133e <_sercom_usart_interrupt_handler+0x4a>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
   11354:	2280      	movs	r2, #128	; 0x80
   11356:	7622      	strb	r2, [r4, #24]
		device->usart_cb.error_cb(device);
   11358:	4618      	mov	r0, r3
   1135a:	68da      	ldr	r2, [r3, #12]
   1135c:	4790      	blx	r2
	return ((Sercom *)hw)->USART.STATUS.reg;
   1135e:	8b63      	ldrh	r3, [r4, #26]
   11360:	b29b      	uxth	r3, r3
   11362:	e7eb      	b.n	1133c <_sercom_usart_interrupt_handler+0x48>

00011364 <_sercom_init_irq_param>:
 * \brief Init irq param with the given sercom hardware instance
 */
static void _sercom_init_irq_param(const void *const hw, void *dev)
{

	if (hw == SERCOM0) {
   11364:	4b11      	ldr	r3, [pc, #68]	; (113ac <_sercom_init_irq_param+0x48>)
   11366:	4298      	cmp	r0, r3
   11368:	d105      	bne.n	11376 <_sercom_init_irq_param+0x12>
		_sercom0_dev = (struct _usart_async_device *)dev;
   1136a:	4b11      	ldr	r3, [pc, #68]	; (113b0 <_sercom_init_irq_param+0x4c>)
   1136c:	6019      	str	r1, [r3, #0]

	if (hw == SERCOM5) {
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
	}

	if (hw == SERCOM6) {
   1136e:	4b11      	ldr	r3, [pc, #68]	; (113b4 <_sercom_init_irq_param+0x50>)
   11370:	4298      	cmp	r0, r3
   11372:	d018      	beq.n	113a6 <_sercom_init_irq_param+0x42>
   11374:	4770      	bx	lr
	if (hw == SERCOM1) {
   11376:	4b10      	ldr	r3, [pc, #64]	; (113b8 <_sercom_init_irq_param+0x54>)
   11378:	4298      	cmp	r0, r3
   1137a:	d00b      	beq.n	11394 <_sercom_init_irq_param+0x30>
	if (hw == SERCOM3) {
   1137c:	4b0f      	ldr	r3, [pc, #60]	; (113bc <_sercom_init_irq_param+0x58>)
   1137e:	4298      	cmp	r0, r3
   11380:	d00b      	beq.n	1139a <_sercom_init_irq_param+0x36>
	if (hw == SERCOM4) {
   11382:	f1b0 4f86 	cmp.w	r0, #1124073472	; 0x43000000
   11386:	d00b      	beq.n	113a0 <_sercom_init_irq_param+0x3c>
	if (hw == SERCOM5) {
   11388:	4b0d      	ldr	r3, [pc, #52]	; (113c0 <_sercom_init_irq_param+0x5c>)
   1138a:	4298      	cmp	r0, r3
   1138c:	d1ef      	bne.n	1136e <_sercom_init_irq_param+0xa>
		_sercom5_dev = (struct _i2c_m_async_device *)dev;
   1138e:	4b08      	ldr	r3, [pc, #32]	; (113b0 <_sercom_init_irq_param+0x4c>)
   11390:	6119      	str	r1, [r3, #16]
	if (hw == SERCOM6) {
   11392:	4770      	bx	lr
		_sercom1_dev = (struct _usart_async_device *)dev;
   11394:	4b06      	ldr	r3, [pc, #24]	; (113b0 <_sercom_init_irq_param+0x4c>)
   11396:	6059      	str	r1, [r3, #4]
	if (hw == SERCOM5) {
   11398:	e7e9      	b.n	1136e <_sercom_init_irq_param+0xa>
		_sercom3_dev = (struct _spi_async_dev *)dev;
   1139a:	4b05      	ldr	r3, [pc, #20]	; (113b0 <_sercom_init_irq_param+0x4c>)
   1139c:	6099      	str	r1, [r3, #8]
	if (hw == SERCOM6) {
   1139e:	4770      	bx	lr
		_sercom4_dev = (struct _usart_async_device *)dev;
   113a0:	4b03      	ldr	r3, [pc, #12]	; (113b0 <_sercom_init_irq_param+0x4c>)
   113a2:	60d9      	str	r1, [r3, #12]
	if (hw == SERCOM6) {
   113a4:	4770      	bx	lr
		_sercom6_dev = (struct _usart_async_device *)dev;
   113a6:	4b02      	ldr	r3, [pc, #8]	; (113b0 <_sercom_init_irq_param+0x4c>)
   113a8:	6159      	str	r1, [r3, #20]
	}
}
   113aa:	4770      	bx	lr
   113ac:	40003000 	.word	0x40003000
   113b0:	20008d68 	.word	0x20008d68
   113b4:	43000800 	.word	0x43000800
   113b8:	40003400 	.word	0x40003400
   113bc:	41014000 	.word	0x41014000
   113c0:	43000400 	.word	0x43000400

000113c4 <_sercom_get_irq_num>:

/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
   113c4:	b508      	push	{r3, lr}
	return SERCOM0_0_IRQn + (_sercom_get_hardware_index(hw) << 2);
   113c6:	4b03      	ldr	r3, [pc, #12]	; (113d4 <_sercom_get_irq_num+0x10>)
   113c8:	4798      	blx	r3
   113ca:	0080      	lsls	r0, r0, #2
   113cc:	302e      	adds	r0, #46	; 0x2e
}
   113ce:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   113d2:	bd08      	pop	{r3, pc}
   113d4:	000112bd 	.word	0x000112bd

000113d8 <_spi_sync_enable>:
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   113d8:	69c2      	ldr	r2, [r0, #28]
 *
 * \return Enabling status
 */
static int32_t _spi_sync_enable(void *const hw)
{
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   113da:	f012 0201 	ands.w	r2, r2, #1
{
   113de:	b508      	push	{r3, lr}
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   113e0:	d108      	bne.n	113f4 <_spi_sync_enable+0x1c>
	((Sercom *)hw)->SPI.CTRLA.reg |= SERCOM_SPI_CTRLA_ENABLE;
   113e2:	6803      	ldr	r3, [r0, #0]
   113e4:	f043 0302 	orr.w	r3, r3, #2
   113e8:	6003      	str	r3, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   113ea:	2103      	movs	r1, #3
   113ec:	4b03      	ldr	r3, [pc, #12]	; (113fc <_spi_sync_enable+0x24>)
   113ee:	4798      	blx	r3
		return ERR_BUSY;
	}

	hri_sercomspi_set_CTRLA_ENABLE_bit(hw);

	return ERR_NONE;
   113f0:	4610      	mov	r0, r2
}
   113f2:	bd08      	pop	{r3, pc}
		return ERR_BUSY;
   113f4:	f06f 0003 	mvn.w	r0, #3
   113f8:	e7fb      	b.n	113f2 <_spi_sync_enable+0x1a>
   113fa:	bf00      	nop
   113fc:	00011245 	.word	0x00011245

00011400 <_spi_get_regs>:
/** \brief Return the pointer to register settings of specific SERCOM
 *  \param[in] hw_addr The hardware register base address.
 *  \return Pointer to register settings of specific SERCOM.
 */
static inline const struct sercomspi_regs_cfg *_spi_get_regs(const uint32_t hw_addr)
{
   11400:	b508      	push	{r3, lr}
	uint8_t n = _sercom_get_hardware_index((const void *)hw_addr);
   11402:	4b08      	ldr	r3, [pc, #32]	; (11424 <_spi_get_regs+0x24>)
   11404:	4798      	blx	r3
	uint8_t i;

	for (i = 0; i < sizeof(sercomspi_regs) / sizeof(struct sercomspi_regs_cfg); i++) {
		if (sercomspi_regs[i].n == n) {
   11406:	2803      	cmp	r0, #3
   11408:	d007      	beq.n	1141a <_spi_get_regs+0x1a>
   1140a:	2807      	cmp	r0, #7
   1140c:	d107      	bne.n	1141e <_spi_get_regs+0x1e>
   1140e:	2301      	movs	r3, #1
			return &sercomspi_regs[i];
   11410:	4805      	ldr	r0, [pc, #20]	; (11428 <_spi_get_regs+0x28>)
   11412:	eb00 1003 	add.w	r0, r0, r3, lsl #4
   11416:	4418      	add	r0, r3
		}
	}

	return NULL;
}
   11418:	bd08      	pop	{r3, pc}
		if (sercomspi_regs[i].n == n) {
   1141a:	2300      	movs	r3, #0
   1141c:	e7f8      	b.n	11410 <_spi_get_regs+0x10>
	return NULL;
   1141e:	2000      	movs	r0, #0
   11420:	e7fa      	b.n	11418 <_spi_get_regs+0x18>
   11422:	bf00      	nop
   11424:	000112bd 	.word	0x000112bd
   11428:	0001724c 	.word	0x0001724c

0001142c <_spi_dma_tx_complete>:
 */
static void _spi_dma_tx_complete(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.tx) {
   1142c:	6883      	ldr	r3, [r0, #8]
   1142e:	685b      	ldr	r3, [r3, #4]
   11430:	b103      	cbz	r3, 11434 <_spi_dma_tx_complete+0x8>
		dev->callbacks.tx(resource);
   11432:	4718      	bx	r3
	}
}
   11434:	4770      	bx	lr

00011436 <_spi_dma_error_occured>:
 */
static void _spi_dma_error_occured(struct _dma_resource *resource)
{
	struct _spi_m_dma_dev *dev = (struct _spi_m_dma_dev *)resource->back;

	if (dev->callbacks.error) {
   11436:	6883      	ldr	r3, [r0, #8]
   11438:	68db      	ldr	r3, [r3, #12]
   1143a:	b103      	cbz	r3, 1143e <_spi_dma_error_occured+0x8>
		dev->callbacks.error(resource);
   1143c:	4718      	bx	r3
	}
}
   1143e:	4770      	bx	lr

00011440 <__NVIC_EnableIRQ>:
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   11440:	0942      	lsrs	r2, r0, #5
   11442:	2301      	movs	r3, #1
   11444:	f000 001f 	and.w	r0, r0, #31
   11448:	fa03 f000 	lsl.w	r0, r3, r0
   1144c:	4b01      	ldr	r3, [pc, #4]	; (11454 <__NVIC_EnableIRQ+0x14>)
   1144e:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
}
   11452:	4770      	bx	lr
   11454:	e000e100 	.word	0xe000e100

00011458 <_spi_async_enable>:
{
   11458:	b538      	push	{r3, r4, r5, lr}
   1145a:	4604      	mov	r4, r0
	_spi_sync_enable(hw);
   1145c:	4b07      	ldr	r3, [pc, #28]	; (1147c <_spi_async_enable+0x24>)
		NVIC_EnableIRQ((IRQn_Type)irq++);
   1145e:	4d08      	ldr	r5, [pc, #32]	; (11480 <_spi_async_enable+0x28>)
	_spi_sync_enable(hw);
   11460:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   11462:	4620      	mov	r0, r4
   11464:	4b07      	ldr	r3, [pc, #28]	; (11484 <_spi_async_enable+0x2c>)
   11466:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11468:	2100      	movs	r1, #0
	uint8_t irq = _sercom_get_irq_num(hw);
   1146a:	4604      	mov	r4, r0
		NVIC_EnableIRQ((IRQn_Type)irq++);
   1146c:	1860      	adds	r0, r4, r1
   1146e:	b2c0      	uxtb	r0, r0
   11470:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   11472:	3101      	adds	r1, #1
   11474:	2904      	cmp	r1, #4
   11476:	d1f9      	bne.n	1146c <_spi_async_enable+0x14>
}
   11478:	2000      	movs	r0, #0
   1147a:	bd38      	pop	{r3, r4, r5, pc}
   1147c:	000113d9 	.word	0x000113d9
   11480:	00011441 	.word	0x00011441
   11484:	000113c5 	.word	0x000113c5

00011488 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   11488:	0943      	lsrs	r3, r0, #5
   1148a:	2201      	movs	r2, #1
   1148c:	f000 001f 	and.w	r0, r0, #31
   11490:	fa02 f000 	lsl.w	r0, r2, r0
   11494:	3320      	adds	r3, #32
   11496:	4a04      	ldr	r2, [pc, #16]	; (114a8 <__NVIC_DisableIRQ+0x20>)
   11498:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1149c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   114a0:	f3bf 8f6f 	isb	sy
}
   114a4:	4770      	bx	lr
   114a6:	bf00      	nop
   114a8:	e000e100 	.word	0xe000e100

000114ac <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   114ac:	0943      	lsrs	r3, r0, #5
   114ae:	2201      	movs	r2, #1
   114b0:	f000 001f 	and.w	r0, r0, #31
   114b4:	fa02 f000 	lsl.w	r0, r2, r0
   114b8:	3360      	adds	r3, #96	; 0x60
   114ba:	4a02      	ldr	r2, [pc, #8]	; (114c4 <__NVIC_ClearPendingIRQ+0x18>)
   114bc:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   114c0:	4770      	bx	lr
   114c2:	bf00      	nop
   114c4:	e000e100 	.word	0xe000e100

000114c8 <_get_i2cm_index>:
{
   114c8:	b508      	push	{r3, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   114ca:	4b07      	ldr	r3, [pc, #28]	; (114e8 <_get_i2cm_index+0x20>)
   114cc:	4798      	blx	r3
		if (_i2cms[i].number == sercom_offset) {
   114ce:	2805      	cmp	r0, #5
   114d0:	d008      	beq.n	114e4 <_get_i2cm_index+0x1c>
	ASSERT(false);
   114d2:	2000      	movs	r0, #0
   114d4:	4905      	ldr	r1, [pc, #20]	; (114ec <_get_i2cm_index+0x24>)
   114d6:	4b06      	ldr	r3, [pc, #24]	; (114f0 <_get_i2cm_index+0x28>)
   114d8:	f240 32ed 	movw	r2, #1005	; 0x3ed
   114dc:	4798      	blx	r3
   114de:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   114e2:	bd08      	pop	{r3, pc}
			return i;
   114e4:	2000      	movs	r0, #0
   114e6:	e7fc      	b.n	114e2 <_get_i2cm_index+0x1a>
   114e8:	000112bd 	.word	0x000112bd
   114ec:	00017211 	.word	0x00017211
   114f0:	0000e9b9 	.word	0x0000e9b9

000114f4 <_sercom_i2c_send_stop>:
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   114f4:	6842      	ldr	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   114f6:	4b03      	ldr	r3, [pc, #12]	; (11504 <_sercom_i2c_send_stop+0x10>)
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_CMD(mask);
   114f8:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
   114fc:	6042      	str	r2, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   114fe:	2104      	movs	r1, #4
   11500:	4718      	bx	r3
   11502:	bf00      	nop
   11504:	0001123d 	.word	0x0001123d

00011508 <_sercom_i2c_sync_analyse_flags>:
{
   11508:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1150c:	460e      	mov	r6, r1
   1150e:	4614      	mov	r4, r2
	((Sercom *)hw)->I2CM.STATUS.reg |= mask;
}

static inline hri_sercomi2cm_status_reg_t hri_sercomi2cm_read_STATUS_reg(const void *const hw)
{
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11510:	2104      	movs	r1, #4
   11512:	4a56      	ldr	r2, [pc, #344]	; (1166c <_sercom_i2c_sync_analyse_flags+0x164>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   11514:	f8d0 8000 	ldr.w	r8, [r0]
   11518:	4605      	mov	r5, r0
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1151a:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.STATUS.reg;
   1151c:	8b43      	ldrh	r3, [r0, #26]
	if (flags & MB_FLAG) {
   1151e:	f016 0f01 	tst.w	r6, #1
   11522:	b29b      	uxth	r3, r3
   11524:	4617      	mov	r7, r2
   11526:	d064      	beq.n	115f2 <_sercom_i2c_sync_analyse_flags+0xea>
		if (status & SERCOM_I2CM_STATUS_ARBLOST) {
   11528:	079f      	lsls	r7, r3, #30
   1152a:	d516      	bpl.n	1155a <_sercom_i2c_sync_analyse_flags+0x52>
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_MB;
   1152c:	2201      	movs	r2, #1
   1152e:	7602      	strb	r2, [r0, #24]
			msg->flags |= I2C_M_FAIL;
   11530:	8862      	ldrh	r2, [r4, #2]
   11532:	b292      	uxth	r2, r2
   11534:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
   11538:	8062      	strh	r2, [r4, #2]
			msg->flags &= ~I2C_M_BUSY;
   1153a:	8862      	ldrh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   1153c:	f003 0601 	and.w	r6, r3, #1
			msg->flags &= ~I2C_M_BUSY;
   11540:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   11544:	0412      	lsls	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   11546:	f1c6 26ff 	rsb	r6, r6, #4278255360	; 0xff00ff00
			msg->flags &= ~I2C_M_BUSY;
   1154a:	0c12      	lsrs	r2, r2, #16
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   1154c:	f506 067f 	add.w	r6, r6, #16711680	; 0xff0000
			msg->flags &= ~I2C_M_BUSY;
   11550:	8062      	strh	r2, [r4, #2]
			if (status & SERCOM_I2CM_STATUS_BUSERR) {
   11552:	36fc      	adds	r6, #252	; 0xfc
}
   11554:	4630      	mov	r0, r6
   11556:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (status & SERCOM_I2CM_STATUS_RXNACK) {
   1155a:	f013 0604 	ands.w	r6, r3, #4
   1155e:	d015      	beq.n	1158c <_sercom_i2c_sync_analyse_flags+0x84>
				if (msg->len > 0) {
   11560:	6863      	ldr	r3, [r4, #4]
   11562:	2b00      	cmp	r3, #0
					msg->flags |= I2C_M_FAIL;
   11564:	bfc1      	itttt	gt
   11566:	8863      	ldrhgt	r3, [r4, #2]
   11568:	b29b      	uxthgt	r3, r3
   1156a:	f443 5380 	orrgt.w	r3, r3, #4096	; 0x1000
   1156e:	8063      	strhgt	r3, [r4, #2]
				if (msg->flags & I2C_M_STOP) {
   11570:	8863      	ldrh	r3, [r4, #2]
   11572:	041e      	lsls	r6, r3, #16
   11574:	d501      	bpl.n	1157a <_sercom_i2c_sync_analyse_flags+0x72>
					_sercom_i2c_send_stop(hw);
   11576:	4b3e      	ldr	r3, [pc, #248]	; (11670 <_sercom_i2c_sync_analyse_flags+0x168>)
   11578:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   1157a:	8863      	ldrh	r3, [r4, #2]
   1157c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   11580:	041b      	lsls	r3, r3, #16
   11582:	0c1b      	lsrs	r3, r3, #16
   11584:	8063      	strh	r3, [r4, #2]
			return I2C_NACK;
   11586:	f06f 0601 	mvn.w	r6, #1
   1158a:	e7e3      	b.n	11554 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->flags & I2C_M_TEN) {
   1158c:	8863      	ldrh	r3, [r4, #2]
   1158e:	f413 6780 	ands.w	r7, r3, #1024	; 0x400
   11592:	d015      	beq.n	115c0 <_sercom_i2c_sync_analyse_flags+0xb8>
				                              ((((msg->addr & TEN_ADDR_MASK) >> 8) | TEN_ADDR_FRAME) << 1) | I2C_M_RD
   11594:	8823      	ldrh	r3, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11596:	2104      	movs	r1, #4
   11598:	09db      	lsrs	r3, r3, #7
				                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   1159a:	f003 0706 	and.w	r7, r3, #6
   1159e:	4790      	blx	r2
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   115a0:	6a43      	ldr	r3, [r0, #36]	; 0x24
   115a2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   115a6:	433b      	orrs	r3, r7
				hri_sercomi2cm_write_ADDR_reg(hw,
   115a8:	f043 03f1 	orr.w	r3, r3, #241	; 0xf1
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   115ac:	6243      	str	r3, [r0, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   115ae:	2104      	movs	r1, #4
   115b0:	4790      	blx	r2
				msg->flags &= ~I2C_M_TEN;
   115b2:	8863      	ldrh	r3, [r4, #2]
   115b4:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
				msg->flags &= ~I2C_M_BUSY;
   115b8:	041b      	lsls	r3, r3, #16
   115ba:	0c1b      	lsrs	r3, r3, #16
   115bc:	8063      	strh	r3, [r4, #2]
   115be:	e7c9      	b.n	11554 <_sercom_i2c_sync_analyse_flags+0x4c>
			if (msg->len == 0) {
   115c0:	6866      	ldr	r6, [r4, #4]
   115c2:	b94e      	cbnz	r6, 115d8 <_sercom_i2c_sync_analyse_flags+0xd0>
				if (msg->flags & I2C_M_STOP) {
   115c4:	8863      	ldrh	r3, [r4, #2]
   115c6:	0418      	lsls	r0, r3, #16
   115c8:	d502      	bpl.n	115d0 <_sercom_i2c_sync_analyse_flags+0xc8>
					_sercom_i2c_send_stop(hw);
   115ca:	4b29      	ldr	r3, [pc, #164]	; (11670 <_sercom_i2c_sync_analyse_flags+0x168>)
   115cc:	4628      	mov	r0, r5
   115ce:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   115d0:	8863      	ldrh	r3, [r4, #2]
   115d2:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   115d6:	e7ef      	b.n	115b8 <_sercom_i2c_sync_analyse_flags+0xb0>
				hri_sercomi2cm_write_DATA_reg(hw, *msg->buffer);
   115d8:	68a3      	ldr	r3, [r4, #8]
   115da:	781b      	ldrb	r3, [r3, #0]
	((Sercom *)hw)->I2CM.DATA.reg = data;
   115dc:	6283      	str	r3, [r0, #40]	; 0x28
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   115de:	2104      	movs	r1, #4
   115e0:	4790      	blx	r2
				msg->buffer++;
   115e2:	68a3      	ldr	r3, [r4, #8]
   115e4:	3301      	adds	r3, #1
   115e6:	60a3      	str	r3, [r4, #8]
				msg->len--;
   115e8:	6863      	ldr	r3, [r4, #4]
   115ea:	3b01      	subs	r3, #1
   115ec:	6063      	str	r3, [r4, #4]
	return I2C_OK;
   115ee:	2600      	movs	r6, #0
}
   115f0:	e7b0      	b.n	11554 <_sercom_i2c_sync_analyse_flags+0x4c>
	} else if (flags & SB_FLAG) {
   115f2:	f016 0602 	ands.w	r6, r6, #2
   115f6:	d0ad      	beq.n	11554 <_sercom_i2c_sync_analyse_flags+0x4c>
		if ((msg->len) && !(status & SERCOM_I2CM_STATUS_RXNACK)) {
   115f8:	6862      	ldr	r2, [r4, #4]
   115fa:	2a00      	cmp	r2, #0
   115fc:	d032      	beq.n	11664 <_sercom_i2c_sync_analyse_flags+0x15c>
   115fe:	0759      	lsls	r1, r3, #29
   11600:	d430      	bmi.n	11664 <_sercom_i2c_sync_analyse_flags+0x15c>
			msg->len--;
   11602:	3a01      	subs	r2, #1
   11604:	f3c8 61c0 	ubfx	r1, r8, #27, #1
   11608:	6062      	str	r2, [r4, #4]
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   1160a:	b99a      	cbnz	r2, 11634 <_sercom_i2c_sync_analyse_flags+0x12c>
   1160c:	b1a9      	cbz	r1, 1163a <_sercom_i2c_sync_analyse_flags+0x132>
				if (msg->flags & I2C_M_STOP) {
   1160e:	8863      	ldrh	r3, [r4, #2]
   11610:	041b      	lsls	r3, r3, #16
   11612:	d508      	bpl.n	11626 <_sercom_i2c_sync_analyse_flags+0x11e>
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_SMEN;
   11614:	686b      	ldr	r3, [r5, #4]
   11616:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1161a:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1161c:	2104      	movs	r1, #4
   1161e:	4628      	mov	r0, r5
   11620:	47b8      	blx	r7
					_sercom_i2c_send_stop(hw);
   11622:	4b13      	ldr	r3, [pc, #76]	; (11670 <_sercom_i2c_sync_analyse_flags+0x168>)
   11624:	4798      	blx	r3
				msg->flags &= ~I2C_M_BUSY;
   11626:	8863      	ldrh	r3, [r4, #2]
   11628:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   1162c:	041b      	lsls	r3, r3, #16
   1162e:	0c1b      	lsrs	r3, r3, #16
   11630:	8063      	strh	r3, [r4, #2]
   11632:	e00c      	b.n	1164e <_sercom_i2c_sync_analyse_flags+0x146>
			if ((msg->len == 0 && !sclsm) || (msg->len == 1 && sclsm)) {
   11634:	2a01      	cmp	r2, #1
   11636:	d10a      	bne.n	1164e <_sercom_i2c_sync_analyse_flags+0x146>
   11638:	b149      	cbz	r1, 1164e <_sercom_i2c_sync_analyse_flags+0x146>
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   1163a:	686b      	ldr	r3, [r5, #4]
   1163c:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
   11640:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11642:	2104      	movs	r1, #4
   11644:	4628      	mov	r0, r5
   11646:	47b8      	blx	r7
			if (msg->len == 0) {
   11648:	6863      	ldr	r3, [r4, #4]
   1164a:	2b00      	cmp	r3, #0
   1164c:	d0df      	beq.n	1160e <_sercom_i2c_sync_analyse_flags+0x106>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   1164e:	2104      	movs	r1, #4
   11650:	4628      	mov	r0, r5
   11652:	47b8      	blx	r7
			*msg->buffer++ = hri_sercomi2cm_read_DATA_reg(hw);
   11654:	68a3      	ldr	r3, [r4, #8]
	return ((Sercom *)hw)->I2CM.DATA.reg;
   11656:	6aaa      	ldr	r2, [r5, #40]	; 0x28
   11658:	1c59      	adds	r1, r3, #1
   1165a:	60a1      	str	r1, [r4, #8]
   1165c:	701a      	strb	r2, [r3, #0]
	((Sercom *)hw)->I2CM.INTFLAG.reg = SERCOM_I2CM_INTFLAG_SB;
   1165e:	2302      	movs	r3, #2
   11660:	762b      	strb	r3, [r5, #24]
   11662:	e7c4      	b.n	115ee <_sercom_i2c_sync_analyse_flags+0xe6>
   11664:	2302      	movs	r3, #2
   11666:	762b      	strb	r3, [r5, #24]
   11668:	e78d      	b.n	11586 <_sercom_i2c_sync_analyse_flags+0x7e>
   1166a:	bf00      	nop
   1166c:	0001123d 	.word	0x0001123d
   11670:	000114f5 	.word	0x000114f5

00011674 <_usart_set_parity>:
{
   11674:	b573      	push	{r0, r1, r4, r5, r6, lr}
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   11676:	4b16      	ldr	r3, [pc, #88]	; (116d0 <_usart_set_parity+0x5c>)
{
   11678:	4604      	mov	r4, r0
   1167a:	460d      	mov	r5, r1
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   1167c:	4798      	blx	r3
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   1167e:	4b15      	ldr	r3, [pc, #84]	; (116d4 <_usart_set_parity+0x60>)
	bool enabled = hri_sercomusart_get_CTRLA_ENABLE_bit(hw);
   11680:	4606      	mov	r6, r0
	hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   11682:	4620      	mov	r0, r4
   11684:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
   11686:	4b14      	ldr	r3, [pc, #80]	; (116d8 <_usart_set_parity+0x64>)
   11688:	a801      	add	r0, sp, #4
   1168a:	4798      	blx	r3
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   1168c:	4a13      	ldr	r2, [pc, #76]	; (116dc <_usart_set_parity+0x68>)
   1168e:	4620      	mov	r0, r4
   11690:	2102      	movs	r1, #2
   11692:	4790      	blx	r2
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_FORM(mask);
   11694:	6823      	ldr	r3, [r4, #0]
	if (USART_PARITY_NONE != parity) {
   11696:	2d02      	cmp	r5, #2
   11698:	bf14      	ite	ne
   1169a:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_FORM(mask);
   1169e:	f023 7380 	biceq.w	r3, r3, #16777216	; 0x1000000
   116a2:	6023      	str	r3, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   116a4:	211f      	movs	r1, #31
   116a6:	4790      	blx	r2
	tmp = ((Sercom *)hw)->USART.CTRLB.reg;
   116a8:	6863      	ldr	r3, [r4, #4]
	hri_sercomusart_write_CTRLB_PMODE_bit(hw, parity);
   116aa:	3d00      	subs	r5, #0
   116ac:	bf18      	it	ne
   116ae:	2501      	movne	r5, #1
	tmp &= ~SERCOM_USART_CTRLB_PMODE;
   116b0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
	tmp |= value << SERCOM_USART_CTRLB_PMODE_Pos;
   116b4:	ea43 3545 	orr.w	r5, r3, r5, lsl #13
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   116b8:	211f      	movs	r1, #31
	((Sercom *)hw)->USART.CTRLB.reg = tmp;
   116ba:	6065      	str	r5, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   116bc:	4790      	blx	r2
	CRITICAL_SECTION_LEAVE()
   116be:	a801      	add	r0, sp, #4
   116c0:	4b07      	ldr	r3, [pc, #28]	; (116e0 <_usart_set_parity+0x6c>)
   116c2:	4798      	blx	r3
	hri_sercomusart_write_CTRLA_ENABLE_bit(hw, enabled);
   116c4:	4b07      	ldr	r3, [pc, #28]	; (116e4 <_usart_set_parity+0x70>)
   116c6:	4631      	mov	r1, r6
   116c8:	4620      	mov	r0, r4
   116ca:	4798      	blx	r3
}
   116cc:	b002      	add	sp, #8
   116ce:	bd70      	pop	{r4, r5, r6, pc}
   116d0:	0001127d 	.word	0x0001127d
   116d4:	000112a9 	.word	0x000112a9
   116d8:	00012485 	.word	0x00012485
   116dc:	0001124d 	.word	0x0001124d
   116e0:	00012493 	.word	0x00012493
   116e4:	00011291 	.word	0x00011291

000116e8 <_spi_set_mode>:
{
   116e8:	b570      	push	{r4, r5, r6, lr}
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   116ea:	69c4      	ldr	r4, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   116ec:	f014 0403 	ands.w	r4, r4, #3
{
   116f0:	460a      	mov	r2, r1
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE)) {
   116f2:	d10e      	bne.n	11712 <_spi_set_mode+0x2a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   116f4:	4e08      	ldr	r6, [pc, #32]	; (11718 <_spi_set_mode+0x30>)
   116f6:	2103      	movs	r1, #3
   116f8:	47b0      	blx	r6
	return ((Sercom *)hw)->SPI.CTRLA.reg;
   116fa:	6803      	ldr	r3, [r0, #0]
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   116fc:	0712      	lsls	r2, r2, #28
	ctrla &= ~(SERCOM_SPI_CTRLA_CPOL | SERCOM_SPI_CTRLA_CPHA);
   116fe:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
	ctrla |= (mode & 0x3u) << SERCOM_SPI_CTRLA_CPHA_Pos;
   11702:	f002 5240 	and.w	r2, r2, #805306368	; 0x30000000
   11706:	431a      	orrs	r2, r3
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11708:	6002      	str	r2, [r0, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1170a:	2103      	movs	r1, #3
   1170c:	47b0      	blx	r6
	return ERR_NONE;
   1170e:	4620      	mov	r0, r4
}
   11710:	bd70      	pop	{r4, r5, r6, pc}
		return ERR_BUSY;
   11712:	f06f 0003 	mvn.w	r0, #3
   11716:	e7fb      	b.n	11710 <_spi_set_mode+0x28>
   11718:	00011245 	.word	0x00011245

0001171c <_spi_load_regs_master>:
{
   1171c:	b538      	push	{r3, r4, r5, lr}
   1171e:	460d      	mov	r5, r1
	ASSERT(hw && regs);
   11720:	4604      	mov	r4, r0
   11722:	b110      	cbz	r0, 1172a <_spi_load_regs_master+0xe>
   11724:	1e08      	subs	r0, r1, #0
   11726:	bf18      	it	ne
   11728:	2001      	movne	r0, #1
   1172a:	490f      	ldr	r1, [pc, #60]	; (11768 <_spi_load_regs_master+0x4c>)
   1172c:	4b0f      	ldr	r3, [pc, #60]	; (1176c <_spi_load_regs_master+0x50>)
   1172e:	f640 127a 	movw	r2, #2426	; 0x97a
   11732:	4798      	blx	r3
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   11734:	682b      	ldr	r3, [r5, #0]
   11736:	4a0e      	ldr	r2, [pc, #56]	; (11770 <_spi_load_regs_master+0x54>)
	hri_sercomspi_write_CTRLA_reg(
   11738:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   1173c:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11740:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11742:	2103      	movs	r1, #3
   11744:	4620      	mov	r0, r4
   11746:	4790      	blx	r2
	    (regs->ctrlb
   11748:	686b      	ldr	r3, [r5, #4]
	        | (SERCOM_SPI_CTRLB_RXEN));
   1174a:	f423 3338 	bic.w	r3, r3, #188416	; 0x2e000
   1174e:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(
   11752:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   11756:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11758:	2117      	movs	r1, #23
   1175a:	4790      	blx	r2
	hri_sercomspi_write_BAUD_reg(hw, regs->baud);
   1175c:	7b2b      	ldrb	r3, [r5, #12]
	((Sercom *)hw)->SPI.BAUD.reg = data;
   1175e:	7323      	strb	r3, [r4, #12]
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   11760:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   11762:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
}
   11766:	bd38      	pop	{r3, r4, r5, pc}
   11768:	00017211 	.word	0x00017211
   1176c:	0000e9b9 	.word	0x0000e9b9
   11770:	00011245 	.word	0x00011245

00011774 <_i2c_m_sync_init_impl>:
{
   11774:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   11778:	460c      	mov	r4, r1
	uint8_t i = _get_i2cm_index(hw);
   1177a:	4b23      	ldr	r3, [pc, #140]	; (11808 <_i2c_m_sync_init_impl+0x94>)
   1177c:	f8df 9094 	ldr.w	r9, [pc, #148]	; 11814 <_i2c_m_sync_init_impl+0xa0>
   11780:	4d22      	ldr	r5, [pc, #136]	; (1180c <_i2c_m_sync_init_impl+0x98>)
{
   11782:	4607      	mov	r7, r0
	uint8_t i = _get_i2cm_index(hw);
   11784:	4608      	mov	r0, r1
   11786:	4798      	blx	r3
	return ((Sercom *)hw)->I2CM.SYNCBUSY.reg & reg;
   11788:	69e3      	ldr	r3, [r4, #28]
	if (!hri_sercomi2cm_is_syncing(hw, SERCOM_I2CM_SYNCBUSY_SWRST)) {
   1178a:	f013 0f01 	tst.w	r3, #1
   1178e:	fa5f f880 	uxtb.w	r8, r0
   11792:	d115      	bne.n	117c0 <_i2c_m_sync_init_impl+0x4c>
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   11794:	2318      	movs	r3, #24
   11796:	fb03 9308 	mla	r3, r3, r8, r9
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   1179a:	2103      	movs	r1, #3
   1179c:	4620      	mov	r0, r4
   1179e:	6c9e      	ldr	r6, [r3, #72]	; 0x48
   117a0:	47a8      	blx	r5
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   117a2:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   117a4:	079b      	lsls	r3, r3, #30
		uint32_t mode = _i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_MODE_Msk;
   117a6:	f006 061c 	and.w	r6, r6, #28
		if (hri_sercomi2cm_get_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_ENABLE)) {
   117aa:	d503      	bpl.n	117b4 <_i2c_m_sync_init_impl+0x40>
			hri_sercomi2cm_clear_CTRLA_ENABLE_bit(hw);
   117ac:	4b18      	ldr	r3, [pc, #96]	; (11810 <_i2c_m_sync_init_impl+0x9c>)
   117ae:	4798      	blx	r3
			hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_ENABLE);
   117b0:	2102      	movs	r1, #2
   117b2:	47a8      	blx	r5
		hri_sercomi2cm_write_CTRLA_reg(hw, SERCOM_I2CM_CTRLA_SWRST | mode);
   117b4:	f046 0601 	orr.w	r6, r6, #1
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   117b8:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   117ba:	2103      	movs	r1, #3
   117bc:	4620      	mov	r0, r4
   117be:	47a8      	blx	r5
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST);
   117c0:	4620      	mov	r0, r4
   117c2:	2101      	movs	r1, #1
   117c4:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLA_reg(hw, _i2cms[i].ctrl_a);
   117c6:	2218      	movs	r2, #24
   117c8:	fb02 9208 	mla	r2, r2, r8, r9
   117cc:	2103      	movs	r1, #3
   117ce:	6c96      	ldr	r6, [r2, #72]	; 0x48
	((Sercom *)hw)->I2CM.CTRLA.reg = data;
   117d0:	6026      	str	r6, [r4, #0]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SWRST | SERCOM_I2CM_SYNCBUSY_ENABLE);
   117d2:	47a8      	blx	r5
	hri_sercomi2cm_write_CTRLB_reg(hw, _i2cms[i].ctrl_b);
   117d4:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
	((Sercom *)hw)->I2CM.CTRLB.reg = data;
   117d6:	6063      	str	r3, [r4, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   117d8:	2104      	movs	r1, #4
   117da:	47a8      	blx	r5
	hri_sercomi2cm_write_BAUD_reg(hw, _i2cms[i].baud);
   117dc:	6d13      	ldr	r3, [r2, #80]	; 0x50
	((Sercom *)hw)->I2CM.BAUD.reg = data;
   117de:	60e3      	str	r3, [r4, #12]
	service->mode = (_i2cms[i].ctrl_a & SERCOM_I2CM_CTRLA_SPEED_Msk) >> SERCOM_I2CM_CTRLA_SPEED_Pos;
   117e0:	f3c6 6301 	ubfx	r3, r6, #24, #2
   117e4:	81bb      	strh	r3, [r7, #12]
	tmp = ((Sercom *)hw)->I2CM.ADDR.reg;
   117e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_write_ADDR_HS_bit(hw, service->mode < I2C_HS ? 0 : 1);
   117e8:	f3c6 6640 	ubfx	r6, r6, #25, #1
	tmp &= ~SERCOM_I2CM_ADDR_HS;
   117ec:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
	tmp |= value << SERCOM_I2CM_ADDR_HS_Pos;
   117f0:	ea43 3386 	orr.w	r3, r3, r6, lsl #14
	((Sercom *)hw)->I2CM.ADDR.reg = tmp;
   117f4:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   117f6:	2104      	movs	r1, #4
   117f8:	47a8      	blx	r5
	service->trise = _i2cms[i].trise;
   117fa:	f8b2 3056 	ldrh.w	r3, [r2, #86]	; 0x56
   117fe:	81fb      	strh	r3, [r7, #14]
}
   11800:	2000      	movs	r0, #0
   11802:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   11806:	bf00      	nop
   11808:	000114c9 	.word	0x000114c9
   1180c:	0001123d 	.word	0x0001123d
   11810:	00011255 	.word	0x00011255
   11814:	0001722c 	.word	0x0001722c

00011818 <_usart_init>:
{
   11818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   1181c:	4b2d      	ldr	r3, [pc, #180]	; (118d4 <_usart_init+0xbc>)
{
   1181e:	4604      	mov	r4, r0
	uint8_t sercom_offset = _sercom_get_hardware_index(hw);
   11820:	4798      	blx	r3
		if (_usarts[i].number == sercom_offset) {
   11822:	4605      	mov	r5, r0
   11824:	b170      	cbz	r0, 11844 <_usart_init+0x2c>
   11826:	2801      	cmp	r0, #1
   11828:	d00c      	beq.n	11844 <_usart_init+0x2c>
   1182a:	2802      	cmp	r0, #2
   1182c:	d00a      	beq.n	11844 <_usart_init+0x2c>
   1182e:	2804      	cmp	r0, #4
   11830:	d04b      	beq.n	118ca <_usart_init+0xb2>
   11832:	2806      	cmp	r0, #6
   11834:	d04b      	beq.n	118ce <_usart_init+0xb6>
	ASSERT(false);
   11836:	4928      	ldr	r1, [pc, #160]	; (118d8 <_usart_init+0xc0>)
   11838:	4b28      	ldr	r3, [pc, #160]	; (118dc <_usart_init+0xc4>)
   1183a:	f240 2276 	movw	r2, #630	; 0x276
   1183e:	2000      	movs	r0, #0
   11840:	4798      	blx	r3
	return 0;
   11842:	2500      	movs	r5, #0
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
   11844:	69e3      	ldr	r3, [r4, #28]
   11846:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 118e8 <_usart_init+0xd0>
   1184a:	4e25      	ldr	r6, [pc, #148]	; (118e0 <_usart_init+0xc8>)
	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
   1184c:	f013 0f01 	tst.w	r3, #1
   11850:	d115      	bne.n	1187e <_usart_init+0x66>
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   11852:	2318      	movs	r3, #24
   11854:	fb03 8305 	mla	r3, r3, r5, r8
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11858:	2103      	movs	r1, #3
   1185a:	4620      	mov	r0, r4
   1185c:	6e1f      	ldr	r7, [r3, #96]	; 0x60
   1185e:	47b0      	blx	r6
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
   11860:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   11862:	079b      	lsls	r3, r3, #30
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
   11864:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
   11868:	d503      	bpl.n	11872 <_usart_init+0x5a>
			hri_sercomusart_clear_CTRLA_ENABLE_bit(hw);
   1186a:	4b1e      	ldr	r3, [pc, #120]	; (118e4 <_usart_init+0xcc>)
   1186c:	4798      	blx	r3
			hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_ENABLE);
   1186e:	2102      	movs	r1, #2
   11870:	47b0      	blx	r6
		hri_sercomusart_write_CTRLA_reg(hw, SERCOM_USART_CTRLA_SWRST | mode);
   11872:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->USART.CTRLA.reg = data;
   11876:	6027      	str	r7, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11878:	2103      	movs	r1, #3
   1187a:	4620      	mov	r0, r4
   1187c:	47b0      	blx	r6
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST);
   1187e:	2101      	movs	r1, #1
   11880:	4620      	mov	r0, r4
   11882:	47b0      	blx	r6
	hri_sercomusart_write_CTRLA_reg(hw, _usarts[i].ctrl_a);
   11884:	2018      	movs	r0, #24
   11886:	fb00 8505 	mla	r5, r0, r5, r8
   1188a:	2103      	movs	r1, #3
   1188c:	6e2a      	ldr	r2, [r5, #96]	; 0x60
	((Sercom *)hw)->USART.CTRLA.reg = data;
   1188e:	6022      	str	r2, [r4, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   11890:	4620      	mov	r0, r4
   11892:	47b0      	blx	r6
	hri_sercomusart_write_CTRLB_reg(hw, _usarts[i].ctrl_b);
   11894:	6e6b      	ldr	r3, [r5, #100]	; 0x64
	((Sercom *)hw)->USART.CTRLB.reg = data;
   11896:	6063      	str	r3, [r4, #4]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_MASK);
   11898:	211f      	movs	r1, #31
   1189a:	47b0      	blx	r6
	hri_sercomusart_write_CTRLC_reg(hw, _usarts[i].ctrl_c);
   1189c:	6eab      	ldr	r3, [r5, #104]	; 0x68
	((Sercom *)hw)->USART.CTRLC.reg = data;
   1189e:	60a3      	str	r3, [r4, #8]
	if ((_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x1)) || (_usarts[i].ctrl_a & SERCOM_USART_CTRLA_SAMPR(0x3))) {
   118a0:	f412 4fc0 	tst.w	r2, #24576	; 0x6000
   118a4:	f8b5 306c 	ldrh.w	r3, [r5, #108]	; 0x6c
   118a8:	d008      	beq.n	118bc <_usart_init+0xa4>
		((Sercom *)hw)->USART.BAUD.FRAC.BAUD = _usarts[i].baud;
   118aa:	89a2      	ldrh	r2, [r4, #12]
   118ac:	f363 020c 	bfi	r2, r3, #0, #13
   118b0:	81a2      	strh	r2, [r4, #12]
		((Sercom *)hw)->USART.BAUD.FRAC.FP   = _usarts[i].fractional;
   118b2:	89a3      	ldrh	r3, [r4, #12]
   118b4:	f895 206e 	ldrb.w	r2, [r5, #110]	; 0x6e
   118b8:	f362 334f 	bfi	r3, r2, #13, #3
	((Sercom *)hw)->USART.RXPL.reg = data;
   118bc:	2000      	movs	r0, #0
	((Sercom *)hw)->USART.BAUD.reg = data;
   118be:	81a3      	strh	r3, [r4, #12]
	((Sercom *)hw)->USART.RXPL.reg = data;
   118c0:	73a0      	strb	r0, [r4, #14]
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
   118c2:	f884 0030 	strb.w	r0, [r4, #48]	; 0x30
}
   118c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	for (i = 0; i < ARRAY_SIZE(_usarts); i++) {
   118ca:	2503      	movs	r5, #3
   118cc:	e7ba      	b.n	11844 <_usart_init+0x2c>
   118ce:	2504      	movs	r5, #4
   118d0:	e7b8      	b.n	11844 <_usart_init+0x2c>
   118d2:	bf00      	nop
   118d4:	000112bd 	.word	0x000112bd
   118d8:	00017211 	.word	0x00017211
   118dc:	0000e9b9 	.word	0x0000e9b9
   118e0:	0001124d 	.word	0x0001124d
   118e4:	000112a9 	.word	0x000112a9
   118e8:	0001722c 	.word	0x0001722c

000118ec <_usart_sync_init>:
{
   118ec:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   118ee:	4605      	mov	r5, r0
   118f0:	3800      	subs	r0, #0
{
   118f2:	460c      	mov	r4, r1
	ASSERT(device);
   118f4:	4b05      	ldr	r3, [pc, #20]	; (1190c <_usart_sync_init+0x20>)
   118f6:	4906      	ldr	r1, [pc, #24]	; (11910 <_usart_sync_init+0x24>)
   118f8:	bf18      	it	ne
   118fa:	2001      	movne	r0, #1
   118fc:	22c8      	movs	r2, #200	; 0xc8
   118fe:	4798      	blx	r3
	device->hw = hw;
   11900:	602c      	str	r4, [r5, #0]
	return _usart_init(hw);
   11902:	4620      	mov	r0, r4
   11904:	4b03      	ldr	r3, [pc, #12]	; (11914 <_usart_sync_init+0x28>)
}
   11906:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _usart_init(hw);
   1190a:	4718      	bx	r3
   1190c:	0000e9b9 	.word	0x0000e9b9
   11910:	00017211 	.word	0x00017211
   11914:	00011819 	.word	0x00011819

00011918 <_usart_async_init>:
{
   11918:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(device);
   1191c:	4606      	mov	r6, r0
   1191e:	3800      	subs	r0, #0
   11920:	bf18      	it	ne
   11922:	2001      	movne	r0, #1
   11924:	4b12      	ldr	r3, [pc, #72]	; (11970 <_usart_async_init+0x58>)
{
   11926:	460c      	mov	r4, r1
	ASSERT(device);
   11928:	22d6      	movs	r2, #214	; 0xd6
   1192a:	4912      	ldr	r1, [pc, #72]	; (11974 <_usart_async_init+0x5c>)
   1192c:	4798      	blx	r3
	init_status = _usart_init(hw);
   1192e:	4b12      	ldr	r3, [pc, #72]	; (11978 <_usart_async_init+0x60>)
   11930:	4620      	mov	r0, r4
   11932:	4798      	blx	r3
	if (init_status) {
   11934:	4605      	mov	r5, r0
   11936:	b9b8      	cbnz	r0, 11968 <_usart_async_init+0x50>
	_sercom_init_irq_param(hw, (void *)device);
   11938:	4631      	mov	r1, r6
	device->hw = hw;
   1193a:	61b4      	str	r4, [r6, #24]
	_sercom_init_irq_param(hw, (void *)device);
   1193c:	4620      	mov	r0, r4
   1193e:	4b0f      	ldr	r3, [pc, #60]	; (1197c <_usart_async_init+0x64>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11940:	f8df 8048 	ldr.w	r8, [pc, #72]	; 1198c <_usart_async_init+0x74>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11944:	4f0e      	ldr	r7, [pc, #56]	; (11980 <_usart_async_init+0x68>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   11946:	4e0f      	ldr	r6, [pc, #60]	; (11984 <_usart_async_init+0x6c>)
	_sercom_init_irq_param(hw, (void *)device);
   11948:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   1194a:	4b0f      	ldr	r3, [pc, #60]	; (11988 <_usart_async_init+0x70>)
   1194c:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   1194e:	4629      	mov	r1, r5
	uint8_t irq = _sercom_get_irq_num(hw);
   11950:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11952:	1863      	adds	r3, r4, r1
   11954:	b2d8      	uxtb	r0, r3
   11956:	9001      	str	r0, [sp, #4]
   11958:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   1195a:	9801      	ldr	r0, [sp, #4]
   1195c:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   1195e:	9801      	ldr	r0, [sp, #4]
   11960:	47b0      	blx	r6
	for (uint32_t i = 0; i < 4; i++) {
   11962:	3101      	adds	r1, #1
   11964:	2904      	cmp	r1, #4
   11966:	d1f4      	bne.n	11952 <_usart_async_init+0x3a>
}
   11968:	4628      	mov	r0, r5
   1196a:	b002      	add	sp, #8
   1196c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11970:	0000e9b9 	.word	0x0000e9b9
   11974:	00017211 	.word	0x00017211
   11978:	00011819 	.word	0x00011819
   1197c:	00011365 	.word	0x00011365
   11980:	000114ad 	.word	0x000114ad
   11984:	00011441 	.word	0x00011441
   11988:	000113c5 	.word	0x000113c5
   1198c:	00011489 	.word	0x00011489

00011990 <_usart_sync_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   11990:	6800      	ldr	r0, [r0, #0]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   11992:	6803      	ldr	r3, [r0, #0]
   11994:	f043 0302 	orr.w	r3, r3, #2
   11998:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   1199a:	2103      	movs	r1, #3
   1199c:	4b00      	ldr	r3, [pc, #0]	; (119a0 <_usart_sync_enable+0x10>)
   1199e:	4718      	bx	r3
   119a0:	0001124d 	.word	0x0001124d

000119a4 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
   119a4:	6980      	ldr	r0, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
   119a6:	6803      	ldr	r3, [r0, #0]
   119a8:	f043 0302 	orr.w	r3, r3, #2
   119ac:	6003      	str	r3, [r0, #0]
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
   119ae:	2103      	movs	r1, #3
   119b0:	4b00      	ldr	r3, [pc, #0]	; (119b4 <_usart_async_enable+0x10>)
   119b2:	4718      	bx	r3
   119b4:	0001124d 	.word	0x0001124d

000119b8 <_usart_async_disable>:
	hri_sercomusart_clear_CTRLA_ENABLE_bit(device->hw);
   119b8:	6980      	ldr	r0, [r0, #24]
   119ba:	4b01      	ldr	r3, [pc, #4]	; (119c0 <_usart_async_disable+0x8>)
   119bc:	4718      	bx	r3
   119be:	bf00      	nop
   119c0:	000112a9 	.word	0x000112a9

000119c4 <_usart_async_set_parity>:
	_usart_set_parity(device->hw, parity);
   119c4:	6980      	ldr	r0, [r0, #24]
   119c6:	4b01      	ldr	r3, [pc, #4]	; (119cc <_usart_async_set_parity+0x8>)
   119c8:	4718      	bx	r3
   119ca:	bf00      	nop
   119cc:	00011675 	.word	0x00011675

000119d0 <_usart_sync_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   119d0:	6803      	ldr	r3, [r0, #0]
	((Sercom *)hw)->USART.DATA.reg = data;
   119d2:	6299      	str	r1, [r3, #40]	; 0x28
}
   119d4:	4770      	bx	lr

000119d6 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
   119d6:	6983      	ldr	r3, [r0, #24]
   119d8:	6299      	str	r1, [r3, #40]	; 0x28
}
   119da:	4770      	bx	lr

000119dc <_usart_sync_read_byte>:
	return hri_sercomusart_read_DATA_reg(device->hw);
   119dc:	6803      	ldr	r3, [r0, #0]
	return ((Sercom *)hw)->USART.DATA.reg;
   119de:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   119e0:	b2c0      	uxtb	r0, r0
   119e2:	4770      	bx	lr

000119e4 <_usart_sync_is_ready_to_send>:
	return hri_sercomusart_get_interrupt_DRE_bit(device->hw);
   119e4:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
   119e6:	7e18      	ldrb	r0, [r3, #24]
}
   119e8:	f000 0001 	and.w	r0, r0, #1
   119ec:	4770      	bx	lr

000119ee <_usart_sync_is_transmit_done>:
	return hri_sercomusart_get_interrupt_TXC_bit(device->hw);
   119ee:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
   119f0:	7e18      	ldrb	r0, [r3, #24]
}
   119f2:	f3c0 0040 	ubfx	r0, r0, #1, #1
   119f6:	4770      	bx	lr

000119f8 <_usart_sync_is_byte_received>:
	return hri_sercomusart_get_interrupt_RXC_bit(device->hw);
   119f8:	6803      	ldr	r3, [r0, #0]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
   119fa:	7e18      	ldrb	r0, [r3, #24]
}
   119fc:	f3c0 0080 	ubfx	r0, r0, #2, #1
   11a00:	4770      	bx	lr

00011a02 <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
   11a02:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   11a04:	2201      	movs	r2, #1
   11a06:	759a      	strb	r2, [r3, #22]
}
   11a08:	4770      	bx	lr

00011a0a <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
   11a0a:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
   11a0c:	2202      	movs	r2, #2
   11a0e:	759a      	strb	r2, [r3, #22]
}
   11a10:	4770      	bx	lr
	...

00011a14 <_usart_async_set_irq_state>:
{
   11a14:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   11a16:	4604      	mov	r4, r0
   11a18:	3800      	subs	r0, #0
{
   11a1a:	460e      	mov	r6, r1
	ASSERT(device);
   11a1c:	bf18      	it	ne
   11a1e:	2001      	movne	r0, #1
   11a20:	490f      	ldr	r1, [pc, #60]	; (11a60 <_usart_async_set_irq_state+0x4c>)
   11a22:	4b10      	ldr	r3, [pc, #64]	; (11a64 <_usart_async_set_irq_state+0x50>)
{
   11a24:	4615      	mov	r5, r2
	ASSERT(device);
   11a26:	f240 2236 	movw	r2, #566	; 0x236
   11a2a:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
   11a2c:	f016 0ffd 	tst.w	r6, #253	; 0xfd
   11a30:	d109      	bne.n	11a46 <_usart_async_set_irq_state+0x32>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
   11a32:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   11a34:	2101      	movs	r1, #1
   11a36:	2202      	movs	r2, #2
   11a38:	b915      	cbnz	r5, 11a40 <_usart_async_set_irq_state+0x2c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
   11a3a:	7519      	strb	r1, [r3, #20]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
   11a3c:	751a      	strb	r2, [r3, #20]
}
   11a3e:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
   11a40:	7599      	strb	r1, [r3, #22]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
   11a42:	759a      	strb	r2, [r3, #22]
   11a44:	e7fb      	b.n	11a3e <_usart_async_set_irq_state+0x2a>
	} else if (USART_ASYNC_RX_DONE == type) {
   11a46:	2e01      	cmp	r6, #1
   11a48:	d104      	bne.n	11a54 <_usart_async_set_irq_state+0x40>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
   11a4a:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
   11a4c:	2204      	movs	r2, #4
	if (value == 0x0) {
   11a4e:	2d00      	cmp	r5, #0
   11a50:	d1f7      	bne.n	11a42 <_usart_async_set_irq_state+0x2e>
   11a52:	e7f3      	b.n	11a3c <_usart_async_set_irq_state+0x28>
	} else if (USART_ASYNC_ERROR == type) {
   11a54:	2e03      	cmp	r6, #3
   11a56:	d1f2      	bne.n	11a3e <_usart_async_set_irq_state+0x2a>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
   11a58:	69a3      	ldr	r3, [r4, #24]
   11a5a:	2280      	movs	r2, #128	; 0x80
   11a5c:	e7f7      	b.n	11a4e <_usart_async_set_irq_state+0x3a>
   11a5e:	bf00      	nop
   11a60:	00017211 	.word	0x00017211
   11a64:	0000e9b9 	.word	0x0000e9b9

00011a68 <_i2c_m_async_init>:
{
   11a68:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   11a6c:	4605      	mov	r5, r0
   11a6e:	3800      	subs	r0, #0
{
   11a70:	460c      	mov	r4, r1
	ASSERT(i2c_dev);
   11a72:	bf18      	it	ne
   11a74:	2001      	movne	r0, #1
   11a76:	4913      	ldr	r1, [pc, #76]	; (11ac4 <_i2c_m_async_init+0x5c>)
   11a78:	4b13      	ldr	r3, [pc, #76]	; (11ac8 <_i2c_m_async_init+0x60>)
   11a7a:	f240 42d3 	movw	r2, #1235	; 0x4d3
   11a7e:	4798      	blx	r3
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11a80:	4b12      	ldr	r3, [pc, #72]	; (11acc <_i2c_m_async_init+0x64>)
	i2c_dev->hw = hw;
   11a82:	612c      	str	r4, [r5, #16]
	init_status = _i2c_m_sync_init_impl(&i2c_dev->service, hw);
   11a84:	4621      	mov	r1, r4
   11a86:	4628      	mov	r0, r5
   11a88:	4798      	blx	r3
	if (init_status) {
   11a8a:	4606      	mov	r6, r0
   11a8c:	b9b0      	cbnz	r0, 11abc <_i2c_m_async_init+0x54>
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11a8e:	4629      	mov	r1, r5
   11a90:	4620      	mov	r0, r4
   11a92:	4b0f      	ldr	r3, [pc, #60]	; (11ad0 <_i2c_m_async_init+0x68>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11a94:	f8df 8048 	ldr.w	r8, [pc, #72]	; 11ae0 <_i2c_m_async_init+0x78>
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11a98:	4f0e      	ldr	r7, [pc, #56]	; (11ad4 <_i2c_m_async_init+0x6c>)
		NVIC_EnableIRQ((IRQn_Type)irq);
   11a9a:	4d0f      	ldr	r5, [pc, #60]	; (11ad8 <_i2c_m_async_init+0x70>)
	_sercom_init_irq_param(hw, (void *)i2c_dev);
   11a9c:	4798      	blx	r3
	uint8_t irq = _sercom_get_irq_num(hw);
   11a9e:	4b0f      	ldr	r3, [pc, #60]	; (11adc <_i2c_m_async_init+0x74>)
   11aa0:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11aa2:	4631      	mov	r1, r6
	uint8_t irq = _sercom_get_irq_num(hw);
   11aa4:	4604      	mov	r4, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11aa6:	1863      	adds	r3, r4, r1
   11aa8:	b2d8      	uxtb	r0, r3
   11aaa:	9001      	str	r0, [sp, #4]
   11aac:	47c0      	blx	r8
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11aae:	9801      	ldr	r0, [sp, #4]
   11ab0:	47b8      	blx	r7
		NVIC_EnableIRQ((IRQn_Type)irq);
   11ab2:	9801      	ldr	r0, [sp, #4]
   11ab4:	47a8      	blx	r5
	for (uint32_t i = 0; i < 4; i++) {
   11ab6:	3101      	adds	r1, #1
   11ab8:	2904      	cmp	r1, #4
   11aba:	d1f4      	bne.n	11aa6 <_i2c_m_async_init+0x3e>
}
   11abc:	4630      	mov	r0, r6
   11abe:	b002      	add	sp, #8
   11ac0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   11ac4:	00017211 	.word	0x00017211
   11ac8:	0000e9b9 	.word	0x0000e9b9
   11acc:	00011775 	.word	0x00011775
   11ad0:	00011365 	.word	0x00011365
   11ad4:	000114ad 	.word	0x000114ad
   11ad8:	00011441 	.word	0x00011441
   11adc:	000113c5 	.word	0x000113c5
   11ae0:	00011489 	.word	0x00011489

00011ae4 <_i2c_m_async_transfer>:
{
   11ae4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	ASSERT(i2c_dev);
   11ae8:	4604      	mov	r4, r0
   11aea:	3800      	subs	r0, #0
   11aec:	4e3c      	ldr	r6, [pc, #240]	; (11be0 <_i2c_m_async_transfer+0xfc>)
{
   11aee:	460d      	mov	r5, r1
	ASSERT(i2c_dev);
   11af0:	bf18      	it	ne
   11af2:	2001      	movne	r0, #1
   11af4:	493b      	ldr	r1, [pc, #236]	; (11be4 <_i2c_m_async_transfer+0x100>)
   11af6:	f240 5229 	movw	r2, #1321	; 0x529
   11afa:	47b0      	blx	r6
	ASSERT(i2c_dev->hw);
   11afc:	6920      	ldr	r0, [r4, #16]
   11afe:	4939      	ldr	r1, [pc, #228]	; (11be4 <_i2c_m_async_transfer+0x100>)
   11b00:	3800      	subs	r0, #0
   11b02:	f240 522a 	movw	r2, #1322	; 0x52a
   11b06:	bf18      	it	ne
   11b08:	2001      	movne	r0, #1
   11b0a:	47b0      	blx	r6
	ASSERT(msg);
   11b0c:	1e28      	subs	r0, r5, #0
   11b0e:	bf18      	it	ne
   11b10:	2001      	movne	r0, #1
   11b12:	4934      	ldr	r1, [pc, #208]	; (11be4 <_i2c_m_async_transfer+0x100>)
   11b14:	f240 522b 	movw	r2, #1323	; 0x52b
   11b18:	47b0      	blx	r6
	if (msg->len == 0) {
   11b1a:	6868      	ldr	r0, [r5, #4]
   11b1c:	2800      	cmp	r0, #0
   11b1e:	d048      	beq.n	11bb2 <_i2c_m_async_transfer+0xce>
	if (i2c_dev->service.msg.flags & I2C_M_BUSY) {
   11b20:	8863      	ldrh	r3, [r4, #2]
   11b22:	05da      	lsls	r2, r3, #23
   11b24:	d458      	bmi.n	11bd8 <_i2c_m_async_transfer+0xf4>
	msg->flags |= I2C_M_BUSY;
   11b26:	886b      	ldrh	r3, [r5, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11b28:	4f2f      	ldr	r7, [pc, #188]	; (11be8 <_i2c_m_async_transfer+0x104>)
   11b2a:	b29b      	uxth	r3, r3
   11b2c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   11b30:	806b      	strh	r3, [r5, #2]
	i2c_dev->service.msg = *msg;
   11b32:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
   11b36:	e884 0007 	stmia.w	r4, {r0, r1, r2}
	hri_sercomi2cm_set_CTRLB_SMEN_bit(i2c_dev->hw);
   11b3a:	6920      	ldr	r0, [r4, #16]
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_SMEN;
   11b3c:	6843      	ldr	r3, [r0, #4]
   11b3e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
   11b42:	6043      	str	r3, [r0, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11b44:	2104      	movs	r1, #4
   11b46:	47b8      	blx	r7
	void *             hw    = i2c_dev->hw;
   11b48:	6925      	ldr	r5, [r4, #16]
	ASSERT(i2c_dev);
   11b4a:	4926      	ldr	r1, [pc, #152]	; (11be4 <_i2c_m_async_transfer+0x100>)
	tmp = ((Sercom *)hw)->I2CM.CTRLA.reg;
   11b4c:	f8d5 8000 	ldr.w	r8, [r5]
   11b50:	f240 5201 	movw	r2, #1281	; 0x501
   11b54:	2001      	movs	r0, #1
   11b56:	47b0      	blx	r6
	if (msg->len == 1 && sclsm) {
   11b58:	6863      	ldr	r3, [r4, #4]
   11b5a:	2b01      	cmp	r3, #1
	((Sercom *)hw)->I2CM.CTRLB.reg |= SERCOM_I2CM_CTRLB_ACKACT;
   11b5c:	686b      	ldr	r3, [r5, #4]
   11b5e:	d12a      	bne.n	11bb6 <_i2c_m_async_transfer+0xd2>
   11b60:	f018 6f00 	tst.w	r8, #134217728	; 0x8000000
   11b64:	d027      	beq.n	11bb6 <_i2c_m_async_transfer+0xd2>
   11b66:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11b6a:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   11b6c:	606b      	str	r3, [r5, #4]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11b6e:	2104      	movs	r1, #4
   11b70:	47b8      	blx	r7
	if (msg->addr & I2C_M_TEN) {
   11b72:	8820      	ldrh	r0, [r4, #0]
   11b74:	f410 6680 	ands.w	r6, r0, #1024	; 0x400
   11b78:	ea4f 0240 	mov.w	r2, r0, lsl #1
   11b7c:	d01e      	beq.n	11bbc <_i2c_m_async_transfer+0xd8>
		if (msg->flags & I2C_M_RD) {
   11b7e:	8863      	ldrh	r3, [r4, #2]
   11b80:	07db      	lsls	r3, r3, #31
			msg->flags |= I2C_M_TEN;
   11b82:	bf41      	itttt	mi
   11b84:	8863      	ldrhmi	r3, [r4, #2]
   11b86:	b29b      	uxthmi	r3, r3
   11b88:	f443 6380 	orrmi.w	r3, r3, #1024	; 0x400
   11b8c:	8063      	strhmi	r3, [r4, #2]
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11b8e:	2104      	movs	r1, #4
   11b90:	4628      	mov	r0, r5
   11b92:	47b8      	blx	r7
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11b94:	6a6b      	ldr	r3, [r5, #36]	; 0x24
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   11b96:	f022 0201 	bic.w	r2, r2, #1
   11b9a:	0552      	lsls	r2, r2, #21
   11b9c:	0d52      	lsrs	r2, r2, #21
   11b9e:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
   11ba2:	431a      	orrs	r2, r3
		hri_sercomi2cm_write_ADDR_reg(hw,
   11ba4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11ba8:	4628      	mov	r0, r5
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   11baa:	626a      	str	r2, [r5, #36]	; 0x24
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11bac:	2104      	movs	r1, #4
   11bae:	47b8      	blx	r7
	return ERR_NONE;
   11bb0:	2000      	movs	r0, #0
}
   11bb2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	((Sercom *)hw)->I2CM.CTRLB.reg &= ~SERCOM_I2CM_CTRLB_ACKACT;
   11bb6:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
   11bba:	e7d6      	b.n	11b6a <_i2c_m_async_transfer+0x86>
	hri_sercomi2cm_wait_for_sync(hw, SERCOM_I2CM_SYNCBUSY_SYSOP);
   11bbc:	2104      	movs	r1, #4
   11bbe:	4628      	mov	r0, r5
		                              ((msg->addr & SEVEN_ADDR_MASK) << 1) | (msg->flags & I2C_M_RD ? I2C_M_RD : 0x0)
   11bc0:	8864      	ldrh	r4, [r4, #2]
   11bc2:	47b8      	blx	r7
   11bc4:	b2a4      	uxth	r4, r4
	return ((Sercom *)hw)->I2CM.ADDR.reg;
   11bc6:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   11bc8:	b2d2      	uxtb	r2, r2
   11bca:	f004 0401 	and.w	r4, r4, #1
   11bce:	4322      	orrs	r2, r4
		                                  | (hri_sercomi2cm_read_ADDR_reg(hw) & SERCOM_I2CM_ADDR_HS));
   11bd0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
		hri_sercomi2cm_write_ADDR_reg(hw,
   11bd4:	431a      	orrs	r2, r3
	((Sercom *)hw)->I2CM.ADDR.reg = data;
   11bd6:	e7e7      	b.n	11ba8 <_i2c_m_async_transfer+0xc4>
		return ERR_BUSY;
   11bd8:	f06f 0003 	mvn.w	r0, #3
   11bdc:	e7e9      	b.n	11bb2 <_i2c_m_async_transfer+0xce>
   11bde:	bf00      	nop
   11be0:	0000e9b9 	.word	0x0000e9b9
   11be4:	00017211 	.word	0x00017211
   11be8:	0001123d 	.word	0x0001123d

00011bec <_i2c_m_async_register_callback>:
	switch (type) {
   11bec:	2901      	cmp	r1, #1
   11bee:	d005      	beq.n	11bfc <_i2c_m_async_register_callback+0x10>
   11bf0:	2902      	cmp	r1, #2
   11bf2:	d005      	beq.n	11c00 <_i2c_m_async_register_callback+0x14>
   11bf4:	b901      	cbnz	r1, 11bf8 <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.error = (_i2c_error_cb_t)func;
   11bf6:	6142      	str	r2, [r0, #20]
}
   11bf8:	2000      	movs	r0, #0
   11bfa:	4770      	bx	lr
		i2c_dev->cb.tx_complete = (_i2c_complete_cb_t)func;
   11bfc:	6182      	str	r2, [r0, #24]
		break;
   11bfe:	e7fb      	b.n	11bf8 <_i2c_m_async_register_callback+0xc>
		i2c_dev->cb.rx_complete = (_i2c_complete_cb_t)func;
   11c00:	61c2      	str	r2, [r0, #28]
		break;
   11c02:	e7f9      	b.n	11bf8 <_i2c_m_async_register_callback+0xc>

00011c04 <SERCOM0_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom0_dev);
   11c04:	4b01      	ldr	r3, [pc, #4]	; (11c0c <SERCOM0_0_Handler+0x8>)
   11c06:	6818      	ldr	r0, [r3, #0]
   11c08:	4b01      	ldr	r3, [pc, #4]	; (11c10 <SERCOM0_0_Handler+0xc>)
   11c0a:	4718      	bx	r3
   11c0c:	20008d68 	.word	0x20008d68
   11c10:	000112f5 	.word	0x000112f5

00011c14 <SERCOM0_1_Handler>:
   11c14:	4b00      	ldr	r3, [pc, #0]	; (11c18 <SERCOM0_1_Handler+0x4>)
   11c16:	4718      	bx	r3
   11c18:	00011c05 	.word	0x00011c05

00011c1c <SERCOM0_2_Handler>:
   11c1c:	4b00      	ldr	r3, [pc, #0]	; (11c20 <SERCOM0_2_Handler+0x4>)
   11c1e:	4718      	bx	r3
   11c20:	00011c05 	.word	0x00011c05

00011c24 <SERCOM0_3_Handler>:
   11c24:	4b00      	ldr	r3, [pc, #0]	; (11c28 <SERCOM0_3_Handler+0x4>)
   11c26:	4718      	bx	r3
   11c28:	00011c05 	.word	0x00011c05

00011c2c <SERCOM1_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom1_dev);
   11c2c:	4b01      	ldr	r3, [pc, #4]	; (11c34 <SERCOM1_0_Handler+0x8>)
   11c2e:	6858      	ldr	r0, [r3, #4]
   11c30:	4b01      	ldr	r3, [pc, #4]	; (11c38 <SERCOM1_0_Handler+0xc>)
   11c32:	4718      	bx	r3
   11c34:	20008d68 	.word	0x20008d68
   11c38:	000112f5 	.word	0x000112f5

00011c3c <SERCOM1_1_Handler>:
   11c3c:	4b00      	ldr	r3, [pc, #0]	; (11c40 <SERCOM1_1_Handler+0x4>)
   11c3e:	4718      	bx	r3
   11c40:	00011c2d 	.word	0x00011c2d

00011c44 <SERCOM1_2_Handler>:
   11c44:	4b00      	ldr	r3, [pc, #0]	; (11c48 <SERCOM1_2_Handler+0x4>)
   11c46:	4718      	bx	r3
   11c48:	00011c2d 	.word	0x00011c2d

00011c4c <SERCOM1_3_Handler>:
   11c4c:	4b00      	ldr	r3, [pc, #0]	; (11c50 <SERCOM1_3_Handler+0x4>)
   11c4e:	4718      	bx	r3
   11c50:	00011c2d 	.word	0x00011c2d

00011c54 <SERCOM3_0_Handler>:
	_spi_handler(_sercom3_dev);
   11c54:	4b0f      	ldr	r3, [pc, #60]	; (11c94 <SERCOM3_0_Handler+0x40>)
   11c56:	6898      	ldr	r0, [r3, #8]
	void *                      hw = dev->prvt;
   11c58:	6802      	ldr	r2, [r0, #0]
	return ((Sercom *)hw)->SPI.INTFLAG.reg;
   11c5a:	7e13      	ldrb	r3, [r2, #24]
	return ((Sercom *)hw)->SPI.INTENSET.reg;
   11c5c:	7d91      	ldrb	r1, [r2, #22]
	st &= hri_sercomspi_read_INTEN_reg(hw);
   11c5e:	400b      	ands	r3, r1
	if (st & SERCOM_SPI_INTFLAG_DRE) {
   11c60:	07d9      	lsls	r1, r3, #31
   11c62:	d501      	bpl.n	11c68 <SERCOM3_0_Handler+0x14>
		dev->callbacks.tx(dev);
   11c64:	6883      	ldr	r3, [r0, #8]
		dev->callbacks.rx(dev);
   11c66:	4718      	bx	r3
	} else if (st & SERCOM_SPI_INTFLAG_RXC) {
   11c68:	0759      	lsls	r1, r3, #29
   11c6a:	d501      	bpl.n	11c70 <SERCOM3_0_Handler+0x1c>
		dev->callbacks.rx(dev);
   11c6c:	68c3      	ldr	r3, [r0, #12]
   11c6e:	e7fa      	b.n	11c66 <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_TXC) {
   11c70:	0799      	lsls	r1, r3, #30
   11c72:	d503      	bpl.n	11c7c <SERCOM3_0_Handler+0x28>
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11c74:	2302      	movs	r3, #2
   11c76:	7613      	strb	r3, [r2, #24]
		dev->callbacks.complete(dev);
   11c78:	6903      	ldr	r3, [r0, #16]
   11c7a:	e7f4      	b.n	11c66 <SERCOM3_0_Handler+0x12>
	} else if (st & SERCOM_SPI_INTFLAG_ERROR) {
   11c7c:	061b      	lsls	r3, r3, #24
   11c7e:	d507      	bpl.n	11c90 <SERCOM3_0_Handler+0x3c>
	((Sercom *)hw)->SPI.STATUS.reg = mask;
   11c80:	2304      	movs	r3, #4
   11c82:	8353      	strh	r3, [r2, #26]
	((Sercom *)hw)->SPI.INTFLAG.reg = mask;
   11c84:	2380      	movs	r3, #128	; 0x80
   11c86:	7613      	strb	r3, [r2, #24]
		dev->callbacks.err(dev, ERR_OVERFLOW);
   11c88:	f06f 0112 	mvn.w	r1, #18
   11c8c:	6943      	ldr	r3, [r0, #20]
   11c8e:	4718      	bx	r3
}
   11c90:	4770      	bx	lr
   11c92:	bf00      	nop
   11c94:	20008d68 	.word	0x20008d68

00011c98 <SERCOM3_1_Handler>:
   11c98:	4b00      	ldr	r3, [pc, #0]	; (11c9c <SERCOM3_1_Handler+0x4>)
   11c9a:	4718      	bx	r3
   11c9c:	00011c55 	.word	0x00011c55

00011ca0 <SERCOM3_2_Handler>:
   11ca0:	4b00      	ldr	r3, [pc, #0]	; (11ca4 <SERCOM3_2_Handler+0x4>)
   11ca2:	4718      	bx	r3
   11ca4:	00011c55 	.word	0x00011c55

00011ca8 <SERCOM3_3_Handler>:
   11ca8:	4b00      	ldr	r3, [pc, #0]	; (11cac <SERCOM3_3_Handler+0x4>)
   11caa:	4718      	bx	r3
   11cac:	00011c55 	.word	0x00011c55

00011cb0 <SERCOM4_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom4_dev);
   11cb0:	4b01      	ldr	r3, [pc, #4]	; (11cb8 <SERCOM4_0_Handler+0x8>)
   11cb2:	68d8      	ldr	r0, [r3, #12]
   11cb4:	4b01      	ldr	r3, [pc, #4]	; (11cbc <SERCOM4_0_Handler+0xc>)
   11cb6:	4718      	bx	r3
   11cb8:	20008d68 	.word	0x20008d68
   11cbc:	000112f5 	.word	0x000112f5

00011cc0 <SERCOM4_1_Handler>:
   11cc0:	4b00      	ldr	r3, [pc, #0]	; (11cc4 <SERCOM4_1_Handler+0x4>)
   11cc2:	4718      	bx	r3
   11cc4:	00011cb1 	.word	0x00011cb1

00011cc8 <SERCOM4_2_Handler>:
   11cc8:	4b00      	ldr	r3, [pc, #0]	; (11ccc <SERCOM4_2_Handler+0x4>)
   11cca:	4718      	bx	r3
   11ccc:	00011cb1 	.word	0x00011cb1

00011cd0 <SERCOM4_3_Handler>:
   11cd0:	4b00      	ldr	r3, [pc, #0]	; (11cd4 <SERCOM4_3_Handler+0x4>)
   11cd2:	4718      	bx	r3
   11cd4:	00011cb1 	.word	0x00011cb1

00011cd8 <SERCOM5_0_Handler>:
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   11cd8:	4b1f      	ldr	r3, [pc, #124]	; (11d58 <SERCOM5_0_Handler+0x80>)
	ASSERT(i2c_dev);
   11cda:	4920      	ldr	r1, [pc, #128]	; (11d5c <SERCOM5_0_Handler+0x84>)
{
   11cdc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	_sercom_i2c_m_irq_handler(_sercom5_dev);
   11ce0:	691c      	ldr	r4, [r3, #16]
	ASSERT(i2c_dev);
   11ce2:	4f1f      	ldr	r7, [pc, #124]	; (11d60 <SERCOM5_0_Handler+0x88>)
	void *   hw    = i2c_dev->hw;
   11ce4:	6926      	ldr	r6, [r4, #16]
	ASSERT(i2c_dev);
   11ce6:	f240 425f 	movw	r2, #1119	; 0x45f
   11cea:	2001      	movs	r0, #1
	return ((Sercom *)hw)->I2CM.INTFLAG.reg;
   11cec:	7e35      	ldrb	r5, [r6, #24]
   11cee:	47b8      	blx	r7
	ASSERT(i2c_dev->hw);
   11cf0:	6920      	ldr	r0, [r4, #16]
   11cf2:	491a      	ldr	r1, [pc, #104]	; (11d5c <SERCOM5_0_Handler+0x84>)
   11cf4:	3800      	subs	r0, #0
   11cf6:	bf18      	it	ne
   11cf8:	2001      	movne	r0, #1
   11cfa:	b2ed      	uxtb	r5, r5
   11cfc:	f44f 628c 	mov.w	r2, #1120	; 0x460
   11d00:	47b8      	blx	r7
	while (!(flags & ERROR_FLAG)) {
   11d02:	0629      	lsls	r1, r5, #24
   11d04:	d415      	bmi.n	11d32 <SERCOM5_0_Handler+0x5a>
		ret = _sercom_i2c_sync_analyse_flags(hw, flags, &i2c_dev->service.msg);
   11d06:	4629      	mov	r1, r5
   11d08:	4b16      	ldr	r3, [pc, #88]	; (11d64 <SERCOM5_0_Handler+0x8c>)
   11d0a:	4622      	mov	r2, r4
   11d0c:	4630      	mov	r0, r6
   11d0e:	4798      	blx	r3
		if (ret != 0) {
   11d10:	4601      	mov	r1, r0
   11d12:	b978      	cbnz	r0, 11d34 <SERCOM5_0_Handler+0x5c>
		if ((flags & MB_FLAG) && i2c_dev->cb.tx_complete) {
   11d14:	07ea      	lsls	r2, r5, #31
   11d16:	d505      	bpl.n	11d24 <SERCOM5_0_Handler+0x4c>
   11d18:	69a3      	ldr	r3, [r4, #24]
   11d1a:	b11b      	cbz	r3, 11d24 <SERCOM5_0_Handler+0x4c>
			i2c_dev->cb.rx_complete(i2c_dev);
   11d1c:	4620      	mov	r0, r4
}
   11d1e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			i2c_dev->cb.rx_complete(i2c_dev);
   11d22:	4718      	bx	r3
		} else if ((flags & SB_FLAG) && i2c_dev->cb.rx_complete) {
   11d24:	07ab      	lsls	r3, r5, #30
   11d26:	d502      	bpl.n	11d2e <SERCOM5_0_Handler+0x56>
   11d28:	69e3      	ldr	r3, [r4, #28]
   11d2a:	2b00      	cmp	r3, #0
   11d2c:	d1f6      	bne.n	11d1c <SERCOM5_0_Handler+0x44>
}
   11d2e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	int32_t  ret   = I2C_OK;
   11d32:	2100      	movs	r1, #0
	i2c_dev->service.msg.flags &= ~I2C_M_BUSY;
   11d34:	8863      	ldrh	r3, [r4, #2]
   11d36:	f423 7380 	bic.w	r3, r3, #256	; 0x100
   11d3a:	041b      	lsls	r3, r3, #16
   11d3c:	0c1b      	lsrs	r3, r3, #16
   11d3e:	8063      	strh	r3, [r4, #2]
	if (i2c_dev->cb.error) {
   11d40:	6963      	ldr	r3, [r4, #20]
   11d42:	2b00      	cmp	r3, #0
   11d44:	d0f3      	beq.n	11d2e <SERCOM5_0_Handler+0x56>
		if (ret != I2C_OK) {
   11d46:	b121      	cbz	r1, 11d52 <SERCOM5_0_Handler+0x7a>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   11d48:	4620      	mov	r0, r4
   11d4a:	4798      	blx	r3
	((Sercom *)hw)->I2CM.INTFLAG.reg = mask;
   11d4c:	2380      	movs	r3, #128	; 0x80
   11d4e:	7633      	strb	r3, [r6, #24]
}
   11d50:	e7ed      	b.n	11d2e <SERCOM5_0_Handler+0x56>
			i2c_dev->cb.error(i2c_dev, I2C_ERR_BUS);
   11d52:	f06f 0104 	mvn.w	r1, #4
   11d56:	e7f7      	b.n	11d48 <SERCOM5_0_Handler+0x70>
   11d58:	20008d68 	.word	0x20008d68
   11d5c:	00017211 	.word	0x00017211
   11d60:	0000e9b9 	.word	0x0000e9b9
   11d64:	00011509 	.word	0x00011509

00011d68 <SERCOM5_1_Handler>:
   11d68:	4b00      	ldr	r3, [pc, #0]	; (11d6c <SERCOM5_1_Handler+0x4>)
   11d6a:	4718      	bx	r3
   11d6c:	00011cd9 	.word	0x00011cd9

00011d70 <SERCOM5_2_Handler>:
   11d70:	4b00      	ldr	r3, [pc, #0]	; (11d74 <SERCOM5_2_Handler+0x4>)
   11d72:	4718      	bx	r3
   11d74:	00011cd9 	.word	0x00011cd9

00011d78 <SERCOM5_3_Handler>:
   11d78:	4b00      	ldr	r3, [pc, #0]	; (11d7c <SERCOM5_3_Handler+0x4>)
   11d7a:	4718      	bx	r3
   11d7c:	00011cd9 	.word	0x00011cd9

00011d80 <SERCOM6_0_Handler>:
	_sercom_usart_interrupt_handler(_sercom6_dev);
   11d80:	4b01      	ldr	r3, [pc, #4]	; (11d88 <SERCOM6_0_Handler+0x8>)
   11d82:	6958      	ldr	r0, [r3, #20]
   11d84:	4b01      	ldr	r3, [pc, #4]	; (11d8c <SERCOM6_0_Handler+0xc>)
   11d86:	4718      	bx	r3
   11d88:	20008d68 	.word	0x20008d68
   11d8c:	000112f5 	.word	0x000112f5

00011d90 <SERCOM6_1_Handler>:
   11d90:	4b00      	ldr	r3, [pc, #0]	; (11d94 <SERCOM6_1_Handler+0x4>)
   11d92:	4718      	bx	r3
   11d94:	00011d81 	.word	0x00011d81

00011d98 <SERCOM6_2_Handler>:
   11d98:	4b00      	ldr	r3, [pc, #0]	; (11d9c <SERCOM6_2_Handler+0x4>)
   11d9a:	4718      	bx	r3
   11d9c:	00011d81 	.word	0x00011d81

00011da0 <SERCOM6_3_Handler>:
   11da0:	4b00      	ldr	r3, [pc, #0]	; (11da4 <SERCOM6_3_Handler+0x4>)
   11da2:	4718      	bx	r3
   11da4:	00011d81 	.word	0x00011d81

00011da8 <_spi_m_sync_init>:
{
   11da8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11dac:	4b37      	ldr	r3, [pc, #220]	; (11e8c <_spi_m_sync_init+0xe4>)
{
   11dae:	4606      	mov	r6, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11db0:	4608      	mov	r0, r1
{
   11db2:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   11db4:	4798      	blx	r3
   11db6:	4605      	mov	r5, r0
	ASSERT(dev && hw);
   11db8:	2e00      	cmp	r6, #0
   11dba:	d05d      	beq.n	11e78 <_spi_m_sync_init+0xd0>
   11dbc:	1e20      	subs	r0, r4, #0
   11dbe:	bf18      	it	ne
   11dc0:	2001      	movne	r0, #1
   11dc2:	4f33      	ldr	r7, [pc, #204]	; (11e90 <_spi_m_sync_init+0xe8>)
   11dc4:	4933      	ldr	r1, [pc, #204]	; (11e94 <_spi_m_sync_init+0xec>)
   11dc6:	f640 2278 	movw	r2, #2680	; 0xa78
   11dca:	47b8      	blx	r7
	if (regs == NULL) {
   11dcc:	46b9      	mov	r9, r7
   11dce:	2d00      	cmp	r5, #0
   11dd0:	d058      	beq.n	11e84 <_spi_m_sync_init+0xdc>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11dd2:	69e3      	ldr	r3, [r4, #28]
   11dd4:	4f30      	ldr	r7, [pc, #192]	; (11e98 <_spi_m_sync_init+0xf0>)
	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   11dd6:	f013 0f01 	tst.w	r3, #1
   11dda:	d113      	bne.n	11e04 <_spi_m_sync_init+0x5c>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11ddc:	2103      	movs	r1, #3
   11dde:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11de0:	f8d5 8000 	ldr.w	r8, [r5]
   11de4:	47b8      	blx	r7
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   11de6:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11de8:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   11dea:	f008 081c 	and.w	r8, r8, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   11dee:	d503      	bpl.n	11df8 <_spi_m_sync_init+0x50>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   11df0:	4b2a      	ldr	r3, [pc, #168]	; (11e9c <_spi_m_sync_init+0xf4>)
   11df2:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   11df4:	2102      	movs	r1, #2
   11df6:	47b8      	blx	r7
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   11df8:	f048 0301 	orr.w	r3, r8, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11dfc:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11dfe:	2103      	movs	r1, #3
   11e00:	4620      	mov	r0, r4
   11e02:	47b8      	blx	r7
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   11e04:	2101      	movs	r1, #1
   11e06:	4620      	mov	r0, r4
   11e08:	47b8      	blx	r7
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   11e0a:	682b      	ldr	r3, [r5, #0]
	dev->prvt = hw;
   11e0c:	6034      	str	r4, [r6, #0]
	if ((regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk) == SERCOM_USART_CTRLA_MODE_SPI_SLAVE) {
   11e0e:	f003 031c 	and.w	r3, r3, #28
   11e12:	2b08      	cmp	r3, #8
   11e14:	d132      	bne.n	11e7c <_spi_m_sync_init+0xd4>
	ASSERT(hw && regs);
   11e16:	f640 128e 	movw	r2, #2446	; 0x98e
   11e1a:	491e      	ldr	r1, [pc, #120]	; (11e94 <_spi_m_sync_init+0xec>)
   11e1c:	2001      	movs	r0, #1
   11e1e:	47c8      	blx	r9
	    hw, regs->ctrla & ~(SERCOM_SPI_CTRLA_IBON | SERCOM_SPI_CTRLA_ENABLE | SERCOM_SPI_CTRLA_SWRST));
   11e20:	682b      	ldr	r3, [r5, #0]
	hri_sercomspi_write_CTRLA_reg(
   11e22:	f423 7381 	bic.w	r3, r3, #258	; 0x102
   11e26:	f023 0301 	bic.w	r3, r3, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   11e2a:	6023      	str	r3, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   11e2c:	2103      	movs	r1, #3
   11e2e:	4620      	mov	r0, r4
   11e30:	47b8      	blx	r7
	                              (regs->ctrlb & ~(SERCOM_SPI_CTRLB_MSSEN))
   11e32:	686b      	ldr	r3, [r5, #4]
	                                  | (SERCOM_SPI_CTRLB_RXEN | SERCOM_SPI_CTRLB_SSDE | SERCOM_SPI_CTRLB_PLOADEN));
   11e34:	f423 3308 	bic.w	r3, r3, #139264	; 0x22000
   11e38:	f423 7310 	bic.w	r3, r3, #576	; 0x240
	hri_sercomspi_write_CTRLB_reg(hw,
   11e3c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   11e40:	f443 7310 	orr.w	r3, r3, #576	; 0x240
	((Sercom *)hw)->SPI.CTRLB.reg = data;
   11e44:	6063      	str	r3, [r4, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   11e46:	2117      	movs	r1, #23
   11e48:	47b8      	blx	r7
	hri_sercomspi_write_ADDR_reg(hw, regs->addr);
   11e4a:	68ab      	ldr	r3, [r5, #8]
	((Sercom *)hw)->SPI.ADDR.reg = data;
   11e4c:	6263      	str	r3, [r4, #36]	; 0x24
	hri_sercomspi_write_DBGCTRL_reg(hw, regs->dbgctrl);
   11e4e:	7b6b      	ldrb	r3, [r5, #13]
	((Sercom *)hw)->SPI.DBGCTRL.reg = data;
   11e50:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   11e54:	69e3      	ldr	r3, [r4, #28]
	while (hri_sercomspi_is_syncing(hw, 0xFFFFFFFF))
   11e56:	2b00      	cmp	r3, #0
   11e58:	d1fc      	bne.n	11e54 <_spi_m_sync_init+0xac>
	dev->char_size = ((regs->ctrlb & SERCOM_SPI_CTRLB_CHSIZE_Msk) == 0) ? 1 : 2;
   11e5a:	686b      	ldr	r3, [r5, #4]
   11e5c:	f013 0f07 	tst.w	r3, #7
   11e60:	bf0c      	ite	eq
   11e62:	2301      	moveq	r3, #1
   11e64:	2302      	movne	r3, #2
   11e66:	7133      	strb	r3, [r6, #4]
	dev->dummy_byte = regs->dummy_byte;
   11e68:	7bab      	ldrb	r3, [r5, #14]
   11e6a:	7bea      	ldrb	r2, [r5, #15]
   11e6c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
   11e70:	80f3      	strh	r3, [r6, #6]
	return ERR_NONE;
   11e72:	2000      	movs	r0, #0
}
   11e74:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	ASSERT(dev && hw);
   11e78:	4630      	mov	r0, r6
   11e7a:	e7a2      	b.n	11dc2 <_spi_m_sync_init+0x1a>
		_spi_load_regs_master(hw, regs);
   11e7c:	4b08      	ldr	r3, [pc, #32]	; (11ea0 <_spi_m_sync_init+0xf8>)
   11e7e:	4629      	mov	r1, r5
   11e80:	4798      	blx	r3
   11e82:	e7ea      	b.n	11e5a <_spi_m_sync_init+0xb2>
		return ERR_INVALID_ARG;
   11e84:	f06f 000c 	mvn.w	r0, #12
   11e88:	e7f4      	b.n	11e74 <_spi_m_sync_init+0xcc>
   11e8a:	bf00      	nop
   11e8c:	00011401 	.word	0x00011401
   11e90:	0000e9b9 	.word	0x0000e9b9
   11e94:	00017211 	.word	0x00017211
   11e98:	00011245 	.word	0x00011245
   11e9c:	00011269 	.word	0x00011269
   11ea0:	0001171d 	.word	0x0001171d

00011ea4 <_spi_m_async_init>:
{
   11ea4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11ea6:	4b10      	ldr	r3, [pc, #64]	; (11ee8 <_spi_m_async_init+0x44>)
{
   11ea8:	4605      	mov	r5, r0
   11eaa:	460e      	mov	r6, r1
	int32_t rc = _spi_m_sync_init((struct _spi_m_sync_dev *)dev, hw);
   11eac:	4798      	blx	r3
	if (rc < 0) {
   11eae:	2800      	cmp	r0, #0
   11eb0:	db17      	blt.n	11ee2 <_spi_m_async_init+0x3e>
	_sercom_init_irq_param(hw, (void *)dev);
   11eb2:	4629      	mov	r1, r5
	spid->callbacks.complete = NULL;
   11eb4:	2400      	movs	r4, #0
	_sercom_init_irq_param(hw, (void *)dev);
   11eb6:	4630      	mov	r0, r6
   11eb8:	4b0c      	ldr	r3, [pc, #48]	; (11eec <_spi_m_async_init+0x48>)
		NVIC_DisableIRQ((IRQn_Type)irq);
   11eba:	4e0d      	ldr	r6, [pc, #52]	; (11ef0 <_spi_m_async_init+0x4c>)
	_sercom_init_irq_param(hw, (void *)dev);
   11ebc:	4798      	blx	r3
	spid->callbacks.rx       = NULL;
   11ebe:	e9c5 4403 	strd	r4, r4, [r5, #12]
	spid->callbacks.tx       = NULL;
   11ec2:	60ac      	str	r4, [r5, #8]
	uint8_t irq              = _sercom_get_irq_num(hw);
   11ec4:	4b0b      	ldr	r3, [pc, #44]	; (11ef4 <_spi_m_async_init+0x50>)
   11ec6:	4798      	blx	r3
	for (uint32_t i = 0; i < 4; i++) {
   11ec8:	4621      	mov	r1, r4
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11eca:	4c0b      	ldr	r4, [pc, #44]	; (11ef8 <_spi_m_async_init+0x54>)
	uint8_t irq              = _sercom_get_irq_num(hw);
   11ecc:	4605      	mov	r5, r0
		NVIC_DisableIRQ((IRQn_Type)irq);
   11ece:	186b      	adds	r3, r5, r1
   11ed0:	b2d8      	uxtb	r0, r3
   11ed2:	9001      	str	r0, [sp, #4]
   11ed4:	47b0      	blx	r6
		NVIC_ClearPendingIRQ((IRQn_Type)irq);
   11ed6:	9801      	ldr	r0, [sp, #4]
   11ed8:	47a0      	blx	r4
	for (uint32_t i = 0; i < 4; i++) {
   11eda:	3101      	adds	r1, #1
   11edc:	2904      	cmp	r1, #4
   11ede:	d1f6      	bne.n	11ece <_spi_m_async_init+0x2a>
   11ee0:	2000      	movs	r0, #0
}
   11ee2:	b002      	add	sp, #8
   11ee4:	bd70      	pop	{r4, r5, r6, pc}
   11ee6:	bf00      	nop
   11ee8:	00011da9 	.word	0x00011da9
   11eec:	00011365 	.word	0x00011365
   11ef0:	00011489 	.word	0x00011489
   11ef4:	000113c5 	.word	0x000113c5
   11ef8:	000114ad 	.word	0x000114ad

00011efc <_spi_m_async_enable>:
{
   11efc:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   11efe:	4604      	mov	r4, r0
   11f00:	b118      	cbz	r0, 11f0a <_spi_m_async_enable+0xe>
   11f02:	6800      	ldr	r0, [r0, #0]
   11f04:	3800      	subs	r0, #0
   11f06:	bf18      	it	ne
   11f08:	2001      	movne	r0, #1
   11f0a:	4b05      	ldr	r3, [pc, #20]	; (11f20 <_spi_m_async_enable+0x24>)
   11f0c:	4905      	ldr	r1, [pc, #20]	; (11f24 <_spi_m_async_enable+0x28>)
   11f0e:	f640 22e5 	movw	r2, #2789	; 0xae5
   11f12:	4798      	blx	r3
	return _spi_async_enable(dev->prvt);
   11f14:	6820      	ldr	r0, [r4, #0]
   11f16:	4b04      	ldr	r3, [pc, #16]	; (11f28 <_spi_m_async_enable+0x2c>)
}
   11f18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_async_enable(dev->prvt);
   11f1c:	4718      	bx	r3
   11f1e:	bf00      	nop
   11f20:	0000e9b9 	.word	0x0000e9b9
   11f24:	00017211 	.word	0x00017211
   11f28:	00011459 	.word	0x00011459

00011f2c <_spi_m_async_set_mode>:
{
   11f2c:	b570      	push	{r4, r5, r6, lr}
   11f2e:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11f30:	4604      	mov	r4, r0
   11f32:	b118      	cbz	r0, 11f3c <_spi_m_async_set_mode+0x10>
   11f34:	6800      	ldr	r0, [r0, #0]
   11f36:	3800      	subs	r0, #0
   11f38:	bf18      	it	ne
   11f3a:	2001      	movne	r0, #1
   11f3c:	4905      	ldr	r1, [pc, #20]	; (11f54 <_spi_m_async_set_mode+0x28>)
   11f3e:	4b06      	ldr	r3, [pc, #24]	; (11f58 <_spi_m_async_set_mode+0x2c>)
   11f40:	f640 3216 	movw	r2, #2838	; 0xb16
   11f44:	4798      	blx	r3
	return _spi_set_mode(dev->prvt, mode);
   11f46:	6820      	ldr	r0, [r4, #0]
   11f48:	4b04      	ldr	r3, [pc, #16]	; (11f5c <_spi_m_async_set_mode+0x30>)
   11f4a:	4629      	mov	r1, r5
}
   11f4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _spi_set_mode(dev->prvt, mode);
   11f50:	4718      	bx	r3
   11f52:	bf00      	nop
   11f54:	00017211 	.word	0x00017211
   11f58:	0000e9b9 	.word	0x0000e9b9
   11f5c:	000116e9 	.word	0x000116e9

00011f60 <_spi_m_async_set_baudrate>:
{
   11f60:	b538      	push	{r3, r4, r5, lr}
   11f62:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   11f64:	4604      	mov	r4, r0
   11f66:	b118      	cbz	r0, 11f70 <_spi_m_async_set_baudrate+0x10>
   11f68:	6800      	ldr	r0, [r0, #0]
   11f6a:	3800      	subs	r0, #0
   11f6c:	bf18      	it	ne
   11f6e:	2001      	movne	r0, #1
   11f70:	4907      	ldr	r1, [pc, #28]	; (11f90 <_spi_m_async_set_baudrate+0x30>)
   11f72:	4b08      	ldr	r3, [pc, #32]	; (11f94 <_spi_m_async_set_baudrate+0x34>)
   11f74:	f640 3245 	movw	r2, #2885	; 0xb45
   11f78:	4798      	blx	r3
	return _spi_set_baudrate(dev->prvt, baud_val);
   11f7a:	6823      	ldr	r3, [r4, #0]
   11f7c:	69d8      	ldr	r0, [r3, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   11f7e:	f010 0001 	ands.w	r0, r0, #1
	hri_sercomspi_write_BAUD_reg(hw, baud_val);
   11f82:	bf06      	itte	eq
   11f84:	b2ed      	uxtbeq	r5, r5
	((Sercom *)hw)->SPI.BAUD.reg = data;
   11f86:	731d      	strbeq	r5, [r3, #12]
		return ERR_BUSY;
   11f88:	f06f 0003 	mvnne.w	r0, #3
}
   11f8c:	bd38      	pop	{r3, r4, r5, pc}
   11f8e:	bf00      	nop
   11f90:	00017211 	.word	0x00017211
   11f94:	0000e9b9 	.word	0x0000e9b9

00011f98 <_spi_m_async_enable_tx>:
{
   11f98:	b538      	push	{r3, r4, r5, lr}
	void *hw = dev->prvt;
   11f9a:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev && hw);
   11f9c:	4b07      	ldr	r3, [pc, #28]	; (11fbc <_spi_m_async_enable_tx+0x24>)
   11f9e:	1e20      	subs	r0, r4, #0
{
   11fa0:	460d      	mov	r5, r1
	ASSERT(dev && hw);
   11fa2:	f640 4208 	movw	r2, #3080	; 0xc08
   11fa6:	4906      	ldr	r1, [pc, #24]	; (11fc0 <_spi_m_async_enable_tx+0x28>)
   11fa8:	bf18      	it	ne
   11faa:	2001      	movne	r0, #1
   11fac:	4798      	blx	r3
	if (state) {
   11fae:	2301      	movs	r3, #1
   11fb0:	b115      	cbz	r5, 11fb8 <_spi_m_async_enable_tx+0x20>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_DRE;
   11fb2:	75a3      	strb	r3, [r4, #22]
}
   11fb4:	2000      	movs	r0, #0
   11fb6:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_DRE;
   11fb8:	7523      	strb	r3, [r4, #20]
}
   11fba:	e7fb      	b.n	11fb4 <_spi_m_async_enable_tx+0x1c>
   11fbc:	0000e9b9 	.word	0x0000e9b9
   11fc0:	00017211 	.word	0x00017211

00011fc4 <_spi_m_async_enable_rx>:
{
   11fc4:	b570      	push	{r4, r5, r6, lr}
	void *hw = dev->prvt;
   11fc6:	6804      	ldr	r4, [r0, #0]
	ASSERT(dev);
   11fc8:	4e0a      	ldr	r6, [pc, #40]	; (11ff4 <_spi_m_async_enable_rx+0x30>)
   11fca:	f640 421c 	movw	r2, #3100	; 0xc1c
   11fce:	2001      	movs	r0, #1
{
   11fd0:	460d      	mov	r5, r1
	ASSERT(dev);
   11fd2:	4909      	ldr	r1, [pc, #36]	; (11ff8 <_spi_m_async_enable_rx+0x34>)
   11fd4:	47b0      	blx	r6
	ASSERT(hw);
   11fd6:	1e20      	subs	r0, r4, #0
   11fd8:	4907      	ldr	r1, [pc, #28]	; (11ff8 <_spi_m_async_enable_rx+0x34>)
   11fda:	f640 421d 	movw	r2, #3101	; 0xc1d
   11fde:	bf18      	it	ne
   11fe0:	2001      	movne	r0, #1
   11fe2:	47b0      	blx	r6
	if (state) {
   11fe4:	2304      	movs	r3, #4
   11fe6:	b115      	cbz	r5, 11fee <_spi_m_async_enable_rx+0x2a>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_RXC;
   11fe8:	75a3      	strb	r3, [r4, #22]
}
   11fea:	2000      	movs	r0, #0
   11fec:	bd70      	pop	{r4, r5, r6, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_RXC;
   11fee:	7523      	strb	r3, [r4, #20]
}
   11ff0:	e7fb      	b.n	11fea <_spi_m_async_enable_rx+0x26>
   11ff2:	bf00      	nop
   11ff4:	0000e9b9 	.word	0x0000e9b9
   11ff8:	00017211 	.word	0x00017211

00011ffc <_spi_m_async_enable_tx_complete>:
{
   11ffc:	b538      	push	{r3, r4, r5, lr}
   11ffe:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   12000:	4604      	mov	r4, r0
   12002:	b118      	cbz	r0, 1200c <_spi_m_async_enable_tx_complete+0x10>
   12004:	6800      	ldr	r0, [r0, #0]
   12006:	3800      	subs	r0, #0
   12008:	bf18      	it	ne
   1200a:	2001      	movne	r0, #1
   1200c:	4b06      	ldr	r3, [pc, #24]	; (12028 <_spi_m_async_enable_tx_complete+0x2c>)
   1200e:	4907      	ldr	r1, [pc, #28]	; (1202c <_spi_m_async_enable_tx_complete+0x30>)
   12010:	f640 422f 	movw	r2, #3119	; 0xc2f
   12014:	4798      	blx	r3
	if (state) {
   12016:	6823      	ldr	r3, [r4, #0]
   12018:	2202      	movs	r2, #2
   1201a:	b115      	cbz	r5, 12022 <_spi_m_async_enable_tx_complete+0x26>
	((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_TXC;
   1201c:	759a      	strb	r2, [r3, #22]
}
   1201e:	2000      	movs	r0, #0
   12020:	bd38      	pop	{r3, r4, r5, pc}
	((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_TXC;
   12022:	751a      	strb	r2, [r3, #20]
}
   12024:	e7fb      	b.n	1201e <_spi_m_async_enable_tx_complete+0x22>
   12026:	bf00      	nop
   12028:	0000e9b9 	.word	0x0000e9b9
   1202c:	00017211 	.word	0x00017211

00012030 <_spi_m_async_write_one>:
{
   12030:	b538      	push	{r3, r4, r5, lr}
   12032:	460d      	mov	r5, r1
	ASSERT(dev && dev->prvt);
   12034:	4604      	mov	r4, r0
   12036:	b118      	cbz	r0, 12040 <_spi_m_async_write_one+0x10>
   12038:	6800      	ldr	r0, [r0, #0]
   1203a:	3800      	subs	r0, #0
   1203c:	bf18      	it	ne
   1203e:	2001      	movne	r0, #1
   12040:	4904      	ldr	r1, [pc, #16]	; (12054 <_spi_m_async_write_one+0x24>)
   12042:	4b05      	ldr	r3, [pc, #20]	; (12058 <_spi_m_async_write_one+0x28>)
   12044:	f640 4241 	movw	r2, #3137	; 0xc41
   12048:	4798      	blx	r3
	hri_sercomspi_write_DATA_reg(dev->prvt, data);
   1204a:	6823      	ldr	r3, [r4, #0]
}
   1204c:	2000      	movs	r0, #0
	((Sercom *)hw)->SPI.DATA.reg = data;
   1204e:	629d      	str	r5, [r3, #40]	; 0x28
   12050:	bd38      	pop	{r3, r4, r5, pc}
   12052:	bf00      	nop
   12054:	00017211 	.word	0x00017211
   12058:	0000e9b9 	.word	0x0000e9b9

0001205c <_spi_m_async_read_one>:
{
   1205c:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   1205e:	4604      	mov	r4, r0
   12060:	b118      	cbz	r0, 1206a <_spi_m_async_read_one+0xe>
   12062:	6800      	ldr	r0, [r0, #0]
   12064:	3800      	subs	r0, #0
   12066:	bf18      	it	ne
   12068:	2001      	movne	r0, #1
   1206a:	4904      	ldr	r1, [pc, #16]	; (1207c <_spi_m_async_read_one+0x20>)
   1206c:	4b04      	ldr	r3, [pc, #16]	; (12080 <_spi_m_async_read_one+0x24>)
   1206e:	f640 425c 	movw	r2, #3164	; 0xc5c
   12072:	4798      	blx	r3
	return hri_sercomspi_read_DATA_reg(dev->prvt);
   12074:	6823      	ldr	r3, [r4, #0]
	return ((Sercom *)hw)->SPI.DATA.reg;
   12076:	6a98      	ldr	r0, [r3, #40]	; 0x28
}
   12078:	b280      	uxth	r0, r0
   1207a:	bd10      	pop	{r4, pc}
   1207c:	00017211 	.word	0x00017211
   12080:	0000e9b9 	.word	0x0000e9b9

00012084 <_spi_m_async_register_callback>:
{
   12084:	b570      	push	{r4, r5, r6, lr}
   12086:	460d      	mov	r5, r1
   12088:	4616      	mov	r6, r2
	ASSERT(dev && (cb_type < SPI_DEV_CB_N));
   1208a:	4604      	mov	r4, r0
   1208c:	b118      	cbz	r0, 12096 <_spi_m_async_register_callback+0x12>
   1208e:	2903      	cmp	r1, #3
   12090:	bf8c      	ite	hi
   12092:	2000      	movhi	r0, #0
   12094:	2001      	movls	r0, #1
   12096:	4905      	ldr	r1, [pc, #20]	; (120ac <_spi_m_async_register_callback+0x28>)
   12098:	4b05      	ldr	r3, [pc, #20]	; (120b0 <_spi_m_async_register_callback+0x2c>)
   1209a:	f640 4275 	movw	r2, #3189	; 0xc75
   1209e:	4798      	blx	r3
	p_ls[cb_type] = (func_t)func;
   120a0:	eb04 0185 	add.w	r1, r4, r5, lsl #2
}
   120a4:	2000      	movs	r0, #0
	p_ls[cb_type] = (func_t)func;
   120a6:	608e      	str	r6, [r1, #8]
}
   120a8:	bd70      	pop	{r4, r5, r6, pc}
   120aa:	bf00      	nop
   120ac:	00017211 	.word	0x00017211
   120b0:	0000e9b9 	.word	0x0000e9b9

000120b4 <_spi_m_async_set_irq_state>:
{
   120b4:	b570      	push	{r4, r5, r6, lr}
	ASSERT(device);
   120b6:	4604      	mov	r4, r0
   120b8:	3800      	subs	r0, #0
{
   120ba:	460e      	mov	r6, r1
	ASSERT(device);
   120bc:	bf18      	it	ne
   120be:	2001      	movne	r0, #1
   120c0:	4907      	ldr	r1, [pc, #28]	; (120e0 <_spi_m_async_set_irq_state+0x2c>)
   120c2:	4b08      	ldr	r3, [pc, #32]	; (120e4 <_spi_m_async_set_irq_state+0x30>)
{
   120c4:	4615      	mov	r5, r2
	ASSERT(device);
   120c6:	f640 42b6 	movw	r2, #3254	; 0xcb6
   120ca:	4798      	blx	r3
	if (SPI_DEV_CB_ERROR == type) {
   120cc:	2e03      	cmp	r6, #3
   120ce:	d103      	bne.n	120d8 <_spi_m_async_set_irq_state+0x24>
		hri_sercomspi_write_INTEN_ERROR_bit(device->prvt, state);
   120d0:	6823      	ldr	r3, [r4, #0]
	if (value == 0x0) {
   120d2:	2280      	movs	r2, #128	; 0x80
   120d4:	b90d      	cbnz	r5, 120da <_spi_m_async_set_irq_state+0x26>
		((Sercom *)hw)->SPI.INTENCLR.reg = SERCOM_SPI_INTENSET_ERROR;
   120d6:	751a      	strb	r2, [r3, #20]
}
   120d8:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->SPI.INTENSET.reg = SERCOM_SPI_INTENSET_ERROR;
   120da:	759a      	strb	r2, [r3, #22]
   120dc:	e7fc      	b.n	120d8 <_spi_m_async_set_irq_state+0x24>
   120de:	bf00      	nop
   120e0:	00017211 	.word	0x00017211
   120e4:	0000e9b9 	.word	0x0000e9b9

000120e8 <_spi_m_dma_init>:

int32_t _spi_m_dma_init(struct _spi_m_dma_dev *dev, void *const hw)
{
   120e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   120ec:	4b25      	ldr	r3, [pc, #148]	; (12184 <_spi_m_dma_init+0x9c>)
{
   120ee:	4605      	mov	r5, r0
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   120f0:	4608      	mov	r0, r1
{
   120f2:	460c      	mov	r4, r1
	const struct sercomspi_regs_cfg *regs = _spi_get_regs((uint32_t)hw);
   120f4:	4798      	blx	r3
   120f6:	4606      	mov	r6, r0

	ASSERT(dev && hw);
   120f8:	2d00      	cmp	r5, #0
   120fa:	d03e      	beq.n	1217a <_spi_m_dma_init+0x92>
   120fc:	1e20      	subs	r0, r4, #0
   120fe:	bf18      	it	ne
   12100:	2001      	movne	r0, #1
   12102:	4921      	ldr	r1, [pc, #132]	; (12188 <_spi_m_dma_init+0xa0>)
   12104:	4b21      	ldr	r3, [pc, #132]	; (1218c <_spi_m_dma_init+0xa4>)
   12106:	f640 52e3 	movw	r2, #3555	; 0xde3
   1210a:	4798      	blx	r3

	if (regs == NULL) {
   1210c:	2e00      	cmp	r6, #0
   1210e:	d036      	beq.n	1217e <_spi_m_dma_init+0x96>
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   12110:	69e3      	ldr	r3, [r4, #28]
   12112:	f8df 8094 	ldr.w	r8, [pc, #148]	; 121a8 <_spi_m_dma_init+0xc0>
		return ERR_INVALID_ARG;
	}

	if (!hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_SWRST)) {
   12116:	f013 0f01 	tst.w	r3, #1
   1211a:	d112      	bne.n	12142 <_spi_m_dma_init+0x5a>
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1211c:	2103      	movs	r1, #3
   1211e:	4620      	mov	r0, r4
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   12120:	6837      	ldr	r7, [r6, #0]
   12122:	47c0      	blx	r8
	tmp = ((Sercom *)hw)->SPI.CTRLA.reg;
   12124:	6823      	ldr	r3, [r4, #0]
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   12126:	079b      	lsls	r3, r3, #30
		uint32_t mode = regs->ctrla & SERCOM_SPI_CTRLA_MODE_Msk;
   12128:	f007 071c 	and.w	r7, r7, #28
		if (hri_sercomspi_get_CTRLA_reg(hw, SERCOM_SPI_CTRLA_ENABLE)) {
   1212c:	d503      	bpl.n	12136 <_spi_m_dma_init+0x4e>
			hri_sercomspi_clear_CTRLA_ENABLE_bit(hw);
   1212e:	4b18      	ldr	r3, [pc, #96]	; (12190 <_spi_m_dma_init+0xa8>)
   12130:	4798      	blx	r3
			hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_ENABLE);
   12132:	2102      	movs	r1, #2
   12134:	47c0      	blx	r8
		}
		hri_sercomspi_write_CTRLA_reg(hw, SERCOM_SPI_CTRLA_SWRST | mode);
   12136:	f047 0701 	orr.w	r7, r7, #1
	((Sercom *)hw)->SPI.CTRLA.reg = data;
   1213a:	6027      	str	r7, [r4, #0]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST | SERCOM_SPI_SYNCBUSY_ENABLE);
   1213c:	2103      	movs	r1, #3
   1213e:	4620      	mov	r0, r4
   12140:	47c0      	blx	r8
	}
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);

	dev->prvt = hw;
   12142:	462f      	mov	r7, r5
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_SWRST);
   12144:	4620      	mov	r0, r4
   12146:	2101      	movs	r1, #1
   12148:	47c0      	blx	r8

	_spi_load_regs_master(hw, regs);
   1214a:	4631      	mov	r1, r6
	dev->prvt = hw;
   1214c:	f847 4b18 	str.w	r4, [r7], #24
	_spi_load_regs_master(hw, regs);
   12150:	4b10      	ldr	r3, [pc, #64]	; (12194 <_spi_m_dma_init+0xac>)
   12152:	4798      	blx	r3
	uint8_t index = _sercom_get_hardware_index(hw);
   12154:	4b10      	ldr	r3, [pc, #64]	; (12198 <_spi_m_dma_init+0xb0>)
   12156:	4620      	mov	r0, r4
   12158:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   1215a:	2807      	cmp	r0, #7
		dev->resource->back                 = dev;
		dev->resource->dma_cb.transfer_done = _spi_dma_rx_complete;
		dev->resource->dma_cb.error         = _spi_dma_error_occured;
	}
	/* Initialize DMA tx channel */
	_dma_get_channel_resource(&dev->resource, _spi_get_tx_dma_channel(hw));
   1215c:	4b0f      	ldr	r3, [pc, #60]	; (1219c <_spi_m_dma_init+0xb4>)
   1215e:	bf0c      	ite	eq
   12160:	2108      	moveq	r1, #8
   12162:	2100      	movne	r1, #0
   12164:	4638      	mov	r0, r7
   12166:	4798      	blx	r3
	dev->resource->back                 = dev;
   12168:	69ab      	ldr	r3, [r5, #24]
	dev->resource->dma_cb.transfer_done = _spi_dma_tx_complete;
   1216a:	4a0d      	ldr	r2, [pc, #52]	; (121a0 <_spi_m_dma_init+0xb8>)
   1216c:	601a      	str	r2, [r3, #0]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   1216e:	4a0d      	ldr	r2, [pc, #52]	; (121a4 <_spi_m_dma_init+0xbc>)
	dev->resource->back                 = dev;
   12170:	609d      	str	r5, [r3, #8]
	dev->resource->dma_cb.error         = _spi_dma_error_occured;
   12172:	605a      	str	r2, [r3, #4]

	return ERR_NONE;
   12174:	2000      	movs	r0, #0
}
   12176:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	ASSERT(dev && hw);
   1217a:	4628      	mov	r0, r5
   1217c:	e7c1      	b.n	12102 <_spi_m_dma_init+0x1a>
		return ERR_INVALID_ARG;
   1217e:	f06f 000c 	mvn.w	r0, #12
   12182:	e7f8      	b.n	12176 <_spi_m_dma_init+0x8e>
   12184:	00011401 	.word	0x00011401
   12188:	00017211 	.word	0x00017211
   1218c:	0000e9b9 	.word	0x0000e9b9
   12190:	00011269 	.word	0x00011269
   12194:	0001171d 	.word	0x0001171d
   12198:	000112bd 	.word	0x000112bd
   1219c:	0000ebfd 	.word	0x0000ebfd
   121a0:	0001142d 	.word	0x0001142d
   121a4:	00011437 	.word	0x00011437
   121a8:	00011245 	.word	0x00011245

000121ac <_spi_m_dma_enable>:
{
	return _spi_deinit(dev->prvt);
}

int32_t _spi_m_dma_enable(struct _spi_m_dma_dev *dev)
{
   121ac:	b510      	push	{r4, lr}
	ASSERT(dev && dev->prvt);
   121ae:	4604      	mov	r4, r0
   121b0:	b118      	cbz	r0, 121ba <_spi_m_dma_enable+0xe>
   121b2:	6800      	ldr	r0, [r0, #0]
   121b4:	3800      	subs	r0, #0
   121b6:	bf18      	it	ne
   121b8:	2001      	movne	r0, #1
   121ba:	4b05      	ldr	r3, [pc, #20]	; (121d0 <_spi_m_dma_enable+0x24>)
   121bc:	4905      	ldr	r1, [pc, #20]	; (121d4 <_spi_m_dma_enable+0x28>)
   121be:	f640 620e 	movw	r2, #3598	; 0xe0e
   121c2:	4798      	blx	r3

	return _spi_sync_enable(dev->prvt);
   121c4:	6820      	ldr	r0, [r4, #0]
   121c6:	4b04      	ldr	r3, [pc, #16]	; (121d8 <_spi_m_dma_enable+0x2c>)
}
   121c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return _spi_sync_enable(dev->prvt);
   121cc:	4718      	bx	r3
   121ce:	bf00      	nop
   121d0:	0000e9b9 	.word	0x0000e9b9
   121d4:	00017211 	.word	0x00017211
   121d8:	000113d9 	.word	0x000113d9

000121dc <_spi_m_dma_register_callback>:
	return size;
}

void _spi_m_dma_register_callback(struct _spi_m_dma_dev *dev, enum _spi_dma_dev_cb_type type, _spi_dma_cb_t func)
{
	switch (type) {
   121dc:	2901      	cmp	r1, #1
{
   121de:	b573      	push	{r0, r1, r4, r5, r6, lr}
   121e0:	4605      	mov	r5, r0
   121e2:	460e      	mov	r6, r1
   121e4:	4614      	mov	r4, r2
	switch (type) {
   121e6:	d014      	beq.n	12212 <_spi_m_dma_register_callback+0x36>
   121e8:	2902      	cmp	r1, #2
   121ea:	d020      	beq.n	1222e <_spi_m_dma_register_callback+0x52>
   121ec:	2900      	cmp	r1, #0
   121ee:	d138      	bne.n	12262 <_spi_m_dma_register_callback+0x86>
	case SPI_DEV_CB_DMA_TX:
		dev->callbacks.tx = func;
   121f0:	6042      	str	r2, [r0, #4]
	uint8_t index = _sercom_get_hardware_index(hw);
   121f2:	4b1d      	ldr	r3, [pc, #116]	; (12268 <_spi_m_dma_register_callback+0x8c>)
   121f4:	6800      	ldr	r0, [r0, #0]
   121f6:	4798      	blx	r3
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   121f8:	2807      	cmp	r0, #7
   121fa:	bf08      	it	eq
   121fc:	2608      	moveq	r6, #8
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   121fe:	1e22      	subs	r2, r4, #0
   12200:	bf18      	it	ne
   12202:	2201      	movne	r2, #1
   12204:	2100      	movs	r1, #0
   12206:	4630      	mov	r0, r6
		break;
	case SPI_DEV_CB_DMA_RX:
		dev->callbacks.rx = func;
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   12208:	4b18      	ldr	r3, [pc, #96]	; (1226c <_spi_m_dma_register_callback+0x90>)
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
		break;
	case SPI_DEV_CB_DMA_N:
		break;
	}
}
   1220a:	b002      	add	sp, #8
   1220c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   12210:	4718      	bx	r3
		dev->callbacks.rx = func;
   12212:	6082      	str	r2, [r0, #8]
	uint8_t index = _sercom_get_hardware_index(hw);
   12214:	4b14      	ldr	r3, [pc, #80]	; (12268 <_spi_m_dma_register_callback+0x8c>)
   12216:	6800      	ldr	r0, [r0, #0]
   12218:	4798      	blx	r3
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_COMPLETE_CB, func != NULL);
   1221a:	1e22      	subs	r2, r4, #0
   1221c:	bf18      	it	ne
   1221e:	2201      	movne	r2, #1
   12220:	2807      	cmp	r0, #7
   12222:	f04f 0100 	mov.w	r1, #0
   12226:	bf8c      	ite	hi
   12228:	2000      	movhi	r0, #0
   1222a:	2001      	movls	r0, #1
   1222c:	e7ec      	b.n	12208 <_spi_m_dma_register_callback+0x2c>
		dev->callbacks.error = func;
   1222e:	60c2      	str	r2, [r0, #12]
	uint8_t index = _sercom_get_hardware_index(hw);
   12230:	4e0d      	ldr	r6, [pc, #52]	; (12268 <_spi_m_dma_register_callback+0x8c>)
   12232:	6800      	ldr	r0, [r0, #0]
   12234:	47b0      	blx	r6
		_dma_set_irq_state(_spi_get_rx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   12236:	1e22      	subs	r2, r4, #0
   12238:	bf18      	it	ne
   1223a:	2201      	movne	r2, #1
   1223c:	2807      	cmp	r0, #7
   1223e:	bf8c      	ite	hi
   12240:	2000      	movhi	r0, #0
   12242:	2001      	movls	r0, #1
   12244:	2101      	movs	r1, #1
   12246:	4c09      	ldr	r4, [pc, #36]	; (1226c <_spi_m_dma_register_callback+0x90>)
   12248:	9201      	str	r2, [sp, #4]
   1224a:	47a0      	blx	r4
	uint8_t index = _sercom_get_hardware_index(hw);
   1224c:	6828      	ldr	r0, [r5, #0]
   1224e:	47b0      	blx	r6
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   12250:	2807      	cmp	r0, #7
		_dma_set_irq_state(_spi_get_tx_dma_channel(dev->prvt), DMA_TRANSFER_ERROR_CB, func != NULL);
   12252:	9a01      	ldr	r2, [sp, #4]
   12254:	f04f 0101 	mov.w	r1, #1
   12258:	bf0c      	ite	eq
   1225a:	2008      	moveq	r0, #8
   1225c:	2000      	movne	r0, #0
   1225e:	4623      	mov	r3, r4
   12260:	e7d3      	b.n	1220a <_spi_m_dma_register_callback+0x2e>
}
   12262:	b002      	add	sp, #8
   12264:	bd70      	pop	{r4, r5, r6, pc}
   12266:	bf00      	nop
   12268:	000112bd 	.word	0x000112bd
   1226c:	0000eb19 	.word	0x0000eb19

00012270 <_spi_m_dma_transfer>:

int32_t _spi_m_dma_transfer(struct _spi_m_dma_dev *dev, uint8_t const *txbuf, uint8_t *const rxbuf,
                            const uint16_t length)
{
   12270:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   12274:	f8d0 8000 	ldr.w	r8, [r0]
	uint8_t index = _sercom_get_hardware_index(hw);
   12278:	f8df 911c 	ldr.w	r9, [pc, #284]	; 12398 <_spi_m_dma_transfer+0x128>
{
   1227c:	4605      	mov	r5, r0
   1227e:	461f      	mov	r7, r3
	uint8_t index = _sercom_get_hardware_index(hw);
   12280:	4640      	mov	r0, r8
   12282:	4b3d      	ldr	r3, [pc, #244]	; (12378 <_spi_m_dma_transfer+0x108>)
{
   12284:	460e      	mov	r6, r1
   12286:	4692      	mov	sl, r2
	uint8_t index = _sercom_get_hardware_index(hw);
   12288:	4798      	blx	r3
	switch (index) {
   1228a:	2807      	cmp	r0, #7
   1228c:	4b3b      	ldr	r3, [pc, #236]	; (1237c <_spi_m_dma_transfer+0x10c>)
   1228e:	d86a      	bhi.n	12366 <_spi_m_dma_transfer+0xf6>
	switch (index) {
   12290:	d06c      	beq.n	1236c <_spi_m_dma_transfer+0xfc>
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   12292:	f04f 0b01 	mov.w	fp, #1
	uint8_t                          rx_ch = _spi_get_rx_dma_channel(dev->prvt);
	uint8_t                          tx_ch = _spi_get_tx_dma_channel(dev->prvt);

	if (rxbuf) {
   12296:	f1ba 0f00 	cmp.w	sl, #0
   1229a:	d114      	bne.n	122c6 <_spi_m_dma_transfer+0x56>
   1229c:	4654      	mov	r4, sl
	ASSERT(dev && dev->prvt);
   1229e:	f1b8 0000 	subs.w	r0, r8, #0
   122a2:	bf18      	it	ne
   122a4:	2001      	movne	r0, #1
   122a6:	4936      	ldr	r1, [pc, #216]	; (12380 <_spi_m_dma_transfer+0x110>)
   122a8:	f640 523d 	movw	r2, #3389	; 0xd3d
   122ac:	4798      	blx	r3
	return _spi_sync_rx_disable(dev->prvt);
   122ae:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   122b0:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   122b2:	075b      	lsls	r3, r3, #29
   122b4:	d42b      	bmi.n	1230e <_spi_m_dma_transfer+0x9e>
	((Sercom *)hw)->SPI.CTRLB.reg &= ~SERCOM_SPI_CTRLB_RXEN;
   122b6:	6843      	ldr	r3, [r0, #4]
   122b8:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
   122bc:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   122be:	2117      	movs	r1, #23
   122c0:	4b30      	ldr	r3, [pc, #192]	; (12384 <_spi_m_dma_transfer+0x114>)
   122c2:	4798      	blx	r3
}
   122c4:	e023      	b.n	1230e <_spi_m_dma_transfer+0x9e>
	if (rxbuf) {
   122c6:	2400      	movs	r4, #0
	ASSERT(dev && dev->prvt);
   122c8:	f1b8 0000 	subs.w	r0, r8, #0
   122cc:	bf18      	it	ne
   122ce:	2001      	movne	r0, #1
   122d0:	f640 5236 	movw	r2, #3382	; 0xd36
   122d4:	492a      	ldr	r1, [pc, #168]	; (12380 <_spi_m_dma_transfer+0x110>)
   122d6:	4798      	blx	r3
	return _spi_sync_rx_enable(dev->prvt);
   122d8:	6828      	ldr	r0, [r5, #0]
	return ((Sercom *)hw)->SPI.SYNCBUSY.reg & reg;
   122da:	69c3      	ldr	r3, [r0, #28]
	if (hri_sercomspi_is_syncing(hw, SERCOM_SPI_SYNCBUSY_CTRLB)) {
   122dc:	075a      	lsls	r2, r3, #29
   122de:	d406      	bmi.n	122ee <_spi_m_dma_transfer+0x7e>
	((Sercom *)hw)->SPI.CTRLB.reg |= SERCOM_SPI_CTRLB_RXEN;
   122e0:	6843      	ldr	r3, [r0, #4]
   122e2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   122e6:	6043      	str	r3, [r0, #4]
	hri_sercomspi_wait_for_sync(hw, SERCOM_SPI_SYNCBUSY_MASK);
   122e8:	2117      	movs	r1, #23
   122ea:	4b26      	ldr	r3, [pc, #152]	; (12384 <_spi_m_dma_transfer+0x114>)
   122ec:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   122ee:	6829      	ldr	r1, [r5, #0]
		/* Enable spi rx */
		_spi_m_dma_rx_enable(dev);
		_dma_set_source_address(rx_ch, (void *)_spi_m_get_source_for_dma(dev->prvt));
   122f0:	4b25      	ldr	r3, [pc, #148]	; (12388 <_spi_m_dma_transfer+0x118>)
   122f2:	3128      	adds	r1, #40	; 0x28
   122f4:	4658      	mov	r0, fp
   122f6:	4798      	blx	r3
		_dma_set_destination_address(rx_ch, rxbuf);
   122f8:	4651      	mov	r1, sl
   122fa:	4658      	mov	r0, fp
   122fc:	47c8      	blx	r9
		_dma_set_data_amount(rx_ch, length);
   122fe:	4b23      	ldr	r3, [pc, #140]	; (1238c <_spi_m_dma_transfer+0x11c>)
   12300:	4639      	mov	r1, r7
   12302:	4658      	mov	r0, fp
   12304:	4798      	blx	r3
		_dma_enable_transaction(rx_ch, false);
   12306:	4b22      	ldr	r3, [pc, #136]	; (12390 <_spi_m_dma_transfer+0x120>)
   12308:	2100      	movs	r1, #0
   1230a:	4658      	mov	r0, fp
   1230c:	4798      	blx	r3
	} else {
		/* Disable spi rx */
		_spi_m_dma_rx_disable(dev);
	}

	if (txbuf) {
   1230e:	f8df a07c 	ldr.w	sl, [pc, #124]	; 1238c <_spi_m_dma_transfer+0x11c>
   12312:	f8df b088 	ldr.w	fp, [pc, #136]	; 1239c <_spi_m_dma_transfer+0x12c>
   12316:	b1c6      	cbz	r6, 1234a <_spi_m_dma_transfer+0xda>
		/* Enable spi tx */
		_dma_set_source_address(tx_ch, txbuf);
   12318:	4b1b      	ldr	r3, [pc, #108]	; (12388 <_spi_m_dma_transfer+0x118>)
   1231a:	4631      	mov	r1, r6
   1231c:	4620      	mov	r0, r4
   1231e:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   12320:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   12322:	4620      	mov	r0, r4
   12324:	3128      	adds	r1, #40	; 0x28
   12326:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, true);
   12328:	2101      	movs	r1, #1
		_dma_set_data_amount(tx_ch, length);
	} else {
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
		_dma_srcinc_enable(tx_ch, false);
   1232a:	4620      	mov	r0, r4
   1232c:	47d8      	blx	fp
		_dma_set_data_amount(tx_ch, length);
   1232e:	4639      	mov	r1, r7
   12330:	4620      	mov	r0, r4
   12332:	47d0      	blx	sl
	}
	_dma_enable_transaction(tx_ch, false);
   12334:	4b16      	ldr	r3, [pc, #88]	; (12390 <_spi_m_dma_transfer+0x120>)
   12336:	2100      	movs	r1, #0
   12338:	4620      	mov	r0, r4
   1233a:	4798      	blx	r3

	return ERR_NONE;
}
   1233c:	2000      	movs	r0, #0
   1233e:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return CONF_SERCOM_0_SPI_M_DMA_RX_CHANNEL;
   12342:	f04f 0b01 	mov.w	fp, #1
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   12346:	2408      	movs	r4, #8
   12348:	e7be      	b.n	122c8 <_spi_m_dma_transfer+0x58>
	const struct sercomspi_regs_cfg *regs  = _spi_get_regs((uint32_t)dev->prvt);
   1234a:	4b12      	ldr	r3, [pc, #72]	; (12394 <_spi_m_dma_transfer+0x124>)
   1234c:	4640      	mov	r0, r8
   1234e:	4798      	blx	r3
		_dma_set_source_address(tx_ch, &regs->dummy_byte);
   12350:	4b0d      	ldr	r3, [pc, #52]	; (12388 <_spi_m_dma_transfer+0x118>)
   12352:	f100 010e 	add.w	r1, r0, #14
   12356:	4620      	mov	r0, r4
   12358:	4798      	blx	r3
	return (uint32_t) & (((Sercom *)hw)->SPI.DATA);
   1235a:	6829      	ldr	r1, [r5, #0]
		_dma_set_destination_address(tx_ch, (void *)_spi_m_get_destination_for_dma(dev->prvt));
   1235c:	4620      	mov	r0, r4
   1235e:	3128      	adds	r1, #40	; 0x28
   12360:	47c8      	blx	r9
		_dma_srcinc_enable(tx_ch, false);
   12362:	4631      	mov	r1, r6
   12364:	e7e1      	b.n	1232a <_spi_m_dma_transfer+0xba>
		return CONF_SERCOM_0_SPI_M_DMA_TX_CHANNEL;
   12366:	f04f 0b00 	mov.w	fp, #0
   1236a:	e794      	b.n	12296 <_spi_m_dma_transfer+0x26>
	if (rxbuf) {
   1236c:	f1ba 0f00 	cmp.w	sl, #0
   12370:	d1e7      	bne.n	12342 <_spi_m_dma_transfer+0xd2>
		return CONF_SERCOM_7_SPI_M_DMA_TX_CHANNEL;
   12372:	2408      	movs	r4, #8
   12374:	e793      	b.n	1229e <_spi_m_dma_transfer+0x2e>
   12376:	bf00      	nop
   12378:	000112bd 	.word	0x000112bd
   1237c:	0000e9b9 	.word	0x0000e9b9
   12380:	00017211 	.word	0x00017211
   12384:	00011245 	.word	0x00011245
   12388:	0000eb51 	.word	0x0000eb51
   1238c:	0000eb7d 	.word	0x0000eb7d
   12390:	0000ebc1 	.word	0x0000ebc1
   12394:	00011401 	.word	0x00011401
   12398:	0000eb41 	.word	0x0000eb41
   1239c:	0000eb61 	.word	0x0000eb61

000123a0 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
   123a0:	b570      	push	{r4, r5, r6, lr}
   123a2:	460e      	mov	r6, r1
   123a4:	4614      	mov	r4, r2
	ASSERT(rb && buf && size);
   123a6:	4605      	mov	r5, r0
   123a8:	b118      	cbz	r0, 123b2 <ringbuffer_init+0x12>
   123aa:	b189      	cbz	r1, 123d0 <ringbuffer_init+0x30>
   123ac:	1e10      	subs	r0, r2, #0
   123ae:	bf18      	it	ne
   123b0:	2001      	movne	r0, #1
   123b2:	4908      	ldr	r1, [pc, #32]	; (123d4 <ringbuffer_init+0x34>)
   123b4:	4b08      	ldr	r3, [pc, #32]	; (123d8 <ringbuffer_init+0x38>)
   123b6:	2228      	movs	r2, #40	; 0x28
   123b8:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
   123ba:	1e63      	subs	r3, r4, #1
   123bc:	ea13 0004 	ands.w	r0, r3, r4
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
	rb->read_index  = 0;
   123c0:	bf03      	ittte	eq
   123c2:	e9c5 3001 	strdeq	r3, r0, [r5, #4]
	rb->write_index = rb->read_index;
   123c6:	60e8      	streq	r0, [r5, #12]
	rb->buf         = (uint8_t *)buf;
   123c8:	602e      	streq	r6, [r5, #0]
		return ERR_INVALID_ARG;
   123ca:	f06f 000c 	mvnne.w	r0, #12

	return ERR_NONE;
}
   123ce:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
   123d0:	4608      	mov	r0, r1
   123d2:	e7ee      	b.n	123b2 <ringbuffer_init+0x12>
   123d4:	00017300 	.word	0x00017300
   123d8:	0000e9b9 	.word	0x0000e9b9

000123dc <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
   123dc:	b538      	push	{r3, r4, r5, lr}
   123de:	460d      	mov	r5, r1
	ASSERT(rb && data);
   123e0:	4604      	mov	r4, r0
   123e2:	b110      	cbz	r0, 123ea <ringbuffer_get+0xe>
   123e4:	1e08      	subs	r0, r1, #0
   123e6:	bf18      	it	ne
   123e8:	2001      	movne	r0, #1
   123ea:	4b0a      	ldr	r3, [pc, #40]	; (12414 <ringbuffer_get+0x38>)
   123ec:	490a      	ldr	r1, [pc, #40]	; (12418 <ringbuffer_get+0x3c>)
   123ee:	2240      	movs	r2, #64	; 0x40
   123f0:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
   123f2:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
   123f6:	429a      	cmp	r2, r3
   123f8:	d009      	beq.n	1240e <ringbuffer_get+0x32>
		*data = rb->buf[rb->read_index & rb->size];
   123fa:	6862      	ldr	r2, [r4, #4]
   123fc:	4013      	ands	r3, r2
   123fe:	6822      	ldr	r2, [r4, #0]
   12400:	5cd3      	ldrb	r3, [r2, r3]
   12402:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
   12404:	68a3      	ldr	r3, [r4, #8]
   12406:	3301      	adds	r3, #1
   12408:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
   1240a:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
   1240c:	bd38      	pop	{r3, r4, r5, pc}
	return ERR_NOT_FOUND;
   1240e:	f06f 0009 	mvn.w	r0, #9
   12412:	e7fb      	b.n	1240c <ringbuffer_get+0x30>
   12414:	0000e9b9 	.word	0x0000e9b9
   12418:	00017300 	.word	0x00017300

0001241c <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
   1241c:	b538      	push	{r3, r4, r5, lr}
	ASSERT(rb);
   1241e:	4604      	mov	r4, r0
   12420:	3800      	subs	r0, #0
   12422:	bf18      	it	ne
   12424:	2001      	movne	r0, #1
{
   12426:	460d      	mov	r5, r1
	ASSERT(rb);
   12428:	4b0b      	ldr	r3, [pc, #44]	; (12458 <ringbuffer_put+0x3c>)
   1242a:	490c      	ldr	r1, [pc, #48]	; (1245c <ringbuffer_put+0x40>)
   1242c:	2251      	movs	r2, #81	; 0x51
   1242e:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
   12430:	68e3      	ldr	r3, [r4, #12]
   12432:	6862      	ldr	r2, [r4, #4]
   12434:	4013      	ands	r3, r2
   12436:	6822      	ldr	r2, [r4, #0]
   12438:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
   1243a:	e9d4 2101 	ldrd	r2, r1, [r4, #4]
   1243e:	68e3      	ldr	r3, [r4, #12]
   12440:	1a59      	subs	r1, r3, r1
   12442:	4291      	cmp	r1, r2
		rb->read_index = rb->write_index - rb->size;
   12444:	bf88      	it	hi
   12446:	1a9a      	subhi	r2, r3, r2
	}

	rb->write_index++;
   12448:	f103 0301 	add.w	r3, r3, #1
		rb->read_index = rb->write_index - rb->size;
   1244c:	bf88      	it	hi
   1244e:	60a2      	strhi	r2, [r4, #8]
	rb->write_index++;
   12450:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
   12452:	2000      	movs	r0, #0
   12454:	bd38      	pop	{r3, r4, r5, pc}
   12456:	bf00      	nop
   12458:	0000e9b9 	.word	0x0000e9b9
   1245c:	00017300 	.word	0x00017300

00012460 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
   12460:	b510      	push	{r4, lr}
	ASSERT(rb);
   12462:	4604      	mov	r4, r0
   12464:	3800      	subs	r0, #0
   12466:	bf18      	it	ne
   12468:	2001      	movne	r0, #1
   1246a:	4904      	ldr	r1, [pc, #16]	; (1247c <ringbuffer_num+0x1c>)
   1246c:	4b04      	ldr	r3, [pc, #16]	; (12480 <ringbuffer_num+0x20>)
   1246e:	2267      	movs	r2, #103	; 0x67
   12470:	4798      	blx	r3

	return rb->write_index - rb->read_index;
   12472:	e9d4 3002 	ldrd	r3, r0, [r4, #8]
}
   12476:	1ac0      	subs	r0, r0, r3
   12478:	bd10      	pop	{r4, pc}
   1247a:	bf00      	nop
   1247c:	00017300 	.word	0x00017300
   12480:	0000e9b9 	.word	0x0000e9b9

00012484 <atomic_enter_critical>:
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   12484:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
   12488:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   1248a:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   1248c:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
   12490:	4770      	bx	lr

00012492 <atomic_leave_critical>:
   12492:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
   12496:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
   12498:	f383 8810 	msr	PRIMASK, r3
}
   1249c:	4770      	bx	lr
	...

000124a0 <RTC_Scheduler_ping_cb>:
static struct timer_task RTC_Scheduler_heartbeat;

void RTC_Scheduler_ping_cb(const struct timer_task *const timer_task)
{

	pingflag++;
   124a0:	4a0d      	ldr	r2, [pc, #52]	; (124d8 <RTC_Scheduler_ping_cb+0x38>)
   124a2:	7813      	ldrb	r3, [r2, #0]
   124a4:	3301      	adds	r3, #1
   124a6:	b2db      	uxtb	r3, r3
   124a8:	7013      	strb	r3, [r2, #0]
	
	switch (pingflag%4)
   124aa:	7813      	ldrb	r3, [r2, #0]
   124ac:	f003 0303 	and.w	r3, r3, #3
   124b0:	2b02      	cmp	r3, #2
   124b2:	f642 7248 	movw	r2, #12104	; 0x2f48
   124b6:	d00a      	beq.n	124ce <RTC_Scheduler_ping_cb+0x2e>
   124b8:	2b03      	cmp	r3, #3
   124ba:	d00a      	beq.n	124d2 <RTC_Scheduler_ping_cb+0x32>
   124bc:	2b01      	cmp	r3, #1
   124be:	d003      	beq.n	124c8 <RTC_Scheduler_ping_cb+0x28>
	{
		case 0:
			GRID_PORT_N.ping_flag = 1;
   124c0:	4b06      	ldr	r3, [pc, #24]	; (124dc <RTC_Scheduler_ping_cb+0x3c>)
			break;
		case 2:
			GRID_PORT_S.ping_flag = 1;
			break;
		case 3:
			GRID_PORT_W.ping_flag = 1;
   124c2:	2101      	movs	r1, #1
   124c4:	5499      	strb	r1, [r3, r2]
			break;
	}
	
}
   124c6:	4770      	bx	lr
			GRID_PORT_E.ping_flag = 1;
   124c8:	4905      	ldr	r1, [pc, #20]	; (124e0 <RTC_Scheduler_ping_cb+0x40>)
   124ca:	548b      	strb	r3, [r1, r2]
			break;
   124cc:	4770      	bx	lr
			GRID_PORT_S.ping_flag = 1;
   124ce:	4b05      	ldr	r3, [pc, #20]	; (124e4 <RTC_Scheduler_ping_cb+0x44>)
   124d0:	e7f7      	b.n	124c2 <RTC_Scheduler_ping_cb+0x22>
			GRID_PORT_W.ping_flag = 1;
   124d2:	4b05      	ldr	r3, [pc, #20]	; (124e8 <RTC_Scheduler_ping_cb+0x48>)
   124d4:	e7f5      	b.n	124c2 <RTC_Scheduler_ping_cb+0x22>
   124d6:	bf00      	nop
   124d8:	20008d80 	.word	0x20008d80
   124dc:	20009150 	.word	0x20009150
   124e0:	20019870 	.word	0x20019870
   124e4:	200138d4 	.word	0x200138d4
   124e8:	200102d4 	.word	0x200102d4

000124ec <RTC_Scheduler_heartbeat_cb>:
	}

}

void RTC_Scheduler_heartbeat_cb(const struct timer_task *const timer_task)
{
   124ec:	b410      	push	{r4}
	
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   124ee:	4c04      	ldr	r4, [pc, #16]	; (12500 <RTC_Scheduler_heartbeat_cb+0x14>)
   124f0:	4804      	ldr	r0, [pc, #16]	; (12504 <RTC_Scheduler_heartbeat_cb+0x18>)
   124f2:	2200      	movs	r2, #0
   124f4:	46a4      	mov	ip, r4
   124f6:	230c      	movs	r3, #12

}
   124f8:	f85d 4b04 	ldr.w	r4, [sp], #4
	grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_HEARTBEAT);
   124fc:	4611      	mov	r1, r2
   124fe:	4760      	bx	ip
   12500:	0000aaa1 	.word	0x0000aaa1
   12504:	2001c7c0 	.word	0x2001c7c0

00012508 <example_task>:
{
   12508:	b507      	push	{r0, r1, r2, lr}
		CRITICAL_SECTION_ENTER()
   1250a:	4e08      	ldr	r6, [pc, #32]	; (1252c <example_task+0x24>)
		printf("ExampleTask ????... %d \r\n", globaltest);
   1250c:	4d08      	ldr	r5, [pc, #32]	; (12530 <example_task+0x28>)
   1250e:	4c09      	ldr	r4, [pc, #36]	; (12534 <example_task+0x2c>)
		CRITICAL_SECTION_ENTER()
   12510:	a801      	add	r0, sp, #4
   12512:	47b0      	blx	r6
		printf("ExampleTask ????... %d \r\n", globaltest);
   12514:	6869      	ldr	r1, [r5, #4]
   12516:	4b08      	ldr	r3, [pc, #32]	; (12538 <example_task+0x30>)
   12518:	4620      	mov	r0, r4
   1251a:	4798      	blx	r3
		CRITICAL_SECTION_LEAVE()
   1251c:	a801      	add	r0, sp, #4
   1251e:	4b07      	ldr	r3, [pc, #28]	; (1253c <example_task+0x34>)
   12520:	4798      	blx	r3
		vTaskDelay(1000*configTICK_RATE_HZ/1000);
   12522:	4b07      	ldr	r3, [pc, #28]	; (12540 <example_task+0x38>)
   12524:	f241 3088 	movw	r0, #5000	; 0x1388
   12528:	4798      	blx	r3
	while (1) {
   1252a:	e7f1      	b.n	12510 <example_task+0x8>
   1252c:	00012485 	.word	0x00012485
   12530:	20008d80 	.word	0x20008d80
   12534:	00017324 	.word	0x00017324
   12538:	00014eb1 	.word	0x00014eb1
   1253c:	00012493 	.word	0x00012493
   12540:	000133fd 	.word	0x000133fd

00012544 <inbound_task>:
static void inbound_task(void *p){
   12544:	b508      	push	{r3, lr}
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12546:	4c02      	ldr	r4, [pc, #8]	; (12550 <inbound_task+0xc>)
   12548:	2005      	movs	r0, #5
   1254a:	47a0      	blx	r4
	while (1) {
   1254c:	e7fc      	b.n	12548 <inbound_task+0x4>
   1254e:	bf00      	nop
   12550:	000133fd 	.word	0x000133fd

00012554 <usb_task_inner>:
static void usb_task_inner(){
   12554:	b570      	push	{r4, r5, r6, lr}
	grid_keyboard_tx_pop();
   12556:	4b2c      	ldr	r3, [pc, #176]	; (12608 <usb_task_inner+0xb4>)
static void usb_task_inner(){
   12558:	b08a      	sub	sp, #40	; 0x28
	grid_keyboard_tx_pop();
   1255a:	4798      	blx	r3
	grid_midi_tx_pop();        
   1255c:	4b2b      	ldr	r3, [pc, #172]	; (1260c <usb_task_inner+0xb8>)
   1255e:	4798      	blx	r3
	audiodf_midi_read(midi_rx_buffer,16);
   12560:	4b2b      	ldr	r3, [pc, #172]	; (12610 <usb_task_inner+0xbc>)
   12562:	482c      	ldr	r0, [pc, #176]	; (12614 <usb_task_inner+0xc0>)
   12564:	2110      	movs	r1, #16
   12566:	4798      	blx	r3
		if (midi_rx_buffer[i]){
   12568:	492b      	ldr	r1, [pc, #172]	; (12618 <usb_task_inner+0xc4>)
	audiodf_midi_read(midi_rx_buffer,16);
   1256a:	2200      	movs	r2, #0
	uint8_t found = 0;
   1256c:	4613      	mov	r3, r2
   1256e:	460d      	mov	r5, r1
		if (midi_rx_buffer[i]){
   12570:	1888      	adds	r0, r1, r2
   12572:	7a00      	ldrb	r0, [r0, #8]
   12574:	b108      	cbz	r0, 1257a <usb_task_inner+0x26>
			found++;
   12576:	3301      	adds	r3, #1
   12578:	b2db      	uxtb	r3, r3
	for (uint8_t i=0; i<16; i++){
   1257a:	3201      	adds	r2, #1
   1257c:	2a10      	cmp	r2, #16
   1257e:	d1f7      	bne.n	12570 <usb_task_inner+0x1c>
	if (found){
   12580:	b313      	cbz	r3, 125c8 <usb_task_inner+0x74>
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   12582:	7a29      	ldrb	r1, [r5, #8]
   12584:	7a6a      	ldrb	r2, [r5, #9]
   12586:	7aab      	ldrb	r3, [r5, #10]
   12588:	7ae8      	ldrb	r0, [r5, #11]
   1258a:	4c24      	ldr	r4, [pc, #144]	; (1261c <usb_task_inner+0xc8>)
   1258c:	9000      	str	r0, [sp, #0]
   1258e:	4824      	ldr	r0, [pc, #144]	; (12620 <usb_task_inner+0xcc>)
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   12590:	4e24      	ldr	r6, [pc, #144]	; (12624 <usb_task_inner+0xd0>)
		printf("MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   12592:	47a0      	blx	r4
		uint8_t message[30] = {0};
   12594:	2400      	movs	r4, #0
   12596:	4b24      	ldr	r3, [pc, #144]	; (12628 <usb_task_inner+0xd4>)
   12598:	9402      	str	r4, [sp, #8]
   1259a:	221a      	movs	r2, #26
   1259c:	4621      	mov	r1, r4
   1259e:	a803      	add	r0, sp, #12
   125a0:	4798      	blx	r3
		sprintf(message, "MIDI: %02x %02x %02x %02x\n", midi_rx_buffer[0],midi_rx_buffer[1],midi_rx_buffer[2],midi_rx_buffer[3]);
   125a2:	7a2a      	ldrb	r2, [r5, #8]
   125a4:	7a6b      	ldrb	r3, [r5, #9]
   125a6:	7aa9      	ldrb	r1, [r5, #10]
   125a8:	7ae8      	ldrb	r0, [r5, #11]
   125aa:	e9cd 1000 	strd	r1, r0, [sp]
   125ae:	491c      	ldr	r1, [pc, #112]	; (12620 <usb_task_inner+0xcc>)
   125b0:	a802      	add	r0, sp, #8
   125b2:	47b0      	blx	r6
		grid_debug_print_text(message);
   125b4:	4b1d      	ldr	r3, [pc, #116]	; (1262c <usb_task_inner+0xd8>)
   125b6:	a802      	add	r0, sp, #8
   125b8:	4798      	blx	r3
   125ba:	4621      	mov	r1, r4
			midi_rx_buffer[i] = 0;
   125bc:	4622      	mov	r2, r4
   125be:	186b      	adds	r3, r5, r1
   125c0:	3101      	adds	r1, #1
		for (uint8_t i=0; i<16; i++){
   125c2:	2910      	cmp	r1, #16
			midi_rx_buffer[i] = 0;
   125c4:	721a      	strb	r2, [r3, #8]
		for (uint8_t i=0; i<16; i++){
   125c6:	d1fa      	bne.n	125be <usb_task_inner+0x6a>
	cdcdf_acm_read(GRID_PORT_H.rx_double_buffer, CONF_USB_COMPOSITE_CDC_ACM_DATA_BULKIN_MAXPKSZ_HS);			
   125c8:	4b19      	ldr	r3, [pc, #100]	; (12630 <usb_task_inner+0xdc>)
   125ca:	481a      	ldr	r0, [pc, #104]	; (12634 <usb_task_inner+0xe0>)
   125cc:	f44f 7100 	mov.w	r1, #512	; 0x200
   125d0:	4798      	blx	r3
	uint16_t usblength = strlen(GRID_PORT_H.rx_double_buffer);
   125d2:	4818      	ldr	r0, [pc, #96]	; (12634 <usb_task_inner+0xe0>)
   125d4:	4b18      	ldr	r3, [pc, #96]	; (12638 <usb_task_inner+0xe4>)
   125d6:	4798      	blx	r3
	if (usblength){	
   125d8:	4606      	mov	r6, r0
   125da:	b190      	cbz	r0, 12602 <usb_task_inner+0xae>
		GRID_PORT_H.rx_double_buffer_status = 1;			
   125dc:	4d17      	ldr	r5, [pc, #92]	; (1263c <usb_task_inner+0xe8>)
   125de:	2301      	movs	r3, #1
   125e0:	622b      	str	r3, [r5, #32]
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   125e2:	2400      	movs	r4, #0
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   125e4:	1ec3      	subs	r3, r0, #3
		GRID_PORT_H.rx_double_buffer_read_start_index = 0;
   125e6:	62ac      	str	r4, [r5, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_H);
   125e8:	4628      	mov	r0, r5
		GRID_PORT_H.rx_double_buffer_seek_start_index = usblength-3; //-3
   125ea:	626b      	str	r3, [r5, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_H);
   125ec:	4b14      	ldr	r3, [pc, #80]	; (12640 <usb_task_inner+0xec>)
   125ee:	4798      	blx	r3
		for(uint32_t i=0; i<usblength; i++){
   125f0:	4623      	mov	r3, r4
			GRID_PORT_H.rx_double_buffer[i] = 0;
   125f2:	f241 32b4 	movw	r2, #5044	; 0x13b4
   125f6:	4620      	mov	r0, r4
   125f8:	18e9      	adds	r1, r5, r3
		for(uint32_t i=0; i<usblength; i++){
   125fa:	3301      	adds	r3, #1
   125fc:	429e      	cmp	r6, r3
			GRID_PORT_H.rx_double_buffer[i] = 0;
   125fe:	5488      	strb	r0, [r1, r2]
		for(uint32_t i=0; i<usblength; i++){
   12600:	d1fa      	bne.n	125f8 <usb_task_inner+0xa4>
}
   12602:	b00a      	add	sp, #40	; 0x28
   12604:	bd70      	pop	{r4, r5, r6, pc}
   12606:	bf00      	nop
   12608:	0000b979 	.word	0x0000b979
   1260c:	0000b859 	.word	0x0000b859
   12610:	0000451d 	.word	0x0000451d
   12614:	20008d88 	.word	0x20008d88
   12618:	20008d80 	.word	0x20008d80
   1261c:	00014eb1 	.word	0x00014eb1
   12620:	0001733e 	.word	0x0001733e
   12624:	00015299 	.word	0x00015299
   12628:	00014d51 	.word	0x00014d51
   1262c:	00009b89 	.word	0x00009b89
   12630:	0000c685 	.word	0x0000c685
   12634:	20017bd8 	.word	0x20017bd8
   12638:	00015317 	.word	0x00015317
   1263c:	20016824 	.word	0x20016824
   12640:	00004d41 	.word	0x00004d41

00012644 <usb_task>:
{
   12644:	b508      	push	{r3, lr}
		usb_task_inner();
   12646:	4d03      	ldr	r5, [pc, #12]	; (12654 <usb_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12648:	4c03      	ldr	r4, [pc, #12]	; (12658 <usb_task+0x14>)
		usb_task_inner();
   1264a:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   1264c:	2005      	movs	r0, #5
   1264e:	47a0      	blx	r4
	while (1) {
   12650:	e7fb      	b.n	1264a <usb_task+0x6>
   12652:	bf00      	nop
   12654:	00012555 	.word	0x00012555
   12658:	000133fd 	.word	0x000133fd

0001265c <receive_task_inner>:
static void receive_task_inner(){
   1265c:	b510      	push	{r4, lr}
	grid_port_receive_task(&GRID_PORT_N);
   1265e:	4806      	ldr	r0, [pc, #24]	; (12678 <receive_task_inner+0x1c>)
   12660:	4c06      	ldr	r4, [pc, #24]	; (1267c <receive_task_inner+0x20>)
   12662:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_E);
   12664:	4806      	ldr	r0, [pc, #24]	; (12680 <receive_task_inner+0x24>)
   12666:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_S);
   12668:	4806      	ldr	r0, [pc, #24]	; (12684 <receive_task_inner+0x28>)
   1266a:	47a0      	blx	r4
	grid_port_receive_task(&GRID_PORT_W);							
   1266c:	4623      	mov	r3, r4
   1266e:	4806      	ldr	r0, [pc, #24]	; (12688 <receive_task_inner+0x2c>)
}
   12670:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_receive_task(&GRID_PORT_W);							
   12674:	4718      	bx	r3
   12676:	bf00      	nop
   12678:	20009150 	.word	0x20009150
   1267c:	00004d41 	.word	0x00004d41
   12680:	20019870 	.word	0x20019870
   12684:	200138d4 	.word	0x200138d4
   12688:	200102d4 	.word	0x200102d4

0001268c <receive_task>:
static void receive_task(void *p){
   1268c:	b508      	push	{r3, lr}
		receive_task_inner();
   1268e:	4d03      	ldr	r5, [pc, #12]	; (1269c <receive_task+0x10>)
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12690:	4c03      	ldr	r4, [pc, #12]	; (126a0 <receive_task+0x14>)
		receive_task_inner();
   12692:	47a8      	blx	r5
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   12694:	2005      	movs	r0, #5
   12696:	47a0      	blx	r4
	while (1) {
   12698:	e7fb      	b.n	12692 <receive_task+0x6>
   1269a:	bf00      	nop
   1269c:	0001265d 	.word	0x0001265d
   126a0:	000133fd 	.word	0x000133fd

000126a4 <nvm_task_inner>:
static void nvm_task_inner(){
   126a4:	b510      	push	{r4, lr}
	if (GRID_PORT_U.rx_double_buffer_status == 0){
   126a6:	4c1a      	ldr	r4, [pc, #104]	; (12710 <nvm_task_inner+0x6c>)
   126a8:	6a23      	ldr	r3, [r4, #32]
   126aa:	b943      	cbnz	r3, 126be <nvm_task_inner+0x1a>
		if (grid_nvm_ui_bulk_read_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   126ac:	4919      	ldr	r1, [pc, #100]	; (12714 <nvm_task_inner+0x70>)
   126ae:	481a      	ldr	r0, [pc, #104]	; (12718 <nvm_task_inner+0x74>)
   126b0:	4b1a      	ldr	r3, [pc, #104]	; (1271c <nvm_task_inner+0x78>)
   126b2:	4798      	blx	r3
   126b4:	b118      	cbz	r0, 126be <nvm_task_inner+0x1a>
			grid_nvm_ui_bulk_read_next(&grid_nvm_state, &grid_ui_state);
   126b6:	4917      	ldr	r1, [pc, #92]	; (12714 <nvm_task_inner+0x70>)
   126b8:	4817      	ldr	r0, [pc, #92]	; (12718 <nvm_task_inner+0x74>)
   126ba:	4b19      	ldr	r3, [pc, #100]	; (12720 <nvm_task_inner+0x7c>)
   126bc:	4798      	blx	r3
	if (grid_nvm_ui_bulk_clear_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   126be:	4915      	ldr	r1, [pc, #84]	; (12714 <nvm_task_inner+0x70>)
   126c0:	4815      	ldr	r0, [pc, #84]	; (12718 <nvm_task_inner+0x74>)
   126c2:	4b18      	ldr	r3, [pc, #96]	; (12724 <nvm_task_inner+0x80>)
   126c4:	4798      	blx	r3
   126c6:	b118      	cbz	r0, 126d0 <nvm_task_inner+0x2c>
		grid_nvm_ui_bulk_clear_next(&grid_nvm_state, &grid_ui_state);
   126c8:	4912      	ldr	r1, [pc, #72]	; (12714 <nvm_task_inner+0x70>)
   126ca:	4813      	ldr	r0, [pc, #76]	; (12718 <nvm_task_inner+0x74>)
   126cc:	4b16      	ldr	r3, [pc, #88]	; (12728 <nvm_task_inner+0x84>)
   126ce:	4798      	blx	r3
	if (grid_nvm_ui_bulk_store_is_in_progress(&grid_nvm_state, &grid_ui_state)){
   126d0:	4910      	ldr	r1, [pc, #64]	; (12714 <nvm_task_inner+0x70>)
   126d2:	4811      	ldr	r0, [pc, #68]	; (12718 <nvm_task_inner+0x74>)
   126d4:	4b15      	ldr	r3, [pc, #84]	; (1272c <nvm_task_inner+0x88>)
   126d6:	4798      	blx	r3
   126d8:	b118      	cbz	r0, 126e2 <nvm_task_inner+0x3e>
		grid_nvm_ui_bulk_store_next(&grid_nvm_state, &grid_ui_state);
   126da:	490e      	ldr	r1, [pc, #56]	; (12714 <nvm_task_inner+0x70>)
   126dc:	480e      	ldr	r0, [pc, #56]	; (12718 <nvm_task_inner+0x74>)
   126de:	4b14      	ldr	r3, [pc, #80]	; (12730 <nvm_task_inner+0x8c>)
   126e0:	4798      	blx	r3
	uint32_t nvmlength = GRID_PORT_U.rx_double_buffer_status;
   126e2:	6a23      	ldr	r3, [r4, #32]
	if (nvmlength){
   126e4:	b143      	cbz	r3, 126f8 <nvm_task_inner+0x54>
		GRID_PORT_U.rx_double_buffer_status = 1;
   126e6:	2201      	movs	r2, #1
   126e8:	6222      	str	r2, [r4, #32]
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   126ea:	3b01      	subs	r3, #1
		GRID_PORT_U.rx_double_buffer_read_start_index = 0;
   126ec:	2200      	movs	r2, #0
   126ee:	62a2      	str	r2, [r4, #40]	; 0x28
		grid_port_receive_task(&GRID_PORT_U);	
   126f0:	4807      	ldr	r0, [pc, #28]	; (12710 <nvm_task_inner+0x6c>)
		GRID_PORT_U.rx_double_buffer_seek_start_index = nvmlength-1; //-3
   126f2:	6263      	str	r3, [r4, #36]	; 0x24
		grid_port_receive_task(&GRID_PORT_U);	
   126f4:	4b0f      	ldr	r3, [pc, #60]	; (12734 <nvm_task_inner+0x90>)
   126f6:	4798      	blx	r3
static void nvm_task_inner(){
   126f8:	2300      	movs	r3, #0
		GRID_PORT_U.rx_double_buffer[i] = 0;
   126fa:	f241 32b4 	movw	r2, #5044	; 0x13b4
   126fe:	4618      	mov	r0, r3
   12700:	18e1      	adds	r1, r4, r3
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   12702:	3301      	adds	r3, #1
   12704:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
		GRID_PORT_U.rx_double_buffer[i] = 0;
   12708:	5488      	strb	r0, [r1, r2]
	for (uint32_t i=0; i<GRID_NVM_PAGE_SIZE; i++)
   1270a:	d1f9      	bne.n	12700 <nvm_task_inner+0x5c>
}
   1270c:	bd10      	pop	{r4, pc}
   1270e:	bf00      	nop
   12710:	2000c0b0 	.word	0x2000c0b0
   12714:	2000effc 	.word	0x2000effc
   12718:	2000fa1c 	.word	0x2000fa1c
   1271c:	0000913f 	.word	0x0000913f
   12720:	00009145 	.word	0x00009145
   12724:	00009417 	.word	0x00009417
   12728:	0000941d 	.word	0x0000941d
   1272c:	00009253 	.word	0x00009253
   12730:	00009259 	.word	0x00009259
   12734:	00004d41 	.word	0x00004d41

00012738 <inbound_task_inner>:
static void inbound_task_inner(){
   12738:	b510      	push	{r4, lr}
	grid_port_process_inbound(&GRID_PORT_U, 1); // Loopback
   1273a:	2101      	movs	r1, #1
   1273c:	4c0a      	ldr	r4, [pc, #40]	; (12768 <inbound_task_inner+0x30>)
   1273e:	480b      	ldr	r0, [pc, #44]	; (1276c <inbound_task_inner+0x34>)
   12740:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_N, 0);		
   12742:	2100      	movs	r1, #0
   12744:	480a      	ldr	r0, [pc, #40]	; (12770 <inbound_task_inner+0x38>)
   12746:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_E, 0);		
   12748:	2100      	movs	r1, #0
   1274a:	480a      	ldr	r0, [pc, #40]	; (12774 <inbound_task_inner+0x3c>)
   1274c:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_S, 0);
   1274e:	2100      	movs	r1, #0
   12750:	4809      	ldr	r0, [pc, #36]	; (12778 <inbound_task_inner+0x40>)
   12752:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_W, 0);
   12754:	2100      	movs	r1, #0
   12756:	4809      	ldr	r0, [pc, #36]	; (1277c <inbound_task_inner+0x44>)
   12758:	47a0      	blx	r4
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   1275a:	4623      	mov	r3, r4
   1275c:	4808      	ldr	r0, [pc, #32]	; (12780 <inbound_task_inner+0x48>)
}
   1275e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_inbound(&GRID_PORT_H, 0);	// USB	
   12762:	2100      	movs	r1, #0
   12764:	4718      	bx	r3
   12766:	bf00      	nop
   12768:	000051c1 	.word	0x000051c1
   1276c:	2000c0b0 	.word	0x2000c0b0
   12770:	20009150 	.word	0x20009150
   12774:	20019870 	.word	0x20019870
   12778:	200138d4 	.word	0x200138d4
   1277c:	200102d4 	.word	0x200102d4
   12780:	20016824 	.word	0x20016824

00012784 <outbound_task_inner>:
static void outbound_task_inner(){
   12784:	b510      	push	{r4, lr}
	grid_port_process_outbound_usart(&GRID_PORT_N);
   12786:	4808      	ldr	r0, [pc, #32]	; (127a8 <outbound_task_inner+0x24>)
   12788:	4c08      	ldr	r4, [pc, #32]	; (127ac <outbound_task_inner+0x28>)
   1278a:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_E);
   1278c:	4808      	ldr	r0, [pc, #32]	; (127b0 <outbound_task_inner+0x2c>)
   1278e:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_S);
   12790:	4808      	ldr	r0, [pc, #32]	; (127b4 <outbound_task_inner+0x30>)
   12792:	47a0      	blx	r4
	grid_port_process_outbound_usart(&GRID_PORT_W);
   12794:	4808      	ldr	r0, [pc, #32]	; (127b8 <outbound_task_inner+0x34>)
   12796:	47a0      	blx	r4
	grid_port_process_outbound_usb(&GRID_PORT_H);
   12798:	4b08      	ldr	r3, [pc, #32]	; (127bc <outbound_task_inner+0x38>)
   1279a:	4809      	ldr	r0, [pc, #36]	; (127c0 <outbound_task_inner+0x3c>)
   1279c:	4798      	blx	r3
}
   1279e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	grid_port_process_outbound_ui(&GRID_PORT_U);
   127a2:	4808      	ldr	r0, [pc, #32]	; (127c4 <outbound_task_inner+0x40>)
   127a4:	4b08      	ldr	r3, [pc, #32]	; (127c8 <outbound_task_inner+0x44>)
   127a6:	4718      	bx	r3
   127a8:	20009150 	.word	0x20009150
   127ac:	000062cd 	.word	0x000062cd
   127b0:	20019870 	.word	0x20019870
   127b4:	200138d4 	.word	0x200138d4
   127b8:	200102d4 	.word	0x200102d4
   127bc:	00005385 	.word	0x00005385
   127c0:	20016824 	.word	0x20016824
   127c4:	2000c0b0 	.word	0x2000c0b0
   127c8:	00005679 	.word	0x00005679

000127cc <led_task_inner>:
static void led_task_inner(){
   127cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (grid_sys_state.alert_state){
   127d0:	4c45      	ldr	r4, [pc, #276]	; (128e8 <led_task_inner+0x11c>)
static void led_task_inner(){
   127d2:	ed2d 8b02 	vpush	{d8}
	if (grid_sys_state.alert_state){
   127d6:	8963      	ldrh	r3, [r4, #10]
   127d8:	b29b      	uxth	r3, r3
static void led_task_inner(){
   127da:	b083      	sub	sp, #12
	if (grid_sys_state.alert_state){
   127dc:	b98b      	cbnz	r3, 12802 <led_task_inner+0x36>
	grid_task_enter_task(&grid_task_state, GRID_TASK_LED);
   127de:	2106      	movs	r1, #6
   127e0:	4b42      	ldr	r3, [pc, #264]	; (128ec <led_task_inner+0x120>)
   127e2:	4843      	ldr	r0, [pc, #268]	; (128f0 <led_task_inner+0x124>)
   127e4:	4798      	blx	r3
	grid_led_tick(&grid_led_state);
   127e6:	4843      	ldr	r0, [pc, #268]	; (128f4 <led_task_inner+0x128>)
   127e8:	4b43      	ldr	r3, [pc, #268]	; (128f8 <led_task_inner+0x12c>)
   127ea:	4798      	blx	r3
	grid_led_lowlevel_render_all(&grid_led_state);	
   127ec:	4841      	ldr	r0, [pc, #260]	; (128f4 <led_task_inner+0x128>)
   127ee:	4b43      	ldr	r3, [pc, #268]	; (128fc <led_task_inner+0x130>)
   127f0:	4798      	blx	r3
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   127f2:	4840      	ldr	r0, [pc, #256]	; (128f4 <led_task_inner+0x128>)
   127f4:	4b42      	ldr	r3, [pc, #264]	; (12900 <led_task_inner+0x134>)
}
   127f6:	b003      	add	sp, #12
   127f8:	ecbd 8b02 	vpop	{d8}
   127fc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	grid_led_lowlevel_hardware_start_transfer(&grid_led_state);
   12800:	4718      	bx	r3
		grid_sys_state.alert_state--;
   12802:	8963      	ldrh	r3, [r4, #10]
   12804:	3b01      	subs	r3, #1
   12806:	b29b      	uxth	r3, r3
   12808:	8163      	strh	r3, [r4, #10]
		if (grid_sys_alert_read_color_changed_flag(&grid_sys_state)){
   1280a:	4620      	mov	r0, r4
   1280c:	4b3d      	ldr	r3, [pc, #244]	; (12904 <led_task_inner+0x138>)
   1280e:	4798      	blx	r3
   12810:	b988      	cbnz	r0, 12836 <led_task_inner+0x6a>
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   12812:	4835      	ldr	r0, [pc, #212]	; (128e8 <led_task_inner+0x11c>)
   12814:	4b3c      	ldr	r3, [pc, #240]	; (12908 <led_task_inner+0x13c>)
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   12816:	4e37      	ldr	r6, [pc, #220]	; (128f4 <led_task_inner+0x128>)
   12818:	4f3c      	ldr	r7, [pc, #240]	; (1290c <led_task_inner+0x140>)
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   1281a:	4798      	blx	r3
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   1281c:	2400      	movs	r4, #0
		uint8_t intensity = grid_sys_alert_get_color_intensity(&grid_sys_state);
   1281e:	4605      	mov	r5, r0
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   12820:	4b34      	ldr	r3, [pc, #208]	; (128f4 <led_task_inner+0x128>)
   12822:	785b      	ldrb	r3, [r3, #1]
   12824:	b2e1      	uxtb	r1, r4
   12826:	428b      	cmp	r3, r1
   12828:	d9d9      	bls.n	127de <led_task_inner+0x12>
			grid_led_set_phase(&grid_led_state, i, GRID_LED_LAYER_ALERT, intensity);
   1282a:	462b      	mov	r3, r5
   1282c:	2200      	movs	r2, #0
   1282e:	4630      	mov	r0, r6
   12830:	47b8      	blx	r7
		for (uint8_t i=0; i<grid_led_state.led_number; i++){	
   12832:	3401      	adds	r4, #1
   12834:	e7f4      	b.n	12820 <led_task_inner+0x54>
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   12836:	4b36      	ldr	r3, [pc, #216]	; (12910 <led_task_inner+0x144>)
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   12838:	4e2e      	ldr	r6, [pc, #184]	; (128f4 <led_task_inner+0x128>)
			grid_sys_alert_clear_color_changed_flag(&grid_sys_state);			
   1283a:	4620      	mov	r0, r4
   1283c:	4798      	blx	r3
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   1283e:	4b35      	ldr	r3, [pc, #212]	; (12914 <led_task_inner+0x148>)
   12840:	4620      	mov	r0, r4
   12842:	4798      	blx	r3
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   12844:	4b34      	ldr	r3, [pc, #208]	; (12918 <led_task_inner+0x14c>)
			uint8_t color_r   = grid_sys_alert_get_color_r(&grid_sys_state);
   12846:	ee08 0a10 	vmov	s16, r0
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   1284a:	4620      	mov	r0, r4
   1284c:	4798      	blx	r3
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   1284e:	4b33      	ldr	r3, [pc, #204]	; (1291c <led_task_inner+0x150>)
			uint8_t color_g   = grid_sys_alert_get_color_g(&grid_sys_state);
   12850:	4682      	mov	sl, r0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   12852:	4620      	mov	r0, r4
   12854:	4798      	blx	r3
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   12856:	f04f 0900 	mov.w	r9, #0
			uint8_t color_b   = grid_sys_alert_get_color_b(&grid_sys_state);
   1285a:	4683      	mov	fp, r0
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   1285c:	4b30      	ldr	r3, [pc, #192]	; (12920 <led_task_inner+0x154>)
   1285e:	4630      	mov	r0, r6
   12860:	4798      	blx	r3
   12862:	fa5f f589 	uxtb.w	r5, r9
   12866:	42a8      	cmp	r0, r5
   12868:	f109 0901 	add.w	r9, r9, #1
   1286c:	d9d1      	bls.n	12812 <led_task_inner+0x46>
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   1286e:	2400      	movs	r4, #0
   12870:	4622      	mov	r2, r4
   12872:	e9cd 4400 	strd	r4, r4, [sp]
   12876:	4623      	mov	r3, r4
   12878:	4629      	mov	r1, r5
   1287a:	4630      	mov	r0, r6
   1287c:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 12934 <led_task_inner+0x168>
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   12880:	4f28      	ldr	r7, [pc, #160]	; (12924 <led_task_inner+0x158>)
				grid_led_set_min(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0   , color_g*0   , color_b*0);
   12882:	47c0      	blx	r8
				grid_led_set_mid(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*0.5 , color_g*0.5 , color_b*0.5);
   12884:	ee18 0a10 	vmov	r0, s16
   12888:	4b27      	ldr	r3, [pc, #156]	; (12928 <led_task_inner+0x15c>)
   1288a:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 12938 <led_task_inner+0x16c>
   1288e:	4798      	blx	r3
   12890:	4b26      	ldr	r3, [pc, #152]	; (1292c <led_task_inner+0x160>)
   12892:	2200      	movs	r2, #0
   12894:	47b8      	blx	r7
   12896:	47c0      	blx	r8
   12898:	4b23      	ldr	r3, [pc, #140]	; (12928 <led_task_inner+0x15c>)
   1289a:	b2c2      	uxtb	r2, r0
   1289c:	4658      	mov	r0, fp
   1289e:	ee08 2a90 	vmov	s17, r2
   128a2:	4798      	blx	r3
   128a4:	2200      	movs	r2, #0
   128a6:	4b21      	ldr	r3, [pc, #132]	; (1292c <led_task_inner+0x160>)
   128a8:	47b8      	blx	r7
   128aa:	47c0      	blx	r8
   128ac:	b2c0      	uxtb	r0, r0
   128ae:	9001      	str	r0, [sp, #4]
   128b0:	4b1d      	ldr	r3, [pc, #116]	; (12928 <led_task_inner+0x15c>)
   128b2:	4650      	mov	r0, sl
   128b4:	4798      	blx	r3
   128b6:	4b1d      	ldr	r3, [pc, #116]	; (1292c <led_task_inner+0x160>)
   128b8:	2200      	movs	r2, #0
   128ba:	47b8      	blx	r7
   128bc:	47c0      	blx	r8
   128be:	b2c0      	uxtb	r0, r0
   128c0:	ee18 3a90 	vmov	r3, s17
   128c4:	9000      	str	r0, [sp, #0]
   128c6:	4622      	mov	r2, r4
   128c8:	4629      	mov	r1, r5
   128ca:	4630      	mov	r0, r6
   128cc:	f8df 806c 	ldr.w	r8, [pc, #108]	; 1293c <led_task_inner+0x170>
   128d0:	47c0      	blx	r8
				grid_led_set_max(&grid_led_state, i, GRID_LED_LAYER_ALERT, color_r*1   , color_g*1   , color_b*1);
   128d2:	4622      	mov	r2, r4
   128d4:	e9cd ab00 	strd	sl, fp, [sp]
   128d8:	ee18 3a10 	vmov	r3, s16
   128dc:	4c14      	ldr	r4, [pc, #80]	; (12930 <led_task_inner+0x164>)
   128de:	4629      	mov	r1, r5
   128e0:	4630      	mov	r0, r6
   128e2:	47a0      	blx	r4
			for (uint8_t i=0; i<grid_led_get_led_number(&grid_led_state); i++){
   128e4:	e7ba      	b.n	1285c <led_task_inner+0x90>
   128e6:	bf00      	nop
   128e8:	2000f008 	.word	0x2000f008
   128ec:	0000968b 	.word	0x0000968b
   128f0:	200102b0 	.word	0x200102b0
   128f4:	2001c838 	.word	0x2001c838
   128f8:	0000758d 	.word	0x0000758d
   128fc:	0000797d 	.word	0x0000797d
   12900:	0000799d 	.word	0x0000799d
   12904:	0000a0d5 	.word	0x0000a0d5
   12908:	0000a0df 	.word	0x0000a0df
   1290c:	00007695 	.word	0x00007695
   12910:	0000a0d9 	.word	0x0000a0d9
   12914:	0000a13d 	.word	0x0000a13d
   12918:	0000a141 	.word	0x0000a141
   1291c:	0000a145 	.word	0x0000a145
   12920:	00007589 	.word	0x00007589
   12924:	00014879 	.word	0x00014879
   12928:	000147a5 	.word	0x000147a5
   1292c:	3fe00000 	.word	0x3fe00000
   12930:	00007605 	.word	0x00007605
   12934:	000075c5 	.word	0x000075c5
   12938:	00014c9d 	.word	0x00014c9d
   1293c:	000075e5 	.word	0x000075e5

00012940 <RTC_Scheduler_realtime_cb>:
{
   12940:	b537      	push	{r0, r1, r2, r4, r5, lr}
	grid_sys_rtc_tick_time(&grid_sys_state);	
   12942:	4d16      	ldr	r5, [pc, #88]	; (1299c <RTC_Scheduler_realtime_cb+0x5c>)
   12944:	4b16      	ldr	r3, [pc, #88]	; (129a0 <RTC_Scheduler_realtime_cb+0x60>)
   12946:	4628      	mov	r0, r5
   12948:	4798      	blx	r3
	grid_task_timer_tick(&grid_task_state);
   1294a:	4816      	ldr	r0, [pc, #88]	; (129a4 <RTC_Scheduler_realtime_cb+0x64>)
   1294c:	4b16      	ldr	r3, [pc, #88]	; (129a8 <RTC_Scheduler_realtime_cb+0x68>)
   1294e:	4798      	blx	r3
	CRITICAL_SECTION_ENTER();
   12950:	4b16      	ldr	r3, [pc, #88]	; (129ac <RTC_Scheduler_realtime_cb+0x6c>)
   12952:	a801      	add	r0, sp, #4
   12954:	4798      	blx	r3
	return ((Port *)hw)->Group[submodule_index].DIR.reg;
   12956:	4a16      	ldr	r2, [pc, #88]	; (129b0 <RTC_Scheduler_realtime_cb+0x70>)
   12958:	f8d2 1100 	ldr.w	r1, [r2, #256]	; 0x100
	return ((Port *)hw)->Group[submodule_index].IN.reg;
   1295c:	f8d2 3120 	ldr.w	r3, [r2, #288]	; 0x120
	return ((Port *)hw)->Group[submodule_index].OUT.reg;
   12960:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
	tmp |= hri_port_read_OUT_reg(PORT, port) & dir_tmp;
   12964:	405c      	eors	r4, r3
   12966:	400c      	ands	r4, r1
   12968:	405c      	eors	r4, r3
	CRITICAL_SECTION_LEAVE();
   1296a:	a801      	add	r0, sp, #4
   1296c:	4b11      	ldr	r3, [pc, #68]	; (129b4 <RTC_Scheduler_realtime_cb+0x74>)
   1296e:	4798      	blx	r3
	if (mapmode_value != grid_sys_state.mapmodestate){
   12970:	7c2a      	ldrb	r2, [r5, #16]
	uint8_t mapmode_value = !gpio_get_pin_level(MAP_MODE);
   12972:	f484 6300 	eor.w	r3, r4, #2048	; 0x800
   12976:	f3c3 23c0 	ubfx	r3, r3, #11, #1
	if (mapmode_value != grid_sys_state.mapmodestate){
   1297a:	429a      	cmp	r2, r3
   1297c:	d009      	beq.n	12992 <RTC_Scheduler_realtime_cb+0x52>
		grid_sys_state.mapmodestate = mapmode_value;
   1297e:	742b      	strb	r3, [r5, #16]
		if (grid_sys_state.mapmodestate == 0){ // RELEASE
   12980:	7c2b      	ldrb	r3, [r5, #16]
   12982:	4c0d      	ldr	r4, [pc, #52]	; (129b8 <RTC_Scheduler_realtime_cb+0x78>)
   12984:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   12988:	b92b      	cbnz	r3, 12996 <RTC_Scheduler_realtime_cb+0x56>
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_RELEASE);
   1298a:	2308      	movs	r3, #8
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   1298c:	480b      	ldr	r0, [pc, #44]	; (129bc <RTC_Scheduler_realtime_cb+0x7c>)
   1298e:	4611      	mov	r1, r2
   12990:	47a0      	blx	r4
}
   12992:	b003      	add	sp, #12
   12994:	bd30      	pop	{r4, r5, pc}
			grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_MAPMODE_PRESS);		
   12996:	2307      	movs	r3, #7
   12998:	2200      	movs	r2, #0
   1299a:	e7f7      	b.n	1298c <RTC_Scheduler_realtime_cb+0x4c>
   1299c:	2000f008 	.word	0x2000f008
   129a0:	0000a0c3 	.word	0x0000a0c3
   129a4:	200102b0 	.word	0x200102b0
   129a8:	00009693 	.word	0x00009693
   129ac:	00012485 	.word	0x00012485
   129b0:	41008000 	.word	0x41008000
   129b4:	00012493 	.word	0x00012493
   129b8:	0000aaa1 	.word	0x0000aaa1
   129bc:	2001c7c0 	.word	0x2001c7c0

000129c0 <outbound_task>:
   129c0:	b508      	push	{r3, lr}
   129c2:	4c02      	ldr	r4, [pc, #8]	; (129cc <outbound_task+0xc>)
   129c4:	2005      	movs	r0, #5
   129c6:	47a0      	blx	r4
   129c8:	e7fc      	b.n	129c4 <outbound_task+0x4>
   129ca:	bf00      	nop
   129cc:	000133fd 	.word	0x000133fd

000129d0 <led_task>:
{
   129d0:	b508      	push	{r3, lr}
		globaltest++;
   129d2:	4c08      	ldr	r4, [pc, #32]	; (129f4 <led_task+0x24>)
		inbound_task_inner();
   129d4:	4e08      	ldr	r6, [pc, #32]	; (129f8 <led_task+0x28>)
		outbound_task_inner();
   129d6:	4d09      	ldr	r5, [pc, #36]	; (129fc <led_task+0x2c>)
		globaltest++;
   129d8:	6863      	ldr	r3, [r4, #4]
   129da:	3301      	adds	r3, #1
   129dc:	6063      	str	r3, [r4, #4]
		inbound_task_inner();
   129de:	47b0      	blx	r6
		outbound_task_inner();
   129e0:	47a8      	blx	r5
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   129e2:	4807      	ldr	r0, [pc, #28]	; (12a00 <led_task+0x30>)
   129e4:	4b07      	ldr	r3, [pc, #28]	; (12a04 <led_task+0x34>)
   129e6:	4798      	blx	r3
		led_task_inner();
   129e8:	4b07      	ldr	r3, [pc, #28]	; (12a08 <led_task+0x38>)
   129ea:	4798      	blx	r3
		vTaskDelay(1*configTICK_RATE_HZ/1000);
   129ec:	4b07      	ldr	r3, [pc, #28]	; (12a0c <led_task+0x3c>)
   129ee:	2005      	movs	r0, #5
   129f0:	4798      	blx	r3
	while (1) {
   129f2:	e7f1      	b.n	129d8 <led_task+0x8>
   129f4:	20008d80 	.word	0x20008d80
   129f8:	00012739 	.word	0x00012739
   129fc:	00012785 	.word	0x00012785
   12a00:	2000c0b0 	.word	0x2000c0b0
   12a04:	0000b0b5 	.word	0x0000b0b5
   12a08:	000127cd 	.word	0x000127cd
   12a0c:	000133fd 	.word	0x000133fd

00012a10 <vApplicationStackOverflowHook>:
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   12a10:	b583      	push	{r0, r1, r7, lr}
	CRITICAL_SECTION_ENTER()
   12a12:	4b08      	ldr	r3, [pc, #32]	; (12a34 <vApplicationStackOverflowHook+0x24>)
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   12a14:	4f08      	ldr	r7, [pc, #32]	; (12a38 <vApplicationStackOverflowHook+0x28>)
   12a16:	4e09      	ldr	r6, [pc, #36]	; (12a3c <vApplicationStackOverflowHook+0x2c>)
   12a18:	4d09      	ldr	r5, [pc, #36]	; (12a40 <vApplicationStackOverflowHook+0x30>)
void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName ){
   12a1a:	4604      	mov	r4, r0
	CRITICAL_SECTION_ENTER()
   12a1c:	a801      	add	r0, sp, #4
   12a1e:	4798      	blx	r3
		printf("Stack overflow in task %s\r\n", pcTaskGetName(xTask));
   12a20:	4620      	mov	r0, r4
   12a22:	47b8      	blx	r7
   12a24:	4601      	mov	r1, r0
   12a26:	4630      	mov	r0, r6
   12a28:	47a8      	blx	r5
		delay_ms(1000);
   12a2a:	4b06      	ldr	r3, [pc, #24]	; (12a44 <vApplicationStackOverflowHook+0x34>)
   12a2c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
   12a30:	4798      	blx	r3
	while(1){
   12a32:	e7f5      	b.n	12a20 <vApplicationStackOverflowHook+0x10>
   12a34:	00012485 	.word	0x00012485
   12a38:	000131e1 	.word	0x000131e1
   12a3c:	00017359 	.word	0x00017359
   12a40:	00014eb1 	.word	0x00014eb1
   12a44:	0000e709 	.word	0x0000e709

00012a48 <init_timer>:


void init_timer(void)
{
   12a48:	b570      	push	{r4, r5, r6, lr}
	
		
	//RTC_Scheduler_ping.interval = RTC1SEC/20; //50ms
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   12a4a:	4c14      	ldr	r4, [pc, #80]	; (12a9c <init_timer+0x54>)
	
	RTC_Scheduler_realtime.interval = 1;
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;

	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12a4c:	4d14      	ldr	r5, [pc, #80]	; (12aa0 <init_timer+0x58>)
   12a4e:	4e15      	ldr	r6, [pc, #84]	; (12aa4 <init_timer+0x5c>)
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   12a50:	f44f 63c8 	mov.w	r3, #1600	; 0x640
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   12a54:	f44f 627a 	mov.w	r2, #4000	; 0xfa0
	RTC_Scheduler_ping.interval = RTC1MS*GRID_PARAMETER_PING_interval;
   12a58:	6223      	str	r3, [r4, #32]
	RTC_Scheduler_heartbeat.interval = RTC1MS*GRID_PARAMETER_HEARTBEAT_interval;
   12a5a:	6362      	str	r2, [r4, #52]	; 0x34
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   12a5c:	4b12      	ldr	r3, [pc, #72]	; (12aa8 <init_timer+0x60>)
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   12a5e:	4a13      	ldr	r2, [pc, #76]	; (12aac <init_timer+0x64>)
	RTC_Scheduler_ping.cb       = RTC_Scheduler_ping_cb;
   12a60:	6263      	str	r3, [r4, #36]	; 0x24
	RTC_Scheduler_heartbeat.cb       = RTC_Scheduler_heartbeat_cb;
   12a62:	63a2      	str	r2, [r4, #56]	; 0x38
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   12a64:	2301      	movs	r3, #1
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   12a66:	4a12      	ldr	r2, [pc, #72]	; (12ab0 <init_timer+0x68>)
	RTC_Scheduler_ping.mode     = TIMER_TASK_REPEAT;
   12a68:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12a6c:	f104 0118 	add.w	r1, r4, #24
   12a70:	4628      	mov	r0, r5
	RTC_Scheduler_heartbeat.mode     = TIMER_TASK_REPEAT;
   12a72:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
	RTC_Scheduler_realtime.interval = 1;
   12a76:	64a3      	str	r3, [r4, #72]	; 0x48
	RTC_Scheduler_realtime.mode     = TIMER_TASK_REPEAT;
   12a78:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
	RTC_Scheduler_realtime.cb       = RTC_Scheduler_realtime_cb;
   12a7c:	64e2      	str	r2, [r4, #76]	; 0x4c
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_ping);
   12a7e:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_heartbeat);
   12a80:	f104 012c 	add.w	r1, r4, #44	; 0x2c
   12a84:	4628      	mov	r0, r5
   12a86:	47b0      	blx	r6
	timer_add_task(&RTC_Scheduler, &RTC_Scheduler_realtime);
   12a88:	f104 0140 	add.w	r1, r4, #64	; 0x40
   12a8c:	4628      	mov	r0, r5
   12a8e:	47b0      	blx	r6
	
	timer_start(&RTC_Scheduler);
   12a90:	4628      	mov	r0, r5
   12a92:	4b08      	ldr	r3, [pc, #32]	; (12ab4 <init_timer+0x6c>)
	
}
   12a94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	timer_start(&RTC_Scheduler);
   12a98:	4718      	bx	r3
   12a9a:	bf00      	nop
   12a9c:	20008d80 	.word	0x20008d80
   12aa0:	2001ccb8 	.word	0x2001ccb8
   12aa4:	0000d3d1 	.word	0x0000d3d1
   12aa8:	000124a1 	.word	0x000124a1
   12aac:	000124ed 	.word	0x000124ed
   12ab0:	00012941 	.word	0x00012941
   12ab4:	0000d391 	.word	0x0000d391

00012ab8 <main>:

//====================== USB TEST =====================//

int main(void)
{
   12ab8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	

	// boundary scan here

	uint32_t boundary_result[4] = {0};
   12abc:	2210      	movs	r2, #16
{
   12abe:	b08d      	sub	sp, #52	; 0x34
	uint32_t boundary_result[4] = {0};
   12ac0:	eb0d 0002 	add.w	r0, sp, r2
   12ac4:	2100      	movs	r1, #0
   12ac6:	4d93      	ldr	r5, [pc, #588]	; (12d14 <main+0x25c>)


	atmel_start_init();	
    
            
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   12ac8:	4c93      	ldr	r4, [pc, #588]	; (12d18 <main+0x260>)


	printf("test.mcu.ATSAMD51N20A\r\n");
   12aca:	4f94      	ldr	r7, [pc, #592]	; (12d1c <main+0x264>)

	printf("test.serialno.%08x %08x %08x %08x\r\n", uniqueid[0], uniqueid[1], uniqueid[2], uniqueid[3]);

	for (uint8_t i=0; i<4; i++){

		delay_ms(10);
   12acc:	f8df 8348 	ldr.w	r8, [pc, #840]	; 12e18 <main+0x360>
		printf("test.boundary.%d.", i);
   12ad0:	f8df a348 	ldr.w	sl, [pc, #840]	; 12e1c <main+0x364>
	uint32_t boundary_result[4] = {0};
   12ad4:	47a8      	blx	r5
	grid_d51_boundary_scan(boundary_result);
   12ad6:	4b92      	ldr	r3, [pc, #584]	; (12d20 <main+0x268>)
   12ad8:	a804      	add	r0, sp, #16
   12ada:	4798      	blx	r3
	atmel_start_init();	
   12adc:	4b91      	ldr	r3, [pc, #580]	; (12d24 <main+0x26c>)
   12ade:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "Start Initialized");
   12ae0:	4991      	ldr	r1, [pc, #580]	; (12d28 <main+0x270>)
   12ae2:	4892      	ldr	r0, [pc, #584]	; (12d2c <main+0x274>)
   12ae4:	47a0      	blx	r4
	printf("test.mcu.ATSAMD51N20A\r\n");
   12ae6:	4892      	ldr	r0, [pc, #584]	; (12d30 <main+0x278>)
   12ae8:	47b8      	blx	r7
	printf("test.hwcfg.%d\r\n", grid_sys_get_hwcfg());
   12aea:	4b92      	ldr	r3, [pc, #584]	; (12d34 <main+0x27c>)
   12aec:	4798      	blx	r3
   12aee:	4601      	mov	r1, r0
   12af0:	4891      	ldr	r0, [pc, #580]	; (12d38 <main+0x280>)
   12af2:	47a0      	blx	r4
	uint32_t uniqueid[4] = {0};
   12af4:	2210      	movs	r2, #16
   12af6:	2100      	movs	r1, #0
   12af8:	a808      	add	r0, sp, #32
   12afa:	47a8      	blx	r5
	grid_sys_get_id(uniqueid);	
   12afc:	4b8f      	ldr	r3, [pc, #572]	; (12d3c <main+0x284>)
   12afe:	a808      	add	r0, sp, #32
   12b00:	4798      	blx	r3
	printf("test.serialno.%08x %08x %08x %08x\r\n", uniqueid[0], uniqueid[1], uniqueid[2], uniqueid[3]);
   12b02:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
   12b04:	9300      	str	r3, [sp, #0]
   12b06:	9908      	ldr	r1, [sp, #32]
   12b08:	488d      	ldr	r0, [pc, #564]	; (12d40 <main+0x288>)
   12b0a:	e9dd 2309 	ldrd	r2, r3, [sp, #36]	; 0x24
   12b0e:	47a0      	blx	r4
	for (uint8_t i=0; i<4; i++){
   12b10:	ad04      	add	r5, sp, #16
   12b12:	9703      	str	r7, [sp, #12]
	printf("test.serialno.%08x %08x %08x %08x\r\n", uniqueid[0], uniqueid[1], uniqueid[2], uniqueid[3]);
   12b14:	2600      	movs	r6, #0
   12b16:	4647      	mov	r7, r8
		delay_ms(10);
   12b18:	200a      	movs	r0, #10
   12b1a:	47c0      	blx	r8
		printf("test.boundary.%d.", i);
   12b1c:	4631      	mov	r1, r6
   12b1e:	4650      	mov	r0, sl
   12b20:	47a0      	blx	r4

		for (uint8_t j=0; j<32; j++){
   12b22:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 12e20 <main+0x368>
		printf("test.boundary.%d.", i);
   12b26:	f04f 0b00 	mov.w	fp, #0

			if (boundary_result[i]&(1<<j)){
   12b2a:	6829      	ldr	r1, [r5, #0]
   12b2c:	2301      	movs	r3, #1
   12b2e:	fa03 f20b 	lsl.w	r2, r3, fp
   12b32:	420a      	tst	r2, r1
				printf("1");
   12b34:	bf14      	ite	ne
   12b36:	2031      	movne	r0, #49	; 0x31
			}
			else{
				printf("0");
   12b38:	2030      	moveq	r0, #48	; 0x30
   12b3a:	f10b 0b01 	add.w	fp, fp, #1
   12b3e:	47c8      	blx	r9
		for (uint8_t j=0; j<32; j++){
   12b40:	f1bb 0f20 	cmp.w	fp, #32
   12b44:	d1f1      	bne.n	12b2a <main+0x72>
			}
		}


		printf("\r\n");
   12b46:	487f      	ldr	r0, [pc, #508]	; (12d44 <main+0x28c>)
   12b48:	9b03      	ldr	r3, [sp, #12]
   12b4a:	3601      	adds	r6, #1
   12b4c:	4798      	blx	r3
	for (uint8_t i=0; i<4; i++){
   12b4e:	2e04      	cmp	r6, #4
   12b50:	f105 0504 	add.w	r5, r5, #4
   12b54:	d1e0      	bne.n	12b18 <main+0x60>

	}


	printf("Hello %d %d %d %d", boundary_result[0], boundary_result[1], boundary_result[2], boundary_result[3]);
   12b56:	9b07      	ldr	r3, [sp, #28]
   12b58:	9904      	ldr	r1, [sp, #16]
   12b5a:	9300      	str	r3, [sp, #0]
   12b5c:	487a      	ldr	r0, [pc, #488]	; (12d48 <main+0x290>)
	// 	}
	// }


    
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   12b5e:	4d7b      	ldr	r5, [pc, #492]	; (12d4c <main+0x294>)
   12b60:	f8df 82c0 	ldr.w	r8, [pc, #704]	; 12e24 <main+0x36c>
	printf("Hello %d %d %d %d", boundary_result[0], boundary_result[1], boundary_result[2], boundary_result[3]);
   12b64:	e9dd 2305 	ldrd	r2, r3, [sp, #20]
   12b68:	47a0      	blx	r4
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_PORT, "D51 Init");
   12b6a:	4979      	ldr	r1, [pc, #484]	; (12d50 <main+0x298>)
   12b6c:	486f      	ldr	r0, [pc, #444]	; (12d2c <main+0x274>)
   12b6e:	47a0      	blx	r4
	grid_d51_init(); // Check User Row
   12b70:	4b78      	ldr	r3, [pc, #480]	; (12d54 <main+0x29c>)
   12b72:	4798      	blx	r3
	audiodf_midi_init();
   12b74:	4b78      	ldr	r3, [pc, #480]	; (12d58 <main+0x2a0>)
   12b76:	4798      	blx	r3
	composite_device_start();
   12b78:	4b78      	ldr	r3, [pc, #480]	; (12d5c <main+0x2a4>)
   12b7a:	4798      	blx	r3
	grid_usb_serial_init();
   12b7c:	4b78      	ldr	r3, [pc, #480]	; (12d60 <main+0x2a8>)
   12b7e:	4798      	blx	r3
	grid_usb_midi_init();
   12b80:	4b78      	ldr	r3, [pc, #480]	; (12d64 <main+0x2ac>)
   12b82:	4798      	blx	r3
	grid_keyboard_init(&grid_keyboard_state);
   12b84:	4b78      	ldr	r3, [pc, #480]	; (12d68 <main+0x2b0>)
   12b86:	4879      	ldr	r0, [pc, #484]	; (12d6c <main+0x2b4>)
   12b88:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Initialized");
   12b8a:	4979      	ldr	r1, [pc, #484]	; (12d70 <main+0x2b8>)
   12b8c:	4867      	ldr	r0, [pc, #412]	; (12d2c <main+0x274>)
   12b8e:	47a0      	blx	r4
	rand_sync_enable(&RAND_0);	
   12b90:	4b78      	ldr	r3, [pc, #480]	; (12d74 <main+0x2bc>)
   12b92:	4879      	ldr	r0, [pc, #484]	; (12d78 <main+0x2c0>)
   12b94:	4798      	blx	r3
	grid_expr_init(&grid_expr_state);
   12b96:	4879      	ldr	r0, [pc, #484]	; (12d7c <main+0x2c4>)
   12b98:	4b79      	ldr	r3, [pc, #484]	; (12d80 <main+0x2c8>)
   12b9a:	4798      	blx	r3
	grid_module_common_init();
   12b9c:	4b79      	ldr	r3, [pc, #484]	; (12d84 <main+0x2cc>)
   12b9e:	4798      	blx	r3
    grid_ui_reinit(&grid_ui_state);
   12ba0:	4b79      	ldr	r3, [pc, #484]	; (12d88 <main+0x2d0>)
   12ba2:	487a      	ldr	r0, [pc, #488]	; (12d8c <main+0x2d4>)
   12ba4:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Grid Module Initialized");
   12ba6:	497a      	ldr	r1, [pc, #488]	; (12d90 <main+0x2d8>)
   12ba8:	4860      	ldr	r0, [pc, #384]	; (12d2c <main+0x274>)
   12baa:	47a0      	blx	r4
	init_timer();
   12bac:	4b79      	ldr	r3, [pc, #484]	; (12d94 <main+0x2dc>)
   12bae:	4798      	blx	r3
	GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Entering Main Loop");
   12bb0:	4979      	ldr	r1, [pc, #484]	; (12d98 <main+0x2e0>)
   12bb2:	485e      	ldr	r0, [pc, #376]	; (12d2c <main+0x274>)
   12bb4:	47a0      	blx	r4
	grid_sys_nvm_load_configuration(&grid_sys_state, &grid_nvm_state);
   12bb6:	4979      	ldr	r1, [pc, #484]	; (12d9c <main+0x2e4>)
   12bb8:	4879      	ldr	r0, [pc, #484]	; (12da0 <main+0x2e8>)
   12bba:	4b7a      	ldr	r3, [pc, #488]	; (12da4 <main+0x2ec>)
   12bbc:	4798      	blx	r3
	grid_ui_nvm_load_all_configuration(&grid_ui_state, &grid_nvm_state);	
   12bbe:	4977      	ldr	r1, [pc, #476]	; (12d9c <main+0x2e4>)
   12bc0:	4872      	ldr	r0, [pc, #456]	; (12d8c <main+0x2d4>)
   12bc2:	4b79      	ldr	r3, [pc, #484]	; (12da8 <main+0x2f0>)
   12bc4:	4798      	blx	r3
	if (xTaskCreate(usb_task, "Usb Task", TASK_USB_STACK_SIZE, NULL, TASK_USB_PRIORITY, &xCreatedUsbTask)
   12bc6:	2301      	movs	r3, #1
   12bc8:	9300      	str	r3, [sp, #0]
   12bca:	4978      	ldr	r1, [pc, #480]	; (12dac <main+0x2f4>)
   12bcc:	4878      	ldr	r0, [pc, #480]	; (12db0 <main+0x2f8>)
   12bce:	9501      	str	r5, [sp, #4]
   12bd0:	2300      	movs	r3, #0
   12bd2:	f44f 7200 	mov.w	r2, #512	; 0x200
   12bd6:	47c0      	blx	r8
   12bd8:	2801      	cmp	r0, #1
   12bda:	d000      	beq.n	12bde <main+0x126>
	    != pdPASS) {
		while (1) {
   12bdc:	e7fe      	b.n	12bdc <main+0x124>
			;
		}
	}

	if (xTaskCreate(usb_task, "Nvm Task", TASK_NVM_STACK_SIZE, NULL, TASK_NVM_PRIORITY, &xCreatedNvmTask)
   12bde:	1d2b      	adds	r3, r5, #4
   12be0:	f04f 0902 	mov.w	r9, #2
   12be4:	9301      	str	r3, [sp, #4]
   12be6:	4973      	ldr	r1, [pc, #460]	; (12db4 <main+0x2fc>)
   12be8:	4871      	ldr	r0, [pc, #452]	; (12db0 <main+0x2f8>)
   12bea:	f8cd 9000 	str.w	r9, [sp]
   12bee:	2300      	movs	r3, #0
   12bf0:	f44f 7280 	mov.w	r2, #256	; 0x100
   12bf4:	47c0      	blx	r8
   12bf6:	2801      	cmp	r0, #1
   12bf8:	d000      	beq.n	12bfc <main+0x144>
	    != pdPASS) {
		while (1) {
   12bfa:	e7fe      	b.n	12bfa <main+0x142>
			;
		}
	}

	if (xTaskCreate(usb_task, "Ui Task", TASK_UI_STACK_SIZE, NULL, TASK_UI_PRIORITY, &xCreatedUiTask)
   12bfc:	f105 0308 	add.w	r3, r5, #8
   12c00:	9301      	str	r3, [sp, #4]
   12c02:	2305      	movs	r3, #5
   12c04:	9300      	str	r3, [sp, #0]
   12c06:	496c      	ldr	r1, [pc, #432]	; (12db8 <main+0x300>)
   12c08:	4869      	ldr	r0, [pc, #420]	; (12db0 <main+0x2f8>)
   12c0a:	2300      	movs	r3, #0
   12c0c:	f44f 6280 	mov.w	r2, #1024	; 0x400
   12c10:	47c0      	blx	r8
   12c12:	2801      	cmp	r0, #1
   12c14:	d000      	beq.n	12c18 <main+0x160>
	    != pdPASS) {
		while (1) {
   12c16:	e7fe      	b.n	12c16 <main+0x15e>
			;
		}
	}

	if (xTaskCreate(receive_task, "Receive Task", TASK_RECEIVE_STACK_SIZE, NULL, TASK_RECEIVE_PRIORITY, &xCreatedReceiveTask)
   12c18:	f105 030c 	add.w	r3, r5, #12
   12c1c:	e9cd 9300 	strd	r9, r3, [sp]
   12c20:	4966      	ldr	r1, [pc, #408]	; (12dbc <main+0x304>)
   12c22:	4867      	ldr	r0, [pc, #412]	; (12dc0 <main+0x308>)
   12c24:	2300      	movs	r3, #0
   12c26:	f44f 7280 	mov.w	r2, #256	; 0x100
   12c2a:	47c0      	blx	r8
   12c2c:	2801      	cmp	r0, #1
   12c2e:	d000      	beq.n	12c32 <main+0x17a>
	    != pdPASS) {
		while (1) {
   12c30:	e7fe      	b.n	12c30 <main+0x178>
			;
		}
	}

	if (xTaskCreate(inbound_task, "Inbound Task", TASK_INBOUND_STACK_SIZE, NULL, TASK_INBOUND_PRIORITY, &xCreatedInboundTask)
   12c32:	f105 0310 	add.w	r3, r5, #16
   12c36:	e9cd 9300 	strd	r9, r3, [sp]
   12c3a:	4962      	ldr	r1, [pc, #392]	; (12dc4 <main+0x30c>)
   12c3c:	4862      	ldr	r0, [pc, #392]	; (12dc8 <main+0x310>)
   12c3e:	2300      	movs	r3, #0
   12c40:	f44f 7280 	mov.w	r2, #256	; 0x100
   12c44:	47c0      	blx	r8
   12c46:	2801      	cmp	r0, #1
   12c48:	d000      	beq.n	12c4c <main+0x194>
	    != pdPASS) {
		while (1) {
   12c4a:	e7fe      	b.n	12c4a <main+0x192>
			;
		}
	}

	if (xTaskCreate(outbound_task, "Outbound Task", TASK_OUTBOUND_STACK_SIZE, NULL, TASK_OUTBOUND_PRIORITY, &xCreatedOutboundTask)
   12c4c:	f105 0314 	add.w	r3, r5, #20
   12c50:	e9cd 9300 	strd	r9, r3, [sp]
   12c54:	495d      	ldr	r1, [pc, #372]	; (12dcc <main+0x314>)
   12c56:	485e      	ldr	r0, [pc, #376]	; (12dd0 <main+0x318>)
   12c58:	2300      	movs	r3, #0
   12c5a:	f44f 7280 	mov.w	r2, #256	; 0x100
   12c5e:	47c0      	blx	r8
   12c60:	2801      	cmp	r0, #1
   12c62:	d000      	beq.n	12c66 <main+0x1ae>
	    != pdPASS) {
		while (1) {
   12c64:	e7fe      	b.n	12c64 <main+0x1ac>
			;
		}
	}


	if (xTaskCreate(led_task, "Led Task", TASK_LED_STACK_SIZE, NULL, TASK_LED_PRIORITY, &xCreatedLedTask)
   12c66:	f105 0318 	add.w	r3, r5, #24
   12c6a:	e9cd 6300 	strd	r6, r3, [sp]
   12c6e:	4959      	ldr	r1, [pc, #356]	; (12dd4 <main+0x31c>)
   12c70:	4859      	ldr	r0, [pc, #356]	; (12dd8 <main+0x320>)
   12c72:	2300      	movs	r3, #0
   12c74:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   12c78:	47c0      	blx	r8
   12c7a:	2801      	cmp	r0, #1
   12c7c:	d000      	beq.n	12c80 <main+0x1c8>
	    != pdPASS) {
		while (1) {
   12c7e:	e7fe      	b.n	12c7e <main+0x1c6>
			;
		}
	}
    
	if (xTaskCreate(example_task, "Example", TASK_EXAMPLE_STACK_SIZE, NULL, TASK_EXAMPLE_STACK_PRIORITY, &xCreatedExampleTask)
   12c80:	351c      	adds	r5, #28
   12c82:	e9cd 9500 	strd	r9, r5, [sp]
   12c86:	4955      	ldr	r1, [pc, #340]	; (12ddc <main+0x324>)
   12c88:	4855      	ldr	r0, [pc, #340]	; (12de0 <main+0x328>)
   12c8a:	2300      	movs	r3, #0
   12c8c:	2280      	movs	r2, #128	; 0x80
   12c8e:	47c0      	blx	r8
   12c90:	2801      	cmp	r0, #1
   12c92:	d000      	beq.n	12c96 <main+0x1de>
	    != pdPASS) {
		while (1) {
   12c94:	e7fe      	b.n	12c94 <main+0x1dc>
   12c96:	f8df 9190 	ldr.w	r9, [pc, #400]	; 12e28 <main+0x370>
   12c9a:	f8df 8190 	ldr.w	r8, [pc, #400]	; 12e2c <main+0x374>
	uint32_t loopcounter = 0;
   12c9e:	2500      	movs	r5, #0
	
		
		if (usb_init_flag == 0){
			
			
			if (usb_d_get_frame_num() == 0){
   12ca0:	4b50      	ldr	r3, [pc, #320]	; (12de4 <main+0x32c>)
   12ca2:	4e51      	ldr	r6, [pc, #324]	; (12de8 <main+0x330>)
   12ca4:	f8df b188 	ldr.w	fp, [pc, #392]	; 12e30 <main+0x378>
   12ca8:	4798      	blx	r3
   12caa:	2800      	cmp	r0, #0
   12cac:	f000 80c4 	beq.w	12e38 <main+0x380>
				
			}
			else{			
			
				grid_sys_alert_set_alert(&grid_sys_state, 0, 255, 0, 0, 500); // GREEN	
   12cb0:	2500      	movs	r5, #0
   12cb2:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
   12cb6:	22ff      	movs	r2, #255	; 0xff
   12cb8:	e9cd 5300 	strd	r5, r3, [sp]
   12cbc:	4629      	mov	r1, r5
   12cbe:	462b      	mov	r3, r5
   12cc0:	4837      	ldr	r0, [pc, #220]	; (12da0 <main+0x2e8>)
   12cc2:	f8df a170 	ldr.w	sl, [pc, #368]	; 12e34 <main+0x37c>
   12cc6:	47d0      	blx	sl
				
				GRID_DEBUG_LOG(GRID_DEBUG_CONTEXT_BOOT, "Composite Device Connected");
   12cc8:	4948      	ldr	r1, [pc, #288]	; (12dec <main+0x334>)
   12cca:	4818      	ldr	r0, [pc, #96]	; (12d2c <main+0x274>)
   12ccc:	47a0      	blx	r4
				
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   12cce:	4b48      	ldr	r3, [pc, #288]	; (12df0 <main+0x338>)
   12cd0:	4833      	ldr	r0, [pc, #204]	; (12da0 <main+0x2e8>)
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   12cd2:	4c48      	ldr	r4, [pc, #288]	; (12df4 <main+0x33c>)
				grid_sys_set_bank(&grid_sys_state, grid_sys_get_bank_number_of_first_valid(&grid_sys_state));
   12cd4:	4798      	blx	r3
   12cd6:	4b48      	ldr	r3, [pc, #288]	; (12df8 <main+0x340>)
   12cd8:	4601      	mov	r1, r0
   12cda:	4831      	ldr	r0, [pc, #196]	; (12da0 <main+0x2e8>)
   12cdc:	4798      	blx	r3
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   12cde:	462a      	mov	r2, r5
   12ce0:	4629      	mov	r1, r5
   12ce2:	4846      	ldr	r0, [pc, #280]	; (12dfc <main+0x344>)
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12ce4:	4d46      	ldr	r5, [pc, #280]	; (12e00 <main+0x348>)
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_RESPONSE);
   12ce6:	2309      	movs	r3, #9
   12ce8:	47a0      	blx	r4
				
				usb_init_flag = 1;
				
				

				printf("Forever! \r\n");
   12cea:	9b03      	ldr	r3, [sp, #12]
   12cec:	4845      	ldr	r0, [pc, #276]	; (12e04 <main+0x34c>)

					inbound_task_inner();

					outbound_task_inner();

					led_task_inner();
   12cee:	4c46      	ldr	r4, [pc, #280]	; (12e08 <main+0x350>)
				printf("Forever! \r\n");
   12cf0:	4798      	blx	r3
				delay_ms(2);
   12cf2:	2002      	movs	r0, #2
   12cf4:	47b8      	blx	r7
				vTaskStartScheduler();
   12cf6:	4b45      	ldr	r3, [pc, #276]	; (12e0c <main+0x354>)
   12cf8:	4798      	blx	r3
					usb_task_inner();
   12cfa:	47c8      	blx	r9
					nvm_task_inner();
   12cfc:	47c0      	blx	r8
					receive_task_inner();
   12cfe:	47b0      	blx	r6
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12d00:	4628      	mov	r0, r5
   12d02:	47d8      	blx	fp
					inbound_task_inner();
   12d04:	4b42      	ldr	r3, [pc, #264]	; (12e10 <main+0x358>)
   12d06:	4798      	blx	r3
					outbound_task_inner();
   12d08:	4b42      	ldr	r3, [pc, #264]	; (12e14 <main+0x35c>)
   12d0a:	4798      	blx	r3
					led_task_inner();
   12d0c:	47a0      	blx	r4

					delay_ms(1);
   12d0e:	2001      	movs	r0, #1
   12d10:	47b8      	blx	r7
				while(1){
   12d12:	e7f2      	b.n	12cfa <main+0x242>
   12d14:	00014d51 	.word	0x00014d51
   12d18:	00014eb1 	.word	0x00014eb1
   12d1c:	00014fe5 	.word	0x00014fe5
   12d20:	00006481 	.word	0x00006481
   12d24:	00013b15 	.word	0x00013b15
   12d28:	00017375 	.word	0x00017375
   12d2c:	00016746 	.word	0x00016746
   12d30:	00017387 	.word	0x00017387
   12d34:	0000a1fd 	.word	0x0000a1fd
   12d38:	0001739e 	.word	0x0001739e
   12d3c:	0000a1d1 	.word	0x0000a1d1
   12d40:	000173ae 	.word	0x000173ae
   12d44:	000174be 	.word	0x000174be
   12d48:	000173e4 	.word	0x000173e4
   12d4c:	20008dd4 	.word	0x20008dd4
   12d50:	000173f6 	.word	0x000173f6
   12d54:	00006431 	.word	0x00006431
   12d58:	00004495 	.word	0x00004495
   12d5c:	0000d279 	.word	0x0000d279
   12d60:	0000b5f1 	.word	0x0000b5f1
   12d64:	0000b7e9 	.word	0x0000b7e9
   12d68:	0000b8d5 	.word	0x0000b8d5
   12d6c:	20010264 	.word	0x20010264
   12d70:	000173ff 	.word	0x000173ff
   12d74:	0000f109 	.word	0x0000f109
   12d78:	2001cd7c 	.word	0x2001cd7c
   12d7c:	20013220 	.word	0x20013220
   12d80:	000067a5 	.word	0x000067a5
   12d84:	000079d9 	.word	0x000079d9
   12d88:	0000a9d9 	.word	0x0000a9d9
   12d8c:	2000effc 	.word	0x2000effc
   12d90:	0001741c 	.word	0x0001741c
   12d94:	00012a49 	.word	0x00012a49
   12d98:	00017434 	.word	0x00017434
   12d9c:	2000fa1c 	.word	0x2000fa1c
   12da0:	2000f008 	.word	0x2000f008
   12da4:	000099f5 	.word	0x000099f5
   12da8:	0000a405 	.word	0x0000a405
   12dac:	00017447 	.word	0x00017447
   12db0:	00012645 	.word	0x00012645
   12db4:	00017450 	.word	0x00017450
   12db8:	00017459 	.word	0x00017459
   12dbc:	00017461 	.word	0x00017461
   12dc0:	0001268d 	.word	0x0001268d
   12dc4:	0001746e 	.word	0x0001746e
   12dc8:	00012545 	.word	0x00012545
   12dcc:	0001747b 	.word	0x0001747b
   12dd0:	000129c1 	.word	0x000129c1
   12dd4:	00017489 	.word	0x00017489
   12dd8:	000129d1 	.word	0x000129d1
   12ddc:	00017492 	.word	0x00017492
   12de0:	00012509 	.word	0x00012509
   12de4:	0000fe8d 	.word	0x0000fe8d
   12de8:	0001265d 	.word	0x0001265d
   12dec:	0001749a 	.word	0x0001749a
   12df0:	0000a059 	.word	0x0000a059
   12df4:	0000aaa1 	.word	0x0000aaa1
   12df8:	0000a073 	.word	0x0000a073
   12dfc:	2001c7c0 	.word	0x2001c7c0
   12e00:	2000c0b0 	.word	0x2000c0b0
   12e04:	000174b5 	.word	0x000174b5
   12e08:	000127cd 	.word	0x000127cd
   12e0c:	0001313d 	.word	0x0001313d
   12e10:	00012739 	.word	0x00012739
   12e14:	00012785 	.word	0x00012785
   12e18:	0000e709 	.word	0x0000e709
   12e1c:	000173d2 	.word	0x000173d2
   12e20:	00014ee1 	.word	0x00014ee1
   12e24:	00012f99 	.word	0x00012f99
   12e28:	00012555 	.word	0x00012555
   12e2c:	000126a5 	.word	0x000126a5
   12e30:	0000b0b5 	.word	0x0000b0b5
   12e34:	0000a123 	.word	0x0000a123
		
		
		
		// Request neighbor bank settings if we don't have it initialized
		
 		if (grid_sys_get_bank_valid(&grid_sys_state) == 0 && loopcounter%80 == 0){
   12e38:	f8df a060 	ldr.w	sl, [pc, #96]	; 12e9c <main+0x3e4>
   12e3c:	4b11      	ldr	r3, [pc, #68]	; (12e84 <main+0x3cc>)
   12e3e:	4650      	mov	r0, sl
   12e40:	4798      	blx	r3
   12e42:	b980      	cbnz	r0, 12e66 <main+0x3ae>
   12e44:	2250      	movs	r2, #80	; 0x50
   12e46:	fbb5 f3f2 	udiv	r3, r5, r2
   12e4a:	fb02 5313 	mls	r3, r2, r3, r5
   12e4e:	b953      	cbnz	r3, 12e66 <main+0x3ae>
 								
			if (grid_sys_state.bank_init_flag == 0)	{
   12e50:	f89a 3027 	ldrb.w	r3, [sl, #39]	; 0x27
   12e54:	f003 02ff 	and.w	r2, r3, #255	; 0xff
   12e58:	b92b      	cbnz	r3, 12e66 <main+0x3ae>
				
				grid_ui_smart_trigger(&grid_core_state, 0, 0, GRID_UI_EVENT_CFG_REQUEST);
   12e5a:	480b      	ldr	r0, [pc, #44]	; (12e88 <main+0x3d0>)
   12e5c:	f8df a040 	ldr.w	sl, [pc, #64]	; 12ea0 <main+0x3e8>
   12e60:	230a      	movs	r3, #10
   12e62:	4611      	mov	r1, r2
   12e64:	47d0      	blx	sl
	

		
		
		
		usb_task_inner();
   12e66:	47c8      	blx	r9
		


		nvm_task_inner();
   12e68:	47c0      	blx	r8
		
					


		receive_task_inner();
   12e6a:	47b0      	blx	r6
	grid_port_process_ui(&GRID_PORT_U); // COOLDOWN DELAY IMPLEMENTED INSIDE
   12e6c:	4807      	ldr	r0, [pc, #28]	; (12e8c <main+0x3d4>)
   12e6e:	47d8      	blx	fp
		
		
		
		
		
		inbound_task_inner();
   12e70:	4b07      	ldr	r3, [pc, #28]	; (12e90 <main+0x3d8>)
   12e72:	4798      	blx	r3

		outbound_task_inner();
   12e74:	4b07      	ldr	r3, [pc, #28]	; (12e94 <main+0x3dc>)
   12e76:	4798      	blx	r3

		led_task_inner();
   12e78:	4b07      	ldr	r3, [pc, #28]	; (12e98 <main+0x3e0>)
   12e7a:	4798      	blx	r3

		delay_ms(1);
   12e7c:	2001      	movs	r0, #1
		loopcounter++;
   12e7e:	3501      	adds	r5, #1
		delay_ms(1);
   12e80:	47b8      	blx	r7
		if (usb_init_flag == 0){
   12e82:	e70d      	b.n	12ca0 <main+0x1e8>
   12e84:	0000a01b 	.word	0x0000a01b
   12e88:	2001c7c0 	.word	0x2001c7c0
   12e8c:	2000c0b0 	.word	0x2000c0b0
   12e90:	00012739 	.word	0x00012739
   12e94:	00012785 	.word	0x00012785
   12e98:	000127cd 	.word	0x000127cd
   12e9c:	2000f008 	.word	0x2000f008
   12ea0:	0000aaa1 	.word	0x0000aaa1

00012ea4 <qspi_dma_init>:
 * \brief Driver version
 */
#define QSPI_DMA_DRIVER_VERSION 0x00000001u

int32_t qspi_dma_init(struct qspi_dma_descriptor *qspi, void *const hw)
{
   12ea4:	b570      	push	{r4, r5, r6, lr}
   12ea6:	460d      	mov	r5, r1
	ASSERT(qspi && hw);
   12ea8:	4604      	mov	r4, r0
   12eaa:	b110      	cbz	r0, 12eb2 <qspi_dma_init+0xe>
   12eac:	1e08      	subs	r0, r1, #0
   12eae:	bf18      	it	ne
   12eb0:	2001      	movne	r0, #1
   12eb2:	4905      	ldr	r1, [pc, #20]	; (12ec8 <qspi_dma_init+0x24>)
   12eb4:	4b05      	ldr	r3, [pc, #20]	; (12ecc <qspi_dma_init+0x28>)
   12eb6:	2231      	movs	r2, #49	; 0x31
   12eb8:	4798      	blx	r3

	return _qspi_dma_init(&qspi->dev, hw);
   12eba:	4629      	mov	r1, r5
   12ebc:	4620      	mov	r0, r4
   12ebe:	4b04      	ldr	r3, [pc, #16]	; (12ed0 <qspi_dma_init+0x2c>)
}
   12ec0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return _qspi_dma_init(&qspi->dev, hw);
   12ec4:	4718      	bx	r3
   12ec6:	bf00      	nop
   12ec8:	000174c0 	.word	0x000174c0
   12ecc:	0000e9b9 	.word	0x0000e9b9
   12ed0:	0000c795 	.word	0x0000c795

00012ed4 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12ed4:	4906      	ldr	r1, [pc, #24]	; (12ef0 <prvIdleTask+0x1c>)
				taskYIELD();
   12ed6:	4b07      	ldr	r3, [pc, #28]	; (12ef4 <prvIdleTask+0x20>)
   12ed8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[tskIDLE_PRIORITY])) > (UBaseType_t)1) {
   12edc:	6808      	ldr	r0, [r1, #0]
   12ede:	2801      	cmp	r0, #1
   12ee0:	d9fc      	bls.n	12edc <prvIdleTask+0x8>
				taskYIELD();
   12ee2:	601a      	str	r2, [r3, #0]
   12ee4:	f3bf 8f4f 	dsb	sy
   12ee8:	f3bf 8f6f 	isb	sy
   12eec:	e7f6      	b.n	12edc <prvIdleTask+0x8>
   12eee:	bf00      	nop
   12ef0:	20008df8 	.word	0x20008df8
   12ef4:	e000ed04 	.word	0xe000ed04

00012ef8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime(void)
{
	TCB_t *pxTCB;

	if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   12ef8:	4b07      	ldr	r3, [pc, #28]	; (12f18 <prvResetNextTaskUnblockTime+0x20>)
   12efa:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   12efe:	6812      	ldr	r2, [r2, #0]
   12f00:	b922      	cbnz	r2, 12f0c <prvResetNextTaskUnblockTime+0x14>
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   12f02:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   12f06:	f8c3 22ac 	str.w	r2, [r3, #684]	; 0x2ac
	}
}
   12f0a:	4770      	bx	lr
		(pxTCB)              = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   12f0c:	f8d3 22a8 	ldr.w	r2, [r3, #680]	; 0x2a8
   12f10:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE(&((pxTCB)->xStateListItem));
   12f12:	68d2      	ldr	r2, [r2, #12]
   12f14:	6852      	ldr	r2, [r2, #4]
   12f16:	e7f6      	b.n	12f06 <prvResetNextTaskUnblockTime+0xe>
   12f18:	20008df8 	.word	0x20008df8

00012f1c <prvAddCurrentTaskToDelayedList>:

#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList(TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely)
{
   12f1c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	TickType_t       xTimeToWake;
	const TickType_t xConstTickCount = xTickCount;
   12f20:	4f19      	ldr	r7, [pc, #100]	; (12f88 <prvAddCurrentTaskToDelayedList+0x6c>)
	}
#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12f22:	4b1a      	ldr	r3, [pc, #104]	; (12f8c <prvAddCurrentTaskToDelayedList+0x70>)
	const TickType_t xConstTickCount = xTickCount;
   12f24:	f8d7 62b0 	ldr.w	r6, [r7, #688]	; 0x2b0
{
   12f28:	4605      	mov	r5, r0
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12f2a:	f8d7 02b4 	ldr.w	r0, [r7, #692]	; 0x2b4
   12f2e:	3004      	adds	r0, #4
{
   12f30:	4688      	mov	r8, r1
	if (uxListRemove(&(pxCurrentTCB->xStateListItem)) == (UBaseType_t)0) {
   12f32:	4798      	blx	r3
		mtCOVERAGE_TEST_MARKER();
	}

#if (INCLUDE_vTaskSuspend == 1)
	{
		if ((xTicksToWait == portMAX_DELAY) && (xCanBlockIndefinitely != pdFALSE)) {
   12f34:	1c6b      	adds	r3, r5, #1
   12f36:	463c      	mov	r4, r7
   12f38:	d10b      	bne.n	12f52 <prvAddCurrentTaskToDelayedList+0x36>
   12f3a:	f1b8 0f00 	cmp.w	r8, #0
   12f3e:	d008      	beq.n	12f52 <prvAddCurrentTaskToDelayedList+0x36>
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd(&xSuspendedTaskList, &(pxCurrentTCB->xStateListItem));
   12f40:	f8d7 12b4 	ldr.w	r1, [r7, #692]	; 0x2b4
   12f44:	4b12      	ldr	r3, [pc, #72]	; (12f90 <prvAddCurrentTaskToDelayedList+0x74>)
   12f46:	3104      	adds	r1, #4
   12f48:	f507 7020 	add.w	r0, r7, #640	; 0x280

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		(void)xCanBlockIndefinitely;
	}
#endif /* INCLUDE_vTaskSuspend */
}
   12f4c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   12f50:	4718      	bx	r3
			listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), xTimeToWake);
   12f52:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   12f56:	1975      	adds	r5, r6, r5
   12f58:	605d      	str	r5, [r3, #4]
			if (xTimeToWake < xConstTickCount) {
   12f5a:	4b0e      	ldr	r3, [pc, #56]	; (12f94 <prvAddCurrentTaskToDelayedList+0x78>)
   12f5c:	d305      	bcc.n	12f6a <prvAddCurrentTaskToDelayedList+0x4e>
				vListInsert(pxOverflowDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   12f5e:	f8d4 02b8 	ldr.w	r0, [r4, #696]	; 0x2b8
   12f62:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12f66:	3104      	adds	r1, #4
   12f68:	e7f0      	b.n	12f4c <prvAddCurrentTaskToDelayedList+0x30>
				vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
   12f6a:	f8d4 02a8 	ldr.w	r0, [r4, #680]	; 0x2a8
   12f6e:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   12f72:	3104      	adds	r1, #4
   12f74:	4798      	blx	r3
				if (xTimeToWake < xNextTaskUnblockTime) {
   12f76:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   12f7a:	42ab      	cmp	r3, r5
					xNextTaskUnblockTime = xTimeToWake;
   12f7c:	bf88      	it	hi
   12f7e:	f8c4 52ac 	strhi.w	r5, [r4, #684]	; 0x2ac
}
   12f82:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   12f86:	bf00      	nop
   12f88:	20008df8 	.word	0x20008df8
   12f8c:	0000babf 	.word	0x0000babf
   12f90:	0000ba79 	.word	0x0000ba79
   12f94:	0000ba91 	.word	0x0000ba91

00012f98 <xTaskCreate>:
{
   12f98:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		pxStack = (StackType_t *)pvPortMalloc(
   12f9c:	0095      	lsls	r5, r2, #2
   12f9e:	4c5b      	ldr	r4, [pc, #364]	; (1310c <xTaskCreate+0x174>)
{
   12fa0:	4607      	mov	r7, r0
		pxStack = (StackType_t *)pvPortMalloc(
   12fa2:	4628      	mov	r0, r5
{
   12fa4:	460e      	mov	r6, r1
   12fa6:	4698      	mov	r8, r3
		pxStack = (StackType_t *)pvPortMalloc(
   12fa8:	47a0      	blx	r4
		if (pxStack != NULL) {
   12faa:	4681      	mov	r9, r0
   12fac:	2800      	cmp	r0, #0
   12fae:	f000 809b 	beq.w	130e8 <xTaskCreate+0x150>
			pxNewTCB = (TCB_t *)pvPortMalloc(
   12fb2:	2054      	movs	r0, #84	; 0x54
   12fb4:	47a0      	blx	r4
			if (pxNewTCB != NULL) {
   12fb6:	4604      	mov	r4, r0
   12fb8:	2800      	cmp	r0, #0
   12fba:	f000 8092 	beq.w	130e2 <xTaskCreate+0x14a>
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   12fbe:	4b54      	ldr	r3, [pc, #336]	; (13110 <xTaskCreate+0x178>)
				pxNewTCB->pxStack = pxStack;
   12fc0:	f8c0 9030 	str.w	r9, [r0, #48]	; 0x30
		(void)memset(pxNewTCB->pxStack, (int)tskSTACK_FILL_BYTE, (size_t)ulStackDepth * sizeof(StackType_t));
   12fc4:	462a      	mov	r2, r5
   12fc6:	21a5      	movs	r1, #165	; 0xa5
   12fc8:	4648      	mov	r0, r9
   12fca:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   12fcc:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12fd0:	1e73      	subs	r3, r6, #1
   12fd2:	f104 0234 	add.w	r2, r4, #52	; 0x34
   12fd6:	3607      	adds	r6, #7
		pxNewTCB->pcTaskName[x] = pcName[x];
   12fd8:	f813 1f01 	ldrb.w	r1, [r3, #1]!
   12fdc:	f802 1b01 	strb.w	r1, [r2], #1
		if (pcName[x] == 0x00) {
   12fe0:	7819      	ldrb	r1, [r3, #0]
   12fe2:	b109      	cbz	r1, 12fe8 <xTaskCreate+0x50>
	for (x = (UBaseType_t)0; x < (UBaseType_t)configMAX_TASK_NAME_LEN; x++) {
   12fe4:	42b3      	cmp	r3, r6
   12fe6:	d1f7      	bne.n	12fd8 <xTaskCreate+0x40>
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12fe8:	9e0a      	ldr	r6, [sp, #40]	; 0x28
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12fea:	4a4a      	ldr	r2, [pc, #296]	; (13114 <xTaskCreate+0x17c>)
   12fec:	2e1f      	cmp	r6, #31
   12fee:	bf28      	it	cs
   12ff0:	261f      	movcs	r6, #31
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   12ff2:	f04f 0a00 	mov.w	sl, #0
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   12ff6:	f104 0904 	add.w	r9, r4, #4
		pxNewTCB->uxMutexesHeld  = 0;
   12ffa:	e9c4 6a11 	strd	r6, sl, [r4, #68]	; 0x44
	pxNewTCB->uxPriority = uxPriority;
   12ffe:	62e6      	str	r6, [r4, #44]	; 0x2c
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   13000:	4648      	mov	r0, r9
	pxNewTCB->pcTaskName[configMAX_TASK_NAME_LEN - 1] = '\0';
   13002:	f884 a03b 	strb.w	sl, [r4, #59]	; 0x3b
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   13006:	3d04      	subs	r5, #4
	vListInitialiseItem(&(pxNewTCB->xStateListItem));
   13008:	4790      	blx	r2
	listSET_LIST_ITEM_VALUE(
   1300a:	f1c6 0620 	rsb	r6, r6, #32
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   1300e:	4a41      	ldr	r2, [pc, #260]	; (13114 <xTaskCreate+0x17c>)
   13010:	f104 0018 	add.w	r0, r4, #24
		pxTopOfStack = pxNewTCB->pxStack + (ulStackDepth - (uint32_t)1);
   13014:	445d      	add	r5, fp
	vListInitialiseItem(&(pxNewTCB->xEventListItem));
   13016:	4790      	blx	r2
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   13018:	4b3f      	ldr	r3, [pc, #252]	; (13118 <xTaskCreate+0x180>)
		pxNewTCB->ulNotifiedValue = 0;
   1301a:	f8c4 a04c 	str.w	sl, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xStateListItem), pxNewTCB);
   1301e:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE(
   13020:	61a6      	str	r6, [r4, #24]
	listSET_LIST_ITEM_OWNER(&(pxNewTCB->xEventListItem), pxNewTCB);
   13022:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState   = taskNOT_WAITING_NOTIFICATION;
   13024:	f884 a050 	strb.w	sl, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   13028:	4642      	mov	r2, r8
   1302a:	4639      	mov	r1, r7
   1302c:	f025 0007 	bic.w	r0, r5, #7
   13030:	4798      	blx	r3
	if ((void *)pxCreatedTask != NULL) {
   13032:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack(pxTopOfStack, pxTaskCode, pvParameters);
   13034:	6020      	str	r0, [r4, #0]
	if ((void *)pxCreatedTask != NULL) {
   13036:	b103      	cbz	r3, 1303a <xTaskCreate+0xa2>
		*pxCreatedTask = (TaskHandle_t)pxNewTCB;
   13038:	601c      	str	r4, [r3, #0]
		uxCurrentNumberOfTasks++;
   1303a:	4d38      	ldr	r5, [pc, #224]	; (1311c <xTaskCreate+0x184>)
	taskENTER_CRITICAL();
   1303c:	4b38      	ldr	r3, [pc, #224]	; (13120 <xTaskCreate+0x188>)
   1303e:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   13040:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   13044:	3301      	adds	r3, #1
   13046:	f8c5 32bc 	str.w	r3, [r5, #700]	; 0x2bc
		if (pxCurrentTCB == NULL) {
   1304a:	f8d5 62b4 	ldr.w	r6, [r5, #692]	; 0x2b4
   1304e:	2e00      	cmp	r6, #0
   13050:	d14e      	bne.n	130f0 <xTaskCreate+0x158>
			pxCurrentTCB = pxNewTCB;
   13052:	f8c5 42b4 	str.w	r4, [r5, #692]	; 0x2b4
			if (uxCurrentNumberOfTasks == (UBaseType_t)1) {
   13056:	f8d5 32bc 	ldr.w	r3, [r5, #700]	; 0x2bc
   1305a:	2b01      	cmp	r3, #1
   1305c:	d119      	bne.n	13092 <xTaskCreate+0xfa>
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   1305e:	4f31      	ldr	r7, [pc, #196]	; (13124 <xTaskCreate+0x18c>)
   13060:	46a8      	mov	r8, r5
   13062:	4640      	mov	r0, r8
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   13064:	3601      	adds	r6, #1
		vListInitialise(&(pxReadyTasksLists[uxPriority]));
   13066:	47b8      	blx	r7
	for (uxPriority = (UBaseType_t)0U; uxPriority < (UBaseType_t)configMAX_PRIORITIES; uxPriority++) {
   13068:	2e20      	cmp	r6, #32
   1306a:	f108 0814 	add.w	r8, r8, #20
   1306e:	d1f8      	bne.n	13062 <xTaskCreate+0xca>
	vListInitialise(&xDelayedTaskList1);
   13070:	4e2d      	ldr	r6, [pc, #180]	; (13128 <xTaskCreate+0x190>)
   13072:	4630      	mov	r0, r6
	vListInitialise(&xDelayedTaskList2);
   13074:	f106 0814 	add.w	r8, r6, #20
	vListInitialise(&xDelayedTaskList1);
   13078:	47b8      	blx	r7
	vListInitialise(&xDelayedTaskList2);
   1307a:	4640      	mov	r0, r8
   1307c:	47b8      	blx	r7
	vListInitialise(&xPendingReadyList);
   1307e:	f1a6 002c 	sub.w	r0, r6, #44	; 0x2c
   13082:	47b8      	blx	r7
		vListInitialise(&xSuspendedTaskList);
   13084:	f1a6 0040 	sub.w	r0, r6, #64	; 0x40
   13088:	47b8      	blx	r7
	pxDelayedTaskList         = &xDelayedTaskList1;
   1308a:	f8c5 62a8 	str.w	r6, [r5, #680]	; 0x2a8
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   1308e:	f8c5 82b8 	str.w	r8, [r5, #696]	; 0x2b8
		uxTaskNumber++;
   13092:	f8d5 32ec 	ldr.w	r3, [r5, #748]	; 0x2ec
		prvAddTaskToReadyList(pxNewTCB);
   13096:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
		uxTaskNumber++;
   1309a:	3301      	adds	r3, #1
   1309c:	f8c5 32ec 	str.w	r3, [r5, #748]	; 0x2ec
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   130a0:	63e3      	str	r3, [r4, #60]	; 0x3c
		prvAddTaskToReadyList(pxNewTCB);
   130a2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   130a4:	2014      	movs	r0, #20
   130a6:	4293      	cmp	r3, r2
   130a8:	bf88      	it	hi
   130aa:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   130ae:	fb00 5003 	mla	r0, r0, r3, r5
   130b2:	4649      	mov	r1, r9
   130b4:	4b1d      	ldr	r3, [pc, #116]	; (1312c <xTaskCreate+0x194>)
   130b6:	4798      	blx	r3
	taskEXIT_CRITICAL();
   130b8:	4b1d      	ldr	r3, [pc, #116]	; (13130 <xTaskCreate+0x198>)
   130ba:	4798      	blx	r3
	if (xSchedulerRunning != pdFALSE) {
   130bc:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   130c0:	b16b      	cbz	r3, 130de <xTaskCreate+0x146>
		if (pxCurrentTCB->uxPriority < pxNewTCB->uxPriority) {
   130c2:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   130c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   130c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   130ca:	429a      	cmp	r2, r3
   130cc:	d207      	bcs.n	130de <xTaskCreate+0x146>
			taskYIELD_IF_USING_PREEMPTION();
   130ce:	4b19      	ldr	r3, [pc, #100]	; (13134 <xTaskCreate+0x19c>)
   130d0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   130d4:	601a      	str	r2, [r3, #0]
   130d6:	f3bf 8f4f 	dsb	sy
   130da:	f3bf 8f6f 	isb	sy
		xReturn = pdPASS;
   130de:	2001      	movs	r0, #1
	return xReturn;
   130e0:	e004      	b.n	130ec <xTaskCreate+0x154>
				vPortFree(pxStack);
   130e2:	4b15      	ldr	r3, [pc, #84]	; (13138 <xTaskCreate+0x1a0>)
   130e4:	4648      	mov	r0, r9
   130e6:	4798      	blx	r3
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   130e8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   130ec:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (xSchedulerRunning == pdFALSE) {
   130f0:	f8d5 32e8 	ldr.w	r3, [r5, #744]	; 0x2e8
   130f4:	2b00      	cmp	r3, #0
   130f6:	d1cc      	bne.n	13092 <xTaskCreate+0xfa>
				if (pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority) {
   130f8:	f8d5 32b4 	ldr.w	r3, [r5, #692]	; 0x2b4
   130fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   130fe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   13100:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
   13102:	bf98      	it	ls
   13104:	f8c5 42b4 	strls.w	r4, [r5, #692]	; 0x2b4
   13108:	e7c3      	b.n	13092 <xTaskCreate+0xfa>
   1310a:	bf00      	nop
   1310c:	0000bf75 	.word	0x0000bf75
   13110:	00014d51 	.word	0x00014d51
   13114:	0000ba73 	.word	0x0000ba73
   13118:	0000bb5d 	.word	0x0000bb5d
   1311c:	20008df8 	.word	0x20008df8
   13120:	0000bbb5 	.word	0x0000bbb5
   13124:	0000ba5d 	.word	0x0000ba5d
   13128:	200090b8 	.word	0x200090b8
   1312c:	0000ba79 	.word	0x0000ba79
   13130:	0000bbf9 	.word	0x0000bbf9
   13134:	e000ed04 	.word	0xe000ed04
   13138:	0000c079 	.word	0x0000c079

0001313c <vTaskStartScheduler>:
{
   1313c:	b573      	push	{r0, r1, r4, r5, r6, lr}
		xReturn = xTaskCreate(prvIdleTask,
   1313e:	4c1a      	ldr	r4, [pc, #104]	; (131a8 <vTaskStartScheduler+0x6c>)
   13140:	491a      	ldr	r1, [pc, #104]	; (131ac <vTaskStartScheduler+0x70>)
   13142:	481b      	ldr	r0, [pc, #108]	; (131b0 <vTaskStartScheduler+0x74>)
   13144:	4e1b      	ldr	r6, [pc, #108]	; (131b4 <vTaskStartScheduler+0x78>)
   13146:	f504 733e 	add.w	r3, r4, #760	; 0x2f8
   1314a:	2500      	movs	r5, #0
   1314c:	9301      	str	r3, [sp, #4]
   1314e:	9500      	str	r5, [sp, #0]
   13150:	462b      	mov	r3, r5
   13152:	2240      	movs	r2, #64	; 0x40
   13154:	47b0      	blx	r6
		if (xReturn == pdPASS) {
   13156:	2801      	cmp	r0, #1
   13158:	d118      	bne.n	1318c <vTaskStartScheduler+0x50>
			xReturn = xTimerCreateTimerTask();
   1315a:	4b17      	ldr	r3, [pc, #92]	; (131b8 <vTaskStartScheduler+0x7c>)
   1315c:	4798      	blx	r3
	if (xReturn == pdPASS) {
   1315e:	2801      	cmp	r0, #1
   13160:	d114      	bne.n	1318c <vTaskStartScheduler+0x50>
   13162:	f04f 0380 	mov.w	r3, #128	; 0x80
   13166:	f383 8811 	msr	BASEPRI, r3
   1316a:	f3bf 8f6f 	isb	sy
   1316e:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   13172:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
   13176:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
		if (xPortStartScheduler() != pdFALSE) {
   1317a:	4b10      	ldr	r3, [pc, #64]	; (131bc <vTaskStartScheduler+0x80>)
		xSchedulerRunning    = pdTRUE;
   1317c:	f8c4 02e8 	str.w	r0, [r4, #744]	; 0x2e8
		xTickCount           = (TickType_t)0U;
   13180:	f8c4 52b0 	str.w	r5, [r4, #688]	; 0x2b0
}
   13184:	b002      	add	sp, #8
   13186:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		if (xPortStartScheduler() != pdFALSE) {
   1318a:	4718      	bx	r3
		configASSERT(xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY);
   1318c:	3001      	adds	r0, #1
   1318e:	d108      	bne.n	131a2 <vTaskStartScheduler+0x66>
   13190:	f04f 0380 	mov.w	r3, #128	; 0x80
   13194:	f383 8811 	msr	BASEPRI, r3
   13198:	f3bf 8f6f 	isb	sy
   1319c:	f3bf 8f4f 	dsb	sy
   131a0:	e7fe      	b.n	131a0 <vTaskStartScheduler+0x64>
}
   131a2:	b002      	add	sp, #8
   131a4:	bd70      	pop	{r4, r5, r6, pc}
   131a6:	bf00      	nop
   131a8:	20008df8 	.word	0x20008df8
   131ac:	000174da 	.word	0x000174da
   131b0:	00012ed5 	.word	0x00012ed5
   131b4:	00012f99 	.word	0x00012f99
   131b8:	0000e3ed 	.word	0x0000e3ed
   131bc:	0000bcd9 	.word	0x0000bcd9

000131c0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   131c0:	4a03      	ldr	r2, [pc, #12]	; (131d0 <vTaskSuspendAll+0x10>)
   131c2:	f8d2 32f4 	ldr.w	r3, [r2, #756]	; 0x2f4
   131c6:	3301      	adds	r3, #1
   131c8:	f8c2 32f4 	str.w	r3, [r2, #756]	; 0x2f4
}
   131cc:	4770      	bx	lr
   131ce:	bf00      	nop
   131d0:	20008df8 	.word	0x20008df8

000131d4 <xTaskGetTickCount>:
		xTicks = xTickCount;
   131d4:	4b01      	ldr	r3, [pc, #4]	; (131dc <xTaskGetTickCount+0x8>)
   131d6:	f8d3 02b0 	ldr.w	r0, [r3, #688]	; 0x2b0
}
   131da:	4770      	bx	lr
   131dc:	20008df8 	.word	0x20008df8

000131e0 <pcTaskGetName>:
	pxTCB = prvGetTCBFromHandle(xTaskToQuery);
   131e0:	b960      	cbnz	r0, 131fc <pcTaskGetName+0x1c>
   131e2:	4b07      	ldr	r3, [pc, #28]	; (13200 <pcTaskGetName+0x20>)
   131e4:	f8d3 02b4 	ldr.w	r0, [r3, #692]	; 0x2b4
	configASSERT(pxTCB);
   131e8:	b940      	cbnz	r0, 131fc <pcTaskGetName+0x1c>
   131ea:	f04f 0380 	mov.w	r3, #128	; 0x80
   131ee:	f383 8811 	msr	BASEPRI, r3
   131f2:	f3bf 8f6f 	isb	sy
   131f6:	f3bf 8f4f 	dsb	sy
   131fa:	e7fe      	b.n	131fa <pcTaskGetName+0x1a>
}
   131fc:	3034      	adds	r0, #52	; 0x34
   131fe:	4770      	bx	lr
   13200:	20008df8 	.word	0x20008df8

00013204 <xTaskIncrementTick>:
{
   13204:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   13208:	4b3b      	ldr	r3, [pc, #236]	; (132f8 <xTaskIncrementTick+0xf4>)
   1320a:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   1320e:	461c      	mov	r4, r3
   13210:	2a00      	cmp	r2, #0
   13212:	d16a      	bne.n	132ea <xTaskIncrementTick+0xe6>
		const TickType_t xConstTickCount = xTickCount + (TickType_t)1;
   13214:	f8d3 72b0 	ldr.w	r7, [r3, #688]	; 0x2b0
   13218:	3701      	adds	r7, #1
		xTickCount = xConstTickCount;
   1321a:	f8c3 72b0 	str.w	r7, [r3, #688]	; 0x2b0
		if (xConstTickCount
   1321e:	b9df      	cbnz	r7, 13258 <xTaskIncrementTick+0x54>
			taskSWITCH_DELAYED_LISTS();
   13220:	f8d3 32a8 	ldr.w	r3, [r3, #680]	; 0x2a8
   13224:	681b      	ldr	r3, [r3, #0]
   13226:	b143      	cbz	r3, 1323a <xTaskIncrementTick+0x36>
   13228:	f04f 0380 	mov.w	r3, #128	; 0x80
   1322c:	f383 8811 	msr	BASEPRI, r3
   13230:	f3bf 8f6f 	isb	sy
   13234:	f3bf 8f4f 	dsb	sy
   13238:	e7fe      	b.n	13238 <xTaskIncrementTick+0x34>
   1323a:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   1323e:	f8d4 22b8 	ldr.w	r2, [r4, #696]	; 0x2b8
   13242:	f8c4 22a8 	str.w	r2, [r4, #680]	; 0x2a8
   13246:	f8c4 32b8 	str.w	r3, [r4, #696]	; 0x2b8
   1324a:	f8d4 32fc 	ldr.w	r3, [r4, #764]	; 0x2fc
   1324e:	3301      	adds	r3, #1
   13250:	f8c4 32fc 	str.w	r3, [r4, #764]	; 0x2fc
   13254:	4b29      	ldr	r3, [pc, #164]	; (132fc <xTaskIncrementTick+0xf8>)
   13256:	4798      	blx	r3
		if (xConstTickCount >= xNextTaskUnblockTime) {
   13258:	f8d4 32ac 	ldr.w	r3, [r4, #684]	; 0x2ac
   1325c:	42bb      	cmp	r3, r7
	BaseType_t xSwitchRequired = pdFALSE;
   1325e:	f04f 0500 	mov.w	r5, #0
		if (xConstTickCount >= xNextTaskUnblockTime) {
   13262:	d910      	bls.n	13286 <xTaskIncrementTick+0x82>
			if (listCURRENT_LIST_LENGTH(&(pxReadyTasksLists[pxCurrentTCB->uxPriority])) > (UBaseType_t)1) {
   13264:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   13268:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   1326a:	2314      	movs	r3, #20
   1326c:	4353      	muls	r3, r2
   1326e:	58e3      	ldr	r3, [r4, r3]
				xSwitchRequired = pdTRUE;
   13270:	2b02      	cmp	r3, #2
   13272:	bf28      	it	cs
   13274:	2501      	movcs	r5, #1
		if (xYieldPending != pdFALSE) {
   13276:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
			xSwitchRequired = pdTRUE;
   1327a:	2b00      	cmp	r3, #0
}
   1327c:	bf0c      	ite	eq
   1327e:	4628      	moveq	r0, r5
   13280:	2001      	movne	r0, #1
   13282:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					(void)uxListRemove(&(pxTCB->xStateListItem));
   13286:	f8df 8078 	ldr.w	r8, [pc, #120]	; 13300 <xTaskIncrementTick+0xfc>
					prvAddTaskToReadyList(pxTCB);
   1328a:	f8df 9078 	ldr.w	r9, [pc, #120]	; 13304 <xTaskIncrementTick+0x100>
   1328e:	f04f 0a14 	mov.w	sl, #20
				if (listLIST_IS_EMPTY(pxDelayedTaskList) != pdFALSE) {
   13292:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   13296:	681b      	ldr	r3, [r3, #0]
   13298:	b923      	cbnz	r3, 132a4 <xTaskIncrementTick+0xa0>
					    = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1329a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
						xNextTaskUnblockTime = xItemValue;
   1329e:	f8c4 32ac 	str.w	r3, [r4, #684]	; 0x2ac
						break;
   132a2:	e7df      	b.n	13264 <xTaskIncrementTick+0x60>
					pxTCB      = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxDelayedTaskList);
   132a4:	f8d4 32a8 	ldr.w	r3, [r4, #680]	; 0x2a8
   132a8:	68db      	ldr	r3, [r3, #12]
   132aa:	68de      	ldr	r6, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE(&(pxTCB->xStateListItem));
   132ac:	6873      	ldr	r3, [r6, #4]
					if (xConstTickCount < xItemValue) {
   132ae:	429f      	cmp	r7, r3
   132b0:	d3f5      	bcc.n	1329e <xTaskIncrementTick+0x9a>
					(void)uxListRemove(&(pxTCB->xStateListItem));
   132b2:	f106 0b04 	add.w	fp, r6, #4
   132b6:	4658      	mov	r0, fp
   132b8:	47c0      	blx	r8
					if (listLIST_ITEM_CONTAINER(&(pxTCB->xEventListItem)) != NULL) {
   132ba:	6ab3      	ldr	r3, [r6, #40]	; 0x28
   132bc:	b113      	cbz	r3, 132c4 <xTaskIncrementTick+0xc0>
						(void)uxListRemove(&(pxTCB->xEventListItem));
   132be:	f106 0018 	add.w	r0, r6, #24
   132c2:	47c0      	blx	r8
					prvAddTaskToReadyList(pxTCB);
   132c4:	6af0      	ldr	r0, [r6, #44]	; 0x2c
   132c6:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   132ca:	4298      	cmp	r0, r3
   132cc:	bf88      	it	hi
   132ce:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   132d2:	4659      	mov	r1, fp
   132d4:	fb0a 4000 	mla	r0, sl, r0, r4
   132d8:	47c8      	blx	r9
						if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   132da:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   132de:	6af2      	ldr	r2, [r6, #44]	; 0x2c
   132e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   132e2:	429a      	cmp	r2, r3
   132e4:	bf28      	it	cs
   132e6:	2501      	movcs	r5, #1
   132e8:	e7d3      	b.n	13292 <xTaskIncrementTick+0x8e>
		++uxPendedTicks;
   132ea:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
   132ee:	3301      	adds	r3, #1
   132f0:	f8c4 3300 	str.w	r3, [r4, #768]	; 0x300
	BaseType_t xSwitchRequired = pdFALSE;
   132f4:	2500      	movs	r5, #0
   132f6:	e7be      	b.n	13276 <xTaskIncrementTick+0x72>
   132f8:	20008df8 	.word	0x20008df8
   132fc:	00012ef9 	.word	0x00012ef9
   13300:	0000babf 	.word	0x0000babf
   13304:	0000ba79 	.word	0x0000ba79

00013308 <xTaskResumeAll>:
{
   13308:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	configASSERT(uxSchedulerSuspended);
   1330c:	4c33      	ldr	r4, [pc, #204]	; (133dc <xTaskResumeAll+0xd4>)
   1330e:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   13312:	b943      	cbnz	r3, 13326 <xTaskResumeAll+0x1e>
   13314:	f04f 0380 	mov.w	r3, #128	; 0x80
   13318:	f383 8811 	msr	BASEPRI, r3
   1331c:	f3bf 8f6f 	isb	sy
   13320:	f3bf 8f4f 	dsb	sy
   13324:	e7fe      	b.n	13324 <xTaskResumeAll+0x1c>
	taskENTER_CRITICAL();
   13326:	4b2e      	ldr	r3, [pc, #184]	; (133e0 <xTaskResumeAll+0xd8>)
   13328:	4798      	blx	r3
		--uxSchedulerSuspended;
   1332a:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   1332e:	3b01      	subs	r3, #1
   13330:	f8c4 32f4 	str.w	r3, [r4, #756]	; 0x2f4
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   13334:	f8d4 52f4 	ldr.w	r5, [r4, #756]	; 0x2f4
   13338:	b135      	cbz	r5, 13348 <xTaskResumeAll+0x40>
	BaseType_t xAlreadyYielded = pdFALSE;
   1333a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1333c:	4b29      	ldr	r3, [pc, #164]	; (133e4 <xTaskResumeAll+0xdc>)
   1333e:	4798      	blx	r3
}
   13340:	4620      	mov	r0, r4
   13342:	b002      	add	sp, #8
   13344:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (uxCurrentNumberOfTasks > (UBaseType_t)0U) {
   13348:	f8d4 32bc 	ldr.w	r3, [r4, #700]	; 0x2bc
   1334c:	2b00      	cmp	r3, #0
   1334e:	d0f4      	beq.n	1333a <xTaskResumeAll+0x32>
					(void)uxListRemove(&(pxTCB->xEventListItem));
   13350:	4e25      	ldr	r6, [pc, #148]	; (133e8 <xTaskResumeAll+0xe0>)
					prvAddTaskToReadyList(pxTCB);
   13352:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 133f8 <xTaskResumeAll+0xf0>
   13356:	2714      	movs	r7, #20
   13358:	e01d      	b.n	13396 <xTaskResumeAll+0x8e>
					pxTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY((&xPendingReadyList));
   1335a:	f8d4 32a0 	ldr.w	r3, [r4, #672]	; 0x2a0
   1335e:	68dd      	ldr	r5, [r3, #12]
					(void)uxListRemove(&(pxTCB->xEventListItem));
   13360:	f105 0018 	add.w	r0, r5, #24
   13364:	47b0      	blx	r6
					(void)uxListRemove(&(pxTCB->xStateListItem));
   13366:	1d29      	adds	r1, r5, #4
   13368:	4608      	mov	r0, r1
   1336a:	9101      	str	r1, [sp, #4]
   1336c:	47b0      	blx	r6
					prvAddTaskToReadyList(pxTCB);
   1336e:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
   13370:	f8d4 32f0 	ldr.w	r3, [r4, #752]	; 0x2f0
   13374:	9901      	ldr	r1, [sp, #4]
   13376:	4298      	cmp	r0, r3
   13378:	bf88      	it	hi
   1337a:	f8c4 02f0 	strhi.w	r0, [r4, #752]	; 0x2f0
   1337e:	fb07 4000 	mla	r0, r7, r0, r4
   13382:	47c0      	blx	r8
					if (pxTCB->uxPriority >= pxCurrentTCB->uxPriority) {
   13384:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   13388:	6aea      	ldr	r2, [r5, #44]	; 0x2c
   1338a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   1338c:	429a      	cmp	r2, r3
   1338e:	d302      	bcc.n	13396 <xTaskResumeAll+0x8e>
						xYieldPending = pdTRUE;
   13390:	2301      	movs	r3, #1
   13392:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
				while (listLIST_IS_EMPTY(&xPendingReadyList) == pdFALSE) {
   13396:	f8d4 3294 	ldr.w	r3, [r4, #660]	; 0x294
   1339a:	2b00      	cmp	r3, #0
   1339c:	d1dd      	bne.n	1335a <xTaskResumeAll+0x52>
				if (pxTCB != NULL) {
   1339e:	b10d      	cbz	r5, 133a4 <xTaskResumeAll+0x9c>
					prvResetNextTaskUnblockTime();
   133a0:	4b12      	ldr	r3, [pc, #72]	; (133ec <xTaskResumeAll+0xe4>)
   133a2:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   133a4:	f8d4 5300 	ldr.w	r5, [r4, #768]	; 0x300
					if (uxPendedCounts > (UBaseType_t)0U) {
   133a8:	b14d      	cbz	r5, 133be <xTaskResumeAll+0xb6>
							if (xTaskIncrementTick() != pdFALSE) {
   133aa:	4e11      	ldr	r6, [pc, #68]	; (133f0 <xTaskResumeAll+0xe8>)
								xYieldPending = pdTRUE;
   133ac:	2701      	movs	r7, #1
							if (xTaskIncrementTick() != pdFALSE) {
   133ae:	47b0      	blx	r6
   133b0:	b108      	cbz	r0, 133b6 <xTaskResumeAll+0xae>
								xYieldPending = pdTRUE;
   133b2:	f8c4 7304 	str.w	r7, [r4, #772]	; 0x304
						} while (uxPendedCounts > (UBaseType_t)0U);
   133b6:	3d01      	subs	r5, #1
   133b8:	d1f9      	bne.n	133ae <xTaskResumeAll+0xa6>
						uxPendedTicks = 0;
   133ba:	f8c4 5300 	str.w	r5, [r4, #768]	; 0x300
				if (xYieldPending != pdFALSE) {
   133be:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
   133c2:	2b00      	cmp	r3, #0
   133c4:	d0b9      	beq.n	1333a <xTaskResumeAll+0x32>
					taskYIELD_IF_USING_PREEMPTION();
   133c6:	4b0b      	ldr	r3, [pc, #44]	; (133f4 <xTaskResumeAll+0xec>)
   133c8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   133cc:	601a      	str	r2, [r3, #0]
   133ce:	f3bf 8f4f 	dsb	sy
   133d2:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   133d6:	2401      	movs	r4, #1
   133d8:	e7b0      	b.n	1333c <xTaskResumeAll+0x34>
   133da:	bf00      	nop
   133dc:	20008df8 	.word	0x20008df8
   133e0:	0000bbb5 	.word	0x0000bbb5
   133e4:	0000bbf9 	.word	0x0000bbf9
   133e8:	0000babf 	.word	0x0000babf
   133ec:	00012ef9 	.word	0x00012ef9
   133f0:	00013205 	.word	0x00013205
   133f4:	e000ed04 	.word	0xe000ed04
   133f8:	0000ba79 	.word	0x0000ba79

000133fc <vTaskDelay>:
{
   133fc:	b508      	push	{r3, lr}
	if (xTicksToDelay > (TickType_t)0U) {
   133fe:	b940      	cbnz	r0, 13412 <vTaskDelay+0x16>
		portYIELD_WITHIN_API();
   13400:	4b0f      	ldr	r3, [pc, #60]	; (13440 <vTaskDelay+0x44>)
   13402:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   13406:	601a      	str	r2, [r3, #0]
   13408:	f3bf 8f4f 	dsb	sy
   1340c:	f3bf 8f6f 	isb	sy
}
   13410:	bd08      	pop	{r3, pc}
		configASSERT(uxSchedulerSuspended == 0);
   13412:	4b0c      	ldr	r3, [pc, #48]	; (13444 <vTaskDelay+0x48>)
   13414:	f8d3 12f4 	ldr.w	r1, [r3, #756]	; 0x2f4
   13418:	b141      	cbz	r1, 1342c <vTaskDelay+0x30>
   1341a:	f04f 0380 	mov.w	r3, #128	; 0x80
   1341e:	f383 8811 	msr	BASEPRI, r3
   13422:	f3bf 8f6f 	isb	sy
   13426:	f3bf 8f4f 	dsb	sy
   1342a:	e7fe      	b.n	1342a <vTaskDelay+0x2e>
		vTaskSuspendAll();
   1342c:	4b06      	ldr	r3, [pc, #24]	; (13448 <vTaskDelay+0x4c>)
   1342e:	4798      	blx	r3
			prvAddCurrentTaskToDelayedList(xTicksToDelay, pdFALSE);
   13430:	4b06      	ldr	r3, [pc, #24]	; (1344c <vTaskDelay+0x50>)
   13432:	4798      	blx	r3
		xAlreadyYielded = xTaskResumeAll();
   13434:	4b06      	ldr	r3, [pc, #24]	; (13450 <vTaskDelay+0x54>)
   13436:	4798      	blx	r3
	if (xAlreadyYielded == pdFALSE) {
   13438:	2800      	cmp	r0, #0
   1343a:	d0e1      	beq.n	13400 <vTaskDelay+0x4>
   1343c:	e7e8      	b.n	13410 <vTaskDelay+0x14>
   1343e:	bf00      	nop
   13440:	e000ed04 	.word	0xe000ed04
   13444:	20008df8 	.word	0x20008df8
   13448:	000131c1 	.word	0x000131c1
   1344c:	00012f1d 	.word	0x00012f1d
   13450:	00013309 	.word	0x00013309

00013454 <vTaskSwitchContext>:
{
   13454:	b538      	push	{r3, r4, r5, lr}
	if (uxSchedulerSuspended != (UBaseType_t)pdFALSE) {
   13456:	4b20      	ldr	r3, [pc, #128]	; (134d8 <vTaskSwitchContext+0x84>)
   13458:	f8d3 22f4 	ldr.w	r2, [r3, #756]	; 0x2f4
   1345c:	461c      	mov	r4, r3
   1345e:	b11a      	cbz	r2, 13468 <vTaskSwitchContext+0x14>
		xYieldPending = pdTRUE;
   13460:	2201      	movs	r2, #1
   13462:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   13466:	bd38      	pop	{r3, r4, r5, pc}
		xYieldPending = pdFALSE;
   13468:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		taskCHECK_FOR_STACK_OVERFLOW();
   1346c:	f8d3 22b4 	ldr.w	r2, [r3, #692]	; 0x2b4
   13470:	f8d3 32b4 	ldr.w	r3, [r3, #692]	; 0x2b4
   13474:	6812      	ldr	r2, [r2, #0]
   13476:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   13478:	429a      	cmp	r2, r3
   1347a:	d806      	bhi.n	1348a <vTaskSwitchContext+0x36>
   1347c:	f8d4 02b4 	ldr.w	r0, [r4, #692]	; 0x2b4
   13480:	f8d4 12b4 	ldr.w	r1, [r4, #692]	; 0x2b4
   13484:	4b15      	ldr	r3, [pc, #84]	; (134dc <vTaskSwitchContext+0x88>)
   13486:	3134      	adds	r1, #52	; 0x34
   13488:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
   1348a:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   1348e:	2514      	movs	r5, #20
   13490:	fb05 f302 	mul.w	r3, r5, r2
   13494:	18e1      	adds	r1, r4, r3
   13496:	58e0      	ldr	r0, [r4, r3]
   13498:	b190      	cbz	r0, 134c0 <vTaskSwitchContext+0x6c>
   1349a:	6848      	ldr	r0, [r1, #4]
   1349c:	3308      	adds	r3, #8
   1349e:	6840      	ldr	r0, [r0, #4]
   134a0:	6048      	str	r0, [r1, #4]
   134a2:	4423      	add	r3, r4
   134a4:	4298      	cmp	r0, r3
   134a6:	bf04      	itt	eq
   134a8:	6843      	ldreq	r3, [r0, #4]
   134aa:	604b      	streq	r3, [r1, #4]
   134ac:	2314      	movs	r3, #20
   134ae:	fb03 4302 	mla	r3, r3, r2, r4
   134b2:	685b      	ldr	r3, [r3, #4]
   134b4:	68db      	ldr	r3, [r3, #12]
   134b6:	f8c4 32b4 	str.w	r3, [r4, #692]	; 0x2b4
   134ba:	f8c4 22f0 	str.w	r2, [r4, #752]	; 0x2f0
}
   134be:	e7d2      	b.n	13466 <vTaskSwitchContext+0x12>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   134c0:	b942      	cbnz	r2, 134d4 <vTaskSwitchContext+0x80>
   134c2:	f04f 0380 	mov.w	r3, #128	; 0x80
   134c6:	f383 8811 	msr	BASEPRI, r3
   134ca:	f3bf 8f6f 	isb	sy
   134ce:	f3bf 8f4f 	dsb	sy
   134d2:	e7fe      	b.n	134d2 <vTaskSwitchContext+0x7e>
   134d4:	3a01      	subs	r2, #1
   134d6:	e7db      	b.n	13490 <vTaskSwitchContext+0x3c>
   134d8:	20008df8 	.word	0x20008df8
   134dc:	00012a11 	.word	0x00012a11

000134e0 <vTaskPlaceOnEventList>:
{
   134e0:	b510      	push	{r4, lr}
   134e2:	460c      	mov	r4, r1
	configASSERT(pxEventList);
   134e4:	b940      	cbnz	r0, 134f8 <vTaskPlaceOnEventList+0x18>
   134e6:	f04f 0380 	mov.w	r3, #128	; 0x80
   134ea:	f383 8811 	msr	BASEPRI, r3
   134ee:	f3bf 8f6f 	isb	sy
   134f2:	f3bf 8f4f 	dsb	sy
   134f6:	e7fe      	b.n	134f6 <vTaskPlaceOnEventList+0x16>
	vListInsert(pxEventList, &(pxCurrentTCB->xEventListItem));
   134f8:	4b05      	ldr	r3, [pc, #20]	; (13510 <vTaskPlaceOnEventList+0x30>)
   134fa:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   134fe:	4b05      	ldr	r3, [pc, #20]	; (13514 <vTaskPlaceOnEventList+0x34>)
   13500:	3118      	adds	r1, #24
   13502:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   13504:	4620      	mov	r0, r4
   13506:	4b04      	ldr	r3, [pc, #16]	; (13518 <vTaskPlaceOnEventList+0x38>)
}
   13508:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, pdTRUE);
   1350c:	2101      	movs	r1, #1
   1350e:	4718      	bx	r3
   13510:	20008df8 	.word	0x20008df8
   13514:	0000ba91 	.word	0x0000ba91
   13518:	00012f1d 	.word	0x00012f1d

0001351c <vTaskPlaceOnEventListRestricted>:
{
   1351c:	b570      	push	{r4, r5, r6, lr}
   1351e:	460d      	mov	r5, r1
   13520:	4614      	mov	r4, r2
	configASSERT(pxEventList);
   13522:	b940      	cbnz	r0, 13536 <vTaskPlaceOnEventListRestricted+0x1a>
   13524:	f04f 0380 	mov.w	r3, #128	; 0x80
   13528:	f383 8811 	msr	BASEPRI, r3
   1352c:	f3bf 8f6f 	isb	sy
   13530:	f3bf 8f4f 	dsb	sy
   13534:	e7fe      	b.n	13534 <vTaskPlaceOnEventListRestricted+0x18>
	vListInsertEnd(pxEventList, &(pxCurrentTCB->xEventListItem));
   13536:	4b08      	ldr	r3, [pc, #32]	; (13558 <vTaskPlaceOnEventListRestricted+0x3c>)
   13538:	f8d3 12b4 	ldr.w	r1, [r3, #692]	; 0x2b4
   1353c:	4b07      	ldr	r3, [pc, #28]	; (1355c <vTaskPlaceOnEventListRestricted+0x40>)
   1353e:	3118      	adds	r1, #24
   13540:	4798      	blx	r3
		xTicksToWait = portMAX_DELAY;
   13542:	2c00      	cmp	r4, #0
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   13544:	4621      	mov	r1, r4
   13546:	bf08      	it	eq
   13548:	4628      	moveq	r0, r5
   1354a:	4b05      	ldr	r3, [pc, #20]	; (13560 <vTaskPlaceOnEventListRestricted+0x44>)
}
   1354c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	prvAddCurrentTaskToDelayedList(xTicksToWait, xWaitIndefinitely);
   13550:	bf18      	it	ne
   13552:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
   13556:	4718      	bx	r3
   13558:	20008df8 	.word	0x20008df8
   1355c:	0000ba79 	.word	0x0000ba79
   13560:	00012f1d 	.word	0x00012f1d

00013564 <xTaskRemoveFromEventList>:
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   13564:	68c3      	ldr	r3, [r0, #12]
{
   13566:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	pxUnblockedTCB = (TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(pxEventList);
   13568:	68df      	ldr	r7, [r3, #12]
	configASSERT(pxUnblockedTCB);
   1356a:	b947      	cbnz	r7, 1357e <xTaskRemoveFromEventList+0x1a>
   1356c:	f04f 0380 	mov.w	r3, #128	; 0x80
   13570:	f383 8811 	msr	BASEPRI, r3
   13574:	f3bf 8f6f 	isb	sy
   13578:	f3bf 8f4f 	dsb	sy
   1357c:	e7fe      	b.n	1357c <xTaskRemoveFromEventList+0x18>
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   1357e:	f107 0118 	add.w	r1, r7, #24
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   13582:	4c15      	ldr	r4, [pc, #84]	; (135d8 <xTaskRemoveFromEventList+0x74>)
	(void)uxListRemove(&(pxUnblockedTCB->xEventListItem));
   13584:	4e15      	ldr	r6, [pc, #84]	; (135dc <xTaskRemoveFromEventList+0x78>)
   13586:	9101      	str	r1, [sp, #4]
   13588:	4608      	mov	r0, r1
   1358a:	47b0      	blx	r6
	if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   1358c:	f8d4 32f4 	ldr.w	r3, [r4, #756]	; 0x2f4
   13590:	4d13      	ldr	r5, [pc, #76]	; (135e0 <xTaskRemoveFromEventList+0x7c>)
   13592:	9901      	ldr	r1, [sp, #4]
   13594:	b9e3      	cbnz	r3, 135d0 <xTaskRemoveFromEventList+0x6c>
		(void)uxListRemove(&(pxUnblockedTCB->xStateListItem));
   13596:	1d39      	adds	r1, r7, #4
   13598:	4608      	mov	r0, r1
   1359a:	9101      	str	r1, [sp, #4]
   1359c:	47b0      	blx	r6
		prvAddTaskToReadyList(pxUnblockedTCB);
   1359e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
   135a0:	f8d4 22f0 	ldr.w	r2, [r4, #752]	; 0x2f0
   135a4:	9901      	ldr	r1, [sp, #4]
   135a6:	4293      	cmp	r3, r2
   135a8:	f04f 0014 	mov.w	r0, #20
   135ac:	bf88      	it	hi
   135ae:	f8c4 32f0 	strhi.w	r3, [r4, #752]	; 0x2f0
   135b2:	fb00 4003 	mla	r0, r0, r3, r4
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   135b6:	47a8      	blx	r5
	if (pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority) {
   135b8:	f8d4 32b4 	ldr.w	r3, [r4, #692]	; 0x2b4
   135bc:	6afa      	ldr	r2, [r7, #44]	; 0x2c
   135be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   135c0:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   135c2:	bf8a      	itet	hi
   135c4:	2001      	movhi	r0, #1
		xReturn = pdFALSE;
   135c6:	2000      	movls	r0, #0
		xYieldPending = pdTRUE;
   135c8:	f8c4 0304 	strhi.w	r0, [r4, #772]	; 0x304
}
   135cc:	b003      	add	sp, #12
   135ce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		vListInsertEnd(&(xPendingReadyList), &(pxUnblockedTCB->xEventListItem));
   135d0:	f504 7025 	add.w	r0, r4, #660	; 0x294
   135d4:	e7ef      	b.n	135b6 <xTaskRemoveFromEventList+0x52>
   135d6:	bf00      	nop
   135d8:	20008df8 	.word	0x20008df8
   135dc:	0000babf 	.word	0x0000babf
   135e0:	0000ba79 	.word	0x0000ba79

000135e4 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   135e4:	4b03      	ldr	r3, [pc, #12]	; (135f4 <vTaskInternalSetTimeOutState+0x10>)
   135e6:	f8d3 22fc 	ldr.w	r2, [r3, #764]	; 0x2fc
	pxTimeOut->xTimeOnEntering = xTickCount;
   135ea:	f8d3 32b0 	ldr.w	r3, [r3, #688]	; 0x2b0
	pxTimeOut->xOverflowCount  = xNumOfOverflows;
   135ee:	6002      	str	r2, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   135f0:	6043      	str	r3, [r0, #4]
}
   135f2:	4770      	bx	lr
   135f4:	20008df8 	.word	0x20008df8

000135f8 <xTaskCheckForTimeOut>:
{
   135f8:	b570      	push	{r4, r5, r6, lr}
   135fa:	460c      	mov	r4, r1
	configASSERT(pxTimeOut);
   135fc:	4605      	mov	r5, r0
   135fe:	b940      	cbnz	r0, 13612 <xTaskCheckForTimeOut+0x1a>
   13600:	f04f 0380 	mov.w	r3, #128	; 0x80
   13604:	f383 8811 	msr	BASEPRI, r3
   13608:	f3bf 8f6f 	isb	sy
   1360c:	f3bf 8f4f 	dsb	sy
   13610:	e7fe      	b.n	13610 <xTaskCheckForTimeOut+0x18>
	configASSERT(pxTicksToWait);
   13612:	b941      	cbnz	r1, 13626 <xTaskCheckForTimeOut+0x2e>
   13614:	f04f 0380 	mov.w	r3, #128	; 0x80
   13618:	f383 8811 	msr	BASEPRI, r3
   1361c:	f3bf 8f6f 	isb	sy
   13620:	f3bf 8f4f 	dsb	sy
   13624:	e7fe      	b.n	13624 <xTaskCheckForTimeOut+0x2c>
	taskENTER_CRITICAL();
   13626:	4b11      	ldr	r3, [pc, #68]	; (1366c <xTaskCheckForTimeOut+0x74>)
   13628:	4798      	blx	r3
		    if (*pxTicksToWait == portMAX_DELAY) {
   1362a:	6823      	ldr	r3, [r4, #0]
		const TickType_t xConstTickCount = xTickCount;
   1362c:	4810      	ldr	r0, [pc, #64]	; (13670 <xTaskCheckForTimeOut+0x78>)
		    if (*pxTicksToWait == portMAX_DELAY) {
   1362e:	1c5a      	adds	r2, r3, #1
		const TickType_t xConstTickCount = xTickCount;
   13630:	f8d0 12b0 	ldr.w	r1, [r0, #688]	; 0x2b0
		    if (*pxTicksToWait == portMAX_DELAY) {
   13634:	d010      	beq.n	13658 <xTaskCheckForTimeOut+0x60>
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   13636:	f8d0 02fc 	ldr.w	r0, [r0, #764]	; 0x2fc
   1363a:	682e      	ldr	r6, [r5, #0]
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   1363c:	686a      	ldr	r2, [r5, #4]
		    if ((xNumOfOverflows != pxTimeOut->xOverflowCount)
   1363e:	4286      	cmp	r6, r0
   13640:	d001      	beq.n	13646 <xTaskCheckForTimeOut+0x4e>
		        && (xConstTickCount >= pxTimeOut->xTimeOnEntering)) /*lint !e525 Indentation preferred as is to make
   13642:	428a      	cmp	r2, r1
   13644:	d90f      	bls.n	13666 <xTaskCheckForTimeOut+0x6e>
		const TickType_t xElapsedTime    = xConstTickCount - pxTimeOut->xTimeOnEntering;
   13646:	1a88      	subs	r0, r1, r2
		} else if (xElapsedTime < *pxTicksToWait) /*lint !e961 Explicit casting is only redundant with some compilers,
   13648:	4283      	cmp	r3, r0
   1364a:	d90a      	bls.n	13662 <xTaskCheckForTimeOut+0x6a>
			*pxTicksToWait -= xElapsedTime;
   1364c:	1a5b      	subs	r3, r3, r1
   1364e:	4413      	add	r3, r2
   13650:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState(pxTimeOut);
   13652:	4628      	mov	r0, r5
   13654:	4b07      	ldr	r3, [pc, #28]	; (13674 <xTaskCheckForTimeOut+0x7c>)
   13656:	4798      	blx	r3
			xReturn = pdFALSE;
   13658:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   1365a:	4b07      	ldr	r3, [pc, #28]	; (13678 <xTaskCheckForTimeOut+0x80>)
   1365c:	4798      	blx	r3
}
   1365e:	4620      	mov	r0, r4
   13660:	bd70      	pop	{r4, r5, r6, pc}
			*pxTicksToWait = 0;
   13662:	2300      	movs	r3, #0
   13664:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
   13666:	2401      	movs	r4, #1
   13668:	e7f7      	b.n	1365a <xTaskCheckForTimeOut+0x62>
   1366a:	bf00      	nop
   1366c:	0000bbb5 	.word	0x0000bbb5
   13670:	20008df8 	.word	0x20008df8
   13674:	000135e5 	.word	0x000135e5
   13678:	0000bbf9 	.word	0x0000bbf9

0001367c <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   1367c:	4b02      	ldr	r3, [pc, #8]	; (13688 <vTaskMissedYield+0xc>)
   1367e:	2201      	movs	r2, #1
   13680:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
   13684:	4770      	bx	lr
   13686:	bf00      	nop
   13688:	20008df8 	.word	0x20008df8

0001368c <xTaskGetSchedulerState>:
	if (xSchedulerRunning == pdFALSE) {
   1368c:	4b06      	ldr	r3, [pc, #24]	; (136a8 <xTaskGetSchedulerState+0x1c>)
   1368e:	f8d3 22e8 	ldr.w	r2, [r3, #744]	; 0x2e8
   13692:	b132      	cbz	r2, 136a2 <xTaskGetSchedulerState+0x16>
		if (uxSchedulerSuspended == (UBaseType_t)pdFALSE) {
   13694:	f8d3 32f4 	ldr.w	r3, [r3, #756]	; 0x2f4
   13698:	2b00      	cmp	r3, #0
			xReturn = taskSCHEDULER_SUSPENDED;
   1369a:	bf0c      	ite	eq
   1369c:	2002      	moveq	r0, #2
   1369e:	2000      	movne	r0, #0
   136a0:	4770      	bx	lr
		xReturn = taskSCHEDULER_NOT_STARTED;
   136a2:	2001      	movs	r0, #1
}
   136a4:	4770      	bx	lr
   136a6:	bf00      	nop
   136a8:	20008df8 	.word	0x20008df8

000136ac <xTaskPriorityDisinherit>:
{
   136ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
	if (pxMutexHolder != NULL) {
   136ae:	b910      	cbnz	r0, 136b6 <xTaskPriorityDisinherit+0xa>
	BaseType_t   xReturn = pdFALSE;
   136b0:	2000      	movs	r0, #0
}
   136b2:	b003      	add	sp, #12
   136b4:	bd30      	pop	{r4, r5, pc}
		configASSERT(pxTCB == pxCurrentTCB);
   136b6:	4d1d      	ldr	r5, [pc, #116]	; (1372c <xTaskPriorityDisinherit+0x80>)
   136b8:	f8d5 42b4 	ldr.w	r4, [r5, #692]	; 0x2b4
   136bc:	4284      	cmp	r4, r0
   136be:	d008      	beq.n	136d2 <xTaskPriorityDisinherit+0x26>
   136c0:	f04f 0380 	mov.w	r3, #128	; 0x80
   136c4:	f383 8811 	msr	BASEPRI, r3
   136c8:	f3bf 8f6f 	isb	sy
   136cc:	f3bf 8f4f 	dsb	sy
   136d0:	e7fe      	b.n	136d0 <xTaskPriorityDisinherit+0x24>
		configASSERT(pxTCB->uxMutexesHeld);
   136d2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
   136d4:	b943      	cbnz	r3, 136e8 <xTaskPriorityDisinherit+0x3c>
   136d6:	f04f 0380 	mov.w	r3, #128	; 0x80
   136da:	f383 8811 	msr	BASEPRI, r3
   136de:	f3bf 8f6f 	isb	sy
   136e2:	f3bf 8f4f 	dsb	sy
   136e6:	e7fe      	b.n	136e6 <xTaskPriorityDisinherit+0x3a>
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   136e8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   136ea:	6c62      	ldr	r2, [r4, #68]	; 0x44
		(pxTCB->uxMutexesHeld)--;
   136ec:	3b01      	subs	r3, #1
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   136ee:	4291      	cmp	r1, r2
		(pxTCB->uxMutexesHeld)--;
   136f0:	64a3      	str	r3, [r4, #72]	; 0x48
		if (pxTCB->uxPriority != pxTCB->uxBasePriority) {
   136f2:	d0dd      	beq.n	136b0 <xTaskPriorityDisinherit+0x4>
			if (pxTCB->uxMutexesHeld == (UBaseType_t)0) {
   136f4:	2b00      	cmp	r3, #0
   136f6:	d1db      	bne.n	136b0 <xTaskPriorityDisinherit+0x4>
				if (uxListRemove(&(pxTCB->xStateListItem)) == (UBaseType_t)0) {
   136f8:	1d21      	adds	r1, r4, #4
   136fa:	4b0d      	ldr	r3, [pc, #52]	; (13730 <xTaskPriorityDisinherit+0x84>)
   136fc:	9101      	str	r1, [sp, #4]
   136fe:	4608      	mov	r0, r1
   13700:	4798      	blx	r3
				pxTCB->uxPriority = pxTCB->uxBasePriority;
   13702:	6c63      	ldr	r3, [r4, #68]	; 0x44
   13704:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE(
   13706:	f1c3 0220 	rsb	r2, r3, #32
   1370a:	61a2      	str	r2, [r4, #24]
				prvAddTaskToReadyList(pxTCB);
   1370c:	f8d5 22f0 	ldr.w	r2, [r5, #752]	; 0x2f0
   13710:	9901      	ldr	r1, [sp, #4]
   13712:	4293      	cmp	r3, r2
   13714:	f04f 0014 	mov.w	r0, #20
   13718:	fb00 5003 	mla	r0, r0, r3, r5
   1371c:	bf88      	it	hi
   1371e:	f8c5 32f0 	strhi.w	r3, [r5, #752]	; 0x2f0
   13722:	4b04      	ldr	r3, [pc, #16]	; (13734 <xTaskPriorityDisinherit+0x88>)
   13724:	4798      	blx	r3
				xReturn = pdTRUE;
   13726:	2001      	movs	r0, #1
	return xReturn;
   13728:	e7c3      	b.n	136b2 <xTaskPriorityDisinherit+0x6>
   1372a:	bf00      	nop
   1372c:	20008df8 	.word	0x20008df8
   13730:	0000babf 	.word	0x0000babf
   13734:	0000ba79 	.word	0x0000ba79

00013738 <event_system_init>:
/**
 * \brief Initialize event system.
 */
int32_t event_system_init(void)
{
	return _event_system_init();
   13738:	4b00      	ldr	r3, [pc, #0]	; (1373c <event_system_init+0x4>)
   1373a:	4718      	bx	r3
   1373c:	0000c3ad 	.word	0x0000c3ad

00013740 <hri_adc_wait_for_sync>:
typedef uint8_t  hri_adc_status_reg_t;
typedef uint8_t  hri_adc_swtrig_reg_t;

static inline void hri_adc_wait_for_sync(const void *const hw, hri_adc_syncbusy_reg_t reg)
{
	while (((Adc *)hw)->SYNCBUSY.reg & reg) {
   13740:	6b03      	ldr	r3, [r0, #48]	; 0x30
   13742:	420b      	tst	r3, r1
   13744:	d1fc      	bne.n	13740 <hri_adc_wait_for_sync>
	};
}
   13746:	4770      	bx	lr

00013748 <hri_adc_set_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg |= ADC_CTRLA_ENABLE;
   13748:	8803      	ldrh	r3, [r0, #0]
   1374a:	b29b      	uxth	r3, r3
   1374c:	f043 0302 	orr.w	r3, r3, #2
   13750:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   13752:	2103      	movs	r1, #3
   13754:	4b00      	ldr	r3, [pc, #0]	; (13758 <hri_adc_set_CTRLA_ENABLE_bit+0x10>)
   13756:	4718      	bx	r3
   13758:	00013741 	.word	0x00013741

0001375c <hri_adc_clear_CTRLA_ENABLE_bit>:
}

static inline void hri_adc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg &= ~ADC_CTRLA_ENABLE;
   1375c:	8803      	ldrh	r3, [r0, #0]
   1375e:	f023 0302 	bic.w	r3, r3, #2
   13762:	041b      	lsls	r3, r3, #16
   13764:	0c1b      	lsrs	r3, r3, #16
   13766:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   13768:	2103      	movs	r1, #3
   1376a:	4b01      	ldr	r3, [pc, #4]	; (13770 <hri_adc_clear_CTRLA_ENABLE_bit+0x14>)
   1376c:	4718      	bx	r3
   1376e:	bf00      	nop
   13770:	00013741 	.word	0x00013741

00013774 <_adc_interrupt_handler>:
 *
 * \param[in] p The pointer to interrupt parameter
 */
static void _adc_interrupt_handler(struct _adc_async_device *device)
{
	void *const hw      = device->hw;
   13774:	6942      	ldr	r2, [r0, #20]
	return ((Adc *)hw)->INTFLAG.reg;
   13776:	f892 102e 	ldrb.w	r1, [r2, #46]	; 0x2e
	return ((Adc *)hw)->INTENSET.reg;
   1377a:	f892 302d 	ldrb.w	r3, [r2, #45]	; 0x2d
	uint8_t     intflag = hri_adc_read_INTFLAG_reg(hw);
	intflag &= hri_adc_read_INTEN_reg(hw);
   1377e:	400b      	ands	r3, r1
{
   13780:	b430      	push	{r4, r5}
	if (intflag & ADC_INTFLAG_RESRDY) {
   13782:	f013 0501 	ands.w	r5, r3, #1
   13786:	d009      	beq.n	1379c <_adc_interrupt_handler+0x28>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_RESRDY;
   13788:	2301      	movs	r3, #1
   1378a:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
	return ((Adc *)hw)->RESULT.reg;
   1378e:	f8b2 2040 	ldrh.w	r2, [r2, #64]	; 0x40
		hri_adc_clear_interrupt_RESRDY_bit(hw);
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   13792:	6883      	ldr	r3, [r0, #8]
		device->adc_async_cb.error_cb(device, 0);
	} else if (intflag & ADC_INTFLAG_WINMON) {
		hri_adc_clear_interrupt_WINMON_bit(hw);
		device->adc_async_cb.window_cb(device, 0);
	}
}
   13794:	bc30      	pop	{r4, r5}
		device->adc_async_ch_cb.convert_done(device, 0, hri_adc_read_RESULT_reg(hw));
   13796:	b292      	uxth	r2, r2
   13798:	2100      	movs	r1, #0
   1379a:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_OVERRUN) {
   1379c:	f013 0102 	ands.w	r1, r3, #2
   137a0:	d006      	beq.n	137b0 <_adc_interrupt_handler+0x3c>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_OVERRUN;
   137a2:	2302      	movs	r3, #2
   137a4:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.error_cb(device, 0);
   137a8:	6843      	ldr	r3, [r0, #4]
   137aa:	4629      	mov	r1, r5
}
   137ac:	bc30      	pop	{r4, r5}
		device->adc_async_cb.window_cb(device, 0);
   137ae:	4718      	bx	r3
	} else if (intflag & ADC_INTFLAG_WINMON) {
   137b0:	075b      	lsls	r3, r3, #29
   137b2:	d504      	bpl.n	137be <_adc_interrupt_handler+0x4a>
	((Adc *)hw)->INTFLAG.reg = ADC_INTFLAG_WINMON;
   137b4:	2304      	movs	r3, #4
   137b6:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
		device->adc_async_cb.window_cb(device, 0);
   137ba:	6803      	ldr	r3, [r0, #0]
   137bc:	e7f6      	b.n	137ac <_adc_interrupt_handler+0x38>
}
   137be:	bc30      	pop	{r4, r5}
   137c0:	4770      	bx	lr
	...

000137c4 <_adc_get_regs>:
{
   137c4:	b508      	push	{r3, lr}
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   137c6:	f100 433d 	add.w	r3, r0, #3170893824	; 0xbd000000
   137ca:	f5a3 53e0 	sub.w	r3, r3, #7168	; 0x1c00
		if (_adcs[i].number == n) {
   137ce:	f413 3f7f 	tst.w	r3, #261120	; 0x3fc00
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   137d2:	f3c3 2087 	ubfx	r0, r3, #10, #8
		if (_adcs[i].number == n) {
   137d6:	d007      	beq.n	137e8 <_adc_get_regs+0x24>
   137d8:	2801      	cmp	r0, #1
   137da:	d005      	beq.n	137e8 <_adc_get_regs+0x24>
	ASSERT(false);
   137dc:	2000      	movs	r0, #0
   137de:	4903      	ldr	r1, [pc, #12]	; (137ec <_adc_get_regs+0x28>)
   137e0:	4b03      	ldr	r3, [pc, #12]	; (137f0 <_adc_get_regs+0x2c>)
   137e2:	228c      	movs	r2, #140	; 0x8c
   137e4:	4798      	blx	r3
	return 0;
   137e6:	2000      	movs	r0, #0
}
   137e8:	bd08      	pop	{r3, pc}
   137ea:	bf00      	nop
   137ec:	000174ee 	.word	0x000174ee
   137f0:	0000e9b9 	.word	0x0000e9b9

000137f4 <__NVIC_ClearPendingIRQ>:
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   137f4:	0943      	lsrs	r3, r0, #5
   137f6:	2201      	movs	r2, #1
   137f8:	f000 001f 	and.w	r0, r0, #31
   137fc:	fa02 f000 	lsl.w	r0, r2, r0
   13800:	3360      	adds	r3, #96	; 0x60
   13802:	4a02      	ldr	r2, [pc, #8]	; (1380c <__NVIC_ClearPendingIRQ+0x18>)
   13804:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
   13808:	4770      	bx	lr
   1380a:	bf00      	nop
   1380c:	e000e100 	.word	0xe000e100

00013810 <_adc_get_irq_num.isra.0>:
	return ((uint32_t)hw - (uint32_t)ADC0) >> 10;
   13810:	f100 403d 	add.w	r0, r0, #3170893824	; 0xbd000000
   13814:	f5a0 50e0 	sub.w	r0, r0, #7168	; 0x1c00
   13818:	0a80      	lsrs	r0, r0, #10
	return ADC0_0_IRQn + (_adc_get_hardware_index(device->hw) << 1);
   1381a:	0040      	lsls	r0, r0, #1
   1381c:	3076      	adds	r0, #118	; 0x76
}
   1381e:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
   13822:	4770      	bx	lr

00013824 <__NVIC_DisableIRQ>:
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13824:	0943      	lsrs	r3, r0, #5
   13826:	2201      	movs	r2, #1
   13828:	f000 001f 	and.w	r0, r0, #31
   1382c:	fa02 f000 	lsl.w	r0, r2, r0
   13830:	3320      	adds	r3, #32
   13832:	4a04      	ldr	r2, [pc, #16]	; (13844 <__NVIC_DisableIRQ+0x20>)
   13834:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   13838:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   1383c:	f3bf 8f6f 	isb	sy
}
   13840:	4770      	bx	lr
   13842:	bf00      	nop
   13844:	e000e100 	.word	0xe000e100

00013848 <_adc_init>:
{
   13848:	b538      	push	{r3, r4, r5, lr}
	if (hw == ADC0) {
   1384a:	4b39      	ldr	r3, [pc, #228]	; (13930 <_adc_init+0xe8>)
   1384c:	4298      	cmp	r0, r3
{
   1384e:	460c      	mov	r4, r1
	if (hw == ADC0) {
   13850:	d15c      	bne.n	1390c <_adc_init+0xc4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   13852:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   13856:	681b      	ldr	r3, [r3, #0]
   13858:	00da      	lsls	r2, r3, #3
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   1385a:	0919      	lsrs	r1, r3, #4
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC0_FUSES_BIASREFBUF_ADDR >> ADC0_FUSES_BIASREFBUF_Pos))
   1385c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC0_FUSES_BIASR2R_ADDR >> ADC0_FUSES_BIASR2R_Pos))
   13860:	f001 0170 	and.w	r1, r1, #112	; 0x70
   13864:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC0_FUSES_BIASCOMP_ADDR >> ADC0_FUSES_BIASCOMP_Pos));
   13866:	f3c3 0382 	ubfx	r3, r3, #2, #3
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   1386a:	431a      	orrs	r2, r3
	return ((Adc *)hw)->SYNCBUSY.reg & reg;
   1386c:	6b03      	ldr	r3, [r0, #48]	; 0x30
   1386e:	4d31      	ldr	r5, [pc, #196]	; (13934 <_adc_init+0xec>)
	if (!hri_adc_is_syncing(hw, ADC_SYNCBUSY_SWRST)) {
   13870:	f013 0f01 	tst.w	r3, #1
   13874:	d10c      	bne.n	13890 <_adc_init+0x48>
}

static inline hri_adc_ctrla_reg_t hri_adc_get_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t mask)
{
	uint16_t tmp;
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   13876:	2103      	movs	r1, #3
   13878:	47a8      	blx	r5
	tmp = ((Adc *)hw)->CTRLA.reg;
   1387a:	8803      	ldrh	r3, [r0, #0]
		if (hri_adc_get_CTRLA_reg(hw, ADC_CTRLA_ENABLE)) {
   1387c:	079b      	lsls	r3, r3, #30
   1387e:	d503      	bpl.n	13888 <_adc_init+0x40>
			hri_adc_clear_CTRLA_ENABLE_bit(hw);
   13880:	4b2d      	ldr	r3, [pc, #180]	; (13938 <_adc_init+0xf0>)
   13882:	4798      	blx	r3
			hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_ENABLE);
   13884:	2102      	movs	r1, #2
   13886:	47a8      	blx	r5
}

static inline void hri_adc_write_CTRLA_reg(const void *const hw, hri_adc_ctrla_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CTRLA.reg = data;
   13888:	2301      	movs	r3, #1
   1388a:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   1388c:	2103      	movs	r1, #3
   1388e:	47a8      	blx	r5
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST);
   13890:	2101      	movs	r1, #1
   13892:	47a8      	blx	r5
	hri_adc_write_CTRLB_reg(hw, _adcs[i].ctrl_b);
   13894:	4929      	ldr	r1, [pc, #164]	; (1393c <_adc_init+0xf4>)
}

static inline void hri_adc_write_CALIB_reg(const void *const hw, hri_adc_calib_reg_t data)
{
	ADC_CRITICAL_SECTION_ENTER();
	((Adc *)hw)->CALIB.reg = data;
   13896:	f8a0 2048 	strh.w	r2, [r0, #72]	; 0x48
   1389a:	2316      	movs	r3, #22
   1389c:	fb03 1404 	mla	r4, r3, r4, r1
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   138a0:	f640 71ff 	movw	r1, #4095	; 0xfff
   138a4:	88a3      	ldrh	r3, [r4, #4]
	((Adc *)hw)->CTRLB.reg = data;
   138a6:	80c3      	strh	r3, [r0, #6]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   138a8:	47a8      	blx	r5
	hri_adc_write_REFCTRL_reg(hw, _adcs[i].ref_ctrl);
   138aa:	79a3      	ldrb	r3, [r4, #6]
	((Adc *)hw)->REFCTRL.reg = data;
   138ac:	7203      	strb	r3, [r0, #8]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   138ae:	f640 71ff 	movw	r1, #4095	; 0xfff
   138b2:	47a8      	blx	r5
	hri_adc_write_EVCTRL_reg(hw, _adcs[i].ev_ctrl);
   138b4:	79e3      	ldrb	r3, [r4, #7]
	((Adc *)hw)->EVCTRL.reg = data;
   138b6:	7083      	strb	r3, [r0, #2]
	hri_adc_write_INPUTCTRL_reg(hw, _adcs[i].input_ctrl);
   138b8:	8923      	ldrh	r3, [r4, #8]
	((Adc *)hw)->INPUTCTRL.reg = data;
   138ba:	8083      	strh	r3, [r0, #4]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   138bc:	f640 71ff 	movw	r1, #4095	; 0xfff
   138c0:	47a8      	blx	r5
	hri_adc_write_AVGCTRL_reg(hw, _adcs[i].avg_ctrl);
   138c2:	7aa3      	ldrb	r3, [r4, #10]
	((Adc *)hw)->AVGCTRL.reg = data;
   138c4:	7283      	strb	r3, [r0, #10]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   138c6:	f640 71ff 	movw	r1, #4095	; 0xfff
   138ca:	47a8      	blx	r5
	hri_adc_write_SAMPCTRL_reg(hw, _adcs[i].samp_ctrl);
   138cc:	7ae3      	ldrb	r3, [r4, #11]
	((Adc *)hw)->SAMPCTRL.reg = data;
   138ce:	72c3      	strb	r3, [r0, #11]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   138d0:	f640 71ff 	movw	r1, #4095	; 0xfff
   138d4:	47a8      	blx	r5
	hri_adc_write_WINLT_reg(hw, _adcs[i].win_lt);
   138d6:	89a3      	ldrh	r3, [r4, #12]
	((Adc *)hw)->WINLT.reg = data;
   138d8:	8183      	strh	r3, [r0, #12]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINLT);
   138da:	2180      	movs	r1, #128	; 0x80
   138dc:	47a8      	blx	r5
	hri_adc_write_WINUT_reg(hw, _adcs[i].win_ut);
   138de:	89e3      	ldrh	r3, [r4, #14]
	((Adc *)hw)->WINUT.reg = data;
   138e0:	81c3      	strh	r3, [r0, #14]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_WINUT);
   138e2:	f44f 7180 	mov.w	r1, #256	; 0x100
   138e6:	47a8      	blx	r5
	hri_adc_write_GAINCORR_reg(hw, _adcs[i].gain_corr);
   138e8:	8a23      	ldrh	r3, [r4, #16]
	((Adc *)hw)->GAINCORR.reg = data;
   138ea:	8203      	strh	r3, [r0, #16]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_GAINCORR);
   138ec:	f44f 7100 	mov.w	r1, #512	; 0x200
   138f0:	47a8      	blx	r5
	hri_adc_write_OFFSETCORR_reg(hw, _adcs[i].offset_corr);
   138f2:	8a63      	ldrh	r3, [r4, #18]
	((Adc *)hw)->OFFSETCORR.reg = data;
   138f4:	8243      	strh	r3, [r0, #18]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_OFFSETCORR);
   138f6:	f44f 6180 	mov.w	r1, #1024	; 0x400
   138fa:	47a8      	blx	r5
	hri_adc_write_DBGCTRL_reg(hw, _adcs[i].dbg_ctrl);
   138fc:	7d23      	ldrb	r3, [r4, #20]
	((Adc *)hw)->DBGCTRL.reg = data;
   138fe:	70c3      	strb	r3, [r0, #3]
	hri_adc_write_CTRLA_reg(hw, _adcs[i].ctrl_a);
   13900:	8863      	ldrh	r3, [r4, #2]
	((Adc *)hw)->CTRLA.reg = data;
   13902:	8003      	strh	r3, [r0, #0]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_SWRST | ADC_SYNCBUSY_ENABLE);
   13904:	2103      	movs	r1, #3
   13906:	47a8      	blx	r5
}
   13908:	2000      	movs	r0, #0
   1390a:	bd38      	pop	{r3, r4, r5, pc}
	} else if (hw == ADC1) {
   1390c:	4b0c      	ldr	r3, [pc, #48]	; (13940 <_adc_init+0xf8>)
   1390e:	4298      	cmp	r0, r3
   13910:	d10c      	bne.n	1392c <_adc_init+0xe4>
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   13912:	f04f 1380 	mov.w	r3, #8388736	; 0x800080
   13916:	681b      	ldr	r3, [r3, #0]
   13918:	0ada      	lsrs	r2, r3, #11
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   1391a:	0c99      	lsrs	r1, r3, #18
		calib_reg = ADC_CALIB_BIASREFBUF((*(uint32_t *)ADC1_FUSES_BIASREFBUF_ADDR >> ADC1_FUSES_BIASREFBUF_Pos))
   1391c:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
		            | ADC_CALIB_BIASR2R((*(uint32_t *)ADC1_FUSES_BIASR2R_ADDR >> ADC1_FUSES_BIASR2R_Pos))
   13920:	f001 0170 	and.w	r1, r1, #112	; 0x70
   13924:	430a      	orrs	r2, r1
		            | ADC_CALIB_BIASCOMP((*(uint32_t *)ADC1_FUSES_BIASCOMP_ADDR >> ADC1_FUSES_BIASCOMP_Pos));
   13926:	f3c3 4302 	ubfx	r3, r3, #16, #3
   1392a:	e79e      	b.n	1386a <_adc_init+0x22>
	uint16_t calib_reg = 0;
   1392c:	2200      	movs	r2, #0
   1392e:	e79d      	b.n	1386c <_adc_init+0x24>
   13930:	43001c00 	.word	0x43001c00
   13934:	00013741 	.word	0x00013741
   13938:	0001375d 	.word	0x0001375d
   1393c:	00017504 	.word	0x00017504
   13940:	43002000 	.word	0x43002000

00013944 <_adc_async_init>:
{
   13944:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	ASSERT(device);
   13948:	4604      	mov	r4, r0
   1394a:	3800      	subs	r0, #0
   1394c:	bf18      	it	ne
   1394e:	2001      	movne	r0, #1
{
   13950:	460d      	mov	r5, r1
	ASSERT(device);
   13952:	22f1      	movs	r2, #241	; 0xf1
   13954:	4923      	ldr	r1, [pc, #140]	; (139e4 <_adc_async_init+0xa0>)
   13956:	4b24      	ldr	r3, [pc, #144]	; (139e8 <_adc_async_init+0xa4>)
   13958:	4798      	blx	r3
	init_status = _adc_init(hw, _adc_get_regs((uint32_t)hw));
   1395a:	4b24      	ldr	r3, [pc, #144]	; (139ec <_adc_async_init+0xa8>)
   1395c:	4628      	mov	r0, r5
   1395e:	4798      	blx	r3
   13960:	4b23      	ldr	r3, [pc, #140]	; (139f0 <_adc_async_init+0xac>)
   13962:	4601      	mov	r1, r0
   13964:	4628      	mov	r0, r5
   13966:	4798      	blx	r3
	if (init_status) {
   13968:	4606      	mov	r6, r0
   1396a:	2800      	cmp	r0, #0
   1396c:	d130      	bne.n	139d0 <_adc_async_init+0x8c>
	if (hw == ADC0) {
   1396e:	4b21      	ldr	r3, [pc, #132]	; (139f4 <_adc_async_init+0xb0>)
	device->hw = hw;
   13970:	6165      	str	r5, [r4, #20]
	if (hw == ADC0) {
   13972:	429d      	cmp	r5, r3
   13974:	d12f      	bne.n	139d6 <_adc_async_init+0x92>
		_adc0_dev = dev;
   13976:	4b20      	ldr	r3, [pc, #128]	; (139f8 <_adc_async_init+0xb4>)
   13978:	601c      	str	r4, [r3, #0]
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   1397a:	4920      	ldr	r1, [pc, #128]	; (139fc <_adc_async_init+0xb8>)
   1397c:	f8df 9088 	ldr.w	r9, [pc, #136]	; 13a08 <_adc_async_init+0xc4>
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   13980:	f8df 8088 	ldr.w	r8, [pc, #136]	; 13a0c <_adc_async_init+0xc8>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   13984:	4f1e      	ldr	r7, [pc, #120]	; (13a00 <_adc_async_init+0xbc>)
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 0);
   13986:	4628      	mov	r0, r5
   13988:	4788      	blx	r1
   1398a:	b200      	sxth	r0, r0
   1398c:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 0);
   1398e:	6960      	ldr	r0, [r4, #20]
   13990:	4788      	blx	r1
   13992:	b200      	sxth	r0, r0
   13994:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 0);
   13996:	6960      	ldr	r0, [r4, #20]
   13998:	4788      	blx	r1
   1399a:	2501      	movs	r5, #1
   1399c:	0942      	lsrs	r2, r0, #5
   1399e:	f000 031f 	and.w	r3, r0, #31
   139a2:	fa05 f303 	lsl.w	r3, r5, r3
	NVIC_DisableIRQ(_adc_get_irq_num(device) + 1);
   139a6:	4428      	add	r0, r5
   139a8:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
   139ac:	b200      	sxth	r0, r0
   139ae:	47c8      	blx	r9
	NVIC_ClearPendingIRQ(_adc_get_irq_num(device) + 1);
   139b0:	6960      	ldr	r0, [r4, #20]
   139b2:	4788      	blx	r1
   139b4:	4428      	add	r0, r5
   139b6:	b200      	sxth	r0, r0
   139b8:	47c0      	blx	r8
	NVIC_EnableIRQ(_adc_get_irq_num(device) + 1);
   139ba:	6960      	ldr	r0, [r4, #20]
   139bc:	4788      	blx	r1
   139be:	1943      	adds	r3, r0, r5
   139c0:	f3c3 124a 	ubfx	r2, r3, #5, #11
   139c4:	f003 031f 	and.w	r3, r3, #31
   139c8:	fa05 f303 	lsl.w	r3, r5, r3
   139cc:	f847 3022 	str.w	r3, [r7, r2, lsl #2]
}
   139d0:	4630      	mov	r0, r6
   139d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (hw == ADC1) {
   139d6:	4b0b      	ldr	r3, [pc, #44]	; (13a04 <_adc_async_init+0xc0>)
   139d8:	429d      	cmp	r5, r3
		_adc1_dev = dev;
   139da:	bf04      	itt	eq
   139dc:	4b06      	ldreq	r3, [pc, #24]	; (139f8 <_adc_async_init+0xb4>)
   139de:	605c      	streq	r4, [r3, #4]
   139e0:	e7cb      	b.n	1397a <_adc_async_init+0x36>
   139e2:	bf00      	nop
   139e4:	000174ee 	.word	0x000174ee
   139e8:	0000e9b9 	.word	0x0000e9b9
   139ec:	000137c5 	.word	0x000137c5
   139f0:	00013849 	.word	0x00013849
   139f4:	43001c00 	.word	0x43001c00
   139f8:	20009100 	.word	0x20009100
   139fc:	00013811 	.word	0x00013811
   13a00:	e000e100 	.word	0xe000e100
   13a04:	43002000 	.word	0x43002000
   13a08:	00013825 	.word	0x00013825
   13a0c:	000137f5 	.word	0x000137f5

00013a10 <_adc_async_enable_channel>:
	hri_adc_set_CTRLA_ENABLE_bit(device->hw);
   13a10:	6940      	ldr	r0, [r0, #20]
   13a12:	4b01      	ldr	r3, [pc, #4]	; (13a18 <_adc_async_enable_channel+0x8>)
   13a14:	4718      	bx	r3
   13a16:	bf00      	nop
   13a18:	00013749 	.word	0x00013749

00013a1c <_adc_async_get_data_size>:
	return hri_adc_read_CTRLB_RESSEL_bf(device->hw) == ADC_CTRLB_RESSEL_8BIT_Val ? 1 : 2;
   13a1c:	6943      	ldr	r3, [r0, #20]
	tmp = ((Adc *)hw)->CTRLB.reg;
   13a1e:	88db      	ldrh	r3, [r3, #6]
   13a20:	f3c3 03c1 	ubfx	r3, r3, #3, #2
   13a24:	2b03      	cmp	r3, #3
}
   13a26:	bf0c      	ite	eq
   13a28:	2001      	moveq	r0, #1
   13a2a:	2002      	movne	r0, #2
   13a2c:	4770      	bx	lr
	...

00013a30 <_adc_async_convert>:
	hri_adc_set_SWTRIG_START_bit(device->hw);
   13a30:	6940      	ldr	r0, [r0, #20]
	((Adc *)hw)->SWTRIG.reg |= ADC_SWTRIG_START;
   13a32:	7d03      	ldrb	r3, [r0, #20]
   13a34:	f043 0302 	orr.w	r3, r3, #2
   13a38:	7503      	strb	r3, [r0, #20]
	hri_adc_wait_for_sync(hw, ADC_SYNCBUSY_MASK);
   13a3a:	f640 71ff 	movw	r1, #4095	; 0xfff
   13a3e:	4b01      	ldr	r3, [pc, #4]	; (13a44 <_adc_async_convert+0x14>)
   13a40:	4718      	bx	r3
   13a42:	bf00      	nop
   13a44:	00013741 	.word	0x00013741

00013a48 <_adc_async_set_irq_state>:
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   13a48:	2a01      	cmp	r2, #1
	void *const hw = device->hw;
   13a4a:	6941      	ldr	r1, [r0, #20]
	if (ADC_ASYNC_DEVICE_MONITOR_CB == type) {
   13a4c:	d104      	bne.n	13a58 <_adc_async_set_irq_state+0x10>
	if (value == 0x0) {
   13a4e:	2204      	movs	r2, #4
	if (value == 0x0) {
   13a50:	b93b      	cbnz	r3, 13a62 <_adc_async_set_irq_state+0x1a>
		((Adc *)hw)->INTENCLR.reg = ADC_INTENSET_RESRDY;
   13a52:	f881 202c 	strb.w	r2, [r1, #44]	; 0x2c
   13a56:	4770      	bx	lr
	} else if (ADC_ASYNC_DEVICE_ERROR_CB == type) {
   13a58:	2a02      	cmp	r2, #2
   13a5a:	d0f9      	beq.n	13a50 <_adc_async_set_irq_state+0x8>
	} else if (ADC_ASYNC_DEVICE_CONVERT_CB == type) {
   13a5c:	b91a      	cbnz	r2, 13a66 <_adc_async_set_irq_state+0x1e>
	if (value == 0x0) {
   13a5e:	2201      	movs	r2, #1
   13a60:	e7f6      	b.n	13a50 <_adc_async_set_irq_state+0x8>
		((Adc *)hw)->INTENSET.reg = ADC_INTENSET_RESRDY;
   13a62:	f881 202d 	strb.w	r2, [r1, #45]	; 0x2d
}
   13a66:	4770      	bx	lr

00013a68 <ADC0_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC0_0_Handler(void)
{
	_adc_interrupt_handler(_adc0_dev);
   13a68:	4b01      	ldr	r3, [pc, #4]	; (13a70 <ADC0_0_Handler+0x8>)
   13a6a:	6818      	ldr	r0, [r3, #0]
   13a6c:	4b01      	ldr	r3, [pc, #4]	; (13a74 <ADC0_0_Handler+0xc>)
   13a6e:	4718      	bx	r3
   13a70:	20009100 	.word	0x20009100
   13a74:	00013775 	.word	0x00013775

00013a78 <ADC0_1_Handler>:
   13a78:	4b00      	ldr	r3, [pc, #0]	; (13a7c <ADC0_1_Handler+0x4>)
   13a7a:	4718      	bx	r3
   13a7c:	00013a69 	.word	0x00013a69

00013a80 <ADC1_0_Handler>:
/**
 * \brief DMAC interrupt handler
 */
void ADC1_0_Handler(void)
{
	_adc_interrupt_handler(_adc1_dev);
   13a80:	4b01      	ldr	r3, [pc, #4]	; (13a88 <ADC1_0_Handler+0x8>)
   13a82:	6858      	ldr	r0, [r3, #4]
   13a84:	4b01      	ldr	r3, [pc, #4]	; (13a8c <ADC1_0_Handler+0xc>)
   13a86:	4718      	bx	r3
   13a88:	20009100 	.word	0x20009100
   13a8c:	00013775 	.word	0x00013775

00013a90 <ADC1_1_Handler>:
   13a90:	4b00      	ldr	r3, [pc, #0]	; (13a94 <ADC1_1_Handler+0x4>)
   13a92:	4718      	bx	r3
   13a94:	00013a81 	.word	0x00013a81

00013a98 <Dummy_Handler>:
/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
	while (1) {
   13a98:	e7fe      	b.n	13a98 <Dummy_Handler>
	...

00013a9c <Reset_Handler>:
{
   13a9c:	b508      	push	{r3, lr}
	if (pSrc != pDest) {
   13a9e:	4a14      	ldr	r2, [pc, #80]	; (13af0 <Reset_Handler+0x54>)
   13aa0:	4b14      	ldr	r3, [pc, #80]	; (13af4 <Reset_Handler+0x58>)
   13aa2:	429a      	cmp	r2, r3
   13aa4:	d002      	beq.n	13aac <Reset_Handler+0x10>
		for (; pDest < &_erelocate;) {
   13aa6:	4914      	ldr	r1, [pc, #80]	; (13af8 <Reset_Handler+0x5c>)
   13aa8:	428b      	cmp	r3, r1
   13aaa:	d318      	bcc.n	13ade <Reset_Handler+0x42>
	pSrc  = &_etext;
   13aac:	4b13      	ldr	r3, [pc, #76]	; (13afc <Reset_Handler+0x60>)
	for (pDest = &_szero; pDest < &_ezero;) {
   13aae:	4a14      	ldr	r2, [pc, #80]	; (13b00 <Reset_Handler+0x64>)
		*pDest++ = 0;
   13ab0:	2100      	movs	r1, #0
	for (pDest = &_szero; pDest < &_ezero;) {
   13ab2:	4293      	cmp	r3, r2
   13ab4:	d318      	bcc.n	13ae8 <Reset_Handler+0x4c>
	SCB->VTOR = ((uint32_t)pSrc & SCB_VTOR_TBLOFF_Msk);
   13ab6:	4a13      	ldr	r2, [pc, #76]	; (13b04 <Reset_Handler+0x68>)
   13ab8:	4b13      	ldr	r3, [pc, #76]	; (13b08 <Reset_Handler+0x6c>)
   13aba:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   13abe:	609a      	str	r2, [r3, #8]
	SCB->CPACR |= (0xFu << 20);
   13ac0:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
   13ac4:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   13ac8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
   13acc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   13ad0:	f3bf 8f6f 	isb	sy
	__libc_init_array();
   13ad4:	4b0d      	ldr	r3, [pc, #52]	; (13b0c <Reset_Handler+0x70>)
   13ad6:	4798      	blx	r3
	main();
   13ad8:	4b0d      	ldr	r3, [pc, #52]	; (13b10 <Reset_Handler+0x74>)
   13ada:	4798      	blx	r3
	while (1)
   13adc:	e7fe      	b.n	13adc <Reset_Handler+0x40>
			*pDest++ = *pSrc++;
   13ade:	f852 0b04 	ldr.w	r0, [r2], #4
   13ae2:	f843 0b04 	str.w	r0, [r3], #4
   13ae6:	e7df      	b.n	13aa8 <Reset_Handler+0xc>
		*pDest++ = 0;
   13ae8:	f843 1b04 	str.w	r1, [r3], #4
   13aec:	e7e1      	b.n	13ab2 <Reset_Handler+0x16>
   13aee:	bf00      	nop
   13af0:	00017754 	.word	0x00017754
   13af4:	20000000 	.word	0x20000000
   13af8:	200005b0 	.word	0x200005b0
   13afc:	200005b0 	.word	0x200005b0
   13b00:	2001cfe4 	.word	0x2001cfe4
   13b04:	00004000 	.word	0x00004000
   13b08:	e000ed00 	.word	0xe000ed00
   13b0c:	00014cdd 	.word	0x00014cdd
   13b10:	00012ab9 	.word	0x00012ab9

00013b14 <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
   13b14:	b510      	push	{r4, lr}
	system_init();
   13b16:	4b04      	ldr	r3, [pc, #16]	; (13b28 <atmel_start_init+0x14>)
   13b18:	4798      	blx	r3
	usb_init();
   13b1a:	4b04      	ldr	r3, [pc, #16]	; (13b2c <atmel_start_init+0x18>)
   13b1c:	4798      	blx	r3
	stdio_redirect_init();
}
   13b1e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	stdio_redirect_init();
   13b22:	4b03      	ldr	r3, [pc, #12]	; (13b30 <atmel_start_init+0x1c>)
   13b24:	4718      	bx	r3
   13b26:	bf00      	nop
   13b28:	00010ce1 	.word	0x00010ce1
   13b2c:	0000d295 	.word	0x0000d295
   13b30:	0000f649 	.word	0x0000f649

00013b34 <usbdc_unconfig>:
/**
 * \brief Unconfig, close all interfaces
 */
static void usbdc_unconfig(void)
{
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   13b34:	4b05      	ldr	r3, [pc, #20]	; (13b4c <usbdc_unconfig+0x18>)
{
   13b36:	b510      	push	{r4, lr}
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   13b38:	691c      	ldr	r4, [r3, #16]
	while (NULL != func) {
   13b3a:	b904      	cbnz	r4, 13b3e <usbdc_unconfig+0xa>
		func->ctrl(func, USBDF_DISABLE, NULL);
		func = func->next;
	}
}
   13b3c:	bd10      	pop	{r4, pc}
		func->ctrl(func, USBDF_DISABLE, NULL);
   13b3e:	6863      	ldr	r3, [r4, #4]
   13b40:	4620      	mov	r0, r4
   13b42:	2200      	movs	r2, #0
   13b44:	2101      	movs	r1, #1
   13b46:	4798      	blx	r3
		func = func->next;
   13b48:	6824      	ldr	r4, [r4, #0]
   13b4a:	e7f6      	b.n	13b3a <usbdc_unconfig+0x6>
   13b4c:	20009108 	.word	0x20009108

00013b50 <usbdc_change_notify>:
}

/** Invoke all registered Change notification callbacks. */
static void usbdc_change_notify(enum usbdc_change_type change, uint32_t value)
{
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   13b50:	4b06      	ldr	r3, [pc, #24]	; (13b6c <usbdc_change_notify+0x1c>)
{
   13b52:	b570      	push	{r4, r5, r6, lr}
	struct usbdc_change_handler *cg = (struct usbdc_change_handler *)usbdc.handlers.change_list.head;
   13b54:	68dc      	ldr	r4, [r3, #12]
{
   13b56:	4605      	mov	r5, r0
   13b58:	460e      	mov	r6, r1

	while (cg != NULL) {
   13b5a:	b904      	cbnz	r4, 13b5e <usbdc_change_notify+0xe>
		if (NULL != cg->cb) {
			cg->cb(change, value);
		}
		cg = cg->next;
	}
}
   13b5c:	bd70      	pop	{r4, r5, r6, pc}
		if (NULL != cg->cb) {
   13b5e:	6863      	ldr	r3, [r4, #4]
   13b60:	b113      	cbz	r3, 13b68 <usbdc_change_notify+0x18>
			cg->cb(change, value);
   13b62:	4631      	mov	r1, r6
   13b64:	4628      	mov	r0, r5
   13b66:	4798      	blx	r3
		cg = cg->next;
   13b68:	6824      	ldr	r4, [r4, #0]
   13b6a:	e7f6      	b.n	13b5a <usbdc_change_notify+0xa>
   13b6c:	20009108 	.word	0x20009108

00013b70 <usbdc_request_handler>:

/** Invoke all registered request callbacks until request handled. */
static int32_t usbdc_request_handler(uint8_t ep, struct usb_req *req, enum usb_ctrl_stage stage)
{
   13b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct usbdc_req_handler *h = (struct usbdc_req_handler *)usbdc.handlers.req_list.head;
   13b72:	4b0c      	ldr	r3, [pc, #48]	; (13ba4 <usbdc_request_handler+0x34>)
   13b74:	689c      	ldr	r4, [r3, #8]
{
   13b76:	4605      	mov	r5, r0
   13b78:	460e      	mov	r6, r1
   13b7a:	4617      	mov	r7, r2
	int32_t                   rc;

	while (h != NULL) {
   13b7c:	b90c      	cbnz	r4, 13b82 <usbdc_request_handler+0x12>
				return -1;
			}
		}
		h = h->next;
	}
	return false;
   13b7e:	4620      	mov	r0, r4
}
   13b80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (NULL != h->cb) {
   13b82:	6863      	ldr	r3, [r4, #4]
   13b84:	b90b      	cbnz	r3, 13b8a <usbdc_request_handler+0x1a>
		h = h->next;
   13b86:	6824      	ldr	r4, [r4, #0]
   13b88:	e7f8      	b.n	13b7c <usbdc_request_handler+0xc>
			rc = h->cb(ep, req, stage);
   13b8a:	463a      	mov	r2, r7
   13b8c:	4631      	mov	r1, r6
   13b8e:	4628      	mov	r0, r5
   13b90:	4798      	blx	r3
			if (0 == rc) {
   13b92:	b120      	cbz	r0, 13b9e <usbdc_request_handler+0x2e>
			} else if (ERR_NOT_FOUND != rc) {
   13b94:	300a      	adds	r0, #10
   13b96:	d0f6      	beq.n	13b86 <usbdc_request_handler+0x16>
				return -1;
   13b98:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   13b9c:	e7f0      	b.n	13b80 <usbdc_request_handler+0x10>
				return true;
   13b9e:	2001      	movs	r0, #1
   13ba0:	e7ee      	b.n	13b80 <usbdc_request_handler+0x10>
   13ba2:	bf00      	nop
   13ba4:	20009108 	.word	0x20009108

00013ba8 <usbd_sof_cb>:
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   13ba8:	4b04      	ldr	r3, [pc, #16]	; (13bbc <usbd_sof_cb+0x14>)

/**
 * \brief Callback invoked on USB device SOF
 */
static void usbd_sof_cb(void)
{
   13baa:	b510      	push	{r4, lr}
	struct usbdc_sof_handler *sof = (struct usbdc_sof_handler *)usbdc.handlers.sof_list.head;
   13bac:	685c      	ldr	r4, [r3, #4]
	while (sof != NULL) {
   13bae:	b904      	cbnz	r4, 13bb2 <usbd_sof_cb+0xa>
	usbdc_sof_notify();
}
   13bb0:	bd10      	pop	{r4, pc}
		if (NULL != sof->cb) {
   13bb2:	6863      	ldr	r3, [r4, #4]
   13bb4:	b103      	cbz	r3, 13bb8 <usbd_sof_cb+0x10>
			sof->cb();
   13bb6:	4798      	blx	r3
		sof = sof->next;
   13bb8:	6824      	ldr	r4, [r4, #0]
   13bba:	e7f8      	b.n	13bae <usbd_sof_cb+0x6>
   13bbc:	20009108 	.word	0x20009108

00013bc0 <usbdc_cb_ctl_done>:
 * \return Data has error or not.
 * \retval true There is data error, protocol error.
 * \retval false There is no data error.
 */
static bool usbdc_cb_ctl_done(const uint8_t ep, const enum usb_xfer_code code, struct usb_req *req)
{
   13bc0:	b510      	push	{r4, lr}
   13bc2:	4614      	mov	r4, r2
	(void)ep;

	switch (code) {
   13bc4:	460a      	mov	r2, r1
   13bc6:	b119      	cbz	r1, 13bd0 <usbdc_cb_ctl_done+0x10>
   13bc8:	2901      	cmp	r1, #1
   13bca:	d021      	beq.n	13c10 <usbdc_cb_ctl_done+0x50>
		return usbdc_ctrl_data_end(req);
	default:
		break;
	}
	return false;
}
   13bcc:	2000      	movs	r0, #0
   13bce:	bd10      	pop	{r4, pc}
	if (req->bmRequestType != USB_REQT_TYPE_STANDARD) {
   13bd0:	7823      	ldrb	r3, [r4, #0]
   13bd2:	2b00      	cmp	r3, #0
   13bd4:	d1fa      	bne.n	13bcc <usbdc_cb_ctl_done+0xc>
	switch (req->bRequest) {
   13bd6:	7863      	ldrb	r3, [r4, #1]
   13bd8:	2b05      	cmp	r3, #5
   13bda:	d00d      	beq.n	13bf8 <usbdc_cb_ctl_done+0x38>
   13bdc:	2b09      	cmp	r3, #9
   13bde:	d1f5      	bne.n	13bcc <usbdc_cb_ctl_done+0xc>
		usbdc.cfg_value = req->wValue;
   13be0:	8862      	ldrh	r2, [r4, #2]
   13be2:	4b0e      	ldr	r3, [pc, #56]	; (13c1c <usbdc_cb_ctl_done+0x5c>)
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   13be4:	2a00      	cmp	r2, #0
		usbdc.cfg_value = req->wValue;
   13be6:	76da      	strb	r2, [r3, #27]
		usbdc.state     = req->wValue ? USBD_S_CONFIG : USBD_S_ADDRESS;
   13be8:	bf14      	ite	ne
   13bea:	2104      	movne	r1, #4
   13bec:	2103      	moveq	r1, #3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   13bee:	7699      	strb	r1, [r3, #26]
		usbdc_change_notify(USBDC_C_STATE, usbdc.state);
   13bf0:	2001      	movs	r0, #1
   13bf2:	4b0b      	ldr	r3, [pc, #44]	; (13c20 <usbdc_cb_ctl_done+0x60>)
   13bf4:	4798      	blx	r3
		break;
   13bf6:	e7e9      	b.n	13bcc <usbdc_cb_ctl_done+0xc>
		usbdc_set_address(req->wValue);
   13bf8:	8860      	ldrh	r0, [r4, #2]
	usb_d_set_address(addr);
   13bfa:	4b0a      	ldr	r3, [pc, #40]	; (13c24 <usbdc_cb_ctl_done+0x64>)
   13bfc:	b2c0      	uxtb	r0, r0
   13bfe:	4798      	blx	r3
		usbdc.state = req->wValue ? USBD_S_ADDRESS : USBD_S_DEFAULT;
   13c00:	8863      	ldrh	r3, [r4, #2]
   13c02:	2b00      	cmp	r3, #0
   13c04:	bf18      	it	ne
   13c06:	2103      	movne	r1, #3
   13c08:	4b04      	ldr	r3, [pc, #16]	; (13c1c <usbdc_cb_ctl_done+0x5c>)
   13c0a:	bf08      	it	eq
   13c0c:	2102      	moveq	r1, #2
   13c0e:	e7ee      	b.n	13bee <usbdc_cb_ctl_done+0x2e>
	usbdc_request_handler(0, req, USB_DATA_STAGE);
   13c10:	4b05      	ldr	r3, [pc, #20]	; (13c28 <usbdc_cb_ctl_done+0x68>)
   13c12:	4621      	mov	r1, r4
   13c14:	2000      	movs	r0, #0
   13c16:	4798      	blx	r3
		return usbdc_ctrl_data_end(req);
   13c18:	e7d8      	b.n	13bcc <usbdc_cb_ctl_done+0xc>
   13c1a:	bf00      	nop
   13c1c:	20009108 	.word	0x20009108
   13c20:	00013b51 	.word	0x00013b51
   13c24:	0000fe95 	.word	0x0000fe95
   13c28:	00013b71 	.word	0x00013b71

00013c2c <usbdc_reset>:

/**
 * \brief USB Device Core Reset
 */
void usbdc_reset(void)
{
   13c2c:	b570      	push	{r4, r5, r6, lr}
	usbdc_unconfig();

	usbdc.state       = USBD_S_DEFAULT;
   13c2e:	4d0d      	ldr	r5, [pc, #52]	; (13c64 <usbdc_reset+0x38>)
	usbdc_unconfig();
   13c30:	4b0d      	ldr	r3, [pc, #52]	; (13c68 <usbdc_reset+0x3c>)
	usbdc.cfg_value   = 0;
	usbdc.ifc_alt_map = 0;
   13c32:	2400      	movs	r4, #0
	usbdc.state       = USBD_S_DEFAULT;
   13c34:	2602      	movs	r6, #2
	usbdc_unconfig();
   13c36:	4798      	blx	r3
	usbdc.state       = USBD_S_DEFAULT;
   13c38:	836e      	strh	r6, [r5, #26]

	// Setup EP0
	usb_d_ep_deinit(0);
   13c3a:	4620      	mov	r0, r4
   13c3c:	4b0b      	ldr	r3, [pc, #44]	; (13c6c <usbdc_reset+0x40>)
	usbdc.ifc_alt_map = 0;
   13c3e:	776c      	strb	r4, [r5, #29]
	usb_d_ep_deinit(0);
   13c40:	4798      	blx	r3
	usb_d_ep0_init(usbdc.ctrl_size);
   13c42:	4b0b      	ldr	r3, [pc, #44]	; (13c70 <usbdc_reset+0x44>)
   13c44:	7f28      	ldrb	r0, [r5, #28]
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   13c46:	4d0b      	ldr	r5, [pc, #44]	; (13c74 <usbdc_reset+0x48>)
	usb_d_ep0_init(usbdc.ctrl_size);
   13c48:	4798      	blx	r3
	usb_d_ep_register_callback(0, USB_D_EP_CB_SETUP, (FUNC_PTR)usbdc_cb_ctl_req);
   13c4a:	4621      	mov	r1, r4
   13c4c:	4620      	mov	r0, r4
   13c4e:	4a0a      	ldr	r2, [pc, #40]	; (13c78 <usbdc_reset+0x4c>)
   13c50:	47a8      	blx	r5
	usb_d_ep_register_callback(0, USB_D_EP_CB_XFER, (FUNC_PTR)usbdc_cb_ctl_done);
   13c52:	4620      	mov	r0, r4
   13c54:	4631      	mov	r1, r6
   13c56:	4a09      	ldr	r2, [pc, #36]	; (13c7c <usbdc_reset+0x50>)
   13c58:	47a8      	blx	r5
	usb_d_ep_enable(0);
   13c5a:	4620      	mov	r0, r4
   13c5c:	4b08      	ldr	r3, [pc, #32]	; (13c80 <usbdc_reset+0x54>)
}
   13c5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	usb_d_ep_enable(0);
   13c62:	4718      	bx	r3
   13c64:	20009108 	.word	0x20009108
   13c68:	00013b35 	.word	0x00013b35
   13c6c:	0000ff01 	.word	0x0000ff01
   13c70:	0000fef1 	.word	0x0000fef1
   13c74:	00010115 	.word	0x00010115
   13c78:	00013cbd 	.word	0x00013cbd
   13c7c:	00013bc1 	.word	0x00013bc1
   13c80:	0000ff2d 	.word	0x0000ff2d

00013c84 <usbd_event_cb>:
 */
static void usbd_event_cb(const enum usb_event ev, const uint32_t param)
{
	(void)param;

	switch (ev) {
   13c84:	b110      	cbz	r0, 13c8c <usbd_event_cb+0x8>
   13c86:	2801      	cmp	r0, #1
   13c88:	d002      	beq.n	13c90 <usbd_event_cb+0xc>
   13c8a:	4770      	bx	lr
	case USB_EV_VBUS:
		usbdc_change_notify(USBDC_C_CONN, param);
   13c8c:	4b01      	ldr	r3, [pc, #4]	; (13c94 <usbd_event_cb+0x10>)
   13c8e:	4718      	bx	r3
		break;

	case USB_EV_RESET:
		usbdc_reset();
   13c90:	4b01      	ldr	r3, [pc, #4]	; (13c98 <usbd_event_cb+0x14>)
   13c92:	4718      	bx	r3
   13c94:	00013b51 	.word	0x00013b51
   13c98:	00013c2d 	.word	0x00013c2d

00013c9c <usbdc_xfer>:

/**
 * \brief Issue USB device transfer
 */
int32_t usbdc_xfer(uint8_t ep, uint8_t *buf, uint32_t size, bool zlp)
{
   13c9c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   13c9e:	f88d 000c 	strb.w	r0, [sp, #12]
   13ca2:	f88d 300d 	strb.w	r3, [sp, #13]
	return usb_d_ep_transfer(&xfer);
   13ca6:	a801      	add	r0, sp, #4
   13ca8:	4b03      	ldr	r3, [pc, #12]	; (13cb8 <usbdc_xfer+0x1c>)
	struct usb_d_transfer xfer = {(uint8_t *)buf, size, ep, zlp};
   13caa:	e9cd 1201 	strd	r1, r2, [sp, #4]
	return usb_d_ep_transfer(&xfer);
   13cae:	4798      	blx	r3
}
   13cb0:	b005      	add	sp, #20
   13cb2:	f85d fb04 	ldr.w	pc, [sp], #4
   13cb6:	bf00      	nop
   13cb8:	0000ff6d 	.word	0x0000ff6d

00013cbc <usbdc_cb_ctl_req>:
{
   13cbc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   13cc0:	4ba6      	ldr	r3, [pc, #664]	; (13f5c <usbdc_cb_ctl_req+0x2a0>)
   13cc2:	2200      	movs	r2, #0
{
   13cc4:	4605      	mov	r5, r0
   13cc6:	460c      	mov	r4, r1
	switch (usbdc_request_handler(ep, req, USB_SETUP_STAGE)) {
   13cc8:	4798      	blx	r3
   13cca:	1c43      	adds	r3, r0, #1
   13ccc:	d008      	beq.n	13ce0 <usbdc_cb_ctl_req+0x24>
   13cce:	2801      	cmp	r0, #1
   13cd0:	d034      	beq.n	13d3c <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & (USB_REQT_TYPE_MASK | USB_REQT_DIR_IN)) {
   13cd2:	7823      	ldrb	r3, [r4, #0]
   13cd4:	f013 02e0 	ands.w	r2, r3, #224	; 0xe0
   13cd8:	d004      	beq.n	13ce4 <usbdc_cb_ctl_req+0x28>
   13cda:	2a80      	cmp	r2, #128	; 0x80
   13cdc:	f000 80ca 	beq.w	13e74 <usbdc_cb_ctl_req+0x1b8>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13ce0:	2000      	movs	r0, #0
   13ce2:	e02b      	b.n	13d3c <usbdc_cb_ctl_req+0x80>
	switch (req->bRequest) {
   13ce4:	7862      	ldrb	r2, [r4, #1]
   13ce6:	3a01      	subs	r2, #1
   13ce8:	2a0a      	cmp	r2, #10
   13cea:	d8f9      	bhi.n	13ce0 <usbdc_cb_ctl_req+0x24>
   13cec:	a101      	add	r1, pc, #4	; (adr r1, 13cf4 <usbdc_cb_ctl_req+0x38>)
   13cee:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   13cf2:	bf00      	nop
   13cf4:	00013da7 	.word	0x00013da7
   13cf8:	00013ce1 	.word	0x00013ce1
   13cfc:	00013dcd 	.word	0x00013dcd
   13d00:	00013ce1 	.word	0x00013ce1
   13d04:	00013d2b 	.word	0x00013d2b
   13d08:	00013ce1 	.word	0x00013ce1
   13d0c:	00013ce1 	.word	0x00013ce1
   13d10:	00013ce1 	.word	0x00013ce1
   13d14:	00013d21 	.word	0x00013d21
   13d18:	00013ce1 	.word	0x00013ce1
   13d1c:	00013de7 	.word	0x00013de7
		if (!usbdc_set_config(req->wValue)) {
   13d20:	8862      	ldrh	r2, [r4, #2]
   13d22:	b2d2      	uxtb	r2, r2
	if (cfg_value == 0) {
   13d24:	b96a      	cbnz	r2, 13d42 <usbdc_cb_ctl_req+0x86>
		usbdc_unconfig();
   13d26:	4b8e      	ldr	r3, [pc, #568]	; (13f60 <usbdc_cb_ctl_req+0x2a4>)
   13d28:	4798      	blx	r3
		return (ERR_NONE == usbdc_xfer(ep, NULL, 0, true));
   13d2a:	2200      	movs	r2, #0
   13d2c:	2301      	movs	r3, #1
   13d2e:	4611      	mov	r1, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   13d30:	4c8c      	ldr	r4, [pc, #560]	; (13f64 <usbdc_cb_ctl_req+0x2a8>)
   13d32:	4628      	mov	r0, r5
   13d34:	47a0      	blx	r4
   13d36:	fab0 f080 	clz	r0, r0
   13d3a:	0940      	lsrs	r0, r0, #5
}
   13d3c:	b004      	add	sp, #16
   13d3e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, cfg_value);
   13d42:	4c89      	ldr	r4, [pc, #548]	; (13f68 <usbdc_cb_ctl_req+0x2ac>)
   13d44:	6823      	ldr	r3, [r4, #0]
   13d46:	e9d3 0100 	ldrd	r0, r1, [r3]
   13d4a:	4b88      	ldr	r3, [pc, #544]	; (13f6c <usbdc_cb_ctl_req+0x2b0>)
   13d4c:	4798      	blx	r3
	if (NULL == cfg_desc) {
   13d4e:	2800      	cmp	r0, #0
   13d50:	d0c6      	beq.n	13ce0 <usbdc_cb_ctl_req+0x24>
   13d52:	78c2      	ldrb	r2, [r0, #3]
   13d54:	7883      	ldrb	r3, [r0, #2]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13d56:	4f86      	ldr	r7, [pc, #536]	; (13f70 <usbdc_cb_ctl_req+0x2b4>)
   13d58:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod  = cfg_desc + total_len;
   13d5c:	fa10 f183 	uxtah	r1, r0, r3
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13d60:	2204      	movs	r2, #4
	desc.eod  = cfg_desc + total_len;
   13d62:	9103      	str	r1, [sp, #12]
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13d64:	47b8      	blx	r7
	uint8_t                 last_iface = 0xFF;
   13d66:	23ff      	movs	r3, #255	; 0xff
	desc.sod  = usb_find_desc(cfg_desc, desc.eod, USB_DT_INTERFACE);
   13d68:	9002      	str	r0, [sp, #8]
	while (NULL != desc.sod) {
   13d6a:	9a02      	ldr	r2, [sp, #8]
   13d6c:	2a00      	cmp	r2, #0
   13d6e:	d0dc      	beq.n	13d2a <usbdc_cb_ctl_req+0x6e>
		if (last_iface != desc.sod[2] /* bInterfaceNumber */) {
   13d70:	f892 8002 	ldrb.w	r8, [r2, #2]
   13d74:	4598      	cmp	r8, r3
   13d76:	d014      	beq.n	13da2 <usbdc_cb_ctl_req+0xe6>
			func       = (struct usbdf_driver *)usbdc.func_list.head;
   13d78:	6926      	ldr	r6, [r4, #16]
			while (NULL != func) {
   13d7a:	b94e      	cbnz	r6, 13d90 <usbdc_cb_ctl_req+0xd4>
		desc.sod = usb_desc_next(desc.sod);
   13d7c:	9802      	ldr	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13d7e:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   13d80:	7803      	ldrb	r3, [r0, #0]
   13d82:	2204      	movs	r2, #4
   13d84:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   13d86:	9002      	str	r0, [sp, #8]
		desc.sod = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13d88:	47b8      	blx	r7
   13d8a:	4643      	mov	r3, r8
   13d8c:	9002      	str	r0, [sp, #8]
   13d8e:	e7ec      	b.n	13d6a <usbdc_cb_ctl_req+0xae>
				if (func->ctrl(func, USBDF_ENABLE, &desc)) {
   13d90:	6873      	ldr	r3, [r6, #4]
   13d92:	aa02      	add	r2, sp, #8
   13d94:	2100      	movs	r1, #0
   13d96:	4630      	mov	r0, r6
   13d98:	4798      	blx	r3
   13d9a:	2800      	cmp	r0, #0
   13d9c:	d0ee      	beq.n	13d7c <usbdc_cb_ctl_req+0xc0>
					func = func->next;
   13d9e:	6836      	ldr	r6, [r6, #0]
   13da0:	e7eb      	b.n	13d7a <usbdc_cb_ctl_req+0xbe>
   13da2:	4698      	mov	r8, r3
   13da4:	e7ea      	b.n	13d7c <usbdc_cb_ctl_req+0xc0>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13da6:	2b02      	cmp	r3, #2
   13da8:	d19a      	bne.n	13ce0 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   13daa:	88e2      	ldrh	r2, [r4, #6]
   13dac:	2a00      	cmp	r2, #0
   13dae:	d197      	bne.n	13ce0 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_CLR);
   13db0:	88a0      	ldrh	r0, [r4, #4]
   13db2:	4b70      	ldr	r3, [pc, #448]	; (13f74 <usbdc_cb_ctl_req+0x2b8>)
   13db4:	9201      	str	r2, [sp, #4]
   13db6:	4611      	mov	r1, r2
   13db8:	b2c0      	uxtb	r0, r0
   13dba:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   13dbc:	9a01      	ldr	r2, [sp, #4]
   13dbe:	2301      	movs	r3, #1
		usbdc_xfer(ep, NULL, 0, true);
   13dc0:	4611      	mov	r1, r2
   13dc2:	4628      	mov	r0, r5
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13dc4:	4c67      	ldr	r4, [pc, #412]	; (13f64 <usbdc_cb_ctl_req+0x2a8>)
   13dc6:	47a0      	blx	r4
			return true;
   13dc8:	2001      	movs	r0, #1
   13dca:	e7b7      	b.n	13d3c <usbdc_cb_ctl_req+0x80>
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13dcc:	2b02      	cmp	r3, #2
   13dce:	d187      	bne.n	13ce0 <usbdc_cb_ctl_req+0x24>
		if (req->wLength != 0) {
   13dd0:	88e6      	ldrh	r6, [r4, #6]
   13dd2:	2e00      	cmp	r6, #0
   13dd4:	d184      	bne.n	13ce0 <usbdc_cb_ctl_req+0x24>
		usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_SET);
   13dd6:	88a0      	ldrh	r0, [r4, #4]
   13dd8:	4b66      	ldr	r3, [pc, #408]	; (13f74 <usbdc_cb_ctl_req+0x2b8>)
   13dda:	2101      	movs	r1, #1
   13ddc:	b2c0      	uxtb	r0, r0
   13dde:	4798      	blx	r3
		usbdc_xfer(ep, NULL, 0, true);
   13de0:	2301      	movs	r3, #1
   13de2:	4632      	mov	r2, r6
   13de4:	e7ec      	b.n	13dc0 <usbdc_cb_ctl_req+0x104>
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   13de6:	4d60      	ldr	r5, [pc, #384]	; (13f68 <usbdc_cb_ctl_req+0x2ac>)
		return usbdc_set_interface(req->wValue, req->wIndex);
   13de8:	8866      	ldrh	r6, [r4, #2]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   13dea:	682b      	ldr	r3, [r5, #0]
   13dec:	7eea      	ldrb	r2, [r5, #27]
		return usbdc_set_interface(req->wValue, req->wIndex);
   13dee:	88a7      	ldrh	r7, [r4, #4]
		ifc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, usbdc.cfg_value);
   13df0:	e9d3 0100 	ldrd	r0, r1, [r3]
   13df4:	4b5d      	ldr	r3, [pc, #372]	; (13f6c <usbdc_cb_ctl_req+0x2b0>)
   13df6:	4798      	blx	r3
	if (NULL == ifc) {
   13df8:	2800      	cmp	r0, #0
   13dfa:	f43f af71 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
	desc.sod = ifc;
   13dfe:	9002      	str	r0, [sp, #8]
	return (ptr[0] + (ptr[1] << 8));
   13e00:	78c2      	ldrb	r2, [r0, #3]
   13e02:	7883      	ldrb	r3, [r0, #2]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   13e04:	4c5a      	ldr	r4, [pc, #360]	; (13f70 <usbdc_cb_ctl_req+0x2b4>)
   13e06:	eb03 2302 	add.w	r3, r3, r2, lsl #8
	desc.eod = ifc + usb_cfg_desc_total_len(ifc);
   13e0a:	fa10 f183 	uxtah	r1, r0, r3
   13e0e:	9103      	str	r1, [sp, #12]
	if (NULL == (ifc = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE))) {
   13e10:	2204      	movs	r2, #4
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13e12:	47a0      	blx	r4
		if (NULL == ifc) {
   13e14:	2800      	cmp	r0, #0
   13e16:	f43f af63 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
	while (ifc[2] != ifc_id || ifc[3] != alt_set) {
   13e1a:	7883      	ldrb	r3, [r0, #2]
   13e1c:	42bb      	cmp	r3, r7
   13e1e:	d110      	bne.n	13e42 <usbdc_cb_ctl_req+0x186>
   13e20:	78c3      	ldrb	r3, [r0, #3]
   13e22:	42b3      	cmp	r3, r6
   13e24:	d10d      	bne.n	13e42 <usbdc_cb_ctl_req+0x186>
	func     = (struct usbdf_driver *)usbdc.func_list.head;
   13e26:	692c      	ldr	r4, [r5, #16]
	desc.sod = ifc;
   13e28:	9002      	str	r0, [sp, #8]
	while (NULL != func) {
   13e2a:	2c00      	cmp	r4, #0
   13e2c:	f43f af58 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
		if (func->ctrl(func, USBDF_DISABLE, &desc)) {
   13e30:	2101      	movs	r1, #1
   13e32:	6863      	ldr	r3, [r4, #4]
   13e34:	aa02      	add	r2, sp, #8
   13e36:	4620      	mov	r0, r4
   13e38:	4798      	blx	r3
   13e3a:	4601      	mov	r1, r0
   13e3c:	b140      	cbz	r0, 13e50 <usbdc_cb_ctl_req+0x194>
			func = func->next;
   13e3e:	6824      	ldr	r4, [r4, #0]
   13e40:	e7f3      	b.n	13e2a <usbdc_cb_ctl_req+0x16e>
		desc.sod = usb_desc_next(desc.sod);
   13e42:	9802      	ldr	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13e44:	9903      	ldr	r1, [sp, #12]
	return (desc + usb_desc_len(desc));
   13e46:	7803      	ldrb	r3, [r0, #0]
   13e48:	4418      	add	r0, r3
		desc.sod = usb_desc_next(desc.sod);
   13e4a:	9002      	str	r0, [sp, #8]
		ifc      = usb_find_desc(desc.sod, desc.eod, USB_DT_INTERFACE);
   13e4c:	2204      	movs	r2, #4
   13e4e:	e7e0      	b.n	13e12 <usbdc_cb_ctl_req+0x156>
		} else if (ERR_NONE == func->ctrl(func, USBDF_ENABLE, &desc)) {
   13e50:	6863      	ldr	r3, [r4, #4]
   13e52:	aa02      	add	r2, sp, #8
   13e54:	4620      	mov	r0, r4
   13e56:	4798      	blx	r3
   13e58:	2800      	cmp	r0, #0
   13e5a:	f47f af41 	bne.w	13ce0 <usbdc_cb_ctl_req+0x24>
			if (alt_set) {
   13e5e:	b126      	cbz	r6, 13e6a <usbdc_cb_ctl_req+0x1ae>
				usbdc.ifc_alt_map |= 1 << ifc_id;
   13e60:	2301      	movs	r3, #1
   13e62:	40bb      	lsls	r3, r7
   13e64:	7f6f      	ldrb	r7, [r5, #29]
   13e66:	431f      	orrs	r7, r3
   13e68:	776f      	strb	r7, [r5, #29]
			usbdc_xfer(0, NULL, 0, 0);
   13e6a:	2300      	movs	r3, #0
   13e6c:	461a      	mov	r2, r3
   13e6e:	4619      	mov	r1, r3
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13e70:	4618      	mov	r0, r3
   13e72:	e7a7      	b.n	13dc4 <usbdc_cb_ctl_req+0x108>
	switch (req->bRequest) {
   13e74:	7862      	ldrb	r2, [r4, #1]
   13e76:	2a0a      	cmp	r2, #10
   13e78:	f63f af32 	bhi.w	13ce0 <usbdc_cb_ctl_req+0x24>
   13e7c:	a101      	add	r1, pc, #4	; (adr r1, 13e84 <usbdc_cb_ctl_req+0x1c8>)
   13e7e:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
   13e82:	bf00      	nop
   13e84:	00013f7d 	.word	0x00013f7d
   13e88:	00013ce1 	.word	0x00013ce1
   13e8c:	00013ce1 	.word	0x00013ce1
   13e90:	00013ce1 	.word	0x00013ce1
   13e94:	00013ce1 	.word	0x00013ce1
   13e98:	00013ce1 	.word	0x00013ce1
   13e9c:	00013eb1 	.word	0x00013eb1
   13ea0:	00013ce1 	.word	0x00013ce1
   13ea4:	00013f4d 	.word	0x00013f4d
   13ea8:	00013ce1 	.word	0x00013ce1
   13eac:	00013fab 	.word	0x00013fab
	uint8_t type = (uint8_t)(req->wValue >> 8);
   13eb0:	8863      	ldrh	r3, [r4, #2]
   13eb2:	0a19      	lsrs	r1, r3, #8
	switch (type) {
   13eb4:	2902      	cmp	r1, #2
	uint8_t type = (uint8_t)(req->wValue >> 8);
   13eb6:	460a      	mov	r2, r1
	switch (type) {
   13eb8:	d016      	beq.n	13ee8 <usbdc_cb_ctl_req+0x22c>
   13eba:	2903      	cmp	r1, #3
   13ebc:	d031      	beq.n	13f22 <usbdc_cb_ctl_req+0x266>
   13ebe:	2901      	cmp	r1, #1
   13ec0:	f47f af0e 	bne.w	13ce0 <usbdc_cb_ctl_req+0x24>
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   13ec4:	4b28      	ldr	r3, [pc, #160]	; (13f68 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13ec6:	88e4      	ldrh	r4, [r4, #6]
		dev_desc = usb_find_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, USB_DT_DEVICE);
   13ec8:	681b      	ldr	r3, [r3, #0]
   13eca:	e9d3 0100 	ldrd	r0, r1, [r3]
   13ece:	4b28      	ldr	r3, [pc, #160]	; (13f70 <usbdc_cb_ctl_req+0x2b4>)
   13ed0:	4798      	blx	r3
	if (!dev_desc) {
   13ed2:	4601      	mov	r1, r0
   13ed4:	2800      	cmp	r0, #0
   13ed6:	f43f af03 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
	if (ERR_NONE != usbdc_xfer(ep, dev_desc, length, false)) {
   13eda:	2c12      	cmp	r4, #18
   13edc:	4622      	mov	r2, r4
   13ede:	f04f 0300 	mov.w	r3, #0
   13ee2:	bf28      	it	cs
   13ee4:	2212      	movcs	r2, #18
   13ee6:	e723      	b.n	13d30 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13ee8:	4a1f      	ldr	r2, [pc, #124]	; (13f68 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13eea:	88e4      	ldrh	r4, [r4, #6]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   13eec:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13eee:	7f16      	ldrb	r6, [r2, #28]
		cfg_desc = usb_find_cfg_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index + 1);
   13ef0:	1c5a      	adds	r2, r3, #1
   13ef2:	e9d0 0100 	ldrd	r0, r1, [r0]
   13ef6:	4b1d      	ldr	r3, [pc, #116]	; (13f6c <usbdc_cb_ctl_req+0x2b0>)
   13ef8:	b2d2      	uxtb	r2, r2
   13efa:	4798      	blx	r3
	if (NULL == cfg_desc) {
   13efc:	4601      	mov	r1, r0
   13efe:	2800      	cmp	r0, #0
   13f00:	f43f aeee 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
	return (ptr[0] + (ptr[1] << 8));
   13f04:	78c3      	ldrb	r3, [r0, #3]
   13f06:	7882      	ldrb	r2, [r0, #2]
   13f08:	eb02 2203 	add.w	r2, r2, r3, lsl #8
   13f0c:	b292      	uxth	r2, r2
	if (length <= total_len) {
   13f0e:	4294      	cmp	r4, r2
   13f10:	d91a      	bls.n	13f48 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13f12:	3e01      	subs	r6, #1
   13f14:	4226      	tst	r6, r4
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13f16:	bf0c      	ite	eq
   13f18:	2301      	moveq	r3, #1
   13f1a:	2300      	movne	r3, #0
   13f1c:	4614      	mov	r4, r2
	if (ERR_NONE != usbdc_xfer(ep, str_desc, length, need_zlp)) {
   13f1e:	4622      	mov	r2, r4
   13f20:	e706      	b.n	13d30 <usbdc_cb_ctl_req+0x74>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13f22:	4a11      	ldr	r2, [pc, #68]	; (13f68 <usbdc_cb_ctl_req+0x2ac>)
	uint16_t length   = req->wLength;
   13f24:	88e4      	ldrh	r4, [r4, #6]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   13f26:	6810      	ldr	r0, [r2, #0]
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13f28:	7f16      	ldrb	r6, [r2, #28]
	str_desc = usb_find_str_desc(usbdc.desces.ls_fs->sod, usbdc.desces.ls_fs->eod, index);
   13f2a:	e9d0 0100 	ldrd	r0, r1, [r0]
   13f2e:	b2da      	uxtb	r2, r3
   13f30:	4b11      	ldr	r3, [pc, #68]	; (13f78 <usbdc_cb_ctl_req+0x2bc>)
   13f32:	4798      	blx	r3
	if (NULL == str_desc) {
   13f34:	4601      	mov	r1, r0
   13f36:	2800      	cmp	r0, #0
   13f38:	f43f aed2 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
	if (length <= str_desc[0]) {
   13f3c:	7802      	ldrb	r2, [r0, #0]
   13f3e:	4294      	cmp	r4, r2
   13f40:	d902      	bls.n	13f48 <usbdc_cb_ctl_req+0x28c>
	bool     need_zlp = !(length & (usbdc.ctrl_size - 1));
   13f42:	1e73      	subs	r3, r6, #1
   13f44:	4223      	tst	r3, r4
   13f46:	e7e6      	b.n	13f16 <usbdc_cb_ctl_req+0x25a>
		need_zlp = false;
   13f48:	2300      	movs	r3, #0
   13f4a:	e7e8      	b.n	13f1e <usbdc_cb_ctl_req+0x262>
		*(uint8_t *)usbdc.ctrl_buf = usbdc.cfg_value;
   13f4c:	4906      	ldr	r1, [pc, #24]	; (13f68 <usbdc_cb_ctl_req+0x2ac>)
   13f4e:	694b      	ldr	r3, [r1, #20]
   13f50:	7eca      	ldrb	r2, [r1, #27]
   13f52:	701a      	strb	r2, [r3, #0]
		usbdc_xfer(ep, usbdc.ctrl_buf, 1, false);
   13f54:	2300      	movs	r3, #0
   13f56:	2201      	movs	r2, #1
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13f58:	6949      	ldr	r1, [r1, #20]
   13f5a:	e732      	b.n	13dc2 <usbdc_cb_ctl_req+0x106>
   13f5c:	00013b71 	.word	0x00013b71
   13f60:	00013b35 	.word	0x00013b35
   13f64:	00013c9d 	.word	0x00013c9d
   13f68:	20009108 	.word	0x20009108
   13f6c:	0000c185 	.word	0x0000c185
   13f70:	0000c14d 	.word	0x0000c14d
   13f74:	000100b1 	.word	0x000100b1
   13f78:	0000c1c1 	.word	0x0000c1c1
	switch (req->bmRequestType & USB_REQT_RECIP_MASK) {
   13f7c:	f003 011f 	and.w	r1, r3, #31
   13f80:	f013 031e 	ands.w	r3, r3, #30
   13f84:	d00b      	beq.n	13f9e <usbdc_cb_ctl_req+0x2e2>
   13f86:	2902      	cmp	r1, #2
   13f88:	f47f aeaa 	bne.w	13ce0 <usbdc_cb_ctl_req+0x24>
		st = usb_d_ep_halt(req->wIndex & 0xFF, USB_EP_HALT_GET);
   13f8c:	88a0      	ldrh	r0, [r4, #4]
   13f8e:	4b17      	ldr	r3, [pc, #92]	; (13fec <usbdc_cb_ctl_req+0x330>)
   13f90:	b2c0      	uxtb	r0, r0
   13f92:	4798      	blx	r3
		if (st < 0) {
   13f94:	1e03      	subs	r3, r0, #0
   13f96:	f6ff aea3 	blt.w	13ce0 <usbdc_cb_ctl_req+0x24>
		st = st & 0x1;
   13f9a:	f003 0301 	and.w	r3, r3, #1
	memcpy(usbdc.ctrl_buf, &st, 2);
   13f9e:	4914      	ldr	r1, [pc, #80]	; (13ff0 <usbdc_cb_ctl_req+0x334>)
   13fa0:	694a      	ldr	r2, [r1, #20]
   13fa2:	8013      	strh	r3, [r2, #0]
	usbdc_xfer(ep, usbdc.ctrl_buf, 2, false);
   13fa4:	2300      	movs	r3, #0
   13fa6:	2202      	movs	r2, #2
   13fa8:	e7d6      	b.n	13f58 <usbdc_cb_ctl_req+0x29c>
	if (!(usbdc.ifc_alt_map & (1 << req->wIndex))) {
   13faa:	4911      	ldr	r1, [pc, #68]	; (13ff0 <usbdc_cb_ctl_req+0x334>)
   13fac:	88a2      	ldrh	r2, [r4, #4]
   13fae:	7f4b      	ldrb	r3, [r1, #29]
   13fb0:	4113      	asrs	r3, r2
   13fb2:	f013 0301 	ands.w	r3, r3, #1
   13fb6:	460e      	mov	r6, r1
   13fb8:	d00c      	beq.n	13fd4 <usbdc_cb_ctl_req+0x318>
	struct usbdf_driver *func = (struct usbdf_driver *)usbdc.func_list.head;
   13fba:	690d      	ldr	r5, [r1, #16]
	while (NULL != func) {
   13fbc:	2d00      	cmp	r5, #0
   13fbe:	f43f ae8f 	beq.w	13ce0 <usbdc_cb_ctl_req+0x24>
		if (0 > (rc = func->ctrl(func, USBDF_GET_IFACE, req))) {
   13fc2:	686b      	ldr	r3, [r5, #4]
   13fc4:	4622      	mov	r2, r4
   13fc6:	2102      	movs	r1, #2
   13fc8:	4628      	mov	r0, r5
   13fca:	4798      	blx	r3
   13fcc:	2800      	cmp	r0, #0
   13fce:	da06      	bge.n	13fde <usbdc_cb_ctl_req+0x322>
			func = func->next;
   13fd0:	682d      	ldr	r5, [r5, #0]
   13fd2:	e7f3      	b.n	13fbc <usbdc_cb_ctl_req+0x300>
		usbdc.ctrl_buf[0] = 0;
   13fd4:	694a      	ldr	r2, [r1, #20]
   13fd6:	7013      	strb	r3, [r2, #0]
		usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13fd8:	6949      	ldr	r1, [r1, #20]
   13fda:	2201      	movs	r2, #1
   13fdc:	e748      	b.n	13e70 <usbdc_cb_ctl_req+0x1b4>
			usbdc.ctrl_buf[0] = (uint8_t)rc;
   13fde:	6973      	ldr	r3, [r6, #20]
   13fe0:	7018      	strb	r0, [r3, #0]
			usbdc_xfer(0, usbdc.ctrl_buf, 1, false);
   13fe2:	6971      	ldr	r1, [r6, #20]
   13fe4:	2300      	movs	r3, #0
   13fe6:	2201      	movs	r2, #1
   13fe8:	e742      	b.n	13e70 <usbdc_cb_ctl_req+0x1b4>
   13fea:	bf00      	nop
   13fec:	000100b1 	.word	0x000100b1
   13ff0:	20009108 	.word	0x20009108

00013ff4 <usbdc_register_handler>:
/**
 * \brief Register the handler
 */
void usbdc_register_handler(enum usbdc_handler_type type, const struct usbdc_handler *h)
{
	switch (type) {
   13ff4:	2801      	cmp	r0, #1
   13ff6:	d005      	beq.n	14004 <usbdc_register_handler+0x10>
   13ff8:	2802      	cmp	r0, #2
   13ffa:	d005      	beq.n	14008 <usbdc_register_handler+0x14>
   13ffc:	b930      	cbnz	r0, 1400c <usbdc_register_handler+0x18>
	case USBDC_HDL_SOF:
		list_insert_at_end(&usbdc.handlers.sof_list, (void *)h);
   13ffe:	4804      	ldr	r0, [pc, #16]	; (14010 <usbdc_register_handler+0x1c>)
		break;
	case USBDC_HDL_REQ:
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
		break;
	case USBDC_HDL_CHANGE:
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   14000:	4b04      	ldr	r3, [pc, #16]	; (14014 <usbdc_register_handler+0x20>)
   14002:	4718      	bx	r3
		list_insert_at_end(&usbdc.handlers.req_list, (void *)h);
   14004:	4804      	ldr	r0, [pc, #16]	; (14018 <usbdc_register_handler+0x24>)
   14006:	e7fb      	b.n	14000 <usbdc_register_handler+0xc>
		list_insert_at_end(&usbdc.handlers.change_list, (void *)h);
   14008:	4804      	ldr	r0, [pc, #16]	; (1401c <usbdc_register_handler+0x28>)
   1400a:	e7f9      	b.n	14000 <usbdc_register_handler+0xc>
		break;
	default:
		break;
	}
}
   1400c:	4770      	bx	lr
   1400e:	bf00      	nop
   14010:	2000910c 	.word	0x2000910c
   14014:	000101a5 	.word	0x000101a5
   14018:	20009110 	.word	0x20009110
   1401c:	20009114 	.word	0x20009114

00014020 <usbdc_init>:

/**
 * \brief Initialize the USB device core driver
 */
int32_t usbdc_init(uint8_t *ctrl_buf)
{
   14020:	b538      	push	{r3, r4, r5, lr}
	ASSERT(ctrl_buf);
   14022:	4604      	mov	r4, r0
   14024:	3800      	subs	r0, #0
   14026:	bf18      	it	ne
   14028:	2001      	movne	r0, #1
   1402a:	490c      	ldr	r1, [pc, #48]	; (1405c <usbdc_init+0x3c>)
   1402c:	4b0c      	ldr	r3, [pc, #48]	; (14060 <usbdc_init+0x40>)
   1402e:	f240 3255 	movw	r2, #853	; 0x355
   14032:	4798      	blx	r3

	int32_t rc;

	rc = usb_d_init();
   14034:	4b0b      	ldr	r3, [pc, #44]	; (14064 <usbdc_init+0x44>)
   14036:	4798      	blx	r3
	if (rc < 0) {
   14038:	2800      	cmp	r0, #0
   1403a:	db0e      	blt.n	1405a <usbdc_init+0x3a>
		return rc;
	}

	memset(&usbdc, 0, sizeof(usbdc));
   1403c:	4b0a      	ldr	r3, [pc, #40]	; (14068 <usbdc_init+0x48>)
   1403e:	4d0b      	ldr	r5, [pc, #44]	; (1406c <usbdc_init+0x4c>)
   14040:	2220      	movs	r2, #32
   14042:	4618      	mov	r0, r3
   14044:	2100      	movs	r1, #0
   14046:	47a8      	blx	r5
	usbdc.ctrl_buf = ctrl_buf;
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   14048:	4909      	ldr	r1, [pc, #36]	; (14070 <usbdc_init+0x50>)
	usbdc.ctrl_buf = ctrl_buf;
   1404a:	6144      	str	r4, [r0, #20]
	usb_d_register_callback(USB_D_CB_SOF, (FUNC_PTR)usbd_sof_cb);
   1404c:	4c09      	ldr	r4, [pc, #36]	; (14074 <usbdc_init+0x54>)
   1404e:	2000      	movs	r0, #0
   14050:	47a0      	blx	r4
	usb_d_register_callback(USB_D_CB_EVENT, (FUNC_PTR)usbd_event_cb);
   14052:	2001      	movs	r0, #1
   14054:	4908      	ldr	r1, [pc, #32]	; (14078 <usbdc_init+0x58>)
   14056:	47a0      	blx	r4

	return 0;
   14058:	2000      	movs	r0, #0
}
   1405a:	bd38      	pop	{r3, r4, r5, pc}
   1405c:	00017530 	.word	0x00017530
   14060:	0000e9b9 	.word	0x0000e9b9
   14064:	0000fe0d 	.word	0x0000fe0d
   14068:	20009108 	.word	0x20009108
   1406c:	00014d51 	.word	0x00014d51
   14070:	00013ba9 	.word	0x00013ba9
   14074:	0000fe75 	.word	0x0000fe75
   14078:	00013c85 	.word	0x00013c85

0001407c <usbdc_register_function>:
 * \brief Register/unregister function support of a USB device function
 *
 * Must be invoked when USB device is stopped.
 */
void usbdc_register_function(struct usbdf_driver *func)
{
   1407c:	4601      	mov	r1, r0
	list_insert_at_end(&usbdc.func_list, func);
   1407e:	4b01      	ldr	r3, [pc, #4]	; (14084 <usbdc_register_function+0x8>)
   14080:	4801      	ldr	r0, [pc, #4]	; (14088 <usbdc_register_function+0xc>)
   14082:	4718      	bx	r3
   14084:	000101a5 	.word	0x000101a5
   14088:	20009118 	.word	0x20009118

0001408c <usbdc_start>:

/**
 * \brief Start the USB device driver with specific descriptors set
 */
int32_t usbdc_start(struct usbd_descriptors *desces)
{
   1408c:	b510      	push	{r4, lr}
	if (usbdc.state >= USBD_S_POWER) {
   1408e:	4b0a      	ldr	r3, [pc, #40]	; (140b8 <usbdc_start+0x2c>)
   14090:	7e9c      	ldrb	r4, [r3, #26]
   14092:	b954      	cbnz	r4, 140aa <usbdc_start+0x1e>
		return ERR_BUSY;
	}

	if (desces) {
   14094:	b160      	cbz	r0, 140b0 <usbdc_start+0x24>
#endif
	} else {
		return ERR_BAD_DATA;
	}

	usbdc.ctrl_size = desces->sod[7];
   14096:	6802      	ldr	r2, [r0, #0]
		usbdc.desces.ls_fs = desces;
   14098:	6018      	str	r0, [r3, #0]
	usbdc.ctrl_size = desces->sod[7];
   1409a:	79d2      	ldrb	r2, [r2, #7]
   1409c:	771a      	strb	r2, [r3, #28]
	usbdc.state     = USBD_S_POWER;
   1409e:	2201      	movs	r2, #1
   140a0:	769a      	strb	r2, [r3, #26]
	usb_d_enable();
   140a2:	4b06      	ldr	r3, [pc, #24]	; (140bc <usbdc_start+0x30>)
   140a4:	4798      	blx	r3
	return ERR_NONE;
   140a6:	4620      	mov	r0, r4
}
   140a8:	bd10      	pop	{r4, pc}
		return ERR_BUSY;
   140aa:	f06f 0003 	mvn.w	r0, #3
   140ae:	e7fb      	b.n	140a8 <usbdc_start+0x1c>
		return ERR_BAD_DATA;
   140b0:	f06f 0008 	mvn.w	r0, #8
   140b4:	e7f8      	b.n	140a8 <usbdc_start+0x1c>
   140b6:	bf00      	nop
   140b8:	20009108 	.word	0x20009108
   140bc:	0000fe7d 	.word	0x0000fe7d

000140c0 <usbdc_attach>:
/**
 * \brief Attach the USB device to host
 */
void usbdc_attach(void)
{
	usb_d_attach();
   140c0:	4b00      	ldr	r3, [pc, #0]	; (140c4 <usbdc_attach+0x4>)
   140c2:	4718      	bx	r3
   140c4:	0000fe85 	.word	0x0000fe85

000140c8 <usbdc_get_ctrl_buffer>:
 * \brief Return USB Device endpoint0 buffer
 */
uint8_t *usbdc_get_ctrl_buffer(void)
{
	return usbdc.ctrl_buf;
}
   140c8:	4b01      	ldr	r3, [pc, #4]	; (140d0 <usbdc_get_ctrl_buffer+0x8>)
   140ca:	6958      	ldr	r0, [r3, #20]
   140cc:	4770      	bx	lr
   140ce:	bf00      	nop
   140d0:	20009108 	.word	0x20009108

000140d4 <usbdc_get_state>:
/**
 * \brief Return current USB state
 */
uint8_t usbdc_get_state(void)
{
	if (usbdc.state & USBD_S_SUSPEND) {
   140d4:	4b03      	ldr	r3, [pc, #12]	; (140e4 <usbdc_get_state+0x10>)
   140d6:	7e98      	ldrb	r0, [r3, #26]
   140d8:	f010 0f10 	tst.w	r0, #16
		return USBD_S_SUSPEND;
	}
	return usbdc.state;
}
   140dc:	bf18      	it	ne
   140de:	2010      	movne	r0, #16
   140e0:	4770      	bx	lr
   140e2:	bf00      	nop
   140e4:	20009108 	.word	0x20009108

000140e8 <hri_tc_wait_for_sync>:
typedef uint8_t  hri_tccount8_per_reg_t;
typedef uint8_t  hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg) {
   140e8:	6903      	ldr	r3, [r0, #16]
   140ea:	420b      	tst	r3, r1
   140ec:	d1fc      	bne.n	140e8 <hri_tc_wait_for_sync>
	};
}
   140ee:	4770      	bx	lr

000140f0 <_tc_timer_start>:
/**
 * \brief Start hardware timer
 */
void _tc_timer_start(struct _timer_device *const device)
{
	hri_tc_set_CTRLA_ENABLE_bit(device->hw);
   140f0:	68c0      	ldr	r0, [r0, #12]
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	TC_CRITICAL_SECTION_ENTER();
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
   140f2:	6803      	ldr	r3, [r0, #0]
   140f4:	f043 0302 	orr.w	r3, r3, #2
   140f8:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   140fa:	2103      	movs	r1, #3
   140fc:	4b00      	ldr	r3, [pc, #0]	; (14100 <_tc_timer_start+0x10>)
   140fe:	4718      	bx	r3
   14100:	000140e9 	.word	0x000140e9

00014104 <_tc_timer_get_period>:
/**
 * \brief Retrieve timer period
 */
uint32_t _tc_timer_get_period(const struct _timer_device *const device)
{
	void *const hw = device->hw;
   14104:	68c0      	ldr	r0, [r0, #12]
{
   14106:	b508      	push	{r3, lr}
}

static inline hri_tc_ctrla_reg_t hri_tc_read_CTRLA_MODE_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   14108:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   1410a:	f3c3 0381 	ubfx	r3, r3, #2, #2

	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1410e:	2b02      	cmp	r3, #2
   14110:	d104      	bne.n	1411c <_tc_timer_get_period+0x18>
	TC_CRITICAL_SECTION_LEAVE();
}

static inline hri_tccount32_cc_reg_t hri_tccount32_read_CC_reg(const void *const hw, uint8_t index)
{
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   14112:	4b0e      	ldr	r3, [pc, #56]	; (1414c <_tc_timer_get_period+0x48>)
   14114:	21c0      	movs	r1, #192	; 0xc0
   14116:	4798      	blx	r3
	return ((Tc *)hw)->COUNT32.CC[index].reg;
   14118:	69c0      	ldr	r0, [r0, #28]
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
		return hri_tccount8_read_PER_reg(hw);
	}

	return 0;
}
   1411a:	bd08      	pop	{r3, pc}
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1411c:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1411e:	f013 0f0c 	tst.w	r3, #12
   14122:	d105      	bne.n	14130 <_tc_timer_get_period+0x2c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   14124:	4b09      	ldr	r3, [pc, #36]	; (1414c <_tc_timer_get_period+0x48>)
   14126:	21c0      	movs	r1, #192	; 0xc0
   14128:	4798      	blx	r3
	return ((Tc *)hw)->COUNT16.CC[index].reg;
   1412a:	8b80      	ldrh	r0, [r0, #28]
   1412c:	b280      	uxth	r0, r0
		return hri_tccount16_read_CC_reg(hw, 0);
   1412e:	e7f4      	b.n	1411a <_tc_timer_get_period+0x16>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   14130:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   14132:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   14136:	2b01      	cmp	r3, #1
   14138:	d105      	bne.n	14146 <_tc_timer_get_period+0x42>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   1413a:	4b04      	ldr	r3, [pc, #16]	; (1414c <_tc_timer_get_period+0x48>)
   1413c:	2120      	movs	r1, #32
   1413e:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.PER.reg;
   14140:	7ec0      	ldrb	r0, [r0, #27]
   14142:	b2c0      	uxtb	r0, r0
		return hri_tccount8_read_PER_reg(hw);
   14144:	e7e9      	b.n	1411a <_tc_timer_get_period+0x16>
	return 0;
   14146:	2000      	movs	r0, #0
   14148:	e7e7      	b.n	1411a <_tc_timer_get_period+0x16>
   1414a:	bf00      	nop
   1414c:	000140e9 	.word	0x000140e9

00014150 <_tc_timer_is_started>:
/**
 * \brief Check if timer is running
 */
bool _tc_timer_is_started(const struct _timer_device *const device)
{
   14150:	b508      	push	{r3, lr}
	return hri_tc_get_CTRLA_ENABLE_bit(device->hw);
   14152:	68c0      	ldr	r0, [r0, #12]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   14154:	4b03      	ldr	r3, [pc, #12]	; (14164 <_tc_timer_is_started+0x14>)
   14156:	2103      	movs	r1, #3
   14158:	4798      	blx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1415a:	6800      	ldr	r0, [r0, #0]
}
   1415c:	f3c0 0040 	ubfx	r0, r0, #1, #1
   14160:	bd08      	pop	{r3, pc}
   14162:	bf00      	nop
   14164:	000140e9 	.word	0x000140e9

00014168 <tc_interrupt_handler>:
 *
 * \param[in] instance TC instance number
 */
static void tc_interrupt_handler(struct _timer_device *device)
{
	void *const hw = device->hw;
   14168:	68c2      	ldr	r2, [r0, #12]
	return (((Tc *)hw)->COUNT16.INTFLAG.reg & TC_INTFLAG_OVF) >> TC_INTFLAG_OVF_Pos;
   1416a:	7a91      	ldrb	r1, [r2, #10]

	if (hri_tc_get_interrupt_OVF_bit(hw)) {
   1416c:	07c9      	lsls	r1, r1, #31
   1416e:	d503      	bpl.n	14178 <tc_interrupt_handler+0x10>
	((Tc *)hw)->COUNT16.INTFLAG.reg = TC_INTFLAG_OVF;
   14170:	2101      	movs	r1, #1
		hri_tc_clear_interrupt_OVF_bit(hw);
		device->timer_cb.period_expired(device);
   14172:	6803      	ldr	r3, [r0, #0]
   14174:	7291      	strb	r1, [r2, #10]
   14176:	4718      	bx	r3
	}
}
   14178:	4770      	bx	lr
	...

0001417c <get_tc_index>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The index of TC configuration
 */
static int8_t get_tc_index(const void *const hw)
{
   1417c:	b570      	push	{r4, r5, r6, lr}
 * \param[in] hw The pointer to hardware instance
 */
static inline uint8_t _get_hardware_offset(const void *const hw)
{
	/* List of available TC modules. */
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   1417e:	4d15      	ldr	r5, [pc, #84]	; (141d4 <get_tc_index+0x58>)
{
   14180:	4606      	mov	r6, r0
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   14182:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
{
   14184:	b088      	sub	sp, #32
	Tc *const tc_modules[TC_INST_NUM] = TC_INSTS;
   14186:	466c      	mov	r4, sp
   14188:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   1418a:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
   1418e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

	/* Find index for TC instance. */
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   14192:	466a      	mov	r2, sp
   14194:	2300      	movs	r3, #0
		if ((uint32_t)hw == (uint32_t)tc_modules[i]) {
   14196:	f852 1b04 	ldr.w	r1, [r2], #4
   1419a:	42b1      	cmp	r1, r6
   1419c:	d104      	bne.n	141a8 <get_tc_index+0x2c>
			return i;
   1419e:	b2d8      	uxtb	r0, r3
		if (_tcs[i].number == index) {
   141a0:	b93b      	cbnz	r3, 141b2 <get_tc_index+0x36>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   141a2:	4618      	mov	r0, r3
			return i;
   141a4:	b240      	sxtb	r0, r0
   141a6:	e012      	b.n	141ce <get_tc_index+0x52>
	for (uint32_t i = 0; i < TC_INST_NUM; i++) {
   141a8:	3301      	adds	r3, #1
   141aa:	2b08      	cmp	r3, #8
   141ac:	d1f3      	bne.n	14196 <get_tc_index+0x1a>
	for (i = 0; i < ARRAY_SIZE(_tcs); i++) {
   141ae:	2000      	movs	r0, #0
   141b0:	e7f8      	b.n	141a4 <get_tc_index+0x28>
		if (_tcs[i].number == index) {
   141b2:	2801      	cmp	r0, #1
   141b4:	d0f6      	beq.n	141a4 <get_tc_index+0x28>
   141b6:	2802      	cmp	r0, #2
   141b8:	d0f4      	beq.n	141a4 <get_tc_index+0x28>
   141ba:	2803      	cmp	r0, #3
   141bc:	d0f2      	beq.n	141a4 <get_tc_index+0x28>
	ASSERT(false);
   141be:	2000      	movs	r0, #0
   141c0:	4905      	ldr	r1, [pc, #20]	; (141d8 <get_tc_index+0x5c>)
   141c2:	4b06      	ldr	r3, [pc, #24]	; (141dc <get_tc_index+0x60>)
   141c4:	f240 1267 	movw	r2, #359	; 0x167
   141c8:	4798      	blx	r3
	return -1;
   141ca:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
   141ce:	b008      	add	sp, #32
   141d0:	bd70      	pop	{r4, r5, r6, pc}
   141d2:	bf00      	nop
   141d4:	0001755c 	.word	0x0001755c
   141d8:	00017546 	.word	0x00017546
   141dc:	0000e9b9 	.word	0x0000e9b9

000141e0 <_tc_timer_set_irq>:
{
   141e0:	b510      	push	{r4, lr}
	int8_t      i  = get_tc_index(hw);
   141e2:	4b0a      	ldr	r3, [pc, #40]	; (1420c <_tc_timer_set_irq+0x2c>)
   141e4:	68c0      	ldr	r0, [r0, #12]
   141e6:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   141e8:	4b09      	ldr	r3, [pc, #36]	; (14210 <_tc_timer_set_irq+0x30>)
   141ea:	490a      	ldr	r1, [pc, #40]	; (14214 <_tc_timer_set_irq+0x34>)
	int8_t      i  = get_tc_index(hw);
   141ec:	4604      	mov	r4, r0
	ASSERT(ARRAY_SIZE(_tcs));
   141ee:	f44f 7291 	mov.w	r2, #290	; 0x122
   141f2:	2001      	movs	r0, #1
   141f4:	4798      	blx	r3
	_irq_set(_tcs[i].irq);
   141f6:	4808      	ldr	r0, [pc, #32]	; (14218 <_tc_timer_set_irq+0x38>)
   141f8:	2314      	movs	r3, #20
   141fa:	fb03 0404 	mla	r4, r3, r4, r0
   141fe:	4b07      	ldr	r3, [pc, #28]	; (1421c <_tc_timer_set_irq+0x3c>)
   14200:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
}
   14204:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	_irq_set(_tcs[i].irq);
   14208:	4718      	bx	r3
   1420a:	bf00      	nop
   1420c:	0001417d 	.word	0x0001417d
   14210:	0000e9b9 	.word	0x0000e9b9
   14214:	00017546 	.word	0x00017546
   14218:	0001755c 	.word	0x0001755c
   1421c:	0000c409 	.word	0x0000c409

00014220 <_tc_timer_stop>:
	hri_tc_clear_CTRLA_ENABLE_bit(device->hw);
   14220:	68c0      	ldr	r0, [r0, #12]
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   14222:	6803      	ldr	r3, [r0, #0]
   14224:	f023 0302 	bic.w	r3, r3, #2
   14228:	6003      	str	r3, [r0, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   1422a:	2103      	movs	r1, #3
   1422c:	4b00      	ldr	r3, [pc, #0]	; (14230 <_tc_timer_stop+0x10>)
   1422e:	4718      	bx	r3
   14230:	000140e9 	.word	0x000140e9

00014234 <_tc_timer_deinit>:
{
   14234:	b570      	push	{r4, r5, r6, lr}
	void *const hw = device->hw;
   14236:	68c4      	ldr	r4, [r0, #12]
	int8_t      i  = get_tc_index(hw);
   14238:	4b17      	ldr	r3, [pc, #92]	; (14298 <_tc_timer_deinit+0x64>)
   1423a:	4620      	mov	r0, r4
   1423c:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   1423e:	4b17      	ldr	r3, [pc, #92]	; (1429c <_tc_timer_deinit+0x68>)
   14240:	4917      	ldr	r1, [pc, #92]	; (142a0 <_tc_timer_deinit+0x6c>)
	int8_t      i  = get_tc_index(hw);
   14242:	4605      	mov	r5, r0
	ASSERT(ARRAY_SIZE(_tcs));
   14244:	22cd      	movs	r2, #205	; 0xcd
   14246:	2001      	movs	r0, #1
   14248:	4798      	blx	r3
	NVIC_DisableIRQ(_tcs[i].irq);
   1424a:	4816      	ldr	r0, [pc, #88]	; (142a4 <_tc_timer_deinit+0x70>)
   1424c:	2314      	movs	r3, #20
   1424e:	fb03 0505 	mla	r5, r3, r5, r0
   14252:	f9b5 3022 	ldrsh.w	r3, [r5, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   14256:	2b00      	cmp	r3, #0
   14258:	db0d      	blt.n	14276 <_tc_timer_deinit+0x42>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1425a:	095a      	lsrs	r2, r3, #5
   1425c:	2101      	movs	r1, #1
   1425e:	f003 031f 	and.w	r3, r3, #31
   14262:	fa01 f303 	lsl.w	r3, r1, r3
   14266:	3220      	adds	r2, #32
   14268:	490f      	ldr	r1, [pc, #60]	; (142a8 <_tc_timer_deinit+0x74>)
   1426a:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   1426e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   14272:	f3bf 8f6f 	isb	sy
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   14276:	6823      	ldr	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   14278:	4a0c      	ldr	r2, [pc, #48]	; (142ac <_tc_timer_deinit+0x78>)
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   1427a:	f023 0302 	bic.w	r3, r3, #2
   1427e:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   14280:	2103      	movs	r1, #3
   14282:	4620      	mov	r0, r4
   14284:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_SWRST;
   14286:	6823      	ldr	r3, [r4, #0]
   14288:	f043 0301 	orr.w	r3, r3, #1
   1428c:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   1428e:	2101      	movs	r1, #1
}
   14290:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
   14294:	4710      	bx	r2
   14296:	bf00      	nop
   14298:	0001417d 	.word	0x0001417d
   1429c:	0000e9b9 	.word	0x0000e9b9
   142a0:	00017546 	.word	0x00017546
   142a4:	0001755c 	.word	0x0001755c
   142a8:	e000e100 	.word	0xe000e100
   142ac:	000140e9 	.word	0x000140e9

000142b0 <_tc_timer_init>:
{
   142b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	int8_t i = get_tc_index(hw);
   142b4:	4b51      	ldr	r3, [pc, #324]	; (143fc <_tc_timer_init+0x14c>)
{
   142b6:	4607      	mov	r7, r0
	int8_t i = get_tc_index(hw);
   142b8:	4608      	mov	r0, r1
{
   142ba:	460c      	mov	r4, r1
	int8_t i = get_tc_index(hw);
   142bc:	4798      	blx	r3
	ASSERT(ARRAY_SIZE(_tcs));
   142be:	4b50      	ldr	r3, [pc, #320]	; (14400 <_tc_timer_init+0x150>)
   142c0:	4950      	ldr	r1, [pc, #320]	; (14404 <_tc_timer_init+0x154>)
	device->hw = hw;
   142c2:	60fc      	str	r4, [r7, #12]
	ASSERT(ARRAY_SIZE(_tcs));
   142c4:	22a0      	movs	r2, #160	; 0xa0
	int8_t i = get_tc_index(hw);
   142c6:	4606      	mov	r6, r0
	ASSERT(ARRAY_SIZE(_tcs));
   142c8:	2001      	movs	r0, #1
   142ca:	4798      	blx	r3
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
   142cc:	6923      	ldr	r3, [r4, #16]
   142ce:	4a4e      	ldr	r2, [pc, #312]	; (14408 <_tc_timer_init+0x158>)
	if (!hri_tc_is_syncing(hw, TC_SYNCBUSY_SWRST)) {
   142d0:	f013 0f01 	tst.w	r3, #1
   142d4:	d112      	bne.n	142fc <_tc_timer_init+0x4c>
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   142d6:	2103      	movs	r1, #3
   142d8:	4620      	mov	r0, r4
   142da:	4790      	blx	r2
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   142dc:	6823      	ldr	r3, [r4, #0]
		if (hri_tc_get_CTRLA_reg(hw, TC_CTRLA_ENABLE)) {
   142de:	079b      	lsls	r3, r3, #30
   142e0:	d507      	bpl.n	142f2 <_tc_timer_init+0x42>
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   142e2:	6823      	ldr	r3, [r4, #0]
   142e4:	f023 0302 	bic.w	r3, r3, #2
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   142e8:	2103      	movs	r1, #3
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
   142ea:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   142ec:	4790      	blx	r2
			hri_tc_wait_for_sync(hw, TC_SYNCBUSY_ENABLE);
   142ee:	2102      	movs	r1, #2
   142f0:	4790      	blx	r2
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   142f2:	2301      	movs	r3, #1
   142f4:	6023      	str	r3, [r4, #0]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   142f6:	2103      	movs	r1, #3
   142f8:	4620      	mov	r0, r4
   142fa:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   142fc:	f8df 9124 	ldr.w	r9, [pc, #292]	; 14424 <_tc_timer_init+0x174>
   14300:	2514      	movs	r5, #20
   14302:	fb05 9506 	mla	r5, r5, r6, r9
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST);
   14306:	2101      	movs	r1, #1
   14308:	4620      	mov	r0, r4
   1430a:	4790      	blx	r2
	hri_tc_write_CTRLA_reg(hw, _tcs[i].ctrl_a);
   1430c:	f8d5 8024 	ldr.w	r8, [r5, #36]	; 0x24
	((Tc *)hw)->COUNT16.CTRLA.reg = data;
   14310:	f8c4 8000 	str.w	r8, [r4]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
   14314:	2103      	movs	r1, #3
   14316:	4790      	blx	r2
	hri_tc_write_DBGCTRL_reg(hw, _tcs[i].dbg_ctrl);
   14318:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
	((Tc *)hw)->COUNT16.DBGCTRL.reg = data;
   1431c:	73e3      	strb	r3, [r4, #15]
	hri_tc_write_EVCTRL_reg(hw, _tcs[i].event_ctrl);
   1431e:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
   14320:	80e3      	strh	r3, [r4, #6]
	((Tc *)hw)->COUNT16.WAVE.reg = data;
   14322:	2301      	movs	r3, #1
   14324:	7323      	strb	r3, [r4, #12]
	if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT32) {
   14326:	f008 030c 	and.w	r3, r8, #12
   1432a:	2b08      	cmp	r3, #8
   1432c:	d13b      	bne.n	143a6 <_tc_timer_init+0xf6>
		hri_tccount32_write_CC_reg(hw, 0, _tcs[i].cc0);
   1432e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   14330:	61e3      	str	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   14332:	21c0      	movs	r1, #192	; 0xc0
   14334:	4790      	blx	r2
		hri_tccount32_write_CC_reg(hw, 1, _tcs[i].cc1);
   14336:	6b2b      	ldr	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   14338:	6223      	str	r3, [r4, #32]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   1433a:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   1433c:	4620      	mov	r0, r4
   1433e:	4790      	blx	r2
	((Tc *)hw)->COUNT16.INTENSET.reg = TC_INTENSET_OVF;
   14340:	2301      	movs	r3, #1
   14342:	7263      	strb	r3, [r4, #9]
	if (hw == TC0) {
   14344:	4b31      	ldr	r3, [pc, #196]	; (1440c <_tc_timer_init+0x15c>)
   14346:	429c      	cmp	r4, r3
   14348:	d146      	bne.n	143d8 <_tc_timer_init+0x128>
		_tc0_dev = (struct _timer_device *)dev;
   1434a:	4b31      	ldr	r3, [pc, #196]	; (14410 <_tc_timer_init+0x160>)
   1434c:	601f      	str	r7, [r3, #0]
	NVIC_DisableIRQ(_tcs[i].irq);
   1434e:	2314      	movs	r3, #20
   14350:	fb03 9306 	mla	r3, r3, r6, r9
   14354:	f9b3 3022 	ldrsh.w	r3, [r3, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   14358:	2b00      	cmp	r3, #0
   1435a:	db0d      	blt.n	14378 <_tc_timer_init+0xc8>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1435c:	095a      	lsrs	r2, r3, #5
   1435e:	2101      	movs	r1, #1
   14360:	f003 031f 	and.w	r3, r3, #31
   14364:	fa01 f303 	lsl.w	r3, r1, r3
   14368:	3220      	adds	r2, #32
   1436a:	492a      	ldr	r1, [pc, #168]	; (14414 <_tc_timer_init+0x164>)
   1436c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
   14370:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
   14374:	f3bf 8f6f 	isb	sy
	NVIC_ClearPendingIRQ(_tcs[i].irq);
   14378:	2014      	movs	r0, #20
   1437a:	fb00 9606 	mla	r6, r0, r6, r9
   1437e:	f9b6 3022 	ldrsh.w	r3, [r6, #34]	; 0x22
  if ((int32_t)(IRQn) >= 0)
   14382:	2b00      	cmp	r3, #0
   14384:	db0c      	blt.n	143a0 <_tc_timer_init+0xf0>
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   14386:	f003 011f 	and.w	r1, r3, #31
   1438a:	095b      	lsrs	r3, r3, #5
   1438c:	009b      	lsls	r3, r3, #2
   1438e:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   14392:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
   14396:	2201      	movs	r2, #1
   14398:	408a      	lsls	r2, r1
   1439a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   1439e:	601a      	str	r2, [r3, #0]
}
   143a0:	2000      	movs	r0, #0
   143a2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT16) {
   143a6:	b933      	cbnz	r3, 143b6 <_tc_timer_init+0x106>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)_tcs[i].cc0);
   143a8:	8dab      	ldrh	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   143aa:	83a3      	strh	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   143ac:	21c0      	movs	r1, #192	; 0xc0
   143ae:	4790      	blx	r2
		hri_tccount16_write_CC_reg(hw, 1, (uint16_t)_tcs[i].cc1);
   143b0:	8e2b      	ldrh	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   143b2:	83e3      	strh	r3, [r4, #30]
   143b4:	e7c1      	b.n	1433a <_tc_timer_init+0x8a>
	} else if ((_tcs[i].ctrl_a & TC_CTRLA_MODE_Msk) == TC_CTRLA_MODE_COUNT8) {
   143b6:	2b04      	cmp	r3, #4
   143b8:	d1c2      	bne.n	14340 <_tc_timer_init+0x90>
		hri_tccount8_write_CC_reg(hw, 0, (uint8_t)_tcs[i].cc0);
   143ba:	f895 302c 	ldrb.w	r3, [r5, #44]	; 0x2c
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   143be:	7723      	strb	r3, [r4, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   143c0:	21c0      	movs	r1, #192	; 0xc0
   143c2:	4790      	blx	r2
		hri_tccount8_write_CC_reg(hw, 1, (uint8_t)_tcs[i].cc1);
   143c4:	f895 3030 	ldrb.w	r3, [r5, #48]	; 0x30
	((Tc *)hw)->COUNT8.CC[index].reg = data;
   143c8:	7763      	strb	r3, [r4, #29]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   143ca:	21c0      	movs	r1, #192	; 0xc0
   143cc:	4790      	blx	r2
		hri_tccount8_write_PER_reg(hw, _tcs[i].per);
   143ce:	f895 302b 	ldrb.w	r3, [r5, #43]	; 0x2b
	((Tc *)hw)->COUNT8.PER.reg = data;
   143d2:	76e3      	strb	r3, [r4, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   143d4:	2120      	movs	r1, #32
   143d6:	e7b1      	b.n	1433c <_tc_timer_init+0x8c>
	if (hw == TC1) {
   143d8:	4b0f      	ldr	r3, [pc, #60]	; (14418 <_tc_timer_init+0x168>)
   143da:	429c      	cmp	r4, r3
   143dc:	d008      	beq.n	143f0 <_tc_timer_init+0x140>
	if (hw == TC2) {
   143de:	4b0f      	ldr	r3, [pc, #60]	; (1441c <_tc_timer_init+0x16c>)
   143e0:	429c      	cmp	r4, r3
   143e2:	d008      	beq.n	143f6 <_tc_timer_init+0x146>
	if (hw == TC3) {
   143e4:	4b0e      	ldr	r3, [pc, #56]	; (14420 <_tc_timer_init+0x170>)
   143e6:	429c      	cmp	r4, r3
   143e8:	d1b1      	bne.n	1434e <_tc_timer_init+0x9e>
		_tc3_dev = (struct _timer_device *)dev;
   143ea:	4b09      	ldr	r3, [pc, #36]	; (14410 <_tc_timer_init+0x160>)
   143ec:	60df      	str	r7, [r3, #12]
   143ee:	e7ae      	b.n	1434e <_tc_timer_init+0x9e>
		_tc1_dev = (struct _timer_device *)dev;
   143f0:	4b07      	ldr	r3, [pc, #28]	; (14410 <_tc_timer_init+0x160>)
   143f2:	605f      	str	r7, [r3, #4]
	if (hw == TC3) {
   143f4:	e7ab      	b.n	1434e <_tc_timer_init+0x9e>
		_tc2_dev = (struct _timer_device *)dev;
   143f6:	4b06      	ldr	r3, [pc, #24]	; (14410 <_tc_timer_init+0x160>)
   143f8:	609f      	str	r7, [r3, #8]
	if (hw == TC3) {
   143fa:	e7a8      	b.n	1434e <_tc_timer_init+0x9e>
   143fc:	0001417d 	.word	0x0001417d
   14400:	0000e9b9 	.word	0x0000e9b9
   14404:	00017546 	.word	0x00017546
   14408:	000140e9 	.word	0x000140e9
   1440c:	40003800 	.word	0x40003800
   14410:	20009128 	.word	0x20009128
   14414:	e000e100 	.word	0xe000e100
   14418:	40003c00 	.word	0x40003c00
   1441c:	4101a000 	.word	0x4101a000
   14420:	4101c000 	.word	0x4101c000
   14424:	0001755c 	.word	0x0001755c

00014428 <_tc_timer_set_period>:
	void *const hw = device->hw;
   14428:	68c0      	ldr	r0, [r0, #12]
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1442a:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   1442c:	f3c3 0381 	ubfx	r3, r3, #2, #2
	if (TC_CTRLA_MODE_COUNT32_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   14430:	2b02      	cmp	r3, #2
   14432:	d103      	bne.n	1443c <_tc_timer_set_period+0x14>
	((Tc *)hw)->COUNT32.CC[index].reg = data;
   14434:	61c1      	str	r1, [r0, #28]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
   14436:	21c0      	movs	r1, #192	; 0xc0
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   14438:	4b09      	ldr	r3, [pc, #36]	; (14460 <_tc_timer_set_period+0x38>)
   1443a:	4718      	bx	r3
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1443c:	6803      	ldr	r3, [r0, #0]
	} else if (TC_CTRLA_MODE_COUNT16_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   1443e:	f013 0f0c 	tst.w	r3, #12
   14442:	d102      	bne.n	1444a <_tc_timer_set_period+0x22>
		hri_tccount16_write_CC_reg(hw, 0, (uint16_t)clock_cycles);
   14444:	b289      	uxth	r1, r1
	((Tc *)hw)->COUNT16.CC[index].reg = data;
   14446:	8381      	strh	r1, [r0, #28]
   14448:	e7f5      	b.n	14436 <_tc_timer_set_period+0xe>
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
   1444a:	6803      	ldr	r3, [r0, #0]
	tmp = (tmp & TC_CTRLA_MODE_Msk) >> TC_CTRLA_MODE_Pos;
   1444c:	f3c3 0381 	ubfx	r3, r3, #2, #2
	} else if (TC_CTRLA_MODE_COUNT8_Val == hri_tc_read_CTRLA_MODE_bf(hw)) {
   14450:	2b01      	cmp	r3, #1
   14452:	d103      	bne.n	1445c <_tc_timer_set_period+0x34>
		hri_tccount8_write_PER_reg(hw, clock_cycles);
   14454:	b2c9      	uxtb	r1, r1
	((Tc *)hw)->COUNT8.PER.reg = data;
   14456:	76c1      	strb	r1, [r0, #27]
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
   14458:	2120      	movs	r1, #32
   1445a:	e7ed      	b.n	14438 <_tc_timer_set_period+0x10>
}
   1445c:	4770      	bx	lr
   1445e:	bf00      	nop
   14460:	000140e9 	.word	0x000140e9

00014464 <_tc_get_timer>:
}
   14464:	4800      	ldr	r0, [pc, #0]	; (14468 <_tc_get_timer+0x4>)
   14466:	4770      	bx	lr
   14468:	2000052c 	.word	0x2000052c

0001446c <TC0_Handler>:
	tc_interrupt_handler(_tc0_dev);
   1446c:	4b01      	ldr	r3, [pc, #4]	; (14474 <TC0_Handler+0x8>)
   1446e:	6818      	ldr	r0, [r3, #0]
   14470:	4b01      	ldr	r3, [pc, #4]	; (14478 <TC0_Handler+0xc>)
   14472:	4718      	bx	r3
   14474:	20009128 	.word	0x20009128
   14478:	00014169 	.word	0x00014169

0001447c <TC1_Handler>:
	tc_interrupt_handler(_tc1_dev);
   1447c:	4b01      	ldr	r3, [pc, #4]	; (14484 <TC1_Handler+0x8>)
   1447e:	6858      	ldr	r0, [r3, #4]
   14480:	4b01      	ldr	r3, [pc, #4]	; (14488 <TC1_Handler+0xc>)
   14482:	4718      	bx	r3
   14484:	20009128 	.word	0x20009128
   14488:	00014169 	.word	0x00014169

0001448c <TC2_Handler>:
	tc_interrupt_handler(_tc2_dev);
   1448c:	4b01      	ldr	r3, [pc, #4]	; (14494 <TC2_Handler+0x8>)
   1448e:	6898      	ldr	r0, [r3, #8]
   14490:	4b01      	ldr	r3, [pc, #4]	; (14498 <TC2_Handler+0xc>)
   14492:	4718      	bx	r3
   14494:	20009128 	.word	0x20009128
   14498:	00014169 	.word	0x00014169

0001449c <TC3_Handler>:
	tc_interrupt_handler(_tc3_dev);
   1449c:	4b01      	ldr	r3, [pc, #4]	; (144a4 <TC3_Handler+0x8>)
   1449e:	68d8      	ldr	r0, [r3, #12]
   144a0:	4b01      	ldr	r3, [pc, #4]	; (144a8 <TC3_Handler+0xc>)
   144a2:	4718      	bx	r3
   144a4:	20009128 	.word	0x20009128
   144a8:	00014169 	.word	0x00014169

000144ac <_delay_init>:
   144ac:	4b03      	ldr	r3, [pc, #12]	; (144bc <_delay_init+0x10>)
   144ae:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   144b2:	605a      	str	r2, [r3, #4]
   144b4:	2205      	movs	r2, #5
   144b6:	601a      	str	r2, [r3, #0]
   144b8:	4770      	bx	lr
   144ba:	bf00      	nop
   144bc:	e000e010 	.word	0xe000e010

000144c0 <_delay_cycles>:
 * \brief Delay loop to delay n number of cycles
 */
void _delay_cycles(void *const hw, uint32_t cycles)
{
	(void)hw;
	uint8_t  n   = cycles >> 24;
   144c0:	0e0b      	lsrs	r3, r1, #24
   144c2:	4a0c      	ldr	r2, [pc, #48]	; (144f4 <_delay_cycles+0x34>)
{
   144c4:	b530      	push	{r4, r5, lr}
	uint8_t  n   = cycles >> 24;
   144c6:	4618      	mov	r0, r3
	uint32_t buf = cycles;

	while (n--) {
		SysTick->LOAD = 0xFFFFFF;
   144c8:	f06f 447f 	mvn.w	r4, #4278190080	; 0xff000000
	while (n--) {
   144cc:	3801      	subs	r0, #1
   144ce:	b2c0      	uxtb	r0, r0
   144d0:	28ff      	cmp	r0, #255	; 0xff
   144d2:	d108      	bne.n	144e6 <_delay_cycles+0x26>
   144d4:	eba3 6303 	sub.w	r3, r3, r3, lsl #24
   144d8:	4419      	add	r1, r3
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
			;
		buf -= 0xFFFFFF;
	}

	SysTick->LOAD = buf;
   144da:	6051      	str	r1, [r2, #4]
	SysTick->VAL  = buf;
   144dc:	6091      	str	r1, [r2, #8]
	while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   144de:	6813      	ldr	r3, [r2, #0]
   144e0:	03db      	lsls	r3, r3, #15
   144e2:	d5fc      	bpl.n	144de <_delay_cycles+0x1e>
		;
}
   144e4:	bd30      	pop	{r4, r5, pc}
		SysTick->LOAD = 0xFFFFFF;
   144e6:	6054      	str	r4, [r2, #4]
		SysTick->VAL  = 0xFFFFFF;
   144e8:	6094      	str	r4, [r2, #8]
		while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk))
   144ea:	6815      	ldr	r5, [r2, #0]
   144ec:	03ed      	lsls	r5, r5, #15
   144ee:	d5fc      	bpl.n	144ea <_delay_cycles+0x2a>
   144f0:	e7ec      	b.n	144cc <_delay_cycles+0xc>
   144f2:	bf00      	nop
   144f4:	e000e010 	.word	0xe000e010

000144f8 <_crc_sync_init>:
/**
 * \brief Initialize CRC.
 */
int32_t _crc_sync_init(struct _crc_sync_device *const device, void *const hw)
{
	device->hw = hw;
   144f8:	6001      	str	r1, [r0, #0]

	return ERR_NONE;
}
   144fa:	2000      	movs	r0, #0
   144fc:	4770      	bx	lr
	...

00014500 <__aeabi_drsub>:
   14500:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
   14504:	e002      	b.n	1450c <__adddf3>
   14506:	bf00      	nop

00014508 <__aeabi_dsub>:
   14508:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

0001450c <__adddf3>:
   1450c:	b530      	push	{r4, r5, lr}
   1450e:	ea4f 0441 	mov.w	r4, r1, lsl #1
   14512:	ea4f 0543 	mov.w	r5, r3, lsl #1
   14516:	ea94 0f05 	teq	r4, r5
   1451a:	bf08      	it	eq
   1451c:	ea90 0f02 	teqeq	r0, r2
   14520:	bf1f      	itttt	ne
   14522:	ea54 0c00 	orrsne.w	ip, r4, r0
   14526:	ea55 0c02 	orrsne.w	ip, r5, r2
   1452a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
   1452e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   14532:	f000 80e2 	beq.w	146fa <__adddf3+0x1ee>
   14536:	ea4f 5454 	mov.w	r4, r4, lsr #21
   1453a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
   1453e:	bfb8      	it	lt
   14540:	426d      	neglt	r5, r5
   14542:	dd0c      	ble.n	1455e <__adddf3+0x52>
   14544:	442c      	add	r4, r5
   14546:	ea80 0202 	eor.w	r2, r0, r2
   1454a:	ea81 0303 	eor.w	r3, r1, r3
   1454e:	ea82 0000 	eor.w	r0, r2, r0
   14552:	ea83 0101 	eor.w	r1, r3, r1
   14556:	ea80 0202 	eor.w	r2, r0, r2
   1455a:	ea81 0303 	eor.w	r3, r1, r3
   1455e:	2d36      	cmp	r5, #54	; 0x36
   14560:	bf88      	it	hi
   14562:	bd30      	pophi	{r4, r5, pc}
   14564:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   14568:	ea4f 3101 	mov.w	r1, r1, lsl #12
   1456c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
   14570:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
   14574:	d002      	beq.n	1457c <__adddf3+0x70>
   14576:	4240      	negs	r0, r0
   14578:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   1457c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
   14580:	ea4f 3303 	mov.w	r3, r3, lsl #12
   14584:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
   14588:	d002      	beq.n	14590 <__adddf3+0x84>
   1458a:	4252      	negs	r2, r2
   1458c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
   14590:	ea94 0f05 	teq	r4, r5
   14594:	f000 80a7 	beq.w	146e6 <__adddf3+0x1da>
   14598:	f1a4 0401 	sub.w	r4, r4, #1
   1459c:	f1d5 0e20 	rsbs	lr, r5, #32
   145a0:	db0d      	blt.n	145be <__adddf3+0xb2>
   145a2:	fa02 fc0e 	lsl.w	ip, r2, lr
   145a6:	fa22 f205 	lsr.w	r2, r2, r5
   145aa:	1880      	adds	r0, r0, r2
   145ac:	f141 0100 	adc.w	r1, r1, #0
   145b0:	fa03 f20e 	lsl.w	r2, r3, lr
   145b4:	1880      	adds	r0, r0, r2
   145b6:	fa43 f305 	asr.w	r3, r3, r5
   145ba:	4159      	adcs	r1, r3
   145bc:	e00e      	b.n	145dc <__adddf3+0xd0>
   145be:	f1a5 0520 	sub.w	r5, r5, #32
   145c2:	f10e 0e20 	add.w	lr, lr, #32
   145c6:	2a01      	cmp	r2, #1
   145c8:	fa03 fc0e 	lsl.w	ip, r3, lr
   145cc:	bf28      	it	cs
   145ce:	f04c 0c02 	orrcs.w	ip, ip, #2
   145d2:	fa43 f305 	asr.w	r3, r3, r5
   145d6:	18c0      	adds	r0, r0, r3
   145d8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
   145dc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   145e0:	d507      	bpl.n	145f2 <__adddf3+0xe6>
   145e2:	f04f 0e00 	mov.w	lr, #0
   145e6:	f1dc 0c00 	rsbs	ip, ip, #0
   145ea:	eb7e 0000 	sbcs.w	r0, lr, r0
   145ee:	eb6e 0101 	sbc.w	r1, lr, r1
   145f2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
   145f6:	d31b      	bcc.n	14630 <__adddf3+0x124>
   145f8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
   145fc:	d30c      	bcc.n	14618 <__adddf3+0x10c>
   145fe:	0849      	lsrs	r1, r1, #1
   14600:	ea5f 0030 	movs.w	r0, r0, rrx
   14604:	ea4f 0c3c 	mov.w	ip, ip, rrx
   14608:	f104 0401 	add.w	r4, r4, #1
   1460c:	ea4f 5244 	mov.w	r2, r4, lsl #21
   14610:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
   14614:	f080 809a 	bcs.w	1474c <__adddf3+0x240>
   14618:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   1461c:	bf08      	it	eq
   1461e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   14622:	f150 0000 	adcs.w	r0, r0, #0
   14626:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1462a:	ea41 0105 	orr.w	r1, r1, r5
   1462e:	bd30      	pop	{r4, r5, pc}
   14630:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
   14634:	4140      	adcs	r0, r0
   14636:	eb41 0101 	adc.w	r1, r1, r1
   1463a:	3c01      	subs	r4, #1
   1463c:	bf28      	it	cs
   1463e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
   14642:	d2e9      	bcs.n	14618 <__adddf3+0x10c>
   14644:	f091 0f00 	teq	r1, #0
   14648:	bf04      	itt	eq
   1464a:	4601      	moveq	r1, r0
   1464c:	2000      	moveq	r0, #0
   1464e:	fab1 f381 	clz	r3, r1
   14652:	bf08      	it	eq
   14654:	3320      	addeq	r3, #32
   14656:	f1a3 030b 	sub.w	r3, r3, #11
   1465a:	f1b3 0220 	subs.w	r2, r3, #32
   1465e:	da0c      	bge.n	1467a <__adddf3+0x16e>
   14660:	320c      	adds	r2, #12
   14662:	dd08      	ble.n	14676 <__adddf3+0x16a>
   14664:	f102 0c14 	add.w	ip, r2, #20
   14668:	f1c2 020c 	rsb	r2, r2, #12
   1466c:	fa01 f00c 	lsl.w	r0, r1, ip
   14670:	fa21 f102 	lsr.w	r1, r1, r2
   14674:	e00c      	b.n	14690 <__adddf3+0x184>
   14676:	f102 0214 	add.w	r2, r2, #20
   1467a:	bfd8      	it	le
   1467c:	f1c2 0c20 	rsble	ip, r2, #32
   14680:	fa01 f102 	lsl.w	r1, r1, r2
   14684:	fa20 fc0c 	lsr.w	ip, r0, ip
   14688:	bfdc      	itt	le
   1468a:	ea41 010c 	orrle.w	r1, r1, ip
   1468e:	4090      	lslle	r0, r2
   14690:	1ae4      	subs	r4, r4, r3
   14692:	bfa2      	ittt	ge
   14694:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
   14698:	4329      	orrge	r1, r5
   1469a:	bd30      	popge	{r4, r5, pc}
   1469c:	ea6f 0404 	mvn.w	r4, r4
   146a0:	3c1f      	subs	r4, #31
   146a2:	da1c      	bge.n	146de <__adddf3+0x1d2>
   146a4:	340c      	adds	r4, #12
   146a6:	dc0e      	bgt.n	146c6 <__adddf3+0x1ba>
   146a8:	f104 0414 	add.w	r4, r4, #20
   146ac:	f1c4 0220 	rsb	r2, r4, #32
   146b0:	fa20 f004 	lsr.w	r0, r0, r4
   146b4:	fa01 f302 	lsl.w	r3, r1, r2
   146b8:	ea40 0003 	orr.w	r0, r0, r3
   146bc:	fa21 f304 	lsr.w	r3, r1, r4
   146c0:	ea45 0103 	orr.w	r1, r5, r3
   146c4:	bd30      	pop	{r4, r5, pc}
   146c6:	f1c4 040c 	rsb	r4, r4, #12
   146ca:	f1c4 0220 	rsb	r2, r4, #32
   146ce:	fa20 f002 	lsr.w	r0, r0, r2
   146d2:	fa01 f304 	lsl.w	r3, r1, r4
   146d6:	ea40 0003 	orr.w	r0, r0, r3
   146da:	4629      	mov	r1, r5
   146dc:	bd30      	pop	{r4, r5, pc}
   146de:	fa21 f004 	lsr.w	r0, r1, r4
   146e2:	4629      	mov	r1, r5
   146e4:	bd30      	pop	{r4, r5, pc}
   146e6:	f094 0f00 	teq	r4, #0
   146ea:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
   146ee:	bf06      	itte	eq
   146f0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
   146f4:	3401      	addeq	r4, #1
   146f6:	3d01      	subne	r5, #1
   146f8:	e74e      	b.n	14598 <__adddf3+0x8c>
   146fa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   146fe:	bf18      	it	ne
   14700:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
   14704:	d029      	beq.n	1475a <__adddf3+0x24e>
   14706:	ea94 0f05 	teq	r4, r5
   1470a:	bf08      	it	eq
   1470c:	ea90 0f02 	teqeq	r0, r2
   14710:	d005      	beq.n	1471e <__adddf3+0x212>
   14712:	ea54 0c00 	orrs.w	ip, r4, r0
   14716:	bf04      	itt	eq
   14718:	4619      	moveq	r1, r3
   1471a:	4610      	moveq	r0, r2
   1471c:	bd30      	pop	{r4, r5, pc}
   1471e:	ea91 0f03 	teq	r1, r3
   14722:	bf1e      	ittt	ne
   14724:	2100      	movne	r1, #0
   14726:	2000      	movne	r0, #0
   14728:	bd30      	popne	{r4, r5, pc}
   1472a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
   1472e:	d105      	bne.n	1473c <__adddf3+0x230>
   14730:	0040      	lsls	r0, r0, #1
   14732:	4149      	adcs	r1, r1
   14734:	bf28      	it	cs
   14736:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
   1473a:	bd30      	pop	{r4, r5, pc}
   1473c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
   14740:	bf3c      	itt	cc
   14742:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
   14746:	bd30      	popcc	{r4, r5, pc}
   14748:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   1474c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
   14750:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14754:	f04f 0000 	mov.w	r0, #0
   14758:	bd30      	pop	{r4, r5, pc}
   1475a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
   1475e:	bf1a      	itte	ne
   14760:	4619      	movne	r1, r3
   14762:	4610      	movne	r0, r2
   14764:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
   14768:	bf1c      	itt	ne
   1476a:	460b      	movne	r3, r1
   1476c:	4602      	movne	r2, r0
   1476e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14772:	bf06      	itte	eq
   14774:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
   14778:	ea91 0f03 	teqeq	r1, r3
   1477c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
   14780:	bd30      	pop	{r4, r5, pc}
   14782:	bf00      	nop

00014784 <__aeabi_ui2d>:
   14784:	f090 0f00 	teq	r0, #0
   14788:	bf04      	itt	eq
   1478a:	2100      	moveq	r1, #0
   1478c:	4770      	bxeq	lr
   1478e:	b530      	push	{r4, r5, lr}
   14790:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14794:	f104 0432 	add.w	r4, r4, #50	; 0x32
   14798:	f04f 0500 	mov.w	r5, #0
   1479c:	f04f 0100 	mov.w	r1, #0
   147a0:	e750      	b.n	14644 <__adddf3+0x138>
   147a2:	bf00      	nop

000147a4 <__aeabi_i2d>:
   147a4:	f090 0f00 	teq	r0, #0
   147a8:	bf04      	itt	eq
   147aa:	2100      	moveq	r1, #0
   147ac:	4770      	bxeq	lr
   147ae:	b530      	push	{r4, r5, lr}
   147b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
   147b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
   147b8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
   147bc:	bf48      	it	mi
   147be:	4240      	negmi	r0, r0
   147c0:	f04f 0100 	mov.w	r1, #0
   147c4:	e73e      	b.n	14644 <__adddf3+0x138>
   147c6:	bf00      	nop

000147c8 <__aeabi_f2d>:
   147c8:	0042      	lsls	r2, r0, #1
   147ca:	ea4f 01e2 	mov.w	r1, r2, asr #3
   147ce:	ea4f 0131 	mov.w	r1, r1, rrx
   147d2:	ea4f 7002 	mov.w	r0, r2, lsl #28
   147d6:	bf1f      	itttt	ne
   147d8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
   147dc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
   147e0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
   147e4:	4770      	bxne	lr
   147e6:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
   147ea:	bf08      	it	eq
   147ec:	4770      	bxeq	lr
   147ee:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
   147f2:	bf04      	itt	eq
   147f4:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
   147f8:	4770      	bxeq	lr
   147fa:	b530      	push	{r4, r5, lr}
   147fc:	f44f 7460 	mov.w	r4, #896	; 0x380
   14800:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
   14804:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   14808:	e71c      	b.n	14644 <__adddf3+0x138>
   1480a:	bf00      	nop

0001480c <__aeabi_ul2d>:
   1480c:	ea50 0201 	orrs.w	r2, r0, r1
   14810:	bf08      	it	eq
   14812:	4770      	bxeq	lr
   14814:	b530      	push	{r4, r5, lr}
   14816:	f04f 0500 	mov.w	r5, #0
   1481a:	e00a      	b.n	14832 <__aeabi_l2d+0x16>

0001481c <__aeabi_l2d>:
   1481c:	ea50 0201 	orrs.w	r2, r0, r1
   14820:	bf08      	it	eq
   14822:	4770      	bxeq	lr
   14824:	b530      	push	{r4, r5, lr}
   14826:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
   1482a:	d502      	bpl.n	14832 <__aeabi_l2d+0x16>
   1482c:	4240      	negs	r0, r0
   1482e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   14832:	f44f 6480 	mov.w	r4, #1024	; 0x400
   14836:	f104 0432 	add.w	r4, r4, #50	; 0x32
   1483a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
   1483e:	f43f aed8 	beq.w	145f2 <__adddf3+0xe6>
   14842:	f04f 0203 	mov.w	r2, #3
   14846:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   1484a:	bf18      	it	ne
   1484c:	3203      	addne	r2, #3
   1484e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
   14852:	bf18      	it	ne
   14854:	3203      	addne	r2, #3
   14856:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
   1485a:	f1c2 0320 	rsb	r3, r2, #32
   1485e:	fa00 fc03 	lsl.w	ip, r0, r3
   14862:	fa20 f002 	lsr.w	r0, r0, r2
   14866:	fa01 fe03 	lsl.w	lr, r1, r3
   1486a:	ea40 000e 	orr.w	r0, r0, lr
   1486e:	fa21 f102 	lsr.w	r1, r1, r2
   14872:	4414      	add	r4, r2
   14874:	e6bd      	b.n	145f2 <__adddf3+0xe6>
   14876:	bf00      	nop

00014878 <__aeabi_dmul>:
   14878:	b570      	push	{r4, r5, r6, lr}
   1487a:	f04f 0cff 	mov.w	ip, #255	; 0xff
   1487e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   14882:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   14886:	bf1d      	ittte	ne
   14888:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   1488c:	ea94 0f0c 	teqne	r4, ip
   14890:	ea95 0f0c 	teqne	r5, ip
   14894:	f000 f8de 	bleq	14a54 <__aeabi_dmul+0x1dc>
   14898:	442c      	add	r4, r5
   1489a:	ea81 0603 	eor.w	r6, r1, r3
   1489e:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
   148a2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
   148a6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
   148aa:	bf18      	it	ne
   148ac:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
   148b0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   148b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   148b8:	d038      	beq.n	1492c <__aeabi_dmul+0xb4>
   148ba:	fba0 ce02 	umull	ip, lr, r0, r2
   148be:	f04f 0500 	mov.w	r5, #0
   148c2:	fbe1 e502 	umlal	lr, r5, r1, r2
   148c6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
   148ca:	fbe0 e503 	umlal	lr, r5, r0, r3
   148ce:	f04f 0600 	mov.w	r6, #0
   148d2:	fbe1 5603 	umlal	r5, r6, r1, r3
   148d6:	f09c 0f00 	teq	ip, #0
   148da:	bf18      	it	ne
   148dc:	f04e 0e01 	orrne.w	lr, lr, #1
   148e0:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
   148e4:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
   148e8:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
   148ec:	d204      	bcs.n	148f8 <__aeabi_dmul+0x80>
   148ee:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
   148f2:	416d      	adcs	r5, r5
   148f4:	eb46 0606 	adc.w	r6, r6, r6
   148f8:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
   148fc:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
   14900:	ea4f 20c5 	mov.w	r0, r5, lsl #11
   14904:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
   14908:	ea4f 2ece 	mov.w	lr, lr, lsl #11
   1490c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14910:	bf88      	it	hi
   14912:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14916:	d81e      	bhi.n	14956 <__aeabi_dmul+0xde>
   14918:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
   1491c:	bf08      	it	eq
   1491e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
   14922:	f150 0000 	adcs.w	r0, r0, #0
   14926:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   1492a:	bd70      	pop	{r4, r5, r6, pc}
   1492c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
   14930:	ea46 0101 	orr.w	r1, r6, r1
   14934:	ea40 0002 	orr.w	r0, r0, r2
   14938:	ea81 0103 	eor.w	r1, r1, r3
   1493c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
   14940:	bfc2      	ittt	gt
   14942:	ebd4 050c 	rsbsgt	r5, r4, ip
   14946:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   1494a:	bd70      	popgt	{r4, r5, r6, pc}
   1494c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14950:	f04f 0e00 	mov.w	lr, #0
   14954:	3c01      	subs	r4, #1
   14956:	f300 80ab 	bgt.w	14ab0 <__aeabi_dmul+0x238>
   1495a:	f114 0f36 	cmn.w	r4, #54	; 0x36
   1495e:	bfde      	ittt	le
   14960:	2000      	movle	r0, #0
   14962:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
   14966:	bd70      	pople	{r4, r5, r6, pc}
   14968:	f1c4 0400 	rsb	r4, r4, #0
   1496c:	3c20      	subs	r4, #32
   1496e:	da35      	bge.n	149dc <__aeabi_dmul+0x164>
   14970:	340c      	adds	r4, #12
   14972:	dc1b      	bgt.n	149ac <__aeabi_dmul+0x134>
   14974:	f104 0414 	add.w	r4, r4, #20
   14978:	f1c4 0520 	rsb	r5, r4, #32
   1497c:	fa00 f305 	lsl.w	r3, r0, r5
   14980:	fa20 f004 	lsr.w	r0, r0, r4
   14984:	fa01 f205 	lsl.w	r2, r1, r5
   14988:	ea40 0002 	orr.w	r0, r0, r2
   1498c:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
   14990:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
   14994:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   14998:	fa21 f604 	lsr.w	r6, r1, r4
   1499c:	eb42 0106 	adc.w	r1, r2, r6
   149a0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   149a4:	bf08      	it	eq
   149a6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   149aa:	bd70      	pop	{r4, r5, r6, pc}
   149ac:	f1c4 040c 	rsb	r4, r4, #12
   149b0:	f1c4 0520 	rsb	r5, r4, #32
   149b4:	fa00 f304 	lsl.w	r3, r0, r4
   149b8:	fa20 f005 	lsr.w	r0, r0, r5
   149bc:	fa01 f204 	lsl.w	r2, r1, r4
   149c0:	ea40 0002 	orr.w	r0, r0, r2
   149c4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   149c8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
   149cc:	f141 0100 	adc.w	r1, r1, #0
   149d0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   149d4:	bf08      	it	eq
   149d6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   149da:	bd70      	pop	{r4, r5, r6, pc}
   149dc:	f1c4 0520 	rsb	r5, r4, #32
   149e0:	fa00 f205 	lsl.w	r2, r0, r5
   149e4:	ea4e 0e02 	orr.w	lr, lr, r2
   149e8:	fa20 f304 	lsr.w	r3, r0, r4
   149ec:	fa01 f205 	lsl.w	r2, r1, r5
   149f0:	ea43 0302 	orr.w	r3, r3, r2
   149f4:	fa21 f004 	lsr.w	r0, r1, r4
   149f8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   149fc:	fa21 f204 	lsr.w	r2, r1, r4
   14a00:	ea20 0002 	bic.w	r0, r0, r2
   14a04:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
   14a08:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
   14a0c:	bf08      	it	eq
   14a0e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
   14a12:	bd70      	pop	{r4, r5, r6, pc}
   14a14:	f094 0f00 	teq	r4, #0
   14a18:	d10f      	bne.n	14a3a <__aeabi_dmul+0x1c2>
   14a1a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
   14a1e:	0040      	lsls	r0, r0, #1
   14a20:	eb41 0101 	adc.w	r1, r1, r1
   14a24:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14a28:	bf08      	it	eq
   14a2a:	3c01      	subeq	r4, #1
   14a2c:	d0f7      	beq.n	14a1e <__aeabi_dmul+0x1a6>
   14a2e:	ea41 0106 	orr.w	r1, r1, r6
   14a32:	f095 0f00 	teq	r5, #0
   14a36:	bf18      	it	ne
   14a38:	4770      	bxne	lr
   14a3a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
   14a3e:	0052      	lsls	r2, r2, #1
   14a40:	eb43 0303 	adc.w	r3, r3, r3
   14a44:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
   14a48:	bf08      	it	eq
   14a4a:	3d01      	subeq	r5, #1
   14a4c:	d0f7      	beq.n	14a3e <__aeabi_dmul+0x1c6>
   14a4e:	ea43 0306 	orr.w	r3, r3, r6
   14a52:	4770      	bx	lr
   14a54:	ea94 0f0c 	teq	r4, ip
   14a58:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   14a5c:	bf18      	it	ne
   14a5e:	ea95 0f0c 	teqne	r5, ip
   14a62:	d00c      	beq.n	14a7e <__aeabi_dmul+0x206>
   14a64:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14a68:	bf18      	it	ne
   14a6a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14a6e:	d1d1      	bne.n	14a14 <__aeabi_dmul+0x19c>
   14a70:	ea81 0103 	eor.w	r1, r1, r3
   14a74:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14a78:	f04f 0000 	mov.w	r0, #0
   14a7c:	bd70      	pop	{r4, r5, r6, pc}
   14a7e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14a82:	bf06      	itte	eq
   14a84:	4610      	moveq	r0, r2
   14a86:	4619      	moveq	r1, r3
   14a88:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14a8c:	d019      	beq.n	14ac2 <__aeabi_dmul+0x24a>
   14a8e:	ea94 0f0c 	teq	r4, ip
   14a92:	d102      	bne.n	14a9a <__aeabi_dmul+0x222>
   14a94:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
   14a98:	d113      	bne.n	14ac2 <__aeabi_dmul+0x24a>
   14a9a:	ea95 0f0c 	teq	r5, ip
   14a9e:	d105      	bne.n	14aac <__aeabi_dmul+0x234>
   14aa0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
   14aa4:	bf1c      	itt	ne
   14aa6:	4610      	movne	r0, r2
   14aa8:	4619      	movne	r1, r3
   14aaa:	d10a      	bne.n	14ac2 <__aeabi_dmul+0x24a>
   14aac:	ea81 0103 	eor.w	r1, r1, r3
   14ab0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
   14ab4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14ab8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
   14abc:	f04f 0000 	mov.w	r0, #0
   14ac0:	bd70      	pop	{r4, r5, r6, pc}
   14ac2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
   14ac6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
   14aca:	bd70      	pop	{r4, r5, r6, pc}

00014acc <__aeabi_ddiv>:
   14acc:	b570      	push	{r4, r5, r6, lr}
   14ace:	f04f 0cff 	mov.w	ip, #255	; 0xff
   14ad2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
   14ad6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
   14ada:	bf1d      	ittte	ne
   14adc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
   14ae0:	ea94 0f0c 	teqne	r4, ip
   14ae4:	ea95 0f0c 	teqne	r5, ip
   14ae8:	f000 f8a7 	bleq	14c3a <__aeabi_ddiv+0x16e>
   14aec:	eba4 0405 	sub.w	r4, r4, r5
   14af0:	ea81 0e03 	eor.w	lr, r1, r3
   14af4:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14af8:	ea4f 3101 	mov.w	r1, r1, lsl #12
   14afc:	f000 8088 	beq.w	14c10 <__aeabi_ddiv+0x144>
   14b00:	ea4f 3303 	mov.w	r3, r3, lsl #12
   14b04:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
   14b08:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
   14b0c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
   14b10:	ea4f 2202 	mov.w	r2, r2, lsl #8
   14b14:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
   14b18:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
   14b1c:	ea4f 2600 	mov.w	r6, r0, lsl #8
   14b20:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
   14b24:	429d      	cmp	r5, r3
   14b26:	bf08      	it	eq
   14b28:	4296      	cmpeq	r6, r2
   14b2a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
   14b2e:	f504 7440 	add.w	r4, r4, #768	; 0x300
   14b32:	d202      	bcs.n	14b3a <__aeabi_ddiv+0x6e>
   14b34:	085b      	lsrs	r3, r3, #1
   14b36:	ea4f 0232 	mov.w	r2, r2, rrx
   14b3a:	1ab6      	subs	r6, r6, r2
   14b3c:	eb65 0503 	sbc.w	r5, r5, r3
   14b40:	085b      	lsrs	r3, r3, #1
   14b42:	ea4f 0232 	mov.w	r2, r2, rrx
   14b46:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
   14b4a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
   14b4e:	ebb6 0e02 	subs.w	lr, r6, r2
   14b52:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b56:	bf22      	ittt	cs
   14b58:	1ab6      	subcs	r6, r6, r2
   14b5a:	4675      	movcs	r5, lr
   14b5c:	ea40 000c 	orrcs.w	r0, r0, ip
   14b60:	085b      	lsrs	r3, r3, #1
   14b62:	ea4f 0232 	mov.w	r2, r2, rrx
   14b66:	ebb6 0e02 	subs.w	lr, r6, r2
   14b6a:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b6e:	bf22      	ittt	cs
   14b70:	1ab6      	subcs	r6, r6, r2
   14b72:	4675      	movcs	r5, lr
   14b74:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   14b78:	085b      	lsrs	r3, r3, #1
   14b7a:	ea4f 0232 	mov.w	r2, r2, rrx
   14b7e:	ebb6 0e02 	subs.w	lr, r6, r2
   14b82:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b86:	bf22      	ittt	cs
   14b88:	1ab6      	subcs	r6, r6, r2
   14b8a:	4675      	movcs	r5, lr
   14b8c:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   14b90:	085b      	lsrs	r3, r3, #1
   14b92:	ea4f 0232 	mov.w	r2, r2, rrx
   14b96:	ebb6 0e02 	subs.w	lr, r6, r2
   14b9a:	eb75 0e03 	sbcs.w	lr, r5, r3
   14b9e:	bf22      	ittt	cs
   14ba0:	1ab6      	subcs	r6, r6, r2
   14ba2:	4675      	movcs	r5, lr
   14ba4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   14ba8:	ea55 0e06 	orrs.w	lr, r5, r6
   14bac:	d018      	beq.n	14be0 <__aeabi_ddiv+0x114>
   14bae:	ea4f 1505 	mov.w	r5, r5, lsl #4
   14bb2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
   14bb6:	ea4f 1606 	mov.w	r6, r6, lsl #4
   14bba:	ea4f 03c3 	mov.w	r3, r3, lsl #3
   14bbe:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
   14bc2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
   14bc6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
   14bca:	d1c0      	bne.n	14b4e <__aeabi_ddiv+0x82>
   14bcc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14bd0:	d10b      	bne.n	14bea <__aeabi_ddiv+0x11e>
   14bd2:	ea41 0100 	orr.w	r1, r1, r0
   14bd6:	f04f 0000 	mov.w	r0, #0
   14bda:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
   14bde:	e7b6      	b.n	14b4e <__aeabi_ddiv+0x82>
   14be0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
   14be4:	bf04      	itt	eq
   14be6:	4301      	orreq	r1, r0
   14be8:	2000      	moveq	r0, #0
   14bea:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
   14bee:	bf88      	it	hi
   14bf0:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
   14bf4:	f63f aeaf 	bhi.w	14956 <__aeabi_dmul+0xde>
   14bf8:	ebb5 0c03 	subs.w	ip, r5, r3
   14bfc:	bf04      	itt	eq
   14bfe:	ebb6 0c02 	subseq.w	ip, r6, r2
   14c02:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
   14c06:	f150 0000 	adcs.w	r0, r0, #0
   14c0a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
   14c0e:	bd70      	pop	{r4, r5, r6, pc}
   14c10:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
   14c14:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
   14c18:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
   14c1c:	bfc2      	ittt	gt
   14c1e:	ebd4 050c 	rsbsgt	r5, r4, ip
   14c22:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
   14c26:	bd70      	popgt	{r4, r5, r6, pc}
   14c28:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
   14c2c:	f04f 0e00 	mov.w	lr, #0
   14c30:	3c01      	subs	r4, #1
   14c32:	e690      	b.n	14956 <__aeabi_dmul+0xde>
   14c34:	ea45 0e06 	orr.w	lr, r5, r6
   14c38:	e68d      	b.n	14956 <__aeabi_dmul+0xde>
   14c3a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
   14c3e:	ea94 0f0c 	teq	r4, ip
   14c42:	bf08      	it	eq
   14c44:	ea95 0f0c 	teqeq	r5, ip
   14c48:	f43f af3b 	beq.w	14ac2 <__aeabi_dmul+0x24a>
   14c4c:	ea94 0f0c 	teq	r4, ip
   14c50:	d10a      	bne.n	14c68 <__aeabi_ddiv+0x19c>
   14c52:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
   14c56:	f47f af34 	bne.w	14ac2 <__aeabi_dmul+0x24a>
   14c5a:	ea95 0f0c 	teq	r5, ip
   14c5e:	f47f af25 	bne.w	14aac <__aeabi_dmul+0x234>
   14c62:	4610      	mov	r0, r2
   14c64:	4619      	mov	r1, r3
   14c66:	e72c      	b.n	14ac2 <__aeabi_dmul+0x24a>
   14c68:	ea95 0f0c 	teq	r5, ip
   14c6c:	d106      	bne.n	14c7c <__aeabi_ddiv+0x1b0>
   14c6e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
   14c72:	f43f aefd 	beq.w	14a70 <__aeabi_dmul+0x1f8>
   14c76:	4610      	mov	r0, r2
   14c78:	4619      	mov	r1, r3
   14c7a:	e722      	b.n	14ac2 <__aeabi_dmul+0x24a>
   14c7c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
   14c80:	bf18      	it	ne
   14c82:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
   14c86:	f47f aec5 	bne.w	14a14 <__aeabi_dmul+0x19c>
   14c8a:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
   14c8e:	f47f af0d 	bne.w	14aac <__aeabi_dmul+0x234>
   14c92:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
   14c96:	f47f aeeb 	bne.w	14a70 <__aeabi_dmul+0x1f8>
   14c9a:	e712      	b.n	14ac2 <__aeabi_dmul+0x24a>

00014c9c <__aeabi_d2uiz>:
   14c9c:	004a      	lsls	r2, r1, #1
   14c9e:	d211      	bcs.n	14cc4 <__aeabi_d2uiz+0x28>
   14ca0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
   14ca4:	d211      	bcs.n	14cca <__aeabi_d2uiz+0x2e>
   14ca6:	d50d      	bpl.n	14cc4 <__aeabi_d2uiz+0x28>
   14ca8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
   14cac:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
   14cb0:	d40e      	bmi.n	14cd0 <__aeabi_d2uiz+0x34>
   14cb2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
   14cb6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   14cba:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
   14cbe:	fa23 f002 	lsr.w	r0, r3, r2
   14cc2:	4770      	bx	lr
   14cc4:	f04f 0000 	mov.w	r0, #0
   14cc8:	4770      	bx	lr
   14cca:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
   14cce:	d102      	bne.n	14cd6 <__aeabi_d2uiz+0x3a>
   14cd0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   14cd4:	4770      	bx	lr
   14cd6:	f04f 0000 	mov.w	r0, #0
   14cda:	4770      	bx	lr

00014cdc <__libc_init_array>:
   14cdc:	b570      	push	{r4, r5, r6, lr}
   14cde:	4d0d      	ldr	r5, [pc, #52]	; (14d14 <__libc_init_array+0x38>)
   14ce0:	4c0d      	ldr	r4, [pc, #52]	; (14d18 <__libc_init_array+0x3c>)
   14ce2:	1b64      	subs	r4, r4, r5
   14ce4:	10a4      	asrs	r4, r4, #2
   14ce6:	2600      	movs	r6, #0
   14ce8:	42a6      	cmp	r6, r4
   14cea:	d109      	bne.n	14d00 <__libc_init_array+0x24>
   14cec:	4d0b      	ldr	r5, [pc, #44]	; (14d1c <__libc_init_array+0x40>)
   14cee:	4c0c      	ldr	r4, [pc, #48]	; (14d20 <__libc_init_array+0x44>)
   14cf0:	f002 fd20 	bl	17734 <_init>
   14cf4:	1b64      	subs	r4, r4, r5
   14cf6:	10a4      	asrs	r4, r4, #2
   14cf8:	2600      	movs	r6, #0
   14cfa:	42a6      	cmp	r6, r4
   14cfc:	d105      	bne.n	14d0a <__libc_init_array+0x2e>
   14cfe:	bd70      	pop	{r4, r5, r6, pc}
   14d00:	f855 3b04 	ldr.w	r3, [r5], #4
   14d04:	4798      	blx	r3
   14d06:	3601      	adds	r6, #1
   14d08:	e7ee      	b.n	14ce8 <__libc_init_array+0xc>
   14d0a:	f855 3b04 	ldr.w	r3, [r5], #4
   14d0e:	4798      	blx	r3
   14d10:	3601      	adds	r6, #1
   14d12:	e7f2      	b.n	14cfa <__libc_init_array+0x1e>
   14d14:	00017740 	.word	0x00017740
   14d18:	00017740 	.word	0x00017740
   14d1c:	00017740 	.word	0x00017740
   14d20:	00017744 	.word	0x00017744

00014d24 <malloc>:
   14d24:	4b02      	ldr	r3, [pc, #8]	; (14d30 <malloc+0xc>)
   14d26:	4601      	mov	r1, r0
   14d28:	6818      	ldr	r0, [r3, #0]
   14d2a:	f000 b867 	b.w	14dfc <_malloc_r>
   14d2e:	bf00      	nop
   14d30:	2000054c 	.word	0x2000054c

00014d34 <memcpy>:
   14d34:	440a      	add	r2, r1
   14d36:	4291      	cmp	r1, r2
   14d38:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
   14d3c:	d100      	bne.n	14d40 <memcpy+0xc>
   14d3e:	4770      	bx	lr
   14d40:	b510      	push	{r4, lr}
   14d42:	f811 4b01 	ldrb.w	r4, [r1], #1
   14d46:	f803 4f01 	strb.w	r4, [r3, #1]!
   14d4a:	4291      	cmp	r1, r2
   14d4c:	d1f9      	bne.n	14d42 <memcpy+0xe>
   14d4e:	bd10      	pop	{r4, pc}

00014d50 <memset>:
   14d50:	4402      	add	r2, r0
   14d52:	4603      	mov	r3, r0
   14d54:	4293      	cmp	r3, r2
   14d56:	d100      	bne.n	14d5a <memset+0xa>
   14d58:	4770      	bx	lr
   14d5a:	f803 1b01 	strb.w	r1, [r3], #1
   14d5e:	e7f9      	b.n	14d54 <memset+0x4>

00014d60 <_free_r>:
   14d60:	b538      	push	{r3, r4, r5, lr}
   14d62:	4605      	mov	r5, r0
   14d64:	2900      	cmp	r1, #0
   14d66:	d045      	beq.n	14df4 <_free_r+0x94>
   14d68:	f851 3c04 	ldr.w	r3, [r1, #-4]
   14d6c:	1f0c      	subs	r4, r1, #4
   14d6e:	2b00      	cmp	r3, #0
   14d70:	bfb8      	it	lt
   14d72:	18e4      	addlt	r4, r4, r3
   14d74:	f000 fde6 	bl	15944 <__malloc_lock>
   14d78:	4a1f      	ldr	r2, [pc, #124]	; (14df8 <_free_r+0x98>)
   14d7a:	6813      	ldr	r3, [r2, #0]
   14d7c:	4610      	mov	r0, r2
   14d7e:	b933      	cbnz	r3, 14d8e <_free_r+0x2e>
   14d80:	6063      	str	r3, [r4, #4]
   14d82:	6014      	str	r4, [r2, #0]
   14d84:	4628      	mov	r0, r5
   14d86:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14d8a:	f000 bde1 	b.w	15950 <__malloc_unlock>
   14d8e:	42a3      	cmp	r3, r4
   14d90:	d90b      	bls.n	14daa <_free_r+0x4a>
   14d92:	6821      	ldr	r1, [r4, #0]
   14d94:	1862      	adds	r2, r4, r1
   14d96:	4293      	cmp	r3, r2
   14d98:	bf04      	itt	eq
   14d9a:	681a      	ldreq	r2, [r3, #0]
   14d9c:	685b      	ldreq	r3, [r3, #4]
   14d9e:	6063      	str	r3, [r4, #4]
   14da0:	bf04      	itt	eq
   14da2:	1852      	addeq	r2, r2, r1
   14da4:	6022      	streq	r2, [r4, #0]
   14da6:	6004      	str	r4, [r0, #0]
   14da8:	e7ec      	b.n	14d84 <_free_r+0x24>
   14daa:	461a      	mov	r2, r3
   14dac:	685b      	ldr	r3, [r3, #4]
   14dae:	b10b      	cbz	r3, 14db4 <_free_r+0x54>
   14db0:	42a3      	cmp	r3, r4
   14db2:	d9fa      	bls.n	14daa <_free_r+0x4a>
   14db4:	6811      	ldr	r1, [r2, #0]
   14db6:	1850      	adds	r0, r2, r1
   14db8:	42a0      	cmp	r0, r4
   14dba:	d10b      	bne.n	14dd4 <_free_r+0x74>
   14dbc:	6820      	ldr	r0, [r4, #0]
   14dbe:	4401      	add	r1, r0
   14dc0:	1850      	adds	r0, r2, r1
   14dc2:	4283      	cmp	r3, r0
   14dc4:	6011      	str	r1, [r2, #0]
   14dc6:	d1dd      	bne.n	14d84 <_free_r+0x24>
   14dc8:	6818      	ldr	r0, [r3, #0]
   14dca:	685b      	ldr	r3, [r3, #4]
   14dcc:	6053      	str	r3, [r2, #4]
   14dce:	4401      	add	r1, r0
   14dd0:	6011      	str	r1, [r2, #0]
   14dd2:	e7d7      	b.n	14d84 <_free_r+0x24>
   14dd4:	d902      	bls.n	14ddc <_free_r+0x7c>
   14dd6:	230c      	movs	r3, #12
   14dd8:	602b      	str	r3, [r5, #0]
   14dda:	e7d3      	b.n	14d84 <_free_r+0x24>
   14ddc:	6820      	ldr	r0, [r4, #0]
   14dde:	1821      	adds	r1, r4, r0
   14de0:	428b      	cmp	r3, r1
   14de2:	bf04      	itt	eq
   14de4:	6819      	ldreq	r1, [r3, #0]
   14de6:	685b      	ldreq	r3, [r3, #4]
   14de8:	6063      	str	r3, [r4, #4]
   14dea:	bf04      	itt	eq
   14dec:	1809      	addeq	r1, r1, r0
   14dee:	6021      	streq	r1, [r4, #0]
   14df0:	6054      	str	r4, [r2, #4]
   14df2:	e7c7      	b.n	14d84 <_free_r+0x24>
   14df4:	bd38      	pop	{r3, r4, r5, pc}
   14df6:	bf00      	nop
   14df8:	20009138 	.word	0x20009138

00014dfc <_malloc_r>:
   14dfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   14dfe:	1ccd      	adds	r5, r1, #3
   14e00:	f025 0503 	bic.w	r5, r5, #3
   14e04:	3508      	adds	r5, #8
   14e06:	2d0c      	cmp	r5, #12
   14e08:	bf38      	it	cc
   14e0a:	250c      	movcc	r5, #12
   14e0c:	2d00      	cmp	r5, #0
   14e0e:	4606      	mov	r6, r0
   14e10:	db01      	blt.n	14e16 <_malloc_r+0x1a>
   14e12:	42a9      	cmp	r1, r5
   14e14:	d903      	bls.n	14e1e <_malloc_r+0x22>
   14e16:	230c      	movs	r3, #12
   14e18:	6033      	str	r3, [r6, #0]
   14e1a:	2000      	movs	r0, #0
   14e1c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   14e1e:	f000 fd91 	bl	15944 <__malloc_lock>
   14e22:	4921      	ldr	r1, [pc, #132]	; (14ea8 <_malloc_r+0xac>)
   14e24:	680a      	ldr	r2, [r1, #0]
   14e26:	4614      	mov	r4, r2
   14e28:	b99c      	cbnz	r4, 14e52 <_malloc_r+0x56>
   14e2a:	4f20      	ldr	r7, [pc, #128]	; (14eac <_malloc_r+0xb0>)
   14e2c:	683b      	ldr	r3, [r7, #0]
   14e2e:	b923      	cbnz	r3, 14e3a <_malloc_r+0x3e>
   14e30:	4621      	mov	r1, r4
   14e32:	4630      	mov	r0, r6
   14e34:	f000 f91e 	bl	15074 <_sbrk_r>
   14e38:	6038      	str	r0, [r7, #0]
   14e3a:	4629      	mov	r1, r5
   14e3c:	4630      	mov	r0, r6
   14e3e:	f000 f919 	bl	15074 <_sbrk_r>
   14e42:	1c43      	adds	r3, r0, #1
   14e44:	d123      	bne.n	14e8e <_malloc_r+0x92>
   14e46:	230c      	movs	r3, #12
   14e48:	6033      	str	r3, [r6, #0]
   14e4a:	4630      	mov	r0, r6
   14e4c:	f000 fd80 	bl	15950 <__malloc_unlock>
   14e50:	e7e3      	b.n	14e1a <_malloc_r+0x1e>
   14e52:	6823      	ldr	r3, [r4, #0]
   14e54:	1b5b      	subs	r3, r3, r5
   14e56:	d417      	bmi.n	14e88 <_malloc_r+0x8c>
   14e58:	2b0b      	cmp	r3, #11
   14e5a:	d903      	bls.n	14e64 <_malloc_r+0x68>
   14e5c:	6023      	str	r3, [r4, #0]
   14e5e:	441c      	add	r4, r3
   14e60:	6025      	str	r5, [r4, #0]
   14e62:	e004      	b.n	14e6e <_malloc_r+0x72>
   14e64:	6863      	ldr	r3, [r4, #4]
   14e66:	42a2      	cmp	r2, r4
   14e68:	bf0c      	ite	eq
   14e6a:	600b      	streq	r3, [r1, #0]
   14e6c:	6053      	strne	r3, [r2, #4]
   14e6e:	4630      	mov	r0, r6
   14e70:	f000 fd6e 	bl	15950 <__malloc_unlock>
   14e74:	f104 000b 	add.w	r0, r4, #11
   14e78:	1d23      	adds	r3, r4, #4
   14e7a:	f020 0007 	bic.w	r0, r0, #7
   14e7e:	1ac2      	subs	r2, r0, r3
   14e80:	d0cc      	beq.n	14e1c <_malloc_r+0x20>
   14e82:	1a1b      	subs	r3, r3, r0
   14e84:	50a3      	str	r3, [r4, r2]
   14e86:	e7c9      	b.n	14e1c <_malloc_r+0x20>
   14e88:	4622      	mov	r2, r4
   14e8a:	6864      	ldr	r4, [r4, #4]
   14e8c:	e7cc      	b.n	14e28 <_malloc_r+0x2c>
   14e8e:	1cc4      	adds	r4, r0, #3
   14e90:	f024 0403 	bic.w	r4, r4, #3
   14e94:	42a0      	cmp	r0, r4
   14e96:	d0e3      	beq.n	14e60 <_malloc_r+0x64>
   14e98:	1a21      	subs	r1, r4, r0
   14e9a:	4630      	mov	r0, r6
   14e9c:	f000 f8ea 	bl	15074 <_sbrk_r>
   14ea0:	3001      	adds	r0, #1
   14ea2:	d1dd      	bne.n	14e60 <_malloc_r+0x64>
   14ea4:	e7cf      	b.n	14e46 <_malloc_r+0x4a>
   14ea6:	bf00      	nop
   14ea8:	20009138 	.word	0x20009138
   14eac:	2000913c 	.word	0x2000913c

00014eb0 <iprintf>:
   14eb0:	b40f      	push	{r0, r1, r2, r3}
   14eb2:	4b0a      	ldr	r3, [pc, #40]	; (14edc <iprintf+0x2c>)
   14eb4:	b513      	push	{r0, r1, r4, lr}
   14eb6:	681c      	ldr	r4, [r3, #0]
   14eb8:	b124      	cbz	r4, 14ec4 <iprintf+0x14>
   14eba:	69a3      	ldr	r3, [r4, #24]
   14ebc:	b913      	cbnz	r3, 14ec4 <iprintf+0x14>
   14ebe:	4620      	mov	r0, r4
   14ec0:	f000 fc2a 	bl	15718 <__sinit>
   14ec4:	ab05      	add	r3, sp, #20
   14ec6:	9a04      	ldr	r2, [sp, #16]
   14ec8:	68a1      	ldr	r1, [r4, #8]
   14eca:	9301      	str	r3, [sp, #4]
   14ecc:	4620      	mov	r0, r4
   14ece:	f000 fec9 	bl	15c64 <_vfiprintf_r>
   14ed2:	b002      	add	sp, #8
   14ed4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   14ed8:	b004      	add	sp, #16
   14eda:	4770      	bx	lr
   14edc:	2000054c 	.word	0x2000054c

00014ee0 <putchar>:
   14ee0:	b538      	push	{r3, r4, r5, lr}
   14ee2:	4b08      	ldr	r3, [pc, #32]	; (14f04 <putchar+0x24>)
   14ee4:	681c      	ldr	r4, [r3, #0]
   14ee6:	4605      	mov	r5, r0
   14ee8:	b124      	cbz	r4, 14ef4 <putchar+0x14>
   14eea:	69a3      	ldr	r3, [r4, #24]
   14eec:	b913      	cbnz	r3, 14ef4 <putchar+0x14>
   14eee:	4620      	mov	r0, r4
   14ef0:	f000 fc12 	bl	15718 <__sinit>
   14ef4:	68a2      	ldr	r2, [r4, #8]
   14ef6:	4629      	mov	r1, r5
   14ef8:	4620      	mov	r0, r4
   14efa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   14efe:	f001 b975 	b.w	161ec <_putc_r>
   14f02:	bf00      	nop
   14f04:	2000054c 	.word	0x2000054c

00014f08 <_puts_r>:
   14f08:	b570      	push	{r4, r5, r6, lr}
   14f0a:	460e      	mov	r6, r1
   14f0c:	4605      	mov	r5, r0
   14f0e:	b118      	cbz	r0, 14f18 <_puts_r+0x10>
   14f10:	6983      	ldr	r3, [r0, #24]
   14f12:	b90b      	cbnz	r3, 14f18 <_puts_r+0x10>
   14f14:	f000 fc00 	bl	15718 <__sinit>
   14f18:	69ab      	ldr	r3, [r5, #24]
   14f1a:	68ac      	ldr	r4, [r5, #8]
   14f1c:	b913      	cbnz	r3, 14f24 <_puts_r+0x1c>
   14f1e:	4628      	mov	r0, r5
   14f20:	f000 fbfa 	bl	15718 <__sinit>
   14f24:	4b2c      	ldr	r3, [pc, #176]	; (14fd8 <_puts_r+0xd0>)
   14f26:	429c      	cmp	r4, r3
   14f28:	d120      	bne.n	14f6c <_puts_r+0x64>
   14f2a:	686c      	ldr	r4, [r5, #4]
   14f2c:	6e63      	ldr	r3, [r4, #100]	; 0x64
   14f2e:	07db      	lsls	r3, r3, #31
   14f30:	d405      	bmi.n	14f3e <_puts_r+0x36>
   14f32:	89a3      	ldrh	r3, [r4, #12]
   14f34:	0598      	lsls	r0, r3, #22
   14f36:	d402      	bmi.n	14f3e <_puts_r+0x36>
   14f38:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14f3a:	f000 fc9d 	bl	15878 <__retarget_lock_acquire_recursive>
   14f3e:	89a3      	ldrh	r3, [r4, #12]
   14f40:	0719      	lsls	r1, r3, #28
   14f42:	d51d      	bpl.n	14f80 <_puts_r+0x78>
   14f44:	6923      	ldr	r3, [r4, #16]
   14f46:	b1db      	cbz	r3, 14f80 <_puts_r+0x78>
   14f48:	3e01      	subs	r6, #1
   14f4a:	68a3      	ldr	r3, [r4, #8]
   14f4c:	f816 1f01 	ldrb.w	r1, [r6, #1]!
   14f50:	3b01      	subs	r3, #1
   14f52:	60a3      	str	r3, [r4, #8]
   14f54:	bb39      	cbnz	r1, 14fa6 <_puts_r+0x9e>
   14f56:	2b00      	cmp	r3, #0
   14f58:	da38      	bge.n	14fcc <_puts_r+0xc4>
   14f5a:	4622      	mov	r2, r4
   14f5c:	210a      	movs	r1, #10
   14f5e:	4628      	mov	r0, r5
   14f60:	f000 f9e2 	bl	15328 <__swbuf_r>
   14f64:	3001      	adds	r0, #1
   14f66:	d011      	beq.n	14f8c <_puts_r+0x84>
   14f68:	250a      	movs	r5, #10
   14f6a:	e011      	b.n	14f90 <_puts_r+0x88>
   14f6c:	4b1b      	ldr	r3, [pc, #108]	; (14fdc <_puts_r+0xd4>)
   14f6e:	429c      	cmp	r4, r3
   14f70:	d101      	bne.n	14f76 <_puts_r+0x6e>
   14f72:	68ac      	ldr	r4, [r5, #8]
   14f74:	e7da      	b.n	14f2c <_puts_r+0x24>
   14f76:	4b1a      	ldr	r3, [pc, #104]	; (14fe0 <_puts_r+0xd8>)
   14f78:	429c      	cmp	r4, r3
   14f7a:	bf08      	it	eq
   14f7c:	68ec      	ldreq	r4, [r5, #12]
   14f7e:	e7d5      	b.n	14f2c <_puts_r+0x24>
   14f80:	4621      	mov	r1, r4
   14f82:	4628      	mov	r0, r5
   14f84:	f000 fa22 	bl	153cc <__swsetup_r>
   14f88:	2800      	cmp	r0, #0
   14f8a:	d0dd      	beq.n	14f48 <_puts_r+0x40>
   14f8c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   14f90:	6e63      	ldr	r3, [r4, #100]	; 0x64
   14f92:	07da      	lsls	r2, r3, #31
   14f94:	d405      	bmi.n	14fa2 <_puts_r+0x9a>
   14f96:	89a3      	ldrh	r3, [r4, #12]
   14f98:	059b      	lsls	r3, r3, #22
   14f9a:	d402      	bmi.n	14fa2 <_puts_r+0x9a>
   14f9c:	6da0      	ldr	r0, [r4, #88]	; 0x58
   14f9e:	f000 fc6c 	bl	1587a <__retarget_lock_release_recursive>
   14fa2:	4628      	mov	r0, r5
   14fa4:	bd70      	pop	{r4, r5, r6, pc}
   14fa6:	2b00      	cmp	r3, #0
   14fa8:	da04      	bge.n	14fb4 <_puts_r+0xac>
   14faa:	69a2      	ldr	r2, [r4, #24]
   14fac:	429a      	cmp	r2, r3
   14fae:	dc06      	bgt.n	14fbe <_puts_r+0xb6>
   14fb0:	290a      	cmp	r1, #10
   14fb2:	d004      	beq.n	14fbe <_puts_r+0xb6>
   14fb4:	6823      	ldr	r3, [r4, #0]
   14fb6:	1c5a      	adds	r2, r3, #1
   14fb8:	6022      	str	r2, [r4, #0]
   14fba:	7019      	strb	r1, [r3, #0]
   14fbc:	e7c5      	b.n	14f4a <_puts_r+0x42>
   14fbe:	4622      	mov	r2, r4
   14fc0:	4628      	mov	r0, r5
   14fc2:	f000 f9b1 	bl	15328 <__swbuf_r>
   14fc6:	3001      	adds	r0, #1
   14fc8:	d1bf      	bne.n	14f4a <_puts_r+0x42>
   14fca:	e7df      	b.n	14f8c <_puts_r+0x84>
   14fcc:	6823      	ldr	r3, [r4, #0]
   14fce:	250a      	movs	r5, #10
   14fd0:	1c5a      	adds	r2, r3, #1
   14fd2:	6022      	str	r2, [r4, #0]
   14fd4:	701d      	strb	r5, [r3, #0]
   14fd6:	e7db      	b.n	14f90 <_puts_r+0x88>
   14fd8:	000176c0 	.word	0x000176c0
   14fdc:	000176e0 	.word	0x000176e0
   14fe0:	000176a0 	.word	0x000176a0

00014fe4 <puts>:
   14fe4:	4b02      	ldr	r3, [pc, #8]	; (14ff0 <puts+0xc>)
   14fe6:	4601      	mov	r1, r0
   14fe8:	6818      	ldr	r0, [r3, #0]
   14fea:	f7ff bf8d 	b.w	14f08 <_puts_r>
   14fee:	bf00      	nop
   14ff0:	2000054c 	.word	0x2000054c

00014ff4 <rand>:
   14ff4:	4b17      	ldr	r3, [pc, #92]	; (15054 <rand+0x60>)
   14ff6:	b510      	push	{r4, lr}
   14ff8:	681c      	ldr	r4, [r3, #0]
   14ffa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   14ffc:	b9b3      	cbnz	r3, 1502c <rand+0x38>
   14ffe:	2018      	movs	r0, #24
   15000:	f7ff fe90 	bl	14d24 <malloc>
   15004:	4602      	mov	r2, r0
   15006:	63a0      	str	r0, [r4, #56]	; 0x38
   15008:	b920      	cbnz	r0, 15014 <rand+0x20>
   1500a:	4b13      	ldr	r3, [pc, #76]	; (15058 <rand+0x64>)
   1500c:	4813      	ldr	r0, [pc, #76]	; (1505c <rand+0x68>)
   1500e:	214e      	movs	r1, #78	; 0x4e
   15010:	f000 fa4a 	bl	154a8 <__assert_func>
   15014:	4912      	ldr	r1, [pc, #72]	; (15060 <rand+0x6c>)
   15016:	4b13      	ldr	r3, [pc, #76]	; (15064 <rand+0x70>)
   15018:	e9c0 1300 	strd	r1, r3, [r0]
   1501c:	4b12      	ldr	r3, [pc, #72]	; (15068 <rand+0x74>)
   1501e:	6083      	str	r3, [r0, #8]
   15020:	230b      	movs	r3, #11
   15022:	8183      	strh	r3, [r0, #12]
   15024:	2100      	movs	r1, #0
   15026:	2001      	movs	r0, #1
   15028:	e9c2 0104 	strd	r0, r1, [r2, #16]
   1502c:	6ba1      	ldr	r1, [r4, #56]	; 0x38
   1502e:	480f      	ldr	r0, [pc, #60]	; (1506c <rand+0x78>)
   15030:	690a      	ldr	r2, [r1, #16]
   15032:	694b      	ldr	r3, [r1, #20]
   15034:	4c0e      	ldr	r4, [pc, #56]	; (15070 <rand+0x7c>)
   15036:	4350      	muls	r0, r2
   15038:	fb04 0003 	mla	r0, r4, r3, r0
   1503c:	fba2 3404 	umull	r3, r4, r2, r4
   15040:	1c5a      	adds	r2, r3, #1
   15042:	4404      	add	r4, r0
   15044:	f144 0000 	adc.w	r0, r4, #0
   15048:	e9c1 2004 	strd	r2, r0, [r1, #16]
   1504c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
   15050:	bd10      	pop	{r4, pc}
   15052:	bf00      	nop
   15054:	2000054c 	.word	0x2000054c
   15058:	000175d0 	.word	0x000175d0
   1505c:	000175e7 	.word	0x000175e7
   15060:	abcd330e 	.word	0xabcd330e
   15064:	e66d1234 	.word	0xe66d1234
   15068:	0005deec 	.word	0x0005deec
   1506c:	5851f42d 	.word	0x5851f42d
   15070:	4c957f2d 	.word	0x4c957f2d

00015074 <_sbrk_r>:
   15074:	b538      	push	{r3, r4, r5, lr}
   15076:	4d06      	ldr	r5, [pc, #24]	; (15090 <_sbrk_r+0x1c>)
   15078:	2300      	movs	r3, #0
   1507a:	4604      	mov	r4, r0
   1507c:	4608      	mov	r0, r1
   1507e:	602b      	str	r3, [r5, #0]
   15080:	f7f7 fb4c 	bl	c71c <_sbrk>
   15084:	1c43      	adds	r3, r0, #1
   15086:	d102      	bne.n	1508e <_sbrk_r+0x1a>
   15088:	682b      	ldr	r3, [r5, #0]
   1508a:	b103      	cbz	r3, 1508e <_sbrk_r+0x1a>
   1508c:	6023      	str	r3, [r4, #0]
   1508e:	bd38      	pop	{r3, r4, r5, pc}
   15090:	2001cfe0 	.word	0x2001cfe0

00015094 <setbuf>:
   15094:	2900      	cmp	r1, #0
   15096:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1509a:	bf0c      	ite	eq
   1509c:	2202      	moveq	r2, #2
   1509e:	2200      	movne	r2, #0
   150a0:	f000 b800 	b.w	150a4 <setvbuf>

000150a4 <setvbuf>:
   150a4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
   150a8:	461d      	mov	r5, r3
   150aa:	4b5d      	ldr	r3, [pc, #372]	; (15220 <setvbuf+0x17c>)
   150ac:	681f      	ldr	r7, [r3, #0]
   150ae:	4604      	mov	r4, r0
   150b0:	460e      	mov	r6, r1
   150b2:	4690      	mov	r8, r2
   150b4:	b127      	cbz	r7, 150c0 <setvbuf+0x1c>
   150b6:	69bb      	ldr	r3, [r7, #24]
   150b8:	b913      	cbnz	r3, 150c0 <setvbuf+0x1c>
   150ba:	4638      	mov	r0, r7
   150bc:	f000 fb2c 	bl	15718 <__sinit>
   150c0:	4b58      	ldr	r3, [pc, #352]	; (15224 <setvbuf+0x180>)
   150c2:	429c      	cmp	r4, r3
   150c4:	d167      	bne.n	15196 <setvbuf+0xf2>
   150c6:	687c      	ldr	r4, [r7, #4]
   150c8:	f1b8 0f02 	cmp.w	r8, #2
   150cc:	d006      	beq.n	150dc <setvbuf+0x38>
   150ce:	f1b8 0f01 	cmp.w	r8, #1
   150d2:	f200 809f 	bhi.w	15214 <setvbuf+0x170>
   150d6:	2d00      	cmp	r5, #0
   150d8:	f2c0 809c 	blt.w	15214 <setvbuf+0x170>
   150dc:	6e63      	ldr	r3, [r4, #100]	; 0x64
   150de:	07db      	lsls	r3, r3, #31
   150e0:	d405      	bmi.n	150ee <setvbuf+0x4a>
   150e2:	89a3      	ldrh	r3, [r4, #12]
   150e4:	0598      	lsls	r0, r3, #22
   150e6:	d402      	bmi.n	150ee <setvbuf+0x4a>
   150e8:	6da0      	ldr	r0, [r4, #88]	; 0x58
   150ea:	f000 fbc5 	bl	15878 <__retarget_lock_acquire_recursive>
   150ee:	4621      	mov	r1, r4
   150f0:	4638      	mov	r0, r7
   150f2:	f000 fa7d 	bl	155f0 <_fflush_r>
   150f6:	6b61      	ldr	r1, [r4, #52]	; 0x34
   150f8:	b141      	cbz	r1, 1510c <setvbuf+0x68>
   150fa:	f104 0344 	add.w	r3, r4, #68	; 0x44
   150fe:	4299      	cmp	r1, r3
   15100:	d002      	beq.n	15108 <setvbuf+0x64>
   15102:	4638      	mov	r0, r7
   15104:	f7ff fe2c 	bl	14d60 <_free_r>
   15108:	2300      	movs	r3, #0
   1510a:	6363      	str	r3, [r4, #52]	; 0x34
   1510c:	2300      	movs	r3, #0
   1510e:	61a3      	str	r3, [r4, #24]
   15110:	6063      	str	r3, [r4, #4]
   15112:	89a3      	ldrh	r3, [r4, #12]
   15114:	0619      	lsls	r1, r3, #24
   15116:	d503      	bpl.n	15120 <setvbuf+0x7c>
   15118:	6921      	ldr	r1, [r4, #16]
   1511a:	4638      	mov	r0, r7
   1511c:	f7ff fe20 	bl	14d60 <_free_r>
   15120:	89a3      	ldrh	r3, [r4, #12]
   15122:	f423 634a 	bic.w	r3, r3, #3232	; 0xca0
   15126:	f023 0303 	bic.w	r3, r3, #3
   1512a:	f1b8 0f02 	cmp.w	r8, #2
   1512e:	81a3      	strh	r3, [r4, #12]
   15130:	d06c      	beq.n	1520c <setvbuf+0x168>
   15132:	ab01      	add	r3, sp, #4
   15134:	466a      	mov	r2, sp
   15136:	4621      	mov	r1, r4
   15138:	4638      	mov	r0, r7
   1513a:	f000 fb9f 	bl	1587c <__swhatbuf_r>
   1513e:	89a3      	ldrh	r3, [r4, #12]
   15140:	4318      	orrs	r0, r3
   15142:	81a0      	strh	r0, [r4, #12]
   15144:	2d00      	cmp	r5, #0
   15146:	d130      	bne.n	151aa <setvbuf+0x106>
   15148:	9d00      	ldr	r5, [sp, #0]
   1514a:	4628      	mov	r0, r5
   1514c:	f7ff fdea 	bl	14d24 <malloc>
   15150:	4606      	mov	r6, r0
   15152:	2800      	cmp	r0, #0
   15154:	d155      	bne.n	15202 <setvbuf+0x15e>
   15156:	f8dd 9000 	ldr.w	r9, [sp]
   1515a:	45a9      	cmp	r9, r5
   1515c:	d14a      	bne.n	151f4 <setvbuf+0x150>
   1515e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   15162:	2200      	movs	r2, #0
   15164:	60a2      	str	r2, [r4, #8]
   15166:	f104 0247 	add.w	r2, r4, #71	; 0x47
   1516a:	6022      	str	r2, [r4, #0]
   1516c:	6122      	str	r2, [r4, #16]
   1516e:	2201      	movs	r2, #1
   15170:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15174:	6162      	str	r2, [r4, #20]
   15176:	6e62      	ldr	r2, [r4, #100]	; 0x64
   15178:	f043 0302 	orr.w	r3, r3, #2
   1517c:	07d2      	lsls	r2, r2, #31
   1517e:	81a3      	strh	r3, [r4, #12]
   15180:	d405      	bmi.n	1518e <setvbuf+0xea>
   15182:	f413 7f00 	tst.w	r3, #512	; 0x200
   15186:	d102      	bne.n	1518e <setvbuf+0xea>
   15188:	6da0      	ldr	r0, [r4, #88]	; 0x58
   1518a:	f000 fb76 	bl	1587a <__retarget_lock_release_recursive>
   1518e:	4628      	mov	r0, r5
   15190:	b003      	add	sp, #12
   15192:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
   15196:	4b24      	ldr	r3, [pc, #144]	; (15228 <setvbuf+0x184>)
   15198:	429c      	cmp	r4, r3
   1519a:	d101      	bne.n	151a0 <setvbuf+0xfc>
   1519c:	68bc      	ldr	r4, [r7, #8]
   1519e:	e793      	b.n	150c8 <setvbuf+0x24>
   151a0:	4b22      	ldr	r3, [pc, #136]	; (1522c <setvbuf+0x188>)
   151a2:	429c      	cmp	r4, r3
   151a4:	bf08      	it	eq
   151a6:	68fc      	ldreq	r4, [r7, #12]
   151a8:	e78e      	b.n	150c8 <setvbuf+0x24>
   151aa:	2e00      	cmp	r6, #0
   151ac:	d0cd      	beq.n	1514a <setvbuf+0xa6>
   151ae:	69bb      	ldr	r3, [r7, #24]
   151b0:	b913      	cbnz	r3, 151b8 <setvbuf+0x114>
   151b2:	4638      	mov	r0, r7
   151b4:	f000 fab0 	bl	15718 <__sinit>
   151b8:	f1b8 0f01 	cmp.w	r8, #1
   151bc:	bf08      	it	eq
   151be:	89a3      	ldrheq	r3, [r4, #12]
   151c0:	6026      	str	r6, [r4, #0]
   151c2:	bf04      	itt	eq
   151c4:	f043 0301 	orreq.w	r3, r3, #1
   151c8:	81a3      	strheq	r3, [r4, #12]
   151ca:	89a2      	ldrh	r2, [r4, #12]
   151cc:	f012 0308 	ands.w	r3, r2, #8
   151d0:	e9c4 6504 	strd	r6, r5, [r4, #16]
   151d4:	d01c      	beq.n	15210 <setvbuf+0x16c>
   151d6:	07d3      	lsls	r3, r2, #31
   151d8:	bf41      	itttt	mi
   151da:	2300      	movmi	r3, #0
   151dc:	426d      	negmi	r5, r5
   151de:	60a3      	strmi	r3, [r4, #8]
   151e0:	61a5      	strmi	r5, [r4, #24]
   151e2:	bf58      	it	pl
   151e4:	60a5      	strpl	r5, [r4, #8]
   151e6:	6e65      	ldr	r5, [r4, #100]	; 0x64
   151e8:	f015 0501 	ands.w	r5, r5, #1
   151ec:	d115      	bne.n	1521a <setvbuf+0x176>
   151ee:	f412 7f00 	tst.w	r2, #512	; 0x200
   151f2:	e7c8      	b.n	15186 <setvbuf+0xe2>
   151f4:	4648      	mov	r0, r9
   151f6:	f7ff fd95 	bl	14d24 <malloc>
   151fa:	4606      	mov	r6, r0
   151fc:	2800      	cmp	r0, #0
   151fe:	d0ae      	beq.n	1515e <setvbuf+0xba>
   15200:	464d      	mov	r5, r9
   15202:	89a3      	ldrh	r3, [r4, #12]
   15204:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   15208:	81a3      	strh	r3, [r4, #12]
   1520a:	e7d0      	b.n	151ae <setvbuf+0x10a>
   1520c:	2500      	movs	r5, #0
   1520e:	e7a8      	b.n	15162 <setvbuf+0xbe>
   15210:	60a3      	str	r3, [r4, #8]
   15212:	e7e8      	b.n	151e6 <setvbuf+0x142>
   15214:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
   15218:	e7b9      	b.n	1518e <setvbuf+0xea>
   1521a:	2500      	movs	r5, #0
   1521c:	e7b7      	b.n	1518e <setvbuf+0xea>
   1521e:	bf00      	nop
   15220:	2000054c 	.word	0x2000054c
   15224:	000176c0 	.word	0x000176c0
   15228:	000176e0 	.word	0x000176e0
   1522c:	000176a0 	.word	0x000176a0

00015230 <sniprintf>:
   15230:	b40c      	push	{r2, r3}
   15232:	b530      	push	{r4, r5, lr}
   15234:	4b17      	ldr	r3, [pc, #92]	; (15294 <sniprintf+0x64>)
   15236:	1e0c      	subs	r4, r1, #0
   15238:	681d      	ldr	r5, [r3, #0]
   1523a:	b09d      	sub	sp, #116	; 0x74
   1523c:	da08      	bge.n	15250 <sniprintf+0x20>
   1523e:	238b      	movs	r3, #139	; 0x8b
   15240:	602b      	str	r3, [r5, #0]
   15242:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15246:	b01d      	add	sp, #116	; 0x74
   15248:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
   1524c:	b002      	add	sp, #8
   1524e:	4770      	bx	lr
   15250:	f44f 7302 	mov.w	r3, #520	; 0x208
   15254:	f8ad 3014 	strh.w	r3, [sp, #20]
   15258:	bf14      	ite	ne
   1525a:	f104 33ff 	addne.w	r3, r4, #4294967295	; 0xffffffff
   1525e:	4623      	moveq	r3, r4
   15260:	9304      	str	r3, [sp, #16]
   15262:	9307      	str	r3, [sp, #28]
   15264:	f64f 73ff 	movw	r3, #65535	; 0xffff
   15268:	9002      	str	r0, [sp, #8]
   1526a:	9006      	str	r0, [sp, #24]
   1526c:	f8ad 3016 	strh.w	r3, [sp, #22]
   15270:	9a20      	ldr	r2, [sp, #128]	; 0x80
   15272:	ab21      	add	r3, sp, #132	; 0x84
   15274:	a902      	add	r1, sp, #8
   15276:	4628      	mov	r0, r5
   15278:	9301      	str	r3, [sp, #4]
   1527a:	f000 fbcb 	bl	15a14 <_svfiprintf_r>
   1527e:	1c43      	adds	r3, r0, #1
   15280:	bfbc      	itt	lt
   15282:	238b      	movlt	r3, #139	; 0x8b
   15284:	602b      	strlt	r3, [r5, #0]
   15286:	2c00      	cmp	r4, #0
   15288:	d0dd      	beq.n	15246 <sniprintf+0x16>
   1528a:	9b02      	ldr	r3, [sp, #8]
   1528c:	2200      	movs	r2, #0
   1528e:	701a      	strb	r2, [r3, #0]
   15290:	e7d9      	b.n	15246 <sniprintf+0x16>
   15292:	bf00      	nop
   15294:	2000054c 	.word	0x2000054c

00015298 <siprintf>:
   15298:	b40e      	push	{r1, r2, r3}
   1529a:	b500      	push	{lr}
   1529c:	b09c      	sub	sp, #112	; 0x70
   1529e:	ab1d      	add	r3, sp, #116	; 0x74
   152a0:	9002      	str	r0, [sp, #8]
   152a2:	9006      	str	r0, [sp, #24]
   152a4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
   152a8:	4809      	ldr	r0, [pc, #36]	; (152d0 <siprintf+0x38>)
   152aa:	9107      	str	r1, [sp, #28]
   152ac:	9104      	str	r1, [sp, #16]
   152ae:	4909      	ldr	r1, [pc, #36]	; (152d4 <siprintf+0x3c>)
   152b0:	f853 2b04 	ldr.w	r2, [r3], #4
   152b4:	9105      	str	r1, [sp, #20]
   152b6:	6800      	ldr	r0, [r0, #0]
   152b8:	9301      	str	r3, [sp, #4]
   152ba:	a902      	add	r1, sp, #8
   152bc:	f000 fbaa 	bl	15a14 <_svfiprintf_r>
   152c0:	9b02      	ldr	r3, [sp, #8]
   152c2:	2200      	movs	r2, #0
   152c4:	701a      	strb	r2, [r3, #0]
   152c6:	b01c      	add	sp, #112	; 0x70
   152c8:	f85d eb04 	ldr.w	lr, [sp], #4
   152cc:	b003      	add	sp, #12
   152ce:	4770      	bx	lr
   152d0:	2000054c 	.word	0x2000054c
   152d4:	ffff0208 	.word	0xffff0208

000152d8 <strchr>:
   152d8:	b2c9      	uxtb	r1, r1
   152da:	4603      	mov	r3, r0
   152dc:	4618      	mov	r0, r3
   152de:	f813 2b01 	ldrb.w	r2, [r3], #1
   152e2:	b112      	cbz	r2, 152ea <strchr+0x12>
   152e4:	428a      	cmp	r2, r1
   152e6:	d1f9      	bne.n	152dc <strchr+0x4>
   152e8:	4770      	bx	lr
   152ea:	2900      	cmp	r1, #0
   152ec:	bf18      	it	ne
   152ee:	2000      	movne	r0, #0
   152f0:	4770      	bx	lr

000152f2 <strcmp>:
   152f2:	f810 2b01 	ldrb.w	r2, [r0], #1
   152f6:	f811 3b01 	ldrb.w	r3, [r1], #1
   152fa:	2a01      	cmp	r2, #1
   152fc:	bf28      	it	cs
   152fe:	429a      	cmpcs	r2, r3
   15300:	d0f7      	beq.n	152f2 <strcmp>
   15302:	1ad0      	subs	r0, r2, r3
   15304:	4770      	bx	lr

00015306 <strcpy>:
   15306:	4603      	mov	r3, r0
   15308:	f811 2b01 	ldrb.w	r2, [r1], #1
   1530c:	f803 2b01 	strb.w	r2, [r3], #1
   15310:	2a00      	cmp	r2, #0
   15312:	d1f9      	bne.n	15308 <strcpy+0x2>
   15314:	4770      	bx	lr

00015316 <strlen>:
   15316:	4603      	mov	r3, r0
   15318:	f813 2b01 	ldrb.w	r2, [r3], #1
   1531c:	2a00      	cmp	r2, #0
   1531e:	d1fb      	bne.n	15318 <strlen+0x2>
   15320:	1a18      	subs	r0, r3, r0
   15322:	3801      	subs	r0, #1
   15324:	4770      	bx	lr
	...

00015328 <__swbuf_r>:
   15328:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1532a:	460e      	mov	r6, r1
   1532c:	4614      	mov	r4, r2
   1532e:	4605      	mov	r5, r0
   15330:	b118      	cbz	r0, 1533a <__swbuf_r+0x12>
   15332:	6983      	ldr	r3, [r0, #24]
   15334:	b90b      	cbnz	r3, 1533a <__swbuf_r+0x12>
   15336:	f000 f9ef 	bl	15718 <__sinit>
   1533a:	4b21      	ldr	r3, [pc, #132]	; (153c0 <__swbuf_r+0x98>)
   1533c:	429c      	cmp	r4, r3
   1533e:	d12b      	bne.n	15398 <__swbuf_r+0x70>
   15340:	686c      	ldr	r4, [r5, #4]
   15342:	69a3      	ldr	r3, [r4, #24]
   15344:	60a3      	str	r3, [r4, #8]
   15346:	89a3      	ldrh	r3, [r4, #12]
   15348:	071a      	lsls	r2, r3, #28
   1534a:	d52f      	bpl.n	153ac <__swbuf_r+0x84>
   1534c:	6923      	ldr	r3, [r4, #16]
   1534e:	b36b      	cbz	r3, 153ac <__swbuf_r+0x84>
   15350:	6923      	ldr	r3, [r4, #16]
   15352:	6820      	ldr	r0, [r4, #0]
   15354:	1ac0      	subs	r0, r0, r3
   15356:	6963      	ldr	r3, [r4, #20]
   15358:	b2f6      	uxtb	r6, r6
   1535a:	4283      	cmp	r3, r0
   1535c:	4637      	mov	r7, r6
   1535e:	dc04      	bgt.n	1536a <__swbuf_r+0x42>
   15360:	4621      	mov	r1, r4
   15362:	4628      	mov	r0, r5
   15364:	f000 f944 	bl	155f0 <_fflush_r>
   15368:	bb30      	cbnz	r0, 153b8 <__swbuf_r+0x90>
   1536a:	68a3      	ldr	r3, [r4, #8]
   1536c:	3b01      	subs	r3, #1
   1536e:	60a3      	str	r3, [r4, #8]
   15370:	6823      	ldr	r3, [r4, #0]
   15372:	1c5a      	adds	r2, r3, #1
   15374:	6022      	str	r2, [r4, #0]
   15376:	701e      	strb	r6, [r3, #0]
   15378:	6963      	ldr	r3, [r4, #20]
   1537a:	3001      	adds	r0, #1
   1537c:	4283      	cmp	r3, r0
   1537e:	d004      	beq.n	1538a <__swbuf_r+0x62>
   15380:	89a3      	ldrh	r3, [r4, #12]
   15382:	07db      	lsls	r3, r3, #31
   15384:	d506      	bpl.n	15394 <__swbuf_r+0x6c>
   15386:	2e0a      	cmp	r6, #10
   15388:	d104      	bne.n	15394 <__swbuf_r+0x6c>
   1538a:	4621      	mov	r1, r4
   1538c:	4628      	mov	r0, r5
   1538e:	f000 f92f 	bl	155f0 <_fflush_r>
   15392:	b988      	cbnz	r0, 153b8 <__swbuf_r+0x90>
   15394:	4638      	mov	r0, r7
   15396:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   15398:	4b0a      	ldr	r3, [pc, #40]	; (153c4 <__swbuf_r+0x9c>)
   1539a:	429c      	cmp	r4, r3
   1539c:	d101      	bne.n	153a2 <__swbuf_r+0x7a>
   1539e:	68ac      	ldr	r4, [r5, #8]
   153a0:	e7cf      	b.n	15342 <__swbuf_r+0x1a>
   153a2:	4b09      	ldr	r3, [pc, #36]	; (153c8 <__swbuf_r+0xa0>)
   153a4:	429c      	cmp	r4, r3
   153a6:	bf08      	it	eq
   153a8:	68ec      	ldreq	r4, [r5, #12]
   153aa:	e7ca      	b.n	15342 <__swbuf_r+0x1a>
   153ac:	4621      	mov	r1, r4
   153ae:	4628      	mov	r0, r5
   153b0:	f000 f80c 	bl	153cc <__swsetup_r>
   153b4:	2800      	cmp	r0, #0
   153b6:	d0cb      	beq.n	15350 <__swbuf_r+0x28>
   153b8:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
   153bc:	e7ea      	b.n	15394 <__swbuf_r+0x6c>
   153be:	bf00      	nop
   153c0:	000176c0 	.word	0x000176c0
   153c4:	000176e0 	.word	0x000176e0
   153c8:	000176a0 	.word	0x000176a0

000153cc <__swsetup_r>:
   153cc:	4b32      	ldr	r3, [pc, #200]	; (15498 <__swsetup_r+0xcc>)
   153ce:	b570      	push	{r4, r5, r6, lr}
   153d0:	681d      	ldr	r5, [r3, #0]
   153d2:	4606      	mov	r6, r0
   153d4:	460c      	mov	r4, r1
   153d6:	b125      	cbz	r5, 153e2 <__swsetup_r+0x16>
   153d8:	69ab      	ldr	r3, [r5, #24]
   153da:	b913      	cbnz	r3, 153e2 <__swsetup_r+0x16>
   153dc:	4628      	mov	r0, r5
   153de:	f000 f99b 	bl	15718 <__sinit>
   153e2:	4b2e      	ldr	r3, [pc, #184]	; (1549c <__swsetup_r+0xd0>)
   153e4:	429c      	cmp	r4, r3
   153e6:	d10f      	bne.n	15408 <__swsetup_r+0x3c>
   153e8:	686c      	ldr	r4, [r5, #4]
   153ea:	89a3      	ldrh	r3, [r4, #12]
   153ec:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   153f0:	0719      	lsls	r1, r3, #28
   153f2:	d42c      	bmi.n	1544e <__swsetup_r+0x82>
   153f4:	06dd      	lsls	r5, r3, #27
   153f6:	d411      	bmi.n	1541c <__swsetup_r+0x50>
   153f8:	2309      	movs	r3, #9
   153fa:	6033      	str	r3, [r6, #0]
   153fc:	f042 0340 	orr.w	r3, r2, #64	; 0x40
   15400:	81a3      	strh	r3, [r4, #12]
   15402:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15406:	e03e      	b.n	15486 <__swsetup_r+0xba>
   15408:	4b25      	ldr	r3, [pc, #148]	; (154a0 <__swsetup_r+0xd4>)
   1540a:	429c      	cmp	r4, r3
   1540c:	d101      	bne.n	15412 <__swsetup_r+0x46>
   1540e:	68ac      	ldr	r4, [r5, #8]
   15410:	e7eb      	b.n	153ea <__swsetup_r+0x1e>
   15412:	4b24      	ldr	r3, [pc, #144]	; (154a4 <__swsetup_r+0xd8>)
   15414:	429c      	cmp	r4, r3
   15416:	bf08      	it	eq
   15418:	68ec      	ldreq	r4, [r5, #12]
   1541a:	e7e6      	b.n	153ea <__swsetup_r+0x1e>
   1541c:	0758      	lsls	r0, r3, #29
   1541e:	d512      	bpl.n	15446 <__swsetup_r+0x7a>
   15420:	6b61      	ldr	r1, [r4, #52]	; 0x34
   15422:	b141      	cbz	r1, 15436 <__swsetup_r+0x6a>
   15424:	f104 0344 	add.w	r3, r4, #68	; 0x44
   15428:	4299      	cmp	r1, r3
   1542a:	d002      	beq.n	15432 <__swsetup_r+0x66>
   1542c:	4630      	mov	r0, r6
   1542e:	f7ff fc97 	bl	14d60 <_free_r>
   15432:	2300      	movs	r3, #0
   15434:	6363      	str	r3, [r4, #52]	; 0x34
   15436:	89a3      	ldrh	r3, [r4, #12]
   15438:	f023 0324 	bic.w	r3, r3, #36	; 0x24
   1543c:	81a3      	strh	r3, [r4, #12]
   1543e:	2300      	movs	r3, #0
   15440:	6063      	str	r3, [r4, #4]
   15442:	6923      	ldr	r3, [r4, #16]
   15444:	6023      	str	r3, [r4, #0]
   15446:	89a3      	ldrh	r3, [r4, #12]
   15448:	f043 0308 	orr.w	r3, r3, #8
   1544c:	81a3      	strh	r3, [r4, #12]
   1544e:	6923      	ldr	r3, [r4, #16]
   15450:	b94b      	cbnz	r3, 15466 <__swsetup_r+0x9a>
   15452:	89a3      	ldrh	r3, [r4, #12]
   15454:	f403 7320 	and.w	r3, r3, #640	; 0x280
   15458:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   1545c:	d003      	beq.n	15466 <__swsetup_r+0x9a>
   1545e:	4621      	mov	r1, r4
   15460:	4630      	mov	r0, r6
   15462:	f000 fa2f 	bl	158c4 <__smakebuf_r>
   15466:	89a0      	ldrh	r0, [r4, #12]
   15468:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
   1546c:	f010 0301 	ands.w	r3, r0, #1
   15470:	d00a      	beq.n	15488 <__swsetup_r+0xbc>
   15472:	2300      	movs	r3, #0
   15474:	60a3      	str	r3, [r4, #8]
   15476:	6963      	ldr	r3, [r4, #20]
   15478:	425b      	negs	r3, r3
   1547a:	61a3      	str	r3, [r4, #24]
   1547c:	6923      	ldr	r3, [r4, #16]
   1547e:	b943      	cbnz	r3, 15492 <__swsetup_r+0xc6>
   15480:	f010 0080 	ands.w	r0, r0, #128	; 0x80
   15484:	d1ba      	bne.n	153fc <__swsetup_r+0x30>
   15486:	bd70      	pop	{r4, r5, r6, pc}
   15488:	0781      	lsls	r1, r0, #30
   1548a:	bf58      	it	pl
   1548c:	6963      	ldrpl	r3, [r4, #20]
   1548e:	60a3      	str	r3, [r4, #8]
   15490:	e7f4      	b.n	1547c <__swsetup_r+0xb0>
   15492:	2000      	movs	r0, #0
   15494:	e7f7      	b.n	15486 <__swsetup_r+0xba>
   15496:	bf00      	nop
   15498:	2000054c 	.word	0x2000054c
   1549c:	000176c0 	.word	0x000176c0
   154a0:	000176e0 	.word	0x000176e0
   154a4:	000176a0 	.word	0x000176a0

000154a8 <__assert_func>:
   154a8:	b51f      	push	{r0, r1, r2, r3, r4, lr}
   154aa:	4614      	mov	r4, r2
   154ac:	461a      	mov	r2, r3
   154ae:	4b09      	ldr	r3, [pc, #36]	; (154d4 <__assert_func+0x2c>)
   154b0:	681b      	ldr	r3, [r3, #0]
   154b2:	4605      	mov	r5, r0
   154b4:	68d8      	ldr	r0, [r3, #12]
   154b6:	b14c      	cbz	r4, 154cc <__assert_func+0x24>
   154b8:	4b07      	ldr	r3, [pc, #28]	; (154d8 <__assert_func+0x30>)
   154ba:	9100      	str	r1, [sp, #0]
   154bc:	e9cd 3401 	strd	r3, r4, [sp, #4]
   154c0:	4906      	ldr	r1, [pc, #24]	; (154dc <__assert_func+0x34>)
   154c2:	462b      	mov	r3, r5
   154c4:	f000 f9a6 	bl	15814 <fiprintf>
   154c8:	f000 ff2e 	bl	16328 <abort>
   154cc:	4b04      	ldr	r3, [pc, #16]	; (154e0 <__assert_func+0x38>)
   154ce:	461c      	mov	r4, r3
   154d0:	e7f3      	b.n	154ba <__assert_func+0x12>
   154d2:	bf00      	nop
   154d4:	2000054c 	.word	0x2000054c
   154d8:	00017663 	.word	0x00017663
   154dc:	00017670 	.word	0x00017670
   154e0:	00016ca0 	.word	0x00016ca0

000154e4 <__sflush_r>:
   154e4:	898a      	ldrh	r2, [r1, #12]
   154e6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   154ea:	4605      	mov	r5, r0
   154ec:	0710      	lsls	r0, r2, #28
   154ee:	460c      	mov	r4, r1
   154f0:	d458      	bmi.n	155a4 <__sflush_r+0xc0>
   154f2:	684b      	ldr	r3, [r1, #4]
   154f4:	2b00      	cmp	r3, #0
   154f6:	dc05      	bgt.n	15504 <__sflush_r+0x20>
   154f8:	6c0b      	ldr	r3, [r1, #64]	; 0x40
   154fa:	2b00      	cmp	r3, #0
   154fc:	dc02      	bgt.n	15504 <__sflush_r+0x20>
   154fe:	2000      	movs	r0, #0
   15500:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   15504:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   15506:	2e00      	cmp	r6, #0
   15508:	d0f9      	beq.n	154fe <__sflush_r+0x1a>
   1550a:	2300      	movs	r3, #0
   1550c:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
   15510:	682f      	ldr	r7, [r5, #0]
   15512:	602b      	str	r3, [r5, #0]
   15514:	d032      	beq.n	1557c <__sflush_r+0x98>
   15516:	6d60      	ldr	r0, [r4, #84]	; 0x54
   15518:	89a3      	ldrh	r3, [r4, #12]
   1551a:	075a      	lsls	r2, r3, #29
   1551c:	d505      	bpl.n	1552a <__sflush_r+0x46>
   1551e:	6863      	ldr	r3, [r4, #4]
   15520:	1ac0      	subs	r0, r0, r3
   15522:	6b63      	ldr	r3, [r4, #52]	; 0x34
   15524:	b10b      	cbz	r3, 1552a <__sflush_r+0x46>
   15526:	6c23      	ldr	r3, [r4, #64]	; 0x40
   15528:	1ac0      	subs	r0, r0, r3
   1552a:	2300      	movs	r3, #0
   1552c:	4602      	mov	r2, r0
   1552e:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
   15530:	6a21      	ldr	r1, [r4, #32]
   15532:	4628      	mov	r0, r5
   15534:	47b0      	blx	r6
   15536:	1c43      	adds	r3, r0, #1
   15538:	89a3      	ldrh	r3, [r4, #12]
   1553a:	d106      	bne.n	1554a <__sflush_r+0x66>
   1553c:	6829      	ldr	r1, [r5, #0]
   1553e:	291d      	cmp	r1, #29
   15540:	d82c      	bhi.n	1559c <__sflush_r+0xb8>
   15542:	4a2a      	ldr	r2, [pc, #168]	; (155ec <__sflush_r+0x108>)
   15544:	40ca      	lsrs	r2, r1
   15546:	07d6      	lsls	r6, r2, #31
   15548:	d528      	bpl.n	1559c <__sflush_r+0xb8>
   1554a:	2200      	movs	r2, #0
   1554c:	6062      	str	r2, [r4, #4]
   1554e:	04d9      	lsls	r1, r3, #19
   15550:	6922      	ldr	r2, [r4, #16]
   15552:	6022      	str	r2, [r4, #0]
   15554:	d504      	bpl.n	15560 <__sflush_r+0x7c>
   15556:	1c42      	adds	r2, r0, #1
   15558:	d101      	bne.n	1555e <__sflush_r+0x7a>
   1555a:	682b      	ldr	r3, [r5, #0]
   1555c:	b903      	cbnz	r3, 15560 <__sflush_r+0x7c>
   1555e:	6560      	str	r0, [r4, #84]	; 0x54
   15560:	6b61      	ldr	r1, [r4, #52]	; 0x34
   15562:	602f      	str	r7, [r5, #0]
   15564:	2900      	cmp	r1, #0
   15566:	d0ca      	beq.n	154fe <__sflush_r+0x1a>
   15568:	f104 0344 	add.w	r3, r4, #68	; 0x44
   1556c:	4299      	cmp	r1, r3
   1556e:	d002      	beq.n	15576 <__sflush_r+0x92>
   15570:	4628      	mov	r0, r5
   15572:	f7ff fbf5 	bl	14d60 <_free_r>
   15576:	2000      	movs	r0, #0
   15578:	6360      	str	r0, [r4, #52]	; 0x34
   1557a:	e7c1      	b.n	15500 <__sflush_r+0x1c>
   1557c:	6a21      	ldr	r1, [r4, #32]
   1557e:	2301      	movs	r3, #1
   15580:	4628      	mov	r0, r5
   15582:	47b0      	blx	r6
   15584:	1c41      	adds	r1, r0, #1
   15586:	d1c7      	bne.n	15518 <__sflush_r+0x34>
   15588:	682b      	ldr	r3, [r5, #0]
   1558a:	2b00      	cmp	r3, #0
   1558c:	d0c4      	beq.n	15518 <__sflush_r+0x34>
   1558e:	2b1d      	cmp	r3, #29
   15590:	d001      	beq.n	15596 <__sflush_r+0xb2>
   15592:	2b16      	cmp	r3, #22
   15594:	d101      	bne.n	1559a <__sflush_r+0xb6>
   15596:	602f      	str	r7, [r5, #0]
   15598:	e7b1      	b.n	154fe <__sflush_r+0x1a>
   1559a:	89a3      	ldrh	r3, [r4, #12]
   1559c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   155a0:	81a3      	strh	r3, [r4, #12]
   155a2:	e7ad      	b.n	15500 <__sflush_r+0x1c>
   155a4:	690f      	ldr	r7, [r1, #16]
   155a6:	2f00      	cmp	r7, #0
   155a8:	d0a9      	beq.n	154fe <__sflush_r+0x1a>
   155aa:	0793      	lsls	r3, r2, #30
   155ac:	680e      	ldr	r6, [r1, #0]
   155ae:	bf08      	it	eq
   155b0:	694b      	ldreq	r3, [r1, #20]
   155b2:	600f      	str	r7, [r1, #0]
   155b4:	bf18      	it	ne
   155b6:	2300      	movne	r3, #0
   155b8:	eba6 0807 	sub.w	r8, r6, r7
   155bc:	608b      	str	r3, [r1, #8]
   155be:	f1b8 0f00 	cmp.w	r8, #0
   155c2:	dd9c      	ble.n	154fe <__sflush_r+0x1a>
   155c4:	6a21      	ldr	r1, [r4, #32]
   155c6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
   155c8:	4643      	mov	r3, r8
   155ca:	463a      	mov	r2, r7
   155cc:	4628      	mov	r0, r5
   155ce:	47b0      	blx	r6
   155d0:	2800      	cmp	r0, #0
   155d2:	dc06      	bgt.n	155e2 <__sflush_r+0xfe>
   155d4:	89a3      	ldrh	r3, [r4, #12]
   155d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   155da:	81a3      	strh	r3, [r4, #12]
   155dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   155e0:	e78e      	b.n	15500 <__sflush_r+0x1c>
   155e2:	4407      	add	r7, r0
   155e4:	eba8 0800 	sub.w	r8, r8, r0
   155e8:	e7e9      	b.n	155be <__sflush_r+0xda>
   155ea:	bf00      	nop
   155ec:	20400001 	.word	0x20400001

000155f0 <_fflush_r>:
   155f0:	b538      	push	{r3, r4, r5, lr}
   155f2:	690b      	ldr	r3, [r1, #16]
   155f4:	4605      	mov	r5, r0
   155f6:	460c      	mov	r4, r1
   155f8:	b913      	cbnz	r3, 15600 <_fflush_r+0x10>
   155fa:	2500      	movs	r5, #0
   155fc:	4628      	mov	r0, r5
   155fe:	bd38      	pop	{r3, r4, r5, pc}
   15600:	b118      	cbz	r0, 1560a <_fflush_r+0x1a>
   15602:	6983      	ldr	r3, [r0, #24]
   15604:	b90b      	cbnz	r3, 1560a <_fflush_r+0x1a>
   15606:	f000 f887 	bl	15718 <__sinit>
   1560a:	4b14      	ldr	r3, [pc, #80]	; (1565c <_fflush_r+0x6c>)
   1560c:	429c      	cmp	r4, r3
   1560e:	d11b      	bne.n	15648 <_fflush_r+0x58>
   15610:	686c      	ldr	r4, [r5, #4]
   15612:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   15616:	2b00      	cmp	r3, #0
   15618:	d0ef      	beq.n	155fa <_fflush_r+0xa>
   1561a:	6e62      	ldr	r2, [r4, #100]	; 0x64
   1561c:	07d0      	lsls	r0, r2, #31
   1561e:	d404      	bmi.n	1562a <_fflush_r+0x3a>
   15620:	0599      	lsls	r1, r3, #22
   15622:	d402      	bmi.n	1562a <_fflush_r+0x3a>
   15624:	6da0      	ldr	r0, [r4, #88]	; 0x58
   15626:	f000 f927 	bl	15878 <__retarget_lock_acquire_recursive>
   1562a:	4628      	mov	r0, r5
   1562c:	4621      	mov	r1, r4
   1562e:	f7ff ff59 	bl	154e4 <__sflush_r>
   15632:	6e63      	ldr	r3, [r4, #100]	; 0x64
   15634:	07da      	lsls	r2, r3, #31
   15636:	4605      	mov	r5, r0
   15638:	d4e0      	bmi.n	155fc <_fflush_r+0xc>
   1563a:	89a3      	ldrh	r3, [r4, #12]
   1563c:	059b      	lsls	r3, r3, #22
   1563e:	d4dd      	bmi.n	155fc <_fflush_r+0xc>
   15640:	6da0      	ldr	r0, [r4, #88]	; 0x58
   15642:	f000 f91a 	bl	1587a <__retarget_lock_release_recursive>
   15646:	e7d9      	b.n	155fc <_fflush_r+0xc>
   15648:	4b05      	ldr	r3, [pc, #20]	; (15660 <_fflush_r+0x70>)
   1564a:	429c      	cmp	r4, r3
   1564c:	d101      	bne.n	15652 <_fflush_r+0x62>
   1564e:	68ac      	ldr	r4, [r5, #8]
   15650:	e7df      	b.n	15612 <_fflush_r+0x22>
   15652:	4b04      	ldr	r3, [pc, #16]	; (15664 <_fflush_r+0x74>)
   15654:	429c      	cmp	r4, r3
   15656:	bf08      	it	eq
   15658:	68ec      	ldreq	r4, [r5, #12]
   1565a:	e7da      	b.n	15612 <_fflush_r+0x22>
   1565c:	000176c0 	.word	0x000176c0
   15660:	000176e0 	.word	0x000176e0
   15664:	000176a0 	.word	0x000176a0

00015668 <std>:
   15668:	2300      	movs	r3, #0
   1566a:	b510      	push	{r4, lr}
   1566c:	4604      	mov	r4, r0
   1566e:	e9c0 3300 	strd	r3, r3, [r0]
   15672:	e9c0 3304 	strd	r3, r3, [r0, #16]
   15676:	6083      	str	r3, [r0, #8]
   15678:	8181      	strh	r1, [r0, #12]
   1567a:	6643      	str	r3, [r0, #100]	; 0x64
   1567c:	81c2      	strh	r2, [r0, #14]
   1567e:	6183      	str	r3, [r0, #24]
   15680:	4619      	mov	r1, r3
   15682:	2208      	movs	r2, #8
   15684:	305c      	adds	r0, #92	; 0x5c
   15686:	f7ff fb63 	bl	14d50 <memset>
   1568a:	4b05      	ldr	r3, [pc, #20]	; (156a0 <std+0x38>)
   1568c:	6263      	str	r3, [r4, #36]	; 0x24
   1568e:	4b05      	ldr	r3, [pc, #20]	; (156a4 <std+0x3c>)
   15690:	62a3      	str	r3, [r4, #40]	; 0x28
   15692:	4b05      	ldr	r3, [pc, #20]	; (156a8 <std+0x40>)
   15694:	62e3      	str	r3, [r4, #44]	; 0x2c
   15696:	4b05      	ldr	r3, [pc, #20]	; (156ac <std+0x44>)
   15698:	6224      	str	r4, [r4, #32]
   1569a:	6323      	str	r3, [r4, #48]	; 0x30
   1569c:	bd10      	pop	{r4, pc}
   1569e:	bf00      	nop
   156a0:	0001627d 	.word	0x0001627d
   156a4:	0001629f 	.word	0x0001629f
   156a8:	000162d7 	.word	0x000162d7
   156ac:	000162fb 	.word	0x000162fb

000156b0 <_cleanup_r>:
   156b0:	4901      	ldr	r1, [pc, #4]	; (156b8 <_cleanup_r+0x8>)
   156b2:	f000 b8c1 	b.w	15838 <_fwalk_reent>
   156b6:	bf00      	nop
   156b8:	000155f1 	.word	0x000155f1

000156bc <__sfmoreglue>:
   156bc:	b570      	push	{r4, r5, r6, lr}
   156be:	1e4a      	subs	r2, r1, #1
   156c0:	2568      	movs	r5, #104	; 0x68
   156c2:	4355      	muls	r5, r2
   156c4:	460e      	mov	r6, r1
   156c6:	f105 0174 	add.w	r1, r5, #116	; 0x74
   156ca:	f7ff fb97 	bl	14dfc <_malloc_r>
   156ce:	4604      	mov	r4, r0
   156d0:	b140      	cbz	r0, 156e4 <__sfmoreglue+0x28>
   156d2:	2100      	movs	r1, #0
   156d4:	e9c0 1600 	strd	r1, r6, [r0]
   156d8:	300c      	adds	r0, #12
   156da:	60a0      	str	r0, [r4, #8]
   156dc:	f105 0268 	add.w	r2, r5, #104	; 0x68
   156e0:	f7ff fb36 	bl	14d50 <memset>
   156e4:	4620      	mov	r0, r4
   156e6:	bd70      	pop	{r4, r5, r6, pc}

000156e8 <__sfp_lock_acquire>:
   156e8:	4801      	ldr	r0, [pc, #4]	; (156f0 <__sfp_lock_acquire+0x8>)
   156ea:	f000 b8c5 	b.w	15878 <__retarget_lock_acquire_recursive>
   156ee:	bf00      	nop
   156f0:	2001cfdc 	.word	0x2001cfdc

000156f4 <__sfp_lock_release>:
   156f4:	4801      	ldr	r0, [pc, #4]	; (156fc <__sfp_lock_release+0x8>)
   156f6:	f000 b8c0 	b.w	1587a <__retarget_lock_release_recursive>
   156fa:	bf00      	nop
   156fc:	2001cfdc 	.word	0x2001cfdc

00015700 <__sinit_lock_acquire>:
   15700:	4801      	ldr	r0, [pc, #4]	; (15708 <__sinit_lock_acquire+0x8>)
   15702:	f000 b8b9 	b.w	15878 <__retarget_lock_acquire_recursive>
   15706:	bf00      	nop
   15708:	2001cfd7 	.word	0x2001cfd7

0001570c <__sinit_lock_release>:
   1570c:	4801      	ldr	r0, [pc, #4]	; (15714 <__sinit_lock_release+0x8>)
   1570e:	f000 b8b4 	b.w	1587a <__retarget_lock_release_recursive>
   15712:	bf00      	nop
   15714:	2001cfd7 	.word	0x2001cfd7

00015718 <__sinit>:
   15718:	b510      	push	{r4, lr}
   1571a:	4604      	mov	r4, r0
   1571c:	f7ff fff0 	bl	15700 <__sinit_lock_acquire>
   15720:	69a3      	ldr	r3, [r4, #24]
   15722:	b11b      	cbz	r3, 1572c <__sinit+0x14>
   15724:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   15728:	f7ff bff0 	b.w	1570c <__sinit_lock_release>
   1572c:	e9c4 3312 	strd	r3, r3, [r4, #72]	; 0x48
   15730:	6523      	str	r3, [r4, #80]	; 0x50
   15732:	4b13      	ldr	r3, [pc, #76]	; (15780 <__sinit+0x68>)
   15734:	4a13      	ldr	r2, [pc, #76]	; (15784 <__sinit+0x6c>)
   15736:	681b      	ldr	r3, [r3, #0]
   15738:	62a2      	str	r2, [r4, #40]	; 0x28
   1573a:	42a3      	cmp	r3, r4
   1573c:	bf04      	itt	eq
   1573e:	2301      	moveq	r3, #1
   15740:	61a3      	streq	r3, [r4, #24]
   15742:	4620      	mov	r0, r4
   15744:	f000 f820 	bl	15788 <__sfp>
   15748:	6060      	str	r0, [r4, #4]
   1574a:	4620      	mov	r0, r4
   1574c:	f000 f81c 	bl	15788 <__sfp>
   15750:	60a0      	str	r0, [r4, #8]
   15752:	4620      	mov	r0, r4
   15754:	f000 f818 	bl	15788 <__sfp>
   15758:	2200      	movs	r2, #0
   1575a:	60e0      	str	r0, [r4, #12]
   1575c:	2104      	movs	r1, #4
   1575e:	6860      	ldr	r0, [r4, #4]
   15760:	f7ff ff82 	bl	15668 <std>
   15764:	68a0      	ldr	r0, [r4, #8]
   15766:	2201      	movs	r2, #1
   15768:	2109      	movs	r1, #9
   1576a:	f7ff ff7d 	bl	15668 <std>
   1576e:	68e0      	ldr	r0, [r4, #12]
   15770:	2202      	movs	r2, #2
   15772:	2112      	movs	r1, #18
   15774:	f7ff ff78 	bl	15668 <std>
   15778:	2301      	movs	r3, #1
   1577a:	61a3      	str	r3, [r4, #24]
   1577c:	e7d2      	b.n	15724 <__sinit+0xc>
   1577e:	bf00      	nop
   15780:	000175cc 	.word	0x000175cc
   15784:	000156b1 	.word	0x000156b1

00015788 <__sfp>:
   15788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   1578a:	4607      	mov	r7, r0
   1578c:	f7ff ffac 	bl	156e8 <__sfp_lock_acquire>
   15790:	4b1e      	ldr	r3, [pc, #120]	; (1580c <__sfp+0x84>)
   15792:	681e      	ldr	r6, [r3, #0]
   15794:	69b3      	ldr	r3, [r6, #24]
   15796:	b913      	cbnz	r3, 1579e <__sfp+0x16>
   15798:	4630      	mov	r0, r6
   1579a:	f7ff ffbd 	bl	15718 <__sinit>
   1579e:	3648      	adds	r6, #72	; 0x48
   157a0:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
   157a4:	3b01      	subs	r3, #1
   157a6:	d503      	bpl.n	157b0 <__sfp+0x28>
   157a8:	6833      	ldr	r3, [r6, #0]
   157aa:	b30b      	cbz	r3, 157f0 <__sfp+0x68>
   157ac:	6836      	ldr	r6, [r6, #0]
   157ae:	e7f7      	b.n	157a0 <__sfp+0x18>
   157b0:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
   157b4:	b9d5      	cbnz	r5, 157ec <__sfp+0x64>
   157b6:	4b16      	ldr	r3, [pc, #88]	; (15810 <__sfp+0x88>)
   157b8:	60e3      	str	r3, [r4, #12]
   157ba:	f104 0058 	add.w	r0, r4, #88	; 0x58
   157be:	6665      	str	r5, [r4, #100]	; 0x64
   157c0:	f000 f859 	bl	15876 <__retarget_lock_init_recursive>
   157c4:	f7ff ff96 	bl	156f4 <__sfp_lock_release>
   157c8:	e9c4 5501 	strd	r5, r5, [r4, #4]
   157cc:	e9c4 5504 	strd	r5, r5, [r4, #16]
   157d0:	6025      	str	r5, [r4, #0]
   157d2:	61a5      	str	r5, [r4, #24]
   157d4:	2208      	movs	r2, #8
   157d6:	4629      	mov	r1, r5
   157d8:	f104 005c 	add.w	r0, r4, #92	; 0x5c
   157dc:	f7ff fab8 	bl	14d50 <memset>
   157e0:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
   157e4:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
   157e8:	4620      	mov	r0, r4
   157ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   157ec:	3468      	adds	r4, #104	; 0x68
   157ee:	e7d9      	b.n	157a4 <__sfp+0x1c>
   157f0:	2104      	movs	r1, #4
   157f2:	4638      	mov	r0, r7
   157f4:	f7ff ff62 	bl	156bc <__sfmoreglue>
   157f8:	4604      	mov	r4, r0
   157fa:	6030      	str	r0, [r6, #0]
   157fc:	2800      	cmp	r0, #0
   157fe:	d1d5      	bne.n	157ac <__sfp+0x24>
   15800:	f7ff ff78 	bl	156f4 <__sfp_lock_release>
   15804:	230c      	movs	r3, #12
   15806:	603b      	str	r3, [r7, #0]
   15808:	e7ee      	b.n	157e8 <__sfp+0x60>
   1580a:	bf00      	nop
   1580c:	000175cc 	.word	0x000175cc
   15810:	ffff0001 	.word	0xffff0001

00015814 <fiprintf>:
   15814:	b40e      	push	{r1, r2, r3}
   15816:	b503      	push	{r0, r1, lr}
   15818:	4601      	mov	r1, r0
   1581a:	ab03      	add	r3, sp, #12
   1581c:	4805      	ldr	r0, [pc, #20]	; (15834 <fiprintf+0x20>)
   1581e:	f853 2b04 	ldr.w	r2, [r3], #4
   15822:	6800      	ldr	r0, [r0, #0]
   15824:	9301      	str	r3, [sp, #4]
   15826:	f000 fa1d 	bl	15c64 <_vfiprintf_r>
   1582a:	b002      	add	sp, #8
   1582c:	f85d eb04 	ldr.w	lr, [sp], #4
   15830:	b003      	add	sp, #12
   15832:	4770      	bx	lr
   15834:	2000054c 	.word	0x2000054c

00015838 <_fwalk_reent>:
   15838:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   1583c:	4606      	mov	r6, r0
   1583e:	4688      	mov	r8, r1
   15840:	f100 0448 	add.w	r4, r0, #72	; 0x48
   15844:	2700      	movs	r7, #0
   15846:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
   1584a:	f1b9 0901 	subs.w	r9, r9, #1
   1584e:	d505      	bpl.n	1585c <_fwalk_reent+0x24>
   15850:	6824      	ldr	r4, [r4, #0]
   15852:	2c00      	cmp	r4, #0
   15854:	d1f7      	bne.n	15846 <_fwalk_reent+0xe>
   15856:	4638      	mov	r0, r7
   15858:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   1585c:	89ab      	ldrh	r3, [r5, #12]
   1585e:	2b01      	cmp	r3, #1
   15860:	d907      	bls.n	15872 <_fwalk_reent+0x3a>
   15862:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
   15866:	3301      	adds	r3, #1
   15868:	d003      	beq.n	15872 <_fwalk_reent+0x3a>
   1586a:	4629      	mov	r1, r5
   1586c:	4630      	mov	r0, r6
   1586e:	47c0      	blx	r8
   15870:	4307      	orrs	r7, r0
   15872:	3568      	adds	r5, #104	; 0x68
   15874:	e7e9      	b.n	1584a <_fwalk_reent+0x12>

00015876 <__retarget_lock_init_recursive>:
   15876:	4770      	bx	lr

00015878 <__retarget_lock_acquire_recursive>:
   15878:	4770      	bx	lr

0001587a <__retarget_lock_release_recursive>:
   1587a:	4770      	bx	lr

0001587c <__swhatbuf_r>:
   1587c:	b570      	push	{r4, r5, r6, lr}
   1587e:	460e      	mov	r6, r1
   15880:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   15884:	2900      	cmp	r1, #0
   15886:	b096      	sub	sp, #88	; 0x58
   15888:	4614      	mov	r4, r2
   1588a:	461d      	mov	r5, r3
   1588c:	da07      	bge.n	1589e <__swhatbuf_r+0x22>
   1588e:	2300      	movs	r3, #0
   15890:	602b      	str	r3, [r5, #0]
   15892:	89b3      	ldrh	r3, [r6, #12]
   15894:	061a      	lsls	r2, r3, #24
   15896:	d410      	bmi.n	158ba <__swhatbuf_r+0x3e>
   15898:	f44f 6380 	mov.w	r3, #1024	; 0x400
   1589c:	e00e      	b.n	158bc <__swhatbuf_r+0x40>
   1589e:	466a      	mov	r2, sp
   158a0:	f000 fd5a 	bl	16358 <_fstat_r>
   158a4:	2800      	cmp	r0, #0
   158a6:	dbf2      	blt.n	1588e <__swhatbuf_r+0x12>
   158a8:	9a01      	ldr	r2, [sp, #4]
   158aa:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
   158ae:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
   158b2:	425a      	negs	r2, r3
   158b4:	415a      	adcs	r2, r3
   158b6:	602a      	str	r2, [r5, #0]
   158b8:	e7ee      	b.n	15898 <__swhatbuf_r+0x1c>
   158ba:	2340      	movs	r3, #64	; 0x40
   158bc:	2000      	movs	r0, #0
   158be:	6023      	str	r3, [r4, #0]
   158c0:	b016      	add	sp, #88	; 0x58
   158c2:	bd70      	pop	{r4, r5, r6, pc}

000158c4 <__smakebuf_r>:
   158c4:	898b      	ldrh	r3, [r1, #12]
   158c6:	b573      	push	{r0, r1, r4, r5, r6, lr}
   158c8:	079d      	lsls	r5, r3, #30
   158ca:	4606      	mov	r6, r0
   158cc:	460c      	mov	r4, r1
   158ce:	d507      	bpl.n	158e0 <__smakebuf_r+0x1c>
   158d0:	f104 0347 	add.w	r3, r4, #71	; 0x47
   158d4:	6023      	str	r3, [r4, #0]
   158d6:	6123      	str	r3, [r4, #16]
   158d8:	2301      	movs	r3, #1
   158da:	6163      	str	r3, [r4, #20]
   158dc:	b002      	add	sp, #8
   158de:	bd70      	pop	{r4, r5, r6, pc}
   158e0:	ab01      	add	r3, sp, #4
   158e2:	466a      	mov	r2, sp
   158e4:	f7ff ffca 	bl	1587c <__swhatbuf_r>
   158e8:	9900      	ldr	r1, [sp, #0]
   158ea:	4605      	mov	r5, r0
   158ec:	4630      	mov	r0, r6
   158ee:	f7ff fa85 	bl	14dfc <_malloc_r>
   158f2:	b948      	cbnz	r0, 15908 <__smakebuf_r+0x44>
   158f4:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
   158f8:	059a      	lsls	r2, r3, #22
   158fa:	d4ef      	bmi.n	158dc <__smakebuf_r+0x18>
   158fc:	f023 0303 	bic.w	r3, r3, #3
   15900:	f043 0302 	orr.w	r3, r3, #2
   15904:	81a3      	strh	r3, [r4, #12]
   15906:	e7e3      	b.n	158d0 <__smakebuf_r+0xc>
   15908:	4b0d      	ldr	r3, [pc, #52]	; (15940 <__smakebuf_r+0x7c>)
   1590a:	62b3      	str	r3, [r6, #40]	; 0x28
   1590c:	89a3      	ldrh	r3, [r4, #12]
   1590e:	6020      	str	r0, [r4, #0]
   15910:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   15914:	81a3      	strh	r3, [r4, #12]
   15916:	9b00      	ldr	r3, [sp, #0]
   15918:	6163      	str	r3, [r4, #20]
   1591a:	9b01      	ldr	r3, [sp, #4]
   1591c:	6120      	str	r0, [r4, #16]
   1591e:	b15b      	cbz	r3, 15938 <__smakebuf_r+0x74>
   15920:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   15924:	4630      	mov	r0, r6
   15926:	f000 fd29 	bl	1637c <_isatty_r>
   1592a:	b128      	cbz	r0, 15938 <__smakebuf_r+0x74>
   1592c:	89a3      	ldrh	r3, [r4, #12]
   1592e:	f023 0303 	bic.w	r3, r3, #3
   15932:	f043 0301 	orr.w	r3, r3, #1
   15936:	81a3      	strh	r3, [r4, #12]
   15938:	89a0      	ldrh	r0, [r4, #12]
   1593a:	4305      	orrs	r5, r0
   1593c:	81a5      	strh	r5, [r4, #12]
   1593e:	e7cd      	b.n	158dc <__smakebuf_r+0x18>
   15940:	000156b1 	.word	0x000156b1

00015944 <__malloc_lock>:
   15944:	4801      	ldr	r0, [pc, #4]	; (1594c <__malloc_lock+0x8>)
   15946:	f7ff bf97 	b.w	15878 <__retarget_lock_acquire_recursive>
   1594a:	bf00      	nop
   1594c:	2001cfd8 	.word	0x2001cfd8

00015950 <__malloc_unlock>:
   15950:	4801      	ldr	r0, [pc, #4]	; (15958 <__malloc_unlock+0x8>)
   15952:	f7ff bf92 	b.w	1587a <__retarget_lock_release_recursive>
   15956:	bf00      	nop
   15958:	2001cfd8 	.word	0x2001cfd8

0001595c <__ssputs_r>:
   1595c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15960:	688e      	ldr	r6, [r1, #8]
   15962:	429e      	cmp	r6, r3
   15964:	4682      	mov	sl, r0
   15966:	460c      	mov	r4, r1
   15968:	4690      	mov	r8, r2
   1596a:	461f      	mov	r7, r3
   1596c:	d838      	bhi.n	159e0 <__ssputs_r+0x84>
   1596e:	898a      	ldrh	r2, [r1, #12]
   15970:	f412 6f90 	tst.w	r2, #1152	; 0x480
   15974:	d032      	beq.n	159dc <__ssputs_r+0x80>
   15976:	6825      	ldr	r5, [r4, #0]
   15978:	6909      	ldr	r1, [r1, #16]
   1597a:	eba5 0901 	sub.w	r9, r5, r1
   1597e:	6965      	ldr	r5, [r4, #20]
   15980:	eb05 0545 	add.w	r5, r5, r5, lsl #1
   15984:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
   15988:	3301      	adds	r3, #1
   1598a:	444b      	add	r3, r9
   1598c:	106d      	asrs	r5, r5, #1
   1598e:	429d      	cmp	r5, r3
   15990:	bf38      	it	cc
   15992:	461d      	movcc	r5, r3
   15994:	0553      	lsls	r3, r2, #21
   15996:	d531      	bpl.n	159fc <__ssputs_r+0xa0>
   15998:	4629      	mov	r1, r5
   1599a:	f7ff fa2f 	bl	14dfc <_malloc_r>
   1599e:	4606      	mov	r6, r0
   159a0:	b950      	cbnz	r0, 159b8 <__ssputs_r+0x5c>
   159a2:	230c      	movs	r3, #12
   159a4:	f8ca 3000 	str.w	r3, [sl]
   159a8:	89a3      	ldrh	r3, [r4, #12]
   159aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
   159ae:	81a3      	strh	r3, [r4, #12]
   159b0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   159b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   159b8:	6921      	ldr	r1, [r4, #16]
   159ba:	464a      	mov	r2, r9
   159bc:	f7ff f9ba 	bl	14d34 <memcpy>
   159c0:	89a3      	ldrh	r3, [r4, #12]
   159c2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
   159c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   159ca:	81a3      	strh	r3, [r4, #12]
   159cc:	6126      	str	r6, [r4, #16]
   159ce:	6165      	str	r5, [r4, #20]
   159d0:	444e      	add	r6, r9
   159d2:	eba5 0509 	sub.w	r5, r5, r9
   159d6:	6026      	str	r6, [r4, #0]
   159d8:	60a5      	str	r5, [r4, #8]
   159da:	463e      	mov	r6, r7
   159dc:	42be      	cmp	r6, r7
   159de:	d900      	bls.n	159e2 <__ssputs_r+0x86>
   159e0:	463e      	mov	r6, r7
   159e2:	4632      	mov	r2, r6
   159e4:	6820      	ldr	r0, [r4, #0]
   159e6:	4641      	mov	r1, r8
   159e8:	f000 fd3a 	bl	16460 <memmove>
   159ec:	68a3      	ldr	r3, [r4, #8]
   159ee:	6822      	ldr	r2, [r4, #0]
   159f0:	1b9b      	subs	r3, r3, r6
   159f2:	4432      	add	r2, r6
   159f4:	60a3      	str	r3, [r4, #8]
   159f6:	6022      	str	r2, [r4, #0]
   159f8:	2000      	movs	r0, #0
   159fa:	e7db      	b.n	159b4 <__ssputs_r+0x58>
   159fc:	462a      	mov	r2, r5
   159fe:	f000 fd49 	bl	16494 <_realloc_r>
   15a02:	4606      	mov	r6, r0
   15a04:	2800      	cmp	r0, #0
   15a06:	d1e1      	bne.n	159cc <__ssputs_r+0x70>
   15a08:	6921      	ldr	r1, [r4, #16]
   15a0a:	4650      	mov	r0, sl
   15a0c:	f7ff f9a8 	bl	14d60 <_free_r>
   15a10:	e7c7      	b.n	159a2 <__ssputs_r+0x46>
	...

00015a14 <_svfiprintf_r>:
   15a14:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15a18:	4698      	mov	r8, r3
   15a1a:	898b      	ldrh	r3, [r1, #12]
   15a1c:	061b      	lsls	r3, r3, #24
   15a1e:	b09d      	sub	sp, #116	; 0x74
   15a20:	4607      	mov	r7, r0
   15a22:	460d      	mov	r5, r1
   15a24:	4614      	mov	r4, r2
   15a26:	d50e      	bpl.n	15a46 <_svfiprintf_r+0x32>
   15a28:	690b      	ldr	r3, [r1, #16]
   15a2a:	b963      	cbnz	r3, 15a46 <_svfiprintf_r+0x32>
   15a2c:	2140      	movs	r1, #64	; 0x40
   15a2e:	f7ff f9e5 	bl	14dfc <_malloc_r>
   15a32:	6028      	str	r0, [r5, #0]
   15a34:	6128      	str	r0, [r5, #16]
   15a36:	b920      	cbnz	r0, 15a42 <_svfiprintf_r+0x2e>
   15a38:	230c      	movs	r3, #12
   15a3a:	603b      	str	r3, [r7, #0]
   15a3c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15a40:	e0d1      	b.n	15be6 <_svfiprintf_r+0x1d2>
   15a42:	2340      	movs	r3, #64	; 0x40
   15a44:	616b      	str	r3, [r5, #20]
   15a46:	2300      	movs	r3, #0
   15a48:	9309      	str	r3, [sp, #36]	; 0x24
   15a4a:	2320      	movs	r3, #32
   15a4c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   15a50:	f8cd 800c 	str.w	r8, [sp, #12]
   15a54:	2330      	movs	r3, #48	; 0x30
   15a56:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 15c00 <_svfiprintf_r+0x1ec>
   15a5a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   15a5e:	f04f 0901 	mov.w	r9, #1
   15a62:	4623      	mov	r3, r4
   15a64:	469a      	mov	sl, r3
   15a66:	f813 2b01 	ldrb.w	r2, [r3], #1
   15a6a:	b10a      	cbz	r2, 15a70 <_svfiprintf_r+0x5c>
   15a6c:	2a25      	cmp	r2, #37	; 0x25
   15a6e:	d1f9      	bne.n	15a64 <_svfiprintf_r+0x50>
   15a70:	ebba 0b04 	subs.w	fp, sl, r4
   15a74:	d00b      	beq.n	15a8e <_svfiprintf_r+0x7a>
   15a76:	465b      	mov	r3, fp
   15a78:	4622      	mov	r2, r4
   15a7a:	4629      	mov	r1, r5
   15a7c:	4638      	mov	r0, r7
   15a7e:	f7ff ff6d 	bl	1595c <__ssputs_r>
   15a82:	3001      	adds	r0, #1
   15a84:	f000 80aa 	beq.w	15bdc <_svfiprintf_r+0x1c8>
   15a88:	9a09      	ldr	r2, [sp, #36]	; 0x24
   15a8a:	445a      	add	r2, fp
   15a8c:	9209      	str	r2, [sp, #36]	; 0x24
   15a8e:	f89a 3000 	ldrb.w	r3, [sl]
   15a92:	2b00      	cmp	r3, #0
   15a94:	f000 80a2 	beq.w	15bdc <_svfiprintf_r+0x1c8>
   15a98:	2300      	movs	r3, #0
   15a9a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15a9e:	e9cd 2305 	strd	r2, r3, [sp, #20]
   15aa2:	f10a 0a01 	add.w	sl, sl, #1
   15aa6:	9304      	str	r3, [sp, #16]
   15aa8:	9307      	str	r3, [sp, #28]
   15aaa:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   15aae:	931a      	str	r3, [sp, #104]	; 0x68
   15ab0:	4654      	mov	r4, sl
   15ab2:	2205      	movs	r2, #5
   15ab4:	f814 1b01 	ldrb.w	r1, [r4], #1
   15ab8:	4851      	ldr	r0, [pc, #324]	; (15c00 <_svfiprintf_r+0x1ec>)
   15aba:	f000 fc81 	bl	163c0 <memchr>
   15abe:	9a04      	ldr	r2, [sp, #16]
   15ac0:	b9d8      	cbnz	r0, 15afa <_svfiprintf_r+0xe6>
   15ac2:	06d0      	lsls	r0, r2, #27
   15ac4:	bf44      	itt	mi
   15ac6:	2320      	movmi	r3, #32
   15ac8:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15acc:	0711      	lsls	r1, r2, #28
   15ace:	bf44      	itt	mi
   15ad0:	232b      	movmi	r3, #43	; 0x2b
   15ad2:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15ad6:	f89a 3000 	ldrb.w	r3, [sl]
   15ada:	2b2a      	cmp	r3, #42	; 0x2a
   15adc:	d015      	beq.n	15b0a <_svfiprintf_r+0xf6>
   15ade:	9a07      	ldr	r2, [sp, #28]
   15ae0:	4654      	mov	r4, sl
   15ae2:	2000      	movs	r0, #0
   15ae4:	f04f 0c0a 	mov.w	ip, #10
   15ae8:	4621      	mov	r1, r4
   15aea:	f811 3b01 	ldrb.w	r3, [r1], #1
   15aee:	3b30      	subs	r3, #48	; 0x30
   15af0:	2b09      	cmp	r3, #9
   15af2:	d94e      	bls.n	15b92 <_svfiprintf_r+0x17e>
   15af4:	b1b0      	cbz	r0, 15b24 <_svfiprintf_r+0x110>
   15af6:	9207      	str	r2, [sp, #28]
   15af8:	e014      	b.n	15b24 <_svfiprintf_r+0x110>
   15afa:	eba0 0308 	sub.w	r3, r0, r8
   15afe:	fa09 f303 	lsl.w	r3, r9, r3
   15b02:	4313      	orrs	r3, r2
   15b04:	9304      	str	r3, [sp, #16]
   15b06:	46a2      	mov	sl, r4
   15b08:	e7d2      	b.n	15ab0 <_svfiprintf_r+0x9c>
   15b0a:	9b03      	ldr	r3, [sp, #12]
   15b0c:	1d19      	adds	r1, r3, #4
   15b0e:	681b      	ldr	r3, [r3, #0]
   15b10:	9103      	str	r1, [sp, #12]
   15b12:	2b00      	cmp	r3, #0
   15b14:	bfbb      	ittet	lt
   15b16:	425b      	neglt	r3, r3
   15b18:	f042 0202 	orrlt.w	r2, r2, #2
   15b1c:	9307      	strge	r3, [sp, #28]
   15b1e:	9307      	strlt	r3, [sp, #28]
   15b20:	bfb8      	it	lt
   15b22:	9204      	strlt	r2, [sp, #16]
   15b24:	7823      	ldrb	r3, [r4, #0]
   15b26:	2b2e      	cmp	r3, #46	; 0x2e
   15b28:	d10c      	bne.n	15b44 <_svfiprintf_r+0x130>
   15b2a:	7863      	ldrb	r3, [r4, #1]
   15b2c:	2b2a      	cmp	r3, #42	; 0x2a
   15b2e:	d135      	bne.n	15b9c <_svfiprintf_r+0x188>
   15b30:	9b03      	ldr	r3, [sp, #12]
   15b32:	1d1a      	adds	r2, r3, #4
   15b34:	681b      	ldr	r3, [r3, #0]
   15b36:	9203      	str	r2, [sp, #12]
   15b38:	2b00      	cmp	r3, #0
   15b3a:	bfb8      	it	lt
   15b3c:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   15b40:	3402      	adds	r4, #2
   15b42:	9305      	str	r3, [sp, #20]
   15b44:	f8df a0c8 	ldr.w	sl, [pc, #200]	; 15c10 <_svfiprintf_r+0x1fc>
   15b48:	7821      	ldrb	r1, [r4, #0]
   15b4a:	2203      	movs	r2, #3
   15b4c:	4650      	mov	r0, sl
   15b4e:	f000 fc37 	bl	163c0 <memchr>
   15b52:	b140      	cbz	r0, 15b66 <_svfiprintf_r+0x152>
   15b54:	2340      	movs	r3, #64	; 0x40
   15b56:	eba0 000a 	sub.w	r0, r0, sl
   15b5a:	fa03 f000 	lsl.w	r0, r3, r0
   15b5e:	9b04      	ldr	r3, [sp, #16]
   15b60:	4303      	orrs	r3, r0
   15b62:	3401      	adds	r4, #1
   15b64:	9304      	str	r3, [sp, #16]
   15b66:	f814 1b01 	ldrb.w	r1, [r4], #1
   15b6a:	4826      	ldr	r0, [pc, #152]	; (15c04 <_svfiprintf_r+0x1f0>)
   15b6c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   15b70:	2206      	movs	r2, #6
   15b72:	f000 fc25 	bl	163c0 <memchr>
   15b76:	2800      	cmp	r0, #0
   15b78:	d038      	beq.n	15bec <_svfiprintf_r+0x1d8>
   15b7a:	4b23      	ldr	r3, [pc, #140]	; (15c08 <_svfiprintf_r+0x1f4>)
   15b7c:	bb1b      	cbnz	r3, 15bc6 <_svfiprintf_r+0x1b2>
   15b7e:	9b03      	ldr	r3, [sp, #12]
   15b80:	3307      	adds	r3, #7
   15b82:	f023 0307 	bic.w	r3, r3, #7
   15b86:	3308      	adds	r3, #8
   15b88:	9303      	str	r3, [sp, #12]
   15b8a:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15b8c:	4433      	add	r3, r6
   15b8e:	9309      	str	r3, [sp, #36]	; 0x24
   15b90:	e767      	b.n	15a62 <_svfiprintf_r+0x4e>
   15b92:	fb0c 3202 	mla	r2, ip, r2, r3
   15b96:	460c      	mov	r4, r1
   15b98:	2001      	movs	r0, #1
   15b9a:	e7a5      	b.n	15ae8 <_svfiprintf_r+0xd4>
   15b9c:	2300      	movs	r3, #0
   15b9e:	3401      	adds	r4, #1
   15ba0:	9305      	str	r3, [sp, #20]
   15ba2:	4619      	mov	r1, r3
   15ba4:	f04f 0c0a 	mov.w	ip, #10
   15ba8:	4620      	mov	r0, r4
   15baa:	f810 2b01 	ldrb.w	r2, [r0], #1
   15bae:	3a30      	subs	r2, #48	; 0x30
   15bb0:	2a09      	cmp	r2, #9
   15bb2:	d903      	bls.n	15bbc <_svfiprintf_r+0x1a8>
   15bb4:	2b00      	cmp	r3, #0
   15bb6:	d0c5      	beq.n	15b44 <_svfiprintf_r+0x130>
   15bb8:	9105      	str	r1, [sp, #20]
   15bba:	e7c3      	b.n	15b44 <_svfiprintf_r+0x130>
   15bbc:	fb0c 2101 	mla	r1, ip, r1, r2
   15bc0:	4604      	mov	r4, r0
   15bc2:	2301      	movs	r3, #1
   15bc4:	e7f0      	b.n	15ba8 <_svfiprintf_r+0x194>
   15bc6:	ab03      	add	r3, sp, #12
   15bc8:	9300      	str	r3, [sp, #0]
   15bca:	462a      	mov	r2, r5
   15bcc:	4b0f      	ldr	r3, [pc, #60]	; (15c0c <_svfiprintf_r+0x1f8>)
   15bce:	a904      	add	r1, sp, #16
   15bd0:	4638      	mov	r0, r7
   15bd2:	f3af 8000 	nop.w
   15bd6:	1c42      	adds	r2, r0, #1
   15bd8:	4606      	mov	r6, r0
   15bda:	d1d6      	bne.n	15b8a <_svfiprintf_r+0x176>
   15bdc:	89ab      	ldrh	r3, [r5, #12]
   15bde:	065b      	lsls	r3, r3, #25
   15be0:	f53f af2c 	bmi.w	15a3c <_svfiprintf_r+0x28>
   15be4:	9809      	ldr	r0, [sp, #36]	; 0x24
   15be6:	b01d      	add	sp, #116	; 0x74
   15be8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15bec:	ab03      	add	r3, sp, #12
   15bee:	9300      	str	r3, [sp, #0]
   15bf0:	462a      	mov	r2, r5
   15bf2:	4b06      	ldr	r3, [pc, #24]	; (15c0c <_svfiprintf_r+0x1f8>)
   15bf4:	a904      	add	r1, sp, #16
   15bf6:	4638      	mov	r0, r7
   15bf8:	f000 f9d2 	bl	15fa0 <_printf_i>
   15bfc:	e7eb      	b.n	15bd6 <_svfiprintf_r+0x1c2>
   15bfe:	bf00      	nop
   15c00:	00017700 	.word	0x00017700
   15c04:	0001770a 	.word	0x0001770a
   15c08:	00000000 	.word	0x00000000
   15c0c:	0001595d 	.word	0x0001595d
   15c10:	00017706 	.word	0x00017706

00015c14 <__sfputc_r>:
   15c14:	6893      	ldr	r3, [r2, #8]
   15c16:	3b01      	subs	r3, #1
   15c18:	2b00      	cmp	r3, #0
   15c1a:	b410      	push	{r4}
   15c1c:	6093      	str	r3, [r2, #8]
   15c1e:	da07      	bge.n	15c30 <__sfputc_r+0x1c>
   15c20:	6994      	ldr	r4, [r2, #24]
   15c22:	42a3      	cmp	r3, r4
   15c24:	db01      	blt.n	15c2a <__sfputc_r+0x16>
   15c26:	290a      	cmp	r1, #10
   15c28:	d102      	bne.n	15c30 <__sfputc_r+0x1c>
   15c2a:	bc10      	pop	{r4}
   15c2c:	f7ff bb7c 	b.w	15328 <__swbuf_r>
   15c30:	6813      	ldr	r3, [r2, #0]
   15c32:	1c58      	adds	r0, r3, #1
   15c34:	6010      	str	r0, [r2, #0]
   15c36:	7019      	strb	r1, [r3, #0]
   15c38:	4608      	mov	r0, r1
   15c3a:	bc10      	pop	{r4}
   15c3c:	4770      	bx	lr

00015c3e <__sfputs_r>:
   15c3e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   15c40:	4606      	mov	r6, r0
   15c42:	460f      	mov	r7, r1
   15c44:	4614      	mov	r4, r2
   15c46:	18d5      	adds	r5, r2, r3
   15c48:	42ac      	cmp	r4, r5
   15c4a:	d101      	bne.n	15c50 <__sfputs_r+0x12>
   15c4c:	2000      	movs	r0, #0
   15c4e:	e007      	b.n	15c60 <__sfputs_r+0x22>
   15c50:	f814 1b01 	ldrb.w	r1, [r4], #1
   15c54:	463a      	mov	r2, r7
   15c56:	4630      	mov	r0, r6
   15c58:	f7ff ffdc 	bl	15c14 <__sfputc_r>
   15c5c:	1c43      	adds	r3, r0, #1
   15c5e:	d1f3      	bne.n	15c48 <__sfputs_r+0xa>
   15c60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

00015c64 <_vfiprintf_r>:
   15c64:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15c68:	460d      	mov	r5, r1
   15c6a:	b09d      	sub	sp, #116	; 0x74
   15c6c:	4614      	mov	r4, r2
   15c6e:	4698      	mov	r8, r3
   15c70:	4606      	mov	r6, r0
   15c72:	b118      	cbz	r0, 15c7c <_vfiprintf_r+0x18>
   15c74:	6983      	ldr	r3, [r0, #24]
   15c76:	b90b      	cbnz	r3, 15c7c <_vfiprintf_r+0x18>
   15c78:	f7ff fd4e 	bl	15718 <__sinit>
   15c7c:	4b89      	ldr	r3, [pc, #548]	; (15ea4 <_vfiprintf_r+0x240>)
   15c7e:	429d      	cmp	r5, r3
   15c80:	d11b      	bne.n	15cba <_vfiprintf_r+0x56>
   15c82:	6875      	ldr	r5, [r6, #4]
   15c84:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   15c86:	07d9      	lsls	r1, r3, #31
   15c88:	d405      	bmi.n	15c96 <_vfiprintf_r+0x32>
   15c8a:	89ab      	ldrh	r3, [r5, #12]
   15c8c:	059a      	lsls	r2, r3, #22
   15c8e:	d402      	bmi.n	15c96 <_vfiprintf_r+0x32>
   15c90:	6da8      	ldr	r0, [r5, #88]	; 0x58
   15c92:	f7ff fdf1 	bl	15878 <__retarget_lock_acquire_recursive>
   15c96:	89ab      	ldrh	r3, [r5, #12]
   15c98:	071b      	lsls	r3, r3, #28
   15c9a:	d501      	bpl.n	15ca0 <_vfiprintf_r+0x3c>
   15c9c:	692b      	ldr	r3, [r5, #16]
   15c9e:	b9eb      	cbnz	r3, 15cdc <_vfiprintf_r+0x78>
   15ca0:	4629      	mov	r1, r5
   15ca2:	4630      	mov	r0, r6
   15ca4:	f7ff fb92 	bl	153cc <__swsetup_r>
   15ca8:	b1c0      	cbz	r0, 15cdc <_vfiprintf_r+0x78>
   15caa:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   15cac:	07dc      	lsls	r4, r3, #31
   15cae:	d50e      	bpl.n	15cce <_vfiprintf_r+0x6a>
   15cb0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15cb4:	b01d      	add	sp, #116	; 0x74
   15cb6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   15cba:	4b7b      	ldr	r3, [pc, #492]	; (15ea8 <_vfiprintf_r+0x244>)
   15cbc:	429d      	cmp	r5, r3
   15cbe:	d101      	bne.n	15cc4 <_vfiprintf_r+0x60>
   15cc0:	68b5      	ldr	r5, [r6, #8]
   15cc2:	e7df      	b.n	15c84 <_vfiprintf_r+0x20>
   15cc4:	4b79      	ldr	r3, [pc, #484]	; (15eac <_vfiprintf_r+0x248>)
   15cc6:	429d      	cmp	r5, r3
   15cc8:	bf08      	it	eq
   15cca:	68f5      	ldreq	r5, [r6, #12]
   15ccc:	e7da      	b.n	15c84 <_vfiprintf_r+0x20>
   15cce:	89ab      	ldrh	r3, [r5, #12]
   15cd0:	0598      	lsls	r0, r3, #22
   15cd2:	d4ed      	bmi.n	15cb0 <_vfiprintf_r+0x4c>
   15cd4:	6da8      	ldr	r0, [r5, #88]	; 0x58
   15cd6:	f7ff fdd0 	bl	1587a <__retarget_lock_release_recursive>
   15cda:	e7e9      	b.n	15cb0 <_vfiprintf_r+0x4c>
   15cdc:	2300      	movs	r3, #0
   15cde:	9309      	str	r3, [sp, #36]	; 0x24
   15ce0:	2320      	movs	r3, #32
   15ce2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
   15ce6:	f8cd 800c 	str.w	r8, [sp, #12]
   15cea:	2330      	movs	r3, #48	; 0x30
   15cec:	f8df 81c0 	ldr.w	r8, [pc, #448]	; 15eb0 <_vfiprintf_r+0x24c>
   15cf0:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
   15cf4:	f04f 0901 	mov.w	r9, #1
   15cf8:	4623      	mov	r3, r4
   15cfa:	469a      	mov	sl, r3
   15cfc:	f813 2b01 	ldrb.w	r2, [r3], #1
   15d00:	b10a      	cbz	r2, 15d06 <_vfiprintf_r+0xa2>
   15d02:	2a25      	cmp	r2, #37	; 0x25
   15d04:	d1f9      	bne.n	15cfa <_vfiprintf_r+0x96>
   15d06:	ebba 0b04 	subs.w	fp, sl, r4
   15d0a:	d00b      	beq.n	15d24 <_vfiprintf_r+0xc0>
   15d0c:	465b      	mov	r3, fp
   15d0e:	4622      	mov	r2, r4
   15d10:	4629      	mov	r1, r5
   15d12:	4630      	mov	r0, r6
   15d14:	f7ff ff93 	bl	15c3e <__sfputs_r>
   15d18:	3001      	adds	r0, #1
   15d1a:	f000 80aa 	beq.w	15e72 <_vfiprintf_r+0x20e>
   15d1e:	9a09      	ldr	r2, [sp, #36]	; 0x24
   15d20:	445a      	add	r2, fp
   15d22:	9209      	str	r2, [sp, #36]	; 0x24
   15d24:	f89a 3000 	ldrb.w	r3, [sl]
   15d28:	2b00      	cmp	r3, #0
   15d2a:	f000 80a2 	beq.w	15e72 <_vfiprintf_r+0x20e>
   15d2e:	2300      	movs	r3, #0
   15d30:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
   15d34:	e9cd 2305 	strd	r2, r3, [sp, #20]
   15d38:	f10a 0a01 	add.w	sl, sl, #1
   15d3c:	9304      	str	r3, [sp, #16]
   15d3e:	9307      	str	r3, [sp, #28]
   15d40:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
   15d44:	931a      	str	r3, [sp, #104]	; 0x68
   15d46:	4654      	mov	r4, sl
   15d48:	2205      	movs	r2, #5
   15d4a:	f814 1b01 	ldrb.w	r1, [r4], #1
   15d4e:	4858      	ldr	r0, [pc, #352]	; (15eb0 <_vfiprintf_r+0x24c>)
   15d50:	f000 fb36 	bl	163c0 <memchr>
   15d54:	9a04      	ldr	r2, [sp, #16]
   15d56:	b9d8      	cbnz	r0, 15d90 <_vfiprintf_r+0x12c>
   15d58:	06d1      	lsls	r1, r2, #27
   15d5a:	bf44      	itt	mi
   15d5c:	2320      	movmi	r3, #32
   15d5e:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15d62:	0713      	lsls	r3, r2, #28
   15d64:	bf44      	itt	mi
   15d66:	232b      	movmi	r3, #43	; 0x2b
   15d68:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
   15d6c:	f89a 3000 	ldrb.w	r3, [sl]
   15d70:	2b2a      	cmp	r3, #42	; 0x2a
   15d72:	d015      	beq.n	15da0 <_vfiprintf_r+0x13c>
   15d74:	9a07      	ldr	r2, [sp, #28]
   15d76:	4654      	mov	r4, sl
   15d78:	2000      	movs	r0, #0
   15d7a:	f04f 0c0a 	mov.w	ip, #10
   15d7e:	4621      	mov	r1, r4
   15d80:	f811 3b01 	ldrb.w	r3, [r1], #1
   15d84:	3b30      	subs	r3, #48	; 0x30
   15d86:	2b09      	cmp	r3, #9
   15d88:	d94e      	bls.n	15e28 <_vfiprintf_r+0x1c4>
   15d8a:	b1b0      	cbz	r0, 15dba <_vfiprintf_r+0x156>
   15d8c:	9207      	str	r2, [sp, #28]
   15d8e:	e014      	b.n	15dba <_vfiprintf_r+0x156>
   15d90:	eba0 0308 	sub.w	r3, r0, r8
   15d94:	fa09 f303 	lsl.w	r3, r9, r3
   15d98:	4313      	orrs	r3, r2
   15d9a:	9304      	str	r3, [sp, #16]
   15d9c:	46a2      	mov	sl, r4
   15d9e:	e7d2      	b.n	15d46 <_vfiprintf_r+0xe2>
   15da0:	9b03      	ldr	r3, [sp, #12]
   15da2:	1d19      	adds	r1, r3, #4
   15da4:	681b      	ldr	r3, [r3, #0]
   15da6:	9103      	str	r1, [sp, #12]
   15da8:	2b00      	cmp	r3, #0
   15daa:	bfbb      	ittet	lt
   15dac:	425b      	neglt	r3, r3
   15dae:	f042 0202 	orrlt.w	r2, r2, #2
   15db2:	9307      	strge	r3, [sp, #28]
   15db4:	9307      	strlt	r3, [sp, #28]
   15db6:	bfb8      	it	lt
   15db8:	9204      	strlt	r2, [sp, #16]
   15dba:	7823      	ldrb	r3, [r4, #0]
   15dbc:	2b2e      	cmp	r3, #46	; 0x2e
   15dbe:	d10c      	bne.n	15dda <_vfiprintf_r+0x176>
   15dc0:	7863      	ldrb	r3, [r4, #1]
   15dc2:	2b2a      	cmp	r3, #42	; 0x2a
   15dc4:	d135      	bne.n	15e32 <_vfiprintf_r+0x1ce>
   15dc6:	9b03      	ldr	r3, [sp, #12]
   15dc8:	1d1a      	adds	r2, r3, #4
   15dca:	681b      	ldr	r3, [r3, #0]
   15dcc:	9203      	str	r2, [sp, #12]
   15dce:	2b00      	cmp	r3, #0
   15dd0:	bfb8      	it	lt
   15dd2:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
   15dd6:	3402      	adds	r4, #2
   15dd8:	9305      	str	r3, [sp, #20]
   15dda:	f8df a0e4 	ldr.w	sl, [pc, #228]	; 15ec0 <_vfiprintf_r+0x25c>
   15dde:	7821      	ldrb	r1, [r4, #0]
   15de0:	2203      	movs	r2, #3
   15de2:	4650      	mov	r0, sl
   15de4:	f000 faec 	bl	163c0 <memchr>
   15de8:	b140      	cbz	r0, 15dfc <_vfiprintf_r+0x198>
   15dea:	2340      	movs	r3, #64	; 0x40
   15dec:	eba0 000a 	sub.w	r0, r0, sl
   15df0:	fa03 f000 	lsl.w	r0, r3, r0
   15df4:	9b04      	ldr	r3, [sp, #16]
   15df6:	4303      	orrs	r3, r0
   15df8:	3401      	adds	r4, #1
   15dfa:	9304      	str	r3, [sp, #16]
   15dfc:	f814 1b01 	ldrb.w	r1, [r4], #1
   15e00:	482c      	ldr	r0, [pc, #176]	; (15eb4 <_vfiprintf_r+0x250>)
   15e02:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
   15e06:	2206      	movs	r2, #6
   15e08:	f000 fada 	bl	163c0 <memchr>
   15e0c:	2800      	cmp	r0, #0
   15e0e:	d03f      	beq.n	15e90 <_vfiprintf_r+0x22c>
   15e10:	4b29      	ldr	r3, [pc, #164]	; (15eb8 <_vfiprintf_r+0x254>)
   15e12:	bb1b      	cbnz	r3, 15e5c <_vfiprintf_r+0x1f8>
   15e14:	9b03      	ldr	r3, [sp, #12]
   15e16:	3307      	adds	r3, #7
   15e18:	f023 0307 	bic.w	r3, r3, #7
   15e1c:	3308      	adds	r3, #8
   15e1e:	9303      	str	r3, [sp, #12]
   15e20:	9b09      	ldr	r3, [sp, #36]	; 0x24
   15e22:	443b      	add	r3, r7
   15e24:	9309      	str	r3, [sp, #36]	; 0x24
   15e26:	e767      	b.n	15cf8 <_vfiprintf_r+0x94>
   15e28:	fb0c 3202 	mla	r2, ip, r2, r3
   15e2c:	460c      	mov	r4, r1
   15e2e:	2001      	movs	r0, #1
   15e30:	e7a5      	b.n	15d7e <_vfiprintf_r+0x11a>
   15e32:	2300      	movs	r3, #0
   15e34:	3401      	adds	r4, #1
   15e36:	9305      	str	r3, [sp, #20]
   15e38:	4619      	mov	r1, r3
   15e3a:	f04f 0c0a 	mov.w	ip, #10
   15e3e:	4620      	mov	r0, r4
   15e40:	f810 2b01 	ldrb.w	r2, [r0], #1
   15e44:	3a30      	subs	r2, #48	; 0x30
   15e46:	2a09      	cmp	r2, #9
   15e48:	d903      	bls.n	15e52 <_vfiprintf_r+0x1ee>
   15e4a:	2b00      	cmp	r3, #0
   15e4c:	d0c5      	beq.n	15dda <_vfiprintf_r+0x176>
   15e4e:	9105      	str	r1, [sp, #20]
   15e50:	e7c3      	b.n	15dda <_vfiprintf_r+0x176>
   15e52:	fb0c 2101 	mla	r1, ip, r1, r2
   15e56:	4604      	mov	r4, r0
   15e58:	2301      	movs	r3, #1
   15e5a:	e7f0      	b.n	15e3e <_vfiprintf_r+0x1da>
   15e5c:	ab03      	add	r3, sp, #12
   15e5e:	9300      	str	r3, [sp, #0]
   15e60:	462a      	mov	r2, r5
   15e62:	4b16      	ldr	r3, [pc, #88]	; (15ebc <_vfiprintf_r+0x258>)
   15e64:	a904      	add	r1, sp, #16
   15e66:	4630      	mov	r0, r6
   15e68:	f3af 8000 	nop.w
   15e6c:	4607      	mov	r7, r0
   15e6e:	1c78      	adds	r0, r7, #1
   15e70:	d1d6      	bne.n	15e20 <_vfiprintf_r+0x1bc>
   15e72:	6e6b      	ldr	r3, [r5, #100]	; 0x64
   15e74:	07d9      	lsls	r1, r3, #31
   15e76:	d405      	bmi.n	15e84 <_vfiprintf_r+0x220>
   15e78:	89ab      	ldrh	r3, [r5, #12]
   15e7a:	059a      	lsls	r2, r3, #22
   15e7c:	d402      	bmi.n	15e84 <_vfiprintf_r+0x220>
   15e7e:	6da8      	ldr	r0, [r5, #88]	; 0x58
   15e80:	f7ff fcfb 	bl	1587a <__retarget_lock_release_recursive>
   15e84:	89ab      	ldrh	r3, [r5, #12]
   15e86:	065b      	lsls	r3, r3, #25
   15e88:	f53f af12 	bmi.w	15cb0 <_vfiprintf_r+0x4c>
   15e8c:	9809      	ldr	r0, [sp, #36]	; 0x24
   15e8e:	e711      	b.n	15cb4 <_vfiprintf_r+0x50>
   15e90:	ab03      	add	r3, sp, #12
   15e92:	9300      	str	r3, [sp, #0]
   15e94:	462a      	mov	r2, r5
   15e96:	4b09      	ldr	r3, [pc, #36]	; (15ebc <_vfiprintf_r+0x258>)
   15e98:	a904      	add	r1, sp, #16
   15e9a:	4630      	mov	r0, r6
   15e9c:	f000 f880 	bl	15fa0 <_printf_i>
   15ea0:	e7e4      	b.n	15e6c <_vfiprintf_r+0x208>
   15ea2:	bf00      	nop
   15ea4:	000176c0 	.word	0x000176c0
   15ea8:	000176e0 	.word	0x000176e0
   15eac:	000176a0 	.word	0x000176a0
   15eb0:	00017700 	.word	0x00017700
   15eb4:	0001770a 	.word	0x0001770a
   15eb8:	00000000 	.word	0x00000000
   15ebc:	00015c3f 	.word	0x00015c3f
   15ec0:	00017706 	.word	0x00017706

00015ec4 <_printf_common>:
   15ec4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   15ec8:	4616      	mov	r6, r2
   15eca:	4699      	mov	r9, r3
   15ecc:	688a      	ldr	r2, [r1, #8]
   15ece:	690b      	ldr	r3, [r1, #16]
   15ed0:	f8dd 8020 	ldr.w	r8, [sp, #32]
   15ed4:	4293      	cmp	r3, r2
   15ed6:	bfb8      	it	lt
   15ed8:	4613      	movlt	r3, r2
   15eda:	6033      	str	r3, [r6, #0]
   15edc:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
   15ee0:	4607      	mov	r7, r0
   15ee2:	460c      	mov	r4, r1
   15ee4:	b10a      	cbz	r2, 15eea <_printf_common+0x26>
   15ee6:	3301      	adds	r3, #1
   15ee8:	6033      	str	r3, [r6, #0]
   15eea:	6823      	ldr	r3, [r4, #0]
   15eec:	0699      	lsls	r1, r3, #26
   15eee:	bf42      	ittt	mi
   15ef0:	6833      	ldrmi	r3, [r6, #0]
   15ef2:	3302      	addmi	r3, #2
   15ef4:	6033      	strmi	r3, [r6, #0]
   15ef6:	6825      	ldr	r5, [r4, #0]
   15ef8:	f015 0506 	ands.w	r5, r5, #6
   15efc:	d106      	bne.n	15f0c <_printf_common+0x48>
   15efe:	f104 0a19 	add.w	sl, r4, #25
   15f02:	68e3      	ldr	r3, [r4, #12]
   15f04:	6832      	ldr	r2, [r6, #0]
   15f06:	1a9b      	subs	r3, r3, r2
   15f08:	42ab      	cmp	r3, r5
   15f0a:	dc26      	bgt.n	15f5a <_printf_common+0x96>
   15f0c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
   15f10:	1e13      	subs	r3, r2, #0
   15f12:	6822      	ldr	r2, [r4, #0]
   15f14:	bf18      	it	ne
   15f16:	2301      	movne	r3, #1
   15f18:	0692      	lsls	r2, r2, #26
   15f1a:	d42b      	bmi.n	15f74 <_printf_common+0xb0>
   15f1c:	f104 0243 	add.w	r2, r4, #67	; 0x43
   15f20:	4649      	mov	r1, r9
   15f22:	4638      	mov	r0, r7
   15f24:	47c0      	blx	r8
   15f26:	3001      	adds	r0, #1
   15f28:	d01e      	beq.n	15f68 <_printf_common+0xa4>
   15f2a:	6823      	ldr	r3, [r4, #0]
   15f2c:	68e5      	ldr	r5, [r4, #12]
   15f2e:	6832      	ldr	r2, [r6, #0]
   15f30:	f003 0306 	and.w	r3, r3, #6
   15f34:	2b04      	cmp	r3, #4
   15f36:	bf08      	it	eq
   15f38:	1aad      	subeq	r5, r5, r2
   15f3a:	68a3      	ldr	r3, [r4, #8]
   15f3c:	6922      	ldr	r2, [r4, #16]
   15f3e:	bf0c      	ite	eq
   15f40:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
   15f44:	2500      	movne	r5, #0
   15f46:	4293      	cmp	r3, r2
   15f48:	bfc4      	itt	gt
   15f4a:	1a9b      	subgt	r3, r3, r2
   15f4c:	18ed      	addgt	r5, r5, r3
   15f4e:	2600      	movs	r6, #0
   15f50:	341a      	adds	r4, #26
   15f52:	42b5      	cmp	r5, r6
   15f54:	d11a      	bne.n	15f8c <_printf_common+0xc8>
   15f56:	2000      	movs	r0, #0
   15f58:	e008      	b.n	15f6c <_printf_common+0xa8>
   15f5a:	2301      	movs	r3, #1
   15f5c:	4652      	mov	r2, sl
   15f5e:	4649      	mov	r1, r9
   15f60:	4638      	mov	r0, r7
   15f62:	47c0      	blx	r8
   15f64:	3001      	adds	r0, #1
   15f66:	d103      	bne.n	15f70 <_printf_common+0xac>
   15f68:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   15f6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   15f70:	3501      	adds	r5, #1
   15f72:	e7c6      	b.n	15f02 <_printf_common+0x3e>
   15f74:	18e1      	adds	r1, r4, r3
   15f76:	1c5a      	adds	r2, r3, #1
   15f78:	2030      	movs	r0, #48	; 0x30
   15f7a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
   15f7e:	4422      	add	r2, r4
   15f80:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
   15f84:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
   15f88:	3302      	adds	r3, #2
   15f8a:	e7c7      	b.n	15f1c <_printf_common+0x58>
   15f8c:	2301      	movs	r3, #1
   15f8e:	4622      	mov	r2, r4
   15f90:	4649      	mov	r1, r9
   15f92:	4638      	mov	r0, r7
   15f94:	47c0      	blx	r8
   15f96:	3001      	adds	r0, #1
   15f98:	d0e6      	beq.n	15f68 <_printf_common+0xa4>
   15f9a:	3601      	adds	r6, #1
   15f9c:	e7d9      	b.n	15f52 <_printf_common+0x8e>
	...

00015fa0 <_printf_i>:
   15fa0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
   15fa4:	460c      	mov	r4, r1
   15fa6:	4691      	mov	r9, r2
   15fa8:	7e27      	ldrb	r7, [r4, #24]
   15faa:	990c      	ldr	r1, [sp, #48]	; 0x30
   15fac:	2f78      	cmp	r7, #120	; 0x78
   15fae:	4680      	mov	r8, r0
   15fb0:	469a      	mov	sl, r3
   15fb2:	f104 0243 	add.w	r2, r4, #67	; 0x43
   15fb6:	d807      	bhi.n	15fc8 <_printf_i+0x28>
   15fb8:	2f62      	cmp	r7, #98	; 0x62
   15fba:	d80a      	bhi.n	15fd2 <_printf_i+0x32>
   15fbc:	2f00      	cmp	r7, #0
   15fbe:	f000 80d8 	beq.w	16172 <_printf_i+0x1d2>
   15fc2:	2f58      	cmp	r7, #88	; 0x58
   15fc4:	f000 80a3 	beq.w	1610e <_printf_i+0x16e>
   15fc8:	f104 0642 	add.w	r6, r4, #66	; 0x42
   15fcc:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
   15fd0:	e03a      	b.n	16048 <_printf_i+0xa8>
   15fd2:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
   15fd6:	2b15      	cmp	r3, #21
   15fd8:	d8f6      	bhi.n	15fc8 <_printf_i+0x28>
   15fda:	a001      	add	r0, pc, #4	; (adr r0, 15fe0 <_printf_i+0x40>)
   15fdc:	f850 f023 	ldr.w	pc, [r0, r3, lsl #2]
   15fe0:	00016039 	.word	0x00016039
   15fe4:	0001604d 	.word	0x0001604d
   15fe8:	00015fc9 	.word	0x00015fc9
   15fec:	00015fc9 	.word	0x00015fc9
   15ff0:	00015fc9 	.word	0x00015fc9
   15ff4:	00015fc9 	.word	0x00015fc9
   15ff8:	0001604d 	.word	0x0001604d
   15ffc:	00015fc9 	.word	0x00015fc9
   16000:	00015fc9 	.word	0x00015fc9
   16004:	00015fc9 	.word	0x00015fc9
   16008:	00015fc9 	.word	0x00015fc9
   1600c:	00016159 	.word	0x00016159
   16010:	0001607d 	.word	0x0001607d
   16014:	0001613b 	.word	0x0001613b
   16018:	00015fc9 	.word	0x00015fc9
   1601c:	00015fc9 	.word	0x00015fc9
   16020:	0001617b 	.word	0x0001617b
   16024:	00015fc9 	.word	0x00015fc9
   16028:	0001607d 	.word	0x0001607d
   1602c:	00015fc9 	.word	0x00015fc9
   16030:	00015fc9 	.word	0x00015fc9
   16034:	00016143 	.word	0x00016143
   16038:	680b      	ldr	r3, [r1, #0]
   1603a:	1d1a      	adds	r2, r3, #4
   1603c:	681b      	ldr	r3, [r3, #0]
   1603e:	600a      	str	r2, [r1, #0]
   16040:	f104 0642 	add.w	r6, r4, #66	; 0x42
   16044:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
   16048:	2301      	movs	r3, #1
   1604a:	e0a3      	b.n	16194 <_printf_i+0x1f4>
   1604c:	6825      	ldr	r5, [r4, #0]
   1604e:	6808      	ldr	r0, [r1, #0]
   16050:	062e      	lsls	r6, r5, #24
   16052:	f100 0304 	add.w	r3, r0, #4
   16056:	d50a      	bpl.n	1606e <_printf_i+0xce>
   16058:	6805      	ldr	r5, [r0, #0]
   1605a:	600b      	str	r3, [r1, #0]
   1605c:	2d00      	cmp	r5, #0
   1605e:	da03      	bge.n	16068 <_printf_i+0xc8>
   16060:	232d      	movs	r3, #45	; 0x2d
   16062:	426d      	negs	r5, r5
   16064:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   16068:	485e      	ldr	r0, [pc, #376]	; (161e4 <_printf_i+0x244>)
   1606a:	230a      	movs	r3, #10
   1606c:	e019      	b.n	160a2 <_printf_i+0x102>
   1606e:	f015 0f40 	tst.w	r5, #64	; 0x40
   16072:	6805      	ldr	r5, [r0, #0]
   16074:	600b      	str	r3, [r1, #0]
   16076:	bf18      	it	ne
   16078:	b22d      	sxthne	r5, r5
   1607a:	e7ef      	b.n	1605c <_printf_i+0xbc>
   1607c:	680b      	ldr	r3, [r1, #0]
   1607e:	6825      	ldr	r5, [r4, #0]
   16080:	1d18      	adds	r0, r3, #4
   16082:	6008      	str	r0, [r1, #0]
   16084:	0628      	lsls	r0, r5, #24
   16086:	d501      	bpl.n	1608c <_printf_i+0xec>
   16088:	681d      	ldr	r5, [r3, #0]
   1608a:	e002      	b.n	16092 <_printf_i+0xf2>
   1608c:	0669      	lsls	r1, r5, #25
   1608e:	d5fb      	bpl.n	16088 <_printf_i+0xe8>
   16090:	881d      	ldrh	r5, [r3, #0]
   16092:	4854      	ldr	r0, [pc, #336]	; (161e4 <_printf_i+0x244>)
   16094:	2f6f      	cmp	r7, #111	; 0x6f
   16096:	bf0c      	ite	eq
   16098:	2308      	moveq	r3, #8
   1609a:	230a      	movne	r3, #10
   1609c:	2100      	movs	r1, #0
   1609e:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
   160a2:	6866      	ldr	r6, [r4, #4]
   160a4:	60a6      	str	r6, [r4, #8]
   160a6:	2e00      	cmp	r6, #0
   160a8:	bfa2      	ittt	ge
   160aa:	6821      	ldrge	r1, [r4, #0]
   160ac:	f021 0104 	bicge.w	r1, r1, #4
   160b0:	6021      	strge	r1, [r4, #0]
   160b2:	b90d      	cbnz	r5, 160b8 <_printf_i+0x118>
   160b4:	2e00      	cmp	r6, #0
   160b6:	d04d      	beq.n	16154 <_printf_i+0x1b4>
   160b8:	4616      	mov	r6, r2
   160ba:	fbb5 f1f3 	udiv	r1, r5, r3
   160be:	fb03 5711 	mls	r7, r3, r1, r5
   160c2:	5dc7      	ldrb	r7, [r0, r7]
   160c4:	f806 7d01 	strb.w	r7, [r6, #-1]!
   160c8:	462f      	mov	r7, r5
   160ca:	42bb      	cmp	r3, r7
   160cc:	460d      	mov	r5, r1
   160ce:	d9f4      	bls.n	160ba <_printf_i+0x11a>
   160d0:	2b08      	cmp	r3, #8
   160d2:	d10b      	bne.n	160ec <_printf_i+0x14c>
   160d4:	6823      	ldr	r3, [r4, #0]
   160d6:	07df      	lsls	r7, r3, #31
   160d8:	d508      	bpl.n	160ec <_printf_i+0x14c>
   160da:	6923      	ldr	r3, [r4, #16]
   160dc:	6861      	ldr	r1, [r4, #4]
   160de:	4299      	cmp	r1, r3
   160e0:	bfde      	ittt	le
   160e2:	2330      	movle	r3, #48	; 0x30
   160e4:	f806 3c01 	strble.w	r3, [r6, #-1]
   160e8:	f106 36ff 	addle.w	r6, r6, #4294967295	; 0xffffffff
   160ec:	1b92      	subs	r2, r2, r6
   160ee:	6122      	str	r2, [r4, #16]
   160f0:	f8cd a000 	str.w	sl, [sp]
   160f4:	464b      	mov	r3, r9
   160f6:	aa03      	add	r2, sp, #12
   160f8:	4621      	mov	r1, r4
   160fa:	4640      	mov	r0, r8
   160fc:	f7ff fee2 	bl	15ec4 <_printf_common>
   16100:	3001      	adds	r0, #1
   16102:	d14c      	bne.n	1619e <_printf_i+0x1fe>
   16104:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   16108:	b004      	add	sp, #16
   1610a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1610e:	4835      	ldr	r0, [pc, #212]	; (161e4 <_printf_i+0x244>)
   16110:	f884 7045 	strb.w	r7, [r4, #69]	; 0x45
   16114:	6823      	ldr	r3, [r4, #0]
   16116:	680e      	ldr	r6, [r1, #0]
   16118:	061f      	lsls	r7, r3, #24
   1611a:	f856 5b04 	ldr.w	r5, [r6], #4
   1611e:	600e      	str	r6, [r1, #0]
   16120:	d514      	bpl.n	1614c <_printf_i+0x1ac>
   16122:	07d9      	lsls	r1, r3, #31
   16124:	bf44      	itt	mi
   16126:	f043 0320 	orrmi.w	r3, r3, #32
   1612a:	6023      	strmi	r3, [r4, #0]
   1612c:	b91d      	cbnz	r5, 16136 <_printf_i+0x196>
   1612e:	6823      	ldr	r3, [r4, #0]
   16130:	f023 0320 	bic.w	r3, r3, #32
   16134:	6023      	str	r3, [r4, #0]
   16136:	2310      	movs	r3, #16
   16138:	e7b0      	b.n	1609c <_printf_i+0xfc>
   1613a:	6823      	ldr	r3, [r4, #0]
   1613c:	f043 0320 	orr.w	r3, r3, #32
   16140:	6023      	str	r3, [r4, #0]
   16142:	2378      	movs	r3, #120	; 0x78
   16144:	4828      	ldr	r0, [pc, #160]	; (161e8 <_printf_i+0x248>)
   16146:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
   1614a:	e7e3      	b.n	16114 <_printf_i+0x174>
   1614c:	065e      	lsls	r6, r3, #25
   1614e:	bf48      	it	mi
   16150:	b2ad      	uxthmi	r5, r5
   16152:	e7e6      	b.n	16122 <_printf_i+0x182>
   16154:	4616      	mov	r6, r2
   16156:	e7bb      	b.n	160d0 <_printf_i+0x130>
   16158:	680b      	ldr	r3, [r1, #0]
   1615a:	6826      	ldr	r6, [r4, #0]
   1615c:	6960      	ldr	r0, [r4, #20]
   1615e:	1d1d      	adds	r5, r3, #4
   16160:	600d      	str	r5, [r1, #0]
   16162:	0635      	lsls	r5, r6, #24
   16164:	681b      	ldr	r3, [r3, #0]
   16166:	d501      	bpl.n	1616c <_printf_i+0x1cc>
   16168:	6018      	str	r0, [r3, #0]
   1616a:	e002      	b.n	16172 <_printf_i+0x1d2>
   1616c:	0671      	lsls	r1, r6, #25
   1616e:	d5fb      	bpl.n	16168 <_printf_i+0x1c8>
   16170:	8018      	strh	r0, [r3, #0]
   16172:	2300      	movs	r3, #0
   16174:	6123      	str	r3, [r4, #16]
   16176:	4616      	mov	r6, r2
   16178:	e7ba      	b.n	160f0 <_printf_i+0x150>
   1617a:	680b      	ldr	r3, [r1, #0]
   1617c:	1d1a      	adds	r2, r3, #4
   1617e:	600a      	str	r2, [r1, #0]
   16180:	681e      	ldr	r6, [r3, #0]
   16182:	6862      	ldr	r2, [r4, #4]
   16184:	2100      	movs	r1, #0
   16186:	4630      	mov	r0, r6
   16188:	f000 f91a 	bl	163c0 <memchr>
   1618c:	b108      	cbz	r0, 16192 <_printf_i+0x1f2>
   1618e:	1b80      	subs	r0, r0, r6
   16190:	6060      	str	r0, [r4, #4]
   16192:	6863      	ldr	r3, [r4, #4]
   16194:	6123      	str	r3, [r4, #16]
   16196:	2300      	movs	r3, #0
   16198:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
   1619c:	e7a8      	b.n	160f0 <_printf_i+0x150>
   1619e:	6923      	ldr	r3, [r4, #16]
   161a0:	4632      	mov	r2, r6
   161a2:	4649      	mov	r1, r9
   161a4:	4640      	mov	r0, r8
   161a6:	47d0      	blx	sl
   161a8:	3001      	adds	r0, #1
   161aa:	d0ab      	beq.n	16104 <_printf_i+0x164>
   161ac:	6823      	ldr	r3, [r4, #0]
   161ae:	079b      	lsls	r3, r3, #30
   161b0:	d413      	bmi.n	161da <_printf_i+0x23a>
   161b2:	68e0      	ldr	r0, [r4, #12]
   161b4:	9b03      	ldr	r3, [sp, #12]
   161b6:	4298      	cmp	r0, r3
   161b8:	bfb8      	it	lt
   161ba:	4618      	movlt	r0, r3
   161bc:	e7a4      	b.n	16108 <_printf_i+0x168>
   161be:	2301      	movs	r3, #1
   161c0:	4632      	mov	r2, r6
   161c2:	4649      	mov	r1, r9
   161c4:	4640      	mov	r0, r8
   161c6:	47d0      	blx	sl
   161c8:	3001      	adds	r0, #1
   161ca:	d09b      	beq.n	16104 <_printf_i+0x164>
   161cc:	3501      	adds	r5, #1
   161ce:	68e3      	ldr	r3, [r4, #12]
   161d0:	9903      	ldr	r1, [sp, #12]
   161d2:	1a5b      	subs	r3, r3, r1
   161d4:	42ab      	cmp	r3, r5
   161d6:	dcf2      	bgt.n	161be <_printf_i+0x21e>
   161d8:	e7eb      	b.n	161b2 <_printf_i+0x212>
   161da:	2500      	movs	r5, #0
   161dc:	f104 0619 	add.w	r6, r4, #25
   161e0:	e7f5      	b.n	161ce <_printf_i+0x22e>
   161e2:	bf00      	nop
   161e4:	00017711 	.word	0x00017711
   161e8:	00017722 	.word	0x00017722

000161ec <_putc_r>:
   161ec:	b570      	push	{r4, r5, r6, lr}
   161ee:	460d      	mov	r5, r1
   161f0:	4614      	mov	r4, r2
   161f2:	4606      	mov	r6, r0
   161f4:	b118      	cbz	r0, 161fe <_putc_r+0x12>
   161f6:	6983      	ldr	r3, [r0, #24]
   161f8:	b90b      	cbnz	r3, 161fe <_putc_r+0x12>
   161fa:	f7ff fa8d 	bl	15718 <__sinit>
   161fe:	4b1c      	ldr	r3, [pc, #112]	; (16270 <_putc_r+0x84>)
   16200:	429c      	cmp	r4, r3
   16202:	d124      	bne.n	1624e <_putc_r+0x62>
   16204:	6874      	ldr	r4, [r6, #4]
   16206:	6e63      	ldr	r3, [r4, #100]	; 0x64
   16208:	07d8      	lsls	r0, r3, #31
   1620a:	d405      	bmi.n	16218 <_putc_r+0x2c>
   1620c:	89a3      	ldrh	r3, [r4, #12]
   1620e:	0599      	lsls	r1, r3, #22
   16210:	d402      	bmi.n	16218 <_putc_r+0x2c>
   16212:	6da0      	ldr	r0, [r4, #88]	; 0x58
   16214:	f7ff fb30 	bl	15878 <__retarget_lock_acquire_recursive>
   16218:	68a3      	ldr	r3, [r4, #8]
   1621a:	3b01      	subs	r3, #1
   1621c:	2b00      	cmp	r3, #0
   1621e:	60a3      	str	r3, [r4, #8]
   16220:	da05      	bge.n	1622e <_putc_r+0x42>
   16222:	69a2      	ldr	r2, [r4, #24]
   16224:	4293      	cmp	r3, r2
   16226:	db1c      	blt.n	16262 <_putc_r+0x76>
   16228:	b2eb      	uxtb	r3, r5
   1622a:	2b0a      	cmp	r3, #10
   1622c:	d019      	beq.n	16262 <_putc_r+0x76>
   1622e:	6823      	ldr	r3, [r4, #0]
   16230:	1c5a      	adds	r2, r3, #1
   16232:	6022      	str	r2, [r4, #0]
   16234:	701d      	strb	r5, [r3, #0]
   16236:	b2ed      	uxtb	r5, r5
   16238:	6e63      	ldr	r3, [r4, #100]	; 0x64
   1623a:	07da      	lsls	r2, r3, #31
   1623c:	d405      	bmi.n	1624a <_putc_r+0x5e>
   1623e:	89a3      	ldrh	r3, [r4, #12]
   16240:	059b      	lsls	r3, r3, #22
   16242:	d402      	bmi.n	1624a <_putc_r+0x5e>
   16244:	6da0      	ldr	r0, [r4, #88]	; 0x58
   16246:	f7ff fb18 	bl	1587a <__retarget_lock_release_recursive>
   1624a:	4628      	mov	r0, r5
   1624c:	bd70      	pop	{r4, r5, r6, pc}
   1624e:	4b09      	ldr	r3, [pc, #36]	; (16274 <_putc_r+0x88>)
   16250:	429c      	cmp	r4, r3
   16252:	d101      	bne.n	16258 <_putc_r+0x6c>
   16254:	68b4      	ldr	r4, [r6, #8]
   16256:	e7d6      	b.n	16206 <_putc_r+0x1a>
   16258:	4b07      	ldr	r3, [pc, #28]	; (16278 <_putc_r+0x8c>)
   1625a:	429c      	cmp	r4, r3
   1625c:	bf08      	it	eq
   1625e:	68f4      	ldreq	r4, [r6, #12]
   16260:	e7d1      	b.n	16206 <_putc_r+0x1a>
   16262:	4629      	mov	r1, r5
   16264:	4622      	mov	r2, r4
   16266:	4630      	mov	r0, r6
   16268:	f7ff f85e 	bl	15328 <__swbuf_r>
   1626c:	4605      	mov	r5, r0
   1626e:	e7e3      	b.n	16238 <_putc_r+0x4c>
   16270:	000176c0 	.word	0x000176c0
   16274:	000176e0 	.word	0x000176e0
   16278:	000176a0 	.word	0x000176a0

0001627c <__sread>:
   1627c:	b510      	push	{r4, lr}
   1627e:	460c      	mov	r4, r1
   16280:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   16284:	f000 f92c 	bl	164e0 <_read_r>
   16288:	2800      	cmp	r0, #0
   1628a:	bfab      	itete	ge
   1628c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
   1628e:	89a3      	ldrhlt	r3, [r4, #12]
   16290:	181b      	addge	r3, r3, r0
   16292:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
   16296:	bfac      	ite	ge
   16298:	6563      	strge	r3, [r4, #84]	; 0x54
   1629a:	81a3      	strhlt	r3, [r4, #12]
   1629c:	bd10      	pop	{r4, pc}

0001629e <__swrite>:
   1629e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   162a2:	461f      	mov	r7, r3
   162a4:	898b      	ldrh	r3, [r1, #12]
   162a6:	05db      	lsls	r3, r3, #23
   162a8:	4605      	mov	r5, r0
   162aa:	460c      	mov	r4, r1
   162ac:	4616      	mov	r6, r2
   162ae:	d505      	bpl.n	162bc <__swrite+0x1e>
   162b0:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   162b4:	2302      	movs	r3, #2
   162b6:	2200      	movs	r2, #0
   162b8:	f000 f870 	bl	1639c <_lseek_r>
   162bc:	89a3      	ldrh	r3, [r4, #12]
   162be:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
   162c2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
   162c6:	81a3      	strh	r3, [r4, #12]
   162c8:	4632      	mov	r2, r6
   162ca:	463b      	mov	r3, r7
   162cc:	4628      	mov	r0, r5
   162ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   162d2:	f000 b817 	b.w	16304 <_write_r>

000162d6 <__sseek>:
   162d6:	b510      	push	{r4, lr}
   162d8:	460c      	mov	r4, r1
   162da:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   162de:	f000 f85d 	bl	1639c <_lseek_r>
   162e2:	1c43      	adds	r3, r0, #1
   162e4:	89a3      	ldrh	r3, [r4, #12]
   162e6:	bf15      	itete	ne
   162e8:	6560      	strne	r0, [r4, #84]	; 0x54
   162ea:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
   162ee:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
   162f2:	81a3      	strheq	r3, [r4, #12]
   162f4:	bf18      	it	ne
   162f6:	81a3      	strhne	r3, [r4, #12]
   162f8:	bd10      	pop	{r4, pc}

000162fa <__sclose>:
   162fa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
   162fe:	f000 b81b 	b.w	16338 <_close_r>
	...

00016304 <_write_r>:
   16304:	b538      	push	{r3, r4, r5, lr}
   16306:	4d07      	ldr	r5, [pc, #28]	; (16324 <_write_r+0x20>)
   16308:	4604      	mov	r4, r0
   1630a:	4608      	mov	r0, r1
   1630c:	4611      	mov	r1, r2
   1630e:	2200      	movs	r2, #0
   16310:	602a      	str	r2, [r5, #0]
   16312:	461a      	mov	r2, r3
   16314:	f7f6 f838 	bl	c388 <_write>
   16318:	1c43      	adds	r3, r0, #1
   1631a:	d102      	bne.n	16322 <_write_r+0x1e>
   1631c:	682b      	ldr	r3, [r5, #0]
   1631e:	b103      	cbz	r3, 16322 <_write_r+0x1e>
   16320:	6023      	str	r3, [r4, #0]
   16322:	bd38      	pop	{r3, r4, r5, pc}
   16324:	2001cfe0 	.word	0x2001cfe0

00016328 <abort>:
   16328:	b508      	push	{r3, lr}
   1632a:	2006      	movs	r0, #6
   1632c:	f000 f912 	bl	16554 <raise>
   16330:	2001      	movs	r0, #1
   16332:	f7f6 fa0d 	bl	c750 <_exit>
	...

00016338 <_close_r>:
   16338:	b538      	push	{r3, r4, r5, lr}
   1633a:	4d06      	ldr	r5, [pc, #24]	; (16354 <_close_r+0x1c>)
   1633c:	2300      	movs	r3, #0
   1633e:	4604      	mov	r4, r0
   16340:	4608      	mov	r0, r1
   16342:	602b      	str	r3, [r5, #0]
   16344:	f7f6 f9f8 	bl	c738 <_close>
   16348:	1c43      	adds	r3, r0, #1
   1634a:	d102      	bne.n	16352 <_close_r+0x1a>
   1634c:	682b      	ldr	r3, [r5, #0]
   1634e:	b103      	cbz	r3, 16352 <_close_r+0x1a>
   16350:	6023      	str	r3, [r4, #0]
   16352:	bd38      	pop	{r3, r4, r5, pc}
   16354:	2001cfe0 	.word	0x2001cfe0

00016358 <_fstat_r>:
   16358:	b538      	push	{r3, r4, r5, lr}
   1635a:	4d07      	ldr	r5, [pc, #28]	; (16378 <_fstat_r+0x20>)
   1635c:	2300      	movs	r3, #0
   1635e:	4604      	mov	r4, r0
   16360:	4608      	mov	r0, r1
   16362:	4611      	mov	r1, r2
   16364:	602b      	str	r3, [r5, #0]
   16366:	f7f6 f9ea 	bl	c73e <_fstat>
   1636a:	1c43      	adds	r3, r0, #1
   1636c:	d102      	bne.n	16374 <_fstat_r+0x1c>
   1636e:	682b      	ldr	r3, [r5, #0]
   16370:	b103      	cbz	r3, 16374 <_fstat_r+0x1c>
   16372:	6023      	str	r3, [r4, #0]
   16374:	bd38      	pop	{r3, r4, r5, pc}
   16376:	bf00      	nop
   16378:	2001cfe0 	.word	0x2001cfe0

0001637c <_isatty_r>:
   1637c:	b538      	push	{r3, r4, r5, lr}
   1637e:	4d06      	ldr	r5, [pc, #24]	; (16398 <_isatty_r+0x1c>)
   16380:	2300      	movs	r3, #0
   16382:	4604      	mov	r4, r0
   16384:	4608      	mov	r0, r1
   16386:	602b      	str	r3, [r5, #0]
   16388:	f7f6 f9de 	bl	c748 <_isatty>
   1638c:	1c43      	adds	r3, r0, #1
   1638e:	d102      	bne.n	16396 <_isatty_r+0x1a>
   16390:	682b      	ldr	r3, [r5, #0]
   16392:	b103      	cbz	r3, 16396 <_isatty_r+0x1a>
   16394:	6023      	str	r3, [r4, #0]
   16396:	bd38      	pop	{r3, r4, r5, pc}
   16398:	2001cfe0 	.word	0x2001cfe0

0001639c <_lseek_r>:
   1639c:	b538      	push	{r3, r4, r5, lr}
   1639e:	4d07      	ldr	r5, [pc, #28]	; (163bc <_lseek_r+0x20>)
   163a0:	4604      	mov	r4, r0
   163a2:	4608      	mov	r0, r1
   163a4:	4611      	mov	r1, r2
   163a6:	2200      	movs	r2, #0
   163a8:	602a      	str	r2, [r5, #0]
   163aa:	461a      	mov	r2, r3
   163ac:	f7f6 f9ce 	bl	c74c <_lseek>
   163b0:	1c43      	adds	r3, r0, #1
   163b2:	d102      	bne.n	163ba <_lseek_r+0x1e>
   163b4:	682b      	ldr	r3, [r5, #0]
   163b6:	b103      	cbz	r3, 163ba <_lseek_r+0x1e>
   163b8:	6023      	str	r3, [r4, #0]
   163ba:	bd38      	pop	{r3, r4, r5, pc}
   163bc:	2001cfe0 	.word	0x2001cfe0

000163c0 <memchr>:
   163c0:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   163c4:	2a10      	cmp	r2, #16
   163c6:	db2b      	blt.n	16420 <memchr+0x60>
   163c8:	f010 0f07 	tst.w	r0, #7
   163cc:	d008      	beq.n	163e0 <memchr+0x20>
   163ce:	f810 3b01 	ldrb.w	r3, [r0], #1
   163d2:	3a01      	subs	r2, #1
   163d4:	428b      	cmp	r3, r1
   163d6:	d02d      	beq.n	16434 <memchr+0x74>
   163d8:	f010 0f07 	tst.w	r0, #7
   163dc:	b342      	cbz	r2, 16430 <memchr+0x70>
   163de:	d1f6      	bne.n	163ce <memchr+0xe>
   163e0:	b4f0      	push	{r4, r5, r6, r7}
   163e2:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
   163e6:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
   163ea:	f022 0407 	bic.w	r4, r2, #7
   163ee:	f07f 0700 	mvns.w	r7, #0
   163f2:	2300      	movs	r3, #0
   163f4:	e8f0 5602 	ldrd	r5, r6, [r0], #8
   163f8:	3c08      	subs	r4, #8
   163fa:	ea85 0501 	eor.w	r5, r5, r1
   163fe:	ea86 0601 	eor.w	r6, r6, r1
   16402:	fa85 f547 	uadd8	r5, r5, r7
   16406:	faa3 f587 	sel	r5, r3, r7
   1640a:	fa86 f647 	uadd8	r6, r6, r7
   1640e:	faa5 f687 	sel	r6, r5, r7
   16412:	b98e      	cbnz	r6, 16438 <memchr+0x78>
   16414:	d1ee      	bne.n	163f4 <memchr+0x34>
   16416:	bcf0      	pop	{r4, r5, r6, r7}
   16418:	f001 01ff 	and.w	r1, r1, #255	; 0xff
   1641c:	f002 0207 	and.w	r2, r2, #7
   16420:	b132      	cbz	r2, 16430 <memchr+0x70>
   16422:	f810 3b01 	ldrb.w	r3, [r0], #1
   16426:	3a01      	subs	r2, #1
   16428:	ea83 0301 	eor.w	r3, r3, r1
   1642c:	b113      	cbz	r3, 16434 <memchr+0x74>
   1642e:	d1f8      	bne.n	16422 <memchr+0x62>
   16430:	2000      	movs	r0, #0
   16432:	4770      	bx	lr
   16434:	3801      	subs	r0, #1
   16436:	4770      	bx	lr
   16438:	2d00      	cmp	r5, #0
   1643a:	bf06      	itte	eq
   1643c:	4635      	moveq	r5, r6
   1643e:	3803      	subeq	r0, #3
   16440:	3807      	subne	r0, #7
   16442:	f015 0f01 	tst.w	r5, #1
   16446:	d107      	bne.n	16458 <memchr+0x98>
   16448:	3001      	adds	r0, #1
   1644a:	f415 7f80 	tst.w	r5, #256	; 0x100
   1644e:	bf02      	ittt	eq
   16450:	3001      	addeq	r0, #1
   16452:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
   16456:	3001      	addeq	r0, #1
   16458:	bcf0      	pop	{r4, r5, r6, r7}
   1645a:	3801      	subs	r0, #1
   1645c:	4770      	bx	lr
   1645e:	bf00      	nop

00016460 <memmove>:
   16460:	4288      	cmp	r0, r1
   16462:	b510      	push	{r4, lr}
   16464:	eb01 0402 	add.w	r4, r1, r2
   16468:	d902      	bls.n	16470 <memmove+0x10>
   1646a:	4284      	cmp	r4, r0
   1646c:	4623      	mov	r3, r4
   1646e:	d807      	bhi.n	16480 <memmove+0x20>
   16470:	1e43      	subs	r3, r0, #1
   16472:	42a1      	cmp	r1, r4
   16474:	d008      	beq.n	16488 <memmove+0x28>
   16476:	f811 2b01 	ldrb.w	r2, [r1], #1
   1647a:	f803 2f01 	strb.w	r2, [r3, #1]!
   1647e:	e7f8      	b.n	16472 <memmove+0x12>
   16480:	4402      	add	r2, r0
   16482:	4601      	mov	r1, r0
   16484:	428a      	cmp	r2, r1
   16486:	d100      	bne.n	1648a <memmove+0x2a>
   16488:	bd10      	pop	{r4, pc}
   1648a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
   1648e:	f802 4d01 	strb.w	r4, [r2, #-1]!
   16492:	e7f7      	b.n	16484 <memmove+0x24>

00016494 <_realloc_r>:
   16494:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   16496:	4607      	mov	r7, r0
   16498:	4614      	mov	r4, r2
   1649a:	460e      	mov	r6, r1
   1649c:	b921      	cbnz	r1, 164a8 <_realloc_r+0x14>
   1649e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   164a2:	4611      	mov	r1, r2
   164a4:	f7fe bcaa 	b.w	14dfc <_malloc_r>
   164a8:	b922      	cbnz	r2, 164b4 <_realloc_r+0x20>
   164aa:	f7fe fc59 	bl	14d60 <_free_r>
   164ae:	4625      	mov	r5, r4
   164b0:	4628      	mov	r0, r5
   164b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   164b4:	f000 f86a 	bl	1658c <_malloc_usable_size_r>
   164b8:	42a0      	cmp	r0, r4
   164ba:	d20f      	bcs.n	164dc <_realloc_r+0x48>
   164bc:	4621      	mov	r1, r4
   164be:	4638      	mov	r0, r7
   164c0:	f7fe fc9c 	bl	14dfc <_malloc_r>
   164c4:	4605      	mov	r5, r0
   164c6:	2800      	cmp	r0, #0
   164c8:	d0f2      	beq.n	164b0 <_realloc_r+0x1c>
   164ca:	4631      	mov	r1, r6
   164cc:	4622      	mov	r2, r4
   164ce:	f7fe fc31 	bl	14d34 <memcpy>
   164d2:	4631      	mov	r1, r6
   164d4:	4638      	mov	r0, r7
   164d6:	f7fe fc43 	bl	14d60 <_free_r>
   164da:	e7e9      	b.n	164b0 <_realloc_r+0x1c>
   164dc:	4635      	mov	r5, r6
   164de:	e7e7      	b.n	164b0 <_realloc_r+0x1c>

000164e0 <_read_r>:
   164e0:	b538      	push	{r3, r4, r5, lr}
   164e2:	4d07      	ldr	r5, [pc, #28]	; (16500 <_read_r+0x20>)
   164e4:	4604      	mov	r4, r0
   164e6:	4608      	mov	r0, r1
   164e8:	4611      	mov	r1, r2
   164ea:	2200      	movs	r2, #0
   164ec:	602a      	str	r2, [r5, #0]
   164ee:	461a      	mov	r2, r3
   164f0:	f7f7 ff28 	bl	e344 <_read>
   164f4:	1c43      	adds	r3, r0, #1
   164f6:	d102      	bne.n	164fe <_read_r+0x1e>
   164f8:	682b      	ldr	r3, [r5, #0]
   164fa:	b103      	cbz	r3, 164fe <_read_r+0x1e>
   164fc:	6023      	str	r3, [r4, #0]
   164fe:	bd38      	pop	{r3, r4, r5, pc}
   16500:	2001cfe0 	.word	0x2001cfe0

00016504 <_raise_r>:
   16504:	291f      	cmp	r1, #31
   16506:	b538      	push	{r3, r4, r5, lr}
   16508:	4604      	mov	r4, r0
   1650a:	460d      	mov	r5, r1
   1650c:	d904      	bls.n	16518 <_raise_r+0x14>
   1650e:	2316      	movs	r3, #22
   16510:	6003      	str	r3, [r0, #0]
   16512:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
   16516:	bd38      	pop	{r3, r4, r5, pc}
   16518:	6c42      	ldr	r2, [r0, #68]	; 0x44
   1651a:	b112      	cbz	r2, 16522 <_raise_r+0x1e>
   1651c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
   16520:	b94b      	cbnz	r3, 16536 <_raise_r+0x32>
   16522:	4620      	mov	r0, r4
   16524:	f000 f830 	bl	16588 <_getpid_r>
   16528:	462a      	mov	r2, r5
   1652a:	4601      	mov	r1, r0
   1652c:	4620      	mov	r0, r4
   1652e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   16532:	f000 b817 	b.w	16564 <_kill_r>
   16536:	2b01      	cmp	r3, #1
   16538:	d00a      	beq.n	16550 <_raise_r+0x4c>
   1653a:	1c59      	adds	r1, r3, #1
   1653c:	d103      	bne.n	16546 <_raise_r+0x42>
   1653e:	2316      	movs	r3, #22
   16540:	6003      	str	r3, [r0, #0]
   16542:	2001      	movs	r0, #1
   16544:	e7e7      	b.n	16516 <_raise_r+0x12>
   16546:	2400      	movs	r4, #0
   16548:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
   1654c:	4628      	mov	r0, r5
   1654e:	4798      	blx	r3
   16550:	2000      	movs	r0, #0
   16552:	e7e0      	b.n	16516 <_raise_r+0x12>

00016554 <raise>:
   16554:	4b02      	ldr	r3, [pc, #8]	; (16560 <raise+0xc>)
   16556:	4601      	mov	r1, r0
   16558:	6818      	ldr	r0, [r3, #0]
   1655a:	f7ff bfd3 	b.w	16504 <_raise_r>
   1655e:	bf00      	nop
   16560:	2000054c 	.word	0x2000054c

00016564 <_kill_r>:
   16564:	b538      	push	{r3, r4, r5, lr}
   16566:	4d07      	ldr	r5, [pc, #28]	; (16584 <_kill_r+0x20>)
   16568:	2300      	movs	r3, #0
   1656a:	4604      	mov	r4, r0
   1656c:	4608      	mov	r0, r1
   1656e:	4611      	mov	r1, r2
   16570:	602b      	str	r3, [r5, #0]
   16572:	f7f6 f8f7 	bl	c764 <_kill>
   16576:	1c43      	adds	r3, r0, #1
   16578:	d102      	bne.n	16580 <_kill_r+0x1c>
   1657a:	682b      	ldr	r3, [r5, #0]
   1657c:	b103      	cbz	r3, 16580 <_kill_r+0x1c>
   1657e:	6023      	str	r3, [r4, #0]
   16580:	bd38      	pop	{r3, r4, r5, pc}
   16582:	bf00      	nop
   16584:	2001cfe0 	.word	0x2001cfe0

00016588 <_getpid_r>:
   16588:	f7f6 b8ed 	b.w	c766 <_getpid>

0001658c <_malloc_usable_size_r>:
   1658c:	f851 3c04 	ldr.w	r3, [r1, #-4]
   16590:	1f18      	subs	r0, r3, #4
   16592:	2b00      	cmp	r3, #0
   16594:	bfbc      	itt	lt
   16596:	580b      	ldrlt	r3, [r1, r0]
   16598:	18c0      	addlt	r0, r0, r3
   1659a:	4770      	bx	lr
   1659c:	6d617246 	.word	0x6d617246
   165a0:	74532065 	.word	0x74532065
   165a4:	20747261 	.word	0x20747261
   165a8:	7366664f 	.word	0x7366664f
   165ac:	7b007465 	.word	0x7b007465
   165b0:	70797422 	.word	0x70797422
   165b4:	223a2265 	.word	0x223a2265
   165b8:	4e524157 	.word	0x4e524157
   165bc:	22474e49 	.word	0x22474e49
   165c0:	6422202c 	.word	0x6422202c
   165c4:	22617461 	.word	0x22617461
   165c8:	225b203a 	.word	0x225b203a
   165cc:	5d227325 	.word	0x5d227325
   165d0:	000a0d7d 	.word	0x000a0d7d
   165d4:	6e6e6f43 	.word	0x6e6e6f43
   165d8:	00746365 	.word	0x00746365
   165dc:	7974227b 	.word	0x7974227b
   165e0:	3a226570 	.word	0x3a226570
   165e4:	41572220 	.word	0x41572220
   165e8:	4e494e52 	.word	0x4e494e52
   165ec:	202c2247 	.word	0x202c2247
   165f0:	74616422 	.word	0x74616422
   165f4:	203a2261 	.word	0x203a2261
   165f8:	6e55225b 	.word	0x6e55225b
   165fc:	776f6e6b 	.word	0x776f6e6b
   16600:	73654d20 	.word	0x73654d20
   16604:	65676173 	.word	0x65676173
   16608:	70795420 	.word	0x70795420
   1660c:	7d5d2265 	.word	0x7d5d2265
   16610:	227b000d 	.word	0x227b000d
   16614:	65707974 	.word	0x65707974
   16618:	22203a22 	.word	0x22203a22
   1661c:	4e524157 	.word	0x4e524157
   16620:	22474e49 	.word	0x22474e49
   16624:	6422202c 	.word	0x6422202c
   16628:	22617461 	.word	0x22617461
   1662c:	225b203a 	.word	0x225b203a
   16630:	61766e49 	.word	0x61766e49
   16634:	2064696c 	.word	0x2064696c
   16638:	63656843 	.word	0x63656843
   1663c:	6d75736b 	.word	0x6d75736b
   16640:	0d7d5d22 	.word	0x0d7d5d22
   16644:	6d695400 	.word	0x6d695400
   16648:	74756f65 	.word	0x74756f65
   1664c:	73694420 	.word	0x73694420
   16650:	6e6e6f63 	.word	0x6e6e6f63
   16654:	20746365 	.word	0x20746365
   16658:	65522026 	.word	0x65522026
   1665c:	20746573 	.word	0x20746573
   16660:	65636552 	.word	0x65636552
   16664:	72657669 	.word	0x72657669
   16668:	6d695400 	.word	0x6d695400
   1666c:	74756f65 	.word	0x74756f65
   16670:	52202620 	.word	0x52202620
   16674:	74657365 	.word	0x74657365
   16678:	63655220 	.word	0x63655220
   1667c:	65766965 	.word	0x65766965
   16680:	63250072 	.word	0x63250072
   16684:	63256325 	.word	0x63256325
   16688:	30256325 	.word	0x30256325
   1668c:	30257832 	.word	0x30257832
   16690:	30257832 	.word	0x30257832
   16694:	63257832 	.word	0x63257832
   16698:	000a3030 	.word	0x000a3030
   1669c:	30256325 	.word	0x30256325
   166a0:	2e5f7833 	.word	0x2e5f7833
   166a4:	2e2e2e2e 	.word	0x2e2e2e2e
   166a8:	2e2e2e2e 	.word	0x2e2e2e2e
   166ac:	2e2e2e2e 	.word	0x2e2e2e2e
   166b0:	2e2e2e2e 	.word	0x2e2e2e2e
   166b4:	2e2e2e2e 	.word	0x2e2e2e2e
   166b8:	2e2e2e2e 	.word	0x2e2e2e2e
   166bc:	2e2e2e2e 	.word	0x2e2e2e2e
   166c0:	252e2e2e 	.word	0x252e2e2e
   166c4:	63250063 	.word	0x63250063
   166c8:	78333025 	.word	0x78333025
   166cc:	2e2e2e5f 	.word	0x2e2e2e5f
   166d0:	2e2e2e2e 	.word	0x2e2e2e2e
   166d4:	0063252e 	.word	0x0063252e
   166d8:	30256325 	.word	0x30256325
   166dc:	2e5f7833 	.word	0x2e5f7833
   166e0:	0063252e 	.word	0x0063252e
   166e4:	30256325 	.word	0x30256325
   166e8:	2e5f7833 	.word	0x2e5f7833
   166ec:	2e2e2e2e 	.word	0x2e2e2e2e
   166f0:	0063252e 	.word	0x0063252e
   166f4:	7974227b 	.word	0x7974227b
   166f8:	3a226570 	.word	0x3a226570
   166fc:	43574822 	.word	0x43574822
   16700:	2c224746 	.word	0x2c224746
   16704:	61642220 	.word	0x61642220
   16708:	3a226174 	.word	0x3a226174
   1670c:	64252220 	.word	0x64252220
   16710:	0a0d7d22 	.word	0x0a0d7d22
   16714:	204f4e00 	.word	0x204f4e00
   16718:	52455355 	.word	0x52455355
   1671c:	574f5220 	.word	0x574f5220
   16720:	45484320 	.word	0x45484320
   16724:	00214b43 	.word	0x00214b43
   16728:	55206f4e 	.word	0x55206f4e
   1672c:	2074696e 	.word	0x2074696e
   16730:	74736554 	.word	0x74736554
   16734:	61655200 	.word	0x61655200
   16738:	676e6964 	.word	0x676e6964
   1673c:	65735520 	.word	0x65735520
   16740:	6f522072 	.word	0x6f522072
   16744:	227b0077 	.word	0x227b0077
   16748:	65707974 	.word	0x65707974
   1674c:	4c223a22 	.word	0x4c223a22
   16750:	2c22474f 	.word	0x2c22474f
   16754:	61642220 	.word	0x61642220
   16758:	3a226174 	.word	0x3a226174
   1675c:	25225b20 	.word	0x25225b20
   16760:	7d5d2273 	.word	0x7d5d2273
   16764:	56000a0d 	.word	0x56000a0d
   16768:	66697265 	.word	0x66697265
   1676c:	676e6979 	.word	0x676e6979
   16770:	65735520 	.word	0x65735520
   16774:	6f522072 	.word	0x6f522072
   16778:	70550077 	.word	0x70550077
   1677c:	69746164 	.word	0x69746164
   16780:	5520676e 	.word	0x5520676e
   16784:	20726573 	.word	0x20726573
   16788:	00776f52 	.word	0x00776f52
   1678c:	74737953 	.word	0x74737953
   16790:	52206d65 	.word	0x52206d65
   16794:	74657365 	.word	0x74657365
   16798:	636e5500 	.word	0x636e5500
   1679c:	676e6168 	.word	0x676e6168
   167a0:	55206465 	.word	0x55206465
   167a4:	20726573 	.word	0x20726573
   167a8:	00776f52 	.word	0x00776f52
   167ac:	4f525245 	.word	0x4f525245
   167b0:	6e692052 	.word	0x6e692052
   167b4:	70786520 	.word	0x70786520
   167b8:	656c5f72 	.word	0x656c5f72
   167bc:	5f6c6576 	.word	0x5f6c6576
   167c0:	00292833 	.word	0x00292833
   167c4:	00736261 	.word	0x00736261
   167c8:	00786973 	.word	0x00786973
   167cc:	00646461 	.word	0x00646461
   167d0:	6e697270 	.word	0x6e697270
   167d4:	66690074 	.word	0x66690074
   167d8:	6e754600 	.word	0x6e754600
   167dc:	6f697463 	.word	0x6f697463
   167e0:	2522206e 	.word	0x2522206e
   167e4:	6e202273 	.word	0x6e202273
   167e8:	6620746f 	.word	0x6620746f
   167ec:	646e756f 	.word	0x646e756f
   167f0:	28000a21 	.word	0x28000a21
   167f4:	00296425 	.word	0x00296425
   167f8:	78323025 	.word	0x78323025
   167fc:	00          	.byte	0x00
   167fd:	48          	.byte	0x48
   167fe:	7261      	.short	0x7261
   16800:	72617764 	.word	0x72617764
   16804:	65542065 	.word	0x65542065
   16808:	49207473 	.word	0x49207473
   1680c:	0074696e 	.word	0x0074696e
   16810:	30353002 	.word	0x30353002
   16814:	28707b65 	.word	0x28707b65
   16818:	7d29305a 	.word	0x7d29305a
   1681c:	63303030 	.word	0x63303030
   16820:	00033030 	.word	0x00033030
   16824:	30353002 	.word	0x30353002
   16828:	28707b65 	.word	0x28707b65
   1682c:	7d29305a 	.word	0x7d29305a
   16830:	38303030 	.word	0x38303030
   16834:	5a28707b 	.word	0x5a28707b
   16838:	037d2934 	.word	0x037d2934
   1683c:	30333002 	.word	0x30333002
   16840:	28707b65 	.word	0x28707b65
   16844:	7d29355a 	.word	0x7d29355a
   16848:	30020003 	.word	0x30020003
   1684c:	7b653035 	.word	0x7b653035
   16850:	305a2870 	.word	0x305a2870
   16854:	30307d29 	.word	0x30307d29
   16858:	707b3930 	.word	0x707b3930
   1685c:	29345a28 	.word	0x29345a28
   16860:	0200037d 	.word	0x0200037d
   16864:	65303530 	.word	0x65303530
   16868:	5a28707b 	.word	0x5a28707b
   1686c:	307d2930 	.word	0x307d2930
   16870:	7b613030 	.word	0x7b613030
   16874:	345a2870 	.word	0x345a2870
   16878:	02037d29 	.word	0x02037d29
   1687c:	65303330 	.word	0x65303330
   16880:	5a28707b 	.word	0x5a28707b
   16884:	037d2930 	.word	0x037d2930
   16888:	35300200 	.word	0x35300200
   1688c:	707b6530 	.word	0x707b6530
   16890:	29305a28 	.word	0x29305a28
   16894:	3030307d 	.word	0x3030307d
   16898:	28707b62 	.word	0x28707b62
   1689c:	7d29345a 	.word	0x7d29345a
   168a0:	33300203 	.word	0x33300203
   168a4:	707b6630 	.word	0x707b6630
   168a8:	29305a28 	.word	0x29305a28
   168ac:	5500037d 	.word	0x5500037d
   168b0:	6f502049 	.word	0x6f502049
   168b4:	20726577 	.word	0x20726577
   168b8:	62616e45 	.word	0x62616e45
   168bc:	4900656c 	.word	0x4900656c
   168c0:	2074696e 	.word	0x2074696e
   168c4:	75646f4d 	.word	0x75646f4d
   168c8:	203a656c 	.word	0x203a656c
   168cc:	36314f50 	.word	0x36314f50
   168d0:	696e4900 	.word	0x696e4900
   168d4:	6f4d2074 	.word	0x6f4d2074
   168d8:	656c7564 	.word	0x656c7564
   168dc:	5542203a 	.word	0x5542203a
   168e0:	49003631 	.word	0x49003631
   168e4:	2074696e 	.word	0x2074696e
   168e8:	75646f4d 	.word	0x75646f4d
   168ec:	203a656c 	.word	0x203a656c
   168f0:	34464250 	.word	0x34464250
   168f4:	696e4900 	.word	0x696e4900
   168f8:	6f4d2074 	.word	0x6f4d2074
   168fc:	656c7564 	.word	0x656c7564
   16900:	4e45203a 	.word	0x4e45203a
   16904:	49003631 	.word	0x49003631
   16908:	2074696e 	.word	0x2074696e
   1690c:	75646f4d 	.word	0x75646f4d
   16910:	203a656c 	.word	0x203a656c
   16914:	6e6b6e55 	.word	0x6e6b6e55
   16918:	206e776f 	.word	0x206e776f
   1691c:	75646f4d 	.word	0x75646f4d
   16920:	4800656c 	.word	0x4800656c
   16924:	47464357 	.word	0x47464357
   16928:	73694d20 	.word	0x73694d20
   1692c:	6374616d 	.word	0x6374616d
   16930:	0068      	.short	0x0068
   16932:	0d0c      	.short	0x0d0c
   16934:	09080f0e 	.word	0x09080f0e
   16938:	05040b0a 	.word	0x05040b0a
   1693c:	01000706 	.word	0x01000706
   16940:	0302      	.short	0x0302
   16942:	0d0c      	.short	0x0d0c
   16944:	09080f0e 	.word	0x09080f0e
   16948:	05040b0a 	.word	0x05040b0a
   1694c:	01000706 	.word	0x01000706
   16950:	0302      	.short	0x0302
   16952:	0d0c      	.short	0x0d0c
   16954:	09080f0e 	.word	0x09080f0e
   16958:	05040b0a 	.word	0x05040b0a
   1695c:	01000706 	.word	0x01000706
   16960:	0302      	.short	0x0302
   16962:	0d0c      	.short	0x0d0c
   16964:	09080f0e 	.word	0x09080f0e
   16968:	05040b0a 	.word	0x05040b0a
   1696c:	01000706 	.word	0x01000706
   16970:	0302      	.short	0x0302
   16972:	6325      	.short	0x6325
   16974:	2e2e6325 	.word	0x2e2e6325
   16978:	2e2e2e2e 	.word	0x2e2e2e2e
   1697c:	2e2e2e2e 	.word	0x2e2e2e2e
   16980:	63252e2e 	.word	0x63252e2e
   16984:	00          	.byte	0x00
   16985:	25          	.byte	0x25
   16986:	2563      	.short	0x2563
   16988:	65783330 	.word	0x65783330
   1698c:	6325      	.short	0x6325
   1698e:	00          	.byte	0x00
   1698f:	25          	.byte	0x25
   16990:	33302563 	.word	0x33302563
   16994:	2e2e5f78 	.word	0x2e2e5f78
   16998:	63252e2e 	.word	0x63252e2e
   1699c:	25632500 	.word	0x25632500
   169a0:	65783330 	.word	0x65783330
   169a4:	00202300 	.word	0x00202300
   169a8:	25002320 	.word	0x25002320
   169ac:	00783830 	.word	0x00783830
   169b0:	64697267 	.word	0x64697267
   169b4:	7379735f 	.word	0x7379735f
   169b8:	68633a3a 	.word	0x68633a3a
   169bc:	736b6365 	.word	0x736b6365
   169c0:	43006d75 	.word	0x43006d75
   169c4:	6b636568 	.word	0x6b636568
   169c8:	206d7573 	.word	0x206d7573
   169cc:	64616552 	.word	0x64616552
   169d0:	6c61432f 	.word	0x6c61432f
   169d4:	616c7563 	.word	0x616c7563
   169d8:	70006574 	.word	0x70006574
   169dc:	656b6361 	.word	0x656b6361
   169e0:	64257b74 	.word	0x64257b74
   169e4:	6425202c 	.word	0x6425202c
   169e8:	6425202c 	.word	0x6425202c
   169ec:	6425202c 	.word	0x6425202c
   169f0:	6425202c 	.word	0x6425202c
   169f4:	6425202c 	.word	0x6425202c
   169f8:	6425202c 	.word	0x6425202c
   169fc:	6425202c 	.word	0x6425202c
   16a00:	6552207d 	.word	0x6552207d
   16a04:	203a6461 	.word	0x203a6461
   16a08:	202c6425 	.word	0x202c6425
   16a0c:	636c6143 	.word	0x636c6143
   16a10:	74616c75 	.word	0x74616c75
   16a14:	25203a65 	.word	0x25203a65
   16a18:	68430064 	.word	0x68430064
   16a1c:	736b6365 	.word	0x736b6365
   16a20:	57206d75 	.word	0x57206d75
   16a24:	65746972 	.word	0x65746972
   16a28:	6c61432f 	.word	0x6c61432f
   16a2c:	616c7563 	.word	0x616c7563
   16a30:	43006574 	.word	0x43006574
   16a34:	6b636568 	.word	0x6b636568
   16a38:	206d7573 	.word	0x206d7573
   16a3c:	7265764f 	.word	0x7265764f
   16a40:	74697277 	.word	0x74697277
   16a44:	61500065 	.word	0x61500065
   16a48:	61706172 	.word	0x61706172
   16a4c:	6b697270 	.word	0x6b697270
   16a50:	7361      	.short	0x7361
   16a52:	00          	.byte	0x00
   16a53:	25          	.byte	0x25
   16a54:	33302563 	.word	0x33302563
   16a58:	2e2e5f78 	.word	0x2e2e5f78
   16a5c:	2e2e2e2e 	.word	0x2e2e2e2e
   16a60:	34300200 	.word	0x34300200
   16a64:	707b6531 	.word	0x707b6531
   16a68:	29305428 	.word	0x29305428
   16a6c:	7b31307d 	.word	0x7b31307d
   16a70:	315a2870 	.word	0x315a2870
   16a74:	707b7d29 	.word	0x707b7d29
   16a78:	29325a28 	.word	0x29325a28
   16a7c:	28707b7d 	.word	0x28707b7d
   16a80:	7d29335a 	.word	0x7d29335a
   16a84:	30020003 	.word	0x30020003
   16a88:	30653030 	.word	0x30653030
   16a8c:	7b303930 	.word	0x7b303930
   16a90:	30542870 	.word	0x30542870
   16a94:	707b7d29 	.word	0x707b7d29
   16a98:	29325428 	.word	0x29325428
   16a9c:	3002037d 	.word	0x3002037d
   16aa0:	7b653034 	.word	0x7b653034
   16aa4:	30542870 	.word	0x30542870
   16aa8:	31307d29 	.word	0x31307d29
   16aac:	5428707b 	.word	0x5428707b
   16ab0:	037d2932 	.word	0x037d2932
   16ab4:	30300200 	.word	0x30300200
   16ab8:	30306530 	.word	0x30306530
   16abc:	707b3038 	.word	0x707b3038
   16ac0:	29305428 	.word	0x29305428
   16ac4:	28707b7d 	.word	0x28707b7d
   16ac8:	7d293254 	.word	0x7d293254
   16acc:	34300203 	.word	0x34300203
   16ad0:	707b6530 	.word	0x707b6530
   16ad4:	29305428 	.word	0x29305428
   16ad8:	7b31307d 	.word	0x7b31307d
   16adc:	32542870 	.word	0x32542870
   16ae0:	00037d29 	.word	0x00037d29
   16ae4:	30303002 	.word	0x30303002
   16ae8:	62303065 	.word	0x62303065
   16aec:	28707b30 	.word	0x28707b30
   16af0:	7d293054 	.word	0x7d293054
   16af4:	5428707b 	.word	0x5428707b
   16af8:	037d2932 	.word	0x037d2932
   16afc:	30343002 	.word	0x30343002
   16b00:	28707b65 	.word	0x28707b65
   16b04:	7d293054 	.word	0x7d293054
   16b08:	707b3130 	.word	0x707b3130
   16b0c:	29325428 	.word	0x29325428
   16b10:	0200037d 	.word	0x0200037d
   16b14:	65313430 	.word	0x65313430
   16b18:	5428707b 	.word	0x5428707b
   16b1c:	307d2930 	.word	0x307d2930
   16b20:	28707b31 	.word	0x28707b31
   16b24:	7d29315a 	.word	0x7d29315a
   16b28:	5a28707b 	.word	0x5a28707b
   16b2c:	7b7d2932 	.word	0x7b7d2932
   16b30:	335a2870 	.word	0x335a2870
   16b34:	02037d29 	.word	0x02037d29
   16b38:	65313430 	.word	0x65313430
   16b3c:	5428707b 	.word	0x5428707b
   16b40:	307d2930 	.word	0x307d2930
   16b44:	28707b32 	.word	0x28707b32
   16b48:	7d29315a 	.word	0x7d29315a
   16b4c:	5a28707b 	.word	0x5a28707b
   16b50:	7b7d2932 	.word	0x7b7d2932
   16b54:	335a2870 	.word	0x335a2870
   16b58:	00037d29 	.word	0x00037d29
   16b5c:	30303002 	.word	0x30303002
   16b60:	62303065 	.word	0x62303065
   16b64:	28707b30 	.word	0x28707b30
   16b68:	7d293054 	.word	0x7d293054
   16b6c:	5428707b 	.word	0x5428707b
   16b70:	037d2938 	.word	0x037d2938
   16b74:	7b464923 	.word	0x7b464923
   16b78:	3d3d305a 	.word	0x3d3d305a
   16b7c:	54237d33 	.word	0x54237d33
   16b80:	34300248 	.word	0x34300248
   16b84:	707b6531 	.word	0x707b6531
   16b88:	29305428 	.word	0x29305428
   16b8c:	7b31307d 	.word	0x7b31307d
   16b90:	38542870 	.word	0x38542870
   16b94:	707b7d29 	.word	0x707b7d29
   16b98:	29325a28 	.word	0x29325a28
   16b9c:	28707b7d 	.word	0x28707b7d
   16ba0:	2d383231 	.word	0x2d383231
   16ba4:	7d293854 	.word	0x7d293854
   16ba8:	4c452303 	.word	0x4c452303
   16bac:	024e4523 	.word	0x024e4523
   16bb0:	65303430 	.word	0x65303430
   16bb4:	5428707b 	.word	0x5428707b
   16bb8:	307d2930 	.word	0x307d2930
   16bbc:	28707b31 	.word	0x28707b31
   16bc0:	7d293854 	.word	0x7d293854
   16bc4:	30020003 	.word	0x30020003
   16bc8:	30653030 	.word	0x30653030
   16bcc:	7b306230 	.word	0x7b306230
   16bd0:	30542870 	.word	0x30542870
   16bd4:	707b7d29 	.word	0x707b7d29
   16bd8:	29385428 	.word	0x29385428
   16bdc:	3002037d 	.word	0x3002037d
   16be0:	7b653034 	.word	0x7b653034
   16be4:	30542870 	.word	0x30542870
   16be8:	31307d29 	.word	0x31307d29
   16bec:	5428707b 	.word	0x5428707b
   16bf0:	037d2938 	.word	0x037d2938
   16bf4:	30300200 	.word	0x30300200
   16bf8:	30306530 	.word	0x30306530
   16bfc:	707b3039 	.word	0x707b3039
   16c00:	29305428 	.word	0x29305428
   16c04:	28707b7d 	.word	0x28707b7d
   16c08:	7d293254 	.word	0x7d293254
   16c0c:	34300203 	.word	0x34300203
   16c10:	707b6530 	.word	0x707b6530
   16c14:	29305428 	.word	0x29305428
   16c18:	7b32307d 	.word	0x7b32307d
   16c1c:	32542870 	.word	0x32542870
   16c20:	00037d29 	.word	0x00037d29
   16c24:	30303002 	.word	0x30303002
   16c28:	38303065 	.word	0x38303065
   16c2c:	28707b30 	.word	0x28707b30
   16c30:	7d293054 	.word	0x7d293054
   16c34:	5428707b 	.word	0x5428707b
   16c38:	037d2932 	.word	0x037d2932
   16c3c:	30343002 	.word	0x30343002
   16c40:	28707b65 	.word	0x28707b65
   16c44:	7d293054 	.word	0x7d293054
   16c48:	707b3230 	.word	0x707b3230
   16c4c:	29325428 	.word	0x29325428
   16c50:	5200037d 	.word	0x5200037d
   16c54:	73696765 	.word	0x73696765
   16c58:	20726574 	.word	0x20726574
   16c5c:	69746341 	.word	0x69746341
   16c60:	45006e6f 	.word	0x45006e6f
   16c64:	746e6576 	.word	0x746e6576
   16c68:	746f4e20 	.word	0x746f4e20
   16c6c:	756f4620 	.word	0x756f4620
   16c70:	2000646e 	.word	0x2000646e
   16c74:	61637345 	.word	0x61637345
   16c78:	20646570 	.word	0x20646570
   16c7c:	72616843 	.word	0x72616843
   16c80:	756f4620 	.word	0x756f4620
   16c84:	0020646e 	.word	0x0020646e
   16c88:	30353002 	.word	0x30353002
   16c8c:	28707b65 	.word	0x28707b65
   16c90:	7d29305a 	.word	0x7d29305a
   16c94:	5428707b 	.word	0x5428707b
   16c98:	307d2930 	.word	0x307d2930
   16c9c:	03303030 	.word	0x03303030
   16ca0:	35300200 	.word	0x35300200
   16ca4:	707b6530 	.word	0x707b6530
   16ca8:	29305a28 	.word	0x29305a28
   16cac:	28707b7d 	.word	0x28707b7d
   16cb0:	7d293054 	.word	0x7d293054
   16cb4:	707b3430 	.word	0x707b3430
   16cb8:	29325428 	.word	0x29325428
   16cbc:	0200037d 	.word	0x0200037d
   16cc0:	65303530 	.word	0x65303530
   16cc4:	5a28707b 	.word	0x5a28707b
   16cc8:	7b7d2930 	.word	0x7b7d2930
   16ccc:	30542870 	.word	0x30542870
   16cd0:	35307d29 	.word	0x35307d29
   16cd4:	5428707b 	.word	0x5428707b
   16cd8:	037d2932 	.word	0x037d2932
   16cdc:	35300200 	.word	0x35300200
   16ce0:	707b6530 	.word	0x707b6530
   16ce4:	29305a28 	.word	0x29305a28
   16ce8:	28707b7d 	.word	0x28707b7d
   16cec:	7d293054 	.word	0x7d293054
   16cf0:	707b3130 	.word	0x707b3130
   16cf4:	29325428 	.word	0x29325428
   16cf8:	0200037d 	.word	0x0200037d
   16cfc:	65303530 	.word	0x65303530
   16d00:	5a28707b 	.word	0x5a28707b
   16d04:	7b7d2930 	.word	0x7b7d2930
   16d08:	30542870 	.word	0x30542870
   16d0c:	31307d29 	.word	0x31307d29
   16d10:	5428707b 	.word	0x5428707b
   16d14:	037d2935 	.word	0x037d2935
   16d18:	35300200 	.word	0x35300200
   16d1c:	707b6530 	.word	0x707b6530
   16d20:	29305a28 	.word	0x29305a28
   16d24:	28707b7d 	.word	0x28707b7d
   16d28:	7d293054 	.word	0x7d293054
   16d2c:	707b6430 	.word	0x707b6430
   16d30:	29355428 	.word	0x29355428
   16d34:	5300037d 	.word	0x5300037d
   16d38:	61746e79 	.word	0x61746e79
   16d3c:	72452078 	.word	0x72452078
   16d40:	21726f72 	.word	0x21726f72
   16d44:	0000000d 	.word	0x0000000d
   16d48:	20009150 	.word	0x20009150
   16d4c:	20019870 	.word	0x20019870
   16d50:	200138d4 	.word	0x200138d4
   16d54:	200102d4 	.word	0x200102d4
   16d58:	682f2e2e 	.word	0x682f2e2e
   16d5c:	732f6c61 	.word	0x732f6c61
   16d60:	682f6372 	.word	0x682f6372
   16d64:	695f6c61 	.word	0x695f6c61
   16d68:	00632e6f 	.word	0x00632e6f
   16d6c:	682f2e2e 	.word	0x682f2e2e
   16d70:	732f6c61 	.word	0x732f6c61
   16d74:	682f6372 	.word	0x682f6372
   16d78:	695f6c61 	.word	0x695f6c61
   16d7c:	6d5f6332 	.word	0x6d5f6332
   16d80:	7973615f 	.word	0x7973615f
   16d84:	632e636e 	.word	0x632e636e
   16d88:	00          	.byte	0x00
   16d89:	2e          	.byte	0x2e
   16d8a:	2f2e      	.short	0x2f2e
   16d8c:	2f6c7068 	.word	0x2f6c7068
   16d90:	2f746477 	.word	0x2f746477
   16d94:	5f6c7068 	.word	0x5f6c7068
   16d98:	2e746477 	.word	0x2e746477
   16d9c:	0063      	.short	0x0063
   16d9e:	2e2e      	.short	0x2e2e
   16da0:	6c61682f 	.word	0x6c61682f
   16da4:	6372732f 	.word	0x6372732f
   16da8:	6c61682f 	.word	0x6c61682f
   16dac:	6970735f 	.word	0x6970735f
   16db0:	645f6d5f 	.word	0x645f6d5f
   16db4:	632e616d 	.word	0x632e616d
   16db8:	00000000 	.word	0x00000000

00016dbc <user_mux_confs>:
	...
   16de8:	04030201 04030201 00000000 00000000     ................
	...

00016e00 <channel_confs>:
   16e00:	05230522 05250524 00000000 00000000     ".#.$.%.........
	...

00016e40 <interrupt_cfg>:
   16e40:	00000002 00000002 00000002 00000002     ................
	...
   16ec0:	74697845 20676e69 68746977 61747320     Exiting with sta
   16ed0:	20737574 0a2e6425 2f2e2e00 2f6c7068     tus %d...../hpl/
   16ee0:	69707371 6c70682f 7073715f 00632e69     qspi/hpl_qspi.c.
   16ef0:	682f2e2e 6e2f6c70 74636d76 682f6c72     ../hpl/nvmctrl/h
   16f00:	6e5f6c70 74636d76 632e6c72 2f2e2e00     pl_nvmctrl.c.../
   16f10:	2f6c6168 2f637273 5f6c6168 656d6974     hal/src/hal_time
   16f20:	00632e72                                r.c.

00016f24 <_usb_ep_cfgs>:
   16f24:	20008928 00000000 00000040 00000000     (.. ....@.......
	...
   16f3c:	20008920 00000000 00000008 200088e0      .. ........... 
   16f4c:	200088d8 00080040 00000000 00000000     ... @...........
	...
   16f64:	20008898 00400000 20726d54 00637653     ... ..@.Tmr Svc.

00016f74 <mouse_report_desc>:
   16f74:	02090105 010901a1 090500a1 03290119     ..............).
   16f84:	01250015 03950175 05750281 01810195     ..%.u.....u.....
   16f94:	30090105 38093109 7f258115 03950875     ...0.1.8..%.u...
   16fa4:	c0c00681                                ....

00016fa8 <_cfgs>:
   16fa8:	00200600 08068000 00200400 08068000     .. ....... .....
   16fb8:	00201000 08068000 00200c00 08068000     .. ....... .....
	...
   16fd8:	00200b00 14000003 00200a00 08000002     .. ....... .....
   16fe8:	00201300 14000003 00000000 00000000     .. .............
	...
   17098:	00005400 1c000000 00005300 0c000000     .T.......S......
   170a8:	682f2e2e 732f6c61 682f6372 615f6c61     ../hal/src/hal_a
   170b8:	615f6364 636e7973 2e00632e 61682f2e     dc_async.c.../ha
   170c8:	72732f6c 61682f63 61725f6c 735f646e     l/src/hal_rand_s
   170d8:	2e636e79 2e2e0063 6c70682f 6e72742f     ync.c.../hpl/trn
   170e8:	70682f67 72745f6c 632e676e               g/hpl_trng.c.

000170f5 <keyboard_report_desc>:
   170f5:	06090105 070501a1 e729e019 01250015     ..........)...%.
   17105:	08950175 01810281 65290019 65250015     u.........)e..%e
   17115:	06950875 08050081 05290119 01250015     u.........)...%.
   17125:	05950175 03950291 2ec00191 61682f2e     u............/ha
   17135:	72732f6c 61682f63 73755f6c 5f747261     l/src/hal_usart_
   17145:	636e7973 2e00632e 61682f2e 72732f6c     sync.c.../hal/sr
   17155:	61682f63 6c665f6c 2e687361 2e2e0063     c/hal_flash.c...
   17165:	6c61682f 6372732f 6c61682f 6970735f     /hal/src/hal_spi
   17175:	615f6d5f 636e7973 2e00632e 61682f2e     _m_async.c.../ha
   17185:	72732f6c 61682f63 72635f6c 79735f63     l/src/hal_crc_sy
   17195:	632e636e                                 nc.c.

0001719a <CSWTCH.37>:
   1719a:	010101ed                                 .......

000171a1 <CSWTCH.40>:
   171a1:	010100ed 2ef00201 61682f2e 74752f6c     ........./hal/ut
   171b1:	2f736c69 2f637273 6c697475 696c5f73     ils/src/utils_li
   171c1:	632e7473 2f2e2e00 2f6c7068 2f637472     st.c.../hpl/rtc/
   171d1:	5f6c7068 2e637472 2e2e0063 6c61682f     hpl_rtc.c.../hal
   171e1:	636e692f 6564756c 6c61682f 7464775f     /include/hal_wdt
   171f1:	2e00682e 61682f2e 72732f6c 61682f63     .h.../hal/src/ha
   17201:	73755f6c 5f747261 6e797361 00632e63     l_usart_async.c.
   17211:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
   17221:	65735f6c 6d6f6372 0000632e 00400030     l_sercom.c..0.@.
   17231:	00400034 00410120 00410140 00430000     4.@. .A.@.A...C.
   17241:	00430004 00430008                        ..C...C...C

0001724c <sercomspi_regs>:
   1724c:	3020000c 00020000 00000000 01ff0005     .. 0............
   1725c:	20000c03 00000000 00000000 ff000600     ... ............
   1726c:	00000701                                ....

00017270 <_i2cms>:
   17270:	00000005 00200014 00000100 0000e6e5     ...... .........
   17280:	00d70000 02dc6c00                       .....l..

00017288 <_usarts>:
   17288:	00000000 40100004 00030000 00700002     .......@......p.
   17298:	0000aaaa 00000000 00000001 40100004     ...............@
   172a8:	00030000 00700002 0000aaaa 00000000     ......p.........
   172b8:	00000002 40100004 00030000 00700002     .......@......p.
   172c8:	00005555 00000000 00000004 40100004     UU.............@
   172d8:	00030000 00700002 0000aaaa 00000000     ......p.........
   172e8:	00000006 40100004 00030000 00700002     .......@......p.
   172f8:	0000aaaa 00000000 682f2e2e 752f6c61     ........../hal/u
   17308:	736c6974 6372732f 6974752f 725f736c     tils/src/utils_r
   17318:	62676e69 65666675 00632e72 6d617845     ingbuffer.c.Exam
   17328:	54656c70 206b7361 3f3f3f3f 202e2e2e     pleTask ????... 
   17338:	0d206425 494d000a 203a4944 78323025     %d ...MIDI: %02x
   17348:	32302520 30252078 25207832 0a783230      %02x %02x %02x.
   17358:	61745300 6f206b63 66726576 20776f6c     .Stack overflow 
   17368:	74206e69 206b7361 0a0d7325 61745300     in task %s...Sta
   17378:	49207472 6974696e 7a696c61 74006465     rt Initialized.t
   17388:	2e747365 2e75636d 41535441 3135444d     est.mcu.ATSAMD51
   17398:	4130324e 6574000d 682e7473 67666377     N20A..test.hwcfg
   173a8:	0d64252e 6574000a 732e7473 61697265     .%d...test.seria
   173b8:	2e6f6e6c 78383025 38302520 30252078     lno.%08x %08x %0
   173c8:	25207838 0d783830 6574000a 622e7473     8x %08x...test.b
   173d8:	646e756f 2e797261 002e6425 6c6c6548     oundary.%d..Hell
   173e8:	6425206f 20642520 25206425 35440064     o %d %d %d %d.D5
   173f8:	6e492031 43007469 6f706d6f 65746973     1 Init.Composite
   17408:	76654420 20656369 74696e49 696c6169      Device Initiali
   17418:	0064657a 64697247 646f4d20 20656c75     zed.Grid Module 
   17428:	74696e49 696c6169 0064657a 65746e45     Initialized.Ente
   17438:	676e6972 69614d20 6f4c206e 5500706f     ring Main Loop.U
   17448:	54206273 006b7361 206d764e 6b736154     sb Task.Nvm Task
   17458:	20695500 6b736154 63655200 65766965     .Ui Task.Receive
   17468:	73615420 6e49006b 6e756f62 61542064      Task.Inbound Ta
   17478:	4f006b73 6f627475 20646e75 6b736154     sk.Outbound Task
   17488:	64654c00 73615420 7845006b 6c706d61     .Led Task.Exampl
   17498:	6f430065 736f706d 20657469 69766544     e.Composite Devi
   174a8:	43206563 656e6e6f 64657463 726f4600     ce Connected.For
   174b8:	72657665 000d2021 682f2e2e 732f6c61     ever! ..../hal/s
   174c8:	682f6372 715f6c61 5f697073 2e616d64     rc/hal_qspi_dma.
   174d8:	44490063 0900454c 25096325 75250975     c.IDLE..%c.%u.%u
   174e8:	0d752509 2e2e000a 6c70682f 6364612f     .%u...../hpl/adc
   174f8:	6c70682f 6364615f 0000632e              /hpl_adc.c..

00017504 <_adcs>:
   17504:	01000000 0003000c 00041807 00000000     ................
   17514:	0014080b 00010000 000c0100 18040003     ................
   17524:	00000004 080b0000 00000014 752f2e2e     ............../u
   17534:	642f6273 63697665 73752f65 2e636462     sb/device/usbdc.
   17544:	2e2e0063 6c70682f 2f63742f 5f6c7068     c.../hpl/tc/hpl_
   17554:	632e6374 00000000 40003800 40003c00     tc.c.....8.@.<.@
   17564:	4101a000 4101c000 42001400 42001800     ...A...A...B...B
   17574:	43001400 43001800                       ...C...C

0001757c <_tcs>:
   1757c:	006b0000 00000308 00000021 00003a98     ..k.....!....:..
   1758c:	00000000 006c0001 00000308 00000021     ......l.....!...
   1759c:	00003a98 00000000 006d0002 00000308     .:........m.....
   175ac:	00000021 00003a98 00000000 006e0003     !....:........n.
   175bc:	00000308 00000021 00003a98 00000000     ....!....:......

000175cc <_global_impure_ptr>:
   175cc:	20000550 4e454552 616d2054 636f6c6c     P.. REENT malloc
   175dc:	63757320 64656563 2f006465 2f746e6d      succeeded./mnt/
   175ec:	6b726f77 63617073 6f772f65 70736b72     workspace/worksp
   175fc:	2f656361 2d434347 69702d39 696c6570     ace/GCC-9-pipeli
   1760c:	6a2f656e 696b6e65 472d736e 392d4343     ne/jenkins-GCC-9
   1761c:	7069702d 6e696c65 30322d65 30325f30     -pipeline-200_20
   1762c:	35303032 315f3132 30303935 37333335     200521_159005337
   1763c:	72732f34 656e2f63 62696c77 77656e2f     4/src/newlib/new
   1764c:	2f62696c 6362696c 6474732f 2f62696c     lib/libc/stdlib/
   1765c:	646e6172 2c00632e 6e756620 6f697463     rand.c., functio
   1766c:	00203a6e 65737361 6f697472 2522206e     n: .assertion "%
   1767c:	66202273 656c6961 66203a64 20656c69     s" failed: file 
   1768c:	22732522 696c202c 2520656e 25732564     "%s", line %d%s%
   1769c:	00000a73                                s...

000176a0 <__sf_fake_stderr>:
	...

000176c0 <__sf_fake_stdin>:
	...

000176e0 <__sf_fake_stdout>:
	...
   17700:	2b302d23 6c680020 6665004c 47464567     #-0+ .hlL.efgEFG
   17710:	32313000 36353433 41393837 45444342     .0123456789ABCDE
   17720:	31300046 35343332 39383736 64636261     F.0123456789abcd
   17730:	00006665                                ef..

00017734 <_init>:
   17734:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17736:	bf00      	nop
   17738:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1773a:	bc08      	pop	{r3}
   1773c:	469e      	mov	lr, r3
   1773e:	4770      	bx	lr

00017740 <__frame_dummy_init_array_entry>:
   17740:	4289 0000                                   .B..

00017744 <_fini>:
   17744:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   17746:	bf00      	nop
   17748:	bcf8      	pop	{r3, r4, r5, r6, r7}
   1774a:	bc08      	pop	{r3}
   1774c:	469e      	mov	lr, r3
   1774e:	4770      	bx	lr

00017750 <__do_global_dtors_aux_fini_array_entry>:
   17750:	4265 0000                                   eB..
